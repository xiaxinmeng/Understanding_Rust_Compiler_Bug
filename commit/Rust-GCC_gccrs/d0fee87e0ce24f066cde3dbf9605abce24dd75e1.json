{"sha": "d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBmZWU4N2UwY2UyNGYwNjZjZGUzZGJmOTYwNWFiY2UyNGRkNzVlMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-12T12:37:22Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-13T07:29:17Z"}, "message": "libsanitizer: merge from master\n\nMerged revision: f58e0513dd95944b81ce7a6e7b49ba656de7d75f", "tree": {"sha": "9172c165d55d36021fa70059ed0e9fef5324119e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9172c165d55d36021fa70059ed0e9fef5324119e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "810afb0b5fbb9da1e0e51ee9607f275f14c17459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/810afb0b5fbb9da1e0e51ee9607f275f14c17459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/810afb0b5fbb9da1e0e51ee9607f275f14c17459"}], "stats": {"total": 3777, "additions": 2538, "deletions": 1239}, "files": [{"sha": "c4731d0866ca4ea736cdce0de7cf6d1294cf2284", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -1,4 +1,4 @@\n-6e7dd1e3e1170080b76b5dcc5716bdd974343233\n+f58e0513dd95944b81ce7a6e7b49ba656de7d75f\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "7c8bb504332d6e1960f947f69873801e16c26cf1", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -476,7 +476,7 @@ struct Allocator {\n       return false;\n     if (m->Beg() != addr) return false;\n     AsanThread *t = GetCurrentThread();\n-    m->SetAllocContext(t ? t->tid() : 0, StackDepotPut(*stack));\n+    m->SetAllocContext(t ? t->tid() : kMainTid, StackDepotPut(*stack));\n     return true;\n   }\n \n@@ -570,7 +570,7 @@ struct Allocator {\n     m->SetUsedSize(size);\n     m->user_requested_alignment_log = user_requested_alignment_log;\n \n-    m->SetAllocContext(t ? t->tid() : 0, StackDepotPut(*stack));\n+    m->SetAllocContext(t ? t->tid() : kMainTid, StackDepotPut(*stack));\n \n     uptr size_rounded_down_to_granularity =\n         RoundDownTo(size, SHADOW_GRANULARITY);\n@@ -1183,6 +1183,34 @@ IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n   m->lsan_tag = __lsan::kIgnored;\n   return kIgnoreObjectSuccess;\n }\n+\n+void GetAdditionalThreadContextPtrs(ThreadContextBase *tctx, void *ptrs) {\n+  // Look for the arg pointer of threads that have been created or are running.\n+  // This is necessary to prevent false positive leaks due to the AsanThread\n+  // holding the only live reference to a heap object.  This can happen because\n+  // the `pthread_create()` interceptor doesn't wait for the child thread to\n+  // start before returning and thus loosing the the only live reference to the\n+  // heap object on the stack.\n+\n+  __asan::AsanThreadContext *atctx =\n+      reinterpret_cast<__asan::AsanThreadContext *>(tctx);\n+  __asan::AsanThread *asan_thread = atctx->thread;\n+\n+  // Note ThreadStatusRunning is required because there is a small window where\n+  // the thread status switches to `ThreadStatusRunning` but the `arg` pointer\n+  // still isn't on the stack yet.\n+  if (atctx->status != ThreadStatusCreated &&\n+      atctx->status != ThreadStatusRunning)\n+    return;\n+\n+  uptr thread_arg = reinterpret_cast<uptr>(asan_thread->get_arg());\n+  if (!thread_arg)\n+    return;\n+\n+  auto ptrsVec = reinterpret_cast<InternalMmapVector<uptr> *>(ptrs);\n+  ptrsVec->push_back(thread_arg);\n+}\n+\n }  // namespace __lsan\n \n // ---------------------- Interface ---------------- {{{1"}, {"sha": "2ba8a02f8410624042d6e13856ea9d847d111090", "filename": "libsanitizer/asan/asan_descriptions.cpp", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_descriptions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_descriptions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -44,11 +44,11 @@ void DescribeThread(AsanThreadContext *context) {\n   CHECK(context);\n   asanThreadRegistry().CheckLocked();\n   // No need to announce the main thread.\n-  if (context->tid == 0 || context->announced) {\n+  if (context->tid == kMainTid || context->announced) {\n     return;\n   }\n   context->announced = true;\n-  InternalScopedString str(1024);\n+  InternalScopedString str;\n   str.append(\"Thread %s\", AsanThreadIdAndName(context).c_str());\n   if (context->parent_tid == kInvalidTid) {\n     str.append(\" created by unknown thread\\n\");\n@@ -77,7 +77,6 @@ static bool GetShadowKind(uptr addr, ShadowKind *shadow_kind) {\n   } else if (AddrIsInLowShadow(addr)) {\n     *shadow_kind = kShadowKindLow;\n   } else {\n-    CHECK(0 && \"Address is not in memory and not in shadow?\");\n     return false;\n   }\n   return true;\n@@ -126,7 +125,7 @@ static void GetAccessToHeapChunkInformation(ChunkAccess *descr,\n \n static void PrintHeapChunkAccess(uptr addr, const ChunkAccess &descr) {\n   Decorator d;\n-  InternalScopedString str(4096);\n+  InternalScopedString str;\n   str.append(\"%s\", d.Location());\n   switch (descr.access_type) {\n     case kAccessTypeLeft:\n@@ -243,7 +242,7 @@ static void PrintAccessAndVarIntersection(const StackVarDescr &var, uptr addr,\n     else if (addr >= prev_var_end && addr - prev_var_end >= var.beg - addr_end)\n       pos_descr = \"underflows\";\n   }\n-  InternalScopedString str(1024);\n+  InternalScopedString str;\n   str.append(\"    [%zd, %zd)\", var.beg, var_end);\n   // Render variable name.\n   str.append(\" '\");\n@@ -276,7 +275,7 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n // Global descriptions\n static void DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n                                             const __asan_global &g) {\n-  InternalScopedString str(4096);\n+  InternalScopedString str;\n   Decorator d;\n   str.append(\"%s\", d.Location());\n   if (addr < g.beg) {\n@@ -464,7 +463,13 @@ AddressDescription::AddressDescription(uptr addr, uptr access_size,\n     return;\n   }\n   data.kind = kAddressKindWild;\n-  addr = 0;\n+  data.wild.addr = addr;\n+  data.wild.access_size = access_size;\n+}\n+\n+void WildAddressDescription::Print() const {\n+  Printf(\"Address %p is a wild pointer inside of access range of size %p.\\n\",\n+         addr, access_size);\n }\n \n void PrintAddressDescription(uptr addr, uptr access_size,"}, {"sha": "650e2eb9173ad57895dc394fa32586c609aea942", "filename": "libsanitizer/asan/asan_descriptions.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_descriptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_descriptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -146,6 +146,13 @@ struct StackAddressDescription {\n bool GetStackAddressInformation(uptr addr, uptr access_size,\n                                 StackAddressDescription *descr);\n \n+struct WildAddressDescription {\n+  uptr addr;\n+  uptr access_size;\n+\n+  void Print() const;\n+};\n+\n struct GlobalAddressDescription {\n   uptr addr;\n   // Assume address is close to at most four globals.\n@@ -193,7 +200,7 @@ class AddressDescription {\n       HeapAddressDescription heap;\n       StackAddressDescription stack;\n       GlobalAddressDescription global;\n-      uptr addr;\n+      WildAddressDescription wild;\n     };\n   };\n \n@@ -211,7 +218,7 @@ class AddressDescription {\n   uptr Address() const {\n     switch (data.kind) {\n       case kAddressKindWild:\n-        return data.addr;\n+        return data.wild.addr;\n       case kAddressKindShadow:\n         return data.shadow.addr;\n       case kAddressKindHeap:\n@@ -226,7 +233,7 @@ class AddressDescription {\n   void Print(const char *bug_descr = nullptr) const {\n     switch (data.kind) {\n       case kAddressKindWild:\n-        Printf(\"Address %p is a wild pointer.\\n\", data.addr);\n+        data.wild.Print();\n         return;\n       case kAddressKindShadow:\n         return data.shadow.Print();"}, {"sha": "e68e6971f963a3797f907ebd1763c1e8ae492477", "filename": "libsanitizer/asan/asan_errors.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_errors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_errors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -343,7 +343,8 @@ void ErrorODRViolation::Print() {\n   Report(\"ERROR: AddressSanitizer: %s (%p):\\n\", scariness.GetDescription(),\n          global1.beg);\n   Printf(\"%s\", d.Default());\n-  InternalScopedString g1_loc(256), g2_loc(256);\n+  InternalScopedString g1_loc;\n+  InternalScopedString g2_loc;\n   PrintGlobalLocation(&g1_loc, global1);\n   PrintGlobalLocation(&g2_loc, global2);\n   Printf(\"  [1] size=%zd '%s' %s\\n\", global1.size,\n@@ -360,7 +361,7 @@ void ErrorODRViolation::Print() {\n   Report(\n       \"HINT: if you don't care about these errors you may set \"\n       \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n-  InternalScopedString error_msg(256);\n+  InternalScopedString error_msg;\n   error_msg.append(\"%s: global '%s' at %s\", scariness.GetDescription(),\n                    MaybeDemangleGlobalName(global1.name), g1_loc.data());\n   ReportErrorSummary(error_msg.data());\n@@ -554,7 +555,7 @@ static void PrintShadowMemoryForAddress(uptr addr) {\n   uptr shadow_addr = MemToShadow(addr);\n   const uptr n_bytes_per_row = 16;\n   uptr aligned_shadow = shadow_addr & ~(n_bytes_per_row - 1);\n-  InternalScopedString str(4096 * 8);\n+  InternalScopedString str;\n   str.append(\"Shadow bytes around the buggy address:\\n\");\n   for (int i = -5; i <= 5; i++) {\n     uptr row_shadow_addr = aligned_shadow + i * n_bytes_per_row;"}, {"sha": "1f873fec7d7cc18f7ebbbcf5091827fb47497dbb", "filename": "libsanitizer/asan/asan_fake_stack.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_fake_stack.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_fake_stack.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -65,7 +65,7 @@ FakeStack *FakeStack::Create(uptr stack_size_log) {\n void FakeStack::Destroy(int tid) {\n   PoisonAll(0);\n   if (Verbosity() >= 2) {\n-    InternalScopedString str(kNumberOfSizeClasses * 50);\n+    InternalScopedString str;\n     for (uptr class_id = 0; class_id < kNumberOfSizeClasses; class_id++)\n       str.append(\"%zd: %zd/%zd; \", class_id, hint_position_[class_id],\n                  NumberOfFrames(stack_size_log(), class_id));"}, {"sha": "b0c7255144ac8ea32adb1a0149424398cf3d6f92", "filename": "libsanitizer/asan/asan_fuchsia.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fuchsia.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -81,7 +81,7 @@ void AsanTSDInit(void (*destructor)(void *tsd)) {\n void PlatformTSDDtor(void *tsd) { UNREACHABLE(__func__); }\n \n static inline size_t AsanThreadMmapSize() {\n-  return RoundUpTo(sizeof(AsanThread), PAGE_SIZE);\n+  return RoundUpTo(sizeof(AsanThread), _zx_system_get_page_size());\n }\n \n struct AsanThread::InitOptions {"}, {"sha": "9d7dbc6f264cea7b80a71a91da37cfa0cfbbd0db", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "9db7db89fa1a18c599fbcb0a30130db78000120c", "filename": "libsanitizer/asan/asan_interceptors.cpp", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -191,20 +191,11 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n #include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n #include \"sanitizer_common/sanitizer_syscalls_netbsd.inc\"\n \n-struct ThreadStartParam {\n-  atomic_uintptr_t t;\n-  atomic_uintptr_t is_registered;\n-};\n-\n #if ASAN_INTERCEPT_PTHREAD_CREATE\n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n-  ThreadStartParam *param = reinterpret_cast<ThreadStartParam *>(arg);\n-  AsanThread *t = nullptr;\n-  while ((t = reinterpret_cast<AsanThread *>(\n-              atomic_load(&param->t, memory_order_acquire))) == nullptr)\n-    internal_sched_yield();\n+  AsanThread *t = (AsanThread *)arg;\n   SetCurrentThread(t);\n-  return t->ThreadStart(GetTid(), &param->is_registered);\n+  return t->ThreadStart(GetTid());\n }\n \n INTERCEPTOR(int, pthread_create, void *thread,\n@@ -217,9 +208,11 @@ INTERCEPTOR(int, pthread_create, void *thread,\n   int detached = 0;\n   if (attr)\n     REAL(pthread_attr_getdetachstate)(attr, &detached);\n-  ThreadStartParam param;\n-  atomic_store(&param.t, 0, memory_order_relaxed);\n-  atomic_store(&param.is_registered, 0, memory_order_relaxed);\n+\n+  u32 current_tid = GetCurrentTidOrInvalid();\n+  AsanThread *t =\n+      AsanThread::Create(start_routine, arg, current_tid, &stack, detached);\n+\n   int result;\n   {\n     // Ignore all allocations made by pthread_create: thread stack/TLS may be\n@@ -229,21 +222,13 @@ INTERCEPTOR(int, pthread_create, void *thread,\n #if CAN_SANITIZE_LEAKS\n     __lsan::ScopedInterceptorDisabler disabler;\n #endif\n-    result = REAL(pthread_create)(thread, attr, asan_thread_start, &param);\n+    result = REAL(pthread_create)(thread, attr, asan_thread_start, t);\n   }\n-  if (result == 0) {\n-    u32 current_tid = GetCurrentTidOrInvalid();\n-    AsanThread *t =\n-        AsanThread::Create(start_routine, arg, current_tid, &stack, detached);\n-    atomic_store(&param.t, reinterpret_cast<uptr>(t), memory_order_release);\n-    // Wait until the AsanThread object is initialized and the ThreadRegistry\n-    // entry is in \"started\" state. One reason for this is that after this\n-    // interceptor exits, the child thread's stack may be the only thing holding\n-    // the |arg| pointer. This may cause LSan to report a leak if leak checking\n-    // happens at a point when the interceptor has already exited, but the stack\n-    // range for the child thread is not yet known.\n-    while (atomic_load(&param.is_registered, memory_order_acquire) == 0)\n-      internal_sched_yield();\n+  if (result != 0) {\n+    // If the thread didn't start delete the AsanThread to avoid leaking it.\n+    // Note AsanThreadContexts never get destroyed so the AsanThreadContext\n+    // that was just created for the AsanThread is wasted.\n+    t->Destroy();\n   }\n   return result;\n }"}, {"sha": "e8c58c2dc6b6ce4f7a025b71e30a8b3cfa807add", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -60,7 +60,7 @@ void InitializePlatformInterceptors();\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n #endif\n \n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_SOLARIS\n+#if SANITIZER_GLIBC || SANITIZER_SOLARIS\n # define ASAN_INTERCEPT_SWAPCONTEXT 1\n #else\n # define ASAN_INTERCEPT_SWAPCONTEXT 0\n@@ -72,7 +72,7 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT_SIGLONGJMP 0\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC\n # define ASAN_INTERCEPT___LONGJMP_CHK 1\n #else\n # define ASAN_INTERCEPT___LONGJMP_CHK 0\n@@ -81,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else\n@@ -111,7 +106,7 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT_ATEXIT 0\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC\n # define ASAN_INTERCEPT___STRDUP 1\n #else\n # define ASAN_INTERCEPT___STRDUP 0\n@@ -139,10 +134,10 @@ DECLARE_REAL(uptr, strnlen, const char *s, uptr maxlen)\n DECLARE_REAL(char*, strstr, const char *s1, const char *s2)\n \n #if !SANITIZER_MAC\n-#define ASAN_INTERCEPT_FUNC(name)                                         \\\n-  do {                                                                    \\\n-    if (!INTERCEPT_FUNCTION(name))                                        \\\n-      VReport(1, \"AddressSanitizer: failed to intercept '%s'\\n'\", #name); \\\n+#define ASAN_INTERCEPT_FUNC(name)                                        \\\n+  do {                                                                   \\\n+    if (!INTERCEPT_FUNCTION(name))                                       \\\n+      VReport(1, \"AddressSanitizer: failed to intercept '%s'\\n\", #name); \\\n   } while (0)\n #define ASAN_INTERCEPT_FUNC_VER(name, ver)                                  \\\n   do {                                                                      \\"}, {"sha": "4bcbe5d02e3344da86ba2ed8c63230691f1cd74a", "filename": "libsanitizer/asan/asan_linux.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -55,6 +55,7 @@ extern Elf_Dyn _DYNAMIC;\n #else\n #include <sys/ucontext.h>\n #include <link.h>\n+extern ElfW(Dyn) _DYNAMIC[];\n #endif\n \n // x86-64 FreeBSD 9.2 and older define 'ucontext_t' incorrectly in\n@@ -84,7 +85,7 @@ bool IsSystemHeapAddress (uptr addr) { return false; }\n \n void *AsanDoesNotSupportStaticLinkage() {\n   // This will fail to link with -static.\n-  return &_DYNAMIC;  // defined in link.h\n+  return &_DYNAMIC;\n }\n \n #if ASAN_PREMAP_SHADOW"}, {"sha": "455e2364cd0caf7ac3dde193e5b618f967c51ddb", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -72,27 +72,20 @@\n // || `[0x2000000000, 0x23ffffffff]` || LowShadow  ||\n // || `[0x0000000000, 0x1fffffffff]` || LowMem     ||\n //\n+// Default Linux/RISCV64 Sv39 mapping:\n+// || `[0x1555550000, 0x3fffffffff]` || HighMem    ||\n+// || `[0x0fffffa000, 0x1555555fff]` || HighShadow ||\n+// || `[0x0effffa000, 0x0fffff9fff]` || ShadowGap  ||\n+// || `[0x0d55550000, 0x0effff9fff]` || LowShadow  ||\n+// || `[0x0000000000, 0x0d5554ffff]` || LowMem     ||\n+//\n // Default Linux/AArch64 (39-bit VMA) mapping:\n // || `[0x2000000000, 0x7fffffffff]` || highmem    ||\n // || `[0x1400000000, 0x1fffffffff]` || highshadow ||\n // || `[0x1200000000, 0x13ffffffff]` || shadowgap  ||\n // || `[0x1000000000, 0x11ffffffff]` || lowshadow  ||\n // || `[0x0000000000, 0x0fffffffff]` || lowmem     ||\n //\n-// RISC-V has only 38 bits for task size\n-// Low mem size is set with kRiscv64_ShadowOffset64 in\n-// compiler-rt/lib/asan/asan_allocator.h and in\n-// llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp with\n-// kRiscv64_ShadowOffset64, High mem top border is set with\n-// GetMaxVirtualAddress() in\n-// compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp\n-// Default Linux/RISCV64 Sv39/Sv48 mapping:\n-// || `[0x000820000000, 0x003fffffffff]` || HighMem    ||\n-// || `[0x000124000000, 0x00081fffffff]` || HighShadow ||\n-// || `[0x000024000000, 0x000123ffffff]` || ShadowGap  ||\n-// || `[0x000020000000, 0x000023ffffff]` || LowShadow  ||\n-// || `[0x000000000000, 0x00001fffffff]` || LowMem     ||\n-//\n // Default Linux/AArch64 (42-bit VMA) mapping:\n // || `[0x10000000000, 0x3ffffffffff]` || highmem    ||\n // || `[0x0a000000000, 0x0ffffffffff]` || highshadow ||\n@@ -175,10 +168,10 @@ static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset =\n     0x7FFFFFFF & (~0xFFFULL << kDefaultShadowScale);  // < 2G.\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n-static const u64 kRiscv64_ShadowOffset64 = 0x20000000;\n+static const u64 kRiscv64_ShadowOffset64 = 0xd55550000;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000"}, {"sha": "92a8648452b07c5ad44f2012a71106d4537b66c4", "filename": "libsanitizer/asan/asan_new_delete.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -45,7 +45,7 @@ COMMENT_EXPORT(\"??_V@YAXPAX@Z\")                   // operator delete[]\n #endif\n #undef COMMENT_EXPORT\n #else\n-#define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE\n+#define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n #endif\n \n using namespace __asan;"}, {"sha": "fa149ecfde661736094fed711ca24537d8608f64", "filename": "libsanitizer/asan/asan_poisoning.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -364,7 +364,7 @@ void __sanitizer_annotate_contiguous_container(const void *beg_p,\n                                                  &stack);\n   }\n   CHECK_LE(end - beg,\n-           FIRST_32_SECOND_64(1UL << 30, 1ULL << 34)); // Sanity check.\n+           FIRST_32_SECOND_64(1UL << 30, 1ULL << 40)); // Sanity check.\n \n   uptr a = RoundDownTo(Min(old_mid, new_mid), granularity);\n   uptr c = RoundUpTo(Max(old_mid, new_mid), granularity);"}, {"sha": "63ad735f8bba661bccee7794f14706cc3b999a81", "filename": "libsanitizer/asan/asan_posix.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -56,7 +56,7 @@ bool PlatformUnpoisonStacks() {\n   if (signal_stack.ss_flags != SS_ONSTACK)\n     return false;\n \n-  // Since we're on the signal altnerate stack, we cannot find the DEFAULT\n+  // Since we're on the signal alternate stack, we cannot find the DEFAULT\n   // stack bottom using a local variable.\n   uptr default_bottom, tls_addr, tls_size, stack_size;\n   GetThreadStackAndTls(/*main=*/false, &default_bottom, &stack_size, &tls_addr,"}, {"sha": "e715d7742289c1b97dd572afa19bf180bb78405f", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -62,19 +62,9 @@ static void AsanDie() {\n   }\n }\n \n-static void AsanCheckFailed(const char *file, int line, const char *cond,\n-                            u64 v1, u64 v2) {\n-  Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\", file,\n-         line, cond, (uptr)v1, (uptr)v2);\n-\n-  // Print a stack trace the first time we come here. Otherwise, we probably\n-  // failed a CHECK during symbolization.\n-  static atomic_uint32_t num_calls;\n-  if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) == 0) {\n-    PRINT_CURRENT_STACK_CHECK();\n-  }\n-\n-  Die();\n+static void CheckUnwind() {\n+  GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_check);\n+  stack.Print();\n }\n \n // -------------------------- Globals --------------------- {{{1\n@@ -432,7 +422,7 @@ static void AsanInitInternal() {\n \n   // Install tool-specific callbacks in sanitizer_common.\n   AddDieCallback(AsanDie);\n-  SetCheckFailedCallback(AsanCheckFailed);\n+  SetCheckUnwindCallback(CheckUnwind);\n   SetPrintfAndReportCallback(AppendToErrorMessageBuffer);\n \n   __sanitizer_set_report_path(common_flags()->log_path);\n@@ -568,7 +558,7 @@ void UnpoisonStack(uptr bottom, uptr top, const char *type) {\n         type, top, bottom, top - bottom, top - bottom);\n     return;\n   }\n-  PoisonShadow(bottom, top - bottom, 0);\n+  PoisonShadow(bottom, RoundUpTo(top - bottom, SHADOW_GRANULARITY), 0);\n }\n \n static void UnpoisonDefaultStack() {"}, {"sha": "b9575d2f427eea1f0cab39fde354955cb9f17870", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -54,9 +54,6 @@ u32 GetMallocContextSize();\n #define GET_STACK_TRACE_FATAL_HERE                                \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n \n-#define GET_STACK_TRACE_CHECK_HERE                                \\\n-  GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_check)\n-\n #define GET_STACK_TRACE_THREAD                                    \\\n   GET_STACK_TRACE(kStackTraceMax, true)\n \n@@ -71,10 +68,4 @@ u32 GetMallocContextSize();\n     stack.Print();              \\\n   }\n \n-#define PRINT_CURRENT_STACK_CHECK() \\\n-  {                                 \\\n-    GET_STACK_TRACE_CHECK_HERE;     \\\n-    stack.Print();                  \\\n-  }\n-\n #endif // ASAN_STACK_H"}, {"sha": "9c3c86f5735e10fa763cb5d62cc98fe91db9af00", "filename": "libsanitizer/asan/asan_thread.cpp", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -100,18 +100,27 @@ void AsanThread::Destroy() {\n   int tid = this->tid();\n   VReport(1, \"T%d exited\\n\", tid);\n \n-  malloc_storage().CommitBack();\n-  if (common_flags()->use_sigaltstack) UnsetAlternateSignalStack();\n-  asanThreadRegistry().FinishThread(tid);\n-  FlushToDeadThreadStats(&stats_);\n-  // We also clear the shadow on thread destruction because\n-  // some code may still be executing in later TSD destructors\n-  // and we don't want it to have any poisoned stack.\n-  ClearShadowForThreadStackAndTLS();\n-  DeleteFakeStack(tid);\n+  bool was_running =\n+      (asanThreadRegistry().FinishThread(tid) == ThreadStatusRunning);\n+  if (was_running) {\n+    if (AsanThread *thread = GetCurrentThread())\n+      CHECK_EQ(this, thread);\n+    malloc_storage().CommitBack();\n+    if (common_flags()->use_sigaltstack)\n+      UnsetAlternateSignalStack();\n+    FlushToDeadThreadStats(&stats_);\n+    // We also clear the shadow on thread destruction because\n+    // some code may still be executing in later TSD destructors\n+    // and we don't want it to have any poisoned stack.\n+    ClearShadowForThreadStackAndTLS();\n+    DeleteFakeStack(tid);\n+  } else {\n+    CHECK_NE(this, GetCurrentThread());\n+  }\n   uptr size = RoundUpTo(sizeof(AsanThread), GetPageSizeCached());\n   UnmapOrDie(this, size);\n-  DTLS_Destroy();\n+  if (was_running)\n+    DTLS_Destroy();\n }\n \n void AsanThread::StartSwitchFiber(FakeStack **fake_stack_save, uptr bottom,\n@@ -219,7 +228,7 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n }\n \n void AsanThread::Init(const InitOptions *options) {\n-  DCHECK_NE(tid(), ThreadRegistry::kUnknownTid);\n+  DCHECK_NE(tid(), kInvalidTid);\n   next_stack_top_ = next_stack_bottom_ = 0;\n   atomic_store(&stack_switching_, false, memory_order_release);\n   CHECK_EQ(this->stack_size(), 0U);\n@@ -253,12 +262,9 @@ void AsanThread::Init(const InitOptions *options) {\n // SetThreadStackAndTls.\n #if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n-thread_return_t AsanThread::ThreadStart(\n-    tid_t os_id, atomic_uintptr_t *signal_thread_is_registered) {\n+thread_return_t AsanThread::ThreadStart(tid_t os_id) {\n   Init();\n   asanThreadRegistry().StartThread(tid(), os_id, ThreadType::Regular, nullptr);\n-  if (signal_thread_is_registered)\n-    atomic_store(signal_thread_is_registered, 1, memory_order_release);\n \n   if (common_flags()->use_sigaltstack) SetAlternateSignalStack();\n \n@@ -285,11 +291,10 @@ thread_return_t AsanThread::ThreadStart(\n \n AsanThread *CreateMainThread() {\n   AsanThread *main_thread = AsanThread::Create(\n-      /* start_routine */ nullptr, /* arg */ nullptr, /* parent_tid */ 0,\n+      /* start_routine */ nullptr, /* arg */ nullptr, /* parent_tid */ kMainTid,\n       /* stack */ nullptr, /* detached */ true);\n   SetCurrentThread(main_thread);\n-  main_thread->ThreadStart(internal_getpid(),\n-                           /* signal_thread_is_registered */ nullptr);\n+  main_thread->ThreadStart(internal_getpid());\n   return main_thread;\n }\n \n@@ -300,9 +305,9 @@ void AsanThread::SetThreadStackAndTls(const InitOptions *options) {\n   DCHECK_EQ(options, nullptr);\n   uptr tls_size = 0;\n   uptr stack_size = 0;\n-  GetThreadStackAndTls(tid() == 0, &stack_bottom_, &stack_size, &tls_begin_,\n-                       &tls_size);\n-  stack_top_ = stack_bottom_ + stack_size;\n+  GetThreadStackAndTls(tid() == kMainTid, &stack_bottom_, &stack_size,\n+                       &tls_begin_, &tls_size);\n+  stack_top_ = RoundDownTo(stack_bottom_ + stack_size, SHADOW_GRANULARITY);\n   tls_end_ = tls_begin_ + tls_size;\n   dtls_ = DTLS_Get();\n \n@@ -426,7 +431,7 @@ AsanThread *GetCurrentThread() {\n       // address. We are not entirely sure that we have correct main thread\n       // limits, so only do this magic on Android, and only if the found thread\n       // is the main thread.\n-      AsanThreadContext *tctx = GetThreadContextByTidLocked(0);\n+      AsanThreadContext *tctx = GetThreadContextByTidLocked(kMainTid);\n       if (tctx && ThreadStackContainsAddress(tctx, &context)) {\n         SetCurrentThread(tctx->thread);\n         return tctx->thread;\n@@ -463,7 +468,7 @@ AsanThread *FindThreadByStackAddress(uptr addr) {\n void EnsureMainThreadIDIsCorrect() {\n   AsanThreadContext *context =\n       reinterpret_cast<AsanThreadContext *>(AsanTSDGet());\n-  if (context && (context->tid == 0))\n+  if (context && (context->tid == kMainTid))\n     context->os_id = GetTid();\n }\n "}, {"sha": "200069ce0dd37c51666b02a491cfc2926f045375", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -28,7 +28,6 @@ struct DTLS;\n \n namespace __asan {\n \n-const u32 kInvalidTid = 0xffffff;  // Must fit into 24 bits.\n const u32 kMaxNumberOfThreads = (1 << 22);  // 4M\n \n class AsanThread;\n@@ -69,8 +68,7 @@ class AsanThread {\n   struct InitOptions;\n   void Init(const InitOptions *options = nullptr);\n \n-  thread_return_t ThreadStart(tid_t os_id,\n-                              atomic_uintptr_t *signal_thread_is_registered);\n+  thread_return_t ThreadStart(tid_t os_id);\n \n   uptr stack_top();\n   uptr stack_bottom();\n@@ -132,6 +130,8 @@ class AsanThread {\n \n   void *extra_spill_area() { return &extra_spill_area_; }\n \n+  void *get_arg() { return arg_; }\n+\n  private:\n   // NOTE: There is no AsanThread constructor. It is allocated\n   // via mmap() and *must* be valid in zero-initialized state."}, {"sha": "1577c83cf9941663b763c42ab51f2d96066c7d96", "filename": "libsanitizer/asan/asan_win.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fasan%2Fasan_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -134,7 +134,7 @@ INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n   AsanThread *t = (AsanThread *)arg;\n   SetCurrentThread(t);\n-  return t->ThreadStart(GetTid(), /* signal_thread_is_registered */ nullptr);\n+  return t->ThreadStart(GetTid());\n }\n \n INTERCEPTOR_WINAPI(HANDLE, CreateThread, LPSECURITY_ATTRIBUTES security,"}, {"sha": "9c015059af5a68e94dfe343f5c290fa018084836", "filename": "libsanitizer/builtins/assembly.h", "status": "modified", "additions": 92, "deletions": 6, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fbuiltins%2Fassembly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fbuiltins%2Fassembly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fbuiltins%2Fassembly.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -14,8 +14,8 @@\n #ifndef COMPILERRT_ASSEMBLY_H\n #define COMPILERRT_ASSEMBLY_H\n \n-#if defined(__POWERPC__) || defined(__powerpc__) || defined(__ppc__)\n-#define SEPARATOR @\n+#if defined(__APPLE__) && defined(__aarch64__)\n+#define SEPARATOR %%\n #else\n #define SEPARATOR ;\n #endif\n@@ -35,14 +35,14 @@\n #define HIDDEN(name) .hidden name\n #define LOCAL_LABEL(name) .L_##name\n #define FILE_LEVEL_DIRECTIVE\n-#if defined(__arm__)\n+#if defined(__arm__) || defined(__aarch64__)\n #define SYMBOL_IS_FUNC(name) .type name,%function\n #else\n #define SYMBOL_IS_FUNC(name) .type name,@function\n #endif\n #define CONST_SECTION .section .rodata\n \n-#if defined(__GNU__) || defined(__FreeBSD__) || defined(__Fuchsia__) || \\\n+#if defined(__GNU__) || defined(__FreeBSD__) || defined(__Fuchsia__) ||        \\\n     defined(__linux__)\n #define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,\"\",%progbits\n #else\n@@ -65,6 +65,68 @@\n \n #endif\n \n+#if defined(__arm__) || defined(__aarch64__)\n+#define FUNC_ALIGN                                                             \\\n+  .text SEPARATOR                                                              \\\n+  .balign 16 SEPARATOR\n+#else\n+#define FUNC_ALIGN\n+#endif\n+\n+// BTI and PAC gnu property note\n+#define NT_GNU_PROPERTY_TYPE_0 5\n+#define GNU_PROPERTY_AARCH64_FEATURE_1_AND 0xc0000000\n+#define GNU_PROPERTY_AARCH64_FEATURE_1_BTI 1\n+#define GNU_PROPERTY_AARCH64_FEATURE_1_PAC 2\n+\n+#if defined(__ARM_FEATURE_BTI_DEFAULT)\n+#define BTI_FLAG GNU_PROPERTY_AARCH64_FEATURE_1_BTI\n+#else\n+#define BTI_FLAG 0\n+#endif\n+\n+#if __ARM_FEATURE_PAC_DEFAULT & 3\n+#define PAC_FLAG GNU_PROPERTY_AARCH64_FEATURE_1_PAC\n+#else\n+#define PAC_FLAG 0\n+#endif\n+\n+#define GNU_PROPERTY(type, value)                                              \\\n+  .pushsection .note.gnu.property, \"a\" SEPARATOR                               \\\n+  .p2align 3 SEPARATOR                                                         \\\n+  .word 4 SEPARATOR                                                            \\\n+  .word 16 SEPARATOR                                                           \\\n+  .word NT_GNU_PROPERTY_TYPE_0 SEPARATOR                                       \\\n+  .asciz \"GNU\" SEPARATOR                                                       \\\n+  .word type SEPARATOR                                                         \\\n+  .word 4 SEPARATOR                                                            \\\n+  .word value SEPARATOR                                                        \\\n+  .word 0 SEPARATOR                                                            \\\n+  .popsection\n+\n+#if BTI_FLAG != 0\n+#define BTI_C hint #34\n+#define BTI_J hint #36\n+#else\n+#define BTI_C\n+#define BTI_J\n+#endif\n+\n+#if (BTI_FLAG | PAC_FLAG) != 0\n+#define GNU_PROPERTY_BTI_PAC                                                   \\\n+  GNU_PROPERTY(GNU_PROPERTY_AARCH64_FEATURE_1_AND, BTI_FLAG | PAC_FLAG)\n+#else\n+#define GNU_PROPERTY_BTI_PAC\n+#endif\n+\n+#if defined(__clang__) || defined(__GCC_HAVE_DWARF2_CFI_ASM)\n+#define CFI_START .cfi_startproc\n+#define CFI_END .cfi_endproc\n+#else\n+#define CFI_START\n+#define CFI_END\n+#endif\n+\n #if defined(__arm__)\n \n // Determine actual [ARM][THUMB[1][2]] ISA using compiler predefined macros:\n@@ -131,15 +193,24 @@\n #define DEFINE_CODE_STATE\n #endif\n \n-#define GLUE2(a, b) a##b\n-#define GLUE(a, b) GLUE2(a, b)\n+#define GLUE2_(a, b) a##b\n+#define GLUE(a, b) GLUE2_(a, b)\n+#define GLUE2(a, b) GLUE2_(a, b)\n+#define GLUE3_(a, b, c) a##b##c\n+#define GLUE3(a, b, c) GLUE3_(a, b, c)\n+#define GLUE4_(a, b, c, d) a##b##c##d\n+#define GLUE4(a, b, c, d) GLUE4_(a, b, c, d)\n+\n #define SYMBOL_NAME(name) GLUE(__USER_LABEL_PREFIX__, name)\n \n #ifdef VISIBILITY_HIDDEN\n #define DECLARE_SYMBOL_VISIBILITY(name)                                        \\\n   HIDDEN(SYMBOL_NAME(name)) SEPARATOR\n+#define DECLARE_SYMBOL_VISIBILITY_UNMANGLED(name) \\\n+  HIDDEN(name) SEPARATOR\n #else\n #define DECLARE_SYMBOL_VISIBILITY(name)\n+#define DECLARE_SYMBOL_VISIBILITY_UNMANGLED(name)\n #endif\n \n #define DEFINE_COMPILERRT_FUNCTION(name)                                       \\\n@@ -177,6 +248,16 @@\n   DECLARE_FUNC_ENCODING                                                        \\\n   name:\n \n+#define DEFINE_COMPILERRT_OUTLINE_FUNCTION_UNMANGLED(name)                     \\\n+  DEFINE_CODE_STATE                                                            \\\n+  FUNC_ALIGN                                                                   \\\n+  .globl name SEPARATOR                                                        \\\n+  SYMBOL_IS_FUNC(name) SEPARATOR                                               \\\n+  DECLARE_SYMBOL_VISIBILITY_UNMANGLED(name) SEPARATOR                          \\\n+  CFI_START SEPARATOR                                                          \\\n+  DECLARE_FUNC_ENCODING                                                        \\\n+  name: SEPARATOR BTI_C\n+\n #define DEFINE_COMPILERRT_FUNCTION_ALIAS(name, target)                         \\\n   .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n   SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n@@ -193,8 +274,13 @@\n #ifdef __ELF__\n #define END_COMPILERRT_FUNCTION(name)                                          \\\n   .size SYMBOL_NAME(name), . - SYMBOL_NAME(name)\n+#define END_COMPILERRT_OUTLINE_FUNCTION(name)                                  \\\n+  CFI_END SEPARATOR                                                            \\\n+  .size SYMBOL_NAME(name), . - SYMBOL_NAME(name)\n #else\n #define END_COMPILERRT_FUNCTION(name)\n+#define END_COMPILERRT_OUTLINE_FUNCTION(name)                                  \\\n+  CFI_END\n #endif\n \n #endif // COMPILERRT_ASSEMBLY_H"}, {"sha": "8d6c25261b80488d450264d29141f7d7e36906d6", "filename": "libsanitizer/hwasan/hwasan.cpp", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -128,16 +128,11 @@ static void InitializeFlags() {\n   if (common_flags()->help) parser.PrintFlagDescriptions();\n }\n \n-static void HWAsanCheckFailed(const char *file, int line, const char *cond,\n-                              u64 v1, u64 v2) {\n-  Report(\"HWAddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\", file,\n-         line, cond, (uptr)v1, (uptr)v2);\n-  PRINT_CURRENT_STACK_CHECK();\n-  Die();\n+static void CheckUnwind() {\n+  GET_FATAL_STACK_TRACE_PC_BP(StackTrace::GetCurrentPc(), GET_CURRENT_FRAME());\n+  stack.Print();\n }\n \n-static constexpr uptr kMemoryUsageBufferSize = 4096;\n-\n static void HwasanFormatMemoryUsage(InternalScopedString &s) {\n   HwasanThreadList &thread_list = hwasanThreadList();\n   auto thread_stats = thread_list.GetThreadStats();\n@@ -155,6 +150,8 @@ static void HwasanFormatMemoryUsage(InternalScopedString &s) {\n }\n \n #if SANITIZER_ANDROID\n+static constexpr uptr kMemoryUsageBufferSize = 4096;\n+\n static char *memory_usage_buffer = nullptr;\n \n static void InitMemoryUsage() {\n@@ -171,7 +168,7 @@ void UpdateMemoryUsage() {\n     return;\n   if (!memory_usage_buffer)\n     InitMemoryUsage();\n-  InternalScopedString s(kMemoryUsageBufferSize);\n+  InternalScopedString s;\n   HwasanFormatMemoryUsage(s);\n   internal_strncpy(memory_usage_buffer, s.data(), kMemoryUsageBufferSize - 1);\n   memory_usage_buffer[kMemoryUsageBufferSize - 1] = '\\0';\n@@ -271,7 +268,7 @@ void __hwasan_init() {\n   InitializeFlags();\n \n   // Install tool-specific callbacks in sanitizer_common.\n-  SetCheckFailedCallback(HWAsanCheckFailed);\n+  SetCheckUnwindCallback(CheckUnwind);\n \n   __sanitizer_set_report_path(common_flags()->log_path);\n \n@@ -493,7 +490,7 @@ extern \"C\" void *__hwasan_extra_spill_area() {\n }\n \n void __hwasan_print_memory_usage() {\n-  InternalScopedString s(kMemoryUsageBufferSize);\n+  InternalScopedString s;\n   HwasanFormatMemoryUsage(s);\n   Printf(\"%s\\n\", s.data());\n }"}, {"sha": "8515df559f30acb1c16933aae126b950021f45ab", "filename": "libsanitizer/hwasan/hwasan.h", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -14,11 +14,12 @@\n #ifndef HWASAN_H\n #define HWASAN_H\n \n+#include \"hwasan_flags.h\"\n+#include \"hwasan_interface_internal.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n-#include \"hwasan_interface_internal.h\"\n-#include \"hwasan_flags.h\"\n #include \"ubsan/ubsan_platform.h\"\n \n #ifndef HWASAN_CONTAINS_UBSAN\n@@ -35,10 +36,31 @@\n \n typedef u8 tag_t;\n \n+#if defined(__x86_64__)\n+// Tags are done in middle bits using userspace aliasing.\n+constexpr unsigned kAddressTagShift = 39;\n+constexpr unsigned kTagBits = 3;\n+\n+// The alias region is placed next to the shadow so the upper bits of all\n+// taggable addresses matches the upper bits of the shadow base.  This shift\n+// value determines which upper bits must match.  It has a floor of 44 since the\n+// shadow is always 8TB.\n+// TODO(morehouse): In alias mode we can shrink the shadow and use a\n+// simpler/faster shadow calculation.\n+constexpr unsigned kTaggableRegionCheckShift =\n+    __sanitizer::Max(kAddressTagShift + kTagBits + 1U, 44U);\n+#else\n // TBI (Top Byte Ignore) feature of AArch64: bits [63:56] are ignored in address\n // translation and can be used to store a tag.\n-const unsigned kAddressTagShift = 56;\n-const uptr kAddressTagMask = 0xFFUL << kAddressTagShift;\n+constexpr unsigned kAddressTagShift = 56;\n+constexpr unsigned kTagBits = 8;\n+#endif  // defined(__x86_64__)\n+\n+// Mask for extracting tag bits from the lower 8 bits.\n+constexpr uptr kTagMask = (1UL << kTagBits) - 1;\n+\n+// Mask for extracting tag bits from full pointers.\n+constexpr uptr kAddressTagMask = kTagMask << kAddressTagShift;\n \n // Minimal alignment of the shadow base address. Determines the space available\n // for threads and stack histories. This is an ABI constant.\n@@ -50,7 +72,7 @@ const unsigned kRecordFPLShift = 4;\n const unsigned kRecordFPModulus = 1 << (64 - kRecordFPShift + kRecordFPLShift);\n \n static inline tag_t GetTagFromPointer(uptr p) {\n-  return p >> kAddressTagShift;\n+  return (p >> kAddressTagShift) & kTagMask;\n }\n \n static inline uptr UntagAddr(uptr tagged_addr) {\n@@ -105,15 +127,6 @@ void InstallAtExitHandler();\n   if (hwasan_inited)                                     \\\n     stack.Unwind(pc, bp, nullptr, common_flags()->fast_unwind_on_fatal)\n \n-#define GET_FATAL_STACK_TRACE_HERE \\\n-  GET_FATAL_STACK_TRACE_PC_BP(StackTrace::GetCurrentPc(), GET_CURRENT_FRAME())\n-\n-#define PRINT_CURRENT_STACK_CHECK() \\\n-  {                                 \\\n-    GET_FATAL_STACK_TRACE_HERE;     \\\n-    stack.Print();                  \\\n-  }\n-\n void HwasanTSDInit();\n void HwasanTSDThreadInit();\n "}, {"sha": "a6fc794082a58c963e22935ad37032042a08fbd8", "filename": "libsanitizer/hwasan/hwasan_allocator.cpp", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocator.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -29,8 +29,8 @@ static AllocatorCache fallback_allocator_cache;\n static SpinMutex fallback_mutex;\n static atomic_uint8_t hwasan_allocator_tagging_enabled;\n \n-static const tag_t kFallbackAllocTag = 0xBB;\n-static const tag_t kFallbackFreeTag = 0xBC;\n+static constexpr tag_t kFallbackAllocTag = 0xBB & kTagMask;\n+static constexpr tag_t kFallbackFreeTag = 0xBC;\n \n enum RightAlignMode {\n   kRightAlignNever,\n@@ -84,7 +84,8 @@ void HwasanAllocatorInit() {\n   atomic_store_relaxed(&hwasan_allocator_tagging_enabled,\n                        !flags()->disable_allocator_tagging);\n   SetAllocatorMayReturnNull(common_flags()->allocator_may_return_null);\n-  allocator.Init(common_flags()->allocator_release_to_os_interval_ms);\n+  allocator.Init(common_flags()->allocator_release_to_os_interval_ms,\n+                 kAliasRegionStart);\n   for (uptr i = 0; i < sizeof(tail_magic); i++)\n     tail_magic[i] = GetCurrentThread()->GenerateRandomTag();\n }\n@@ -148,7 +149,8 @@ static void *HwasanAllocate(StackTrace *stack, uptr orig_size, uptr alignment,\n   // Tagging can only be skipped when both tag_in_malloc and tag_in_free are\n   // false. When tag_in_malloc = false and tag_in_free = true malloc needs to\n   // retag to 0.\n-  if ((flags()->tag_in_malloc || flags()->tag_in_free) &&\n+  if (InTaggableRegion(reinterpret_cast<uptr>(user_ptr)) &&\n+      (flags()->tag_in_malloc || flags()->tag_in_free) &&\n       atomic_load_relaxed(&hwasan_allocator_tagging_enabled)) {\n     if (flags()->tag_in_malloc && malloc_bisect(stack, orig_size)) {\n       tag_t tag = t ? t->GenerateRandomTag() : kFallbackAllocTag;\n@@ -175,6 +177,8 @@ static void *HwasanAllocate(StackTrace *stack, uptr orig_size, uptr alignment,\n static bool PointerAndMemoryTagsMatch(void *tagged_ptr) {\n   CHECK(tagged_ptr);\n   uptr tagged_uptr = reinterpret_cast<uptr>(tagged_ptr);\n+  if (!InTaggableRegion(tagged_uptr))\n+    return true;\n   tag_t mem_tag = *reinterpret_cast<tag_t *>(\n       MemToShadow(reinterpret_cast<uptr>(UntagPtr(tagged_ptr))));\n   return PossiblyShortTagMatches(mem_tag, tagged_uptr, 1);\n@@ -187,7 +191,9 @@ static void HwasanDeallocate(StackTrace *stack, void *tagged_ptr) {\n   if (!PointerAndMemoryTagsMatch(tagged_ptr))\n     ReportInvalidFree(stack, reinterpret_cast<uptr>(tagged_ptr));\n \n-  void *untagged_ptr = UntagPtr(tagged_ptr);\n+  void *untagged_ptr = InTaggableRegion(reinterpret_cast<uptr>(tagged_ptr))\n+                           ? UntagPtr(tagged_ptr)\n+                           : tagged_ptr;\n   void *aligned_ptr = reinterpret_cast<void *>(\n       RoundDownTo(reinterpret_cast<uptr>(untagged_ptr), kShadowAlignment));\n   Metadata *meta =\n@@ -219,10 +225,14 @@ static void HwasanDeallocate(StackTrace *stack, void *tagged_ptr) {\n         Min(TaggedSize(orig_size), (uptr)flags()->max_free_fill_size);\n     internal_memset(aligned_ptr, flags()->free_fill_byte, fill_size);\n   }\n-  if (flags()->tag_in_free && malloc_bisect(stack, 0) &&\n-      atomic_load_relaxed(&hwasan_allocator_tagging_enabled))\n+  if (InTaggableRegion(reinterpret_cast<uptr>(tagged_ptr)) &&\n+      flags()->tag_in_free && malloc_bisect(stack, 0) &&\n+      atomic_load_relaxed(&hwasan_allocator_tagging_enabled)) {\n+    // Always store full 8-bit tags on free to maximize UAF detection.\n+    tag_t tag = t ? t->GenerateRandomTag(/*num_bits=*/8) : kFallbackFreeTag;\n     TagMemoryAligned(reinterpret_cast<uptr>(aligned_ptr), TaggedSize(orig_size),\n-                     t ? t->GenerateRandomTag() : kFallbackFreeTag);\n+                     tag);\n+  }\n   if (t) {\n     allocator.Deallocate(t->allocator_cache(), aligned_ptr);\n     if (auto *ha = t->heap_allocations())\n@@ -365,7 +375,7 @@ int hwasan_posix_memalign(void **memptr, uptr alignment, uptr size,\n     // OOM error is already taken care of by HwasanAllocate.\n     return errno_ENOMEM;\n   CHECK(IsAligned((uptr)ptr, alignment));\n-  *(void **)UntagPtr(memptr) = ptr;\n+  *memptr = ptr;\n   return 0;\n }\n "}, {"sha": "03bbcff3f0f2ee2e4b20dc7b80c6352e34c20fb6", "filename": "libsanitizer/hwasan/hwasan_allocator.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocator.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -13,13 +13,15 @@\n #ifndef HWASAN_ALLOCATOR_H\n #define HWASAN_ALLOCATOR_H\n \n+#include \"hwasan.h\"\n+#include \"hwasan_interface_internal.h\"\n+#include \"hwasan_poisoning.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_allocator_checks.h\"\n #include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_allocator_report.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_ring_buffer.h\"\n-#include \"hwasan_poisoning.h\"\n \n #if !defined(__aarch64__) && !defined(__x86_64__)\n #error Unsupported platform\n@@ -55,7 +57,12 @@ static const uptr kMaxAllowedMallocSize = 1UL << 40;  // 1T\n \n struct AP64 {\n   static const uptr kSpaceBeg = ~0ULL;\n+\n+#if defined(__x86_64__)\n+  static const uptr kSpaceSize = 1ULL << kAddressTagShift;\n+#else\n   static const uptr kSpaceSize = 0x2000000000ULL;\n+#endif\n   static const uptr kMetadataSize = sizeof(Metadata);\n   typedef __sanitizer::VeryDenseSizeClassMap SizeClassMap;\n   using AddressSpaceView = LocalAddressSpaceView;\n@@ -102,6 +109,16 @@ typedef RingBuffer<HeapAllocationRecord> HeapAllocationsRingBuffer;\n \n void GetAllocatorStats(AllocatorStatCounters s);\n \n+inline bool InTaggableRegion(uptr addr) {\n+#if defined(__x86_64__)\n+  // Aliases are mapped next to shadow so that the upper bits match the shadow\n+  // base.\n+  return (addr >> kTaggableRegionCheckShift) ==\n+         (__hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n+#endif\n+  return true;\n+}\n+\n } // namespace __hwasan\n \n #endif // HWASAN_ALLOCATOR_H"}, {"sha": "ab543ea88bebf24a6c7065e90d1a808e713fa25f", "filename": "libsanitizer/hwasan/hwasan_checks.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_checks.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -13,6 +13,7 @@\n #ifndef HWASAN_CHECKS_H\n #define HWASAN_CHECKS_H\n \n+#include \"hwasan_allocator.h\"\n #include \"hwasan_mapping.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n \n@@ -81,6 +82,8 @@ enum class AccessType { Load, Store };\n \n template <ErrorAction EA, AccessType AT, unsigned LogSize>\n __attribute__((always_inline, nodebug)) static void CheckAddress(uptr p) {\n+  if (!InTaggableRegion(p))\n+    return;\n   uptr ptr_raw = p & ~kAddressTagMask;\n   tag_t mem_tag = *(tag_t *)MemToShadow(ptr_raw);\n   if (UNLIKELY(!PossiblyShortTagMatches(mem_tag, p, 1 << LogSize))) {\n@@ -94,7 +97,7 @@ __attribute__((always_inline, nodebug)) static void CheckAddress(uptr p) {\n template <ErrorAction EA, AccessType AT>\n __attribute__((always_inline, nodebug)) static void CheckAddressSized(uptr p,\n                                                                       uptr sz) {\n-  if (sz == 0)\n+  if (sz == 0 || !InTaggableRegion(p))\n     return;\n   tag_t ptr_tag = GetTagFromPointer(p);\n   uptr ptr_raw = p & ~kAddressTagMask;"}, {"sha": "f53276e330d39ac0664cea346f60e518928541de", "filename": "libsanitizer/hwasan/hwasan_dynamic_shadow.cpp", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_dynamic_shadow.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_dynamic_shadow.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_dynamic_shadow.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -12,15 +12,17 @@\n ///\n //===----------------------------------------------------------------------===//\n \n-#include \"hwasan.h\"\n #include \"hwasan_dynamic_shadow.h\"\n-#include \"hwasan_mapping.h\"\n-#include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_posix.h\"\n \n #include <elf.h>\n #include <link.h>\n \n+#include \"hwasan.h\"\n+#include \"hwasan_mapping.h\"\n+#include \"hwasan_thread_list.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_posix.h\"\n+\n // The code in this file needs to run in an unrelocated binary. It should not\n // access any external symbol, including its own non-hidden globals.\n \n@@ -117,6 +119,12 @@ namespace __hwasan {\n void InitShadowGOT() {}\n \n uptr FindDynamicShadowStart(uptr shadow_size_bytes) {\n+#if defined(__x86_64__)\n+  constexpr uptr kAliasSize = 1ULL << kAddressTagShift;\n+  constexpr uptr kNumAliases = 1ULL << kTagBits;\n+  return MapDynamicShadowAndAliases(shadow_size_bytes, kAliasSize, kNumAliases,\n+                                    RingBufferSize());\n+#endif\n   return MapDynamicShadow(shadow_size_bytes, kShadowScale, kShadowBaseAlignment,\n                           kHighMemEnd);\n }"}, {"sha": "b17750158d021cb0079182ca54917dc8d3f8d0bf", "filename": "libsanitizer/hwasan/hwasan_flags.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_flags.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -12,6 +12,8 @@\n #ifndef HWASAN_FLAGS_H\n #define HWASAN_FLAGS_H\n \n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+\n namespace __hwasan {\n \n struct Flags {"}, {"sha": "18ea47f981bec9538c54130c09a4bfe2ec31305a", "filename": "libsanitizer/hwasan/hwasan_flags.inc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_flags.inc?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -72,3 +72,12 @@ HWASAN_FLAG(uptr, malloc_bisect_right, 0,\n HWASAN_FLAG(bool, malloc_bisect_dump, false,\n             \"Print all allocations within [malloc_bisect_left, \"\n             \"malloc_bisect_right] range \")\n+\n+\n+// Exit if we fail to enable the AArch64 kernel ABI relaxation which allows\n+// tagged pointers in syscalls.  This is the default, but being able to disable\n+// that behaviour is useful for running the testsuite on more platforms (the\n+// testsuite can run since we manually ensure any pointer arguments to syscalls\n+// are untagged before the call.\n+HWASAN_FLAG(bool, fail_without_syscall_abi, true,\n+            \"Exit if fail to request relaxed syscall ABI.\")"}, {"sha": "ad67e2787d3123ef0c1988f2797568f0e77e58bf", "filename": "libsanitizer/hwasan/hwasan_interceptors.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_interceptors.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -221,8 +221,7 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr, void *(*callback)(void*),\n   ThreadStartArg *A = reinterpret_cast<ThreadStartArg *> (MmapOrDie(\n       GetPageSizeCached(), \"pthread_create\"));\n   *A = {callback, param};\n-  int res = REAL(pthread_create)(UntagPtr(th), UntagPtr(attr),\n-                                 &HwasanThreadStartFunc, A);\n+  int res = REAL(pthread_create)(th, attr, &HwasanThreadStartFunc, A);\n   return res;\n }\n "}, {"sha": "fd20825e3dacce3d4179e6140330fdab789aec81", "filename": "libsanitizer/hwasan/hwasan_interceptors_vfork.S", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_interceptors_vfork.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_interceptors_vfork.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_interceptors_vfork.S?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -1,4 +1,5 @@\n #include \"sanitizer_common/sanitizer_asm.h\"\n+#include \"builtins/assembly.h\"\n \n #if defined(__linux__) && HWASAN_WITH_INTERCEPTORS\n #define COMMON_INTERCEPTOR_SPILL_AREA __hwasan_extra_spill_area\n@@ -9,3 +10,5 @@\n #endif\n \n NO_EXEC_STACK_DIRECTIVE\n+\n+GNU_PROPERTY_BTI_PAC"}, {"sha": "25c0f94fe51f542432b1cc3c76ae925241fbc9ac", "filename": "libsanitizer/hwasan/hwasan_interface_internal.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_interface_internal.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -222,6 +222,9 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void *__hwasan_memset(void *s, int c, uptr n);\n SANITIZER_INTERFACE_ATTRIBUTE\n void *__hwasan_memmove(void *dest, const void *src, uptr n);\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __hwasan_set_error_report_callback(void (*callback)(const char *));\n }  // extern \"C\"\n \n #endif  // HWASAN_INTERFACE_INTERNAL_H"}, {"sha": "8ce0ff7da95695bc634e1c08b425141e22b9b38e", "filename": "libsanitizer/hwasan/hwasan_linux.cpp", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -76,6 +76,8 @@ uptr kHighShadowEnd;\n uptr kHighMemStart;\n uptr kHighMemEnd;\n \n+uptr kAliasRegionStart;  // Always 0 on non-x86.\n+\n static void PrintRange(uptr start, uptr end, const char *name) {\n   Printf(\"|| [%p, %p] || %.*s ||\\n\", (void *)start, (void *)end, 10, name);\n }\n@@ -119,27 +121,32 @@ void InitPrctl() {\n #define PR_GET_TAGGED_ADDR_CTRL 56\n #define PR_TAGGED_ADDR_ENABLE (1UL << 0)\n   // Check we're running on a kernel that can use the tagged address ABI.\n-  if (internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0) == (uptr)-1 &&\n-      errno == EINVAL) {\n-#if SANITIZER_ANDROID\n+  int local_errno = 0;\n+  if (internal_iserror(internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0),\n+                       &local_errno) &&\n+      local_errno == EINVAL) {\n+#if SANITIZER_ANDROID || defined(__x86_64__)\n     // Some older Android kernels have the tagged pointer ABI on\n     // unconditionally, and hence don't have the tagged-addr prctl while still\n     // allow the ABI.\n     // If targeting Android and the prctl is not around we assume this is the\n     // case.\n     return;\n #else\n-    Printf(\n-        \"FATAL: \"\n-        \"HWAddressSanitizer requires a kernel with tagged address ABI.\\n\");\n-    Die();\n+    if (flags()->fail_without_syscall_abi) {\n+      Printf(\n+          \"FATAL: \"\n+          \"HWAddressSanitizer requires a kernel with tagged address ABI.\\n\");\n+      Die();\n+    }\n #endif\n   }\n \n   // Turn on the tagged address ABI.\n-  if (internal_prctl(PR_SET_TAGGED_ADDR_CTRL, PR_TAGGED_ADDR_ENABLE, 0, 0, 0) ==\n-          (uptr)-1 ||\n-      !internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0)) {\n+  if ((internal_iserror(internal_prctl(PR_SET_TAGGED_ADDR_CTRL,\n+                                       PR_TAGGED_ADDR_ENABLE, 0, 0, 0)) ||\n+       !internal_prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0)) &&\n+      flags()->fail_without_syscall_abi) {\n     Printf(\n         \"FATAL: HWAddressSanitizer failed to enable tagged address syscall \"\n         \"ABI.\\nSuggest check `sysctl abi.tagged_addr_disabled` \"\n@@ -174,6 +181,18 @@ bool InitShadow() {\n   // High memory starts where allocated shadow allows.\n   kHighMemStart = ShadowToMem(kHighShadowStart);\n \n+#if defined(__x86_64__)\n+  constexpr uptr kAliasRegionOffset = 1ULL << (kTaggableRegionCheckShift - 1);\n+  kAliasRegionStart =\n+      __hwasan_shadow_memory_dynamic_address + kAliasRegionOffset;\n+\n+  CHECK_EQ(kAliasRegionStart >> kTaggableRegionCheckShift,\n+           __hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n+  CHECK_EQ(\n+      (kAliasRegionStart + kAliasRegionOffset - 1) >> kTaggableRegionCheckShift,\n+      __hwasan_shadow_memory_dynamic_address >> kTaggableRegionCheckShift);\n+#endif\n+\n   // Check the sanity of the defined memory ranges (there might be gaps).\n   CHECK_EQ(kHighMemStart % GetMmapGranularity(), 0);\n   CHECK_GT(kHighMemStart, kHighShadowEnd);\n@@ -217,7 +236,9 @@ void InitThreads() {\n }\n \n bool MemIsApp(uptr p) {\n+#if !defined(__x86_64__)  // Memory outside the alias range has non-zero tags.\n   CHECK(GetTagFromPointer(p) == 0);\n+#endif\n   return p >= kHighMemStart || (p >= kLowMemStart && p <= kLowMemEnd);\n }\n "}, {"sha": "8243d1ec7ed50a9274459fdc28f9b4f8a4b6c4cd", "filename": "libsanitizer/hwasan/hwasan_mapping.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_mapping.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -48,6 +48,8 @@ extern uptr kHighShadowEnd;\n extern uptr kHighMemStart;\n extern uptr kHighMemEnd;\n \n+extern uptr kAliasRegionStart;\n+\n inline uptr MemToShadow(uptr untagged_addr) {\n   return (untagged_addr >> kShadowScale) +\n          __hwasan_shadow_memory_dynamic_address;"}, {"sha": "fab017aae60bed2bac6c02742a5f57a91eb888e6", "filename": "libsanitizer/hwasan/hwasan_memintrinsics.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_memintrinsics.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_memintrinsics.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_memintrinsics.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -24,15 +24,15 @@ using namespace __hwasan;\n void *__hwasan_memset(void *block, int c, uptr size) {\n   CheckAddressSized<ErrorAction::Recover, AccessType::Store>(\n       reinterpret_cast<uptr>(block), size);\n-  return memset(UntagPtr(block), c, size);\n+  return memset(block, c, size);\n }\n \n void *__hwasan_memcpy(void *to, const void *from, uptr size) {\n   CheckAddressSized<ErrorAction::Recover, AccessType::Store>(\n       reinterpret_cast<uptr>(to), size);\n   CheckAddressSized<ErrorAction::Recover, AccessType::Load>(\n       reinterpret_cast<uptr>(from), size);\n-  return memcpy(UntagPtr(to), UntagPtr(from), size);\n+  return memcpy(to, from, size);\n }\n \n void *__hwasan_memmove(void *to, const void *from, uptr size) {"}, {"sha": "69cddda736eb4a5156ddf441cd9ce717df15674a", "filename": "libsanitizer/hwasan/hwasan_new_delete.cpp", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_new_delete.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -27,6 +27,12 @@\n   void *res = hwasan_malloc(size, &stack);\\\n   if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n   return res\n+#define OPERATOR_NEW_ALIGN_BODY(nothrow)                                    \\\n+  GET_MALLOC_STACK_TRACE;                                                   \\\n+  void *res = hwasan_aligned_alloc(static_cast<uptr>(align), size, &stack); \\\n+  if (!nothrow && UNLIKELY(!res))                                           \\\n+    ReportOutOfMemory(size, &stack);                                        \\\n+  return res\n \n #define OPERATOR_DELETE_BODY \\\n   GET_MALLOC_STACK_TRACE; \\\n@@ -50,6 +56,7 @@ using namespace __hwasan;\n // Fake std::nothrow_t to avoid including <new>.\n namespace std {\n   struct nothrow_t {};\n+  enum class align_val_t : size_t {};\n }  // namespace std\n \n \n@@ -66,6 +73,22 @@ INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void *operator new[](size_t size, std::nothrow_t const&) {\n   OPERATOR_NEW_BODY(true /*nothrow*/);\n }\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void *operator new(\n+    size_t size, std::align_val_t align) {\n+  OPERATOR_NEW_ALIGN_BODY(false /*nothrow*/);\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void *operator new[](\n+    size_t size, std::align_val_t align) {\n+  OPERATOR_NEW_ALIGN_BODY(false /*nothrow*/);\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void *operator new(\n+    size_t size, std::align_val_t align, std::nothrow_t const &) {\n+  OPERATOR_NEW_ALIGN_BODY(true /*nothrow*/);\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void *operator new[](\n+    size_t size, std::align_val_t align, std::nothrow_t const &) {\n+  OPERATOR_NEW_ALIGN_BODY(true /*nothrow*/);\n+}\n \n INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void operator delete(void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\n@@ -77,5 +100,21 @@ INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void operator delete[](void *ptr, std::nothrow_t const&) {\n   OPERATOR_DELETE_BODY;\n }\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete(\n+    void *ptr, std::align_val_t align) NOEXCEPT {\n+  OPERATOR_DELETE_BODY;\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete[](\n+    void *ptr, std::align_val_t) NOEXCEPT {\n+  OPERATOR_DELETE_BODY;\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete(\n+    void *ptr, std::align_val_t, std::nothrow_t const &) NOEXCEPT {\n+  OPERATOR_DELETE_BODY;\n+}\n+INTERCEPTOR_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void operator delete[](\n+    void *ptr, std::align_val_t, std::nothrow_t const &) NOEXCEPT {\n+  OPERATOR_DELETE_BODY;\n+}\n \n #endif // OPERATOR_NEW_BODY"}, {"sha": "c02177993918d88183ad229074f2decc05228a84", "filename": "libsanitizer/hwasan/hwasan_report.cpp", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_report.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -43,12 +43,16 @@ class ScopedReport {\n   }\n \n   ~ScopedReport() {\n+    void (*report_cb)(const char *);\n     {\n       BlockingMutexLock lock(&error_message_lock_);\n-      if (fatal)\n-        SetAbortMessage(error_message_.data());\n+      report_cb = error_report_callback_;\n       error_message_ptr_ = nullptr;\n     }\n+    if (report_cb)\n+      report_cb(error_message_.data());\n+    if (fatal)\n+      SetAbortMessage(error_message_.data());\n     if (common_flags()->print_module_map >= 2 ||\n         (fatal && common_flags()->print_module_map))\n       DumpProcessMap();\n@@ -66,17 +70,25 @@ class ScopedReport {\n     // overwrite old trailing '\\0', keep new trailing '\\0' untouched.\n     internal_memcpy(&(*error_message_ptr_)[old_size - 1], msg, len);\n   }\n+\n+  static void SetErrorReportCallback(void (*callback)(const char *)) {\n+    BlockingMutexLock lock(&error_message_lock_);\n+    error_report_callback_ = callback;\n+  }\n+\n  private:\n   ScopedErrorReportLock error_report_lock_;\n   InternalMmapVector<char> error_message_;\n   bool fatal;\n \n   static InternalMmapVector<char> *error_message_ptr_;\n   static BlockingMutex error_message_lock_;\n+  static void (*error_report_callback_)(const char *);\n };\n \n InternalMmapVector<char> *ScopedReport::error_message_ptr_;\n BlockingMutex ScopedReport::error_message_lock_;\n+void (*ScopedReport::error_report_callback_)(const char *);\n \n // If there is an active ScopedReport, append to its error message.\n void AppendToErrorMessageBuffer(const char *buffer) {\n@@ -212,7 +224,7 @@ static void PrintStackAllocations(StackAllocationsRingBuffer *sa,\n \n   // We didn't find any locals. Most likely we don't have symbols, so dump\n   // the information that we have for offline analysis.\n-  InternalScopedString frame_desc(GetPageSizeCached() * 2);\n+  InternalScopedString frame_desc;\n   Printf(\"Previously allocated frames:\\n\");\n   for (uptr i = 0; i < frames; i++) {\n     const uptr *record_addr = &(*sa)[i];\n@@ -447,7 +459,7 @@ static void PrintTagInfoAroundAddr(tag_t *tag_ptr, uptr num_rows,\n       RoundDownTo(reinterpret_cast<uptr>(tag_ptr), row_len));\n   tag_t *beg_row = center_row_beg - row_len * (num_rows / 2);\n   tag_t *end_row = center_row_beg + row_len * ((num_rows + 1) / 2);\n-  InternalScopedString s(GetPageSizeCached() * 8);\n+  InternalScopedString s;\n   for (tag_t *row = beg_row; row < end_row; row += row_len) {\n     s.append(\"%s\", row == center_row_beg ? \"=>\" : \"  \");\n     s.append(\"%p:\", row);\n@@ -535,7 +547,7 @@ void ReportTailOverwritten(StackTrace *stack, uptr tagged_addr, uptr orig_size,\n     GetStackTraceFromId(chunk.GetAllocStackId()).Print();\n   }\n \n-  InternalScopedString s(GetPageSizeCached() * 8);\n+  InternalScopedString s;\n   CHECK_GT(tail_size, 0U);\n   CHECK_LT(tail_size, kShadowAlignment);\n   u8 *tail = reinterpret_cast<u8*>(untagged_addr + orig_size);\n@@ -650,3 +662,7 @@ void ReportRegisters(uptr *frame, uptr pc) {\n }\n \n }  // namespace __hwasan\n+\n+void __hwasan_set_error_report_callback(void (*callback)(const char *)) {\n+  __hwasan::ScopedReport::SetErrorReportCallback(callback);\n+}"}, {"sha": "381af63363cc3b96f2dd63f1cca706dedbb55e03", "filename": "libsanitizer/hwasan/hwasan_setjmp.S", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_setjmp.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_setjmp.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_setjmp.S?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -12,6 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_asm.h\"\n+#include \"builtins/assembly.h\"\n \n #if HWASAN_WITH_INTERCEPTORS && defined(__aarch64__)\n #include \"sanitizer_common/sanitizer_platform.h\"\n@@ -34,6 +35,7 @@\n ASM_TYPE_FUNCTION(__interceptor_setjmp)\n __interceptor_setjmp:\n   CFI_STARTPROC\n+  BTI_C\n   mov\tx1, #0\n   b\t__interceptor_sigsetjmp\n   CFI_ENDPROC\n@@ -46,6 +48,7 @@ ASM_SIZE(__interceptor_setjmp)\n ASM_TYPE_FUNCTION(__interceptor_setjmp_bionic)\n __interceptor_setjmp_bionic:\n   CFI_STARTPROC\n+  BTI_C\n   mov\tx1, #1\n   b\t__interceptor_sigsetjmp\n   CFI_ENDPROC\n@@ -56,6 +59,7 @@ ASM_SIZE(__interceptor_setjmp_bionic)\n ASM_TYPE_FUNCTION(__interceptor_sigsetjmp)\n __interceptor_sigsetjmp:\n   CFI_STARTPROC\n+  BTI_C\n   stp\tx19, x20, [x0, #0<<3]\n   stp\tx21, x22, [x0, #2<<3]\n   stp\tx23, x24, [x0, #4<<3]\n@@ -98,3 +102,5 @@ ALIAS __interceptor_setjmp, _setjmp\n \n // We do not need executable stack.\n NO_EXEC_STACK_DIRECTIVE\n+\n+GNU_PROPERTY_BTI_PAC"}, {"sha": "bcb0df42019029d36cbc38d1757118abf3b110bc", "filename": "libsanitizer/hwasan/hwasan_tag_mismatch_aarch64.S", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_tag_mismatch_aarch64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_tag_mismatch_aarch64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_tag_mismatch_aarch64.S?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -1,4 +1,5 @@\n #include \"sanitizer_common/sanitizer_asm.h\"\n+#include \"builtins/assembly.h\"\n \n // The content of this file is AArch64-only:\n #if defined(__aarch64__)\n@@ -74,6 +75,8 @@\n .global __hwasan_tag_mismatch\n .type __hwasan_tag_mismatch, %function\n __hwasan_tag_mismatch:\n+  BTI_J\n+\n   // Compute the granule position one past the end of the access.\n   mov x16, #1\n   and x17, x1, #0xf\n@@ -106,6 +109,7 @@ __hwasan_tag_mismatch:\n .type __hwasan_tag_mismatch_v2, %function\n __hwasan_tag_mismatch_v2:\n   CFI_STARTPROC\n+  BTI_J\n \n   // Set the CFA to be the return address for caller of __hwasan_check_*. Note\n   // that we do not emit CFI predicates to describe the contents of this stack\n@@ -150,3 +154,5 @@ __hwasan_tag_mismatch_v2:\n \n // We do not need executable stack.\n NO_EXEC_STACK_DIRECTIVE\n+\n+GNU_PROPERTY_BTI_PAC"}, {"sha": "bb4d56abed0a71f44eef43a94448547f625f312b", "filename": "libsanitizer/hwasan/hwasan_thread.cpp", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -35,6 +35,10 @@ void Thread::InitRandomState() {\n }\n \n void Thread::Init(uptr stack_buffer_start, uptr stack_buffer_size) {\n+  CHECK_EQ(0, unique_id_);  // try to catch bad stack reuse\n+  CHECK_EQ(0, stack_top_);\n+  CHECK_EQ(0, stack_bottom_);\n+\n   static u64 unique_id;\n   unique_id_ = unique_id++;\n   if (auto sz = flags()->heap_history_size)\n@@ -113,18 +117,21 @@ static u32 xorshift(u32 state) {\n }\n \n // Generate a (pseudo-)random non-zero tag.\n-tag_t Thread::GenerateRandomTag() {\n+tag_t Thread::GenerateRandomTag(uptr num_bits) {\n+  DCHECK_GT(num_bits, 0);\n   if (tagging_disabled_) return 0;\n   tag_t tag;\n+  const uptr tag_mask = (1ULL << num_bits) - 1;\n   do {\n     if (flags()->random_tags) {\n       if (!random_buffer_)\n         random_buffer_ = random_state_ = xorshift(random_state_);\n       CHECK(random_buffer_);\n-      tag = random_buffer_ & 0xFF;\n-      random_buffer_ >>= 8;\n+      tag = random_buffer_ & tag_mask;\n+      random_buffer_ >>= num_bits;\n     } else {\n-      tag = random_state_ = (random_state_ + 1) & 0xFF;\n+      random_state_ += 1;\n+      tag = random_state_ & tag_mask;\n     }\n   } while (!tag);\n   return tag;"}, {"sha": "1c71cab41c429af00414d3d68fcb976120ad67b2", "filename": "libsanitizer/hwasan/hwasan_thread.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -42,7 +42,7 @@ class Thread {\n   HeapAllocationsRingBuffer *heap_allocations() { return heap_allocations_; }\n   StackAllocationsRingBuffer *stack_allocations() { return stack_allocations_; }\n \n-  tag_t GenerateRandomTag();\n+  tag_t GenerateRandomTag(uptr num_bits = kTagBits);\n \n   void DisableTagging() { tagging_disabled_++; }\n   void EnableTagging() { tagging_disabled_--; }\n@@ -74,8 +74,6 @@ class Thread {\n   HeapAllocationsRingBuffer *heap_allocations_;\n   StackAllocationsRingBuffer *stack_allocations_;\n \n-  Thread *next_;  // All live threads form a linked list.\n-\n   u64 unique_id_;  // counting from zero.\n \n   u32 tagging_disabled_;  // if non-zero, malloc uses zero tag in this thread."}, {"sha": "11c586314ce75f45914ccbb007ab8c6fa86b4639", "filename": "libsanitizer/hwasan/hwasan_thread_list.h", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_thread_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fhwasan%2Fhwasan_thread_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread_list.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -66,40 +66,6 @@ static uptr RingBufferSize() {\n   return 0;\n }\n \n-struct ThreadListHead {\n-  Thread *list_;\n-\n-  ThreadListHead() : list_(nullptr) {}\n-\n-  void Push(Thread *t) {\n-    t->next_ = list_;\n-    list_ = t;\n-  }\n-\n-  Thread *Pop() {\n-    Thread *t = list_;\n-    if (t)\n-      list_ = t->next_;\n-    return t;\n-  }\n-\n-  void Remove(Thread *t) {\n-    Thread **cur = &list_;\n-    while (*cur != t) cur = &(*cur)->next_;\n-    CHECK(*cur && \"thread not found\");\n-    *cur = (*cur)->next_;\n-  }\n-\n-  template <class CB>\n-  void ForEach(CB cb) {\n-    Thread *t = list_;\n-    while (t) {\n-      cb(t);\n-      t = t->next_;\n-    }\n-  }\n-};\n-\n struct ThreadStats {\n   uptr n_live_threads;\n   uptr total_stack_size;\n@@ -120,17 +86,23 @@ class HwasanThreadList {\n   }\n \n   Thread *CreateCurrentThread() {\n-    Thread *t;\n+    Thread *t = nullptr;\n     {\n-      SpinMutexLock l(&list_mutex_);\n-      t = free_list_.Pop();\n-      if (t) {\n-        uptr start = (uptr)t - ring_buffer_size_;\n-        internal_memset((void *)start, 0, ring_buffer_size_ + sizeof(Thread));\n-      } else {\n-        t = AllocThread();\n+      SpinMutexLock l(&free_list_mutex_);\n+      if (!free_list_.empty()) {\n+        t = free_list_.back();\n+        free_list_.pop_back();\n       }\n-      live_list_.Push(t);\n+    }\n+    if (t) {\n+      uptr start = (uptr)t - ring_buffer_size_;\n+      internal_memset((void *)start, 0, ring_buffer_size_ + sizeof(Thread));\n+    } else {\n+      t = AllocThread();\n+    }\n+    {\n+      SpinMutexLock l(&live_list_mutex_);\n+      live_list_.push_back(t);\n     }\n     t->Init((uptr)t - ring_buffer_size_, ring_buffer_size_);\n     AddThreadStats(t);\n@@ -142,13 +114,26 @@ class HwasanThreadList {\n     ReleaseMemoryPagesToOS(start, start + thread_alloc_size_);\n   }\n \n+  void RemoveThreadFromLiveList(Thread *t) {\n+    SpinMutexLock l(&live_list_mutex_);\n+    for (Thread *&t2 : live_list_)\n+      if (t2 == t) {\n+        // To remove t2, copy the last element of the list in t2's position, and\n+        // pop_back(). This works even if t2 is itself the last element.\n+        t2 = live_list_.back();\n+        live_list_.pop_back();\n+        return;\n+      }\n+    CHECK(0 && \"thread not found in live list\");\n+  }\n+\n   void ReleaseThread(Thread *t) {\n     RemoveThreadStats(t);\n     t->Destroy();\n-    SpinMutexLock l(&list_mutex_);\n-    live_list_.Remove(t);\n-    free_list_.Push(t);\n     DontNeedThread(t);\n+    RemoveThreadFromLiveList(t);\n+    SpinMutexLock l(&free_list_mutex_);\n+    free_list_.push_back(t);\n   }\n \n   Thread *GetThreadByBufferAddress(uptr p) {\n@@ -165,8 +150,8 @@ class HwasanThreadList {\n \n   template <class CB>\n   void VisitAllLiveThreads(CB cb) {\n-    SpinMutexLock l(&list_mutex_);\n-    live_list_.ForEach(cb);\n+    SpinMutexLock l(&live_list_mutex_);\n+    for (Thread *t : live_list_) cb(t);\n   }\n \n   void AddThreadStats(Thread *t) {\n@@ -188,6 +173,7 @@ class HwasanThreadList {\n \n  private:\n   Thread *AllocThread() {\n+    SpinMutexLock l(&free_space_mutex_);\n     uptr align = ring_buffer_size_ * 2;\n     CHECK(IsAligned(free_space_, align));\n     Thread *t = (Thread *)(free_space_ + ring_buffer_size_);\n@@ -196,14 +182,16 @@ class HwasanThreadList {\n     return t;\n   }\n \n+  SpinMutex free_space_mutex_;\n   uptr free_space_;\n   uptr free_space_end_;\n   uptr ring_buffer_size_;\n   uptr thread_alloc_size_;\n \n-  ThreadListHead free_list_;\n-  ThreadListHead live_list_;\n-  SpinMutex list_mutex_;\n+  SpinMutex free_list_mutex_;\n+  InternalMmapVector<Thread *> free_list_;\n+  SpinMutex live_list_mutex_;\n+  InternalMmapVector<Thread *> live_list_;\n \n   ThreadStats stats_;\n   SpinMutex stats_mutex_;"}, {"sha": "cd69285b8d4afec5f5615eff88129811db497912", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -43,6 +43,9 @@ void __sanitizer_set_report_path(const char *path);\n // Tell the tools to write their reports to the provided file descriptor\n // (casted to void *).\n void __sanitizer_set_report_fd(void *fd);\n+// Get the current full report file path, if a path was specified by\n+// an earlier call to __sanitizer_set_report_path. Returns null otherwise.\n+const char *__sanitizer_get_report_path();\n \n // Notify the tools that the sandbox is going to be turned on. The reserved\n // parameter will be used in the future to hold a structure with functions"}, {"sha": "40f9379b5579c4ee273d840771d6cde5480d29c7", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -22,6 +22,7 @@ extern \"C\" {\n #endif\n \n typedef uint16_t dfsan_label;\n+typedef uint32_t dfsan_origin;\n \n /// Stores information associated with a specific label identifier.  A label\n /// may be a base label created using dfsan_create_label, with associated\n@@ -63,6 +64,12 @@ void dfsan_add_label(dfsan_label label, void *addr, size_t size);\n /// value.\n dfsan_label dfsan_get_label(long data);\n \n+/// Retrieves the immediate origin associated with the given data. The returned\n+/// origin may point to another origin.\n+///\n+/// The type of 'data' is arbitrary.\n+dfsan_origin dfsan_get_origin(long data);\n+\n /// Retrieves the label associated with the data at the given address.\n dfsan_label dfsan_read_label(const void *addr, size_t size);\n \n@@ -110,6 +117,15 @@ void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,\n void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,\n                              size_t n, dfsan_label s1_label,\n                              dfsan_label s2_label, dfsan_label n_label);\n+\n+/// Prints the origin trace of the label at the address addr to stderr. It also\n+/// prints description at the beginning of the trace. If origin tracking is not\n+/// on, or the address is not labeled, it prints nothing.\n+void dfsan_print_origin_trace(const void *addr, const char *description);\n+\n+/// Retrieves the very first origin associated with the data at the given\n+/// address.\n+dfsan_origin dfsan_get_init_origin(const void *addr);\n #ifdef __cplusplus\n }  // extern \"C\"\n "}, {"sha": "14035c05c63535f531b60e248861d9dfcda1da0b", "filename": "libsanitizer/include/sanitizer/hwasan_interface.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -73,6 +73,9 @@ extern \"C\" {\n    * accessed through the pointer in x, or -1 if the whole range is good. */\n   intptr_t __hwasan_test_shadow(const volatile void *x, size_t size);\n \n+  /* Sets the callback function to be called during HWASan error reporting. */\n+  void __hwasan_set_error_report_callback(void (*callback)(const char *));\n+\n   int __sanitizer_posix_memalign(void **memptr, size_t alignment, size_t size);\n   void * __sanitizer_memalign(size_t alignment, size_t size);\n   void * __sanitizer_aligned_alloc(size_t alignment, size_t size);"}, {"sha": "76031de4014c0a79361505b8a904eff5b0eb8114", "filename": "libsanitizer/include/sanitizer/memprof_interface.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fmemprof_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Fmemprof_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmemprof_interface.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -53,6 +53,11 @@ void __memprof_print_accumulated_stats(void);\n /// \\returns Default options string.\n const char *__memprof_default_options(void);\n \n+/// Prints the memory profile to the current profile file.\n+///\n+/// \\returns 0 on success.\n+int __memprof_profile_dump(void);\n+\n #ifdef __cplusplus\n } // extern \"C\"\n #endif"}, {"sha": "565aa391a9fac0a97fc06576efe603121cf6ee71", "filename": "libsanitizer/include/sanitizer/tsan_interface.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -67,6 +67,12 @@ static const unsigned __tsan_mutex_recursive_lock   = 1 << 6;\n // the corresponding __tsan_mutex_post_lock annotation.\n static const unsigned __tsan_mutex_recursive_unlock = 1 << 7;\n \n+// Convenient composed constants.\n+static const unsigned __tsan_mutex_try_read_lock =\n+    __tsan_mutex_read_lock | __tsan_mutex_try_lock;\n+static const unsigned __tsan_mutex_try_read_lock_failed =\n+    __tsan_mutex_try_read_lock | __tsan_mutex_try_lock_failed;\n+\n // Annotate creation of a mutex.\n // Supported flags: mutex creation flags.\n void __tsan_mutex_create(void *addr, unsigned flags);\n@@ -141,7 +147,7 @@ void __tsan_external_write(void *addr, void *caller_pc, void *tag);\n //     and freed by __tsan_destroy_fiber.\n //   - TSAN context of current fiber or thread can be obtained\n //     by calling __tsan_get_current_fiber.\n-//   - __tsan_switch_to_fiber should be called immediatly before switch\n+//   - __tsan_switch_to_fiber should be called immediately before switch\n //     to fiber, such as call of swapcontext.\n //   - Fiber name can be set by __tsan_set_fiber_name.\n void *__tsan_get_current_fiber(void);\n@@ -154,6 +160,15 @@ void __tsan_set_fiber_name(void *fiber, const char *name);\n // Do not establish a happens-before relation between fibers\n static const unsigned __tsan_switch_to_fiber_no_sync = 1 << 0;\n \n+// User-provided callback invoked on TSan initialization.\n+void __tsan_on_initialize();\n+\n+// User-provided callback invoked on TSan shutdown.\n+// `failed` - Nonzero if TSan did detect issues, zero otherwise.\n+// Return `0` if TSan should exit as if no issues were detected.  Return nonzero\n+// if TSan should exit as if issues were detected.\n+int __tsan_on_finalize(int failed);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "5e41e2256c300fd3a4d65939b61efdc0c10b757b", "filename": "libsanitizer/include/sanitizer/tsan_interface_atomic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -30,7 +30,7 @@ __extension__ typedef __int128 __tsan_atomic128;\n #endif\n \n // Part of ABI, do not change.\n-// https://github.com/llvm/llvm-project/blob/master/libcxx/include/atomic\n+// https://github.com/llvm/llvm-project/blob/main/libcxx/include/atomic\n typedef enum {\n   __tsan_memory_order_relaxed,\n   __tsan_memory_order_consume,"}, {"sha": "5111a87f0a6c91dbc0c40c9004fb3eae12c0c0a4", "filename": "libsanitizer/interception/interception_linux.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finterception%2Finterception_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finterception%2Finterception_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -63,8 +63,8 @@ bool InterceptFunction(const char *name, uptr *ptr_to_real, uptr func,\n   return addr && (func == wrapper);\n }\n \n-// Android and Solaris do not have dlvsym\n-#if !SANITIZER_ANDROID && !SANITIZER_SOLARIS\n+// dlvsym is a GNU extension supported by some other platforms.\n+#if SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD\n static void *GetFuncAddr(const char *name, const char *ver) {\n   return dlvsym(RTLD_NEXT, name, ver);\n }\n@@ -75,7 +75,7 @@ bool InterceptFunction(const char *name, const char *ver, uptr *ptr_to_real,\n   *ptr_to_real = (uptr)addr;\n   return addr && (func == wrapper);\n }\n-#endif  // !SANITIZER_ANDROID\n+#endif  // SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD\n \n }  // namespace __interception\n "}, {"sha": "a08f8cb98c4091564db29f53b0674d923ae53508", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -35,8 +35,8 @@ bool InterceptFunction(const char *name, const char *ver, uptr *ptr_to_real,\n       (::__interception::uptr) & (func),          \\\n       (::__interception::uptr) & WRAP(func))\n \n-// Android and Solaris do not have dlvsym\n-#if !SANITIZER_ANDROID && !SANITIZER_SOLARIS\n+// dlvsym is a GNU extension supported by some other platforms.\n+#if SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD\n #define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n   ::__interception::InterceptFunction(                        \\\n       #func, symver,                                          \\\n@@ -46,7 +46,7 @@ bool InterceptFunction(const char *name, const char *ver, uptr *ptr_to_real,\n #else\n #define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n   INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n-#endif  // !SANITIZER_ANDROID && !SANITIZER_SOLARIS\n+#endif  // SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD\n \n #endif  // INTERCEPTION_LINUX_H\n #endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||"}, {"sha": "98bc756ae53aa574ba98e04649978640d597b2d3", "filename": "libsanitizer/interception/interception_win.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finterception%2Finterception_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Finterception%2Finterception_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -136,7 +136,7 @@ namespace __interception {\n static const int kAddressLength = FIRST_32_SECOND_64(4, 8);\n static const int kJumpInstructionLength = 5;\n static const int kShortJumpInstructionLength = 2;\n-static const int kIndirectJumpInstructionLength = 6;\n+UNUSED static const int kIndirectJumpInstructionLength = 6;\n static const int kBranchLength =\n     FIRST_32_SECOND_64(kJumpInstructionLength, kIndirectJumpInstructionLength);\n static const int kDirectBranchLength = kBranchLength + kAddressLength;\n@@ -165,7 +165,7 @@ static uptr GetMmapGranularity() {\n   return si.dwAllocationGranularity;\n }\n \n-static uptr RoundUpTo(uptr size, uptr boundary) {\n+UNUSED static uptr RoundUpTo(uptr size, uptr boundary) {\n   return (size + boundary - 1) & ~(boundary - 1);\n }\n \n@@ -309,7 +309,7 @@ struct TrampolineMemoryRegion {\n   uptr max_size;\n };\n \n-static const uptr kTrampolineScanLimitRange = 1 << 31;  // 2 gig\n+UNUSED static const uptr kTrampolineScanLimitRange = 1 << 31;  // 2 gig\n static const int kMaxTrampolineRegion = 1024;\n static TrampolineMemoryRegion TrampolineRegions[kMaxTrampolineRegion];\n "}, {"sha": "91e34ebb32143de04f8f319222f5e942fadf8a89", "filename": "libsanitizer/lsan/lsan_allocator.cpp", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -123,14 +123,18 @@ void Deallocate(void *p) {\n \n void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n                  uptr alignment) {\n-  RegisterDeallocation(p);\n   if (new_size > max_malloc_size) {\n-    allocator.Deallocate(GetAllocatorCache(), p);\n-    return ReportAllocationSizeTooBig(new_size, stack);\n+    ReportAllocationSizeTooBig(new_size, stack);\n+    return nullptr;\n   }\n-  p = allocator.Reallocate(GetAllocatorCache(), p, new_size, alignment);\n-  RegisterAllocation(stack, p, new_size);\n-  return p;\n+  RegisterDeallocation(p);\n+  void *new_p =\n+      allocator.Reallocate(GetAllocatorCache(), p, new_size, alignment);\n+  if (new_p)\n+    RegisterAllocation(stack, new_p, new_size);\n+  else if (new_size != 0)\n+    RegisterAllocation(stack, p, new_size);\n+  return new_p;\n }\n \n void GetAllocatorCacheRange(uptr *begin, uptr *end) {\n@@ -309,6 +313,16 @@ IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n     return kIgnoreObjectInvalid;\n   }\n }\n+\n+void GetAdditionalThreadContextPtrs(ThreadContextBase *tctx, void *ptrs) {\n+  // This function can be used to treat memory reachable from `tctx` as live.\n+  // This is useful for threads that have been created but not yet started.\n+\n+  // This is currently a no-op because the LSan `pthread_create()` interceptor\n+  // blocks until the child thread starts which keeps the thread's `arg` pointer\n+  // live.\n+}\n+\n } // namespace __lsan\n \n using namespace __lsan;"}, {"sha": "9d763789154fb57a45e7fc5faf2a6d7578cc3d0d", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -50,7 +50,7 @@ struct ChunkMetadata {\n };\n \n #if defined(__mips64) || defined(__aarch64__) || defined(__i386__) || \\\n-    defined(__arm__)\n+    defined(__arm__) || SANITIZER_RISCV64\n template <typename AddressSpaceViewTy>\n struct AP32 {\n   static const uptr kSpaceBeg = 0;"}, {"sha": "74400d2e8426d01e99a7832e7bd0c2bc1aec49e3", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 179, "deletions": 55, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -65,8 +65,34 @@ void RegisterLsanFlags(FlagParser *parser, Flags *f) {\n     if (flags()->log_threads) Report(__VA_ARGS__); \\\n   } while (0)\n \n-ALIGNED(64) static char suppression_placeholder[sizeof(SuppressionContext)];\n-static SuppressionContext *suppression_ctx = nullptr;\n+class LeakSuppressionContext {\n+  bool parsed = false;\n+  SuppressionContext context;\n+  bool suppressed_stacks_sorted = true;\n+  InternalMmapVector<u32> suppressed_stacks;\n+\n+  Suppression *GetSuppressionForAddr(uptr addr);\n+  void LazyInit();\n+\n+ public:\n+  LeakSuppressionContext(const char *supprression_types[],\n+                         int suppression_types_num)\n+      : context(supprression_types, suppression_types_num) {}\n+\n+  Suppression *GetSuppressionForStack(u32 stack_trace_id);\n+\n+  const InternalMmapVector<u32> &GetSortedSuppressedStacks() {\n+    if (!suppressed_stacks_sorted) {\n+      suppressed_stacks_sorted = true;\n+      SortAndDedup(suppressed_stacks);\n+    }\n+    return suppressed_stacks;\n+  }\n+  void PrintMatchedSuppressions();\n+};\n+\n+ALIGNED(64) static char suppression_placeholder[sizeof(LeakSuppressionContext)];\n+static LeakSuppressionContext *suppression_ctx = nullptr;\n static const char kSuppressionLeak[] = \"leak\";\n static const char *kSuppressionTypes[] = { kSuppressionLeak };\n static const char kStdSuppressions[] =\n@@ -86,14 +112,20 @@ static const char kStdSuppressions[] =\n void InitializeSuppressions() {\n   CHECK_EQ(nullptr, suppression_ctx);\n   suppression_ctx = new (suppression_placeholder)\n-      SuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n-  suppression_ctx->ParseFromFile(flags()->suppressions);\n-  if (&__lsan_default_suppressions)\n-    suppression_ctx->Parse(__lsan_default_suppressions());\n-  suppression_ctx->Parse(kStdSuppressions);\n+      LeakSuppressionContext(kSuppressionTypes, ARRAY_SIZE(kSuppressionTypes));\n+}\n+\n+void LeakSuppressionContext::LazyInit() {\n+  if (!parsed) {\n+    parsed = true;\n+    context.ParseFromFile(flags()->suppressions);\n+    if (&__lsan_default_suppressions)\n+      context.Parse(__lsan_default_suppressions());\n+    context.Parse(kStdSuppressions);\n+  }\n }\n \n-static SuppressionContext *GetSuppressionContext() {\n+static LeakSuppressionContext *GetSuppressionContext() {\n   CHECK(suppression_ctx);\n   return suppression_ctx;\n }\n@@ -221,6 +253,27 @@ extern \"C\" SANITIZER_WEAK_ATTRIBUTE void __libc_iterate_dynamic_tls(\n     pid_t, void (*cb)(void *, void *, uptr, void *), void *);\n #endif\n \n+static void ProcessThreadRegistry(Frontier *frontier) {\n+  InternalMmapVector<uptr> ptrs;\n+  GetThreadRegistryLocked()->RunCallbackForEachThreadLocked(\n+      GetAdditionalThreadContextPtrs, &ptrs);\n+\n+  for (uptr i = 0; i < ptrs.size(); ++i) {\n+    void *ptr = reinterpret_cast<void *>(ptrs[i]);\n+    uptr chunk = PointsIntoChunk(ptr);\n+    if (!chunk)\n+      continue;\n+    LsanMetadata m(chunk);\n+    if (!m.allocated())\n+      continue;\n+\n+    // Mark as reachable and add to frontier.\n+    LOG_POINTERS(\"Treating pointer %p from ThreadContext as reachable\\n\", ptr);\n+    m.set_tag(kReachable);\n+    frontier->push_back(chunk);\n+  }\n+}\n+\n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            Frontier *frontier) {\n@@ -315,15 +368,15 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n       __libc_iterate_dynamic_tls(os_id, cb, frontier);\n #else\n       if (dtls && !DTLSInDestruction(dtls)) {\n-        for (uptr j = 0; j < dtls->dtv_size; ++j) {\n-          uptr dtls_beg = dtls->dtv[j].beg;\n-          uptr dtls_end = dtls_beg + dtls->dtv[j].size;\n+        ForEachDVT(dtls, [&](const DTLS::DTV &dtv, int id) {\n+          uptr dtls_beg = dtv.beg;\n+          uptr dtls_end = dtls_beg + dtv.size;\n           if (dtls_beg < dtls_end) {\n-            LOG_THREADS(\"DTLS %zu at %p-%p.\\n\", j, dtls_beg, dtls_end);\n+            LOG_THREADS(\"DTLS %zu at %p-%p.\\n\", id, dtls_beg, dtls_end);\n             ScanRangeForPointers(dtls_beg, dtls_end, frontier, \"DTLS\",\n                                  kReachable);\n           }\n-        }\n+        });\n       } else {\n         // We are handling a thread with DTLS under destruction. Log about\n         // this and continue.\n@@ -332,6 +385,9 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n #endif\n     }\n   }\n+\n+  // Add pointers reachable from ThreadContexts\n+  ProcessThreadRegistry(frontier);\n }\n \n #endif  // SANITIZER_FUCHSIA\n@@ -390,6 +446,24 @@ static void MarkIndirectlyLeakedCb(uptr chunk, void *arg) {\n   }\n }\n \n+static void IgnoredSuppressedCb(uptr chunk, void *arg) {\n+  CHECK(arg);\n+  chunk = GetUserBegin(chunk);\n+  LsanMetadata m(chunk);\n+  if (!m.allocated() || m.tag() == kIgnored)\n+    return;\n+\n+  const InternalMmapVector<u32> &suppressed =\n+      *static_cast<const InternalMmapVector<u32> *>(arg);\n+  uptr idx = InternalLowerBound(suppressed, m.stack_trace_id());\n+  if (idx >= suppressed.size() || m.stack_trace_id() != suppressed[idx])\n+    return;\n+\n+  LOG_POINTERS(\"Suppressed: chunk %p-%p of size %zu.\\n\", chunk,\n+               chunk + m.requested_size(), m.requested_size());\n+  m.set_tag(kIgnored);\n+}\n+\n // ForEachChunk callback. If chunk is marked as ignored, adds its address to\n // frontier.\n static void CollectIgnoredCb(uptr chunk, void *arg) {\n@@ -473,6 +547,12 @@ void ProcessPC(Frontier *frontier) {\n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads,\n                               Frontier *frontier) {\n+  const InternalMmapVector<u32> &suppressed_stacks =\n+      GetSuppressionContext()->GetSortedSuppressedStacks();\n+  if (!suppressed_stacks.empty()) {\n+    ForEachChunk(IgnoredSuppressedCb,\n+                 const_cast<InternalMmapVector<u32> *>(&suppressed_stacks));\n+  }\n   ForEachChunk(CollectIgnoredCb, frontier);\n   ProcessGlobalRegions(frontier);\n   ProcessThreads(suspended_threads, frontier);\n@@ -532,27 +612,28 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n   }\n }\n \n-static void PrintMatchedSuppressions() {\n+void LeakSuppressionContext::PrintMatchedSuppressions() {\n   InternalMmapVector<Suppression *> matched;\n-  GetSuppressionContext()->GetMatched(&matched);\n+  context.GetMatched(&matched);\n   if (!matched.size())\n     return;\n   const char *line = \"-----------------------------------------------------\";\n   Printf(\"%s\\n\", line);\n   Printf(\"Suppressions used:\\n\");\n   Printf(\"  count      bytes template\\n\");\n-  for (uptr i = 0; i < matched.size(); i++)\n-    Printf(\"%7zu %10zu %s\\n\", static_cast<uptr>(atomic_load_relaxed(\n-        &matched[i]->hit_count)), matched[i]->weight, matched[i]->templ);\n+  for (uptr i = 0; i < matched.size(); i++) {\n+    Printf(\"%7zu %10zu %s\\n\",\n+           static_cast<uptr>(atomic_load_relaxed(&matched[i]->hit_count)),\n+           matched[i]->weight, matched[i]->templ);\n+  }\n   Printf(\"%s\\n\\n\", line);\n }\n \n static void ReportIfNotSuspended(ThreadContextBase *tctx, void *arg) {\n   const InternalMmapVector<tid_t> &suspended_threads =\n       *(const InternalMmapVector<tid_t> *)arg;\n   if (tctx->status == ThreadStatusRunning) {\n-    uptr i = InternalLowerBound(suspended_threads, 0, suspended_threads.size(),\n-                                tctx->os_id, CompareLess<int>());\n+    uptr i = InternalLowerBound(suspended_threads, tctx->os_id);\n     if (i >= suspended_threads.size() || suspended_threads[i] != tctx->os_id)\n       Report(\"Running thread %d was not suspended. False leaks are possible.\\n\",\n              tctx->os_id);\n@@ -595,43 +676,68 @@ static void CheckForLeaksCallback(const SuspendedThreadsList &suspended_threads,\n   param->success = true;\n }\n \n-static bool CheckForLeaks() {\n-  if (&__lsan_is_turned_off && __lsan_is_turned_off())\n-    return false;\n-  EnsureMainThreadIDIsCorrect();\n-  CheckForLeaksParam param;\n-  LockStuffAndStopTheWorld(CheckForLeaksCallback, &param);\n-\n-  if (!param.success) {\n-    Report(\"LeakSanitizer has encountered a fatal error.\\n\");\n-    Report(\n-        \"HINT: For debugging, try setting environment variable \"\n-        \"LSAN_OPTIONS=verbosity=1:log_threads=1\\n\");\n-    Report(\n-        \"HINT: LeakSanitizer does not work under ptrace (strace, gdb, etc)\\n\");\n-    Die();\n-  }\n-  param.leak_report.ApplySuppressions();\n-  uptr unsuppressed_count = param.leak_report.UnsuppressedLeakCount();\n-  if (unsuppressed_count > 0) {\n+static bool PrintResults(LeakReport &report) {\n+  uptr unsuppressed_count = report.UnsuppressedLeakCount();\n+  if (unsuppressed_count) {\n     Decorator d;\n-    Printf(\"\\n\"\n-           \"=================================================================\"\n-           \"\\n\");\n+    Printf(\n+        \"\\n\"\n+        \"=================================================================\"\n+        \"\\n\");\n     Printf(\"%s\", d.Error());\n     Report(\"ERROR: LeakSanitizer: detected memory leaks\\n\");\n     Printf(\"%s\", d.Default());\n-    param.leak_report.ReportTopLeaks(flags()->max_leaks);\n+    report.ReportTopLeaks(flags()->max_leaks);\n   }\n   if (common_flags()->print_suppressions)\n-    PrintMatchedSuppressions();\n+    GetSuppressionContext()->PrintMatchedSuppressions();\n   if (unsuppressed_count > 0) {\n-    param.leak_report.PrintSummary();\n+    report.PrintSummary();\n     return true;\n   }\n   return false;\n }\n \n+static bool CheckForLeaks() {\n+  if (&__lsan_is_turned_off && __lsan_is_turned_off())\n+    return false;\n+  // Inside LockStuffAndStopTheWorld we can't run symbolizer, so we can't match\n+  // suppressions. However if a stack id was previously suppressed, it should be\n+  // suppressed in future checks as well.\n+  for (int i = 0;; ++i) {\n+    EnsureMainThreadIDIsCorrect();\n+    CheckForLeaksParam param;\n+    LockStuffAndStopTheWorld(CheckForLeaksCallback, &param);\n+    if (!param.success) {\n+      Report(\"LeakSanitizer has encountered a fatal error.\\n\");\n+      Report(\n+          \"HINT: For debugging, try setting environment variable \"\n+          \"LSAN_OPTIONS=verbosity=1:log_threads=1\\n\");\n+      Report(\n+          \"HINT: LeakSanitizer does not work under ptrace (strace, gdb, \"\n+          \"etc)\\n\");\n+      Die();\n+    }\n+    // No new suppressions stacks, so rerun will not help and we can report.\n+    if (!param.leak_report.ApplySuppressions())\n+      return PrintResults(param.leak_report);\n+\n+    // No indirect leaks to report, so we are done here.\n+    if (!param.leak_report.IndirectUnsuppressedLeakCount())\n+      return PrintResults(param.leak_report);\n+\n+    if (i >= 8) {\n+      Report(\"WARNING: LeakSanitizer gave up on indirect leaks suppression.\\n\");\n+      return PrintResults(param.leak_report);\n+    }\n+\n+    // We found a new previously unseen suppressed call stack. Rerun to make\n+    // sure it does not hold indirect leaks.\n+    VReport(1, \"Rerun with %zu suppressed stacks.\",\n+            GetSuppressionContext()->GetSortedSuppressedStacks().size());\n+  }\n+}\n+\n static bool has_reported_leaks = false;\n bool HasReportedLeaks() { return has_reported_leaks; }\n \n@@ -652,34 +758,39 @@ static int DoRecoverableLeakCheck() {\n \n void DoRecoverableLeakCheckVoid() { DoRecoverableLeakCheck(); }\n \n-static Suppression *GetSuppressionForAddr(uptr addr) {\n+Suppression *LeakSuppressionContext::GetSuppressionForAddr(uptr addr) {\n   Suppression *s = nullptr;\n \n   // Suppress by module name.\n-  SuppressionContext *suppressions = GetSuppressionContext();\n   if (const char *module_name =\n           Symbolizer::GetOrInit()->GetModuleNameForPc(addr))\n-    if (suppressions->Match(module_name, kSuppressionLeak, &s))\n+    if (context.Match(module_name, kSuppressionLeak, &s))\n       return s;\n \n   // Suppress by file or function name.\n   SymbolizedStack *frames = Symbolizer::GetOrInit()->SymbolizePC(addr);\n   for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n-    if (suppressions->Match(cur->info.function, kSuppressionLeak, &s) ||\n-        suppressions->Match(cur->info.file, kSuppressionLeak, &s)) {\n+    if (context.Match(cur->info.function, kSuppressionLeak, &s) ||\n+        context.Match(cur->info.file, kSuppressionLeak, &s)) {\n       break;\n     }\n   }\n   frames->ClearAll();\n   return s;\n }\n \n-static Suppression *GetSuppressionForStack(u32 stack_trace_id) {\n+Suppression *LeakSuppressionContext::GetSuppressionForStack(\n+    u32 stack_trace_id) {\n+  LazyInit();\n   StackTrace stack = StackDepotGet(stack_trace_id);\n   for (uptr i = 0; i < stack.size; i++) {\n     Suppression *s = GetSuppressionForAddr(\n         StackTrace::GetPreviousInstructionPc(stack.trace[i]));\n-    if (s) return s;\n+    if (s) {\n+      suppressed_stacks_sorted = false;\n+      suppressed_stacks.push_back(stack_trace_id);\n+      return s;\n+    }\n   }\n   return nullptr;\n }\n@@ -784,22 +895,27 @@ void LeakReport::PrintSummary() {\n       bytes += leaks_[i].total_size;\n       allocations += leaks_[i].hit_count;\n   }\n-  InternalScopedString summary(kMaxSummaryLength);\n+  InternalScopedString summary;\n   summary.append(\"%zu byte(s) leaked in %zu allocation(s).\", bytes,\n                  allocations);\n   ReportErrorSummary(summary.data());\n }\n \n-void LeakReport::ApplySuppressions() {\n+uptr LeakReport::ApplySuppressions() {\n+  LeakSuppressionContext *suppressions = GetSuppressionContext();\n+  uptr new_suppressions = false;\n   for (uptr i = 0; i < leaks_.size(); i++) {\n-    Suppression *s = GetSuppressionForStack(leaks_[i].stack_trace_id);\n+    Suppression *s =\n+        suppressions->GetSuppressionForStack(leaks_[i].stack_trace_id);\n     if (s) {\n       s->weight += leaks_[i].total_size;\n       atomic_store_relaxed(&s->hit_count, atomic_load_relaxed(&s->hit_count) +\n           leaks_[i].hit_count);\n       leaks_[i].is_suppressed = true;\n+      ++new_suppressions;\n     }\n   }\n+  return new_suppressions;\n }\n \n uptr LeakReport::UnsuppressedLeakCount() {\n@@ -809,6 +925,14 @@ uptr LeakReport::UnsuppressedLeakCount() {\n   return result;\n }\n \n+uptr LeakReport::IndirectUnsuppressedLeakCount() {\n+  uptr result = 0;\n+  for (uptr i = 0; i < leaks_.size(); i++)\n+    if (!leaks_[i].is_suppressed && !leaks_[i].is_directly_leaked)\n+      result++;\n+  return result;\n+}\n+\n } // namespace __lsan\n #else // CAN_SANITIZE_LEAKS\n namespace __lsan {"}, {"sha": "fe855cf3754589856b151f86427792fc9b8c7f32", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -41,6 +41,8 @@\n #define CAN_SANITIZE_LEAKS 1\n #elif defined(__arm__) && SANITIZER_LINUX\n #define CAN_SANITIZE_LEAKS 1\n+#elif SANITIZER_RISCV64 && SANITIZER_LINUX\n+#define CAN_SANITIZE_LEAKS 1\n #elif SANITIZER_NETBSD || SANITIZER_FUCHSIA\n #define CAN_SANITIZE_LEAKS 1\n #else\n@@ -50,6 +52,7 @@\n namespace __sanitizer {\n class FlagParser;\n class ThreadRegistry;\n+class ThreadContextBase;\n struct DTLS;\n }\n \n@@ -63,8 +66,6 @@ enum ChunkTag {\n   kIgnored = 3\n };\n \n-const u32 kInvalidTid = (u32) -1;\n-\n struct Flags {\n #define LSAN_FLAG(Type, Name, DefaultValue, Description) Type Name;\n #include \"lsan_flags.inc\"\n@@ -103,8 +104,9 @@ class LeakReport {\n                       ChunkTag tag);\n   void ReportTopLeaks(uptr max_leaks);\n   void PrintSummary();\n-  void ApplySuppressions();\n+  uptr ApplySuppressions();\n   uptr UnsuppressedLeakCount();\n+  uptr IndirectUnsuppressedLeakCount();\n \n  private:\n   void PrintReportForLeak(uptr index);\n@@ -141,6 +143,7 @@ InternalMmapVector<RootRegion> const *GetRootRegions();\n void ScanRootRegion(Frontier *frontier, RootRegion const &region,\n                     uptr region_begin, uptr region_end, bool is_readable);\n void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg);\n+void GetAdditionalThreadContextPtrs(ThreadContextBase *tctx, void *ptrs);\n // Run stoptheworld while holding any platform-specific locks, as well as the\n // allocator and thread registry locks.\n void LockStuffAndStopTheWorld(StopTheWorldCallback callback,"}, {"sha": "2d35fa5b1cffdda2cf624eeaea3ce53b70417bf2", "filename": "libsanitizer/lsan/lsan_common_fuchsia.cpp", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_common_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_common_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_fuchsia.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -107,9 +107,7 @@ void LockStuffAndStopTheWorld(StopTheWorldCallback callback,\n     auto params = static_cast<const Params *>(data);\n     uptr begin = reinterpret_cast<uptr>(chunk);\n     uptr end = begin + size;\n-    auto i = __sanitizer::InternalLowerBound(params->allocator_caches, 0,\n-                                             params->allocator_caches.size(),\n-                                             begin, CompareLess<uptr>());\n+    auto i = __sanitizer::InternalLowerBound(params->allocator_caches, begin);\n     if (i < params->allocator_caches.size() &&\n         params->allocator_caches[i] >= begin &&\n         end - params->allocator_caches[i] <= sizeof(AllocatorCache)) {"}, {"sha": "e730d8f25f21eee4d1313c8a8c6cd3dc50905700", "filename": "libsanitizer/lsan/lsan_fuchsia.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_fuchsia.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -23,7 +23,7 @@\n \n namespace __lsan {\n \n-class ThreadContext : public ThreadContextLsanBase {\n+class ThreadContext final : public ThreadContextLsanBase {\n  public:\n   explicit ThreadContext(int tid);\n   void OnCreated(void *arg) override;"}, {"sha": "90a90a56c54c22222a3fb684e408b6d51103ceb5", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -460,7 +460,7 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr,\n   if (res == 0) {\n     int tid = ThreadCreate(GetCurrentThread(), *(uptr *)th,\n                            IsStateDetached(detached));\n-    CHECK_NE(tid, 0);\n+    CHECK_NE(tid, kMainTid);\n     atomic_store(&p.tid, tid, memory_order_release);\n     while (atomic_load(&p.tid, memory_order_acquire) != 0)\n       internal_sched_yield();"}, {"sha": "5d1c3f6260ddd0618b9e60d4b2c7b6f8938d20e5", "filename": "libsanitizer/lsan/lsan_posix.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_posix.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -48,7 +48,7 @@ void ThreadStart(u32 tid, tid_t os_id, ThreadType thread_type) {\n   OnStartedArgs args;\n   uptr stack_size = 0;\n   uptr tls_size = 0;\n-  GetThreadStackAndTls(tid == 0, &args.stack_begin, &stack_size,\n+  GetThreadStackAndTls(tid == kMainTid, &args.stack_begin, &stack_size,\n                        &args.tls_begin, &tls_size);\n   args.stack_end = args.stack_begin + stack_size;\n   args.tls_end = args.tls_begin + tls_size;\n@@ -75,8 +75,8 @@ bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n }\n \n void InitializeMainThread() {\n-  u32 tid = ThreadCreate(0, 0, true);\n-  CHECK_EQ(tid, 0);\n+  u32 tid = ThreadCreate(kMainTid, 0, true);\n+  CHECK_EQ(tid, kMainTid);\n   ThreadStart(tid, GetTid());\n }\n "}, {"sha": "8efb54a6fb778d1e24d19de0807d651ca06dcf04", "filename": "libsanitizer/lsan/lsan_thread.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Flsan%2Flsan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -94,7 +94,7 @@ void ThreadJoin(u32 tid) {\n }\n \n void EnsureMainThreadIDIsCorrect() {\n-  if (GetCurrentThread() == 0)\n+  if (GetCurrentThread() == kMainTid)\n     CurrentThreadContext()->os_id = GetTid();\n }\n "}, {"sha": "eb836bc47876398e7fff50def697ed5a7d55aa44", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -35,9 +35,9 @@ class CombinedAllocator {\n     secondary_.InitLinkerInitialized();\n   }\n \n-  void Init(s32 release_to_os_interval_ms) {\n+  void Init(s32 release_to_os_interval_ms, uptr heap_start = 0) {\n     stats_.Init();\n-    primary_.Init(release_to_os_interval_ms);\n+    primary_.Init(release_to_os_interval_ms, heap_start);\n     secondary_.Init();\n   }\n "}, {"sha": "fb5394cd39c4cc4f95d40daa5f5505c79d741053", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -119,7 +119,8 @@ class SizeClassAllocator32 {\n   typedef SizeClassAllocator32<Params> ThisT;\n   typedef SizeClassAllocator32LocalCache<ThisT> AllocatorCache;\n \n-  void Init(s32 release_to_os_interval_ms) {\n+  void Init(s32 release_to_os_interval_ms, uptr heap_start = 0) {\n+    CHECK(!heap_start);\n     possible_regions.Init();\n     internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));\n   }"}, {"sha": "db30e138154ac7113bef3722f74bf00ead653c2d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -19,7 +19,7 @@ template<class SizeClassAllocator> struct SizeClassAllocator64LocalCache;\n // The template parameter Params is a class containing the actual parameters.\n //\n // Space: a portion of address space of kSpaceSize bytes starting at SpaceBeg.\n-// If kSpaceBeg is ~0 then SpaceBeg is chosen dynamically my mmap.\n+// If kSpaceBeg is ~0 then SpaceBeg is chosen dynamically by mmap.\n // Otherwise SpaceBeg=kSpaceBeg (fixed address).\n // kSpaceSize is a power of two.\n // At the beginning the entire space is mprotect-ed, then small parts of it\n@@ -69,25 +69,45 @@ class SizeClassAllocator64 {\n     return base + (static_cast<uptr>(ptr32) << kCompactPtrScale);\n   }\n \n-  void Init(s32 release_to_os_interval_ms) {\n+  // If heap_start is nonzero, assumes kSpaceSize bytes are already mapped R/W\n+  // at heap_start and places the heap there.  This mode requires kSpaceBeg ==\n+  // ~(uptr)0.\n+  void Init(s32 release_to_os_interval_ms, uptr heap_start = 0) {\n     uptr TotalSpaceSize = kSpaceSize + AdditionalSize();\n-    if (kUsingConstantSpaceBeg) {\n-      CHECK(IsAligned(kSpaceBeg, SizeClassMap::kMaxSize));\n-      CHECK_EQ(kSpaceBeg, address_range.Init(TotalSpaceSize,\n-                                             PrimaryAllocatorName, kSpaceBeg));\n+    PremappedHeap = heap_start != 0;\n+    if (PremappedHeap) {\n+      CHECK(!kUsingConstantSpaceBeg);\n+      NonConstSpaceBeg = heap_start;\n+      uptr RegionInfoSize = AdditionalSize();\n+      RegionInfoSpace =\n+          address_range.Init(RegionInfoSize, PrimaryAllocatorName);\n+      CHECK_NE(RegionInfoSpace, ~(uptr)0);\n+      CHECK_EQ(RegionInfoSpace,\n+               address_range.MapOrDie(RegionInfoSpace, RegionInfoSize,\n+                                      \"SizeClassAllocator: region info\"));\n+      MapUnmapCallback().OnMap(RegionInfoSpace, RegionInfoSize);\n     } else {\n-      // Combined allocator expects that an 2^N allocation is always aligned to\n-      // 2^N. For this to work, the start of the space needs to be aligned as\n-      // high as the largest size class (which also needs to be a power of 2).\n-      NonConstSpaceBeg = address_range.InitAligned(\n-          TotalSpaceSize, SizeClassMap::kMaxSize, PrimaryAllocatorName);\n-      CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n+      if (kUsingConstantSpaceBeg) {\n+        CHECK(IsAligned(kSpaceBeg, SizeClassMap::kMaxSize));\n+        CHECK_EQ(kSpaceBeg,\n+                 address_range.Init(TotalSpaceSize, PrimaryAllocatorName,\n+                                    kSpaceBeg));\n+      } else {\n+        // Combined allocator expects that an 2^N allocation is always aligned\n+        // to 2^N. For this to work, the start of the space needs to be aligned\n+        // as high as the largest size class (which also needs to be a power of\n+        // 2).\n+        NonConstSpaceBeg = address_range.InitAligned(\n+            TotalSpaceSize, SizeClassMap::kMaxSize, PrimaryAllocatorName);\n+        CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n+      }\n+      RegionInfoSpace = SpaceEnd();\n+      MapWithCallbackOrDie(RegionInfoSpace, AdditionalSize(),\n+                           \"SizeClassAllocator: region info\");\n     }\n     SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n-    MapWithCallbackOrDie(SpaceEnd(), AdditionalSize(),\n-                         \"SizeClassAllocator: region info\");\n     // Check that the RegionInfo array is aligned on the CacheLine size.\n-    DCHECK_EQ(SpaceEnd() % kCacheLineSize, 0);\n+    DCHECK_EQ(RegionInfoSpace % kCacheLineSize, 0);\n   }\n \n   s32 ReleaseToOSIntervalMs() const {\n@@ -144,6 +164,17 @@ class SizeClassAllocator64 {\n     CompactPtrT *free_array = GetFreeArray(region_beg);\n \n     BlockingMutexLock l(&region->mutex);\n+#if SANITIZER_WINDOWS\n+    /* On Windows unmapping of memory during __sanitizer_purge_allocator is\n+    explicit and immediate, so unmapped regions must be explicitly mapped back\n+    in when they are accessed again. */\n+    if (region->rtoi.last_released_bytes > 0) {\n+      MmapFixedOrDie(region_beg, region->mapped_user,\n+                                      \"SizeClassAllocator: region data\");\n+      region->rtoi.n_freed_at_last_release = 0;\n+      region->rtoi.last_released_bytes = 0;\n+    }\n+#endif\n     if (UNLIKELY(region->num_freed_chunks < n_chunks)) {\n       if (UNLIKELY(!PopulateFreeArray(stat, class_id, region,\n                                       n_chunks - region->num_freed_chunks)))\n@@ -360,8 +391,7 @@ class SizeClassAllocator64 {\n     }\n     ~PackedCounterArray() {\n       if (buffer) {\n-        memory_mapper->UnmapPackedCounterArrayBuffer(\n-            reinterpret_cast<uptr>(buffer), buffer_size);\n+        memory_mapper->UnmapPackedCounterArrayBuffer(buffer, buffer_size);\n       }\n     }\n \n@@ -586,6 +616,11 @@ class SizeClassAllocator64 {\n \n   atomic_sint32_t release_to_os_interval_ms_;\n \n+  uptr RegionInfoSpace;\n+\n+  // True if the user has already mapped the entire heap R/W.\n+  bool PremappedHeap;\n+\n   struct Stats {\n     uptr n_allocated;\n     uptr n_freed;\n@@ -615,7 +650,7 @@ class SizeClassAllocator64 {\n \n   RegionInfo *GetRegionInfo(uptr class_id) const {\n     DCHECK_LT(class_id, kNumClasses);\n-    RegionInfo *regions = reinterpret_cast<RegionInfo *>(SpaceEnd());\n+    RegionInfo *regions = reinterpret_cast<RegionInfo *>(RegionInfoSpace);\n     return &regions[class_id];\n   }\n \n@@ -640,6 +675,9 @@ class SizeClassAllocator64 {\n   }\n \n   bool MapWithCallback(uptr beg, uptr size, const char *name) {\n+    if (PremappedHeap)\n+      return beg >= NonConstSpaceBeg &&\n+             beg + size <= NonConstSpaceBeg + kSpaceSize;\n     uptr mapped = address_range.Map(beg, size, name);\n     if (UNLIKELY(!mapped))\n       return false;\n@@ -649,11 +687,18 @@ class SizeClassAllocator64 {\n   }\n \n   void MapWithCallbackOrDie(uptr beg, uptr size, const char *name) {\n+    if (PremappedHeap) {\n+      CHECK_GE(beg, NonConstSpaceBeg);\n+      CHECK_LE(beg + size, NonConstSpaceBeg + kSpaceSize);\n+      return;\n+    }\n     CHECK_EQ(beg, address_range.MapOrDie(beg, size, name));\n     MapUnmapCallback().OnMap(beg, size);\n   }\n \n   void UnmapWithCallbackOrDie(uptr beg, uptr size) {\n+    if (PremappedHeap)\n+      return;\n     MapUnmapCallback().OnUnmap(beg, size);\n     address_range.Unmap(beg, size);\n   }\n@@ -792,17 +837,16 @@ class SizeClassAllocator64 {\n       return released_bytes;\n     }\n \n-    uptr MapPackedCounterArrayBuffer(uptr buffer_size) {\n+    void *MapPackedCounterArrayBuffer(uptr buffer_size) {\n       // TODO(alekseyshl): The idea to explore is to check if we have enough\n       // space between num_freed_chunks*sizeof(CompactPtrT) and\n       // mapped_free_array to fit buffer_size bytes and use that space instead\n       // of mapping a temporary one.\n-      return reinterpret_cast<uptr>(\n-          MmapOrDieOnFatalError(buffer_size, \"ReleaseToOSPageCounters\"));\n+      return MmapOrDieOnFatalError(buffer_size, \"ReleaseToOSPageCounters\");\n     }\n \n-    void UnmapPackedCounterArrayBuffer(uptr buffer, uptr buffer_size) {\n-      UnmapOrDie(reinterpret_cast<void *>(buffer), buffer_size);\n+    void UnmapPackedCounterArrayBuffer(void *buffer, uptr buffer_size) {\n+      UnmapOrDie(buffer, buffer_size);\n     }\n \n     // Releases [from, to) range of pages back to OS.\n@@ -823,6 +867,9 @@ class SizeClassAllocator64 {\n \n   // Attempts to release RAM occupied by freed chunks back to OS. The region is\n   // expected to be locked.\n+  //\n+  // TODO(morehouse): Support a callback on memory release so HWASan can release\n+  // aliases as well.\n   void MaybeReleaseToOS(uptr class_id, bool force) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     const uptr chunk_size = ClassIdToSize(class_id);"}, {"sha": "c50d13303edecd77bac4676502892cf6104f20a6", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_size_class_map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -24,7 +24,7 @@\n //             E.g. with kNumBits==3 all size classes after 2^kMidSizeLog\n //             look like 0b1xx0..0, where x is either 0 or 1.\n //\n-// Example: kNumBits=3, kMidSizeLog=4, kMidSizeLog=8, kMaxSizeLog=17:\n+// Example: kNumBits=3, kMinSizeLog=4, kMidSizeLog=8, kMaxSizeLog=17:\n //\n // Classes 1 - 16 correspond to sizes 16 to 256 (size = class_id * 16).\n // Next 4 classes: 256 + i * 64  (i = 1 to 4)."}, {"sha": "2b39097112d4ac83a36fbd92cd477a8edd955121", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_mips.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -41,7 +41,7 @@ inline atomic_uint64_t::Type atomic_fetch_add(volatile atomic_uint64_t *ptr,\n                                               atomic_uint64_t::Type val,\n                                               memory_order mo) {\n   DCHECK(mo &\n-         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+         (memory_order_relaxed | memory_order_release | memory_order_seq_cst));\n   DCHECK(!((uptr)ptr % sizeof(*ptr)));\n \n   atomic_uint64_t::Type ret;\n@@ -67,7 +67,7 @@ inline bool atomic_compare_exchange_strong(volatile atomic_uint64_t *ptr,\n                                            atomic_uint64_t::Type xchg,\n                                            memory_order mo) {\n   DCHECK(mo &\n-         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+         (memory_order_relaxed | memory_order_release | memory_order_seq_cst));\n   DCHECK(!((uptr)ptr % sizeof(*ptr)));\n \n   typedef atomic_uint64_t::Type Type;\n@@ -90,7 +90,7 @@ template <>\n inline atomic_uint64_t::Type atomic_load(const volatile atomic_uint64_t *ptr,\n                                          memory_order mo) {\n   DCHECK(mo &\n-         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+         (memory_order_relaxed | memory_order_release | memory_order_seq_cst));\n   DCHECK(!((uptr)ptr % sizeof(*ptr)));\n \n   atomic_uint64_t::Type zero = 0;\n@@ -103,7 +103,7 @@ template <>\n inline void atomic_store(volatile atomic_uint64_t *ptr, atomic_uint64_t::Type v,\n                          memory_order mo) {\n   DCHECK(mo &\n-         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+         (memory_order_relaxed | memory_order_release | memory_order_seq_cst));\n   DCHECK(!((uptr)ptr % sizeof(*ptr)));\n \n   __spin_lock(&lock.lock);"}, {"sha": "250ac39e13016b37798d327df51a782d86169eac", "filename": "libsanitizer/sanitizer_common/sanitizer_chained_origin_depot.cpp", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -0,0 +1,108 @@\n+//===-- sanitizer_chained_origin_depot.cpp --------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// A storage for chained origins.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_chained_origin_depot.h\"\n+\n+namespace __sanitizer {\n+\n+bool ChainedOriginDepot::ChainedOriginDepotNode::eq(\n+    u32 hash, const args_type &args) const {\n+  return here_id == args.here_id && prev_id == args.prev_id;\n+}\n+\n+uptr ChainedOriginDepot::ChainedOriginDepotNode::storage_size(\n+    const args_type &args) {\n+  return sizeof(ChainedOriginDepotNode);\n+}\n+\n+/* This is murmur2 hash for the 64->32 bit case.\n+   It does not behave all that well because the keys have a very biased\n+   distribution (I've seen 7-element buckets with the table only 14% full).\n+\n+   here_id is built of\n+   * (1 bits) Reserved, zero.\n+   * (8 bits) Part id = bits 13..20 of the hash value of here_id's key.\n+   * (23 bits) Sequential number (each part has each own sequence).\n+\n+   prev_id has either the same distribution as here_id (but with 3:8:21)\n+   split, or one of two reserved values (-1) or (-2). Either case can\n+   dominate depending on the workload.\n+*/\n+u32 ChainedOriginDepot::ChainedOriginDepotNode::hash(const args_type &args) {\n+  const u32 m = 0x5bd1e995;\n+  const u32 seed = 0x9747b28c;\n+  const u32 r = 24;\n+  u32 h = seed;\n+  u32 k = args.here_id;\n+  k *= m;\n+  k ^= k >> r;\n+  k *= m;\n+  h *= m;\n+  h ^= k;\n+\n+  k = args.prev_id;\n+  k *= m;\n+  k ^= k >> r;\n+  k *= m;\n+  h *= m;\n+  h ^= k;\n+\n+  h ^= h >> 13;\n+  h *= m;\n+  h ^= h >> 15;\n+  return h;\n+}\n+\n+bool ChainedOriginDepot::ChainedOriginDepotNode::is_valid(\n+    const args_type &args) {\n+  return true;\n+}\n+\n+void ChainedOriginDepot::ChainedOriginDepotNode::store(const args_type &args,\n+                                                       u32 other_hash) {\n+  here_id = args.here_id;\n+  prev_id = args.prev_id;\n+}\n+\n+ChainedOriginDepot::ChainedOriginDepotNode::args_type\n+ChainedOriginDepot::ChainedOriginDepotNode::load() const {\n+  args_type ret = {here_id, prev_id};\n+  return ret;\n+}\n+\n+ChainedOriginDepot::ChainedOriginDepotNode::Handle\n+ChainedOriginDepot::ChainedOriginDepotNode::get_handle() {\n+  return Handle(this);\n+}\n+\n+ChainedOriginDepot::ChainedOriginDepot() {}\n+\n+StackDepotStats *ChainedOriginDepot::GetStats() { return depot.GetStats(); }\n+\n+bool ChainedOriginDepot::Put(u32 here_id, u32 prev_id, u32 *new_id) {\n+  ChainedOriginDepotDesc desc = {here_id, prev_id};\n+  bool inserted;\n+  ChainedOriginDepotNode::Handle h = depot.Put(desc, &inserted);\n+  *new_id = h.valid() ? h.id() : 0;\n+  return inserted;\n+}\n+\n+u32 ChainedOriginDepot::Get(u32 id, u32 *other) {\n+  ChainedOriginDepotDesc desc = depot.Get(id);\n+  *other = desc.prev_id;\n+  return desc.here_id;\n+}\n+\n+void ChainedOriginDepot::LockAll() { depot.LockAll(); }\n+\n+void ChainedOriginDepot::UnlockAll() { depot.UnlockAll(); }\n+\n+}  // namespace __sanitizer"}, {"sha": "453cdf6b5449829048211ffe8ca57c3e6890495f", "filename": "libsanitizer/sanitizer_common/sanitizer_chained_origin_depot.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_chained_origin_depot.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -0,0 +1,88 @@\n+//===-- sanitizer_chained_origin_depot.h ------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// A storage for chained origins.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_CHAINED_ORIGIN_DEPOT_H\n+#define SANITIZER_CHAINED_ORIGIN_DEPOT_H\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_stackdepotbase.h\"\n+\n+namespace __sanitizer {\n+\n+class ChainedOriginDepot {\n+ public:\n+  ChainedOriginDepot();\n+\n+  // Gets the statistic of the origin chain storage.\n+  StackDepotStats *GetStats();\n+\n+  // Stores a chain with StackDepot ID here_id and previous chain ID prev_id.\n+  // If successful, returns true and the new chain id new_id.\n+  // If the same element already exists, returns false and sets new_id to the\n+  // existing ID.\n+  bool Put(u32 here_id, u32 prev_id, u32 *new_id);\n+\n+  // Retrieves the stored StackDepot ID for the given origin ID.\n+  u32 Get(u32 id, u32 *other);\n+\n+  void LockAll();\n+  void UnlockAll();\n+\n+ private:\n+  struct ChainedOriginDepotDesc {\n+    u32 here_id;\n+    u32 prev_id;\n+  };\n+\n+  struct ChainedOriginDepotNode {\n+    ChainedOriginDepotNode *link;\n+    u32 id;\n+    u32 here_id;\n+    u32 prev_id;\n+\n+    typedef ChainedOriginDepotDesc args_type;\n+\n+    bool eq(u32 hash, const args_type &args) const;\n+\n+    static uptr storage_size(const args_type &args);\n+\n+    static u32 hash(const args_type &args);\n+\n+    static bool is_valid(const args_type &args);\n+\n+    void store(const args_type &args, u32 other_hash);\n+\n+    args_type load() const;\n+\n+    struct Handle {\n+      ChainedOriginDepotNode *node_;\n+      Handle() : node_(nullptr) {}\n+      explicit Handle(ChainedOriginDepotNode *node) : node_(node) {}\n+      bool valid() { return node_; }\n+      u32 id() { return node_->id; }\n+      int here_id() { return node_->here_id; }\n+      int prev_id() { return node_->prev_id; }\n+    };\n+\n+    Handle get_handle();\n+\n+    typedef Handle handle_type;\n+  };\n+\n+  StackDepotBase<ChainedOriginDepotNode, 4, 20> depot;\n+\n+  ChainedOriginDepot(const ChainedOriginDepot &) = delete;\n+  void operator=(const ChainedOriginDepot &) = delete;\n+};\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_CHAINED_ORIGIN_DEPOT_H"}, {"sha": "33960d94a2f4af07cba32ea99423cac1a5e1d2d2", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -87,7 +87,7 @@ const char *StripModuleName(const char *module) {\n void ReportErrorSummary(const char *error_message, const char *alt_tool_name) {\n   if (!common_flags()->print_summary)\n     return;\n-  InternalScopedString buff(kMaxSummaryLength);\n+  InternalScopedString buff;\n   buff.append(\"SUMMARY: %s: %s\",\n               alt_tool_name ? alt_tool_name : SanitizerToolName, error_message);\n   __sanitizer_report_error_summary(buff.data());\n@@ -274,6 +274,14 @@ uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {\n   return name_len;\n }\n \n+uptr ReadBinaryDir(/*out*/ char *buf, uptr buf_len) {\n+  ReadBinaryNameCached(buf, buf_len);\n+  const char *exec_name_pos = StripModuleName(buf);\n+  uptr name_len = exec_name_pos - buf;\n+  buf[name_len] = '\\0';\n+  return name_len;\n+}\n+\n #if !SANITIZER_GO\n void PrintCmdline() {\n   char **argv = GetArgv();"}, {"sha": "7b65dd7dfb8ff0691c06398d590002a5ef026651", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -44,7 +44,7 @@ const uptr kMaxPathLength = 4096;\n \n const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n \n-static const uptr kErrorMessageBufferSize = 1 << 16;\n+const uptr kErrorMessageBufferSize = 1 << 16;\n \n // Denotes fake PC values that come from JIT/JAVA/etc.\n // For such PC values __tsan_symbolize_external_ex() will be called.\n@@ -135,6 +135,15 @@ void UnmapFromTo(uptr from, uptr to);\n uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n                       uptr min_shadow_base_alignment, uptr &high_mem_end);\n \n+// Let S = max(shadow_size, num_aliases * alias_size, ring_buffer_size).\n+// Reserves 2*S bytes of address space to the right of the returned address and\n+// ring_buffer_size bytes to the left.  The returned address is aligned to 2*S.\n+// Also creates num_aliases regions of accessible memory starting at offset S\n+// from the returned address.  Each region has size alias_size and is backed by\n+// the same physical memory.\n+uptr MapDynamicShadowAndAliases(uptr shadow_size, uptr alias_size,\n+                                uptr num_aliases, uptr ring_buffer_size);\n+\n // Reserve memory range [beg, end]. If madvise_shadow is true then apply\n // madvise (e.g. hugepages, core dumping) requested by options.\n void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name,\n@@ -248,6 +257,7 @@ const char *StripModuleName(const char *module);\n // OS\n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len);\n uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len);\n+uptr ReadBinaryDir(/*out*/ char *buf, uptr buf_len);\n uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len);\n const char *GetProcessName();\n void UpdateProcessName();\n@@ -294,8 +304,8 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                       const char *mmap_type, error_t err,\n                                       bool raw_report = false);\n \n-// Specific tools may override behavior of \"Die\" and \"CheckFailed\" functions\n-// to do tool-specific job.\n+// Specific tools may override behavior of \"Die\" function to do tool-specific\n+// job.\n typedef void (*DieCallbackType)(void);\n \n // It's possible to add several callbacks that would be run when \"Die\" is\n@@ -307,9 +317,7 @@ bool RemoveDieCallback(DieCallbackType callback);\n \n void SetUserDieCallback(DieCallbackType callback);\n \n-typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n-                                       u64, u64);\n-void SetCheckFailedCallback(CheckFailedCallbackType callback);\n+void SetCheckUnwindCallback(void (*callback)());\n \n // Callback will be called if soft_rss_limit_mb is given and the limit is\n // exceeded (exceeded==true) or if rss went down below the limit\n@@ -343,8 +351,6 @@ void ReportDeadlySignal(const SignalContext &sig, u32 tid,\n void SetAlternateSignalStack();\n void UnsetAlternateSignalStack();\n \n-// We don't want a summary too long.\n-const int kMaxSummaryLength = 1024;\n // Construct a one-line string:\n //   SUMMARY: SanitizerToolName: error_message\n // and pass it to __sanitizer_report_error_summary.\n@@ -441,8 +447,14 @@ inline uptr Log2(uptr x) {\n \n // Don't use std::min, std::max or std::swap, to minimize dependency\n // on libstdc++.\n-template<class T> T Min(T a, T b) { return a < b ? a : b; }\n-template<class T> T Max(T a, T b) { return a > b ? a : b; }\n+template <class T>\n+constexpr T Min(T a, T b) {\n+  return a < b ? a : b;\n+}\n+template <class T>\n+constexpr T Max(T a, T b) {\n+  return a > b ? a : b;\n+}\n template<class T> void Swap(T& a, T& b) {\n   T tmp = a;\n   a = b;\n@@ -467,6 +479,7 @@ inline int ToLower(int c) {\n template<typename T>\n class InternalMmapVectorNoCtor {\n  public:\n+  using value_type = T;\n   void Initialize(uptr initial_capacity) {\n     capacity_bytes_ = 0;\n     size_ = 0;\n@@ -590,21 +603,21 @@ class InternalMmapVector : public InternalMmapVectorNoCtor<T> {\n   InternalMmapVector &operator=(InternalMmapVector &&) = delete;\n };\n \n-class InternalScopedString : public InternalMmapVector<char> {\n+class InternalScopedString {\n  public:\n-  explicit InternalScopedString(uptr max_length)\n-      : InternalMmapVector<char>(max_length), length_(0) {\n-    (*this)[0] = '\\0';\n-  }\n-  uptr length() { return length_; }\n+  InternalScopedString() : buffer_(1) { buffer_[0] = '\\0'; }\n+\n+  uptr length() const { return buffer_.size() - 1; }\n   void clear() {\n-    (*this)[0] = '\\0';\n-    length_ = 0;\n+    buffer_.resize(1);\n+    buffer_[0] = '\\0';\n   }\n   void append(const char *format, ...);\n+  const char *data() const { return buffer_.data(); }\n+  char *data() { return buffer_.data(); }\n \n  private:\n-  uptr length_;\n+  InternalMmapVector<char> buffer_;\n };\n \n template <class T>\n@@ -651,9 +664,13 @@ void Sort(T *v, uptr size, Compare comp = {}) {\n \n // Works like std::lower_bound: finds the first element that is not less\n // than the val.\n-template <class Container, class Value, class Compare>\n-uptr InternalLowerBound(const Container &v, uptr first, uptr last,\n-                        const Value &val, Compare comp) {\n+template <class Container,\n+          class Compare = CompareLess<typename Container::value_type>>\n+uptr InternalLowerBound(const Container &v,\n+                        const typename Container::value_type &val,\n+                        Compare comp = {}) {\n+  uptr first = 0;\n+  uptr last = v.size();\n   while (last > first) {\n     uptr mid = (first + last) / 2;\n     if (comp(v[mid], val))\n@@ -677,6 +694,27 @@ enum ModuleArch {\n   kModuleArchRISCV64\n };\n \n+// Sorts and removes duplicates from the container.\n+template <class Container,\n+          class Compare = CompareLess<typename Container::value_type>>\n+void SortAndDedup(Container &v, Compare comp = {}) {\n+  Sort(v.data(), v.size(), comp);\n+  uptr size = v.size();\n+  if (size < 2)\n+    return;\n+  uptr last = 0;\n+  for (uptr i = 1; i < size; ++i) {\n+    if (comp(v[last], v[i])) {\n+      ++last;\n+      if (last != i)\n+        v[last] = v[i];\n+    } else {\n+      CHECK(!comp(v[i], v[last]));\n+    }\n+  }\n+  v.resize(last + 1);\n+}\n+\n // Opens the file 'file_name\" and reads up to 'max_len' bytes.\n // The resulting buffer is mmaped and stored in '*buff'.\n // Returns true if file was successfully opened and read."}, {"sha": "7867fccde390728350ca3d1bf31bf59ed5d2c259", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -239,7 +239,7 @@ extern const short *_tolower_tab_;\n     COMMON_INTERCEPT_FUNCTION(fn)\n #endif\n \n-#ifdef __GLIBC__\n+#if SANITIZER_GLIBC\n // If we could not find the versioned symbol, fall back to an unversioned\n // lookup. This is needed to work around a GLibc bug that causes dlsym\n // with RTLD_NEXT to return the oldest versioned symbol.\n@@ -2195,6 +2195,7 @@ INTERCEPTOR(int, clock_gettime, u32 clk_id, void *tp) {\n   }\n   return res;\n }\n+#if SANITIZER_GLIBC\n namespace __sanitizer {\n extern \"C\" {\n int real_clock_gettime(u32 clk_id, void *tp) {\n@@ -2204,6 +2205,7 @@ int real_clock_gettime(u32 clk_id, void *tp) {\n }\n }  // extern \"C\"\n }  // namespace __sanitizer\n+#endif\n INTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, clock_settime, clk_id, tp);\n@@ -3355,7 +3357,7 @@ INTERCEPTOR(char *, setlocale, int category, char *locale) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, locale, REAL(strlen)(locale) + 1);\n   char *res = REAL(setlocale)(category, locale);\n   if (res) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n     unpoison_ctype_arrays(ctx);\n   }\n   return res;\n@@ -4030,7 +4032,7 @@ INTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n-  int res = REAL(sigwait)(set, sig);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sigwait)(set, sig);\n   if (!res && sig) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sig, sizeof(*sig));\n   return res;\n }\n@@ -4047,7 +4049,7 @@ INTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n-  int res = REAL(sigwaitinfo)(set, info);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sigwaitinfo)(set, info);\n   if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n   return res;\n }\n@@ -4066,7 +4068,7 @@ INTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n-  int res = REAL(sigtimedwait)(set, info, timeout);\n+  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sigtimedwait)(set, info, timeout);\n   if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n   return res;\n }\n@@ -5995,6 +5997,9 @@ void unpoison_file(__sanitizer_FILE *fp) {\n   if (fp->_IO_read_base && fp->_IO_read_base < fp->_IO_read_end)\n     COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_IO_read_base,\n                                         fp->_IO_read_end - fp->_IO_read_base);\n+  if (fp->_IO_write_base && fp->_IO_write_base < fp->_IO_write_end)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_IO_write_base,\n+                                        fp->_IO_write_end - fp->_IO_write_base);\n #endif\n #endif  // SANITIZER_HAS_STRUCT_FILE\n }\n@@ -6221,6 +6226,8 @@ INTERCEPTOR(void, _obstack_newchunk, __sanitizer_obstack *obstack, int length) {\n INTERCEPTOR(int, fflush, __sanitizer_FILE *fp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fflush, fp);\n+  if (fp)\n+    unpoison_file(fp);\n   int res = REAL(fflush)(fp);\n   // FIXME: handle fp == NULL\n   if (fp) {\n@@ -6240,6 +6247,8 @@ INTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n   COMMON_INTERCEPTOR_ENTER(ctx, fclose, fp);\n   COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n   const FileMetadata *m = GetInterceptorMetadata(fp);\n+  if (fp)\n+    unpoison_file(fp);\n   int res = REAL(fclose)(fp);\n   if (m) {\n     COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);"}, {"sha": "7f181258eab52b11688d6857ddfe09acc98ba986", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -330,13 +330,17 @@ static void ioctl_table_fill() {\n   _(SOUND_PCM_WRITE_CHANNELS, WRITE, sizeof(int));\n   _(SOUND_PCM_WRITE_FILTER, WRITE, sizeof(int));\n   _(TCFLSH, NONE, 0);\n+#if SANITIZER_GLIBC\n   _(TCGETA, WRITE, struct_termio_sz);\n+#endif\n   _(TCGETS, WRITE, struct_termios_sz);\n   _(TCSBRK, NONE, 0);\n   _(TCSBRKP, NONE, 0);\n+#if SANITIZER_GLIBC\n   _(TCSETA, READ, struct_termio_sz);\n   _(TCSETAF, READ, struct_termio_sz);\n   _(TCSETAW, READ, struct_termio_sz);\n+#endif\n   _(TCSETS, READ, struct_termios_sz);\n   _(TCSETSF, READ, struct_termios_sz);\n   _(TCSETSW, READ, struct_termios_sz);\n@@ -364,7 +368,7 @@ static void ioctl_table_fill() {\n   _(VT_WAITACTIVE, NONE, 0);\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC\n   // _(SIOCDEVPLIP, WRITE, struct_ifreq_sz); // the same as EQL_ENSLAVE\n   _(CYGETDEFTHRESH, WRITE, sizeof(int));\n   _(CYGETDEFTIMEOUT, WRITE, sizeof(int));"}, {"sha": "72e482754b62b2b21bfd9af03c67056af4509411", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_aarch64.inc.S", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_aarch64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_aarch64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_aarch64.inc.S?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -1,6 +1,7 @@\n #if defined(__aarch64__) && defined(__linux__)\n \n #include \"sanitizer_common/sanitizer_asm.h\"\n+#include \"builtins/assembly.h\"\n \n ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n \n@@ -9,6 +10,7 @@ ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n ASM_WRAPPER_NAME(vfork):\n         // Save x30 in the off-stack spill area.\n+        hint    #25 // paciasp\n         stp     xzr, x30, [sp, #-16]!\n         bl      COMMON_INTERCEPTOR_SPILL_AREA\n         ldp     xzr, x30, [sp], 16\n@@ -33,11 +35,14 @@ ASM_WRAPPER_NAME(vfork):\n         bl     COMMON_INTERCEPTOR_SPILL_AREA\n         ldr    x30, [x0]\n         ldp    x0, xzr, [sp], 16\n+        hint   #29 // autiasp\n \n         ret\n ASM_SIZE(vfork)\n \n .weak vfork\n .set vfork, ASM_WRAPPER_NAME(vfork)\n \n+GNU_PROPERTY_BTI_PAC\n+\n #endif"}, {"sha": "932e5478616d58c439b608a17e95e4769ac5b850", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface.inc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -13,6 +13,7 @@ INTERFACE_FUNCTION(__sanitizer_contiguous_container_find_bad_address)\n INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n INTERFACE_FUNCTION(__sanitizer_set_report_path)\n INTERFACE_FUNCTION(__sanitizer_set_report_fd)\n+INTERFACE_FUNCTION(__sanitizer_get_report_path)\n INTERFACE_FUNCTION(__sanitizer_verify_contiguous_container)\n INTERFACE_WEAK_FUNCTION(__sanitizer_on_print)\n INTERFACE_WEAK_FUNCTION(__sanitizer_report_error_summary)"}, {"sha": "1037938f3d336f1c3ba2886265cba0bf910f801c", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -92,14 +92,13 @@ void *BackgroundThread(void *arg) {\n #endif\n \n void WriteToSyslog(const char *msg) {\n-  InternalScopedString msg_copy(kErrorMessageBufferSize);\n+  InternalScopedString msg_copy;\n   msg_copy.append(\"%s\", msg);\n-  char *p = msg_copy.data();\n-  char *q;\n+  const char *p = msg_copy.data();\n \n   // Print one line at a time.\n   // syslog, at least on Android, has an implicit message length limit.\n-  while ((q = internal_strchr(p, '\\n'))) {\n+  while (char* q = internal_strchr(p, '\\n')) {\n     *q = '\\0';\n     WriteOneLineToSyslog(p);\n     p = q + 1;"}, {"sha": "0b92dccde4a144c988efed2cbb647477bfb2fb10", "filename": "libsanitizer/sanitizer_common/sanitizer_file.cpp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -58,6 +58,9 @@ void ReportFile::ReopenIfNecessary() {\n   } else {\n     internal_snprintf(full_path, kMaxPathLength, \"%s.%zu\", path_prefix, pid);\n   }\n+  if (common_flags()->log_suffix) {\n+    internal_strlcat(full_path, common_flags()->log_suffix, kMaxPathLength);\n+  }\n   error_t err;\n   fd = OpenFile(full_path, WrOnly, &err);\n   if (fd == kInvalidFd) {\n@@ -95,6 +98,12 @@ void ReportFile::SetReportPath(const char *path) {\n   }\n }\n \n+const char *ReportFile::GetReportPath() {\n+  SpinMutexLock l(mu);\n+  ReopenIfNecessary();\n+  return full_path;\n+}\n+\n bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n                       uptr *read_len, uptr max_len, error_t *errno_p) {\n   *buff = nullptr;\n@@ -213,6 +222,10 @@ void __sanitizer_set_report_fd(void *fd) {\n   report_file.fd = (fd_t)reinterpret_cast<uptr>(fd);\n   report_file.fd_pid = internal_getpid();\n }\n+\n+const char *__sanitizer_get_report_path() {\n+  return report_file.GetReportPath();\n+}\n } // extern \"C\"\n \n #endif  // !SANITIZER_FUCHSIA"}, {"sha": "08671ab67d0f54dd5640961243d57b41386d8de5", "filename": "libsanitizer/sanitizer_common/sanitizer_file.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -26,6 +26,7 @@ struct ReportFile {\n   void Write(const char *buffer, uptr length);\n   bool SupportsColors();\n   void SetReportPath(const char *path);\n+  const char *GetReportPath();\n \n   // Don't use fields directly. They are only declared public to allow\n   // aggregate initialization."}, {"sha": "d52e96a7c381eb2ad7cefb8774763d0cc74dfcf4", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cpp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -35,6 +35,7 @@ void CommonFlags::CopyFrom(const CommonFlags &other) {\n // Copy the string from \"s\" to \"out\", making the following substitutions:\n // %b = binary basename\n // %p = pid\n+// %d = binary directory\n void SubstituteForFlagValue(const char *s, char *out, uptr out_size) {\n   char *out_end = out + out_size;\n   while (*s && out < out_end - 1) {\n@@ -64,6 +65,12 @@ void SubstituteForFlagValue(const char *s, char *out, uptr out_size) {\n         s += 2; // skip \"%p\"\n         break;\n       }\n+      case 'd': {\n+        uptr len = ReadBinaryDir(out, out_end - out);\n+        out += len;\n+        s += 2;  // skip \"%d\"\n+        break;\n+      }\n       default:\n         *out++ = *s++;\n         break;"}, {"sha": "3bc44c6b1eb1a12820c0a8ebffec32c57b3bbe67", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -59,6 +59,8 @@ COMMON_FLAG(\n     bool, log_exe_name, false,\n     \"Mention name of executable when reporting error and \"\n     \"append executable name to logs (as in \\\"log_path.exe_name.pid\\\").\")\n+COMMON_FLAG(const char *, log_suffix, nullptr,\n+            \"String to append to log file name, e.g. \\\".txt\\\".\")\n COMMON_FLAG(\n     bool, log_to_syslog, (bool)SANITIZER_ANDROID || (bool)SANITIZER_MAC,\n     \"Write all sanitizer output to syslog in addition to other means of \""}, {"sha": "4f692f99c207cda08c6b6c23f7b35c457b3722c2", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cpp", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -14,7 +14,6 @@\n #include \"sanitizer_fuchsia.h\"\n #if SANITIZER_FUCHSIA\n \n-#include <limits.h>\n #include <pthread.h>\n #include <stdlib.h>\n #include <unistd.h>\n@@ -69,9 +68,7 @@ uptr internal_getpid() {\n   return pid;\n }\n \n-int internal_dlinfo(void *handle, int request, void *p) {\n-  UNIMPLEMENTED();\n-}\n+int internal_dlinfo(void *handle, int request, void *p) { UNIMPLEMENTED(); }\n \n uptr GetThreadSelf() { return reinterpret_cast<uptr>(thrd_current()); }\n \n@@ -153,9 +150,9 @@ void BlockingMutex::CheckLocked() {\n   CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n }\n \n-uptr GetPageSize() { return PAGE_SIZE; }\n+uptr GetPageSize() { return _zx_system_get_page_size(); }\n \n-uptr GetMmapGranularity() { return PAGE_SIZE; }\n+uptr GetMmapGranularity() { return _zx_system_get_page_size(); }\n \n sanitizer_shadow_bounds_t ShadowBounds;\n \n@@ -168,7 +165,7 @@ uptr GetMaxVirtualAddress() { return GetMaxUserVirtualAddress(); }\n \n static void *DoAnonymousMmapOrDie(uptr size, const char *mem_type,\n                                   bool raw_report, bool die_for_nomem) {\n-  size = RoundUpTo(size, PAGE_SIZE);\n+  size = RoundUpTo(size, GetPageSize());\n \n   zx_handle_t vmo;\n   zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n@@ -214,15 +211,14 @@ void *MmapOrDieOnFatalError(uptr size, const char *mem_type) {\n \n uptr ReservedAddressRange::Init(uptr init_size, const char *name,\n                                 uptr fixed_addr) {\n-  init_size = RoundUpTo(init_size, PAGE_SIZE);\n+  init_size = RoundUpTo(init_size, GetPageSize());\n   DCHECK_EQ(os_handle_, ZX_HANDLE_INVALID);\n   uintptr_t base;\n   zx_handle_t vmar;\n-  zx_status_t status =\n-      _zx_vmar_allocate(\n-          _zx_vmar_root_self(),\n-          ZX_VM_CAN_MAP_READ | ZX_VM_CAN_MAP_WRITE | ZX_VM_CAN_MAP_SPECIFIC,\n-          0, init_size, &vmar, &base);\n+  zx_status_t status = _zx_vmar_allocate(\n+      _zx_vmar_root_self(),\n+      ZX_VM_CAN_MAP_READ | ZX_VM_CAN_MAP_WRITE | ZX_VM_CAN_MAP_SPECIFIC, 0,\n+      init_size, &vmar, &base);\n   if (status != ZX_OK)\n     ReportMmapFailureAndDie(init_size, name, \"zx_vmar_allocate\", status);\n   base_ = reinterpret_cast<void *>(base);\n@@ -236,7 +232,7 @@ uptr ReservedAddressRange::Init(uptr init_size, const char *name,\n static uptr DoMmapFixedOrDie(zx_handle_t vmar, uptr fixed_addr, uptr map_size,\n                              void *base, const char *name, bool die_for_nomem) {\n   uptr offset = fixed_addr - reinterpret_cast<uptr>(base);\n-  map_size = RoundUpTo(map_size, PAGE_SIZE);\n+  map_size = RoundUpTo(map_size, GetPageSize());\n   zx_handle_t vmo;\n   zx_status_t status = _zx_vmo_create(map_size, 0, &vmo);\n   if (status != ZX_OK) {\n@@ -264,19 +260,19 @@ static uptr DoMmapFixedOrDie(zx_handle_t vmar, uptr fixed_addr, uptr map_size,\n \n uptr ReservedAddressRange::Map(uptr fixed_addr, uptr map_size,\n                                const char *name) {\n-  return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_,\n-                          name_, false);\n+  return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_, name_,\n+                          false);\n }\n \n uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr map_size,\n                                     const char *name) {\n-  return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_,\n-                          name_, true);\n+  return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_, name_, true);\n }\n \n void UnmapOrDieVmar(void *addr, uptr size, zx_handle_t target_vmar) {\n-  if (!addr || !size) return;\n-  size = RoundUpTo(size, PAGE_SIZE);\n+  if (!addr || !size)\n+    return;\n+  size = RoundUpTo(size, GetPageSize());\n \n   zx_status_t status =\n       _zx_vmar_unmap(target_vmar, reinterpret_cast<uintptr_t>(addr), size);\n@@ -316,7 +312,7 @@ void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name) {\n \n void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n                                    const char *mem_type) {\n-  CHECK_GE(size, PAGE_SIZE);\n+  CHECK_GE(size, GetPageSize());\n   CHECK(IsPowerOfTwo(size));\n   CHECK(IsPowerOfTwo(alignment));\n \n@@ -356,7 +352,8 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n             _zx_vmar_root_self(),\n             ZX_VM_PERM_READ | ZX_VM_PERM_WRITE | ZX_VM_SPECIFIC_OVERWRITE,\n             addr - info.base, vmo, 0, size, &new_addr);\n-        if (status == ZX_OK) CHECK_EQ(new_addr, addr);\n+        if (status == ZX_OK)\n+          CHECK_EQ(new_addr, addr);\n       }\n     }\n     if (status == ZX_OK && addr != map_addr)\n@@ -381,9 +378,18 @@ void UnmapOrDie(void *addr, uptr size) {\n   UnmapOrDieVmar(addr, size, _zx_vmar_root_self());\n }\n \n-// This is used on the shadow mapping, which cannot be changed.\n-// Zircon doesn't have anything like MADV_DONTNEED.\n-void ReleaseMemoryPagesToOS(uptr beg, uptr end) {}\n+void ReleaseMemoryPagesToOS(uptr beg, uptr end) {\n+  uptr beg_aligned = RoundUpTo(beg, GetPageSize());\n+  uptr end_aligned = RoundDownTo(end, GetPageSize());\n+  if (beg_aligned < end_aligned) {\n+    zx_handle_t root_vmar = _zx_vmar_root_self();\n+    CHECK_NE(root_vmar, ZX_HANDLE_INVALID);\n+    zx_status_t status =\n+        _zx_vmar_op_range(root_vmar, ZX_VMAR_OP_DECOMMIT, beg_aligned,\n+                          end_aligned - beg_aligned, nullptr, 0);\n+    CHECK_EQ(status, ZX_OK);\n+  }\n+}\n \n void DumpProcessMap() {\n   // TODO(mcgrathr): write it\n@@ -412,8 +418,9 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n     uint64_t vmo_size;\n     status = _zx_vmo_get_size(vmo, &vmo_size);\n     if (status == ZX_OK) {\n-      if (vmo_size < max_len) max_len = vmo_size;\n-      size_t map_size = RoundUpTo(max_len, PAGE_SIZE);\n+      if (vmo_size < max_len)\n+        max_len = vmo_size;\n+      size_t map_size = RoundUpTo(max_len, GetPageSize());\n       uintptr_t addr;\n       status = _zx_vmar_map(_zx_vmar_root_self(), ZX_VM_PERM_READ, 0, vmo, 0,\n                             map_size, &addr);\n@@ -425,7 +432,8 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n     }\n     _zx_handle_close(vmo);\n   }\n-  if (status != ZX_OK && errno_p) *errno_p = status;\n+  if (status != ZX_OK && errno_p)\n+    *errno_p = status;\n   return status == ZX_OK;\n }\n \n@@ -499,9 +507,7 @@ bool GetRandom(void *buffer, uptr length, bool blocking) {\n   return true;\n }\n \n-u32 GetNumberOfCPUs() {\n-  return zx_system_get_num_cpus();\n-}\n+u32 GetNumberOfCPUs() { return zx_system_get_num_cpus(); }\n \n uptr GetRSS() { UNIMPLEMENTED(); }\n \n@@ -529,6 +535,10 @@ void __sanitizer_set_report_path(const char *path) {\n void __sanitizer_set_report_fd(void *fd) {\n   UNREACHABLE(\"not available on Fuchsia\");\n }\n+\n+const char *__sanitizer_get_report_path() {\n+  UNREACHABLE(\"not available on Fuchsia\");\n+}\n }  // extern \"C\"\n \n #endif  // SANITIZER_FUCHSIA"}, {"sha": "0b001c1c483007e3349e576ffa0a40d09d372fbd", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -28,6 +28,10 @@ extern \"C\" {\n   // (casted to void *).\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_set_report_fd(void *fd);\n+  // Get the current full report file path, if a path was specified by\n+  // an earlier call to __sanitizer_set_report_path. Returns null otherwise.\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  const char *__sanitizer_get_report_path();\n \n   typedef struct {\n       int coverage_sandboxed;"}, {"sha": "84053fec2649a950e36c3d012983eeb6ce86cb65", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -409,6 +409,9 @@ inline void Trap() {\n     (void)enable_fp;                      \\\n   } while (0)\n \n+constexpr u32 kInvalidTid = -1;\n+constexpr u32 kMainTid = 0;\n+\n }  // namespace __sanitizer\n \n namespace __asan {"}, {"sha": "a65d3d896e33e180a2acf0d4c1b2ad1211f7c2a9", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -38,7 +38,7 @@ void LibIgnore::AddIgnoredLibrary(const char *name_templ) {\n void LibIgnore::OnLibraryLoaded(const char *name) {\n   BlockingMutexLock lock(&mutex_);\n   // Try to match suppressions with symlink target.\n-  InternalScopedString buf(kMaxPathLength);\n+  InternalMmapVector<char> buf(kMaxPathLength);\n   if (name && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&\n       buf[0]) {\n     for (uptr i = 0; i < count_; i++) {"}, {"sha": "b371477755fd3ba29eb5499ff156bd9f716b1d90", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -183,6 +183,14 @@ uptr internal_munmap(void *addr, uptr length) {\n   return internal_syscall(SYSCALL(munmap), (uptr)addr, length);\n }\n \n+#if SANITIZER_LINUX\n+uptr internal_mremap(void *old_address, uptr old_size, uptr new_size, int flags,\n+                     void *new_address) {\n+  return internal_syscall(SYSCALL(mremap), (uptr)old_address, old_size,\n+                          new_size, flags, (uptr)new_address);\n+}\n+#endif\n+\n int internal_mprotect(void *addr, uptr length, int prot) {\n   return internal_syscall(SYSCALL(mprotect), (uptr)addr, length, prot);\n }\n@@ -489,22 +497,24 @@ int TgKill(pid_t pid, tid_t tid, int sig) {\n }\n #endif\n \n-#if !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n+#if SANITIZER_GLIBC\n u64 NanoTime() {\n-#if SANITIZER_FREEBSD\n-  timeval tv;\n-#else\n   kernel_timeval tv;\n-#endif\n   internal_memset(&tv, 0, sizeof(tv));\n   internal_syscall(SYSCALL(gettimeofday), &tv, 0);\n-  return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n+  return (u64)tv.tv_sec * 1000 * 1000 * 1000 + tv.tv_usec * 1000;\n }\n-\n+// Used by real_clock_gettime.\n uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp) {\n   return internal_syscall(SYSCALL(clock_gettime), clk_id, tp);\n }\n-#endif  // !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n+#elif !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n+u64 NanoTime() {\n+  struct timespec ts;\n+  clock_gettime(CLOCK_REALTIME, &ts);\n+  return (u64)ts.tv_sec * 1000 * 1000 * 1000 + ts.tv_nsec;\n+}\n+#endif\n \n // Like getenv, but reads env directly from /proc (on Linux) or parses the\n // 'environ' array (on some others) and does not use libc. This function\n@@ -1334,50 +1344,42 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n #elif SANITIZER_RISCV64\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr) {\n-  long long res;\n   if (!fn || !child_stack)\n     return -EINVAL;\n+\n   CHECK_EQ(0, (uptr)child_stack % 16);\n-  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n-  ((unsigned long long *)child_stack)[0] = (uptr)fn;\n-  ((unsigned long long *)child_stack)[1] = (uptr)arg;\n \n-  register int (*__fn)(void *) __asm__(\"a0\") = fn;\n+  register int res __asm__(\"a0\");\n+  register int __flags __asm__(\"a0\") = flags;\n   register void *__stack __asm__(\"a1\") = child_stack;\n-  register int __flags __asm__(\"a2\") = flags;\n-  register void *__arg __asm__(\"a3\") = arg;\n-  register int *__ptid __asm__(\"a4\") = parent_tidptr;\n-  register void *__tls __asm__(\"a5\") = newtls;\n-  register int *__ctid __asm__(\"a6\") = child_tidptr;\n+  register int *__ptid __asm__(\"a2\") = parent_tidptr;\n+  register void *__tls __asm__(\"a3\") = newtls;\n+  register int *__ctid __asm__(\"a4\") = child_tidptr;\n+  register int (*__fn)(void *) __asm__(\"a5\") = fn;\n+  register void *__arg __asm__(\"a6\") = arg;\n+  register int nr_clone __asm__(\"a7\") = __NR_clone;\n \n   __asm__ __volatile__(\n-      \"mv a0,a2\\n\"          /* flags  */\n-      \"mv a2,a4\\n\"          /* ptid  */\n-      \"mv a3,a5\\n\"          /* tls  */\n-      \"mv a4,a6\\n\"          /* ctid  */\n-      \"addi a7, zero, %9\\n\" /* clone  */\n-\n       \"ecall\\n\"\n \n-      /* if (%r0 != 0)\n-       *   return %r0;\n+      /* if (a0 != 0)\n+       *   return a0;\n        */\n       \"bnez a0, 1f\\n\"\n \n-      /* In the child, now. Call \"fn(arg)\". */\n-      \"ld  a0,  8(sp)\\n\"\n-      \"ld  a1, 16(sp)\\n\"\n-      \"jalr a1\\n\"\n+      // In the child, now. Call \"fn(arg)\".\n+      \"mv a0, a6\\n\"\n+      \"jalr a5\\n\"\n \n-      /* Call _exit(%r0).  */\n-      \"addi  a7, zero, %10\\n\"\n+      // Call _exit(a0).\n+      \"addi a7, zero, %9\\n\"\n       \"ecall\\n\"\n       \"1:\\n\"\n \n       : \"=r\"(res)\n-      : \"i\"(-EINVAL), \"r\"(__fn), \"r\"(__stack), \"r\"(__flags), \"r\"(__arg),\n-        \"r\"(__ptid), \"r\"(__tls), \"r\"(__ctid), \"i\"(__NR_clone), \"i\"(__NR_exit)\n-      : \"ra\", \"memory\");\n+      : \"0\"(__flags), \"r\"(__stack), \"r\"(__ptid), \"r\"(__tls), \"r\"(__ctid),\n+        \"r\"(__fn), \"r\"(__arg), \"r\"(nr_clone), \"i\"(__NR_exit)\n+      : \"memory\");\n   return res;\n }\n #elif defined(__aarch64__)"}, {"sha": "9a23fcfb3b93d9e09aa5e932816f4eb35b55ab04", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -49,7 +49,9 @@ uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n uptr internal_sigaltstack(const void* ss, void* oss);\n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n     __sanitizer_sigset_t *oldset);\n+#if SANITIZER_GLIBC\n uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp);\n+#endif\n \n // Linux-only syscalls.\n #if SANITIZER_LINUX\n@@ -96,7 +98,6 @@ class ThreadLister {\n // Exposed for testing.\n uptr ThreadDescriptorSize();\n uptr ThreadSelf();\n-uptr ThreadSelfOffset();\n \n // Matches a library's file name against a base name (stripping path and version\n // information)."}, {"sha": "572aa86fa53910ae0ab8157ffdf2656c0f23cb80", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 249, "deletions": 198, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -36,6 +36,7 @@\n #include <link.h>\n #include <pthread.h>\n #include <signal.h>\n+#include <sys/mman.h>\n #include <sys/resource.h>\n #include <syslog.h>\n \n@@ -48,6 +49,10 @@\n #include <osreldate.h>\n #include <sys/sysctl.h>\n #define pthread_getattr_np pthread_attr_get_np\n+// The MAP_NORESERVE define has been removed in FreeBSD 11.x, and even before\n+// that, it was never implemented. So just define it to zero.\n+#undef MAP_NORESERVE\n+#define MAP_NORESERVE 0\n #endif\n \n #if SANITIZER_NETBSD\n@@ -183,85 +188,35 @@ __attribute__((unused)) static bool GetLibcVersion(int *major, int *minor,\n #endif\n }\n \n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO && \\\n-    !SANITIZER_NETBSD && !SANITIZER_SOLARIS\n-static uptr g_tls_size;\n+// True if we can use dlpi_tls_data. glibc before 2.25 may leave NULL (BZ\n+// #19826) so dlpi_tls_data cannot be used.\n+//\n+// musl before 1.2.3 and FreeBSD as of 12.2 incorrectly set dlpi_tls_data to\n+// the TLS initialization image\n+// https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=254774\n+__attribute__((unused)) static int g_use_dlpi_tls_data;\n \n-#ifdef __i386__\n-#define CHECK_GET_TLS_STATIC_INFO_VERSION (!__GLIBC_PREREQ(2, 27))\n-#else\n-#define CHECK_GET_TLS_STATIC_INFO_VERSION 0\n-#endif\n+#if SANITIZER_GLIBC && !SANITIZER_GO\n+__attribute__((unused)) static uptr g_tls_size;\n+void InitTlsSize() {\n+  int major, minor, patch;\n+  g_use_dlpi_tls_data =\n+      GetLibcVersion(&major, &minor, &patch) && major == 2 && minor >= 25;\n \n-#if CHECK_GET_TLS_STATIC_INFO_VERSION\n-#define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n-#else\n-#define DL_INTERNAL_FUNCTION\n+#if defined(__x86_64__) || defined(__powerpc64__)\n+  void *get_tls_static_info = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n+  size_t tls_align;\n+  ((void (*)(size_t *, size_t *))get_tls_static_info)(&g_tls_size, &tls_align);\n #endif\n-\n-namespace {\n-struct GetTlsStaticInfoCall {\n-  typedef void (*get_tls_func)(size_t*, size_t*);\n-};\n-struct GetTlsStaticInfoRegparmCall {\n-  typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;\n-};\n-\n-template <typename T>\n-void CallGetTls(void* ptr, size_t* size, size_t* align) {\n-  typename T::get_tls_func get_tls;\n-  CHECK_EQ(sizeof(get_tls), sizeof(ptr));\n-  internal_memcpy(&get_tls, &ptr, sizeof(ptr));\n-  CHECK_NE(get_tls, 0);\n-  get_tls(size, align);\n-}\n-\n-bool CmpLibcVersion(int major, int minor, int patch) {\n-  int ma;\n-  int mi;\n-  int pa;\n-  if (!GetLibcVersion(&ma, &mi, &pa))\n-    return false;\n-  if (ma > major)\n-    return true;\n-  if (ma < major)\n-    return false;\n-  if (mi > minor)\n-    return true;\n-  if (mi < minor)\n-    return false;\n-  return pa >= patch;\n-}\n-\n-}  // namespace\n-\n-void InitTlsSize() {\n-  // all current supported platforms have 16 bytes stack alignment\n-  const size_t kStackAlign = 16;\n-  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n-  size_t tls_size = 0;\n-  size_t tls_align = 0;\n-  // On i?86, _dl_get_tls_static_info used to be internal_function, i.e.\n-  // __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal\n-  // function in 2.27 and later.\n-  if (CHECK_GET_TLS_STATIC_INFO_VERSION && !CmpLibcVersion(2, 27, 0))\n-    CallGetTls<GetTlsStaticInfoRegparmCall>(get_tls_static_info_ptr,\n-                                            &tls_size, &tls_align);\n-  else\n-    CallGetTls<GetTlsStaticInfoCall>(get_tls_static_info_ptr,\n-                                     &tls_size, &tls_align);\n-  if (tls_align < kStackAlign)\n-    tls_align = kStackAlign;\n-  g_tls_size = RoundUpTo(tls_size, tls_align);\n }\n #else\n void InitTlsSize() { }\n-#endif\n+#endif  // SANITIZER_GLIBC && !SANITIZER_GO\n \n-#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) ||       \\\n-     defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__) || \\\n-     defined(__arm__) || SANITIZER_RISCV64) &&                              \\\n-    SANITIZER_LINUX && !SANITIZER_ANDROID\n+// On glibc x86_64, ThreadDescriptorSize() needs to be precise due to the usage\n+// of g_tls_size. On other targets, ThreadDescriptorSize() is only used by lsan\n+// to get the pointer to thread-specific data keys in the thread control block.\n+#if (SANITIZER_FREEBSD || SANITIZER_LINUX) && !SANITIZER_ANDROID\n // sizeof(struct pthread) from glibc.\n static atomic_uintptr_t thread_descriptor_size;\n \n@@ -294,9 +249,18 @@ uptr ThreadDescriptorSize() {\n       val = FIRST_32_SECOND_64(1168, 2288);\n     else if (minor <= 14)\n       val = FIRST_32_SECOND_64(1168, 2304);\n-    else\n+    else if (minor < 32)  // Unknown version\n       val = FIRST_32_SECOND_64(1216, 2304);\n+    else  // minor == 32\n+      val = FIRST_32_SECOND_64(1344, 2496);\n   }\n+#elif defined(__s390__) || defined(__sparc__)\n+  // The size of a prefix of TCB including pthread::{specific_1stblock,specific}\n+  // suffices. Just return offsetof(struct pthread, specific_used), which hasn't\n+  // changed since 2007-05. Technically this applies to i386/x86_64 as well but\n+  // we call _dl_get_tls_static_info and need the precise size of struct\n+  // pthread.\n+  return FIRST_32_SECOND_64(524, 1552);\n #elif defined(__mips__)\n   // TODO(sagarthakur): add more values as per different glibc versions.\n   val = FIRST_32_SECOND_64(1152, 1776);\n@@ -320,21 +284,12 @@ uptr ThreadDescriptorSize() {\n   val = 1776;\n #elif defined(__powerpc64__)\n   val = 1776; // from glibc.ppc64le 2.20-8.fc21\n-#elif defined(__s390__)\n-  val = FIRST_32_SECOND_64(1152, 1776); // valid for glibc 2.22\n #endif\n   if (val)\n     atomic_store_relaxed(&thread_descriptor_size, val);\n   return val;\n }\n \n-// The offset at which pointer to self is located in the thread descriptor.\n-const uptr kThreadSelfOffset = FIRST_32_SECOND_64(8, 16);\n-\n-uptr ThreadSelfOffset() {\n-  return kThreadSelfOffset;\n-}\n-\n #if defined(__mips__) || defined(__powerpc64__) || SANITIZER_RISCV64\n // TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n // head structure. It lies before the static tls blocks.\n@@ -353,68 +308,74 @@ static uptr TlsPreTcbSize() {\n }\n #endif\n \n-uptr ThreadSelf() {\n-  uptr descr_addr;\n-#if defined(__i386__)\n-  asm(\"mov %%gs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n-#elif defined(__x86_64__)\n-  asm(\"mov %%fs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n-#elif defined(__mips__)\n-  // MIPS uses TLS variant I. The thread pointer (in hardware register $29)\n-  // points to the end of the TCB + 0x7000. The pthread_descr structure is\n-  // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n-  // TCB and the size of pthread_descr.\n-  const uptr kTlsTcbOffset = 0x7000;\n-  uptr thread_pointer;\n-  asm volatile(\".set push;\\\n-                .set mips64r2;\\\n-                rdhwr %0,$29;\\\n-                .set pop\" : \"=r\" (thread_pointer));\n-  descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n-#elif defined(__aarch64__) || defined(__arm__)\n-  descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer()) -\n-                                      ThreadDescriptorSize();\n-#elif SANITIZER_RISCV64\n-  // https://github.com/riscv/riscv-elf-psabi-doc/issues/53\n-  uptr thread_pointer = reinterpret_cast<uptr>(__builtin_thread_pointer());\n-  descr_addr = thread_pointer - TlsPreTcbSize();\n-#elif defined(__s390__)\n-  descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer());\n-#elif defined(__powerpc64__)\n-  // PPC64LE uses TLS variant I. The thread pointer (in GPR 13)\n-  // points to the end of the TCB + 0x7000. The pthread_descr structure is\n-  // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n-  // TCB and the size of pthread_descr.\n-  const uptr kTlsTcbOffset = 0x7000;\n-  uptr thread_pointer;\n-  asm(\"addi %0,13,%1\" : \"=r\"(thread_pointer) : \"I\"(-kTlsTcbOffset));\n-  descr_addr = thread_pointer - TlsPreTcbSize();\n-#else\n-#error \"unsupported CPU arch\"\n-#endif\n-  return descr_addr;\n-}\n-#endif  // (x86_64 || i386 || MIPS) && SANITIZER_LINUX\n+#if !SANITIZER_GO\n+namespace {\n+struct TlsBlock {\n+  uptr begin, end, align;\n+  size_t tls_modid;\n+  bool operator<(const TlsBlock &rhs) const { return begin < rhs.begin; }\n+};\n+}  // namespace\n \n-#if SANITIZER_FREEBSD\n-static void **ThreadSelfSegbase() {\n-  void **segbase = 0;\n-#if defined(__i386__)\n-  // sysarch(I386_GET_GSBASE, segbase);\n-  __asm __volatile(\"mov %%gs:0, %0\" : \"=r\" (segbase));\n-#elif defined(__x86_64__)\n-  // sysarch(AMD64_GET_FSBASE, segbase);\n-  __asm __volatile(\"movq %%fs:0, %0\" : \"=r\" (segbase));\n-#else\n-#error \"unsupported CPU arch\"\n+extern \"C\" void *__tls_get_addr(size_t *);\n+\n+static int CollectStaticTlsBlocks(struct dl_phdr_info *info, size_t size,\n+                                  void *data) {\n+  if (!info->dlpi_tls_modid)\n+    return 0;\n+  uptr begin = (uptr)info->dlpi_tls_data;\n+#ifndef __s390__\n+  if (!g_use_dlpi_tls_data) {\n+    // Call __tls_get_addr as a fallback. This forces TLS allocation on glibc\n+    // and FreeBSD.\n+    size_t mod_and_off[2] = {info->dlpi_tls_modid, 0};\n+    begin = (uptr)__tls_get_addr(mod_and_off);\n+  }\n #endif\n-  return segbase;\n+  for (unsigned i = 0; i != info->dlpi_phnum; ++i)\n+    if (info->dlpi_phdr[i].p_type == PT_TLS) {\n+      static_cast<InternalMmapVector<TlsBlock> *>(data)->push_back(\n+          TlsBlock{begin, begin + info->dlpi_phdr[i].p_memsz,\n+                   info->dlpi_phdr[i].p_align, info->dlpi_tls_modid});\n+      break;\n+    }\n+  return 0;\n }\n \n-uptr ThreadSelf() {\n-  return (uptr)ThreadSelfSegbase()[2];\n-}\n-#endif  // SANITIZER_FREEBSD\n+__attribute__((unused)) static void GetStaticTlsBoundary(uptr *addr, uptr *size,\n+                                                         uptr *align) {\n+  InternalMmapVector<TlsBlock> ranges;\n+  dl_iterate_phdr(CollectStaticTlsBlocks, &ranges);\n+  uptr len = ranges.size();\n+  Sort(ranges.begin(), len);\n+  // Find the range with tls_modid=1. For glibc, because libc.so uses PT_TLS,\n+  // this module is guaranteed to exist and is one of the initially loaded\n+  // modules.\n+  uptr one = 0;\n+  while (one != len && ranges[one].tls_modid != 1) ++one;\n+  if (one == len) {\n+    // This may happen with musl if no module uses PT_TLS.\n+    *addr = 0;\n+    *size = 0;\n+    *align = 1;\n+    return;\n+  }\n+  // Find the maximum consecutive ranges. We consider two modules consecutive if\n+  // the gap is smaller than the alignment. The dynamic loader places static TLS\n+  // blocks this way not to waste space.\n+  uptr l = one;\n+  *align = ranges[l].align;\n+  while (l != 0 && ranges[l].begin < ranges[l - 1].end + ranges[l - 1].align)\n+    *align = Max(*align, ranges[--l].align);\n+  uptr r = one + 1;\n+  while (r != len && ranges[r].begin < ranges[r - 1].end + ranges[r - 1].align)\n+    *align = Max(*align, ranges[r++].align);\n+  *addr = ranges[l].begin;\n+  *size = ranges[r - 1].end - ranges[l].begin;\n+}\n+#endif  // !SANITIZER_GO\n+#endif  // (x86_64 || i386 || mips || ...) && (SANITIZER_FREEBSD ||\n+        // SANITIZER_LINUX) && !SANITIZER_ANDROID\n \n #if SANITIZER_NETBSD\n static struct tls_tcb * ThreadSelfTlsTcb() {\n@@ -465,33 +426,67 @@ static void GetTls(uptr *addr, uptr *size) {\n     *addr = 0;\n     *size = 0;\n   }\n-#elif SANITIZER_LINUX\n-#if defined(__x86_64__) || defined(__i386__) || defined(__s390__)\n-  *addr = ThreadSelf();\n-  *size = GetTlsSize();\n+#elif SANITIZER_GLIBC && defined(__x86_64__)\n+  // For x86-64, use an O(1) approach which requires precise\n+  // ThreadDescriptorSize. g_tls_size was initialized in InitTlsSize.\n+  asm(\"mov %%fs:16,%0\" : \"=r\"(*addr));\n+  *size = g_tls_size;\n   *addr -= *size;\n   *addr += ThreadDescriptorSize();\n-#elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__) || \\\n-    defined(__arm__) || SANITIZER_RISCV64\n-  *addr = ThreadSelf();\n-  *size = GetTlsSize();\n+#elif SANITIZER_GLIBC && defined(__powerpc64__)\n+  // Workaround for glibc<2.25(?). 2.27 is known to not need this.\n+  uptr tp;\n+  asm(\"addi %0,13,-0x7000\" : \"=r\"(tp));\n+  const uptr pre_tcb_size = TlsPreTcbSize();\n+  *addr = tp - pre_tcb_size;\n+  *size = g_tls_size + pre_tcb_size;\n+#elif SANITIZER_FREEBSD || SANITIZER_LINUX\n+  uptr align;\n+  GetStaticTlsBoundary(addr, size, &align);\n+#if defined(__x86_64__) || defined(__i386__) || defined(__s390__) || \\\n+    defined(__sparc__)\n+  if (SANITIZER_GLIBC) {\n+#if defined(__x86_64__) || defined(__i386__)\n+    align = Max<uptr>(align, 64);\n #else\n-  *addr = 0;\n-  *size = 0;\n+    align = Max<uptr>(align, 16);\n #endif\n-#elif SANITIZER_FREEBSD\n-  void** segbase = ThreadSelfSegbase();\n-  *addr = 0;\n-  *size = 0;\n-  if (segbase != 0) {\n-    // tcbalign = 16\n-    // tls_size = round(tls_static_space, tcbalign);\n-    // dtv = segbase[1];\n-    // dtv[2] = segbase - tls_static_space;\n-    void **dtv = (void**) segbase[1];\n-    *addr = (uptr) dtv[2];\n-    *size = (*addr == 0) ? 0 : ((uptr) segbase[0] - (uptr) dtv[2]);\n   }\n+  const uptr tp = RoundUpTo(*addr + *size, align);\n+\n+  // lsan requires the range to additionally cover the static TLS surplus\n+  // (elf/dl-tls.c defines 1664). Otherwise there may be false positives for\n+  // allocations only referenced by tls in dynamically loaded modules.\n+  if (SANITIZER_GLIBC)\n+    *size += 1644;\n+  else if (SANITIZER_FREEBSD)\n+    *size += 128;  // RTLD_STATIC_TLS_EXTRA\n+\n+  // Extend the range to include the thread control block. On glibc, lsan needs\n+  // the range to include pthread::{specific_1stblock,specific} so that\n+  // allocations only referenced by pthread_setspecific can be scanned. This may\n+  // underestimate by at most TLS_TCB_ALIGN-1 bytes but it should be fine\n+  // because the number of bytes after pthread::specific is larger.\n+  *addr = tp - RoundUpTo(*size, align);\n+  *size = tp - *addr + ThreadDescriptorSize();\n+#else\n+  if (SANITIZER_GLIBC)\n+    *size += 1664;\n+  else if (SANITIZER_FREEBSD)\n+    *size += 128;  // RTLD_STATIC_TLS_EXTRA\n+#if defined(__mips__) || defined(__powerpc64__) || SANITIZER_RISCV64\n+  const uptr pre_tcb_size = TlsPreTcbSize();\n+  *addr -= pre_tcb_size;\n+  *size += pre_tcb_size;\n+#else\n+  // arm and aarch64 reserve two words at TP, so this underestimates the range.\n+  // However, this is sufficient for the purpose of finding the pointers to\n+  // thread-specific data keys.\n+  const uptr tcb_size = ThreadDescriptorSize();\n+  *addr -= tcb_size;\n+  *size += tcb_size;\n+#endif\n+#endif\n #elif SANITIZER_NETBSD\n   struct tls_tcb * const tcb = ThreadSelfTlsTcb();\n   *addr = 0;\n@@ -518,15 +513,13 @@ static void GetTls(uptr *addr, uptr *size) {\n \n #if !SANITIZER_GO\n uptr GetTlsSize() {\n-#if SANITIZER_FREEBSD || SANITIZER_ANDROID || SANITIZER_NETBSD || \\\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD || \\\n     SANITIZER_SOLARIS\n   uptr addr, size;\n   GetTls(&addr, &size);\n   return size;\n-#elif defined(__mips__) || defined(__powerpc64__) || SANITIZER_RISCV64\n-  return RoundUpTo(g_tls_size + TlsPreTcbSize(), 16);\n #else\n-  return g_tls_size;\n+  return 0;\n #endif\n }\n #endif\n@@ -547,10 +540,9 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n   if (!main) {\n     // If stack and tls intersect, make them non-intersecting.\n     if (*tls_addr > *stk_addr && *tls_addr < *stk_addr + *stk_size) {\n-      CHECK_GT(*tls_addr + *tls_size, *stk_addr);\n-      CHECK_LE(*tls_addr + *tls_size, *stk_addr + *stk_size);\n-      *stk_size -= *tls_size;\n-      *tls_addr = *stk_addr + *stk_size;\n+      if (*stk_addr + *stk_size < *tls_addr + *tls_size)\n+        *tls_size = *stk_addr + *stk_size - *tls_addr;\n+      *stk_size = *tls_addr - *stk_addr;\n     }\n   }\n #endif\n@@ -569,20 +561,12 @@ struct DlIteratePhdrData {\n   bool first;\n };\n \n-static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n-  DlIteratePhdrData *data = (DlIteratePhdrData*)arg;\n-  InternalScopedString module_name(kMaxPathLength);\n-  if (data->first) {\n-    data->first = false;\n-    // First module is the binary itself.\n-    ReadBinaryNameCached(module_name.data(), module_name.size());\n-  } else if (info->dlpi_name) {\n-    module_name.append(\"%s\", info->dlpi_name);\n-  }\n+static int AddModuleSegments(const char *module_name, dl_phdr_info *info,\n+                             InternalMmapVectorNoCtor<LoadedModule> *modules) {\n   if (module_name[0] == '\\0')\n     return 0;\n   LoadedModule cur_module;\n-  cur_module.set(module_name.data(), info->dlpi_addr);\n+  cur_module.set(module_name, info->dlpi_addr);\n   for (int i = 0; i < (int)info->dlpi_phnum; i++) {\n     const Elf_Phdr *phdr = &info->dlpi_phdr[i];\n     if (phdr->p_type == PT_LOAD) {\n@@ -594,7 +578,26 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n                                  writable);\n     }\n   }\n-  data->modules->push_back(cur_module);\n+  modules->push_back(cur_module);\n+  return 0;\n+}\n+\n+static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n+  DlIteratePhdrData *data = (DlIteratePhdrData *)arg;\n+  if (data->first) {\n+    InternalMmapVector<char> module_name(kMaxPathLength);\n+    data->first = false;\n+    // First module is the binary itself.\n+    ReadBinaryNameCached(module_name.data(), module_name.size());\n+    return AddModuleSegments(module_name.data(), info, data->modules);\n+  }\n+\n+  if (info->dlpi_name) {\n+    InternalScopedString module_name;\n+    module_name.append(\"%s\", info->dlpi_name);\n+    return AddModuleSegments(module_name.data(), info, data->modules);\n+  }\n+\n   return 0;\n }\n \n@@ -729,13 +732,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n \n@@ -802,20 +801,13 @@ void LogMessageOnPrintf(const char *str) {\n \n #endif  // SANITIZER_LINUX\n \n-#if SANITIZER_LINUX && !SANITIZER_GO\n+#if SANITIZER_GLIBC && !SANITIZER_GO\n // glibc crashes when using clock_gettime from a preinit_array function as the\n // vDSO function pointers haven't been initialized yet. __progname is\n // initialized after the vDSO function pointers, so if it exists, is not null\n // and is not empty, we can use clock_gettime.\n extern \"C\" SANITIZER_WEAK_ATTRIBUTE char *__progname;\n-inline bool CanUseVDSO() {\n-  // Bionic is safe, it checks for the vDSO function pointers to be initialized.\n-  if (SANITIZER_ANDROID)\n-    return true;\n-  if (&__progname && __progname && *__progname)\n-    return true;\n-  return false;\n-}\n+inline bool CanUseVDSO() { return &__progname && __progname && *__progname; }\n \n // MonotonicNanoTime is a timing function that can leverage the vDSO by calling\n // clock_gettime. real_clock_gettime only exists if clock_gettime is\n@@ -835,13 +827,13 @@ u64 MonotonicNanoTime() {\n   return (u64)ts.tv_sec * (1000ULL * 1000 * 1000) + ts.tv_nsec;\n }\n #else\n-// Non-Linux & Go always use the syscall.\n+// Non-glibc & Go always use the regular function.\n u64 MonotonicNanoTime() {\n   timespec ts;\n-  internal_clock_gettime(CLOCK_MONOTONIC, &ts);\n+  clock_gettime(CLOCK_MONOTONIC, &ts);\n   return (u64)ts.tv_sec * (1000ULL * 1000 * 1000) + ts.tv_nsec;\n }\n-#endif  // SANITIZER_LINUX && !SANITIZER_GO\n+#endif  // SANITIZER_GLIBC && !SANITIZER_GO\n \n void ReExec() {\n   const char *pathname = \"/proc/self/exe\";\n@@ -910,6 +902,65 @@ uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n   return shadow_start;\n }\n \n+static uptr MmapSharedNoReserve(uptr addr, uptr size) {\n+  return internal_mmap(\n+      reinterpret_cast<void *>(addr), size, PROT_READ | PROT_WRITE,\n+      MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_NORESERVE, -1, 0);\n+}\n+\n+static uptr MremapCreateAlias(uptr base_addr, uptr alias_addr,\n+                              uptr alias_size) {\n+#if SANITIZER_LINUX\n+  return internal_mremap(reinterpret_cast<void *>(base_addr), 0, alias_size,\n+                         MREMAP_MAYMOVE | MREMAP_FIXED,\n+                         reinterpret_cast<void *>(alias_addr));\n+#else\n+  CHECK(false && \"mremap is not supported outside of Linux\");\n+  return 0;\n+#endif\n+}\n+\n+static void CreateAliases(uptr start_addr, uptr alias_size, uptr num_aliases) {\n+  uptr total_size = alias_size * num_aliases;\n+  uptr mapped = MmapSharedNoReserve(start_addr, total_size);\n+  CHECK_EQ(mapped, start_addr);\n+\n+  for (uptr i = 1; i < num_aliases; ++i) {\n+    uptr alias_addr = start_addr + i * alias_size;\n+    CHECK_EQ(MremapCreateAlias(start_addr, alias_addr, alias_size), alias_addr);\n+  }\n+}\n+\n+uptr MapDynamicShadowAndAliases(uptr shadow_size, uptr alias_size,\n+                                uptr num_aliases, uptr ring_buffer_size) {\n+  CHECK_EQ(alias_size & (alias_size - 1), 0);\n+  CHECK_EQ(num_aliases & (num_aliases - 1), 0);\n+  CHECK_EQ(ring_buffer_size & (ring_buffer_size - 1), 0);\n+\n+  const uptr granularity = GetMmapGranularity();\n+  shadow_size = RoundUpTo(shadow_size, granularity);\n+  CHECK_EQ(shadow_size & (shadow_size - 1), 0);\n+\n+  const uptr alias_region_size = alias_size * num_aliases;\n+  const uptr alignment =\n+      2 * Max(Max(shadow_size, alias_region_size), ring_buffer_size);\n+  const uptr left_padding = ring_buffer_size;\n+\n+  const uptr right_size = alignment;\n+  const uptr map_size = left_padding + 2 * alignment;\n+\n+  const uptr map_start = reinterpret_cast<uptr>(MmapNoAccess(map_size));\n+  CHECK_NE(map_start, static_cast<uptr>(-1));\n+  const uptr right_start = RoundUpTo(map_start + left_padding, alignment);\n+\n+  UnmapFromTo(map_start, right_start - left_padding);\n+  UnmapFromTo(right_start + right_size, map_start + map_size);\n+\n+  CreateAliases(right_start + right_size / 2, alias_size, num_aliases);\n+\n+  return right_start;\n+}\n+\n void InitializePlatformCommonFlags(CommonFlags *cf) {\n #if SANITIZER_ANDROID\n   if (&__libc_get_static_tls_bounds == nullptr)"}, {"sha": "0e19c4d4a80110d999724c215da52394c4c8a513", "filename": "libsanitizer/sanitizer_common/sanitizer_local_address_space_view.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_local_address_space_view.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_local_address_space_view.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_local_address_space_view.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -7,7 +7,7 @@\n //===----------------------------------------------------------------------===//\n //\n // `LocalAddressSpaceView` provides the local (i.e. target and current address\n-// space are the same) implementation of the `AddressSpaveView` interface which\n+// space are the same) implementation of the `AddressSpaceView` interface which\n // provides a simple interface to load memory from another process (i.e.\n // out-of-process)\n //"}, {"sha": "f4c6b442a14a38035984ec095ea097e7fdd64eec", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 117, "deletions": 24, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -37,13 +37,21 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n #define SANITIZER_OS_TRACE 0\n #endif\n \n+// import new crash reporting api\n+#if defined(__has_include) && __has_include(<CrashReporterClient.h>)\n+#define HAVE_CRASHREPORTERCLIENT_H 1\n+#include <CrashReporterClient.h>\n+#else\n+#define HAVE_CRASHREPORTERCLIENT_H 0\n+#endif\n+\n #if !SANITIZER_IOS\n #include <crt_externs.h>  // for _NSGetArgv and _NSGetEnviron\n #else\n@@ -62,6 +70,7 @@ extern \"C\" {\n #include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n #include <malloc/malloc.h>\n+#include <os/log.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n@@ -133,6 +142,12 @@ uptr internal_munmap(void *addr, uptr length) {\n   return munmap(addr, length);\n }\n \n+uptr internal_mremap(void *old_address, uptr old_size, uptr new_size, int flags,\n+                     void *new_address) {\n+  CHECK(false && \"internal_mremap is unimplemented on Mac\");\n+  return 0;\n+}\n+\n int internal_mprotect(void *addr, uptr length, int prot) {\n   return mprotect(addr, length, prot);\n }\n@@ -444,7 +459,7 @@ uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n   // On OS X the executable path is saved to the stack by dyld. Reading it\n   // from there is much faster than calling dladdr, especially for large\n   // binaries with symbols.\n-  InternalScopedString exe_path(kMaxPathLength);\n+  InternalMmapVector<char> exe_path(kMaxPathLength);\n   uint32_t size = exe_path.size();\n   if (_NSGetExecutablePath(exe_path.data(), &size) == 0 &&\n       realpath(exe_path.data(), buf) != 0) {\n@@ -620,6 +635,23 @@ constexpr u16 GetOSMajorKernelOffset() {\n \n using VersStr = char[64];\n \n+static uptr ApproximateOSVersionViaKernelVersion(VersStr vers) {\n+  u16 kernel_major = GetDarwinKernelVersion().major;\n+  u16 offset = GetOSMajorKernelOffset();\n+  CHECK_GE(kernel_major, offset);\n+  u16 os_major = kernel_major - offset;\n+\n+  const char *format = \"%d.0\";\n+  if (TARGET_OS_OSX) {\n+    if (os_major >= 16) {  // macOS 11+\n+      os_major -= 5;\n+    } else {  // macOS 10.15 and below\n+      format = \"10.%d\";\n+    }\n+  }\n+  return internal_snprintf(vers, sizeof(VersStr), format, os_major);\n+}\n+\n static void GetOSVersion(VersStr vers) {\n   uptr len = sizeof(VersStr);\n   if (SANITIZER_IOSSIM) {\n@@ -633,17 +665,19 @@ static void GetOSVersion(VersStr vers) {\n   } else {\n     int res =\n         internal_sysctlbyname(\"kern.osproductversion\", vers, &len, nullptr, 0);\n-    if (res) {\n-      // Fallback for XNU 17 (macOS 10.13) and below that do not provide the\n-      // `kern.osproductversion` property.\n-      u16 kernel_major = GetDarwinKernelVersion().major;\n-      u16 offset = GetOSMajorKernelOffset();\n-      CHECK_LE(kernel_major, 17);\n-      CHECK_GE(kernel_major, offset);\n-      u16 os_major = kernel_major - offset;\n-\n-      auto format = TARGET_OS_OSX ? \"10.%d\" : \"%d.0\";\n-      len = internal_snprintf(vers, len, format, os_major);\n+\n+    // XNU 17 (macOS 10.13) and below do not provide the sysctl\n+    // `kern.osproductversion` entry (res != 0).\n+    bool no_os_version = res != 0;\n+\n+    // For launchd, sanitizer initialization runs before sysctl is setup\n+    // (res == 0 && len != strlen(vers), vers is not a valid version).  However,\n+    // the kernel version `kern.osrelease` is available.\n+    bool launchd = (res == 0 && internal_strlen(vers) < 3);\n+    if (launchd) CHECK_EQ(internal_getpid(), 1);\n+\n+    if (no_os_version || launchd) {\n+      len = ApproximateOSVersionViaKernelVersion(vers);\n     }\n   }\n   CHECK_LT(len, sizeof(VersStr));\n@@ -681,7 +715,7 @@ static void MapToMacos(u16 *major, u16 *minor) {\n }\n \n static MacosVersion GetMacosAlignedVersionInternal() {\n-  VersStr vers;\n+  VersStr vers = {};\n   GetOSVersion(vers);\n \n   u16 major, minor;\n@@ -707,7 +741,7 @@ MacosVersion GetMacosAlignedVersion() {\n }\n \n DarwinKernelVersion GetDarwinKernelVersion() {\n-  VersStr vers;\n+  VersStr vers = {};\n   uptr len = sizeof(VersStr);\n   int res = internal_sysctlbyname(\"kern.osrelease\", vers, &len, nullptr, 0);\n   CHECK_EQ(res, 0);\n@@ -751,7 +785,51 @@ static BlockingMutex syslog_lock(LINKER_INITIALIZED);\n void WriteOneLineToSyslog(const char *s) {\n #if !SANITIZER_GO\n   syslog_lock.CheckLocked();\n-  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", s);\n+  if (GetMacosAlignedVersion() >= MacosVersion(10, 12)) {\n+    os_log_error(OS_LOG_DEFAULT, \"%{public}s\", s);\n+  } else {\n+    asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", s);\n+  }\n+#endif\n+}\n+\n+// buffer to store crash report application information\n+static char crashreporter_info_buff[__sanitizer::kErrorMessageBufferSize] = {};\n+static BlockingMutex crashreporter_info_mutex(LINKER_INITIALIZED);\n+\n+extern \"C\" {\n+// Integrate with crash reporter libraries.\n+#if HAVE_CRASHREPORTERCLIENT_H\n+CRASH_REPORTER_CLIENT_HIDDEN\n+struct crashreporter_annotations_t gCRAnnotations\n+    __attribute__((section(\"__DATA,\" CRASHREPORTER_ANNOTATIONS_SECTION))) = {\n+        CRASHREPORTER_ANNOTATIONS_VERSION,\n+        0,\n+        0,\n+        0,\n+        0,\n+        0,\n+        0,\n+#if CRASHREPORTER_ANNOTATIONS_VERSION > 4\n+        0,\n+#endif\n+};\n+\n+#else\n+// fall back to old crashreporter api\n+static const char *__crashreporter_info__ __attribute__((__used__)) =\n+    &crashreporter_info_buff[0];\n+asm(\".desc ___crashreporter_info__, 0x10\");\n+#endif\n+\n+}  // extern \"C\"\n+\n+static void CRAppendCrashLogMessage(const char *msg) {\n+  BlockingMutexLock l(&crashreporter_info_mutex);\n+  internal_strlcat(crashreporter_info_buff, msg,\n+                   sizeof(crashreporter_info_buff));\n+#if HAVE_CRASHREPORTERCLIENT_H\n+  (void)CRSetCrashLogMessage(crashreporter_info_buff);\n #endif\n }\n \n@@ -947,7 +1025,7 @@ void MaybeReexec() {\n   if (DyldNeedsEnvVariable() && !lib_is_in_env) {\n     // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n     // library.\n-    InternalScopedString program_name(1024);\n+    InternalMmapVector<char> program_name(1024);\n     uint32_t buf_size = program_name.size();\n     _NSGetExecutablePath(program_name.data(), &buf_size);\n     char *new_env = const_cast<char*>(info.dli_fname);\n@@ -1066,7 +1144,7 @@ char **GetArgv() {\n   return *_NSGetArgv();\n }\n \n-#if SANITIZER_IOS\n+#if SANITIZER_IOS && !SANITIZER_IOSSIM\n // The task_vm_info struct is normally provided by the macOS SDK, but we need\n // fields only available in 10.12+. Declare the struct manually to be able to\n // build against older SDKs.\n@@ -1106,26 +1184,35 @@ static uptr GetTaskInfoMaxAddress() {\n \n uptr GetMaxUserVirtualAddress() {\n   static uptr max_vm = GetTaskInfoMaxAddress();\n-  if (max_vm != 0)\n-    return max_vm - 1;\n+  if (max_vm != 0) {\n+    const uptr ret_value = max_vm - 1;\n+    CHECK_LE(ret_value, SANITIZER_MMAP_RANGE_SIZE);\n+    return ret_value;\n+  }\n \n   // xnu cannot provide vm address limit\n # if SANITIZER_WORDSIZE == 32\n-  return 0xffe00000 - 1;\n+  constexpr uptr fallback_max_vm = 0xffe00000 - 1;\n # else\n-  return 0x200000000 - 1;\n+  constexpr uptr fallback_max_vm = 0x200000000 - 1;\n # endif\n+  static_assert(fallback_max_vm <= SANITIZER_MMAP_RANGE_SIZE,\n+                \"Max virtual address must be less than mmap range size.\");\n+  return fallback_max_vm;\n }\n \n #else // !SANITIZER_IOS\n \n uptr GetMaxUserVirtualAddress() {\n # if SANITIZER_WORDSIZE == 64\n-  return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n+  constexpr uptr max_vm = (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n # else // SANITIZER_WORDSIZE == 32\n   static_assert(SANITIZER_WORDSIZE == 32, \"Wrong wordsize\");\n-  return (1ULL << 32) - 1;  // 0xffffffff;\n+  constexpr uptr max_vm = (1ULL << 32) - 1;  // 0xffffffff;\n # endif\n+  static_assert(max_vm <= SANITIZER_MMAP_RANGE_SIZE,\n+                \"Max virtual address must be less than mmap range size.\");\n+  return max_vm;\n }\n #endif\n \n@@ -1180,6 +1267,12 @@ uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n   return shadow_start;\n }\n \n+uptr MapDynamicShadowAndAliases(uptr shadow_size, uptr alias_size,\n+                                uptr num_aliases, uptr ring_buffer_size) {\n+  CHECK(false && \"HWASan aliasing is unimplemented on Mac\");\n+  return 0;\n+}\n+\n uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n                               uptr *largest_gap_found,\n                               uptr *max_occupied_addr) {"}, {"sha": "0b6af5a3c0edc649c4d65dfd1a6ca1bce13aa9b9", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -14,26 +14,6 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n-\n-/* TARGET_OS_OSX is not present in SDKs before Darwin16 (macOS 10.12) use\n-   TARGET_OS_MAC (we have no support for iOS in any form for these versions,\n-   so there's no ambiguity).  */\n-#if !defined(TARGET_OS_OSX) && TARGET_OS_MAC\n-# define TARGET_OS_OSX 1\n-#endif\n-\n-/* Other TARGET_OS_xxx are not present on earlier versions, define them to\n-   0 (we have no support for them; they are not valid targets anyway).  */\n-#ifndef TARGET_OS_IOS\n-#define TARGET_OS_IOS 0\n-#endif\n-#ifndef TARGET_OS_TV\n-#define TARGET_OS_TV 0\n-#endif\n-#ifndef TARGET_OS_WATCH\n-#define TARGET_OS_WATCH 0\n-#endif\n-\n #if SANITIZER_MAC\n #include \"sanitizer_posix.h\"\n \n@@ -84,22 +64,5 @@ void RestrictMemoryToMaxAddress(uptr max_address);\n \n }  // namespace __sanitizer\n \n-extern \"C\" {\n-static char __crashreporter_info_buff__[__sanitizer::kErrorMessageBufferSize] =\n-  {};\n-static const char *__crashreporter_info__ __attribute__((__used__)) =\n-  &__crashreporter_info_buff__[0];\n-asm(\".desc ___crashreporter_info__, 0x10\");\n-} // extern \"C\"\n-\n-namespace __sanitizer {\n-static BlockingMutex crashreporter_info_mutex(LINKER_INITIALIZED);\n-\n-inline void CRAppendCrashLogMessage(const char *msg) {\n-  BlockingMutexLock l(&crashreporter_info_mutex);\n-  internal_strlcat(__crashreporter_info_buff__, msg,\n-                   sizeof(__crashreporter_info_buff__)); }\n-}  // namespace __sanitizer\n-\n #endif  // SANITIZER_MAC\n #endif  // SANITIZER_MAC_H"}, {"sha": "e3b664f68b618cc48746cf3ce8e578d9e661a995", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -120,11 +120,7 @@ INTERCEPTOR(int, malloc_make_nonpurgeable, void *ptr) {\n \n INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n   COMMON_MALLOC_ENTER();\n-  // Allocate |sizeof(COMMON_MALLOC_ZONE_NAME \"-\") + internal_strlen(name)|\n-  // bytes.\n-  size_t buflen =\n-      sizeof(COMMON_MALLOC_ZONE_NAME \"-\") + (name ? internal_strlen(name) : 0);\n-  InternalScopedString new_name(buflen);\n+  InternalScopedString new_name;\n   if (name && zone->introspect == sanitizer_zone.introspect) {\n     new_name.append(COMMON_MALLOC_ZONE_NAME \"-%s\", name);\n     name = new_name.data();"}, {"sha": "ac20f915fefe577195edf19d6c2c3f71495813a3", "filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -105,6 +105,12 @@ uptr internal_munmap(void *addr, uptr length) {\n   return _REAL(munmap, addr, length);\n }\n \n+uptr internal_mremap(void *old_address, uptr old_size, uptr new_size, int flags,\n+                     void *new_address) {\n+  CHECK(false && \"internal_mremap is unimplemented on NetBSD\");\n+  return 0;\n+}\n+\n int internal_mprotect(void *addr, uptr length, int prot) {\n   DEFINE__REAL(int, mprotect, void *a, uptr b, int c);\n   return _REAL(mprotect, addr, length, prot);"}, {"sha": "2f6458431c89e69866ce7ebe5225316b67ab5b75", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -19,12 +19,25 @@\n # error \"This operating system is not supported\"\n #endif\n \n+// Get __GLIBC__ on a glibc platform. Exclude Android: features.h includes C\n+// function declarations into a .S file which doesn't compile.\n+// https://crbug.com/1162741\n+#if __has_include(<features.h>) && !defined(__ANDROID__)\n+#include <features.h>\n+#endif\n+\n #if defined(__linux__)\n # define SANITIZER_LINUX   1\n #else\n # define SANITIZER_LINUX   0\n #endif\n \n+#if defined(__GLIBC__)\n+# define SANITIZER_GLIBC   1\n+#else\n+# define SANITIZER_GLIBC   0\n+#endif\n+\n #if defined(__FreeBSD__)\n # define SANITIZER_FREEBSD 1\n #else\n@@ -46,6 +59,11 @@\n #if defined(__APPLE__)\n # define SANITIZER_MAC     1\n # include <TargetConditionals.h>\n+# if TARGET_OS_OSX\n+#  define SANITIZER_OSX    1\n+# else\n+#  define SANITIZER_OSX    0\n+# endif\n # if TARGET_OS_IPHONE\n #  define SANITIZER_IOS    1\n # else\n@@ -60,6 +78,7 @@\n # define SANITIZER_MAC     0\n # define SANITIZER_IOS     0\n # define SANITIZER_IOSSIM  0\n+# define SANITIZER_OSX     0\n #endif\n \n #if defined(__APPLE__) && TARGET_OS_IPHONE && TARGET_OS_WATCH\n@@ -247,8 +266,12 @@\n #define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 38)\n #elif defined(__aarch64__)\n # if SANITIZER_MAC\n-// Darwin iOS/ARM64 has a 36-bit VMA, 64GiB VM\n-#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 36)\n+#  if SANITIZER_OSX || SANITIZER_IOSSIM\n+#   define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n+#  else\n+    // Darwin iOS/ARM64 has a 36-bit VMA, 64GiB VM\n+#   define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 36)\n+#  endif\n # else\n #  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 48)\n # endif"}, {"sha": "731df710df54ab11f09dcba75798fe3677e701b6", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -46,6 +46,12 @@\n #define SI_LINUX_NOT_ANDROID 0\n #endif\n \n+#if SANITIZER_GLIBC\n+#define SI_GLIBC 1\n+#else\n+#define SI_GLIBC 0\n+#endif\n+\n #if SANITIZER_ANDROID\n #define SI_ANDROID 1\n #else\n@@ -159,7 +165,7 @@\n   SANITIZER_INTERCEPT_MEMCMP &&  \\\n       ((SI_POSIX && _GNU_SOURCE) || SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_STRNDUP SI_POSIX\n-#define SANITIZER_INTERCEPT___STRNDUP SI_LINUX_NOT_FREEBSD\n+#define SANITIZER_INTERCEPT___STRNDUP SI_GLIBC\n #if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \\\n     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070\n #define SI_MAC_DEPLOYMENT_BELOW_10_7 1\n@@ -183,34 +189,34 @@\n #define SANITIZER_INTERCEPT_FPUTS SI_POSIX\n #define SANITIZER_INTERCEPT_PUTS SI_POSIX\n \n-#define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n-#define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n+#define SANITIZER_INTERCEPT_PREAD64 (SI_GLIBC || SI_SOLARIS32)\n+#define SANITIZER_INTERCEPT_PWRITE64 (SI_GLIBC || SI_SOLARIS32)\n \n #define SANITIZER_INTERCEPT_READV SI_POSIX\n #define SANITIZER_INTERCEPT_WRITEV SI_POSIX\n \n #define SANITIZER_INTERCEPT_PREADV \\\n   (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_PWRITEV SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PREADV64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PWRITEV64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PREADV64 SI_GLIBC\n+#define SANITIZER_INTERCEPT_PWRITEV64 SI_GLIBC\n \n #define SANITIZER_INTERCEPT_PRCTL SI_LINUX\n \n #define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_POSIX\n #define SANITIZER_INTERCEPT_STRPTIME SI_POSIX\n \n #define SANITIZER_INTERCEPT_SCANF SI_POSIX\n-#define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ISOC99_SCANF SI_GLIBC\n \n #ifndef SANITIZER_INTERCEPT_PRINTF\n #define SANITIZER_INTERCEPT_PRINTF SI_POSIX\n #define SANITIZER_INTERCEPT_PRINTF_L (SI_FREEBSD || SI_NETBSD)\n-#define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_GLIBC\n #endif\n \n #define SANITIZER_INTERCEPT___PRINTF_CHK \\\n-  (SANITIZER_INTERCEPT_PRINTF && SI_LINUX_NOT_ANDROID)\n+  (SANITIZER_INTERCEPT_PRINTF && SI_GLIBC)\n \n #define SANITIZER_INTERCEPT_FREXP SI_NOT_FUCHSIA\n #define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_POSIX\n@@ -220,22 +226,20 @@\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETPWENT \\\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_FGETGRENT_R \\\n-  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_FGETGRENT_R (SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_GETPWENT_R \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_FGETPWENT_R \\\n-  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+  (SI_FREEBSD || SI_NETBSD || SI_GLIBC || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_FGETPWENT_R (SI_FREEBSD || SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SETPWENT \\\n   (SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_CLOCK_GETTIME \\\n   (SI_FREEBSD || SI_NETBSD || SI_LINUX || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_CLOCK_GETCPUCLOCKID SI_LINUX\n #define SANITIZER_INTERCEPT_GETITIMER SI_POSIX\n #define SANITIZER_INTERCEPT_TIME SI_POSIX\n-#define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID || SI_SOLARIS\n-#define SANITIZER_INTERCEPT_GLOB64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GLOB (SI_GLIBC || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_GLOB64 SI_GLIBC\n #define SANITIZER_INTERCEPT_WAIT SI_POSIX\n #define SANITIZER_INTERCEPT_INET SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_POSIX\n@@ -250,8 +254,7 @@\n   (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_GETHOSTBYADDR_R \\\n   (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_GETHOSTENT_R \\\n-  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_GETHOSTENT_R (SI_FREEBSD || SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETSOCKOPT SI_POSIX\n #define SANITIZER_INTERCEPT_ACCEPT SI_POSIX\n #define SANITIZER_INTERCEPT_ACCEPT4 (SI_LINUX_NOT_ANDROID || SI_NETBSD)\n@@ -296,8 +299,7 @@\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_REALPATH SI_POSIX\n-#define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME \\\n-  (SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME (SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_CONFSTR \\\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n@@ -324,7 +326,7 @@\n #define SANITIZER_INTERCEPT_SIGPROCMASK SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_SIGMASK SI_POSIX\n #define SANITIZER_INTERCEPT_BACKTRACE \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+  (SI_FREEBSD || SI_NETBSD || SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n #define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATFS \\\n@@ -342,11 +344,11 @@\n #define SANITIZER_INTERCEPT_SHMCTL                                       \\\n   (((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && SANITIZER_WORDSIZE == 64) || \\\n    SI_NETBSD || SI_SOLARIS)  // NOLINT\n-#define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_RANDOM_R SI_GLIBC\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_GLIBC\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED \\\n   (SI_POSIX && !SI_NETBSD)\n@@ -360,15 +362,15 @@\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED \\\n   (SI_POSIX && !SI_NETBSD)\n-#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP SI_GLIBC\n #define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED (SI_POSIX && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK \\\n   (SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED \\\n   (SI_LINUX_NOT_ANDROID && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_THR_EXIT SI_FREEBSD\n #define SANITIZER_INTERCEPT_TMPNAM SI_POSIX\n-#define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n+#define SANITIZER_INTERCEPT_TMPNAM_R (SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTSNAME SI_LINUX\n #define SANITIZER_INTERCEPT_PTSNAME_R SI_LINUX\n #define SANITIZER_INTERCEPT_TTYNAME SI_POSIX\n@@ -381,7 +383,7 @@\n #define SANITIZER_INTERCEPT_LGAMMAL (SI_POSIX && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_LGAMMA_R (SI_FREEBSD || SI_LINUX || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n-#define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_DRAND48_R SI_GLIBC\n #define SANITIZER_INTERCEPT_RAND_R \\\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_ICONV \\\n@@ -396,12 +398,12 @@\n   (SI_LINUX || SI_FREEBSD || SI_NETBSD || SI_MAC || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPT_PTHREAD_MUTEX SI_POSIX\n-#define SANITIZER_INTERCEPT___PTHREAD_MUTEX SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT___PTHREAD_MUTEX SI_GLIBC\n #define SANITIZER_INTERCEPT___LIBC_MUTEX SI_NETBSD\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+  (SI_FREEBSD || SI_NETBSD || SI_GLIBC || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_GETNAME_NP \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+  (SI_FREEBSD || SI_NETBSD || SI_GLIBC || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPT_TLS_GET_ADDR \\\n   (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n@@ -419,19 +421,19 @@\n #else\n #define SANITIZER_INTERCEPT_AEABI_MEM 0\n #endif\n-#define SANITIZER_INTERCEPT___BZERO SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT___BZERO SI_MAC || SI_GLIBC\n #define SANITIZER_INTERCEPT_BZERO SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FTIME (!SI_FREEBSD && !SI_NETBSD && SI_POSIX)\n-#define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n-#define SANITIZER_INTERCEPT_XDRREC SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_XDR (SI_GLIBC || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_XDRREC SI_GLIBC\n #define SANITIZER_INTERCEPT_TSEARCH \\\n   (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_GLIBC\n #define SANITIZER_INTERCEPT_FOPEN SI_POSIX\n-#define SANITIZER_INTERCEPT_FOPEN64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n+#define SANITIZER_INTERCEPT_FOPEN64 (SI_GLIBC || SI_SOLARIS32)\n #define SANITIZER_INTERCEPT_OPEN_MEMSTREAM \\\n   (SI_LINUX_NOT_ANDROID || SI_NETBSD || SI_SOLARIS)\n-#define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_OBSTACK SI_GLIBC\n #define SANITIZER_INTERCEPT_FFLUSH SI_POSIX\n #define SANITIZER_INTERCEPT_FCLOSE SI_POSIX\n \n@@ -456,7 +458,7 @@\n #define SANITIZER_INTERCEPT_CTERMID_R (SI_MAC || SI_FREEBSD || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPTOR_HOOKS \\\n-  (SI_LINUX || SI_MAC || SI_WINDOWS || SI_NETBSD)\n+  (SI_LINUX || SI_MAC || SI_WINDOWS || SI_FREEBSD || SI_NETBSD || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_RECV_RECVFROM SI_POSIX\n #define SANITIZER_INTERCEPT_SEND_SENDTO SI_POSIX\n #define SANITIZER_INTERCEPT_EVENTFD_READ_WRITE SI_LINUX\n@@ -479,20 +481,12 @@\n \n #define SANITIZER_INTERCEPT_MMAP SI_POSIX\n #define SANITIZER_INTERCEPT_MMAP64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO                             \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA && SI_NOT_RTEMS && \\\n-   !SI_SOLARIS)  // NOLINT\n+#define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO (SI_GLIBC || SI_ANDROID)\n #define SANITIZER_INTERCEPT_MEMALIGN \\\n   (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_RTEMS)\n-#define SANITIZER_INTERCEPT___LIBC_MEMALIGN                               \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_RTEMS && \\\n-   !SI_ANDROID)  // NOLINT\n-#define SANITIZER_INTERCEPT_PVALLOC                                          \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA && SI_NOT_RTEMS && \\\n-   !SI_SOLARIS)  // NOLINT\n-#define SANITIZER_INTERCEPT_CFREE                                            \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA && SI_NOT_RTEMS && \\\n-   !SI_SOLARIS && !SANITIZER_ANDROID)  // NOLINT\n+#define SANITIZER_INTERCEPT___LIBC_MEMALIGN SI_GLIBC\n+#define SANITIZER_INTERCEPT_PVALLOC (SI_GLIBC || SI_ANDROID)\n+#define SANITIZER_INTERCEPT_CFREE (SI_GLIBC && !SANITIZER_RISCV64)\n #define SANITIZER_INTERCEPT_REALLOCARRAY SI_POSIX\n #define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC && SI_NOT_RTEMS)\n #define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC && !SI_NETBSD)\n@@ -532,7 +526,7 @@\n #define SANITIZER_INTERCEPT_STRMODE (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_TTYENT SI_NETBSD\n #define SANITIZER_INTERCEPT_PROTOENT (SI_NETBSD || SI_LINUX)\n-#define SANITIZER_INTERCEPT_PROTOENT_R (SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_PROTOENT_R SI_GLIBC\n #define SANITIZER_INTERCEPT_NETENT SI_NETBSD\n #define SANITIZER_INTERCEPT_SETVBUF \\\n   (SI_NETBSD || SI_FREEBSD || SI_LINUX || SI_MAC)\n@@ -583,12 +577,33 @@\n #define SANITIZER_INTERCEPT_GETENTROPY SI_FREEBSD\n #define SANITIZER_INTERCEPT_QSORT \\\n   (SI_POSIX && !SI_IOSSIM && !SI_WATCHOS && !SI_TVOS && !SI_ANDROID)\n-#define SANITIZER_INTERCEPT_QSORT_R (SI_LINUX && !SI_ANDROID)\n+#define SANITIZER_INTERCEPT_QSORT_R SI_GLIBC\n // sigaltstack on i386 macOS cannot be intercepted due to setjmp()\n // calling it and assuming that it does not clobber registers.\n #define SANITIZER_INTERCEPT_SIGALTSTACK \\\n   (SI_POSIX && !(SANITIZER_MAC && SANITIZER_I386))\n #define SANITIZER_INTERCEPT_UNAME (SI_POSIX && !SI_FREEBSD)\n #define SANITIZER_INTERCEPT___XUNAME SI_FREEBSD\n \n+// This macro gives a way for downstream users to override the above\n+// interceptor macros irrespective of the platform they are on. They have\n+// to do two things:\n+// 1. Build compiler-rt with -DSANITIZER_OVERRIDE_INTERCEPTORS.\n+// 2. Provide a header file named sanitizer_intercept_overriders.h in the\n+//    include path for their compiler-rt build.\n+// An example of an overrider for strlen interceptor that one can list in\n+// sanitizer_intercept_overriders.h is as follows:\n+//\n+// #ifdef SANITIZER_INTERCEPT_STRLEN\n+// #undef SANITIZER_INTERCEPT_STRLEN\n+// #define SANITIZER_INTERCEPT_STRLEN <value of choice>\n+// #endif\n+//\n+// This \"feature\" is useful for downstream users who do not want some of\n+// their libc funtions to be intercepted. They can selectively disable\n+// interception of those functions.\n+#ifdef SANITIZER_OVERRIDE_INTERCEPTORS\n+#include <sanitizer_intercept_overriders.h>\n+#endif\n+\n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "b5a45ae72cd9393d702ac15b19ac76201af887dd", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -35,7 +35,10 @@\n #include <sys/stat.h>\n #include <sys/statvfs.h>\n #include <sys/time.h>\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-W#warnings\"\n #include <sys/timeb.h>\n+#pragma clang diagnostic pop\n #include <sys/times.h>\n #include <sys/timespec.h>\n #include <sys/types.h>"}, {"sha": "c51327e1269e081cb0e231b75cbce71b62601e88", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -26,12 +26,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t"}, {"sha": "35a690cba5c834a6952ebc0d633195155b151447", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp", "status": "modified", "additions": 52, "deletions": 33, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -11,18 +11,19 @@\n // Sizes and layouts of platform-specific POSIX data structures.\n //===----------------------------------------------------------------------===//\n \n-#include \"sanitizer_platform.h\"\n-\n-#if SANITIZER_LINUX || SANITIZER_MAC\n+#if defined(__linux__) || defined(__APPLE__)\n // Tests in this file assume that off_t-dependent data structures match the\n // libc ABI. For example, struct dirent here is what readdir() function (as\n // exported from libc) returns, and not the user-facing \"dirent\", which\n // depends on _FILE_OFFSET_BITS setting.\n // To get this \"true\" dirent definition, we undefine _FILE_OFFSET_BITS below.\n-#ifdef _FILE_OFFSET_BITS\n #undef _FILE_OFFSET_BITS\n #endif\n \n+// Must go after undef _FILE_OFFSET_BITS.\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_LINUX || SANITIZER_MAC\n // Must go after undef _FILE_OFFSET_BITS.\n #include \"sanitizer_glibc_version.h\"\n \n@@ -37,6 +38,7 @@\n #include <pwd.h>\n #include <signal.h>\n #include <stddef.h>\n+#include <stdio.h>\n #include <sys/mman.h>\n #include <sys/resource.h>\n #include <sys/socket.h>\n@@ -58,7 +60,6 @@\n #endif\n \n #if !SANITIZER_ANDROID\n-#include <fstab.h>\n #include <sys/mount.h>\n #include <sys/timeb.h>\n #include <utmpx.h>\n@@ -110,20 +111,31 @@ typedef struct user_fpregs elf_fpregset_t;\n #include <wordexp.h>\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n-#include <glob.h>\n-#include <obstack.h>\n-#include <mqueue.h>\n+#if SANITIZER_LINUX\n+#if SANITIZER_GLIBC\n+#include <fstab.h>\n #include <net/if_ppp.h>\n #include <netax25/ax25.h>\n #include <netipx/ipx.h>\n #include <netrom/netrom.h>\n+#include <obstack.h>\n #if HAVE_RPC_XDR_H\n # include <rpc/xdr.h>\n #endif\n #include <scsi/scsi.h>\n-#include <sys/mtio.h>\n+#else\n+#include <linux/if_ppp.h>\n+#include <linux/kd.h>\n+#include <linux/ppp_defs.h>\n+#endif  // SANITIZER_GLIBC\n+\n+#if SANITIZER_ANDROID\n+#include <linux/mtio.h>\n+#else\n+#include <glob.h>\n+#include <mqueue.h>\n #include <sys/kd.h>\n+#include <sys/mtio.h>\n #include <sys/shm.h>\n #include <sys/statvfs.h>\n #include <sys/timex.h>\n@@ -142,20 +154,14 @@ typedef struct user_fpregs elf_fpregset_t;\n #include <sys/msg.h>\n #include <sys/ipc.h>\n #include <crypt.h>\n-#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n+#endif  // SANITIZER_ANDROID\n \n-#if SANITIZER_ANDROID\n-#include <linux/kd.h>\n-#include <linux/mtio.h>\n-#include <linux/ppp_defs.h>\n-#include <linux/if_ppp.h>\n-#endif\n-\n-#if SANITIZER_LINUX\n #include <link.h>\n #include <sys/vfs.h>\n #include <sys/epoll.h>\n #include <linux/capability.h>\n+#else\n+#include <fstab.h>\n #endif // SANITIZER_LINUX\n \n #if SANITIZER_MAC\n@@ -202,8 +208,11 @@ namespace __sanitizer {\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n #endif // (SANITIZER_MAC && !TARGET_CPU_ARM64) && !SANITIZER_IOS\n \n-#if !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_MAC\n   unsigned struct_fstab_sz = sizeof(struct fstab);\n+#endif  // SANITIZER_GLIBC || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n+        // SANITIZER_MAC\n+#if !SANITIZER_ANDROID\n   unsigned struct_statfs_sz = sizeof(struct statfs);\n   unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n   unsigned ucontext_t_sz = sizeof(ucontext_t);\n@@ -299,7 +308,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(ElfW(Phdr));\n unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC\n   int glob_nomatch = GLOB_NOMATCH;\n   int glob_altdirfunc = GLOB_ALTDIRFUNC;\n #endif\n@@ -422,7 +431,9 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_input_id_sz = sizeof(struct input_id);\n   unsigned struct_mtpos_sz = sizeof(struct mtpos);\n   unsigned struct_rtentry_sz = sizeof(struct rtentry);\n+#if SANITIZER_GLIBC || SANITIZER_ANDROID\n   unsigned struct_termio_sz = sizeof(struct termio);\n+#endif\n   unsigned struct_vt_consize_sz = sizeof(struct vt_consize);\n   unsigned struct_vt_sizes_sz = sizeof(struct vt_sizes);\n   unsigned struct_vt_stat_sz = sizeof(struct vt_stat);\n@@ -447,7 +458,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_vt_mode_sz = sizeof(struct vt_mode);\n #endif // SANITIZER_LINUX\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC\n   unsigned struct_ax25_parms_struct_sz = sizeof(struct ax25_parms_struct);\n   unsigned struct_cyclades_monitor_sz = sizeof(struct cyclades_monitor);\n #if EV_VERSION > (0x010000)\n@@ -470,12 +481,10 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_sockaddr_ax25_sz = sizeof(struct sockaddr_ax25);\n   unsigned struct_unimapdesc_sz = sizeof(struct unimapdesc);\n   unsigned struct_unimapinit_sz = sizeof(struct unimapinit);\n-#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n   unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n-#endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#endif  // SANITIZER_GLIBC\n \n #if !SANITIZER_ANDROID && !SANITIZER_MAC\n   unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n@@ -881,6 +890,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_PIO_UNIMAP = PIO_UNIMAP;\n   unsigned IOCTL_PIO_UNIMAPCLR = PIO_UNIMAPCLR;\n   unsigned IOCTL_PIO_UNISCRNMAP = PIO_UNISCRNMAP;\n+#if SANITIZER_GLIBC\n   unsigned IOCTL_SCSI_IOCTL_GET_IDLUN = SCSI_IOCTL_GET_IDLUN;\n   unsigned IOCTL_SCSI_IOCTL_PROBE_HOST = SCSI_IOCTL_PROBE_HOST;\n   unsigned IOCTL_SCSI_IOCTL_TAGGED_DISABLE = SCSI_IOCTL_TAGGED_DISABLE;\n@@ -899,6 +909,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_SIOCNRGETPARMS = SIOCNRGETPARMS;\n   unsigned IOCTL_SIOCNRRTCTL = SIOCNRRTCTL;\n   unsigned IOCTL_SIOCNRSETPARMS = SIOCNRSETPARMS;\n+#endif\n   unsigned IOCTL_TIOCGSERIAL = TIOCGSERIAL;\n   unsigned IOCTL_TIOCSERGETMULTI = TIOCSERGETMULTI;\n   unsigned IOCTL_TIOCSERSETMULTI = TIOCSERSETMULTI;\n@@ -969,7 +980,7 @@ CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n #endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC || SANITIZER_FREEBSD\n CHECK_TYPE_SIZE(glob_t);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n@@ -980,7 +991,7 @@ CHECK_SIZE_AND_OFFSET(glob_t, gl_readdir);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_opendir);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_lstat);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_stat);\n-#endif\n+#endif  // SANITIZER_GLIBC || SANITIZER_FREEBSD\n \n CHECK_TYPE_SIZE(addrinfo);\n CHECK_SIZE_AND_OFFSET(addrinfo, ai_flags);\n@@ -1003,17 +1014,27 @@ CHECK_TYPE_SIZE(iovec);\n CHECK_SIZE_AND_OFFSET(iovec, iov_base);\n CHECK_SIZE_AND_OFFSET(iovec, iov_len);\n \n+// In POSIX, int msg_iovlen; socklen_t msg_controllen; socklen_t cmsg_len; but\n+// many implementations don't conform to the standard. Since we pick the\n+// non-conforming glibc definition, exclude the checks for musl (incompatible\n+// sizes but compatible offsets).\n CHECK_TYPE_SIZE(msghdr);\n CHECK_SIZE_AND_OFFSET(msghdr, msg_name);\n CHECK_SIZE_AND_OFFSET(msghdr, msg_namelen);\n CHECK_SIZE_AND_OFFSET(msghdr, msg_iov);\n+#if SANITIZER_GLIBC || SANITIZER_ANDROID\n CHECK_SIZE_AND_OFFSET(msghdr, msg_iovlen);\n+#endif\n CHECK_SIZE_AND_OFFSET(msghdr, msg_control);\n+#if SANITIZER_GLIBC || SANITIZER_ANDROID\n CHECK_SIZE_AND_OFFSET(msghdr, msg_controllen);\n+#endif\n CHECK_SIZE_AND_OFFSET(msghdr, msg_flags);\n \n CHECK_TYPE_SIZE(cmsghdr);\n+#if SANITIZER_GLIBC || SANITIZER_ANDROID\n CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_len);\n+#endif\n CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_level);\n CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_type);\n \n@@ -1121,7 +1142,7 @@ CHECK_SIZE_AND_OFFSET(mntent, mnt_passno);\n \n CHECK_TYPE_SIZE(ether_addr);\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC || SANITIZER_FREEBSD\n CHECK_TYPE_SIZE(ipc_perm);\n # if SANITIZER_FREEBSD\n CHECK_SIZE_AND_OFFSET(ipc_perm, key);\n@@ -1183,7 +1204,7 @@ CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n #endif\n \n-#if SANITIZER_LINUX\n+#if SANITIZER_GLIBC || SANITIZER_ANDROID\n COMPILER_CHECK(sizeof(__sanitizer_struct_mallinfo) == sizeof(struct mallinfo));\n #endif\n \n@@ -1233,7 +1254,7 @@ COMPILER_CHECK(__sanitizer_XDR_DECODE == XDR_DECODE);\n COMPILER_CHECK(__sanitizer_XDR_FREE == XDR_FREE);\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if SANITIZER_GLIBC\n COMPILER_CHECK(sizeof(__sanitizer_FILE) <= sizeof(FILE));\n CHECK_SIZE_AND_OFFSET(FILE, _flags);\n CHECK_SIZE_AND_OFFSET(FILE, _IO_read_ptr);\n@@ -1250,9 +1271,7 @@ CHECK_SIZE_AND_OFFSET(FILE, _IO_save_end);\n CHECK_SIZE_AND_OFFSET(FILE, _markers);\n CHECK_SIZE_AND_OFFSET(FILE, _chain);\n CHECK_SIZE_AND_OFFSET(FILE, _fileno);\n-#endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n COMPILER_CHECK(sizeof(__sanitizer__obstack_chunk) <= sizeof(_obstack_chunk));\n CHECK_SIZE_AND_OFFSET(_obstack_chunk, limit);\n CHECK_SIZE_AND_OFFSET(_obstack_chunk, prev);\n@@ -1267,7 +1286,7 @@ CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, read);\n CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, write);\n CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, seek);\n CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, close);\n-#endif\n+#endif  // SANITIZER_GLIBC\n \n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n CHECK_TYPE_SIZE(sem_t);"}, {"sha": "836b178c131ba03680eeaaaf04aeb1848c90564b", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -83,7 +83,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                            ? FIRST_32_SECOND_64(104, 128)\n-                                           : FIRST_32_SECOND_64(144, 216);\n+                                           : FIRST_32_SECOND_64(160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;\n@@ -443,6 +443,8 @@ struct __sanitizer_cmsghdr {\n   int cmsg_type;\n };\n #else\n+// In POSIX, int msg_iovlen; socklen_t msg_controllen; socklen_t cmsg_len; but\n+// many implementations don't conform to the standard.\n struct __sanitizer_msghdr {\n   void *msg_name;\n   unsigned msg_namelen;"}, {"sha": "f8457a6aac413849593fbaf88902b9b4e9bab67a", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -275,8 +275,8 @@ void ReportFile::Write(const char *buffer, uptr length) {\n \n bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {\n   MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n-  InternalScopedString buff(kMaxPathLength);\n-  MemoryMappedSegment segment(buff.data(), kMaxPathLength);\n+  InternalMmapVector<char> buff(kMaxPathLength);\n+  MemoryMappedSegment segment(buff.data(), buff.size());\n   while (proc_maps.Next(&segment)) {\n     if (segment.IsExecutable() &&\n         internal_strcmp(module, segment.filename) == 0) {"}, {"sha": "b65dae644767ade1bd35440405f8fffb669acb0a", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -40,6 +40,10 @@ uptr internal_write(fd_t fd, const void *buf, uptr count);\n uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n                    int fd, u64 offset);\n uptr internal_munmap(void *addr, uptr length);\n+#if SANITIZER_LINUX\n+uptr internal_mremap(void *old_address, uptr old_size, uptr new_size, int flags,\n+                     void *new_address);\n+#endif\n int internal_mprotect(void *addr, uptr length, int prot);\n int internal_madvise(uptr addr, uptr length, int advice);\n "}, {"sha": "d1d8e509c4dbaa2cb1a0d020959765c20fa7a895", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -143,7 +143,7 @@ void Abort() {\n   if (GetHandleSignalMode(SIGABRT) != kHandleSignalNo) {\n     struct sigaction sigact;\n     internal_memset(&sigact, 0, sizeof(sigact));\n-    sigact.sa_sigaction = (sa_sigaction_t)SIG_DFL;\n+    sigact.sa_handler = SIG_DFL;\n     internal_sigaction(SIGABRT, &sigact, nullptr);\n   }\n #endif"}, {"sha": "5d16dfde678654984defe8cb22aea9725803c9cc", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cpp", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -249,26 +249,21 @@ static void NOINLINE SharedPrintfCodeNoBuffer(bool append_pid,\n                                               va_list args) {\n   va_list args2;\n   va_copy(args2, args);\n-  const int kLen = 16 * 1024;\n-  int needed_length;\n+  InternalMmapVector<char> v;\n+  int needed_length = 0;\n   char *buffer = local_buffer;\n   // First try to print a message using a local buffer, and then fall back to\n   // mmaped buffer.\n-  for (int use_mmap = 0; use_mmap < 2; use_mmap++) {\n+  for (int use_mmap = 0;; use_mmap++) {\n     if (use_mmap) {\n       va_end(args);\n       va_copy(args, args2);\n-      buffer = (char*)MmapOrDie(kLen, \"Report\");\n-      buffer_size = kLen;\n+      v.resize(needed_length + 1);\n+      buffer_size = v.capacity();\n+      v.resize(buffer_size);\n+      buffer = &v[0];\n     }\n     needed_length = 0;\n-    // Check that data fits into the current buffer.\n-#   define CHECK_NEEDED_LENGTH \\\n-      if (needed_length >= buffer_size) { \\\n-        if (!use_mmap) continue; \\\n-        RAW_CHECK_MSG(needed_length < kLen, \\\n-                      \"Buffer in Report is too short!\\n\"); \\\n-      }\n     // Fuchsia's logging infrastructure always keeps track of the logging\n     // process, thread, and timestamp, so never prepend such information.\n     if (!SANITIZER_FUCHSIA && append_pid) {\n@@ -277,18 +272,20 @@ static void NOINLINE SharedPrintfCodeNoBuffer(bool append_pid,\n       if (common_flags()->log_exe_name && exe_name) {\n         needed_length += internal_snprintf(buffer, buffer_size,\n                                            \"==%s\", exe_name);\n-        CHECK_NEEDED_LENGTH\n+        if (needed_length >= buffer_size)\n+          continue;\n       }\n       needed_length += internal_snprintf(\n           buffer + needed_length, buffer_size - needed_length, \"==%d==\", pid);\n-      CHECK_NEEDED_LENGTH\n+      if (needed_length >= buffer_size)\n+        continue;\n     }\n     needed_length += VSNPrintf(buffer + needed_length,\n                                buffer_size - needed_length, format, args);\n-    CHECK_NEEDED_LENGTH\n+    if (needed_length >= buffer_size)\n+      continue;\n     // If the message fit into the buffer, print it and exit.\n     break;\n-#   undef CHECK_NEEDED_LENGTH\n   }\n   RawWrite(buffer);\n \n@@ -297,9 +294,6 @@ static void NOINLINE SharedPrintfCodeNoBuffer(bool append_pid,\n   CallPrintfAndReportCallback(buffer);\n   LogMessageOnPrintf(buffer);\n \n-  // If we had mapped any memory, clean up.\n-  if (buffer != local_buffer)\n-    UnmapOrDie((void *)buffer, buffer_size);\n   va_end(args2);\n }\n \n@@ -346,13 +340,24 @@ int internal_snprintf(char *buffer, uptr length, const char *format, ...) {\n \n FORMAT(2, 3)\n void InternalScopedString::append(const char *format, ...) {\n-  CHECK_LT(length_, size());\n-  va_list args;\n-  va_start(args, format);\n-  VSNPrintf(data() + length_, size() - length_, format, args);\n-  va_end(args);\n-  length_ += internal_strlen(data() + length_);\n-  CHECK_LT(length_, size());\n+  uptr prev_len = length();\n+\n+  while (true) {\n+    buffer_.resize(buffer_.capacity());\n+\n+    va_list args;\n+    va_start(args, format);\n+    uptr sz = VSNPrintf(buffer_.data() + prev_len, buffer_.size() - prev_len,\n+                        format, args);\n+    va_end(args);\n+    if (sz < buffer_.size() - prev_len) {\n+      buffer_.resize(prev_len + sz + 1);\n+      break;\n+    }\n+\n+    buffer_.reserve(buffer_.capacity() * 2);\n+  }\n+  CHECK_EQ(buffer_[length()], '\\0');\n }\n \n } // namespace __sanitizer"}, {"sha": "1b7dd46d8de4f793822b66abc7eadb5129884bcf", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -120,7 +120,7 @@ void MemoryMappingLayout::LoadFromCache() {\n void MemoryMappingLayout::DumpListOfModules(\n     InternalMmapVectorNoCtor<LoadedModule> *modules) {\n   Reset();\n-  InternalScopedString module_name(kMaxPathLength);\n+  InternalMmapVector<char> module_name(kMaxPathLength);\n   MemoryMappedSegment segment(module_name.data(), module_name.size());\n   for (uptr i = 0; Next(&segment); i++) {\n     const char *cur_name = segment.filename;"}, {"sha": "1f53e3e46d8fea509e882992b4e17187b2090f4f", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -354,8 +354,8 @@ bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n void MemoryMappingLayout::DumpListOfModules(\n     InternalMmapVectorNoCtor<LoadedModule> *modules) {\n   Reset();\n-  InternalScopedString module_name(kMaxPathLength);\n-  MemoryMappedSegment segment(module_name.data(), kMaxPathLength);\n+  InternalMmapVector<char> module_name(kMaxPathLength);\n+  MemoryMappedSegment segment(module_name.data(), module_name.size());\n   MemoryMappedSegmentData data;\n   segment.data_ = &data;\n   while (Next(&segment)) {"}, {"sha": "bf813f235bb7a9987241f4ba5924b68e04fbfbea", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_solaris.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -9,13 +9,13 @@\n // Information about the process mappings (Solaris-specific parts).\n //===----------------------------------------------------------------------===//\n \n+// Before Solaris 11.4, <procfs.h> doesn't work in a largefile environment.\n+#undef _FILE_OFFSET_BITS\n #include \"sanitizer_platform.h\"\n #if SANITIZER_SOLARIS\n #include \"sanitizer_common.h\"\n #include \"sanitizer_procmaps.h\"\n \n-// Before Solaris 11.4, <procfs.h> doesn't work in a largefile environment.\n-#undef _FILE_OFFSET_BITS\n #include <procfs.h>\n #include <limits.h>\n "}, {"sha": "5200354694851eba77f0eb9dbe2a58d62a06889d", "filename": "libsanitizer/sanitizer_common/sanitizer_ptrauth.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -11,13 +11,31 @@\n \n #if __has_feature(ptrauth_calls)\n #include <ptrauth.h>\n+#elif defined(__ARM_FEATURE_PAC_DEFAULT) && !defined(__APPLE__)\n+inline unsigned long ptrauth_strip(void* __value, unsigned int __key) {\n+  // On the stack the link register is protected with Pointer\n+  // Authentication Code when compiled with -mbranch-protection.\n+  // Let's stripping the PAC unconditionally because xpaclri is in\n+  // the NOP space so will do nothing when it is not enabled or not available.\n+  unsigned long ret;\n+  asm volatile(\n+      \"mov x30, %1\\n\\t\"\n+      \"hint #7\\n\\t\"  // xpaclri\n+      \"mov %0, x30\\n\\t\"\n+      : \"=r\"(ret)\n+      : \"r\"(__value)\n+      : \"x30\");\n+  return ret;\n+}\n+#define ptrauth_auth_data(__value, __old_key, __old_data) __value\n+#define ptrauth_string_discriminator(__string) ((int)0)\n #else\n // Copied from <ptrauth.h>\n #define ptrauth_strip(__value, __key) __value\n #define ptrauth_auth_data(__value, __old_key, __old_data) __value\n #define ptrauth_string_discriminator(__string) ((int)0)\n #endif\n \n-#define STRIP_PC(pc) ((uptr)ptrauth_strip(pc, 0))\n+#define STRIP_PAC_PC(pc) ((uptr)ptrauth_strip(pc, 0))\n \n #endif // SANITIZER_PTRAUTH_H"}, {"sha": "44a95214e38bfeb91dfea21f869cc0bce206b0d5", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -145,8 +145,7 @@ StackTrace StackDepotReverseMap::Get(u32 id) {\n   if (!map_.size())\n     return StackTrace();\n   IdDescPair pair = {id, nullptr};\n-  uptr idx =\n-      InternalLowerBound(map_, 0, map_.size(), pair, IdDescPair::IdComparator);\n+  uptr idx = InternalLowerBound(map_, pair, IdDescPair::IdComparator);\n   if (idx > map_.size() || map_[idx].id != id)\n     return StackTrace();\n   return map_[idx].desc->load();"}, {"sha": "07e4409f4a5d6680db353a449d6b861f48d8b7ac", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -15,6 +15,7 @@\n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_platform.h\"\n+#include \"sanitizer_ptrauth.h\"\n \n namespace __sanitizer {\n \n@@ -84,8 +85,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -108,28 +109,21 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #elif defined(__riscv)\n     // frame[-1] contains the return address\n     uhwptr pc1 = frame[-1];\n #else\n-    uhwptr pc1 = frame[1];\n+    uhwptr pc1 = STRIP_PAC_PC((void *)frame[1]);\n #endif\n     // Let's assume that any pointer in the 0th page (i.e. <0x1000 on i386 and\n     // x86_64) is invalid and stop unwinding here.  If we're adding support for"}, {"sha": "15616f899d01ecc33a1a8afe5666a1fcfca373d2", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -67,8 +67,6 @@ struct StackTrace {\n   static uptr GetCurrentPc();\n   static inline uptr GetPreviousInstructionPc(uptr pc);\n   static uptr GetNextInstructionPc(uptr pc);\n-  typedef bool (*SymbolizeCallback)(const void *pc, char *out_buffer,\n-                                    int out_size);\n };\n \n // Performance-critical, must be in the header."}, {"sha": "738633209f087b9411eea7c8b0618e7e0cf1fdb0", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -23,8 +23,8 @@ void StackTrace::Print() const {\n     Printf(\"    <empty stack>\\n\\n\");\n     return;\n   }\n-  InternalScopedString frame_desc(GetPageSizeCached() * 2);\n-  InternalScopedString dedup_token(GetPageSizeCached());\n+  InternalScopedString frame_desc;\n+  InternalScopedString dedup_token;\n   int dedup_frames = common_flags()->dedup_token_length;\n   bool symbolize = RenderNeedsSymbolization(common_flags()->stack_trace_format);\n   uptr frame_num = 0;\n@@ -125,7 +125,7 @@ void __sanitizer_symbolize_pc(uptr pc, const char *fmt, char *out_buf,\n     out_buf[out_buf_size - 1] = 0;\n     return;\n   }\n-  InternalScopedString frame_desc(GetPageSizeCached());\n+  InternalScopedString frame_desc;\n   uptr frame_num = 0;\n   // Reserve one byte for the final 0.\n   char *out_end = out_buf + out_buf_size - 1;\n@@ -156,7 +156,7 @@ void __sanitizer_symbolize_global(uptr data_addr, const char *fmt,\n   out_buf[0] = 0;\n   DataInfo DI;\n   if (!Symbolizer::GetOrInit()->SymbolizeData(data_addr, &DI)) return;\n-  InternalScopedString data_desc(GetPageSizeCached());\n+  InternalScopedString data_desc;\n   RenderData(&data_desc, fmt, &DI, common_flags()->strip_path_prefix);\n   internal_strncpy(out_buf, data_desc.data(), out_buf_size);\n   out_buf[out_buf_size - 1] = 0;"}, {"sha": "53cfddcfbe0bebf00be9b43ebd9d2c5bedf07488", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -490,6 +490,9 @@ typedef user_regs_struct regs_struct;\n #ifndef NT_X86_XSTATE\n #define NT_X86_XSTATE 0x202\n #endif\n+#ifndef PTRACE_GETREGSET\n+#define PTRACE_GETREGSET 0x4204\n+#endif\n // Compiler may use FP registers to store pointers.\n static constexpr uptr kExtraRegs[] = {NT_X86_XSTATE, NT_FPREGSET};\n \n@@ -513,6 +516,8 @@ static constexpr uptr kExtraRegs[] = {0};\n \n #elif SANITIZER_RISCV64\n typedef struct user_regs_struct regs_struct;\n+// sys/ucontext.h already defines REG_SP as 2. Undefine it first.\n+#undef REG_SP\n #define REG_SP sp\n static constexpr uptr kExtraRegs[] = {0};\n #define ARCH_IOVEC_FOR_GETREGSET"}, {"sha": "a674034b8e291c9c9b862bb241996e59c1761172", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -34,7 +34,7 @@ SuppressionContext::SuppressionContext(const char *suppression_types[],\n static bool GetPathAssumingFileIsRelativeToExec(const char *file_path,\n                                                 /*out*/char *new_file_path,\n                                                 uptr new_file_path_size) {\n-  InternalScopedString exec(kMaxPathLength);\n+  InternalMmapVector<char> exec(kMaxPathLength);\n   if (ReadBinaryNameCached(exec.data(), exec.size())) {\n     const char *file_name_pos = StripModuleName(exec.data());\n     uptr path_to_exec_len = file_name_pos - exec.data();\n@@ -69,7 +69,7 @@ void SuppressionContext::ParseFromFile(const char *filename) {\n   if (filename[0] == '\\0')\n     return;\n \n-  InternalScopedString new_file_path(kMaxPathLength);\n+  InternalMmapVector<char> new_file_path(kMaxPathLength);\n   filename = FindFile(filename, new_file_path.data(), new_file_path.size());\n \n   // Read the file."}, {"sha": "98418b426c376d63ebfe55cf117980fb82661e3f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -356,7 +356,7 @@ void ParseSymbolizePCOutput(const char *str, SymbolizedStack *res) {\n       InternalFree(info->function);\n       info->function = 0;\n     }\n-    if (0 == internal_strcmp(info->file, \"??\")) {\n+    if (info->file && 0 == internal_strcmp(info->file, \"??\")) {\n       InternalFree(info->file);\n       info->file = 0;\n     }"}, {"sha": "01edef9c1aa9b21091e97c8ee67831a175f530fc", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -54,6 +54,10 @@ bool Symbolizer::GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n   return false;\n }\n \n+// This is mainly used by hwasan for online symbolization. This isn't needed\n+// since hwasan can always just dump stack frames for offline symbolization.\n+bool Symbolizer::SymbolizeFrame(uptr addr, FrameInfo *info) { return false; }\n+\n // This is used in some places for suppression checking, which we\n // don't really support for Fuchsia.  It's also used in UBSan to\n // identify a PC location to a function name, so we always fill in"}, {"sha": "4cd4b4636f0a871587998c27447763ddda135bad", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -400,11 +400,20 @@ const char *Symbolizer::PlatformDemangle(const char *name) {\n \n static SymbolizerTool *ChooseExternalSymbolizer(LowLevelAllocator *allocator) {\n   const char *path = common_flags()->external_symbolizer_path;\n+\n+  if (path && internal_strchr(path, '%')) {\n+    char *new_path = (char *)InternalAlloc(kMaxPathLength);\n+    SubstituteForFlagValue(path, new_path, kMaxPathLength);\n+    path = new_path;\n+  }\n+\n   const char *binary_name = path ? StripModuleName(path) : \"\";\n+  static const char kLLVMSymbolizerPrefix[] = \"llvm-symbolizer\";\n   if (path && path[0] == '\\0') {\n     VReport(2, \"External symbolizer is explicitly disabled.\\n\");\n     return nullptr;\n-  } else if (!internal_strcmp(binary_name, \"llvm-symbolizer\")) {\n+  } else if (!internal_strncmp(binary_name, kLLVMSymbolizerPrefix,\n+                               internal_strlen(kLLVMSymbolizerPrefix))) {\n     VReport(2, \"Using llvm-symbolizer at user-specified path: %s\\n\", path);\n     return new(*allocator) LLVMSymbolizer(path, allocator);\n   } else if (!internal_strcmp(binary_name, \"atos\")) {"}, {"sha": "9287993e665f697270b8d10c344ad486a644a2fe", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -31,7 +31,7 @@ namespace __sanitizer {\n void ReportErrorSummary(const char *error_type, const AddressInfo &info,\n                         const char *alt_tool_name) {\n   if (!common_flags()->print_summary) return;\n-  InternalScopedString buff(kMaxSummaryLength);\n+  InternalScopedString buff;\n   buff.append(\"%s \", error_type);\n   RenderFrame(&buff, \"%L %F\", 0, info.address, &info,\n               common_flags()->symbolize_vs_style,\n@@ -150,7 +150,7 @@ static void PrintMemoryByte(InternalScopedString *str, const char *before,\n static void MaybeDumpInstructionBytes(uptr pc) {\n   if (!common_flags()->dump_instruction_bytes || (pc < GetPageSizeCached()))\n     return;\n-  InternalScopedString str(1024);\n+  InternalScopedString str;\n   str.append(\"First 16 instruction bytes at pc: \");\n   if (IsAccessibleMemoryRange(pc, 16)) {\n     for (int i = 0; i < 16; ++i) {\n@@ -211,7 +211,7 @@ static void ReportDeadlySignalImpl(const SignalContext &sig, u32 tid,\n     Report(\"The signal is caused by a %s memory access.\\n\", access_type);\n     if (!sig.is_true_faulting_addr)\n       Report(\"Hint: this fault was caused by a dereference of a high value \"\n-             \"address (see register values below).  Dissassemble the provided \"\n+             \"address (see register values below).  Disassemble the provided \"\n              \"pc to learn which register was used.\\n\");\n     else if (sig.addr < GetPageSizeCached())\n       Report(\"Hint: address points to the zero page.\\n\");"}, {"sha": "702d901353dba142dc0f746fc16587961bb07a94", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cpp", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -136,9 +136,10 @@ void InitializeDbgHelpIfNeeded() {\n bool WinSymbolizerTool::SymbolizePC(uptr addr, SymbolizedStack *frame) {\n   InitializeDbgHelpIfNeeded();\n \n-  // See http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx\n-  char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(CHAR)];\n-  PSYMBOL_INFO symbol = (PSYMBOL_INFO)buffer;\n+  // See https://docs.microsoft.com/en-us/windows/win32/debug/retrieving-symbol-information-by-address\n+  InternalMmapVector<char> buffer(sizeof(SYMBOL_INFO) +\n+                                  MAX_SYM_NAME * sizeof(CHAR));\n+  PSYMBOL_INFO symbol = (PSYMBOL_INFO)&buffer[0];\n   symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n   symbol->MaxNameLen = MAX_SYM_NAME;\n   DWORD64 offset = 0;\n@@ -223,7 +224,7 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n   // Compute the command line. Wrap double quotes around everything.\n   const char *argv[kArgVMax];\n   GetArgV(path_, argv);\n-  InternalScopedString command_line(kMaxPathLength * 3);\n+  InternalScopedString command_line;\n   for (int i = 0; argv[i]; i++) {\n     const char *arg = argv[i];\n     int arglen = internal_strlen(arg);\n@@ -281,8 +282,15 @@ static void ChooseSymbolizerTools(IntrusiveList<SymbolizerTool> *list,\n     return;\n   }\n \n-  // Add llvm-symbolizer in case the binary has dwarf.\n+  // Add llvm-symbolizer.\n   const char *user_path = common_flags()->external_symbolizer_path;\n+\n+  if (user_path && internal_strchr(user_path, '%')) {\n+    char *new_path = (char *)InternalAlloc(kMaxPathLength);\n+    SubstituteForFlagValue(user_path, new_path, kMaxPathLength);\n+    user_path = new_path;\n+  }\n+\n   const char *path =\n       user_path ? user_path : FindPathToBinary(\"llvm-symbolizer.exe\");\n   if (path) {"}, {"sha": "6a54734353c5aa77a49acd89df33fc1d0cd6be6c", "filename": "libsanitizer/sanitizer_common/sanitizer_termination.cpp", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -59,26 +59,31 @@ void NORETURN Die() {\n   internal__exit(common_flags()->exitcode);\n }\n \n-static CheckFailedCallbackType CheckFailedCallback;\n-void SetCheckFailedCallback(CheckFailedCallbackType callback) {\n-  CheckFailedCallback = callback;\n+static void (*CheckUnwindCallback)();\n+void SetCheckUnwindCallback(void (*callback)()) {\n+  CheckUnwindCallback = callback;\n }\n \n-const int kSecondsToSleepWhenRecursiveCheckFailed = 2;\n-\n void NORETURN CheckFailed(const char *file, int line, const char *cond,\n                           u64 v1, u64 v2) {\n-  static atomic_uint32_t num_calls;\n-  if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) > 10) {\n-    SleepForSeconds(kSecondsToSleepWhenRecursiveCheckFailed);\n+  u32 tid = GetTid();\n+  Printf(\"%s: CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx) (tid=%u)\\n\",\n+         SanitizerToolName, StripModuleName(file), line, cond, (uptr)v1,\n+         (uptr)v2, tid);\n+  static atomic_uint32_t first_tid;\n+  u32 cmp = 0;\n+  if (!atomic_compare_exchange_strong(&first_tid, &cmp, tid,\n+                                      memory_order_relaxed)) {\n+    if (cmp == tid) {\n+      // Recursing into CheckFailed.\n+    } else {\n+      // Another thread fails already, let it print the stack and terminate.\n+      SleepForSeconds(2);\n+    }\n     Trap();\n   }\n-\n-  if (CheckFailedCallback) {\n-    CheckFailedCallback(file, line, cond, v1, v2);\n-  }\n-  Report(\"Sanitizer CHECK failed: %s:%d %s (%lld, %lld)\\n\", file, line, cond,\n-                                                            v1, v2);\n+  if (CheckUnwindCallback)\n+    CheckUnwindCallback();\n   Die();\n }\n "}, {"sha": "3273da38bfd6cd5f36359d32894d508da15d0612", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -85,7 +85,7 @@ void ThreadContextBase::SetCreated(uptr _user_id, u64 _unique_id,\n   unique_id = _unique_id;\n   detached = _detached;\n   // Parent tid makes no sense for the main thread.\n-  if (tid != 0)\n+  if (tid != kMainTid)\n     parent_tid = _parent_tid;\n   OnCreated(arg);\n }\n@@ -99,8 +99,6 @@ void ThreadContextBase::Reset() {\n \n // ThreadRegistry implementation.\n \n-const u32 ThreadRegistry::kUnknownTid = ~0U;\n-\n ThreadRegistry::ThreadRegistry(ThreadContextFactory factory, u32 max_threads,\n                                u32 thread_quarantine_size, u32 max_reuse)\n     : context_factory_(factory),\n@@ -135,7 +133,7 @@ uptr ThreadRegistry::GetMaxAliveThreads() {\n u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,\n                                  void *arg) {\n   BlockingMutexLock l(&mtx_);\n-  u32 tid = kUnknownTid;\n+  u32 tid = kInvalidTid;\n   ThreadContextBase *tctx = QuarantinePop();\n   if (tctx) {\n     tid = tctx->tid;\n@@ -155,7 +153,7 @@ u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,\n     Die();\n   }\n   CHECK_NE(tctx, 0);\n-  CHECK_NE(tid, kUnknownTid);\n+  CHECK_NE(tid, kInvalidTid);\n   CHECK_LT(tid, max_threads_);\n   CHECK_EQ(tctx->status, ThreadStatusInvalid);\n   alive_threads_++;\n@@ -186,7 +184,7 @@ u32 ThreadRegistry::FindThread(FindThreadCallback cb, void *arg) {\n     if (tctx != 0 && cb(tctx, arg))\n       return tctx->tid;\n   }\n-  return kUnknownTid;\n+  return kInvalidTid;\n }\n \n ThreadContextBase *\n@@ -278,14 +276,15 @@ void ThreadRegistry::JoinThread(u32 tid, void *arg) {\n // really started.  We just did CreateThread for a prospective new\n // thread before trying to create it, and then failed to actually\n // create it, and so never called StartThread.\n-void ThreadRegistry::FinishThread(u32 tid) {\n+ThreadStatus ThreadRegistry::FinishThread(u32 tid) {\n   BlockingMutexLock l(&mtx_);\n   CHECK_GT(alive_threads_, 0);\n   alive_threads_--;\n   CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   bool dead = tctx->detached;\n+  ThreadStatus prev_status = tctx->status;\n   if (tctx->status == ThreadStatusRunning) {\n     CHECK_GT(running_threads_, 0);\n     running_threads_--;\n@@ -300,6 +299,7 @@ void ThreadRegistry::FinishThread(u32 tid) {\n     QuarantinePush(tctx);\n   }\n   tctx->SetDestroyed();\n+  return prev_status;\n }\n \n void ThreadRegistry::StartThread(u32 tid, tid_t os_id, ThreadType thread_type,"}, {"sha": "dcd445c28ae9290f1725b9947598dea04dfc1432", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -87,8 +87,6 @@ typedef ThreadContextBase* (*ThreadContextFactory)(u32 tid);\n \n class ThreadRegistry {\n  public:\n-  static const u32 kUnknownTid;\n-\n   ThreadRegistry(ThreadContextFactory factory, u32 max_threads,\n                  u32 thread_quarantine_size, u32 max_reuse = 0);\n   void GetNumberOfThreads(uptr *total = nullptr, uptr *running = nullptr,\n@@ -113,7 +111,7 @@ class ThreadRegistry {\n   void RunCallbackForEachThreadLocked(ThreadCallback cb, void *arg);\n \n   typedef bool (*FindThreadCallback)(ThreadContextBase *tctx, void *arg);\n-  // Finds a thread using the provided callback. Returns kUnknownTid if no\n+  // Finds a thread using the provided callback. Returns kInvalidTid if no\n   // thread is found.\n   u32 FindThread(FindThreadCallback cb, void *arg);\n   // Should be guarded by ThreadRegistryLock. Return 0 if no thread\n@@ -126,7 +124,8 @@ class ThreadRegistry {\n   void SetThreadNameByUserId(uptr user_id, const char *name);\n   void DetachThread(u32 tid, void *arg);\n   void JoinThread(u32 tid, void *arg);\n-  void FinishThread(u32 tid);\n+  // Finishes thread and returns previous status.\n+  ThreadStatus FinishThread(u32 tid);\n   void StartThread(u32 tid, tid_t os_id, ThreadType thread_type, void *arg);\n   void SetThreadUserId(u32 tid, uptr user_id);\n "}, {"sha": "1f664b6cf5b8fbc772677566ace589d61a2878fb", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cpp", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -12,6 +12,7 @@\n \n #include \"sanitizer_tls_get_addr.h\"\n \n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_platform_interceptors.h\"\n \n@@ -42,39 +43,54 @@ static atomic_uintptr_t number_of_live_dtls;\n \n static const uptr kDestroyedThread = -1;\n \n-static inline void DTLS_Deallocate(DTLS::DTV *dtv, uptr size) {\n-  if (!size) return;\n-  VReport(2, \"__tls_get_addr: DTLS_Deallocate %p %zd\\n\", dtv, size);\n-  UnmapOrDie(dtv, size * sizeof(DTLS::DTV));\n+static void DTLS_Deallocate(DTLS::DTVBlock *block) {\n+  VReport(2, \"__tls_get_addr: DTLS_Deallocate %p %zd\\n\", block);\n+  UnmapOrDie(block, sizeof(DTLS::DTVBlock));\n   atomic_fetch_sub(&number_of_live_dtls, 1, memory_order_relaxed);\n }\n \n-static inline void DTLS_Resize(uptr new_size) {\n-  if (dtls.dtv_size >= new_size) return;\n-  new_size = RoundUpToPowerOfTwo(new_size);\n-  new_size = Max(new_size, 4096UL / sizeof(DTLS::DTV));\n-  DTLS::DTV *new_dtv =\n-      (DTLS::DTV *)MmapOrDie(new_size * sizeof(DTLS::DTV), \"DTLS_Resize\");\n+static DTLS::DTVBlock *DTLS_NextBlock(atomic_uintptr_t *cur) {\n+  uptr v = atomic_load(cur, memory_order_acquire);\n+  if (v == kDestroyedThread)\n+    return nullptr;\n+  DTLS::DTVBlock *next = (DTLS::DTVBlock *)v;\n+  if (next)\n+    return next;\n+  DTLS::DTVBlock *new_dtv =\n+      (DTLS::DTVBlock *)MmapOrDie(sizeof(DTLS::DTVBlock), \"DTLS_NextBlock\");\n+  uptr prev = 0;\n+  if (!atomic_compare_exchange_strong(cur, &prev, (uptr)new_dtv,\n+                                      memory_order_seq_cst)) {\n+    UnmapOrDie(new_dtv, sizeof(DTLS::DTVBlock));\n+    return (DTLS::DTVBlock *)prev;\n+  }\n   uptr num_live_dtls =\n       atomic_fetch_add(&number_of_live_dtls, 1, memory_order_relaxed);\n-  VReport(2, \"__tls_get_addr: DTLS_Resize %p %zd\\n\", &dtls, num_live_dtls);\n-  CHECK_LT(num_live_dtls, 1 << 20);\n-  uptr old_dtv_size = dtls.dtv_size;\n-  DTLS::DTV *old_dtv = dtls.dtv;\n-  if (old_dtv_size)\n-    internal_memcpy(new_dtv, dtls.dtv, dtls.dtv_size * sizeof(DTLS::DTV));\n-  dtls.dtv = new_dtv;\n-  dtls.dtv_size = new_size;\n-  if (old_dtv_size)\n-    DTLS_Deallocate(old_dtv, old_dtv_size);\n+  VReport(2, \"__tls_get_addr: DTLS_NextBlock %p %zd\\n\", &dtls, num_live_dtls);\n+  return new_dtv;\n+}\n+\n+static DTLS::DTV *DTLS_Find(uptr id) {\n+  VReport(2, \"__tls_get_addr: DTLS_Find %p %zd\\n\", &dtls, id);\n+  static constexpr uptr kPerBlock = ARRAY_SIZE(DTLS::DTVBlock::dtvs);\n+  DTLS::DTVBlock *cur = DTLS_NextBlock(&dtls.dtv_block);\n+  if (!cur)\n+    return nullptr;\n+  for (; id >= kPerBlock; id -= kPerBlock) cur = DTLS_NextBlock(&cur->next);\n+  return cur->dtvs + id;\n }\n \n void DTLS_Destroy() {\n   if (!common_flags()->intercept_tls_get_addr) return;\n-  VReport(2, \"__tls_get_addr: DTLS_Destroy %p %zd\\n\", &dtls, dtls.dtv_size);\n-  uptr s = dtls.dtv_size;\n-  dtls.dtv_size = kDestroyedThread;  // Do this before unmap for AS-safety.\n-  DTLS_Deallocate(dtls.dtv, s);\n+  VReport(2, \"__tls_get_addr: DTLS_Destroy %p\\n\", &dtls);\n+  DTLS::DTVBlock *block = (DTLS::DTVBlock *)atomic_exchange(\n+      &dtls.dtv_block, kDestroyedThread, memory_order_release);\n+  while (block) {\n+    DTLS::DTVBlock *next =\n+        (DTLS::DTVBlock *)atomic_load(&block->next, memory_order_acquire);\n+    DTLS_Deallocate(block);\n+    block = next;\n+  }\n }\n \n #if defined(__powerpc64__) || defined(__mips__)\n@@ -96,9 +112,9 @@ DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,\n   if (!common_flags()->intercept_tls_get_addr) return 0;\n   TlsGetAddrParam *arg = reinterpret_cast<TlsGetAddrParam *>(arg_void);\n   uptr dso_id = arg->dso_id;\n-  if (dtls.dtv_size == kDestroyedThread) return 0;\n-  DTLS_Resize(dso_id + 1);\n-  if (dtls.dtv[dso_id].beg) return 0;\n+  DTLS::DTV *dtv = DTLS_Find(dso_id);\n+  if (!dtv || dtv->beg)\n+    return 0;\n   uptr tls_size = 0;\n   uptr tls_beg = reinterpret_cast<uptr>(res) - arg->offset - kDtvOffset;\n   VReport(2, \"__tls_get_addr: %p {%p,%p} => %p; tls_beg: %p; sp: %p \"\n@@ -126,9 +142,9 @@ DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res,\n     // This may happen inside the DTOR of main thread, so just ignore it.\n     tls_size = 0;\n   }\n-  dtls.dtv[dso_id].beg = tls_beg;\n-  dtls.dtv[dso_id].size = tls_size;\n-  return dtls.dtv + dso_id;\n+  dtv->beg = tls_beg;\n+  dtv->size = tls_size;\n+  return dtv;\n }\n \n void DTLS_on_libc_memalign(void *ptr, uptr size) {\n@@ -141,7 +157,8 @@ void DTLS_on_libc_memalign(void *ptr, uptr size) {\n DTLS *DTLS_Get() { return &dtls; }\n \n bool DTLSInDestruction(DTLS *dtls) {\n-  return dtls->dtv_size == kDestroyedThread;\n+  return atomic_load(&dtls->dtv_block, memory_order_relaxed) ==\n+         kDestroyedThread;\n }\n \n #else"}, {"sha": "a599c0bbc75cced7332f61335b141051edb406f3", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -28,6 +28,7 @@\n #ifndef SANITIZER_TLS_GET_ADDR_H\n #define SANITIZER_TLS_GET_ADDR_H\n \n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n \n namespace __sanitizer {\n@@ -38,15 +39,31 @@ struct DTLS {\n   struct DTV {\n     uptr beg, size;\n   };\n+  struct DTVBlock {\n+    atomic_uintptr_t next;\n+    DTV dtvs[(4096UL - sizeof(next)) / sizeof(DTLS::DTV)];\n+  };\n+\n+  static_assert(sizeof(DTVBlock) <= 4096UL, \"Unexpected block size\");\n \n-  uptr dtv_size;\n-  DTV *dtv;  // dtv_size elements, allocated by MmapOrDie.\n+  atomic_uintptr_t dtv_block;\n \n   // Auxiliary fields, don't access them outside sanitizer_tls_get_addr.cpp\n   uptr last_memalign_size;\n   uptr last_memalign_ptr;\n };\n \n+template <typename Fn>\n+void ForEachDVT(DTLS *dtls, const Fn &fn) {\n+  DTLS::DTVBlock *block =\n+      (DTLS::DTVBlock *)atomic_load(&dtls->dtv_block, memory_order_acquire);\n+  while (block) {\n+    int id = 0;\n+    for (auto &d : block->dtvs) fn(d, id++);\n+    block = (DTLS::DTVBlock *)atomic_load(&block->next, memory_order_acquire);\n+  }\n+}\n+\n // Returns pointer and size of a linker-allocated TLS block.\n // Each block is returned exactly once.\n DTLS::DTV *DTLS_on_tls_get_addr(void *arg, void *res, uptr static_tls_begin,"}, {"sha": "7e01c81d0422ab5be07b3180ce2e81799cc4557c", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_win.cpp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -43,6 +43,10 @@ void BufferedStackTrace::UnwindSlow(uptr pc, u32 max_depth) {\n   trace_buffer[0] = pc;\n }\n \n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wframe-larger-than=\"\n+#endif\n void BufferedStackTrace::UnwindSlow(uptr pc, void *context, u32 max_depth) {\n   CHECK(context);\n   CHECK_GE(max_depth, 2);\n@@ -74,6 +78,9 @@ void BufferedStackTrace::UnwindSlow(uptr pc, void *context, u32 max_depth) {\n     trace_buffer[size++] = (uptr)stack_frame.AddrPC.Offset;\n   }\n }\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n #endif  // #if !SANITIZER_GO\n \n #endif  // SANITIZER_WINDOWS"}, {"sha": "f383e130fa59022d3ae8023f147a9c352c830f94", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -334,8 +334,12 @@ bool MprotectNoAccess(uptr addr, uptr size) {\n }\n \n void ReleaseMemoryPagesToOS(uptr beg, uptr end) {\n-  // This is almost useless on 32-bits.\n-  // FIXME: add madvise-analog when we move to 64-bits.\n+  uptr beg_aligned = RoundDownTo(beg, GetPageSizeCached()),\n+       end_aligned = RoundDownTo(end, GetPageSizeCached());\n+  CHECK(beg < end);                // make sure the region is sane\n+  if (beg_aligned == end_aligned)  // make sure we're freeing at least 1 page;\n+    return;\n+  UnmapOrDie((void *)beg, end_aligned - beg_aligned);\n }\n \n void SetShadowRegionHugePageMode(uptr addr, uptr size) {\n@@ -386,6 +390,12 @@ uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n   return 0;\n }\n \n+uptr MapDynamicShadowAndAliases(uptr shadow_size, uptr alias_size,\n+                                uptr num_aliases, uptr ring_buffer_size) {\n+  CHECK(false && \"HWASan aliasing is unimplemented on Windows\");\n+  return 0;\n+}\n+\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n   MEMORY_BASIC_INFORMATION mbi;\n   CHECK(VirtualQuery((void *)range_start, &mbi, sizeof(mbi)));\n@@ -564,7 +574,7 @@ void Abort() {\n // load the image at this address. Therefore, we call it the preferred base. Any\n // addresses in the DWARF typically assume that the object has been loaded at\n // this address.\n-static uptr GetPreferredBase(const char *modname) {\n+static uptr GetPreferredBase(const char *modname, char *buf, size_t buf_size) {\n   fd_t fd = OpenFile(modname, RdOnly, nullptr);\n   if (fd == kInvalidFd)\n     return 0;\n@@ -586,12 +596,10 @@ static uptr GetPreferredBase(const char *modname) {\n   // IMAGE_FILE_HEADER\n   // IMAGE_OPTIONAL_HEADER\n   // Seek to e_lfanew and read all that data.\n-  char buf[4 + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER)];\n   if (::SetFilePointer(fd, dos_header.e_lfanew, nullptr, FILE_BEGIN) ==\n       INVALID_SET_FILE_POINTER)\n     return 0;\n-  if (!ReadFromFile(fd, &buf[0], sizeof(buf), &bytes_read) ||\n-      bytes_read != sizeof(buf))\n+  if (!ReadFromFile(fd, buf, buf_size, &bytes_read) || bytes_read != buf_size)\n     return 0;\n \n   // Check for \"PE\\0\\0\" before the PE header.\n@@ -633,6 +641,10 @@ void ListOfModules::init() {\n     }\n   }\n \n+  InternalMmapVector<char> buf(4 + sizeof(IMAGE_FILE_HEADER) +\n+                               sizeof(IMAGE_OPTIONAL_HEADER));\n+  InternalMmapVector<wchar_t> modname_utf16(kMaxPathLength);\n+  InternalMmapVector<char> module_name(kMaxPathLength);\n   // |num_modules| is the number of modules actually present,\n   size_t num_modules = bytes_required / sizeof(HMODULE);\n   for (size_t i = 0; i < num_modules; ++i) {\n@@ -642,15 +654,13 @@ void ListOfModules::init() {\n       continue;\n \n     // Get the UTF-16 path and convert to UTF-8.\n-    wchar_t modname_utf16[kMaxPathLength];\n     int modname_utf16_len =\n-        GetModuleFileNameW(handle, modname_utf16, kMaxPathLength);\n+        GetModuleFileNameW(handle, &modname_utf16[0], kMaxPathLength);\n     if (modname_utf16_len == 0)\n       modname_utf16[0] = '\\0';\n-    char module_name[kMaxPathLength];\n-    int module_name_len =\n-        ::WideCharToMultiByte(CP_UTF8, 0, modname_utf16, modname_utf16_len + 1,\n-                              &module_name[0], kMaxPathLength, NULL, NULL);\n+    int module_name_len = ::WideCharToMultiByte(\n+        CP_UTF8, 0, &modname_utf16[0], modname_utf16_len + 1, &module_name[0],\n+        kMaxPathLength, NULL, NULL);\n     module_name[module_name_len] = '\\0';\n \n     uptr base_address = (uptr)mi.lpBaseOfDll;\n@@ -660,15 +670,16 @@ void ListOfModules::init() {\n     // RVA when computing the module offset. This helps llvm-symbolizer find the\n     // right DWARF CU. In the common case that the image is loaded at it's\n     // preferred address, we will now print normal virtual addresses.\n-    uptr preferred_base = GetPreferredBase(&module_name[0]);\n+    uptr preferred_base =\n+        GetPreferredBase(&module_name[0], &buf[0], buf.size());\n     uptr adjusted_base = base_address - preferred_base;\n \n-    LoadedModule cur_module;\n-    cur_module.set(module_name, adjusted_base);\n+    modules_.push_back(LoadedModule());\n+    LoadedModule &cur_module = modules_.back();\n+    cur_module.set(&module_name[0], adjusted_base);\n     // We add the whole module as one single address range.\n     cur_module.addAddressRange(base_address, end_address, /*executable*/ true,\n                                /*writable*/ true);\n-    modules_.push_back(cur_module);\n   }\n   UnmapOrDie(hmodules, modules_buffer_size);\n }\n@@ -956,22 +967,27 @@ void SignalContext::InitPcSpBp() {\n \n uptr SignalContext::GetAddress() const {\n   EXCEPTION_RECORD *exception_record = (EXCEPTION_RECORD *)siginfo;\n-  return exception_record->ExceptionInformation[1];\n+  if (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)\n+    return exception_record->ExceptionInformation[1];\n+  return (uptr)exception_record->ExceptionAddress;\n }\n \n bool SignalContext::IsMemoryAccess() const {\n-  return GetWriteFlag() != SignalContext::UNKNOWN;\n+  return ((EXCEPTION_RECORD *)siginfo)->ExceptionCode ==\n+         EXCEPTION_ACCESS_VIOLATION;\n }\n \n-bool SignalContext::IsTrueFaultingAddress() const {\n-  // FIXME: Provide real implementation for this. See Linux and Mac variants.\n-  return IsMemoryAccess();\n-}\n+bool SignalContext::IsTrueFaultingAddress() const { return true; }\n \n SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n   EXCEPTION_RECORD *exception_record = (EXCEPTION_RECORD *)siginfo;\n+\n+  // The write flag is only available for access violation exceptions.\n+  if (exception_record->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)\n+    return SignalContext::UNKNOWN;\n+\n   // The contents of this array are documented at\n-  // https://msdn.microsoft.com/en-us/library/windows/desktop/aa363082(v=vs.85).aspx\n+  // https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record\n   // The first element indicates read as 0, write as 1, or execute as 8.  The\n   // second element is the faulting address.\n   switch (exception_record->ExceptionInformation[0]) {\n@@ -1037,10 +1053,24 @@ const char *SignalContext::Describe() const {\n }\n \n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n-  // FIXME: Actually implement this function.\n-  CHECK_GT(buf_len, 0);\n-  buf[0] = 0;\n-  return 0;\n+  if (buf_len == 0)\n+    return 0;\n+\n+  // Get the UTF-16 path and convert to UTF-8.\n+  InternalMmapVector<wchar_t> binname_utf16(kMaxPathLength);\n+  int binname_utf16_len =\n+      GetModuleFileNameW(NULL, &binname_utf16[0], kMaxPathLength);\n+  if (binname_utf16_len == 0) {\n+    buf[0] = '\\0';\n+    return 0;\n+  }\n+  int binary_name_len =\n+      ::WideCharToMultiByte(CP_UTF8, 0, &binname_utf16[0], binname_utf16_len,\n+                            buf, buf_len, NULL, NULL);\n+  if ((unsigned)binary_name_len == buf_len)\n+    --binary_name_len;\n+  buf[binary_name_len] = '\\0';\n+  return binary_name_len;\n }\n \n uptr ReadLongProcessName(/*out*/char *buf, uptr buf_len) {"}, {"sha": "8e5188392cafd6e657cee2b26b269d0aad5fdd18", "filename": "libsanitizer/tsan/tsan_clock.cpp", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_clock.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_clock.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -150,7 +150,7 @@ void ThreadClock::acquire(ClockCache *c, SyncClock *src) {\n   bool acquired = false;\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     SyncClock::Dirty dirty = src->dirty_[i];\n-    unsigned tid = dirty.tid;\n+    unsigned tid = dirty.tid();\n     if (tid != kInvalidTid) {\n       if (clk_[tid] < dirty.epoch) {\n         clk_[tid] = dirty.epoch;\n@@ -299,10 +299,10 @@ void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) {\n     dst->tab_idx_ = cached_idx_;\n     dst->size_ = cached_size_;\n     dst->blocks_ = cached_blocks_;\n-    CHECK_EQ(dst->dirty_[0].tid, kInvalidTid);\n+    CHECK_EQ(dst->dirty_[0].tid(), kInvalidTid);\n     // The cached clock is shared (immutable),\n     // so this is where we store the current clock.\n-    dst->dirty_[0].tid = tid_;\n+    dst->dirty_[0].set_tid(tid_);\n     dst->dirty_[0].epoch = clk_[tid_];\n     dst->release_store_tid_ = tid_;\n     dst->release_store_reused_ = reused_;\n@@ -336,8 +336,7 @@ void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) {\n     ce.reused = 0;\n     i++;\n   }\n-  for (uptr i = 0; i < kDirtyTids; i++)\n-    dst->dirty_[i].tid = kInvalidTid;\n+  for (uptr i = 0; i < kDirtyTids; i++) dst->dirty_[i].set_tid(kInvalidTid);\n   dst->release_store_tid_ = tid_;\n   dst->release_store_reused_ = reused_;\n   // Rememeber that we don't need to acquire it in future.\n@@ -369,10 +368,10 @@ void ThreadClock::UpdateCurrentThread(ClockCache *c, SyncClock *dst) const {\n   // Update the threads time, but preserve 'acquired' flag.\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     SyncClock::Dirty *dirty = &dst->dirty_[i];\n-    const unsigned tid = dirty->tid;\n+    const unsigned tid = dirty->tid();\n     if (tid == tid_ || tid == kInvalidTid) {\n       CPP_STAT_INC(StatClockReleaseFast);\n-      dirty->tid = tid_;\n+      dirty->set_tid(tid_);\n       dirty->epoch = clk_[tid_];\n       return;\n     }\n@@ -393,8 +392,8 @@ bool ThreadClock::IsAlreadyAcquired(const SyncClock *src) const {\n     return false;\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     SyncClock::Dirty dirty = src->dirty_[i];\n-    if (dirty.tid != kInvalidTid) {\n-      if (clk_[dirty.tid] < dirty.epoch)\n+    if (dirty.tid() != kInvalidTid) {\n+      if (clk_[dirty.tid()] < dirty.epoch)\n         return false;\n     }\n   }\n@@ -453,8 +452,7 @@ void SyncClock::ResetImpl() {\n   blocks_ = 0;\n   release_store_tid_ = kInvalidTid;\n   release_store_reused_ = 0;\n-  for (uptr i = 0; i < kDirtyTids; i++)\n-    dirty_[i].tid = kInvalidTid;\n+  for (uptr i = 0; i < kDirtyTids; i++) dirty_[i].set_tid(kInvalidTid);\n }\n \n void SyncClock::Resize(ClockCache *c, uptr nclk) {\n@@ -503,10 +501,10 @@ void SyncClock::Resize(ClockCache *c, uptr nclk) {\n void SyncClock::FlushDirty() {\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     Dirty *dirty = &dirty_[i];\n-    if (dirty->tid != kInvalidTid) {\n-      CHECK_LT(dirty->tid, size_);\n-      elem(dirty->tid).epoch = dirty->epoch;\n-      dirty->tid = kInvalidTid;\n+    if (dirty->tid() != kInvalidTid) {\n+      CHECK_LT(dirty->tid(), size_);\n+      elem(dirty->tid()).epoch = dirty->epoch;\n+      dirty->set_tid(kInvalidTid);\n     }\n   }\n }\n@@ -559,7 +557,7 @@ ALWAYS_INLINE bool SyncClock::Cachable() const {\n   if (size_ == 0)\n     return false;\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n-    if (dirty_[i].tid != kInvalidTid)\n+    if (dirty_[i].tid() != kInvalidTid)\n       return false;\n   }\n   return atomic_load_relaxed(ref_ptr(tab_)) == 1;\n@@ -606,7 +604,7 @@ ALWAYS_INLINE void SyncClock::append_block(u32 idx) {\n u64 SyncClock::get(unsigned tid) const {\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     Dirty dirty = dirty_[i];\n-    if (dirty.tid == tid)\n+    if (dirty.tid() == tid)\n       return dirty.epoch;\n   }\n   return elem(tid).epoch;\n@@ -625,9 +623,8 @@ void SyncClock::DebugDump(int(*printf)(const char *s, ...)) {\n   for (uptr i = 0; i < size_; i++)\n     printf(\"%s%llu\", i == 0 ? \"\" : \",\", elem(i).reused);\n   printf(\"] release_store_tid=%d/%d dirty_tids=%d[%llu]/%d[%llu]\",\n-      release_store_tid_, release_store_reused_,\n-      dirty_[0].tid, dirty_[0].epoch,\n-      dirty_[1].tid, dirty_[1].epoch);\n+         release_store_tid_, release_store_reused_, dirty_[0].tid(),\n+         dirty_[0].epoch, dirty_[1].tid(), dirty_[1].epoch);\n }\n \n void SyncClock::Iter::Next() {"}, {"sha": "31376a1bc9e2f4953aa99ac38cdb9b26cb1a4c2e", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -17,7 +17,7 @@\n \n namespace __tsan {\n \n-typedef DenseSlabAlloc<ClockBlock, 1<<16, 1<<10> ClockAlloc;\n+typedef DenseSlabAlloc<ClockBlock, 1 << 22, 1 << 10> ClockAlloc;\n typedef DenseSlabAllocCache ClockCache;\n \n // The clock that lives in sync variables (mutexes, atomics, etc).\n@@ -65,10 +65,20 @@ class SyncClock {\n   static const uptr kDirtyTids = 2;\n \n   struct Dirty {\n-    u64 epoch  : kClkBits;\n-    u64 tid : 64 - kClkBits;  // kInvalidId if not active\n+    u32 tid() const { return tid_ == kShortInvalidTid ? kInvalidTid : tid_; }\n+    void set_tid(u32 tid) {\n+      tid_ = tid == kInvalidTid ? kShortInvalidTid : tid;\n+    }\n+    u64 epoch : kClkBits;\n+\n+   private:\n+    // Full kInvalidTid won't fit into Dirty::tid.\n+    static const u64 kShortInvalidTid = (1ull << (64 - kClkBits)) - 1;\n+    u64 tid_ : 64 - kClkBits;  // kInvalidId if not active\n   };\n \n+  static_assert(sizeof(Dirty) == 8, \"Dirty is not 64bit\");\n+\n   unsigned release_store_tid_;\n   unsigned release_store_reused_;\n   Dirty dirty_[kDirtyTids];"}, {"sha": "f53787aeba970f7109662680a7ba1ac53541e662", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -98,8 +98,6 @@ const bool kCollectHistory = false;\n const bool kCollectHistory = true;\n #endif\n \n-const u16 kInvalidTid = kMaxTid + 1;\n-\n // The following \"build consistency\" machinery ensures that all source files\n // are built in the same configuration. Inconsistent builds lead to\n // hard to debug crashes."}, {"sha": "6c89e40598042e730ba089dbf98e36bcc7e08c7a", "filename": "libsanitizer/tsan/tsan_dense_alloc.h", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -29,28 +29,40 @@ class DenseSlabAllocCache {\n   typedef u32 IndexT;\n   uptr pos;\n   IndexT cache[kSize];\n-  template<typename T, uptr kL1Size, uptr kL2Size> friend class DenseSlabAlloc;\n+  template <typename, uptr, uptr, u64>\n+  friend class DenseSlabAlloc;\n };\n \n-template<typename T, uptr kL1Size, uptr kL2Size>\n+template <typename T, uptr kL1Size, uptr kL2Size, u64 kReserved = 0>\n class DenseSlabAlloc {\n  public:\n   typedef DenseSlabAllocCache Cache;\n   typedef typename Cache::IndexT IndexT;\n \n-  explicit DenseSlabAlloc(const char *name) {\n-    // Check that kL1Size and kL2Size are sane.\n-    CHECK_EQ(kL1Size & (kL1Size - 1), 0);\n-    CHECK_EQ(kL2Size & (kL2Size - 1), 0);\n-    CHECK_GE(1ull << (sizeof(IndexT) * 8), kL1Size * kL2Size);\n-    // Check that it makes sense to use the dense alloc.\n-    CHECK_GE(sizeof(T), sizeof(IndexT));\n-    internal_memset(map_, 0, sizeof(map_));\n+  static_assert((kL1Size & (kL1Size - 1)) == 0,\n+                \"kL1Size must be a power-of-two\");\n+  static_assert((kL2Size & (kL2Size - 1)) == 0,\n+                \"kL2Size must be a power-of-two\");\n+  static_assert((kL1Size * kL2Size) <= (1ull << (sizeof(IndexT) * 8)),\n+                \"kL1Size/kL2Size are too large\");\n+  static_assert(((kL1Size * kL2Size - 1) & kReserved) == 0,\n+                \"reserved bits don't fit\");\n+  static_assert(sizeof(T) > sizeof(IndexT),\n+                \"it doesn't make sense to use dense alloc\");\n+\n+  explicit DenseSlabAlloc(LinkerInitialized, const char *name) {\n     freelist_ = 0;\n     fillpos_ = 0;\n     name_ = name;\n   }\n \n+  explicit DenseSlabAlloc(const char *name)\n+      : DenseSlabAlloc(LINKER_INITIALIZED, name) {\n+    // It can be very large.\n+    // Don't page it in for linker initialized objects.\n+    internal_memset(map_, 0, sizeof(map_));\n+  }\n+\n   ~DenseSlabAlloc() {\n     for (uptr i = 0; i < kL1Size; i++) {\n       if (map_[i] != 0)"}, {"sha": "a87e12f2936f3c58b35eba9151b38a0d34306a0a", "filename": "libsanitizer/tsan/tsan_external.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_external.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_external.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_external.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -111,12 +111,12 @@ void __tsan_external_assign_tag(void *addr, void *tag) {\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_external_read(void *addr, void *caller_pc, void *tag) {\n-  ExternalAccess(addr, STRIP_PC(caller_pc), tag, MemoryRead);\n+  ExternalAccess(addr, STRIP_PAC_PC(caller_pc), tag, MemoryRead);\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_external_write(void *addr, void *caller_pc, void *tag) {\n-  ExternalAccess(addr, STRIP_PC(caller_pc), tag, MemoryWrite);\n+  ExternalAccess(addr, STRIP_PAC_PC(caller_pc), tag, MemoryWrite);\n }\n }  // extern \"C\"\n "}, {"sha": "ed10fccc980a45033c2a7d77b88158a72db3359f", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -438,6 +438,7 @@ struct fake_shared_weak_count {\n   virtual void on_zero_shared() = 0;\n   virtual void _unused_0x18() = 0;\n   virtual void on_zero_shared_weak() = 0;\n+  virtual ~fake_shared_weak_count() = 0;  // suppress -Wnon-virtual-dtor\n };\n }  // namespace\n "}, {"sha": "2651e22c39fa99677654af243766fb9f0cbad520", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 100, "deletions": 49, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -54,10 +54,6 @@ using namespace __tsan;\n #define vfork __vfork14\n #endif\n \n-#if SANITIZER_ANDROID\n-#define mallopt(a, b)\n-#endif\n-\n #ifdef __mips__\n const int kSigCount = 129;\n #else\n@@ -85,6 +81,8 @@ extern \"C\" int pthread_attr_init(void *attr);\n extern \"C\" int pthread_attr_destroy(void *attr);\n DECLARE_REAL(int, pthread_attr_getdetachstate, void *, void *)\n extern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\n+extern \"C\" int pthread_atfork(void (*prepare)(void), void (*parent)(void),\n+                              void (*child)(void));\n extern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n extern \"C\" int pthread_setspecific(unsigned key, const void *v);\n DECLARE_REAL(int, pthread_mutexattr_gettype, void *, void *)\n@@ -97,7 +95,7 @@ extern \"C\" void _exit(int status);\n extern \"C\" int fileno_unlocked(void *stream);\n extern \"C\" int dirfd(void *dirp);\n #endif\n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_NETBSD\n+#if SANITIZER_GLIBC\n extern \"C\" int mallopt(int param, int value);\n #endif\n #if SANITIZER_NETBSD\n@@ -659,8 +657,11 @@ TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n   return p;\n }\n \n+// In glibc<2.25, dynamic TLS blocks are allocated by __libc_memalign. Intercept\n+// __libc_memalign so that (1) we can detect races (2) free will not be called\n+// on libc internally allocated blocks.\n TSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {\n-  SCOPED_TSAN_INTERCEPTOR(__libc_memalign, align, sz);\n+  SCOPED_INTERCEPTOR_RAW(__libc_memalign, align, sz);\n   return user_memalign(thr, pc, align, sz);\n }\n \n@@ -773,6 +774,11 @@ static void *mmap_interceptor(ThreadState *thr, uptr pc, Mmap real_mmap,\n   if (!fix_mmap_addr(&addr, sz, flags)) return MAP_FAILED;\n   void *res = real_mmap(addr, sz, prot, flags, fd, off);\n   if (res != MAP_FAILED) {\n+    if (!IsAppMem((uptr)res) || !IsAppMem((uptr)res + sz - 1)) {\n+      Report(\"ThreadSanitizer: mmap at bad address: addr=%p size=%p res=%p\\n\",\n+             addr, (void*)sz, res);\n+      Die();\n+    }\n     if (fd > 0) FdAccess(thr, pc, fd);\n     MemoryRangeImitateWriteOrResetRange(thr, pc, (uptr)res, sz);\n   }\n@@ -1122,27 +1128,37 @@ static void *init_cond(void *c, bool force = false) {\n   return (void*)cond;\n }\n \n+namespace {\n+\n+template <class Fn>\n struct CondMutexUnlockCtx {\n   ScopedInterceptor *si;\n   ThreadState *thr;\n   uptr pc;\n   void *m;\n+  void *c;\n+  const Fn &fn;\n+\n+  int Cancel() const { return fn(); }\n+  void Unlock() const;\n };\n \n-static void cond_mutex_unlock(CondMutexUnlockCtx *arg) {\n+template <class Fn>\n+void CondMutexUnlockCtx<Fn>::Unlock() const {\n   // pthread_cond_wait interceptor has enabled async signal delivery\n   // (see BlockingCall below). Disable async signals since we are running\n   // tsan code. Also ScopedInterceptor and BlockingCall destructors won't run\n   // since the thread is cancelled, so we have to manually execute them\n   // (the thread still can run some user code due to pthread_cleanup_push).\n-  ThreadSignalContext *ctx = SigCtx(arg->thr);\n+  ThreadSignalContext *ctx = SigCtx(thr);\n   CHECK_EQ(atomic_load(&ctx->in_blocking_func, memory_order_relaxed), 1);\n   atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n-  MutexPostLock(arg->thr, arg->pc, (uptr)arg->m, MutexFlagDoPreLockOnPostLock);\n+  MutexPostLock(thr, pc, (uptr)m, MutexFlagDoPreLockOnPostLock);\n   // Undo BlockingCall ctor effects.\n-  arg->thr->ignore_interceptors--;\n-  arg->si->~ScopedInterceptor();\n+  thr->ignore_interceptors--;\n+  si->~ScopedInterceptor();\n }\n+}  // namespace\n \n INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n   void *cond = init_cond(c, true);\n@@ -1151,20 +1167,24 @@ INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n   return REAL(pthread_cond_init)(cond, a);\n }\n \n-static int cond_wait(ThreadState *thr, uptr pc, ScopedInterceptor *si,\n-                     int (*fn)(void *c, void *m, void *abstime), void *c,\n-                     void *m, void *t) {\n+template <class Fn>\n+int cond_wait(ThreadState *thr, uptr pc, ScopedInterceptor *si, const Fn &fn,\n+              void *c, void *m) {\n   MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n   MutexUnlock(thr, pc, (uptr)m);\n-  CondMutexUnlockCtx arg = {si, thr, pc, m};\n   int res = 0;\n   // This ensures that we handle mutex lock even in case of pthread_cancel.\n   // See test/tsan/cond_cancel.cpp.\n   {\n     // Enable signal delivery while the thread is blocked.\n     BlockingCall bc(thr);\n+    CondMutexUnlockCtx<Fn> arg = {si, thr, pc, m, c, fn};\n     res = call_pthread_cancel_with_cleanup(\n-        fn, c, m, t, (void (*)(void *arg))cond_mutex_unlock, &arg);\n+        [](void *arg) -> int {\n+          return ((const CondMutexUnlockCtx<Fn> *)arg)->Cancel();\n+        },\n+        [](void *arg) { ((const CondMutexUnlockCtx<Fn> *)arg)->Unlock(); },\n+        &arg);\n   }\n   if (res == errno_EOWNERDEAD) MutexRepair(thr, pc, (uptr)m);\n   MutexPostLock(thr, pc, (uptr)m, MutexFlagDoPreLockOnPostLock);\n@@ -1174,25 +1194,46 @@ static int cond_wait(ThreadState *thr, uptr pc, ScopedInterceptor *si,\n INTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n   void *cond = init_cond(c);\n   SCOPED_TSAN_INTERCEPTOR(pthread_cond_wait, cond, m);\n-  return cond_wait(thr, pc, &si, (int (*)(void *c, void *m, void *abstime))REAL(\n-                                     pthread_cond_wait),\n-                   cond, m, 0);\n+  return cond_wait(\n+      thr, pc, &si, [=]() { return REAL(pthread_cond_wait)(cond, m); }, cond,\n+      m);\n }\n \n INTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m, void *abstime) {\n   void *cond = init_cond(c);\n   SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait, cond, m, abstime);\n-  return cond_wait(thr, pc, &si, REAL(pthread_cond_timedwait), cond, m,\n-                   abstime);\n+  return cond_wait(\n+      thr, pc, &si,\n+      [=]() { return REAL(pthread_cond_timedwait)(cond, m, abstime); }, cond,\n+      m);\n }\n \n+#if SANITIZER_LINUX\n+INTERCEPTOR(int, pthread_cond_clockwait, void *c, void *m,\n+            __sanitizer_clockid_t clock, void *abstime) {\n+  void *cond = init_cond(c);\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_clockwait, cond, m, clock, abstime);\n+  return cond_wait(\n+      thr, pc, &si,\n+      [=]() { return REAL(pthread_cond_clockwait)(cond, m, clock, abstime); },\n+      cond, m);\n+}\n+#define TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT TSAN_INTERCEPT(pthread_cond_clockwait)\n+#else\n+#define TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT\n+#endif\n+\n #if SANITIZER_MAC\n INTERCEPTOR(int, pthread_cond_timedwait_relative_np, void *c, void *m,\n             void *reltime) {\n   void *cond = init_cond(c);\n   SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait_relative_np, cond, m, reltime);\n-  return cond_wait(thr, pc, &si, REAL(pthread_cond_timedwait_relative_np), cond,\n-                   m, reltime);\n+  return cond_wait(\n+      thr, pc, &si,\n+      [=]() {\n+        return REAL(pthread_cond_timedwait_relative_np)(cond, m, reltime);\n+      },\n+      cond, m);\n }\n #endif\n \n@@ -1937,7 +1978,8 @@ static void CallUserSignalHandler(ThreadState *thr, bool sync, bool acquire,\n   // because in async signal processing case (when handler is called directly\n   // from rtl_generic_sighandler) we have not yet received the reraised\n   // signal; and it looks too fragile to intercept all ways to reraise a signal.\n-  if (flags()->report_bugs && !sync && sig != SIGTERM && errno != 99) {\n+  if (ShouldReport(thr, ReportTypeErrnoInSignal) && !sync && sig != SIGTERM &&\n+      errno != 99) {\n     VarSizeStackTrace stack;\n     // StackTrace::GetNestInstructionPc(pc) is used because return address is\n     // expected, OutputReport() will undo this.\n@@ -2107,26 +2149,32 @@ TSAN_INTERCEPTOR(int, fork, int fake) {\n   if (in_symbolizer())\n     return REAL(fork)(fake);\n   SCOPED_INTERCEPTOR_RAW(fork, fake);\n+  return REAL(fork)(fake);\n+}\n+\n+void atfork_prepare() {\n+  if (in_symbolizer())\n+    return;\n+  ThreadState *thr = cur_thread();\n+  const uptr pc = StackTrace::GetCurrentPc();\n   ForkBefore(thr, pc);\n-  int pid;\n-  {\n-    // On OS X, REAL(fork) can call intercepted functions (OSSpinLockLock), and\n-    // we'll assert in CheckNoLocks() unless we ignore interceptors.\n-    ScopedIgnoreInterceptors ignore;\n-    pid = REAL(fork)(fake);\n-  }\n-  if (pid == 0) {\n-    // child\n-    ForkChildAfter(thr, pc);\n-    FdOnFork(thr, pc);\n-  } else if (pid > 0) {\n-    // parent\n-    ForkParentAfter(thr, pc);\n-  } else {\n-    // error\n-    ForkParentAfter(thr, pc);\n-  }\n-  return pid;\n+}\n+\n+void atfork_parent() {\n+  if (in_symbolizer())\n+    return;\n+  ThreadState *thr = cur_thread();\n+  const uptr pc = StackTrace::GetCurrentPc();\n+  ForkParentAfter(thr, pc);\n+}\n+\n+void atfork_child() {\n+  if (in_symbolizer())\n+    return;\n+  ThreadState *thr = cur_thread();\n+  const uptr pc = StackTrace::GetCurrentPc();\n+  ForkChildAfter(thr, pc);\n+  FdOnFork(thr, pc);\n }\n \n TSAN_INTERCEPTOR(int, vfork, int fake) {\n@@ -2479,13 +2527,10 @@ static USED void syscall_fd_release(uptr pc, int fd) {\n   FdRelease(thr, pc, fd);\n }\n \n-static void syscall_pre_fork(uptr pc) {\n-  TSAN_SYSCALL();\n-  ForkBefore(thr, pc);\n-}\n+static void syscall_pre_fork(uptr pc) { ForkBefore(cur_thread(), pc); }\n \n static void syscall_post_fork(uptr pc, int pid) {\n-  TSAN_SYSCALL();\n+  ThreadState *thr = cur_thread();\n   if (pid == 0) {\n     // child\n     ForkChildAfter(thr, pc);\n@@ -2635,7 +2680,7 @@ void InitializeInterceptors() {\n #endif\n \n   // Instruct libc malloc to consume less memory.\n-#if SANITIZER_LINUX\n+#if SANITIZER_GLIBC\n   mallopt(1, 0);  // M_MXFAST\n   mallopt(-3, 32*1024);  // M_MMAP_THRESHOLD\n #endif\n@@ -2698,6 +2743,8 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT_VER(pthread_cond_timedwait, PTHREAD_ABI_BASE);\n   TSAN_INTERCEPT_VER(pthread_cond_destroy, PTHREAD_ABI_BASE);\n \n+  TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT;\n+\n   TSAN_INTERCEPT(pthread_mutex_init);\n   TSAN_INTERCEPT(pthread_mutex_destroy);\n   TSAN_INTERCEPT(pthread_mutex_trylock);\n@@ -2799,6 +2846,10 @@ void InitializeInterceptors() {\n     Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n     Die();\n   }\n+  if (pthread_atfork(atfork_prepare, atfork_parent, atfork_child)) {\n+    Printf(\"ThreadSanitizer: failed to setup atfork callbacks\\n\");\n+    Die();\n+  }\n \n #if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n   if (pthread_key_create(&interceptor_ctx()->finalize_key, &thread_finalize)) {"}, {"sha": "9bd0e8580b175b47d316bfb27adf1bffdd8a3ab8", "filename": "libsanitizer/tsan/tsan_interface.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -40,13 +40,13 @@ void __tsan_write16(void *addr) {\n }\n \n void __tsan_read16_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n-  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr + 8, kSizeLog8);\n+  MemoryRead(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog8);\n+  MemoryRead(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr + 8, kSizeLog8);\n }\n \n void __tsan_write16_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n-  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr + 8, kSizeLog8);\n+  MemoryWrite(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog8);\n+  MemoryWrite(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr + 8, kSizeLog8);\n }\n \n // __tsan_unaligned_read/write calls are emitted by compiler."}, {"sha": "6e022b56850cfafc25eae850cca165f5e15ee34f", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -204,7 +204,7 @@ __extension__ typedef __int128 a128;\n #endif\n \n // Part of ABI, do not change.\n-// https://github.com/llvm/llvm-project/blob/master/libcxx/include/atomic\n+// https://github.com/llvm/llvm-project/blob/main/libcxx/include/atomic\n typedef enum {\n   mo_relaxed,\n   mo_consume,\n@@ -415,6 +415,13 @@ void __tsan_go_atomic32_compare_exchange(ThreadState *thr, uptr cpc, uptr pc,\n SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_go_atomic64_compare_exchange(ThreadState *thr, uptr cpc, uptr pc,\n                                          u8 *a);\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_on_initialize();\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_on_finalize(int failed);\n+\n }  // extern \"C\"\n \n }  // namespace __tsan"}, {"sha": "5e77d4d3d288b97a892ea78f09cb41fd60a66d22", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -51,35 +51,35 @@ void __tsan_write8(void *addr) {\n }\n \n void __tsan_read1_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog1);\n+  MemoryRead(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog1);\n }\n \n void __tsan_read2_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog2);\n+  MemoryRead(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog2);\n }\n \n void __tsan_read4_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog4);\n+  MemoryRead(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog4);\n }\n \n void __tsan_read8_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n+  MemoryRead(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog8);\n }\n \n void __tsan_write1_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog1);\n+  MemoryWrite(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog1);\n }\n \n void __tsan_write2_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog2);\n+  MemoryWrite(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog2);\n }\n \n void __tsan_write4_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog4);\n+  MemoryWrite(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog4);\n }\n \n void __tsan_write8_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n+  MemoryWrite(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, kSizeLog8);\n }\n \n void __tsan_vptr_update(void **vptr_p, void *new_val) {\n@@ -101,7 +101,7 @@ void __tsan_vptr_read(void **vptr_p) {\n }\n \n void __tsan_func_entry(void *pc) {\n-  FuncEntry(cur_thread(), STRIP_PC(pc));\n+  FuncEntry(cur_thread(), STRIP_PAC_PC(pc));\n }\n \n void __tsan_func_exit() {\n@@ -125,9 +125,9 @@ void __tsan_write_range(void *addr, uptr size) {\n }\n \n void __tsan_read_range_pc(void *addr, uptr size, void *pc) {\n-  MemoryAccessRange(cur_thread(), STRIP_PC(pc), (uptr)addr, size, false);\n+  MemoryAccessRange(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, size, false);\n }\n \n void __tsan_write_range_pc(void *addr, uptr size, void *pc) {\n-  MemoryAccessRange(cur_thread(), STRIP_PC(pc), (uptr)addr, size, true);\n+  MemoryAccessRange(cur_thread(), STRIP_PAC_PC(pc), (uptr)addr, size, true);\n }"}, {"sha": "45a39f0f8ec9acfec673e30325fffa57b9e142b2", "filename": "libsanitizer/tsan/tsan_mman.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_mman.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_mman.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -145,7 +145,7 @@ void AllocatorPrintStats() {\n \n static void SignalUnsafeCall(ThreadState *thr, uptr pc) {\n   if (atomic_load_relaxed(&thr->in_signal_handler) == 0 ||\n-      !flags()->report_signal_unsafe)\n+      !ShouldReport(thr, ReportTypeSignalUnsafe))\n     return;\n   VarSizeStackTrace stack;\n   ObtainCurrentStack(thr, pc, &stack);"}, {"sha": "101522d8fa4aa85dcfd65f918c56bb4e3c4af711", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 113, "deletions": 8, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -23,9 +23,21 @@\n \n namespace __tsan {\n \n+#if defined(__x86_64__)\n+#define HAS_48_BIT_ADDRESS_SPACE 1\n+#elif SANITIZER_IOSSIM // arm64 iOS simulators (order of #if matters)\n+#define HAS_48_BIT_ADDRESS_SPACE 1\n+#elif SANITIZER_IOS // arm64 iOS devices (order of #if matters)\n+#define HAS_48_BIT_ADDRESS_SPACE 0\n+#elif SANITIZER_MAC // arm64 macOS (order of #if matters)\n+#define HAS_48_BIT_ADDRESS_SPACE 1\n+#else\n+#define HAS_48_BIT_ADDRESS_SPACE 0\n+#endif\n+\n #if !SANITIZER_GO\n \n-#if defined(__x86_64__)\n+#if HAS_48_BIT_ADDRESS_SPACE\n /*\n C/C++ on linux/x86_64 and freebsd/x86_64\n 0000 0000 1000 - 0080 0000 0000: main binary and/or MAP_32BIT mappings (512GB)\n@@ -93,7 +105,7 @@ fe00 0000 00 - ff00 0000 00: heap                                        (4 GB)\n ff00 0000 00 - ff80 0000 00: -                                           (2 GB)\n ff80 0000 00 - ffff ffff ff: modules and main thread stack              (<2 GB)\n */\n-struct Mapping {\n+struct Mapping40 {\n   static const uptr kMetaShadowBeg = 0x4000000000ull;\n   static const uptr kMetaShadowEnd = 0x5000000000ull;\n   static const uptr kTraceMemBeg   = 0xb000000000ull;\n@@ -114,6 +126,7 @@ struct Mapping {\n };\n \n #define TSAN_MID_APP_RANGE 1\n+#define TSAN_RUNTIME_VMA 1\n #elif defined(__aarch64__) && defined(__APPLE__)\n /*\n C/C++ on Darwin/iOS/ARM64 (36-bit VMA, 64 GB VM)\n@@ -146,7 +159,7 @@ struct Mapping {\n   static const uptr kVdsoBeg       = 0x7000000000000000ull;\n };\n \n-#elif defined(__aarch64__)\n+#elif defined(__aarch64__) && !defined(__APPLE__)\n // AArch64 supports multiple VMA which leads to multiple address transformation\n // functions.  To support these multiple VMAS transformations and mappings TSAN\n // runtime for AArch64 uses an external memory read (vmaSize) to select which\n@@ -354,7 +367,7 @@ struct Mapping47 {\n #define TSAN_RUNTIME_VMA 1\n #endif\n \n-#elif SANITIZER_GO && !SANITIZER_WINDOWS && defined(__x86_64__)\n+#elif SANITIZER_GO && !SANITIZER_WINDOWS && HAS_48_BIT_ADDRESS_SPACE\n \n /* Go on linux, darwin and freebsd on x86_64\n 0000 0000 1000 - 0000 1000 0000: executable\n@@ -502,7 +515,7 @@ Go on linux/mips64 (47-bit VMA)\n 6000 0000 0000 - 6200 0000 0000: traces\n 6200 0000 0000 - 8000 0000 0000: -\n */\n-struct Mapping {\n+struct Mapping47 {\n   static const uptr kMetaShadowBeg = 0x300000000000ull;\n   static const uptr kMetaShadowEnd = 0x400000000000ull;\n   static const uptr kTraceMemBeg = 0x600000000000ull;\n@@ -512,6 +525,9 @@ struct Mapping {\n   static const uptr kAppMemBeg = 0x000000001000ull;\n   static const uptr kAppMemEnd = 0x00e000000000ull;\n };\n+\n+#define TSAN_RUNTIME_VMA 1\n+\n #else\n # error \"Unknown platform\"\n #endif\n@@ -592,6 +608,16 @@ uptr MappingArchImpl(void) {\n   }\n   DCHECK(0);\n   return 0;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return MappingImpl<Mapping40, Type>();\n+#else\n+    case 47: return MappingImpl<Mapping47, Type>();\n+#endif\n+  }\n+  DCHECK(0);\n+  return 0;\n #else\n   return MappingImpl<Mapping, Type>();\n #endif\n@@ -749,6 +775,16 @@ bool IsAppMem(uptr mem) {\n   }\n   DCHECK(0);\n   return false;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return IsAppMemImpl<Mapping40>(mem);\n+#else\n+    case 47: return IsAppMemImpl<Mapping47>(mem);\n+#endif\n+  }\n+  DCHECK(0);\n+  return false;\n #else\n   return IsAppMemImpl<Mapping>(mem);\n #endif\n@@ -780,6 +816,16 @@ bool IsShadowMem(uptr mem) {\n   }\n   DCHECK(0);\n   return false;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return IsShadowMemImpl<Mapping40>(mem);\n+#else\n+    case 47: return IsShadowMemImpl<Mapping47>(mem);\n+#endif\n+  }\n+  DCHECK(0);\n+  return false;\n #else\n   return IsShadowMemImpl<Mapping>(mem);\n #endif\n@@ -811,6 +857,16 @@ bool IsMetaMem(uptr mem) {\n   }\n   DCHECK(0);\n   return false;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return IsMetaMemImpl<Mapping40>(mem);\n+#else\n+    case 47: return IsMetaMemImpl<Mapping47>(mem);\n+#endif\n+  }\n+  DCHECK(0);\n+  return false;\n #else\n   return IsMetaMemImpl<Mapping>(mem);\n #endif\n@@ -852,6 +908,16 @@ uptr MemToShadow(uptr x) {\n   }\n   DCHECK(0);\n   return 0;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return MemToShadowImpl<Mapping40>(x);\n+#else\n+    case 47: return MemToShadowImpl<Mapping47>(x);\n+#endif\n+  }\n+  DCHECK(0);\n+  return 0;\n #else\n   return MemToShadowImpl<Mapping>(x);\n #endif\n@@ -895,6 +961,16 @@ u32 *MemToMeta(uptr x) {\n   }\n   DCHECK(0);\n   return 0;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return MemToMetaImpl<Mapping40>(x);\n+#else\n+    case 47: return MemToMetaImpl<Mapping47>(x);\n+#endif\n+  }\n+  DCHECK(0);\n+  return 0;\n #else\n   return MemToMetaImpl<Mapping>(x);\n #endif\n@@ -951,6 +1027,16 @@ uptr ShadowToMem(uptr s) {\n   }\n   DCHECK(0);\n   return 0;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return ShadowToMemImpl<Mapping40>(s);\n+#else\n+    case 47: return ShadowToMemImpl<Mapping47>(s);\n+#endif\n+  }\n+  DCHECK(0);\n+  return 0;\n #else\n   return ShadowToMemImpl<Mapping>(s);\n #endif\n@@ -990,6 +1076,16 @@ uptr GetThreadTrace(int tid) {\n   }\n   DCHECK(0);\n   return 0;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return GetThreadTraceImpl<Mapping40>(tid);\n+#else\n+    case 47: return GetThreadTraceImpl<Mapping47>(tid);\n+#endif\n+  }\n+  DCHECK(0);\n+  return 0;\n #else\n   return GetThreadTraceImpl<Mapping>(tid);\n #endif\n@@ -1024,6 +1120,16 @@ uptr GetThreadTraceHeader(int tid) {\n   }\n   DCHECK(0);\n   return 0;\n+#elif defined(__mips64)\n+  switch (vmaSize) {\n+#if !SANITIZER_GO\n+    case 40: return GetThreadTraceHeaderImpl<Mapping40>(tid);\n+#else\n+    case 47: return GetThreadTraceHeaderImpl<Mapping47>(tid);\n+#endif\n+  }\n+  DCHECK(0);\n+  return 0;\n #else\n   return GetThreadTraceHeaderImpl<Mapping>(tid);\n #endif\n@@ -1040,9 +1146,8 @@ int ExtractRecvmsgFDs(void *msg, int *fds, int nfd);\n uptr ExtractLongJmpSp(uptr *env);\n void ImitateTlsWrite(ThreadState *thr, uptr tls_addr, uptr tls_size);\n \n-int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n-    void *abstime), void *c, void *m, void *abstime,\n-    void(*cleanup)(void *arg), void *arg);\n+int call_pthread_cancel_with_cleanup(int (*fn)(void *arg),\n+                                     void (*cleanup)(void *arg), void *arg);\n \n void DestroyThreadState();\n void PlatformCleanUpThreadState(ThreadState *thr);"}, {"sha": "e5b6690edfd019f8f0304b25868561026653fb27", "filename": "libsanitizer/tsan/tsan_platform_linux.cpp", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -250,6 +250,20 @@ void InitializePlatformEarly() {\n     Die();\n   }\n # endif\n+#elif defined(__mips64)\n+# if !SANITIZER_GO\n+  if (vmaSize != 40) {\n+    Printf(\"FATAL: ThreadSanitizer: unsupported VMA range\\n\");\n+    Printf(\"FATAL: Found %zd - Supported 40\\n\", vmaSize);\n+    Die();\n+  }\n+# else\n+  if (vmaSize != 47) {\n+    Printf(\"FATAL: ThreadSanitizer: unsupported VMA range\\n\");\n+    Printf(\"FATAL: Found %zd - Supported 47\\n\", vmaSize);\n+    Die();\n+  }\n+# endif\n #endif\n #endif\n }\n@@ -443,14 +457,13 @@ void ImitateTlsWrite(ThreadState *thr, uptr tls_addr, uptr tls_size) {\n \n // Note: this function runs with async signals enabled,\n // so it must not touch any tsan state.\n-int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n-    void *abstime), void *c, void *m, void *abstime,\n-    void(*cleanup)(void *arg), void *arg) {\n+int call_pthread_cancel_with_cleanup(int (*fn)(void *arg),\n+                                     void (*cleanup)(void *arg), void *arg) {\n   // pthread_cleanup_push/pop are hardcore macros mess.\n   // We can't intercept nor call them w/o including pthread.h.\n   int res;\n   pthread_cleanup_push(cleanup, arg);\n-  res = fn(c, m, abstime);\n+  res = fn(arg);\n   pthread_cleanup_pop(0);\n   return res;\n }\n@@ -484,7 +497,7 @@ ThreadState *cur_thread() {\n         dead_thread_state->fast_state.SetIgnoreBit();\n         dead_thread_state->ignore_interceptors = 1;\n         dead_thread_state->is_dead = true;\n-        *const_cast<int*>(&dead_thread_state->tid) = -1;\n+        *const_cast<u32*>(&dead_thread_state->tid) = -1;\n         CHECK_EQ(0, internal_mprotect(dead_thread_state, sizeof(ThreadState),\n                                       PROT_READ));\n       }"}, {"sha": "d9719a136b2163f9062754ceed0729850f6c67c9", "filename": "libsanitizer/tsan/tsan_platform_mac.cpp", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -234,7 +234,7 @@ static void my_pthread_introspection_hook(unsigned int event, pthread_t thread,\n #endif\n \n void InitializePlatformEarly() {\n-#if !SANITIZER_GO && defined(__aarch64__)\n+#if !SANITIZER_GO && !HAS_48_BIT_ADDRESS_SPACE\n   uptr max_vm = GetMaxUserVirtualAddress() + 1;\n   if (max_vm != Mapping::kHiAppMemEnd) {\n     Printf(\"ThreadSanitizer: unsupported vm address limit %p, expected %p.\\n\",\n@@ -306,14 +306,13 @@ void ImitateTlsWrite(ThreadState *thr, uptr tls_addr, uptr tls_size) {\n #if !SANITIZER_GO\n // Note: this function runs with async signals enabled,\n // so it must not touch any tsan state.\n-int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n-    void *abstime), void *c, void *m, void *abstime,\n-    void(*cleanup)(void *arg), void *arg) {\n+int call_pthread_cancel_with_cleanup(int (*fn)(void *arg),\n+                                     void (*cleanup)(void *arg), void *arg) {\n   // pthread_cleanup_push/pop are hardcore macros mess.\n   // We can't intercept nor call them w/o including pthread.h.\n   int res;\n   pthread_cleanup_push(cleanup, arg);\n-  res = fn(c, m, abstime);\n+  res = fn(arg);\n   pthread_cleanup_pop(0);\n   return res;\n }"}, {"sha": "73e1d4577c2c2a70dcdf4ceea97af12a9ae0ca7e", "filename": "libsanitizer/tsan/tsan_platform_posix.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -99,7 +99,7 @@ void CheckAndProtect() {\n     Die();\n   }\n \n-#if defined(__aarch64__) && defined(__APPLE__)\n+#if defined(__aarch64__) && defined(__APPLE__) && !HAS_48_BIT_ADDRESS_SPACE\n   ProtectRange(HeapMemEnd(), ShadowBeg());\n   ProtectRange(ShadowEnd(), MetaShadowBeg());\n   ProtectRange(MetaShadowEnd(), TraceMemBeg());"}, {"sha": "8ef9f0cd4fe801d8f090fdb4fffd208529ef124c", "filename": "libsanitizer/tsan/tsan_report.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -69,7 +69,7 @@ ReportDesc::~ReportDesc() {\n \n const int kThreadBufSize = 32;\n const char *thread_name(char *buf, int tid) {\n-  if (tid == 0)\n+  if (tid == kMainTid)\n     return \"main thread\";\n   internal_snprintf(buf, kThreadBufSize, \"thread T%d\", tid);\n   return buf;\n@@ -127,7 +127,7 @@ void PrintStack(const ReportStack *ent) {\n   }\n   SymbolizedStack *frame = ent->frames;\n   for (int i = 0; frame && frame->info.address; frame = frame->next, i++) {\n-    InternalScopedString res(2 * GetPageSizeCached());\n+    InternalScopedString res;\n     RenderFrame(&res, common_flags()->stack_trace_format, i,\n                 frame->info.address, &frame->info,\n                 common_flags()->symbolize_vs_style,\n@@ -250,7 +250,7 @@ static void PrintMutex(const ReportMutex *rm) {\n \n static void PrintThread(const ReportThread *rt) {\n   Decorator d;\n-  if (rt->id == 0)  // Little sense in describing the main thread.\n+  if (rt->id == kMainTid)  // Little sense in describing the main thread.\n     return;\n   Printf(\"%s\", d.ThreadDescription());\n   Printf(\"  Thread T%d\", rt->id);\n@@ -394,7 +394,7 @@ void PrintReport(const ReportDesc *rep) {\n \n #else  // #if !SANITIZER_GO\n \n-const int kMainThreadId = 1;\n+const u32 kMainGoroutineId = 1;\n \n void PrintStack(const ReportStack *ent) {\n   if (ent == 0 || ent->frames == 0) {\n@@ -415,7 +415,7 @@ static void PrintMop(const ReportMop *mop, bool first) {\n   Printf(\"%s at %p by \",\n       (first ? (mop->write ? \"Write\" : \"Read\")\n              : (mop->write ? \"Previous write\" : \"Previous read\")), mop->addr);\n-  if (mop->tid == kMainThreadId)\n+  if (mop->tid == kMainGoroutineId)\n     Printf(\"main goroutine:\\n\");\n   else\n     Printf(\"goroutine %d:\\n\", mop->tid);\n@@ -428,7 +428,7 @@ static void PrintLocation(const ReportLocation *loc) {\n     Printf(\"\\n\");\n     Printf(\"Heap block of size %zu at %p allocated by \",\n         loc->heap_chunk_size, loc->heap_chunk_start);\n-    if (loc->tid == kMainThreadId)\n+    if (loc->tid == kMainGoroutineId)\n       Printf(\"main goroutine:\\n\");\n     else\n       Printf(\"goroutine %d:\\n\", loc->tid);\n@@ -448,7 +448,7 @@ static void PrintLocation(const ReportLocation *loc) {\n }\n \n static void PrintThread(const ReportThread *rt) {\n-  if (rt->id == kMainThreadId)\n+  if (rt->id == kMainGoroutineId)\n     return;\n   Printf(\"\\n\");\n   Printf(\"Goroutine %d (%s) created at:\\n\","}, {"sha": "0efa99788abe64ef04c58053a87cc7364e8944f6", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 84, "deletions": 45, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -11,17 +11,19 @@\n // Main file (entry points) for the TSan run-time.\n //===----------------------------------------------------------------------===//\n \n+#include \"tsan_rtl.h\"\n+\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_file.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n-#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n #include \"tsan_defs.h\"\n-#include \"tsan_platform.h\"\n-#include \"tsan_rtl.h\"\n+#include \"tsan_interface.h\"\n #include \"tsan_mman.h\"\n+#include \"tsan_platform.h\"\n #include \"tsan_suppressions.h\"\n #include \"tsan_symbolize.h\"\n #include \"ubsan/ubsan_init.h\"\n@@ -56,12 +58,23 @@ Context *ctx;\n bool OnFinalize(bool failed);\n void OnInitialize();\n #else\n+#include <dlfcn.h>\n SANITIZER_WEAK_CXX_DEFAULT_IMPL\n bool OnFinalize(bool failed) {\n+#if !SANITIZER_GO\n+  if (auto *ptr = dlsym(RTLD_DEFAULT, \"__tsan_on_finalize\"))\n+    return reinterpret_cast<decltype(&__tsan_on_finalize)>(ptr)(failed);\n+#endif\n   return failed;\n }\n SANITIZER_WEAK_CXX_DEFAULT_IMPL\n-void OnInitialize() {}\n+void OnInitialize() {\n+#if !SANITIZER_GO\n+  if (auto *ptr = dlsym(RTLD_DEFAULT, \"__tsan_on_initialize\")) {\n+    return reinterpret_cast<decltype(&__tsan_on_initialize)>(ptr)();\n+  }\n+#endif\n+}\n #endif\n \n static char thread_registry_placeholder[sizeof(ThreadRegistry)];\n@@ -77,12 +90,19 @@ static ThreadContextBase *CreateThreadContext(u32 tid) {\n   new((void*)hdr) Trace();\n   // We are going to use only a small part of the trace with the default\n   // value of history_size. However, the constructor writes to the whole trace.\n-  // Unmap the unused part.\n+  // Release the unused part.\n   uptr hdr_end = hdr + sizeof(Trace);\n   hdr_end -= sizeof(TraceHeader) * (kTraceParts - TraceParts());\n   hdr_end = RoundUp(hdr_end, GetPageSizeCached());\n-  if (hdr_end < hdr + sizeof(Trace))\n-    UnmapOrDie((void*)hdr_end, hdr + sizeof(Trace) - hdr_end);\n+  if (hdr_end < hdr + sizeof(Trace)) {\n+    ReleaseMemoryPagesToOS(hdr_end, hdr + sizeof(Trace));\n+    uptr unused = hdr + sizeof(Trace) - hdr_end;\n+    if (hdr_end != (uptr)MmapFixedNoAccess(hdr_end, unused)) {\n+      Report(\"ThreadSanitizer: failed to mprotect(%p, %p)\\n\",\n+          hdr_end, unused);\n+      CHECK(\"unable to mprotect\" && 0);\n+    }\n+  }\n   void *mem = internal_alloc(MBlockThreadContex, sizeof(ThreadContext));\n   return new(mem) ThreadContext(tid);\n }\n@@ -94,42 +114,45 @@ static const u32 kThreadQuarantineSize = 64;\n #endif\n \n Context::Context()\n-  : initialized()\n-  , report_mtx(MutexTypeReport, StatMtxReport)\n-  , nreported()\n-  , nmissed_expected()\n-  , thread_registry(new(thread_registry_placeholder) ThreadRegistry(\n-      CreateThreadContext, kMaxTid, kThreadQuarantineSize, kMaxTidReuse))\n-  , racy_mtx(MutexTypeRacy, StatMtxRacy)\n-  , racy_stacks()\n-  , racy_addresses()\n-  , fired_suppressions_mtx(MutexTypeFired, StatMtxFired)\n-  , clock_alloc(\"clock allocator\") {\n+    : initialized(),\n+      report_mtx(MutexTypeReport, StatMtxReport),\n+      nreported(),\n+      nmissed_expected(),\n+      thread_registry(new (thread_registry_placeholder) ThreadRegistry(\n+          CreateThreadContext, kMaxTid, kThreadQuarantineSize, kMaxTidReuse)),\n+      racy_mtx(MutexTypeRacy, StatMtxRacy),\n+      racy_stacks(),\n+      racy_addresses(),\n+      fired_suppressions_mtx(MutexTypeFired, StatMtxFired),\n+      clock_alloc(LINKER_INITIALIZED, \"clock allocator\") {\n   fired_suppressions.reserve(8);\n }\n \n // The objects are allocated in TLS, so one may rely on zero-initialization.\n-ThreadState::ThreadState(Context *ctx, int tid, int unique_id, u64 epoch,\n-                         unsigned reuse_count,\n-                         uptr stk_addr, uptr stk_size,\n+ThreadState::ThreadState(Context *ctx, u32 tid, int unique_id, u64 epoch,\n+                         unsigned reuse_count, uptr stk_addr, uptr stk_size,\n                          uptr tls_addr, uptr tls_size)\n-  : fast_state(tid, epoch)\n-  // Do not touch these, rely on zero initialization,\n-  // they may be accessed before the ctor.\n-  // , ignore_reads_and_writes()\n-  // , ignore_interceptors()\n-  , clock(tid, reuse_count)\n+    : fast_state(tid, epoch)\n+      // Do not touch these, rely on zero initialization,\n+      // they may be accessed before the ctor.\n+      // , ignore_reads_and_writes()\n+      // , ignore_interceptors()\n+      ,\n+      clock(tid, reuse_count)\n #if !SANITIZER_GO\n-  , jmp_bufs()\n+      ,\n+      jmp_bufs()\n #endif\n-  , tid(tid)\n-  , unique_id(unique_id)\n-  , stk_addr(stk_addr)\n-  , stk_size(stk_size)\n-  , tls_addr(tls_addr)\n-  , tls_size(tls_size)\n+      ,\n+      tid(tid),\n+      unique_id(unique_id),\n+      stk_addr(stk_addr),\n+      stk_size(stk_size),\n+      tls_addr(tls_addr),\n+      tls_size(tls_size)\n #if !SANITIZER_GO\n-  , last_sleep_clock(tid)\n+      ,\n+      last_sleep_clock(tid)\n #endif\n {\n }\n@@ -160,12 +183,12 @@ static void *BackgroundThread(void *arg) {\n     } else if (internal_strcmp(flags()->profile_memory, \"stderr\") == 0) {\n       mprof_fd = 2;\n     } else {\n-      InternalScopedString filename(kMaxPathLength);\n+      InternalScopedString filename;\n       filename.append(\"%s.%d\", flags()->profile_memory, (int)internal_getpid());\n       fd_t fd = OpenFile(filename.data(), WrOnly);\n       if (fd == kInvalidFd) {\n         Printf(\"ThreadSanitizer: failed to open memory profile file '%s'\\n\",\n-            &filename[0]);\n+               filename.data());\n       } else {\n         mprof_fd = fd;\n       }\n@@ -351,6 +374,18 @@ static void TsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n }\n #endif\n \n+void CheckUnwind() {\n+  // There is high probability that interceptors will check-fail as well,\n+  // on the other hand there is no sense in processing interceptors\n+  // since we are going to die soon.\n+  ScopedIgnoreInterceptors ignore;\n+#if !SANITIZER_GO\n+  cur_thread()->ignore_sync++;\n+  cur_thread()->ignore_reads_and_writes++;\n+#endif\n+  PrintCurrentStackSlow(StackTrace::GetCurrentPc());\n+}\n+\n void Initialize(ThreadState *thr) {\n   // Thread safe because done before all threads exist.\n   static bool is_initialized = false;\n@@ -361,7 +396,7 @@ void Initialize(ThreadState *thr) {\n   ScopedIgnoreInterceptors ignore;\n   SanitizerToolName = \"ThreadSanitizer\";\n   // Install tool-specific callbacks in sanitizer_common.\n-  SetCheckFailedCallback(TsanCheckFailed);\n+  SetCheckUnwindCallback(CheckUnwind);\n \n   ctx = new(ctx_placeholder) Context;\n   const char *env_name = SANITIZER_GO ? \"GORACE\" : \"TSAN_OPTIONS\";\n@@ -499,23 +534,27 @@ int Finalize(ThreadState *thr) {\n void ForkBefore(ThreadState *thr, uptr pc) {\n   ctx->thread_registry->Lock();\n   ctx->report_mtx.Lock();\n-  // Ignore memory accesses in the pthread_atfork callbacks.\n-  // If any of them triggers a data race we will deadlock\n-  // on the report_mtx.\n-  // We could ignore interceptors and sync operations as well,\n+  // Suppress all reports in the pthread_atfork callbacks.\n+  // Reports will deadlock on the report_mtx.\n+  // We could ignore sync operations as well,\n   // but so far it's unclear if it will do more good or harm.\n   // Unnecessarily ignoring things can lead to false positives later.\n-  ThreadIgnoreBegin(thr, pc);\n+  thr->suppress_reports++;\n+  // On OS X, REAL(fork) can call intercepted functions (OSSpinLockLock), and\n+  // we'll assert in CheckNoLocks() unless we ignore interceptors.\n+  thr->ignore_interceptors++;\n }\n \n void ForkParentAfter(ThreadState *thr, uptr pc) {\n-  ThreadIgnoreEnd(thr, pc);  // Begin is in ForkBefore.\n+  thr->suppress_reports--;  // Enabled in ForkBefore.\n+  thr->ignore_interceptors--;\n   ctx->report_mtx.Unlock();\n   ctx->thread_registry->Unlock();\n }\n \n void ForkChildAfter(ThreadState *thr, uptr pc) {\n-  ThreadIgnoreEnd(thr, pc);  // Begin is in ForkBefore.\n+  thr->suppress_reports--;  // Enabled in ForkBefore.\n+  thr->ignore_interceptors--;\n   ctx->report_mtx.Unlock();\n   ctx->thread_registry->Unlock();\n "}, {"sha": "3ae519d34da4f7b1476e0f2cea4f72399fcb3619", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -84,9 +84,6 @@ typedef Allocator::AllocatorCache AllocatorCache;\n Allocator *allocator();\n #endif\n \n-void TsanCheckFailed(const char *file, int line, const char *cond,\n-                     u64 v1, u64 v2);\n-\n const u64 kShadowRodata = (u64)-1;  // .rodata shadow marker\n \n // FastState (from most significant bit):\n@@ -406,7 +403,7 @@ struct ThreadState {\n #if TSAN_COLLECT_STATS\n   u64 stat[StatCnt];\n #endif\n-  const int tid;\n+  const u32 tid;\n   const int unique_id;\n   bool in_symbolizer;\n   bool in_ignored_lib;\n@@ -447,9 +444,8 @@ struct ThreadState {\n \n   const ReportDesc *current_report;\n \n-  explicit ThreadState(Context *ctx, int tid, int unique_id, u64 epoch,\n-                       unsigned reuse_count,\n-                       uptr stk_addr, uptr stk_size,\n+  explicit ThreadState(Context *ctx, u32 tid, int unique_id, u64 epoch,\n+                       unsigned reuse_count, uptr stk_addr, uptr stk_size,\n                        uptr tls_addr, uptr tls_size);\n };\n \n@@ -624,6 +620,7 @@ class ScopedReport : public ScopedReportBase {\n   ScopedErrorReportLock lock_;\n };\n \n+bool ShouldReport(ThreadState *thr, ReportType typ);\n ThreadContext *IsThreadStackOrTls(uptr addr, bool *is_stack);\n void RestoreStack(int tid, const u64 epoch, VarSizeStackTrace *stk,\n                   MutexSet *mset, uptr *tag = nullptr);"}, {"sha": "0a8f3aa3ddb2012d1900f5dd4ff07c56a68c8dc1", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cpp", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -51,6 +51,8 @@ static void ReportMutexMisuse(ThreadState *thr, uptr pc, ReportType typ,\n   // or false positives (e.g. unlock in a different thread).\n   if (SANITIZER_GO)\n     return;\n+  if (!ShouldReport(thr, typ))\n+    return;\n   ThreadRegistryLock l(ctx->thread_registry);\n   ScopedReport rep(typ);\n   rep.AddMutex(mid);\n@@ -96,9 +98,8 @@ void MutexDestroy(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n     ctx->dd->MutexInit(&cb, &s->dd);\n   }\n   bool unlock_locked = false;\n-  if (flags()->report_destroy_locked\n-      && s->owner_tid != SyncVar::kInvalidTid\n-      && !s->IsFlagSet(MutexFlagBroken)) {\n+  if (flags()->report_destroy_locked && s->owner_tid != kInvalidTid &&\n+      !s->IsFlagSet(MutexFlagBroken)) {\n     s->SetFlags(MutexFlagBroken);\n     unlock_locked = true;\n   }\n@@ -107,7 +108,7 @@ void MutexDestroy(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n   if (!unlock_locked)\n     s->Reset(thr->proc());  // must not reset it before the report is printed\n   s->mtx.Unlock();\n-  if (unlock_locked) {\n+  if (unlock_locked && ShouldReport(thr, ReportTypeMutexDestroyLocked)) {\n     ThreadRegistryLock l(ctx->thread_registry);\n     ScopedReport rep(ReportTypeMutexDestroyLocked);\n     rep.AddMutex(mid);\n@@ -169,7 +170,7 @@ void MutexPostLock(ThreadState *thr, uptr pc, uptr addr, u32 flagz, int rec) {\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeLock, s->GetId());\n   bool report_double_lock = false;\n-  if (s->owner_tid == SyncVar::kInvalidTid) {\n+  if (s->owner_tid == kInvalidTid) {\n     CHECK_EQ(s->recursion, 0);\n     s->owner_tid = thr->tid;\n     s->last_lock = thr->fast_state.raw();\n@@ -229,7 +230,7 @@ int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n     s->recursion -= rec;\n     if (s->recursion == 0) {\n       StatInc(thr, StatMutexUnlock);\n-      s->owner_tid = SyncVar::kInvalidTid;\n+      s->owner_tid = kInvalidTid;\n       ReleaseStoreImpl(thr, pc, &s->clock);\n     } else {\n       StatInc(thr, StatMutexRecUnlock);\n@@ -275,7 +276,7 @@ void MutexPostReadLock(ThreadState *thr, uptr pc, uptr addr, u32 flagz) {\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeRLock, s->GetId());\n   bool report_bad_lock = false;\n-  if (s->owner_tid != SyncVar::kInvalidTid) {\n+  if (s->owner_tid != kInvalidTid) {\n     if (flags()->report_mutex_bugs && !s->IsFlagSet(MutexFlagBroken)) {\n       s->SetFlags(MutexFlagBroken);\n       report_bad_lock = true;\n@@ -314,7 +315,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, s->GetId());\n   bool report_bad_unlock = false;\n-  if (s->owner_tid != SyncVar::kInvalidTid) {\n+  if (s->owner_tid != kInvalidTid) {\n     if (flags()->report_mutex_bugs && !s->IsFlagSet(MutexFlagBroken)) {\n       s->SetFlags(MutexFlagBroken);\n       report_bad_unlock = true;\n@@ -344,7 +345,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   bool write = true;\n   bool report_bad_unlock = false;\n-  if (s->owner_tid == SyncVar::kInvalidTid) {\n+  if (s->owner_tid == kInvalidTid) {\n     // Seems to be read unlock.\n     write = false;\n     StatInc(thr, StatMutexReadUnlock);\n@@ -359,7 +360,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     s->recursion--;\n     if (s->recursion == 0) {\n       StatInc(thr, StatMutexUnlock);\n-      s->owner_tid = SyncVar::kInvalidTid;\n+      s->owner_tid = kInvalidTid;\n       ReleaseStoreImpl(thr, pc, &s->clock);\n     } else {\n       StatInc(thr, StatMutexRecUnlock);\n@@ -387,7 +388,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n void MutexRepair(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: MutexRepair %zx\\n\", thr->tid, addr);\n   SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n-  s->owner_tid = SyncVar::kInvalidTid;\n+  s->owner_tid = kInvalidTid;\n   s->recursion = 0;\n   s->mtx.Unlock();\n }\n@@ -534,7 +535,7 @@ void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n }\n \n void ReportDeadlock(ThreadState *thr, uptr pc, DDReport *r) {\n-  if (r == 0)\n+  if (r == 0 || !ShouldReport(thr, ReportTypeDeadlock))\n     return;\n   ThreadRegistryLock l(ctx->thread_registry);\n   ScopedReport rep(ReportTypeDeadlock);"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "706794fdad10dfda88b665a5662cc0a775c76ff7", "filename": "libsanitizer/tsan/tsan_rtl_report.cpp", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -31,23 +31,6 @@ using namespace __sanitizer;\n \n static ReportStack *SymbolizeStack(StackTrace trace);\n \n-void TsanCheckFailed(const char *file, int line, const char *cond,\n-                     u64 v1, u64 v2) {\n-  // There is high probability that interceptors will check-fail as well,\n-  // on the other hand there is no sense in processing interceptors\n-  // since we are going to die soon.\n-  ScopedIgnoreInterceptors ignore;\n-#if !SANITIZER_GO\n-  cur_thread()->ignore_sync++;\n-  cur_thread()->ignore_reads_and_writes++;\n-#endif\n-  Printf(\"FATAL: ThreadSanitizer CHECK failed: \"\n-         \"%s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n-         file, line, cond, (uptr)v1, (uptr)v2);\n-  PrintCurrentStackSlow(StackTrace::GetCurrentPc());\n-  Die();\n-}\n-\n // Can be overriden by an application/test to intercept reports.\n #ifdef TSAN_EXTERNAL_HOOKS\n bool OnReport(const ReportDesc *rep, bool suppressed);\n@@ -142,6 +125,34 @@ static ReportStack *SymbolizeStack(StackTrace trace) {\n   return stack;\n }\n \n+bool ShouldReport(ThreadState *thr, ReportType typ) {\n+  // We set thr->suppress_reports in the fork context.\n+  // Taking any locking in the fork context can lead to deadlocks.\n+  // If any locks are already taken, it's too late to do this check.\n+  CheckNoLocks(thr);\n+  // For the same reason check we didn't lock thread_registry yet.\n+  if (SANITIZER_DEBUG)\n+    ThreadRegistryLock l(ctx->thread_registry);\n+  if (!flags()->report_bugs || thr->suppress_reports)\n+    return false;\n+  switch (typ) {\n+    case ReportTypeSignalUnsafe:\n+      return flags()->report_signal_unsafe;\n+    case ReportTypeThreadLeak:\n+#if !SANITIZER_GO\n+      // It's impossible to join phantom threads\n+      // in the child after fork.\n+      if (ctx->after_multithreaded_fork)\n+        return false;\n+#endif\n+      return flags()->report_thread_leaks;\n+    case ReportTypeMutexDestroyLocked:\n+      return flags()->report_destroy_locked;\n+    default:\n+      return true;\n+  }\n+}\n+\n ScopedReportBase::ScopedReportBase(ReportType typ, uptr tag) {\n   ctx->thread_registry->CheckLocked();\n   void *mem = internal_alloc(MBlockReport, sizeof(ReportDesc));\n@@ -497,8 +508,10 @@ static bool HandleRacyAddress(ThreadState *thr, uptr addr_min, uptr addr_max) {\n }\n \n bool OutputReport(ThreadState *thr, const ScopedReport &srep) {\n-  if (!flags()->report_bugs || thr->suppress_reports)\n-    return false;\n+  // These should have been checked in ShouldReport.\n+  // It's too late to check them here, we have already taken locks.\n+  CHECK(flags()->report_bugs);\n+  CHECK(!thr->suppress_reports);\n   atomic_store_relaxed(&ctx->last_symbolize_time_ns, NanoTime());\n   const ReportDesc *rep = srep.GetReport();\n   CHECK_EQ(thr->current_report, nullptr);\n@@ -589,7 +602,7 @@ void ReportRace(ThreadState *thr) {\n   // at best it will cause deadlocks on internal mutexes.\n   ScopedIgnoreInterceptors ignore;\n \n-  if (!flags()->report_bugs)\n+  if (!ShouldReport(thr, ReportTypeRace))\n     return;\n   if (!flags()->report_atomic_races && !RaceBetweenAtomicAndFree(thr))\n     return;\n@@ -722,8 +735,7 @@ void PrintCurrentStack(ThreadState *thr, uptr pc) {\n // However, this solution is not reliable enough, please see dvyukov's comment\n // http://reviews.llvm.org/D19148#406208\n // Also see PR27280 comment 2 and 3 for breaking examples and analysis.\n-ALWAYS_INLINE\n-void PrintCurrentStackSlow(uptr pc) {\n+ALWAYS_INLINE USED void PrintCurrentStackSlow(uptr pc) {\n #if !SANITIZER_GO\n   uptr bp = GET_CURRENT_FRAME();\n   BufferedStackTrace *ptrace ="}, {"sha": "6d1ccd8c9c78a51d6d36575f13f5bab22ce42d89", "filename": "libsanitizer/tsan/tsan_rtl_thread.cpp", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -51,7 +51,7 @@ struct OnCreatedArgs {\n \n void ThreadContext::OnCreated(void *arg) {\n   thr = 0;\n-  if (tid == 0)\n+  if (tid == kMainTid)\n     return;\n   OnCreatedArgs *args = static_cast<OnCreatedArgs *>(arg);\n   if (!args->thr)  // GCD workers don't have a parent thread.\n@@ -179,7 +179,7 @@ static void MaybeReportThreadLeak(ThreadContextBase *tctx_base, void *arg) {\n \n #if !SANITIZER_GO\n static void ReportIgnoresEnabled(ThreadContext *tctx, IgnoreSet *set) {\n-  if (tctx->tid == 0) {\n+  if (tctx->tid == kMainTid) {\n     Printf(\"ThreadSanitizer: main thread finished with ignores enabled\\n\");\n   } else {\n     Printf(\"ThreadSanitizer: thread T%d %s finished with ignores enabled,\"\n@@ -210,7 +210,7 @@ static void ThreadCheckIgnore(ThreadState *thr) {}\n void ThreadFinalize(ThreadState *thr) {\n   ThreadCheckIgnore(thr);\n #if !SANITIZER_GO\n-  if (!flags()->report_thread_leaks)\n+  if (!ShouldReport(thr, ReportTypeThreadLeak))\n     return;\n   ThreadRegistryLock l(ctx->thread_registry);\n   Vector<ThreadLeak> leaks;\n@@ -250,9 +250,10 @@ void ThreadStart(ThreadState *thr, int tid, tid_t os_id,\n   uptr tls_size = 0;\n #if !SANITIZER_GO\n   if (thread_type != ThreadType::Fiber)\n-    GetThreadStackAndTls(tid == 0, &stk_addr, &stk_size, &tls_addr, &tls_size);\n+    GetThreadStackAndTls(tid == kMainTid, &stk_addr, &stk_size, &tls_addr,\n+                         &tls_size);\n \n-  if (tid) {\n+  if (tid != kMainTid) {\n     if (stk_addr && stk_size)\n       MemoryRangeImitateWrite(thr, /*pc=*/ 1, stk_addr, stk_size);\n \n@@ -313,7 +314,7 @@ static bool ConsumeThreadByUid(ThreadContextBase *tctx, void *arg) {\n int ThreadConsumeTid(ThreadState *thr, uptr pc, uptr uid) {\n   ConsumeThreadContext findCtx = {uid, nullptr};\n   ctx->thread_registry->FindThread(ConsumeThreadByUid, &findCtx);\n-  int tid = findCtx.tctx ? findCtx.tctx->tid : ThreadRegistry::kUnknownTid;\n+  int tid = findCtx.tctx ? findCtx.tctx->tid : kInvalidTid;\n   DPrintf(\"#%d: ThreadTid uid=%zu tid=%d\\n\", thr->tid, uid, tid);\n   return tid;\n }"}, {"sha": "ba24f98ae9f6f91627e040aa3a4aee8559bf53c4", "filename": "libsanitizer/tsan/tsan_sync.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_sync.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_sync.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -53,8 +53,8 @@ void SyncVar::Reset(Processor *proc) {\n }\n \n MetaMap::MetaMap()\n-    : block_alloc_(\"heap block allocator\")\n-    , sync_alloc_(\"sync allocator\") {\n+    : block_alloc_(LINKER_INITIALIZED, \"heap block allocator\"),\n+      sync_alloc_(LINKER_INITIALIZED, \"sync allocator\") {\n   atomic_store(&uid_gen_, 0, memory_order_relaxed);\n }\n "}, {"sha": "c4056f684d7e868358190bda40921fe18bb4a290", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -50,13 +50,11 @@ enum MutexFlags {\n struct SyncVar {\n   SyncVar();\n \n-  static const int kInvalidTid = -1;\n-\n   uptr addr;  // overwritten by DenseSlabAlloc freelist\n   Mutex mtx;\n   u64 uid;  // Globally unique id.\n   u32 creation_stack_id;\n-  int owner_tid;  // Set only by exclusive owners.\n+  u32 owner_tid;  // Set only by exclusive owners.\n   u64 last_lock;\n   int recursion;\n   atomic_uint32_t flags;\n@@ -130,8 +128,8 @@ class MetaMap {\n   static const u32 kFlagMask  = 3u << 30;\n   static const u32 kFlagBlock = 1u << 30;\n   static const u32 kFlagSync  = 2u << 30;\n-  typedef DenseSlabAlloc<MBlock, 1<<16, 1<<12> BlockAlloc;\n-  typedef DenseSlabAlloc<SyncVar, 1<<16, 1<<10> SyncAlloc;\n+  typedef DenseSlabAlloc<MBlock, 1 << 18, 1 << 12, kFlagMask> BlockAlloc;\n+  typedef DenseSlabAlloc<SyncVar, 1 << 20, 1 << 10, kFlagMask> SyncAlloc;\n   BlockAlloc block_alloc_;\n   SyncAlloc sync_alloc_;\n   atomic_uint64_t uid_gen_;"}, {"sha": "ef2e495cac8edc7d3e956e28768ac9f5c125ad17", "filename": "libsanitizer/ubsan/ubsan_diag.cpp", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_diag.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_diag.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -278,7 +278,7 @@ static void PrintMemorySnippet(const Decorator &Decor, MemoryLocation Loc,\n   }\n \n   // Emit data.\n-  InternalScopedString Buffer(1024);\n+  InternalScopedString Buffer;\n   for (uptr P = Min; P != Max; ++P) {\n     unsigned char C = *reinterpret_cast<const unsigned char*>(P);\n     Buffer.append(\"%s%02x\", (P % 8 == 0) ? \"  \" : \" \", C);\n@@ -346,7 +346,7 @@ Diag::~Diag() {\n   // All diagnostics should be printed under report mutex.\n   ScopedReport::CheckLocked();\n   Decorator Decor;\n-  InternalScopedString Buffer(1024);\n+  InternalScopedString Buffer;\n \n   // Prepare a report that a monitor process can inspect.\n   if (Level == DL_Error) {\n@@ -388,6 +388,10 @@ ScopedReport::ScopedReport(ReportOptions Opts, Location SummaryLoc,\n ScopedReport::~ScopedReport() {\n   MaybePrintStackTrace(Opts.pc, Opts.bp);\n   MaybeReportErrorSummary(SummaryLoc, Type);\n+\n+  if (common_flags()->print_module_map >= 2)\n+    DumpProcessMap();\n+\n   if (flags()->halt_on_error)\n     Die();\n }"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -50,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "e201e6bba22078e3d873aeb5792b98ecd860cdaa", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -894,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -215,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "9931d85bf40c55ecbeec9410703e5d698c3f18d2", "filename": "libsanitizer/ubsan/ubsan_init.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_init.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_init.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -33,6 +33,11 @@ static void CommonInit() {\n   InitializeSuppressions();\n }\n \n+static void UbsanDie() {\n+  if (common_flags()->print_module_map >= 1)\n+    DumpProcessMap();\n+}\n+\n static void CommonStandaloneInit() {\n   SanitizerToolName = GetSanititizerToolName();\n   CacheBinaryName();\n@@ -42,6 +47,10 @@ static void CommonStandaloneInit() {\n   AndroidLogInit();\n   InitializeCoverage(common_flags()->coverage, common_flags()->coverage_dir);\n   CommonInit();\n+\n+  // Only add die callback when running in standalone mode to avoid printing\n+  // the same information from multiple sanitizers' output\n+  AddDieCallback(UbsanDie);\n   Symbolizer::LateInitialize();\n }\n "}, {"sha": "69dd986f9bdfc52111ff2ff460036baa39b893c5", "filename": "libsanitizer/ubsan/ubsan_monitor.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_monitor.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_monitor.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_monitor.cpp?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -17,7 +17,7 @@ using namespace __ubsan;\n UndefinedBehaviorReport::UndefinedBehaviorReport(const char *IssueKind,\n                                                  Location &Loc,\n                                                  InternalScopedString &Msg)\n-    : IssueKind(IssueKind), Loc(Loc), Buffer(Msg.length() + 1) {\n+    : IssueKind(IssueKind), Loc(Loc) {\n   // We have the common sanitizer reporting lock, so it's safe to register a\n   // new UB report.\n   RegisterUndefinedBehaviorReport(this);\n@@ -52,9 +52,9 @@ void __ubsan::__ubsan_get_current_report_data(const char **OutIssueKind,\n \n   // Ensure that the first character of the diagnostic text can't start with a\n   // lowercase letter.\n-  char FirstChar = Buf.data()[0];\n+  char FirstChar = *Buf.data();\n   if (FirstChar >= 'a' && FirstChar <= 'z')\n-    Buf.data()[0] = FirstChar - 'a' + 'A';\n+    *Buf.data() += 'A' - 'a';\n \n   *OutIssueKind = CurrentUBR->IssueKind;\n   *OutMessage = Buf.data();"}, {"sha": "51e535d1e2221b915cad8ffde852910cefe8f0d3", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0fee87e0ce24f066cde3dbf9605abce24dd75e1/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=d0fee87e0ce24f066cde3dbf9605abce24dd75e1", "patch": "@@ -12,16 +12,14 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n-    defined(__NetBSD__) || \\\n+    defined(__NetBSD__) || defined(__DragonFly__) || \\\n     (defined(__sun__) && defined(__svr4__)) || \\\n     defined(_WIN32) || defined(__Fuchsia__) || defined(__rtems__)\n # define CAN_SANITIZE_UB 1\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}]}