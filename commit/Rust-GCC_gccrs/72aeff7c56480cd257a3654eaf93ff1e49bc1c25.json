{"sha": "72aeff7c56480cd257a3654eaf93ff1e49bc1c25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJhZWZmN2M1NjQ4MGNkMjU3YTM2NTRlYWY5M2ZmMWU0OWJjMWMyNQ==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2006-07-15T06:58:57Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2006-07-15T06:58:57Z"}, "message": "re PR middle-end/28160 (Bogus \"size of array 'foo' is too large\" error with -mms-bitfields)\n\n\tPR middle-end/28160\n\t* stor-layout.c (place_field): Take the bit field with\n\tan excessive size into account in the ms-bitfiled case.\n\n\tPR middle-end/28161\n\t* stor-layout.c (place_field): Use DECL_BIT_FIELD_TYPE of\n\tthe previous bit field.\n\nFrom-SVN: r115464", "tree": {"sha": "5a9d43d87ccf06adee9d7332a079bc75057b5f43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a9d43d87ccf06adee9d7332a079bc75057b5f43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72aeff7c56480cd257a3654eaf93ff1e49bc1c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72aeff7c56480cd257a3654eaf93ff1e49bc1c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72aeff7c56480cd257a3654eaf93ff1e49bc1c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72aeff7c56480cd257a3654eaf93ff1e49bc1c25/comments", "author": null, "committer": null, "parents": [{"sha": "5cd8e1235ab323384494098385ec75071b64152b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd8e1235ab323384494098385ec75071b64152b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cd8e1235ab323384494098385ec75071b64152b"}], "stats": {"total": 47, "additions": 33, "deletions": 14}, "files": [{"sha": "8bdcd70435ab5fc092c0f5485af68d2dead7136f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72aeff7c56480cd257a3654eaf93ff1e49bc1c25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72aeff7c56480cd257a3654eaf93ff1e49bc1c25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72aeff7c56480cd257a3654eaf93ff1e49bc1c25", "patch": "@@ -1,3 +1,13 @@\n+2006-07-15  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR middle-end/28160\n+\t* stor-layout.c (place_field): Take the bit field with\n+\tan excessive size into account in the ms-bitfiled case.\n+\n+\tPR middle-end/28161\n+\t* stor-layout.c (place_field): Use DECL_BIT_FIELD_TYPE of\n+\tthe previous bit field.\n+\n 2006-07-14  Eliot Dresselhaus  <eliot@sonic.net>\n \n \tPR target/27287"}, {"sha": "415f7c1168e2dbfd26f8cee33608cec6eb0a3b7b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72aeff7c56480cd257a3654eaf93ff1e49bc1c25/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72aeff7c56480cd257a3654eaf93ff1e49bc1c25/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=72aeff7c56480cd257a3654eaf93ff1e49bc1c25", "patch": "@@ -1022,6 +1022,7 @@ place_field (record_layout_info rli, tree field)\n   if (targetm.ms_bitfield_layout_p (rli->t))\n     {\n       tree prev_saved = rli->prev_field;\n+      tree prev_type = prev_saved ? DECL_BIT_FIELD_TYPE (prev_saved) : NULL;\n \n       /* This is a bitfield if it exists.  */\n       if (rli->prev_field)\n@@ -1037,8 +1038,7 @@ place_field (record_layout_info rli, tree field)\n \t      && !integer_zerop (DECL_SIZE (rli->prev_field))\n \t      && host_integerp (DECL_SIZE (rli->prev_field), 0)\n \t      && host_integerp (TYPE_SIZE (type), 0)\n-\t      && simple_cst_equal (TYPE_SIZE (type),\n-\t\t\t\t   TYPE_SIZE (TREE_TYPE (rli->prev_field))))\n+\t      && simple_cst_equal (TYPE_SIZE (type), TYPE_SIZE (prev_type)))\n \t    {\n \t      /* We're in the middle of a run of equal type size fields; make\n \t\t sure we realign if we run out of bits.  (Not decl size,\n@@ -1047,17 +1047,20 @@ place_field (record_layout_info rli, tree field)\n \n \t      if (rli->remaining_in_alignment < bitsize)\n \t\t{\n+\t\t  HOST_WIDE_INT typesize = tree_low_cst (TYPE_SIZE (type), 1);\n+\n \t\t  /* out of bits; bump up to next 'word'.  */\n-\t\t  rli->offset = DECL_FIELD_OFFSET (rli->prev_field);\n \t\t  rli->bitpos\n-\t\t    = size_binop (PLUS_EXPR, TYPE_SIZE (type),\n-\t\t\t\t  DECL_FIELD_BIT_OFFSET (rli->prev_field));\n+\t\t    = size_binop (PLUS_EXPR, rli->bitpos,\n+\t\t\t\t  bitsize_int (rli->remaining_in_alignment));\n \t\t  rli->prev_field = field;\n-\t\t  rli->remaining_in_alignment\n-\t\t    = tree_low_cst (TYPE_SIZE (type), 1);\n+\t\t  if (typesize < bitsize)\n+\t\t    rli->remaining_in_alignment = 0;\n+\t\t  else\n+\t\t    rli->remaining_in_alignment = typesize - bitsize;\n \t\t}\n-\n-\t      rli->remaining_in_alignment -= bitsize;\n+\t      else\n+\t\trli->remaining_in_alignment -= bitsize;\n \t    }\n \t  else\n \t    {\n@@ -1105,8 +1108,7 @@ place_field (record_layout_info rli, tree field)\n \n       if (!DECL_BIT_FIELD_TYPE (field)\n \t  || (prev_saved != NULL\n-\t      ? !simple_cst_equal (TYPE_SIZE (type),\n-\t\t\t\t   TYPE_SIZE (TREE_TYPE (prev_saved)))\n+\t      ? !simple_cst_equal (TYPE_SIZE (type), TYPE_SIZE (prev_type))\n \t      : !integer_zerop (DECL_SIZE (field)) ))\n \t{\n \t  /* Never smaller than a byte for compatibility.  */\n@@ -1119,9 +1121,16 @@ place_field (record_layout_info rli, tree field)\n \t  if (DECL_SIZE (field) != NULL\n \t      && host_integerp (TYPE_SIZE (TREE_TYPE (field)), 0)\n \t      && host_integerp (DECL_SIZE (field), 0))\n-\t    rli->remaining_in_alignment\n-\t      = tree_low_cst (TYPE_SIZE (TREE_TYPE(field)), 1)\n-\t\t- tree_low_cst (DECL_SIZE (field), 1);\n+\t    {\n+\t      HOST_WIDE_INT bitsize = tree_low_cst (DECL_SIZE (field), 1);\n+\t      HOST_WIDE_INT typesize\n+\t\t= tree_low_cst (TYPE_SIZE (TREE_TYPE (field)), 1);\n+\n+\t      if (typesize < bitsize)\n+\t\trli->remaining_in_alignment = 0;\n+\t      else\n+\t\trli->remaining_in_alignment = typesize - bitsize;\n+\t    }\n \n \t  /* Now align (conventionally) for the new type.  */\n \t  type_align = TYPE_ALIGN (TREE_TYPE (field));"}]}