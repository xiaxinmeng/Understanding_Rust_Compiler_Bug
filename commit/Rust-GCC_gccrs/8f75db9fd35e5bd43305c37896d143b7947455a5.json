{"sha": "8f75db9fd35e5bd43305c37896d143b7947455a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY3NWRiOWZkMzVlNWJkNDMzMDVjMzc4OTZkMTQzYjc5NDc0NTVhNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-05-05T08:49:43Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-05-05T08:49:43Z"}, "message": "re PR fortran/41600 ([OOP] SELECT TYPE with associate-name => exp: Arrays not supported)\n\n2012-05-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/41600\n\t* trans-array.c (build_array_ref): New static function.\n\t(gfc_conv_array_ref, gfc_get_dataptr_offset): Call it.\n\t* trans-expr.c (gfc_get_vptr_from_expr): New function.\n\t(gfc_conv_derived_to_class): Add a new argument for a caller\n\tsupplied vptr and use it if it is not NULL.\n\t(gfc_conv_procedure_call): Add NULL to call to above.\n\tsymbol.c (gfc_is_associate_pointer): Return true if symbol is\n\ta class object.\n\t* trans-stmt.c (trans_associate_var): Handle class associate-\n\tnames.\n\t* expr.c (gfc_get_variable_expr): Supply the array-spec if\n\tpossible.\n\t* trans-types.c (gfc_typenode_for_spec): Set GFC_CLASS_TYPE_P\n\tfor class types.\n\t* trans.h : Add prototypes for gfc_get_vptr_from_expr and\n\tgfc_conv_derived_to_class. Define GFC_CLASS_TYPE_P.\n\t* resolve.c (resolve_variable): For class arrays, ensure that\n\tthe target expression has all the necessary _data references.\n\t(resolve_assoc_var): Throw a \"not yet implemented\" error for\n\tclass array selectors that need a temporary.\n\t* match.c (copy_ts_from_selector_to_associate,\n\tselect_derived_set_tmp, select_class_set_tmp): New functions.\n\t(select_type_set_tmp): Call one of last two new functions.\n\t(gfc_match_select_type): Copy_ts_from_selector_to_associate is\n\tcalled if associate-name is typed.\n\n\tPR fortran/53191\n\t* resolve.c (resolve_ref): C614 applied to class expressions.\n\n\n2012-05-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/41600\n\t* gfortran.dg/select_type_26.f03 : New test.\n\t* gfortran.dg/select_type_27.f03 : New test.\n\n\tPR fortran/53191\n\t* gfortran.dg/select_type_28.f03 : New test.\n\nFrom-SVN: r187192", "tree": {"sha": "f1d96d51a38966953fe2297f969ed19ca584af35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1d96d51a38966953fe2297f969ed19ca584af35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f75db9fd35e5bd43305c37896d143b7947455a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f75db9fd35e5bd43305c37896d143b7947455a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f75db9fd35e5bd43305c37896d143b7947455a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f75db9fd35e5bd43305c37896d143b7947455a5/comments", "author": null, "committer": null, "parents": [{"sha": "4ecad771dd276d6c518d679b3e13c58b45737b8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ecad771dd276d6c518d679b3e13c58b45737b8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ecad771dd276d6c518d679b3e13c58b45737b8c"}], "stats": {"total": 683, "additions": 616, "deletions": 67}, "files": [{"sha": "a9f1cecc46222cbe40f7d7ea845e51ab5af77812", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -1,3 +1,35 @@\n+2012-05-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/41600\n+\t* trans-array.c (build_array_ref): New static function.\n+\t(gfc_conv_array_ref, gfc_get_dataptr_offset): Call it.\n+\t* trans-expr.c (gfc_get_vptr_from_expr): New function.\n+\t(gfc_conv_derived_to_class): Add a new argument for a caller\n+\tsupplied vptr and use it if it is not NULL.\n+\t(gfc_conv_procedure_call): Add NULL to call to above.\n+\tsymbol.c (gfc_is_associate_pointer): Return true if symbol is\n+\ta class object.\n+\t* trans-stmt.c (trans_associate_var): Handle class associate-\n+\tnames.\n+\t* expr.c (gfc_get_variable_expr): Supply the array-spec if\n+\tpossible.\n+\t* trans-types.c (gfc_typenode_for_spec): Set GFC_CLASS_TYPE_P\n+\tfor class types.\n+\t* trans.h : Add prototypes for gfc_get_vptr_from_expr and\n+\tgfc_conv_derived_to_class. Define GFC_CLASS_TYPE_P.\n+\t* resolve.c (resolve_variable): For class arrays, ensure that\n+\tthe target expression has all the necessary _data references.\n+\t(resolve_assoc_var): Throw a \"not yet implemented\" error for\n+\tclass array selectors that need a temporary.\n+\t* match.c (copy_ts_from_selector_to_associate,\n+\tselect_derived_set_tmp, select_class_set_tmp): New functions.\n+\t(select_type_set_tmp): Call one of last two new functions.\n+\t(gfc_match_select_type): Copy_ts_from_selector_to_associate is\n+\tcalled if associate-name is typed.\n+\n+\tPR fortran/53191\n+\t* resolve.c (resolve_ref): C614 applied to class expressions.\n+\n 2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/49010"}, {"sha": "93d5df654556c7b0b946ea8de4ad94dfae08f20c", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -3821,6 +3821,9 @@ gfc_get_variable_expr (gfc_symtree *var)\n       e->ref = gfc_get_ref ();\n       e->ref->type = REF_ARRAY;\n       e->ref->u.ar.type = AR_FULL;\n+      e->ref->u.ar.as = gfc_copy_array_spec (var->n.sym->ts.type == BT_CLASS\n+\t\t\t\t\t     ? CLASS_DATA (var->n.sym)->as\n+\t\t\t\t\t     : var->n.sym->as);\n     }\n \n   return e;"}, {"sha": "3d119180a73a058c6cd1343099a1616d643c284b", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 155, "deletions": 40, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -5112,6 +5112,78 @@ gfc_match_select (void)\n }\n \n \n+/* Transfer the selector typespec to the associate name.  */\n+\n+static void\n+copy_ts_from_selector_to_associate (gfc_expr *associate, gfc_expr *selector)\n+{\n+  gfc_ref *ref;\n+  gfc_symbol *assoc_sym;\n+\n+  assoc_sym = associate->symtree->n.sym;\n+\n+  /* Ensure that any array reference is resolved.  */\n+  gfc_resolve_expr (selector);\n+\n+  /* At this stage the expression rank and arrayspec dimensions have\n+     not been completely sorted out. We must get the expr2->rank\n+     right here, so that the correct class container is obtained.  */\n+  ref = selector->ref;\n+  while (ref && ref->next)\n+    ref = ref->next;\n+\n+  if (selector->ts.type == BT_CLASS\n+\t&& CLASS_DATA (selector)->as\n+\t&& ref && ref->type == REF_ARRAY)\n+    {\n+      if (ref->u.ar.type == AR_FULL)\n+\tselector->rank = CLASS_DATA (selector)->as->rank;\n+      else if (ref->u.ar.type == AR_SECTION)\n+\tselector->rank = ref->u.ar.dimen;\n+      else\n+\tselector->rank = 0;\n+    }\n+\n+  if (selector->ts.type != BT_CLASS)\n+    {\n+      /* The correct class container has to be available.  */\n+      if (selector->rank)\n+\t{\n+\t  assoc_sym->attr.dimension = 1;\n+\t  assoc_sym->as = gfc_get_array_spec ();\n+\t  assoc_sym->as->rank = selector->rank;\n+\t  assoc_sym->as->type = AS_DEFERRED;\n+\t}\n+      else\n+\tassoc_sym->as = NULL;\n+\n+      assoc_sym->ts.type = BT_CLASS;\n+      assoc_sym->ts.u.derived = selector->ts.u.derived;\n+      assoc_sym->attr.pointer = 1;\n+      gfc_build_class_symbol (&assoc_sym->ts, &assoc_sym->attr,\n+\t\t\t      &assoc_sym->as, false);\n+    }\n+  else\n+    {\n+      /* The correct class container has to be available.  */\n+      if (selector->rank)\n+\t{\n+\t  assoc_sym->attr.dimension = 1;\n+\t  assoc_sym->as = gfc_get_array_spec ();\n+\t  assoc_sym->as->rank = selector->rank;\n+\t  assoc_sym->as->type = AS_DEFERRED;\n+\t}\n+      else\n+\tassoc_sym->as = NULL;\n+      assoc_sym->ts.type = BT_CLASS;\n+      assoc_sym->ts.u.derived = CLASS_DATA (selector)->ts.u.derived;\n+      assoc_sym->attr.pointer = 1;\n+      gfc_build_class_symbol (&assoc_sym->ts, &assoc_sym->attr,\n+\t\t\t      &assoc_sym->as, false);\n+    }\n+}\n+\n+\n /* Push the current selector onto the SELECT TYPE stack.  */\n \n static void\n@@ -5126,64 +5198,103 @@ select_type_push (gfc_symbol *sel)\n }\n \n \n-/* Set the temporary for the current SELECT TYPE selector.  */\n+/* Set the temporary for the current derived type SELECT TYPE selector.  */\n \n-static void\n-select_type_set_tmp (gfc_typespec *ts)\n+static gfc_symtree *\n+select_derived_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp;\n   \n-  if (!ts)\n+  sprintf (name, \"__tmp_type_%s\", ts->u.derived->name);\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n+  gfc_add_type (tmp->n.sym, ts, NULL);\n+\n+  /* Copy across the array spec to the selector.  */\n+  if (select_type_stack->selector->ts.type == BT_CLASS\n+      && select_type_stack->selector->attr.class_ok\n+      && (CLASS_DATA (select_type_stack->selector)->attr.dimension\n+\t  || CLASS_DATA (select_type_stack->selector)->attr.codimension))\n     {\n-      select_type_stack->tmp = NULL;\n-      return;\n+      tmp->n.sym->attr.dimension\n+\t\t= CLASS_DATA (select_type_stack->selector)->attr.dimension;\n+      tmp->n.sym->attr.codimension\n+\t\t= CLASS_DATA (select_type_stack->selector)->attr.codimension;\n+      tmp->n.sym->as\n+\t= gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);\n     }\n+\n+  gfc_set_sym_referenced (tmp->n.sym);\n+  gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n+  tmp->n.sym->attr.select_type_temporary = 1;\n+\n+  return tmp;\n+}\n+\n+\n+/* Set the temporary for the current class SELECT TYPE selector.  */\n+\n+static gfc_symtree *\n+select_class_set_tmp (gfc_typespec *ts)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN];\n+  gfc_symtree *tmp;\n   \n-  if (!gfc_type_is_extensible (ts->u.derived))\n-    return;\n+  if (select_type_stack->selector->ts.type == BT_CLASS\n+      && !select_type_stack->selector->attr.class_ok)\n+    return NULL;\n \n-  if (ts->type == BT_CLASS)\n-    sprintf (name, \"__tmp_class_%s\", ts->u.derived->name);\n-  else\n-    sprintf (name, \"__tmp_type_%s\", ts->u.derived->name);\n+  sprintf (name, \"__tmp_class_%s\", ts->u.derived->name);\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n   gfc_add_type (tmp->n.sym, ts, NULL);\n \n-/* Copy across the array spec to the selector, taking care as to\n-   whether or not it is a class object or not.  */\n+/* Copy across the array spec to the selector.  */\n   if (select_type_stack->selector->ts.type == BT_CLASS\n-      && select_type_stack->selector->attr.class_ok\n       && (CLASS_DATA (select_type_stack->selector)->attr.dimension\n \t  || CLASS_DATA (select_type_stack->selector)->attr.codimension))\n     {\n-      if (ts->type == BT_CLASS)\n-\t{\n-\t  CLASS_DATA (tmp->n.sym)->attr.dimension\n+      tmp->n.sym->attr.pointer = 1;\n+      tmp->n.sym->attr.dimension\n \t\t= CLASS_DATA (select_type_stack->selector)->attr.dimension;\n-\t  CLASS_DATA (tmp->n.sym)->attr.codimension\n+      tmp->n.sym->attr.codimension\n \t\t= CLASS_DATA (select_type_stack->selector)->attr.codimension;\n-\t  CLASS_DATA (tmp->n.sym)->as = gfc_get_array_spec ();\n-\t  CLASS_DATA (tmp->n.sym)->as\n-\t\t\t= CLASS_DATA (select_type_stack->selector)->as;\n-\t}\n-      else\n-\t{\n-\t  tmp->n.sym->attr.dimension\n-\t\t= CLASS_DATA (select_type_stack->selector)->attr.dimension;\n-\t  tmp->n.sym->attr.codimension\n-\t\t= CLASS_DATA (select_type_stack->selector)->attr.codimension;\n-\t  tmp->n.sym->as = gfc_get_array_spec ();\n-\t  tmp->n.sym->as = CLASS_DATA (select_type_stack->selector)->as;\n-\t}\n+      tmp->n.sym->as\n+\t= gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);\n     }\n \n   gfc_set_sym_referenced (tmp->n.sym);\n   gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n   tmp->n.sym->attr.select_type_temporary = 1;\n+  gfc_build_class_symbol (&tmp->n.sym->ts, &tmp->n.sym->attr,\n+\t\t\t  &tmp->n.sym->as, false);\n+\n+  return tmp;\n+}\n+\n+\n+static void\n+select_type_set_tmp (gfc_typespec *ts)\n+{\n+  gfc_symtree *tmp;\n+\n+  if (!ts)\n+    {\n+      select_type_stack->tmp = NULL;\n+      return;\n+    }\n+  \n+  if (!gfc_type_is_extensible (ts->u.derived))\n+    return;\n+\n+  /* Logic is a LOT clearer with separate functions for class and derived\n+     type temporaries! There are not many more lines of code either.  */\n   if (ts->type == BT_CLASS)\n-    gfc_build_class_symbol (&tmp->n.sym->ts, &tmp->n.sym->attr,\n-\t\t\t    &tmp->n.sym->as, false);\n+    tmp = select_class_set_tmp (ts);\n+  else\n+    tmp = select_derived_set_tmp (ts);\n+\n+  if (tmp == NULL)\n+    return;\n \n   /* Add an association for it, so the rest of the parser knows it is\n      an associate-name.  The target will be set during resolution.  */\n@@ -5194,7 +5305,7 @@ select_type_set_tmp (gfc_typespec *ts)\n   select_type_stack->tmp = tmp;\n }\n \n-\n+  \n /* Match a SELECT TYPE statement.  */\n \n match\n@@ -5204,6 +5315,7 @@ gfc_match_select_type (void)\n   match m;\n   char name[GFC_MAX_SYMBOL_LEN];\n   bool class_array;\n+  gfc_symbol *sym;\n \n   m = gfc_match_label ();\n   if (m == MATCH_ERROR)\n@@ -5225,13 +5337,16 @@ gfc_match_select_type (void)\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n \t}\n+\n+      sym = expr1->symtree->n.sym;\n       if (expr2->ts.type == BT_UNKNOWN)\n-\texpr1->symtree->n.sym->attr.untyped = 1;\n+\tsym->attr.untyped = 1;\n       else\n-\texpr1->symtree->n.sym->ts = expr2->ts;\n-      expr1->symtree->n.sym->attr.flavor = FL_VARIABLE;\n-      expr1->symtree->n.sym->attr.referenced = 1;\n-      expr1->symtree->n.sym->attr.class_ok = 1;\n+\tcopy_ts_from_selector_to_associate (expr1, expr2);\n+\n+      sym->attr.flavor = FL_VARIABLE;\n+      sym->attr.referenced = 1;\n+      sym->attr.class_ok = 1;\n     }\n   else\n     {"}, {"sha": "e5a49bcd5614b675862fb7e85d7ffc415b25a90c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -4904,14 +4904,19 @@ resolve_ref (gfc_expr *expr)\n \t    {\n \t      /* F03:C614.  */\n \t      if (ref->u.c.component->attr.pointer\n-\t\t  || ref->u.c.component->attr.proc_pointer)\n+\t\t  || ref->u.c.component->attr.proc_pointer\n+\t\t  || (ref->u.c.component->ts.type == BT_CLASS\n+\t\t\t&& CLASS_DATA (ref->u.c.component)->attr.pointer))\n \t\t{\n \t\t  gfc_error (\"Component to the right of a part reference \"\n \t\t\t     \"with nonzero rank must not have the POINTER \"\n \t\t\t     \"attribute at %L\", &expr->where);\n \t\t  return FAILURE;\n \t\t}\n-\t      else if (ref->u.c.component->attr.allocatable)\n+\t      else if (ref->u.c.component->attr.allocatable\n+\t\t\t|| (ref->u.c.component->ts.type == BT_CLASS\n+\t\t\t    && CLASS_DATA (ref->u.c.component)->attr.allocatable))\n+\n \t\t{\n \t\t  gfc_error (\"Component to the right of a part reference \"\n \t\t\t     \"with nonzero rank must not have the ALLOCATABLE \"\n@@ -5081,9 +5086,15 @@ resolve_variable (gfc_expr *e)\n     }\n \n   /* If this is an associate-name, it may be parsed with an array reference\n-     in error even though the target is scalar.  Fail directly in this case.  */\n-  if (sym->assoc && !sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)\n-    return FAILURE;\n+     in error even though the target is scalar.  Fail directly in this case.\n+     TODO Understand why class scalar expressions must be excluded.  */\n+  if (sym->assoc && !(sym->ts.type == BT_CLASS && e->rank == 0))\n+    {\n+      if (sym->ts.type == BT_CLASS)\n+\tgfc_fix_class_refs (e);\n+      if (!sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)\n+\treturn FAILURE;\n+    }\n \n   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.generic)\n     sym->ts.u.derived = gfc_find_dt_in_generic (sym->ts.u.derived);\n@@ -7941,7 +7952,7 @@ gfc_type_is_extensible (gfc_symbol *sym)\n }\n \n \n-/* Resolve an associate name:  Resolve target and ensure the type-spec is\n+/* Resolve an associate-name:  Resolve target and ensure the type-spec is\n    correct as well as possibly the array-spec.  */\n \n static void\n@@ -7997,8 +8008,25 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       sym->attr.dimension = 0;\n       return;\n     }\n-  if (target->rank > 0)\n+\n+  /* We cannot deal with class selectors that need temporaries.  */\n+  if (target->ts.type == BT_CLASS\n+\t&& gfc_ref_needs_temporary_p (target->ref))\n+    {\n+      gfc_error (\"CLASS selector at %L needs a temporary which is not \"\n+\t\t \"yet implemented\", &target->where);\n+      return;\n+    }\n+\n+  if (target->ts.type != BT_CLASS && target->rank > 0)\n     sym->attr.dimension = 1;\n+  else if (target->ts.type == BT_CLASS)\n+    gfc_fix_class_refs (target);\n+\n+  /* The associate-name will have a correct type by now. Make absolutely\n+     sure that it has not picked up a dimension attribute.  */\n+  if (sym->ts.type == BT_CLASS)\n+    sym->attr.dimension = 0;\n \n   if (sym->attr.dimension)\n     {"}, {"sha": "6ca4ca330142a800b7324da062d661f8a441ca8c", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -4882,6 +4882,9 @@ gfc_is_associate_pointer (gfc_symbol* sym)\n   if (!sym->assoc)\n     return false;\n \n+  if (sym->ts.type == BT_CLASS)\n+    return true;\n+\n   if (!sym->assoc->variable)\n     return false;\n "}, {"sha": "b24d1c323ede58f1f57e80e86dfaa94725fe73d4", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -3068,6 +3068,36 @@ add_to_offset (tree *cst_offset, tree *offset, tree t)\n     }\n }\n \n+\n+static tree\n+build_array_ref (tree desc, tree offset, tree decl)\n+{\n+  tree tmp;\n+\n+  /* Class array references need special treatment because the assigned\n+     type size needs to be used to point to the element.  */ \n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n+\t&& TREE_CODE (desc) == COMPONENT_REF\n+\t&& GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (desc, 0))))\n+    {\n+      tree type = gfc_get_element_type (TREE_TYPE (desc));\n+      tmp = TREE_OPERAND (desc, 0);\n+      tmp = gfc_get_class_array_ref (offset, tmp);\n+      tmp = fold_convert (build_pointer_type (type), tmp);\n+      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+    }\n+  else\n+    {\n+      tmp = gfc_conv_array_data (desc);\n+      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+      tmp = gfc_build_array_ref (tmp, offset, decl);\n+    }\n+\n+  return tmp;\n+}\n+\n+\n+\n /* Build an array reference.  se->expr already holds the array descriptor.\n    This should be either a variable, indirect variable reference or component\n    reference.  For arrays which do not have a descriptor, se->expr will be\n@@ -3195,10 +3225,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n     offset = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t      gfc_array_index_type, offset, cst_offset);\n \n-  /* Access the calculated element.  */\n-  tmp = gfc_conv_array_data (se->expr);\n-  tmp = build_fold_indirect_ref (tmp);\n-  se->expr = gfc_build_array_ref (tmp, offset, sym->backend_decl);\n+  se->expr = build_array_ref (se->expr, offset, sym->backend_decl);\n }\n \n \n@@ -6010,10 +6037,7 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n \treturn;\n     }\n \n-  tmp = gfc_conv_array_data (desc);\n-  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t tmp);\n-  tmp = gfc_build_array_ref (tmp, offset, NULL);\n+  tmp = build_array_ref (desc, offset, NULL);\n \n   /* Offset the data pointer for pointer assignments from arrays with\n      subreferences; e.g. my_integer => my_type(:)%integer_component.  */"}, {"sha": "8045b1f029b81d9bfee65abb912431dee75fabe6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -147,11 +147,25 @@ gfc_vtable_copy_get (tree decl)\n #undef VTABLE_COPY_FIELD\n \n \n+/* Obtain the vptr of the last class reference in an expression.  */\n+\n+tree\n+gfc_get_vptr_from_expr (tree expr)\n+{\n+  tree tmp = expr;\n+  while (tmp && !GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+    tmp = TREE_OPERAND (tmp, 0);\n+  tmp = gfc_class_vptr_get (tmp);\n+  return tmp;\n+}\n+ \n+\n /* Takes a derived type expression and returns the address of a temporary\n-   class object of the 'declared' type.  */ \n-static void\n+   class object of the 'declared' type.  If vptr is not NULL, this is\n+   used for the temporary class object.  */ \n+void\n gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n-\t\t\t   gfc_typespec class_ts)\n+\t\t\t   gfc_typespec class_ts, tree vptr)\n {\n   gfc_symbol *vtab;\n   gfc_ss *ss;\n@@ -167,11 +181,19 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n   /* Set the vptr.  */\n   ctree =  gfc_class_vptr_get (var);\n \n-  /* Remember the vtab corresponds to the derived type\n-     not to the class declared type.  */\n-  vtab = gfc_find_derived_vtab (e->ts.u.derived);\n-  gcc_assert (vtab);\n-  tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n+  if (vptr != NULL_TREE)\n+    {\n+      /* Use the dynamic vptr.  */\n+      tmp = vptr;\n+    }\n+  else\n+    {\n+      /* In this case the vtab corresponds to the derived type and the\n+\t vptr must point to it.  */\n+      vtab = gfc_find_derived_vtab (e->ts.u.derived);\n+      gcc_assert (vtab);\n+      tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n+    }\n   gfc_add_modify (&parmse->pre, ctree,\n \t\t  fold_convert (TREE_TYPE (ctree), tmp));\n \n@@ -3531,7 +3553,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  /* The derived type needs to be converted to a temporary\n \t     CLASS object.  */\n \t  gfc_init_se (&parmse, se);\n-\t  gfc_conv_derived_to_class (&parmse, e, fsym->ts);\n+\t  gfc_conv_derived_to_class (&parmse, e, fsym->ts, NULL);\n \t}\n       else if (se->ss && se->ss->info->useflags)\n \t{"}, {"sha": "323fca382c3fe0950aff8fddba73878c23c4347d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -1140,6 +1140,10 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n   gfc_expr *e;\n   tree tmp;\n   bool class_target;\n+  tree desc;\n+  tree offset;\n+  tree dim;\n+  int n;\n \n   gcc_assert (sym->assoc);\n   e = sym->assoc->target;\n@@ -1191,8 +1195,9 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t\t\t    gfc_finish_block (&se.post));\n     }\n \n-  /* CLASS arrays just need the descriptor to be directly assigned.  */\n-  else if (class_target && sym->attr.dimension)\n+  /* Derived type temporaries, arising from TYPE IS, just need the\n+     descriptor of class arrays to be assigned directly.  */\n+  else if (class_target && sym->ts.type == BT_DERIVED && sym->attr.dimension)\n     {\n       gfc_se se;\n \n@@ -1217,7 +1222,47 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       gcc_assert (!sym->attr.dimension);\n \n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr (&se, e);\n+\n+      /* Class associate-names come this way because they are\n+\t unconditionally associate pointers and the symbol is scalar.  */\n+      if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.dimension)\n+\t{\n+\t  /* For a class array we need a descriptor for the selector.  */\n+\t  gfc_conv_expr_descriptor (&se, e, gfc_walk_expr (e));\n+\n+\t  /* Obtain a temporary class container for the result.  */ \n+\t  gfc_conv_class_to_class (&se, e, sym->ts, false);\n+\t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n+\n+\t  /* Set the offset.  */\n+\t  desc = gfc_class_data_get (se.expr);\n+\t  offset = gfc_index_zero_node;\n+\t  for (n = 0; n < e->rank; n++)\n+\t    {\n+\t      dim = gfc_rank_cst[n];\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     gfc_conv_descriptor_stride_get (desc, dim),\n+\t\t\t\t     gfc_conv_descriptor_lbound_get (desc, dim));\n+\t      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t        gfc_array_index_type,\n+\t\t\t\t        offset, tmp);\n+\t    }\n+\t  gfc_conv_descriptor_offset_set (&se.pre, desc, offset);\n+\t}\n+      else if (sym->ts.type == BT_CLASS && e->ts.type == BT_CLASS\n+\t       && CLASS_DATA (e)->attr.dimension)\n+\t{\n+\t  /* This is bound to be a class array element.  */\n+\t  gfc_conv_expr_reference (&se, e);\n+\t  /* Get the _vptr component of the class object.  */ \n+\t  tmp = gfc_get_vptr_from_expr (se.expr);\n+\t  /* Obtain a temporary class container for the result.  */\n+\t  gfc_conv_derived_to_class (&se, e, sym->ts, tmp);\n+\t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n+\t}\n+      else\n+\tgfc_conv_expr (&se, e);\n \n       tmp = TREE_TYPE (sym->backend_decl);\n       tmp = gfc_build_addr_expr (tmp, se.expr);"}, {"sha": "21a94fd6f069aaab0d42b6713e0ed70abeb83bab", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -1106,6 +1106,9 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n     case BT_CLASS:\n       basetype = gfc_get_derived_type (spec->u.derived);\n \n+      if (spec->type == BT_CLASS)\n+\tGFC_CLASS_TYPE_P (basetype) = 1;\n+\n       /* If we're dealing with either C_PTR or C_FUNPTR, we modified the\n          type and kind to fit a (void *) and the basetype returned was a\n          ptr_type_node.  We need to pass up this new information to the"}, {"sha": "3b77281568af8ef8ef72cff5941a838f1fdf6eb0", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -348,8 +348,10 @@ tree gfc_vtable_size_get (tree);\n tree gfc_vtable_extends_get (tree);\n tree gfc_vtable_def_init_get (tree);\n tree gfc_vtable_copy_get (tree);\n+tree gfc_get_vptr_from_expr (tree);\n tree gfc_get_class_array_ref (tree, tree);\n tree gfc_copy_class_to_class (tree, tree, tree);\n+void gfc_conv_derived_to_class (gfc_se *, gfc_expr *, gfc_typespec, tree);\n void gfc_conv_class_to_class (gfc_se *, gfc_expr *, gfc_typespec, bool);\n \n /* Initialize an init/cleanup block.  */\n@@ -827,6 +829,8 @@ struct GTY((variable_size)) lang_decl {\n #define GFC_ARRAY_TYPE_P(node) TYPE_LANG_FLAG_2(node)\n /* Fortran POINTER type.  */\n #define GFC_POINTER_TYPE_P(node) TYPE_LANG_FLAG_3(node)\n+/* Fortran CLASS type.  */\n+#define GFC_CLASS_TYPE_P(node) TYPE_LANG_FLAG_4(node)\n /* The GFC_TYPE_ARRAY_* members are present in both descriptor and\n    descriptorless array types.  */\n #define GFC_TYPE_ARRAY_LBOUND(node, dim) \\"}, {"sha": "f43eb54fa3d32f6f95662ac1a810e04ffedcc3a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -1,3 +1,12 @@\n+2012-05-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/41600\n+\t* gfortran.dg/select_type_26.f03 : New test.\n+\t* gfortran.dg/select_type_27.f03 : New test.\n+\n+\tPR fortran/53191\n+\t* gfortran.dg/select_type_28.f03 : New test.\n+\n 2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/49010"}, {"sha": "7d9c43739fe9b0591b000d2b4a9e1300b096b82c", "filename": "gcc/testsuite/gfortran.dg/select_type_26.f03", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_26.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_26.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_26.f03?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -0,0 +1,110 @@\n+! { dg-do run }\n+! Tests fix for PR41600 and further SELECT TYPE functionality.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+  implicit none\n+  type t0\n+    integer :: j = 42\n+  end type t0\n+\n+  type, extends(t0) :: t1\n+    integer :: k = 99\n+  end type t1\n+\n+  type t\n+    integer :: i\n+    class(t0), allocatable :: foo(:)\n+  end type t\n+\n+  type t_scalar\n+    integer :: i\n+    class(t0), allocatable :: foo\n+  end type t_scalar\n+\n+  type(t) :: m\n+  type(t_scalar) :: m1(4)\n+  integer :: n\n+\n+! Test the fix for PR41600 itself - first with m%foo of declared type.\n+  allocate(m%foo(3), source = [(t0(n), n = 1,3)])\n+  select type(bar => m%foo)\n+    type is(t0)\n+      if (any (bar%j .ne. [1,2,3])) call abort\n+    type is(t1)\n+      call abort\n+  end select\n+\n+  deallocate(m%foo)\n+  allocate(m%foo(3), source = [(t1(n, n*10), n = 4,6)])\n+\n+! Then with m%foo of another dynamic type.\n+  select type(bar => m%foo)\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (any (bar%k .ne. [40,50,60])) call abort\n+  end select\n+\n+! Try it with a selector array section.\n+  select type(bar => m%foo(2:3))\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (any (bar%k .ne. [50,60])) call abort\n+  end select\n+\n+! Try it with a selector array element.\n+  select type(bar => m%foo(2))\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (bar%k .ne. 50) call abort\n+  end select\n+\n+! Now try class is and a selector which is an array section of an associate name.\n+  select type(bar => m%foo)\n+    type is(t0)\n+      call abort\n+    class is (t1)\n+      if (any (bar%j .ne. [4,5,6])) call abort\n+      select type (foobar => bar(3:2:-1))\n+        type is (t1)\n+          if (any (foobar%k .ne. [60,50])) call abort\n+        end select\n+  end select\n+\n+! Now try class is and a selector which is an array element of an associate name.\n+  select type(bar => m%foo)\n+    type is(t0)\n+      call abort\n+    class is (t1)\n+      if (any (bar%j .ne. [4,5,6])) call abort\n+      select type (foobar => bar(2))\n+        type is (t1)\n+          if (foobar%k .ne. 50) call abort\n+        end select\n+  end select\n+\n+! Check class a component of an element of an array. Note that an array of such\n+! objects cannot be allowed since the elements could have different dynamic types.\n+! (F2003 C614)\n+  do n = 1, 2\n+    allocate(m1(n)%foo, source = t1(n*99, n*999))\n+  end do\n+  do n = 3, 4\n+    allocate(m1(n)%foo, source = t0(n*99))\n+  end do\n+  select type(bar => m1(3)%foo)\n+    type is(t0)\n+      if (bar%j .ne. 297) call abort\n+    type is(t1)\n+      call abort\n+  end select\n+  select type(bar => m1(1)%foo)\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (bar%k .ne. 999) call abort\n+  end select\n+end"}, {"sha": "5bd3c1a357bbc05cab324930c01dc0c2f71108b0", "filename": "gcc/testsuite/gfortran.dg/select_type_27.f03", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_27.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_27.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_27.f03?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -0,0 +1,115 @@\n+! { dg-do run }\n+! Tests fix for PR41600 and further SELECT TYPE functionality.\n+! This differs from the original and select_type_26.f03 by 'm'\n+! being a class object rather than a derived type.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+  implicit none\n+  type t0\n+    integer :: j = 42\n+  end type t0\n+\n+  type, extends(t0) :: t1\n+    integer :: k = 99\n+  end type t1\n+\n+  type t\n+    integer :: i\n+    class(t0), allocatable :: foo(:)\n+  end type t\n+\n+  type t_scalar\n+    integer :: i\n+    class(t0), allocatable :: foo\n+  end type t_scalar\n+\n+  class(t), allocatable :: m\n+  class(t_scalar), allocatable :: m1(:)\n+  integer :: n\n+\n+  allocate (m)\n+  allocate (m1(4))\n+\n+! Test the fix for PR41600 itself - first with m%foo of declared type.\n+  allocate(m%foo(3), source = [(t0(n), n = 1,3)])\n+  select type(bar => m%foo)\n+    type is(t0)\n+      if (any (bar%j .ne. [1,2,3])) call abort\n+    type is(t1)\n+      call abort\n+  end select\n+\n+  deallocate(m%foo)\n+  allocate(m%foo(3), source = [(t1(n, n*10), n = 4,6)])\n+\n+! Then with m%foo of another dynamic type.\n+  select type(bar => m%foo)\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (any (bar%k .ne. [40,50,60])) call abort\n+  end select\n+\n+! Try it with a selector array section.\n+  select type(bar => m%foo(2:3))\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (any (bar%k .ne. [50,60])) call abort\n+  end select\n+\n+! Try it with a selector array element.\n+  select type(bar => m%foo(2))\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (bar%k .ne. 50) call abort\n+  end select\n+\n+! Now try class is and a selector which is an array section of an associate name.\n+  select type(bar => m%foo)\n+    type is(t0)\n+      call abort\n+    class is (t1)\n+      if (any (bar%j .ne. [4,5,6])) call abort\n+      select type (foobar => bar(3:2:-1))\n+        type is (t1)\n+          if (any (foobar%k .ne. [60,50])) call abort\n+        end select\n+  end select\n+\n+! Now try class is and a selector which is an array element of an associate name.\n+  select type(bar => m%foo)\n+    type is(t0)\n+      call abort\n+    class is (t1)\n+      if (any (bar%j .ne. [4,5,6])) call abort\n+      select type (foobar => bar(2))\n+        type is (t1)\n+          if (foobar%k .ne. 50) call abort\n+        end select\n+  end select\n+\n+! Check class a component of an element of an array. Note that an array of such\n+! objects cannot be allowed since the elements could have different dynamic types.\n+! (F2003 C614)\n+  do n = 1, 2\n+    allocate(m1(n)%foo, source = t1(n*99, n*999))\n+  end do\n+  do n = 3, 4\n+    allocate(m1(n)%foo, source = t0(n*99))\n+  end do\n+  select type(bar => m1(3)%foo)\n+    type is(t0)\n+      if (bar%j .ne. 297) call abort\n+    type is(t1)\n+      call abort\n+  end select\n+  select type(bar => m1(1)%foo)\n+    type is(t0)\n+      call abort\n+    type is(t1)\n+      if (bar%k .ne. 999) call abort\n+  end select\n+end"}, {"sha": "9cab721449122165874cf10d469f035945778417", "filename": "gcc/testsuite/gfortran.dg/select_type_28.f03", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_28.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f75db9fd35e5bd43305c37896d143b7947455a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_28.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_28.f03?ref=8f75db9fd35e5bd43305c37896d143b7947455a5", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+!\n+! Fix for PR53191\n+!\n+  implicit none\n+  type t0\n+    integer :: j = 42\n+  end type t0\n+  type, extends(t0) :: t1\n+    integer :: k = 99\n+  end type t1\n+  type t\n+    integer :: i\n+    class(t0), allocatable :: foo\n+  end type t\n+  type(t) :: m(4)\n+  integer :: n\n+\n+  do n = 1, 2\n+    allocate(m(n)%foo, source = t0(n*99))\n+  end do\n+  do n = 3, 4\n+    allocate(m(n)%foo, source = t1(n*99, n*999))\n+  end do\n+\n+! An array of objects with ultimate class components cannot be a selector\n+! since each element could have a different dynamic type. (F2003 C614)\n+\n+  select type(bar => m%foo) ! { dg-error \"part reference with nonzero rank\" }\n+    type is(t0)\n+      if (any (bar%j .ne. [99, 198, 297, 396])) call abort\n+    type is(t1)\n+      call abort\n+  end select\n+\n+end"}]}