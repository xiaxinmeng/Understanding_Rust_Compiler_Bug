{"sha": "82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjZDlhOTZhZDA2YmRiNjAwODhhYTJlNzZmODU0MGExMjQ1OWNiOQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@gmail.com", "date": "2020-01-27T12:51:03Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gmail.com", "date": "2020-01-27T12:51:03Z"}, "message": "[ARC] Save mlo/mhi registers when ISR.\n\nARC600 when configured with mul64 instructions uses mlo and mhi\nregisters to store the 64 result of the multiplication. In the ARC600\nISA documentation we have the next register configuration when ARC600\nis configured only with mul64 extension:\n\nRegister | Name | Use\n---------+------+------------------------------------\nr57      | mlo  | Multiply low 32 bits, read only\nr58      | mmid | Multiply middle 32 bits, read only\nr59      | mhi  | Multiply high 32 bits, read only\n-----------------------------------------------------\n\nWhen used for Co-existence configurations we have for mul64 the next\nregisters used:\n\nRegister | Name | Use\n---------+------+------------------------------------\nr58      | mlo  | Multiply low 32 bits, read only\nr59      | mhi  | Multiply high 32 bits, read only\n-----------------------------------------------------\n\nNote that mlo/mhi assignment doesn't swap when bigendian CPU\nconfiguration is used.\n\nThe compiler will always use r58 for mlo, regardless of the\nconfiguration choosen to ensure mlo/mhi correct splitting. Fixing mlo\nto the right register number is done at assembly time. The dwarf info\nis also notified via DBX_... macro. Both mlo/mhi registers needs to\nsaved when ISR happens using a custom sequence.\n\ngcc/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-protos.h (gen_mlo): Remove.\n\t(gen_mhi): Likewise.\n\t* config/arc/arc.c (AUX_MULHI): Define.\n\t(arc_must_save_reister): Special handling for r58/59.\n\t(arc_compute_frame_size): Consider mlo/mhi registers.\n\t(arc_save_callee_saves): Emit fp/sp move only when emit_move\n\tparamter is true.\n\t(arc_conditional_register_usage): Remove TARGET_BIG_ENDIAN from\n\tmlo/mhi name selection.\n\t(arc_restore_callee_saves): Don't early restore blink when ISR.\n\t(arc_expand_prologue): Add mlo/mhi saving.\n\t(arc_expand_epilogue): Add mlo/mhi restoring.\n\t(gen_mlo): Remove.\n\t(gen_mhi): Remove.\n\t* config/arc/arc.h (DBX_REGISTER_NUMBER): Correct register\n\tnumbering when MUL64 option is used.\n\t(DWARF2_FRAME_REG_OUT): Define.\n\t* config/arc/arc.md (arc600_stall): New pattern.\n\t(VUNSPEC_ARC_ARC600_STALL): Define.\n\t(mulsi64): Use correct mlo/mhi registers.\n\t(mulsi_600): Clean it up.\n\t* config/arc/predicates.md (mlo_operand): Remove any dependency on\n\tTARGET_BIG_ENDIAN.\n\t(mhi_operand): Likewise.\n\ntestsuite/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/interrupt-6.c: Update test.", "tree": {"sha": "fd12eec241c723ae613cae3eb08928be0de3b2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd12eec241c723ae613cae3eb08928be0de3b2b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62a715c706d8482560dadfa9ead0766f3c20e434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a715c706d8482560dadfa9ead0766f3c20e434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62a715c706d8482560dadfa9ead0766f3c20e434"}], "stats": {"total": 373, "additions": 231, "deletions": 142}, "files": [{"sha": "d75d5634fbc7efd6cab8858c533d313a591f32e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -1,3 +1,30 @@\n+2020-01-27  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h (gen_mlo): Remove.\n+\t(gen_mhi): Likewise.\n+\t* config/arc/arc.c (AUX_MULHI): Define.\n+\t(arc_must_save_reister): Special handling for r58/59.\n+\t(arc_compute_frame_size): Consider mlo/mhi registers.\n+\t(arc_save_callee_saves): Emit fp/sp move only when emit_move\n+\tparamter is true.\n+\t(arc_conditional_register_usage): Remove TARGET_BIG_ENDIAN from\n+\tmlo/mhi name selection.\n+\t(arc_restore_callee_saves): Don't early restore blink when ISR.\n+\t(arc_expand_prologue): Add mlo/mhi saving.\n+\t(arc_expand_epilogue): Add mlo/mhi restoring.\n+\t(gen_mlo): Remove.\n+\t(gen_mhi): Remove.\n+\t* config/arc/arc.h (DBX_REGISTER_NUMBER): Correct register\n+\tnumbering when MUL64 option is used.\n+\t(DWARF2_FRAME_REG_OUT): Define.\n+\t* config/arc/arc.md (arc600_stall): New pattern.\n+\t(VUNSPEC_ARC_ARC600_STALL): Define.\n+\t(mulsi64): Use correct mlo/mhi registers.\n+\t(mulsi_600): Clean it up.\n+\t* config/arc/predicates.md (mlo_operand): Remove any dependency on\n+\tTARGET_BIG_ENDIAN.\n+\t(mhi_operand): Likewise.\n+\n 2020-01-27  Claudiu Zissulescu  <claziss@synopsys.com>\n \t    Petro Karashchenko  <petro.karashchenko@ring.com>\n "}, {"sha": "c72d78e3b9ebbc3fb1880bb858423db1b57f5096", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -75,8 +75,6 @@ extern int arc_hazard (rtx_insn *, rtx_insn *);\n extern int arc_write_ext_corereg (rtx);\n extern rtx gen_acc1 (void);\n extern rtx gen_acc2 (void);\n-extern rtx gen_mlo (void);\n-extern rtx gen_mhi (void);\n extern bool arc_branch_size_unknown_p (void);\n struct arc_ccfsm;\n extern void arc_ccfsm_record_condition (rtx, bool, rtx_insn *,"}, {"sha": "a1f863f17ca8fe8ef88d2aa069d45b5f210388ca", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 158, "deletions": 106, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -213,6 +213,9 @@ static int rgf_banked_register_count;\n /* FPX AUX registers.  */\n #define AUX_DPFP_START 0x301\n \n+/* ARC600 MULHI register.  */\n+#define AUX_MULHI 0x12\n+\n /* A nop is needed between a 4 byte insn that sets the condition codes and\n    a branch that uses them (the same isn't true for an 8 byte insn that sets\n    the condition codes).  Set by arc_ccfsm_advance.  Used by\n@@ -1910,8 +1913,8 @@ arc_conditional_register_usage (void)\n \t this way, we don't have to carry clobbers of that reg around in every\n \t isntruction that modifies mlo and/or mhi.  */\n       strcpy (rname57, \"\");\n-      strcpy (rname58, TARGET_BIG_ENDIAN ? \"mhi\" : \"mlo\");\n-      strcpy (rname59, TARGET_BIG_ENDIAN ? \"mlo\" : \"mhi\");\n+      strcpy (rname58, \"mlo\");\n+      strcpy (rname59, \"mhi\");\n     }\n \n   /* The nature of arc_tp_regno is actually something more like a global\n@@ -2699,8 +2702,6 @@ arc_must_save_register (int regno, struct function *func, bool special_p)\n     case R55_REG:\n     case R56_REG:\n     case R57_REG:\n-    case R58_REG:\n-    case R59_REG:\n       /* The Extension Registers.  */\n       if (ARC_INTERRUPT_P (fn_type)\n \t  && (df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n@@ -2711,6 +2712,20 @@ arc_must_save_register (int regno, struct function *func, bool special_p)\n \treturn true;\n       return false;\n \n+    case R58_REG:\n+    case R59_REG:\n+      /* ARC600 specifies those ones as mlo/mhi registers, otherwise\n+\t just handle them like any other extension register.  */\n+      if (ARC_INTERRUPT_P (fn_type)\n+\t  && (df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n+\t      || df_regs_ever_live_p (regno))\n+\t  /* Not all extension registers are available, choose the\n+\t     real ones.  */\n+\t  && ((!fixed_regs[regno] && !special_p)\n+\t      || (TARGET_MUL64_SET && special_p)))\n+\treturn true;\n+      return false;\n+\n     case 61:\n     case 62:\n     case 63:\n@@ -2797,6 +2812,7 @@ arc_compute_frame_size (void)\n   int size;\n   unsigned int extra_plus_reg_size;\n   unsigned int extra_plus_reg_size_aligned;\n+  unsigned int fn_type = arc_compute_function_type (cfun);\n \n   /* The answer might already be known.  */\n   if (cfun->machine->frame_info.initialized)\n@@ -2851,8 +2867,8 @@ arc_compute_frame_size (void)\n \n   /* Saving blink reg for millicode thunk calls.  */\n   if (TARGET_MILLICODE_THUNK_SET\n-      && !crtl->calls_eh_return\n-      && !ARC_INTERRUPT_P (arc_compute_function_type (cfun)))\n+      && !ARC_INTERRUPT_P (fn_type)\n+      && !crtl->calls_eh_return)\n     {\n       if (arc_compute_millicode_save_restore_regs (gmask, frame_info))\n \tframe_info->save_return_addr = true;\n@@ -2870,11 +2886,18 @@ arc_compute_frame_size (void)\n \t\t\t      cfun, TARGET_DPFP))\n     reg_size += UNITS_PER_WORD * 2;\n \n+  /* Check for special MLO/MHI case used by ARC600' MUL64\n+     extension.  */\n+  if (arc_must_save_register (R58_REG, cfun, TARGET_MUL64_SET))\n+    reg_size += UNITS_PER_WORD * 2;\n+\n   /* 4) Calculate extra size made up of the blink + fp size.  */\n   extra_size = 0;\n   if (arc_must_save_return_addr (cfun))\n     extra_size = 4;\n-  if (arc_frame_pointer_needed ())\n+  /* Add FP size only when it is not autosaved.  */\n+  if (arc_frame_pointer_needed ()\n+      && !ARC_AUTOFP_IRQ_P (fn_type))\n     extra_size += 4;\n \n   /* 5) Space for variable arguments passed in registers */\n@@ -3074,7 +3097,6 @@ pop_reg (rtx reg)\n   return GET_MODE_SIZE (GET_MODE (reg));\n }\n \n-\n /* Check if we have a continous range to be save/restored with the\n    help of enter/leave instructions.  A vaild register range starts\n    from $r13 and is up to (including) $r26.  */\n@@ -3106,7 +3128,8 @@ static int\n arc_save_callee_saves (uint64_t gmask,\n \t\t       bool save_blink,\n \t\t       bool save_fp,\n-\t\t       HOST_WIDE_INT offset)\n+\t\t       HOST_WIDE_INT offset,\n+\t\t       bool emit_move)\n {\n   rtx reg;\n   int frame_allocated = 0;\n@@ -3142,41 +3165,6 @@ arc_save_callee_saves (uint64_t gmask,\n \toffset = 0;\n       }\n \n-  /* Check if we need to save the ZOL machinery.  */\n-  if (arc_lpcwidth != 0 && arc_must_save_register (LP_COUNT, cfun, true))\n-    {\n-      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n-      emit_insn (gen_rtx_SET (reg0,\n-\t\t\t      gen_rtx_UNSPEC_VOLATILE\n-\t\t\t      (Pmode, gen_rtvec (1, GEN_INT (AUX_LP_START)),\n-\t\t\t       VUNSPEC_ARC_LR)));\n-      frame_allocated += push_reg (reg0);\n-      emit_insn (gen_rtx_SET (reg0,\n-\t\t\t      gen_rtx_UNSPEC_VOLATILE\n-\t\t\t      (Pmode, gen_rtvec (1, GEN_INT (AUX_LP_END)),\n-\t\t\t       VUNSPEC_ARC_LR)));\n-      frame_allocated += push_reg (reg0);\n-      emit_move_insn (reg0, gen_rtx_REG (SImode, LP_COUNT));\n-      frame_allocated += push_reg (reg0);\n-    }\n-\n-  /* Save AUX regs used by FPX machinery.  */\n-  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n-\t\t\t      cfun, TARGET_DPFP))\n-    {\n-      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n-\n-      for (i = 0; i < 4; i++)\n-\t{\n-\t  emit_insn (gen_rtx_SET (reg0,\n-\t\t\t\t  gen_rtx_UNSPEC_VOLATILE\n-\t\t\t\t  (Pmode, gen_rtvec (1, GEN_INT (AUX_DPFP_START\n-\t\t\t\t\t\t\t\t + i)),\n-\t\t\t\t   VUNSPEC_ARC_LR)));\n-\t  frame_allocated += push_reg (reg0);\n-\t}\n-    }\n-\n   /* Save frame pointer if needed.  First save the FP on stack, if not\n      autosaved.  Unfortunately, I cannot add it to gmask and use the\n      above loop to save fp because our ABI states fp goes aftert all\n@@ -3188,7 +3176,7 @@ arc_save_callee_saves (uint64_t gmask,\n     }\n \n   /* Emit mov fp,sp.  */\n-  if (arc_frame_pointer_needed ())\n+  if (emit_move)\n     frame_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n \n   return frame_allocated;\n@@ -3207,6 +3195,7 @@ arc_restore_callee_saves (uint64_t gmask,\n   rtx reg;\n   int frame_deallocated = 0;\n   HOST_WIDE_INT offs = cfun->machine->frame_info.reg_size;\n+  unsigned int fn_type = arc_compute_function_type (cfun);\n   bool early_blink_restore;\n   int i;\n \n@@ -3225,43 +3214,6 @@ arc_restore_callee_saves (uint64_t gmask,\n       frame_deallocated += frame_restore_reg (hard_frame_pointer_rtx, 0);\n     }\n \n-  /* Restore AUX-regs used by FPX machinery.  */\n-  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n-\t\t\t      cfun, TARGET_DPFP))\n-    {\n-      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n-\n-      gcc_assert (offset == 0);\n-      for (i = 0; i < 4; i++)\n-\t{\n-\t  frame_deallocated += pop_reg (reg0);\n-\t  emit_insn (gen_rtx_UNSPEC_VOLATILE\n-\t\t     (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_DPFP_START\n-\t\t\t\t\t\t\t     + i)),\n-\t\t      VUNSPEC_ARC_SR));\n-\t}\n-    }\n-\n-  /* Check if we need to restore the ZOL machinery.  */\n-  if (arc_lpcwidth !=0 && arc_must_save_register (LP_COUNT, cfun, true))\n-    {\n-      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n-\n-      gcc_assert (offset == 0);\n-      frame_deallocated += pop_reg (reg0);\n-      emit_move_insn (gen_rtx_REG (SImode, LP_COUNT), reg0);\n-\n-      frame_deallocated += pop_reg (reg0);\n-      emit_insn (gen_rtx_UNSPEC_VOLATILE\n-\t\t (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_LP_END)),\n-\t\t  VUNSPEC_ARC_SR));\n-\n-      frame_deallocated += pop_reg (reg0);\n-      emit_insn (gen_rtx_UNSPEC_VOLATILE\n-\t\t (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_LP_START)),\n-\t\t  VUNSPEC_ARC_SR));\n-    }\n-\n   if (offset)\n     {\n       /* No $fp involved, we need to do an add to set the $sp to the\n@@ -3271,9 +3223,10 @@ arc_restore_callee_saves (uint64_t gmask,\n       offset = 0;\n     }\n \n-  /* When we do not optimize for size, restore first blink.  */\n+  /* When we do not optimize for size or we aren't in an interrupt,\n+     restore first blink.  */\n   early_blink_restore = restore_blink && !optimize_size && offs\n-    && !ARC_INTERRUPT_P (arc_compute_function_type (cfun));\n+    && !ARC_INTERRUPT_P (fn_type);\n   if (early_blink_restore)\n     {\n       rtx addr = plus_constant (Pmode, stack_pointer_rtx, offs);\n@@ -3817,6 +3770,7 @@ arc_expand_prologue (void)\n   unsigned int fn_type = arc_compute_function_type (cfun);\n   bool save_blink = false;\n   bool save_fp = false;\n+  bool emit_move = false;\n \n   /* Naked functions don't have prologue.  */\n   if (ARC_NAKED_P (fn_type))\n@@ -3854,7 +3808,9 @@ arc_expand_prologue (void)\n \n   save_blink = arc_must_save_return_addr (cfun)\n     && !ARC_AUTOBLINK_IRQ_P (fn_type);\n-  save_fp = arc_frame_pointer_needed () && !ARC_AUTOFP_IRQ_P (fn_type);\n+  save_fp = arc_frame_pointer_needed () && !ARC_AUTOFP_IRQ_P (fn_type)\n+    && !ARC_INTERRUPT_P (fn_type);\n+  emit_move = arc_frame_pointer_needed () && !ARC_INTERRUPT_P (fn_type);\n \n   /* Use enter/leave only for non-interrupt functions.  */\n   if (TARGET_CODE_DENSITY\n@@ -3873,7 +3829,55 @@ arc_expand_prologue (void)\n \t\t\t\t\t\t     frame->reg_size);\n   else\n     frame_size_to_allocate -= arc_save_callee_saves (gmask, save_blink, save_fp,\n-\t\t\t\t\t\t     first_offset);\n+\t\t\t\t\t\t     first_offset, emit_move);\n+\n+  /* Check if we need to save the ZOL machinery.  */\n+  if (arc_lpcwidth != 0 && arc_must_save_register (LP_COUNT, cfun, true))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+      emit_insn (gen_rtx_SET (reg0,\n+\t\t\t      gen_rtx_UNSPEC_VOLATILE\n+\t\t\t      (Pmode, gen_rtvec (1, GEN_INT (AUX_LP_START)),\n+\t\t\t       VUNSPEC_ARC_LR)));\n+      frame_size_to_allocate -= push_reg (reg0);\n+      emit_insn (gen_rtx_SET (reg0,\n+\t\t\t      gen_rtx_UNSPEC_VOLATILE\n+\t\t\t      (Pmode, gen_rtvec (1, GEN_INT (AUX_LP_END)),\n+\t\t\t       VUNSPEC_ARC_LR)));\n+      frame_size_to_allocate -= push_reg (reg0);\n+      emit_move_insn (reg0, gen_rtx_REG (SImode, LP_COUNT));\n+      frame_size_to_allocate -= push_reg (reg0);\n+    }\n+\n+  /* Save AUX regs used by FPX machinery.  */\n+  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n+\t\t\t      cfun, TARGET_DPFP))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+      int i;\n+\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  emit_insn (gen_rtx_SET (reg0,\n+\t\t\t\t  gen_rtx_UNSPEC_VOLATILE\n+\t\t\t\t  (Pmode, gen_rtvec (1, GEN_INT (AUX_DPFP_START\n+\t\t\t\t\t\t\t\t + i)),\n+\t\t\t\t   VUNSPEC_ARC_LR)));\n+\t  frame_size_to_allocate -= push_reg (reg0);\n+\t}\n+    }\n+\n+  /* Save ARC600' MUL64 registers.  */\n+  if (arc_must_save_register (R58_REG, cfun, true))\n+    frame_size_to_allocate -= arc_save_callee_saves (3ULL << 58,\n+\t\t\t\t\t\t     false, false, 0, false);\n+\n+  if (arc_frame_pointer_needed () && ARC_INTERRUPT_P (fn_type))\n+    {\n+      /* Just save fp at the end of the saving context.  */\n+      frame_size_to_allocate -=\n+\tarc_save_callee_saves (0, false, !ARC_AUTOFP_IRQ_P (fn_type), 0, true);\n+    }\n \n   /* Allocate the stack frame.  */\n   if (frame_size_to_allocate > 0)\n@@ -3944,6 +3948,74 @@ arc_expand_epilogue (int sibcall_p)\n   if (size)\n     emit_insn (gen_blockage ());\n \n+  if (ARC_INTERRUPT_P (fn_type) && restore_fp)\n+    {\n+      /* We need to restore FP before any SP operation in an\n+\t interrupt.  */\n+      size_to_deallocate -= arc_restore_callee_saves (0, false,\n+\t\t\t\t\t\t      restore_fp,\n+\t\t\t\t\t\t      first_offset,\n+\t\t\t\t\t\t      size_to_deallocate);\n+      restore_fp = false;\n+      first_offset = 0;\n+    }\n+\n+  /* Restore ARC600' MUL64 registers.  */\n+  if (arc_must_save_register (R58_REG, cfun, true))\n+    {\n+      rtx insn;\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+      rtx reg1 = gen_rtx_REG (SImode, R1_REG);\n+      size_to_deallocate -= pop_reg (reg0);\n+      size_to_deallocate -= pop_reg (reg1);\n+\n+      insn = emit_insn (gen_mulu64 (reg0, const1_rtx));\n+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (SImode, R58_REG));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      emit_insn (gen_arc600_stall ());\n+      insn = emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t\t(VOIDmode, gen_rtvec (2, reg1, GEN_INT (AUX_MULHI)),\n+\t\t\t VUNSPEC_ARC_SR));\n+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (SImode, R59_REG));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Restore AUX-regs used by FPX machinery.  */\n+  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n+\t\t\t      cfun, TARGET_DPFP))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+      int i;\n+\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  size_to_deallocate -= pop_reg (reg0);\n+\t  emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t     (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_DPFP_START\n+\t\t\t\t\t\t\t     + i)),\n+\t\t      VUNSPEC_ARC_SR));\n+\t}\n+    }\n+\n+  /* Check if we need to restore the ZOL machinery.  */\n+  if (arc_lpcwidth !=0 && arc_must_save_register (LP_COUNT, cfun, true))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+\n+      size_to_deallocate -= pop_reg (reg0);\n+      emit_move_insn (gen_rtx_REG (SImode, LP_COUNT), reg0);\n+\n+      size_to_deallocate -= pop_reg (reg0);\n+      emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_LP_END)),\n+\t\t  VUNSPEC_ARC_SR));\n+\n+      size_to_deallocate -= pop_reg (reg0);\n+      emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_LP_START)),\n+\t\t  VUNSPEC_ARC_SR));\n+    }\n+\n   if (TARGET_CODE_DENSITY\n       && TARGET_CODE_DENSITY_FRAME\n       && !ARC_AUTOFP_IRQ_P (fn_type)\n@@ -9775,26 +9847,6 @@ gen_acc2 (void)\n   return gen_rtx_REG (SImode, TARGET_BIG_ENDIAN ? 57: 56);\n }\n \n-/* Return a REG rtx for mlo.  N.B. the gcc-internal representation may\n-   differ from the hardware register number in order to allow the generic\n-   code to correctly split the concatenation of mhi and mlo.  */\n-\n-rtx\n-gen_mlo (void)\n-{\n-  return gen_rtx_REG (SImode, TARGET_BIG_ENDIAN ? 59: 58);\n-}\n-\n-/* Return a REG rtx for mhi.  N.B. the gcc-internal representation may\n-   differ from the hardware register number in order to allow the generic\n-   code to correctly split the concatenation of mhi and mlo.  */\n-\n-rtx\n-gen_mhi (void)\n-{\n-  return gen_rtx_REG (SImode, TARGET_BIG_ENDIAN ? 58: 59);\n-}\n-\n /* FIXME: a parameter should be added, and code added to final.c,\n    to reproduce this functionality in shorten_branches.  */\n #if 0"}, {"sha": "be1d5cb21e75fc757b757ee6d5e8e2f7e3bc8aa6", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -1342,19 +1342,30 @@ do { \\\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n /* How to renumber registers for dbx and gdb.  */\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n+#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\\\n   ((TARGET_MULMAC_32BY16_SET && (REGNO) >= 56 && (REGNO) <= 57) \\\n-   ? ((REGNO) ^ !TARGET_BIG_ENDIAN) \\\n-   : (TARGET_MUL64_SET && (REGNO) >= 57 && (REGNO) <= 59) \\\n-   ? ((REGNO) == 57 \\\n-      ? 58 /* MMED */ \\\n-      : ((REGNO) & 1) ^ TARGET_BIG_ENDIAN \\\n-      ? 59 /* MHI */ \\\n-      : 57 + !!TARGET_MULMAC_32BY16_SET) /* MLO */ \\\n+   ? ((REGNO) ^ !TARGET_BIG_ENDIAN)\t\t\t\t\\\n+   : (TARGET_MUL64_SET && (REGNO) >= 57 && (REGNO) <= 58)\t\\\n+   ? (((REGNO) == 57)\t\t\t\t\t\t\\\n+      ? 58 /* MMED */\t\t\t\t\t\t\\\n+      : 57 + !!TARGET_MULMAC_32BY16_SET) /* MLO */\t\t\\\n    : (REGNO))\n \n+/* Use gcc hard register numbering for eh_frame.  */\n #define DWARF_FRAME_REGNUM(REG) (REG)\n \n+/* Map register numbers held in the call frame info that gcc has\n+   collected using DWARF_FRAME_REGNUM to those that should be output\n+   in .debug_frame and .eh_frame.  */\n+#define DWARF2_FRAME_REG_OUT(REGNO, FOR_EH)\t\t\t\\\n+  ((TARGET_MULMAC_32BY16_SET && (REGNO) >= 56 && (REGNO) <= 57) \\\n+   ? ((REGNO) ^ !TARGET_BIG_ENDIAN)\t\t\t\t\\\n+   : (TARGET_MUL64_SET && (REGNO) >= 57 && (REGNO) <= 58)\t\\\n+   ? (((REGNO) == 57)\t\t\t\t\t\t\\\n+      ? 58 /* MMED */\t\t\t\t\t\t\\\n+      : 57 + !!TARGET_MULMAC_32BY16_SET) /* MLO */\t\t\\\n+   : (REGNO))\n+\n #define DWARF_FRAME_RETURN_COLUMN \tDWARF_FRAME_REGNUM (31)\n \n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 31)"}, {"sha": "3cb5c5dd9322bc553d6a2e990c300039651539f4", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -164,6 +164,7 @@\n   VUNSPEC_ARC_BLOCKAGE\n   VUNSPEC_ARC_EH_RETURN\n   VUNSPEC_ARC_ARC600_RTIE\n+  VUNSPEC_ARC_ARC600_STALL\n   VUNSPEC_ARC_LDDI\n   VUNSPEC_ARC_STDI\n   ])\n@@ -2238,6 +2239,9 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n    (set_attr \"predicable\" \"no, no, yes\")\n    (set_attr \"cond\" \"nocond, canuse_limm, canuse\")])\n \n+; The gcc-internal representation may differ from the hardware\n+; register number in order to allow the generic code to correctly\n+; split the concatenation of mhi and mlo.\n (define_insn_and_split \"mulsi64\"\n  [(set (match_operand:SI 0 \"register_operand\"            \"=w\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\"  \"%c\")\n@@ -2247,12 +2251,13 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n  \"#\"\n  \"TARGET_MUL64_SET && reload_completed\"\n   [(const_int 0)]\n-{\n-  emit_insn (gen_mulsi_600 (operands[1], operands[2],\n-\t\t\tgen_mlo (), gen_mhi ()));\n-  emit_move_insn (operands[0], gen_mlo ());\n-  DONE;\n-}\n+  {\n+   rtx mhi = gen_rtx_REG (SImode, R59_REG);\n+   rtx mlo = gen_rtx_REG (SImode, R58_REG);\n+   emit_insn (gen_mulsi_600 (operands[1], operands[2], mlo, mhi));\n+   emit_move_insn (operands[0], mlo);\n+   DONE;\n+  }\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n@@ -2262,23 +2267,7 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n \t\t (match_operand:SI 1 \"nonmemory_operand\" \"Rcq#q,cL,I,Cal\")))\n    (clobber (match_operand:SI 3 \"mhi_operand\" \"\"))]\n   \"TARGET_MUL64_SET\"\n-; The assembler mis-assembles mul64 / mulu64 with \"I\" constraint constants,\n-; using a machine code pattern that only allows \"L\" constraint constants.\n-;  \"mul64%? \\t0, %0, %1%&\"\n-{\n-  if (satisfies_constraint_I (operands[1])\n-      && !satisfies_constraint_L (operands[1]))\n-    {\n-      /* MUL64 <0,>b,s12 00101bbb10000100 0BBBssssssSSSSSS  */\n-      int n = true_regnum (operands[0]);\n-      int i = INTVAL (operands[1]);\n-      asm_fprintf (asm_out_file, \"\\t.short %d`\", 0x2884 + ((n & 7) << 8));\n-      asm_fprintf (asm_out_file, \"\\t.short %d`\",\n-\t\t   ((i & 0x3f) << 6) + ((i >> 6) & 0x3f) + ((n & 070) << 9));\n-      return \"; mul64%? \\t0, %0, %1%&\";\n-    }\n-  return \"mul64%? \\t0, %0, %1%&\";\n-}\n+  \"mul64%?\\\\t0,%0,%1\"\n   [(set_attr \"length\" \"*,4,4,8\")\n    (set_attr \"iscompact\" \"maybe,false,false,false\")\n    (set_attr \"type\" \"multi,multi,multi,multi\")\n@@ -4298,6 +4287,14 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n    (set_attr \"type\" \"block\")]\n )\n \n+(define_insn \"arc600_stall\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_ARC_ARC600_STALL)]\n+  \"TARGET_MUL64_SET\"\n+  \"mov\\\\t0,mlo\\t;wait until multiply complete.\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"move\")]\n+)\n+\n ;; Split up troublesome insns for better scheduling.\n \n ;; Peepholes go at the end."}, {"sha": "3c03436c901c21d676e27493e866deed78184ddf", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -688,11 +688,11 @@\n \n (define_predicate \"mlo_operand\"\n   (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == (TARGET_BIG_ENDIAN ? 59 : 58)\")))\n+       (match_test \"REGNO (op) == R58_REG\")))\n \n (define_predicate \"mhi_operand\"\n   (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == (TARGET_BIG_ENDIAN ? 58 : 59)\")))\n+       (match_test \"REGNO (op) == R59_REG\")))\n \n (define_predicate \"accl_operand\"\n   (and (match_code \"reg\")"}, {"sha": "852d0ed3649d7a5e03b87a23b71d290a078072e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -1,3 +1,7 @@\n+2020-01-27  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/interrupt-6.c: Update test.\n+\n 2020-01-27  Claudiu Zissulescu  <claziss@synopsys.com>\n \t    Petro Karashchenko  <petro.karashchenko@ring.com>\n "}, {"sha": "b3d2bed45374b8b5eafd99d01193cf99600976b6", "filename": "gcc/testsuite/gcc.target/arc/interrupt-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82cd9a96ad06bdb60088aa2e76f8540a12459cb9/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c?ref=82cd9a96ad06bdb60088aa2e76f8540a12459cb9", "patch": "@@ -17,5 +17,5 @@ foo(void)\n   bar (p);\n }\n /* { dg-final { scan-assembler-not \".*fp,\\\\\\[sp\" } } */\n-/* { dg-final { scan-assembler \"ld.*blink,\\\\\\[sp\" } } */\n+/* { dg-final { scan-assembler \"pop_s.*blink\" } } */\n /* { dg-final { scan-assembler \"push_s.*blink\" } } */"}]}