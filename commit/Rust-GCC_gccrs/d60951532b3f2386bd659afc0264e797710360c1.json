{"sha": "d60951532b3f2386bd659afc0264e797710360c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwOTUxNTMyYjNmMjM4NmJkNjU5YWZjMDI2NGU3OTc3MTAzNjBjMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T16:07:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T16:07:33Z"}, "message": "[multiple changes]\n\n2013-04-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch9.adb (Build_PPC_Wrapper): Correct the traversal of\n\tpre- and post-conditions.\n\t(Expand_N_Task_Type_Declaration):\n\tUse the correct attribute to check for pre- and post-conditions.\n\t* exp_ch13.adb (Expand_N_Freeze_Entity): Correct the traversal of\n\tpre- and post-conditions.  Analyze delayed classification items.\n\t* freeze.adb (Freeze_Entity): Use the correct attribute to\n\tcheck for pre- and post- conditions.\n\t* sem_ch3.adb (Analyze_Declarations): Correct the traversal\n\tof pre- and post-conditions as well as contract- and\n\ttest-cases. Analyze delayed pragmas Depends and Global.\n\t* sem_ch6.adb (Check_Subprogram_Contract): Use the correct\n\tattribute to check for pre- and post-conditions, as well as\n\tcontract-cases and test-cases.\t(List_Inherited_Pre_Post_Aspects):\n\tCorrect the traversal of pre- and post- conditions.\n\t(Process_Contract_Cases): Update the comment on usage. Correct\n\tthe traversal of contract-cases.\n\t(Process_Post_Conditions): Update the comment on usage. Correct the\n\ttraversal of pre- and post-conditions.\n\t(Process_PPCs): Correct the traversal of pre- and post-conditions.\n\t(Spec_Postconditions): Use the correct\n\tattribute to check for pre- and post- conditions, as well as\n\tcontract-cases and test-cases.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Reimplement the\n\tactions related to aspects Depends and Global. Code refactoring\n\tfor pre- and post-conditions.\n\t(Insert_Delayed_Pragma): New routine.\n\t* sem_prag.adb (Add_Item): New routine.\n\t(Analyze_Depends_In_Decl_Part): New routine.\n\t(Analyze_Global_In_Decl_Part): New routine.\n\t(Analyze_Pragma): Reimplement the actions related to aspects Depends and\n\tGlobal. Verify that a body acts as a spec for pragma Contract_Cases.\n\t(Chain_PPC): Use Add_Contract_Item to chain a pragma.\n\t(Chain_CTC): Correct the traversal of contract-\n\tand test-cases. Use Add_Contract_Item to chain a pragma.\n\t(Chain_Contract_Cases): Correct the traversal of contract-\n\tand test-cases. Use Add_Contract_Item to chain a pragma.\n\t(Check_Precondition_Postcondition): Update the comment on usage.\n\t(Check_Test_Case): Update the comment on usage.\n\t* sem_prag.ads (Analyze_Depends_In_Decl_Part): New routine.\n\t(Analyze_Global_In_Decl_Part): New routine.\n\t* sem_util.ads, sem_util.adb (Add_Contract_Item): New routine.\n\t* sinfo.adb (Classifications): New routine.\n\t(Contract_Test_Cases): New routine.\n\t(Pre_Post_Conditions): New routine.\n\t(Set_Classifications): New routine.\n\t(Set_Contract_Test_Cases): New routine.\n\t(Set_Pre_Post_Conditions): New routine.\n\t(Set_Spec_CTC_List): Removed.\n\t(Set_Spec_PPC_List): Removed.\n\t(Spec_CTC_List): Removed.\n\t(Spec_PPC_List): Removed.\n\t* sinfo.ads: Update the structure of N_Contruct along with all\n\trelated comments.\n\t(Classifications): New routine and pragma Inline.\n\t(Contract_Test_Cases): New routine and pragma Inline.\n\t(Pre_Post_Conditions): New routine and pragma Inline.\n\t(Set_Classifications): New routine and pragma Inline.\n\t(Set_Contract_Test_Cases): New routine and pragma Inline.\n\t(Set_Pre_Post_Conditions): New routine and pragma Inline.\n\t(Set_Spec_CTC_List): Removed.\n\t(Set_Spec_PPC_List): Removed.\n\t(Spec_CTC_List): Removed.\n\t(Spec_PPC_List): Removed.\n\n2013-04-23  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c (GNAT$STOP) [VMS]: Bump sigargs[0] count by 2\n\tto account for LIB$STOP not having the chance to add the PC and\n\tPSL fields.\n\nFrom-SVN: r198198", "tree": {"sha": "a228f0a0c1fab7222b74aba774a2e0bb9413a452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a228f0a0c1fab7222b74aba774a2e0bb9413a452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d60951532b3f2386bd659afc0264e797710360c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60951532b3f2386bd659afc0264e797710360c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60951532b3f2386bd659afc0264e797710360c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60951532b3f2386bd659afc0264e797710360c1/comments", "author": null, "committer": null, "parents": [{"sha": "683e5dc2c5f4a56d7b02200e8905d7bcf0dcb993", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683e5dc2c5f4a56d7b02200e8905d7bcf0dcb993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683e5dc2c5f4a56d7b02200e8905d7bcf0dcb993"}], "stats": {"total": 16638, "additions": 8451, "deletions": 8187}, "files": [{"sha": "f914728a2f1ed617fc75ce6013d7733d6f0089dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -1,3 +1,76 @@\n+2013-04-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch9.adb (Build_PPC_Wrapper): Correct the traversal of\n+\tpre- and post-conditions.\n+\t(Expand_N_Task_Type_Declaration):\n+\tUse the correct attribute to check for pre- and post-conditions.\n+\t* exp_ch13.adb (Expand_N_Freeze_Entity): Correct the traversal of\n+\tpre- and post-conditions.  Analyze delayed classification items.\n+\t* freeze.adb (Freeze_Entity): Use the correct attribute to\n+\tcheck for pre- and post- conditions.\n+\t* sem_ch3.adb (Analyze_Declarations): Correct the traversal\n+\tof pre- and post-conditions as well as contract- and\n+\ttest-cases. Analyze delayed pragmas Depends and Global.\n+\t* sem_ch6.adb (Check_Subprogram_Contract): Use the correct\n+\tattribute to check for pre- and post-conditions, as well as\n+\tcontract-cases and test-cases.\t(List_Inherited_Pre_Post_Aspects):\n+\tCorrect the traversal of pre- and post- conditions.\n+\t(Process_Contract_Cases): Update the comment on usage. Correct\n+\tthe traversal of contract-cases.\n+\t(Process_Post_Conditions): Update the comment on usage. Correct the\n+\ttraversal of pre- and post-conditions.\n+\t(Process_PPCs): Correct the traversal of pre- and post-conditions.\n+\t(Spec_Postconditions): Use the correct\n+\tattribute to check for pre- and post- conditions, as well as\n+\tcontract-cases and test-cases.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Reimplement the\n+\tactions related to aspects Depends and Global. Code refactoring\n+\tfor pre- and post-conditions.\n+\t(Insert_Delayed_Pragma): New routine.\n+\t* sem_prag.adb (Add_Item): New routine.\n+\t(Analyze_Depends_In_Decl_Part): New routine.\n+\t(Analyze_Global_In_Decl_Part): New routine.\n+\t(Analyze_Pragma): Reimplement the actions related to aspects Depends and\n+\tGlobal. Verify that a body acts as a spec for pragma Contract_Cases.\n+\t(Chain_PPC): Use Add_Contract_Item to chain a pragma.\n+\t(Chain_CTC): Correct the traversal of contract-\n+\tand test-cases. Use Add_Contract_Item to chain a pragma.\n+\t(Chain_Contract_Cases): Correct the traversal of contract-\n+\tand test-cases. Use Add_Contract_Item to chain a pragma.\n+\t(Check_Precondition_Postcondition): Update the comment on usage.\n+\t(Check_Test_Case): Update the comment on usage.\n+\t* sem_prag.ads (Analyze_Depends_In_Decl_Part): New routine.\n+\t(Analyze_Global_In_Decl_Part): New routine.\n+\t* sem_util.ads, sem_util.adb (Add_Contract_Item): New routine.\n+\t* sinfo.adb (Classifications): New routine.\n+\t(Contract_Test_Cases): New routine.\n+\t(Pre_Post_Conditions): New routine.\n+\t(Set_Classifications): New routine.\n+\t(Set_Contract_Test_Cases): New routine.\n+\t(Set_Pre_Post_Conditions): New routine.\n+\t(Set_Spec_CTC_List): Removed.\n+\t(Set_Spec_PPC_List): Removed.\n+\t(Spec_CTC_List): Removed.\n+\t(Spec_PPC_List): Removed.\n+\t* sinfo.ads: Update the structure of N_Contruct along with all\n+\trelated comments.\n+\t(Classifications): New routine and pragma Inline.\n+\t(Contract_Test_Cases): New routine and pragma Inline.\n+\t(Pre_Post_Conditions): New routine and pragma Inline.\n+\t(Set_Classifications): New routine and pragma Inline.\n+\t(Set_Contract_Test_Cases): New routine and pragma Inline.\n+\t(Set_Pre_Post_Conditions): New routine and pragma Inline.\n+\t(Set_Spec_CTC_List): Removed.\n+\t(Set_Spec_PPC_List): Removed.\n+\t(Spec_CTC_List): Removed.\n+\t(Spec_PPC_List): Removed.\n+\n+2013-04-23  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c (GNAT$STOP) [VMS]: Bump sigargs[0] count by 2\n+\tto account for LIB$STOP not having the chance to add the PC and\n+\tPSL fields.\n+\n 2013-04-23  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch13.adb: Minor code reorganization (remove some redundant"}, {"sha": "d6525b2912cf6dc24c5638805f00d256bf1843e1", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -568,9 +568,21 @@ package body Exp_Ch13 is\n                   declare\n                      Prag : Node_Id;\n                   begin\n-                     Prag := Spec_PPC_List (Contract (E));\n+                     Prag := Pre_Post_Conditions (Contract (E));\n                      while Present (Prag) loop\n                         Analyze_PPC_In_Decl_Part (Prag, E);\n+\n+                        Prag := Next_Pragma (Prag);\n+                     end loop;\n+\n+                     Prag := Classifications (Contract (E));\n+                     while Present (Prag) loop\n+                        if Pragma_Name (Prag) = Name_Depends then\n+                           Analyze_Depends_In_Decl_Part (Prag);\n+                        else\n+                           Analyze_Global_In_Decl_Part (Prag);\n+                        end if;\n+\n                         Prag := Next_Pragma (Prag);\n                      end loop;\n                   end;"}, {"sha": "84b50ac9d86cbf1af463ac46a97c015c47023b48", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -1925,7 +1925,7 @@ package body Exp_Ch9 is\n          P : Node_Id;\n \n       begin\n-         P := Spec_PPC_List (Contract (E));\n+         P := Pre_Post_Conditions (Contract (E));\n          if No (P) then\n             return;\n          end if;\n@@ -11840,7 +11840,7 @@ package body Exp_Ch9 is\n          Ent := First_Entity (Tasktyp);\n          while Present (Ent) loop\n             if Ekind_In (Ent, E_Entry, E_Entry_Family)\n-              and then Present (Spec_PPC_List (Contract (Ent)))\n+              and then Present (Pre_Post_Conditions (Contract (Ent)))\n             then\n                Build_PPC_Wrapper (Ent, N);\n             end if;"}, {"sha": "d4f46fa58c03d0ad2c8589ae6bf4ea400bf2b5c7", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -3119,11 +3119,11 @@ package body Freeze is\n                if Is_Subprogram (E)\n                  and then Is_Imported (E)\n                  and then Present (Contract (E))\n-                 and then Present (Spec_PPC_List (Contract (E)))\n+                 and then Present (Pre_Post_Conditions (Contract (E)))\n                then\n                   Error_Msg_NE\n-                    (\"pre/post conditions on imported subprogram \"\n-                     & \"are not enforced??\", E, Spec_PPC_List (Contract (E)));\n+                    (\"pre/post conditions on imported subprogram are not \"\n+                     & \"enforced??\", E, Pre_Post_Conditions (Contract (E)));\n                end if;\n \n             end if;"}, {"sha": "1b2e188ab515c82501ed75109c431ddd9c1ed765", "filename": "gcc/ada/init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -1297,7 +1297,10 @@ void\n GNAT$STOP (int *sigargs)\n {\n    /* Note that there are no mechargs. We rely on the fact that condtions\n-      raised from DEClib I/O do not require an \"adjust\".  */\n+      raised from DEClib I/O do not require an \"adjust\".  Also the count\n+      will be off by 2, since LIB$STOP didn't get a chance to add the\n+      PC and PSL fields, so we bump it so PUTMSG comes out right.  */\n+   sigargs [0] += 2;\n    __gnat_handle_vms_condition (sigargs, 0);\n }\n #endif"}, {"sha": "b91dd895b19fcc0d71342234b90a918f08c58dde", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -925,6 +925,57 @@ package body Sem_Ch13 is\n    -----------------------------------\n \n    procedure Analyze_Aspect_Specifications (N : Node_Id; E : Entity_Id) is\n+      procedure Insert_Delayed_Pragma (Prag : Node_Id);\n+      --  Insert a postcondition-like pragma into the tree depending on the\n+      --  context. Prag one of the following: Pre, Post, Depends or Global.\n+\n+      ---------------------------\n+      -- Insert_Delayed_Pragma --\n+      ---------------------------\n+\n+      procedure Insert_Delayed_Pragma (Prag : Node_Id) is\n+         Aux : Node_Id;\n+\n+      begin\n+         --  When the context is a library unit, the pragma is added to the\n+         --  Pragmas_After list.\n+\n+         if Nkind (Parent (N)) = N_Compilation_Unit then\n+            Aux := Aux_Decls_Node (Parent (N));\n+\n+            if No (Pragmas_After (Aux)) then\n+               Set_Pragmas_After (Aux, New_List);\n+            end if;\n+\n+            Prepend (Prag, Pragmas_After (Aux));\n+\n+         --  Pragmas associated with subprogram bodies are inserted in the\n+         --  declarative part.\n+\n+         elsif Nkind (N) = N_Subprogram_Body then\n+            if No (Declarations (N)) then\n+               Set_Declarations (N, New_List);\n+            end if;\n+\n+            Append (Prag, Declarations (N));\n+\n+         --  Default\n+\n+         else\n+            Insert_After (N, Prag);\n+\n+            --  Analyze the pragma before analyzing the proper body of a stub.\n+            --  This ensures that the pragma will appear on the proper contract\n+            --  list (see N_Contract).\n+\n+            if Nkind (N) = N_Subprogram_Body_Stub then\n+               Analyze (Prag);\n+            end if;\n+         end if;\n+      end Insert_Delayed_Pragma;\n+\n+      --  Local variables\n+\n       Aspect : Node_Id;\n       Aitem  : Node_Id;\n       Ent    : Node_Id;\n@@ -1535,6 +1586,8 @@ package body Sem_Ch13 is\n \n                --  Aspect Depends must be delayed because it mentions names\n                --  of inputs and output that are classified by aspect Global.\n+               --  The aspect and pragma are treated the same way as a post\n+               --  condition.\n \n                when Aspect_Depends =>\n                   Make_Aitem_Pragma\n@@ -1543,11 +1596,24 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Depends);\n \n+                  --  Decorate the aspect and pragma\n+\n+                  Set_Aspect_Rep_Item           (Aspect, Aitem);\n+                  Set_Corresponding_Aspect      (Aitem, Aspect);\n+                  Set_From_Aspect_Specification (Aitem);\n+                  Set_Is_Delayed_Aspect         (Aitem);\n+                  Set_Is_Delayed_Aspect         (Aspect);\n+                  Set_Parent                    (Aitem, Aspect);\n+\n+                  Insert_Delayed_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Global\n \n                --  Aspect Global must be delayed because it can mention names\n                --  and benefit from the forward visibility rules applicable to\n-               --  aspects of subprograms.\n+               --  aspects of subprograms. The aspect and pragma are treated\n+               --  the same way as a post condition.\n \n                when Aspect_Global =>\n                   Make_Aitem_Pragma\n@@ -1556,6 +1622,18 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Global);\n \n+                  --  Decorate the aspect and pragma\n+\n+                  Set_Aspect_Rep_Item           (Aspect, Aitem);\n+                  Set_Corresponding_Aspect      (Aitem, Aspect);\n+                  Set_From_Aspect_Specification (Aitem);\n+                  Set_Is_Delayed_Aspect         (Aitem);\n+                  Set_Is_Delayed_Aspect         (Aspect);\n+                  Set_Parent                    (Aitem, Aspect);\n+\n+                  Insert_Delayed_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Relative_Deadline\n \n                when Aspect_Relative_Deadline =>\n@@ -1727,46 +1805,7 @@ package body Sem_Ch13 is\n                   --  about delay issues, since the pragmas themselves deal\n                   --  with delay of visibility for the expression analysis.\n \n-                  --  If the entity is a library-level subprogram, the pre/\n-                  --  postconditions must be treated as late pragmas. Note\n-                  --  that they must be prepended, not appended, to the list,\n-                  --  so that split AND THEN sections are processed in the\n-                  --  correct order.\n-\n-                  if Nkind (Parent (N)) = N_Compilation_Unit then\n-                     declare\n-                        Aux : constant Node_Id := Aux_Decls_Node (Parent (N));\n-\n-                     begin\n-                        if No (Pragmas_After (Aux)) then\n-                           Set_Pragmas_After (Aux, New_List);\n-                        end if;\n-\n-                        Prepend (Aitem, Pragmas_After (Aux));\n-                     end;\n-\n-                  --  If it is a subprogram body, add pragmas to list of\n-                  --  declarations in body.\n-\n-                  elsif Nkind (N) = N_Subprogram_Body then\n-                     if No (Declarations (N)) then\n-                        Set_Declarations (N, New_List);\n-                     end if;\n-\n-                     Append (Aitem, Declarations (N));\n-\n-                  else\n-                     Insert_After (N, Aitem);\n-\n-                     --  Pre/Postconditions on stubs are analyzed at once,\n-                     --  because the proper body is analyzed next, and the\n-                     --  contract must be captured before the body.\n-\n-                     if Nkind (N) = N_Subprogram_Body_Stub then\n-                        Analyze (Aitem);\n-                     end if;\n-                  end if;\n-\n+                  Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n                end;\n "}, {"sha": "e09facd6b06bcb5489f9cfa4462bebf077a1ab03", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -2202,20 +2202,33 @@ package body Sem_Ch3 is\n \n                --  Analyze preconditions and postconditions\n \n-               Prag := Spec_PPC_List (Contract (Sent));\n+               Prag := Pre_Post_Conditions (Contract (Sent));\n                while Present (Prag) loop\n                   Analyze_PPC_In_Decl_Part (Prag, Sent);\n                   Prag := Next_Pragma (Prag);\n                end loop;\n \n                --  Analyze contract-cases and test-cases\n \n-               Prag := Spec_CTC_List (Contract (Sent));\n+               Prag := Contract_Test_Cases (Contract (Sent));\n                while Present (Prag) loop\n                   Analyze_CTC_In_Decl_Part (Prag, Sent);\n                   Prag := Next_Pragma (Prag);\n                end loop;\n \n+               --  Analyze classification pragmas\n+\n+               Prag := Classifications (Contract (Sent));\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Depends then\n+                     Analyze_Depends_In_Decl_Part (Prag);\n+                  else\n+                     Analyze_Global_In_Decl_Part (Prag);\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+\n                --  At this point, entities have been attached to identifiers.\n                --  This is required to be able to detect suspicious contracts.\n "}, {"sha": "42c9fb2c11568266b9e9361e53205b2b00500954", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -7091,15 +7091,15 @@ package body Sem_Ch6 is\n       --  not considered as trivial.\n \n       procedure Process_Contract_Cases (Spec : Node_Id);\n-      --  This processes the Spec_CTC_List from Spec, processing any contract\n-      --  case from the list. The caller has checked that Spec_CTC_List is\n-      --  non-Empty.\n+      --  This processes the Contract_Test_Cases from Spec, processing any\n+      --  contract case from the list. The caller has checked that list\n+      --  Contract_Test_Cases is non-Empty.\n \n       procedure Process_Post_Conditions (Spec : Node_Id; Class : Boolean);\n-      --  This processes the Spec_PPC_List from Spec, processing any\n+      --  This processes the Pre_Post_Conditions from Spec, processing any\n       --  postcondition from the list. If Class is True, then only\n       --  postconditions marked with Class_Present are considered. The\n-      --  caller has checked that Spec_PPC_List is non-Empty.\n+      --  caller has checked that Pre_Post_Conditions is non-Empty.\n \n       function Find_Attribute_Result is new Traverse_Func (Check_Attr_Result);\n \n@@ -7207,7 +7207,7 @@ package body Sem_Ch6 is\n          pragma Unreferenced (Ignored);\n \n       begin\n-         Prag := Spec_CTC_List (Contract (Spec));\n+         Prag := Contract_Test_Cases (Contract (Spec));\n          loop\n             if Pragma_Name (Prag) = Name_Contract_Cases then\n                Aggr :=\n@@ -7269,7 +7269,7 @@ package body Sem_Ch6 is\n          pragma Unreferenced (Ignored);\n \n       begin\n-         Prag := Spec_PPC_List (Contract (Spec));\n+         Prag := Pre_Post_Conditions (Contract (Spec));\n          loop\n             Arg := First (Pragma_Argument_Associations (Prag));\n \n@@ -7322,7 +7322,7 @@ package body Sem_Ch6 is\n \n       --  Process spec postconditions\n \n-      if Present (Spec_PPC_List (Contract (Spec_Id))) then\n+      if Present (Pre_Post_Conditions (Contract (Spec_Id))) then\n          Process_Post_Conditions (Spec_Id, Class => False);\n       end if;\n \n@@ -7333,14 +7333,14 @@ package body Sem_Ch6 is\n       --  type. This may cause more warnings to be issued than necessary. ???\n \n --        for J in Inherited'Range loop\n---           if Present (Spec_PPC_List (Contract (Inherited (J)))) then\n+--           if Present (Pre_Post_Conditions (Contract (Inherited (J)))) then\n --              Process_Post_Conditions (Inherited (J), Class => True);\n --           end if;\n --        end loop;\n \n       --  Process contract cases\n \n-      if Present (Spec_CTC_List (Contract (Spec_Id))) then\n+      if Present (Contract_Test_Cases (Contract (Spec_Id))) then\n          Process_Contract_Cases (Spec_Id);\n       end if;\n \n@@ -9446,7 +9446,7 @@ package body Sem_Ch6 is\n \n          begin\n             for J in Inherited'Range loop\n-               P := Spec_PPC_List (Contract (Inherited (J)));\n+               P := Pre_Post_Conditions (Contract (Inherited (J)));\n                while Present (P) loop\n                   Error_Msg_Sloc := Sloc (P);\n \n@@ -12033,7 +12033,7 @@ package body Sem_Ch6 is\n          --  the body will be analyzed and converted when we scan the body\n          --  declarations below.\n \n-         Prag := Spec_PPC_List (Contract (Spec_Id));\n+         Prag := Pre_Post_Conditions (Contract (Spec_Id));\n          while Present (Prag) loop\n             if Pragma_Name (Prag) = Name_Precondition then\n \n@@ -12062,7 +12062,7 @@ package body Sem_Ch6 is\n          --  Now deal with inherited preconditions\n \n          for J in Inherited'Range loop\n-            Prag := Spec_PPC_List (Contract (Inherited (J)));\n+            Prag := Pre_Post_Conditions (Contract (Inherited (J)));\n \n             while Present (Prag) loop\n                if Pragma_Name (Prag) = Name_Precondition\n@@ -12210,17 +12210,17 @@ package body Sem_Ch6 is\n       if Present (Spec_Id) then\n          Spec_Postconditions : declare\n             procedure Process_Contract_Cases (Spec : Node_Id);\n-            --  This processes the Spec_CTC_List from Spec, processing any\n-            --  contract-cases from the list. The caller has checked that\n-            --  Spec_CTC_List is non-Empty.\n+            --  This processes the Contract_Test_Cases from Spec, processing\n+            --  any contract-cases from the list. The caller has checked that\n+            --  Contract_Test_Cases is non-Empty.\n \n             procedure Process_Post_Conditions\n               (Spec  : Node_Id;\n                Class : Boolean);\n-            --  This processes the Spec_PPC_List from Spec, processing any\n-            --  postconditions from the list. If Class is True, then only\n-            --  postconditions marked with Class_Present are considered.\n-            --  The caller has checked that Spec_PPC_List is non-Empty.\n+            --  This processes the Pre_Post_Conditions from Spec, processing\n+            --  any postconditions from the list. If Class is True, then only\n+            --  postconditions marked with Class_Present are considered. The\n+            --  caller has checked that Pre_Post_Conditions is non-Empty.\n \n             ----------------------------\n             -- Process_Contract_Cases --\n@@ -12230,7 +12230,7 @@ package body Sem_Ch6 is\n             begin\n                --  Loop through Contract_Cases pragmas from spec\n \n-               Prag := Spec_CTC_List (Contract (Spec));\n+               Prag := Contract_Test_Cases (Contract (Spec));\n                loop\n                   if Pragma_Name (Prag) = Name_Contract_Cases then\n                      Expand_Contract_Cases (Prag, Spec_Id);\n@@ -12260,7 +12260,7 @@ package body Sem_Ch6 is\n \n                --  Loop through PPC pragmas from spec\n \n-               Prag := Spec_PPC_List (Contract (Spec));\n+               Prag := Pre_Post_Conditions (Contract (Spec));\n                loop\n                   if Pragma_Name (Prag) = Name_Postcondition\n                     and then (not Class or else Class_Present (Prag))\n@@ -12286,20 +12286,20 @@ package body Sem_Ch6 is\n          begin\n             --  Process postconditions expressed as contract-cases\n \n-            if Present (Spec_CTC_List (Contract (Spec_Id))) then\n+            if Present (Contract_Test_Cases (Contract (Spec_Id))) then\n                Process_Contract_Cases (Spec_Id);\n             end if;\n \n             --  Process spec postconditions\n \n-            if Present (Spec_PPC_List (Contract (Spec_Id))) then\n+            if Present (Pre_Post_Conditions (Contract (Spec_Id))) then\n                Process_Post_Conditions (Spec_Id, Class => False);\n             end if;\n \n             --  Process inherited postconditions\n \n             for J in Inherited'Range loop\n-               if Present (Spec_PPC_List (Contract (Inherited (J)))) then\n+               if Present (Pre_Post_Conditions (Contract (Inherited (J)))) then\n                   Process_Post_Conditions (Inherited (J), Class => True);\n                end if;\n             end loop;"}, {"sha": "a29f52667fb5d442731c4aa4c7b09a385da89acd", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8095, "deletions": 8043, "changes": 16138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d60951532b3f2386bd659afc0264e797710360c1"}, {"sha": "5bf118a3867dd97326b6d87f68319de6bb280430", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -46,6 +46,12 @@ package Sem_Prag is\n    --  expressions in the pragma as \"spec expressions\" (see section in Sem\n    --  \"Handling of Default and Per-Object Expressions...\").\n \n+   procedure Analyze_Depends_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Depends\n+\n+   procedure Analyze_Global_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Global\n+\n    procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n    --  Special analyze routine for precondition/postcondition pragma that\n    --  appears within a declarative part where the pragma is associated"}, {"sha": "51c63debc614bb0ed4a07092482264961373cf4c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -208,6 +208,43 @@ package body Sem_Util is\n       Append_Elmt (A, L);\n    end Add_Access_Type_To_Process;\n \n+   -----------------------\n+   -- Add_Contract_Item --\n+   -----------------------\n+\n+   procedure Add_Contract_Item (Item : Node_Id; Subp_Id : Entity_Id) is\n+      Items : constant Node_Id := Contract (Subp_Id);\n+      Nam   : Name_Id;\n+\n+   begin\n+      if Present (Items) and then Nkind (Item) = N_Pragma then\n+         Nam := Pragma_Name (Item);\n+\n+         if Nam_In (Nam, Name_Precondition, Name_Postcondition) then\n+            Set_Next_Pragma (Item, Pre_Post_Conditions (Items));\n+            Set_Pre_Post_Conditions (Items, Item);\n+\n+         elsif Nam_In (Nam, Name_Contract_Cases, Name_Test_Case) then\n+            Set_Next_Pragma (Item, Contract_Test_Cases (Items));\n+            Set_Contract_Test_Cases (Items, Item);\n+\n+         elsif Nam_In (Nam, Name_Depends, Name_Global) then\n+            Set_Next_Pragma (Item, Classifications (Items));\n+            Set_Classifications (Items, Item);\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  The subprogram has not been properly decorated or the item is illegal\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+   end Add_Contract_Item;\n+\n    ----------------------------\n    -- Add_Global_Declaration --\n    ----------------------------"}, {"sha": "66c31c9f0912fee4313867e971a84c3f4dd56641", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -43,6 +43,11 @@ package Sem_Util is\n    --  Add A to the list of access types to process when expanding the\n    --  freeze node of E.\n \n+   procedure Add_Contract_Item (Item : Node_Id; Subp_Id : Entity_Id);\n+   --  Add a contract item (pragma Precondition, Postcondition, Test_Case,\n+   --  Contract_Cases, Global, Depends) to the contract of a subprogram. Item\n+   --  denotes a pragma and Subp_Id is the related subprogram.\n+\n    procedure Add_Global_Declaration (N : Node_Id);\n    --  These procedures adds a declaration N at the library level, to be\n    --  elaborated before any other code in the unit. It is used for example"}, {"sha": "c8eab8a9536aea4414772e64bb771fb4e1c0a440", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -423,6 +423,14 @@ package body Sinfo is\n       return Flag6 (N);\n    end Class_Present;\n \n+   function Classifications\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      return Node3 (N);\n+   end Classifications;\n+\n    function Comes_From_Extended_Return_Statement\n      (N : Node_Id) return Boolean is\n    begin\n@@ -585,6 +593,14 @@ package body Sinfo is\n       return Flag16 (N);\n    end Context_Pending;\n \n+   function Contract_Test_Cases\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      return Node2 (N);\n+   end Contract_Test_Cases;\n+\n    function Controlling_Argument\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2494,6 +2510,14 @@ package body Sinfo is\n       return List4 (N);\n    end Pragmas_Before;\n \n+   function Pre_Post_Conditions\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      return Node1 (N);\n+   end Pre_Post_Conditions;\n+\n    function Prefix\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2832,22 +2856,6 @@ package body Sinfo is\n       return Node1 (N);\n    end Source_Type;\n \n-   function Spec_PPC_List\n-      (N : Node_Id) return Node_Id is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Contract);\n-      return Node1 (N);\n-   end Spec_PPC_List;\n-\n-   function Spec_CTC_List\n-      (N : Node_Id) return Node_Id is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Contract);\n-      return Node2 (N);\n-   end Spec_CTC_List;\n-\n    function Specification\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -3532,8 +3540,16 @@ package body Sinfo is\n       Set_Flag6 (N, Val);\n    end Set_Class_Present;\n \n+   procedure Set_Classifications\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      Set_Node3 (N, Val); -- semantic field, no parent set\n+   end Set_Classifications;\n+\n    procedure Set_Comes_From_Extended_Return_Statement\n-     (N : Node_Id; Val : Boolean := True) is\n+      (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Simple_Return_Statement);\n@@ -3694,6 +3710,14 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Context_Pending;\n \n+   procedure Set_Contract_Test_Cases\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      Set_Node2 (N, Val); -- semantic field, no parent set\n+   end Set_Contract_Test_Cases;\n+\n    procedure Set_Controlling_Argument\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -5594,6 +5618,14 @@ package body Sinfo is\n       Set_List4_With_Parent (N, Val);\n    end Set_Pragmas_Before;\n \n+   procedure Set_Pre_Post_Conditions\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      Set_Node1 (N, Val); -- semantic field, no parent set\n+   end Set_Pre_Post_Conditions;\n+\n    procedure Set_Prefix\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -5932,22 +5964,6 @@ package body Sinfo is\n       Set_Node1 (N, Val); -- semantic field, no parent set\n    end Set_Source_Type;\n \n-   procedure Set_Spec_PPC_List\n-      (N : Node_Id; Val : Node_Id) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Contract);\n-      Set_Node1 (N, Val); -- semantic field, no parent set\n-   end Set_Spec_PPC_List;\n-\n-   procedure Set_Spec_CTC_List\n-      (N : Node_Id; Val : Node_Id) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Contract);\n-      Set_Node2 (N, Val); -- semantic field, no parent set\n-   end Set_Spec_CTC_List;\n-\n    procedure Set_Specification\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "5529bd53855adef133342cd5218cf264c9646155", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60951532b3f2386bd659afc0264e797710360c1/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d60951532b3f2386bd659afc0264e797710360c1", "patch": "@@ -7038,22 +7038,23 @@ package Sinfo is\n \n       --  N_Contract\n       --  Sloc points to the subprogram's name\n-      --  Spec_PPC_List (Node1) (set to Empty if none)\n-      --  Spec_CTC_List (Node2) (set to Empty if none)\n-\n-      --  Spec_PPC_List points to a list of Precondition and Postcondition\n-      --  pragma nodes for preconditions and postconditions declared in the\n-      --  spec of the entry/subprogram. The last pragma encountered is at the\n-      --  head of this list, so it is in reverse order of textual appearance.\n-      --  Note that this includes precondition/postcondition pragmas generated\n-      --  to correspond to Pre/Post aspects.\n-\n-      --  Spec_CTC_List points to a list of Contract_Cases and Test_Case pragma\n-      --  nodes for contract-cases and test-cases declared in the spec of the\n-      --  entry/subprogram. The last pragma encountered is at the head of this\n-      --  list, so it is in reverse order of textual appearance. Note that\n-      --  this includes contract-cases and test-case pragmas generated from\n-      --  Contract_Cases and Test_Case aspects.\n+      --  Pre_Post_Conditions (Node1) (set to Empty if none)\n+      --  Contract_Test_Cases (Node2) (set to Empty if none)\n+      --  Classifications (Node3) (set to Empty if none)\n+\n+      --  Pre_Post_Conditions contains a collection of pragmas that correspond\n+      --  to pre- and post-conditions associated with an entry or a subprogram.\n+      --  The pragmas can either come from source or be the byproduct of aspect\n+      --  expansion. The ordering in the list is of LIFO fasion.\n+\n+      --  Contract_Test_Cases contains a collection of pragmas that correspond\n+      --  to aspects/pragmas Contract_Cases and Test_Case. The ordering in the\n+      --  list is of LIFO fasion.\n+\n+      --  Classifications contains pragmas that either categorize subprogram\n+      --  inputs and outputs or establish dependencies between them. Currently\n+      --  pragmas Depends and Global are stored in this list. The ordering is\n+      --  of LIFO fasion.\n \n       -------------------\n       -- Expanded_Name --\n@@ -8306,6 +8307,9 @@ package Sinfo is\n    function Class_Present\n      (N : Node_Id) return Boolean;    -- Flag6\n \n+   function Classifications\n+     (N : Node_Id) return Node_Id;    -- Node3\n+\n    function Comes_From_Extended_Return_Statement\n      (N : Node_Id) return Boolean;    -- Flag18\n \n@@ -8360,6 +8364,9 @@ package Sinfo is\n    function Context_Items\n      (N : Node_Id) return List_Id;    -- List1\n \n+   function Contract_Test_Cases\n+     (N : Node_Id) return Node_Id;    -- Node2\n+\n    function Controlling_Argument\n      (N : Node_Id) return Node_Id;    -- Node1\n \n@@ -8954,6 +8961,9 @@ package Sinfo is\n    function Pragmas_Before\n      (N : Node_Id) return List_Id;    -- List4\n \n+   function Pre_Post_Conditions\n+     (N : Node_Id) return Node_Id;    -- Node1\n+\n    function Prefix\n      (N : Node_Id) return Node_Id;    -- Node3\n \n@@ -9062,12 +9072,6 @@ package Sinfo is\n    function Source_Type\n      (N : Node_Id) return Entity_Id;  -- Node1\n \n-   function Spec_PPC_List\n-     (N : Node_Id) return Node_Id;    -- Node1\n-\n-   function Spec_CTC_List\n-     (N : Node_Id) return Node_Id;    -- Node2\n-\n    function Specification\n      (N : Node_Id) return Node_Id;    -- Node1\n \n@@ -9296,6 +9300,9 @@ package Sinfo is\n    procedure Set_Class_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n+   procedure Set_Classifications\n+     (N : Node_Id; Val : Node_Id);            -- Node3\n+\n    procedure Set_Comes_From_Extended_Return_Statement\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -9350,6 +9357,9 @@ package Sinfo is\n    procedure Set_Context_Pending\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n+   procedure Set_Contract_Test_Cases\n+     (N : Node_Id; Val : Node_Id);            -- Node2\n+\n    procedure Set_Controlling_Argument\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n@@ -9941,6 +9951,9 @@ package Sinfo is\n    procedure Set_Pragmas_Before\n      (N : Node_Id; Val : List_Id);            -- List4\n \n+   procedure Set_Pre_Post_Conditions\n+     (N : Node_Id; Val : Node_Id);            -- Node1\n+\n    procedure Set_Prefix\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n@@ -10049,12 +10062,6 @@ package Sinfo is\n    procedure Set_Source_Type\n      (N : Node_Id; Val : Entity_Id);          -- Node1\n \n-   procedure Set_Spec_PPC_List\n-     (N : Node_Id; Val : Node_Id);            -- Node1\n-\n-   procedure Set_Spec_CTC_List\n-     (N : Node_Id; Val : Node_Id);            -- Node2\n-\n    procedure Set_Specification\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n@@ -11701,9 +11708,9 @@ package Sinfo is\n         5 => False),  --  Etype (Node5-Sem)\n \n      N_Contract =>\n-       (1 => False,   --  Spec_PPC_List (Node1)\n-        2 => False,   --  Spec_CTC_List (Node2)\n-        3 => False,   --  unused\n+       (1 => False,   --  Pre_Post_Conditions (Node1)\n+        2 => False,   --  Contract_Test_Cases (Node2)\n+        3 => False,   --  Classifications (Node3)\n         4 => False,   --  unused\n         5 => False),  --  unused\n \n@@ -11946,6 +11953,7 @@ package Sinfo is\n    pragma Inline (Choice_Parameter);\n    pragma Inline (Choices);\n    pragma Inline (Class_Present);\n+   pragma Inline (Classifications);\n    pragma Inline (Comes_From_Extended_Return_Statement);\n    pragma Inline (Compile_Time_Known_Aggregate);\n    pragma Inline (Component_Associations);\n@@ -11964,6 +11972,7 @@ package Sinfo is\n    pragma Inline (Context_Installed);\n    pragma Inline (Context_Items);\n    pragma Inline (Context_Pending);\n+   pragma Inline (Contract_Test_Cases);\n    pragma Inline (Controlling_Argument);\n    pragma Inline (Convert_To_Return_False);\n    pragma Inline (Conversion_OK);\n@@ -12162,6 +12171,7 @@ package Sinfo is\n    pragma Inline (Pragma_Identifier);\n    pragma Inline (Pragmas_After);\n    pragma Inline (Pragmas_Before);\n+   pragma Inline (Pre_Post_Conditions);\n    pragma Inline (Prefix);\n    pragma Inline (Premature_Use);\n    pragma Inline (Present_Expr);\n@@ -12198,8 +12208,6 @@ package Sinfo is\n    pragma Inline (Selector_Names);\n    pragma Inline (Shift_Count_OK);\n    pragma Inline (Source_Type);\n-   pragma Inline (Spec_PPC_List);\n-   pragma Inline (Spec_CTC_List);\n    pragma Inline (Specification);\n    pragma Inline (Split_PPC);\n    pragma Inline (Statements);\n@@ -12273,6 +12281,7 @@ package Sinfo is\n    pragma Inline (Set_Choice_Parameter);\n    pragma Inline (Set_Choices);\n    pragma Inline (Set_Class_Present);\n+   pragma Inline (Set_Classifications);\n    pragma Inline (Set_Comes_From_Extended_Return_Statement);\n    pragma Inline (Set_Compile_Time_Known_Aggregate);\n    pragma Inline (Set_Component_Associations);\n@@ -12291,6 +12300,7 @@ package Sinfo is\n    pragma Inline (Set_Context_Installed);\n    pragma Inline (Set_Context_Items);\n    pragma Inline (Set_Context_Pending);\n+   pragma Inline (Set_Contract_Test_Cases);\n    pragma Inline (Set_Controlling_Argument);\n    pragma Inline (Set_Conversion_OK);\n    pragma Inline (Set_Convert_To_Return_False);\n@@ -12487,6 +12497,7 @@ package Sinfo is\n    pragma Inline (Set_Pragma_Identifier);\n    pragma Inline (Set_Pragmas_After);\n    pragma Inline (Set_Pragmas_Before);\n+   pragma Inline (Set_Pre_Post_Conditions);\n    pragma Inline (Set_Prefix);\n    pragma Inline (Set_Premature_Use);\n    pragma Inline (Set_Present_Expr);\n@@ -12522,9 +12533,6 @@ package Sinfo is\n    pragma Inline (Set_Selector_Names);\n    pragma Inline (Set_Shift_Count_OK);\n    pragma Inline (Set_Source_Type);\n-   pragma Inline (Set_Spec_CTC_List);\n-   pragma Inline (Set_Spec_PPC_List);\n-   pragma Inline (Set_Specification);\n    pragma Inline (Set_Split_PPC);\n    pragma Inline (Set_Statements);\n    pragma Inline (Set_Storage_Pool);"}]}