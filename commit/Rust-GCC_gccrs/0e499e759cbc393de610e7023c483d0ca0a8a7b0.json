{"sha": "0e499e759cbc393de610e7023c483d0ca0a8a7b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU0OTllNzU5Y2JjMzkzZGU2MTBlNzAyM2M0ODNkMGNhMGE4YTdiMA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2013-10-16T01:43:14Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2013-10-16T01:43:14Z"}, "message": "For CRIS ports, switch to soft-fp.  Improve arit.c and longlong.h.\n\n\t* config.host (cpu_type) <Setting default>: Add entry for\n\tcrisv32-*-*.\n\t(tmake_file) <crisv32-*-elf, cris-*-elf, cris-*-linux*>\n\t<crisv32-*-linux*>: Adjust.\n\t* longlong.h: Wrap the whole CRIS section in a single\n\tdefined(__CRIS__) conditional.  Add comment about add_ssaaaa\n\tand sub_ddmmss.\n\t(COUNT_LEADING_ZEROS_0): Define when count_leading_zeros is\n\tdefined.\n\t[__CRIS__] (__umulsidi3): Define.\n\t[__CRIS__] (umul_ppmm): Define in terms of __umulsidi3.\n\t* config/cris/sfp-machine.h: New file.\n\t* config/cris/umulsidi3.S: New file.\n\t* config/cris/t-elfmulti (LIB2ADD_ST): Add umulsidi3.S.\n\t* config/cris/arit.c (SIGNMULT): New macro.\n\t(__Div, __Mod): Use SIGNMULT instead of naked multiplication.\n\t* config/cris/mulsi3.S: Tweak to avoid redundant register-copying;\n\tsaving 3 out of originally 33 cycles from the fastest\n\tpath, 3 out of 54 from the medium path and one from the longest\n\tpath.  Improve comments.\n\nFrom-SVN: r203640", "tree": {"sha": "c5d3a341da560ba98e56324e917e4ecf6c089531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5d3a341da560ba98e56324e917e4ecf6c089531"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e499e759cbc393de610e7023c483d0ca0a8a7b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e499e759cbc393de610e7023c483d0ca0a8a7b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e499e759cbc393de610e7023c483d0ca0a8a7b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e499e759cbc393de610e7023c483d0ca0a8a7b0/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b82d0df95b6592adfb3f8c4872fdad41c513e7c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82d0df95b6592adfb3f8c4872fdad41c513e7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82d0df95b6592adfb3f8c4872fdad41c513e7c5"}], "stats": {"total": 533, "additions": 489, "deletions": 44}, "files": [{"sha": "c40b6a5be63db49b1b36029f5639b89ea082996f", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -1,3 +1,27 @@\n+2013-10-16  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tFor CRIS ports, switch to soft-fp.  Improve arit.c and longlong.h.\n+\t* config.host (cpu_type) <Setting default>: Add entry for\n+\tcrisv32-*-*.\n+\t(tmake_file) <crisv32-*-elf, cris-*-elf, cris-*-linux*>\n+\t<crisv32-*-linux*>: Adjust.\n+\t* longlong.h: Wrap the whole CRIS section in a single\n+\tdefined(__CRIS__) conditional.  Add comment about add_ssaaaa\n+\tand sub_ddmmss.\n+\t(COUNT_LEADING_ZEROS_0): Define when count_leading_zeros is\n+\tdefined.\n+\t[__CRIS__] (__umulsidi3): Define.\n+\t[__CRIS__] (umul_ppmm): Define in terms of __umulsidi3.\n+\t* config/cris/sfp-machine.h: New file.\n+\t* config/cris/umulsidi3.S: New file.\n+\t* config/cris/t-elfmulti (LIB2ADD_ST): Add umulsidi3.S.\n+\t* config/cris/arit.c (SIGNMULT): New macro.\n+\t(__Div, __Mod): Use SIGNMULT instead of naked multiplication.\n+\t* config/cris/mulsi3.S: Tweak to avoid redundant register-copying;\n+\tsaving 3 out of originally 33 cycles from the fastest\n+\tpath, 3 out of 54 from the medium path and one from the longest\n+\tpath.  Improve comments.\n+\n 2013-10-15  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* sync.c: Remove static aliases and define each function directly"}, {"sha": "6390273bfeffc5f6b56feac2a0a3f4da7d29b15b", "filename": "libgcc/config.host", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -105,6 +105,9 @@ bfin*-*)\n \t;;\n cr16-*-*)\n \t;;\n+crisv32-*-*)\n+\tcpu_type=cris\n+\t;;\n fido-*-*)\n \tcpu_type=m68k\n \t;;\n@@ -408,13 +411,13 @@ cr16-*-elf)\n \textra_parts=\"$extra_parts crti.o crtn.o crtlibid.o\"\n         ;;\n crisv32-*-elf)\n-\ttmake_file=\"$tmake_file cris/t-cris t-fdpbit\"\n+\ttmake_file=\"$tmake_file cris/t-cris t-softfp-sfdf t-softfp\"\n  \t;;\n cris-*-elf)\n-\ttmake_file=\"$tmake_file cris/t-cris t-fdpbit cris/t-elfmulti\"\n+\ttmake_file=\"$tmake_file cris/t-cris t-softfp-sfdf t-softfp cris/t-elfmulti\"\n \t;;\n cris-*-linux* | crisv32-*-linux*)\n-\ttmake_file=\"$tmake_file cris/t-cris t-fdpbit cris/t-linux\"\n+\ttmake_file=\"$tmake_file cris/t-cris t-softfp-sfdf t-softfp cris/t-linux\"\n \t;;\n epiphany-*-elf*)\n \ttmake_file=\"epiphany/t-epiphany t-fdpbit epiphany/t-custom-eqsf\""}, {"sha": "00ffa07a5a00af9199d30864901941b79df5ef52", "filename": "libgcc/config/cris/arit.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Farit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Farit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcris%2Farit.c?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -38,6 +38,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define LZ(v) __builtin_clz (v)\n #endif\n \n+/* In (at least) the 4.7 series, GCC doesn't automatically choose the\n+   most optimal strategy, possibly related to insufficient modelling of\n+   delay-slot costs.  */\n+#if defined (__CRIS_arch_version) && __CRIS_arch_version >= 10\n+#define SIGNMULT(s, a) ((s) * (a)) /* Cheap multiplication, better than branch.  */\n+#else\n+#define SIGNMULT(s, a) ((s) < 0 ? -(a) : (a)) /* Branches are still better.  */\n+#endif\n \n #if defined (L_udivsi3) || defined (L_divsi3) || defined (L_umodsi3) \\\n     || defined (L_modsi3)\n@@ -198,6 +206,7 @@ __Div (long a, long b)\n {\n   long extra = 0;\n   long sign = (b < 0) ? -1 : 1;\n+  long res;\n \n   /* We need to handle a == -2147483648 as expected and must while\n      doing that avoid producing a sequence like \"abs (a) < 0\" as GCC\n@@ -213,15 +222,14 @@ __Div (long a, long b)\n       if ((a & 0x7fffffff) == 0)\n \t{\n \t  /* We're at 0x80000000.  Tread carefully.  */\n-\t  a -= b * sign;\n+\t  a -= SIGNMULT (sign, b);\n \t  extra = sign;\n \t}\n       a = -a;\n     }\n \n-  /* We knowingly penalize pre-v10 models by multiplication with the\n-     sign.  */\n-  return sign * do_31div (a, __builtin_labs (b)).quot + extra;\n+  res = do_31div (a, __builtin_labs (b)).quot;\n+  return SIGNMULT (sign, res) + extra;\n }\n #endif /* L_divsi3 */\n \n@@ -273,6 +281,7 @@ long\n __Mod (long a, long b)\n {\n   long sign = 1;\n+  long res;\n \n   /* We need to handle a == -2147483648 as expected and must while\n      doing that avoid producing a sequence like \"abs (a) < 0\" as GCC\n@@ -290,7 +299,8 @@ __Mod (long a, long b)\n       a = -a;\n     }\n \n-  return sign * do_31div (a, __builtin_labs (b)).rem;\n+  res = do_31div (a, __builtin_labs (b)).rem;\n+  return SIGNMULT (sign, res);\n }\n #endif /* L_modsi3 */\n #endif /* L_udivsi3 || L_divsi3 || L_umodsi3 || L_modsi3 */"}, {"sha": "734e162b4cbd1abc4089db43dc21964c9caa40e8", "filename": "libgcc/config/cris/mulsi3.S", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Fmulsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Fmulsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcris%2Fmulsi3.S?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -113,16 +113,22 @@ ___Mul:\n \tret\n \tnop\n #else\n-\tmove.d $r10,$r12\n+;; See if we can avoid multiplying some of the parts, knowing\n+;; they're zero.\n+\n \tmove.d $r11,$r9\n-\tbound.d $r12,$r9\n+\tbound.d $r10,$r9\n \tcmpu.w 65535,$r9\n \tbls L(L3)\n-\tmove.d $r12,$r13\n+\tmove.d $r10,$r12\n \n-\tmovu.w $r11,$r9\n+;; Nope, have to do all the parts of a 32-bit multiplication.\n+;; See head comment in optabs.c:expand_doubleword_mult.\n+\n+\tmove.d $r10,$r13\n+\tmovu.w $r11,$r9 ; ab*cd = (a*d + b*c)<<16 + b*d\n \tlslq 16,$r13\n-\tmstep $r9,$r13\n+\tmstep $r9,$r13\t; d*b\n \tmstep $r9,$r13\n \tmstep $r9,$r13\n \tmstep $r9,$r13\n@@ -140,7 +146,7 @@ ___Mul:\n \tmstep $r9,$r13\n \tclear.w $r10\n \ttest.d $r10\n-\tmstep $r9,$r10\n+\tmstep $r9,$r10\t; d*a\n \tmstep $r9,$r10\n \tmstep $r9,$r10\n \tmstep $r9,$r10\n@@ -157,10 +163,9 @@ ___Mul:\n \tmstep $r9,$r10\n \tmstep $r9,$r10\n \tmovu.w $r12,$r12\n-\tmove.d $r11,$r9\n-\tclear.w $r9\n-\ttest.d $r9\n-\tmstep $r12,$r9\n+\tclear.w $r11\n+\tmove.d $r11,$r9 ; Doubles as a \"test.d\" preparing for the mstep.\n+\tmstep $r12,$r9\t; b*c\n \tmstep $r12,$r9\n \tmstep $r12,$r9\n \tmstep $r12,$r9\n@@ -182,17 +187,24 @@ ___Mul:\n \tadd.d $r13,$r10\n \n L(L3):\n-\tmove.d $r9,$r10\n+;; Form the maximum in $r10, by knowing the minimum, $r9.\n+;; (We don't know which one of $r10 or $r11 it is.)\n+;; Check if the largest operand is still just 16 bits.\n+\n+\txor $r9,$r10\n \txor $r11,$r10\n-\txor $r12,$r10\n \tcmpu.w 65535,$r10\n \tbls L(L5)\n \tmovu.w $r9,$r13\n \n-\tmovu.w $r13,$r13\n+;; We have ab*cd = (a*c)<<32 + (a*d + b*c)<<16 + b*d, but c==0\n+;; so we only need (a*d)<<16 + b*d with d = $r13, ab = $r10.\n+;; We drop the upper part of (a*d)<<16 as we're only doing a\n+;; 32-bit-result multiplication.\n+\n \tmove.d $r10,$r9\n \tlslq 16,$r9\n-\tmstep $r13,$r9\n+\tmstep $r13,$r9\t; b*d\n \tmstep $r13,$r9\n \tmstep $r13,$r9\n \tmstep $r13,$r9\n@@ -210,7 +222,7 @@ L(L3):\n \tmstep $r13,$r9\n \tclear.w $r10\n \ttest.d $r10\n-\tmstep $r13,$r10\n+\tmstep $r13,$r10\t; a*d\n \tmstep $r13,$r10\n \tmstep $r13,$r10\n \tmstep $r13,$r10\n@@ -231,25 +243,27 @@ L(L3):\n \tadd.d $r9,$r10\n \n L(L5):\n-\tmovu.w $r9,$r9\n+;; We have ab*cd = (a*c)<<32 + (a*d + b*c)<<16 + b*d, but a and c==0\n+;; so b*d (with b=$r13, a=$r10) it is.\n+\n \tlslq 16,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n-\tmstep $r9,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n \tret\n-\tmstep $r9,$r10\n+\tmstep $r13,$r10\n #endif\n L(Lfe1):\n \t.size\t___Mul,L(Lfe1)-___Mul"}, {"sha": "484693ea60ac4243b00367ad7de79f80a62710c5", "filename": "libgcc/config/cris/sfp-machine.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcris%2Fsfp-machine.h?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -0,0 +1,78 @@\n+/* Soft-FP definitions for CRIS.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+/* FIXME: none of the *MEAT* macros have actually been benchmarked to be\n+   better than any other choice for any CRIS variant.  */\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_QNANNEGATEDP 0\n+#define _FP_KEEPNANFRACP 1\n+\n+/* Someone please check this.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+# define __BYTE_ORDER __LITTLE_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));"}, {"sha": "308ef5105a96ba3c7ee6f4c12ad196d1d08bc9b5", "filename": "libgcc/config/cris/t-elfmulti", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Ft-elfmulti", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Ft-elfmulti", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcris%2Ft-elfmulti?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -1,3 +1,3 @@\n-LIB2ADD_ST = $(srcdir)/config/cris/mulsi3.S\n+LIB2ADD_ST = $(srcdir)/config/cris/mulsi3.S $(srcdir)/config/cris/umulsidi3.S\n \n CRTSTUFF_T_CFLAGS = -moverride-best-lib-options"}, {"sha": "eba98a12228be712a8198e24cb8483fb073cc007", "filename": "libgcc/config/cris/umulsidi3.S", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Fumulsidi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Fconfig%2Fcris%2Fumulsidi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fcris%2Fumulsidi3.S?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -0,0 +1,289 @@\n+;; Copyright (C) 2001, 2004, 2013 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; Under Section 7 of GPL version 3, you are granted additional\n+;; permissions described in the GCC Runtime Library Exception, version\n+;; 3.1, as published by the Free Software Foundation.\n+;;\n+;; You should have received a copy of the GNU General Public License and\n+;; a copy of the GCC Runtime Library Exception along with this program;\n+;; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+;; <http://www.gnu.org/licenses/>.\n+;;\n+;; This code is derived from mulsi3.S, observing that the mstep*16-based\n+;; multiplications there, from which it is formed, are actually\n+;; zero-extending; in gcc-speak \"umulhisi3\".  The difference to *this*\n+;; function is just a missing top mstep*16 sequence and shifts and 64-bit\n+;; additions for the high part.  Compared to an implementation based on\n+;; calling __Mul four times (see default implementation of umul_ppmm in\n+;; longlong.h), this will complete in a time between a fourth and a third\n+;; of that, assuming the value-based optimizations don't strike.  If they\n+;; all strike there (very often) but none here, we still win, though by a\n+;; lesser margin, due to lesser total overhead.\n+\n+#define L(x) .x\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+\n+#ifdef __USER_LABEL_PREFIX__\n+# define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n+#else\n+# define SYM(x) x\n+#endif\n+\n+\t.global SYM(__umulsidi3)\n+\t.type\tSYM(__umulsidi3),@function\n+SYM(__umulsidi3):\n+#if defined (__CRIS_arch_version) && __CRIS_arch_version >= 10\n+;; Can't have the mulu.d last on a cache-line, due to a hardware bug.  See\n+;; the documentation for -mmul-bug-workaround.\n+;; Not worthwhile to conditionalize here.\n+\t.p2alignw 2,0x050f\n+\tmulu.d $r11,$r10\n+\tret\n+\tmove $mof,$r11\n+#else\n+\tmove.d $r11,$r9\n+\tbound.d $r10,$r9\n+\tcmpu.w 65535,$r9\n+\tbls L(L3)\n+\tmove.d $r10,$r12\n+\n+\tmove.d $r10,$r13\n+\tmovu.w $r11,$r9 ; ab*cd = (a*c)<<32 (a*d + b*c)<<16 + b*d\n+\n+;; We're called for floating point numbers very often with the \"low\" 16\n+;; bits zero, so it's worthwhile to optimize for that.\n+\n+\tbeq L(L6)\t; d == 0?\n+\tlslq 16,$r13\n+\n+\tbeq L(L7)\t; b == 0?\n+\tclear.w $r10\n+\n+\tmstep $r9,$r13\t; d*b\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\n+L(L7):\n+\ttest.d $r10\n+\tmstep $r9,$r10\t; d*a\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\n+;; d*a in $r10, d*b in $r13, ab in $r12 and cd in $r11\n+;; $r9 = d, need to do b*c and a*c; we can drop d.\n+;; so $r9 is up for use and we can shift down $r11 as the mstep\n+;; source for the next mstep-part.\n+\n+L(L8):\n+\tlsrq 16,$r11\n+\tmove.d $r12,$r9\n+\tlslq 16,$r9\n+\tbeq L(L9)\t; b == 0?\n+\tmstep $r11,$r9\n+\n+\tmstep $r11,$r9\t; b*c\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+\tmstep $r11,$r9\n+L(L9):\n+\n+;; d*a in $r10, d*b in $r13, c*b in $r9, ab in $r12 and c in $r11,\n+;; need to do a*c.  We want that to end up in $r11, so we shift up $r11 to\n+;; now use as the destination operand.  We'd need a test insn to update N\n+;; to do it the other way round.\n+\n+\tlsrq 16,$r12\n+\tlslq 16,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\tmstep $r12,$r11\n+\n+;; d*a in $r10, d*b in $r13, c*b in $r9, a*c in $r11 ($r12 free).\n+;; Need (a*d + b*c)<<16 + b*d into $r10 and\n+;; a*c + (a*d + b*c)>>16 plus carry from the additions into $r11.\n+\n+\tadd.d $r9,$r10\t; (a*d + b*c) - may produce a carry.\n+\tscs $r12\t; The carry corresponds to bit 16 of $r11.\n+\tlslq 16,$r12\n+\tadd.d $r12,$r11\t; $r11 = a*c + carry from (a*d + b*c).\n+\n+#if defined (__CRIS_arch_version) && __CRIS_arch_version >= 8\n+\tswapw $r10\n+\taddu.w $r10,$r11 ; $r11 = a*c + (a*d + b*c) >> 16 including carry.\n+\tclear.w $r10\t; $r10 = (a*d + b*c) << 16\n+#else\n+\tmove.d $r10,$r9\n+\tlsrq 16,$r9\n+\tadd.d $r9,$r11\t; $r11 = a*c + (a*d + b*c) >> 16 including carry.\n+\tlslq 16,$r10\t; $r10 = (a*d + b*c) << 16\n+#endif\n+\tadd.d $r13,$r10\t; $r10 = (a*d + b*c) << 16 + b*d - may produce a carry.\n+\tscs $r9\n+\tret\n+\tadd.d $r9,$r11\t; Last carry added to the high-order 32 bits.\n+\n+L(L6):\n+\tclear.d $r13\n+\tba L(L8)\n+\tclear.d $r10\n+\n+L(L11):\n+\tclear.d $r10\n+\tret\n+\tclear.d $r11\n+\n+L(L3):\n+;; Form the maximum in $r10, by knowing the minimum, $r9.\n+;; (We don't know which one of $r10 or $r11 it is.)\n+;; Check if the largest operand is still just 16 bits.\n+\n+\txor $r9,$r10\n+\txor $r11,$r10\n+\tcmpu.w 65535,$r10\n+\tbls L(L5)\n+\tmovu.w $r9,$r13\n+\n+;; We have ab*cd = (a*c)<<32 + (a*d + b*c)<<16 + b*d, but c==0\n+;; so we only need (a*d)<<16 + b*d with d = $r13, ab = $r10.\n+;; Remember that the upper part of (a*d)<<16 goes into the lower part\n+;; of $r11 and there may be a carry from adding the low 32 parts.\n+\tbeq L(L11)\t; d == 0?\n+\tmove.d $r10,$r9\n+\n+\tlslq 16,$r9\n+\tbeq L(L10)\t; b == 0?\n+\tclear.w $r10\n+\n+\tmstep $r13,$r9\t; b*d\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+L(L10):\n+\ttest.d $r10\n+\tmstep $r13,$r10\t; a*d\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmove.d $r10,$r11\n+\tlsrq 16,$r11\n+\tlslq 16,$r10\n+\tadd.d $r9,$r10\n+\tscs $r12\n+\tret\n+\tadd.d $r12,$r11\n+\n+L(L5):\n+;; We have ab*cd = (a*c)<<32 + (a*d + b*c)<<16 + b*d, but a and c==0\n+;; so b*d (with min=b=$r13, max=d=$r10) it is.  As it won't overflow the\n+;; 32-bit part, just set $r11 to 0.\n+\n+\tlslq 16,$r10\n+\tclear.d $r11\n+\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tret\n+\tmstep $r13,$r10\n+#endif\n+L(Lfe1):\n+\t.size\tSYM(__umulsidi3),L(Lfe1)-SYM(__umulsidi3)"}, {"sha": "5f00e548a70907d70e93989f5ff02a3671bc633a", "filename": "libgcc/longlong.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e499e759cbc393de610e7023c483d0ca0a8a7b0/libgcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flonglong.h?ref=0e499e759cbc393de610e7023c483d0ca0a8a7b0", "patch": "@@ -289,12 +289,39 @@ extern UDItype __udiv_qrnnd (UDItype *, UDItype, UDItype, UDItype);\n \n #endif /* defined (__AVR__) */\n \n-#if defined (__CRIS__) && __CRIS_arch_version >= 3\n+#if defined (__CRIS__)\n+\n+#if __CRIS_arch_version >= 3\n #define count_leading_zeros(COUNT, X) ((COUNT) = __builtin_clz (X))\n+#define COUNT_LEADING_ZEROS_0 32\n+#endif /* __CRIS_arch_version >= 3 */\n+\n #if __CRIS_arch_version >= 8\n #define count_trailing_zeros(COUNT, X) ((COUNT) = __builtin_ctz (X))\n-#endif\n-#endif /* __CRIS__ */\n+#endif /* __CRIS_arch_version >= 8 */\n+\n+#if __CRIS_arch_version >= 10\n+#define __umulsidi3(u,v) ((UDItype)(USItype) (u) * (UDItype)(USItype) (v))\n+#else\n+#define __umulsidi3 __umulsidi3\n+extern UDItype __umulsidi3 (USItype, USItype);\n+#endif /* __CRIS_arch_version >= 10 */\n+\n+#define umul_ppmm(w1, w0, u, v)\t\t\\\n+  do {\t\t\t\t\t\\\n+    UDItype __x = __umulsidi3 (u, v);\t\\\n+    (w0) = (USItype) (__x);\t\t\\\n+    (w1) = (USItype) (__x >> 32);\t\\\n+  } while (0)\n+\n+/* FIXME: defining add_ssaaaa and sub_ddmmss should be advantageous for\n+   DFmode (\"double\" intrinsics, avoiding two of the three insns handling\n+   carry), but defining them as open-code C composing and doing the\n+   operation in DImode (UDImode) shows that the DImode needs work:\n+   register pressure from requiring neighboring registers and the\n+   traffic to and from them come to dominate, in the 4.7 series.  */\n+\n+#endif /* defined (__CRIS__) */\n \n #if defined (__hppa) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\"}]}