{"sha": "628d74de0e60a79f0b0e745a790c573663315f9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4ZDc0ZGUwZTYwYTc5ZjBiMGU3NDVhNzkwYzU3MzY2MzMxNWY5ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-26T22:08:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-26T22:08:59Z"}, "message": "alpha.c (alpha_split_tfmode_pair): New.\n\n        * alpha.c (alpha_split_tfmode_pair): New.\n        * alpha-protos.h: Declare it.\n        * alpha.md (abstf2, negtf2): New.\n        (movtf insn): Add input G constraint.\n        (movtf splitter): Use alpha_split_tfmode_pair.\n\nFrom-SVN: r31634", "tree": {"sha": "2989f870c2bed5a13bcca44d4b4d253ce4f9cbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2989f870c2bed5a13bcca44d4b4d253ce4f9cbfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/628d74de0e60a79f0b0e745a790c573663315f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628d74de0e60a79f0b0e745a790c573663315f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628d74de0e60a79f0b0e745a790c573663315f9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628d74de0e60a79f0b0e745a790c573663315f9e/comments", "author": null, "committer": null, "parents": [{"sha": "c96a8082c969a0eff2e6f769240de63366a5e8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c96a8082c969a0eff2e6f769240de63366a5e8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c96a8082c969a0eff2e6f769240de63366a5e8c2"}], "stats": {"total": 174, "additions": 147, "deletions": 27}, "files": [{"sha": "43797c2c7066ef5041fae8cc301815bef7c1b963", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=628d74de0e60a79f0b0e745a790c573663315f9e", "patch": "@@ -1,3 +1,11 @@\n+2000-01-26  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_split_tfmode_pair): New.\n+\t* alpha-protos.h: Declare it.\n+\t* alpha.md (abstf2, negtf2): New.\n+\t(movtf insn): Add input G constraint.\n+\t(movtf splitter): Use alpha_split_tfmode_pair.\n+\n 2000-01-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* i386/cygwin.h: PROTO -> PARAMS."}, {"sha": "fafe17b3e134f4c310e26bc6f492c744ab53e299", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=628d74de0e60a79f0b0e745a790c573663315f9e", "patch": "@@ -83,6 +83,7 @@ extern rtx alpha_emit_conditional_branch PARAMS ((enum rtx_code));\n extern rtx alpha_emit_conditional_move PARAMS ((rtx, enum machine_mode));\n extern void alpha_emit_xfloating_arith PARAMS ((enum rtx_code, rtx[]));\n extern void alpha_emit_xfloating_cvt PARAMS ((enum rtx_code, rtx[]));\n+extern void alpha_split_tfmode_pair PARAMS ((rtx[]));\n extern void alpha_expand_unaligned_load PARAMS ((rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t\tHOST_WIDE_INT, int));\n extern void alpha_expand_unaligned_store PARAMS ((rtx, rtx, HOST_WIDE_INT,"}, {"sha": "d4300334b16e441188b97439da4cf239be56939f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=628d74de0e60a79f0b0e745a790c573663315f9e", "patch": "@@ -2008,6 +2008,41 @@ alpha_emit_xfloating_cvt (code, operands)\n \t\t\t\tgen_rtx_fmt_e (code, GET_MODE (operands[0]),\n \t\t\t\t\t       operands[1]));\n }\n+\n+void\n+alpha_split_tfmode_pair (operands)\n+     rtx operands[4];\n+{\n+  if (GET_CODE (operands[1]) == REG)\n+    {\n+      operands[3] = gen_rtx_REG (DImode, REGNO (operands[1]) + 1);\n+      operands[2] = gen_rtx_REG (DImode, REGNO (operands[1]));\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    {\n+      operands[3] = change_address (operands[1], DImode,\n+\t\t\t\t    plus_constant (XEXP (operands[1], 0), 8));\n+      operands[2] = change_address (operands[1], DImode, NULL_RTX);\n+    }\n+  else if (operands[1] == CONST0_RTX (TFmode))\n+    operands[2] = operands[3] = const0_rtx;\n+  else\n+    abort ();\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    {\n+      operands[1] = gen_rtx_REG (DImode, REGNO (operands[0]) + 1);\n+      operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      operands[1] = change_address (operands[0], DImode,\n+\t\t\t\t    plus_constant (XEXP (operands[0], 0), 8));\n+      operands[0] = change_address (operands[0], DImode, NULL_RTX);\n+    }\n+  else\n+    abort ();\n+}\n \f\n /* Use ext[wlq][lh] as the Architecture Handbook describes for extracting\n    unaligned data:"}, {"sha": "0202642f02f4420bf5df2f98822ba5aa4edde28b", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 103, "deletions": 27, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628d74de0e60a79f0b0e745a790c573663315f9e/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=628d74de0e60a79f0b0e745a790c573663315f9e", "patch": "@@ -1771,6 +1771,58 @@\n   \"cpys $f31,%R1,%0\"\n   [(set_attr \"type\" \"fcpys\")])\n \n+(define_expand \"abstf2\"\n+  [(parallel [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t\t   (neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n+\t      (use (match_dup 2))])]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"\n+{\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  operands[2] = force_reg (DImode, GEN_INT (0x8000000000000000));\n+#else\n+  operands[2] = force_reg (DImode, immed_double_const (0, 0x80000000, DImode));\n+#endif\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n+\t(abs:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"rG\")))\n+   (use (match_operand:DI 2 \"register_operand\" \"=r\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(abs:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n+   (use (match_operand:DI 4 \"register_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  int move;\n+  rtx tmp;\n+\n+  alpha_split_tfmode_pair (operands);\n+\n+  move = 1;\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    move = 0;\n+  else if (rtx_equal_p (operands[0], operands[3]))\n+    move = -1;\n+\n+  if (move < 0)\n+    emit_move_insn (operands[1], operands[3]);\n+\n+  tmp = gen_rtx_NOT (DImode, operands[4]);\n+  tmp = gen_rtx_AND (DImode, tmp, operands[2]);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], tmp));\n+\t\n+  if (move > 0)\n+    emit_move_insn (operands[1], operands[3]);\n+  DONE;\n+}\")\n+\n (define_insn \"negsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\")))]\n@@ -1785,6 +1837,55 @@\n   \"cpysn %R1,%R1,%0\"\n   [(set_attr \"type\" \"fadd\")])\n \n+(define_expand \"negtf2\"\n+  [(parallel [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t\t   (neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n+\t      (use (match_dup 2))])]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"\n+{\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  operands[2] = force_reg (DImode, GEN_INT (0x8000000000000000));\n+#else\n+  operands[2] = force_reg (DImode, immed_double_const (0, 0x80000000, DImode));\n+#endif\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n+\t(neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"rG\")))\n+   (use (match_operand:DI 2 \"register_operand\" \"=r\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"register_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"reg_or_fp0_operand\" \"\")))\n+   (use (match_operand:DI 4 \"register_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  int move;\n+\n+  alpha_split_tfmode_pair (operands);\n+\n+  move = 1;\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    move = 0;\n+  else if (rtx_equal_p (operands[0], operands[3]))\n+    move = -1;\n+\n+  if (move < 0)\n+    emit_move_insn (operands[1], operands[3]);\n+\n+  emit_insn (gen_xordi3 (operands[0], operands[2], operands[4]));\n+\t\n+  if (move > 0)\n+    emit_move_insn (operands[1], operands[3]);\n+  DONE;\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(plus:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"%fG\")\n@@ -4096,7 +4197,7 @@\n ;; data between general registers until after reload.\n (define_insn \"\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(match_operand:TF 1 \"input_operand\" \"ro,r\"))]\n+\t(match_operand:TF 1 \"input_operand\" \"roG,r\"))]\n   \"register_operand (operands[0], TFmode)\n    || reg_or_fp0_operand (operands[1], TFmode)\"\n   \"#\")\n@@ -4109,30 +4210,7 @@\n    (set (match_dup 1) (match_dup 3))]\n   \"\n {\n-  if (GET_CODE (operands[1]) == REG)\n-    {\n-      operands[3] = gen_rtx_REG (DImode, REGNO (operands[1]) + 1);\n-      operands[2] = gen_rtx_REG (DImode, REGNO (operands[1]));\n-    }\n-  else if (GET_CODE (operands[1]) == MEM)\n-    {\n-      operands[3] = change_address (operands[1], DImode,\n-\t\t\t\t    plus_constant (XEXP (operands[1], 0), 8));\n-      operands[2] = change_address (operands[1], DImode, NULL_RTX);\n-    }\n-\n-  if (GET_CODE (operands[0]) == REG)\n-    {\n-      operands[1] = gen_rtx_REG (DImode, REGNO (operands[0]) + 1);\n-      operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    {\n-      operands[1] = change_address (operands[0], DImode,\n-\t\t\t\t    plus_constant (XEXP (operands[0], 0), 8));\n-      operands[0] = change_address (operands[0], DImode, NULL_RTX);\n-    }\n-\n+  alpha_split_tfmode_pair (operands);\n   if (rtx_equal_p (operands[0], operands[3]))\n     {\n       rtx tmp;\n@@ -4141,8 +4219,6 @@\n     }\n }\")\n \n-\n-\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]"}]}