{"sha": "ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYxZDNiNTdkMmQwMDc5NWM2ZWIwMWZlNmI4ZWY2ZjQxMzE2M2M2Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T11:49:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T11:49:34Z"}, "message": "Add a fixed_size_mode class\n\nThis patch adds a fixed_size_mode machine_mode wrapper\nfor modes that are known to have a fixed size.  That applies\nto all current modes, but future patches will add support for\nvariable-sized modes.\n\nThe use of this class should be pretty restricted.  One important\nuse case is to hold the mode of static data, which can never be\nvariable-sized with current file formats.  Another is to hold\nthe modes of registers involved in __builtin_apply and\n__builtin_result, since those interfaces don't cope well with\nvariable-sized data.\n\nThe class can also be useful when reinterpreting the contents of\na fixed-length bit string as a different kind of value.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (fixed_size_mode): New class.\n\t* rtl.h (get_pool_mode): Return fixed_size_mode.\n\t* gengtype.c (main): Add fixed_size_mode.\n\t* target.def (get_raw_result_mode): Return a fixed_size_mode.\n\t(get_raw_arg_mode): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_get_reg_raw_mode): Return a fixed_size_mode.\n\t* targhooks.c (default_get_reg_raw_mode): Likewise.\n\t* config/ia64/ia64.c (ia64_get_reg_raw_mode): Likewise.\n\t* config/mips/mips.c (mips_get_reg_raw_mode): Likewise.\n\t* config/msp430/msp430.c (msp430_get_raw_arg_mode): Likewise.\n\t(msp430_get_raw_result_mode): Likewise.\n\t* config/avr/avr-protos.h (regmask): Use as_a <fixed_side_mode>\n\t* dbxout.c (dbxout_parms): Require fixed-size modes.\n\t* expr.c (copy_blkmode_from_reg, copy_blkmode_to_reg): Likewise.\n\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Likewise.\n\t* omp-low.c (lower_oacc_reductions): Likewise.\n\t* simplify-rtx.c (simplify_immed_subreg): Take fixed_size_modes.\n\t(simplify_subreg): Update accordingly.\n\t* varasm.c (constant_descriptor_rtx::mode): Change to fixed_size_mode.\n\t(force_const_mem): Update accordingly.  Return NULL_RTX for modes\n\tthat aren't fixed-size.\n\t(get_pool_mode): Return a fixed_size_mode.\n\t(output_constant_pool_2): Take a fixed_size_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254300", "tree": {"sha": "af7a96746cc35a998026456f2e51bdbaea611a6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af7a96746cc35a998026456f2e51bdbaea611a6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/comments", "author": null, "committer": null, "parents": [{"sha": "ef339d6e2e846ba7ff544def1d79f10762da223d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef339d6e2e846ba7ff544def1d79f10762da223d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef339d6e2e846ba7ff544def1d79f10762da223d"}], "stats": {"total": 171, "additions": 131, "deletions": 40}, "files": [{"sha": "f35b954111336a8d9ec1a3358b595ee58b68971d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -1,3 +1,32 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (fixed_size_mode): New class.\n+\t* rtl.h (get_pool_mode): Return fixed_size_mode.\n+\t* gengtype.c (main): Add fixed_size_mode.\n+\t* target.def (get_raw_result_mode): Return a fixed_size_mode.\n+\t(get_raw_arg_mode): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_get_reg_raw_mode): Return a fixed_size_mode.\n+\t* targhooks.c (default_get_reg_raw_mode): Likewise.\n+\t* config/ia64/ia64.c (ia64_get_reg_raw_mode): Likewise.\n+\t* config/mips/mips.c (mips_get_reg_raw_mode): Likewise.\n+\t* config/msp430/msp430.c (msp430_get_raw_arg_mode): Likewise.\n+\t(msp430_get_raw_result_mode): Likewise.\n+\t* config/avr/avr-protos.h (regmask): Use as_a <fixed_side_mode>\n+\t* dbxout.c (dbxout_parms): Require fixed-size modes.\n+\t* expr.c (copy_blkmode_from_reg, copy_blkmode_to_reg): Likewise.\n+\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Likewise.\n+\t* omp-low.c (lower_oacc_reductions): Likewise.\n+\t* simplify-rtx.c (simplify_immed_subreg): Take fixed_size_modes.\n+\t(simplify_subreg): Update accordingly.\n+\t* varasm.c (constant_descriptor_rtx::mode): Change to fixed_size_mode.\n+\t(force_const_mem): Update accordingly.  Return NULL_RTX for modes\n+\tthat aren't fixed-size.\n+\t(get_pool_mode): Return a fixed_size_mode.\n+\t(output_constant_pool_2): Take a fixed_size_mode.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "089e2099874b596fc1f5ecb24e709318031a456d", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -131,7 +131,7 @@ extern bool avr_casei_sequence_check_operands (rtx *xop);\n static inline unsigned\n regmask (machine_mode mode, unsigned regno)\n {\n-  return ((1u << GET_MODE_SIZE (mode)) - 1) << regno;\n+  return ((1u << GET_MODE_SIZE (as_a <fixed_size_mode> (mode))) - 1) << regno;\n }\n \n extern void avr_fix_inputs (rtx*, unsigned, unsigned);"}, {"sha": "84a5b5678a749eb43e43d9c3154bccf7fd15b5c7", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -329,7 +329,7 @@ static tree ia64_fold_builtin (tree, int, tree *, bool);\n static tree ia64_builtin_decl (unsigned, bool);\n \n static reg_class_t ia64_preferred_reload_class (rtx, reg_class_t);\n-static machine_mode ia64_get_reg_raw_mode (int regno);\n+static fixed_size_mode ia64_get_reg_raw_mode (int regno);\n static section * ia64_hpux_function_section (tree, enum node_frequency,\n \t\t\t\t\t     bool, bool);\n \n@@ -11328,7 +11328,7 @@ ia64_dconst_0_375 (void)\n   return ia64_dconst_0_375_rtx;\n }\n \n-static machine_mode\n+static fixed_size_mode\n ia64_get_reg_raw_mode (int regno)\n {\n   if (FR_REGNO_P (regno))"}, {"sha": "7dde705bae7e31ea3ae644d28bce9709784a55d1", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -1132,7 +1132,6 @@ static rtx mips_find_pic_call_symbol (rtx_insn *, rtx, bool);\n static int mips_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t    reg_class_t);\n static unsigned int mips_function_arg_boundary (machine_mode, const_tree);\n-static machine_mode mips_get_reg_raw_mode (int regno);\n static rtx mips_gen_const_int_vector_shuffle (machine_mode, int);\n \f\n /* This hash table keeps track of implicit \"mips16\" and \"nomips16\" attributes\n@@ -6111,7 +6110,7 @@ mips_function_arg_boundary (machine_mode mode, const_tree type)\n \n /* Implement TARGET_GET_RAW_RESULT_MODE and TARGET_GET_RAW_ARG_MODE.  */\n \n-static machine_mode\n+static fixed_size_mode\n mips_get_reg_raw_mode (int regno)\n {\n   if (TARGET_FLOATXX && FP_REG_P (regno))"}, {"sha": "0ee0b6c2dbc42d4e9d4cda100c03577ee63df6c7", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -1402,16 +1402,17 @@ msp430_return_in_memory (const_tree ret_type, const_tree fntype ATTRIBUTE_UNUSED\n #undef  TARGET_GET_RAW_ARG_MODE\n #define TARGET_GET_RAW_ARG_MODE msp430_get_raw_arg_mode\n \n-static machine_mode\n+static fixed_size_mode\n msp430_get_raw_arg_mode (int regno)\n {\n-  return (regno == ARG_POINTER_REGNUM) ? VOIDmode : Pmode;\n+  return as_a <fixed_size_mode> (regno == ARG_POINTER_REGNUM\n+\t\t\t\t ? VOIDmode : Pmode);\n }\n \n #undef  TARGET_GET_RAW_RESULT_MODE\n #define TARGET_GET_RAW_RESULT_MODE msp430_get_raw_result_mode\n \n-static machine_mode\n+static fixed_size_mode\n msp430_get_raw_result_mode (int regno ATTRIBUTE_UNUSED)\n {\n   return Pmode;"}, {"sha": "49a858339f8c4eeead48b30d5a050085e2f5c554", "filename": "gcc/dbxout.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -3393,12 +3393,16 @@ dbxout_parms (tree parms)\n {\n   ++debug_nesting;\n   emit_pending_bincls_if_required ();\n+  fixed_size_mode rtl_mode, type_mode;\n \n   for (; parms; parms = DECL_CHAIN (parms))\n     if (DECL_NAME (parms)\n \t&& TREE_TYPE (parms) != error_mark_node\n \t&& DECL_RTL_SET_P (parms)\n-\t&& DECL_INCOMING_RTL (parms))\n+\t&& DECL_INCOMING_RTL (parms)\n+\t/* We can't represent variable-sized types in this format.  */\n+\t&& is_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (parms)), &type_mode)\n+\t&& is_a <fixed_size_mode> (GET_MODE (DECL_RTL (parms)), &rtl_mode))\n       {\n \ttree eff_type;\n \tchar letter;\n@@ -3555,10 +3559,9 @@ dbxout_parms (tree parms)\n \t    /* Make a big endian correction if the mode of the type of the\n \t       parameter is not the same as the mode of the rtl.  */\n \t    if (BYTES_BIG_ENDIAN\n-\t\t&& TYPE_MODE (TREE_TYPE (parms)) != GET_MODE (DECL_RTL (parms))\n-\t\t&& GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))) < UNITS_PER_WORD)\n-\t      number += (GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))\n-\t\t\t - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))));\n+\t\t&& type_mode != rtl_mode\n+\t\t&& GET_MODE_SIZE (type_mode) < UNITS_PER_WORD)\n+\t      number += GET_MODE_SIZE (rtl_mode) - GET_MODE_SIZE (type_mode);\n \t  }\n \telse\n \t  /* ??? We don't know how to represent this argument.  */"}, {"sha": "72606f53f1c991e0bfadcd5f23aaedaac5f0a8df", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -4551,11 +4551,11 @@ This macro has effect in @option{-fpcc-struct-return} mode, but it does\n nothing when you use @option{-freg-struct-return} mode.\n @end defmac\n \n-@deftypefn {Target Hook} machine_mode TARGET_GET_RAW_RESULT_MODE (int @var{regno})\n+@deftypefn {Target Hook} fixed_size_mode TARGET_GET_RAW_RESULT_MODE (int @var{regno})\n This target hook returns the mode to be used when accessing raw return registers in @code{__builtin_return}.  Define this macro if the value in @var{reg_raw_mode} is not correct.\n @end deftypefn\n \n-@deftypefn {Target Hook} machine_mode TARGET_GET_RAW_ARG_MODE (int @var{regno})\n+@deftypefn {Target Hook} fixed_size_mode TARGET_GET_RAW_ARG_MODE (int @var{regno})\n This target hook returns the mode to be used when accessing raw argument registers in @code{__builtin_apply_args}.  Define this macro if the value in @var{reg_raw_mode} is not correct.\n @end deftypefn\n "}, {"sha": "edcd7e82c818e51e1695356eadf87cdc2aa87c7d", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -2628,9 +2628,10 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n   rtx src = NULL, dst = NULL;\n   unsigned HOST_WIDE_INT bitsize = MIN (TYPE_ALIGN (type), BITS_PER_WORD);\n   unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0;\n-  machine_mode mode = GET_MODE (srcreg);\n-  machine_mode tmode = GET_MODE (target);\n-  machine_mode copy_mode;\n+  /* No current ABI uses variable-sized modes to pass a BLKmnode type.  */\n+  fixed_size_mode mode = as_a <fixed_size_mode> (GET_MODE (srcreg));\n+  fixed_size_mode tmode = as_a <fixed_size_mode> (GET_MODE (target));\n+  fixed_size_mode copy_mode;\n \n   /* BLKmode registers created in the back-end shouldn't have survived.  */\n   gcc_assert (mode != BLKmode);\n@@ -2728,19 +2729,21 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n     }\n }\n \n-/* Copy BLKmode value SRC into a register of mode MODE.  Return the\n+/* Copy BLKmode value SRC into a register of mode MODE_IN.  Return the\n    register if it contains any data, otherwise return null.\n \n    This is used on targets that return BLKmode values in registers.  */\n \n rtx\n-copy_blkmode_to_reg (machine_mode mode, tree src)\n+copy_blkmode_to_reg (machine_mode mode_in, tree src)\n {\n   int i, n_regs;\n   unsigned HOST_WIDE_INT bitpos, xbitpos, padding_correction = 0, bytes;\n   unsigned int bitsize;\n   rtx *dst_words, dst, x, src_word = NULL_RTX, dst_word = NULL_RTX;\n-  machine_mode dst_mode;\n+  /* No current ABI uses variable-sized modes to pass a BLKmnode type.  */\n+  fixed_size_mode mode = as_a <fixed_size_mode> (mode_in);\n+  fixed_size_mode dst_mode;\n \n   gcc_assert (TYPE_MODE (TREE_TYPE (src)) == BLKmode);\n "}, {"sha": "ad2be72e3a634b22a5719504e7e95c162a182a42", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -5197,6 +5197,7 @@ main (int argc, char **argv)\n       POS_HERE (do_scalar_typedef (\"JCF_u2\", &pos));\n       POS_HERE (do_scalar_typedef (\"void\", &pos));\n       POS_HERE (do_scalar_typedef (\"machine_mode\", &pos));\n+      POS_HERE (do_scalar_typedef (\"fixed_size_mode\", &pos));\n       POS_HERE (do_typedef (\"PTR\", \n \t\t\t    create_pointer (resolve_typedef (\"void\", &pos)),\n \t\t\t    &pos));"}, {"sha": "0bc4813be3931ea60d1ee5cf1abf16d7226988c3", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -415,8 +415,11 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n     The awkwardness comes from the fact that bitpos is counted from the\n     most significant bit of a byte.  */\n \n+  /* We must be dealing with fixed-size data at this point, since the\n+     total size is also fixed.  */\n+  fixed_size_mode mode = as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (expr)));\n   /* Allocate an extra byte so that we have space to shift into.  */\n-  unsigned int byte_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr))) + 1;\n+  unsigned int byte_size = GET_MODE_SIZE (mode) + 1;\n   unsigned char *tmpbuf = XALLOCAVEC (unsigned char, byte_size);\n   memset (tmpbuf, '\\0', byte_size);\n   /* The store detection code should only have allowed constants that are"}, {"sha": "f5e5baaec80fd4849311c8106a63aaeb6d7e443b", "filename": "gcc/machmode.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -652,6 +652,39 @@ GET_MODE_2XWIDER_MODE (const T &m)\n extern const unsigned char mode_complex[NUM_MACHINE_MODES];\n #define GET_MODE_COMPLEX_MODE(MODE) ((machine_mode) mode_complex[MODE])\n \n+/* Represents a machine mode that must have a fixed size.  The main\n+   use of this class is to represent the modes of objects that always\n+   have static storage duration, such as constant pool entries.\n+   (No current target supports the concept of variable-size static data.)  */\n+class fixed_size_mode\n+{\n+public:\n+  typedef mode_traits<fixed_size_mode>::from_int from_int;\n+\n+  ALWAYS_INLINE fixed_size_mode () {}\n+  ALWAYS_INLINE fixed_size_mode (from_int m) : m_mode (machine_mode (m)) {}\n+  ALWAYS_INLINE fixed_size_mode (const scalar_mode &m) : m_mode (m) {}\n+  ALWAYS_INLINE fixed_size_mode (const scalar_int_mode &m) : m_mode (m) {}\n+  ALWAYS_INLINE fixed_size_mode (const scalar_float_mode &m) : m_mode (m) {}\n+  ALWAYS_INLINE fixed_size_mode (const scalar_mode_pod &m) : m_mode (m) {}\n+  ALWAYS_INLINE fixed_size_mode (const scalar_int_mode_pod &m) : m_mode (m) {}\n+  ALWAYS_INLINE fixed_size_mode (const complex_mode &m) : m_mode (m) {}\n+  ALWAYS_INLINE operator machine_mode () const { return m_mode; }\n+\n+  static bool includes_p (machine_mode);\n+\n+protected:\n+  machine_mode m_mode;\n+};\n+\n+/* Return true if MODE has a fixed size.  */\n+\n+inline bool\n+fixed_size_mode::includes_p (machine_mode)\n+{\n+  return true;\n+}\n+\n extern opt_machine_mode mode_for_size (unsigned int, enum mode_class, int);\n \n /* Return the machine mode to use for a MODE_INT of SIZE bits, if one"}, {"sha": "33e633cd627b494cd26a45b217905fe5a147d1d1", "filename": "gcc/omp-low.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -5067,8 +5067,10 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n \t  v1 = v2 = v3 = var;\n \n \t/* Determine position in reduction buffer, which may be used\n-\t   by target.  */\n-\tmachine_mode mode = TYPE_MODE (TREE_TYPE (var));\n+\t   by target.  The parser has ensured that this is not a\n+\t   variable-sized type.  */\n+\tfixed_size_mode mode\n+\t  = as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (var)));\n \tunsigned align = GET_MODE_ALIGNMENT (mode) /  BITS_PER_UNIT;\n \toffset = (offset + align - 1) & ~(align - 1);\n \ttree off = build_int_cst (sizetype, offset);"}, {"sha": "53635a2d4b09bfa2d00d238765a05368c9a4c555", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -3021,7 +3021,7 @@ extern rtx force_const_mem (machine_mode, rtx);\n struct function;\n extern rtx get_pool_constant (const_rtx);\n extern rtx get_pool_constant_mark (rtx, bool *);\n-extern machine_mode get_pool_mode (const_rtx);\n+extern fixed_size_mode get_pool_mode (const_rtx);\n extern rtx simplify_subtraction (rtx);\n extern void decide_function_section (tree);\n "}, {"sha": "a6963ce659da43546d4ede501a193c87cc232046", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -48,8 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n static rtx neg_const_int (machine_mode, const_rtx);\n static bool plus_minus_operand_p (const_rtx);\n static rtx simplify_plus_minus (enum rtx_code, machine_mode, rtx, rtx);\n-static rtx simplify_immed_subreg (machine_mode, rtx, machine_mode,\n-\t\t\t\t  unsigned int);\n static rtx simplify_associative_operation (enum rtx_code, machine_mode,\n \t\t\t\t\t   rtx, rtx);\n static rtx simplify_relational_operation_1 (enum rtx_code, machine_mode,\n@@ -5806,8 +5804,8 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n    and then repacking them again for OUTERMODE.  */\n \n static rtx\n-simplify_immed_subreg (machine_mode outermode, rtx op,\n-\t\t       machine_mode innermode, unsigned int byte)\n+simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n+\t\t       fixed_size_mode innermode, unsigned int byte)\n {\n   enum {\n     value_bit = 8,\n@@ -6175,7 +6173,18 @@ simplify_subreg (machine_mode outermode, rtx op,\n       || CONST_DOUBLE_AS_FLOAT_P (op)\n       || GET_CODE (op) == CONST_FIXED\n       || GET_CODE (op) == CONST_VECTOR)\n-    return simplify_immed_subreg (outermode, op, innermode, byte);\n+    {\n+      /* simplify_immed_subreg deconstructs OP into bytes and constructs\n+\t the result from bytes, so it only works if the sizes of the modes\n+\t are known at compile time.  Cases that apply to general modes\n+\t should be handled here before calling simplify_immed_subreg.  */\n+      fixed_size_mode fs_outermode, fs_innermode;\n+      if (is_a <fixed_size_mode> (outermode, &fs_outermode)\n+\t  && is_a <fixed_size_mode> (innermode, &fs_innermode))\n+\treturn simplify_immed_subreg (fs_outermode, op, fs_innermode, byte);\n+\n+      return NULL_RTX;\n+    }\n \n   /* Changing mode twice with SUBREG => just change it once,\n      or not at all if changing back op starting mode.  */"}, {"sha": "577dad8fe86aad73876cef1e9566d66d3ada19b0", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -5042,7 +5042,7 @@ DEFHOOK\n  \"This target hook returns the mode to be used when accessing raw return\\\n  registers in @code{__builtin_return}.  Define this macro if the value\\\n  in @var{reg_raw_mode} is not correct.\",\n- machine_mode, (int regno),\n+ fixed_size_mode, (int regno),\n  default_get_reg_raw_mode)\n \n /* Return a mode wide enough to copy any argument value that might be\n@@ -5052,7 +5052,7 @@ DEFHOOK\n  \"This target hook returns the mode to be used when accessing raw argument\\\n  registers in @code{__builtin_apply_args}.  Define this macro if the value\\\n  in @var{reg_raw_mode} is not correct.\",\n- machine_mode, (int regno),\n+ fixed_size_mode, (int regno),\n  default_get_reg_raw_mode)\n \n HOOK_VECTOR_END (calls)"}, {"sha": "dad1e109d2346fd490070154b1616b0e17a3b595", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -1872,10 +1872,12 @@ default_dwarf_frame_reg_mode (int regno)\n /* To be used by targets where reg_raw_mode doesn't return the right\n    mode for registers used in apply_builtin_return and apply_builtin_arg.  */\n \n-machine_mode\n+fixed_size_mode\n default_get_reg_raw_mode (int regno)\n {\n-  return reg_raw_mode[regno];\n+  /* Targets must override this hook if the underlying register is\n+     variable-sized.  */\n+  return as_a <fixed_size_mode> (reg_raw_mode[regno]);\n }\n \n /* Return true if a leaf function should stay leaf even with profiling"}, {"sha": "15bbf5cdf249a62ac9178375f4192ed63d494059", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -236,7 +236,7 @@ extern int default_jump_align_max_skip (rtx_insn *);\n extern section * default_function_section(tree decl, enum node_frequency freq,\n \t\t\t\t\t  bool startup, bool exit);\n extern machine_mode default_dwarf_frame_reg_mode (int);\n-extern machine_mode default_get_reg_raw_mode (int);\n+extern fixed_size_mode default_get_reg_raw_mode (int);\n extern bool default_keep_leaf_when_profiled ();\n \n extern void *default_get_pch_validity (size_t *);"}, {"sha": "655324e23e2868b953eb83d53a9a0b5f4437ac6a", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "patch": "@@ -3566,7 +3566,7 @@ struct GTY((chain_next (\"%h.next\"), for_user)) constant_descriptor_rtx {\n   rtx constant;\n   HOST_WIDE_INT offset;\n   hashval_t hash;\n-  machine_mode mode;\n+  fixed_size_mode mode;\n   unsigned int align;\n   int labelno;\n   int mark;\n@@ -3742,10 +3742,11 @@ simplify_subtraction (rtx x)\n }\n \f\n /* Given a constant rtx X, make (or find) a memory constant for its value\n-   and return a MEM rtx to refer to it in memory.  */\n+   and return a MEM rtx to refer to it in memory.  IN_MODE is the mode\n+   of X.  */\n \n rtx\n-force_const_mem (machine_mode mode, rtx x)\n+force_const_mem (machine_mode in_mode, rtx x)\n {\n   struct constant_descriptor_rtx *desc, tmp;\n   struct rtx_constant_pool *pool;\n@@ -3754,6 +3755,11 @@ force_const_mem (machine_mode mode, rtx x)\n   hashval_t hash;\n   unsigned int align;\n   constant_descriptor_rtx **slot;\n+  fixed_size_mode mode;\n+\n+  /* We can't force variable-sized objects to memory.  */\n+  if (!is_a <fixed_size_mode> (in_mode, &mode))\n+    return NULL_RTX;\n \n   /* If we're not allowed to drop X into the constant pool, don't.  */\n   if (targetm.cannot_force_const_mem (mode, x))\n@@ -3859,7 +3865,7 @@ get_pool_constant_mark (rtx addr, bool *pmarked)\n \n /* Similar, return the mode.  */\n \n-machine_mode\n+fixed_size_mode\n get_pool_mode (const_rtx addr)\n {\n   return SYMBOL_REF_CONSTANT (addr)->mode;\n@@ -3879,7 +3885,7 @@ constant_pool_empty_p (void)\n    in MODE with known alignment ALIGN.  */\n \n static void\n-output_constant_pool_2 (machine_mode mode, rtx x, unsigned int align)\n+output_constant_pool_2 (fixed_size_mode mode, rtx x, unsigned int align)\n {\n   switch (GET_MODE_CLASS (mode))\n     {"}]}