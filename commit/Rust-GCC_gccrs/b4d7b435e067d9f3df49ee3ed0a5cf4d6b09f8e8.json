{"sha": "b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRkN2I0MzVlMDY3ZDlmM2RmNDllZTNlZDBhNWNmNGQ2YjA5ZjhlOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:26:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:26:07Z"}, "message": "[multiple changes]\n\n2010-06-23  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Add_Internal_Interface_Entities): Generate internal\n\tentities for parent types that are interfaces. Needed in generics to\n\thandle formals that implement interfaces.\n\t(Derive_Subprograms): Add assertion for derivation of tagged types that\n\tdo not cover interfaces. For generics, complete code that handles\n\tderivation of type that covers interfaces because the previous\n\tcondition was weak (it required only name consistency; arguments were\n\tnot checked). Add new code to locate primitives covering interfaces\n\tdefined in generic units or instantiatons.\n\t* sem_util.adb (Has_Interfaces): Add missing support for derived types.\n\t* sem_ch6.adb (Check_Overriding_Indicator): Minor code cleanups.\n\t* exp_disp.adb (Make_Select_Specific_Data_Table): Skip primitives of\n\tinterfaces that are parents of the type because they share the primary\n\tdispatch table.\n\t(Register_Primitive): Do not register primitives of interfaces that\n\tare parents of the type.\n\t* sem_ch13.adb (Analyze_Freeze_Entity): Add documentation.\n\t* exp_cg.adb (Write_Type_Info): When displaying overriding of interface\n\tprimitives skip primitives of interfaces that are parents of the type.\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Eval_Attribute): If the prefix is an array, the\n\tattribute cannot be constant-folded if an index type is a formal type,\n\tor is derived from one.\n\t* checks.adb (Determine_Range): ditto.\n\n2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat_ugn.texi, gnatxref.adb: Add support for --ext switch.\n\n2010-06-23  Bob Duff  <duff@adacore.com>\n\n\t* g-pehage.ads, g-pehage.adb (Put): Fix off-by-one bug.\n\t(Insert): Disallow nul characters.\n\t(misc output routines): Assert no nul characters.\n\nFrom-SVN: r161247", "tree": {"sha": "a0e35a2b20164c8ea9d9dca20639a36a06bef869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0e35a2b20164c8ea9d9dca20639a36a06bef869"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/comments", "author": null, "committer": null, "parents": [{"sha": "bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc20523f7b770a2ad34ab9fb6260d593e007e8ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc20523f7b770a2ad34ab9fb6260d593e007e8ec"}], "stats": {"total": 485, "additions": 350, "deletions": 135}, "files": [{"sha": "361182c438c01e4f2d61cc3a997b4c99ac716ef2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -1,3 +1,42 @@\n+2010-06-23  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Add_Internal_Interface_Entities): Generate internal\n+\tentities for parent types that are interfaces. Needed in generics to\n+\thandle formals that implement interfaces.\n+\t(Derive_Subprograms): Add assertion for derivation of tagged types that\n+\tdo not cover interfaces. For generics, complete code that handles\n+\tderivation of type that covers interfaces because the previous\n+\tcondition was weak (it required only name consistency; arguments were\n+\tnot checked). Add new code to locate primitives covering interfaces\n+\tdefined in generic units or instantiatons.\n+\t* sem_util.adb (Has_Interfaces): Add missing support for derived types.\n+\t* sem_ch6.adb (Check_Overriding_Indicator): Minor code cleanups.\n+\t* exp_disp.adb (Make_Select_Specific_Data_Table): Skip primitives of\n+\tinterfaces that are parents of the type because they share the primary\n+\tdispatch table.\n+\t(Register_Primitive): Do not register primitives of interfaces that\n+\tare parents of the type.\n+\t* sem_ch13.adb (Analyze_Freeze_Entity): Add documentation.\n+\t* exp_cg.adb (Write_Type_Info): When displaying overriding of interface\n+\tprimitives skip primitives of interfaces that are parents of the type.\n+\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Eval_Attribute): If the prefix is an array, the\n+\tattribute cannot be constant-folded if an index type is a formal type,\n+\tor is derived from one.\n+\t* checks.adb (Determine_Range): ditto.\n+\n+2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat_ugn.texi, gnatxref.adb: Add support for --ext switch.\n+\n+2010-06-23  Bob Duff  <duff@adacore.com>\n+\n+\t* g-pehage.ads, g-pehage.adb (Put): Fix off-by-one bug.\n+\t(Insert): Disallow nul characters.\n+\t(misc output routines): Assert no nul characters.\n+\n 2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch4.adb: Use predefined unsigned type in all cases."}, {"sha": "9261a2798827f0227d009a8f9f5fdf7eaefb16d7", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -3351,6 +3351,14 @@ package body Checks is\n                         Indx := Next_Index (Indx);\n                      end loop;\n \n+                     --  if The index type is a formal type, or derived from\n+                     --  one, the bounds are not static.\n+\n+                     if Is_Generic_Type (Root_Type (Etype (Indx))) then\n+                        OK := False;\n+                        return;\n+                     end if;\n+\n                      Determine_Range\n                        (Type_Low_Bound (Etype (Indx)), OK1, LL, LU,\n                         Assume_Valid);"}, {"sha": "e7decc8f1e74642cfa66e053c3bca097266bf1f6", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -572,7 +572,11 @@ package body Exp_CG is\n                   Prim_Op := Node (Prim_Elmt);\n                   Int_Alias := Interface_Alias (Prim_Op);\n \n-                  if Present (Int_Alias) and then (Alias (Prim_Op)) = Prim then\n+                  if Present (Int_Alias)\n+                    and then not Is_Ancestor\n+                                   (Find_Dispatching_Type (Int_Alias), Typ)\n+                    and then (Alias (Prim_Op)) = Prim\n+                  then\n                      Write_Char (',');\n                      Write_Int (UI_To_Int (Slot_Number (Int_Alias)));\n                      Write_Char (':');"}, {"sha": "5a1f24964223e1f6aac65f22ac76bee2baed0618", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -6014,6 +6014,9 @@ package body Exp_Disp is\n             --  Look for primitive overriding an abstract interface subprogram\n \n             if Present (Interface_Alias (Prim))\n+              and then not\n+                Is_Ancestor\n+                  (Find_Dispatching_Type (Interface_Alias (Prim)), Typ)\n               and then not Examined (UI_To_Int (DT_Position (Alias (Prim))))\n             then\n                Prim_Pos := DT_Position (Alias (Prim));\n@@ -6721,6 +6724,13 @@ package body Exp_Disp is\n \n          pragma Assert (Is_Interface (Iface_Typ));\n \n+         --  No action needed for interfaces that are ancestors of Typ because\n+         --  their primitives are located in the primary dispatch table.\n+\n+         if Is_Ancestor (Iface_Typ, Tag_Typ) then\n+            return L;\n+         end if;\n+\n          Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n          if not Is_Ancestor (Iface_Typ, Tag_Typ)"}, {"sha": "91344a0ed8cf822c9f908f02fcfd5a9bb1a2c1a3", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -145,6 +145,9 @@ package body GNAT.Perfect_Hash_Generators is\n    --  Return a string which includes string Str or integer Int preceded by\n    --  leading spaces if required by width W.\n \n+   function Trim_Trailing_Nuls (Str : String) return String;\n+   --  Return Str, but with trailing NUL characters removed.\n+\n    Output : File_Descriptor renames GNAT.OS_Lib.Standout;\n    --  Shortcuts\n \n@@ -524,6 +527,7 @@ package body GNAT.Perfect_Hash_Generators is\n    ---------\n \n    procedure Add (C : Character) is\n+      pragma Assert (C /= ASCII.NUL);\n    begin\n       Line (Last + 1) := C;\n       Last := Last + 1;\n@@ -536,6 +540,11 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Add (S : String) is\n       Len : constant Natural := S'Length;\n    begin\n+      for J in S'Range loop\n+         pragma Assert (S (J) /= ASCII.NUL);\n+         null;\n+      end loop;\n+\n       Line (Last + 1 .. Last + Len) := S;\n       Last := Last + Len;\n    end Add;\n@@ -1261,6 +1270,11 @@ package body GNAT.Perfect_Hash_Generators is\n          New_Line (Output);\n       end if;\n \n+      for J in Value'Range loop\n+         pragma Assert (Value (J) /= ASCII.NUL);\n+         null;\n+      end loop;\n+\n       WT.Set_Last (NK);\n       WT.Table (NK) := New_Word (Value);\n       NK := NK + 1;\n@@ -1726,6 +1740,11 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Put (File : File_Descriptor; Str : String) is\n       Len : constant Natural := Str'Length;\n    begin\n+      for J in Str'Range loop\n+         pragma Assert (Str (J) /= ASCII.NUL);\n+         null;\n+      end loop;\n+\n       if Write (File, Str'Address, Len) /= Len then\n          raise Program_Error;\n       end if;\n@@ -1768,13 +1787,12 @@ package body GNAT.Perfect_Hash_Generators is\n          Last := 0;\n       end if;\n \n-      if Last + Len + 3 > Max then\n+      if Last + Len + 3 >= Max then\n          Flush;\n       end if;\n \n       if Last = 0 then\n-         Line (Last + 1 .. Last + 5) := \"     \";\n-         Last := Last + 5;\n+         Add (\"     \");\n \n          if F1 <= L1 then\n             if C1 = F1 and then C2 = F2 then\n@@ -1801,8 +1819,7 @@ package body GNAT.Perfect_Hash_Generators is\n          Add (' ');\n       end if;\n \n-      Line (Last + 1 .. Last + Len) := S;\n-      Last := Last + Len;\n+      Add (S);\n \n       if C2 = L2 then\n          Add (')');\n@@ -1869,7 +1886,8 @@ package body GNAT.Perfect_Hash_Generators is\n          K := Get_Key (J);\n          Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n          Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, WT.Table (Initial (J)).all, F1, L1, J, 1, 3, 3);\n+         Put (File, Trim_Trailing_Nuls (WT.Table (Initial (J)).all),\n+                    F1, L1, J, 1, 3, 3);\n       end loop;\n    end Put_Initial_Keys;\n \n@@ -1950,7 +1968,8 @@ package body GNAT.Perfect_Hash_Generators is\n          K := Get_Key (J);\n          Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n          Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, WT.Table (Reduced (J)).all, F1, L1, J, 1, 3, 3);\n+         Put (File, Trim_Trailing_Nuls (WT.Table (Reduced (J)).all),\n+                    F1, L1, J, 1, 3, 3);\n       end loop;\n    end Put_Reduced_Keys;\n \n@@ -2337,7 +2356,8 @@ package body GNAT.Perfect_Hash_Generators is\n                     Same_Keys_Sets_Table (J).First ..\n                     Same_Keys_Sets_Table (J).Last\n                   loop\n-                     Put (Output, WT.Table (Reduced (K)).all);\n+                     Put (Output,\n+                          Trim_Trailing_Nuls (WT.Table (Reduced (K)).all));\n                      New_Line (Output);\n                   end loop;\n                   Put (Output, \"--\");\n@@ -2488,6 +2508,20 @@ package body GNAT.Perfect_Hash_Generators is\n       return S;\n    end Sum;\n \n+   ------------------------\n+   -- Trim_Trailing_Nuls --\n+   ------------------------\n+\n+   function Trim_Trailing_Nuls (Str : String) return String is\n+   begin\n+      for J in Str'Range loop\n+         if Str (J) = ASCII.NUL then\n+            return Str (Str'First .. J - 1);\n+         end if;\n+      end loop;\n+      return Str;\n+   end Trim_Trailing_Nuls;\n+\n    ---------------\n    -- Type_Size --\n    ---------------"}, {"sha": "63a5b90093054224ea256e24721699eafa54e04e", "filename": "gcc/ada/g-pehage.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.ads?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -116,7 +116,7 @@ package GNAT.Perfect_Hash_Generators is\n    --  Deallocate the internal structures and the words table\n \n    procedure Insert (Value : String);\n-   --  Insert a new word in the table\n+   --  Insert a new word into the table. ASCII.NUL characters are not allowed.\n \n    Too_Many_Tries : exception;\n    --  Raised after Tries unsuccessful runs"}, {"sha": "a786e2fe6e8d046d6304989b1cb6f97a63d204bf", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -11909,6 +11909,13 @@ Do not look for sources in the system default directory.\n @cindex @option{-nostdlib} (@command{gnatxref})\n Do not look for library files in the system default directory.\n \n+@item --ext=@var{extension}\n+@cindex @option{--ext} (@command{gnatxref})\n+Specify an alternate ali file extension. The default is @code{ali} and other\n+extensions (e.g. @code{sli} for SPARK library files) may be specified via this\n+switch. Note that if this switch overrides the default, which means that only\n+the new extension will be considered.\n+\n @item --RTS=@var{rts-path}\n @cindex @option{--RTS} (@command{gnatxref})\n Specifies the default location of the runtime library. Same meaning as the"}, {"sha": "c20ef1755647db4ebb022b54932e520d5a0a2933", "filename": "gcc/ada/gnatxref.adb", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fgnatxref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fgnatxref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatxref.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,6 +52,9 @@ procedure Gnatxref is\n    RTS_Specified : String_Access := null;\n    --  Used to detect multiple use of --RTS= switch\n \n+   EXT_Specified : String_Access := null;\n+   --  Used to detect multiple use of --ext= switch\n+\n    procedure Parse_Cmd_Line;\n    --  Parse every switch on the command line\n \n@@ -79,7 +82,7 @@ procedure Gnatxref is\n       loop\n          case\n            GNAT.Command_Line.Getopt\n-             (\"a aI: aO: d f g h I: nostdinc nostdlib p: u v -RTS=\")\n+             (\"a aI: aO: d f g h I: nostdinc nostdlib p: u v -RTS= -ext=\")\n          is\n             when ASCII.NUL =>\n                exit;\n@@ -140,43 +143,70 @@ procedure Gnatxref is\n \n                --  Check that it is the first time we see this switch\n \n-               if RTS_Specified = null then\n-                  RTS_Specified := new String'(GNAT.Command_Line.Parameter);\n+               if Full_Switch = \"-RTS\" then\n+                  if RTS_Specified = null then\n+                     RTS_Specified := new String'(GNAT.Command_Line.Parameter);\n \n-               elsif RTS_Specified.all /= GNAT.Command_Line.Parameter then\n-                  Osint.Fail (\"--RTS cannot be specified multiple times\");\n-               end if;\n+                  elsif RTS_Specified.all /= GNAT.Command_Line.Parameter then\n+                     Osint.Fail (\"--RTS cannot be specified multiple times\");\n+                  end if;\n \n-               Opt.No_Stdinc  := True;\n-               Opt.RTS_Switch := True;\n+                  Opt.No_Stdinc  := True;\n+                  Opt.RTS_Switch := True;\n \n-               declare\n-                  Src_Path_Name : constant String_Ptr :=\n-                                    Get_RTS_Search_Dir\n-                                      (GNAT.Command_Line.Parameter, Include);\n+                  declare\n+                     Src_Path_Name : constant String_Ptr :=\n+                                       Get_RTS_Search_Dir\n+                                         (GNAT.Command_Line.Parameter,\n+                                          Include);\n \n-                  Lib_Path_Name : constant String_Ptr :=\n-                                    Get_RTS_Search_Dir\n-                                      (GNAT.Command_Line.Parameter, Objects);\n+                     Lib_Path_Name : constant String_Ptr :=\n+                                       Get_RTS_Search_Dir\n+                                         (GNAT.Command_Line.Parameter,\n+                                          Objects);\n \n-               begin\n-                  if Src_Path_Name /= null and then Lib_Path_Name /= null then\n-                     Add_Search_Dirs (Src_Path_Name, Include);\n-                     Add_Search_Dirs (Lib_Path_Name, Objects);\n+                  begin\n+                     if Src_Path_Name /= null\n+                       and then Lib_Path_Name /= null\n+                     then\n+                        Add_Search_Dirs (Src_Path_Name, Include);\n+                        Add_Search_Dirs (Lib_Path_Name, Objects);\n+\n+                     elsif Src_Path_Name = null\n+                       and then Lib_Path_Name = null\n+                     then\n+                        Osint.Fail (\"RTS path not valid: missing \" &\n+                                    \"adainclude and adalib directories\");\n+\n+                     elsif Src_Path_Name = null then\n+                        Osint.Fail (\"RTS path not valid: missing \" &\n+                                    \"adainclude directory\");\n \n-                  elsif Src_Path_Name = null and then Lib_Path_Name = null then\n-                     Osint.Fail (\"RTS path not valid: missing \" &\n-                                 \"adainclude and adalib directories\");\n+                     elsif  Lib_Path_Name = null then\n+                        Osint.Fail (\"RTS path not valid: missing \" &\n+                                    \"adalib directory\");\n+                     end if;\n+                  end;\n \n-                  elsif Src_Path_Name = null then\n-                     Osint.Fail (\"RTS path not valid: missing \" &\n-                                 \"adainclude directory\");\n+               elsif GNAT.Command_Line.Full_Switch = \"-ext\" then\n \n-                  elsif  Lib_Path_Name = null then\n-                     Osint.Fail (\"RTS path not valid: missing \" &\n-                                 \"adalib directory\");\n+                  --  Check that it is the first time we see this switch\n+\n+                  if EXT_Specified = null then\n+                     EXT_Specified := new String'(GNAT.Command_Line.Parameter);\n+\n+                  elsif EXT_Specified.all /= GNAT.Command_Line.Parameter then\n+                     Osint.Fail (\"--ext cannot be specified multiple times\");\n                   end if;\n-               end;\n+\n+                  if EXT_Specified'Length\n+                    = Osint.ALI_Default_Suffix'Length\n+                  then\n+                     Osint.ALI_Suffix := EXT_Specified.all'Access;\n+                  else\n+                     Osint.Fail (\"--ext argument must have 3 characters\");\n+                  end if;\n+               end if;\n \n             when others =>\n                Write_Usage;\n@@ -239,6 +269,7 @@ procedure Gnatxref is\n                 & \" directory\");\n       Put_Line (\"   -nostdlib Don't look for library files in the system\"\n                 & \" default directory\");\n+      Put_Line (\"   --ext=xxx Specify alternate ali file extension\");\n       Put_Line (\"   --RTS=dir specify the default source and object search\"\n                 & \" path\");\n       Put_Line (\"   -p file   Use file as the default project file\");"}, {"sha": "8b5fd1313dad31eda0e53a102727fcf4f33fadd0", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -5633,10 +5633,10 @@ package body Sem_Attr is\n             while Present (N) loop\n                Static := Static and then Is_Static_Subtype (Etype (N));\n \n-               --  If however the index type is generic, attributes cannot\n-               --  be folded.\n+               --  If however the index type is generic, or derived from\n+               --  one, attributes cannot be folded.\n \n-               if Is_Generic_Type (Etype (N))\n+               if Is_Generic_Type (Root_Type (Etype (N)))\n                  and then Id /= Attribute_Component_Size\n                then\n                   return;\n@@ -6205,13 +6205,13 @@ package body Sem_Attr is\n          Ind : Node_Id;\n \n       begin\n-         --  In the case of a generic index type, the bounds may appear static\n-         --  but the computation is not meaningful in this case, and may\n-         --  generate a spurious warning.\n+         --  If any index type is a formal type, or derived from one, the\n+         --  bounds are not static. Treating them as static can produce\n+         --  spurious warnings or improper constant folding.\n \n          Ind := First_Index (P_Type);\n          while Present (Ind) loop\n-            if Is_Generic_Type (Etype (Ind)) then\n+            if Is_Generic_Type (Root_Type (Etype (Ind))) then\n                return;\n             end if;\n "}, {"sha": "cf151e9d721fd7de030541ec552148b25230b78d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -2366,14 +2366,22 @@ package body Sem_Ch13 is\n       --  code because their main purpose was to provide support to initialize\n       --  the secondary dispatch tables. They are now generated also when\n       --  compiling with no code generation to provide ASIS the relationship\n-      --  between interface primitives and tagged type primitives.\n+      --  between interface primitives and tagged type primitives. They are\n+      --  also used to locate primitives covering interfaces when processing\n+      --  generics (see Derive_Subprograms).\n \n       if Ada_Version >= Ada_05\n         and then Ekind (E) = E_Record_Type\n         and then Is_Tagged_Type (E)\n         and then not Is_Interface (E)\n         and then Has_Interfaces (E)\n       then\n+         --  This would be a good common place to call the routine that checks\n+         --  overriding of interface primitives (and thus factorize calls to\n+         --  Check_Abstract_Overriding located at different contexts in the\n+         --  compiler). However, this is not possible because it causes\n+         --  spurious errors in case of late overriding.\n+\n          Add_Internal_Interface_Entities (E);\n       end if;\n    end Analyze_Freeze_Entity;"}, {"sha": "37856403451cd87daa7e9aa66cedf983792fe199", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 155, "deletions": 79, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -68,6 +68,7 @@ with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n@@ -1537,90 +1538,92 @@ package body Sem_Ch3 is\n       while Present (Iface_Elmt) loop\n          Iface := Node (Iface_Elmt);\n \n-         --  Exclude from this processing interfaces that are parents of\n-         --  Tagged_Type because their primitives are located in the primary\n-         --  dispatch table (and hence no auxiliary internal entities are\n-         --  required to handle secondary dispatch tables in such case).\n+         --  Originally we excluded here from this processing interfaces that\n+         --  are parents of Tagged_Type because their primitives are located\n+         --  in the primary dispatch table (and hence no auxiliary internal\n+         --  entities are required to handle secondary dispatch tables in such\n+         --  case). However, these auxiliary entities are also required to\n+         --  handle derivations of interfaces in formals of generics (see\n+         --  Derive_Subprograms).\n \n-         if not Is_Ancestor (Iface, Tagged_Type) then\n-            Elmt := First_Elmt (Primitive_Operations (Iface));\n-            while Present (Elmt) loop\n-               Iface_Prim := Node (Elmt);\n+         Elmt := First_Elmt (Primitive_Operations (Iface));\n+         while Present (Elmt) loop\n+            Iface_Prim := Node (Elmt);\n \n-               if not Is_Predefined_Dispatching_Operation (Iface_Prim) then\n-                  Prim :=\n-                    Find_Primitive_Covering_Interface\n-                      (Tagged_Type => Tagged_Type,\n-                       Iface_Prim  => Iface_Prim);\n+            if not Is_Predefined_Dispatching_Operation (Iface_Prim) then\n+               Prim :=\n+                 Find_Primitive_Covering_Interface\n+                   (Tagged_Type => Tagged_Type,\n+                    Iface_Prim  => Iface_Prim);\n \n-                  if No (Prim) then\n+               if No (Prim) then\n \n-                     --  In some rare cases, a name conflict may have kept the\n-                     --  operation completely hidden. Look for it in the list\n-                     --  of primitive operations of the type.\n+                  --  In some rare cases, a name conflict may have kept the\n+                  --  operation completely hidden. Look for it in the list\n+                  --  of primitive operations of the type.\n \n-                     declare\n-                        El : Elmt_Id;\n-                     begin\n-                        El := First_Elmt (Primitive_Operations (Tagged_Type));\n-                        while Present (El) loop\n-                           Prim := Node (El);\n-                           exit when Is_Subprogram (Prim)\n-                             and then Alias (Prim) = Iface_Prim;\n-                           Next_Elmt (El);\n-                        end loop;\n+                  declare\n+                     El : Elmt_Id;\n \n-                        --  If the operation was not explicitly overridden, it\n-                        --  should have been inherited as an abstract operation\n-                        --  so Prim can not be Empty at this stage.\n+                  begin\n+                     El := First_Elmt (Primitive_Operations (Tagged_Type));\n+                     while Present (El) loop\n+                        Prim := Node (El);\n+                        exit when Is_Subprogram (Prim)\n+                          and then Alias (Prim) = Iface_Prim;\n+                        Next_Elmt (El);\n+                     end loop;\n \n-                        if No (El) then\n-                           raise Program_Error;\n-                        end if;\n-                     end;\n-                  end if;\n+                     --  If the operation was not explicitly overridden, it\n+                     --  should have been inherited as an abstract operation\n+                     --  so Prim can not be Empty at this stage.\n \n-                  Derive_Subprogram\n-                    (New_Subp     => New_Subp,\n-                     Parent_Subp  => Iface_Prim,\n-                     Derived_Type => Tagged_Type,\n-                     Parent_Type  => Iface);\n-\n-                  --  Ada 2005 (AI-251): Decorate internal entity Iface_Subp\n-                  --  associated with interface types. These entities are\n-                  --  only registered in the list of primitives of its\n-                  --  corresponding tagged type because they are only used\n-                  --  to fill the contents of the secondary dispatch tables.\n-                  --  Therefore they are removed from the homonym chains.\n-\n-                  Set_Is_Hidden (New_Subp);\n-                  Set_Is_Internal (New_Subp);\n-                  Set_Alias (New_Subp, Prim);\n-                  Set_Is_Abstract_Subprogram (New_Subp,\n-                    Is_Abstract_Subprogram (Prim));\n-                  Set_Interface_Alias (New_Subp, Iface_Prim);\n-\n-                  --  Internal entities associated with interface types are\n-                  --  only registered in the list of primitives of the tagged\n-                  --  type. They are only used to fill the contents of the\n-                  --  secondary dispatch tables. Therefore they are not needed\n-                  --  in the homonym chains.\n-\n-                  Remove_Homonym (New_Subp);\n-\n-                  --  Hidden entities associated with interfaces must have set\n-                  --  the Has_Delay_Freeze attribute to ensure that, in case of\n-                  --  locally defined tagged types (or compiling with static\n-                  --  dispatch tables generation disabled) the corresponding\n-                  --  entry of the secondary dispatch table is filled when\n-                  --  such an entity is frozen.\n-\n-                  Set_Has_Delayed_Freeze (New_Subp);\n+                     if No (El) then\n+                        raise Program_Error;\n+                     end if;\n+                  end;\n                end if;\n \n-               Next_Elmt (Elmt);\n-            end loop;\n-         end if;\n+               Derive_Subprogram\n+                 (New_Subp     => New_Subp,\n+                  Parent_Subp  => Iface_Prim,\n+                  Derived_Type => Tagged_Type,\n+                  Parent_Type  => Iface);\n+\n+               --  Ada 2005 (AI-251): Decorate internal entity Iface_Subp\n+               --  associated with interface types. These entities are\n+               --  only registered in the list of primitives of its\n+               --  corresponding tagged type because they are only used\n+               --  to fill the contents of the secondary dispatch tables.\n+               --  Therefore they are removed from the homonym chains.\n+\n+               Set_Is_Hidden (New_Subp);\n+               Set_Is_Internal (New_Subp);\n+               Set_Alias (New_Subp, Prim);\n+               Set_Is_Abstract_Subprogram\n+                 (New_Subp, Is_Abstract_Subprogram (Prim));\n+               Set_Interface_Alias (New_Subp, Iface_Prim);\n+\n+               --  Internal entities associated with interface types are\n+               --  only registered in the list of primitives of the tagged\n+               --  type. They are only used to fill the contents of the\n+               --  secondary dispatch tables. Therefore they are not needed\n+               --  in the homonym chains.\n+\n+               Remove_Homonym (New_Subp);\n+\n+               --  Hidden entities associated with interfaces must have set\n+               --  the Has_Delay_Freeze attribute to ensure that, in case of\n+               --  locally defined tagged types (or compiling with static\n+               --  dispatch tables generation disabled) the corresponding\n+               --  entry of the secondary dispatch table is filled when\n+               --  such an entity is frozen.\n+\n+               Set_Has_Delayed_Freeze (New_Subp);\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n \n          Next_Elmt (Iface_Elmt);\n       end loop;\n@@ -11955,7 +11958,7 @@ package body Sem_Ch3 is\n       --  non-abstract tagged types that can reference abstract primitives\n       --  through its Alias attribute are the internal entities that have\n       --  attribute Interface_Alias, and these entities are generated later\n-      --  by Freeze_Record_Type).\n+      --  by Add_Internal_Interface_Entities).\n \n       if In_Private_Part (Current_Scope)\n         and then Is_Abstract_Type (Parent_Type)\n@@ -12734,6 +12737,12 @@ package body Sem_Ch3 is\n             --  corresponding operations of the actual.\n \n             else\n+               pragma Assert (No (Node (Act_Elmt))\n+                 or else (Primitive_Names_Match (Subp, Node (Act_Elmt))\n+                            and then\n+                          Type_Conformant (Subp, Node (Act_Elmt),\n+                                           Skip_Controlling_Formals => True)));\n+\n                Derive_Subprogram\n                  (New_Subp, Subp, Derived_Type, Parent_Base, Node (Act_Elmt));\n \n@@ -12839,7 +12848,11 @@ package body Sem_Ch3 is\n               or else\n                 (Present (Generic_Actual)\n                   and then Present (Act_Subp)\n-                  and then not Primitive_Names_Match (Subp, Act_Subp))\n+                  and then not\n+                    (Primitive_Names_Match (Subp, Act_Subp)\n+                       and then\n+                     Type_Conformant (Subp, Act_Subp,\n+                                      Skip_Controlling_Formals => True)))\n             then\n                pragma Assert (not Is_Ancestor (Parent_Base, Generic_Actual));\n \n@@ -12849,14 +12862,73 @@ package body Sem_Ch3 is\n \n                --  Handle entities associated with interface primitives\n \n-               if Present (Alias (Subp))\n-                 and then Is_Interface (Find_Dispatching_Type (Alias (Subp)))\n+               if Present (Alias_Subp)\n+                 and then Is_Interface (Find_Dispatching_Type (Alias_Subp))\n                  and then not Is_Predefined_Dispatching_Operation (Subp)\n                then\n+                  --  Search for the primitive in the homonym chain\n+\n                   Act_Subp :=\n                     Find_Primitive_Covering_Interface\n                       (Tagged_Type => Generic_Actual,\n-                       Iface_Prim  => Subp);\n+                       Iface_Prim  => Alias_Subp);\n+\n+                  --  Previous search may not locate primitives covering\n+                  --  interfaces defined in generics units or instantiations.\n+                  --  (it fails if the covering primitive has formals whose\n+                  --  type is also defined in generics or instantiations).\n+                  --  In such case we search in the list of primitives of the\n+                  --  generic actual for the internal entity that links the\n+                  --  interface primitive and the covering primitive.\n+\n+                  if No (Act_Subp)\n+                    and then Is_Generic_Type (Parent_Type)\n+                  then\n+                     --  This code has been designed to handle only generic\n+                     --  formals that implement interfaces that are defined\n+                     --  in a generic unit or instantiation. If this code is\n+                     --  needed for other cases we must review it because\n+                     --  (given that it relies on Original_Location to locate\n+                     --  the primitive of Generic_Actual that covers the\n+                     --  interface) it could leave linked through attribute\n+                     --  Alias entities of unrelated instantiations).\n+\n+                     pragma Assert\n+                       (Is_Generic_Unit\n+                          (Scope (Find_Dispatching_Type (Alias_Subp)))\n+                       or else\n+                        Instantiation_Depth\n+                          (Sloc (Find_Dispatching_Type (Alias_Subp))) > 0);\n+\n+                     declare\n+                        Iface_Prim_Loc : constant Source_Ptr :=\n+                                         Original_Location (Sloc (Alias_Subp));\n+                        Elmt      : Elmt_Id;\n+                        Prim      : Entity_Id;\n+                     begin\n+                        Elmt :=\n+                          First_Elmt (Primitive_Operations (Generic_Actual));\n+\n+                        Search : while Present (Elmt) loop\n+                           Prim := Node (Elmt);\n+\n+                           if Present (Interface_Alias (Prim))\n+                             and then Original_Location\n+                                        (Sloc (Interface_Alias (Prim)))\n+                                       = Iface_Prim_Loc\n+                           then\n+                              Act_Subp := Alias (Prim);\n+                              exit Search;\n+                           end if;\n+\n+                           Next_Elmt (Elmt);\n+                        end loop Search;\n+                     end;\n+                  end if;\n+\n+                  pragma Assert (Present (Act_Subp)\n+                    or else Is_Abstract_Type (Generic_Actual)\n+                    or else Serious_Errors_Detected > 0);\n \n                --  Handle predefined primitives plus the rest of user-defined\n                --  primitives\n@@ -12874,6 +12946,10 @@ package body Sem_Ch3 is\n \n                      Next_Elmt (Act_Elmt);\n                   end loop;\n+\n+                  if No (Act_Elmt) then\n+                     Act_Subp := Empty;\n+                  end if;\n                end if;\n             end if;\n "}, {"sha": "7121b67832ead3bc3bbd7043232f04fec05ddfba", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -4568,7 +4568,7 @@ package body Sem_Ch6 is\n \n             elsif Must_Override (Spec) then\n                if Is_Overriding_Operation (Subp) then\n-                  Set_Is_Overriding_Operation (Subp);\n+                  null;\n \n                elsif not Can_Override then\n                   Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n@@ -6477,8 +6477,8 @@ package body Sem_Ch6 is\n         or else Etype (Prim) = Etype (Iface_Prim)\n         or else not Has_Controlling_Result (Prim)\n       then\n-         return Type_Conformant (Prim, Iface_Prim,\n-                  Skip_Controlling_Formals => True);\n+         return Type_Conformant\n+                  (Iface_Prim, Prim, Skip_Controlling_Formals => True);\n \n       --  Case of a function returning an interface, or an access to one.\n       --  Check that the return types correspond."}, {"sha": "f96b45b17549ebec911cf042f1b62b2d91e66e5b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b4d7b435e067d9f3df49ee3ed0a5cf4d6b09f8e8", "patch": "@@ -4497,15 +4497,13 @@ package body Sem_Util is\n      (T             : Entity_Id;\n       Use_Full_View : Boolean := True) return Boolean\n    is\n-      Typ : Entity_Id;\n+      Typ : Entity_Id := Base_Type (T);\n \n    begin\n       --  Handle concurrent types\n \n-      if Is_Concurrent_Type (T) then\n-         Typ := Corresponding_Record_Type (T);\n-      else\n-         Typ := T;\n+      if Is_Concurrent_Type (Typ) then\n+         Typ := Corresponding_Record_Type (Typ);\n       end if;\n \n       if not Present (Typ)"}]}