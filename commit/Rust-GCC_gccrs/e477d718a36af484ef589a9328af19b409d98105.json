{"sha": "e477d718a36af484ef589a9328af19b409d98105", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ3N2Q3MThhMzZhZjQ4NGVmNTg5YTkzMjhhZjE5YjQwOWQ5ODEwNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T09:59:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T09:59:56Z"}, "message": "[multiple changes]\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* prj-strt.adb, prj-strt.ads, sem_attr.adb: Minor reformatting.\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb Add an entry in table Canonical_Aspect for\n\tDefault_Initial_Condition.\n\t* aspects.ads Add an entry in tables Aspect_Id, Aspect_Argument,\n\tAspect_Names and Aspect_Delay for Default_Initial_Condition.\n\t* einfo.adb Flag3 is now Has_Default_Init_Cond. Flag132\n\tis now Is_Default_Init_Cond_ Procedure. Flag133 is now\n\tHas_Inherited_Default_Init_Cond.\n\t(Default_Init_Cond_Procedure): New routine.\n\t(Has_Default_Init_Cond): New routine.\n\t(Has_Inherited_Default_Init_Cond): New routine.\n\t(Is_Default_Init_Cond_Procedure): New routine.\n\t(Set_Default_Init_Cond_Procedure): New routine.\n\t(Set_Has_Default_Init_Cond): New routine.\n\t(Set_Has_Inherited_Default_Init_Cond): New routine.\n\t(Set_Is_Default_Init_Cond_Procedure): New routine.\n\t(Write_Entity_Flags): Output all the new flags.\n\t* einfo.ads New attributes Default_Init_Cond_Procedure,\n\tHas_Inherited_Default_Init_Cond and Is_Default_Init_Cond_Procedure\n\talong with usage in nodes.\n\t(Default_Init_Cond_Procedure): New routine.\n\t(Has_Default_Init_Cond): New routine and pragma Inline.\n\t(Has_Inherited_Default_Init_Cond): New routine and\n\tpragma Inline.\n\t(Is_Default_Init_Cond_Procedure): New routine and\n\tpragma Inline.\n\t(Set_Default_Init_Cond_Procedure): New routine.\n\t(Set_Has_Default_Init_Cond): New routine and pragma Inline.\n\t(Set_Has_Inherited_Default_Init_Cond): New routine and pragma Inline.\n\t(Set_Is_Default_Init_Cond_Procedure): New routine and pragma Inline.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): New constant\n\tNext_N. Generate a call to the default initial condition procedure\n\tif the object's type is subject to the pragma.\t(Freeze_Type):\n\tGenerate the body of the default initial condition procedure or\n\tinherit the spec from a parent type.\n\t* exp_ch7.adb Add with and use clause for Exp_Prag.\n\t(Expand_Pragma_Initial_Condition): Removed.\n\t* exp_prag.ads, exp_prag.adb (Expand_Pragma_Initial_Condition): New\n\troutine.\n\t* par-prag.adb (Prag): Pragma Default_Initial_Condition does\n\tnot need special treatment by the parser.\n\t* sem_ch3.adb (Build_Derived_Record_Type): Propagate the\n\tattributes related to pragma Default_Initial_Condition to the\n\tderived type.\n\t(Process_Full_View): Propagate the attributes\n\trelated to pragma Default_Initial_Condition to the full view.\n\t* sem_ch7.adb (Analyze_Package_Specification): Build the\n\tdeclaration of the default initial condition procedure for all\n\ttypes that qualify or inherit the one from the parent type.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tAdd processing for aspect Default_Initial_Condition.\n\t(Check_Aspect_At_Freeze_Point): Aspect\n\tDefault_Initial_Condition does not require delayed analysis.\n\t(Replace_Type_References_Generic): Moved to spec.\n\t* sem_ch13.ads (Replace_Type_References_Generic): Moved from body.\n\t* sem_prag.adb Add an entry in table Sif_Glags for\n\tDefault_Initial_Condition.\n\t(Analyze_Pragma): Pragma\n\tDefault_Initial_Condition is now part of assertion\n\tpolicy. Add processing for pragma Default_Initial_Condition.\n\t(Is_Valid_Assertion_Kind): Pragma Default_Initial_Condition is\n\tnow recognized as a proper assertion policy.\n\t* sem_util.ads, sem_util.adb (Build_Default_Init_Cond_Call): New\n\troutine.\n\t(Build_Default_Init_Cond_Procedure_Body): New routine.\n\t(Build_Default_Init_Cond_Procedure_Declaration): New routine.\n\t(Inherit_Default_Init_Cond_Procedure): New routine.\n\t* snames.ads-tmpl Add new predefined name and pragma id for\n\tDefault_Initial_Condition.\n\nFrom-SVN: r213552", "tree": {"sha": "07e0788cedddd16403f58e25a7894f5ecbc3c505", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07e0788cedddd16403f58e25a7894f5ecbc3c505"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e477d718a36af484ef589a9328af19b409d98105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e477d718a36af484ef589a9328af19b409d98105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e477d718a36af484ef589a9328af19b409d98105", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e477d718a36af484ef589a9328af19b409d98105/comments", "author": null, "committer": null, "parents": [{"sha": "dc549f34cb94f69b00296c45517a97e6de57ecba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc549f34cb94f69b00296c45517a97e6de57ecba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc549f34cb94f69b00296c45517a97e6de57ecba"}], "stats": {"total": 1413, "additions": 1019, "deletions": 394}, "files": [{"sha": "7659de4d35fecbbc5b9e1181b314f06c9d84ff6f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -1,3 +1,78 @@\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* prj-strt.adb, prj-strt.ads, sem_attr.adb: Minor reformatting.\n+\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb Add an entry in table Canonical_Aspect for\n+\tDefault_Initial_Condition.\n+\t* aspects.ads Add an entry in tables Aspect_Id, Aspect_Argument,\n+\tAspect_Names and Aspect_Delay for Default_Initial_Condition.\n+\t* einfo.adb Flag3 is now Has_Default_Init_Cond. Flag132\n+\tis now Is_Default_Init_Cond_ Procedure. Flag133 is now\n+\tHas_Inherited_Default_Init_Cond.\n+\t(Default_Init_Cond_Procedure): New routine.\n+\t(Has_Default_Init_Cond): New routine.\n+\t(Has_Inherited_Default_Init_Cond): New routine.\n+\t(Is_Default_Init_Cond_Procedure): New routine.\n+\t(Set_Default_Init_Cond_Procedure): New routine.\n+\t(Set_Has_Default_Init_Cond): New routine.\n+\t(Set_Has_Inherited_Default_Init_Cond): New routine.\n+\t(Set_Is_Default_Init_Cond_Procedure): New routine.\n+\t(Write_Entity_Flags): Output all the new flags.\n+\t* einfo.ads New attributes Default_Init_Cond_Procedure,\n+\tHas_Inherited_Default_Init_Cond and Is_Default_Init_Cond_Procedure\n+\talong with usage in nodes.\n+\t(Default_Init_Cond_Procedure): New routine.\n+\t(Has_Default_Init_Cond): New routine and pragma Inline.\n+\t(Has_Inherited_Default_Init_Cond): New routine and\n+\tpragma Inline.\n+\t(Is_Default_Init_Cond_Procedure): New routine and\n+\tpragma Inline.\n+\t(Set_Default_Init_Cond_Procedure): New routine.\n+\t(Set_Has_Default_Init_Cond): New routine and pragma Inline.\n+\t(Set_Has_Inherited_Default_Init_Cond): New routine and pragma Inline.\n+\t(Set_Is_Default_Init_Cond_Procedure): New routine and pragma Inline.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): New constant\n+\tNext_N. Generate a call to the default initial condition procedure\n+\tif the object's type is subject to the pragma.\t(Freeze_Type):\n+\tGenerate the body of the default initial condition procedure or\n+\tinherit the spec from a parent type.\n+\t* exp_ch7.adb Add with and use clause for Exp_Prag.\n+\t(Expand_Pragma_Initial_Condition): Removed.\n+\t* exp_prag.ads, exp_prag.adb (Expand_Pragma_Initial_Condition): New\n+\troutine.\n+\t* par-prag.adb (Prag): Pragma Default_Initial_Condition does\n+\tnot need special treatment by the parser.\n+\t* sem_ch3.adb (Build_Derived_Record_Type): Propagate the\n+\tattributes related to pragma Default_Initial_Condition to the\n+\tderived type.\n+\t(Process_Full_View): Propagate the attributes\n+\trelated to pragma Default_Initial_Condition to the full view.\n+\t* sem_ch7.adb (Analyze_Package_Specification): Build the\n+\tdeclaration of the default initial condition procedure for all\n+\ttypes that qualify or inherit the one from the parent type.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tAdd processing for aspect Default_Initial_Condition.\n+\t(Check_Aspect_At_Freeze_Point): Aspect\n+\tDefault_Initial_Condition does not require delayed analysis.\n+\t(Replace_Type_References_Generic): Moved to spec.\n+\t* sem_ch13.ads (Replace_Type_References_Generic): Moved from body.\n+\t* sem_prag.adb Add an entry in table Sif_Glags for\n+\tDefault_Initial_Condition.\n+\t(Analyze_Pragma): Pragma\n+\tDefault_Initial_Condition is now part of assertion\n+\tpolicy. Add processing for pragma Default_Initial_Condition.\n+\t(Is_Valid_Assertion_Kind): Pragma Default_Initial_Condition is\n+\tnow recognized as a proper assertion policy.\n+\t* sem_util.ads, sem_util.adb (Build_Default_Init_Cond_Call): New\n+\troutine.\n+\t(Build_Default_Init_Cond_Procedure_Body): New routine.\n+\t(Build_Default_Init_Cond_Procedure_Declaration): New routine.\n+\t(Inherit_Default_Init_Cond_Procedure): New routine.\n+\t* snames.ads-tmpl Add new predefined name and pragma id for\n+\tDefault_Initial_Condition.\n+\n 2014-08-04  Vincent Celier  <celier@adacore.com>\n \n \t* prj-dect.adb (Parse_Case_Construction): It is no longer"}, {"sha": "b1e2e101104583626a36e13f74639687ab8cc16b", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -509,6 +509,7 @@ package body Aspects is\n     Aspect_Convention                   => Aspect_Convention,\n     Aspect_CPU                          => Aspect_CPU,\n     Aspect_Default_Component_Value      => Aspect_Default_Component_Value,\n+    Aspect_Default_Initial_Condition    => Aspect_Default_Initial_Condition,\n     Aspect_Default_Iterator             => Aspect_Default_Iterator,\n     Aspect_Default_Value                => Aspect_Default_Value,\n     Aspect_Depends                      => Aspect_Depends,"}, {"sha": "8e47172803a869edfb1b66e109fdb45b0790acb4", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 75, "deletions": 71, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -86,6 +86,7 @@ package Aspects is\n       Aspect_Convention,\n       Aspect_CPU,\n       Aspect_Default_Component_Value,\n+      Aspect_Default_Initial_Condition,     -- GNAT\n       Aspect_Default_Iterator,\n       Aspect_Default_Value,\n       Aspect_Depends,                       -- GNAT\n@@ -296,76 +297,77 @@ package Aspects is\n    --  The following array indicates what argument type is required\n \n    Aspect_Argument : constant array (Aspect_Id) of Aspect_Expression :=\n-     (No_Aspect                      => Optional_Expression,\n-      Aspect_Abstract_State          => Expression,\n-      Aspect_Address                 => Expression,\n-      Aspect_Alignment               => Expression,\n-      Aspect_Annotate                => Expression,\n-      Aspect_Attach_Handler          => Expression,\n-      Aspect_Bit_Order               => Expression,\n-      Aspect_Component_Size          => Expression,\n-      Aspect_Constant_Indexing       => Name,\n-      Aspect_Contract_Cases          => Expression,\n-      Aspect_Convention              => Name,\n-      Aspect_CPU                     => Expression,\n-      Aspect_Default_Component_Value => Expression,\n-      Aspect_Default_Iterator        => Name,\n-      Aspect_Default_Value           => Expression,\n-      Aspect_Depends                 => Expression,\n-      Aspect_Dimension               => Expression,\n-      Aspect_Dimension_System        => Expression,\n-      Aspect_Dispatching_Domain      => Expression,\n-      Aspect_Dynamic_Predicate       => Expression,\n-      Aspect_External_Name           => Expression,\n-      Aspect_External_Tag            => Expression,\n-      Aspect_Global                  => Expression,\n-      Aspect_Implicit_Dereference    => Name,\n-      Aspect_Initial_Condition       => Expression,\n-      Aspect_Initializes             => Expression,\n-      Aspect_Input                   => Name,\n-      Aspect_Interrupt_Priority      => Expression,\n-      Aspect_Invariant               => Expression,\n-      Aspect_Iterable                => Expression,\n-      Aspect_Iterator_Element        => Name,\n-      Aspect_Link_Name               => Expression,\n-      Aspect_Linker_Section          => Expression,\n-      Aspect_Machine_Radix           => Expression,\n-      Aspect_Object_Size             => Expression,\n-      Aspect_Output                  => Name,\n-      Aspect_Part_Of                 => Expression,\n-      Aspect_Post                    => Expression,\n-      Aspect_Postcondition           => Expression,\n-      Aspect_Pre                     => Expression,\n-      Aspect_Precondition            => Expression,\n-      Aspect_Predicate               => Expression,\n-      Aspect_Priority                => Expression,\n-      Aspect_Read                    => Name,\n-      Aspect_Refined_Depends         => Expression,\n-      Aspect_Refined_Global          => Expression,\n-      Aspect_Refined_Post            => Expression,\n-      Aspect_Refined_State           => Expression,\n-      Aspect_Relative_Deadline       => Expression,\n-      Aspect_Scalar_Storage_Order    => Expression,\n-      Aspect_Simple_Storage_Pool     => Name,\n-      Aspect_Size                    => Expression,\n-      Aspect_Small                   => Expression,\n-      Aspect_SPARK_Mode              => Optional_Name,\n-      Aspect_Static_Predicate        => Expression,\n-      Aspect_Storage_Pool            => Name,\n-      Aspect_Storage_Size            => Expression,\n-      Aspect_Stream_Size             => Expression,\n-      Aspect_Suppress                => Name,\n-      Aspect_Synchronization         => Name,\n-      Aspect_Test_Case               => Expression,\n-      Aspect_Type_Invariant          => Expression,\n-      Aspect_Unsuppress              => Name,\n-      Aspect_Value_Size              => Expression,\n-      Aspect_Variable_Indexing       => Name,\n-      Aspect_Warnings                => Name,\n-      Aspect_Write                   => Name,\n-\n-      Boolean_Aspects                => Optional_Expression,\n-      Library_Unit_Aspects           => Optional_Expression);\n+     (No_Aspect                        => Optional_Expression,\n+      Aspect_Abstract_State            => Expression,\n+      Aspect_Address                   => Expression,\n+      Aspect_Alignment                 => Expression,\n+      Aspect_Annotate                  => Expression,\n+      Aspect_Attach_Handler            => Expression,\n+      Aspect_Bit_Order                 => Expression,\n+      Aspect_Component_Size            => Expression,\n+      Aspect_Constant_Indexing         => Name,\n+      Aspect_Contract_Cases            => Expression,\n+      Aspect_Convention                => Name,\n+      Aspect_CPU                       => Expression,\n+      Aspect_Default_Component_Value   => Expression,\n+      Aspect_Default_Initial_Condition => Optional_Expression,\n+      Aspect_Default_Iterator          => Name,\n+      Aspect_Default_Value             => Expression,\n+      Aspect_Depends                   => Expression,\n+      Aspect_Dimension                 => Expression,\n+      Aspect_Dimension_System          => Expression,\n+      Aspect_Dispatching_Domain        => Expression,\n+      Aspect_Dynamic_Predicate         => Expression,\n+      Aspect_External_Name             => Expression,\n+      Aspect_External_Tag              => Expression,\n+      Aspect_Global                    => Expression,\n+      Aspect_Implicit_Dereference      => Name,\n+      Aspect_Initial_Condition         => Expression,\n+      Aspect_Initializes               => Expression,\n+      Aspect_Input                     => Name,\n+      Aspect_Interrupt_Priority        => Expression,\n+      Aspect_Invariant                 => Expression,\n+      Aspect_Iterable                  => Expression,\n+      Aspect_Iterator_Element          => Name,\n+      Aspect_Link_Name                 => Expression,\n+      Aspect_Linker_Section            => Expression,\n+      Aspect_Machine_Radix             => Expression,\n+      Aspect_Object_Size               => Expression,\n+      Aspect_Output                    => Name,\n+      Aspect_Part_Of                   => Expression,\n+      Aspect_Post                      => Expression,\n+      Aspect_Postcondition             => Expression,\n+      Aspect_Pre                       => Expression,\n+      Aspect_Precondition              => Expression,\n+      Aspect_Predicate                 => Expression,\n+      Aspect_Priority                  => Expression,\n+      Aspect_Read                      => Name,\n+      Aspect_Refined_Depends           => Expression,\n+      Aspect_Refined_Global            => Expression,\n+      Aspect_Refined_Post              => Expression,\n+      Aspect_Refined_State             => Expression,\n+      Aspect_Relative_Deadline         => Expression,\n+      Aspect_Scalar_Storage_Order      => Expression,\n+      Aspect_Simple_Storage_Pool       => Name,\n+      Aspect_Size                      => Expression,\n+      Aspect_Small                     => Expression,\n+      Aspect_SPARK_Mode                => Optional_Name,\n+      Aspect_Static_Predicate          => Expression,\n+      Aspect_Storage_Pool              => Name,\n+      Aspect_Storage_Size              => Expression,\n+      Aspect_Stream_Size               => Expression,\n+      Aspect_Suppress                  => Name,\n+      Aspect_Synchronization           => Name,\n+      Aspect_Test_Case                 => Expression,\n+      Aspect_Type_Invariant            => Expression,\n+      Aspect_Unsuppress                => Name,\n+      Aspect_Value_Size                => Expression,\n+      Aspect_Variable_Indexing         => Name,\n+      Aspect_Warnings                  => Name,\n+      Aspect_Write                     => Name,\n+\n+      Boolean_Aspects                  => Optional_Expression,\n+      Library_Unit_Aspects             => Optional_Expression);\n \n    -----------------------------------------\n    -- Table Linking Names and Aspect_Id's --\n@@ -392,9 +394,10 @@ package Aspects is\n       Aspect_Contract_Cases               => Name_Contract_Cases,\n       Aspect_Convention                   => Name_Convention,\n       Aspect_CPU                          => Name_CPU,\n+      Aspect_Default_Component_Value      => Name_Default_Component_Value,\n+      Aspect_Default_Initial_Condition    => Name_Default_Initial_Condition,\n       Aspect_Default_Iterator             => Name_Default_Iterator,\n       Aspect_Default_Value                => Name_Default_Value,\n-      Aspect_Default_Component_Value      => Name_Default_Component_Value,\n       Aspect_Depends                      => Name_Depends,\n       Aspect_Dimension                    => Name_Dimension,\n       Aspect_Dimension_System             => Name_Dimension_System,\n@@ -675,6 +678,7 @@ package Aspects is\n       Aspect_Async_Writers                => Never_Delay,\n       Aspect_Contract_Cases               => Never_Delay,\n       Aspect_Convention                   => Never_Delay,\n+      Aspect_Default_Initial_Condition    => Never_Delay,\n       Aspect_Depends                      => Never_Delay,\n       Aspect_Dimension                    => Never_Delay,\n       Aspect_Dimension_System             => Never_Delay,"}, {"sha": "76e5a6d67931526869dfa3da79c460c7783391ff", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 98, "deletions": 8, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -270,6 +270,7 @@ package body Einfo is\n \n    --    Is_Inlined_Always               Flag1\n    --    Is_Hidden_Non_Overridden_Subpgm Flag2\n+   --    Has_Default_Init_Cond           Flag3\n    --    Is_Frozen                       Flag4\n    --    Has_Discriminants               Flag5\n    --    Is_Dispatching_Operation        Flag6\n@@ -411,6 +412,8 @@ package body Einfo is\n    --    Is_Generic_Instance             Flag130\n \n    --    No_Pool_Assigned                Flag131\n+   --    Is_Default_Init_Cond_Procedure  Flag132\n+   --    Has_Inherited_Default_Init_Cond Flag133\n    --    Has_Aliased_Components          Flag135\n    --    No_Strict_Aliasing              Flag136\n    --    Is_Machine_Code_Subprogram      Flag137\n@@ -569,10 +572,6 @@ package body Einfo is\n    --    No_Predicate_On_Actual          Flag275\n    --    No_Dynamic_Predicate_On_Actual  Flag276\n \n-   --    (unused)                        Flag3\n-\n-   --    (unused)                        Flag132\n-   --    (unused)                        Flag133\n    --    (unused)                        Flag134\n \n    --    (unused)                        Flag275\n@@ -1394,6 +1393,11 @@ package body Einfo is\n       return Flag39 (Base_Type (Id));\n    end Has_Default_Aspect;\n \n+   function Has_Default_Init_Cond (Id : E) return B is\n+   begin\n+      return Flag3 (Id);\n+   end Has_Default_Init_Cond;\n+\n    function Has_Delayed_Aspects (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -1478,6 +1482,12 @@ package body Einfo is\n       return Flag248 (Id);\n    end Has_Inheritable_Invariants;\n \n+   function Has_Inherited_Default_Init_Cond (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag133 (Id);\n+   end Has_Inherited_Default_Init_Cond;\n+\n    function Has_Initial_Value (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable or else Is_Formal (Id));\n@@ -1975,6 +1985,12 @@ package body Einfo is\n       return Flag74 (Id);\n    end Is_CPP_Class;\n \n+   function Is_Default_Init_Cond_Procedure (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      return Flag132 (Id);\n+   end Is_Default_Init_Cond_Procedure;\n+\n    function Is_Descendent_Of_Address (Id : E) return B is\n    begin\n       return Flag223 (Id);\n@@ -2137,7 +2153,7 @@ package body Einfo is\n \n    function Is_Invariant_Procedure (Id : E) return B is\n    begin\n-      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n       return Flag257 (Id);\n    end Is_Invariant_Procedure;\n \n@@ -4140,6 +4156,12 @@ package body Einfo is\n       Set_Flag39 (Id, V);\n    end Set_Has_Default_Aspect;\n \n+   procedure Set_Has_Default_Init_Cond (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag3 (Id, V);\n+   end Set_Has_Default_Init_Cond;\n+\n    procedure Set_Has_Delayed_Aspects (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4226,6 +4248,12 @@ package body Einfo is\n       Set_Flag248 (Id, V);\n    end Set_Has_Inheritable_Invariants;\n \n+   procedure Set_Has_Inherited_Default_Init_Cond (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag133 (Id, V);\n+   end Set_Has_Inherited_Default_Init_Cond;\n+\n    procedure Set_Has_Initial_Value (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Variable, E_Out_Parameter));\n@@ -4748,6 +4776,12 @@ package body Einfo is\n       Set_Flag74 (Id, V);\n    end Set_Is_CPP_Class;\n \n+   procedure Set_Is_Default_Init_Cond_Procedure (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      Set_Flag132 (Id, V);\n+   end Set_Is_Default_Init_Cond_Procedure;\n+\n    procedure Set_Is_Descendent_Of_Address (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -4920,7 +4954,7 @@ package body Einfo is\n \n    procedure Set_Is_Invariant_Procedure (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind (Id) = E_Procedure);\n       Set_Flag257 (Id, V);\n    end Set_Is_Invariant_Procedure;\n \n@@ -6410,6 +6444,31 @@ package body Einfo is\n       end loop;\n    end Declaration_Node;\n \n+   ---------------------------------\n+   -- Default_Init_Cond_Procedure --\n+   ---------------------------------\n+\n+   function Default_Init_Cond_Procedure (Id : E) return E is\n+      S : Entity_Id;\n+\n+   begin\n+      pragma Assert\n+        (Is_Type (Id)\n+           and then (Has_Default_Init_Cond (Id)\n+                       or Has_Inherited_Default_Init_Cond (Id)));\n+\n+      S := Subprograms_For_Type (Id);\n+      while Present (S) loop\n+         if Is_Default_Init_Cond_Procedure (S) then\n+            return S;\n+         end if;\n+\n+         S := Subprograms_For_Type (S);\n+      end loop;\n+\n+      return Empty;\n+   end Default_Init_Cond_Procedure;\n+\n    ---------------------\n    -- Designated_Type --\n    ---------------------\n@@ -7913,6 +7972,34 @@ package body Einfo is\n       end case;\n    end Set_Component_Alignment;\n \n+   -------------------------------------\n+   -- Set_Default_Init_Cond_Procedure --\n+   -------------------------------------\n+\n+   procedure Set_Default_Init_Cond_Procedure (Id : E; V : E) is\n+      S : Entity_Id;\n+\n+   begin\n+      pragma Assert\n+        (Is_Type (Id)\n+           and then (Has_Default_Init_Cond (Id)\n+                       or Has_Inherited_Default_Init_Cond (Id)));\n+\n+      S := Subprograms_For_Type (Id);\n+      Set_Subprograms_For_Type (Id, V);\n+      Set_Subprograms_For_Type (V, S);\n+\n+      --  Check for a duplicate procedure\n+\n+      while Present (S) loop\n+         if Is_Default_Init_Cond_Procedure (S) then\n+            raise Program_Error;\n+         end if;\n+\n+         S := Subprograms_For_Type (S);\n+      end loop;\n+   end Set_Default_Init_Cond_Procedure;\n+\n    -----------------------------\n    -- Set_Invariant_Procedure --\n    -----------------------------\n@@ -8252,6 +8339,7 @@ package body Einfo is\n       W (\"Has_Controlling_Result\",          Flag98  (Id));\n       W (\"Has_Convention_Pragma\",           Flag119 (Id));\n       W (\"Has_Default_Aspect\",              Flag39  (Id));\n+      W (\"Has_Default_Init_Cond\",           Flag3   (Id));\n       W (\"Has_Delayed_Aspects\",             Flag200 (Id));\n       W (\"Has_Delayed_Freeze\",              Flag18  (Id));\n       W (\"Has_Delayed_Rep_Aspects\",         Flag261 (Id));\n@@ -8267,6 +8355,7 @@ package body Einfo is\n       W (\"Has_Implicit_Dereference\",        Flag251 (Id));\n       W (\"Has_Independent_Components\",      Flag34  (Id));\n       W (\"Has_Inheritable_Invariants\",      Flag248 (Id));\n+      W (\"Has_Inherited_Default_Init_Cond\", Flag133 (Id));\n       W (\"Has_Initial_Value\",               Flag219 (Id));\n       W (\"Has_Invariants\",                  Flag232 (Id));\n       W (\"Has_Loop_Entry_Attributes\",       Flag260 (Id));\n@@ -8327,8 +8416,7 @@ package body Einfo is\n       W (\"In_Private_Part\",                 Flag45  (Id));\n       W (\"In_Use\",                          Flag8   (Id));\n       W (\"Is_Abstract_Subprogram\",          Flag19  (Id));\n-      W (\"Is_Abstract_Type\",                Flag146  (Id));\n-      W (\"Is_Local_Anonymous_Access\",       Flag194 (Id));\n+      W (\"Is_Abstract_Type\",                Flag146 (Id));\n       W (\"Is_Access_Constant\",              Flag69  (Id));\n       W (\"Is_Ada_2005_Only\",                Flag185 (Id));\n       W (\"Is_Ada_2012_Only\",                Flag199 (Id));\n@@ -8350,6 +8438,7 @@ package body Einfo is\n       W (\"Is_Constructor\",                  Flag76  (Id));\n       W (\"Is_Controlled\",                   Flag42  (Id));\n       W (\"Is_Controlling_Formal\",           Flag97  (Id));\n+      W (\"Is_Default_Init_Cond_Procedure\",  Flag132 (Id));\n       W (\"Is_Descendent_Of_Address\",        Flag223 (Id));\n       W (\"Is_Discrim_SO_Function\",          Flag176 (Id));\n       W (\"Is_Discriminant_Check_Function\",  Flag264 (Id));\n@@ -8388,6 +8477,7 @@ package body Einfo is\n       W (\"Is_Limited_Composite\",            Flag106 (Id));\n       W (\"Is_Limited_Interface\",            Flag197 (Id));\n       W (\"Is_Limited_Record\",               Flag25  (Id));\n+      W (\"Is_Local_Anonymous_Access\",       Flag194 (Id));\n       W (\"Is_Machine_Code_Subprogram\",      Flag137 (Id));\n       W (\"Is_Non_Static_Subtype\",           Flag109 (Id));\n       W (\"Is_Null_Init_Proc\",               Flag178 (Id));"}, {"sha": "c87a9899a001ad86c8ebffa4ae38e54ca997f57b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -772,6 +772,16 @@ package Einfo is\n --       default expressions (see Freeze.Process_Default_Expressions), which\n --       would not only waste time, but also generate false error messages.\n \n+--    Default_Init_Cond_Procedure (synthesized)\n+--       Defined in all types. Set for private [sub]types subject to pragma\n+--       Default_Initial_Condition, their corresponding full views and derived\n+--       types with at least one parent subject to the pragma. Contains the\n+--       entity of the procedure which takes a single argument of the given\n+--       type and verifies the assumption of the pragma.\n+--\n+--       Note: the reason this is marked as a synthesized attribute is that the\n+--       way this is stored is as an element of the Subprograms_For_Type field.\n+\n --    Default_Value (Node20)\n --       Defined in formal parameters. Points to the node representing the\n --       expression for the default value for the parameter. Empty if the\n@@ -1474,6 +1484,17 @@ package Einfo is\n --       Convention, Import, or Export has been given. Used to prevent more\n --       than one such pragma appearing for a given entity (RM B.1(45)).\n \n+--    Has_Default_Aspect (Flag39) [base type only]\n+--       Defined in entities for types and subtypes, set for scalar types with\n+--       a Default_Value aspect and array types with a Default_Component_Value\n+--       apsect. If this flag is set, then a corresponding aspect specification\n+--       node will be present on the rep item chain for the entity.\n+\n+--    Has_Default_Init_Cond (Flag3)\n+--       Defined in type and subtype entities. Set if pragma Default_Initial_\n+--       Condition applies to the type or subtype. This flag must be mutually\n+--       exclusive with Has_Inherited_Default_Init_Cond.\n+\n --    Has_Delayed_Aspects (Flag200)\n --      Defined in all entities. Set if the Rep_Item chain for the entity has\n --      one or more N_Aspect_Definition nodes chained which are not to be\n@@ -1486,12 +1507,6 @@ package Einfo is\n --       node must be generated for the entity at its freezing point. See\n --       separate section (\"Delayed Freezing and Elaboration\") for details.\n \n---    Has_Default_Aspect (Flag39) [base type only]\n---       Defined in entities for types and subtypes, set for scalar types with\n---       a Default_Value aspect and array types with a Default_Component_Value\n---       apsect. If this flag is set, then a corresponding aspect specification\n---       node will be present on the rep item chain for the entity.\n-\n --    Has_Delayed_Rep_Aspects (Flag261)\n --       Defined in all type and subtypes. This flag is set if there is at\n --       least one aspect for a representation characteristic that has to be\n@@ -1605,6 +1620,11 @@ package Einfo is\n --       type which has inheritable invariants, and in this case the flag will\n --       also be set in the private type.\n \n+--    Has_Inherited_Default_Init_Cond (Flag133)\n+--       Defined in type and subtype entities. Set if a derived type inherits\n+--       pragma Default_Initial_Condition from its parent type. This flag must\n+--       be mutually exclusive with Had_Default_Init_Cond.\n+\n --    Has_Initial_Value (Flag219)\n --       Defined in entities for variables and out parameters. Set if there\n --       is an explicit initial value expression in the declaration of the\n@@ -2255,6 +2275,10 @@ package Einfo is\n --       Applies to all type entities, true for decimal fixed point\n --       types and subtypes.\n \n+--    Is_Default_Init_Cond_Procedure (Flag132)\n+--       Defined in functions and procedures. Set for a generated procedure\n+--       which verifies the assumption of pragma Default_Initial_Condition.\n+\n --    Is_Descendent_Of_Address (Flag223)\n --       Defined in all entities. True if the entity is type System.Address,\n --       or (recursively) a subtype or derived type of System.Address.\n@@ -5230,11 +5254,13 @@ package Einfo is\n    --    Has_Constrained_Partial_View        (Flag187)\n    --    Has_Controlled_Component            (Flag43)   (base type only)\n    --    Has_Default_Aspect                  (Flag39)   (base type only)\n+   --    Has_Default_Init_Cond               (Flag3)\n    --    Has_Delayed_Rep_Aspects             (Flag261)\n    --    Has_Discriminants                   (Flag5)\n    --    Has_Dynamic_Predicate_Aspect        (Flag258)\n    --    Has_Independent_Components          (Flag34)   (base type only)\n    --    Has_Inheritable_Invariants          (Flag248)\n+   --    Has_Inherited_Default_Init_Cond     (Flag133)\n    --    Has_Invariants                      (Flag232)\n    --    Has_Non_Standard_Rep                (Flag75)   (base type only)\n    --    Has_Object_Size_Clause              (Flag172)\n@@ -5286,6 +5312,7 @@ package Einfo is\n \n    --    Alignment_Clause                    (synth)\n    --    Base_Type                           (synth)\n+   --    Default_Init_Cond_Procedure         (synth)\n    --    Implementation_Base_Type            (synth)\n    --    Invariant_Procedure                 (synth)\n    --    Is_Access_Protected_Subprogram_Type (synth)\n@@ -5953,6 +5980,7 @@ package Einfo is\n    --    Is_Asynchronous                     (Flag81)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Constructor                      (Flag76)\n+   --    Is_Default_Init_Cond_Procedure      (Flag132)  (non-generic case only)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Generic_Actual_Subprogram        (Flag274)  (non-generic case only)\n    --    Is_Hidden_Non_Overridden_Subpgm     (Flag2)    (non-generic case only)\n@@ -6550,6 +6578,7 @@ package Einfo is\n    function Has_Controlling_Result              (Id : E) return B;\n    function Has_Convention_Pragma               (Id : E) return B;\n    function Has_Default_Aspect                  (Id : E) return B;\n+   function Has_Default_Init_Cond               (Id : E) return B;\n    function Has_Delayed_Aspects                 (Id : E) return B;\n    function Has_Delayed_Freeze                  (Id : E) return B;\n    function Has_Delayed_Rep_Aspects             (Id : E) return B;\n@@ -6565,6 +6594,7 @@ package Einfo is\n    function Has_Implicit_Dereference            (Id : E) return B;\n    function Has_Independent_Components          (Id : E) return B;\n    function Has_Inheritable_Invariants          (Id : E) return B;\n+   function Has_Inherited_Default_Init_Cond     (Id : E) return B;\n    function Has_Initial_Value                   (Id : E) return B;\n    function Has_Interrupt_Handler               (Id : E) return B;\n    function Has_Invariants                      (Id : E) return B;\n@@ -6655,6 +6685,7 @@ package Einfo is\n    function Is_Constructor                      (Id : E) return B;\n    function Is_Controlled                       (Id : E) return B;\n    function Is_Controlling_Formal               (Id : E) return B;\n+   function Is_Default_Init_Cond_Procedure      (Id : E) return B;\n    function Is_Descendent_Of_Address            (Id : E) return B;\n    function Is_Discrim_SO_Function              (Id : E) return B;\n    function Is_Discriminant_Check_Function      (Id : E) return B;\n@@ -7183,6 +7214,7 @@ package Einfo is\n    procedure Set_Has_Controlling_Result          (Id : E; V : B := True);\n    procedure Set_Has_Convention_Pragma           (Id : E; V : B := True);\n    procedure Set_Has_Default_Aspect              (Id : E; V : B := True);\n+   procedure Set_Has_Default_Init_Cond           (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Aspects             (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Freeze              (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Rep_Aspects         (Id : E; V : B := True);\n@@ -7198,6 +7230,7 @@ package Einfo is\n    procedure Set_Has_Implicit_Dereference        (Id : E; V : B := True);\n    procedure Set_Has_Independent_Components      (Id : E; V : B := True);\n    procedure Set_Has_Inheritable_Invariants      (Id : E; V : B := True);\n+   procedure Set_Has_Inherited_Default_Init_Cond (Id : E; V : B := True);\n    procedure Set_Has_Initial_Value               (Id : E; V : B := True);\n    procedure Set_Has_Invariants                  (Id : E; V : B := True);\n    procedure Set_Has_Loop_Entry_Attributes       (Id : E; V : B := True);\n@@ -7288,6 +7321,7 @@ package Einfo is\n    procedure Set_Is_Constructor                  (Id : E; V : B := True);\n    procedure Set_Is_Controlled                   (Id : E; V : B := True);\n    procedure Set_Is_Controlling_Formal           (Id : E; V : B := True);\n+   procedure Set_Is_Default_Init_Cond_Procedure  (Id : E; V : B := True);\n    procedure Set_Is_Descendent_Of_Address        (Id : E; V : B := True);\n    procedure Set_Is_Discrim_SO_Function          (Id : E; V : B := True);\n    procedure Set_Is_Discriminant_Check_Function  (Id : E; V : B := True);\n@@ -7502,10 +7536,12 @@ package Einfo is\n    -- Access to Subprograms in Subprograms_For_Type --\n    ---------------------------------------------------\n \n-   function Invariant_Procedure                 (Id : E) return N;\n-   function Predicate_Function                  (Id : E) return N;\n-   function Predicate_Function_M                (Id : E) return N;\n+   function Default_Init_Cond_Procedure         (Id : E) return E;\n+   function Invariant_Procedure                 (Id : E) return E;\n+   function Predicate_Function                  (Id : E) return E;\n+   function Predicate_Function_M                (Id : E) return E;\n \n+   procedure Set_Default_Init_Cond_Procedure    (Id : E; V : E);\n    procedure Set_Invariant_Procedure            (Id : E; V : E);\n    procedure Set_Predicate_Function             (Id : E; V : E);\n    procedure Set_Predicate_Function_M           (Id : E; V : E);\n@@ -7929,6 +7965,7 @@ package Einfo is\n    pragma Inline (Has_Controlling_Result);\n    pragma Inline (Has_Convention_Pragma);\n    pragma Inline (Has_Default_Aspect);\n+   pragma Inline (Has_Default_Init_Cond);\n    pragma Inline (Has_Delayed_Aspects);\n    pragma Inline (Has_Delayed_Freeze);\n    pragma Inline (Has_Delayed_Rep_Aspects);\n@@ -7944,6 +7981,7 @@ package Einfo is\n    pragma Inline (Has_Implicit_Dereference);\n    pragma Inline (Has_Independent_Components);\n    pragma Inline (Has_Inheritable_Invariants);\n+   pragma Inline (Has_Inherited_Default_Init_Cond);\n    pragma Inline (Has_Initial_Value);\n    pragma Inline (Has_Invariants);\n    pragma Inline (Has_Loop_Entry_Attributes);\n@@ -8044,6 +8082,7 @@ package Einfo is\n    pragma Inline (Is_Controlled);\n    pragma Inline (Is_Controlling_Formal);\n    pragma Inline (Is_Decimal_Fixed_Point_Type);\n+   pragma Inline (Is_Default_Init_Cond_Procedure);\n    pragma Inline (Is_Descendent_Of_Address);\n    pragma Inline (Is_Digits_Type);\n    pragma Inline (Is_Discrete_Or_Fixed_Point_Type);\n@@ -8409,6 +8448,7 @@ package Einfo is\n    pragma Inline (Set_Has_Controlling_Result);\n    pragma Inline (Set_Has_Convention_Pragma);\n    pragma Inline (Set_Has_Default_Aspect);\n+   pragma Inline (Set_Has_Default_Init_Cond);\n    pragma Inline (Set_Has_Delayed_Aspects);\n    pragma Inline (Set_Has_Delayed_Freeze);\n    pragma Inline (Set_Has_Delayed_Rep_Aspects);\n@@ -8424,6 +8464,7 @@ package Einfo is\n    pragma Inline (Set_Has_Implicit_Dereference);\n    pragma Inline (Set_Has_Independent_Components);\n    pragma Inline (Set_Has_Inheritable_Invariants);\n+   pragma Inline (Set_Has_Inherited_Default_Init_Cond);\n    pragma Inline (Set_Has_Initial_Value);\n    pragma Inline (Set_Has_Invariants);\n    pragma Inline (Set_Has_Loop_Entry_Attributes);\n@@ -8513,6 +8554,7 @@ package Einfo is\n    pragma Inline (Set_Is_Constructor);\n    pragma Inline (Set_Is_Controlled);\n    pragma Inline (Set_Is_Controlling_Formal);\n+   pragma Inline (Set_Is_Default_Init_Cond_Procedure);\n    pragma Inline (Set_Is_Descendent_Of_Address);\n    pragma Inline (Set_Is_Discrim_SO_Function);\n    pragma Inline (Set_Is_Discriminant_Check_Function);"}, {"sha": "868f9e1b01ec8dfc1374b29184e62f61c5e978d2", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -165,11 +165,6 @@ package body Exp_Ch3 is\n    --  needed after an initialization. Typ is the component type, and Proc_Id\n    --  the initialization procedure for the enclosing composite type.\n \n-   procedure Expand_Tagged_Root (T : Entity_Id);\n-   --  Add a field _Tag at the beginning of the record. This field carries\n-   --  the value of the access to the Dispatch table. This procedure is only\n-   --  called on root type, the _Tag field being inherited by the descendants.\n-\n    procedure Expand_Freeze_Array_Type (N : Node_Id);\n    --  Freeze an array type. Deals with building the initialization procedure,\n    --  creating the packed array type for a packed array and also with the\n@@ -193,6 +188,11 @@ package body Exp_Ch3 is\n    --  applies only to E_Record_Type entities, not to class wide types,\n    --  record subtypes, or private types.\n \n+   procedure Expand_Tagged_Root (T : Entity_Id);\n+   --  Add a field _Tag at the beginning of the record. This field carries\n+   --  the value of the access to the Dispatch table. This procedure is only\n+   --  called on root type, the _Tag field being inherited by the descendants.\n+\n    procedure Freeze_Stream_Operations (N : Node_Id; Typ : Entity_Id);\n    --  Treat user-defined stream operations as renaming_as_body if the\n    --  subprogram they rename is not frozen when the type is frozen.\n@@ -632,19 +632,20 @@ package body Exp_Ch3 is\n \n             return New_List (\n               Make_Implicit_Loop_Statement (Nod,\n-                Identifier => Empty,\n+                Identifier       => Empty,\n                 Iteration_Scheme =>\n                   Make_Iteration_Scheme (Loc,\n                     Loop_Parameter_Specification =>\n                       Make_Loop_Parameter_Specification (Loc,\n-                        Defining_Identifier => Index,\n+                        Defining_Identifier         => Index,\n                         Discrete_Subtype_Definition =>\n                           Make_Attribute_Reference (Loc,\n-                            Prefix => Make_Identifier (Loc, Name_uInit),\n+                            Prefix          =>\n+                              Make_Identifier (Loc, Name_uInit),\n                             Attribute_Name  => Name_Range,\n                             Expressions     => New_List (\n                               Make_Integer_Literal (Loc, N))))),\n-                Statements =>  Init_One_Dimension (N + 1)));\n+                Statements       => Init_One_Dimension (N + 1)));\n          end if;\n       end Init_One_Dimension;\n \n@@ -4664,7 +4665,6 @@ package body Exp_Ch3 is\n    ------------------------------------\n \n    procedure Expand_N_Full_Type_Declaration (N : Node_Id) is\n-\n       procedure Build_Master (Ptr_Typ : Entity_Id);\n       --  Create the master associated with Ptr_Typ\n \n@@ -5313,6 +5313,7 @@ package body Exp_Ch3 is\n \n       --  Local variables\n \n+      Next_N  : constant Node_Id := Next (N);\n       Id_Ref  : Node_Id;\n       New_Ref : Node_Id;\n \n@@ -5563,7 +5564,7 @@ package body Exp_Ch3 is\n                   --  by\n                   --     Tmp : T := Obj;\n                   --     type Ityp is not null access I'Class;\n-                  --     CW  : I'Class renames Ityp(Tmp.I_Tag'Address).all;\n+                  --     CW  : I'Class renames Ityp (Tmp.I_Tag'Address).all;\n \n                   if Comes_From_Source (Expr_N)\n                     and then Nkind (Expr_N) = N_Identifier\n@@ -5672,7 +5673,8 @@ package body Exp_Ch3 is\n                     Make_Object_Renaming_Declaration (Loc,\n                       Defining_Identifier => Make_Temporary (Loc, 'D'),\n                       Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n-                      Name => Convert_Tag_To_Interface (Typ, Tag_Comp)));\n+                      Name                =>\n+                        Convert_Tag_To_Interface (Typ, Tag_Comp)));\n \n                   --  If the original entity comes from source, then mark the\n                   --  new entity as needing debug information, even though it's\n@@ -6026,6 +6028,37 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n+      --  At this point the object is fully initialized by either invoking the\n+      --  related type init proc, routine [Deep_]Initialize or performing in-\n+      --  place assingments for an array object. If the related type is subject\n+      --  to pragma Default_Initial_Condition, add a runtime check to verify\n+      --  the assumption of the pragma. Generate:\n+\n+      --    <Base_Typ>Default_Init_Cond (<Base_Typ> (Def_Id));\n+\n+      --  Note that the check is generated for source objects only\n+\n+      if Comes_From_Source (Def_Id)\n+        and then (Has_Default_Init_Cond (Base_Typ)\n+                    or else Has_Inherited_Default_Init_Cond (Base_Typ))\n+      then\n+         declare\n+            DIC_Call : constant Node_Id :=\n+                         Build_Default_Init_Cond_Call (Loc, Def_Id, Base_Typ);\n+         begin\n+            if Present (Next_N) then\n+               Insert_Before_And_Analyze (Next_N, DIC_Call);\n+\n+            --  The object declaration is the last node in a declarative or a\n+            --  statement list.\n+\n+            else\n+               Append_To (List_Containing (N), DIC_Call);\n+               Analyze (DIC_Call);\n+            end if;\n+         end;\n+      end if;\n+\n    --  Exception on library entity not available\n \n    exception\n@@ -7357,14 +7390,27 @@ package body Exp_Ch3 is\n             end loop;\n          end;\n \n-         if RACW_Seen then\n-\n-            --  If there are RACWs designating this type, make stubs now\n+         --  If there are RACWs designating this type, make stubs now\n \n+         if RACW_Seen then\n             Remote_Types_Tagged_Full_View_Encountered (Def_Id);\n          end if;\n       end if;\n \n+      --  If the type is subject to pragma Default_Initial_Condition, generate\n+      --  the body of the procedure which verifies the assertion of the pragma\n+      --  at runtime.\n+\n+      if Has_Default_Init_Cond (Def_Id) then\n+         Build_Default_Init_Cond_Procedure_Body (Def_Id);\n+\n+      --  A derived type inherits the default initial condition procedure from\n+      --  its parent type.\n+\n+      elsif Has_Inherited_Default_Init_Cond (Def_Id) then\n+         Inherit_Default_Init_Cond_Procedure (Def_Id);\n+      end if;\n+\n       --  Freeze processing for record types\n \n       if Is_Record_Type (Def_Id) then"}, {"sha": "b98aed6bbab7afa3804ad6e8f1d10979c092ad64", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 87, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -38,6 +38,7 @@ with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Dist; use Exp_Dist;\n with Exp_Disp; use Exp_Disp;\n+with Exp_Prag; use Exp_Prag;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n@@ -379,11 +380,6 @@ package body Exp_Ch7 is\n    --  Given an arbitrary entity, traverse the scope chain looking for the\n    --  first enclosing function. Return Empty if no function was found.\n \n-   procedure Expand_Pragma_Initial_Condition (N : Node_Id);\n-   --  Subsidiary to the expansion of package specs and bodies. Generate a\n-   --  runtime check needed to verify the assumption introduced by pragma\n-   --  Initial_Condition. N denotes the package spec or body.\n-\n    function Make_Call\n      (Loc       : Source_Ptr;\n       Proc_Id   : Entity_Id;\n@@ -4263,88 +4259,6 @@ package body Exp_Ch7 is\n       end if;\n    end Expand_N_Package_Declaration;\n \n-   -------------------------------------\n-   -- Expand_Pragma_Initial_Condition --\n-   -------------------------------------\n-\n-   procedure Expand_Pragma_Initial_Condition (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Check     : Node_Id;\n-      Expr      : Node_Id;\n-      Init_Cond : Node_Id;\n-      List      : List_Id;\n-      Pack_Id   : Entity_Id;\n-\n-   begin\n-      if Nkind (N) = N_Package_Body then\n-         Pack_Id := Corresponding_Spec (N);\n-\n-         if Present (Handled_Statement_Sequence (N)) then\n-            List := Statements (Handled_Statement_Sequence (N));\n-\n-         --  The package body lacks statements, create an empty list\n-\n-         else\n-            List := New_List;\n-\n-            Set_Handled_Statement_Sequence (N,\n-              Make_Handled_Sequence_Of_Statements (Loc, Statements => List));\n-         end if;\n-\n-      elsif Nkind (N) = N_Package_Declaration then\n-         Pack_Id := Defining_Entity (N);\n-\n-         if Present (Visible_Declarations (Specification (N))) then\n-            List := Visible_Declarations (Specification (N));\n-\n-         --  The package lacks visible declarations, create an empty list\n-\n-         else\n-            List := New_List;\n-\n-            Set_Visible_Declarations (Specification (N), List);\n-         end if;\n-\n-      --  This routine should not be used on anything other than packages\n-\n-      else\n-         raise Program_Error;\n-      end if;\n-\n-      Init_Cond := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n-\n-      --  The caller should check whether the package is subject to pragma\n-      --  Initial_Condition.\n-\n-      pragma Assert (Present (Init_Cond));\n-\n-      Expr :=\n-        Get_Pragma_Arg (First (Pragma_Argument_Associations (Init_Cond)));\n-\n-      --  The assertion expression was found to be illegal, do not generate the\n-      --  runtime check as it will repeat the illegality.\n-\n-      if Error_Posted (Init_Cond) or else Error_Posted (Expr) then\n-         return;\n-      end if;\n-\n-      --  Generate:\n-      --    pragma Check (Initial_Condition, <Expr>);\n-\n-      Check :=\n-        Make_Pragma (Loc,\n-          Chars                        => Name_Check,\n-          Pragma_Argument_Associations => New_List (\n-            Make_Pragma_Argument_Association (Loc,\n-              Expression => Make_Identifier (Loc, Name_Initial_Condition)),\n-\n-            Make_Pragma_Argument_Association (Loc,\n-              Expression => New_Copy_Tree (Expr))));\n-\n-      Append_To (List, Check);\n-      Analyze (Check);\n-   end Expand_Pragma_Initial_Condition;\n-\n    -----------------------------\n    -- Find_Node_To_Be_Wrapped --\n    -----------------------------"}, {"sha": "bb4bcae192042eb6cf6b1797489e15f7f174e769", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 93, "deletions": 11, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -1152,17 +1152,17 @@ package body Exp_Prag is\n       --  Insert the pragma\n \n       Insert_After_And_Analyze (N,\n-         Make_Pragma (Loc,\n-           Chars                        => Name_Machine_Attribute,\n-           Pragma_Argument_Associations => New_List (\n-             Make_Pragma_Argument_Association (Iloc,\n-               Expression => New_Copy_Tree (Internal)),\n-             Make_Pragma_Argument_Association (Eloc,\n-               Expression =>\n-                 Make_String_Literal (Sloc => Ploc,\n-                   Strval => \"common_object\")),\n-             Make_Pragma_Argument_Association (Ploc,\n-               Expression => New_Copy_Tree (Psect)))));\n+        Make_Pragma (Loc,\n+          Chars                        => Name_Machine_Attribute,\n+          Pragma_Argument_Associations => New_List (\n+            Make_Pragma_Argument_Association (Iloc,\n+              Expression => New_Copy_Tree (Internal)),\n+            Make_Pragma_Argument_Association (Eloc,\n+              Expression =>\n+                Make_String_Literal (Sloc => Ploc,\n+                  Strval => \"common_object\")),\n+            Make_Pragma_Argument_Association (Ploc,\n+              Expression => New_Copy_Tree (Psect)))));\n    end Expand_Pragma_Common_Object;\n \n    ---------------------------------------\n@@ -1283,6 +1283,88 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Import_Or_Interface;\n \n+   -------------------------------------\n+   -- Expand_Pragma_Initial_Condition --\n+   -------------------------------------\n+\n+   procedure Expand_Pragma_Initial_Condition (Spec_Or_Body : Node_Id) is\n+      Loc       : constant Source_Ptr := Sloc (Spec_Or_Body);\n+      Check     : Node_Id;\n+      Expr      : Node_Id;\n+      Init_Cond : Node_Id;\n+      List      : List_Id;\n+      Pack_Id   : Entity_Id;\n+\n+   begin\n+      if Nkind (Spec_Or_Body) = N_Package_Body then\n+         Pack_Id := Corresponding_Spec (Spec_Or_Body);\n+\n+         if Present (Handled_Statement_Sequence (Spec_Or_Body)) then\n+            List := Statements (Handled_Statement_Sequence (Spec_Or_Body));\n+\n+         --  The package body lacks statements, create an empty list\n+\n+         else\n+            List := New_List;\n+\n+            Set_Handled_Statement_Sequence (Spec_Or_Body,\n+              Make_Handled_Sequence_Of_Statements (Loc, Statements => List));\n+         end if;\n+\n+      elsif Nkind (Spec_Or_Body) = N_Package_Declaration then\n+         Pack_Id := Defining_Entity (Spec_Or_Body);\n+\n+         if Present (Visible_Declarations (Specification (Spec_Or_Body))) then\n+            List := Visible_Declarations (Specification (Spec_Or_Body));\n+\n+         --  The package lacks visible declarations, create an empty list\n+\n+         else\n+            List := New_List;\n+\n+            Set_Visible_Declarations (Specification (Spec_Or_Body), List);\n+         end if;\n+\n+      --  This routine should not be used on anything other than packages\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Init_Cond := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n+\n+      --  The caller should check whether the package is subject to pragma\n+      --  Initial_Condition.\n+\n+      pragma Assert (Present (Init_Cond));\n+\n+      Expr :=\n+        Get_Pragma_Arg (First (Pragma_Argument_Associations (Init_Cond)));\n+\n+      --  The assertion expression was found to be illegal, do not generate the\n+      --  runtime check as it will repeat the illegality.\n+\n+      if Error_Posted (Init_Cond) or else Error_Posted (Expr) then\n+         return;\n+      end if;\n+\n+      --  Generate:\n+      --    pragma Check (Initial_Condition, <Expr>);\n+\n+      Check :=\n+        Make_Pragma (Loc,\n+          Chars                        => Name_Check,\n+          Pragma_Argument_Associations => New_List (\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression => Make_Identifier (Loc, Name_Initial_Condition)),\n+\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression => New_Copy_Tree (Expr))));\n+\n+      Append_To (List, Check);\n+      Analyze (Check);\n+   end Expand_Pragma_Initial_Condition;\n+\n    ------------------------------------\n    -- Expand_Pragma_Inspection_Point --\n    ------------------------------------"}, {"sha": "d1ddfea177e5d5d6b5ce48d8967e436b8092e7cd", "filename": "gcc/ada/exp_prag.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fexp_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.ads?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,4 +42,15 @@ package Exp_Prag is\n    --  Subp_Id's body. All generated code is added to list Stmts. If Stmts is\n    --  No_List on entry, a new list is created.\n \n+   procedure Expand_Pragma_Initial_Condition (Spec_Or_Body : Node_Id);\n+   --  Generate a runtime check needed to verify the assumption of introduced\n+   --  by pragma Initial_Condition. Spec_Or_Body denotes the spec or body of\n+   --  the package where the pragma appears. The check is inserted according\n+   --  to the following precedence rules:\n+   --    1) If the package has a body with a statement sequence, the check is\n+   --       inserted at the end of the statments.\n+   --    2) If the package has a body, the check is inserted at the end of the\n+   --       body declarations.\n+   --    3) The check is inserted at the end of the visible declarations.\n+\n end Exp_Prag;"}, {"sha": "b440122dc621acecc4f7b9224917696954d7a1e7", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -1186,6 +1186,7 @@ begin\n            Pragma_Debug_Policy                   |\n            Pragma_Depends                        |\n            Pragma_Detect_Blocking                |\n+           Pragma_Default_Initial_Condition      |\n            Pragma_Default_Scalar_Storage_Order   |\n            Pragma_Default_Storage_Pool           |\n            Pragma_Disable_Atomic_Synchronization |"}, {"sha": "a6b0b381ff209d1e1406284af4a43c148916343c", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -295,16 +295,17 @@ package body Prj.Strt is\n    ---------------------------\n \n    procedure End_Case_Construction\n-     (Check_All_Labels   : Boolean;\n-      Case_Location      : Source_Ptr;\n-      Flags              : Processing_Flags;\n-      String_Type        : Boolean)\n+     (Check_All_Labels : Boolean;\n+      Case_Location    : Source_Ptr;\n+      Flags            : Processing_Flags;\n+      String_Type      : Boolean)\n    is\n-      Non_Used : Natural := 0;\n+      Non_Used       : Natural := 0;\n       First_Non_Used : Choice_Node_Id := First_Choice_Node_Id;\n+\n    begin\n-      --  First, if Check_All_Labels is True, check if all values\n-      --  of the string type have been used.\n+      --  First, if Check_All_Labels is True, check if all values of the string\n+      --  type have been used.\n \n       if Check_All_Labels then\n          if String_Type then\n@@ -325,8 +326,7 @@ package body Prj.Strt is\n                Error_Msg\n                  (Flags, \"?value %% is not used as label\", Case_Location);\n \n-               --  If several are not used, report a warning for each one of\n-               --  them.\n+            --  If several are not used, report a warning for each one of them\n \n             elsif Non_Used > 1 then\n                Error_Msg\n@@ -355,18 +355,15 @@ package body Prj.Strt is\n          Choices.Set_Last (First_Choice_Node_Id);\n          Choice_First := 0;\n \n-      elsif Choice_Lasts.Last = 2 then\n-\n-         --  This is the second case construction, set the tables to the first\n+      --  Second case construction, set the tables to the first\n \n+      elsif Choice_Lasts.Last = 2 then\n          Choice_Lasts.Set_Last (1);\n          Choices.Set_Last (Choice_Lasts.Table (1));\n          Choice_First := 1;\n \n+      --  Third or more case construction, set the tables to the previous one\n       else\n-         --  This is the 3rd or more case construction, set the tables to the\n-         --  previous one.\n-\n          Choice_Lasts.Decrement_Last;\n          Choices.Set_Last (Choice_Lasts.Table (Choice_Lasts.Last));\n          Choice_First := Choice_Lasts.Table (Choice_Lasts.Last - 1) + 1;\n@@ -440,7 +437,6 @@ package body Prj.Strt is\n          Scan (In_Tree);\n \n          case Token is\n-\n             when Tok_Right_Paren =>\n                if Ext_List then\n                   Error_Msg (Flags, \"`,` expected\", Token_Ptr);\n@@ -529,6 +525,7 @@ package body Prj.Strt is\n          Set_String_Value_Of (Current_Choice, In_Tree, To => Choice_String);\n \n          if String_Type then\n+\n             --  Check if the label is part of the string type and if it has not\n             --  been already used.\n "}, {"sha": "ab43346ef574255fd2e172a396ec57af6443a6c2", "filename": "gcc/ada/prj-strt.ads", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fprj-strt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fprj-strt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.ads?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -50,21 +50,20 @@ private package Prj.Strt is\n    procedure Start_New_Case_Construction\n      (In_Tree     : Project_Node_Tree_Ref;\n       String_Type : Project_Node_Id);\n-   --  This procedure is called at the beginning of a case construction The\n+   --  This procedure is called at the beginning of a case construction. The\n    --  parameter String_Type is the node for the string type of the case label\n    --  variable. The different literal strings of the string type are stored\n-   --  into a table to be checked against the case labels of the case\n-   --  construction.\n+   --  into a table to be checked against the labels of the case construction.\n \n    procedure End_Case_Construction\n-     (Check_All_Labels   : Boolean;\n-      Case_Location      : Source_Ptr;\n-      Flags              : Processing_Flags;\n-      String_Type        : Boolean);\n-   --  This procedure is called at the end of a case construction to remove the\n-   --  case labels and to restore the previous state. In particular, in the\n+     (Check_All_Labels : Boolean;\n+      Case_Location    : Source_Ptr;\n+      Flags            : Processing_Flags;\n+      String_Type      : Boolean);\n+   --  This procedure is called at the end of a case construction to remove\n+   --  the case labels and to restore the previous state. In particular, in the\n    --  case of nested case constructions, the case labels of the enclosing case\n-   --  construction are restored. When When_Others is False and we are not in\n+   --  construction are restored. If When_Others is False and we are not in\n    --  quiet output, a warning is emitted for each value of the case variable\n    --  string type that has not been specified.\n "}, {"sha": "aecb69a4e948c36c574a5336e8146bd0a42aa9ce", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -3191,9 +3191,9 @@ package body Sem_Attr is\n       -- Default_Bit_Order --\n       -----------------------\n \n-      when Attribute_Default_Bit_Order => Default_Bit_Order :\n-      declare\n+      when Attribute_Default_Bit_Order => Default_Bit_Order : declare\n          Target_Default_Bit_Order : System.Bit_Order;\n+\n       begin\n          Check_Standard_Prefix;\n \n@@ -3217,6 +3217,7 @@ package body Sem_Attr is\n \n       when Attribute_Default_Scalar_Storage_Order => Default_SSO : declare\n          RE_Default_SSO : RE_Id;\n+\n       begin\n          Check_Standard_Prefix;\n \n@@ -3227,10 +3228,13 @@ package body Sem_Attr is\n                else\n                   RE_Default_SSO := RE_Low_Order_First;\n                end if;\n+\n             when 'H' =>\n                RE_Default_SSO := RE_High_Order_First;\n+\n             when 'L' =>\n                RE_Default_SSO := RE_Low_Order_First;\n+\n             when others =>\n                raise Program_Error;\n          end case;"}, {"sha": "ca52755190b6d9f81e70076a739b8fa50a1d7829", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -182,17 +182,6 @@ package body Sem_Ch13 is\n    --  renaming_as_body. For tagged types, the specification is one of the\n    --  primitive specs.\n \n-   generic\n-      with procedure Replace_Type_Reference (N : Node_Id);\n-   procedure Replace_Type_References_Generic (N : Node_Id; T : Entity_Id);\n-   --  This is used to scan an expression for a predicate or invariant aspect\n-   --  replacing occurrences of the name of the subtype to which the aspect\n-   --  applies with appropriate references to the parameter of the predicate\n-   --  function or invariant procedure. The procedure passed as a generic\n-   --  parameter does the actual replacement of node N, which is either a\n-   --  simple direct reference to T, or a selected component that represents\n-   --  an appropriately qualified occurrence of T.\n-\n    procedure Resolve_Iterable_Operation\n      (N      : Node_Id;\n       Cursor : Entity_Id;\n@@ -2221,6 +2210,26 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end Abstract_State;\n \n+               --  Aspect Default_Internal_Condition is never delayed because\n+               --  it is equivalent to a source pragma which appears after the\n+               --  related private type. To deal with forward references, the\n+               --  generated pragma is stored in the rep chain of the related\n+               --  private type as types do not carry contracts. The pragma is\n+               --  wrapped inside of a procedure at the freeze point of the\n+               --  private type's full view.\n+\n+               when Aspect_Default_Initial_Condition =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  =>\n+                       Name_Default_Initial_Condition);\n+\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Depends\n \n                --  Aspect Depends is never delayed because it is equivalent to\n@@ -8737,25 +8746,26 @@ package body Sem_Ch13 is\n \n          --  Here is the list of aspects that don't require delay analysis\n \n-         when Aspect_Abstract_State       |\n-              Aspect_Annotate             |\n-              Aspect_Contract_Cases       |\n-              Aspect_Dimension            |\n-              Aspect_Dimension_System     |\n-              Aspect_Implicit_Dereference |\n-              Aspect_Initial_Condition    |\n-              Aspect_Initializes          |\n-              Aspect_Part_Of              |\n-              Aspect_Post                 |\n-              Aspect_Postcondition        |\n-              Aspect_Pre                  |\n-              Aspect_Precondition         |\n-              Aspect_Refined_Depends      |\n-              Aspect_Refined_Global       |\n-              Aspect_Refined_Post         |\n-              Aspect_Refined_State        |\n-              Aspect_SPARK_Mode           |\n-              Aspect_Test_Case            =>\n+         when Aspect_Abstract_State            |\n+              Aspect_Annotate                  |\n+              Aspect_Contract_Cases            |\n+              Aspect_Default_Initial_Condition |\n+              Aspect_Dimension                 |\n+              Aspect_Dimension_System          |\n+              Aspect_Implicit_Dereference      |\n+              Aspect_Initial_Condition         |\n+              Aspect_Initializes               |\n+              Aspect_Part_Of                   |\n+              Aspect_Post                      |\n+              Aspect_Postcondition             |\n+              Aspect_Pre                       |\n+              Aspect_Precondition              |\n+              Aspect_Refined_Depends           |\n+              Aspect_Refined_Global            |\n+              Aspect_Refined_Post              |\n+              Aspect_Refined_State             |\n+              Aspect_SPARK_Mode                |\n+              Aspect_Test_Case                 =>\n             raise Program_Error;\n \n       end case;\n@@ -10555,9 +10565,10 @@ package body Sem_Ch13 is\n         (Rep_Item : Node_Id) return Boolean\n       is\n       begin\n-         return Nkind (Rep_Item) = N_Pragma\n-           or else Present_In_Rep_Item\n-                     (Entity (Rep_Item), Aspect_Rep_Item (Rep_Item));\n+         return\n+           Nkind (Rep_Item) = N_Pragma\n+             or else Present_In_Rep_Item\n+                       (Entity (Rep_Item), Aspect_Rep_Item (Rep_Item));\n       end Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item;\n \n    --  Start of processing for Inherit_Aspects_At_Freeze_Point\n@@ -11746,7 +11757,7 @@ package body Sem_Ch13 is\n                end loop;\n             end if;\n \n-            --  Continue for any other node kind\n+         --  Continue for any other node kind\n \n          else\n             return OK;"}, {"sha": "b1bb1592b452b2d905e550538075a28f45db184a", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -144,6 +144,17 @@ package Sem_Ch13 is\n    --  type. Returns False if no such error occurs. If this error does occur,\n    --  appropriate error messages are posted on node N, and True is returned.\n \n+   generic\n+      with procedure Replace_Type_Reference (N : Node_Id);\n+   procedure Replace_Type_References_Generic (N : Node_Id; T : Entity_Id);\n+   --  This is used to scan an expression for a predicate or invariant aspect\n+   --  replacing occurrences of the name of the subtype to which the aspect\n+   --  applies with appropriate references to the parameter of the predicate\n+   --  function or invariant procedure. The procedure passed as a generic\n+   --  parameter does the actual replacement of node N, which is either a\n+   --  simple direct reference to T, or a selected component that represents\n+   --  an appropriately qualified occurrence of T.\n+\n    function Rep_Item_Too_Late\n      (T     : Entity_Id;\n       N     : Node_Id;"}, {"sha": "ae09b34f6561667e8effb64d481da1402b1dbef0", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -92,8 +92,8 @@ package body Sem_Ch3 is\n    --  record type.\n \n    procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of object Obj_Id as\n-   --  if they appeared at the end of the declarative region. The aspects to be\n+   --  Analyze all delayed pragmas chained on the contract of object Obj_Id as\n+   --  if they appeared at the end of the declarative region. The pragmas to be\n    --  considered are:\n    --    Async_Readers\n    --    Async_Writers\n@@ -8508,6 +8508,23 @@ package body Sem_Ch3 is\n       end if;\n \n       Check_Function_Writable_Actuals (N);\n+\n+      --  Propagate the attributes related to pragma Default_Initial_Condition\n+      --  from the parent type to the private extension. A derived type always\n+      --  inherits the default initial condition flag from the parent type. If\n+      --  the derived type carries its own Default_Initial_Condition pragma,\n+      --  the flag is later reset in Analyze_Pragma. Note that both flags are\n+      --  mutually exclusive.\n+\n+      if Has_Inherited_Default_Init_Cond (Parent_Type)\n+        or else Present (Get_Pragma\n+                  (Parent_Type, Pragma_Default_Initial_Condition))\n+      then\n+         Set_Has_Inherited_Default_Init_Cond (Derived_Type);\n+\n+      elsif Has_Default_Init_Cond (Parent_Type) then\n+         Set_Has_Default_Init_Cond (Derived_Type);\n+      end if;\n    end Build_Derived_Record_Type;\n \n    ------------------------\n@@ -18945,6 +18962,21 @@ package body Sem_Ch3 is\n          Set_Has_Specified_Stream_Output (Full_T);\n       end if;\n \n+      --  Propagate the attributes related to pragma Default_Initial_Condition\n+      --  from the private to the full view. Note that both flags are mutually\n+      --  exclusive.\n+\n+      if Has_Inherited_Default_Init_Cond (Priv_T) then\n+         Set_Has_Inherited_Default_Init_Cond (Full_T);\n+         Set_Default_Init_Cond_Procedure\n+           (Full_T, Default_Init_Cond_Procedure (Priv_T));\n+\n+      elsif Has_Default_Init_Cond (Priv_T) then\n+         Set_Has_Default_Init_Cond (Full_T);\n+         Set_Default_Init_Cond_Procedure\n+           (Full_T, Default_Init_Cond_Procedure (Priv_T));\n+      end if;\n+\n       --  Propagate invariants to full type\n \n       if Has_Invariants (Priv_T) then"}, {"sha": "e8991328c44c96652fedfa4516e7bb4f5e4e91ba", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -1350,8 +1350,10 @@ package body Sem_Ch7 is\n          Analyze_Declarations (Vis_Decls);\n       end if;\n \n-      --  Verify that incomplete types have received full declarations and\n-      --  also build invariant procedures for any types with invariants.\n+      --  Inspect the entities defined in the package and ensure that all\n+      --  incomplete types have received full declarations. Build default\n+      --  initial condition and invariant procedures for all types that\n+      --  qualify.\n \n       E := First_Entity (Id);\n       while Present (E) loop\n@@ -1367,10 +1369,26 @@ package body Sem_Ch7 is\n             Error_Msg_N (\"no declaration in visible part for incomplete}\", E);\n          end if;\n \n-         --  Build invariant procedures\n+         if Is_Type (E) then\n \n-         if Is_Type (E) and then Has_Invariants (E) then\n-            Build_Invariant_Procedure (E, N);\n+            --  Each private type subject to pragma Default_Initial_Condition\n+            --  declares a specialized procedure which verifies the assumption\n+            --  of the pragma. The declaration appears in the visible part of\n+            --  the package to allow for being called from the outside.\n+\n+            if Has_Default_Init_Cond (E) then\n+               Build_Default_Init_Cond_Procedure_Declaration (E);\n+\n+            --  A private extension inherits the default initial condition\n+            --  procedure from its parent type.\n+\n+            elsif Has_Inherited_Default_Init_Cond (E) then\n+               Inherit_Default_Init_Cond_Procedure (E);\n+            end if;\n+\n+            if Has_Invariants (E) then\n+               Build_Invariant_Procedure (E, N);\n+            end if;\n          end if;\n \n          Next_Entity (E);"}, {"sha": "82d7df496025aca4ff9a60b87ca6b9731c16e078", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 179, "deletions": 118, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -2363,7 +2363,7 @@ package body Sem_Prag is\n       --  final place yet. A direct analysis may generate side effects and this\n       --  is not desired at this point.\n \n-      Preanalyze_And_Resolve (Expr, Standard_Boolean);\n+      Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n    end Analyze_Initial_Condition_In_Decl_Part;\n \n    --------------------------------------\n@@ -11016,17 +11016,18 @@ package body Sem_Prag is\n          --                        Type_Invariant       |\n          --                        Type_Invariant'Class\n \n-         --  ID_ASSERTION_KIND ::= Assert_And_Cut       |\n-         --                        Assume               |\n-         --                        Contract_Cases       |\n-         --                        Debug                |\n-         --                        Initial_Condition    |\n-         --                        Loop_Invariant       |\n-         --                        Loop_Variant         |\n-         --                        Postcondition        |\n-         --                        Precondition         |\n-         --                        Predicate            |\n-         --                        Refined_Post         |\n+         --  ID_ASSERTION_KIND ::= Assert_And_Cut            |\n+         --                        Assume                    |\n+         --                        Contract_Cases            |\n+         --                        Debug                     |\n+         --                        Default_Initial_Condition |\n+         --                        Initial_Condition         |\n+         --                        Loop_Invariant            |\n+         --                        Loop_Variant              |\n+         --                        Postcondition             |\n+         --                        Precondition              |\n+         --                        Predicate                 |\n+         --                        Refined_Post              |\n          --                        Statement_Assertions\n \n          --  Note: The RM_ASSERTION_KIND list is language-defined, and the\n@@ -12755,100 +12756,66 @@ package body Sem_Prag is\n                     Expression => Get_Pragma_Arg (Arg1)))));\n             Analyze (N);\n \n-         -------------\n-         -- Depends --\n-         -------------\n-\n-         --  pragma Depends (DEPENDENCY_RELATION);\n-\n-         --  DEPENDENCY_RELATION ::=\n-         --    null\n-         --  | DEPENDENCY_CLAUSE {, DEPENDENCY_CLAUSE}\n-\n-         --  DEPENDENCY_CLAUSE ::=\n-         --    OUTPUT_LIST =>[+] INPUT_LIST\n-         --  | NULL_DEPENDENCY_CLAUSE\n-\n-         --  NULL_DEPENDENCY_CLAUSE ::= null => INPUT_LIST\n-\n-         --  OUTPUT_LIST ::= OUTPUT | (OUTPUT {, OUTPUT})\n-\n-         --  INPUT_LIST ::= null | INPUT | (INPUT {, INPUT})\n-\n-         --  OUTPUT ::= NAME | FUNCTION_RESULT\n-         --  INPUT  ::= NAME\n+         --------------------------------------\n+         -- Pragma_Default_Initial_Condition --\n+         --------------------------------------\n \n-         --  where FUNCTION_RESULT is a function Result attribute_reference\n+         --  pragma Pragma_Default_Initial_Condition\n+         --           [ (null | boolean_EXPRESSION) ];\n \n-         when Pragma_Depends => Depends : declare\n-            Subp_Decl : Node_Id;\n+         when Pragma_Default_Initial_Condition => Default_Init_Cond : declare\n+            Discard : Boolean;\n+            Stmt    : Node_Id;\n+            Typ     : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n-            Check_Arg_Count (1);\n-            Ensure_Aggregate_Form (Arg1);\n-\n-            --  Ensure the proper placement of the pragma. Depends must be\n-            --  associated with a subprogram declaration or a body that acts\n-            --  as a spec.\n-\n-            Subp_Decl :=\n-              Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n-\n-            if Nkind (Subp_Decl) = N_Subprogram_Declaration then\n-               null;\n-\n-            --  Body acts as spec\n+            Check_At_Most_N_Arguments (1);\n \n-            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n-              and then No (Corresponding_Spec (Subp_Decl))\n-            then\n-               null;\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n \n-            --  Body stub acts as spec\n+               --  Skip prior pragmas, but check for duplicates\n \n-            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n-              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n-            then\n-               null;\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma % duplicates pragma declared #\", N);\n+                  end if;\n \n-            else\n-               Pragma_Misplaced;\n-               return;\n-            end if;\n+               --  Skip internally generated code\n \n-            --  When the pragma appears on a subprogram body, perform the full\n-            --  analysis now.\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n \n-            if Nkind (Subp_Decl) = N_Subprogram_Body then\n-               Analyze_Depends_In_Decl_Part (N);\n+               --  The associated private type [extension] has been found, stop\n+               --  the search.\n \n-            --  When Depends applies to a subprogram compilation unit, the\n-            --  corresponding pragma is placed after the unit's declaration\n-            --  node and needs to be analyzed immediately.\n+               elsif Nkind_In (Stmt, N_Private_Extension_Declaration,\n+                                     N_Private_Type_Declaration)\n+               then\n+                  Typ := Defining_Entity (Stmt);\n+                  exit;\n \n-            elsif Nkind (Subp_Decl) = N_Subprogram_Declaration\n-              and then Nkind (Parent (Subp_Decl)) = N_Compilation_Unit\n-            then\n-               Analyze_Depends_In_Decl_Part (N);\n-            end if;\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n \n-            --  Chain the pragma on the contract for further processing\n+               else\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n \n-            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n-         end Depends;\n+               Stmt := Prev (Stmt);\n+            end loop;\n \n-         ---------------------\n-         -- Detect_Blocking --\n-         ---------------------\n+            Set_Has_Default_Init_Cond (Typ);\n+            Set_Has_Inherited_Default_Init_Cond (Typ, False);\n \n-         --  pragma Detect_Blocking;\n+            --  Chain the pragma on the rep item chain for further processing\n \n-         when Pragma_Detect_Blocking =>\n-            Ada_2005_Pragma;\n-            Check_Arg_Count (0);\n-            Check_Valid_Configuration_Pragma;\n-            Detect_Blocking := True;\n+            Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n+         end Default_Init_Cond;\n \n          ----------------------------------\n          -- Default_Scalar_Storage_Order --\n@@ -12946,6 +12913,101 @@ package body Sem_Prag is\n \n             Default_Pool := Expression (Arg1);\n \n+         -------------\n+         -- Depends --\n+         -------------\n+\n+         --  pragma Depends (DEPENDENCY_RELATION);\n+\n+         --  DEPENDENCY_RELATION ::=\n+         --    null\n+         --  | DEPENDENCY_CLAUSE {, DEPENDENCY_CLAUSE}\n+\n+         --  DEPENDENCY_CLAUSE ::=\n+         --    OUTPUT_LIST =>[+] INPUT_LIST\n+         --  | NULL_DEPENDENCY_CLAUSE\n+\n+         --  NULL_DEPENDENCY_CLAUSE ::= null => INPUT_LIST\n+\n+         --  OUTPUT_LIST ::= OUTPUT | (OUTPUT {, OUTPUT})\n+\n+         --  INPUT_LIST ::= null | INPUT | (INPUT {, INPUT})\n+\n+         --  OUTPUT ::= NAME | FUNCTION_RESULT\n+         --  INPUT  ::= NAME\n+\n+         --  where FUNCTION_RESULT is a function Result attribute_reference\n+\n+         when Pragma_Depends => Depends : declare\n+            Subp_Decl : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Ensure_Aggregate_Form (Arg1);\n+\n+            --  Ensure the proper placement of the pragma. Depends must be\n+            --  associated with a subprogram declaration or a body that acts\n+            --  as a spec.\n+\n+            Subp_Decl :=\n+              Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+\n+            if Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               null;\n+\n+            --  Body acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Subp_Decl))\n+            then\n+               null;\n+\n+            --  Body stub acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n+            then\n+               null;\n+\n+            else\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            --  When the pragma appears on a subprogram body, perform the full\n+            --  analysis now.\n+\n+            if Nkind (Subp_Decl) = N_Subprogram_Body then\n+               Analyze_Depends_In_Decl_Part (N);\n+\n+            --  When Depends applies to a subprogram compilation unit, the\n+            --  corresponding pragma is placed after the unit's declaration\n+            --  node and needs to be analyzed immediately.\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Declaration\n+              and then Nkind (Parent (Subp_Decl)) = N_Compilation_Unit\n+            then\n+               Analyze_Depends_In_Decl_Part (N);\n+            end if;\n+\n+            --  Chain the pragma on the contract for further processing\n+\n+            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n+         end Depends;\n+\n+         ---------------------\n+         -- Detect_Blocking --\n+         ---------------------\n+\n+         --  pragma Detect_Blocking;\n+\n+         when Pragma_Detect_Blocking =>\n+            Ada_2005_Pragma;\n+            Check_Arg_Count (0);\n+            Check_Valid_Configuration_Pragma;\n+            Detect_Blocking := True;\n+\n          ------------------------------------\n          -- Disable_Atomic_Synchronization --\n          ------------------------------------\n@@ -15208,7 +15270,6 @@ package body Sem_Prag is\n          when Pragma_Invariant => Invariant : declare\n             Type_Id : Node_Id;\n             Typ     : Entity_Id;\n-            PDecl   : Node_Id;\n             Discard : Boolean;\n \n          begin\n@@ -15265,10 +15326,8 @@ package body Sem_Prag is\n             --  procedure declaration, so that calls to it can be generated\n             --  before the body is built (e.g. within an expression function).\n \n-            PDecl := Build_Invariant_Procedure_Declaration (Typ);\n-\n-            Insert_After (N, PDecl);\n-            Analyze (PDecl);\n+            Insert_After_And_Analyze\n+              (N, Build_Invariant_Procedure_Declaration (Typ));\n \n             if Class_Present (N) then\n                Set_Has_Inheritable_Invariants (Typ);\n@@ -24719,6 +24778,7 @@ package body Sem_Prag is\n       Pragma_Debug                          => -1,\n       Pragma_Debug_Policy                   =>  0,\n       Pragma_Detect_Blocking                => -1,\n+      Pragma_Default_Initial_Condition      => -1,\n       Pragma_Default_Scalar_Storage_Order   =>  0,\n       Pragma_Default_Storage_Pool           => -1,\n       Pragma_Depends                        => -1,\n@@ -25105,34 +25165,35 @@ package body Sem_Prag is\n          when\n             --  RM defined\n \n-            Name_Assert               |\n-            Name_Static_Predicate     |\n-            Name_Dynamic_Predicate    |\n-            Name_Pre                  |\n-            Name_uPre                 |\n-            Name_Post                 |\n-            Name_uPost                |\n-            Name_Type_Invariant       |\n-            Name_uType_Invariant      |\n+            Name_Assert                    |\n+            Name_Static_Predicate          |\n+            Name_Dynamic_Predicate         |\n+            Name_Pre                       |\n+            Name_uPre                      |\n+            Name_Post                      |\n+            Name_uPost                     |\n+            Name_Type_Invariant            |\n+            Name_uType_Invariant           |\n \n             --  Impl defined\n \n-            Name_Assert_And_Cut       |\n-            Name_Assume               |\n-            Name_Contract_Cases       |\n-            Name_Debug                |\n-            Name_Initial_Condition    |\n-            Name_Invariant            |\n-            Name_uInvariant           |\n-            Name_Loop_Invariant       |\n-            Name_Loop_Variant         |\n-            Name_Postcondition        |\n-            Name_Precondition         |\n-            Name_Predicate            |\n-            Name_Refined_Post         |\n-            Name_Statement_Assertions => return True;\n-\n-         when others                  => return False;\n+            Name_Assert_And_Cut            |\n+            Name_Assume                    |\n+            Name_Contract_Cases            |\n+            Name_Debug                     |\n+            Name_Default_Initial_Condition |\n+            Name_Initial_Condition         |\n+            Name_Invariant                 |\n+            Name_uInvariant                |\n+            Name_Loop_Invariant            |\n+            Name_Loop_Variant              |\n+            Name_Postcondition             |\n+            Name_Precondition              |\n+            Name_Predicate                 |\n+            Name_Refined_Post              |\n+            Name_Statement_Assertions      => return True;\n+\n+         when others                       => return False;\n       end case;\n    end Is_Valid_Assertion_Kind;\n "}, {"sha": "e325b9ff14c717575b0e67ef5af1798a5f54cf6d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -48,6 +48,7 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Attr; use Sem_Attr;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n@@ -1229,6 +1230,189 @@ package body Sem_Util is\n       return Decl;\n    end Build_Component_Subtype;\n \n+   ----------------------------------\n+   -- Build_Default_Init_Cond_Call --\n+   ----------------------------------\n+\n+   function Build_Default_Init_Cond_Call\n+     (Loc    : Source_Ptr;\n+      Obj_Id : Entity_Id;\n+      Typ    : Entity_Id) return Node_Id\n+   is\n+      Proc_Id    : constant Entity_Id := Default_Init_Cond_Procedure (Typ);\n+      Formal_Typ : constant Entity_Id := Etype (First_Formal (Proc_Id));\n+\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => New_Occurrence_Of (Proc_Id, Loc),\n+          Parameter_Associations => New_List (\n+            Make_Type_Conversion (Loc,\n+              Subtype_Mark => New_Occurrence_Of (Formal_Typ, Loc),\n+              Expression   => New_Occurrence_Of (Obj_Id, Loc))));\n+   end Build_Default_Init_Cond_Call;\n+\n+   --------------------------------------------\n+   -- Build_Default_Init_Cond_Procedure_Body --\n+   --------------------------------------------\n+\n+   procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id) is\n+      Param_Id : Entity_Id;\n+      --  The entity of the formal parameter of the default initial condition\n+      --  procedure.\n+\n+      procedure Replace_Type_Reference (N : Node_Id);\n+      --  Replace a single reference to type Typ with a reference to Param_Id\n+\n+      ----------------------------\n+      -- Replace_Type_Reference --\n+      ----------------------------\n+\n+      procedure Replace_Type_Reference (N : Node_Id) is\n+      begin\n+         Rewrite (N, New_Occurrence_Of (Param_Id, Sloc (N)));\n+      end Replace_Type_Reference;\n+\n+      procedure Replace_Type_References is\n+        new Replace_Type_References_Generic (Replace_Type_Reference);\n+\n+      --  Local variables\n+\n+      Loc       : constant Source_Ptr := Sloc (Typ);\n+      Prag      : constant Node_Id    :=\n+                    Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n+      Proc_Id   : constant Entity_Id  := Default_Init_Cond_Procedure (Typ);\n+      Spec_Decl : constant Node_Id    := Unit_Declaration_Node (Proc_Id);\n+      Body_Decl : Node_Id;\n+      Expr      : Node_Id;\n+      Stmt      : Node_Id;\n+\n+   --  Start of processing for Build_Default_Init_Cond_Procedure\n+\n+   begin\n+      --  The procedure should be generated only for types subject to pragma\n+      --  Default_Initial_Condition. Types that inherit the pragma do not get\n+      --  this specialized procedure.\n+\n+      pragma Assert (Has_Default_Init_Cond (Typ));\n+      pragma Assert (Present (Prag));\n+      pragma Assert (Present (Proc_Id));\n+\n+      --  Nothing to do if the body was already built\n+\n+      if Present (Corresponding_Body (Spec_Decl)) then\n+         return;\n+      end if;\n+\n+      Param_Id := First_Formal (Proc_Id);\n+\n+      --  The pragma has an argument. Note that the argument is analyzed after\n+      --  all references to the current instance of the type are replaced.\n+\n+      if Present (Pragma_Argument_Associations (Prag)) then\n+         Expr := Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+\n+         if Nkind (Expr) = N_Null then\n+            Stmt := Make_Null_Statement (Loc);\n+\n+         --  Preserve the original argument of the pragma by replicating it.\n+         --  Replace all references to the current instance of the type with\n+         --  references to the formal parameter.\n+\n+         else\n+            Expr := New_Copy_Tree (Expr);\n+            Replace_Type_References (Expr, Typ);\n+\n+            --  Generate:\n+            --    pragma Check (Default_Initial_Condition, <Expr>);\n+\n+            Stmt :=\n+              Make_Pragma (Loc,\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Loc, Name_Check),\n+\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression =>\n+                      Make_Identifier (Loc, Name_Default_Initial_Condition)),\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Expr)));\n+         end if;\n+\n+      --  Otherwise the pragma appears without an argument\n+\n+      else\n+         Stmt := Make_Null_Statement (Loc);\n+      end if;\n+\n+      --  Generate:\n+      --    procedure <Typ>Default_Init_Cond (I : <Typ>) is\n+      --    begin\n+      --       <Stmt>;\n+      --    end <Typ>Default_Init_Cond;\n+\n+      Body_Decl :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Copy_Separate_Tree (Specification (Spec_Decl)),\n+          Declarations               => Empty_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Stmt)));\n+\n+      --  Link the spec and body of the default initial condition procedure\n+      --  to prevent the generation of a duplicate body in case there is an\n+      --  attempt to freeze the related type again.\n+\n+      Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n+      Set_Corresponding_Spec (Body_Decl, Proc_Id);\n+\n+      Append_Freeze_Action (Typ, Body_Decl);\n+   end Build_Default_Init_Cond_Procedure_Body;\n+\n+   ---------------------------------------------------\n+   -- Build_Default_Init_Cond_Procedure_Declaration --\n+   ---------------------------------------------------\n+\n+   procedure Build_Default_Init_Cond_Procedure_Declaration (Typ : Entity_Id) is\n+      Loc     : constant Source_Ptr := Sloc (Typ);\n+      Prag    : constant Node_Id    :=\n+                  Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n+      Proc_Id : Entity_Id;\n+\n+   begin\n+      --  The procedure should be generated only for types subject to pragma\n+      --  Default_Initial_Condition. Types that inherit the pragma do not get\n+      --  this specialized procedure.\n+\n+      pragma Assert (Has_Default_Init_Cond (Typ));\n+      pragma Assert (Present (Prag));\n+\n+      Proc_Id  :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Typ), \"Default_Init_Cond\"));\n+\n+      --  Associate the default initial condition procedure with the private\n+      --  type.\n+\n+      Set_Ekind (Proc_Id, E_Procedure);\n+      Set_Is_Default_Init_Cond_Procedure (Proc_Id);\n+      Set_Default_Init_Cond_Procedure (Typ, Proc_Id);\n+\n+      --  Generate:\n+      --    procedure <Typ>Default_Init_Cond (Inn : <Typ>);\n+\n+      Insert_After_And_Analyze (Prag,\n+        Make_Subprogram_Declaration (Loc,\n+          Specification =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Proc_Id,\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Make_Temporary (Loc, 'I'),\n+                  Parameter_Type      => New_Occurrence_Of (Typ, Loc))))));\n+   end Build_Default_Init_Cond_Procedure_Declaration;\n+\n    ---------------------------\n    -- Build_Default_Subtype --\n    ---------------------------\n@@ -9066,6 +9250,23 @@ package body Sem_Util is\n       return Empty;\n    end Incomplete_Or_Private_View;\n \n+   -----------------------------------------\n+   -- Inherit_Default_Init_Cond_Procedure --\n+   -----------------------------------------\n+\n+   procedure Inherit_Default_Init_Cond_Procedure (Typ : Entity_Id) is\n+      Par_Typ : constant Entity_Id := Etype (Typ);\n+\n+   begin\n+      --  A derived type inherits the default initial condition procedure of\n+      --  its parent type.\n+\n+      if No (Default_Init_Cond_Procedure (Typ)) then\n+         Set_Default_Init_Cond_Procedure\n+           (Typ, Default_Init_Cond_Procedure (Par_Typ));\n+      end if;\n+   end Inherit_Default_Init_Cond_Procedure;\n+\n    ---------------------------------\n    -- Insert_Explicit_Dereference --\n    ---------------------------------"}, {"sha": "025b0cfbbe8101b6b27468a07f78f13aaea7b897", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -211,6 +211,25 @@ package Sem_Util is\n    --  Determine whether a selected component has a type that depends on\n    --  discriminants, and build actual subtype for it if so.\n \n+   function Build_Default_Init_Cond_Call\n+     (Loc    : Source_Ptr;\n+      Obj_Id : Entity_Id;\n+      Typ    : Entity_Id) return Node_Id;\n+   --  Build a call to the default initial condition procedure of type Typ with\n+   --  Obj_Id as the actual parameter.\n+\n+   procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id);\n+   --  If private type Typ is subject to pragma Default_Initial_Condition,\n+   --  build the body of the procedure which verifies the assumption of the\n+   --  pragma at runtime. The generated body is added to the freeze actions\n+   --  of the type.\n+\n+   procedure Build_Default_Init_Cond_Procedure_Declaration (Typ : Entity_Id);\n+   --  If private type Typ is subject to pragma Default_Initial_Condition,\n+   --  build the declaration of the procedure which verifies the assumption\n+   --  of the pragma at runtime. The declaration is inserted after the related\n+   --  pragma.\n+\n    function Build_Default_Subtype\n      (T : Entity_Id;\n       N : Node_Id) return Entity_Id;\n@@ -1065,6 +1084,10 @@ package Sem_Util is\n    --  the same type. Note that Typ may not have a partial view to begin with,\n    --  in that case the function returns Empty.\n \n+   procedure Inherit_Default_Init_Cond_Procedure (Typ : Entity_Id);\n+   --  Inherit the default initial condition procedure from the parent type of\n+   --  derived type Typ.\n+\n    procedure Insert_Explicit_Dereference (N : Node_Id);\n    --  In a context that requires a composite or subprogram type and where a\n    --  prefix is an access type, rewrite the access type node N (which is the\n@@ -1596,17 +1619,17 @@ package Sem_Util is\n    --  (e.g. target of assignment, or out parameter), and to False if the\n    --  modification is only potential (e.g. address of entity taken).\n \n+   function Object_Access_Level (Obj : Node_Id) return Uint;\n+   --  Return the accessibility level of the view of the object Obj. For\n+   --  convenience, qualified expressions applied to object names are also\n+   --  allowed as actuals for this function.\n+\n    function Original_Corresponding_Operation (S : Entity_Id) return Entity_Id;\n    --  [Ada 2012: AI05-0125-1]: If S is an inherited dispatching primitive S2,\n    --  or overrides an inherited dispatching primitive S2, the original\n    --  corresponding operation of S is the original corresponding operation of\n    --  S2. Otherwise, it is S itself.\n \n-   function Object_Access_Level (Obj : Node_Id) return Uint;\n-   --  Return the accessibility level of the view of the object Obj. For\n-   --  convenience, qualified expressions applied to object names are also\n-   --  allowed as actuals for this function.\n-\n    function Original_Aspect_Name (N : Node_Id) return Name_Id;\n    --  N is a pragma node or aspect specification node. This function returns\n    --  the name of the pragma or aspect in original source form, taking into"}, {"sha": "c1b62b29e3a36aa0cbe4c19b2ac4ca9844d2e221", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e477d718a36af484ef589a9328af19b409d98105/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=e477d718a36af484ef589a9328af19b409d98105", "patch": "@@ -479,6 +479,7 @@ package Snames is\n    --  pragma.\n \n    Name_Debug                          : constant Name_Id := N + $; -- GNAT\n+   Name_Default_Initial_Condition      : constant Name_Id := N + $; -- GNAT\n    Name_Depends                        : constant Name_Id := N + $; -- GNAT\n    Name_Effective_Reads                : constant Name_Id := N + $; -- GNAT\n    Name_Effective_Writes               : constant Name_Id := N + $; -- GNAT\n@@ -1810,6 +1811,7 @@ package Snames is\n       Pragma_CPP_Virtual,\n       Pragma_CPP_Vtable,\n       Pragma_Debug,\n+      Pragma_Default_Initial_Condition,\n       Pragma_Depends,\n       Pragma_Effective_Reads,\n       Pragma_Effective_Writes,"}]}