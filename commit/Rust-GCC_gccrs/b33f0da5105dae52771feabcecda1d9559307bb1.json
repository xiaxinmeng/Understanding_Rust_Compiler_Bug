{"sha": "b33f0da5105dae52771feabcecda1d9559307bb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMzZjBkYTUxMDVkYWU1Mjc3MWZlYWJjZWNkYTFkOTU1OTMwN2JiMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-20T23:31:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-20T23:31:50Z"}, "message": "Replacement file, for as1750.\n\nFrom-SVN: r8109", "tree": {"sha": "0bc45c875a187aa12178993753f198c3779f01e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bc45c875a187aa12178993753f198c3779f01e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b33f0da5105dae52771feabcecda1d9559307bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33f0da5105dae52771feabcecda1d9559307bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b33f0da5105dae52771feabcecda1d9559307bb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33f0da5105dae52771feabcecda1d9559307bb1/comments", "author": null, "committer": null, "parents": [{"sha": "a4da349f823e4fdf41d50787623571a61d40c791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4da349f823e4fdf41d50787623571a61d40c791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4da349f823e4fdf41d50787623571a61d40c791"}], "stats": {"total": 1086, "additions": 581, "deletions": 505}, "files": [{"sha": "d2a117b353f1f7f65eceeefa93b8c31dedc096fa", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 355, "deletions": 297, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33f0da5105dae52771feabcecda1d9559307bb1/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33f0da5105dae52771feabcecda1d9559307bb1/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=b33f0da5105dae52771feabcecda1d9559307bb1", "patch": "@@ -1,6 +1,6 @@\n-/* Subroutines for insn-output.c for MIL-STD-1750A.\n+/* Subroutines for insn-output.c for MIL-STD-1750.\n    Copyright (C) 1994 Free Software Foundation, Inc.\n-   Contributed by O.M.Kellogg, Deutsche Aerospace (okellogg@salyko.cube.net).\n+   Contributed by O.M.Kellogg, DASA (okellogg@salyko.cube.net).\n \n This file is part of GNU CC.\n \n@@ -36,11 +36,13 @@ int datalbl_ndx = -1;\n struct jumplabel_array jmplbl[JMPLBL_ARRSIZ];\n int jmplbl_ndx = -1;\n int label_pending = 0, program_counter = 0;\n-enum section  current_section=NREL;\n-char *sectname[4] = { \"NREL\",\"IREL\",\"KREL\",\"SREL\" };\n+enum section current_section = Normal;\n+char *sectname[4] =\n+{\"Normal\", \"Init\", \"Konst\", \"Static\"};\n \n-int notice_update_cc(exp)\n-  rtx exp;\n+int\n+notice_update_cc (exp)\n+     rtx exp;\n {\n   if (GET_CODE (exp) == SET)\n     {\n@@ -66,8 +68,8 @@ int notice_update_cc(exp)\n \t}\n       /* Emulated longword bit-ops leave cc's incorrect */\n       else if (GET_MODE (SET_DEST (exp)) == HImode ?\n-               src_code == AND || src_code == IOR ||\n-               src_code == XOR || src_code == NOT : 0)\n+\t       src_code == AND || src_code == IOR ||\n+\t       src_code == XOR || src_code == NOT : 0)\n \t{\n \t  CC_STATUS_INIT;\n \t  return;\n@@ -82,7 +84,7 @@ int notice_update_cc(exp)\n       /* Anything that lands in a reg will set cc_status. */\n       else if (REG_P (SET_DEST (exp)))\n \t{\n-          cc_status.flags = CC_NO_OVERFLOW;\n+\t  cc_status.flags = CC_NO_OVERFLOW;\n \t  cc_status.value1 = SET_SRC (exp);\n \t  cc_status.value2 = SET_DEST (exp);\n \t  return;\n@@ -112,184 +114,191 @@ int notice_update_cc(exp)\n }\n \n \n-rtx function_arg(cum,mode,type,named)\n-  int cum;\n-  enum machine_mode mode;\n-  tree type;\n-  int named;\n+rtx\n+function_arg (cum, mode, type, named)\n+     int cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n {\n   int size;\n   rtx result;\n \n-  if (MUST_PASS_IN_STACK(mode,type))\n+  if (MUST_PASS_IN_STACK (mode, type))\n     return (rtx) 0;\n   if (mode == BLKmode)\n-    size = int_size_in_bytes(type);\n+    size = int_size_in_bytes (type);\n   else\n     size = GET_MODE_SIZE (mode);\n-  if (cum + size < 12) \n-    return gen_rtx(REG, mode, cum);\n+  if (cum + size < 12)\n+    return gen_rtx (REG, mode, cum);\n   else\n     return (rtx) 0;\n }\n \n \n-char *tekasm_float(exp_char,value)\n-  char exp_char;\n-  double value;\n+#ifndef STRDUP\n+char *\n+strdup (str)\n+     char *str;\n {\n-  extern char *strpbrk();\n-  int found_letter = 0;\n   char *p;\n-  static char fbuf[20];\n-    \n-  sprintf(fbuf,\"%g\",value);\n-  if ((p = strpbrk(fbuf,\"Ee\")) == NULL)\n-    sprintf(fbuf+strlen(fbuf),\"%c0\",exp_char);\n-  else\n-    *p = exp_char;\n-  return fbuf;\n+  if (str == NULL)\n+    return NULL;\n+  if ((p = (char *) malloc (strlen (str) + 1)) == NULL)\n+    {\n+      fprintf (stderr, \"dynamic memory exhausted\");\n+      abort ();\n+    }\n+  return strcpy (p, str);\n }\n \n-char *asm_float_syntax(rtx x)\n+#endif\n+\n+\n+double\n+get_double (x)\n+     rtx x;\n {\n-  if (GET_MODE(x) == HFmode)\n+  union\n     {\n-      union { double d; int i[2]; } du;\n-      union { float f; int i; } su;\n-      du.i[0] = CONST_DOUBLE_LOW(x);\n-      du.i[1] = CONST_DOUBLE_HIGH(x);\n-      su.f = (float) du.d;\n-      return tekasm_float('E',su.f);\n-    }\n-  else\n-    {\n-      union { double d; int i[2]; } du;\n-      du.i[0] = CONST_DOUBLE_LOW(x);\n-      du.i[1] = CONST_DOUBLE_HIGH(x);\n-      return tekasm_float('D',du.d);\n+      double d;\n+      long i[2];\n     }\n+  du;\n+\n+  du.i[0] = CONST_DOUBLE_LOW (x);\n+  du.i[1] = CONST_DOUBLE_HIGH (x);\n+  return du.d;\n }\n \n-char *float_label(char code,char *fltstr)\n+char *\n+float_label (code, value)\n+     char code;\n+     double value;\n {\n-    int i=1;\n-    static char label[32];\n-    \n-    label[0] = code;\n-    while (*fltstr)\n+  int i = 1;\n+  static char label[32];\n+  char *p;\n+\n+  label[0] = code;\n+  p = label + 1;\n+  sprintf (p, \"%lf\", value);\n+  while (*p)\n     {\n-\tlabel[i] = (*fltstr == '+') ? 'p' :\n-\t\t   (*fltstr == '-') ? 'm' : *fltstr;\n-\ti++;\n-\tfltstr++;\n+      *p = (*p == '+') ? 'p' :\n+\t(*p == '-') ? 'm' : *p;\n+      p++;\n     }\n-    if (i > 11)\n-\ti = 11;\n-    label[i] = '\\0';\n-    return label;\n+  return strdup (label);\n }\n \n \n-char *movcnt_regno_adjust(rtx *op)\n+char *\n+movcnt_regno_adjust (rtx * op)\n {\n   static char outstr[40];\n-  int cntreg = REGNO(op[2]), cntreg_1750 = REGNO(op[0]) + 1;\n-  int dstreg = REGNO(op[0]), srcreg = REGNO(op[1]);\n+  int cntreg = REGNO (op[2]), cntreg_1750 = REGNO (op[0]) + 1;\n+  int dstreg = REGNO (op[0]), srcreg = REGNO (op[1]);\n \n   if (cntreg == cntreg_1750)\n-    sprintf(outstr,\"MOV    R%%0,R%%1\");\n-  else if (dstreg+1 == srcreg && srcreg == cntreg+2)\n-    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,R%%1\",cntreg,dstreg);\n-  else if (dstreg+1 == srcreg && srcreg < cntreg)\n-    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,R%%1\",srcreg,cntreg);\n-  else if (srcreg+1 == cntreg && dstreg > cntreg)\n-    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,R%%1\",srcreg,dstreg);\n+    sprintf (outstr, \"mov r%%0,r%%1\");\n+  else if (dstreg + 1 == srcreg && srcreg == cntreg + 2)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,r%%1\", cntreg, dstreg);\n+  else if (dstreg + 1 == srcreg && srcreg < cntreg)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,r%%1\", srcreg, cntreg);\n+  else if (srcreg + 1 == cntreg && dstreg > cntreg)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,r%%1\", srcreg, dstreg);\n   else\n-    sprintf(outstr,\"XWR    R%d,R%d\\n\\tMOV    R%%0,%%1\\n\\tXWR     R%d,R%d\",\n-\t\t   cntreg,cntreg_1750,cntreg_1750,cntreg);\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,%%1\\n\\txwr r%d,r%d\",\n+\t     cntreg, cntreg_1750, cntreg_1750, cntreg);\n   return outstr;\n }\n \n-char *mod_regno_adjust(char *instr,rtx *op)\n+char *\n+mod_regno_adjust (char *instr, rtx * op)\n {\n   static char outstr[40];\n-  char *r = (!strncmp(instr,\"DVR\",3) ? \"R\" : \"\");\n-  int modregno_gcc = REGNO(op[3]), modregno_1750 = REGNO(op[0]) + 1;\n+  char *r = (!strncmp (instr, \"dvr\", 3) ? \"r\" : \"\");\n+  int modregno_gcc = REGNO (op[3]), modregno_1750 = REGNO (op[0]) + 1;\n \n   if (modregno_gcc == modregno_1750)\n-    sprintf(outstr,\"%s   R%%0,%s%%2\",instr,r);\n+    sprintf (outstr, \"%s r%%0,%s%%2\", instr, r);\n   else\n-    sprintf(outstr,\"LR     R%d,R%d\\n\\t%s   R%%0,%s%%2\\n\\tXWR     R%d,R%d\",\n-\t    modregno_gcc,modregno_1750,instr,r,modregno_1750,modregno_gcc);\n+    sprintf (outstr, \"lr r%d,r%d\\n\\t%s r%%0,%s%%2\\n\\txwr r%d,r%d\",\n+\tmodregno_gcc, modregno_1750, instr, r, modregno_1750, modregno_gcc);\n   return outstr;\n }\n \n \n /* Auxiliary to `nonindirect_operand':\n    Check if op is a valid memory operand for 1750A arith./logic (non-move)\n    instructions. */\n-int memop_valid(register rtx op)\n+int\n+memop_valid (register rtx op)\n {\n-  if (GET_MODE(op) != Pmode && GET_MODE(op) != VOIDmode)\n+  if (GET_MODE (op) != Pmode && GET_MODE (op) != VOIDmode)\n     return 0;\n-  switch (GET_CODE(op))\n+  switch (GET_CODE (op))\n     {\n-      case MEM:\n-      case MINUS:\n-      case MULT:\n-      case DIV:\n-\treturn 0;\n-      case PLUS:\n-\tif (! memop_valid(XEXP(op,0)))\n-\t    return 0;\n-\treturn memop_valid(XEXP(op,1));\n-      case REG:\n-\tif (REGNO(op) > 0)\n-\t    return 1;\n+    case MEM:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+      return 0;\n+    case PLUS:\n+      if (!memop_valid (XEXP (op, 0)))\n \treturn 0;\n-      case CONST:\n-      case CONST_INT:\n-      case SYMBOL_REF:\n-      case SUBREG:\n-\treturn 1;\n-      default:\n-\tprintf(\"memop_valid: code=%d\\n\",(int) GET_CODE(op));\n+      return memop_valid (XEXP (op, 1));\n+    case REG:\n+      if (REGNO (op) > 0)\n \treturn 1;\n+      return 0;\n+    case CONST:\n+    case CONST_INT:\n+    case SYMBOL_REF:\n+    case SUBREG:\n+      return 1;\n+    default:\n+      printf (\"memop_valid: code=%d\\n\", (int) GET_CODE (op));\n+      return 1;\n     }\n }\n \n /* extra predicate for recog: */\n-int nonindirect_operand(register rtx op, enum machine_mode mode)\n+int\n+nonindirect_operand (register rtx op, enum machine_mode mode)\n {\n   int retval;\n \n-  switch (GET_CODE(op))\n+  switch (GET_CODE (op))\n     {\n-      case MEM:\n-\tretval = memop_valid(XEXP(op,0));\n-\treturn retval;\n-      case REG:\n-\treturn 1;\n-      default:\n-\tif (! CONSTANT_P(op))\n-\t    return 0;\n+    case MEM:\n+      retval = memop_valid (XEXP (op, 0));\n+      return retval;\n+    case REG:\n+      return 1;\n+    default:\n+      if (!CONSTANT_P (op))\n+\treturn 0;\n     }\n   return 1;\n }\n \n /* predicate for the STC instruction: */\n-int small_nonneg_const(register rtx op, enum machine_mode mode)\n+int\n+small_nonneg_const (register rtx op, enum machine_mode mode)\n {\n-  if (GET_CODE(op) == CONST_INT && INTVAL(op) >= 0 && INTVAL(op) <= 15)\n+  if (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) <= 15)\n     return 1;\n   return 0;\n }\n \n /* Decide whether to output a conditional jump as a \"Jump Conditional\"\n    or as a \"Branch Conditional\": */\n \n-int find_jmplbl(int labelnum)\n+int\n+find_jmplbl (int labelnum)\n {\n   int i, found = 0;\n \n@@ -304,227 +313,276 @@ int find_jmplbl(int labelnum)\n   return -1;\n }\n \n-char *branch_or_jump(char *condition, int targetlabel_number)\n+char *\n+branch_or_jump (char *condition, int targetlabel_number)\n {\n   static char buf[30];\n   int index;\n \n-  if ((index = find_jmplbl(targetlabel_number)) >= 0)\n+  if ((index = find_jmplbl (targetlabel_number)) >= 0)\n     if (program_counter - jmplbl[index].pc < 128)\n       {\n-\tsprintf(buf,\"B%s    %%l0\",condition);\n+\tsprintf (buf, \"b%s %%l0\", condition);\n \treturn buf;\n       }\n-  sprintf(buf,\"JC     %s,%%l0\",condition);\n+  sprintf (buf, \"jc %s,%%l0\", condition);\n   return buf;\n }\n \n \n \n-/* The PRINT_OPERAND and PRINT_OPERAND_ADDRESS macros have been \n+/* The PRINT_OPERAND and PRINT_OPERAND_ADDRESS macros have been\n    made functions: */\n \n-print_operand(file, x, code)\n-  FILE *file;\n-  rtx x;\n-  enum rtx_code code;\n-{ \n-  switch (GET_CODE(x))\n+print_operand (file, x, kode)\n+     FILE *file;\n+     rtx x;\n+     enum rtx_code kode;\n+{\n+  switch (GET_CODE (x))\n     {\n-      case REG:\n-        fprintf (file, \"%d\",REGNO (x));\n-        break;\n-      case SYMBOL_REF:\n-        fprintf(file,\"%s\",XSTR(x,0));\n-        break;\n-      case LABEL_REF:\n-      case CONST:\n-      case MEM:\n-        output_address(XEXP(x,0));\n-        break;\n-      case CONST_DOUBLE:\n-        if (code == 'D' || code == 'E')\t/* KREL output hack: */\n-          {\t\t/* make a label out of a floating-point number. */\n-            char *fltstr = (char *)asm_float_syntax(x);\n-            int i, found = 0;\n-            for (i = 0; i <= datalbl_ndx; i++)\n-\t      if (strcmp(fltstr,datalbl[i].value) == 0) { found = 1; break; }\n-            if (! found)\n+    case REG:\n+      fprintf (file, \"%d\", REGNO (x));\n+      break;\n+    case SYMBOL_REF:\n+      fprintf (file, \"%s\", XSTR (x, 0));\n+      break;\n+    case LABEL_REF:\n+    case CONST:\n+    case MEM:\n+      output_address (XEXP (x, 0));\n+      break;\n+    case CONST_DOUBLE:\n+/*    {\n+\tdouble value = get_double (x);\n+\tchar fltstr[32];\n+\tsprintf (fltstr, \"%lf\", value);\n+\n+\tif (kode == 'D' || kode == 'E')\n+\t  {\n+\t    int i, found = 0;\n+\t    for (i = 0; i <= datalbl_ndx; i++)\n+\t      if (strcmp (fltstr, datalbl[i].value) == 0)\n+\t\t{\n+\t\t  found = 1;\n+\t\t  break;\n+\t\t}\n+\t    if (!found)\n \t      {\n-\t        strcpy(datalbl[i = ++datalbl_ndx].value,fltstr);\n-                strcpy(datalbl[i].name,(char *)float_label(code,fltstr));\n-\t        datalbl[i].size = (code=='D') ? 3 : 2;\n-\t        check_section(KREL);\n-\t        fprintf(file,\"K%s \\tDATAF %s ;p_o\\n\", datalbl[i].name,fltstr);\n-\t        check_section(NREL);\n-              }\n-          }\n-\telse if (code == 'F')\n+\t\tstrcpy (datalbl[i = ++datalbl_ndx].value, fltstr);\n+\t\tdatalbl[i].name = float_label (kode, value);\n+\t\tdatalbl[i].size = (kode == 'E') ? 3 : 2;\n+\t\tcheck_section (Konst);\n+\t\tfprintf (file, \"K%s \\tdata%s %s ;p_o\\n\", datalbl[i].name,\n+\t\t\t(kode == 'E' ? \"ef\" : \"f\"), fltstr);\n+\t\tcheck_section (Normal);\n+\t      }\n+\t  }\n+\telse if (kode == 'F' || kode == 'G')\n \t  {\n-            char *fltstr = (char *)asm_float_syntax(x);\n-            int i, found = 0;\n-            for (i = 0; i <= datalbl_ndx; i++)\n-\t      if (strcmp(fltstr,datalbl[i].value) == 0)\n+\t    int i, found = 0;\n+\t    for (i = 0; i <= datalbl_ndx; i++)\n+\t      if (strcmp (fltstr, datalbl[i].value) == 0)\n \t\t{\n \t\t  found = 1;\n \t\t  break;\n \t\t}\n-            if (! found)\n+\t    if (!found)\n \t      {\n-\t\tprintf(\"Aborting: 'F' float label not found in datalbl[].\\n\");\n-\t \tabort();\n+\t\tfprintf (stderr,\n+\t\t   \"float value %lfnot found upon label reference\\n\", value);\n+\t\tstrcpy (datalbl[i = ++datalbl_ndx].value, fltstr);\n+\t\tdatalbl[i].name = float_label (kode, value);\n+\t\tdatalbl[i].size = (kode == 'G') ? 3 : 2;\n+\t\tcheck_section (Konst);\n+\t\tfprintf (file, \"K%s \\tdata%s %s ;p_o\\n\", datalbl[i].name,\n+\t\t\t(kode == 'G' ? \"ef\" : \"f\"), fltstr);\n+\t\tcheck_section (Normal);\n \t      }\n-\t    fprintf(file,\"%s ;P_O 'F'\",datalbl[i].name);\n-          }\n+\t    fprintf (file, \"%s ;P_O 'F'\", datalbl[i].name);\n+\t  }\n \telse\n-\t  fprintf(file,\"%s  ;P_O cst_dbl\",(char *)asm_float_syntax(x));\n-\tbreak;\n-      case CONST_INT:\n-\tif (code == 'J')\n-\t  fprintf (file, \"%d\",-INTVAL(x));\n-\telse if (INTVAL(x) > 0x7FFF)\n-\t  fprintf (file, \"%d  ; range correction (val>0x7FFF) applied\",\n-\t \t\t INTVAL(x) - 0x10000);\n+\t  fprintf (file, \" %s  ;P_O cst_dbl \", fltstr);\n+      }\n+ */\n+      fprintf (file, \"%lf\", get_double (x));\n+      break;\n+    case CONST_INT:\n+      if (kode == 'J')\n+\tfprintf (file, \"%d\", -INTVAL (x));\n+      else if (INTVAL (x) > 0x7FFF)\n+\tfprintf (file, \"%d  ; range correction (val>0x7FFF) applied\",\n+\t\t INTVAL (x) - 0x10000);\n+      else\n+\tfprintf (file, \"%d\", INTVAL (x));\n+      break;\n+    case CODE_LABEL:\n+      fprintf (file, \"L%d\", XINT (x, 3));\n+      break;\n+    case CALL:\n+      fprintf (file, \"CALL nargs=%d, func is either '%s' or '%s'\",\n+       XEXP (x, 1), XSTR (XEXP (XEXP (x, 0), 1), 0), XSTR (XEXP (x, 0), 1));\n+      break;\n+    case PLUS:\n+      {\n+\trtx op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n+\tint op0code = GET_CODE (op0), op1code = GET_CODE (op1);\n+\tif (op1code == CONST_INT)\n+\t  switch (op0code)\n+\t    {\n+\t    case REG:\n+\t      fprintf (file, \"%d,r%d  ; p_o_PLUS for REG and CONST\",\n+\t\t       INTVAL (op1), REGNO (op0));\n+\t      break;\n+\t    case SYMBOL_REF:\n+\t      fprintf (file, \"%d+%s\", INTVAL (op1), XSTR (op0, 0));\n+\t      break;\n+\t    case MEM:\n+\t      fprintf (file, \"%d,[mem:\", INTVAL (op1));\n+\t      output_address (XEXP (op0, 0));\n+\t      fprintf (file, \"] ;P_O plus\");\n+\t      break;\n+\t    default:\n+\t      fprintf (file, \"p_o_PLUS UFO, code=%d, with CONST=%d\",\n+\t\t       (int) op0code, INTVAL (op1));\n+\t    }\n+\telse if (op1code == SYMBOL_REF && op0code == REG)\n+\t  fprintf (file, \"%s,r%d  ; P_O: (plus reg sym)\",\n+\t\t   XSTR (op1, 0), REGNO (op0));\n \telse\n-\t  fprintf (file, \"%d\", INTVAL(x));\n-\tbreak;\n-      case CODE_LABEL:\n-\tfprintf (file, \"L%d\", XINT(x,3));\n-\tbreak;\n-      case CALL:\n-\tfprintf(file,\"CALL nargs=%d, func is either '%s' or '%s'\",\n-                XEXP(x,1),XSTR(XEXP(XEXP(x,0),1),0),XSTR(XEXP(x,0),1));\n-\tbreak;\n-      case PLUS:\n-        {\n-\t  rtx op0 = XEXP(x,0), op1 = XEXP(x,1);\n-\t  int op0code=GET_CODE(op0), op1code=GET_CODE(op1);\n-          if (op1code == CONST_INT)\n-            switch (op0code)\n-\t      {\n-\t\tcase REG:\n-\t\t  fprintf(file,\"%d,R%d  ; p_o_PLUS for REG and CONST\",\n-\t\t\tINTVAL(op1),REGNO(op0));\n-\t\t  break;\n-\t\tcase SYMBOL_REF:\n-\t\t  fprintf(file,\"%d+%s\",INTVAL(op1),XSTR(op0,0));\n-\t\t  break;\n-\t\tcase MEM:\n-\t\t  fprintf(file,\"%d,[mem:\",INTVAL(op1));\n-\t\t  output_address(XEXP(op0,0));\n-\t\t  fprintf(file,\"] ;P_O plus\");\n-\t\t  break;\n-\t\tdefault:\n-\t\t  fprintf(file,\"p_o_PLUS UFO, code=%d, with CONST=%d\",\n-\t\t\t\t(int)op0code,INTVAL(op1));\n-\t      }\n-\t  else if (op1code == SYMBOL_REF && op0code == REG)\n-\t    fprintf(file,\"%s,R%d  ; P_O: (plus reg sym)\",\n-\t\t\tXSTR(op1,0),REGNO(op0));\n-          else\n-            fprintf(file,\"p_o_+: op0code=%d, op1code=%d\",op0code,op1code);\n-        }\n-\tbreak;\n-      default:\n-\tfprintf (file, \"p_o_UFO code=%d\", GET_CODE(x));\n+\t  fprintf (file, \"p_o_+: op0code=%d, op1code=%d\", op0code, op1code);\n+      }\n+      break;\n+    default:\n+      fprintf (file, \"p_o_UFO code=%d\", GET_CODE (x));\n     }\n }\n \n-print_operand_address(file, addr)\n-  FILE *file;\n-  rtx addr;\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n {\n   switch (GET_CODE (addr))\n     {\n-      case REG:\n-\tfprintf (file, \"0,R%d ; P_O_A\", REGNO (addr));\n-\tbreak;\n-      case PLUS:\n-\t{\n-\t  register rtx x = XEXP(addr,0), y = XEXP(addr,1);\n-\t  switch (GET_CODE(x))\n-\t    {\n-\t      case REG:\n-                switch (GET_CODE(y))\n-\t\t  {\n-\t\t    case CONST:\n-\t\t      output_address(XEXP(y,0));\n-\t\t      fprintf(file, \",R%d ;P_O_A reg + const expr\",REGNO(x));\n-\t\t      break;\n-\t\t    case CONST_INT:\n-\t\t      fprintf(file,\"%d,R%d  ; P_O_A reg + const_int\",\n-\t\t\t\tINTVAL(y),REGNO(x));\n-\t\t      break;\n-\t\t    case SYMBOL_REF:\n-\t\t      fprintf(file,\"%s,R%d  ; P_O_A reg + sym\",\n-\t\t\t\tXSTR(y,0),REGNO(x));\n-\t\t      break;\n-\t\t    default:\n-\t\t      fprintf(file, \"[P_O_A reg%d+UFO code=%d]\",\n-\t\t\t        REGNO(x),GET_CODE(y));\n-\t \t  }\n+    case REG:\n+      fprintf (file, \"0,r%d ; P_O_A\", REGNO (addr));\n+      break;\n+    case PLUS:\n+      {\n+\tregister rtx x = XEXP (addr, 0), y = XEXP (addr, 1);\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case REG:\n+\t    switch (GET_CODE (y))\n+\t      {\n+\t      case CONST:\n+\t\toutput_address (XEXP (y, 0));\n+\t\tfprintf (file, \",r%d ;P_O_A reg + const expr\", REGNO (x));\n+\t\tbreak;\n+\t      case CONST_INT:\n+\t\tfprintf (file, \"%d,r%d\", INTVAL (y), REGNO (x));\n \t\tbreak;\n-\t      case LABEL_REF:\n \t      case SYMBOL_REF:\n-\t\tswitch (GET_CODE(y))\n-\t\t  {\n-\t\t    case CONST_INT:\n-\t \t      fprintf (file,\"%d+%s\",INTVAL(y),XSTR(x,0));\n-\t \t      break;\n-\t\t    case REG:\n-\t\t      fprintf (file,\"%s,R%d ;P_O_A sym + reg\",\n-\t\t\t\t XSTR(x,0),REGNO(y));\n-\t\t      break;\n-\t\t    default:\n-\t\t      fprintf(file, \"P_O_A sym/lab+UFO[sym=%s,code(y)=%d]\",\n-\t\t\t\t XSTR(x,0),GET_CODE(y));\n-\t\t  }\n-\t \tbreak;\n-\t      case CONST:\n-\t        output_address(XEXP(x,0));\n-\t        if (GET_CODE(y) == REG)\n-\t\t  fprintf(file, \",R%d ;P_O_A const + reg\",REGNO(x));\n-\t        else\n-\t\t  fprintf(file,\"P_O_A const+UFO code(y)=%d]\",GET_CODE(y));\n-\t        break;\n-\t      case MEM:\n-\t\toutput_address(y);\n-\t\tfprintf(file, \",[mem:\");\n-\t\toutput_address(XEXP(x,0));\n-\t\tfprintf(file, \"] ;P_O_A plus\");\n+\t\tfprintf (file, \"%s,r%d  ; P_O_A reg + sym\",\n+\t\t\t XSTR (y, 0), REGNO (x));\n \t\tbreak;\n \t      default:\n-\t\tfprintf(file, \"P_O_A plus op1_UFO[code1=%d,code2=%d]\",\n-\t\t\tGET_CODE(x),GET_CODE(y));\n-\t    }\n-\t}\n-\tbreak;\n-      case CONST_INT:\n-\tif (INTVAL(addr) < 0x10000 && INTVAL(addr) >= -0x10000)\n-\t  fprintf (file, \"%d ; p_o_a const addr?!\", INTVAL(addr));\n-\telse\n-\t  {\n-\t    fprintf(file,\"[p_o_a=ILLEGAL_CONST]\");\n-\t    output_addr_const (file, addr);\n+\t\tfprintf (file, \"[P_O_A reg%d+UFO code=%d]\",\n+\t\t\t REGNO (x), GET_CODE (y));\n+\t      }\n+\t    break;\n+\t  case LABEL_REF:\n+\t  case SYMBOL_REF:\n+\t    switch (GET_CODE (y))\n+\t      {\n+\t      case CONST_INT:\n+\t\tfprintf (file, \"%d+%s\", INTVAL (y), XSTR (x, 0));\n+\t\tbreak;\n+\t      case REG:\n+\t\tfprintf (file, \"%s,r%d ;P_O_A sym + reg\",\n+\t\t\t XSTR (x, 0), REGNO (y));\n+\t\tbreak;\n+\t      default:\n+\t\tfprintf (file, \"P_O_A sym/lab+UFO[sym=%s,code(y)=%d]\",\n+\t\t\t XSTR (x, 0), GET_CODE (y));\n+\t      }\n+\t    break;\n+\t  case CONST:\n+\t    output_address (XEXP (x, 0));\n+\t    if (GET_CODE (y) == REG)\n+\t      fprintf (file, \",r%d ;P_O_A const + reg\", REGNO (x));\n+\t    else\n+\t      fprintf (file, \"P_O_A const+UFO code(y)=%d]\", GET_CODE (y));\n+\t    break;\n+\t  case MEM:\n+\t    output_address (y);\n+\t    fprintf (file, \",[mem:\");\n+\t    output_address (XEXP (x, 0));\n+\t    fprintf (file, \"] ;P_O_A plus\");\n+\t    break;\n+\t  default:\n+\t    fprintf (file, \"P_O_A plus op1_UFO[code1=%d,code2=%d]\",\n+\t\t     GET_CODE (x), GET_CODE (y));\n \t  }\n-\tbreak;\n-      case LABEL_REF:\n-      case SYMBOL_REF:\n-\tfprintf(file,\"%s\",XSTR(addr,0));\n-\tbreak;\n-      case MEM:\n-\tfprintf(file,\"[memUFO:\");\n-\toutput_address(XEXP(addr,0));\n-\tfprintf(file,\"]\");\n-\tbreak;\n-      case CONST:\n-\toutput_address(XEXP(addr,0));\n-\tfprintf(file,\" ;P_O_A const\");\n-\tbreak;\n-      default:\n-\tfprintf(file,\" p_o_a UFO, code=%d val=0x%x\",\n-\t\t\t(int) GET_CODE(addr),INTVAL(addr));\n-\tbreak;\n+      }\n+      break;\n+    case CONST_INT:\n+      if (INTVAL (addr) < 0x10000 && INTVAL (addr) >= -0x10000)\n+\tfprintf (file, \"%d ; p_o_a const addr?!\", INTVAL (addr));\n+      else\n+\t{\n+\t  fprintf (file, \"[p_o_a=ILLEGAL_CONST]\");\n+\t  output_addr_const (file, addr);\n+\t}\n+      break;\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      fprintf (file, \"%s\", XSTR (addr, 0));\n+      break;\n+    case MEM:\n+      fprintf (file, \"[memUFO:\");\n+      output_address (XEXP (addr, 0));\n+      fprintf (file, \"]\");\n+      break;\n+    case CONST:\n+      output_address (XEXP (addr, 0));\n+      fprintf (file, \" ;P_O_A const\");\n+      break;\n+    default:\n+      fprintf (file, \" p_o_a UFO, code=%d val=0x%x\",\n+\t       (int) GET_CODE (addr), INTVAL (addr));\n+      break;\n     }\n }\n \n+\n+/*\n+ASM_FILE_END(file)\n+  FILE *file;\n+{\n+      if (datalbl_ndx >= 0) {\n+         int i, cum_size=0;\n+         fprintf(file,\"\\n\\tstatic\\ninit_srel\\n\");\n+         for (i = 0; i <= datalbl_ndx; i++) {\n+\t   if (datalbl[i].name == NULL)\t\n+\t   {\n+\t     fprintf (stderr, \"asm_file_end intern err (datalbl)\\n\");\n+\t     exit (0);\n+\t   }\n+           fprintf(file,\"%s\\t block %d\\n\",\n+                 datalbl[i].name,datalbl[i].size);\n+           cum_size += datalbl[i].size;\n+\t }\n+         fprintf(file,\"\\n\\tinit\\n\");\n+         fprintf(file,\"\\tLIM  R0,init_srel ;dst\\n\");\n+         fprintf(file,\"\\tLIM  R1,%d ;cnt\\n\",cum_size);\n+         fprintf(file,\"\\tLIM  R2,K%s ;src\\n\",datalbl[0].name);\n+         fprintf(file,\"\\tMOV  R0,R2\\n\");\n+         fprintf(file,\"\\n\\tnormal\\n\");\n+         datalbl_ndx = -1;\n+         for (i = 0; i < DATALBL_ARRSIZ; i++)\n+            datalbl[i].size = 0;\n+      }\t\n+      fprintf(file,\"\\n\\tend\\n\");\n+}\n+ */"}, {"sha": "e2eb1dd79e68008154512685538e51e6e3f26781", "filename": "gcc/config/1750a/1750a.md", "status": "modified", "additions": 226, "deletions": 208, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33f0da5105dae52771feabcecda1d9559307bb1/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33f0da5105dae52771feabcecda1d9559307bb1/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=b33f0da5105dae52771feabcecda1d9559307bb1", "patch": "@@ -1,6 +1,7 @@\n-;;- Machine description for GNU compiler, MIL-STD-1750A version.\n-;;  Copyright (C) 1994 Free Software Foundation, Inc.\n-;;  Contributed by O.M.Kellogg, Deutsche Aerospace (okellogg@salyko.cube.net).\n+;;- Machine description for GNU compiler\n+;;- MIL-STD-1750A version.\n+;; Copyright (C) 1994 Free Software Foundation, Inc.\n+;; Contributed by O.M.Kellogg, DASA (okellogg@salyko.cube.net).\n \n ;; This file is part of GNU CC.\n \n@@ -53,7 +54,7 @@\n   [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n         (match_operand:QI 1 \"general_operand\" \"r\"))]\n   \"\"\n-  \"PSHM   R%1,R%1\")\n+  \"pshm r%1,r%1\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n@@ -75,7 +76,7 @@\n         rtx new_operands[2];\n         new_operands[0] = operands[1];\n         new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+1);\n-        output_asm_insn(\\\"PSHM   R%0,R%1\\\",new_operands);\n+        output_asm_insn(\\\"pshm r%0,r%1\\\",new_operands);\n         return \\\"\\;\\\";\n    } \")\n \n@@ -88,7 +89,7 @@\n         rtx new_operands[2];\n         new_operands[0] = operands[1];\n         new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[1])+2);\n-        output_asm_insn(\\\"PSHM   R%0,R%1\\\",new_operands);\n+        output_asm_insn(\\\"pshm r%0,r%1\\\",new_operands);\n         return \\\"\\;\\\";\n    } \")\n \n@@ -97,7 +98,7 @@\n   [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n         (match_operand:QI 1 \"push_operand\" \">\"))]\n   \"\"\n-  \"POPM   R%1,R%1\")\n+  \"popm r%1,r%1\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n@@ -108,7 +109,7 @@\n         rtx new_operands[2];\n         new_operands[0] = operands[0];\n         new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+1);\n-        output_asm_insn(\\\"POPM   R%0,R%1\\\",new_operands);\n+        output_asm_insn(\\\"popm r%0,r%1\\\",new_operands);\n         return \\\"\\;\\\";\n    } \")\n \n@@ -121,7 +122,7 @@\n         rtx new_operands[2];\n         new_operands[0] = operands[0];\n         new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+1);\n-        output_asm_insn(\\\"POPM   R%0,R%1\\\",new_operands);\n+        output_asm_insn(\\\"popm r%0,r%1\\\",new_operands);\n         return \\\"\\;\\\";\n    } \")\n \n@@ -134,7 +135,7 @@\n         rtx new_operands[2];\n         new_operands[0] = operands[0];\n         new_operands[1] = gen_rtx(CONST_INT,VOIDmode,REGNO(operands[0])+2);\n-        output_asm_insn(\\\"POPM   R%0,R%1\\\",new_operands);\n+        output_asm_insn(\\\"popm r%0,r%1\\\",new_operands);\n         return \\\"\\;\\\";\n    } \")\n \n@@ -145,26 +146,26 @@\n   [(set (cc0)\n         (match_operand:QI 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"LR     R%0,R%0   ; from tstqi\")\n+  \"lr r%0,r%0   ; from tstqi\")\n \n (define_insn \"tsthi\"\n   [(set (cc0)\n         (match_operand:HI 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"DLR    R%0,R%0   ; from tsthi\")\n+  \"dlr r%0,r%0   ; from tsthi\")\n \n (define_insn \"tsthf\"\n   [(set (cc0)\n         (match_operand:HF 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"DLR    R%0,R%0   ; from tsthf\")\n+  \"dlr r%0,r%0   ; from tsthf\")\n \n ;; This one is happy with \"roughly zero\" :-)  (should be improved)\n (define_insn \"tsttqf\"\n   [(set (cc0)\n         (match_operand:TQF 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"DLR    R%0,R%0   ; from tsttqf\")\n+  \"dlr r%0,r%0   ; from tsttqf\")\n \n \n ;; block move.\n@@ -192,38 +193,38 @@\n                  (match_operand:QI 1 \"general_operand\"  \"I,J,i,r,m\")))]\n   \"\"\n   \"@\n-     CISP   R%0,%1\n-     CISN   R%0,%J1\n-     CIM    R%0,%1\n-     CR     R%0,R%1\n-     C      R%0,%1 \")\n+     cisp r%0,%1\n+     cisn r%0,%J1\n+     cim  r%0,%1\n+     cr   r%0,r%1\n+     c    r%0,%1 \")\n \n (define_insn \"cmphi\"\n   [(set (cc0)\n         (compare (match_operand:HI 0 \"general_operand\" \"r,r\")\n                  (match_operand:HI 1 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    DCR    R%0,R%1\n-    DC     R%0,%1 \")\n+    dcr r%0,r%1\n+    dc  r%0,%1 \")\n \n (define_insn \"cmphf\"\n  [(set (cc0)\n        (compare (match_operand:HF 0 \"general_operand\" \"r,r\")\n                 (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n  \"\"\n  \"@\n-   FCR    R%0,R%1\n-   FC     R%0,%1 \")\n+   fcr r%0,r%1\n+   fc  r%0,%1 \")\n \n (define_insn \"cmptqf\"\n   [(set (cc0)\n         (compare (match_operand:TQF 0 \"general_operand\" \"r,r\")\n                  (match_operand:TQF 1 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    EFCR   R%0,R%1\n-    EFC    R%0,%1 \")\n+    efcr r%0,r%1\n+    efc  r%0,%1 \")\n \n \n ;; truncation instructions\n@@ -237,7 +238,7 @@\n   \"*\n      {\n         REGNO(operands[1]) += 1;\n-        return \\\"LR     R%0,R%1  ;trunchiqi2\\\";\n+        return \\\"lr r%0,r%1  ;trunchiqi2\\\";\n      } \")\n \n ;; zero extension instructions\n@@ -248,16 +249,16 @@\n   \"\"\n   \"*\n       {\n-        output_asm_insn(\\\"XORR   R%0,R%0   ;zero_extendqihi2\\\",operands);\n+        output_asm_insn(\\\"xorr r%0,r%0   ;zero_extendqihi2\\\",operands);\n         REGNO(operands[0]) += 1;\n         switch (which_alternative)\n           {\n             case 0:\n-              return \\\"LR     R%0,R%1\\\";\n+              return \\\"lr  r%0,r%1\\\";\n             case 1:\n-              return \\\"L      R%0,%1\\\";\n+              return \\\"l   r%0,%1\\\";\n             case 2:\n-              return \\\"LIM    R%0,%1\\\";\n+              return \\\"lim r%0,%1\\\";\n           }\n       } \")\n \n@@ -268,9 +269,9 @@\n         (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"r,m,i\")) )]\n   \"\"\n   \"@\n-    LR     R%0,R%1 ;extendqihi2\\;DSRA   R%0,16\n-    L      R%0,%1  ;extendqihi2\\;DSRA   R%0,16\n-    LIM    R%0,%1  ;extendqihi2\\;DSRA   R%0,16 \")\n+    lr  r%0,r%1 ;extendqihi2\\;dsra r%0,16\n+    l   r%0,%1  ;extendqihi2\\;dsra r%0,16\n+    lim r%0,%1  ;extendqihi2\\;dsra r%0,16 \")\n \n \n ;; Conversions between float and double.\n@@ -284,12 +285,12 @@\n   \"*\n       {\n         REGNO(operands[0]) += 2;\n-        output_asm_insn(\\\"XORR   R%0,R%0   ;extendhftqf2\\\",operands);\n+        output_asm_insn(\\\"xorr r%0,r%0   ;extendhftqf2\\\",operands);\n         REGNO(operands[0]) -= 2;\n         if (which_alternative == 0)\n-          return \\\"DLR    R%0,R%1\\\";\n+          return \\\"dlr r%0,r%1\\\";\n         else\n-          return \\\"DL     R%0,%1\\\";\n+          return \\\"dl  r%0,%1\\\";\n       } \")\n \n ; 1750 TQF-to-HF truncate is a no-op: just leave away the least signif. 16 bits\n@@ -299,8 +300,8 @@\n           (match_operand:TQF 1 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-     DLR    R%0,R%1  ;trunctqfhf2\n-     DL     R%0,%1   ;trunctqfhf2 \")\n+     dlr r%0,r%1  ;trunctqfhf2\n+     dl  r%0,%1   ;trunctqfhf2 \")\n \n \n ;; Conversion between fixed point and floating point.\n@@ -309,13 +310,13 @@\n   [(set           (match_operand:HF 0 \"register_operand\" \"=r\")\n         (float:HF (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"FLT    R%0,R%1\")\n+  \"flt r%0,r%1\")\n \n (define_insn \"floathitqf2\"\n   [(set           (match_operand:TQF 0 \"register_operand\" \"=r\")\n         (float:TQF (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"EFLT   R%0,R%1\")\n+  \"eflt r%0,r%1\")\n \n \n ;; Convert floats to ints\n@@ -324,13 +325,13 @@\n   [(set                 (match_operand:QI 0 \"register_operand\" \"=r\")\n         (fix:QI (fix:HF (match_operand:HF 1 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"FIX    R%0,R%1\")\n+  \"fix r%0,r%1\")\n \n (define_insn \"fix_trunctqfhi2\"\n   [(set                 (match_operand:HI 0 \"register_operand\" \"=r\")\n         (fix:HI (fix:TQF (match_operand:TQF 1 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"EFIX   R%0,R%1\")\n+  \"efix r%0,r%1\")\n \n \n ;; Move instructions\n@@ -346,15 +347,15 @@\n         (match_operand:QI 1 \"general_operand\"  \"O,I,J,M,i,r,m,r,K\"))]\n   \"\"\n   \"@\n-     XORR   R%0,R%0\n-     LISP   R%0,%1\n-     LISN   R%0,%J1\n-     LIM    R%0,%1  ; 'M' constraint\n-     LIM    R%0,%1  ; 'i' constraint\n-     LR     R%0,R%1\n-     L      R%0,%1\n-     ST     R%1,%0\n-     STC    %1,%0   \")\n+     xorr r%0,r%0\n+     lisp r%0,%1\n+     lisn r%0,%J1\n+     lim  r%0,%1  ; 'M' constraint\n+     lim  r%0,%1  ; 'i' constraint\n+     lr   r%0,r%1\n+     l    r%0,%1\n+     st   r%1,%0\n+     stc  %1,%0   \")\n \n ;; 32-bit moves\n \n@@ -371,62 +372,79 @@\n           {\n             if (val <= 65535)\n               {\n-                output_asm_insn(\\\"XORR   R%0,R%0 ;movhi cst->reg\\\",operands);\n+                output_asm_insn(\\\"xorr   r%0,r%0 ;movhi cst->reg\\\",operands);\n                 operands[0] = gen_rtx(REG,QImode,REGNO(operands[0]) + 1);\n                 if (val == 0)\n-                  return \\\"XORR   R%0,R%0\\\";\n+                  return \\\"xorr r%0,r%0\\\";\n                 else if (val <= 16)\n-                  return \\\"LISP   R%0,%1\\\";\n+                  return \\\"lisp r%0,%1\\\";\n                 else\n-                  return \\\"LIM    R%0,%1\\\";\n+                  return \\\"lim  r%0,%1\\\";\n               }\n           }\n         else if (val >= -16)\n-          return \\\"LISN   R%0,%J1\\;DSRA   R%0,16 ;movhi cst\\\";\n+          return \\\"lisn r%0,%J1\\;dsra r%0,16 ;movhi cst\\\";\n         INTVAL(operands[1]) >>= 16;\n-        output_asm_insn(\\\"LIM    R%0,%1 ;movhi cst->reg\\\",operands);\n+        output_asm_insn(\\\"lim r%0,%1 ;movhi cst->reg\\\",operands);\n         REGNO(operands[0]) += 1;\n         INTVAL(operands[1]) = val & 0xFFFF;\n-        return \\\"LIM    R%0,%1\\\";\n+        return \\\"lim r%0,%1\\\";\n       }\n-    return \\\"LIM    R%0,%1\\;DSRA   R%0,16 ;movhi cst\\\";\n+    return \\\"lim r%0,%1\\;dsra r%0,16 ;movhi cst\\\";\n   \")\n \n (define_insn \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m\")\n         (match_operand:HI 1 \"general_operand\"  \"r,m,r\"))]\n   \"\"\n   \"@\n-    DLR    R%0,R%1\n-    DL     R%0,%1\n-    DST    R%1,%0 \")\n+    dlr r%0,r%1\n+    dl  r%0,%1\n+    dst r%1,%0 \")\n \n \n ;; Single-Float moves are *same* as HImode moves:\n \n+;(define_insn \"movhf\"\n+;  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,r,m\")\n+;        (match_operand:HF 1 \"general_operand\"  \"F,r,m,r\"))]\n+;  \"\"\n+;  \"@\n+;    %D1\\;dl r%0,%F1\n+;    dlr r%0,r%1\n+;    dl  r%0,%1\n+;    dst r%1,%0 \")\n+\n (define_insn \"movhf\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,r,r,m\")\n-        (match_operand:HF 1 \"general_operand\"  \"G,F,r,m,r\"))]\n+  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,m\")\n+        (match_operand:HF 1 \"general_operand\"  \"r,m,r\"))]\n   \"\"\n   \"@\n-    DXRR.M %0,%0 ; movhf const(0.0)\n-    %E1\\;DL     R%0,%F1\n-    DLR    R%0,R%1\n-    DL     R%0,%1\n-    DST    R%1,%0 \")\n+    dlr r%0,r%1\n+    dl  r%0,%1\n+    dst r%1,%0 \")\n \n \n ;; Longfloat moves\n \n+;(define_insn \"movtqf\"\n+;  [(set (match_operand:TQF 0 \"general_operand\" \"=r,r,r,m\")\n+;        (match_operand:TQF 1 \"general_operand\"  \"F,r,m,r\"))]\n+;  \"\"\n+;  \"@\n+;    %E1\\;efl r%0,%G1\n+;    eflr.m %0,%1\n+;    efl  r%0,%1\n+;    efst r%1,%0 \")\n+\n (define_insn \"movtqf\"\n-  [(set (match_operand:TQF 0 \"general_operand\" \"=r,r,r,m\")\n-        (match_operand:TQF 1 \"general_operand\"  \"F,r,m,r\"))]\n+  [(set (match_operand:TQF 0 \"general_operand\" \"=r,r,m\")\n+        (match_operand:TQF 1 \"general_operand\"  \"r,m,r\"))]\n   \"\"\n   \"@\n-    %D1\\;EFL    R%0,%F1\n-    EFLR.M %0,%1\n-    EFL    R%0,%1\n-    EFST   R%1,%0 \")\n+    eflr.m %0,%1\n+    efl  r%0,%1\n+    efst r%1,%0 \")\n \n \n ;; add instructions \n@@ -440,7 +458,7 @@\n ;        (plus:QI (match_operand:QI 1 \"register_operand\" \"b\")\n ;                 (match_operand:QI 2 \"immediate_operand\"  \"i\")))]\n ;   \"REGNO(operands[0]) != REGNO(operands[1])\"\n-;   \"LIM    R%0,%2,R%1 ;md special addqi\")\n+;   \"lim r%0,%2,r%1 ;md special addqi\")\n \n (define_insn \"addqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,m,m\")\n@@ -451,22 +469,22 @@\n     switch (which_alternative)\n       {\n         case 0:\n-          return \\\"AISP   R%0,%2\\\";\n+          return \\\"aisp r%0,%2\\\";\n         case 1:\n-          return \\\"SISP   R%0,%J2\\\";\n+          return \\\"sisp r%0,%J2\\\";\n         case 2:\n           if (INTVAL(operands[2]) < 0)\n-            return \\\"SIM    R%0,%J2\\\";\n+            return \\\"sim r%0,%J2\\\";\n           else\n-            return \\\"AIM    R%0,%2\\\";\n+            return \\\"aim r%0,%2\\\";\n         case 3:\n-          return \\\"AR     R%0,R%2\\\";\n+          return \\\"ar r%0,r%2\\\";\n         case 4:\n-          return \\\"A      R%0,%2\\\";\n+          return \\\"a r%0,%2\\\";\n         case 5:\n-          return \\\"INCM   %2,%0\\\";\n+          return \\\"incm %2,%0\\\";\n         case 6:\n-          return \\\"DECM   %J2,%0\\\";\n+          return \\\"decm %J2,%0\\\";\n       } \")\n \n ;; double integer\n@@ -476,26 +494,26 @@\n                  (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    DAR    R%0,R%2\n-    DA     R%0,%2 \")\n+    dar r%0,r%2\n+    da  r%0,%2 \")\n \n (define_insn \"addhf3\"\n   [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n         (plus:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n                  (match_operand:HF 2 \"general_operand\" \"m,r\")))]\n   \"\"\n   \"@\n-    FA     R%0,%2\n-    FAR    R%0,R%2 \")\n+    fa  r%0,%2\n+    far r%0,r%2 \")\n \n (define_insn \"addtqf3\"\n   [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n         (plus:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n                  (match_operand:TQF 2 \"general_operand\" \"m,r\")))]\n   \"\"\n   \"@\n-    EFA    R%0,%2\n-    EFAR   R%0,R%2 \")\n+    efa  r%0,%2\n+    efar r%0,r%2 \")\n \n \n ;; subtract instructions\n@@ -507,11 +525,11 @@\n                   (match_operand:QI 2 \"general_operand\"  \"I,i,r,m,I\")))]\n   \"\"\n   \"@\n-    SISP   R%0,%2\n-    SIM    R%0,%2\n-    SR     R%0,R%2\n-    S      R%0,%2\n-    DECM   %2,%0 \")\n+    sisp r%0,%2\n+    sim  r%0,%2\n+    sr   r%0,r%2\n+    s    r%0,%2\n+    decm %2,%0 \")\n \n ;; double integer\n (define_insn \"subhi3\"\n@@ -520,26 +538,26 @@\n                   (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    DSR    R%0,R%2\n-    DS     R%0,%2 \")\n+    dsr r%0,r%2\n+    ds  r%0,%2 \")\n \n (define_insn \"subhf3\"\n   [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n         (minus:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n                   (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    FSR    R%0,R%2\n-    FS     R%0,%2 \")\n+    fsr r%0,r%2\n+    fs  r%0,%2 \")\n \n (define_insn \"subtqf3\"\n   [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n         (minus:TQF (match_operand:TQF 1 \"register_operand\" \"0,0\")\n                   (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    EFSR   R%0,R%2\n-    EFS    R%0,%2 \")\n+    efsr r%0,r%2\n+    efs  r%0,%2 \")\n \n \n ;; multiply instructions\n@@ -550,11 +568,11 @@\n                  (match_operand:QI 2 \"general_operand\"  \"I,J,M,r,m\")))]\n   \"\"\n   \"@\n-     MISP   R%0,%2\n-     MISN   R%0,%J2\n-     MSIM   R%0,%2\n-     MSR    R%0,R%2\n-     MS     R%0,%2  \")\n+     misp r%0,%2\n+     misn r%0,%J2\n+     msim r%0,%2\n+     msr  r%0,r%2\n+     ms   r%0,%2  \")\n \n \n ; 32-bit product\n@@ -564,18 +582,18 @@\n                  (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n   \"\"\n   \"@\n-    MIM    R%0,%1\n-    MR     R%0,R%2\n-    M      R%0,%2 \")\n+    mim r%0,%1\n+    mr  r%0,r%2\n+    m   r%0,%2 \")\n \n (define_insn \"mulhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n         (mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n                  (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    DMR    R%0,R%2\n-    DM     R%0,%2 \")\n+    dmr r%0,r%2\n+    dm  r%0,%2 \")\n \n ; not available on 1750: \"umulhi3\",\"umulhisi3\",\"umulsi3\" (unsigned multiply's)\n \n@@ -585,17 +603,17 @@\n                  (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    FMR    R%0,R%2\n-    FM     R%0,%2 \")\n+    fmr r%0,r%2\n+    fm  r%0,%2 \")\n \n (define_insn \"multqf3\"\n   [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n         (mult:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n                  (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    EFMR   R%0,R%2\n-    EFM    R%0,%2 \")\n+    efmr r%0,r%2\n+    efm  r%0,%2 \")\n \n \n ;; divide instructions\n@@ -621,20 +639,20 @@\n      switch(which_alternative)\n        {\n        case 0:\n-         istr = \\\"DISP\\\";\n+         istr = \\\"disp\\\";\n          break;\n        case 1:\n          INTVAL(operands[2]) = - INTVAL(operands[2]); /* to be corrected */\n-         istr = \\\"DISN\\\";\n+         istr = \\\"disn\\\";\n          break;\n        case 2:\n-         istr = \\\"DVIM\\\";\n+         istr = \\\"dvim\\\";\n          break;\n        case 3:\n-         istr = \\\"DVR \\\";\n+         istr = \\\"dvr \\\";\n          break;\n        case 4:\n-         istr = \\\"DV  \\\";\n+         istr = \\\"dv  \\\";\n          break;\n       }\n       return (char *)mod_regno_adjust(istr,operands);\n@@ -648,26 +666,26 @@\n                 (match_operand:HI 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    DDR    R%0,R%2\n-    DD     R%0,%2 \")\n+    ddr r%0,r%2\n+    dd  r%0,%2 \")\n \n (define_insn \"divhf3\"\n   [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n         (div:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n                 (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    FDR    R%0,R%2\n-    FD     R%0,%2 \")\n+    fdr r%0,r%2\n+    fd  r%0,%2 \")\n \n (define_insn \"divtqf3\"\n   [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n         (div:TQF (match_operand:TQF 1 \"register_operand\" \"0,0\")\n                 (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    EFDR   R%0,R%2\n-    EFD    R%0,%2 \")\n+    efdr r%0,r%2\n+    efd  r%0,%2 \")\n \n \n ;; Other arithmetic instructions:\n@@ -678,19 +696,19 @@\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n         (abs:QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"ABS    R%0,R%1\")\n+  \"abs r%0,r%1\")\n \n (define_insn \"abshi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (abs:HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"DABS   R%0,R%1\")\n+  \"dabs r%0,r%1\")\n \n (define_insn \"abshf2\"\n   [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n         (abs:HF (match_operand:HF 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"FABS   R%0,R%1\")\n+  \"fabs r%0,r%1\")\n \n \n ;; Negation\n@@ -699,31 +717,31 @@\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n         (neg:QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"NEG    R%0,R%1\")\n+  \"neg r%0,r%1\")\n \n (define_insn \"neghi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (neg:HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"DNEG   R%0,R%1\")\n+  \"dneg r%0,r%1\")\n \n (define_insn \"neghf2\"\n   [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n         (neg:HF (match_operand:HF 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"FNEG   R%0,R%1\")\n+  \"fneg r%0,r%1\")\n \n ; The 1750A does not have an extended float negate instruction, so simulate.\n-;(define_expand \"negtqf2\"\n-;  [(set (match_operand:TQF 0 \"register_operand\" \"=&r\")\n-;        (neg:TQF (match_operand:TQF 1 \"register_operand\" \"r\")))]\n-;  \"\"\n-;  \"\n-;   emit_insn(gen_rtx(SET,VOIDmode,operands[0],CONST0_RTX(TQFmode)));\n-;   emit_insn(gen_rtx(SET,VOIDmode,operands[0],\n-;             gen_rtx(MINUS,TQFmode,operands[0],operands[1])));\n-;   DONE;\n-;  \")\n+(define_expand \"negtqf2\"\n+  [(set (match_operand:TQF 0 \"register_operand\" \"=&r\")\n+        (neg:TQF (match_operand:TQF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"\n+   emit_insn(gen_rtx(SET,VOIDmode,operands[0],CONST0_RTX(TQFmode)));\n+   emit_insn(gen_rtx(SET,VOIDmode,operands[0],\n+             gen_rtx(MINUS,TQFmode,operands[0],operands[1])));\n+   DONE;\n+  \")\n \n \n ;; bit-logical instructions\n@@ -736,17 +754,17 @@\n                 (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n   \"\"\n   \"@\n-    ANDM   R%0,%2\n-    ANDR   R%0,R%2\n-    AND    R%0,%2 \")\n+    andm r%0,%2\n+    andr r%0,r%2\n+    and  r%0,%2 \")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n                 (match_operand:HI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"DANR.M %0,%2\")\n+  \"danr.m %0,%2\")\n \n ;; OR\n \n@@ -756,17 +774,17 @@\n                 (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n   \"\"\n   \"@\n-    ORIM   R%0,%2\n-    ORR    R%0,R%2\n-    OR     R%0,%2 \")\n+    orim r%0,%2\n+    orr  r%0,r%2\n+    or   r%0,%2 \")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (ior:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n                 (match_operand:HI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"DORR.M %0,%2\")\n+  \"dorr.m %0,%2\")\n \n ;; XOR\n \n@@ -776,17 +794,17 @@\n                 (match_operand:QI 2 \"general_operand\"  \"M,r,m\")))]\n   \"\"\n   \"@\n-    XORM   R%0,%2\n-    XORR   R%0,R%2\n-    XOR    R%0,%2 \")\n+    xorm r%0,%2\n+    xorr r%0,r%2\n+    xor  r%0,%2 \")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n (define_insn \"xorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (xor:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n                 (match_operand:HI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"DXRR.M %0,%2\")\n+  \"dxrr.m %0,%2\")\n \n ;; NAND\n \n@@ -796,32 +814,32 @@\n \t\t(not:QI (match_operand:QI 2 \"general_operand\" \"M,r,m\"))))]\n   \"\"\n   \"@\n-    NIM    R%0,%2\n-    NR     R%0,R%2\n-    N      R%0,%2 \")\n+    nim r%0,%2\n+    nr  r%0,r%2\n+    n   r%0,%2 \")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(ior:HI (not:HI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t(not:HI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"DNR.M  %0,%2\")\n+  \"dnr.m %0,%2\")\n \n ;; NOT\n \n (define_insn \"one_cmplqi2\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n         (not:QI (match_operand:QI 1 \"register_operand\" \"0\")))]\n   \"\"\n-  \"NR     R%0,R%0\")\n+  \"nr r%0,r%0\")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n (define_insn \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n   \"\"\n-  \"DNR.M  %0,%0\")\n+  \"dnr.m %0,%0\")\n \n \n ;; Shift instructions\n@@ -833,54 +851,54 @@\n                    (match_operand:QI 2 \"general_operand\" \"O,I,r\")))]\n   \"\"\n   \"@\n-    ; optimized away an SLL R%0,0\n-    SLL    R%0,%2\n-    SLR    R%0,R%2 \")\n+    ; optimized away an SLL r%0,0\n+    sll r%0,%2\n+    slr r%0,r%2 \")\n \n (define_insn \"ashlhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n         (ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n                    (match_operand:QI 2 \"general_operand\" \"L,r\")))]\n   \"\"                        ; the 'L' constraint is a slight imprecise...\n   \"@\n-     DSLL   R%0,%2\n-     DSLR   R%0,R%2 \")\n+     dsll r%0,%2\n+     dslr r%0,r%2 \")\n \n (define_insn \"lshrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n         (lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n                      (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-    SRL    R%0,%2\n-    NEG    R%2,R%2\\;SLR    R%0,R%2 \")\n+    srl r%0,%2\n+    neg r%2,r%2\\;slr    r%0,r%2 \")\n \n (define_insn \"lshrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n         (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n                      (match_operand:QI 2 \"general_operand\" \"L,r\")))]\n   \"\"                        ; the 'L' constraint is a slight imprecise...\n   \"@\n-    DSRL   R%0,%2\n-    NEG    R%2,R%2\\;DSLR   R%0,R%2 \")\n+    dsrl r%0,%2\n+    neg  r%2,r%2\\;dslr   r%0,r%2 \")\n \n (define_insn \"ashrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n         (ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n                      (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-     SRA    R%0,%2\n-     NEG    R%2,R%2\\;SAR    R%0,R%2 \")\n+     sra r%0,%2\n+     neg r%2,r%2\\;sar    r%0,r%2 \")\n \n (define_insn \"ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n         (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n                      (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-     DSRA   R%0,%2\n-     NEG    R%2,R%2\\;DSAR   R%0,R%2 \")\n+     dsra r%0,%2\n+     neg  r%2,r%2\\;dsar   r%0,r%2 \")\n \n \n ;; rotate instructions\n@@ -891,35 +909,35 @@\n                    (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-    SLC    R%0,%2\n-    SCR    R%0,R%2 \")\n+    slc r%0,%2\n+    scr r%0,r%2 \")\n \n (define_insn \"rotlhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n         (rotate:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n                    (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-    DSLC   R%0,%2\n-    DSCR   R%0,R%2 \")\n+    dslc r%0,%2\n+    dscr r%0,r%2 \")\n \n (define_insn \"rotrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n         (rotatert:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n                      (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-    SLC    R%0,%2\n-    NEG    R%2,R%2\\;SCR    R%0,R%2 \")\n+    slc r%0,%2\n+    neg r%2,r%2\\;scr    r%0,r%2 \")\n \n (define_insn \"rotrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n         (rotatert:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n                      (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-    DSLC   R%0,%2\n-    NEG    R%2,R%2\\;DSCR   R%0,R%2 \")\n+    dslc r%0,%2\n+    neg  r%2,r%2\\;dscr   r%0,r%2 \")\n \n \n \n@@ -964,7 +982,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"EZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"ez\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"bne\"\n@@ -974,7 +992,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"NZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"nz\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"bgt\"\n@@ -984,7 +1002,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"GT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"gt\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"blt\"\n@@ -994,7 +1012,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"LT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"lt\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"bge\"\n@@ -1004,7 +1022,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"GE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"ge\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"ble\"\n@@ -1014,7 +1032,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"LE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"le\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n \n@@ -1027,7 +1045,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"JC     GT,%l0 ; Warning: this should be an *unsigned* test!\")\n+  \"jc gt,%l0 ; Warning: this should be an *unsigned* test!\")\n \n (define_insn \"bltu\"\n   [(set (pc)\n@@ -1036,7 +1054,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"JC     LT,%l0 ; Warning: this should be an *unsigned* test!\")\n+  \"jc lt,%l0 ; Warning: this should be an *unsigned* test!\")\n \n (define_insn \"bgeu\"\n   [(set (pc)\n@@ -1045,7 +1063,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"JC     GE,%l0 ; Warning: this should be an *unsigned* test!\")\n+  \"jc ge,%l0 ; Warning: this should be an *unsigned* test!\")\n \n (define_insn \"bleu\"\n   [(set (pc)\n@@ -1054,7 +1072,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"JC     LE,%l0 ; Warning: this should be an *unsigned* test!\")\n+  \"jc le,%l0 ; Warning: this should be an *unsigned* test!\")\n \n \n ;; Negated conditional jump instructions.\n@@ -1066,7 +1084,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"NZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"nz\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"\"\n@@ -1076,7 +1094,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"EZ\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"ez\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"\"\n@@ -1086,7 +1104,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"LE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"le\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"\"\n@@ -1096,7 +1114,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"GE\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"ge\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"\"\n@@ -1106,7 +1124,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"LT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"lt\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n (define_insn \"\"\n@@ -1116,7 +1134,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return (char *)branch_or_jump(\\\"GT\\\",CODE_LABEL_NUMBER(operands[0]));\n+  \"* return (char *)branch_or_jump(\\\"gt\\\",CODE_LABEL_NUMBER(operands[0]));\n   \")\n \n \n@@ -1129,7 +1147,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"JC     LE,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+  \"jc le,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1138,7 +1156,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"JC     GE,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+  \"jc ge,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1147,7 +1165,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"JC     LT,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+  \"jc lt,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1156,7 +1174,7 @@\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"JC     GT,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n+  \"jc gt,%l0 ;inv.cond. ;Warning: this should be an *unsigned* test!\")\n \n ;; Tablejump \n ;; 1750 note: CASE_VECTOR_PC_RELATIVE is not defined\n@@ -1165,15 +1183,15 @@\n         (match_operand:QI 0 \"register_operand\" \"b\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"JC     15,0,R%0   ; tablejump label_ref=%1\")\n+  \"jc 15,0,r%0   ; tablejump label_ref=%1\")\n \n \n ;; Unconditional jump\n (define_insn \"jump\"\n   [(set (pc)\n         (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n-  \"JC     UC,%0\")\n+  \"jc uc,%0\")\n \n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n@@ -1183,7 +1201,7 @@\n               (match_operand:QI 2 \"general_operand\" \"g\")))]\n   ;; Operand 2 not really used for 1750.\n   \"\"\n-  \"SJS    R15,%1   ; return value in R0\")\n+  \"sjs r15,%1   ; return value in R0\")\n \n ;; Call subroutine with no return value.\n \n@@ -1192,7 +1210,7 @@\n   [(call (match_operand:QI 0 \"memory_operand\" \"mp\")\n          (match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"SJS    R15,%0   ; no return value\")\n+  \"sjs r15,%0   ; no return value\")\n \n ;;;;;;;;;;;; 1750: NOT READY YET.\n (define_insn \"call\"\n@@ -1208,14 +1226,14 @@\n ;   \"*\n ;    { \n ;         rtx oprnd = gen_rtx(CONST_INT,VOIDmode,get_frame_size());\n-;         output_asm_insn(\\\"RET.M  %0\\\",&oprnd);\n+;         output_asm_insn(\\\"ret.m  %0\\\",&oprnd);\n ;         return \\\"\\;\\\";\n ;    } \")\n \n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:QI 0 \"address_operand\" \"p\"))]\n   \"\"\n-  \"JCI   15,%0\")\n+  \"jci 15,%0\")\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -1235,7 +1253,7 @@\n          (pc)))\n    ]\n   \"INTVAL(operands[2]) == -1\"\n-  \"SOJ    R%0,%3\")\n+  \"soj r%0,%3\")\n \n ;;;End.\n "}]}