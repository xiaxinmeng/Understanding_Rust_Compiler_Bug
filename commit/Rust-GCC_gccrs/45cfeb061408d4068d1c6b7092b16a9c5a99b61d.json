{"sha": "45cfeb061408d4068d1c6b7092b16a9c5a99b61d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVjZmViMDYxNDA4ZDQwNjhkMWM2YjcwOTJiMTZhOWM1YTk5YjYxZA==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2004-02-14T20:45:58Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-02-14T20:45:58Z"}, "message": "UndoManager.java: Re-written from scratch.\n\n2004-02-14  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/UndoManager.java: Re-written from scratch.\n\nFrom-SVN: r77827", "tree": {"sha": "aef800c029328c83567db72e9c0bb8208899bf86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aef800c029328c83567db72e9c0bb8208899bf86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45cfeb061408d4068d1c6b7092b16a9c5a99b61d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45cfeb061408d4068d1c6b7092b16a9c5a99b61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45cfeb061408d4068d1c6b7092b16a9c5a99b61d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45cfeb061408d4068d1c6b7092b16a9c5a99b61d/comments", "author": null, "committer": null, "parents": [{"sha": "33421d69494241aad4603601502a50f50fb1d2dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33421d69494241aad4603601502a50f50fb1d2dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33421d69494241aad4603601502a50f50fb1d2dd"}], "stats": {"total": 801, "additions": 585, "deletions": 216}, "files": [{"sha": "56030dd857631a4ff2cc9f3f6ff5fe7c5f0b9936", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45cfeb061408d4068d1c6b7092b16a9c5a99b61d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45cfeb061408d4068d1c6b7092b16a9c5a99b61d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=45cfeb061408d4068d1c6b7092b16a9c5a99b61d", "patch": "@@ -1,3 +1,7 @@\n+2004-02-14  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/UndoManager.java: Re-written from scratch.\n+\n 2004-02-14  Per Bothner  <per@bothner.com>\n \n \t* java/nio/channels/spi/AbstractInterruptibleChannel.java (close):"}, {"sha": "c1b7cb88ffafec670ee3d858f95b1348daf9e388", "filename": "libjava/javax/swing/undo/UndoManager.java", "status": "modified", "additions": 581, "deletions": 216, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45cfeb061408d4068d1c6b7092b16a9c5a99b61d/libjava%2Fjavax%2Fswing%2Fundo%2FUndoManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45cfeb061408d4068d1c6b7092b16a9c5a99b61d/libjava%2Fjavax%2Fswing%2Fundo%2FUndoManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FUndoManager.java?ref=45cfeb061408d4068d1c6b7092b16a9c5a99b61d", "patch": "@@ -1,5 +1,5 @@\n /* AbstractTableModel.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,223 +38,588 @@\n \n package javax.swing.undo;\n \n+import javax.swing.UIManager;\n import javax.swing.event.UndoableEditEvent;\n import javax.swing.event.UndoableEditListener;\n \n+\n /**\n- * UndoManager\n- * @author\tAndrew Selkirk\n+ * A manager for providing an application&#x2019;s undo/redo\n+ * functionality.\n+ *\n+ * <p>Tyipcally, an application will create only one single instance\n+ * of UndoManager. When the user performs an undoable action, for\n+ * instance changing the color of an object from green to blue, the\n+ * application registers an {@link UndoableEdit} object with the\n+ * <code>UndoManager</code>. To implement the &#x201c;undo&#x201d; and\n+ * &#x201c;redo&#x201d; menu commands, the application invokes the\n+ * UndoManager&#x2019;s {@link #undo} and {@link #redo} methods.  The\n+ * human-readable text of these menu commands is provided by {@link\n+ * #getUndoPresentationName} and {@link #getRedoPresentationName},\n+ * respectively. To determine whether the menu item should be\n+ * selectable or greyed out, use {@link #canUndo} and {@link\n+ * #canRedo}.\n+ *\n+ * <p>The UndoManager will only keep a specified number of editing\n+ * actions, the <em>limit</em>. The value of this parameter can be\n+ * retrieved by calling {@link #getLimit} and set with {@link\n+ * #setLimit}.  If more UndoableEdits are added to the UndoManager,\n+ * the oldest actions will be discarded.\n+ *\n+ * <p>Some applications do not provide separate menu commands for\n+ * &#x201c;undo&#x201d; and &#x201c;redo.&#x201d; Instead, they\n+ * have just a single command whose text switches between the two.\n+ * Such applications would use an UndoManager with a <code>limit</code>\n+ * of 1. The text of this combined menu item is available via\n+ * {@link #getUndoOrRedoPresentationName}, and it is implemented\n+ * by calling {@link #undoOrRedo}.\n+ *\n+ * <p><b>Thread Safety:</b> In constrast to the other classes of the\n+ * <code>javax.swing.undo</code> package, the public methods of an\n+ * <code>UndoManager</code> are safe to call from concurrent threads.\n+ * The caller does not need to perform external synchronization, and\n+ * {@link javax.swing.event.UndoableEvent} sources do not need to\n+ * broadcast their events from inside the Swing worker thread.\n+ *\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n  */\n-public class UndoManager extends CompoundEdit implements UndoableEditListener {\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * indexOfNextAdd\n-\t */\n-\tint indexOfNextAdd;\n-\n-\t/**\n-\t * limit\n-\t */\n-\tint limit;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor UndoManager\n-\t */\n-\tpublic UndoManager() {\n-\t\t// TODO\n-\t} // UndoManager()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * toString\n-\t * @returns String\n-\t */\n-\tpublic String toString() {\n-\t\treturn null; // TODO\n-\t} // toString()\n-\n-\t/**\n-\t * end\n-\t */\n-\tpublic synchronized void end() {\n-\t\t// TODO\n-\t} // end()\n-\n-\t/**\n-\t * getLimit\n-\t * @returns int\n-\t */\n-\tpublic synchronized int getLimit() {\n-\t\treturn 0; // TODO\n-\t} // getLimit()\n-\n-\t/**\n-\t * discardAllEdits\n-\t */\n-\tpublic synchronized void discardAllEdits() {\n-\t\t// TODO\n-\t} // discardAllEdits()\n-\n-\t/**\n-\t * trimForLimit\n-\t */\n-\tprotected void trimForLimit() {\n-\t\t// TODO\n-\t} // trimForLimit()\n-\n-\t/**\n-\t * trimEdits\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t */\n-\tprotected void trimEdits(int value0, int value1) {\n-\t\t// TODO\n-\t} // trimEdits()\n-\n-\t/**\n-\t * setLimit\n-\t * @param value0 TODO\n-\t */\n-\tpublic synchronized void setLimit(int value0) {\n-\t\t// TODO\n-\t} // setLimit()\n-\n-\t/**\n-\t * editToBeUndone\n-\t * @returns UndoableEdit\n-\t */\n-\tprotected UndoableEdit editToBeUndone() {\n-\t\treturn null; // TODO\n-\t} // editToBeUndone()\n-\n-\t/**\n-\t * editToBeRedone\n-\t * @returns UndoableEdit\n-\t */\n-\tprotected UndoableEdit editToBeRedone() {\n-\t\treturn null; // TODO\n-\t} // editToBeRedone()\n-\n-\t/**\n-\t * undoTo\n-\t * @param value0 TODO\n-\t * @exception CannotUndoException TODO\n-\t */\n-\tprotected void undoTo(UndoableEdit value0) throws CannotUndoException {\n-\t\t// TODO\n-\t} // undoTo()\n-\n-\t/**\n-\t * redoTo\n-\t * @param value0 TODO\n-\t * @exception CannotRedoException TODO\n-\t */\n-\tprotected void redoTo(UndoableEdit value0) throws CannotRedoException {\n-\t\t// TODO\n-\t} // redoTo()\n-\n-\t/**\n-\t * undoOrRedo\n-\t * @exception CannotRedoException TODO\n-\t * @exception CannotUndoException TODO\n-\t */\n-\tpublic synchronized void undoOrRedo() throws CannotRedoException, CannotUndoException {\n-\t\t// TODO\n-\t} // undoOrRedo()\n-\n-\t/**\n-\t * canUndoOrRedo\n-\t * @returns boolean\n-\t */\n-\tpublic synchronized boolean canUndoOrRedo() {\n-\t\treturn false; // TODO\n-\t} // canUndoOrRedo()\n-\n-\t/**\n-\t * undo\n-\t * @exception CannotUndoException TODO\n-\t */\n-\tpublic synchronized void undo() throws CannotUndoException {\n-\t\t// TODO\n-\t} // undo()\n-\n-\t/**\n-\t * canUndo\n-\t * @returns boolean\n-\t */\n-\tpublic synchronized boolean canUndo() {\n-\t\treturn false; // TODO\n-\t} // canUndo()\n-\n-\t/**\n-\t * redo\n-\t * @exception CannotRedoException TODO\n-\t */\n-\tpublic synchronized void redo() throws CannotRedoException {\n-\t\t// TODO\n-\t} // redo()\n-\n-\t/**\n-\t * canRedo\n-\t * @returns boolean\n-\t */\n-\tpublic synchronized boolean canRedo() {\n-\t\treturn false; // TODO\n-\t} // canRedo()\n-\n-\t/**\n-\t * addEdit\n-\t * @param value0 TODO\n-\t * @returns boolean\n-\t */\n-\tpublic synchronized boolean addEdit(UndoableEdit value0) {\n-\t\treturn false; // TODO\n-\t} // addEdit()\n-\n-\t/**\n-\t * getUndoOrRedoPresentationName\n-\t * @returns String\n-\t */\n-\tpublic synchronized String getUndoOrRedoPresentationName() {\n-\t\treturn null; // TODO\n-\t} // getUndoOrRedoPresentationName()\n-\n-\t/**\n-\t * getUndoPresentationName\n-\t * @returns String\n-\t */\n-\tpublic synchronized String getUndoPresentationName() {\n-\t\treturn null; // TODO\n-\t} // getUndoPresentationName()\n-\n-\t/**\n-\t * getRedoPresentationName\n-\t * @returns String\n-\t */\n-\tpublic synchronized String getRedoPresentationName() {\n-\t\treturn null; // TODO\n-\t} // getRedoPresentationName()\n-\n-\t/**\n-\t * undoableEditHappened\n-\t * @param value0 TODO\n-\t */\n-\tpublic void undoableEditHappened(UndoableEditEvent value0) {\n-\t\t// TODO\n-\t} // undoableEditHappened()\n-\n-\n-} // UndoManager\n+public class UndoManager\n+  extends CompoundEdit\n+  implements UndoableEditListener\n+{\n+  /**\n+   * The unique ID for serializing instances of this class. Determined\n+   * using the <code>serialver</code> tool of Sun JDK 1.4.1_01 on\n+   * GNU/Linux.\n+   */\n+  static final long serialVersionUID = -2077529998244066750L;\n+\n+\n+  /**\n+   * An index into the inherited {@link #edits} Vector that indicates\n+   * at which position newly added editing actions would get inserted.\n+   *\n+   * <p>Normally, the value of <code>indexOfNextAdd</code> equals\n+   * the number of UndoableEdits stored by this UndoManager, i.e.\n+   * <code>edits.size()</code>. For each call to {@link #undo},\n+   * <code>indexOfNextAdd</code> is decremented by one. For each\n+   * call to {@link #redo}, it is incremented again.\n+   */\n+  int indexOfNextAdd;\n+\n+\n+  /**\n+   * The maximum number of UndoableEdits stored by this UndoManager.\n+   */\n+  int limit;\n+\n+\n+  /**\n+   * Constructs an UndoManager.\n+   *\n+   * <p>The <code>limit</code> of the freshly constructed UndoManager\n+   * is 100.\n+   */\n+  public UndoManager()\n+  {\n+    limit = 100;\n+  }\n+\n+\n+  /**\n+   * Returns a string representation for this UndoManager. This may be\n+   * useful for debugging purposes. For the text of menu items, please\n+   * refer to {@link #getUndoPresentationName}, {@link\n+   * #getRedoPresentationName}, and {@link\n+   * #getUndoOrRedoPresentationName}.\n+   */\n+  public String toString()\n+  {\n+    return super.toString()\n+      + \" limit: \" + limit\n+      + \" indexOfNextAdd: \" + indexOfNextAdd;\n+  }\n+\n+\n+  /**\n+   * Puts this UndoManager into a state where it acts as a normal\n+   * {@link CompoundEdit}. It is unlikely that an application would\n+   * want to do this.\n+   */\n+  public synchronized void end()\n+  {\n+    super.end();\n+    trimEdits(indexOfNextAdd, edits.size() - 1);\n+  }\n+\n+\n+  /**\n+   * Returns how many edits this UndoManager can maximally hold.\n+   *\n+   * @see #setLimit\n+   */\n+  public synchronized int getLimit()\n+  {\n+    return limit;\n+  }\n+\n+\n+  /**\n+   * Changes the maximal number of edits that this UndoManager can\n+   * process. If there are currently more edits than the new limit\n+   * allows, they will receive a {@link UndoableEdit#die() die}\n+   * message in reverse order of addition.\n+   *\n+   * @param limit the new limit.\n+   *\n+   * @throws IllegalStateException if {@link #end()} has already been\n+   * called on this UndoManager.\n+   */\n+  public synchronized void setLimit(int limit)\n+  {\n+    if (!isInProgress())\n+      throw new IllegalStateException();\n+\n+    this.limit = limit;\n+    trimForLimit();\n+  }\n+\n+\n+  /**\n+   * Discards all editing actions that are currently registered with\n+   * this UndoManager. Each {@link UndoableEdit} will receive a {@link\n+   * UndoableEdit#die() die message}.\n+   */\n+  public synchronized void discardAllEdits()\n+  {\n+    int size;\n+\n+    size = edits.size();\n+    for (int i = size - 1; i >= 0; i--)\n+      ((UndoableEdit) edits.get(i)).die();\n+    indexOfNextAdd = 0;\n+    edits.clear();\n+  }\n+\n+\n+  /**\n+   * Called by various internal methods in order to enforce\n+   * the <code>limit</code> value.\n+   */\n+  protected void trimForLimit()\n+  {\n+    int high, s;\n+\n+    s = edits.size();\n+\n+    /* The Sun J2SE1.4.1_01 implementation can be observed to do\n+     * nothing (instead of throwing an exception) with a negative or\n+     * zero limit. It may be debatable whether this is the best\n+     * behavior, but we replicate it for sake of compatibility.\n+     */\n+    if (limit <= 0 || s <= limit)\n+      return;\n+\n+    high = Math.min(indexOfNextAdd + limit/2 - 1, s - 1);\n+    trimEdits(high + 1, s - 1);\n+    trimEdits(0, high - limit);\n+  }\n+\n+\n+  /**\n+   * Discards a range of edits. All edits in the range <code>[from\n+   * .. to]</code> will receive a {@linkplain UndoableEdit#die() die\n+   * message} before being removed from the edits array.  If\n+   * <code>from</code> is greater than <code>to</code>, nothing\n+   * happens.\n+   *\n+   * @param from the lower bound of the range of edits to be\n+   * discarded.\n+   *\n+   * @param to the upper bound of the range of edits to be discarded.\n+   */\n+  protected void trimEdits(int from, int to)\n+  {\n+    if (from > to)\n+      return;\n+\n+    for (int i = to; i >= from; i--)\n+        ((UndoableEdit) edits.get(i)).die();\n+\n+    // Remove the range [from .. to] from edits. If from == to, which\n+    // is likely to be a very common case, we can do better than\n+    // creating a sub-list and clearing it.\n+    if (to == from)\n+      edits.remove(from);\n+    else\n+      edits.subList(from, to + 1).clear();\n+\n+    if (indexOfNextAdd > to)\n+      indexOfNextAdd = indexOfNextAdd - to + from - 1;\n+    else if (indexOfNextAdd >= from)\n+      indexOfNextAdd = from;\n+  }\n+\n+\n+  /**\n+   * Determines which significant edit would be undone if {@link\n+   * #undo()} was called.\n+   *\n+   * @returns the significant edit that would be undone, or\n+   * <code>null</code> if no significant edit would be affected by\n+   * calling {@link #undo()}.\n+   */\n+  protected UndoableEdit editToBeUndone()\n+  {\n+    UndoableEdit result;\n+\n+    for (int i = indexOfNextAdd - 1; i >= 0; i--)\n+      {\n+        result = (UndoableEdit) edits.get(i);\n+        if (result.isSignificant())\n+          return result;\n+      }\n+\n+    return null;\n+  }\n+\n+\n+  /**\n+   * Determines which significant edit would be redone if {@link\n+   * #redo()} was called.\n+   *\n+   * @returns the significant edit that would be redone, or\n+   * <code>null</code> if no significant edit would be affected by\n+   * calling {@link #redo()}.\n+   */\n+  protected UndoableEdit editToBeRedone()\n+  {\n+    UndoableEdit result;\n+\n+    for (int i = indexOfNextAdd; i < edits.size(); i++)\n+      {\n+        result = (UndoableEdit) edits.get(i);\n+        if (result.isSignificant())\n+          return result;\n+      }\n+\n+    return null;\n+  }\n+\n+\n+  /**\n+   * Undoes all editing actions in reverse order of addition,\n+   * up to the specified action,\n+   *\n+   * @param edit the last editing action to be undone.\n+   */\n+  protected void undoTo(UndoableEdit edit)\n+    throws CannotUndoException\n+  {\n+    UndoableEdit cur;\n+\n+    if (!edits.contains(edit))\n+      throw new CannotUndoException();\n+\n+    while (true)\n+      {\n+        indexOfNextAdd -= 1;\n+        cur = (UndoableEdit) edits.get(indexOfNextAdd);\n+        cur.undo();\n+        if (cur == edit)\n+          return;\n+      }\n+  }\n+\n+\n+  /**\n+   * Redoes all editing actions in the same order as they were\n+   * added to this UndoManager, up to the specified action.\n+   *\n+   * @param edit the last editing action to be redone.\n+   */\n+  protected void redoTo(UndoableEdit edit)\n+    throws CannotRedoException\n+  {\n+    UndoableEdit cur;\n+\n+    if (!edits.contains(edit))\n+      throw new CannotRedoException();\n+\n+    while (true)\n+      {\n+        cur = (UndoableEdit) edits.get(indexOfNextAdd);\n+        indexOfNextAdd += 1;\n+        cur.redo();\n+        if (cur == edit)\n+          return;\n+      }\n+  }\n+\n+  \n+  /**\n+   * Undoes or redoes the last action. If the last action has already\n+   * been undone, it will be re-done, and vice versa.\n+   *\n+   * <p>This is useful for applications that do not present a separate\n+   * undo and redo facility, but just have a single menu item for\n+   * undoing and redoing the very last action. Such applications will\n+   * use an <code>UndoManager</code> whose <code>limit</code> is 1.\n+   */\n+  public synchronized void undoOrRedo()\n+    throws CannotRedoException, CannotUndoException\n+  {\n+    if (indexOfNextAdd == edits.size())\n+      undo();\n+    else\n+      redo();\n+  }\n+\n+\n+  /**\n+   * Determines whether it would be possible to either undo or redo\n+   * this editing action.\n+   *\n+   * <p>This is useful for applications that do not present a separate\n+   * undo and redo facility, but just have a single menu item for\n+   * undoing and redoing the very last action. Such applications will\n+   * use an <code>UndoManager</code> whose <code>limit</code> is 1.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * undone or redone; <code>false</code> if neither is possible at\n+   * the current time.\n+   */\n+  public synchronized boolean canUndoOrRedo()\n+  {\n+    return indexOfNextAdd == edits.size() ? canUndo() : canRedo();\n+  }\n+\n+\n+  /**\n+   * Undoes one significant edit action. If insignificant actions have\n+   * been posted after the last signficant action, the insignificant\n+   * ones will be undone first.\n+   *\n+   * <p>However, if {@link #end()} has been called on this\n+   * UndoManager, it will behave like a normal {@link\n+   * CompoundEdit}. In this case, all actions will be undone in\n+   * reverse order of addition. Typical applications will never call\n+   * {@link #end()} on their <code>UndoManager</code>.\n+   *\n+   * @throws CannotUndoException if no action can be undone.\n+   *\n+   * @see #canUndo()\n+   * @see #redo()\n+   * @see #undoOrRedo()\n+   */\n+  public synchronized void undo()\n+    throws CannotUndoException\n+  {\n+    if (!isInProgress())\n+      {\n+        super.undo();\n+        return;\n+      }\n+\n+    UndoableEdit edit = editToBeUndone();\n+    if (edit == null)\n+      throw new CannotUndoException();\n+\n+    undoTo(edit);\n+  }\n+\n+\n+  /**\n+   * Determines whether it would be possible to undo this editing\n+   * action.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * undone; <code>false</code> otherwise.\n+   *\n+   * @see #undo()\n+   * @see #canRedo()\n+   * @see #canUndoOrRedo()\n+   */\n+  public synchronized boolean canUndo()\n+  {\n+    UndoableEdit edit;\n+\n+    if (!isInProgress())\n+      return super.canUndo();\n+\n+    edit = editToBeUndone();\n+    return edit != null && edit.canUndo();\n+  }\n+\n+\n+\n+  /**\n+   * Redoes one significant edit action. If insignificant actions have\n+   * been posted in between, the insignificant ones will be redone\n+   * first.\n+   *\n+   * <p>However, if {@link #end()} has been called on this\n+   * UndoManager, it will behave like a normal {@link\n+   * CompoundEdit}. In this case, <em>all</em> actions will be redone\n+   * in order of addition. Typical applications will never call {@link\n+   * #end()} on their <code>UndoManager</code>.\n+   *\n+   * @throws CannotRedoException if no action can be redone.\n+   *\n+   * @see #canRedo()\n+   * @see #redo()\n+   * @see #undoOrRedo()\n+   */\n+  public synchronized void redo()\n+    throws CannotRedoException\n+  {\n+    if (!isInProgress())\n+      {\n+        super.redo();\n+        return;\n+      }\n+\n+    UndoableEdit edit = editToBeRedone();\n+    if (edit == null)\n+      throw new CannotRedoException();\n+\n+    redoTo(edit);\n+  }\n+\n+\n+  /**\n+   * Determines whether it would be possible to redo this editing\n+   * action.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * redone; <code>false</code> otherwise.\n+   *\n+   * @see #redo()\n+   * @see #canUndo()\n+   * @see #canUndoOrRedo()\n+   */\n+  public synchronized boolean canRedo()\n+  {\n+    UndoableEdit edit;\n+\n+    if (!isInProgress())\n+      return super.canRedo();\n+\n+    edit = editToBeRedone();\n+    return edit != null && edit.canRedo();\n+  }\n+\n+\n+  /**\n+   * Registers an undoable editing action with this UndoManager.  If\n+   * the capacity <code>limit</code> is reached, the oldest action\n+   * will be discarded (and receives a {@linkplain UndoableEdit#die()\n+   * die message}. Equally, any actions that were undone (but not re-done)\n+   * will be discarded, too.\n+   *\n+   * @param edit the editing action that is added to this UndoManager.\n+   *\n+   * @return <code>true</code> if <code>edit</code> could be\n+   * incorporated; <code>false</code> if <code>edit</code> has not\n+   * been incorporated because {@link #end()} has already been called\n+   * on this <code>UndoManager</code>.\n+   */\n+  public synchronized boolean addEdit(UndoableEdit edit)\n+  {\n+    boolean result;\n+\n+    // Discard any edits starting at indexOfNextAdd.\n+    trimEdits(indexOfNextAdd, edits.size() - 1);\n+\n+    result = super.addEdit(edit);\n+    indexOfNextAdd = edits.size();\n+    trimForLimit();\n+    return result;\n+  }\n+\n+\n+  /**\n+   * Calculates a localized text for presenting the undo or redo\n+   * action to the user, for example in the form of a menu command.\n+   *\n+   * <p>This is useful for applications that do not present a separate\n+   * undo and redo facility, but just have a single menu item for\n+   * undoing and redoing the very last action. Such applications will\n+   * use an <code>UndoManager</code> whose <code>limit</code> is 1.\n+   *\n+   * @return the redo presentation name if the last action has already\n+   * been undone, or the undo presentation name otherwise.\n+   *\n+   * @see #getUndoPresentationName()\n+   * @see #getRedoPresentationName()\n+   */\n+  public synchronized String getUndoOrRedoPresentationName()\n+  {\n+    if (indexOfNextAdd == edits.size())\n+      return getUndoPresentationName();\n+    else\n+      return getRedoPresentationName();\n+  }\n+\n+\n+  /**\n+   * Calculates a localized text for presenting the undo action\n+   * to the user, for example in the form of a menu command.\n+   */\n+  public synchronized String getUndoPresentationName()\n+  {\n+    UndoableEdit edit;\n+\n+    if (!isInProgress())\n+      return super.getUndoPresentationName();\n+\n+    edit = editToBeUndone();\n+    if (edit == null)\n+      return UIManager.getString(\"AbstractUndoableEdit.undoText\");\n+    else\n+      return edit.getUndoPresentationName();\n+  }\n+\n+\n+  /**\n+   * Calculates a localized text for presenting the redo action\n+   * to the user, for example in the form of a menu command.\n+   */\n+  public synchronized String getRedoPresentationName()\n+  {\n+    UndoableEdit edit;\n+\n+    if (!isInProgress())\n+      return super.getRedoPresentationName();\n+\n+    edit = editToBeRedone();\n+    if (edit == null)\n+      return UIManager.getString(\"AbstractUndoableEdit.redoText\");\n+    else\n+      return edit.getRedoPresentationName();\n+  }\n+  \n+  \n+  /**\n+   * Registers the edit action of an {@link UndoableEditEvent}\n+   * with this UndoManager.\n+   *\n+   * <p><b>Thread Safety:</b> This method may safely be invoked from\n+   * concurrent threads.  The caller does not need to perform external\n+   * synchronization. This means that {@link\n+   * javax.swing.event.UndoableEvent} sources do not need to broadcast\n+   * their events from inside the Swing worker thread.\n+   *\n+   * @param event the event whose <code>edit</code> will be\n+   * passed to {@link #addEdit}.\n+   *\n+   * @see UndoableEditEvent#getEdit()\n+   * @see #addEdit\n+   */\n+  public void undoableEditHappened(UndoableEditEvent event)\n+  {\n+    // Note that this method does not need to be synchronized,\n+    // because addEdit will obtain and release the mutex.\n+    addEdit(event.getEdit());\n+  }\n+}"}]}