{"sha": "a960e80813e7e08410f5fb94368c63f276039b42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk2MGU4MDgxM2U3ZTA4NDEwZjVmYjk0MzY4YzYzZjI3NjAzOWI0Mg==", "commit": {"author": {"name": "Adam Butcher", "email": "adam@jessamine.co.uk", "date": "2013-07-14T17:29:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-07-14T17:29:55Z"}, "message": "Extract lambda functions from semantics.c.\n\n\t* gcc/cp/semantics.c (build_lambda_expr),\n\t(build_lambda_object), (begin_lambda_type), (lambda_return_type),\n\t(lambda_function), (lambda_capture_field_type), (is_capture_proxy),\n\t(is_normal_capture_proxy), (insert_capture_proxy),\n\t(insert_pending_capture_proxies), (lambda_proxy_type),\n\t(build_capture_proxy), (vla_capture_type),\n\t(register_capture_members), (add_default_capture),\n\t(lambda_expr_this_capture), (maybe_resolve_dummy),\n\t(nonlambda_method_basetype), (maybe_add_lambda_conv_op) and\n\t(is_lambda_ignored_entity): Moved definitions into ...\n\t* gcc/cp/lambda.c: ... this new file.\n\nFrom-SVN: r200948", "tree": {"sha": "7e6fcf2ff26bfcedaa6541a3c33f6660251ea8e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e6fcf2ff26bfcedaa6541a3c33f6660251ea8e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a960e80813e7e08410f5fb94368c63f276039b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a960e80813e7e08410f5fb94368c63f276039b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a960e80813e7e08410f5fb94368c63f276039b42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a960e80813e7e08410f5fb94368c63f276039b42/comments", "author": {"login": "abutcher-gh", "id": 10379705, "node_id": "MDQ6VXNlcjEwMzc5NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/10379705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abutcher-gh", "html_url": "https://github.com/abutcher-gh", "followers_url": "https://api.github.com/users/abutcher-gh/followers", "following_url": "https://api.github.com/users/abutcher-gh/following{/other_user}", "gists_url": "https://api.github.com/users/abutcher-gh/gists{/gist_id}", "starred_url": "https://api.github.com/users/abutcher-gh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abutcher-gh/subscriptions", "organizations_url": "https://api.github.com/users/abutcher-gh/orgs", "repos_url": "https://api.github.com/users/abutcher-gh/repos", "events_url": "https://api.github.com/users/abutcher-gh/events{/privacy}", "received_events_url": "https://api.github.com/users/abutcher-gh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07298ffd6f7c2d2623272bba009a23750db12397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07298ffd6f7c2d2623272bba009a23750db12397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07298ffd6f7c2d2623272bba009a23750db12397"}], "stats": {"total": 1824, "additions": 935, "deletions": 889}, "files": [{"sha": "503586fc0c26d86dc3a82f7a67ee835903ca17d7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a960e80813e7e08410f5fb94368c63f276039b42", "patch": "@@ -1,3 +1,17 @@\n+2013-07-14  Adam Butcher  <adam@jessamine.co.uk>\n+\n+\t* semantics.c (build_lambda_expr),\n+\t(build_lambda_object), (begin_lambda_type), (lambda_return_type),\n+\t(lambda_function), (lambda_capture_field_type), (is_capture_proxy),\n+\t(is_normal_capture_proxy), (insert_capture_proxy),\n+\t(insert_pending_capture_proxies), (lambda_proxy_type),\n+\t(build_capture_proxy), (vla_capture_type),\n+\t(register_capture_members), (add_default_capture),\n+\t(lambda_expr_this_capture), (maybe_resolve_dummy),\n+\t(nonlambda_method_basetype), (maybe_add_lambda_conv_op) and\n+\t(is_lambda_ignored_entity): Moved definitions into ...\n+\t* lambda.c: ... this new file.\n+\n 2013-07-14  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* call.c (build_conditional_expr_1): Handle the case with 1 vector"}, {"sha": "2cb919a21728fba7619679fa114185fe652d9744", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=a960e80813e7e08410f5fb94368c63f276039b42", "patch": "@@ -80,7 +80,7 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \\\n  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n- cp/cp-gimplify.o cp/cp-array-notation.o $(CXX_C_OBJS)\n+ cp/cp-gimplify.o cp/cp-array-notation.o cp/lambda.o $(CXX_C_OBJS)\n \n # Language-specific object files for C++.\n CXX_OBJS = cp/cp-lang.o c-family/stub-objc.o $(CXX_AND_OBJCXX_OBJS)"}, {"sha": "a53e692d48b462ca94db0bb456681cf45d833c29", "filename": "gcc/cp/lambda.c", "status": "added", "additions": 920, "deletions": 0, "changes": 920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=a960e80813e7e08410f5fb94368c63f276039b42", "patch": "@@ -0,0 +1,920 @@\n+/* Perform the semantic phase of lambda parsing, i.e., the process of\n+   building tree structure, checking semantic consistency, and\n+   building RTL.  These routines are used both during actual parsing\n+   and during the instantiation of template functions.\n+\n+   Copyright (C) 1998-2013 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"cgraph.h\"\n+#include \"tree-iterator.h\"\n+#include \"cp-tree.h\"\n+#include \"toplev.h\"\n+#include \"vec.h\"\n+\n+/* Constructor for a lambda expression.  */\n+\n+tree\n+build_lambda_expr (void)\n+{\n+  tree lambda = make_node (LAMBDA_EXPR);\n+  LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) = CPLD_NONE;\n+  LAMBDA_EXPR_CAPTURE_LIST         (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_THIS_CAPTURE         (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_PENDING_PROXIES      (lambda) = NULL;\n+  LAMBDA_EXPR_RETURN_TYPE          (lambda) = NULL_TREE;\n+  LAMBDA_EXPR_MUTABLE_P            (lambda) = false;\n+  return lambda;\n+}\n+\n+/* Create the closure object for a LAMBDA_EXPR.  */\n+\n+tree\n+build_lambda_object (tree lambda_expr)\n+{\n+  /* Build aggregate constructor call.\n+     - cp_parser_braced_list\n+     - cp_parser_functional_cast  */\n+  vec<constructor_elt, va_gc> *elts = NULL;\n+  tree node, expr, type;\n+  location_t saved_loc;\n+\n+  if (processing_template_decl)\n+    return lambda_expr;\n+\n+  /* Make sure any error messages refer to the lambda-introducer.  */\n+  saved_loc = input_location;\n+  input_location = LAMBDA_EXPR_LOCATION (lambda_expr);\n+\n+  for (node = LAMBDA_EXPR_CAPTURE_LIST (lambda_expr);\n+       node;\n+       node = TREE_CHAIN (node))\n+    {\n+      tree field = TREE_PURPOSE (node);\n+      tree val = TREE_VALUE (node);\n+\n+      if (field == error_mark_node)\n+\t{\n+\t  expr = error_mark_node;\n+\t  goto out;\n+\t}\n+\n+      if (DECL_P (val))\n+\tmark_used (val);\n+\n+      /* Mere mortals can't copy arrays with aggregate initialization, so\n+\t do some magic to make it work here.  */\n+      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n+\tval = build_array_copy (val);\n+      else if (DECL_NORMAL_CAPTURE_P (field)\n+\t       && !DECL_VLA_CAPTURE_P (field)\n+\t       && TREE_CODE (TREE_TYPE (field)) != REFERENCE_TYPE)\n+\t{\n+\t  /* \"the entities that are captured by copy are used to\n+\t     direct-initialize each corresponding non-static data\n+\t     member of the resulting closure object.\"\n+\n+\t     There's normally no way to express direct-initialization\n+\t     from an element of a CONSTRUCTOR, so we build up a special\n+\t     TARGET_EXPR to bypass the usual copy-initialization.  */\n+\t  val = force_rvalue (val, tf_warning_or_error);\n+\t  if (TREE_CODE (val) == TARGET_EXPR)\n+\t    TARGET_EXPR_DIRECT_INIT_P (val) = true;\n+\t}\n+\n+      CONSTRUCTOR_APPEND_ELT (elts, DECL_NAME (field), val);\n+    }\n+\n+  expr = build_constructor (init_list_type_node, elts);\n+  CONSTRUCTOR_IS_DIRECT_INIT (expr) = 1;\n+\n+  /* N2927: \"[The closure] class type is not an aggregate.\"\n+     But we briefly treat it as an aggregate to make this simpler.  */\n+  type = LAMBDA_EXPR_CLOSURE (lambda_expr);\n+  CLASSTYPE_NON_AGGREGATE (type) = 0;\n+  expr = finish_compound_literal (type, expr, tf_warning_or_error);\n+  CLASSTYPE_NON_AGGREGATE (type) = 1;\n+\n+ out:\n+  input_location = saved_loc;\n+  return expr;\n+}\n+\n+/* Return an initialized RECORD_TYPE for LAMBDA.\n+   LAMBDA must have its explicit captures already.  */\n+\n+tree\n+begin_lambda_type (tree lambda)\n+{\n+  tree type;\n+\n+  {\n+    /* Unique name.  This is just like an unnamed class, but we cannot use\n+       make_anon_name because of certain checks against TYPE_ANONYMOUS_P.  */\n+    tree name;\n+    name = make_lambda_name ();\n+\n+    /* Create the new RECORD_TYPE for this lambda.  */\n+    type = xref_tag (/*tag_code=*/record_type,\n+                     name,\n+                     /*scope=*/ts_lambda,\n+                     /*template_header_p=*/false);\n+  }\n+\n+  /* Designate it as a struct so that we can use aggregate initialization.  */\n+  CLASSTYPE_DECLARED_CLASS (type) = false;\n+\n+  /* Cross-reference the expression and the type.  */\n+  LAMBDA_EXPR_CLOSURE (lambda) = type;\n+  CLASSTYPE_LAMBDA_EXPR (type) = lambda;\n+\n+  /* Clear base types.  */\n+  xref_basetypes (type, /*bases=*/NULL_TREE);\n+\n+  /* Start the class.  */\n+  type = begin_class_definition (type);\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  return type;\n+}\n+\n+/* Returns the type to use for the return type of the operator() of a\n+   closure class.  */\n+\n+tree\n+lambda_return_type (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return void_type_node;\n+  if (type_unknown_p (expr)\n+      || BRACE_ENCLOSED_INITIALIZER_P (expr))\n+    {\n+      cxx_incomplete_type_error (expr, TREE_TYPE (expr));\n+      return void_type_node;\n+    }\n+  gcc_checking_assert (!type_dependent_expression_p (expr));\n+  return cv_unqualified (type_decays_to (unlowered_expr_type (expr)));\n+}\n+\n+/* Given a LAMBDA_EXPR or closure type LAMBDA, return the op() of the\n+   closure type.  */\n+\n+tree\n+lambda_function (tree lambda)\n+{\n+  tree type;\n+  if (TREE_CODE (lambda) == LAMBDA_EXPR)\n+    type = LAMBDA_EXPR_CLOSURE (lambda);\n+  else\n+    type = lambda;\n+  gcc_assert (LAMBDA_TYPE_P (type));\n+  /* Don't let debug_tree cause instantiation.  */\n+  if (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n+      && !COMPLETE_OR_OPEN_TYPE_P (type))\n+    return NULL_TREE;\n+  lambda = lookup_member (type, ansi_opname (CALL_EXPR),\n+\t\t\t  /*protect=*/0, /*want_type=*/false,\n+\t\t\t  tf_warning_or_error);\n+  if (lambda)\n+    lambda = BASELINK_FUNCTIONS (lambda);\n+  return lambda;\n+}\n+\n+/* Returns the type to use for the FIELD_DECL corresponding to the\n+   capture of EXPR.\n+   The caller should add REFERENCE_TYPE for capture by reference.  */\n+\n+tree\n+lambda_capture_field_type (tree expr, bool explicit_init_p)\n+{\n+  tree type;\n+  if (explicit_init_p)\n+    {\n+      type = make_auto ();\n+      type = do_auto_deduction (type, expr, type);\n+    }\n+  else\n+    type = non_reference (unlowered_expr_type (expr));\n+  if (!type || WILDCARD_TYPE_P (type) || type_uses_auto (type))\n+    {\n+      type = cxx_make_type (DECLTYPE_TYPE);\n+      DECLTYPE_TYPE_EXPR (type) = expr;\n+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;\n+      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;\n+      SET_TYPE_STRUCTURAL_EQUALITY (type);\n+    }\n+  return type;\n+}\n+\n+/* Returns true iff DECL is a lambda capture proxy variable created by\n+   build_capture_proxy.  */\n+\n+bool\n+is_capture_proxy (tree decl)\n+{\n+  return (VAR_P (decl)\n+\t  && DECL_HAS_VALUE_EXPR_P (decl)\n+\t  && !DECL_ANON_UNION_VAR_P (decl)\n+\t  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));\n+}\n+\n+/* Returns true iff DECL is a capture proxy for a normal capture\n+   (i.e. without explicit initializer).  */\n+\n+bool\n+is_normal_capture_proxy (tree decl)\n+{\n+  if (!is_capture_proxy (decl))\n+    /* It's not a capture proxy.  */\n+    return false;\n+\n+  /* It is a capture proxy, is it a normal capture?  */\n+  tree val = DECL_VALUE_EXPR (decl);\n+  if (val == error_mark_node)\n+    return true;\n+\n+  gcc_assert (TREE_CODE (val) == COMPONENT_REF);\n+  val = TREE_OPERAND (val, 1);\n+  return DECL_NORMAL_CAPTURE_P (val);\n+}\n+\n+/* VAR is a capture proxy created by build_capture_proxy; add it to the\n+   current function, which is the operator() for the appropriate lambda.  */\n+\n+void\n+insert_capture_proxy (tree var)\n+{\n+  cp_binding_level *b;\n+  tree stmt_list;\n+\n+  /* Put the capture proxy in the extra body block so that it won't clash\n+     with a later local variable.  */\n+  b = current_binding_level;\n+  for (;;)\n+    {\n+      cp_binding_level *n = b->level_chain;\n+      if (n->kind == sk_function_parms)\n+\tbreak;\n+      b = n;\n+    }\n+  pushdecl_with_scope (var, b, false);\n+\n+  /* And put a DECL_EXPR in the STATEMENT_LIST for the same block.  */\n+  var = build_stmt (DECL_SOURCE_LOCATION (var), DECL_EXPR, var);\n+  stmt_list = (*stmt_list_stack)[1];\n+  gcc_assert (stmt_list);\n+  append_to_statement_list_force (var, &stmt_list);\n+}\n+\n+/* We've just finished processing a lambda; if the containing scope is also\n+   a lambda, insert any capture proxies that were created while processing\n+   the nested lambda.  */\n+\n+void\n+insert_pending_capture_proxies (void)\n+{\n+  tree lam;\n+  vec<tree, va_gc> *proxies;\n+  unsigned i;\n+\n+  if (!current_function_decl || !LAMBDA_FUNCTION_P (current_function_decl))\n+    return;\n+\n+  lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n+  proxies = LAMBDA_EXPR_PENDING_PROXIES (lam);\n+  for (i = 0; i < vec_safe_length (proxies); ++i)\n+    {\n+      tree var = (*proxies)[i];\n+      insert_capture_proxy (var);\n+    }\n+  release_tree_vector (LAMBDA_EXPR_PENDING_PROXIES (lam));\n+  LAMBDA_EXPR_PENDING_PROXIES (lam) = NULL;\n+}\n+\n+/* Given REF, a COMPONENT_REF designating a field in the lambda closure,\n+   return the type we want the proxy to have: the type of the field itself,\n+   with added const-qualification if the lambda isn't mutable and the\n+   capture is by value.  */\n+\n+tree\n+lambda_proxy_type (tree ref)\n+{\n+  tree type;\n+  if (REFERENCE_REF_P (ref))\n+    ref = TREE_OPERAND (ref, 0);\n+  type = TREE_TYPE (ref);\n+  if (type && !WILDCARD_TYPE_P (non_reference (type)))\n+    return type;\n+  type = cxx_make_type (DECLTYPE_TYPE);\n+  DECLTYPE_TYPE_EXPR (type) = ref;\n+  DECLTYPE_FOR_LAMBDA_PROXY (type) = true;\n+  SET_TYPE_STRUCTURAL_EQUALITY (type);\n+  return type;\n+}\n+\n+/* MEMBER is a capture field in a lambda closure class.  Now that we're\n+   inside the operator(), build a placeholder var for future lookups and\n+   debugging.  */\n+\n+tree\n+build_capture_proxy (tree member)\n+{\n+  tree var, object, fn, closure, name, lam, type;\n+\n+  closure = DECL_CONTEXT (member);\n+  fn = lambda_function (closure);\n+  lam = CLASSTYPE_LAMBDA_EXPR (closure);\n+\n+  /* The proxy variable forwards to the capture field.  */\n+  object = build_fold_indirect_ref (DECL_ARGUMENTS (fn));\n+  object = finish_non_static_data_member (member, object, NULL_TREE);\n+  if (REFERENCE_REF_P (object))\n+    object = TREE_OPERAND (object, 0);\n+\n+  /* Remove the __ inserted by add_capture.  */\n+  if (DECL_NORMAL_CAPTURE_P (member))\n+    name = get_identifier (IDENTIFIER_POINTER (DECL_NAME (member)) + 2);\n+  else\n+    name = DECL_NAME (member);\n+\n+  type = lambda_proxy_type (object);\n+\n+  if (DECL_VLA_CAPTURE_P (member))\n+    {\n+      /* Rebuild the VLA type from the pointer and maxindex.  */\n+      tree field = next_initializable_field (TYPE_FIELDS (type));\n+      tree ptr = build_simple_component_ref (object, field);\n+      field = next_initializable_field (DECL_CHAIN (field));\n+      tree max = build_simple_component_ref (object, field);\n+      type = build_array_type (TREE_TYPE (TREE_TYPE (ptr)),\n+\t\t\t       build_index_type (max));\n+      type = build_reference_type (type);\n+      REFERENCE_VLA_OK (type) = true;\n+      object = convert (type, ptr);\n+    }\n+\n+  var = build_decl (input_location, VAR_DECL, name, type);\n+  SET_DECL_VALUE_EXPR (var, object);\n+  DECL_HAS_VALUE_EXPR_P (var) = 1;\n+  DECL_ARTIFICIAL (var) = 1;\n+  TREE_USED (var) = 1;\n+  DECL_CONTEXT (var) = fn;\n+\n+  if (name == this_identifier)\n+    {\n+      gcc_assert (LAMBDA_EXPR_THIS_CAPTURE (lam) == member);\n+      LAMBDA_EXPR_THIS_CAPTURE (lam) = var;\n+    }\n+\n+  if (fn == current_function_decl)\n+    insert_capture_proxy (var);\n+  else\n+    vec_safe_push (LAMBDA_EXPR_PENDING_PROXIES (lam), var);\n+\n+  return var;\n+}\n+\n+/* Return a struct containing a pointer and a length for lambda capture of\n+   an array of runtime length.  */\n+\n+static tree\n+vla_capture_type (tree array_type)\n+{\n+  static tree ptr_id, max_id;\n+  tree type = xref_tag (record_type, make_anon_name (), ts_current, false);\n+  xref_basetypes (type, NULL_TREE);\n+  type = begin_class_definition (type);\n+  if (!ptr_id)\n+    {\n+      ptr_id = get_identifier (\"ptr\");\n+      max_id = get_identifier (\"max\");\n+    }\n+  tree ptrtype = build_pointer_type (TREE_TYPE (array_type));\n+  tree field = build_decl (input_location, FIELD_DECL, ptr_id, ptrtype);\n+  finish_member_declaration (field);\n+  field = build_decl (input_location, FIELD_DECL, max_id, sizetype);\n+  finish_member_declaration (field);\n+  return finish_struct (type, NULL_TREE);\n+}\n+\n+/* From an ID and INITIALIZER, create a capture (by reference if\n+   BY_REFERENCE_P is true), add it to the capture-list for LAMBDA,\n+   and return it.  */\n+\n+tree\n+add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n+\t     bool explicit_init_p)\n+{\n+  char *buf;\n+  tree type, member, name;\n+  bool vla = false;\n+\n+  if (TREE_CODE (initializer) == TREE_LIST)\n+    initializer = build_x_compound_expr_from_list (initializer, ELK_INIT,\n+\t\t\t\t\t\t   tf_warning_or_error);\n+  type = lambda_capture_field_type (initializer, explicit_init_p);\n+  if (array_of_runtime_bound_p (type))\n+    {\n+      vla = true;\n+      if (!by_reference_p)\n+\terror (\"array of runtime bound cannot be captured by copy, \"\n+\t       \"only by reference\");\n+\n+      /* For a VLA, we capture the address of the first element and the\n+\t maximum index, and then reconstruct the VLA for the proxy.  */\n+      tree elt = cp_build_array_ref (input_location, initializer,\n+\t\t\t\t     integer_zero_node, tf_warning_or_error);\n+      initializer = build_constructor_va (init_list_type_node, 2,\n+\t\t\t\t\t  NULL_TREE, build_address (elt),\n+\t\t\t\t\t  NULL_TREE, array_type_nelts (type));\n+      type = vla_capture_type (type);\n+    }\n+  else if (variably_modified_type_p (type, NULL_TREE))\n+    {\n+      error (\"capture of variable-size type %qT that is not a C++1y array \"\n+\t     \"of runtime bound\", type);\n+      if (TREE_CODE (type) == ARRAY_TYPE\n+\t  && variably_modified_type_p (TREE_TYPE (type), NULL_TREE))\n+\tinform (input_location, \"because the array element type %qT has \"\n+\t\t\"variable size\", TREE_TYPE (type));\n+      type = error_mark_node;\n+    }\n+  else if (by_reference_p)\n+    {\n+      type = build_reference_type (type);\n+      if (!real_lvalue_p (initializer))\n+\terror (\"cannot capture %qE by reference\", initializer);\n+    }\n+  else\n+    /* Capture by copy requires a complete type.  */\n+    type = complete_type (type);\n+\n+  /* Add __ to the beginning of the field name so that user code\n+     won't find the field with name lookup.  We can't just leave the name\n+     unset because template instantiation uses the name to find\n+     instantiated fields.  */\n+  if (!explicit_init_p)\n+    {\n+      buf = (char *) alloca (IDENTIFIER_LENGTH (id) + 3);\n+      buf[1] = buf[0] = '_';\n+      memcpy (buf + 2, IDENTIFIER_POINTER (id),\n+\t      IDENTIFIER_LENGTH (id) + 1);\n+      name = get_identifier (buf);\n+    }\n+  else\n+    /* But captures with explicit initializers are named.  */\n+    name = id;\n+\n+  /* If TREE_TYPE isn't set, we're still in the introducer, so check\n+     for duplicates.  */\n+  if (!LAMBDA_EXPR_CLOSURE (lambda))\n+    {\n+      if (IDENTIFIER_MARKED (name))\n+\t{\n+\t  pedwarn (input_location, 0,\n+\t\t   \"already captured %qD in lambda expression\", id);\n+\t  return NULL_TREE;\n+\t}\n+      IDENTIFIER_MARKED (name) = true;\n+    }\n+\n+  /* Make member variable.  */\n+  member = build_lang_decl (FIELD_DECL, name, type);\n+  DECL_VLA_CAPTURE_P (member) = vla;\n+\n+  if (!explicit_init_p)\n+    /* Normal captures are invisible to name lookup but uses are replaced\n+       with references to the capture field; we implement this by only\n+       really making them invisible in unevaluated context; see\n+       qualify_lookup.  For now, let's make explicitly initialized captures\n+       always visible.  */\n+    DECL_NORMAL_CAPTURE_P (member) = true;\n+\n+  if (id == this_identifier)\n+    LAMBDA_EXPR_THIS_CAPTURE (lambda) = member;\n+\n+  /* Add it to the appropriate closure class if we've started it.  */\n+  if (current_class_type\n+      && current_class_type == LAMBDA_EXPR_CLOSURE (lambda))\n+    finish_member_declaration (member);\n+\n+  LAMBDA_EXPR_CAPTURE_LIST (lambda)\n+    = tree_cons (member, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n+\n+  if (LAMBDA_EXPR_CLOSURE (lambda))\n+    return build_capture_proxy (member);\n+  /* For explicit captures we haven't started the function yet, so we wait\n+     and build the proxy from cp_parser_lambda_body.  */\n+  return NULL_TREE;\n+}\n+\n+/* Register all the capture members on the list CAPTURES, which is the\n+   LAMBDA_EXPR_CAPTURE_LIST for the lambda after the introducer.  */\n+\n+void\n+register_capture_members (tree captures)\n+{\n+  if (captures == NULL_TREE)\n+    return;\n+\n+  register_capture_members (TREE_CHAIN (captures));\n+  /* We set this in add_capture to avoid duplicates.  */\n+  IDENTIFIER_MARKED (DECL_NAME (TREE_PURPOSE (captures))) = false;\n+  finish_member_declaration (TREE_PURPOSE (captures));\n+}\n+\n+/* Similar to add_capture, except this works on a stack of nested lambdas.\n+   BY_REFERENCE_P in this case is derived from the default capture mode.\n+   Returns the capture for the lambda at the bottom of the stack.  */\n+\n+tree\n+add_default_capture (tree lambda_stack, tree id, tree initializer)\n+{\n+  bool this_capture_p = (id == this_identifier);\n+\n+  tree var = NULL_TREE;\n+\n+  tree saved_class_type = current_class_type;\n+\n+  tree node;\n+\n+  for (node = lambda_stack;\n+       node;\n+       node = TREE_CHAIN (node))\n+    {\n+      tree lambda = TREE_VALUE (node);\n+\n+      current_class_type = LAMBDA_EXPR_CLOSURE (lambda);\n+      var = add_capture (lambda,\n+                            id,\n+                            initializer,\n+                            /*by_reference_p=*/\n+\t\t\t    (!this_capture_p\n+\t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n+\t\t\t\t == CPLD_REFERENCE)),\n+\t\t\t    /*explicit_init_p=*/false);\n+      initializer = convert_from_reference (var);\n+    }\n+\n+  current_class_type = saved_class_type;\n+\n+  return var;\n+}\n+\n+/* Return the capture pertaining to a use of 'this' in LAMBDA, in the form of an\n+   INDIRECT_REF, possibly adding it through default capturing.  */\n+\n+tree\n+lambda_expr_this_capture (tree lambda)\n+{\n+  tree result;\n+\n+  tree this_capture = LAMBDA_EXPR_THIS_CAPTURE (lambda);\n+\n+  /* In unevaluated context this isn't an odr-use, so just return the\n+     nearest 'this'.  */\n+  if (cp_unevaluated_operand)\n+    return lookup_name (this_identifier);\n+\n+  /* Try to default capture 'this' if we can.  */\n+  if (!this_capture\n+      && LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) != CPLD_NONE)\n+    {\n+      tree lambda_stack = NULL_TREE;\n+      tree init = NULL_TREE;\n+\n+      /* If we are in a lambda function, we can move out until we hit:\n+           1. a non-lambda function or NSDMI,\n+           2. a lambda function capturing 'this', or\n+           3. a non-default capturing lambda function.  */\n+      for (tree tlambda = lambda; ;)\n+\t{\n+          lambda_stack = tree_cons (NULL_TREE,\n+                                    tlambda,\n+                                    lambda_stack);\n+\n+\t  if (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)\n+\t      && TREE_CODE (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)) == FIELD_DECL)\n+\t    {\n+\t      /* In an NSDMI, we don't have a function to look up the decl in,\n+\t\t but the fake 'this' pointer that we're using for parsing is\n+\t\t in scope_chain.  */\n+\t      init = scope_chain->x_current_class_ptr;\n+\t      gcc_checking_assert\n+\t\t(init && (TREE_TYPE (TREE_TYPE (init))\n+\t\t\t  == current_nonlambda_class_type ()));\n+\t      break;\n+\t    }\n+\n+\t  tree closure_decl = TYPE_NAME (LAMBDA_EXPR_CLOSURE (tlambda));\n+\t  tree containing_function = decl_function_context (closure_decl);\n+\n+\t  if (containing_function == NULL_TREE)\n+\t    /* We ran out of scopes; there's no 'this' to capture.  */\n+\t    break;\n+\n+\t  if (!LAMBDA_FUNCTION_P (containing_function))\n+\t    {\n+\t      /* We found a non-lambda function.  */\n+\t      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (containing_function))\n+\t\t/* First parameter is 'this'.  */\n+\t\tinit = DECL_ARGUMENTS (containing_function);\n+\t      break;\n+\t    }\n+\n+\t  tlambda\n+            = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (containing_function));\n+\n+          if (LAMBDA_EXPR_THIS_CAPTURE (tlambda))\n+\t    {\n+\t      /* An outer lambda has already captured 'this'.  */\n+\t      init = LAMBDA_EXPR_THIS_CAPTURE (tlambda);\n+\t      break;\n+\t    }\n+\n+\t  if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (tlambda) == CPLD_NONE)\n+\t    /* An outer lambda won't let us capture 'this'.  */\n+\t    break;\n+\t}\n+\n+      if (init)\n+\tthis_capture = add_default_capture (lambda_stack,\n+\t\t\t\t\t    /*id=*/this_identifier,\n+\t\t\t\t\t    init);\n+    }\n+\n+  if (!this_capture)\n+    {\n+      error (\"%<this%> was not captured for this lambda function\");\n+      result = error_mark_node;\n+    }\n+  else\n+    {\n+      /* To make sure that current_class_ref is for the lambda.  */\n+      gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref))\n+\t\t  == LAMBDA_EXPR_CLOSURE (lambda));\n+\n+      result = this_capture;\n+\n+      /* If 'this' is captured, each use of 'this' is transformed into an\n+\t access to the corresponding unnamed data member of the closure\n+\t type cast (_expr.cast_ 5.4) to the type of 'this'. [ The cast\n+\t ensures that the transformed expression is an rvalue. ] */\n+      result = rvalue (result);\n+    }\n+\n+  return result;\n+}\n+\n+/* We don't want to capture 'this' until we know we need it, i.e. after\n+   overload resolution has chosen a non-static member function.  At that\n+   point we call this function to turn a dummy object into a use of the\n+   'this' capture.  */\n+\n+tree\n+maybe_resolve_dummy (tree object)\n+{\n+  if (!is_dummy_object (object))\n+    return object;\n+\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (object));\n+  gcc_assert (!TYPE_PTR_P (type));\n+\n+  if (type != current_class_type\n+      && current_class_type\n+      && LAMBDA_TYPE_P (current_class_type)\n+      && DERIVED_FROM_P (type, current_nonlambda_class_type ()))\n+    {\n+      /* In a lambda, need to go through 'this' capture.  */\n+      tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n+      tree cap = lambda_expr_this_capture (lam);\n+      object = build_x_indirect_ref (EXPR_LOCATION (object), cap,\n+\t\t\t\t     RO_NULL, tf_warning_or_error);\n+    }\n+\n+  return object;\n+}\n+\n+/* Returns the method basetype of the innermost non-lambda function, or\n+   NULL_TREE if none.  */\n+\n+tree\n+nonlambda_method_basetype (void)\n+{\n+  tree fn, type;\n+  if (!current_class_ref)\n+    return NULL_TREE;\n+\n+  type = current_class_type;\n+  if (!LAMBDA_TYPE_P (type))\n+    return type;\n+\n+  /* Find the nearest enclosing non-lambda function.  */\n+  fn = TYPE_NAME (type);\n+  do\n+    fn = decl_function_context (fn);\n+  while (fn && LAMBDA_FUNCTION_P (fn));\n+\n+  if (!fn || !DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+    return NULL_TREE;\n+\n+  return TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n+}\n+\n+/* If the closure TYPE has a static op(), also add a conversion to function\n+   pointer.  */\n+\n+void\n+maybe_add_lambda_conv_op (tree type)\n+{\n+  bool nested = (current_function_decl != NULL_TREE);\n+  tree callop = lambda_function (type);\n+  tree rettype, name, fntype, fn, body, compound_stmt;\n+  tree thistype, stattype, statfn, convfn, call, arg;\n+  vec<tree, va_gc> *argvec;\n+\n+  if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)\n+    return;\n+\n+  if (processing_template_decl)\n+    return;\n+\n+  if (DECL_INITIAL (callop) == NULL_TREE)\n+    {\n+      /* If the op() wasn't instantiated due to errors, give up.  */\n+      gcc_assert (errorcount || sorrycount);\n+      return;\n+    }\n+\n+  stattype = build_function_type (TREE_TYPE (TREE_TYPE (callop)),\n+\t\t\t\t  FUNCTION_ARG_CHAIN (callop));\n+\n+  /* First build up the conversion op.  */\n+\n+  rettype = build_pointer_type (stattype);\n+  name = mangle_conv_op_name_for_type (rettype);\n+  thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+  fntype = build_method_type_directly (thistype, rettype, void_list_node);\n+  fn = convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n+  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n+\n+  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n+      && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n+    DECL_ALIGN (fn) = 2 * BITS_PER_UNIT;\n+\n+  SET_OVERLOADED_OPERATOR_CODE (fn, TYPE_EXPR);\n+  grokclassfn (type, fn, NO_SPECIAL);\n+  set_linkage_according_to_type (type, fn);\n+  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n+  DECL_IN_AGGR_P (fn) = 1;\n+  DECL_ARTIFICIAL (fn) = 1;\n+  DECL_NOT_REALLY_EXTERN (fn) = 1;\n+  DECL_DECLARED_INLINE_P (fn) = 1;\n+  DECL_ARGUMENTS (fn) = build_this_parm (fntype, TYPE_QUAL_CONST);\n+  if (nested)\n+    DECL_INTERFACE_KNOWN (fn) = 1;\n+\n+  add_method (type, fn, NULL_TREE);\n+\n+  /* Generic thunk code fails for varargs; we'll complain in mark_used if\n+     the conversion op is used.  */\n+  if (varargs_function_p (callop))\n+    {\n+      DECL_DELETED_FN (fn) = 1;\n+      return;\n+    }\n+\n+  /* Now build up the thunk to be returned.  */\n+\n+  name = get_identifier (\"_FUN\");\n+  fn = statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n+  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n+  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n+      && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n+    DECL_ALIGN (fn) = 2 * BITS_PER_UNIT;\n+  grokclassfn (type, fn, NO_SPECIAL);\n+  set_linkage_according_to_type (type, fn);\n+  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n+  DECL_IN_AGGR_P (fn) = 1;\n+  DECL_ARTIFICIAL (fn) = 1;\n+  DECL_NOT_REALLY_EXTERN (fn) = 1;\n+  DECL_DECLARED_INLINE_P (fn) = 1;\n+  DECL_STATIC_FUNCTION_P (fn) = 1;\n+  DECL_ARGUMENTS (fn) = copy_list (DECL_CHAIN (DECL_ARGUMENTS (callop)));\n+  for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n+    {\n+      /* Avoid duplicate -Wshadow warnings.  */\n+      DECL_NAME (arg) = NULL_TREE;\n+      DECL_CONTEXT (arg) = fn;\n+    }\n+  if (nested)\n+    DECL_INTERFACE_KNOWN (fn) = 1;\n+\n+  add_method (type, fn, NULL_TREE);\n+\n+  if (nested)\n+    push_function_context ();\n+  else\n+    /* Still increment function_depth so that we don't GC in the\n+       middle of an expression.  */\n+    ++function_depth;\n+\n+  /* Generate the body of the thunk.  */\n+\n+  start_preparsed_function (statfn, NULL_TREE,\n+\t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n+  if (DECL_ONE_ONLY (statfn))\n+    {\n+      /* Put the thunk in the same comdat group as the call op.  */\n+      symtab_add_to_same_comdat_group\n+\t ((symtab_node) cgraph_get_create_node (statfn),\n+          (symtab_node) cgraph_get_create_node (callop));\n+    }\n+  body = begin_function_body ();\n+  compound_stmt = begin_compound_stmt (0);\n+\n+  arg = build1 (NOP_EXPR, TREE_TYPE (DECL_ARGUMENTS (callop)),\n+\t\tnull_pointer_node);\n+  argvec = make_tree_vector ();\n+  argvec->quick_push (arg);\n+  for (arg = DECL_ARGUMENTS (statfn); arg; arg = DECL_CHAIN (arg))\n+    {\n+      mark_exp_read (arg);\n+      vec_safe_push (argvec, arg);\n+    }\n+  call = build_call_a (callop, argvec->length (), argvec->address ());\n+  CALL_FROM_THUNK_P (call) = 1;\n+  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n+    call = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);\n+  call = convert_from_reference (call);\n+  finish_return_stmt (call);\n+\n+  finish_compound_stmt (compound_stmt);\n+  finish_function_body (body);\n+\n+  expand_or_defer_fn (finish_function (2));\n+\n+  /* Generate the body of the conversion op.  */\n+\n+  start_preparsed_function (convfn, NULL_TREE,\n+\t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n+  body = begin_function_body ();\n+  compound_stmt = begin_compound_stmt (0);\n+\n+  /* decl_needed_p needs to see that it's used.  */\n+  TREE_USED (statfn) = 1;\n+  finish_return_stmt (decay_conversion (statfn, tf_warning_or_error));\n+\n+  finish_compound_stmt (compound_stmt);\n+  finish_function_body (body);\n+\n+  expand_or_defer_fn (finish_function (2));\n+\n+  if (nested)\n+    pop_function_context ();\n+  else\n+    --function_depth;\n+}\n+\n+/* Returns true iff VAL is a lambda-related declaration which should\n+   be ignored by unqualified lookup.  */\n+\n+bool\n+is_lambda_ignored_entity (tree val)\n+{\n+  /* In unevaluated context, look past normal capture proxies.  */\n+  if (cp_unevaluated_operand && is_normal_capture_proxy (val))\n+    return true;\n+\n+  /* Always ignore lambda fields, their names are only for debugging.  */\n+  if (TREE_CODE (val) == FIELD_DECL\n+      && CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (val)))\n+    return true;\n+\n+  /* None of the lookups that use qualify_lookup want the op() from the\n+     lambda; they want the one from the enclosing class.  */\n+  if (TREE_CODE (val) == FUNCTION_DECL && LAMBDA_FUNCTION_P (val))\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "79b29e4331620b3f5a646fc0f0f1d5e4ca845786", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 888, "changes": 888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a960e80813e7e08410f5fb94368c63f276039b42/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a960e80813e7e08410f5fb94368c63f276039b42", "patch": "@@ -8993,201 +8993,6 @@ require_potential_rvalue_constant_expression (tree t)\n   return potential_constant_expression_1 (t, true, tf_warning_or_error);\n }\n \f\n-/* Constructor for a lambda expression.  */\n-\n-tree\n-build_lambda_expr (void)\n-{\n-  tree lambda = make_node (LAMBDA_EXPR);\n-  LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) = CPLD_NONE;\n-  LAMBDA_EXPR_CAPTURE_LIST         (lambda) = NULL_TREE;\n-  LAMBDA_EXPR_THIS_CAPTURE         (lambda) = NULL_TREE;\n-  LAMBDA_EXPR_PENDING_PROXIES      (lambda) = NULL;\n-  LAMBDA_EXPR_RETURN_TYPE          (lambda) = NULL_TREE;\n-  LAMBDA_EXPR_MUTABLE_P            (lambda) = false;\n-  return lambda;\n-}\n-\n-/* Create the closure object for a LAMBDA_EXPR.  */\n-\n-tree\n-build_lambda_object (tree lambda_expr)\n-{\n-  /* Build aggregate constructor call.\n-     - cp_parser_braced_list\n-     - cp_parser_functional_cast  */\n-  vec<constructor_elt, va_gc> *elts = NULL;\n-  tree node, expr, type;\n-  location_t saved_loc;\n-\n-  if (processing_template_decl)\n-    return lambda_expr;\n-\n-  /* Make sure any error messages refer to the lambda-introducer.  */\n-  saved_loc = input_location;\n-  input_location = LAMBDA_EXPR_LOCATION (lambda_expr);\n-\n-  for (node = LAMBDA_EXPR_CAPTURE_LIST (lambda_expr);\n-       node;\n-       node = TREE_CHAIN (node))\n-    {\n-      tree field = TREE_PURPOSE (node);\n-      tree val = TREE_VALUE (node);\n-\n-      if (field == error_mark_node)\n-\t{\n-\t  expr = error_mark_node;\n-\t  goto out;\n-\t}\n-\n-      if (DECL_P (val))\n-\tmark_used (val);\n-\n-      /* Mere mortals can't copy arrays with aggregate initialization, so\n-\t do some magic to make it work here.  */\n-      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n-\tval = build_array_copy (val);\n-      else if (DECL_NORMAL_CAPTURE_P (field)\n-\t       && !DECL_VLA_CAPTURE_P (field)\n-\t       && TREE_CODE (TREE_TYPE (field)) != REFERENCE_TYPE)\n-\t{\n-\t  /* \"the entities that are captured by copy are used to\n-\t     direct-initialize each corresponding non-static data\n-\t     member of the resulting closure object.\"\n-\n-\t     There's normally no way to express direct-initialization\n-\t     from an element of a CONSTRUCTOR, so we build up a special\n-\t     TARGET_EXPR to bypass the usual copy-initialization.  */\n-\t  val = force_rvalue (val, tf_warning_or_error);\n-\t  if (TREE_CODE (val) == TARGET_EXPR)\n-\t    TARGET_EXPR_DIRECT_INIT_P (val) = true;\n-\t}\n-\n-      CONSTRUCTOR_APPEND_ELT (elts, DECL_NAME (field), val);\n-    }\n-\n-  expr = build_constructor (init_list_type_node, elts);\n-  CONSTRUCTOR_IS_DIRECT_INIT (expr) = 1;\n-\n-  /* N2927: \"[The closure] class type is not an aggregate.\"\n-     But we briefly treat it as an aggregate to make this simpler.  */\n-  type = LAMBDA_EXPR_CLOSURE (lambda_expr);\n-  CLASSTYPE_NON_AGGREGATE (type) = 0;\n-  expr = finish_compound_literal (type, expr, tf_warning_or_error);\n-  CLASSTYPE_NON_AGGREGATE (type) = 1;\n-\n- out:\n-  input_location = saved_loc;\n-  return expr;\n-}\n-\n-/* Return an initialized RECORD_TYPE for LAMBDA.\n-   LAMBDA must have its explicit captures already.  */\n-\n-tree\n-begin_lambda_type (tree lambda)\n-{\n-  tree type;\n-\n-  {\n-    /* Unique name.  This is just like an unnamed class, but we cannot use\n-       make_anon_name because of certain checks against TYPE_ANONYMOUS_P.  */\n-    tree name;\n-    name = make_lambda_name ();\n-\n-    /* Create the new RECORD_TYPE for this lambda.  */\n-    type = xref_tag (/*tag_code=*/record_type,\n-                     name,\n-                     /*scope=*/ts_lambda,\n-                     /*template_header_p=*/false);\n-  }\n-\n-  /* Designate it as a struct so that we can use aggregate initialization.  */\n-  CLASSTYPE_DECLARED_CLASS (type) = false;\n-\n-  /* Cross-reference the expression and the type.  */\n-  LAMBDA_EXPR_CLOSURE (lambda) = type;\n-  CLASSTYPE_LAMBDA_EXPR (type) = lambda;\n-\n-  /* Clear base types.  */\n-  xref_basetypes (type, /*bases=*/NULL_TREE);\n-\n-  /* Start the class.  */\n-  type = begin_class_definition (type);\n-  if (type == error_mark_node)\n-    return error_mark_node;\n-\n-  return type;\n-}\n-\n-/* Returns the type to use for the return type of the operator() of a\n-   closure class.  */\n-\n-tree\n-lambda_return_type (tree expr)\n-{\n-  if (expr == NULL_TREE)\n-    return void_type_node;\n-  if (type_unknown_p (expr)\n-      || BRACE_ENCLOSED_INITIALIZER_P (expr))\n-    {\n-      cxx_incomplete_type_error (expr, TREE_TYPE (expr));\n-      return void_type_node;\n-    }\n-  gcc_checking_assert (!type_dependent_expression_p (expr));\n-  return cv_unqualified (type_decays_to (unlowered_expr_type (expr)));\n-}\n-\n-/* Given a LAMBDA_EXPR or closure type LAMBDA, return the op() of the\n-   closure type.  */\n-\n-tree\n-lambda_function (tree lambda)\n-{\n-  tree type;\n-  if (TREE_CODE (lambda) == LAMBDA_EXPR)\n-    type = LAMBDA_EXPR_CLOSURE (lambda);\n-  else\n-    type = lambda;\n-  gcc_assert (LAMBDA_TYPE_P (type));\n-  /* Don't let debug_tree cause instantiation.  */\n-  if (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n-      && !COMPLETE_OR_OPEN_TYPE_P (type))\n-    return NULL_TREE;\n-  lambda = lookup_member (type, ansi_opname (CALL_EXPR),\n-\t\t\t  /*protect=*/0, /*want_type=*/false,\n-\t\t\t  tf_warning_or_error);\n-  if (lambda)\n-    lambda = BASELINK_FUNCTIONS (lambda);\n-  return lambda;\n-}\n-\n-/* Returns the type to use for the FIELD_DECL corresponding to the\n-   capture of EXPR.\n-   The caller should add REFERENCE_TYPE for capture by reference.  */\n-\n-tree\n-lambda_capture_field_type (tree expr, bool explicit_init_p)\n-{\n-  tree type;\n-  if (explicit_init_p)\n-    {\n-      type = make_auto ();\n-      type = do_auto_deduction (type, expr, type);\n-    }\n-  else\n-    type = non_reference (unlowered_expr_type (expr));\n-  if (!type || WILDCARD_TYPE_P (type) || type_uses_auto (type))\n-    {\n-      type = cxx_make_type (DECLTYPE_TYPE);\n-      DECLTYPE_TYPE_EXPR (type) = expr;\n-      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;\n-      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;\n-      SET_TYPE_STRUCTURAL_EQUALITY (type);\n-    }\n-  return type;\n-}\n-\n /* Insert the deduced return type for an auto function.  */\n \n void\n@@ -9287,697 +9092,4 @@ capture_decltype (tree decl)\n   return type;\n }\n \n-/* Returns true iff DECL is a lambda capture proxy variable created by\n-   build_capture_proxy.  */\n-\n-bool\n-is_capture_proxy (tree decl)\n-{\n-  return (VAR_P (decl)\n-\t  && DECL_HAS_VALUE_EXPR_P (decl)\n-\t  && !DECL_ANON_UNION_VAR_P (decl)\n-\t  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));\n-}\n-\n-/* Returns true iff DECL is a capture proxy for a normal capture\n-   (i.e. without explicit initializer).  */\n-\n-bool\n-is_normal_capture_proxy (tree decl)\n-{\n-  if (!is_capture_proxy (decl))\n-    /* It's not a capture proxy.  */\n-    return false;\n-\n-  /* It is a capture proxy, is it a normal capture?  */\n-  tree val = DECL_VALUE_EXPR (decl);\n-  if (val == error_mark_node)\n-    return true;\n-\n-  gcc_assert (TREE_CODE (val) == COMPONENT_REF);\n-  val = TREE_OPERAND (val, 1);\n-  return DECL_NORMAL_CAPTURE_P (val);\n-}\n-\n-/* VAR is a capture proxy created by build_capture_proxy; add it to the\n-   current function, which is the operator() for the appropriate lambda.  */\n-\n-void\n-insert_capture_proxy (tree var)\n-{\n-  cp_binding_level *b;\n-  tree stmt_list;\n-\n-  /* Put the capture proxy in the extra body block so that it won't clash\n-     with a later local variable.  */\n-  b = current_binding_level;\n-  for (;;)\n-    {\n-      cp_binding_level *n = b->level_chain;\n-      if (n->kind == sk_function_parms)\n-\tbreak;\n-      b = n;\n-    }\n-  pushdecl_with_scope (var, b, false);\n-\n-  /* And put a DECL_EXPR in the STATEMENT_LIST for the same block.  */\n-  var = build_stmt (DECL_SOURCE_LOCATION (var), DECL_EXPR, var);\n-  stmt_list = (*stmt_list_stack)[1];\n-  gcc_assert (stmt_list);\n-  append_to_statement_list_force (var, &stmt_list);\n-}\n-\n-/* We've just finished processing a lambda; if the containing scope is also\n-   a lambda, insert any capture proxies that were created while processing\n-   the nested lambda.  */\n-\n-void\n-insert_pending_capture_proxies (void)\n-{\n-  tree lam;\n-  vec<tree, va_gc> *proxies;\n-  unsigned i;\n-\n-  if (!current_function_decl || !LAMBDA_FUNCTION_P (current_function_decl))\n-    return;\n-\n-  lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n-  proxies = LAMBDA_EXPR_PENDING_PROXIES (lam);\n-  for (i = 0; i < vec_safe_length (proxies); ++i)\n-    {\n-      tree var = (*proxies)[i];\n-      insert_capture_proxy (var);\n-    }\n-  release_tree_vector (LAMBDA_EXPR_PENDING_PROXIES (lam));\n-  LAMBDA_EXPR_PENDING_PROXIES (lam) = NULL;\n-}\n-\n-/* Given REF, a COMPONENT_REF designating a field in the lambda closure,\n-   return the type we want the proxy to have: the type of the field itself,\n-   with added const-qualification if the lambda isn't mutable and the\n-   capture is by value.  */\n-\n-tree\n-lambda_proxy_type (tree ref)\n-{\n-  tree type;\n-  if (REFERENCE_REF_P (ref))\n-    ref = TREE_OPERAND (ref, 0);\n-  type = TREE_TYPE (ref);\n-  if (type && !WILDCARD_TYPE_P (non_reference (type)))\n-    return type;\n-  type = cxx_make_type (DECLTYPE_TYPE);\n-  DECLTYPE_TYPE_EXPR (type) = ref;\n-  DECLTYPE_FOR_LAMBDA_PROXY (type) = true;\n-  SET_TYPE_STRUCTURAL_EQUALITY (type);\n-  return type;\n-}\n-\n-/* MEMBER is a capture field in a lambda closure class.  Now that we're\n-   inside the operator(), build a placeholder var for future lookups and\n-   debugging.  */\n-\n-tree\n-build_capture_proxy (tree member)\n-{\n-  tree var, object, fn, closure, name, lam, type;\n-\n-  closure = DECL_CONTEXT (member);\n-  fn = lambda_function (closure);\n-  lam = CLASSTYPE_LAMBDA_EXPR (closure);\n-\n-  /* The proxy variable forwards to the capture field.  */\n-  object = build_fold_indirect_ref (DECL_ARGUMENTS (fn));\n-  object = finish_non_static_data_member (member, object, NULL_TREE);\n-  if (REFERENCE_REF_P (object))\n-    object = TREE_OPERAND (object, 0);\n-\n-  /* Remove the __ inserted by add_capture.  */\n-  if (DECL_NORMAL_CAPTURE_P (member))\n-    name = get_identifier (IDENTIFIER_POINTER (DECL_NAME (member)) + 2);\n-  else\n-    name = DECL_NAME (member);\n-\n-  type = lambda_proxy_type (object);\n-\n-  if (DECL_VLA_CAPTURE_P (member))\n-    {\n-      /* Rebuild the VLA type from the pointer and maxindex.  */\n-      tree field = next_initializable_field (TYPE_FIELDS (type));\n-      tree ptr = build_simple_component_ref (object, field);\n-      field = next_initializable_field (DECL_CHAIN (field));\n-      tree max = build_simple_component_ref (object, field);\n-      type = build_array_type (TREE_TYPE (TREE_TYPE (ptr)),\n-\t\t\t       build_index_type (max));\n-      type = build_reference_type (type);\n-      REFERENCE_VLA_OK (type) = true;\n-      object = convert (type, ptr);\n-    }\n-\n-  var = build_decl (input_location, VAR_DECL, name, type);\n-  SET_DECL_VALUE_EXPR (var, object);\n-  DECL_HAS_VALUE_EXPR_P (var) = 1;\n-  DECL_ARTIFICIAL (var) = 1;\n-  TREE_USED (var) = 1;\n-  DECL_CONTEXT (var) = fn;\n-\n-  if (name == this_identifier)\n-    {\n-      gcc_assert (LAMBDA_EXPR_THIS_CAPTURE (lam) == member);\n-      LAMBDA_EXPR_THIS_CAPTURE (lam) = var;\n-    }\n-\n-  if (fn == current_function_decl)\n-    insert_capture_proxy (var);\n-  else\n-    vec_safe_push (LAMBDA_EXPR_PENDING_PROXIES (lam), var);\n-\n-  return var;\n-}\n-\n-/* Return a struct containing a pointer and a length for lambda capture of\n-   an array of runtime length.  */\n-\n-static tree\n-vla_capture_type (tree array_type)\n-{\n-  static tree ptr_id, max_id;\n-  tree type = xref_tag (record_type, make_anon_name (), ts_current, false);\n-  xref_basetypes (type, NULL_TREE);\n-  type = begin_class_definition (type);\n-  if (!ptr_id)\n-    {\n-      ptr_id = get_identifier (\"ptr\");\n-      max_id = get_identifier (\"max\");\n-    }\n-  tree ptrtype = build_pointer_type (TREE_TYPE (array_type));\n-  tree field = build_decl (input_location, FIELD_DECL, ptr_id, ptrtype);\n-  finish_member_declaration (field);\n-  field = build_decl (input_location, FIELD_DECL, max_id, sizetype);\n-  finish_member_declaration (field);\n-  return finish_struct (type, NULL_TREE);\n-}\n-\n-/* From an ID and INITIALIZER, create a capture (by reference if\n-   BY_REFERENCE_P is true), add it to the capture-list for LAMBDA,\n-   and return it.  */\n-\n-tree\n-add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n-\t     bool explicit_init_p)\n-{\n-  char *buf;\n-  tree type, member, name;\n-  bool vla = false;\n-\n-  if (TREE_CODE (initializer) == TREE_LIST)\n-    initializer = build_x_compound_expr_from_list (initializer, ELK_INIT,\n-\t\t\t\t\t\t   tf_warning_or_error);\n-  type = lambda_capture_field_type (initializer, explicit_init_p);\n-  if (array_of_runtime_bound_p (type))\n-    {\n-      vla = true;\n-      if (!by_reference_p)\n-\terror (\"array of runtime bound cannot be captured by copy, \"\n-\t       \"only by reference\");\n-\n-      /* For a VLA, we capture the address of the first element and the\n-\t maximum index, and then reconstruct the VLA for the proxy.  */\n-      tree elt = cp_build_array_ref (input_location, initializer,\n-\t\t\t\t     integer_zero_node, tf_warning_or_error);\n-      initializer = build_constructor_va (init_list_type_node, 2,\n-\t\t\t\t\t  NULL_TREE, build_address (elt),\n-\t\t\t\t\t  NULL_TREE, array_type_nelts (type));\n-      type = vla_capture_type (type);\n-    }\n-  else if (variably_modified_type_p (type, NULL_TREE))\n-    {\n-      error (\"capture of variable-size type %qT that is not a C++1y array \"\n-\t     \"of runtime bound\", type);\n-      if (TREE_CODE (type) == ARRAY_TYPE\n-\t  && variably_modified_type_p (TREE_TYPE (type), NULL_TREE))\n-\tinform (input_location, \"because the array element type %qT has \"\n-\t\t\"variable size\", TREE_TYPE (type));\n-      type = error_mark_node;\n-    }\n-  else if (by_reference_p)\n-    {\n-      type = build_reference_type (type);\n-      if (!real_lvalue_p (initializer))\n-\terror (\"cannot capture %qE by reference\", initializer);\n-    }\n-  else\n-    /* Capture by copy requires a complete type.  */\n-    type = complete_type (type);\n-\n-  /* Add __ to the beginning of the field name so that user code\n-     won't find the field with name lookup.  We can't just leave the name\n-     unset because template instantiation uses the name to find\n-     instantiated fields.  */\n-  if (!explicit_init_p)\n-    {\n-      buf = (char *) alloca (IDENTIFIER_LENGTH (id) + 3);\n-      buf[1] = buf[0] = '_';\n-      memcpy (buf + 2, IDENTIFIER_POINTER (id),\n-\t      IDENTIFIER_LENGTH (id) + 1);\n-      name = get_identifier (buf);\n-    }\n-  else\n-    /* But captures with explicit initializers are named.  */\n-    name = id;\n-\n-  /* If TREE_TYPE isn't set, we're still in the introducer, so check\n-     for duplicates.  */\n-  if (!LAMBDA_EXPR_CLOSURE (lambda))\n-    {\n-      if (IDENTIFIER_MARKED (name))\n-\t{\n-\t  pedwarn (input_location, 0,\n-\t\t   \"already captured %qD in lambda expression\", id);\n-\t  return NULL_TREE;\n-\t}\n-      IDENTIFIER_MARKED (name) = true;\n-    }\n-\n-  /* Make member variable.  */\n-  member = build_lang_decl (FIELD_DECL, name, type);\n-  DECL_VLA_CAPTURE_P (member) = vla;\n-\n-  if (!explicit_init_p)\n-    /* Normal captures are invisible to name lookup but uses are replaced\n-       with references to the capture field; we implement this by only\n-       really making them invisible in unevaluated context; see\n-       qualify_lookup.  For now, let's make explicitly initialized captures\n-       always visible.  */\n-    DECL_NORMAL_CAPTURE_P (member) = true;\n-\n-  if (id == this_identifier)\n-    LAMBDA_EXPR_THIS_CAPTURE (lambda) = member;\n-\n-  /* Add it to the appropriate closure class if we've started it.  */\n-  if (current_class_type\n-      && current_class_type == LAMBDA_EXPR_CLOSURE (lambda))\n-    finish_member_declaration (member);\n-\n-  LAMBDA_EXPR_CAPTURE_LIST (lambda)\n-    = tree_cons (member, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n-\n-  if (LAMBDA_EXPR_CLOSURE (lambda))\n-    return build_capture_proxy (member);\n-  /* For explicit captures we haven't started the function yet, so we wait\n-     and build the proxy from cp_parser_lambda_body.  */\n-  return NULL_TREE;\n-}\n-\n-/* Register all the capture members on the list CAPTURES, which is the\n-   LAMBDA_EXPR_CAPTURE_LIST for the lambda after the introducer.  */\n-\n-void\n-register_capture_members (tree captures)\n-{\n-  if (captures == NULL_TREE)\n-    return;\n-\n-  register_capture_members (TREE_CHAIN (captures));\n-  /* We set this in add_capture to avoid duplicates.  */\n-  IDENTIFIER_MARKED (DECL_NAME (TREE_PURPOSE (captures))) = false;\n-  finish_member_declaration (TREE_PURPOSE (captures));\n-}\n-\n-/* Similar to add_capture, except this works on a stack of nested lambdas.\n-   BY_REFERENCE_P in this case is derived from the default capture mode.\n-   Returns the capture for the lambda at the bottom of the stack.  */\n-\n-tree\n-add_default_capture (tree lambda_stack, tree id, tree initializer)\n-{\n-  bool this_capture_p = (id == this_identifier);\n-\n-  tree var = NULL_TREE;\n-\n-  tree saved_class_type = current_class_type;\n-\n-  tree node;\n-\n-  for (node = lambda_stack;\n-       node;\n-       node = TREE_CHAIN (node))\n-    {\n-      tree lambda = TREE_VALUE (node);\n-\n-      current_class_type = LAMBDA_EXPR_CLOSURE (lambda);\n-      var = add_capture (lambda,\n-                            id,\n-                            initializer,\n-                            /*by_reference_p=*/\n-\t\t\t    (!this_capture_p\n-\t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n-\t\t\t\t == CPLD_REFERENCE)),\n-\t\t\t    /*explicit_init_p=*/false);\n-      initializer = convert_from_reference (var);\n-    }\n-\n-  current_class_type = saved_class_type;\n-\n-  return var;\n-}\n-\n-/* Return the capture pertaining to a use of 'this' in LAMBDA, in the form of an\n-   INDIRECT_REF, possibly adding it through default capturing.  */\n-\n-tree\n-lambda_expr_this_capture (tree lambda)\n-{\n-  tree result;\n-\n-  tree this_capture = LAMBDA_EXPR_THIS_CAPTURE (lambda);\n-\n-  /* In unevaluated context this isn't an odr-use, so just return the\n-     nearest 'this'.  */\n-  if (cp_unevaluated_operand)\n-    return lookup_name (this_identifier);\n-\n-  /* Try to default capture 'this' if we can.  */\n-  if (!this_capture\n-      && LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) != CPLD_NONE)\n-    {\n-      tree lambda_stack = NULL_TREE;\n-      tree init = NULL_TREE;\n-\n-      /* If we are in a lambda function, we can move out until we hit:\n-           1. a non-lambda function or NSDMI,\n-           2. a lambda function capturing 'this', or\n-           3. a non-default capturing lambda function.  */\n-      for (tree tlambda = lambda; ;)\n-\t{\n-          lambda_stack = tree_cons (NULL_TREE,\n-                                    tlambda,\n-                                    lambda_stack);\n-\n-\t  if (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)\n-\t      && TREE_CODE (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)) == FIELD_DECL)\n-\t    {\n-\t      /* In an NSDMI, we don't have a function to look up the decl in,\n-\t\t but the fake 'this' pointer that we're using for parsing is\n-\t\t in scope_chain.  */\n-\t      init = scope_chain->x_current_class_ptr;\n-\t      gcc_checking_assert\n-\t\t(init && (TREE_TYPE (TREE_TYPE (init))\n-\t\t\t  == current_nonlambda_class_type ()));\n-\t      break;\n-\t    }\n-\n-\t  tree closure_decl = TYPE_NAME (LAMBDA_EXPR_CLOSURE (tlambda));\n-\t  tree containing_function = decl_function_context (closure_decl);\n-\n-\t  if (containing_function == NULL_TREE)\n-\t    /* We ran out of scopes; there's no 'this' to capture.  */\n-\t    break;\n-\n-\t  if (!LAMBDA_FUNCTION_P (containing_function))\n-\t    {\n-\t      /* We found a non-lambda function.  */\n-\t      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (containing_function))\n-\t\t/* First parameter is 'this'.  */\n-\t\tinit = DECL_ARGUMENTS (containing_function);\n-\t      break;\n-\t    }\n-\n-\t  tlambda\n-            = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (containing_function));\n-\n-          if (LAMBDA_EXPR_THIS_CAPTURE (tlambda))\n-\t    {\n-\t      /* An outer lambda has already captured 'this'.  */\n-\t      init = LAMBDA_EXPR_THIS_CAPTURE (tlambda);\n-\t      break;\n-\t    }\n-\n-\t  if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (tlambda) == CPLD_NONE)\n-\t    /* An outer lambda won't let us capture 'this'.  */\n-\t    break;\n-\t}\n-\n-      if (init)\n-\tthis_capture = add_default_capture (lambda_stack,\n-\t\t\t\t\t    /*id=*/this_identifier,\n-\t\t\t\t\t    init);\n-    }\n-\n-  if (!this_capture)\n-    {\n-      error (\"%<this%> was not captured for this lambda function\");\n-      result = error_mark_node;\n-    }\n-  else\n-    {\n-      /* To make sure that current_class_ref is for the lambda.  */\n-      gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (current_class_ref))\n-\t\t  == LAMBDA_EXPR_CLOSURE (lambda));\n-\n-      result = this_capture;\n-\n-      /* If 'this' is captured, each use of 'this' is transformed into an\n-\t access to the corresponding unnamed data member of the closure\n-\t type cast (_expr.cast_ 5.4) to the type of 'this'. [ The cast\n-\t ensures that the transformed expression is an rvalue. ] */\n-      result = rvalue (result);\n-    }\n-\n-  return result;\n-}\n-\n-/* We don't want to capture 'this' until we know we need it, i.e. after\n-   overload resolution has chosen a non-static member function.  At that\n-   point we call this function to turn a dummy object into a use of the\n-   'this' capture.  */\n-\n-tree\n-maybe_resolve_dummy (tree object)\n-{\n-  if (!is_dummy_object (object))\n-    return object;\n-\n-  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (object));\n-  gcc_assert (!TYPE_PTR_P (type));\n-\n-  if (type != current_class_type\n-      && current_class_type\n-      && LAMBDA_TYPE_P (current_class_type)\n-      && DERIVED_FROM_P (type, current_nonlambda_class_type ()))\n-    {\n-      /* In a lambda, need to go through 'this' capture.  */\n-      tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n-      tree cap = lambda_expr_this_capture (lam);\n-      object = build_x_indirect_ref (EXPR_LOCATION (object), cap,\n-\t\t\t\t     RO_NULL, tf_warning_or_error);\n-    }\n-\n-  return object;\n-}\n-\n-/* Returns the method basetype of the innermost non-lambda function, or\n-   NULL_TREE if none.  */\n-\n-tree\n-nonlambda_method_basetype (void)\n-{\n-  tree fn, type;\n-  if (!current_class_ref)\n-    return NULL_TREE;\n-\n-  type = current_class_type;\n-  if (!LAMBDA_TYPE_P (type))\n-    return type;\n-\n-  /* Find the nearest enclosing non-lambda function.  */\n-  fn = TYPE_NAME (type);\n-  do\n-    fn = decl_function_context (fn);\n-  while (fn && LAMBDA_FUNCTION_P (fn));\n-\n-  if (!fn || !DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n-    return NULL_TREE;\n-\n-  return TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n-}\n-\n-/* If the closure TYPE has a static op(), also add a conversion to function\n-   pointer.  */\n-\n-void\n-maybe_add_lambda_conv_op (tree type)\n-{\n-  bool nested = (current_function_decl != NULL_TREE);\n-  tree callop = lambda_function (type);\n-  tree rettype, name, fntype, fn, body, compound_stmt;\n-  tree thistype, stattype, statfn, convfn, call, arg;\n-  vec<tree, va_gc> *argvec;\n-\n-  if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)\n-    return;\n-\n-  if (processing_template_decl)\n-    return;\n-\n-  if (DECL_INITIAL (callop) == NULL_TREE)\n-    {\n-      /* If the op() wasn't instantiated due to errors, give up.  */\n-      gcc_assert (errorcount || sorrycount);\n-      return;\n-    }\n-\n-  stattype = build_function_type (TREE_TYPE (TREE_TYPE (callop)),\n-\t\t\t\t  FUNCTION_ARG_CHAIN (callop));\n-\n-  /* First build up the conversion op.  */\n-\n-  rettype = build_pointer_type (stattype);\n-  name = mangle_conv_op_name_for_type (rettype);\n-  thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n-  fntype = build_method_type_directly (thistype, rettype, void_list_node);\n-  fn = convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n-  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n-\n-  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n-      && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n-    DECL_ALIGN (fn) = 2 * BITS_PER_UNIT;\n-\n-  SET_OVERLOADED_OPERATOR_CODE (fn, TYPE_EXPR);\n-  grokclassfn (type, fn, NO_SPECIAL);\n-  set_linkage_according_to_type (type, fn);\n-  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n-  DECL_IN_AGGR_P (fn) = 1;\n-  DECL_ARTIFICIAL (fn) = 1;\n-  DECL_NOT_REALLY_EXTERN (fn) = 1;\n-  DECL_DECLARED_INLINE_P (fn) = 1;\n-  DECL_ARGUMENTS (fn) = build_this_parm (fntype, TYPE_QUAL_CONST);\n-  if (nested)\n-    DECL_INTERFACE_KNOWN (fn) = 1;\n-\n-  add_method (type, fn, NULL_TREE);\n-\n-  /* Generic thunk code fails for varargs; we'll complain in mark_used if\n-     the conversion op is used.  */\n-  if (varargs_function_p (callop))\n-    {\n-      DECL_DELETED_FN (fn) = 1;\n-      return;\n-    }\n-\n-  /* Now build up the thunk to be returned.  */\n-\n-  name = get_identifier (\"_FUN\");\n-  fn = statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n-  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n-  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n-      && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n-    DECL_ALIGN (fn) = 2 * BITS_PER_UNIT;\n-  grokclassfn (type, fn, NO_SPECIAL);\n-  set_linkage_according_to_type (type, fn);\n-  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n-  DECL_IN_AGGR_P (fn) = 1;\n-  DECL_ARTIFICIAL (fn) = 1;\n-  DECL_NOT_REALLY_EXTERN (fn) = 1;\n-  DECL_DECLARED_INLINE_P (fn) = 1;\n-  DECL_STATIC_FUNCTION_P (fn) = 1;\n-  DECL_ARGUMENTS (fn) = copy_list (DECL_CHAIN (DECL_ARGUMENTS (callop)));\n-  for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n-    {\n-      /* Avoid duplicate -Wshadow warnings.  */\n-      DECL_NAME (arg) = NULL_TREE;\n-      DECL_CONTEXT (arg) = fn;\n-    }\n-  if (nested)\n-    DECL_INTERFACE_KNOWN (fn) = 1;\n-\n-  add_method (type, fn, NULL_TREE);\n-\n-  if (nested)\n-    push_function_context ();\n-  else\n-    /* Still increment function_depth so that we don't GC in the\n-       middle of an expression.  */\n-    ++function_depth;\n-\n-  /* Generate the body of the thunk.  */\n-\n-  start_preparsed_function (statfn, NULL_TREE,\n-\t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n-  if (DECL_ONE_ONLY (statfn))\n-    {\n-      /* Put the thunk in the same comdat group as the call op.  */\n-      symtab_add_to_same_comdat_group\n-\t ((symtab_node) cgraph_get_create_node (statfn),\n-          (symtab_node) cgraph_get_create_node (callop));\n-    }\n-  body = begin_function_body ();\n-  compound_stmt = begin_compound_stmt (0);\n-\n-  arg = build1 (NOP_EXPR, TREE_TYPE (DECL_ARGUMENTS (callop)),\n-\t\tnull_pointer_node);\n-  argvec = make_tree_vector ();\n-  argvec->quick_push (arg);\n-  for (arg = DECL_ARGUMENTS (statfn); arg; arg = DECL_CHAIN (arg))\n-    {\n-      mark_exp_read (arg);\n-      vec_safe_push (argvec, arg);\n-    }\n-  call = build_call_a (callop, argvec->length (), argvec->address ());\n-  CALL_FROM_THUNK_P (call) = 1;\n-  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n-    call = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);\n-  call = convert_from_reference (call);\n-  finish_return_stmt (call);\n-\n-  finish_compound_stmt (compound_stmt);\n-  finish_function_body (body);\n-\n-  expand_or_defer_fn (finish_function (2));\n-\n-  /* Generate the body of the conversion op.  */\n-\n-  start_preparsed_function (convfn, NULL_TREE,\n-\t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n-  body = begin_function_body ();\n-  compound_stmt = begin_compound_stmt (0);\n-\n-  /* decl_needed_p needs to see that it's used.  */\n-  TREE_USED (statfn) = 1;\n-  finish_return_stmt (decay_conversion (statfn, tf_warning_or_error));\n-\n-  finish_compound_stmt (compound_stmt);\n-  finish_function_body (body);\n-\n-  expand_or_defer_fn (finish_function (2));\n-\n-  if (nested)\n-    pop_function_context ();\n-  else\n-    --function_depth;\n-}\n-\n-/* Returns true iff VAL is a lambda-related declaration which should\n-   be ignored by unqualified lookup.  */\n-\n-bool\n-is_lambda_ignored_entity (tree val)\n-{\n-  /* In unevaluated context, look past normal capture proxies.  */\n-  if (cp_unevaluated_operand && is_normal_capture_proxy (val))\n-    return true;\n-\n-  /* Always ignore lambda fields, their names are only for debugging.  */\n-  if (TREE_CODE (val) == FIELD_DECL\n-      && CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (val)))\n-    return true;\n-\n-  /* None of the lookups that use qualify_lookup want the op() from the\n-     lambda; they want the one from the enclosing class.  */\n-  if (TREE_CODE (val) == FUNCTION_DECL && LAMBDA_FUNCTION_P (val))\n-    return true;\n-\n-  return false;\n-}\n-\n #include \"gt-cp-semantics.h\""}]}