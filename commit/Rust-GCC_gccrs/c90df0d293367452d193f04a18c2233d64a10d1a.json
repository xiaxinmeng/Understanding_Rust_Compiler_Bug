{"sha": "c90df0d293367452d193f04a18c2233d64a10d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkwZGYwZDI5MzM2NzQ1MmQxOTNmMDRhMThjMjIzM2Q2NGExMGQxYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-22T18:49:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-22T18:49:52Z"}, "message": "debug/xcoff,cmd: add XCOFF support\n    \n    Reviewed-on: https://go-review.googlesource.com/64592\n\nFrom-SVN: r253105", "tree": {"sha": "7f9287f57a409e317a402d63c9ead0cd7ce42fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f9287f57a409e317a402d63c9ead0cd7ce42fec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c90df0d293367452d193f04a18c2233d64a10d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90df0d293367452d193f04a18c2233d64a10d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c90df0d293367452d193f04a18c2233d64a10d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90df0d293367452d193f04a18c2233d64a10d1a/comments", "author": null, "committer": null, "parents": [{"sha": "f25afa93f72f44feb104ba340fe882e9b67da7d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25afa93f72f44feb104ba340fe882e9b67da7d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f25afa93f72f44feb104ba340fe882e9b67da7d7"}], "stats": {"total": 1135, "additions": 1113, "deletions": 22}, "files": [{"sha": "dcab046c82ea45b674de8c2c71e0ed625eccf52e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -1,4 +1,4 @@\n-1fcb9bb3cefb97cfab1e623826a1cc3f6aadd5f7\n+e0c1f0b645b12a544b484c0f477f8fb6f5980550\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "bd0bbddd4ed3eb0e90a5f1d2c1246fc8a4774a95", "filename": "libgo/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -217,7 +217,8 @@ toolexeclibgodebug_DATA = \\\n \tdebug/gosym.gox \\\n \tdebug/macho.gox \\\n \tdebug/pe.gox \\\n-\tdebug/plan9obj.gox\n+\tdebug/plan9obj.gox \\\n+\tdebug/xcoff.gox\n \n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n \n@@ -722,6 +723,7 @@ PACKAGES = \\\n \tdebug/macho \\\n \tdebug/pe \\\n \tdebug/plan9obj \\\n+\tdebug/xcoff \\\n \tencoding \\\n \tencoding/ascii85 \\\n \tencoding/asn1 \\\n@@ -1293,6 +1295,7 @@ TEST_PACKAGES = \\\n \tdebug/macho/check \\\n \tdebug/pe/check \\\n \tdebug/plan9obj/check \\\n+\tdebug/xcoff/check \\\n \tencoding/ascii85/check \\\n \tencoding/asn1/check \\\n \tencoding/base32/check \\"}, {"sha": "064df58f00eab2922449f605018abc8138da00d9", "filename": "libgo/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -612,7 +612,8 @@ toolexeclibgodebug_DATA = \\\n \tdebug/gosym.gox \\\n \tdebug/macho.gox \\\n \tdebug/pe.gox \\\n-\tdebug/plan9obj.gox\n+\tdebug/plan9obj.gox \\\n+\tdebug/xcoff.gox\n \n toolexeclibgoencodingdir = $(toolexeclibgodir)/encoding\n toolexeclibgoencoding_DATA = \\\n@@ -873,6 +874,7 @@ PACKAGES = \\\n \tdebug/macho \\\n \tdebug/pe \\\n \tdebug/plan9obj \\\n+\tdebug/xcoff \\\n \tencoding \\\n \tencoding/ascii85 \\\n \tencoding/asn1 \\\n@@ -1298,6 +1300,7 @@ TEST_PACKAGES = \\\n \tdebug/macho/check \\\n \tdebug/pe/check \\\n \tdebug/plan9obj/check \\\n+\tdebug/xcoff/check \\\n \tencoding/ascii85/check \\\n \tencoding/asn1/check \\\n \tencoding/base32/check \\"}, {"sha": "5453d1c94d0cb01e2fa23f2c220567fa0acd44ff", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n+\t\"debug/xcoff\"\n \t\"encoding/binary\"\n \t\"errors\"\n \t\"flag\"\n@@ -1289,6 +1290,10 @@ func (p *Package) gccMachine() []string {\n \t\treturn []string{\"-mabi=64\"}\n \tcase \"mips\", \"mipsle\":\n \t\treturn []string{\"-mabi=32\"}\n+\tcase \"ppc64\":\n+\t\tif goos == \"aix\" {\n+\t\t\treturn []string{\"-maix64\"}\n+\t\t}\n \t}\n \treturn nil\n }\n@@ -1616,7 +1621,79 @@ func (p *Package) gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int6\n \t\treturn d, ints, floats, strs\n \t}\n \n-\tfatalf(\"cannot parse gcc output %s as ELF, Mach-O, PE object\", gccTmp())\n+\tif f, err := xcoff.Open(gccTmp()); err == nil {\n+\t\tdefer f.Close()\n+\t\td, err := f.DWARF()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n+\t\t}\n+\t\tbo := binary.BigEndian\n+\t\tfor _, s := range f.Symbols {\n+\t\t\tswitch {\n+\t\t\tcase isDebugInts(s.Name):\n+\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\tints = make([]int64, len(data)/8)\n+\t\t\t\t\t\t\tfor i := range ints {\n+\t\t\t\t\t\t\t\tints[i] = int64(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isDebugFloats(s.Name):\n+\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\tfloats = make([]float64, len(data)/8)\n+\t\t\t\t\t\t\tfor i := range floats {\n+\t\t\t\t\t\t\t\tfloats[i] = math.Float64frombits(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tif n := indexOfDebugStr(s.Name); n != -1 {\n+\t\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\t\tstrdata[n] = string(data)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif n := indexOfDebugStrlen(s.Name); n != -1 {\n+\t\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\t\tstrlen := bo.Uint64(data[:8])\n+\t\t\t\t\t\t\t\tif strlen > (1<<(uint(p.IntSize*8)-1) - 1) { // greater than MaxInt?\n+\t\t\t\t\t\t\t\t\tfatalf(\"string literal too big\")\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tstrlens[n] = int(strlen)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tbuildStrings()\n+\n+\t\treturn d, ints, floats, strs\n+\t}\n+\n+\tfatalf(\"cannot parse gcc output %s as ELF, Mach-O, PE, XCOFF object\", gccTmp())\n \tpanic(\"not reached\")\n }\n "}, {"sha": "72dd884aedb46c5f0cd7bed4792ec241e542a53d", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n+\t\"debug/xcoff\"\n \t\"fmt\"\n \t\"go/ast\"\n \t\"go/printer\"\n@@ -324,7 +325,25 @@ func dynimport(obj string) {\n \t\treturn\n \t}\n \n-\tfatalf(\"cannot parse %s as ELF, Mach-O or PE\", obj)\n+\tif f, err := xcoff.Open(obj); err == nil {\n+\t\tsym, err := f.ImportedSymbols()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported symbols from XCOFF file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, s := range sym {\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s.Name, s.Name, s.Library)\n+\t\t}\n+\t\tlib, err := f.ImportedLibraries()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported libraries from XCOFF file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, l := range lib {\n+\t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic _ _ %q\\n\", l)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tfatalf(\"cannot parse %s as ELF, Mach-O, PE or XCOFF\", obj)\n }\n \n // Construct a gcc struct matching the gc argument frame."}, {"sha": "562730bb6929c485cb1a1f5a58ea8dd4210d0596", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"container/heap\"\n \t\"debug/elf\"\n+\t\"debug/xcoff\"\n \t\"errors\"\n \t\"flag\"\n \t\"fmt\"\n@@ -745,9 +746,13 @@ func (b *Builder) Init() {\n func readpkglist(shlibpath string) (pkgs []*load.Package) {\n \tvar stk load.ImportStack\n \tif cfg.BuildToolchainName == \"gccgo\" {\n-\t\tf, _ := elf.Open(shlibpath)\n-\t\tsect := f.Section(\".go_export\")\n-\t\tdata, _ := sect.Data()\n+\t\tvar data []byte\n+\t\tif f, err := elf.Open(shlibpath); err == nil {\n+\t\t\tsect := f.Section(\".go_export\")\n+\t\t\tdata, _ = sect.Data()\n+\t\t} else if f, err := xcoff.Open(shlibpath); err == nil {\n+\t\t\tdata = f.CSect(\".go_export\")\n+\t\t}\n \t\tscanner := bufio.NewScanner(bytes.NewBuffer(data))\n \t\tfor scanner.Scan() {\n \t\t\tt := scanner.Text()\n@@ -1815,6 +1820,7 @@ func (b *Builder) cover(a *Action, dst, src string, perm os.FileMode, varName st\n \n var objectMagic = [][]byte{\n \t{'!', '<', 'a', 'r', 'c', 'h', '>', '\\n'}, // Package archive\n+\t{'<', 'b', 'i', 'g', 'a', 'f', '>', '\\n'}, // Package archive (AIX format)\n \t{'\\x7F', 'E', 'L', 'F'},                   // ELF\n \t{0xFE, 0xED, 0xFA, 0xCE},                  // Mach-O big-endian 32-bit\n \t{0xFE, 0xED, 0xFA, 0xCF},                  // Mach-O big-endian 64-bit\n@@ -1824,6 +1830,8 @@ var objectMagic = [][]byte{\n \t{0x00, 0x00, 0x01, 0xEB},                  // Plan 9 i386\n \t{0x00, 0x00, 0x8a, 0x97},                  // Plan 9 amd64\n \t{0x00, 0x00, 0x06, 0x47},                  // Plan 9 arm\n+\t{0x01, 0xDF},                              // XCOFF32\n+\t{0x01, 0xF7},                              // XCOFF64\n }\n \n func isObject(s string) bool {\n@@ -3308,6 +3316,10 @@ func (b *Builder) gccArchArgs() []string {\n \t\treturn []string{\"-mabi=64\"}\n \tcase \"mips\", \"mipsle\":\n \t\treturn []string{\"-mabi=32\", \"-march=mips32\"}\n+\tcase \"ppc64\":\n+\t\tif cfg.Goos == \"aix\" {\n+\t\t\treturn []string{\"-maix64\"}\n+\t\t}\n \t}\n \treturn nil\n }"}, {"sha": "253a43cf579b331788162c24d995568ac819bad9", "filename": "libgo/go/debug/dwarf/open.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fopen.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -33,7 +33,7 @@ type Data struct {\n // New returns a new Data object initialized from the given parameters.\n // Rather than calling this function directly, clients should typically use\n // the DWARF method of the File type of the appropriate package debug/elf,\n-// debug/macho, or debug/pe.\n+// debug/macho, debug/pe, or debug/xcoff.\n //\n // The []byte arguments are the data from the corresponding debug section\n // in the object file; for example, for an ELF object, abbrev is the contents of"}, {"sha": "295861093a721032b91c768eb8f5e0e8efcad4e5", "filename": "libgo/go/debug/xcoff/file.go", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ffile.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -0,0 +1,539 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package xcoff implements access to XCOFF (Extended Common Object File Format) files.\n+package xcoff\n+\n+import (\n+\t\"debug/dwarf\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+// Information we store about an XCOFF section header.\n+type SectionHeader struct {\n+\tName           string\n+\tVirtualAddress uint64\n+\tSize           uint64\n+\tType           uint32\n+}\n+type Section struct {\n+\tSectionHeader\n+\tio.ReaderAt\n+\tsr *io.SectionReader\n+}\n+\n+// Information we store about an XCOFF symbol.\n+type AuxiliaryCSect struct {\n+\tLength              int64\n+\tStorageMappingClass int\n+\tSymbolType          int\n+}\n+type Symbol struct {\n+\tName          string\n+\tValue         uint64\n+\tSectionNumber int\n+\tStorageClass  int\n+\tAuxCSect      AuxiliaryCSect\n+}\n+\n+// Information we store about an imported XCOFF symbol.\n+type ImportedSymbol struct {\n+\tName    string\n+\tLibrary string\n+}\n+\n+// A File represents an open XCOFF file.\n+type FileHeader struct {\n+\tTargetMachine uint16\n+}\n+type File struct {\n+\tFileHeader\n+\tSections     []*Section\n+\tSymbols      []*Symbol\n+\tStringTable  []byte\n+\tLibraryPaths []string\n+\n+\tcloser io.Closer\n+}\n+\n+// Open opens the named file using os.Open and prepares it for use as an XCOFF binary.\n+func Open(name string) (*File, error) {\n+\tf, err := os.Open(name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tff, err := NewFile(f)\n+\tif err != nil {\n+\t\tf.Close()\n+\t\treturn nil, err\n+\t}\n+\tff.closer = f\n+\treturn ff, nil\n+}\n+\n+// Close closes the File.\n+// If the File was created using NewFile directly instead of Open,\n+// Close has no effect.\n+func (f *File) Close() error {\n+\tvar err error\n+\tif f.closer != nil {\n+\t\terr = f.closer.Close()\n+\t\tf.closer = nil\n+\t}\n+\treturn err\n+}\n+\n+// SectionByType returns the first section in f with the\n+// given type, or nil if there is no such section.\n+func (f *File) SectionByType(typ uint32) *Section {\n+\tfor _, s := range f.Sections {\n+\t\tif s.Type == typ {\n+\t\t\treturn s\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// cstring converts ASCII byte sequence b to string.\n+// It stops once it finds 0 or reaches end of b.\n+func cstring(b []byte) string {\n+\tvar i int\n+\tfor i = 0; i < len(b) && b[i] != 0; i++ {\n+\t}\n+\treturn string(b[:i])\n+}\n+\n+// getString extracts a string from an XCOFF string table.\n+func getString(st []byte, offset uint32) (string, bool) {\n+\tif offset < 4 || int(offset) >= len(st) {\n+\t\treturn \"\", false\n+\t}\n+\treturn cstring(st[offset:]), true\n+}\n+\n+// NewFile creates a new File for accessing an XCOFF binary in an underlying reader.\n+func NewFile(r io.ReaderAt) (*File, error) {\n+\tsr := io.NewSectionReader(r, 0, 1<<63-1)\n+\t// Read XCOFF target machine\n+\tvar magic uint16\n+\tif err := binary.Read(sr, binary.BigEndian, &magic); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif magic != U802TOCMAGIC && magic != U64_TOCMAGIC {\n+\t\treturn nil, fmt.Errorf(\"unrecognised XCOFF magic\", magic)\n+\t}\n+\n+\tf := new(File)\n+\tf.TargetMachine = magic\n+\n+\t// Read XCOFF file header\n+\tsr.Seek(0, io.SeekStart)\n+\tvar nscns uint16\n+\tvar symptr uint64\n+\tvar nsyms int32\n+\tvar opthdr uint16\n+\tvar hdrsz int\n+\tswitch f.TargetMachine {\n+\tcase U802TOCMAGIC:\n+\t\tfhdr := new(FileHeader32)\n+\t\tif err := binary.Read(sr, binary.BigEndian, fhdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tnscns = fhdr.Fnscns\n+\t\tsymptr = uint64(fhdr.Fsymptr)\n+\t\tnsyms = fhdr.Fnsyms\n+\t\topthdr = fhdr.Fopthdr\n+\t\thdrsz = FILHSZ_32\n+\tcase U64_TOCMAGIC:\n+\t\tfhdr := new(FileHeader64)\n+\t\tif err := binary.Read(sr, binary.BigEndian, fhdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tnscns = fhdr.Fnscns\n+\t\tsymptr = fhdr.Fsymptr\n+\t\tnsyms = fhdr.Fnsyms\n+\t\topthdr = fhdr.Fopthdr\n+\t\thdrsz = FILHSZ_64\n+\t}\n+\n+\tif symptr == 0 || nsyms <= 0 {\n+\t\treturn nil, fmt.Errorf(\"no symbol table\")\n+\t}\n+\n+\t// Read string table (located right after symbol table).\n+\toffset := symptr + uint64(nsyms)*SYMESZ\n+\tsr.Seek(int64(offset), io.SeekStart)\n+\t// The first 4 bytes contain the length (in bytes).\n+\tvar l uint32\n+\tbinary.Read(sr, binary.BigEndian, &l)\n+\tif l > 4 {\n+\t\tsr.Seek(int64(offset), io.SeekStart)\n+\t\tf.StringTable = make([]byte, l)\n+\t\tio.ReadFull(sr, f.StringTable)\n+\t}\n+\n+\t// Read section headers\n+\tsr.Seek(int64(hdrsz)+int64(opthdr), io.SeekStart)\n+\tf.Sections = make([]*Section, nscns)\n+\tfor i := 0; i < int(nscns); i++ {\n+\t\tvar scnptr uint64\n+\t\ts := new(Section)\n+\t\tswitch f.TargetMachine {\n+\t\tcase U802TOCMAGIC:\n+\t\t\tshdr := new(SectionHeader32)\n+\t\t\tif err := binary.Read(sr, binary.BigEndian, shdr); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ts.Name = cstring(shdr.Sname[:])\n+\t\t\ts.VirtualAddress = uint64(shdr.Svaddr)\n+\t\t\ts.Size = uint64(shdr.Ssize)\n+\t\t\tscnptr = uint64(shdr.Sscnptr)\n+\t\t\ts.Type = shdr.Sflags\n+\t\tcase U64_TOCMAGIC:\n+\t\t\tshdr := new(SectionHeader64)\n+\t\t\tif err := binary.Read(sr, binary.BigEndian, shdr); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ts.Name = cstring(shdr.Sname[:])\n+\t\t\ts.VirtualAddress = shdr.Svaddr\n+\t\t\ts.Size = shdr.Ssize\n+\t\t\tscnptr = shdr.Sscnptr\n+\t\t\ts.Type = shdr.Sflags\n+\t\t}\n+\t\tr2 := r\n+\t\tif scnptr == 0 { // .bss must have all 0s\n+\t\t\tr2 = zeroReaderAt{}\n+\t\t}\n+\t\ts.sr = io.NewSectionReader(r2, int64(scnptr), int64(s.Size))\n+\t\ts.ReaderAt = s.sr\n+\t\tf.Sections[i] = s\n+\t}\n+\n+\t// Read symbol table\n+\tsr.Seek(int64(symptr), io.SeekStart)\n+\tf.Symbols = make([]*Symbol, 0)\n+\tfor i := 0; i < int(nsyms); i++ {\n+\t\tvar numaux int\n+\t\tvar ok bool\n+\t\tsym := new(Symbol)\n+\t\tswitch f.TargetMachine {\n+\t\tcase U802TOCMAGIC:\n+\t\t\tse := new(SymEnt32)\n+\t\t\tif err := binary.Read(sr, binary.BigEndian, se); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tnumaux = int(se.Nnumaux)\n+\t\t\tsym.SectionNumber = int(se.Nscnum)\n+\t\t\tsym.StorageClass = int(se.Nsclass)\n+\t\t\tsym.Value = uint64(se.Nvalue)\n+\t\t\tzeroes := binary.BigEndian.Uint32(se.Nname[:4])\n+\t\t\tif zeroes != 0 {\n+\t\t\t\tsym.Name = cstring(se.Nname[:])\n+\t\t\t} else {\n+\t\t\t\toffset := binary.BigEndian.Uint32(se.Nname[4:])\n+\t\t\t\tsym.Name, ok = getString(f.StringTable, offset)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tgoto skip\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase U64_TOCMAGIC:\n+\t\t\tse := new(SymEnt64)\n+\t\t\tif err := binary.Read(sr, binary.BigEndian, se); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tnumaux = int(se.Nnumaux)\n+\t\t\tsym.SectionNumber = int(se.Nscnum)\n+\t\t\tsym.StorageClass = int(se.Nsclass)\n+\t\t\tsym.Value = se.Nvalue\n+\t\t\tsym.Name, ok = getString(f.StringTable, se.Noffset)\n+\t\t\tif !ok {\n+\t\t\t\tgoto skip\n+\t\t\t}\n+\t\t}\n+\t\tif sym.StorageClass != C_EXT && sym.StorageClass != C_WEAKEXT && sym.StorageClass != C_HIDEXT {\n+\t\t\tgoto skip\n+\t\t}\n+\t\t// Must have at least one csect auxiliary entry.\n+\t\tif numaux < 1 || i+numaux >= int(nsyms) {\n+\t\t\tgoto skip\n+\t\t}\n+\t\tif sym.SectionNumber < 1 || sym.SectionNumber > int(nscns) {\n+\t\t\tgoto skip\n+\t\t}\n+\t\tsym.Value -= f.Sections[sym.SectionNumber-1].VirtualAddress\n+\n+\t\t// Read csect auxiliary entry (by convention, it is the last).\n+\t\tsr.Seek(int64((numaux-1)*SYMESZ), io.SeekCurrent)\n+\t\ti += numaux\n+\t\tnumaux = 0\n+\t\tswitch f.TargetMachine {\n+\t\tcase U802TOCMAGIC:\n+\t\t\taux := new(AuxCSect32)\n+\t\t\tif err := binary.Read(sr, binary.BigEndian, aux); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tsym.AuxCSect.SymbolType = int(aux.Xsmtyp & 0x7)\n+\t\t\tsym.AuxCSect.StorageMappingClass = int(aux.Xsmclas)\n+\t\t\tsym.AuxCSect.Length = int64(aux.Xscnlen)\n+\t\tcase U64_TOCMAGIC:\n+\t\t\taux := new(AuxCSect64)\n+\t\t\tif err := binary.Read(sr, binary.BigEndian, aux); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tsym.AuxCSect.SymbolType = int(aux.Xsmtyp & 0x7)\n+\t\t\tsym.AuxCSect.StorageMappingClass = int(aux.Xsmclas)\n+\t\t\tsym.AuxCSect.Length = int64(aux.Xscnlenhi)<<32 | int64(aux.Xscnlenlo)\n+\t\t}\n+\n+\t\tf.Symbols = append(f.Symbols, sym)\n+\tskip:\n+\t\ti += numaux // Skip auxiliary entries\n+\t\tsr.Seek(int64(numaux)*SYMESZ, io.SeekCurrent)\n+\t}\n+\n+\treturn f, nil\n+}\n+\n+// zeroReaderAt is ReaderAt that reads 0s.\n+type zeroReaderAt struct{}\n+\n+// ReadAt writes len(p) 0s into p.\n+func (w zeroReaderAt) ReadAt(p []byte, off int64) (n int, err error) {\n+\tfor i := range p {\n+\t\tp[i] = 0\n+\t}\n+\treturn len(p), nil\n+}\n+\n+// Data reads and returns the contents of the XCOFF section s.\n+func (s *Section) Data() ([]byte, error) {\n+\tdat := make([]byte, s.sr.Size())\n+\tn, err := s.sr.ReadAt(dat, 0)\n+\tif n == len(dat) {\n+\t\terr = nil\n+\t}\n+\treturn dat[0:n], err\n+}\n+\n+// CSect reads and returns the contents of a csect.\n+func (f *File) CSect(name string) []byte {\n+\tfor _, sym := range f.Symbols {\n+\t\tif sym.Name == name && sym.AuxCSect.SymbolType == XTY_SD {\n+\t\t\tif i := sym.SectionNumber - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\ts := f.Sections[i]\n+\t\t\t\tif sym.Value+uint64(sym.AuxCSect.Length) <= s.Size {\n+\t\t\t\t\tdat := make([]byte, sym.AuxCSect.Length)\n+\t\t\t\t\t_, err := s.sr.ReadAt(dat, int64(sym.Value))\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn nil\n+\t\t\t\t\t}\n+\t\t\t\t\treturn dat\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (f *File) DWARF() (*dwarf.Data, error) {\n+\t// There are many other DWARF sections, but these\n+\t// are the ones the debug/dwarf package uses.\n+\t// Don't bother loading others.\n+\tvar subtypes = [...]uint32{SSUBTYP_DWABREV, SSUBTYP_DWINFO, SSUBTYP_DWLINE, SSUBTYP_DWARNGE, SSUBTYP_DWSTR}\n+\tvar dat [len(subtypes)][]byte\n+\tfor i, subtype := range subtypes {\n+\t\ts := f.SectionByType(STYP_DWARF | subtype)\n+\t\tif s != nil {\n+\t\t\tb, err := s.Data()\n+\t\t\tif err != nil && uint64(len(b)) < s.Size {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tdat[i] = b\n+\t\t}\n+\t}\n+\n+\tabbrev, info, line, ranges, str := dat[0], dat[1], dat[2], dat[3], dat[4]\n+\treturn dwarf.New(abbrev, nil, nil, info, line, nil, ranges, str)\n+}\n+\n+// Read a loader section import file IDs.\n+func (f *File) readImportIDs(s *Section) ([]string, error) {\n+\t// Read loader header\n+\ts.sr.Seek(0, io.SeekStart)\n+\tvar istlen uint32\n+\tvar nimpid int32\n+\tvar impoff uint64\n+\tswitch f.TargetMachine {\n+\tcase U802TOCMAGIC:\n+\t\tlhdr := new(LoaderHeader32)\n+\t\tif err := binary.Read(s.sr, binary.BigEndian, lhdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tistlen = lhdr.Listlen\n+\t\tnimpid = lhdr.Lnimpid\n+\t\timpoff = uint64(lhdr.Limpoff)\n+\tcase U64_TOCMAGIC:\n+\t\tlhdr := new(LoaderHeader64)\n+\t\tif err := binary.Read(s.sr, binary.BigEndian, lhdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tistlen = lhdr.Listlen\n+\t\tnimpid = lhdr.Lnimpid\n+\t\timpoff = lhdr.Limpoff\n+\t}\n+\n+\t// Read loader import file ID table\n+\ts.sr.Seek(int64(impoff), io.SeekStart)\n+\ttable := make([]byte, istlen)\n+\tio.ReadFull(s.sr, table)\n+\n+\toffset := 0\n+\t// First import file ID is the default LIBPATH value\n+\tlibpath := cstring(table[offset:])\n+\tf.LibraryPaths = strings.Split(libpath, \":\")\n+\toffset += len(libpath) + 3 // 3 null bytes\n+\tall := make([]string, 0)\n+\tfor i := 1; i < int(nimpid); i++ {\n+\t\timpidpath := cstring(table[offset:])\n+\t\toffset += len(impidpath) + 1\n+\t\timpidbase := cstring(table[offset:])\n+\t\toffset += len(impidbase) + 1\n+\t\timpidmem := cstring(table[offset:])\n+\t\toffset += len(impidmem) + 1\n+\t\tvar path string\n+\t\tif len(impidpath) > 0 {\n+\t\t\tpath = impidpath + \"/\" + impidbase\n+\t\t} else {\n+\t\t\tpath = impidbase\n+\t\t}\n+\t\tall = append(all, path)\n+\t}\n+\n+\treturn all, nil\n+}\n+\n+// ImportedSymbols returns the names of all symbols\n+// referred to by the binary f that are expected to be\n+// satisfied by other libraries at dynamic load time.\n+// It does not return weak symbols.\n+func (f *File) ImportedSymbols() ([]ImportedSymbol, error) {\n+\ts := f.SectionByType(STYP_LOADER)\n+\tif s == nil {\n+\t\treturn nil, nil\n+\t}\n+\t// Read loader header\n+\ts.sr.Seek(0, io.SeekStart)\n+\tvar stlen uint32\n+\tvar stoff uint64\n+\tvar nsyms int32\n+\tvar symoff uint64\n+\tswitch f.TargetMachine {\n+\tcase U802TOCMAGIC:\n+\t\tlhdr := new(LoaderHeader32)\n+\t\tif err := binary.Read(s.sr, binary.BigEndian, lhdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tstlen = lhdr.Lstlen\n+\t\tstoff = uint64(lhdr.Lstoff)\n+\t\tnsyms = lhdr.Lnsyms\n+\t\tsymoff = LDHDRSZ_32\n+\tcase U64_TOCMAGIC:\n+\t\tlhdr := new(LoaderHeader64)\n+\t\tif err := binary.Read(s.sr, binary.BigEndian, lhdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tstlen = lhdr.Lstlen\n+\t\tstoff = lhdr.Lstoff\n+\t\tnsyms = lhdr.Lnsyms\n+\t\tsymoff = lhdr.Lsymoff\n+\t}\n+\n+\t// Read loader section string table\n+\ts.sr.Seek(int64(stoff), io.SeekStart)\n+\tst := make([]byte, stlen)\n+\tio.ReadFull(s.sr, st)\n+\n+\t// Read imported libraries\n+\tlibs, err := f.readImportIDs(s)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Read loader symbol table\n+\ts.sr.Seek(int64(symoff), io.SeekStart)\n+\tall := make([]ImportedSymbol, 0)\n+\tfor i := 0; i < int(nsyms); i++ {\n+\t\tvar name string\n+\t\tvar ifile int32\n+\t\tvar ok bool\n+\t\tswitch f.TargetMachine {\n+\t\tcase U802TOCMAGIC:\n+\t\t\tldsym := new(LoaderSymbol32)\n+\t\t\tif err := binary.Read(s.sr, binary.BigEndian, ldsym); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif ldsym.Lsmtype&0x40 == 0 {\n+\t\t\t\tcontinue // Imported symbols only\n+\t\t\t}\n+\t\t\tzeroes := binary.BigEndian.Uint32(ldsym.Lname[:4])\n+\t\t\tif zeroes != 0 {\n+\t\t\t\tname = cstring(ldsym.Lname[:])\n+\t\t\t} else {\n+\t\t\t\toffset := binary.BigEndian.Uint32(ldsym.Lname[4:])\n+\t\t\t\tname, ok = getString(st, offset)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tifile = ldsym.Lifile\n+\t\tcase U64_TOCMAGIC:\n+\t\t\tldsym := new(LoaderSymbol64)\n+\t\t\tif err := binary.Read(s.sr, binary.BigEndian, ldsym); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif ldsym.Lsmtype&0x40 == 0 {\n+\t\t\t\tcontinue // Imported symbols only\n+\t\t\t}\n+\t\t\tname, ok = getString(st, ldsym.Loffset)\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tifile = ldsym.Lifile\n+\t\t}\n+\t\tvar sym ImportedSymbol\n+\t\tsym.Name = name\n+\t\tif ifile >= 1 && int(ifile) <= len(libs) {\n+\t\t\tsym.Library = libs[ifile-1]\n+\t\t}\n+\t\tall = append(all, sym)\n+\t}\n+\n+\treturn all, nil\n+}\n+\n+// ImportedLibraries returns the names of all libraries\n+// referred to by the binary f that are expected to be\n+// linked with the binary at dynamic link time.\n+func (f *File) ImportedLibraries() ([]string, error) {\n+\ts := f.SectionByType(STYP_LOADER)\n+\tif s == nil {\n+\t\treturn nil, nil\n+\t}\n+\tall, err := f.readImportIDs(s)\n+\treturn all, err\n+}\n+\n+// FormatError is unused.\n+// The type is retained for compatibility.\n+type FormatError struct {\n+}\n+\n+func (e *FormatError) Error() string {\n+\treturn \"unknown error\"\n+}"}, {"sha": "115ce3080696ad890f6fc537d646563069882ec1", "filename": "libgo/go/debug/xcoff/file_test.go", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ffile_test.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -0,0 +1,150 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package xcoff\n+\n+import (\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+type fileTest struct {\n+\tfile     string\n+\thdr      FileHeader\n+\tsections []*SectionHeader\n+\tneeded   []string\n+}\n+\n+var fileTests = []fileTest{\n+\t{\n+\t\t\"testdata/gcc-ppc32-aix-exec\",\n+\t\tFileHeader{U802TOCMAGIC},\n+\t\t[]*SectionHeader{\n+\t\t\t{\".text\", 0x10000150, 0x00000bbd, STYP_TEXT},\n+\t\t\t{\".data\", 0x20000d0d, 0x0000042b, STYP_DATA},\n+\t\t\t{\".bss\", 0x20001138, 0x00000218, STYP_BSS},\n+\t\t\t{\".loader\", 0x00000000, 0x000004b3, STYP_LOADER},\n+\t\t\t{\".debug\", 0x00000000, 0x0000751e, STYP_DEBUG},\n+\t\t},\n+\t\t[]string{\"libc.a\"},\n+\t},\n+\t{\n+\t\t\"testdata/gcc-ppc64-aix-exec\",\n+\t\tFileHeader{U64_TOCMAGIC},\n+\t\t[]*SectionHeader{\n+\t\t\t{\".text\", 0x10000240, 0x00000afd, STYP_TEXT},\n+\t\t\t{\".data\", 0x20000d3d, 0x000002e3, STYP_DATA},\n+\t\t\t{\".bss\", 0x20001020, 0x00000428, STYP_BSS},\n+\t\t\t{\".loader\", 0x00000000, 0x00000535, STYP_LOADER},\n+\t\t\t{\".debug\", 0x00000000, 0x00008238, STYP_DEBUG},\n+\t\t},\n+\t\t[]string{\"libc.a\"},\n+\t},\n+\t{\n+\t\t\"testdata/xlc-ppc32-aix-exec\",\n+\t\tFileHeader{U802TOCMAGIC},\n+\t\t[]*SectionHeader{\n+\t\t\t{\".text\", 0x10000150, 0x00000372, STYP_TEXT},\n+\t\t\t{\".data\", 0x200004c2, 0x0000032e, STYP_DATA},\n+\t\t\t{\".bss\", 0x200007f0, 0x00000004, STYP_BSS},\n+\t\t\t{\".loader\", 0x00000000, 0x0000029d, STYP_LOADER},\n+\t\t\t{\".debug\", 0x00000000, 0x0000008f, STYP_DEBUG},\n+\t\t},\n+\t\t[]string{\"libc.a\"},\n+\t},\n+\t{\n+\t\t\"testdata/xlc-ppc64-aix-exec\",\n+\t\tFileHeader{U64_TOCMAGIC},\n+\t\t[]*SectionHeader{\n+\t\t\t{\".text\", 0x100000240, 0x00000326, STYP_TEXT},\n+\t\t\t{\".data\", 0x110000566, 0x00000182, STYP_DATA},\n+\t\t\t{\".bss\", 0x1100006e8, 0x00000008, STYP_BSS},\n+\t\t\t{\".loader\", 0x00000000, 0x0000029b, STYP_LOADER},\n+\t\t\t{\".debug\", 0x00000000, 0x000000ea, STYP_DEBUG},\n+\t\t},\n+\t\t[]string{\"libc.a\"},\n+\t},\n+\t{\n+\t\t\"testdata/gcc-ppc32-aix-dwarf2-exec\",\n+\t\tFileHeader{U802TOCMAGIC},\n+\t\t[]*SectionHeader{\n+\t\t\t{\".text\", 0x10000290, 0x00000bbd, STYP_TEXT},\n+\t\t\t{\".data\", 0x20000e4d, 0x00000437, STYP_DATA},\n+\t\t\t{\".bss\", 0x20001284, 0x0000021c, STYP_BSS},\n+\t\t\t{\".loader\", 0x00000000, 0x000004b3, STYP_LOADER},\n+\t\t\t{\".dwline\", 0x00000000, 0x000000df, STYP_DWARF | SSUBTYP_DWLINE},\n+\t\t\t{\".dwinfo\", 0x00000000, 0x00000314, STYP_DWARF | SSUBTYP_DWINFO},\n+\t\t\t{\".dwabrev\", 0x00000000, 0x000000d6, STYP_DWARF | SSUBTYP_DWABREV},\n+\t\t\t{\".dwarnge\", 0x00000000, 0x00000020, STYP_DWARF | SSUBTYP_DWARNGE},\n+\t\t\t{\".dwloc\", 0x00000000, 0x00000074, STYP_DWARF | SSUBTYP_DWLOC},\n+\t\t\t{\".debug\", 0x00000000, 0x00005e4f, STYP_DEBUG},\n+\t\t},\n+\t\t[]string{\"libc.a\"},\n+\t},\n+\t{\n+\t\t\"testdata/gcc-ppc64-aix-dwarf2-exec\",\n+\t\tFileHeader{U64_TOCMAGIC},\n+\t\t[]*SectionHeader{\n+\t\t\t{\".text\", 0x10000480, 0x00000afd, STYP_TEXT},\n+\t\t\t{\".data\", 0x20000f7d, 0x000002f3, STYP_DATA},\n+\t\t\t{\".bss\", 0x20001270, 0x00000428, STYP_BSS},\n+\t\t\t{\".loader\", 0x00000000, 0x00000535, STYP_LOADER},\n+\t\t\t{\".dwline\", 0x00000000, 0x000000b4, STYP_DWARF | SSUBTYP_DWLINE},\n+\t\t\t{\".dwinfo\", 0x00000000, 0x0000036a, STYP_DWARF | SSUBTYP_DWINFO},\n+\t\t\t{\".dwabrev\", 0x00000000, 0x000000b5, STYP_DWARF | SSUBTYP_DWABREV},\n+\t\t\t{\".dwarnge\", 0x00000000, 0x00000040, STYP_DWARF | SSUBTYP_DWARNGE},\n+\t\t\t{\".dwloc\", 0x00000000, 0x00000062, STYP_DWARF | SSUBTYP_DWLOC},\n+\t\t\t{\".debug\", 0x00000000, 0x00006605, STYP_DEBUG},\n+\t\t},\n+\t\t[]string{\"libc.a\"},\n+\t},\n+}\n+\n+func TestOpen(t *testing.T) {\n+\tfor i := range fileTests {\n+\t\ttt := &fileTests[i]\n+\n+\t\tf, err := Open(tt.file)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !reflect.DeepEqual(f.FileHeader, tt.hdr) {\n+\t\t\tt.Errorf(\"open %s:\\n\\thave %#v\\n\\twant %#v\\n\", tt.file, f.FileHeader, tt.hdr)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor i, sh := range f.Sections {\n+\t\t\tif i >= len(tt.sections) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\thave := &sh.SectionHeader\n+\t\t\twant := tt.sections[i]\n+\t\t\tif !reflect.DeepEqual(have, want) {\n+\t\t\t\tt.Errorf(\"open %s, section %d:\\n\\thave %#v\\n\\twant %#v\\n\", tt.file, i, have, want)\n+\t\t\t}\n+\t\t}\n+\t\ttn := len(tt.sections)\n+\t\tfn := len(f.Sections)\n+\t\tif tn != fn {\n+\t\t\tt.Errorf(\"open %s: len(Sections) = %d, want %d\", tt.file, fn, tn)\n+\t\t}\n+\t\ttl := tt.needed\n+\t\tfl, err := f.ImportedLibraries()\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tif !reflect.DeepEqual(tl, fl) {\n+\t\t\tt.Errorf(\"open %s: loader import = %v, want %v\", tt.file, tl, fl)\n+\t\t}\n+\t}\n+}\n+\n+func TestOpenFailure(t *testing.T) {\n+\tfilename := \"file.go\"    // not an XCOFF object file\n+\t_, err := Open(filename) // don't crash\n+\tif err == nil {\n+\t\tt.Errorf(\"open %s: succeeded unexpectedly\", filename)\n+\t}\n+}"}, {"sha": "810e21a0dfc78b29f2dfc5afe2bc588763177ea6", "filename": "libgo/go/debug/xcoff/testdata/gcc-ppc32-aix-dwarf2-exec", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc32-aix-dwarf2-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc32-aix-dwarf2-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc32-aix-dwarf2-exec?ref=c90df0d293367452d193f04a18c2233d64a10d1a"}, {"sha": "6e44041b3dfc3ec6c1749714553b095eecccd24e", "filename": "libgo/go/debug/xcoff/testdata/gcc-ppc32-aix-exec", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc32-aix-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc32-aix-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc32-aix-exec?ref=c90df0d293367452d193f04a18c2233d64a10d1a"}, {"sha": "707d01ebd43487081a620250a213dcdba7a80379", "filename": "libgo/go/debug/xcoff/testdata/gcc-ppc64-aix-dwarf2-exec", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc64-aix-dwarf2-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc64-aix-dwarf2-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc64-aix-dwarf2-exec?ref=c90df0d293367452d193f04a18c2233d64a10d1a"}, {"sha": "82ffdaf3e4454b4c266369b7ca669acbc30c4ff3", "filename": "libgo/go/debug/xcoff/testdata/gcc-ppc64-aix-exec", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc64-aix-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc64-aix-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fgcc-ppc64-aix-exec?ref=c90df0d293367452d193f04a18c2233d64a10d1a"}, {"sha": "34d9ee79234ef29ea03feeb69d220b0796295636", "filename": "libgo/go/debug/xcoff/testdata/hello.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fhello.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fhello.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fhello.c?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -0,0 +1,7 @@\n+#include <stdio.h>\n+\n+void\n+main(int argc, char *argv[])\n+{\n+\tprintf(\"hello, world\\n\");\n+}"}, {"sha": "e076f81621b8686a50b70d392640ce26a91a7524", "filename": "libgo/go/debug/xcoff/testdata/xlc-ppc32-aix-exec", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fxlc-ppc32-aix-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fxlc-ppc32-aix-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fxlc-ppc32-aix-exec?ref=c90df0d293367452d193f04a18c2233d64a10d1a"}, {"sha": "26041dc0d4ee9faf5d748618201175cb973e53bd", "filename": "libgo/go/debug/xcoff/testdata/xlc-ppc64-aix-exec", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fxlc-ppc64-aix-exec", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fxlc-ppc64-aix-exec", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Ftestdata%2Fxlc-ppc64-aix-exec?ref=c90df0d293367452d193f04a18c2233d64a10d1a"}, {"sha": "8d76bf3c09e9877de68d7288357f5915ec1d64ba", "filename": "libgo/go/debug/xcoff/xcoff.go", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Fxcoff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fdebug%2Fxcoff%2Fxcoff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fxcoff%2Fxcoff.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -0,0 +1,262 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package xcoff\n+\n+// File Header.\n+type FileHeader32 struct {\n+\tFmagic   uint16 // Target machine\n+\tFnscns   uint16 // Number of sections\n+\tFtimedat int32  // Time and date of file creation\n+\tFsymptr  uint32 // Byte offset to symbol table start\n+\tFnsyms   int32  // Number of entries in symbol table\n+\tFopthdr  uint16 // Number of bytes in optional header\n+\tFflags   uint16 // Flags\n+}\n+\n+type FileHeader64 struct {\n+\tFmagic   uint16 // Target machine\n+\tFnscns   uint16 // Number of sections\n+\tFtimedat int32  // Time and date of file creation\n+\tFsymptr  uint64 // Byte offset to symbol table start\n+\tFopthdr  uint16 // Number of bytes in optional header\n+\tFflags   uint16 // Flags\n+\tFnsyms   int32  // Number of entries in symbol table\n+}\n+\n+const (\n+\tFILHSZ_32 = 20\n+\tFILHSZ_64 = 24\n+)\n+const (\n+\tU802TOCMAGIC = 0737 // AIX 32-bit XCOFF\n+\tU64_TOCMAGIC = 0767 // AIX 64-bit XCOFF\n+)\n+\n+// Flags that describe the type of the object file.\n+const (\n+\tF_RELFLG    = 0x0001\n+\tF_EXEC      = 0x0002\n+\tF_LNNO      = 0x0004\n+\tF_FDPR_PROF = 0x0010\n+\tF_FDPR_OPTI = 0x0020\n+\tF_DSA       = 0x0040\n+\tF_VARPG     = 0x0100\n+\tF_DYNLOAD   = 0x1000\n+\tF_SHROBJ    = 0x2000\n+\tF_LOADONLY  = 0x4000\n+)\n+\n+// Section Header.\n+type SectionHeader32 struct {\n+\tSname    [8]byte // Section name\n+\tSpaddr   uint32  // Physical address\n+\tSvaddr   uint32  // Virtual address\n+\tSsize    uint32  // Section size\n+\tSscnptr  uint32  // Offset in file to raw data for section\n+\tSrelptr  uint32  // Offset in file to relocation entries for section\n+\tSlnnoptr uint32  // Offset in file to line number entries for section\n+\tSnreloc  uint16  // Number of relocation entries\n+\tSnlnno   uint16  // Number of line number entries\n+\tSflags   uint32  // Flags to define the section type\n+}\n+\n+type SectionHeader64 struct {\n+\tSname    [8]byte // Section name\n+\tSpaddr   uint64  // Physical address\n+\tSvaddr   uint64  // Virtual address\n+\tSsize    uint64  // Section size\n+\tSscnptr  uint64  // Offset in file to raw data for section\n+\tSrelptr  uint64  // Offset in file to relocation entries for section\n+\tSlnnoptr uint64  // Offset in file to line number entries for section\n+\tSnreloc  uint32  // Number of relocation entries\n+\tSnlnno   uint32  // Number of line number entries\n+\tSflags   uint32  // Flags to define the section type\n+\tSpad     uint32  // Needs to be 72 bytes long\n+}\n+\n+// Flags defining the section type.\n+const (\n+\tSTYP_DWARF  = 0x0010\n+\tSTYP_TEXT   = 0x0020\n+\tSTYP_DATA   = 0x0040\n+\tSTYP_BSS    = 0x0080\n+\tSTYP_EXCEPT = 0x0100\n+\tSTYP_INFO   = 0x0200\n+\tSTYP_TDATA  = 0x0400\n+\tSTYP_TBSS   = 0x0800\n+\tSTYP_LOADER = 0x1000\n+\tSTYP_DEBUG  = 0x2000\n+\tSTYP_TYPCHK = 0x4000\n+\tSTYP_OVRFLO = 0x8000\n+)\n+const (\n+\tSSUBTYP_DWINFO  = 0x10000 // DWARF info section\n+\tSSUBTYP_DWLINE  = 0x20000 // DWARF line-number section\n+\tSSUBTYP_DWPBNMS = 0x30000 // DWARF public names section\n+\tSSUBTYP_DWPBTYP = 0x40000 // DWARF public types section\n+\tSSUBTYP_DWARNGE = 0x50000 // DWARF aranges section\n+\tSSUBTYP_DWABREV = 0x60000 // DWARF abbreviation section\n+\tSSUBTYP_DWSTR   = 0x70000 // DWARF strings section\n+\tSSUBTYP_DWRNGES = 0x80000 // DWARF ranges section\n+\tSSUBTYP_DWLOC   = 0x90000 // DWARF location lists section\n+\tSSUBTYP_DWFRAME = 0xA0000 // DWARF frames section\n+\tSSUBTYP_DWMAC   = 0xB0000 // DWARF macros section\n+)\n+\n+// Symbol Table Entry.\n+type SymEnt32 struct {\n+\tNname   [8]byte // Symbol name\n+\tNvalue  uint32  // Symbol value\n+\tNscnum  int16   // Section number of symbol\n+\tNtype   uint16  // Basic and derived type specification\n+\tNsclass int8    // Storage class of symbol\n+\tNnumaux int8    // Number of auxiliary entries\n+}\n+\n+type SymEnt64 struct {\n+\tNvalue  uint64 // Symbol value\n+\tNoffset uint32 // Offset of the name in string table or .debug section\n+\tNscnum  int16  // Section number of symbol\n+\tNtype   uint16 // Basic and derived type specification\n+\tNsclass int8   // Storage class of symbol\n+\tNnumaux int8   // Number of auxiliary entries\n+}\n+\n+const SYMESZ = 18\n+\n+// Storage Class.\n+const (\n+\tC_NULL    = 0   // Symbol table entry marked for deletion\n+\tC_EXT     = 2   // External symbol\n+\tC_STAT    = 3   // Static symbol\n+\tC_BLOCK   = 100 // Beginning or end of inner block\n+\tC_FCN     = 101 // Beginning or end of function\n+\tC_FILE    = 103 // Source file name and compiler information\n+\tC_HIDEXT  = 107 // Unnamed external symbol\n+\tC_BINCL   = 108 // Beginning of include file\n+\tC_EINCL   = 109 // End of include file\n+\tC_WEAKEXT = 111 // Weak external symbol\n+\tC_DWARF   = 112 // DWARF symbol\n+\tC_GSYM    = 128 // Global variable\n+\tC_LSYM    = 129 // Automatic variable allocated on stack\n+\tC_PSYM    = 130 // Argument to subroutine allocated on stack\n+\tC_RSYM    = 131 // Register variable\n+\tC_RPSYM   = 132 // Argument to function or procedure stored in register\n+\tC_STSYM   = 133 // Statically allocated symbol\n+\tC_BCOMM   = 135 // Beginning of common block\n+\tC_ECOML   = 136 // Local member of common block\n+\tC_ECOMM   = 137 // End of common block\n+\tC_DECL    = 140 // Declaration of object\n+\tC_ENTRY   = 141 // Alternate entry\n+\tC_FUN     = 142 // Function or procedure\n+\tC_BSTAT   = 143 // Beginning of static block\n+\tC_ESTAT   = 144 // End of static block\n+\tC_GTLS    = 145 // Global thread-local variable\n+\tC_STTLS   = 146 // Static thread-local variable\n+)\n+\n+// csect Auxiliary Entry.\n+type AuxCSect32 struct {\n+\tXscnlen   int32  // Length or symbol table index\n+\tXparmhash uint32 // Offset of parameter type-check string\n+\tXsnhash   uint16 // .typchk section number\n+\tXsmtyp    uint8  // Symbol alignment and type\n+\tXsmclas   uint8  // Storage-mapping class\n+\tXstab     uint32 // Reserved\n+\tXsnstab   uint16 // Reserved\n+}\n+\n+type AuxCSect64 struct {\n+\tXscnlenlo uint32 // Lower 4 bytes of length or symbol table index\n+\tXparmhash uint32 // Offset of parameter type-check string\n+\tXsnhash   uint16 // .typchk section number\n+\tXsmtyp    uint8  // Symbol alignment and type\n+\tXsmclas   uint8  // Storage-mapping class\n+\tXscnlenhi int32  // Upper 4 bytes of length or symbol table index\n+\tXpad      uint8  // Unused\n+\tXauxtype  uint8  // Type of auxiliary entry\n+}\n+\n+// Symbol type field.\n+const (\n+\tXTY_ER = 0 // External reference\n+\tXTY_SD = 1 // Section definition\n+\tXTY_LD = 2 // Label definition\n+\tXTY_CM = 3 // Common csect definition\n+)\n+\n+// Storage-mapping class.\n+const (\n+\tXMC_PR     = 0  // Program code\n+\tXMC_RO     = 1  // Read-only constant\n+\tXMC_DB     = 2  // Debug dictionary table\n+\tXMC_TC     = 3  // TOC entry\n+\tXMC_UA     = 4  // Unclassified\n+\tXMC_RW     = 5  // Read/Write data\n+\tXMC_GL     = 6  // Global linkage\n+\tXMC_XO     = 7  // Extended operation\n+\tXMC_SV     = 8  // 32-bit supervisor call descriptor\n+\tXMC_BS     = 9  // BSS class\n+\tXMC_DS     = 10 // Function descriptor\n+\tXMC_UC     = 11 // Unnamed FORTRAN common\n+\tXMC_TC0    = 15 // TOC anchor\n+\tXMC_TD     = 16 // Scalar data entry in the TOC\n+\tXMC_SV64   = 17 // 64-bit supervisor call descriptor\n+\tXMC_SV3264 = 18 // Supervisor call descriptor for both 32-bit and 64-bit\n+\tXMC_TL     = 20 // Read/Write thread-local data\n+\tXMC_UL     = 21 // Read/Write thread-local data (.tbss)\n+\tXMC_TE     = 22 // TOC entry\n+)\n+\n+// Loader Header.\n+type LoaderHeader32 struct {\n+\tLversion int32  // Loader section version number\n+\tLnsyms   int32  // Number of symbol table entries\n+\tLnreloc  int32  // Number of relocation table entries\n+\tListlen  uint32 // Length of import file ID string table\n+\tLnimpid  int32  // Number of import file IDs\n+\tLimpoff  uint32 // Offset to start of import file IDs\n+\tLstlen   uint32 // Length of string table\n+\tLstoff   uint32 // Offset to start of string table\n+}\n+\n+type LoaderHeader64 struct {\n+\tLversion int32  // Loader section version number\n+\tLnsyms   int32  // Number of symbol table entries\n+\tLnreloc  int32  // Number of relocation table entries\n+\tListlen  uint32 // Length of import file ID string table\n+\tLnimpid  int32  // Number of import file IDs\n+\tLstlen   uint32 // Length of string table\n+\tLimpoff  uint64 // Offset to start of import file IDs\n+\tLstoff   uint64 // Offset to start of string table\n+\tLsymoff  uint64 // Offset to start of symbol table\n+\tLrldoff  uint64 // Offset to start of relocation entries\n+}\n+\n+const (\n+\tLDHDRSZ_32 = 32\n+\tLDHDRSZ_64 = 56\n+)\n+\n+// Loader Symbol.\n+type LoaderSymbol32 struct {\n+\tLname   [8]byte // Symbol name or byte offset into string table\n+\tLvalue  uint32  // Address field\n+\tLscnum  int16   // Section number containing symbol\n+\tLsmtype int8    // Symbol type, export, import flags\n+\tLsmclas int8    // Symbol storage class\n+\tLifile  int32   // Import file ID; ordinal of import file IDs\n+\tLparm   uint32  // Parameter type-check field\n+}\n+\n+type LoaderSymbol64 struct {\n+\tLvalue  uint64 // Address field\n+\tLoffset uint32 // Byte offset into string table of symbol name\n+\tLscnum  int16  // Section number containing symbol\n+\tLsmtype int8   // Symbol type, export, import flags\n+\tLsmclas int8   // Symbol storage class\n+\tLifile  int32  // Import file ID; ordinal of import file IDs\n+\tLparm   uint32 // Parameter type-check field\n+}"}, {"sha": "655c37c52a405c42d1f3bd1aad20fdd66c8b295c", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -221,7 +221,7 @@ var pkgDeps = map[string][]string{\n \t\"go/constant\":               {\"L4\", \"go/token\", \"math/big\"},\n \t\"go/importer\":               {\"L4\", \"go/build\", \"go/internal/gccgoimporter\", \"go/internal/gcimporter\", \"go/internal/srcimporter\", \"go/token\", \"go/types\"},\n \t\"go/internal/gcimporter\":    {\"L4\", \"OS\", \"go/build\", \"go/constant\", \"go/token\", \"go/types\", \"text/scanner\"},\n-\t\"go/internal/gccgoimporter\": {\"L4\", \"OS\", \"debug/elf\", \"go/constant\", \"go/token\", \"go/types\", \"text/scanner\"},\n+\t\"go/internal/gccgoimporter\": {\"L4\", \"OS\", \"debug/elf\", \"debug/xcoff\", \"go/constant\", \"go/token\", \"go/types\", \"text/scanner\"},\n \t\"go/internal/srcimporter\":   {\"L4\", \"fmt\", \"go/ast\", \"go/build\", \"go/parser\", \"go/token\", \"go/types\", \"path/filepath\"},\n \t\"go/types\":                  {\"L4\", \"GOPARSER\", \"container/heap\", \"go/constant\"},\n \n@@ -243,6 +243,7 @@ var pkgDeps = map[string][]string{\n \t\"debug/macho\":              {\"L4\", \"OS\", \"debug/dwarf\"},\n \t\"debug/pe\":                 {\"L4\", \"OS\", \"debug/dwarf\"},\n \t\"debug/plan9obj\":           {\"L4\", \"OS\"},\n+\t\"debug/xcoff\":              {\"L4\", \"OS\", \"debug/dwarf\"},\n \t\"encoding\":                 {\"L4\"},\n \t\"encoding/ascii85\":         {\"L4\"},\n \t\"encoding/asn1\":            {\"L4\", \"math/big\"},"}, {"sha": "ee573ff64f985ab52ef072e17804415777e7a0f1", "filename": "libgo/go/go/internal/gccgoimporter/importer.go", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90df0d293367452d193f04a18c2233d64a10d1a/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter.go?ref=c90df0d293367452d193f04a18c2233d64a10d1a", "patch": "@@ -8,12 +8,14 @@ package gccgoimporter // import \"go/internal/gccgoimporter\"\n import (\n \t\"bytes\"\n \t\"debug/elf\"\n+\t\"debug/xcoff\"\n \t\"fmt\"\n \t\"go/types\"\n \t\"io\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"strings\"\n )\n \n@@ -66,11 +68,12 @@ const (\n \tgccgov2Magic    = \"v2;\\n\"\n \tgoimporterMagic = \"\\n$$ \"\n \tarchiveMagic    = \"!<ar\"\n+\taixbigafMagic   = \"<big\"\n )\n \n-// Opens the export data file at the given path. If this is an ELF file,\n+// Opens the export data file at the given path. If this is an object file,\n // searches for and opens the .go_export section. If this is an archive,\n-// reads the export data from the first member, which is assumed to be an ELF file.\n+// reads the export data from the first member, which is assumed to be an object file.\n // This is intended to replicate the logic in gofrontend.\n func openExportFile(fpath string) (reader io.ReadSeeker, closer io.Closer, err error) {\n \tf, err := os.Open(fpath)\n@@ -90,43 +93,58 @@ func openExportFile(fpath string) (reader io.ReadSeeker, closer io.Closer, err e\n \t\treturn\n \t}\n \n-\tvar elfreader io.ReaderAt\n+\tvar objreader io.ReaderAt\n \tswitch string(magic[:]) {\n \tcase gccgov1Magic, gccgov2Magic, goimporterMagic:\n \t\t// Raw export data.\n \t\treader = f\n \t\treturn\n \n-\tcase archiveMagic:\n+\tcase archiveMagic, aixbigafMagic:\n \t\t// TODO(pcc): Read the archive directly instead of using \"ar\".\n \t\tf.Close()\n \t\tcloser = nil\n \n \t\tcmd := exec.Command(\"ar\", \"p\", fpath)\n+\t\tif runtime.GOOS == \"aix\" && runtime.GOARCH == \"ppc64\" {\n+\t\t\t// AIX puts both 32-bit and 64-bit objects in the same archive.\n+\t\t\t// Tell the AIX \"ar\" command to only care about 64-bit objects.\n+\t\t\tcmd.Env = append(os.Environ(), \"OBJECT_MODE=64\")\n+\t\t}\n \t\tvar out []byte\n \t\tout, err = cmd.Output()\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n \n-\t\telfreader = bytes.NewReader(out)\n+\t\tobjreader = bytes.NewReader(out)\n \n \tdefault:\n-\t\telfreader = f\n+\t\tobjreader = f\n \t}\n \n-\tef, err := elf.NewFile(elfreader)\n-\tif err != nil {\n+\tef, err := elf.NewFile(objreader)\n+\tif err == nil {\n+\t\tsec := ef.Section(\".go_export\")\n+\t\tif sec == nil {\n+\t\t\terr = fmt.Errorf(\"%s: .go_export section not found\", fpath)\n+\t\t\treturn\n+\t\t}\n+\t\treader = sec.Open()\n \t\treturn\n \t}\n \n-\tsec := ef.Section(\".go_export\")\n-\tif sec == nil {\n-\t\terr = fmt.Errorf(\"%s: .go_export section not found\", fpath)\n+\txf, err := xcoff.NewFile(objreader)\n+\tif err == nil {\n+\t\tsdat := xf.CSect(\".go_export\")\n+\t\tif sdat == nil {\n+\t\t\terr = fmt.Errorf(\"%s: .go_export section not found\", fpath)\n+\t\t\treturn\n+\t\t}\n+\t\treader = bytes.NewReader(sdat)\n \t\treturn\n \t}\n \n-\treader = sec.Open()\n \treturn\n }\n "}]}