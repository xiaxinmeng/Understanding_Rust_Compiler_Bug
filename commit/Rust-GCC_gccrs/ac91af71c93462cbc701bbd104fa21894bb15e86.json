{"sha": "ac91af71c93462cbc701bbd104fa21894bb15e86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5MWFmNzFjOTM0NjJjYmM3MDFiYmQxMDRmYTIxODk0YmIxNWU4Ng==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-11-13T14:35:18Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-11-13T14:35:18Z"}, "message": "loops: Invoke lim after successful loop interchange\n\nThis patch makes the entry point to loop invariant motion public, so\nthat it can be called after loop interchange when that pass has\nswapped loops.  This avoids the non-LTO -Ofast run-time regressions of\n410.bwaves and 503.bwaves_r (which are 19% and 15% faster than current\nmaster on an AMD zen2 machine) while not introducing a full LIM pass\ninto the pass pipeline.\n\nThe patch also adds a parameter which allows not to perform any store\nmotion so that it is not done after an interchange.\n\ngcc/ChangeLog:\n\n2020-11-12  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/94406\n\t* tree-ssa-loop-im.c (tree_ssa_lim): Renamed to\n\tloop_invariant_motion_in_fun, added a parameter to control store\n\tmotion.\n\t(pass_lim::execute): Adjust call to tree_ssa_lim, now\n\tloop_invariant_motion_in_fun.\n\t* tree-ssa-loop-manip.h (loop_invariant_motion_in_fun): Declare.\n\t* gimple-loop-interchange.cc (pass_linterchange::execute): Call\n\tloop_invariant_motion_in_fun if any interchange has been done.", "tree": {"sha": "f627c99eee6a069a28488e7f4e33e08fdf7fe14f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f627c99eee6a069a28488e7f4e33e08fdf7fe14f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac91af71c93462cbc701bbd104fa21894bb15e86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac91af71c93462cbc701bbd104fa21894bb15e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac91af71c93462cbc701bbd104fa21894bb15e86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac91af71c93462cbc701bbd104fa21894bb15e86/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d6b8d4213376e8a2405782c7e360b03d4a2b04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6b8d4213376e8a2405782c7e360b03d4a2b04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6b8d4213376e8a2405782c7e360b03d4a2b04a"}], "stats": {"total": 23, "additions": 15, "deletions": 8}, "files": [{"sha": "a36dbb49b1fa1c59bf41b6feb6e96fe4d4125912", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac91af71c93462cbc701bbd104fa21894bb15e86/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac91af71c93462cbc701bbd104fa21894bb15e86/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=ac91af71c93462cbc701bbd104fa21894bb15e86", "patch": "@@ -2085,8 +2085,13 @@ pass_linterchange::execute (function *fun)\n     }\n \n   if (changed_p)\n-    scev_reset ();\n-  return changed_p ? (TODO_update_ssa_only_virtuals) : 0;\n+    {\n+      unsigned todo = TODO_update_ssa_only_virtuals;\n+      todo |= loop_invariant_motion_in_fun (cfun, false);\n+      scev_reset ();\n+      return todo;\n+    }\n+  return 0;\n }\n \n } // anon namespace"}, {"sha": "3c7412737f02e0d5b80bd26a5c33e5d18307718b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac91af71c93462cbc701bbd104fa21894bb15e86/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac91af71c93462cbc701bbd104fa21894bb15e86/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ac91af71c93462cbc701bbd104fa21894bb15e86", "patch": "@@ -3089,10 +3089,11 @@ tree_ssa_lim_finalize (void)\n }\n \n /* Moves invariants from loops.  Only \"expensive\" invariants are moved out --\n-   i.e. those that are likely to be win regardless of the register pressure.  */\n+   i.e. those that are likely to be win regardless of the register pressure.\n+   Only perform store motion if STORE_MOTION is true.  */\n \n-static unsigned int\n-tree_ssa_lim (function *fun)\n+unsigned int\n+loop_invariant_motion_in_fun (function *fun, bool store_motion)\n {\n   unsigned int todo = 0;\n \n@@ -3114,7 +3115,8 @@ tree_ssa_lim (function *fun)\n \n   /* Execute store motion.  Force the necessary invariants to be moved\n      out of the loops as well.  */\n-  do_store_motion ();\n+  if (store_motion)\n+    do_store_motion ();\n \n   free (rpo);\n   rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n@@ -3175,7 +3177,7 @@ pass_lim::execute (function *fun)\n \n   if (number_of_loops (fun) <= 1)\n     return 0;\n-  unsigned int todo = tree_ssa_lim (fun);\n+  unsigned int todo = loop_invariant_motion_in_fun (fun, true);\n \n   if (!in_loop_pipeline)\n     loop_optimizer_finalize ();"}, {"sha": "d8e918ef7c9177547e0287831c01b9c0968392a9", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac91af71c93462cbc701bbd104fa21894bb15e86/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac91af71c93462cbc701bbd104fa21894bb15e86/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=ac91af71c93462cbc701bbd104fa21894bb15e86", "patch": "@@ -55,7 +55,7 @@ extern void tree_transform_and_unroll_loop (class loop *, unsigned,\n extern void tree_unroll_loop (class loop *, unsigned,\n \t\t\t      edge, class tree_niter_desc *);\n extern tree canonicalize_loop_ivs (class loop *, tree *, bool);\n-\n+extern unsigned int loop_invariant_motion_in_fun (function *, bool);\n \n \n #endif /* GCC_TREE_SSA_LOOP_MANIP_H */"}]}