{"sha": "50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkMzJjZjY0YzdmMjYwNzEwOGExY2M4ZjJjMzE1ZTlhYjZiYWMwOQ==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2004-04-21T23:21:59Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2004-04-21T23:21:59Z"}, "message": "MIPS SB-1 DFA scheduler.\n\n* config/mips/mips-protos.h (fp_register_operand, lo_operand): Declare.\n* config/mips/mips.c (mips_multipass_dfa_lookahead): Declare.\n(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD): New.\n(fp_register_operand, lo_operand): New.\n(mips_rtx_costs): Add TUNE_SB1 support.\n(mips_issue_rate): Add comment.  Add PROCESSOR_SB1 support.\n(mips_use_dfa_pipeline_interface): Add PROCESSOR_SB1 support.\n(mips_multipass_dfa_lookahead): New.\n* config/mips/mips.h (MASK_FP_EXCEPTIONS, TARGET_FP_EXCEPTIONS,\nTUNE_SB1): New.\n(TARGET_SWITCHES): Add -mfp-exceptions support.\n(TARGET_FP_EXCEPTIONS_DEFAULT): New.\n(BRANCH_COST): Fix whitespace.\n* config/mips/mips.md: Include sb1.md.\n* config/mips/sb1.md: New file.\n* doc/invoke.texi: Document -mfp-exceptions.\n\nFrom-SVN: r80988", "tree": {"sha": "5cf9396ca05bbcaf40749be722dbfd67a385d142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cf9396ca05bbcaf40749be722dbfd67a385d142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/comments", "author": null, "committer": null, "parents": [{"sha": "e24e0aa7fb4a0e9bc5f6977be63bde9b57d9fce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24e0aa7fb4a0e9bc5f6977be63bde9b57d9fce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24e0aa7fb4a0e9bc5f6977be63bde9b57d9fce4"}], "stats": {"total": 617, "additions": 611, "deletions": 6}, "files": [{"sha": "9b22f4db7eed44712ff6f667e168a9bce08d0adf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -10,6 +10,23 @@\n \n 2004-04-21  James E Wilson  <wilson@specifixinc.com>\n \n+\t* config/mips/mips-protos.h (fp_register_operand, lo_operand): Declare.\n+\t* config/mips/mips.c (mips_multipass_dfa_lookahead): Declare.\n+\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD): New.\n+\t(fp_register_operand, lo_operand): New.\n+\t(mips_rtx_costs): Add TUNE_SB1 support.\n+\t(mips_issue_rate): Add comment.  Add PROCESSOR_SB1 support.\n+\t(mips_use_dfa_pipeline_interface): Add PROCESSOR_SB1 support.\n+\t(mips_multipass_dfa_lookahead): New.\n+\t* config/mips/mips.h (MASK_FP_EXCEPTIONS, TARGET_FP_EXCEPTIONS,\n+\tTUNE_SB1): New.\n+\t(TARGET_SWITCHES): Add -mfp-exceptions support.\n+\t(TARGET_FP_EXCEPTIONS_DEFAULT): New.\n+\t(BRANCH_COST): Fix whitespace.\n+\t* config/mips/mips.md: Include sb1.md.\n+\t* config/mips/sb1.md: New file.\n+\t* doc/invoke.texi: Document -mfp-exceptions.\n+\n \t* Makefile.in (fixinc.sh): Don't set or export WARN_CFLAGS.  Fix\n \tcomment.\n \t* fixinc/Makefile.in (FL_LIST): Don't mention WARN_CFLAGS."}, {"sha": "b8afafb0f6965543f3d9166d8c19b690b9738a53", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -93,6 +93,8 @@ extern int mips_address_insns (rtx, enum machine_mode);\n extern int mips_const_insns (rtx);\n extern int mips_fetch_insns (rtx);\n extern int mips_idiv_insns (void);\n+extern int fp_register_operand (rtx, enum machine_mode);\n+extern int lo_operand (rtx, enum machine_mode);\n extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);"}, {"sha": "69398c60a07708dd3bceb60b1969a9d70a5208c0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -232,6 +232,7 @@ static bool mips_return_in_memory (tree, tree);\n static bool mips_strict_argument_naming (CUMULATIVE_ARGS *);\n static int mips_issue_rate (void);\n static int mips_use_dfa_pipeline_interface (void);\n+static int mips_multipass_dfa_lookahead (void);\n static void mips_init_libfuncs (void);\n static void mips_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n@@ -680,6 +681,9 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_SCHED_ISSUE_RATE mips_issue_rate\n #undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE mips_use_dfa_pipeline_interface\n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n+  mips_multipass_dfa_lookahead\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL mips_function_ok_for_sibcall\n@@ -1661,6 +1665,23 @@ stack_operand (rtx op, enum machine_mode mode)\n \t  && addr.reg == stack_pointer_rtx);\n }\n \n+/* Helper function for DFA schedulers.  Return true if OP is a floating\n+   point register.  */\n+\n+int\n+fp_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return REG_P (op) && FP_REG_P (REGNO (op));\n+}\n+\n+/* Helper function for DFA schedulers.  Return true if OP is a LO reg.  */\n+\n+int\n+lo_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return REG_P (op) && REGNO (op) == LO_REGNUM;\n+}\n+\f\n \n /* This function is used to implement GO_IF_LEGITIMATE_ADDRESS.  It\n    returns a nonzero value if X is a legitimate address for a memory\n@@ -2265,6 +2286,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n             *total = COSTS_N_INSNS (2);\n           else if (TUNE_MIPS6000)\n             *total = COSTS_N_INSNS (3);\n+\t  else if (TUNE_SB1)\n+\t    *total = COSTS_N_INSNS (4);\n           else\n             *total = COSTS_N_INSNS (6);\n           return true;\n@@ -2289,7 +2312,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n         {\n           if (TUNE_MIPS3000\n               || TUNE_MIPS3900\n-              || TUNE_MIPS5000)\n+              || TUNE_MIPS5000\n+\t      || TUNE_SB1)\n             *total = COSTS_N_INSNS (4);\n           else if (TUNE_MIPS6000\n                    || TUNE_MIPS5400\n@@ -2302,7 +2326,9 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n       if (mode == DFmode)\n         {\n-          if (TUNE_MIPS3000\n+          if (TUNE_SB1)\n+\t    *total = COSTS_N_INSNS (4);\n+          else if (TUNE_MIPS3000\n               || TUNE_MIPS3900\n               || TUNE_MIPS5000)\n             *total = COSTS_N_INSNS (5);\n@@ -2319,7 +2345,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n         *total = COSTS_N_INSNS (12);\n       else if (TUNE_MIPS3900)\n         *total = COSTS_N_INSNS (2);\n-      else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n+      else if (TUNE_MIPS5400 || TUNE_MIPS5500 || TUNE_SB1)\n         *total = COSTS_N_INSNS ((mode == DImode) ? 4 : 3);\n       else if (TUNE_MIPS7000)\n         *total = COSTS_N_INSNS (mode == DImode ? 9 : 5);\n@@ -2342,6 +2368,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n             *total = COSTS_N_INSNS (12);\n           else if (TUNE_MIPS6000)\n             *total = COSTS_N_INSNS (15);\n+\t  else if (TUNE_SB1)\n+\t    *total = COSTS_N_INSNS (24);\n           else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n             *total = COSTS_N_INSNS (30);\n           else\n@@ -2358,6 +2386,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n             *total = COSTS_N_INSNS (59);\n           else if (TUNE_MIPS6000)\n             *total = COSTS_N_INSNS (16);\n+\t  else if (TUNE_SB1)\n+\t    *total = COSTS_N_INSNS (32);\n           else\n             *total = COSTS_N_INSNS (36);\n           return true;\n@@ -2373,6 +2403,8 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n         *total = COSTS_N_INSNS (38);\n       else if (TUNE_MIPS5000)\n         *total = COSTS_N_INSNS (36);\n+      else if (TUNE_SB1)\n+\t*total = COSTS_N_INSNS ((mode == SImode) ? 36 : 68);\n       else if (TUNE_MIPS5400 || TUNE_MIPS5500)\n         *total = COSTS_N_INSNS ((mode == SImode) ? 42 : 74);\n       else\n@@ -9292,6 +9324,8 @@ mips_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n {\n   return !TARGET_OLDABI;\n }\n+\f\n+/* Return the number of instructions that can be issued per cycle.  */\n \n static int\n mips_issue_rate (void)\n@@ -9304,6 +9338,13 @@ mips_issue_rate (void)\n     case PROCESSOR_R9000:\n       return 2;\n \n+    case PROCESSOR_SB1:\n+      /* This is actually 4, but we get better performance if we claim 3.\n+\t This is partly because of unwanted speculative code motion with the\n+\t larger number, and partly because in most common cases we can't\n+\t reach the theoretical max of 4.  */\n+      return 3;\n+\n     default:\n       return 1;\n     }\n@@ -9324,6 +9365,7 @@ mips_use_dfa_pipeline_interface (void)\n     case PROCESSOR_R5500:\n     case PROCESSOR_R7000:\n     case PROCESSOR_R9000:\n+    case PROCESSOR_SB1:\n     case PROCESSOR_SR71000:\n       return true;\n \n@@ -9332,6 +9374,19 @@ mips_use_dfa_pipeline_interface (void)\n     }\n }\n \n+/* Implements TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD.  This should\n+   be as wide as the scheduling freedom in the DFA.  */\n+\n+static int\n+mips_multipass_dfa_lookahead (void)\n+{\n+  /* Can schedule up to 4 of the 6 function units in any one cycle.  */\n+  if (mips_tune == PROCESSOR_SB1)\n+    return 4;\n+\n+  return 0;\n+}\n+\f\n \n const char *\n mips_emit_prefetch (rtx *operands)"}, {"sha": "0055828d9b612bf90fdfe363c9e0ec4e12314ec5", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -173,6 +173,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define MASK_FIX_SB1\t   0x04000000\t/* Work around SB-1 errata.  */\n #define MASK_FIX_VR4120\t   0x08000000   /* Work around VR4120 errata.  */\n \n+#define MASK_FP_EXCEPTIONS 0x10000000   /* FP exceptions are enabled.  */\n+\n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n #define MASK_DEBUG_C\t0\t\t/* don't expand seq, etc.  */\n@@ -257,6 +259,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TARGET_FIX_R4400\t(target_flags & MASK_FIX_R4400)\n #define TARGET_FIX_VR4120\t(target_flags & MASK_FIX_VR4120)\n \n+#define TARGET_FP_EXCEPTIONS\t(target_flags & MASK_FP_EXCEPTIONS)\n+\n /* True if we should use NewABI-style relocation operators for\n    symbolic addresses.  This is never true for mips16 code,\n    which has its own conventions.  */\n@@ -339,6 +343,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TUNE_MIPS6000               (mips_tune == PROCESSOR_R6000)\n #define TUNE_MIPS7000               (mips_tune == PROCESSOR_R7000)\n #define TUNE_MIPS9000               (mips_tune == PROCESSOR_R9000)\n+#define TUNE_SB1                    (mips_tune == PROCESSOR_SB1)\n \n #define TARGET_OLDABI\t\t    (mips_abi == ABI_32 || mips_abi == ABI_O64)\n #define TARGET_NEWABI\t\t    (mips_abi == ABI_N32 || mips_abi == ABI_64)\n@@ -630,6 +635,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Lift restrictions on GOT size\") },\t\t\t\t\\\n   {\"no-xgot\",\t\t -MASK_XGOT,\t\t\t\t\t\\\n      N_(\"Do not lift restrictions on GOT size\") },\t\t\t\\\n+  {\"fp-exceptions\",\t  MASK_FP_EXCEPTIONS,\t\t\t\t\\\n+     N_(\"FP exceptions are enabled\") },\t\t\t\t\t\\\n+  {\"no-fp-exceptions\", \t  -MASK_FP_EXCEPTIONS,\t\t\t\t\\\n+     N_(\"FP exceptions are not enabled\") },\t\t\t\t\\\n   {\"debug\",\t\t  MASK_DEBUG,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugc\",\t\t  MASK_DEBUG_C,\t\t\t\t\t\\\n@@ -640,7 +649,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"\",\t\t\t  (TARGET_DEFAULT\t\t\t\t\\\n \t\t\t   | TARGET_CPU_DEFAULT\t\t\t\t\\\n-\t\t\t   | TARGET_ENDIAN_DEFAULT),\t\t\t\\\n+\t\t\t   | TARGET_ENDIAN_DEFAULT\t\t\t\\\n+\t\t\t   | TARGET_FP_EXCEPTIONS_DEFAULT),\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n }\n \n@@ -658,6 +668,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TARGET_ENDIAN_DEFAULT MASK_BIG_ENDIAN\n #endif\n \n+#ifndef TARGET_FP_EXCEPTIONS_DEFAULT\n+#define TARGET_FP_EXCEPTIONS_DEFAULT MASK_FP_EXCEPTIONS\n+#endif\n+\n /* 'from-abi' makes a good default: you get whatever the ABI requires.  */\n #ifndef MIPS_ISA_DEFAULT\n #ifndef MIPS_CPU_STRING_DEFAULT\n@@ -2674,7 +2688,7 @@ typedef struct mips_args {\n /* ??? Fix this to be right for the R8000.  */\n #define BRANCH_COST\t\t\t\t\t\t\t\\\n   ((! TARGET_MIPS16\t\t\t\t\t\t\t\\\n-    && (TUNE_MIPS4000 || TUNE_MIPS6000))\t\\\n+    && (TUNE_MIPS4000 || TUNE_MIPS6000))\t\t\t\t\\\n    ? 2 : 1)\n \n /* If defined, modifies the length assigned to instruction INSN as a"}, {"sha": "5e31e55203f59447a85c767ae20a45b4ea576c47", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -628,6 +628,7 @@\n (include \"5500.md\")\n (include \"7000.md\")\n (include \"9000.md\")\n+(include \"sb1.md\")\n (include \"sr71k.md\")\n \f\n ;;"}, {"sha": "a58992be52548dd1b775bb1327165e79ee3c77b2", "filename": "gcc/config/mips/sb1.md", "status": "added", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fsb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fconfig%2Fmips%2Fsb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsb1.md?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -0,0 +1,504 @@\n+;;\n+;; DFA-based pipeline description for Broadcom SB-1\n+;;\n+\n+;; The Broadcom SB-1 core is 4-way superscalar, in-order.  It has 2 load/store\n+;; pipes (one of which can support some ALU operations), 2 alu pipes, 2 FP\n+;; pipes, and 1 MDMX pipes.  It can issue 2 ls insns and 2 exe/fpu/mdmx insns\n+;; each cycle.\n+\n+;; We model the 4-way issue by ordering unit choices.  The possible choices are\n+;; {ex1,fp1}|{ex0,fp0}|ls1|ls0.  Instructions issue to the first eligible unit\n+;; in the list in most cases.  Non-indexed load/stores issue to ls0 first.\n+;; simple alu operations issue to ls1 if it is still available, and their\n+;; operands are ready (no co-issue with loads), otherwise to the first\n+;; available ex unit.\n+\n+;; When exceptions are enabled, can only issue FP insns to fp1.  This is\n+;; to ensure that instructions complete in order.  The -mfp-exceptions option\n+;; can be used to specify whether the system has FP exceptions enabled or not.\n+\n+;; In 32-bit mode, dependent FP can't co-issue with load, and only one FP exe\n+;; insn can issue per cycle (fp1).\n+\n+;; The A1 MDMX pipe is separate from the FP pipes, but uses the same register\n+;; file.  As a result, once an MDMX insn is issued, no FP insns can be issued\n+;; for 3 cycles.  When an FP insn is issued, no MDMX insn can be issued for\n+;; 5 cycles.  This is currently not handled because there is no MDMX insn\n+;; support as yet.\n+\n+;;\n+;; We use two automata.  sb1_cpu_div is for the integer divides, which are\n+;; not pipelined.  sb1_cpu is for everything else.\n+;;\n+(define_automaton \"sb1_cpu, sb1_cpu_div\")\n+\n+;; Load/store function units.\n+(define_cpu_unit \"sb1_ls0\" \"sb1_cpu\")\n+(define_cpu_unit \"sb1_ls1\" \"sb1_cpu\")\n+\n+;; CPU function units.\n+(define_cpu_unit \"sb1_ex0\" \"sb1_cpu\")\n+(define_cpu_unit \"sb1_ex1\" \"sb1_cpu\")\n+\n+;; The divide unit is not pipelined, and blocks hi/lo reads and writes.\n+(define_cpu_unit \"sb1_div\" \"sb1_cpu_div\")\n+;; DMULT block any multiply from issuing in the next cycle.\n+(define_cpu_unit \"sb1_mul\" \"sb1_cpu\")\n+\n+;; Floating-point units.\n+(define_cpu_unit \"sb1_fp0\" \"sb1_cpu\")\n+(define_cpu_unit \"sb1_fp1\" \"sb1_cpu\")\n+\n+;; Can only issue to one of the ex and fp pipes at a time.\n+(exclusion_set \"sb1_ex0\" \"sb1_fp0\")\n+(exclusion_set \"sb1_ex1\" \"sb1_fp1\")\n+\n+;; Define an SB-1 specific attribute to simplify some FP descriptions.\n+;; We can use 2 FP pipes only if we have 64-bit FP code, and exceptions are\n+;; disabled.\n+\n+(define_attr \"sb1_fp_pipes\" \"one,two\"\n+  (cond [(and (ne (symbol_ref \"TARGET_FLOAT64\") (const_int 0))\n+\t      (eq (symbol_ref \"TARGET_FP_EXCEPTIONS\") (const_int 0)))\n+\t (const_string \"two\")]\n+\t(const_string \"one\")))\n+\n+;; Define reservations for common combinations.\n+\n+;; For long cycle operations, the FPU has a 4 cycle pipeline that repeats,\n+;; effectively re-issuing the operation every 4 cycles.  This means that we\n+;; can have at most 4 long-cycle operations per pipe.\n+\n+;; ??? The fdiv operations should be e.g.\n+;; sb1_fp1_4cycles*7\" | \"sb1_fp0_4cycle*7\n+;; but the DFA is too large when we do that.  Perhaps have to use scheduler\n+;; hooks here.\n+\n+;; ??? Try limiting scheduler to 2 long latency operations, and see if this\n+;; results in a usable DFA, and whether it helps code performance.\n+\n+;;(define_reservation \"sb1_fp0_4cycles\" \"sb1_fp0, nothing*3\")\n+;;(define_reservation \"sb1_fp1_4cycles\" \"sb1_fp1, nothing*3\")\n+\n+;;\n+;; The ordering of the instruction-execution-path/resource-usage\n+;; descriptions (also known as reservation RTL) is roughly ordered\n+;; based on the define attribute RTL for the \"type\" classification.\n+;; When modifying, remember that the first test that matches is the\n+;; reservation used!\n+;;\n+\n+(define_insn_reservation \"ir_sb1_unknown\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"unknown,multi\"))\n+  \"sb1_ls0+sb1_ls1+sb1_ex0+sb1_ex1+sb1_fp0+sb1_fp1\")\n+\n+;; predicted taken branch causes 2 cycle ifetch bubble.  predicted not\n+;; taken branch causes 0 cycle ifetch bubble.  mispredicted branch causes 8\n+;; cycle ifetch bubble.  We assume all branches predicted not taken.\n+\n+;; ??? This assumption that branches are predicated not taken should be\n+;; investigated.  Maybe using 2 here will give better results.\n+\n+(define_insn_reservation \"ir_sb1_branch\" 0\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"branch,jump,call\"))\n+  \"sb1_ex0\")\n+\n+;; ??? This is 1 cycle for ldl/ldr to ldl/ldr when they use the same data\n+;; register as destination.\n+\n+;; ??? Can co-issue a load with a dependent arith insn if it executes on an EX\n+;; unit.  Can not co-issue if the dependent insn executes on an LS unit.\n+\n+;; A load normally has a latency of zero cycles.  In some cases, dependent\n+;; insns can be issued in the same cycle.  However, a value of 1 gives\n+;; better performance in empirical testing.\n+\n+(define_insn_reservation \"ir_sb1_load\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"load,prefetch\"))\n+  \"sb1_ls0 | sb1_ls1\")\n+\n+;; Can not co-issue fpload with fp exe when in 32-bit mode.\n+\n+(define_insn_reservation \"ir_sb1_fpload\" 0\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fpload\")\n+\t    (ne (symbol_ref \"TARGET_FLOAT64\")\n+\t\t(const_int 0))))\n+  \"sb1_ls0 | sb1_ls1\")\n+\n+(define_insn_reservation \"ir_sb1_fpload_32bitfp\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fpload\")\n+\t    (eq (symbol_ref \"TARGET_FLOAT64\")\n+\t\t(const_int 0))))\n+  \"sb1_ls0 | sb1_ls1\")\n+\n+;; Indexed loads can only execute on LS1 pipe.\n+\n+(define_insn_reservation \"ir_sb1_fpidxload\" 0\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fpidxload\")\n+\t    (ne (symbol_ref \"TARGET_FLOAT64\")\n+\t\t(const_int 0))))\n+  \"sb1_ls1\")\n+\n+(define_insn_reservation \"ir_sb1_fpidxload_32bitfp\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fpidxload\")\n+\t    (eq (symbol_ref \"TARGET_FLOAT64\")\n+\t\t(const_int 0))))\n+  \"sb1_ls1\")\n+\n+;; prefx can only execute on the ls1 pipe.\n+\n+(define_insn_reservation \"ir_sb1_prefetchx\" 0\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"prefetchx\"))\n+  \"sb1_ls1\")\n+\n+;; ??? There is a 4.5 cycle latency if a store is followed by a load, and\n+;; there is a RAW dependency.\n+\n+(define_insn_reservation \"ir_sb1_store\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"store\"))\n+  \"sb1_ls0+sb1_ex1 | sb1_ls0+sb1_ex0 | sb1_ls1+sb1_ex1 | sb1_ls1+sb1_ex0\")\n+\n+(define_insn_reservation \"ir_sb1_fpstore\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"fpstore\"))\n+  \"sb1_ls0+sb1_fp1 | sb1_ls0+sb1_fp0 | sb1_ls1+sb1_fp1 | sb1_ls1+sb1_fp0\")\n+\n+;; Indexed stores can only execute on LS1 pipe.\n+\n+(define_insn_reservation \"ir_sb1_fpidxstore\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"fpidxstore\"))\n+  \"sb1_ls1+sb1_fp1 | sb1_ls1+sb1_fp0\")\n+\n+;; Load latencies are 3 cycles for one load to another load or store (address\n+;; only).  This is 0 cycles for one load to a store using it as the data\n+;; written.\n+\n+;; This assumes that if a load is dependent on a previous insn, then it must\n+;; be an address dependence.\n+\n+(define_bypass 3\n+  \"ir_sb1_load,ir_sb1_fpload,ir_sb1_fpload_32bitfp,ir_sb1_fpidxload,\n+   ir_sb1_fpidxload_32bitfp\"\n+  \"ir_sb1_load,ir_sb1_fpload,ir_sb1_fpload_32bitfp,ir_sb1_fpidxload,\n+   ir_sb1_fpidxload_32bitfp,ir_sb1_prefetchx\")\n+\n+(define_bypass 3\n+  \"ir_sb1_load,ir_sb1_fpload,ir_sb1_fpload_32bitfp,ir_sb1_fpidxload,\n+   ir_sb1_fpidxload_32bitfp\"\n+  \"ir_sb1_store,ir_sb1_fpstore,ir_sb1_fpidxstore\"\n+  \"store_data_bypass_p\")\n+\n+;; Simple alu instructions can execute on the LS1 unit.\n+\n+;; ??? A simple alu insn issued on an LS unit has 0 cycle latency to an EX\n+;; insn, to a store (for data), and to an xfer insn.  It has 1 cycle latency to\n+;; another LS insn (excluding store data).  A simple alu insn issued on an EX\n+;; unit has a latency of 5 cycles when the results goes to a LS unit (exluding\n+;; store data), otherwise a latency of 1 cycle.\n+\n+;; ??? We can not handle latencies properly for simple alu instructions\n+;; within the DFA pipeline model.  Latencies can be defined only from one\n+;; insn reservation to another.  We can't make them depend on which function\n+;; unit was used.  This isn't a DFA flaw.  There is a conflict here, as we\n+;; need to know the latency before we can determine which unit will be\n+;; available, but we need to know which unit it is issued to before we can\n+;; compute the latency.  Perhaps this can be handled via scheduler hooks.\n+;; This needs to be investigated.\n+\n+;; ??? Optimal scheduling taking the LS units into account seems to require\n+;; a pre-scheduling pass.  We need to determine which instructions feed results\n+;; into store/load addresses, and thus benefit most from being issued to the\n+;; LS unit.  Also, we need to prune the list to ensure we don't overschedule\n+;; insns to the LS unit, and that we don't conflict with insns that need LS1\n+;; such as indexed loads.  We then need to emit nops to ensure that simple\n+;; alu instructions that are not supposed to be scheduled to LS1 don't\n+;; accidentally end up there because LS1 is free when they are issued.  This\n+;; will be a lot of work, and it isn't clear how useful it will be.\n+\n+;; Empirical testing shows that 2 gives the best result.\n+\n+(define_insn_reservation \"ir_sb1_simple_alu\" 2\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"const,arith\"))\n+  \"sb1_ls1 | sb1_ex1 | sb1_ex0\")\n+\n+;; ??? condmove also includes some FP instructions that execute on the FP\n+;; units.  This needs to be clarified.\n+\n+(define_insn_reservation \"ir_sb1_alu\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"condmove,nop,shift\"))\n+  \"sb1_ex1 | sb1_ex0\")\n+\n+;; These are type arith/darith that only execute on the EX0 unit.\n+\n+(define_insn_reservation \"ir_sb1_alu_0\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"slt,clz,trap\"))\n+  \"sb1_ex0\")\n+\n+;; An alu insn issued on an EX unit has a latency of 5 cycles when the\n+;; result goes to a LS unit (excluding store data).\n+\n+;; This assumes that if a load is dependent on a previous insn, then it must\n+;; be an address dependence.\n+\n+(define_bypass 5\n+  \"ir_sb1_alu,ir_sb1_alu_0,ir_sb1_mfhi,ir_sb1_mflo\"\n+  \"ir_sb1_load,ir_sb1_fpload,ir_sb1_fpload_32bitfp,ir_sb1_fpidxload,\n+   ir_sb1_fpidxload_32bitfp,ir_sb1_prefetchx\")\n+\n+(define_bypass 5\n+  \"ir_sb1_alu,ir_sb1_alu_0,ir_sb1_mfhi,ir_sb1_mflo\"\n+  \"ir_sb1_store,ir_sb1_fpstore,ir_sb1_fpidxstore\"\n+  \"store_data_bypass_p\")\n+\n+;; mf{hi,lo} is 1 cycle.  \n+\n+(define_insn_reservation \"ir_sb1_mfhi\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"mfhilo\")\n+\t    (not (match_operand 1 \"lo_operand\" \"\"))))\n+  \"sb1_ex1\")\n+\n+(define_insn_reservation \"ir_sb1_mflo\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"mfhilo\")\n+\t    (match_operand 1 \"lo_operand\" \"\")))\n+  \"sb1_ex1\")\n+\n+;; mt{hi,lo} to mul/div is 4 cycles.\n+\n+(define_insn_reservation \"ir_sb1_mthilo\" 4\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"mthilo\"))\n+  \"sb1_ex1\")\n+\n+;; mt{hi,lo} to mf{hi,lo} is 3 cycles.\n+\n+(define_bypass 3 \"ir_sb1_mthilo\" \"ir_sb1_mfhi,ir_sb1_mflo\")\n+\n+;; multiply latency to an EX operation is 3 cycles.\n+\n+;; ??? Should check whether we need to make multiply conflict with moves\n+;; to/from hilo registers.\n+\n+(define_insn_reservation \"ir_sb1_mulsi\" 3\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"imul,imadd\")\n+\t    (eq_attr \"mode\" \"SI\")))\n+  \"sb1_ex1+sb1_mul\")\n+\n+;; muldi to mfhi is 4 cycles.\n+;; Blocks any other multiply insn issue for 1 cycle.\n+\n+(define_insn_reservation \"ir_sb1_muldi\" 4\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"mode\" \"DI\")))\n+  \"sb1_ex1+sb1_mul, sb1_mul\")\n+\n+;; muldi to mflo is 3 cycles.\n+\n+(define_bypass 3 \"ir_sb1_muldi\" \"ir_sb1_mflo\")\n+\n+;;  mul latency is 7 cycles if the result is used by any LS insn.\n+\n+;; This assumes that if a load is dependent on a previous insn, then it must\n+;; be an address dependence.\n+\n+(define_bypass 7\n+  \"ir_sb1_mulsi,ir_sb1_muldi\"\n+  \"ir_sb1_load,ir_sb1_fpload,ir_sb1_fpload_32bitfp,ir_sb1_fpidxload,\n+   ir_sb1_fpidxload_32bitfp,ir_sb1_prefetchx\")\n+\n+(define_bypass 7\n+  \"ir_sb1_mulsi,ir_sb1_muldi\"\n+  \"ir_sb1_store,ir_sb1_fpstore,ir_sb1_fpidxstore\"\n+  \"store_data_bypass_p\")\n+\n+;; The divide unit is not pipelined.  Divide busy is asserted in the 4th\n+;; cycle, and then deasserted on the latency cycle.  So only one divide at\n+;; a time, but the first/last 4 cycles can overlap.\n+\n+;; ??? All divides block writes to hi/lo regs.  hi/lo regs are written 4 cycles\n+;; after the latency cycle for divides (e.g. 40/72).  dmult writes lo in\n+;; cycle 7, and hi in cycle 8.  All other insns write hi/lo regs in cycle 7.\n+;; Default for output dependencies is the difference in latencies, which is\n+;; only 1 cycle off here, e.g. div to mtlo stalls for 32 cycles, but should\n+;; stall for 33 cycles.  This does not seem significant enough to worry about.\n+\n+(define_insn_reservation \"ir_sb1_divsi\" 36\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"idiv\")\n+\t    (eq_attr \"mode\" \"SI\")))\n+  \"sb1_ex1, nothing*3, sb1_div*32\")\n+\n+(define_insn_reservation \"ir_sb1_divdi\" 68\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"idiv\")\n+\t    (eq_attr \"mode\" \"DI\")))\n+  \"sb1_ex1, nothing*3, sb1_div*64\")\n+\n+(define_insn_reservation \"ir_sb1_fpu_2pipes\" 4\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fmove,fadd,fmul,fabs,fneg,fcvt\")\n+\t    (eq_attr \"sb1_fp_pipes\" \"two\")))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_fpu_1pipe\" 4\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fmove,fadd,fmul,fabs,fneg,fcvt\")\n+\t    (eq_attr \"sb1_fp_pipes\" \"one\")))\n+  \"sb1_fp1\")\n+\n+;; ??? madd/msub 4-cycle latency to itself (same fr?), but 8 cycle latency\n+;; otherwise.\n+\n+;; ??? Blocks issue of another non-madd/msub after 4 cycles.\n+\n+(define_insn_reservation \"ir_sb1_fmadd_2pipes\" 8\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fmadd\")\n+\t    (eq_attr \"sb1_fp_pipes\" \"two\")))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_fmadd_1pipe\" 8\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fmadd\")\n+\t    (eq_attr \"sb1_fp_pipes\" \"one\")))\n+  \"sb1_fp1\")\n+\n+(define_insn_reservation \"ir_sb1_fcmp\" 4\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (eq_attr \"type\" \"fcmp\"))\n+  \"sb1_fp1\")\n+\n+;; mtc1 latency 5 cycles.\n+\n+(define_insn_reservation \"ir_sb1_mtxfer\" 5\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"xfer\")\n+\t    (match_operand 0 \"fp_register_operand\" \"\")))\n+  \"sb1_fp0\")\n+\n+;; mfc1 latency 1 cycle.  \n+\n+(define_insn_reservation \"ir_sb1_mfxfer\" 1\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"xfer\")\n+\t    (not (match_operand 0 \"fp_register_operand\" \"\"))))\n+  \"sb1_fp0\")\n+\n+;; ??? Can deliver at most 1 result per every 6 cycles because of issue\n+;; restrictions.\n+\n+(define_insn_reservation \"ir_sb1_divsf_2pipes\" 24\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"two\"))))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_divsf_1pipes\" 24\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"one\"))))\n+  \"sb1_fp1\")\n+\n+;; ??? Can deliver at most 1 result per every 8 cycles because of issue\n+;; restrictions.\n+\n+(define_insn_reservation \"ir_sb1_divdf_2pipes\" 32\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"two\"))))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_divdf_1pipe\" 32\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"one\"))))\n+  \"sb1_fp1\")\n+\n+;; ??? Can deliver at most 1 result per every 7 cycles because of issue\n+;; restrictions.\n+\n+(define_insn_reservation \"ir_sb1_sqrtsf_2pipes\" 28\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"two\"))))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_sqrtsf_1pipe\" 28\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"one\"))))\n+  \"sb1_fp1\")\n+\n+;; ??? Can deliver at most 1 result per every 10 cycles because of issue\n+;; restrictions.\n+\n+(define_insn_reservation \"ir_sb1_sqrtdf_2pipes\" 40\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (and (eq_attr \"mode\" \"DF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"two\"))))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_sqrtdf_1pipe\" 40\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (and (eq_attr \"mode\" \"DF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"one\"))))\n+  \"sb1_fp1\")\n+\n+;; ??? Can deliver at most 1 result per every 4 cycles because of issue\n+;; restrictions.\n+\n+(define_insn_reservation \"ir_sb1_rsqrtsf_2pipes\" 16\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"frsqrt\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"two\"))))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_rsqrtsf_1pipe\" 16\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"frsqrt\")\n+\t    (and (eq_attr \"mode\" \"SF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"one\"))))\n+  \"sb1_fp1\")\n+\n+;; ??? Can deliver at most 1 result per every 7 cycles because of issue\n+;; restrictions.\n+\n+(define_insn_reservation \"ir_sb1_rsqrtdf_2pipes\" 28\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"frsqrt\")\n+\t    (and (eq_attr \"mode\" \"DF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"two\"))))\n+  \"sb1_fp1 | sb1_fp0\")\n+\n+(define_insn_reservation \"ir_sb1_rsqrtdf_1pipe\" 28\n+  (and (eq_attr \"cpu\" \"sb1\")\n+       (and (eq_attr \"type\" \"frsqrt\")\n+\t    (and (eq_attr \"mode\" \"DF\")\n+\t\t (eq_attr \"sb1_fp_pipes\" \"one\"))))\n+  \"sb1_fp1\")"}, {"sha": "797efdc048da428fccb9981123b3366e0e72c82a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d32cf64c7f2607108a1cc8f2c315e9ab6bac09/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=50d32cf64c7f2607108a1cc8f2c315e9ab6bac09", "patch": "@@ -482,7 +482,8 @@ in the following sections.\n -mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 @gol\n -mfix-vr4120  -mno-fix-vr4120  -mfix-sb1  -mno-fix-sb1 @gol\n -mflush-func=@var{func}  -mno-flush-func @gol\n--mbranch-likely  -mno-branch-likely}\n+-mbranch-likely  -mno-branch-likely @gol\n+-mfp-exceptions -mno-fp-exceptions}\n \n @emph{i386 and x86-64 Options}\n @gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol\n@@ -8178,6 +8179,17 @@ architecture.  An exception is for the MIPS32 and MIPS64 architectures\n and processors which implement those architectures; for those, Branch\n Likely instructions will not be generated by default because the MIPS32\n and MIPS64 architectures specifically deprecate their use.\n+\n+@item -mfp-exceptions\n+@itemx -mno-fp-exceptions\n+@opindex mfp-exceptions\n+Specifies whether FP exceptions are enabled.  This affects how we schedule\n+FP instructions for some processors.  The default is that FP exceptions are\n+enabled.\n+\n+For instance, on the SB-1, if FP exceptions are disabled, and we are emitting\n+64-bit code, then we can use both FP pipes.  Otherwise, we can only use one\n+FP pipe.\n @end table\n \n @node i386 and x86-64 Options"}]}