{"sha": "8dcfef8f2b2ad81873c1d2bb55182125e3190557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjZmVmOGYyYjJhZDgxODczYzFkMmJiNTUxODIxMjVlMzE5MDU1Nw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-12-22T03:49:00Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2010-12-22T03:49:00Z"}, "message": "re PR debug/46724 (Wrong debug info: Invalid variable location)\n\nPR debug/46724\n* function.c (assign_parms_augmented_arg_list): Name and mark\nDECL of result address as NAMELESS rather than IGNORED.\n(assign_parms): Set DECL_VALUE_EXPR for indirect result.\n* tree.h (tree_decl_common::decl_flag_2): Document RESULT_DECL.\n(DECL_HAS_VALUE_EXPR_P): Accept RESULT_DECL.\n* dwarf2out.c (loc_list_from_tree) <RESULT_DECL>: Use\nDECL_VALUE_EXPR.\n* dbxout.c (dbxout_expand_expr) <RESULT_DECL>: Likewise.\n* var-tracking.c (vt_add_function_parameter): New, split out of...\n(vt_add_function_parameters): ... this.  Handle incoming\npointer to hold result.\n\nFrom-SVN: r168160", "tree": {"sha": "acd635446a64407453a2f7688ccccc3c965f09f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acd635446a64407453a2f7688ccccc3c965f09f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dcfef8f2b2ad81873c1d2bb55182125e3190557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcfef8f2b2ad81873c1d2bb55182125e3190557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dcfef8f2b2ad81873c1d2bb55182125e3190557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcfef8f2b2ad81873c1d2bb55182125e3190557/comments", "author": null, "committer": null, "parents": [{"sha": "16a9afdc664f58ab8ad5e4bd2468cda18375d121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a9afdc664f58ab8ad5e4bd2468cda18375d121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a9afdc664f58ab8ad5e4bd2468cda18375d121"}], "stats": {"total": 240, "additions": 142, "deletions": 98}, "files": [{"sha": "fed571d55e7017b6360a1b9d23f6cabbd479bc2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dcfef8f2b2ad81873c1d2bb55182125e3190557", "patch": "@@ -1,3 +1,18 @@\n+2010-12-22  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/46724\n+\t* function.c (assign_parms_augmented_arg_list): Name and mark\n+\tDECL of result address as NAMELESS rather than IGNORED.\n+\t(assign_parms): Set DECL_VALUE_EXPR for indirect result.\n+\t* tree.h (tree_decl_common::decl_flag_2): Document RESULT_DECL.\n+\t(DECL_HAS_VALUE_EXPR_P): Accept RESULT_DECL.\n+\t* dwarf2out.c (loc_list_from_tree) <RESULT_DECL>: Use\n+\tDECL_VALUE_EXPR.\n+\t* dbxout.c (dbxout_expand_expr) <RESULT_DECL>: Likewise.\n+\t* var-tracking.c (vt_add_function_parameter): New, split out of...\n+\t(vt_add_function_parameters): ... this.  Handle incoming\n+\tpointer to hold result.\n+\n 2010-12-22  Jie Zhang  <jie@codesourcery.com>\n \n \t* config/arm/arm.c (output_move_double): Update the comment"}, {"sha": "3b0cf342f5efd37e2cd466b30675af6b93523060", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=8dcfef8f2b2ad81873c1d2bb55182125e3190557", "patch": "@@ -2396,12 +2396,12 @@ dbxout_expand_expr (tree expr)\n       /* FALLTHRU */\n \n     case PARM_DECL:\n+    case RESULT_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (expr))\n \treturn dbxout_expand_expr (DECL_VALUE_EXPR (expr));\n       /* FALLTHRU */\n \n     case CONST_DECL:\n-    case RESULT_DECL:\n       return DECL_RTL_IF_SET (expr);\n \n     case INTEGER_CST:"}, {"sha": "bc218752ddf6bfa9db435772f853267640f2c910", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8dcfef8f2b2ad81873c1d2bb55182125e3190557", "patch": "@@ -15446,12 +15446,12 @@ loc_list_from_tree (tree loc, int want_address)\n       /* FALLTHRU */\n \n     case PARM_DECL:\n+    case RESULT_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (loc))\n \treturn loc_list_from_tree (DECL_VALUE_EXPR (loc),\n \t\t\t\t   want_address);\n       /* FALLTHRU */\n \n-    case RESULT_DECL:\n     case FUNCTION_DECL:\n       {\n \trtx rtl;"}, {"sha": "0c4d5f82464d75584c5234c8bab945cc71426317", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8dcfef8f2b2ad81873c1d2bb55182125e3190557", "patch": "@@ -2253,10 +2253,11 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n       tree decl;\n \n       decl = build_decl (DECL_SOURCE_LOCATION (fndecl),\n-\t\t\t PARM_DECL, NULL_TREE, type);\n+\t\t\t PARM_DECL, get_identifier (\".result_ptr\"), type);\n       DECL_ARG_TYPE (decl) = type;\n       DECL_ARTIFICIAL (decl) = 1;\n-      DECL_IGNORED_P (decl) = 1;\n+      DECL_NAMELESS (decl) = 1;\n+      TREE_CONSTANT (decl) = 1;\n \n       DECL_CHAIN (decl) = all->orig_fnargs;\n       all->orig_fnargs = decl;\n@@ -3418,13 +3419,22 @@ assign_parms (tree fndecl)\n       rtx x;\n \n       if (DECL_BY_REFERENCE (result))\n-\tx = addr;\n+\t{\n+\t  SET_DECL_VALUE_EXPR (result, all.function_result_decl);\n+\t  x = addr;\n+\t}\n       else\n \t{\n+\t  SET_DECL_VALUE_EXPR (result,\n+\t\t\t       build1 (INDIRECT_REF, TREE_TYPE (result),\n+\t\t\t\t       all.function_result_decl));\n \t  addr = convert_memory_address (Pmode, addr);\n \t  x = gen_rtx_MEM (DECL_MODE (result), addr);\n \t  set_mem_attributes (x, result, 1);\n \t}\n+\n+      DECL_HAS_VALUE_EXPR_P (result) = 1;\n+\n       SET_DECL_RTL (result, x);\n     }\n "}, {"sha": "216f3d27ff01ab31295cbbc93da39d4b6c82e05f", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8dcfef8f2b2ad81873c1d2bb55182125e3190557", "patch": "@@ -2773,7 +2773,8 @@ struct GTY(()) tree_decl_common {\n      In TYPE_DECL, this is TYPE_DECL_SUPPRESS_DEBUG.  */\n   unsigned decl_flag_1 : 1;\n   /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P\n-     In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR_P.  */\n+     In VAR_DECL, PARM_DECL and RESULT_DECL, this is\n+     DECL_HAS_VALUE_EXPR_P.  */\n   unsigned decl_flag_2 : 1;\n   /* Logically, these two would go in a theoretical base shared by var and\n      parm decl. */\n@@ -2818,7 +2819,8 @@ extern void decl_value_expr_insert (tree, tree);\n    decl itself.  This should only be used for debugging; once this field has\n    been set, the decl itself may not legitimately appear in the function.  */\n #define DECL_HAS_VALUE_EXPR_P(NODE) \\\n-  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_2)\n+  (TREE_CHECK3 (NODE, VAR_DECL, PARM_DECL, RESULT_DECL) \\\n+   ->decl_common.decl_flag_2)\n #define DECL_VALUE_EXPR(NODE) \\\n   (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE)))\n #define SET_DECL_VALUE_EXPR(NODE, VAL) \\"}, {"sha": "58dce1b654eba6d0055bebedab5b51503bd1f023", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 108, "deletions": 91, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcfef8f2b2ad81873c1d2bb55182125e3190557/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=8dcfef8f2b2ad81873c1d2bb55182125e3190557", "patch": "@@ -7999,121 +7999,138 @@ vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n   return false;\n }\n \n-/* Insert function parameters to IN and OUT sets of ENTRY_BLOCK.  */\n+/* Insert function parameter PARM in IN and OUT sets of ENTRY_BLOCK.  */\n \n static void\n-vt_add_function_parameters (void)\n+vt_add_function_parameter (tree parm)\n {\n-  tree parm;\n-\n-  for (parm = DECL_ARGUMENTS (current_function_decl);\n-       parm; parm = DECL_CHAIN (parm))\n-    {\n-      rtx decl_rtl = DECL_RTL_IF_SET (parm);\n-      rtx incoming = DECL_INCOMING_RTL (parm);\n-      tree decl;\n-      enum machine_mode mode;\n-      HOST_WIDE_INT offset;\n-      dataflow_set *out;\n-      decl_or_value dv;\n-\n-      if (TREE_CODE (parm) != PARM_DECL)\n-\tcontinue;\n+  rtx decl_rtl = DECL_RTL_IF_SET (parm);\n+  rtx incoming = DECL_INCOMING_RTL (parm);\n+  tree decl;\n+  enum machine_mode mode;\n+  HOST_WIDE_INT offset;\n+  dataflow_set *out;\n+  decl_or_value dv;\n \n-      if (!DECL_NAME (parm))\n-\tcontinue;\n+  if (TREE_CODE (parm) != PARM_DECL)\n+    return;\n \n-      if (!decl_rtl || !incoming)\n-\tcontinue;\n+  if (!decl_rtl || !incoming)\n+    return;\n \n-      if (GET_MODE (decl_rtl) == BLKmode || GET_MODE (incoming) == BLKmode)\n-\tcontinue;\n+  if (GET_MODE (decl_rtl) == BLKmode || GET_MODE (incoming) == BLKmode)\n+    return;\n \n-      if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n+  if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n+    {\n+      if (REG_P (incoming) || MEM_P (incoming))\n \t{\n-\t  if (REG_P (incoming) || MEM_P (incoming))\n-\t    {\n-\t      /* This means argument is passed by invisible reference.  */\n-\t      offset = 0;\n-\t      decl = parm;\n-\t      incoming = gen_rtx_MEM (GET_MODE (decl_rtl), incoming);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (!vt_get_decl_and_offset (decl_rtl, &decl, &offset))\n-\t\tcontinue;\n-\t      offset += byte_lowpart_offset (GET_MODE (incoming),\n-\t\t\t\t\t     GET_MODE (decl_rtl));\n-\t    }\n+\t  /* This means argument is passed by invisible reference.  */\n+\t  offset = 0;\n+\t  decl = parm;\n+\t  incoming = gen_rtx_MEM (GET_MODE (decl_rtl), incoming);\n \t}\n-\n-      if (!decl)\n-\tcontinue;\n-\n-      if (parm != decl)\n+      else\n \t{\n-\t  /* Assume that DECL_RTL was a pseudo that got spilled to\n-\t     memory.  The spill slot sharing code will force the\n-\t     memory to reference spill_slot_decl (%sfp), so we don't\n-\t     match above.  That's ok, the pseudo must have referenced\n-\t     the entire parameter, so just reset OFFSET.  */\n-\t  gcc_assert (decl == get_spill_slot_decl (false));\n-\t  offset = 0;\n+\t  if (!vt_get_decl_and_offset (decl_rtl, &decl, &offset))\n+\t    return;\n+\t  offset += byte_lowpart_offset (GET_MODE (incoming),\n+\t\t\t\t\t GET_MODE (decl_rtl));\n \t}\n+    }\n \n-      if (!track_loc_p (incoming, parm, offset, false, &mode, &offset))\n-\tcontinue;\n+  if (!decl)\n+    return;\n+\n+  if (parm != decl)\n+    {\n+      /* Assume that DECL_RTL was a pseudo that got spilled to\n+\t memory.  The spill slot sharing code will force the\n+\t memory to reference spill_slot_decl (%sfp), so we don't\n+\t match above.  That's ok, the pseudo must have referenced\n+\t the entire parameter, so just reset OFFSET.  */\n+      gcc_assert (decl == get_spill_slot_decl (false));\n+      offset = 0;\n+    }\n \n-      out = &VTI (ENTRY_BLOCK_PTR)->out;\n+  if (!track_loc_p (incoming, parm, offset, false, &mode, &offset))\n+    return;\n \n-      dv = dv_from_decl (parm);\n+  out = &VTI (ENTRY_BLOCK_PTR)->out;\n \n-      if (target_for_debug_bind (parm)\n-\t  /* We can't deal with these right now, because this kind of\n-\t     variable is single-part.  ??? We could handle parallels\n-\t     that describe multiple locations for the same single\n-\t     value, but ATM we don't.  */\n-\t  && GET_CODE (incoming) != PARALLEL)\n-\t{\n-\t  cselib_val *val;\n+  dv = dv_from_decl (parm);\n \n-\t  /* ??? We shouldn't ever hit this, but it may happen because\n-\t     arguments passed by invisible reference aren't dealt with\n-\t     above: incoming-rtl will have Pmode rather than the\n-\t     expected mode for the type.  */\n-\t  if (offset)\n-\t    continue;\n+  if (target_for_debug_bind (parm)\n+      /* We can't deal with these right now, because this kind of\n+\t variable is single-part.  ??? We could handle parallels\n+\t that describe multiple locations for the same single\n+\t value, but ATM we don't.  */\n+      && GET_CODE (incoming) != PARALLEL)\n+    {\n+      cselib_val *val;\n \n-\t  val = cselib_lookup (var_lowpart (mode, incoming), mode, true);\n+      /* ??? We shouldn't ever hit this, but it may happen because\n+\t arguments passed by invisible reference aren't dealt with\n+\t above: incoming-rtl will have Pmode rather than the\n+\t expected mode for the type.  */\n+      if (offset)\n+\treturn;\n \n-\t  /* ??? Float-typed values in memory are not handled by\n-\t     cselib.  */\n-\t  if (val)\n-\t    {\n-\t      preserve_value (val);\n-\t      set_variable_part (out, val->val_rtx, dv, offset,\n-\t\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n-\t      dv = dv_from_value (val->val_rtx);\n-\t    }\n-\t}\n+      val = cselib_lookup (var_lowpart (mode, incoming), mode, true);\n \n-      if (REG_P (incoming))\n+      /* ??? Float-typed values in memory are not handled by\n+\t cselib.  */\n+      if (val)\n \t{\n-\t  incoming = var_lowpart (mode, incoming);\n-\t  gcc_assert (REGNO (incoming) < FIRST_PSEUDO_REGISTER);\n-\t  attrs_list_insert (&out->regs[REGNO (incoming)], dv, offset,\n-\t\t\t     incoming);\n-\t  set_variable_part (out, incoming, dv, offset,\n-\t\t\t     VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n-\t}\n-      else if (MEM_P (incoming))\n-\t{\n-\t  incoming = var_lowpart (mode, incoming);\n-\t  set_variable_part (out, incoming, dv, offset,\n+\t  preserve_value (val);\n+\t  set_variable_part (out, val->val_rtx, dv, offset,\n \t\t\t     VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n+\t  dv = dv_from_value (val->val_rtx);\n \t}\n     }\n \n+  if (REG_P (incoming))\n+    {\n+      incoming = var_lowpart (mode, incoming);\n+      gcc_assert (REGNO (incoming) < FIRST_PSEUDO_REGISTER);\n+      attrs_list_insert (&out->regs[REGNO (incoming)], dv, offset,\n+\t\t\t incoming);\n+      set_variable_part (out, incoming, dv, offset,\n+\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n+    }\n+  else if (MEM_P (incoming))\n+    {\n+      incoming = var_lowpart (mode, incoming);\n+      set_variable_part (out, incoming, dv, offset,\n+\t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n+    }\n+}\n+\n+/* Insert function parameters to IN and OUT sets of ENTRY_BLOCK.  */\n+\n+static void\n+vt_add_function_parameters (void)\n+{\n+  tree parm;\n+\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm; parm = DECL_CHAIN (parm))\n+    vt_add_function_parameter (parm);\n+\n+  if (DECL_HAS_VALUE_EXPR_P (DECL_RESULT (current_function_decl)))\n+    {\n+      tree vexpr = DECL_VALUE_EXPR (DECL_RESULT (current_function_decl));\n+\n+      if (TREE_CODE (vexpr) == INDIRECT_REF)\n+\tvexpr = TREE_OPERAND (vexpr, 0);\n+\n+      if (TREE_CODE (vexpr) == PARM_DECL\n+\t  && DECL_ARTIFICIAL (vexpr)\n+\t  && !DECL_IGNORED_P (vexpr)\n+\t  && DECL_NAMELESS (vexpr))\n+\tvt_add_function_parameter (vexpr);\n+    }\n+\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       cselib_preserve_only_values ();"}]}