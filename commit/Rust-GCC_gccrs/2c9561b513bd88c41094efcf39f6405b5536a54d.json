{"sha": "2c9561b513bd88c41094efcf39f6405b5536a54d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5NTYxYjUxM2JkODhjNDEwOTRlZmNmMzlmNjQwNWI1NTM2YTU0ZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-11-07T15:55:54Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-11-07T15:55:54Z"}, "message": "re PR tree-optimization/53787 (Possible IPA-SRA / IPA-CP improvement)\n\n2012-11-07  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/53787\n\t* ipa-cp.c (ipcp_value_source): New field offset.\n\t(ipcp_agg_lattice): New type.\n\t(ipcp_param_lattices): Likewise, move virt_call from ipcp_lattice here.\n\t(ipcp_agg_lattice_pool): New variable.\n\t(ipa_get_parm_lattices): New function.\n\t(ipa_get_lattice): Turned into ipa_get_scalar_lat, use the above.\n\tAdjusted all callers.\n\t(print_lattice): New function.\n\t(print_all_lattices): Use the above, also print aggregate lattices.\n\t(set_agg_lats_to_bottom): New function.\n\t(set_agg_lats_contain_variable): Likewise.\n\t(set_all_contains_variable): Likewise.\n\t(initialize_node_lattices): Also handle aggregate lattices, set\n\tvirt_call in ipcp_param_lattices.\n\t(add_value_source): Handle offsets.\n\t(add_value_to_lattice): Likewise.\n\t(add_scalar_value_to_lattice): New function.\n\t(propagate_vals_accross_pass_through): Use add_scalar_value_to_lattice.\n\t(propagate_vals_accross_ancestor): Likewise.\n\t(propagate_accross_jump_function): Renamed to\n\tpropagate_scalar_accross_jump_function, use\n\tadd_scalar_value_to_lattice.\n\t(set_check_aggs_by_ref): New function.\n\t(merge_agg_lats_step): Likewise.\n\t(set_chain_of_aglats_contains_variable): Likewise.\n\t(merge_aggregate_lattices): Likewise.\n\t(propagate_constants_accross_call): Also handle aggregate lattices.\n\t(hint_time_bonus): New function.\n\t(context_independent_aggregate_values): Likewise.\n\t(gather_context_independent_values): Also handle agggregate values.\n\t(agg_jmp_p_vec_for_t_vec): New function.\n\t(estimate_local_effects): Also handle agggregate values.\n\t(add_all_node_vals_to_toposort): Likewise.\n\t(ipcp_propagate_stage): Use struct ipcp_param_lattices.\n\t(get_clone_agg_value): New function.\n\t(cgraph_edge_brings_value_p): Also handle agggregate values.\n\t(create_specialized_node): Likewise.\n\t(find_more_values_for_callers_subset): Rename to\n\tfind_more_scalar_values_for_callers_subset.  Modify dump.\n\t(copy_plats_to_inter): New function.\n\t(intersect_with_plats): Likewise.\n\t(agg_replacements_to_vector): Likewise.\n\t(intersect_with_agg_replacements): Likewise.\n\t(find_aggregate_values_for_callers_subset): Likewise.\n\t(known_aggs_to_agg_replacement_list): Likewise.\n\t(cgraph_edge_brings_all_scalars_for_node): Likewise.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Likewise.\n\t(perhaps_add_new_callers): Old functionality moved to\n\tcgraph_edge_brings_all_scalars_for_node, call it and\n\tcgraph_edge_brings_all_agg_vals_for_node.\n\t(ipcp_val_in_agg_replacements_p): New function.\n\t(decide_about_value): New function.\n\t(decide_whether_version_node): A lot of functionality moved to\n\tdecide_about_value.  Also handle agggregate values.\n\t(ipcp_driver): Also allocate ipcp_agg_lattice_pool.\n\t(pass_ipa_cp): Fill in new entries.\n\t* ipa-prop.c (ipa_node_agg_replacements): New variable.\n\t(free_parms_ainfo): New function.\n\t(ipa_analyze_node): Use free_parms_ainfo to free stuff.\n\t(ipa_find_agg_cst_for_param): Do not rely on offset ordering.\n\t(ipa_set_node_agg_value_chain): New function.\n\t(ipa_node_removal_hook): Also handle ipa_node_agg_replacements.\n\t(ipa_node_duplication_hook): Likewise.\n\t(ipa_free_all_structures_after_ipa_cp): Also free ipcp_agg_lattice_pool.\n\t(ipa_free_all_structures_after_iinln): Likewise.\n\t(ipa_dump_agg_replacement_values): New function.\n\t(write_agg_replacement_chain): Likewise.\n\t(read_agg_replacement_chain): Likewise.\n\t(ipa_prop_write_all_agg_replacement): Likewise.\n\t(read_replacements_section): Likewise.\n\t(ipa_prop_read_all_agg_replacement): Likewise.\n\t(adjust_agg_replacement_values): Likewise.\n\t(ipcp_transform_function): Likewise.\n\t* ipa-prop.h: Also define heap vector of ipa_agg_jf_item_t and of\n\tipa_agg_jump_function_t.\n\t(ipa_node_params): Make lattices an array of ipcp_param_lattices.\n\t(ipa_agg_replacement_value): New type and its vector.\n\t(ipa_set_node_agg_value_chain) Declare.\n\t(ipa_node_agg_replacements): Likewise.\n\t(ipa_get_agg_replacements_for_node): New function.\n\t(ipcp_agg_lattice_pool): Declare.\n\t(ipa_dump_agg_replacement_values): Likewise.\n\t(ipa_prop_write_all_agg_replacement): Likewise.\n\t(ipa_prop_read_all_agg_replacement): Likewise.\n\t(ipcp_transform_function): Likewise.\n\t* ipa-inline-analysis.c (estimate_ipcp_clone_size_and_time): Pass around\n\tknown aggregates and hints.\n\t* ipa-inline.h: include ipa-prop.h.\n\t(estimate_ipcp_clone_size_and_time): Adjust declaration.\n\t* lto-streamer.h (lto_section_type): New item\n\tLTO_section_ipcp_transform.\n\t* lto-section-in.c (lto_section_name): New element ipcp_trans.\n\t* params.def (PARAM_IPA_CP_LOOP_HINT_BONUS): New parameter.\n\t* Makefile.in (IPA_INLINE_H): New.  Use everywhee instead of\n\tipa-inline.h.\n\n\t* testsuite/gcc.dg/ipa/ipa-5.c: Adjust.\n\t* testsuite/gcc.dg/ipa/ipcp-agg-1.c: New test.\n\t* testsuite/gcc.dg/ipa/ipcp-agg-2.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipcp-agg-3.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipcp-agg-4.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipcp-agg-5.c: Likewise.\n\t* testsuite/gcc.dg/ipa/ipcp-agg-6.c: Likewise.\n\t* testsuite/gfortran.dg/pr48636.f90: Add -fno-ipa-cp.\n\t* testsuite/gfortran.dg/pr48636-2.f90: New test.\n\t* testsuite/gfortran.dg/pr53787.f90: Likewise.\n\nFrom-SVN: r193298", "tree": {"sha": "d2ea663c799050adc33578f7fb54862612fec7a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2ea663c799050adc33578f7fb54862612fec7a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c9561b513bd88c41094efcf39f6405b5536a54d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9561b513bd88c41094efcf39f6405b5536a54d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9561b513bd88c41094efcf39f6405b5536a54d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9561b513bd88c41094efcf39f6405b5536a54d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a57d75dc7017be0baa20c96018fbe0f004e75175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57d75dc7017be0baa20c96018fbe0f004e75175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a57d75dc7017be0baa20c96018fbe0f004e75175"}], "stats": {"total": 2521, "additions": 2234, "deletions": 287}, "files": [{"sha": "7a72b38c68d5f671905374c7ff57986462956c17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -1,3 +1,102 @@\n+2012-11-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/53787\n+\t* ipa-cp.c (ipcp_value_source): New field offset.\n+\t(ipcp_agg_lattice): New type.\n+\t(ipcp_param_lattices): Likewise, move virt_call from ipcp_lattice here.\n+\t(ipcp_agg_lattice_pool): New variable.\n+\t(ipa_get_parm_lattices): New function.\n+\t(ipa_get_lattice): Turned into ipa_get_scalar_lat, use the above.\n+\tAdjusted all callers.\n+\t(print_lattice): New function.\n+\t(print_all_lattices): Use the above, also print aggregate lattices.\n+\t(set_agg_lats_to_bottom): New function.\n+\t(set_agg_lats_contain_variable): Likewise.\n+\t(set_all_contains_variable): Likewise.\n+\t(initialize_node_lattices): Also handle aggregate lattices, set\n+\tvirt_call in ipcp_param_lattices.\n+\t(add_value_source): Handle offsets.\n+\t(add_value_to_lattice): Likewise.\n+\t(add_scalar_value_to_lattice): New function.\n+\t(propagate_vals_accross_pass_through): Use add_scalar_value_to_lattice.\n+\t(propagate_vals_accross_ancestor): Likewise.\n+\t(propagate_accross_jump_function): Renamed to\n+\tpropagate_scalar_accross_jump_function, use\n+\tadd_scalar_value_to_lattice.\n+\t(set_check_aggs_by_ref): New function.\n+\t(merge_agg_lats_step): Likewise.\n+\t(set_chain_of_aglats_contains_variable): Likewise.\n+\t(merge_aggregate_lattices): Likewise.\n+\t(propagate_constants_accross_call): Also handle aggregate lattices.\n+\t(hint_time_bonus): New function.\n+\t(context_independent_aggregate_values): Likewise.\n+\t(gather_context_independent_values): Also handle agggregate values.\n+\t(agg_jmp_p_vec_for_t_vec): New function.\n+\t(estimate_local_effects): Also handle agggregate values.\n+\t(add_all_node_vals_to_toposort): Likewise.\n+\t(ipcp_propagate_stage): Use struct ipcp_param_lattices.\n+\t(get_clone_agg_value): New function.\n+\t(cgraph_edge_brings_value_p): Also handle agggregate values.\n+\t(create_specialized_node): Likewise.\n+\t(find_more_values_for_callers_subset): Rename to\n+\tfind_more_scalar_values_for_callers_subset.  Modify dump.\n+\t(copy_plats_to_inter): New function.\n+\t(intersect_with_plats): Likewise.\n+\t(agg_replacements_to_vector): Likewise.\n+\t(intersect_with_agg_replacements): Likewise.\n+\t(find_aggregate_values_for_callers_subset): Likewise.\n+\t(known_aggs_to_agg_replacement_list): Likewise.\n+\t(cgraph_edge_brings_all_scalars_for_node): Likewise.\n+\t(cgraph_edge_brings_all_agg_vals_for_node): Likewise.\n+\t(perhaps_add_new_callers): Old functionality moved to\n+\tcgraph_edge_brings_all_scalars_for_node, call it and\n+\tcgraph_edge_brings_all_agg_vals_for_node.\n+\t(ipcp_val_in_agg_replacements_p): New function.\n+\t(decide_about_value): New function.\n+\t(decide_whether_version_node): A lot of functionality moved to\n+\tdecide_about_value.  Also handle agggregate values.\n+\t(ipcp_driver): Also allocate ipcp_agg_lattice_pool.\n+\t(pass_ipa_cp): Fill in new entries.\n+\t* ipa-prop.c (ipa_node_agg_replacements): New variable.\n+\t(free_parms_ainfo): New function.\n+\t(ipa_analyze_node): Use free_parms_ainfo to free stuff.\n+\t(ipa_find_agg_cst_for_param): Do not rely on offset ordering.\n+\t(ipa_set_node_agg_value_chain): New function.\n+\t(ipa_node_removal_hook): Also handle ipa_node_agg_replacements.\n+\t(ipa_node_duplication_hook): Likewise.\n+\t(ipa_free_all_structures_after_ipa_cp): Also free ipcp_agg_lattice_pool.\n+\t(ipa_free_all_structures_after_iinln): Likewise.\n+\t(ipa_dump_agg_replacement_values): New function.\n+\t(write_agg_replacement_chain): Likewise.\n+\t(read_agg_replacement_chain): Likewise.\n+\t(ipa_prop_write_all_agg_replacement): Likewise.\n+\t(read_replacements_section): Likewise.\n+\t(ipa_prop_read_all_agg_replacement): Likewise.\n+\t(adjust_agg_replacement_values): Likewise.\n+\t(ipcp_transform_function): Likewise.\n+\t* ipa-prop.h: Also define heap vector of ipa_agg_jf_item_t and of\n+\tipa_agg_jump_function_t.\n+\t(ipa_node_params): Make lattices an array of ipcp_param_lattices.\n+\t(ipa_agg_replacement_value): New type and its vector.\n+\t(ipa_set_node_agg_value_chain) Declare.\n+\t(ipa_node_agg_replacements): Likewise.\n+\t(ipa_get_agg_replacements_for_node): New function.\n+\t(ipcp_agg_lattice_pool): Declare.\n+\t(ipa_dump_agg_replacement_values): Likewise.\n+\t(ipa_prop_write_all_agg_replacement): Likewise.\n+\t(ipa_prop_read_all_agg_replacement): Likewise.\n+\t(ipcp_transform_function): Likewise.\n+\t* ipa-inline-analysis.c (estimate_ipcp_clone_size_and_time): Pass around\n+\tknown aggregates and hints.\n+\t* ipa-inline.h: include ipa-prop.h.\n+\t(estimate_ipcp_clone_size_and_time): Adjust declaration.\n+\t* lto-streamer.h (lto_section_type): New item\n+\tLTO_section_ipcp_transform.\n+\t* lto-section-in.c (lto_section_name): New element ipcp_trans.\n+\t* params.def (PARAM_IPA_CP_LOOP_HINT_BONUS): New parameter.\n+\t* Makefile.in (IPA_INLINE_H): New.  Use everywhee instead of\n+\tipa-inline.h.\n+\n 2012-11-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (enum upper_128bits_state): Remove."}, {"sha": "24791a4f17080c99a52b0d4b0babf38aa4199c8c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -953,6 +953,7 @@ TREE_STREAMER_H = tree-streamer.h $(TREE_H) $(LTO_STREAMER_H) \\\n STREAMER_HOOKS_H = streamer-hooks.h $(TREE_H)\n TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H) $(TARGET_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H) alloc-pool.h\n+IPA_INLINE_H = ipa-inline.h $(IPA_PROP_H)\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h plugin.def \\\n@@ -2834,27 +2835,27 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \\\n    gt-cgraph.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n    $(TREE_INLINE_H) $(TREE_FLOW_H) cif-code.def \\\n    value-prof.h $(EXCEPT_H) $(IPA_UTILS_H) $(DIAGNOSTIC_CORE_H) \\\n-   ipa-inline.h $(LTO_STREAMER_H) $(CFGLOOP_H) $(GIMPLE_PRETTY_PRINT_H)\n+   $(IPA_INLINE_H) $(LTO_STREAMER_H) $(CFGLOOP_H) $(GIMPLE_PRETTY_PRINT_H)\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(IPA_PROP_H) \\\n    gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H) \\\n-   $(GIMPLE_PRETTY_PRINT_H) ipa-inline.h $(IPA_UTILS_H) \\\n+   $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(IPA_UTILS_H) \\\n    $(LTO_STREAMER_H) output.h $(REGSET_H) $(EXCEPT_H) $(GCC_PLUGIN_H) plugin.h\n cgraphclones.o : cgraphclones.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n    $(PARAMS_H) $(RTL_H) $(IPA_PROP_H) \\\n    tree-iterator.h $(COVERAGE_H) \\\n-   $(GIMPLE_PRETTY_PRINT_H) ipa-inline.h $(IPA_UTILS_H) \\\n+   $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(IPA_UTILS_H) \\\n    $(LTO_STREAMER_H) $(EXCEPT_H) $(GCC_PLUGIN_H) gt-cgraphclones.h\n cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H) \\\n-   ipa-inline.h\n+   $(IPA_INLINE_H)\n varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(CGRAPH_H) langhooks.h $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) \\\n    $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \\\n@@ -2874,21 +2875,22 @@ ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(TREE_H) $(TARGET_H) $(GIMPLE_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(DIAGNOSTIC_H) \\\n-   $(TREE_INLINE_H) $(PARAMS_H) $(TREE_PRETTY_PRINT_H) ipa-inline.h\n+   $(TREE_INLINE_H) $(PARAMS_H) $(TREE_PRETTY_PRINT_H) $(IPA_INLINE_H)\n ipa-split.o : ipa-split.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n-   $(TREE_INLINE_H) $(PARAMS_H) $(GIMPLE_PRETTY_PRINT_H) ipa-inline.h\n+   $(TREE_INLINE_H) $(PARAMS_H) $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H)\n ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TREE_PASS_H) \\\n    $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H) \\\n-   $(EXCEPT_H) $(GIMPLE_PRETTY_PRINT_H) ipa-inline.h $(TARGET_H) $(IPA_UTILS_H)\n+   $(EXCEPT_H) $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(TARGET_H) \\\n+   $(IPA_UTILS_H)\n ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(PARAMS_H) $(TREE_PASS_H) $(CFGLOOP_H) \\\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n-   $(GIMPLE_PRETTY_PRINT_H) ipa-inline.h $(LTO_STREAMER_H) $(DATA_STREAMER_H) \\\n+   $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(LTO_STREAMER_H) $(DATA_STREAMER_H) \\\n    $(TREE_STREAMER_H)\n ipa-inline-transform.o : ipa-inline-transform.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\"}, {"sha": "764c931439ce04055e15ea0640ba16ace947c60f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1237, "deletions": 236, "changes": 1473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -125,6 +125,9 @@ struct ipcp_value;\n \n struct ipcp_value_source\n {\n+  /* Aggregate offset of the source, negative if the source is scalar value of\n+     the argument itself.  */\n+  HOST_WIDE_INT offset;\n   /* The incoming edge that brought the value.  */\n   struct cgraph_edge *cs;\n   /* If the jump function that resulted into his value was a pass-through or an\n@@ -173,15 +176,10 @@ struct ipcp_value\n   bool on_stack;\n };\n \n-/* Allocation pools for values and their sources in ipa-cp.  */\n-\n-alloc_pool ipcp_values_pool;\n-alloc_pool ipcp_sources_pool;\n-\n-/* Lattice describing potential values of a formal parameter of a function and\n-   some of their other properties.  TOP is represented by a lattice with zero\n-   values and with contains_variable and bottom flags cleared.  BOTTOM is\n-   represented by a lattice with the bottom flag set.  In that case, values and\n+/* Lattice describing potential values of a formal parameter of a function, or\n+   a part of an aggreagate.  TOP is represented by a lattice with zero values\n+   and with contains_variable and bottom flags cleared.  BOTTOM is represented\n+   by a lattice with the bottom flag set.  In that case, values and\n    contains_variable flag should be disregarded.  */\n \n struct ipcp_lattice\n@@ -192,15 +190,58 @@ struct ipcp_lattice\n   struct ipcp_value *values;\n   /* Number of known values and types in this lattice.  */\n   int values_count;\n-  /* The lattice contains a variable component  (in addition to values).  */\n+  /* The lattice contains a variable component (in addition to values).  */\n   bool contains_variable;\n   /* The value of the lattice is bottom (i.e. variable and unusable for any\n      propagation).  */\n   bool bottom;\n+};\n+\n+/* Lattice with an offset to describe a part of an aggregate.  */\n+\n+struct ipcp_agg_lattice : public ipcp_lattice\n+{\n+  /* Offset that is being described by this lattice. */\n+  HOST_WIDE_INT offset;\n+  /* Size so that we don't have to re-compute it every time we traverse the\n+     list.  Must correspond to TYPE_SIZE of all lat values.  */\n+  HOST_WIDE_INT size;\n+  /* Next element of the linked list.  */\n+  struct ipcp_agg_lattice *next;\n+};\n+\n+/* Structure containing lattices for a parameter itself and for pieces of\n+   aggregates that are passed in the parameter or by a reference in a parameter\n+   plus some other useful flags.  */\n+\n+struct ipcp_param_lattices\n+{\n+  /* Lattice describing the value of the parameter itself.  */\n+  struct ipcp_lattice itself;\n+  /* Lattices describing aggregate parts.  */\n+  struct ipcp_agg_lattice *aggs;\n+  /* Number of aggregate lattices */\n+  int aggs_count;\n+  /* True if aggregate data were passed by reference (as opposed to by\n+     value).  */\n+  bool aggs_by_ref;\n+  /* All aggregate lattices contain a variable component (in addition to\n+     values).  */\n+  bool aggs_contain_variable;\n+  /* The value of all aggregate lattices is bottom (i.e. variable and unusable\n+     for any propagation).  */\n+  bool aggs_bottom;\n+\n   /* There is a virtual call based on this parameter.  */\n   bool virt_call;\n };\n \n+/* Allocation pools for values and their sources in ipa-cp.  */\n+\n+alloc_pool ipcp_values_pool;\n+alloc_pool ipcp_sources_pool;\n+alloc_pool ipcp_agg_lattice_pool;\n+\n /* Maximal count found in program.  */\n \n static gcov_type max_count;\n@@ -213,17 +254,26 @@ static long overall_size, max_new_size;\n \n static struct ipcp_value *values_topo;\n \n-/* Return the lattice corresponding to the Ith formal parameter of the function\n-   described by INFO.  */\n-static inline struct ipcp_lattice *\n-ipa_get_lattice (struct ipa_node_params *info, int i)\n+/* Return the param lattices structure corresponding to the Ith formal\n+   parameter of the function described by INFO.  */\n+static inline struct ipcp_param_lattices *\n+ipa_get_parm_lattices (struct ipa_node_params *info, int i)\n {\n   gcc_assert (i >= 0 && i < ipa_get_param_count (info));\n   gcc_checking_assert (!info->ipcp_orig_node);\n   gcc_checking_assert (info->lattices);\n   return &(info->lattices[i]);\n }\n \n+/* Return the lattice corresponding to the scalar value of the Ith formal\n+   parameter of the function described by INFO.  */\n+static inline struct ipcp_lattice *\n+ipa_get_scalar_lat (struct ipa_node_params *info, int i)\n+{\n+  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+  return &plats->itself;\n+}\n+\n /* Return whether LAT is a lattice with a single constant and without an\n    undefined value.  */\n \n@@ -274,6 +324,66 @@ print_ipcp_constant_value (FILE * f, tree v)\n     print_generic_expr (f, v, 0);\n }\n \n+/* Print a lattice LAT to F.  */\n+\n+static void\n+print_lattice (FILE * f, struct ipcp_lattice *lat,\n+\t       bool dump_sources, bool dump_benefits)\n+{\n+  struct ipcp_value *val;\n+  bool prev = false;\n+\n+  if (lat->bottom)\n+    {\n+      fprintf (f, \"BOTTOM\\n\");\n+      return;\n+    }\n+\n+  if (!lat->values_count && !lat->contains_variable)\n+    {\n+      fprintf (f, \"TOP\\n\");\n+      return;\n+    }\n+\n+  if (lat->contains_variable)\n+    {\n+      fprintf (f, \"VARIABLE\");\n+      prev = true;\n+      if (dump_benefits)\n+\tfprintf (f, \"\\n\");\n+    }\n+\n+  for (val = lat->values; val; val = val->next)\n+    {\n+      if (dump_benefits && prev)\n+\tfprintf (f, \"               \");\n+      else if (!dump_benefits && prev)\n+\tfprintf (f, \", \");\n+      else\n+\tprev = true;\n+\n+      print_ipcp_constant_value (f, val->value);\n+\n+      if (dump_sources)\n+\t{\n+\t  struct ipcp_value_source *s;\n+\n+\t  fprintf (f, \" [from:\");\n+\t  for (s = val->sources; s; s = s->next)\n+\t    fprintf (f, \" %i(%i)\", s->cs->caller->uid,s->cs->frequency);\n+\t  fprintf (f, \"]\");\n+\t}\n+\n+      if (dump_benefits)\n+\tfprintf (f, \" [loc_time: %i, loc_size: %i, \"\n+\t\t \"prop_time: %i, prop_size: %i]\\n\",\n+\t\t val->local_time_benefit, val->local_size_cost,\n+\t\t val->prop_time_benefit, val->prop_size_cost);\n+    }\n+  if (!dump_benefits)\n+    fprintf (f, \"\\n\");\n+}\n+\n /* Print all ipcp_lattices of all functions to F.  */\n \n static void\n@@ -292,60 +402,27 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n-\t  struct ipcp_value *val;\n-\t  bool prev = false;\n-\n+\t  struct ipcp_agg_lattice *aglat;\n+\t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  fprintf (f, \"    param [%d]: \", i);\n-\t  if (lat->bottom)\n-\t    {\n-\t      fprintf (f, \"BOTTOM\\n\");\n-\t      continue;\n-\t    }\n+\t  print_lattice (f, &plats->itself, dump_sources, dump_benefits);\n \n-\t  if (!lat->values_count && !lat->contains_variable)\n+\t  if (plats->virt_call)\n+\t    fprintf (f, \"        virt_call flag set\\n\");\n+\n+\t  if (plats->aggs_bottom)\n \t    {\n-\t      fprintf (f, \"TOP\\n\");\n+\t      fprintf (f, \"        AGGS BOTTOM\\n\");\n \t      continue;\n \t    }\n-\n-\t  if (lat->contains_variable)\n+\t  if (plats->aggs_contain_variable)\n+\t    fprintf (f, \"        AGGS VARIABLE\\n\");\n+\t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t    {\n-\t      fprintf (f, \"VARIABLE\");\n-\t      prev = true;\n-\t      if (dump_benefits)\n-\t\tfprintf (f, \"\\n\");\n+\t      fprintf (f, \"        %soffset \" HOST_WIDE_INT_PRINT_DEC \": \",\n+\t\t       plats->aggs_by_ref ? \"ref \" : \"\", aglat->offset);\n+\t      print_lattice (f, aglat, dump_sources, dump_benefits);\n \t    }\n-\n-\t  for (val = lat->values; val; val = val->next)\n-\t    {\n-\t      if (dump_benefits && prev)\n-\t\tfprintf (f, \"               \");\n-\t      else if (!dump_benefits && prev)\n-\t\tfprintf (f, \", \");\n-\t      else\n-\t\tprev = true;\n-\n-\t      print_ipcp_constant_value (f, val->value);\n-\n-\t      if (dump_sources)\n-\t\t{\n-\t\t  struct ipcp_value_source *s;\n-\n-\t\t  fprintf (f, \" [from:\");\n-\t\t  for (s = val->sources; s; s = s->next)\n-\t\t    fprintf (f, \" %i(%i)\", s->cs->caller->uid,s->cs->frequency);\n-\t\t  fprintf (f, \"]\");\n-\t\t}\n-\n-\t      if (dump_benefits)\n-\t\tfprintf (f, \" [loc_time: %i, loc_size: %i, \"\n-\t\t\t \"prop_time: %i, prop_size: %i]\\n\",\n-\t\t\t val->local_time_benefit, val->local_size_cost,\n-\t\t\t val->prop_time_benefit, val->prop_size_cost);\n-\t    }\n-\t  if (!dump_benefits)\n-\t    fprintf (f, \"\\n\");\n \t}\n     }\n }\n@@ -578,6 +655,40 @@ set_lattice_contains_variable (struct ipcp_lattice *lat)\n   return ret;\n }\n \n+/* Set all aggegate lattices in PLATS to bottom and return true if they were\n+   not previously set as such.  */\n+\n+static inline bool\n+set_agg_lats_to_bottom (struct ipcp_param_lattices *plats)\n+{\n+  bool ret = !plats->aggs_bottom;\n+  plats->aggs_bottom = true;\n+  return ret;\n+}\n+\n+/* Mark all aggegate lattices in PLATS as containing an unknown value and\n+   return true if they were not previously marked as such.  */\n+\n+static inline bool\n+set_agg_lats_contain_variable (struct ipcp_param_lattices *plats)\n+{\n+  bool ret = !plats->aggs_contain_variable;\n+  plats->aggs_contain_variable = true;\n+  return ret;\n+}\n+\n+/* Mark bot aggregate and scalar lattices as containing an unknown variable,\n+   return true is any of them has not been marked as such so far.  */\n+\n+static inline bool\n+set_all_contains_variable (struct ipcp_param_lattices *plats)\n+{\n+  bool ret = !plats->itself.contains_variable || !plats->aggs_contain_variable;\n+  plats->itself.contains_variable = true;\n+  plats->aggs_contain_variable = true;\n+  return ret;\n+}\n+\n /* Initialize ipcp_lattices.  */\n \n static void\n@@ -605,11 +716,14 @@ initialize_node_lattices (struct cgraph_node *node)\n     {\n       for (i = 0; i < ipa_get_param_count (info) ; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n+\t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  if (disable)\n-\t    set_lattice_to_bottom (lat);\n+\t    {\n+\t      set_lattice_to_bottom (&plats->itself);\n+\t      set_agg_lats_to_bottom (plats);\n+\t    }\n \t  else\n-\t    set_lattice_contains_variable (lat);\n+\t    set_all_contains_variable (plats);\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS)\n \t  && node->alias && node->thunk.thunk_p)\n@@ -622,7 +736,8 @@ initialize_node_lattices (struct cgraph_node *node)\n     if (ie->indirect_info->polymorphic)\n       {\n \tgcc_checking_assert (ie->indirect_info->param_index >= 0);\n-\tipa_get_lattice (info, ie->indirect_info->param_index)->virt_call = 1;\n+\tipa_get_parm_lattices (info,\n+\t\t\t       ie->indirect_info->param_index)->virt_call = 1;\n       }\n }\n \n@@ -725,7 +840,7 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n \t      gcc_checking_assert (!flag_ipa_cp);\n \t      return NULL_TREE;\n \t    }\n-\t  lat = ipa_get_lattice (info, idx);\n+\t  lat = ipa_get_scalar_lat (info, idx);\n \t  if (!ipa_lat_is_single_const (lat))\n \t    return NULL_TREE;\n \t  input = lat->values->value;\n@@ -760,7 +875,7 @@ ipcp_verify_propagated_values (void)\n \n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n+\t  struct ipcp_lattice *lat = ipa_get_scalar_lat (info, i);\n \n \t  if (!lat->bottom\n \t      && !lat->contains_variable\n@@ -804,15 +919,18 @@ values_equal_for_ipcp_p (tree x, tree y)\n \n /* Add a new value source to VAL, marking that a value comes from edge CS and\n    (if the underlying jump function is a pass-through or an ancestor one) from\n-   a caller value SRC_VAL of a caller parameter described by SRC_INDEX.  */\n+   a caller value SRC_VAL of a caller parameter described by SRC_INDEX.  OFFSET\n+   is negative if the source was the scalar value of the parameter itself or\n+   the offset within an aggregate.  */\n \n static void\n add_value_source (struct ipcp_value *val, struct cgraph_edge *cs,\n-\t\t  struct ipcp_value *src_val, int src_idx)\n+\t\t  struct ipcp_value *src_val, int src_idx, HOST_WIDE_INT offset)\n {\n   struct ipcp_value_source *src;\n \n   src = (struct ipcp_value_source *) pool_alloc (ipcp_sources_pool);\n+  src->offset = offset;\n   src->cs = cs;\n   src->val = src_val;\n   src->index = src_idx;\n@@ -821,22 +939,20 @@ add_value_source (struct ipcp_value *val, struct cgraph_edge *cs,\n   val->sources = src;\n }\n \n-\n /* Try to add NEWVAL to LAT, potentially creating a new struct ipcp_value for\n-   it.  CS, SRC_VAL and SRC_INDEX are meant for add_value_source and have the\n-   same meaning.  */\n+   it.  CS, SRC_VAL SRC_INDEX and OFFSET are meant for add_value_source and\n+   have the same meaning.  */\n \n static bool\n add_value_to_lattice (struct ipcp_lattice *lat, tree newval,\n \t\t      struct cgraph_edge *cs, struct ipcp_value *src_val,\n-\t\t      int src_idx)\n+\t\t      int src_idx, HOST_WIDE_INT offset)\n {\n   struct ipcp_value *val;\n \n   if (lat->bottom)\n     return false;\n \n-\n   for (val = lat->values; val; val = val->next)\n     if (values_equal_for_ipcp_p (val->value, newval))\n       {\n@@ -850,7 +966,7 @@ add_value_to_lattice (struct ipcp_lattice *lat, tree newval,\n \t      return false;\n \t  }\n \n-\tadd_value_source (val, cs, src_val, src_idx);\n+\tadd_value_source (val, cs, src_val, src_idx, offset);\n \treturn false;\n       }\n \n@@ -876,13 +992,25 @@ add_value_to_lattice (struct ipcp_lattice *lat, tree newval,\n   val = (struct ipcp_value *) pool_alloc (ipcp_values_pool);\n   memset (val, 0, sizeof (*val));\n \n-  add_value_source (val, cs, src_val, src_idx);\n+  add_value_source (val, cs, src_val, src_idx, offset);\n   val->value = newval;\n   val->next = lat->values;\n   lat->values = val;\n   return true;\n }\n \n+/* Like above but passes a special value of offset to distinguish that the\n+   origin is the scalar value of the parameter rather than a part of an\n+   aggregate.  */\n+\n+static inline bool\n+add_scalar_value_to_lattice (struct ipcp_lattice *lat, tree newval,\n+\t\t\t     struct cgraph_edge *cs,\n+\t\t\t     struct ipcp_value *src_val, int src_idx)\n+{\n+  return add_value_to_lattice (lat, newval, cs, src_val, src_idx, -1);\n+}\n+\n /* Propagate values through a pass-through jump function JFUNC associated with\n    edge CS, taking values from SRC_LAT and putting them into DEST_LAT.  SRC_IDX\n    is the index of the source parameter.  */\n@@ -899,8 +1027,8 @@ propagate_vals_accross_pass_through (struct cgraph_edge *cs,\n \n   if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n-      ret |= add_value_to_lattice (dest_lat, src_val->value, cs,\n-\t\t\t\t   src_val, src_idx);\n+      ret |= add_scalar_value_to_lattice (dest_lat, src_val->value, cs,\n+\t\t\t\t\t  src_val, src_idx);\n   /* Do not create new values when propagating within an SCC because if there\n      are arithmetic functions with circular dependencies, there is infinite\n      number of them and we would just make lattices bottom.  */\n@@ -919,7 +1047,8 @@ propagate_vals_accross_pass_through (struct cgraph_edge *cs,\n \tcstval = ipa_get_jf_pass_through_result (jfunc, cstval);\n \n \tif (cstval)\n-\t  ret |= add_value_to_lattice (dest_lat, cstval, cs, src_val, src_idx);\n+\t  ret |= add_scalar_value_to_lattice (dest_lat, cstval, cs, src_val,\n+\t\t\t\t\t      src_idx);\n \telse\n \t  ret |= set_lattice_contains_variable (dest_lat);\n       }\n@@ -949,21 +1078,21 @@ propagate_vals_accross_ancestor (struct cgraph_edge *cs,\n       tree t = ipa_get_jf_ancestor_result (jfunc, src_val->value);\n \n       if (t)\n-\tret |= add_value_to_lattice (dest_lat, t, cs, src_val, src_idx);\n+\tret |= add_scalar_value_to_lattice (dest_lat, t, cs, src_val, src_idx);\n       else\n \tret |= set_lattice_contains_variable (dest_lat);\n     }\n \n   return ret;\n }\n \n-/* Propagate values across jump function JFUNC that is associated with edge CS\n-   and put the values into DEST_LAT.  */\n+/* Propagate scalar values across jump function JFUNC that is associated with\n+   edge CS and put the values into DEST_LAT.  */\n \n static bool\n-propagate_accross_jump_function (struct cgraph_edge *cs,\n-\t\t\t\t struct ipa_jump_func *jfunc,\n-\t\t\t\t struct ipcp_lattice *dest_lat)\n+propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n+\t\t\t\t\tstruct ipa_jump_func *jfunc,\n+\t\t\t\t\tstruct ipcp_lattice *dest_lat)\n {\n   if (dest_lat->bottom)\n     return false;\n@@ -981,7 +1110,7 @@ propagate_accross_jump_function (struct cgraph_edge *cs,\n \t}\n       else\n \tval = ipa_get_jf_constant (jfunc);\n-      return add_value_to_lattice (dest_lat, val, cs, NULL, 0);\n+      return add_scalar_value_to_lattice (dest_lat, val, cs, NULL, 0);\n     }\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n \t   || jfunc->type == IPA_JF_ANCESTOR)\n@@ -996,7 +1125,7 @@ propagate_accross_jump_function (struct cgraph_edge *cs,\n       else\n \tsrc_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n \n-      src_lat = ipa_get_lattice (caller_info, src_idx);\n+      src_lat = ipa_get_scalar_lat (caller_info, src_idx);\n       if (src_lat->bottom)\n \treturn set_lattice_contains_variable (dest_lat);\n \n@@ -1024,6 +1153,257 @@ propagate_accross_jump_function (struct cgraph_edge *cs,\n   return set_lattice_contains_variable (dest_lat);\n }\n \n+/* If DEST_PLATS already has aggregate items, check that aggs_by_ref matches\n+   NEW_AGGS_BY_REF and if not, mark all aggs as bottoms and return true (in all\n+   other cases, return false).  If there are no aggregate items, set\n+   aggs_by_ref to NEW_AGGS_BY_REF.  */\n+\n+static bool\n+set_check_aggs_by_ref (struct ipcp_param_lattices *dest_plats,\n+\t\t       bool new_aggs_by_ref)\n+{\n+  if (dest_plats->aggs)\n+    {\n+      if (dest_plats->aggs_by_ref != new_aggs_by_ref)\n+\t{\n+\t  set_agg_lats_to_bottom (dest_plats);\n+\t  return true;\n+\t}\n+    }\n+  else\n+    dest_plats->aggs_by_ref = new_aggs_by_ref;\n+  return false;\n+}\n+\n+/* Walk aggregate lattices in DEST_PLATS from ***AGLAT on, until ***aglat is an\n+   already existing lattice for the given OFFSET and SIZE, marking all skipped\n+   lattices as containing variable and checking for overlaps.  If there is no\n+   already existing lattice for the OFFSET and VAL_SIZE, create one, initialize\n+   it with offset, size and contains_variable to PRE_EXISTING, and return true,\n+   unless there are too many already.  If there are two many, return false.  If\n+   there are overlaps turn whole DEST_PLATS to bottom and return false.  If any\n+   skipped lattices were newly marked as containing variable, set *CHANGE to\n+   true.  */\n+\n+static bool\n+merge_agg_lats_step (struct ipcp_param_lattices *dest_plats,\n+\t\t     HOST_WIDE_INT offset, HOST_WIDE_INT val_size,\n+\t\t     struct ipcp_agg_lattice ***aglat,\n+\t\t     bool pre_existing, bool *change)\n+{\n+  gcc_checking_assert (offset >= 0);\n+\n+  while (**aglat && (**aglat)->offset < offset)\n+    {\n+      if ((**aglat)->offset + (**aglat)->size > offset)\n+\t{\n+\t  set_agg_lats_to_bottom (dest_plats);\n+\t  return false;\n+\t}\n+      *change |= set_lattice_contains_variable (**aglat);\n+      *aglat = &(**aglat)->next;\n+    }\n+\n+  if (**aglat && (**aglat)->offset == offset)\n+    {\n+      if ((**aglat)->size != val_size\n+          || ((**aglat)->next\n+              && (**aglat)->next->offset < offset + val_size))\n+\t{\n+\t  set_agg_lats_to_bottom (dest_plats);\n+\t  return false;\n+\t}\n+      gcc_checking_assert (!(**aglat)->next\n+\t\t\t   || (**aglat)->next->offset >= offset + val_size);\n+      return true;\n+    }\n+  else\n+    {\n+      struct ipcp_agg_lattice *new_al;\n+\n+      if (**aglat && (**aglat)->offset < offset + val_size)\n+\t{\n+\t  set_agg_lats_to_bottom (dest_plats);\n+\t  return false;\n+\t}\n+      if (dest_plats->aggs_count == PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS))\n+\treturn false;\n+      dest_plats->aggs_count++;\n+      new_al = (struct ipcp_agg_lattice *) pool_alloc (ipcp_agg_lattice_pool);\n+      memset (new_al, 0, sizeof (*new_al));\n+\n+      new_al->offset = offset;\n+      new_al->size = val_size;\n+      new_al->contains_variable = pre_existing;\n+\n+      new_al->next = **aglat;\n+      **aglat = new_al;\n+      return true;\n+    }\n+}\n+\n+/* Set all AGLAT and all other aggregate lattices reachable by next pointers as\n+   containing an unknown value.  */\n+\n+static bool\n+set_chain_of_aglats_contains_variable (struct ipcp_agg_lattice *aglat)\n+{\n+  bool ret = false;\n+  while (aglat)\n+    {\n+      ret |= set_lattice_contains_variable (aglat);\n+      aglat = aglat->next;\n+    }\n+  return ret;\n+}\n+\n+/* Merge existing aggregate lattices in SRC_PLATS to DEST_PLATS, subtracting\n+   DELTA_OFFSET.  CS is the call graph edge and SRC_IDX the index of the source\n+   parameter used for lattice value sources.  Return true if DEST_PLATS changed\n+   in any way.  */\n+\n+static bool\n+merge_aggregate_lattices (struct cgraph_edge *cs,\n+\t\t\t  struct ipcp_param_lattices *dest_plats,\n+\t\t\t  struct ipcp_param_lattices *src_plats,\n+\t\t\t  int src_idx, HOST_WIDE_INT offset_delta)\n+{\n+  bool pre_existing = dest_plats->aggs != NULL;\n+  struct ipcp_agg_lattice **dst_aglat;\n+  bool ret = false;\n+\n+  if (set_check_aggs_by_ref (dest_plats, src_plats->aggs_by_ref))\n+    return true;\n+  if (src_plats->aggs_bottom)\n+    return set_agg_lats_contain_variable (dest_plats);\n+  dst_aglat = &dest_plats->aggs;\n+\n+  for (struct ipcp_agg_lattice *src_aglat = src_plats->aggs;\n+       src_aglat;\n+       src_aglat = src_aglat->next)\n+    {\n+      HOST_WIDE_INT new_offset = src_aglat->offset - offset_delta;\n+\n+      if (new_offset < 0)\n+\tcontinue;\n+      if (merge_agg_lats_step (dest_plats, new_offset, src_aglat->size,\n+\t\t\t       &dst_aglat, pre_existing, &ret))\n+\t{\n+\t  struct ipcp_agg_lattice *new_al = *dst_aglat;\n+\n+\t  dst_aglat = &(*dst_aglat)->next;\n+\t  if (src_aglat->bottom)\n+\t    {\n+\t      ret |= set_lattice_contains_variable (new_al);\n+\t      continue;\n+\t    }\n+\t  if (src_aglat->contains_variable)\n+\t    ret |= set_lattice_contains_variable (new_al);\n+\t  for (struct ipcp_value *val = src_aglat->values;\n+\t       val;\n+\t       val = val->next)\n+\t    ret |= add_value_to_lattice (new_al, val->value, cs, val, src_idx,\n+\t\t\t\t\t src_aglat->offset);\n+\t}\n+      else if (dest_plats->aggs_bottom)\n+\treturn true;\n+    }\n+  ret |= set_chain_of_aglats_contains_variable (*dst_aglat);\n+  return ret;\n+}\n+\n+/* Propagate scalar values across jump function JFUNC that is associated with\n+   edge CS and put the values into DEST_LAT.  */\n+\n+static bool\n+propagate_aggs_accross_jump_function (struct cgraph_edge *cs,\n+\t\t\t\t      struct ipa_jump_func *jfunc,\n+\t\t\t\t      struct ipcp_param_lattices *dest_plats)\n+{\n+  bool ret = false;\n+\n+  if (dest_plats->aggs_bottom)\n+    return false;\n+\n+  if (jfunc->type == IPA_JF_PASS_THROUGH\n+      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+    {\n+      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+      struct ipcp_param_lattices *src_plats;\n+\n+      src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n+      if (src_plats->aggs\n+\t  && (!src_plats->aggs_by_ref\n+\t      || ipa_get_jf_pass_through_agg_preserved (jfunc)))\n+\t{\n+\t  /* Currently we do not produce clobber aggregate jump\n+\t     functions, replace with merging when we do.  */\n+\t  gcc_assert (!jfunc->agg.items);\n+\t  ret |= merge_aggregate_lattices (cs, dest_plats, src_plats,\n+\t\t\t\t\t   src_idx, 0);\n+\t}\n+      else\n+\tret |= set_agg_lats_contain_variable (dest_plats);\n+    }\n+  else if (jfunc->type == IPA_JF_ANCESTOR\n+\t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n+    {\n+      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n+      struct ipcp_param_lattices *src_plats;\n+\n+      src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n+      if (src_plats->aggs && src_plats->aggs_by_ref)\n+\t{\n+\t  /* Currently we do not produce clobber aggregate jump\n+\t     functions, replace with merging when we do.  */\n+\t  gcc_assert (!jfunc->agg.items);\n+\t  ret |= merge_aggregate_lattices (cs, dest_plats, src_plats, src_idx,\n+\t\t\t\t\t   ipa_get_jf_ancestor_offset (jfunc));\n+\t}\n+      else if (!src_plats->aggs_by_ref)\n+\tret |= set_agg_lats_to_bottom (dest_plats);\n+      else\n+\tret |= set_agg_lats_contain_variable (dest_plats);\n+    }\n+  else if (jfunc->agg.items)\n+    {\n+      bool pre_existing = dest_plats->aggs != NULL;\n+      struct ipcp_agg_lattice **aglat = &dest_plats->aggs;\n+      struct ipa_agg_jf_item *item;\n+      int i;\n+\n+      if (set_check_aggs_by_ref (dest_plats, jfunc->agg.by_ref))\n+\treturn true;\n+\n+      FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, jfunc->agg.items, i, item)\n+\t{\n+\t  HOST_WIDE_INT val_size;\n+\n+\t  if (item->offset < 0)\n+\t    continue;\n+\t  gcc_checking_assert (is_gimple_ip_invariant (item->value));\n+\t  val_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (item->value)), 1);\n+\n+\t  if (merge_agg_lats_step (dest_plats, item->offset, val_size,\n+\t\t\t\t   &aglat, pre_existing, &ret))\n+\t    {\n+\t      ret |= add_value_to_lattice (*aglat, item->value, cs, NULL, 0, 0);\n+\t      aglat = &(*aglat)->next;\n+\t    }\n+\t  else if (dest_plats->aggs_bottom)\n+\t    return true;\n+\t}\n+\n+      ret |= set_chain_of_aglats_contains_variable (*aglat);\n+    }\n+  else\n+    ret |= set_agg_lats_contain_variable (dest_plats);\n+\n+  return ret;\n+}\n+\n /* Propagate constants from the caller to the callee of CS.  INFO describes the\n    caller.  */\n \n@@ -1055,7 +1435,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n     alias_or_thunk = cgraph_alias_aliased_node (alias_or_thunk);\n   if (alias_or_thunk->thunk.thunk_p)\n     {\n-      ret |= set_lattice_contains_variable (ipa_get_lattice (callee_info, 0));\n+      ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,\n+\t\t\t\t\t\t\t       0));\n       i = 1;\n     }\n   else\n@@ -1064,15 +1445,21 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   for (; (i < args_count) && (i < parms_count); i++)\n     {\n       struct ipa_jump_func *jump_func = ipa_get_ith_jump_func (args, i);\n-      struct ipcp_lattice *dest_lat = ipa_get_lattice (callee_info, i);\n+      struct ipcp_param_lattices *dest_plats;\n \n+      dest_plats = ipa_get_parm_lattices (callee_info, i);\n       if (availability == AVAIL_OVERWRITABLE)\n-\tret |= set_lattice_contains_variable (dest_lat);\n+\tret |= set_all_contains_variable (dest_plats);\n       else\n-\tret |= propagate_accross_jump_function (cs, jump_func, dest_lat);\n+\t{\n+\t  ret |= propagate_scalar_accross_jump_function (cs, jump_func,\n+\t\t\t\t\t\t\t &dest_plats->itself);\n+\t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n+\t\t\t\t\t\t       dest_plats);\n+\t}\n     }\n   for (; i < parms_count; i++)\n-    ret |= set_lattice_contains_variable (ipa_get_lattice (callee_info, i));\n+    ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info, i));\n \n   return ret;\n }\n@@ -1204,6 +1591,16 @@ devirtualization_time_bonus (struct cgraph_node *node,\n   return res;\n }\n \n+/* Return time bonus incurred because of HINTS.  */\n+\n+static int\n+hint_time_bonus (inline_hints hints)\n+{\n+  if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n+    return PARAM_VALUE (PARAM_IPA_CP_LOOP_HINT_BONUS);\n+  return 0;\n+}\n+\n /* Return true if cloning NODE is a good idea, given the estimated TIME_BENEFIT\n    and SIZE_COST and with the sum of frequencies of incoming edges to the\n    potential new clone in FREQUENCIES.  */\n@@ -1251,17 +1648,43 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n     }\n }\n \n+/* Return all context independent values from aggregate lattices in PLATS in a\n+   vector.  Return NULL if there are none.  */\n+\n+static VEC (ipa_agg_jf_item_t, gc) *\n+context_independent_aggregate_values (struct ipcp_param_lattices *plats)\n+{\n+  VEC (ipa_agg_jf_item_t, gc) *res = NULL;\n+\n+  if (plats->aggs_bottom\n+      || plats->aggs_contain_variable\n+      || plats->aggs_count == 0)\n+    return NULL;\n+\n+  for (struct ipcp_agg_lattice *aglat = plats->aggs;\n+       aglat;\n+       aglat = aglat->next)\n+    if (ipa_lat_is_single_const (aglat))\n+      {\n+\tstruct ipa_agg_jf_item item;\n+\titem.offset = aglat->offset;\n+\titem.value = aglat->values->value;\n+\tVEC_safe_push (ipa_agg_jf_item_t, gc, res, item);\n+      }\n+  return res;\n+}\n \n-/* Allocate KNOWN_CSTS and KNOWN_BINFOS and populate them with values of\n-   parameters that are known independent of the context.  INFO describes the\n-   function.  If REMOVABLE_PARAMS_COST is non-NULL, the movement cost of all\n-   removable parameters will be stored in it.  */\n+/* Allocate KNOWN_CSTS, KNOWN_BINFOS and, if non-NULL, KNOWN_AGGS and populate\n+   them with values of parameters that are known independent of the context.\n+   INFO describes the function.  If REMOVABLE_PARAMS_COST is non-NULL, the\n+   movement cost of all removable parameters will be stored in it.  */\n \n static bool\n gather_context_independent_values (struct ipa_node_params *info,\n-\t\t\t\t   VEC (tree, heap) **known_csts,\n-\t\t\t\t   VEC (tree, heap) **known_binfos,\n-\t\t\t\t   int *removable_params_cost)\n+\t\t\t       VEC (tree, heap) **known_csts,\n+\t\t\t       VEC (tree, heap) **known_binfos,\n+\t\t\t       VEC (ipa_agg_jump_function_t, heap) **known_aggs,\n+\t\t\t       int *removable_params_cost)\n {\n   int i, count = ipa_get_param_count (info);\n   bool ret = false;\n@@ -1270,13 +1693,19 @@ gather_context_independent_values (struct ipa_node_params *info,\n   *known_binfos = NULL;\n   VEC_safe_grow_cleared (tree, heap, *known_csts, count);\n   VEC_safe_grow_cleared (tree, heap, *known_binfos, count);\n+  if (known_aggs)\n+    {\n+      *known_aggs = NULL;\n+      VEC_safe_grow_cleared (ipa_agg_jump_function_t, heap, *known_aggs, count);\n+    }\n \n   if (removable_params_cost)\n     *removable_params_cost = 0;\n \n   for (i = 0; i < count ; i++)\n     {\n-      struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      struct ipcp_lattice *lat = &plats->itself;\n \n       if (ipa_lat_is_single_const (lat))\n \t{\n@@ -1289,7 +1718,7 @@ gather_context_independent_values (struct ipa_node_params *info,\n \t\t  += estimate_move_cost (TREE_TYPE (val->value));\n \t      ret = true;\n \t    }\n-\t  else if (lat->virt_call)\n+\t  else if (plats->virt_call)\n \t    {\n \t      VEC_replace (tree, *known_binfos, i, val->value);\n \t      ret = true;\n@@ -1302,12 +1731,45 @@ gather_context_independent_values (struct ipa_node_params *info,\n       else if (removable_params_cost\n \t       && !ipa_is_param_used (info, i))\n \t*removable_params_cost\n-\t  +=  estimate_move_cost (TREE_TYPE (ipa_get_param (info, i)));\n+\t  += estimate_move_cost (TREE_TYPE (ipa_get_param (info, i)));\n+\n+      if (known_aggs)\n+\t{\n+\t  VEC (ipa_agg_jf_item_t, gc) *agg_items;\n+\t  struct ipa_agg_jump_function *ajf;\n+\n+\t  agg_items = context_independent_aggregate_values (plats);\n+\t  ajf = &VEC_index (ipa_agg_jump_function_t, *known_aggs, i);\n+\t  ajf->items = agg_items;\n+\t  ajf->by_ref = plats->aggs_by_ref;\n+\t  ret |= agg_items != NULL;\n+\t}\n     }\n \n   return ret;\n }\n \n+/* The current interface in ipa-inline-analysis requires a pointer vector.\n+   Create it.\n+\n+   FIXME: That interface should be re-worked, this is slightly silly.  Still,\n+   I'd like to discuss how to change it first and this demonstrates the\n+   issue.  */\n+\n+static VEC (ipa_agg_jump_function_p, heap) *\n+agg_jmp_p_vec_for_t_vec (VEC (ipa_agg_jump_function_t, heap) *known_aggs)\n+{\n+  VEC (ipa_agg_jump_function_p, heap) *ret;\n+  struct ipa_agg_jump_function *ajf;\n+  int i;\n+\n+  ret = VEC_alloc (ipa_agg_jump_function_p, heap,\n+\t\t   VEC_length (ipa_agg_jump_function_t, known_aggs));\n+  FOR_EACH_VEC_ELT (ipa_agg_jump_function_t, known_aggs, i, ajf)\n+    VEC_quick_push (ipa_agg_jump_function_p, ret, ajf);\n+  return ret;\n+}\n+\n /* Iterate over known values of parameters of NODE and estimate the local\n    effects in terms of time and size they have.  */\n \n@@ -1317,6 +1779,8 @@ estimate_local_effects (struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n   VEC (tree, heap) *known_csts, *known_binfos;\n+  VEC (ipa_agg_jump_function_t, heap) *known_aggs;\n+  VEC (ipa_agg_jump_function_p, heap) *known_aggs_ptrs;\n   bool always_const;\n   int base_time = inline_summary (node)->time;\n   int removable_params_cost;\n@@ -1329,18 +1793,21 @@ estimate_local_effects (struct cgraph_node *node)\n \t     cgraph_node_name (node), node->uid, base_time);\n \n   always_const = gather_context_independent_values (info, &known_csts,\n-\t\t\t\t\t\t    &known_binfos,\n+\t\t\t\t\t\t    &known_binfos, &known_aggs,\n \t\t\t\t\t\t    &removable_params_cost);\n+  known_aggs_ptrs = agg_jmp_p_vec_for_t_vec (known_aggs);\n   if (always_const)\n     {\n       struct caller_statistics stats;\n+      inline_hints hints;\n       int time, size;\n \n       init_caller_stats (&stats);\n       cgraph_for_node_and_aliases (node, gather_caller_stats, &stats, false);\n       estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n-\t\t\t\t\t &size, &time);\n+\t\t\t\t\t known_aggs_ptrs, &size, &time, &hints);\n       time -= devirtualization_time_bonus (node, known_csts, known_binfos);\n+      time -= hint_time_bonus (hints);\n       time -= removable_params_cost;\n       size -= stats.n_calls * removable_params_cost;\n \n@@ -1381,7 +1848,8 @@ estimate_local_effects (struct cgraph_node *node)\n \n   for (i = 0; i < count ; i++)\n     {\n-      struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      struct ipcp_lattice *lat = &plats->itself;\n       struct ipcp_value *val;\n       int emc;\n \n@@ -1394,14 +1862,15 @@ estimate_local_effects (struct cgraph_node *node)\n       for (val = lat->values; val; val = val->next)\n \t{\n \t  int time, size, time_benefit;\n+\t  inline_hints hints;\n \n \t  if (TREE_CODE (val->value) != TREE_BINFO)\n \t    {\n \t      VEC_replace (tree, known_csts, i, val->value);\n \t      VEC_replace (tree, known_binfos, i, NULL_TREE);\n \t      emc = estimate_move_cost (TREE_TYPE (val->value));\n \t    }\n-\t  else if (lat->virt_call)\n+\t  else if (plats->virt_call)\n \t    {\n \t      VEC_replace (tree, known_csts, i, NULL_TREE);\n \t      VEC_replace (tree, known_binfos, i, val->value);\n@@ -1411,9 +1880,11 @@ estimate_local_effects (struct cgraph_node *node)\n \t    continue;\n \n \t  estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n-\t\t\t\t\t     &size, &time);\n+\t\t\t\t\t     known_aggs_ptrs, &size, &time,\n+\t\t\t\t\t     &hints);\n \t  time_benefit = base_time - time\n \t    + devirtualization_time_bonus (node, known_csts, known_binfos)\n+\t    + hint_time_bonus (hints)\n \t    + removable_params_cost + emc;\n \n \t  gcc_checking_assert (size >=0);\n@@ -1437,10 +1908,79 @@ estimate_local_effects (struct cgraph_node *node)\n \t  val->local_time_benefit = time_benefit;\n \t  val->local_size_cost = size;\n \t}\n+      VEC_replace (tree, known_binfos, i, NULL_TREE);\n+      VEC_replace (tree, known_csts, i, NULL_TREE);\n+    }\n+\n+  for (i = 0; i < count ; i++)\n+    {\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      struct ipa_agg_jump_function *ajf;\n+      struct ipcp_agg_lattice *aglat;\n+\n+      if (plats->aggs_bottom || !plats->aggs)\n+\tcontinue;\n+\n+      ajf = &VEC_index (ipa_agg_jump_function_t, known_aggs, i);\n+      for (aglat = plats->aggs; aglat; aglat = aglat->next)\n+\t{\n+\t  struct ipcp_value *val;\n+\t  if (aglat->bottom || !aglat->values\n+\t      /* If the following is true, the one value is in known_aggs.  */\n+\t      || (!plats->aggs_contain_variable\n+\t\t  && ipa_lat_is_single_const (aglat)))\n+\t    continue;\n+\n+\t  for (val = aglat->values; val; val = val->next)\n+\t    {\n+\t      int time, size, time_benefit;\n+\t      struct ipa_agg_jf_item item;\n+\t      inline_hints hints;\n+\n+\t      item.offset = aglat->offset;\n+\t      item.value = val->value;\n+\t      VEC_safe_push (ipa_agg_jf_item_t, gc, ajf->items, item);\n+\n+\t      estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n+\t\t\t\t\t\t known_aggs_ptrs, &size, &time,\n+\t\t\t\t\t\t &hints);\n+\t      time_benefit = base_time - time\n+\t\t+ devirtualization_time_bonus (node, known_csts, known_binfos)\n+\t\t+ hint_time_bonus (hints);\n+\t      gcc_checking_assert (size >=0);\n+\t      if (size == 0)\n+\t\tsize = 1;\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \" - estimates for value \");\n+\t\t  print_ipcp_constant_value (dump_file, val->value);\n+\t\t  fprintf (dump_file, \" for parameter \");\n+\t\t  print_generic_expr (dump_file, ipa_get_param (info, i), 0);\n+\t\t  fprintf (dump_file, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t\t       \"]: time_benefit: %i, size: %i\\n\",\n+\t\t\t\t       plats->aggs_by_ref ? \"ref \" : \"\",\n+\t\t\t\t       aglat->offset, time_benefit, size);\n+\t\t}\n+\n+\t      val->local_time_benefit = time_benefit;\n+\t      val->local_size_cost = size;\n+\t      VEC_pop (ipa_agg_jf_item_t, ajf->items);\n+\t    }\n+\t}\n+    }\n+\n+  for (i = 0; i < count ; i++)\n+    {\n+      VEC_free (ipa_agg_jf_item_t, gc,\n+                VEC_index (ipa_agg_jump_function_t, known_aggs, i).items);\n+      VEC_index (ipa_agg_jump_function_t, known_aggs, i).items = NULL;\n     }\n \n   VEC_free (tree, heap, known_csts);\n   VEC_free (tree, heap, known_binfos);\n+  VEC_free (ipa_agg_jump_function_t, heap, known_aggs);\n+  VEC_free (ipa_agg_jump_function_p, heap, known_aggs_ptrs);\n }\n \n \n@@ -1510,13 +2050,20 @@ add_all_node_vals_to_toposort (struct cgraph_node *node)\n \n   for (i = 0; i < count ; i++)\n     {\n-      struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      struct ipcp_lattice *lat = &plats->itself;\n+      struct ipcp_agg_lattice *aglat;\n       struct ipcp_value *val;\n \n-      if (lat->bottom || !lat->values)\n-\tcontinue;\n-      for (val = lat->values; val; val = val->next)\n-\tadd_val_to_toposort (val);\n+      if (!lat->bottom)\n+\tfor (val = lat->values; val; val = val->next)\n+\t  add_val_to_toposort (val);\n+\n+      if (!plats->aggs_bottom)\n+\tfor (aglat = plats->aggs; aglat; aglat = aglat->next)\n+\t  if (!aglat->bottom)\n+\t    for (val = aglat->values; val; val = val->next)\n+\t      add_val_to_toposort (val);\n     }\n }\n \n@@ -1649,7 +2196,7 @@ ipcp_propagate_stage (struct topo_info *topo)\n     determine_versionability (node);\n     if (cgraph_function_with_gimple_body_p (node))\n       {\n-\tinfo->lattices = XCNEWVEC (struct ipcp_lattice,\n+\tinfo->lattices = XCNEWVEC (struct ipcp_param_lattices,\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n       }\n@@ -1734,12 +2281,24 @@ ipcp_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n   VEC_replace (cgraph_edge_p, next_edge_clone, src->uid, dst);\n }\n \n-/* Get the next clone in the linked list of clones of an edge.  */\n+/* See if NODE is a clone with a known aggregate value at a given OFFSET of a\n+   parameter with the given INDEX.  */\n \n-static inline struct cgraph_edge *\n-get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n+static tree\n+get_clone_agg_value (struct cgraph_node *node, HOST_WIDEST_INT offset,\n+\t\t     int index)\n {\n-  return VEC_index (cgraph_edge_p, next_edge_clone, cs->uid);\n+  struct ipa_agg_replacement_value *aggval;\n+\n+  aggval = ipa_get_agg_replacements_for_node (node);\n+  while (aggval)\n+    {\n+      if (aggval->offset == offset\n+\t  && aggval->index == index)\n+\treturn aggval->value;\n+      aggval = aggval->next;\n+    }\n+  return NULL_TREE;\n }\n \n /* Return true if edge CS does bring about the value described by SRC.  */\n@@ -1758,21 +2317,45 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n \n   if (caller_info->ipcp_orig_node)\n     {\n-      tree t = VEC_index (tree, caller_info->known_vals, src->index);\n+      tree t;\n+      if (src->offset == -1)\n+\tt = VEC_index (tree, caller_info->known_vals, src->index);\n+      else\n+\tt = get_clone_agg_value (cs->caller, src->offset, src->index);\n       return (t != NULL_TREE\n \t      && values_equal_for_ipcp_p (src->val->value, t));\n     }\n   else\n     {\n-      struct ipcp_lattice *lat = ipa_get_lattice (caller_info, src->index);\n-      if (ipa_lat_is_single_const (lat)\n-\t  && values_equal_for_ipcp_p (src->val->value, lat->values->value))\n-\treturn true;\n+      struct ipcp_agg_lattice *aglat;\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n+\t\t\t\t\t\t\t\t src->index);\n+      if (src->offset == -1)\n+\treturn (ipa_lat_is_single_const (&plats->itself)\n+\t\t&& values_equal_for_ipcp_p (src->val->value,\n+\t\t\t\t\t    plats->itself.values->value));\n       else\n-\treturn false;\n+\t{\n+\t  if (plats->aggs_bottom || plats->aggs_contain_variable)\n+\t    return false;\n+\t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n+\t    if (aglat->offset == src->offset)\n+\t      return  (ipa_lat_is_single_const (aglat)\n+\t\t       && values_equal_for_ipcp_p (src->val->value,\n+\t\t\t\t\t\t   aglat->values->value));\n+\t}\n+      return false;\n     }\n }\n \n+/* Get the next clone in the linked list of clones of an edge.  */\n+\n+static inline struct cgraph_edge *\n+get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n+{\n+  return VEC_index (cgraph_edge_p, next_edge_clone, cs->uid);\n+}\n+\n /* Given VAL, iterate over all its sources and if they still hold, add their\n    edge frequency and their number into *FREQUENCY and *CALLER_COUNT\n    respectively.  */\n@@ -2009,6 +2592,7 @@ update_specialized_profile (struct cgraph_node *new_node,\n static struct cgraph_node *\n create_specialized_node (struct cgraph_node *node,\n \t\t\t VEC (tree, heap) *known_vals,\n+\t\t\t struct ipa_agg_replacement_value *aggvals,\n \t\t\t VEC (cgraph_edge_p,heap) *callers)\n {\n   struct ipa_node_params *new_info, *info = IPA_NODE_REF (node);\n@@ -2053,9 +2637,14 @@ create_specialized_node (struct cgraph_node *node,\n \n   new_node = cgraph_create_virtual_clone (node, callers, replace_trees,\n \t\t\t\t\t  args_to_skip, \"constprop\");\n+  ipa_set_node_agg_value_chain (new_node, aggvals);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"     the new node is %s/%i.\\n\",\n-\t     cgraph_node_name (new_node), new_node->uid);\n+    {\n+      fprintf (dump_file, \"     the new node is %s/%i.\\n\",\n+\t       cgraph_node_name (new_node), new_node->uid);\n+      if (aggvals)\n+\tipa_dump_agg_replacement_values (dump_file, aggvals);\n+    }\n   gcc_checking_assert (ipa_node_params_vector\n \t\t       && (VEC_length (ipa_node_params_t,\n \t\t\t\t       ipa_node_params_vector)\n@@ -2076,9 +2665,9 @@ create_specialized_node (struct cgraph_node *node,\n    CALLERS.  */\n \n static void\n-find_more_values_for_callers_subset (struct cgraph_node *node,\n-\t\t\t\t     VEC (tree, heap) *known_vals,\n-\t\t\t\t     VEC (cgraph_edge_p,heap) *callers)\n+find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n+\t\t\t\t\t    VEC (tree, heap) *known_vals,\n+\t\t\t\t\t    VEC (cgraph_edge_p,heap) *callers)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n@@ -2089,7 +2678,7 @@ find_more_values_for_callers_subset (struct cgraph_node *node,\n       tree newval = NULL_TREE;\n       int j;\n \n-      if (ipa_get_lattice (info, i)->bottom\n+      if (ipa_get_scalar_lat (info, i)->bottom\n \t  || VEC_index (tree, known_vals, i))\n \tcontinue;\n \n@@ -2120,7 +2709,7 @@ find_more_values_for_callers_subset (struct cgraph_node *node,\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \"    adding an extra known value \");\n+\t      fprintf (dump_file, \"    adding an extra known scalar value \");\n \t      print_ipcp_constant_value (dump_file, newval);\n \t      fprintf (dump_file, \" for parameter \");\n \t      print_generic_expr (dump_file, ipa_get_param (info, i), 0);\n@@ -2132,6 +2721,391 @@ find_more_values_for_callers_subset (struct cgraph_node *node,\n     }\n }\n \n+/* Go through PLATS and create a vector of values consisting of values and\n+   offsets (minus OFFSET) of lattices that contain only a single value.  */\n+\n+static VEC (ipa_agg_jf_item_t, heap) *\n+copy_plats_to_inter (struct ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n+{\n+  VEC (ipa_agg_jf_item_t, heap) *res = NULL;\n+\n+  if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n+    return NULL;\n+\n+  for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n+    if (ipa_lat_is_single_const (aglat))\n+      {\n+\tstruct ipa_agg_jf_item ti;\n+\tti.offset = aglat->offset - offset;\n+\tti.value = aglat->values->value;\n+\tVEC_safe_push (ipa_agg_jf_item_t, heap, res, ti);\n+      }\n+  return res;\n+}\n+\n+/* Intersect all values in INTER with single value lattices in PLATS (while\n+   subtracting OFFSET).  */\n+\n+static void\n+intersect_with_plats (struct ipcp_param_lattices *plats,\n+\t\t      VEC (ipa_agg_jf_item_t, heap) **inter,\n+\t\t      HOST_WIDE_INT offset)\n+{\n+  struct ipcp_agg_lattice *aglat;\n+  struct ipa_agg_jf_item *item;\n+  int k;\n+\n+  if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n+    {\n+      VEC_free (ipa_agg_jf_item_t, heap, *inter);\n+      *inter = NULL;\n+      return;\n+    }\n+\n+  aglat = plats->aggs;\n+  FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, *inter, k, item)\n+    {\n+      bool found = false;\n+      if (!item->value)\n+\tcontinue;\n+      while (aglat)\n+\t{\n+\t  if (aglat->offset - offset > item->offset)\n+\t    break;\n+\t  if (aglat->offset - offset == item->offset)\n+\t    {\n+\t      gcc_checking_assert (item->value);\n+\t      if (values_equal_for_ipcp_p (item->value, aglat->values->value))\n+\t\tfound = true;\n+\t      break;\n+\t    }\n+\t  aglat = aglat->next;\n+\t}\n+      if (!found)\n+\titem->value = NULL_TREE;\n+    }\n+}\n+\n+/* Copy agggregate replacement values of NODE (which is an IPA-CP clone) to the\n+   vector result while subtracting OFFSET from the individual value offsets.  */\n+\n+static VEC (ipa_agg_jf_item_t, heap) *\n+agg_replacements_to_vector (struct cgraph_node *node, HOST_WIDE_INT offset)\n+{\n+  struct ipa_agg_replacement_value *av;\n+  VEC (ipa_agg_jf_item_t, heap) *res = NULL;\n+\n+  for (av = ipa_get_agg_replacements_for_node (node); av; av = av->next)\n+    {\n+      struct ipa_agg_jf_item item;\n+      gcc_checking_assert (av->value);\n+      item.offset = av->offset - offset;\n+      item.value = av->value;\n+      VEC_safe_push (ipa_agg_jf_item_t, heap, res, item);\n+    }\n+\n+  return res;\n+}\n+\n+/* Intersect all values in INTER with those that we have already scheduled to\n+   be replaced in parameter number INDEX of NODE, which is an IPA-CP clone\n+   (while subtracting OFFSET).  */\n+\n+static void\n+intersect_with_agg_replacements (struct cgraph_node *node, int index,\n+\t\t\t\t VEC (ipa_agg_jf_item_t, heap) **inter,\n+\t\t\t\t HOST_WIDE_INT offset)\n+{\n+  struct ipa_agg_replacement_value *srcvals;\n+  struct ipa_agg_jf_item *item;\n+  int i;\n+\n+  srcvals = ipa_get_agg_replacements_for_node (node);\n+  if (!srcvals)\n+    {\n+      VEC_free (ipa_agg_jf_item_t, heap, *inter);\n+      *inter = NULL;\n+      return;\n+    }\n+\n+  FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, *inter, i, item)\n+    {\n+      struct ipa_agg_replacement_value *av;\n+      bool found = false;\n+      if (!item->value)\n+\tcontinue;\n+      for (av = srcvals; av; av = av->next)\n+\t{\n+\t  gcc_checking_assert (av->value);\n+\t  if (av->index == index\n+\t      && av->offset - offset == item->offset)\n+\t    {\n+\t      if (values_equal_for_ipcp_p (item->value, av->value))\n+\t\tfound = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!found)\n+\titem->value = NULL_TREE;\n+    }\n+}\n+\n+/* Look at edges in CALLERS and collect all known aggregate values that arrive\n+   from all of them.  */\n+\n+static struct ipa_agg_replacement_value *\n+find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n+\t\t\t\t\t  VEC (cgraph_edge_p,heap) *callers)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  struct ipa_agg_replacement_value *res = NULL;\n+  struct cgraph_edge *cs;\n+  int i, j, count = ipa_get_param_count (info);\n+\n+  FOR_EACH_VEC_ELT (cgraph_edge_p, callers, j, cs)\n+    {\n+      int c = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n+      if (c < count)\n+\tcount = c;\n+    }\n+\n+  for (i = 0; i < count ; i++)\n+    {\n+      struct cgraph_edge *cs;\n+      VEC (ipa_agg_jf_item_t, heap) *inter = NULL;\n+      struct ipa_agg_jf_item *item;\n+      int j;\n+\n+      /* Among other things, the following check should deal with all by_ref\n+\t mismatches.  */\n+      if (ipa_get_parm_lattices (info, i)->aggs_bottom)\n+\tcontinue;\n+\n+      FOR_EACH_VEC_ELT (cgraph_edge_p, callers, j, cs)\n+\t{\n+\t  struct ipa_jump_func *jfunc;\n+\t  jfunc = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t  if (jfunc->type == IPA_JF_PASS_THROUGH\n+\t      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+\t    {\n+\t      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+\t      int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+\n+\t      if (caller_info->ipcp_orig_node)\n+\t\t{\n+\t\t  if (!inter)\n+\t\t    inter = agg_replacements_to_vector (cs->caller, 0);\n+\t\t  else\n+\t\t    intersect_with_agg_replacements (cs->caller, src_idx,\n+\t\t\t\t\t\t     &inter, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct ipcp_param_lattices *src_plats;\n+\t\t  src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n+\t\t  /* Currently we do not produce clobber aggregate jump\n+\t\t     functions, adjust when we do.  */\n+\t\t  gcc_checking_assert (!jfunc->agg.items);\n+\t\t  if (!inter)\n+\t\t    inter = copy_plats_to_inter (src_plats, 0);\n+\t\t  else\n+\t\t    intersect_with_plats (src_plats, &inter, 0);\n+\t\t}\n+\t    }\n+\t  else if (jfunc->type == IPA_JF_ANCESTOR\n+\t\t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n+\t    {\n+\t      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+\t      int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t      struct ipcp_param_lattices *src_plats;\n+\t      HOST_WIDE_INT delta = ipa_get_jf_ancestor_offset (jfunc);\n+\n+\t      if (info->ipcp_orig_node)\n+\t\t{\n+\t\t  if (!inter)\n+\t\t    inter = agg_replacements_to_vector (cs->caller, delta);\n+\t\t  else\n+\t\t    intersect_with_agg_replacements (cs->caller, i, &inter,\n+\t\t\t\t\t\t     delta);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  src_plats = ipa_get_parm_lattices (caller_info, src_idx);;\n+\t\t  /* Currently we do not produce clobber aggregate jump\n+\t\t     functions, adjust when we do.  */\n+\t\t  gcc_checking_assert (!jfunc->agg.items);\n+\t\t  if (!inter)\n+\t\t    inter = copy_plats_to_inter (src_plats, delta);\n+\t\t  else\n+\t\t    intersect_with_plats (src_plats, &inter, delta);\n+\t\t}\n+\t    }\n+\t  else if (jfunc->agg.items)\n+\t    {\n+\t      int k;\n+\n+\t      if (!inter)\n+\t\tinter = VEC_copy (ipa_agg_jf_item, heap, jfunc->agg.items);\n+\t      else\n+\t\tFOR_EACH_VEC_ELT (ipa_agg_jf_item_t, inter, k, item)\n+\t\t  {\n+\t\t    int l = 0;\n+\t\t    bool found = false;;\n+\n+\t\t    if (!item->value)\n+\t\t      continue;\n+\n+\t\t    while ((unsigned) l < VEC_length (ipa_agg_jf_item_t,\n+\t\t\t\t\t\t      jfunc->agg.items))\n+\t\t      {\n+\t\t\tstruct ipa_agg_jf_item *ti;\n+\t\t        ti = &VEC_index (ipa_agg_jf_item_t,\n+\t\t\t\t\t jfunc->agg.items, l);\n+\t\t\tif (ti->offset > item->offset)\n+\t\t\t  break;\n+\t\t\tif (ti->offset == item->offset)\n+\t\t\t  {\n+\t\t\t    gcc_checking_assert (ti->value);\n+\t\t\t    if (values_equal_for_ipcp_p (item->value,\n+\t\t\t\t\t\t\t  ti->value))\n+\t\t\t      found = true;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\tl++;\n+\t\t      }\n+\t\t    if (!found)\n+\t\t      item->value = NULL;\n+\t\t  }\n+\t    }\n+\t  else\n+\t    goto next_param;\n+\n+\t  if (!inter)\n+\t    goto next_param;\n+\t}\n+\n+      FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, inter, j, item)\n+\t{\n+\t  struct ipa_agg_replacement_value *v;\n+\n+\t  if (!item->value)\n+\t    continue;\n+\n+\t  v = ggc_alloc_ipa_agg_replacement_value ();\n+\t  v->index = i;\n+\t  v->offset = item->offset;\n+\t  v->value = item->value;\n+\t  v->next = res;\n+\t  res = v;\n+\t}\n+\n+    next_param:\n+      if (inter)\n+\tVEC_free (ipa_agg_jf_item, heap, inter);\n+    }\n+  return res;\n+}\n+\n+/* Turn KNOWN_AGGS into a list of aggreate replacement values.  */\n+\n+static struct ipa_agg_replacement_value *\n+known_aggs_to_agg_replacement_list (VEC (ipa_agg_jump_function_t,\n+\t\t\t\t\t heap) *known_aggs)\n+{\n+  struct ipa_agg_replacement_value *res = NULL;\n+  struct ipa_agg_jump_function *aggjf;\n+  struct ipa_agg_jf_item *item;\n+  int i, j;\n+\n+  FOR_EACH_VEC_ELT (ipa_agg_jump_function_t, known_aggs, i, aggjf)\n+    FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, aggjf->items, j, item)\n+      {\n+\tstruct ipa_agg_replacement_value *v;\n+\tv = ggc_alloc_ipa_agg_replacement_value ();\n+\tv->index = i;\n+\tv->offset = item->offset;\n+\tv->value = item->value;\n+\tv->next = res;\n+\tres = v;\n+      }\n+  return res;\n+}\n+\n+/* Determine whether CS also brings all scalar values that the NODE is\n+   specialized for.  */\n+\n+static bool\n+cgraph_edge_brings_all_scalars_for_node (struct cgraph_edge *cs,\n+\t\t\t\t\t struct cgraph_node *node)\n+{\n+  struct ipa_node_params *dest_info = IPA_NODE_REF (node);\n+  int count = ipa_get_param_count (dest_info);\n+  struct ipa_node_params *caller_info;\n+  struct ipa_edge_args *args;\n+  int i;\n+\n+  caller_info = IPA_NODE_REF (cs->caller);\n+  args = IPA_EDGE_REF (cs);\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipa_jump_func *jump_func;\n+      tree val, t;\n+\n+      val = VEC_index (tree, dest_info->known_vals, i);\n+      if (!val)\n+\tcontinue;\n+\n+      if (i >= ipa_get_cs_argument_count (args))\n+\treturn false;\n+      jump_func = ipa_get_ith_jump_func (args, i);\n+      t = ipa_value_from_jfunc (caller_info, jump_func);\n+      if (!t || !values_equal_for_ipcp_p (val, t))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Determine whether CS also brings all aggregate values that NODE is\n+   specialized for.  */\n+static bool\n+cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n+\t\t\t\t\t  struct cgraph_node *node)\n+{\n+  struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+  struct ipa_agg_replacement_value *aggval;\n+\n+  aggval = ipa_get_agg_replacements_for_node (node);\n+  while (aggval)\n+    {\n+      bool found = false;\n+      struct ipcp_param_lattices *plats;\n+      plats = ipa_get_parm_lattices (caller_info, aggval->index);\n+      if (plats->aggs_bottom || plats->aggs_contain_variable)\n+\treturn false;\n+      for (struct ipcp_agg_lattice *aglat = plats->aggs;\n+\t   aglat;\n+\t   aglat = aglat->next)\n+\t  if (aglat->offset == aggval->offset)\n+\t    {\n+\t      if (ipa_lat_is_single_const (aglat)\n+\t\t  && values_equal_for_ipcp_p (aggval->value,\n+\t\t\t\t\t      aglat->values->value))\n+\t\t{\n+\t\t  found = true;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\treturn false;\n+\t    }\n+\n+      if (!found)\n+\treturn false;\n+\n+      aggval = aggval->next;\n+    }\n+  return true;\n+}\n+\n /* Given an original NODE and a VAL for which we have already created a\n    specialized clone, look whether there are incoming edges that still lead\n    into the old node but now also bring the requested value and also conform to\n@@ -2141,9 +3115,7 @@ find_more_values_for_callers_subset (struct cgraph_node *node,\n static void\n perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n {\n-  struct ipa_node_params *dest_info = IPA_NODE_REF (val->spec_node);\n   struct ipcp_value_source *src;\n-  int count = ipa_get_param_count (dest_info);\n   gcov_type redirected_sum = 0;\n \n   for (src = val->sources; src; src = src->next)\n@@ -2152,42 +3124,14 @@ perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n       while (cs)\n \t{\n \t  enum availability availability;\n-\t  bool insufficient = false;\n \n \t  if (cgraph_function_node (cs->callee, &availability) == node\n \t      && availability > AVAIL_OVERWRITABLE\n \t      && cgraph_edge_brings_value_p (cs, src))\n \t    {\n-\t      struct ipa_node_params *caller_info;\n-\t      struct ipa_edge_args *args;\n-\t      int i;\n-\n-\t      caller_info = IPA_NODE_REF (cs->caller);\n-\t      args = IPA_EDGE_REF (cs);\n-\t      for (i = 0; i < count; i++)\n-\t\t{\n-\t\t  struct ipa_jump_func *jump_func;\n-\t\t  tree val, t;\n-\n-\t\t  val = VEC_index (tree, dest_info->known_vals, i);\n-\t\t  if (!val)\n-\t\t    continue;\n-\n-\t\t  if (i >= ipa_get_cs_argument_count (args))\n-\t\t    {\n-\t\t      insufficient = true;\n-\t\t      break;\n-\t\t    }\n-\t\t  jump_func = ipa_get_ith_jump_func (args, i);\n-\t\t  t = ipa_value_from_jfunc (caller_info, jump_func);\n-\t\t  if (!t || !values_equal_for_ipcp_p (val, t))\n-\t\t    {\n-\t\t      insufficient = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t      if (!insufficient)\n+\t      if (cgraph_edge_brings_all_scalars_for_node (cs, val->spec_node)\n+\t\t  && cgraph_edge_brings_all_agg_vals_for_node (cs,\n+\t\t\t\t\t\t\t       val->spec_node))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \" - adding an extra caller %s/%i\"\n@@ -2224,6 +3168,102 @@ move_binfos_to_values (VEC (tree, heap) *known_vals,\n       VEC_replace (tree, known_vals, i, t);\n }\n \n+/* Return true if there is a replacement equivalent to VALUE, INDEX and OFFSET\n+   among those in the AGGVALS list.  */\n+\n+DEBUG_FUNCTION bool\n+ipcp_val_in_agg_replacements_p (struct ipa_agg_replacement_value *aggvals,\n+\t\t\t\tint index, HOST_WIDE_INT offset, tree value)\n+{\n+  while (aggvals)\n+    {\n+      if (aggvals->index == index\n+\t  && aggvals->offset == offset\n+\t  && values_equal_for_ipcp_p (aggvals->value, value))\n+\treturn true;\n+      aggvals = aggvals->next;\n+    }\n+  return false;\n+}\n+\n+/* Decide wheter to create a special version of NODE for value VAL of parameter\n+   at the given INDEX.  If OFFSET is -1, the value is for the parameter itself,\n+   otherwise it is stored at the given OFFSET of the parameter.  KNOWN_CSTS,\n+   KNOWN_BINFOS and KNOWN_AGGS describe the other already known values.  */\n+\n+static bool\n+decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n+\t\t    struct ipcp_value *val, VEC (tree, heap) *known_csts,\n+\t\t    VEC (tree, heap) *known_binfos)\n+{\n+  struct ipa_agg_replacement_value *aggvals;\n+  int freq_sum, caller_count;\n+  gcov_type count_sum;\n+  VEC (cgraph_edge_p, heap) *callers;\n+  VEC (tree, heap) *kv;\n+\n+  if (val->spec_node)\n+    {\n+      perhaps_add_new_callers (node, val);\n+      return false;\n+    }\n+  else if (val->local_size_cost + overall_size > max_new_size)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"   Ignoring candidate value because \"\n+\t\t \"max_new_size would be reached with %li.\\n\",\n+\t\t val->local_size_cost + overall_size);\n+      return false;\n+    }\n+  else if (!get_info_about_necessary_edges (val, &freq_sum, &count_sum,\n+\t\t\t\t\t    &caller_count))\n+    return false;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \" - considering value \");\n+      print_ipcp_constant_value (dump_file, val->value);\n+      fprintf (dump_file, \" for parameter \");\n+      print_generic_expr (dump_file, ipa_get_param (IPA_NODE_REF (node),\n+\t\t\t\t\t\t    index), 0);\n+      if (offset != -1)\n+\tfprintf (dump_file, \", offset: \" HOST_WIDE_INT_PRINT_DEC, offset);\n+      fprintf (dump_file, \" (caller_count: %i)\\n\", caller_count);\n+    }\n+\n+  if (!good_cloning_opportunity_p (node, val->local_time_benefit,\n+\t\t\t\t   freq_sum, count_sum,\n+\t\t\t\t   val->local_size_cost)\n+      && !good_cloning_opportunity_p (node,\n+\t\t\t\t      val->local_time_benefit\n+\t\t\t\t      + val->prop_time_benefit,\n+\t\t\t\t      freq_sum, count_sum,\n+\t\t\t\t      val->local_size_cost\n+\t\t\t\t      + val->prop_size_cost))\n+    return false;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Creating a specialized node of %s/%i.\\n\",\n+\t     cgraph_node_name (node), node->uid);\n+\n+  callers = gather_edges_for_value (val, caller_count);\n+  kv = VEC_copy (tree, heap, known_csts);\n+  move_binfos_to_values (kv, known_binfos);\n+  if (offset == -1)\n+    VEC_replace (tree, kv, index, val->value);\n+  find_more_scalar_values_for_callers_subset (node, kv, callers);\n+  aggvals = find_aggregate_values_for_callers_subset (node, callers);\n+  gcc_checking_assert (offset == -1\n+\t\t       || ipcp_val_in_agg_replacements_p (aggvals, index,\n+\t\t\t\t\t\t\t  offset, val->value));\n+  val->spec_node = create_specialized_node (node, kv, aggvals, callers);\n+  overall_size += val->local_size_cost;\n+\n+  /* TODO: If for some lattice there is only one other known value\n+     left, make a special node for it too. */\n+\n+  return true;\n+}\n \n /* Decide whether and what specialized clones of NODE should be created.  */\n \n@@ -2233,6 +3273,7 @@ decide_whether_version_node (struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n   VEC (tree, heap) *known_csts, *known_binfos;\n+  VEC (ipa_agg_jump_function_t, heap) *known_aggs = NULL;\n   bool ret = false;\n \n   if (count == 0)\n@@ -2243,82 +3284,37 @@ decide_whether_version_node (struct cgraph_node *node)\n \t     cgraph_node_name (node), node->uid);\n \n   gather_context_independent_values (info, &known_csts, &known_binfos,\n-\t\t\t\t     NULL);\n+\t\t\t\t     info->clone_for_all_contexts ? &known_aggs\n+\t\t\t\t     : NULL, NULL);\n \n-  for (i = 0; i < count ; i++)\n+  for (i = 0; i < count ;i++)\n     {\n-      struct ipcp_lattice *lat = ipa_get_lattice (info, i);\n+      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      struct ipcp_lattice *lat = &plats->itself;\n       struct ipcp_value *val;\n \n-      if (lat->bottom\n-\t  || VEC_index (tree, known_csts, i)\n-\t  || VEC_index (tree, known_binfos, i))\n-\tcontinue;\n+      if (!lat->bottom\n+\t  && !VEC_index (tree, known_csts, i)\n+\t  && !VEC_index (tree, known_binfos, i))\n+\tfor (val = lat->values; val; val = val->next)\n+\t  ret |= decide_about_value (node, i, -1, val, known_csts,\n+\t\t\t\t     known_binfos);\n \n-      for (val = lat->values; val; val = val->next)\n+      if (!plats->aggs_bottom || !plats->aggs)\n \t{\n-\t  int freq_sum, caller_count;\n-\t  gcov_type count_sum;\n-\t  VEC (cgraph_edge_p, heap) *callers;\n-\t  VEC (tree, heap) *kv;\n-\n-\t  if (val->spec_node)\n-\t    {\n-\t      perhaps_add_new_callers (node, val);\n-\t      continue;\n-\t    }\n-\t  else if (val->local_size_cost + overall_size > max_new_size)\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"   Ignoring candidate value because \"\n-\t\t\t \"max_new_size would be reached with %li.\\n\",\n-\t\t\t val->local_size_cost + overall_size);\n-\t      continue;\n-\t    }\n-\t  else if (!get_info_about_necessary_edges (val, &freq_sum, &count_sum,\n-\t\t\t\t\t\t    &caller_count))\n-\t    continue;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \" - considering value \");\n-\t      print_ipcp_constant_value (dump_file, val->value);\n-\t      fprintf (dump_file, \" for parameter \");\n-\t      print_generic_expr (dump_file, ipa_get_param (info, i), 0);\n-\t      fprintf (dump_file, \" (caller_count: %i)\\n\", caller_count);\n-\t    }\n-\n-\n-\t  if (!good_cloning_opportunity_p (node, val->local_time_benefit,\n-\t\t\t\t\t   freq_sum, count_sum,\n-\t\t\t\t\t   val->local_size_cost)\n-\t      && !good_cloning_opportunity_p (node,\n-\t\t\t\t\t      val->local_time_benefit\n-\t\t\t\t\t      + val->prop_time_benefit,\n-\t\t\t\t\t      freq_sum, count_sum,\n-\t\t\t\t\t      val->local_size_cost\n-\t\t\t\t\t      + val->prop_size_cost))\n-\t    continue;\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  Creating a specialized node of %s/%i.\\n\",\n-\t\t     cgraph_node_name (node), node->uid);\n-\n-\t  callers = gather_edges_for_value (val, caller_count);\n-\t  kv = VEC_copy (tree, heap, known_csts);\n-\t  move_binfos_to_values (kv, known_binfos);\n-\t  VEC_replace (tree, kv, i, val->value);\n-\t  find_more_values_for_callers_subset (node, kv, callers);\n-\t  val->spec_node = create_specialized_node (node, kv, callers);\n-\t  overall_size += val->local_size_cost;\n-\t  info = IPA_NODE_REF (node);\n-\n-\t  /* TODO: If for some lattice there is only one other known value\n-\t     left, make a special node for it too. */\n-\t  ret = true;\n-\n-\t  VEC_replace (tree, kv, i, val->value);\n+\t  struct ipcp_agg_lattice *aglat;\n+\t  struct ipcp_value *val;\n+\t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n+\t    if (!aglat->bottom && aglat->values\n+\t\t/* If the following is false, the one value is in\n+\t\t   known_aggs.  */\n+\t\t&& (plats->aggs_contain_variable\n+\t\t    || !ipa_lat_is_single_const (aglat)))\n+\t      for (val = aglat->values; val; val = val->next)\n+\t\tret |= decide_about_value (node, i, aglat->offset, val,\n+\t\t\t\t\t   known_csts, known_binfos);\n \t}\n+        info = IPA_NODE_REF (node);\n     }\n \n   if (info->clone_for_all_contexts)\n@@ -2332,7 +3328,9 @@ decide_whether_version_node (struct cgraph_node *node)\n \n       callers = collect_callers_of_node (node);\n       move_binfos_to_values (known_csts, known_binfos);\n-      create_specialized_node (node, known_csts, callers);\n+      create_specialized_node (node, known_csts,\n+\t\t\t       known_aggs_to_agg_replacement_list (known_aggs),\n+\t\t\t       callers);\n       info = IPA_NODE_REF (node);\n       info->clone_for_all_contexts = false;\n       ret = true;\n@@ -2466,6 +3464,9 @@ ipcp_driver (void)\n \t\t\t\t\tsizeof (struct ipcp_value), 32);\n   ipcp_sources_pool = create_alloc_pool (\"IPA-CP value sources\",\n \t\t\t\t\t sizeof (struct ipcp_value_source), 64);\n+  ipcp_agg_lattice_pool = create_alloc_pool (\"IPA_CP aggregate lattices\",\n+\t\t\t\t\t     sizeof (struct ipcp_agg_lattice),\n+\t\t\t\t\t     32);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIPA structures before propagation:\\n\");\n@@ -2560,10 +3561,10 @@ struct ipa_opt_pass_d pass_ipa_cp =\n  ipcp_generate_summary,\t\t\t/* generate_summary */\n  ipcp_write_summary,\t\t\t/* write_summary */\n  ipcp_read_summary,\t\t\t/* read_summary */\n- NULL,\t\t\t\t\t/* write_optimization_summary */\n- NULL,\t\t\t\t\t/* read_optimization_summary */\n+ ipa_prop_write_all_agg_replacement,\t/* write_optimization_summary */\n+ ipa_prop_read_all_agg_replacement,\t/* read_optimization_summary */\n  NULL,\t\t\t \t\t/* stmt_fixup */\n  0,\t\t\t\t\t/* TODOs */\n- NULL,\t\t\t\t\t/* function_transform */\n+ ipcp_transform_function,\t\t/* function_transform */\n  NULL,\t\t\t\t\t/* variable_transform */\n };"}, {"sha": "75dc308510693547c24c07c42dbdfdf17ac914ea", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -2913,16 +2913,18 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \n void\n estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n-\t\t\t\t   VEC (tree, heap) *known_vals,\n-\t\t\t\t   VEC (tree, heap) *known_binfos,\n-\t\t                   int *ret_size, int *ret_time)\n+\t\t\t\tVEC (tree, heap) *known_vals,\n+\t\t\t\tVEC (tree, heap) *known_binfos,\n+\t\t\t\tVEC (ipa_agg_jump_function_p, heap) *known_aggs,\n+\t\t\t\tint *ret_size, int *ret_time,\n+\t\t\t\tinline_hints *hints)\n {\n   clause_t clause;\n \n-  clause = evaluate_conditions_for_known_args (node, false, known_vals, NULL);\n-  estimate_node_size_and_time (node, clause, known_vals, known_binfos, NULL,\n-\t\t\t       ret_size, ret_time, NULL,\n-\t\t\t       NULL);\n+  clause = evaluate_conditions_for_known_args (node, false, known_vals,\n+\t\t\t\t\t       known_aggs);\n+  estimate_node_size_and_time (node, clause, known_vals, known_binfos,\n+\t\t\t       known_aggs, ret_size, ret_time, hints, NULL);\n }\n \n /* Translate all conditions from callee representation into caller"}, {"sha": "4791bf0caab34bdb6f239419ea551f4dd11b1db4", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -19,6 +19,8 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#include \"ipa-prop.h\"\n+\n /* Representation of inline parameters that do depend on context function is\n    inlined into (i.e. known constant values of function parameters.\n \n@@ -207,9 +209,9 @@ void initialize_inline_failed (struct cgraph_edge *);\n int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n-\t\t\t\t\tVEC (tree, heap) *known_vals,\n-\t\t\t\t\tVEC (tree, heap) *known_binfos,\n-\t\t\t\t\tint *, int *);\n+\t\t\t\t\tVEC (tree, heap) *, VEC (tree, heap) *,\n+\t\t\t\t\tVEC (ipa_agg_jump_function_p, heap) *,\n+\t\t\t\t\tint *, int *, inline_hints *);\n int do_estimate_growth (struct cgraph_node *);\n void inline_merge_summary (struct cgraph_edge *edge);\n void inline_update_overall_summary (struct cgraph_node *node);"}, {"sha": "f7323a638ed5e9c58fd4a2ea5a9a7f29cdba025b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 411, "deletions": 25, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -40,7 +40,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"params.h\"\n \n-\n /* Intermediate information about a parameter that is only useful during the\n    run of ipa_analyze_node and is not kept afterwards.  */\n \n@@ -52,6 +51,8 @@ struct param_analysis_info\n \n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n+/* Vector of known aggregate values in cloned nodes.  */\n+VEC (ipa_agg_replacement_value_p, gc) *ipa_node_agg_replacements;\n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n@@ -1936,6 +1937,22 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n   info->uses_analysis_done = 1;\n }\n \n+/* Free stuff in PARMS_AINFO, assume there are PARAM_COUNT parameters.  */\n+\n+static void\n+free_parms_ainfo (struct param_analysis_info *parms_ainfo, int param_count)\n+{\n+  int i;\n+\n+  for (i = 0; i < param_count; i++)\n+    {\n+      if (parms_ainfo[i].parm_visited_statements)\n+\tBITMAP_FREE (parms_ainfo[i].parm_visited_statements);\n+      if (parms_ainfo[i].pt_visited_statements)\n+\tBITMAP_FREE (parms_ainfo[i].pt_visited_statements);\n+    }\n+}\n+\n /* Initialize the array describing properties of of formal parameters\n    of NODE, analyze their uses and compute jump functions associated\n    with actual arguments of calls from within NODE.  */\n@@ -1945,7 +1962,7 @@ ipa_analyze_node (struct cgraph_node *node)\n {\n   struct ipa_node_params *info;\n   struct param_analysis_info *parms_ainfo;\n-  int i, param_count;\n+  int param_count;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n@@ -1960,14 +1977,7 @@ ipa_analyze_node (struct cgraph_node *node)\n   ipa_analyze_params_uses (node, parms_ainfo);\n   ipa_compute_jump_functions (node, parms_ainfo);\n \n-  for (i = 0; i < param_count; i++)\n-    {\n-      if (parms_ainfo[i].parm_visited_statements)\n-\tBITMAP_FREE (parms_ainfo[i].parm_visited_statements);\n-      if (parms_ainfo[i].pt_visited_statements)\n-\tBITMAP_FREE (parms_ainfo[i].pt_visited_statements);\n-    }\n-\n+  free_parms_ainfo (parms_ainfo, param_count);\n   pop_cfun ();\n }\n \n@@ -2163,17 +2173,13 @@ ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n     return NULL;\n \n   FOR_EACH_VEC_ELT (ipa_agg_jf_item_t, agg->items, i, item)\n-    {\n-      if (item->offset == offset)\n-\t{\n-\t  /* Currently we do not have clobber values, return NULL for them once\n-\t     we do.  */\n-\t  gcc_checking_assert (is_gimple_ip_invariant (item->value));\n-\t  return item->value;\n-\t}\n-      else if (item->offset > offset)\n-\treturn NULL;\n-    }\n+    if (item->offset == offset)\n+      {\n+\t/* Currently we do not have clobber values, return NULL for them once\n+\t   we do.  */\n+\tgcc_checking_assert (is_gimple_ip_invariant (item->value));\n+\treturn item->value;\n+      }\n   return NULL;\n }\n \n@@ -2436,6 +2442,21 @@ ipa_free_all_node_params (void)\n   ipa_node_params_vector = NULL;\n }\n \n+/* Set the aggregate replacements of NODE to be AGGVALS.  */\n+\n+void\n+ipa_set_node_agg_value_chain (struct cgraph_node *node,\n+\t\t\t      struct ipa_agg_replacement_value *aggvals)\n+{\n+  if (VEC_length (ipa_agg_replacement_value_p, ipa_node_agg_replacements)\n+      <= (unsigned) cgraph_max_uid)\n+    VEC_safe_grow_cleared (ipa_agg_replacement_value_p, gc,\n+\t\t\t   ipa_node_agg_replacements, cgraph_max_uid + 1);\n+\n+  VEC_replace (ipa_agg_replacement_value_p, ipa_node_agg_replacements,\n+\t       node->uid, aggvals);\n+}\n+\n /* Hook that is called by cgraph.c when an edge is removed.  */\n \n static void\n@@ -2455,9 +2476,12 @@ ipa_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n   /* During IPA-CP updating we can be called on not-yet analyze clones.  */\n   if (VEC_length (ipa_node_params_t, ipa_node_params_vector)\n-      <= (unsigned)node->uid)\n-    return;\n-  ipa_free_node_params_substructures (IPA_NODE_REF (node));\n+      > (unsigned)node->uid)\n+    ipa_free_node_params_substructures (IPA_NODE_REF (node));\n+  if (VEC_length (ipa_agg_replacement_value_p, ipa_node_agg_replacements)\n+      > (unsigned)node->uid)\n+    VEC_replace (ipa_agg_replacement_value_p, ipa_node_agg_replacements,\n+\t\t (unsigned)node->uid, NULL);\n }\n \n /* Hook that is called by cgraph.c when an edge is duplicated.  */\n@@ -2491,6 +2515,7 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t   ATTRIBUTE_UNUSED void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n+  struct ipa_agg_replacement_value *old_av, *new_av;\n \n   ipa_check_create_node_params ();\n   old_info = IPA_NODE_REF (src);\n@@ -2503,6 +2528,23 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \n   new_info->uses_analysis_done = old_info->uses_analysis_done;\n   new_info->node_enqueued = old_info->node_enqueued;\n+\n+  old_av = ipa_get_agg_replacements_for_node (src);\n+  if (!old_av)\n+    return;\n+\n+  new_av = NULL;\n+  while (old_av)\n+    {\n+      struct ipa_agg_replacement_value *v;\n+\n+      v = ggc_alloc_ipa_agg_replacement_value ();\n+      memcpy (v, old_av, sizeof (*v));\n+      v->next = new_av;\n+      new_av = v;\n+      old_av = old_av->next;\n+    }\n+  ipa_set_node_agg_value_chain (dst, new_av);\n }\n \n \n@@ -2564,6 +2606,7 @@ ipa_free_all_structures_after_ipa_cp (void)\n       ipa_free_all_node_params ();\n       free_alloc_pool (ipcp_sources_pool);\n       free_alloc_pool (ipcp_values_pool);\n+      free_alloc_pool (ipcp_agg_lattice_pool);\n       ipa_unregister_cgraph_hooks ();\n     }\n }\n@@ -2581,13 +2624,15 @@ ipa_free_all_structures_after_iinln (void)\n     free_alloc_pool (ipcp_sources_pool);\n   if (ipcp_values_pool)\n     free_alloc_pool (ipcp_values_pool);\n+  if (ipcp_agg_lattice_pool)\n+    free_alloc_pool (ipcp_agg_lattice_pool);\n }\n \n /* Print ipa_tree_map data structures of all functions in the\n    callgraph to F.  */\n \n void\n-ipa_print_node_params (FILE * f, struct cgraph_node *node)\n+ipa_print_node_params (FILE *f, struct cgraph_node *node)\n {\n   int i, count;\n   tree temp;\n@@ -3171,6 +3216,23 @@ ipa_dump_param_adjustments (FILE *file, ipa_parm_adjustment_vec adjustments,\n   VEC_free (tree, heap, parms);\n }\n \n+/* Dump the AV linked list.  */\n+\n+void\n+ipa_dump_agg_replacement_values (FILE *f, struct ipa_agg_replacement_value *av)\n+{\n+  bool comma = false;\n+  fprintf (f, \"     Aggregate replacements:\");\n+  for (; av; av = av->next)\n+    {\n+      fprintf (f, \"%s %i[\" HOST_WIDE_INT_PRINT_DEC \"]=\", comma ? \",\" : \"\",\n+\t       av->index, av->offset);\n+      print_generic_expr (f, av->value, 0);\n+      comma = true;\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n /* Stream out jump function JUMP_FUNC to OB.  */\n \n static void\n@@ -3550,3 +3612,327 @@ ipa_update_after_lto_read (void)\n     if (node->analyzed)\n       ipa_initialize_node_params (node);\n }\n+\n+void\n+write_agg_replacement_chain (struct output_block *ob, struct cgraph_node *node)\n+{\n+  int node_ref;\n+  unsigned int count = 0;\n+  lto_symtab_encoder_t encoder;\n+  struct ipa_agg_replacement_value *aggvals, *av;\n+\n+  aggvals = ipa_get_agg_replacements_for_node (node);\n+  encoder = ob->decl_state->symtab_node_encoder;\n+  node_ref = lto_symtab_encoder_encode (encoder, (symtab_node) node);\n+  streamer_write_uhwi (ob, node_ref);\n+\n+  for (av = aggvals; av; av = av->next)\n+    count++;\n+  streamer_write_uhwi (ob, count);\n+\n+  for (av = aggvals; av; av = av->next)\n+    {\n+      streamer_write_uhwi (ob, av->offset);\n+      streamer_write_uhwi (ob, av->index);\n+      stream_write_tree (ob, av->value, true);\n+    }\n+}\n+\n+/* Stream in the aggregate value replacement chain for NODE from IB.  */\n+\n+static void\n+read_agg_replacement_chain (struct lto_input_block *ib,\n+\t\t\t    struct cgraph_node *node,\n+\t\t\t    struct data_in *data_in)\n+{\n+  struct ipa_agg_replacement_value *aggvals = NULL;\n+  unsigned int count, i;\n+\n+  count = streamer_read_uhwi (ib);\n+  for (i = 0; i <count; i++)\n+    {\n+      struct ipa_agg_replacement_value *av;\n+\n+      av = ggc_alloc_ipa_agg_replacement_value ();\n+      av->offset = streamer_read_uhwi (ib);\n+      av->index = streamer_read_uhwi (ib);\n+      av->value = stream_read_tree (ib, data_in);\n+      av->next = aggvals;\n+      aggvals = av;\n+    }\n+  ipa_set_node_agg_value_chain (node, aggvals);\n+}\n+\n+/* Write all aggregate replacement for nodes in set.  */\n+\n+void\n+ipa_prop_write_all_agg_replacement (void)\n+{\n+  struct cgraph_node *node;\n+  struct output_block *ob;\n+  unsigned int count = 0;\n+  lto_symtab_encoder_iterator lsei;\n+  lto_symtab_encoder_t encoder;\n+\n+  if (!ipa_node_agg_replacements)\n+    return;\n+\n+  ob = create_output_block (LTO_section_ipcp_transform);\n+  encoder = ob->decl_state->symtab_node_encoder;\n+  ob->cgraph_node = NULL;\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n+    {\n+      node = lsei_cgraph_node (lsei);\n+      if (cgraph_function_with_gimple_body_p (node)\n+\t  && ipa_get_agg_replacements_for_node (node) != NULL)\n+\tcount++;\n+    }\n+\n+  streamer_write_uhwi (ob, count);\n+\n+  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n+       lsei_next_function_in_partition (&lsei))\n+    {\n+      node = lsei_cgraph_node (lsei);\n+      if (cgraph_function_with_gimple_body_p (node)\n+\t  && ipa_get_agg_replacements_for_node (node) != NULL)\n+\twrite_agg_replacement_chain (ob, node);\n+    }\n+  streamer_write_char_stream (ob->main_stream, 0);\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+/* Read replacements section in file FILE_DATA of length LEN with data\n+   DATA.  */\n+\n+static void\n+read_replacements_section (struct lto_file_decl_data *file_data,\n+\t\t\t   const char *data,\n+\t\t\t   size_t len)\n+{\n+  const struct lto_function_header *header =\n+    (const struct lto_function_header *) data;\n+  const int cfg_offset = sizeof (struct lto_function_header);\n+  const int main_offset = cfg_offset + header->cfg_size;\n+  const int string_offset = main_offset + header->main_size;\n+  struct data_in *data_in;\n+  struct lto_input_block ib_main;\n+  unsigned int i;\n+  unsigned int count;\n+\n+  LTO_INIT_INPUT_BLOCK (ib_main, (const char *) data + main_offset, 0,\n+\t\t\theader->main_size);\n+\n+  data_in = lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\t\theader->string_size, NULL);\n+  count = streamer_read_uhwi (&ib_main);\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      unsigned int index;\n+      struct cgraph_node *node;\n+      lto_symtab_encoder_t encoder;\n+\n+      index = streamer_read_uhwi (&ib_main);\n+      encoder = file_data->symtab_node_encoder;\n+      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n+      gcc_assert (node->analyzed);\n+      read_agg_replacement_chain (&ib_main, node, data_in);\n+    }\n+  lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Read IPA-CP aggregate replacements.  */\n+\n+void\n+ipa_prop_read_all_agg_replacement (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data = lto_get_section_data (file_data,\n+\t\t\t\t\t       LTO_section_ipcp_transform,\n+\t\t\t\t\t       NULL, &len);\n+      if (data)\n+        read_replacements_section (file_data, data, len);\n+    }\n+}\n+\n+/* Adjust the aggregate replacements in AGGVAL to reflect parameters skipped in\n+   NODE.  */\n+\n+static void\n+adjust_agg_replacement_values (struct cgraph_node *node,\n+\t\t\t       struct ipa_agg_replacement_value *aggval)\n+{\n+  struct ipa_agg_replacement_value *v;\n+  int i, c = 0, d = 0, *adj;\n+\n+  if (!node->clone.combined_args_to_skip)\n+    return;\n+\n+  for (v = aggval; v; v = v->next)\n+    {\n+      gcc_assert (v->index >= 0);\n+      if (c < v->index)\n+\tc = v->index;\n+    }\n+  c++;\n+\n+  adj = XALLOCAVEC (int, c);\n+  for (i = 0; i < c; i++)\n+    if (bitmap_bit_p (node->clone.combined_args_to_skip, i))\n+      {\n+\tadj[i] = -1;\n+\td++;\n+      }\n+    else\n+      adj[i] = i - d;\n+\n+  for (v = aggval; v; v = v->next)\n+    v->index = adj[v->index];\n+}\n+\n+\n+/* Function body transformation phase.  */\n+\n+unsigned int\n+ipcp_transform_function (struct cgraph_node *node)\n+{\n+  VEC (ipa_param_descriptor_t, heap) *descriptors = NULL;\n+  struct param_analysis_info *parms_ainfo;\n+  struct ipa_agg_replacement_value *aggval;\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+  int param_count;\n+  bool cfg_changed = false, something_changed = false;\n+\n+  gcc_checking_assert (cfun);\n+  gcc_checking_assert (current_function_decl);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Modification phase of node %s/%i\\n\",\n+\t     cgraph_node_name (node), node->uid);\n+\n+  aggval = ipa_get_agg_replacements_for_node (node);\n+  if (!aggval)\n+      return 0;\n+  param_count = count_formal_params (node->symbol.decl);\n+  if (param_count == 0)\n+    return 0;\n+  adjust_agg_replacement_values (node, aggval);\n+  if (dump_file)\n+    ipa_dump_agg_replacement_values (dump_file, aggval);\n+  parms_ainfo = XALLOCAVEC (struct param_analysis_info, param_count);\n+  memset (parms_ainfo, 0, sizeof (struct param_analysis_info) * param_count);\n+  VEC_safe_grow_cleared (ipa_param_descriptor_t, heap,\n+\t\t\t descriptors, param_count);\n+  ipa_populate_param_decls (node, descriptors);\n+\n+  FOR_EACH_BB (bb)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tstruct ipa_agg_replacement_value *v;\n+\tgimple stmt = gsi_stmt (gsi);\n+\ttree rhs, val, t;\n+\tHOST_WIDE_INT offset;\n+\tint index;\n+\tbool by_ref, vce;\n+\n+\tif (!gimple_assign_load_p (stmt))\n+\t  continue;\n+\trhs = gimple_assign_rhs1 (stmt);\n+\tif (!is_gimple_reg_type (TREE_TYPE (rhs)))\n+\t  continue;\n+\n+\tvce = false;\n+\tt = rhs;\n+\twhile (handled_component_p (t))\n+\t  {\n+\t    /* V_C_E can do things like convert an array of integers to one\n+               bigger integer and similar things we do not handle below.  */\n+            if (TREE_CODE (rhs) == VIEW_CONVERT_EXPR)\n+\t      {\n+\t\tvce = true;\n+\t\tbreak;\n+\t      }\n+\t    t = TREE_OPERAND (t, 0);\n+\t  }\n+\tif (vce)\n+\t  continue;\n+\n+\tif (!ipa_load_from_parm_agg_1 (descriptors, parms_ainfo, stmt,\n+\t\t\t\t       rhs, &index, &offset, &by_ref))\n+\t  continue;\n+\tfor (v = aggval; v; v = v->next)\n+\t  if (v->index == index\n+\t      && v->offset == offset)\n+\t    break;\n+\tif (!v)\n+\t  continue;\n+\n+\tgcc_checking_assert (is_gimple_ip_invariant (v->value));\n+\tif (!useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (v->value)))\n+\t  {\n+\t    if (fold_convertible_p (TREE_TYPE (rhs), v->value))\n+\t      val = fold_build1 (NOP_EXPR, TREE_TYPE (rhs), v->value);\n+\t    else if (TYPE_SIZE (TREE_TYPE (rhs))\n+\t\t     == TYPE_SIZE (TREE_TYPE (v->value)))\n+\t      val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), v->value);\n+\t    else\n+\t      {\n+\t\tif (dump_file)\n+\t\t  {\n+\t\t    fprintf (dump_file, \"    const \");\n+\t\t    print_generic_expr (dump_file, v->value, 0);\n+\t\t    fprintf (dump_file, \"  can't be converted to type of \");\n+\t\t    print_generic_expr (dump_file, rhs, 0);\n+\t\t    fprintf (dump_file, \"\\n\");\n+\t\t  }\n+\t\tcontinue;\n+\t      }\n+\t  }\n+\telse\n+\t  val = v->value;\n+\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  {\n+\t    fprintf (dump_file, \"Modifying stmt:\\n  \");\n+\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  }\n+\tgimple_assign_set_rhs_from_tree (&gsi, val);\n+\tupdate_stmt (stmt);\n+\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  {\n+\t    fprintf (dump_file, \"into:\\n  \");\n+\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t    fprintf (dump_file, \"\\n\");\n+\t  }\n+\n+\tsomething_changed = true;\n+\tif (maybe_clean_eh_stmt (stmt)\n+\t    && gimple_purge_dead_eh_edges (gimple_bb (stmt)))\n+\t  cfg_changed = true;\n+      }\n+\n+  VEC_replace (ipa_agg_replacement_value_p, ipa_node_agg_replacements,\n+\t       node->uid, NULL);\n+  free_parms_ainfo (parms_ainfo, param_count);\n+  VEC_free (ipa_param_descriptor_t, heap, descriptors);\n+\n+  if (!something_changed)\n+    return 0;\n+  else if (cfg_changed)\n+    return TODO_update_ssa_only_virtuals | TODO_cleanup_cfg;\n+  else\n+    return TODO_update_ssa_only_virtuals;\n+}"}, {"sha": "da6200fbaa4831e41414d3503cdb610515536b54", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -144,6 +144,7 @@ typedef struct GTY(()) ipa_agg_jf_item\n \n DEF_VEC_O (ipa_agg_jf_item_t);\n DEF_VEC_ALLOC_O (ipa_agg_jf_item_t, gc);\n+DEF_VEC_ALLOC_O (ipa_agg_jf_item_t, heap);\n \n /* Aggregate jump function - i.e. description of contents of aggregates passed\n    either by reference or value.  */\n@@ -159,6 +160,9 @@ struct GTY(()) ipa_agg_jump_function\n typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;\n DEF_VEC_P (ipa_agg_jump_function_p);\n DEF_VEC_ALLOC_P (ipa_agg_jump_function_p, heap);\n+typedef struct ipa_agg_jump_function ipa_agg_jump_function_t;\n+DEF_VEC_P (ipa_agg_jump_function_t);\n+DEF_VEC_ALLOC_P (ipa_agg_jump_function_t, heap);\n \n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n@@ -322,7 +326,7 @@ struct ipa_node_params\n   VEC (ipa_param_descriptor_t, heap) *descriptors;\n   /* Pointer to an array of structures describing individual formal\n      parameters.  */\n-  struct ipcp_lattice *lattices;\n+  struct ipcp_param_lattices *lattices;\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node *ipcp_orig_node;\n@@ -380,6 +384,27 @@ ipa_is_param_used (struct ipa_node_params *info, int i)\n   return VEC_index (ipa_param_descriptor_t, info->descriptors, i).used;\n }\n \n+/* Information about replacements done in aggregates for a given node (each\n+   node has its linked list).  */\n+struct GTY(()) ipa_agg_replacement_value\n+{\n+  /* Next item in the linked list.  */\n+  struct ipa_agg_replacement_value *next;\n+  /* Offset within the aggregate.  */\n+  HOST_WIDE_INT offset;\n+  /* The constant value.  */\n+  tree value;\n+  /* The paramter index.  */\n+  int index;\n+};\n+\n+typedef struct ipa_agg_replacement_value *ipa_agg_replacement_value_p;\n+DEF_VEC_P (ipa_agg_replacement_value_p);\n+DEF_VEC_ALLOC_P (ipa_agg_replacement_value_p, gc);\n+\n+void ipa_set_node_agg_value_chain (struct cgraph_node *node,\n+\t\t\t\t   struct ipa_agg_replacement_value *aggvals);\n+\n /* ipa_edge_args stores information related to a callsite and particularly its\n    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */\n typedef struct GTY(()) ipa_edge_args\n@@ -420,6 +445,8 @@ DEF_VEC_ALLOC_O (ipa_edge_args_t, gc);\n \n /* Vector where the parameter infos are actually stored. */\n extern VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n+/* Vector of known aggregate values in cloned nodes.  */\n+extern GTY(()) VEC (ipa_agg_replacement_value_p, gc) *ipa_node_agg_replacements;\n /* Vector where the parameter infos are actually stored. */\n extern GTY(()) VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n@@ -487,6 +514,18 @@ ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)\n \t\t\t\t\t     ipa_edge_args_vector));\n }\n \n+/* Return the aggregate replacements for NODE, if there are any.  */\n+\n+static inline struct ipa_agg_replacement_value *\n+ipa_get_agg_replacements_for_node (struct cgraph_node *node)\n+{\n+  if ((unsigned) node->uid >= VEC_length (ipa_agg_replacement_value_p,\n+\t\t\t\t\t  ipa_node_agg_replacements))\n+    return NULL;\n+  return VEC_index (ipa_agg_replacement_value_p, ipa_node_agg_replacements,\n+\t\t    node->uid);\n+}\n+\n /* Function formal parameters related computations.  */\n void ipa_initialize_node_params (struct cgraph_node *node);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n@@ -517,6 +556,7 @@ void ipcp_verify_propagated_values (void);\n \n extern alloc_pool ipcp_values_pool;\n extern alloc_pool ipcp_sources_pool;\n+extern alloc_pool ipcp_agg_lattice_pool;\n \n /* Structure to describe transformations of formal parameters and actual\n    arguments.  Each instance describes one new parameter and they are meant to\n@@ -589,13 +629,17 @@ void ipa_modify_call_arguments (struct cgraph_edge *, gimple,\n ipa_parm_adjustment_vec ipa_combine_adjustments (ipa_parm_adjustment_vec,\n \t\t\t\t\t\t ipa_parm_adjustment_vec);\n void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n-\n+void ipa_dump_agg_replacement_values (FILE *f,\n+\t\t\t\t      struct ipa_agg_replacement_value *av);\n void ipa_prop_write_jump_functions (void);\n void ipa_prop_read_jump_functions (void);\n+void ipa_prop_write_all_agg_replacement (void);\n+void ipa_prop_read_all_agg_replacement (void);\n void ipa_update_after_lto_read (void);\n int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n tree ipa_value_from_jfunc (struct ipa_node_params *info,\n \t\t\t   struct ipa_jump_func *jfunc);\n+unsigned int ipcp_transform_function (struct cgraph_node *node);\n \n \n /* From tree-sra.c:  */"}, {"sha": "9afe4ff0c0258103dececc8881a412e4234b49a4", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -58,7 +58,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"symbol_nodes\",\n   \"opts\",\n   \"cgraphopt\",\n-  \"inline\"\n+  \"inline\",\n+  \"ipcp_trans\"\n };\n \n "}, {"sha": "4ad2bc98c85ce3516c7d9374f83bc8b17624d687", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -248,6 +248,7 @@ enum lto_section_type\n   LTO_section_opts,\n   LTO_section_cgraph_opt_sum,\n   LTO_section_inline_summary,\n+  LTO_section_ipcp_transform,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "c801c6172942b8b77dbb082411f4909f247a30e1", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -901,6 +901,12 @@ DEFPARAM (PARAM_IPA_MAX_AGG_ITEMS,\n \t  \"jump functions and lattices\",\n \t  16, 0, 0)\n \n+DEFPARAM (PARAM_IPA_CP_LOOP_HINT_BONUS,\n+\t  \"ipa-cp-loop-hint-bonus\",\n+\t  \"Compile-time bonus IPA-CP assigns to candidates which make loop \"\n+\t  \"bounds or strides known.\",\n+\t  64, 0, 0)\n+\n /* WHOPR partitioning configuration.  */\n \n DEFPARAM (PARAM_LTO_PARTITIONS,"}, {"sha": "3fb9de45bb6d9f7b2e352f9ca45c95e8c7b86731", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -1,3 +1,17 @@\n+2012-11-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/53787\n+\t* gcc.dg/ipa/ipa-5.c: Adjust.\n+\t* gcc.dg/ipa/ipcp-agg-1.c: New test.\n+\t* gcc.dg/ipa/ipcp-agg-2.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-agg-3.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-agg-4.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-agg-5.c: Likewise.\n+\t* gcc.dg/ipa/ipcp-agg-6.c: Likewise.\n+\t* gfortran.dg/pr48636.f90: Add -fno-ipa-cp.\n+\t* gfortran.dg/pr48636-2.f90: New test.\n+\t* gfortran.dg/pr53787.f90: Likewise.\n+\n 2012-11-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55226"}, {"sha": "d599d3187fe1a6fa495c079fcdb4437cdc88cf69", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-5.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-5.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -5,18 +5,19 @@\n /* Float & short constants.  */\n \n #include <stdio.h>\n-void t(void);\n+int t(void);\n int g (float b, short c)\n {\n   t();\n   return c + (int)b;\n }\n int f (float a)\n {\n-  t();\n+  int i, j = t();\n   /* a is modified.  */\n   if (a++ > 0)\n-    g (a, 3);\n+    for (i = 0; i < j; i++)\n+      g (a, 3);\n }\n int main ()\n {\n@@ -26,7 +27,7 @@ int main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"Creating a specialized node\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node\" 3 \"cp\"  } } */\n /* { dg-final { scan-ipa-dump \"replacing param c with const 3\" \"cp\"  } } */\n /* { dg-final { scan-ipa-dump \"replacing param a with const 7\" \"cp\"  } } */\n /* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "b2e04f872420ba0c7443bab56fa75b40db7ca384", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-1.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  int i, c = p->c;\n+  int b = p->b;\n+  void *v = (void *) p;\n+\n+  for (i= 0; i< c; i++)\n+    v = blah(b + i, v);\n+}\n+\n+void\n+entry (void)\n+{\n+  struct S s;\n+  s.a = 1;\n+  s.b = 64;\n+  s.c = 32;\n+  foo (&s);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of foo.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements:\" 2 \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"->c;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7edfa408a5072961e29f41b1a38d7b36e71e8958", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-2.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  int i, c = p->c;\n+  int b = p->b;\n+  void *v = (void *) p;\n+\n+  for (i= 0; i< c; i++)\n+    v = blah(b + i, v);\n+}\n+\n+void\n+entry (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 1;\n+      s.b = 64;\n+      s.c = 32;\n+      foo (&s);\n+    }\n+  s.c = 2;\n+  foo (&s);\n+}\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of foo/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements:\" 4 \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"->c;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "4c0a3e7c54a9c14fe84244d404fb6a00f22e8dd5", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-3.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-3.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+static void __attribute__ ((noinline))\n+foo (int z, struct S *p)\n+{\n+  int i, c = p->c;\n+  int b = p->b;\n+  void *v = (void *) p;\n+\n+  for (i= 0; i< c; i++)\n+    v = blah(b + i, v);\n+}\n+\n+void\n+entry (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 1;\n+      s.b = 64;\n+      s.c = 32;\n+      foo (i, &s);\n+    }\n+  s.c = 2;\n+  foo (0, &s);\n+}\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of foo/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements: 1\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements: 0\" 2 \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"->c;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1c1da4d6847dc3db7f3c3a7ec32f972e9f06bd12", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-4.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-4.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  int i, c = p->c;\n+  int b = p->b;\n+  void *v = (void *) p;\n+\n+  for (i= 0; i< c; i++)\n+    v = blah(b + i, v);\n+}\n+\n+\n+void\n+entry1 (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 1;\n+      s.b = 64;\n+      s.c = 32;\n+      foo (&s);\n+    }\n+  s.c = 2;\n+  foo (&s);\n+}\n+\n+void\n+entry2 (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 6;\n+      s.b = 64;\n+      s.c = 32;\n+      foo (&s);\n+    }\n+  s.c = 2;\n+  foo (&s);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of foo/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements:\" 4 \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"->c;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9f6ee5beea1d99948d94d87aa57f0c82b3c8858f", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-5.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-5.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  int i, c = p->c;\n+  int b = p->b;\n+  void *v = (void *) p;\n+\n+  for (i= 0; i< c; i++)\n+    v = blah(b + i, v);\n+}\n+\n+static void __attribute__ ((noinline))\n+bar (struct S *p)\n+{\n+  foo (p);\n+}\n+\n+void\n+entry1 (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 1;\n+      s.b = 64;\n+      s.c = 32;\n+      bar (&s);\n+    }\n+  s.c = 2;\n+  bar (&s);\n+}\n+\n+void\n+entry2 (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 6;\n+      s.b = 64;\n+      s.c = 32;\n+      foo (&s);\n+    }\n+  s.c = 2;\n+  foo (&s);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of foo/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of bar/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements:\" 8 \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"->c;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "050e13bf5026f4e3333081dc94e86499a7977ca7", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-6.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-6.c?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-cp-details -fdump-tree-optimized-slim\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+struct S\n+{\n+  int a, b, c;\n+};\n+\n+void *blah(int, void *);\n+\n+static void __attribute__ ((noinline))\n+foo (struct S *p)\n+{\n+  int i, c = p->c;\n+  int b = p->b;\n+  void *v = (void *) p;\n+\n+  for (i= 0; i< c; i++)\n+    v = blah(b + i, v);\n+}\n+\n+static void __attribute__ ((noinline))\n+bar (struct S *p)\n+{\n+  foo (p);\n+}\n+\n+static void __attribute__ ((noinline))\n+bar_2 (struct S *p)\n+{\n+  foo (p);\n+}\n+\n+void\n+entry1 (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 1;\n+      s.b = 64;\n+      s.c = 32;\n+      bar (&s);\n+    }\n+  s.c = 2;\n+  bar (&s);\n+}\n+\n+void\n+entry2 (int c)\n+{\n+  struct S s;\n+  int i;\n+\n+  for (i = 0; i<c; i++)\n+    {\n+      s.a = 6;\n+      s.b = 64;\n+      s.c = 32;\n+      bar_2 (&s);\n+    }\n+  s.c = 2;\n+  foo (&s);\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of foo/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of bar/\\[0-9\\]*\\\\.\" 2 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of bar_2.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate replacements:\" 10 \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"->c;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "75012c7750254ee4ff894f35fb3e9a13f55c8d22", "filename": "gcc/testsuite/gfortran.dg/pr48636-2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636-2.f90?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline\" }\n+\n+module foo\n+  implicit none\n+contains\n+  subroutine bar(a,x)\n+    real, dimension(:,:), intent(in) :: a\n+    real, intent(out) :: x\n+    integer :: i,j\n+\n+    x = 0\n+    do j=1,ubound(a,2)\n+       do i=1,ubound(a,1)\n+          x = x + a(i,j)**2\n+       end do\n+    end do\n+  end subroutine bar\n+end module foo\n+\n+program main\n+  use foo\n+  implicit none\n+  real, dimension(2,3) :: a\n+  real :: x\n+  integer :: i\n+\n+  data a /1.0, 2.0, 3.0, -1.0, -2.0, -3.0/\n+\n+  do i=1,2000000\n+     call bar(a,x)\n+  end do\n+  print *,x\n+end program main\n+\n+! { dg-final { scan-ipa-dump \"Creating a specialized node of bar/\\[0-9\\]*\\\\.\" \"cp\" } }\n+! { dg-final { scan-ipa-dump-times \"Aggregate replacements\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\\[^=\\]*=\" 2 \"cp\" } }\n+! { dg-final { cleanup-ipa-dump \"cp\" } }"}, {"sha": "f35eb519f61926b8b382973fa3168111f843c0f8", "filename": "gcc/testsuite/gfortran.dg/pr48636.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -fdump-ipa-inline-details\" }\n+! { dg-options \"-O3 -fdump-ipa-inline-details -fno-ipa-cp\" }\n \n module foo\n   implicit none"}, {"sha": "0103e9ddceb99fcc38c0bb0a7077e6e7129c9af0", "filename": "gcc/testsuite/gfortran.dg/pr53787.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr53787.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9561b513bd88c41094efcf39f6405b5536a54d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr53787.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr53787.f90?ref=2c9561b513bd88c41094efcf39f6405b5536a54d", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fdump-ipa-cp-details -fno-inline -fwhole-program\" }\n+\n+  real x(10)\n+  n = 10\n+  call init(x,n)\n+  print *, x\n+end program\n+\n+subroutine init(x, n)\n+  real x(10)\n+  do i=1,n\n+     x(i) = i*i + 1\n+  enddo\n+\n+  return\n+end subroutine init\n+\n+! { dg-final { scan-ipa-dump \"Creating a specialized node of init\" \"cp\" } }\n+! { dg-final { scan-ipa-dump-times \"Aggregate replacements\" 2 \"cp\" } }\n+! { dg-final { cleanup-ipa-dump \"cp\" } }"}]}