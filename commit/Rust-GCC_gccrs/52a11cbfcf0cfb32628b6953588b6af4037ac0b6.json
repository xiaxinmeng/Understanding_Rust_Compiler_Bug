{"sha": "52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhMTFjYmZjZjBjZmIzMjYyOGI2OTUzNTg4YjZhZjQwMzdhYzBiNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T11:04:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T11:04:51Z"}, "message": "IA-64 ABI Exception Handling.\n\nFrom-SVN: r40924", "tree": {"sha": "a923c8785a06871784c5177530130063c4925f5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a923c8785a06871784c5177530130063c4925f5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/comments", "author": null, "committer": null, "parents": [{"sha": "ce1c98ea459813570b4588427030daa03958fda6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1c98ea459813570b4588427030daa03958fda6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1c98ea459813570b4588427030daa03958fda6"}], "stats": {"total": 19320, "additions": 9951, "deletions": 9369}, "files": [{"sha": "deb12a56c0285bc1544cbfe3a8b282221271fede", "filename": "gcc/ChangeLog", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,3 +1,117 @@\n+2001-03-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c: Rewrite entirely for IA-64 ABI exception handling.\n+\t* except.h: Likewise.\n+\n+\t* Makefile.in (LIB2ADDEH): Mention unwind-dw2*.c\n+\t(LIB2ADDEHDEP): New.\n+\t(LIB2FUNCS_EH): Remove.\n+\t(LIB2ADD): Remove LIB2ADDEH.\n+\t(libgcc.mk): Pass LIB2ADDEHDEP, don't pass LIB2FUNCS_EH.\n+\t(LIBGCC_DEPS): Use LIB2ADDEHDEP.\n+\t(crt{begin,end}[S].o): Likewise.\n+\t(except.o): Update includes.\n+\t* mklibgcc.in: Remove LIB2FUNCS_EH, add LIB2ADDEH, LIB2ADDEHDEP.\n+\t(libgcc2_c_dep): Use LIB2ADDEHDEP.\n+\n+\t* basic-block.h (struct basic_block_def): Remove eh_beg, eh_end.\n+\t* bb-reorder.c (reorder_basic_blocks): Don't disable for EH.\n+\t* builtins.def (BUILT_IN_EH_RETURN_DATA_REGNO): New.\n+\t* builtins.c (expand_builtin): Implement it.\n+\t[BUILT_IN_EH_RETURN]: Update for nr arguments change.\n+\t* c-common.c (c_common_nodes_and_builtins): Declare it.\n+\t* c-decl.c (init_decl_processing): Update __builtin_eh_return.\n+\t* calls.c (libfunc_nothrow): Remove.\n+\t(emit_library_call_value_1): Don't call it.\n+\t* crtstuff.c: Include unwind-dw2-fde.h instead of frame.h.\n+\t* dwarf2.h (dwarf_call_frame_info): Add dwarf2.1 elements.\n+\t(DW_EH_PE_*): New defines for pointer encoding in .eh_frame.\n+\t* dwarf2out.c (struct dw_fde_struct): Add uses_eh_lsda, funcdef_number.\n+\t(current_funcdef_number): Globalize.\n+\t(output_call_frame_info): Emit frame data if an lsda is needed.\n+\tGenerate augmentation for personality routine.  Don't play with\n+\tdifference symbols.\n+\t(dwarf2out_begin_prologue): Record funcdef_number.\n+\t* dwarf2out.h (current_funcdef_number): Declare.\n+\t* expr.c (expand_expr): Update for except.h name changes.\n+\tRemove POPDCC_EXPR, POPDHC_EXPR.  Add EXC_PTR_EXPR.\n+\t* expr.h (LTI_throw, LTI_rethrow): Remove.\n+\t(LTI_sjthrow, LTI_sjpopnthrow, LTI_terminate): Remove.\n+\t(LTI_eh_rtime_match): Remove.\n+\t(LTI_unwind_resume, LTI_eh_personality): Add.\n+\t(LTI_unwind_sjlj_register, LTI_unwind_sjlj_unregister): Add.\n+\t* final.c (final): Don't call check_exception_handler_labels,\n+\tinit_insn_eh_region, or free_insn_eh_region.\n+\t(final_scan_insn): Always emit debug labels for \n+\tNOTE_INSN_EH_REGION notes.\n+\t* flags.h (flag_new_exceptions): Remove.\n+\t* flow.c (entry_exit_blocks): Remove eh_beg, eh_end.\n+\t(record_active_eh_regions): Remove.\n+\t(count_basic_blocks): Check all instructions for REG_EH_REGION.\n+\tUse can_throw_internal.\n+\t(find_basic_blocks_1): Likewise.\n+\t(move_stray_eh_region_notes): Remove.\n+\t(find_label_refs): No eh_return_stub_label.\n+\t(make_edges): Likewise.  No init/free_eh_nesting_info.  Handle RESX.\n+\t(make_eh_edge): No eh_nest_info.  Update for reachable_handlers\n+\tchanges.\n+\t(delete_unreachable_blocks): Don't track deleted handlers.\n+\t(flow_delete_block): Use maybe_remove_eh_handler.\n+\t(delete_eh_regions): Remove.\n+\t(merge_blocks): Don't check for eh region match.\n+\t(mark_regs_live_at_end): Handle EH_RETURN_DATA_REGNO, \n+\tEH_RETURN_STACKADJ_RTX, EH_RETURN_HANDLER_RTX.\n+\t(init_propagate_block_info): Disable dead frame store optimization\n+\twhen current_function_calls_eh_return.\n+\t(dump_bb): Don't print eh_beg, eh_end.\n+\t* function.c (fixup_var_refs): No catch_clauses.\n+\t(expand_function_end): Likewise.  Call expand_eh_return before\n+\tthe return register use.  Call sjlj_emit_function_exit_after.\n+\t(expand_function_start): Force pseudo DECL_RESULT if sjlj exceptions.\n+\t* function.h (struct function): Add calls_eh_return, uses_eh_lsda.\n+\t* ifcvt.c (dead_or_predicable): Remove eh region check.\n+\t* integrate.c (function_cannot_inline_p): Disallow __builtin_eh_return.\n+\tDon't check for EH vs parameters.\n+\t(expand_inline_function_eh_labelmap, eif_eh_map): Remove.\n+\t(expand_inline_function): Call duplicate_eh_regions.\n+\t(copy_insn_list): Don't handle NOTE_INSN_EH_REGION_BEG/END.\n+\t(copy_insn_notes): Remap REG_EH_REGION notes.\n+\t(copy_rtx_and_substitute): Remove SYMBOL_REF_NEED_ADJUST check.\n+\t* integrate.h (struct inline_remap): Add local_return_label.\n+\t* jump.c (jump_optimize_1): Don't init/free_insn_eh_region, nor\n+\tcheck_exception_handler_labels, nor exception_optimize.\n+\t(find_cross_jump): No EH region check.\n+\t* optabs.c (init_optabs): Update for changed eh libfuncs.\n+\t* rtl.def (RESX): New.\n+\t* rtl.h (SYMBOL_REF_NEED_ADJUST): Remove.\n+\t* stmt.c (expand_decl_cleanup): Simplify using_eh_for_cleanups_p\n+\tchecks.  Update for except.h name changes.\n+\t(expand_cleanups): Likewise.\n+\t(expand_dcc_cleanup, expand_dhc_cleanup): Remove.\n+\t* toplev.c (dump_file_index, dump_file): Add .02.eh dump.\n+\t(compile_file): Call init_eh before init_optabs.  Don't\n+\toutput_exception_table here.\n+\t(rest_of_compilation): Call convert_from_eh_region_ranges,\n+\tconvert_to_eh_region_ranges, output_function_exception_table.\n+\tDon't emit_eh_context.\n+\t* tree.def (POPDHC_EXPR, POPDCC_EXPR): Remove.\n+\t(EXC_PTR_EXPR): New.\n+\n+\t* md.texi (eh_epilogue): Remove.\n+\t(eh_return): Document.\n+\t* tm.texi (EH_RETURN_DATA_REGNO): Document.\n+\t(EH_RETURN_STACKADJ_RTX, EH_RETURN_HANDLER_RTX): Document.\n+\n+\t* eh-common.h: Remove file.\n+\t* frame-dwarf2.c, frame.c, frame.h: Remove files.\n+\t* libgcc2.c (L_eh): Remove.\n+\n+\t* unwind-dw2-fde.c: New file, largely copied from frame.c.\n+\t* unwind-dw2-fde.h: New file.\n+\t* unwind-dw2.c: New file, largely cribbed from frame-dwarf2.c.\n+\t* unwind-sjlj.c, unwind.h, unwind.inc: New files.\n+\t* libgcc-std.ver: Update for eh symbols.\n+\n 2001-03-27  Richard Henderson  <rth@redhat.com>\n \n \t* regmove.c (perhaps_ends_bb_p): Use can_throw_internal to"}, {"sha": "5888dcb927c28e7af8e64cce94e90fc886b4f41f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -397,8 +397,10 @@ LIBGCC2_INCLUDES =\n # Additional target-dependent options for compiling libgcc2.a.\n TARGET_LIBGCC2_CFLAGS =\n \n-# Additional sources to handle exceptions; overridden by some targets.\n-LIB2ADDEH = $(srcdir)/frame-dwarf2.c\n+# Additional sources to handle exceptions; overridden on ia64.\n+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n+  $(srcdir)/unwind-sjlj.c\n+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h\n \n # libgcc1-test target (must also be overridable for a target)\n LIBGCC1_TEST = libgcc1-test\n@@ -794,8 +796,6 @@ LIB2FUNCS = _muldi3 _divdi3 _moddi3 _udivdi3 _umoddi3 _negdi2 \\\n     _mulvsi3 _mulvdi3 _negvsi2 _negvdi2 \\\n     _ctors\n \n-LIB2FUNCS_EH = _eh\n-\n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n     _lt_sf _le_sf _unord_sf _si_to_sf _sf_to_si _negate_sf _make_sf \\\n@@ -1033,7 +1033,7 @@ xlimits.h: glimits.h limitx.h limity.h\n #\f\n # Build libgcc.a.\n \n-LIB2ADD = $(LIB2ADDEH) $(LIB2FUNCS_EXTRA)\n+LIB2ADD = $(LIB2FUNCS_EXTRA)\n \n libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) xgcc$(exeext)\n \tobjext='$(objext)' \\\n@@ -1043,8 +1043,9 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) xgcc$(exeext)\n \tLIB1ASMFUNCS='$(LIB1ASMFUNCS)' \\\n \tLIB1FUNCS_EXTRA='$(LIB1FUNCS_EXTRA)' \\\n \tLIB2FUNCS='$(LIB2FUNCS)' \\\n-\tLIB2FUNCS_EH='$(LIB2FUNCS_EH)' \\\n \tLIB2ADD='$(LIB2ADD)' \\\n+\tLIB2ADDEH='$(LIB2ADDEH)' \\\n+\tLIB2ADDEHDEP='$(LIB2ADDEHDEP)' \\\n \tFPBIT='$(FPBIT)' \\\n \tFPBIT_FUNCS='$(FPBIT_FUNCS)' \\\n \tDPBIT='$(DPBIT)' \\\n@@ -1064,8 +1065,9 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) xgcc$(exeext)\n # All the things that might cause us to want to recompile bits of libgcc.\n LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \\\n \tlibgcc.mk $(srcdir)/libgcc1.c $(srcdir)/libgcc2.c $(TCONFIG_H) \\\n-\t$(MACHMODE_H) longlong.h frame.h gbl-ctors.h config.status \\\n-\tstmp-int-hdrs tsystem.h $(FPBIT) $(DPBIT) $(LIB2ADD) $(EXTRA_PARTS)\n+\t$(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs \\\n+\ttsystem.h $(FPBIT) $(DPBIT) $(LIB2ADD) $(LIB2ADDEH) $(LIB2ADDEHDEP) \\\n+\t$(EXTRA_PARTS)\n \n libgcc.a: $(LIBGCC_DEPS)\n \t$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n@@ -1125,30 +1127,30 @@ stmp-multilib: $(LIBGCC_DEPS)\n # linked using GCC on systems using COFF or ELF, for the sake of C++\n # constructors.\n $(T)crtbegin.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \\\n-  frame.h gbl-ctors.h stmp-int-hdrs tsystem.h\n+  gbl-ctors.h stmp-int-hdrs tsystem.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n \t  -finhibit-size-directive -fno-inline-functions \\\n \t  -fno-exceptions $(CRTSTUFF_T_CFLAGS) @inhibit_libc@ \\\n \t  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -o $(T)crtbegin$(objext)\n \n $(T)crtend.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \\\n-  frame.h gbl-ctors.h stmp-int-hdrs tsystem.h\n+  gbl-ctors.h stmp-int-hdrs tsystem.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n \t  -finhibit-size-directive -fno-inline-functions \\\n \t  -fno-exceptions $(CRTSTUFF_T_CFLAGS) @inhibit_libc@ \\\n \t  -c $(srcdir)/crtstuff.c -DCRT_END -o $(T)crtend$(objext)\n \n # These are versions of crtbegin and crtend for shared libraries.\n $(T)crtbeginS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \\\n-  frame.h gbl-ctors.h stmp-int-hdrs tsystem.h\n+  gbl-ctors.h stmp-int-hdrs tsystem.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n \t  -finhibit-size-directive -fno-inline-functions \\\n \t  -fno-exceptions $(CRTSTUFF_T_CFLAGS_S) @inhibit_libc@ \\\n \t  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -DCRTSTUFFS_O \\\n \t  -o $(T)crtbeginS$(objext)\n \n $(T)crtendS.o: crtstuff.c $(GCC_PASSES) $(TCONFIG_H) auto-host.h \\\n-  frame.h gbl-ctors.h stmp-int-hdrs tsystem.h\n+  gbl-ctors.h stmp-int-hdrs tsystem.h\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n \t  -finhibit-size-directive -fno-inline-functions \\\n \t  -fno-exceptions $(CRTSTUFF_T_CFLAGS_S) @inhibit_libc@ \\\n@@ -1394,8 +1396,9 @@ stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-config.h hard-reg-set.h $(EXPR_H) except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   function.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h $(RECOG_H) output.h except.h toplev.h intl.h $(GGC_H) $(TM_P_H)\n+   except.h function.h $(EXPR_H) integrate.h \\\n+   insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n+   dwarf2asm.h dwarf2out.h toplev.h $(HASHTAB_H) intl.h $(GGC_H)\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h \\\n    $(REGS_H) $(EXPR_H) insn-config.h $(RECOG_H) \\\n    output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h \\\n@@ -1414,7 +1417,7 @@ explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    toplev.h function.h $(TM_P_H)\n optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h  \\\n    insn-config.h $(EXPR_H) $(RECOG_H) reload.h \\\n-   toplev.h $(GGC_H) real.h $(TM_P_H)\n+   toplev.h $(GGC_H) real.h $(TM_P_H) except.h\n dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h $(REGS_H) \\\n    insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h toplev.h \\\n    $(TM_P_H)"}, {"sha": "58f6aa1fc943b812a0ae1796e2b7e5ca821a6a28", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -174,14 +174,12 @@ typedef struct basic_block_def {\n \n   /* The index of this block.  */\n   int index;\n-  /* The loop depth of this block plus one.  */\n-  int loop_depth;\n \n-  /* The active eh region before head and after end.  */\n-  int eh_beg, eh_end;\n+  /* The loop depth of this block.  */\n+  int loop_depth;\n \n-  int count;\t\t/* Expected number of executions: calculated in\n-                           profile.c */\n+  /* Expected number of executions: calculated in profile.c.  */\n+  int count;\n } *basic_block;\n \n /* Number of basic blocks in the current function.  */"}, {"sha": "e13e5f14485ce4e07c6d07c056ed5730c48f0cf0", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -92,7 +92,6 @@\n #include \"flags.h\"\n #include \"output.h\"\n #include \"function.h\"\n-#include \"except.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"expr.h\"\n@@ -395,8 +394,6 @@ make_reorder_chain_1 (bb, prev)\n       taken = probability > REG_BR_PROB_BASE / 2;\n \n       /* Find the normal taken edge and the normal fallthru edge.\n-         Note that there may in fact be other edges due to\n-\t flag_non_call_exceptions. \n \n \t Note, conditional jumps with other side effects may not\n \t be fully optimized.  In this case it is possible for\n@@ -1356,17 +1353,6 @@ reorder_basic_blocks ()\n   if (n_basic_blocks <= 1)\n     return;\n \n-  /* We do not currently handle correct re-placement of EH notes.\n-     But that does not matter unless we intend to use them.  */\n-  if (flag_exceptions)\n-    for (i = 0; i < n_basic_blocks; i++)\n-      {\n-\tedge e;\n-\tfor (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n-\t  if (e->flags & EDGE_EH)\n-\t    return;\n-      }\n-\n   for (i = 0; i < n_basic_blocks; i++)\n     BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n "}, {"sha": "eecf1c5a86086355ecbdc1b70796d54e1eb13113", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -3605,9 +3605,12 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_builtin_extract_return_addr (TREE_VALUE (arglist));\n     case BUILT_IN_EH_RETURN:\n       expand_builtin_eh_return (TREE_VALUE (arglist),\n-\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\t\tTREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))));\n+\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)));\n       return const0_rtx;\n+#ifdef EH_RETURN_DATA_REGNO\n+    case BUILT_IN_EH_RETURN_DATA_REGNO:\n+      return expand_builtin_eh_return_data_regno (arglist);\n+#endif\n     case BUILT_IN_VARARGS_START:\n       return expand_builtin_va_start (0, arglist);\n     case BUILT_IN_STDARG_START:"}, {"sha": "1d59d78f8246e917cafe9f0cae67db13c583a10e", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -97,6 +97,7 @@ DEF_BUILTIN(BUILT_IN_INIT_DWARF_REG_SIZES)\n DEF_BUILTIN(BUILT_IN_FROB_RETURN_ADDR)\n DEF_BUILTIN(BUILT_IN_EXTRACT_RETURN_ADDR)\n DEF_BUILTIN(BUILT_IN_EH_RETURN)\n+DEF_BUILTIN(BUILT_IN_EH_RETURN_DATA_REGNO)\n \n DEF_BUILTIN(BUILT_IN_VARARGS_START)\n DEF_BUILTIN(BUILT_IN_STDARG_START)"}, {"sha": "1b00362ba0ddd7a7ab3c9760b405522907229b72", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -3146,6 +3146,11 @@ c_common_nodes_and_builtins ()\n   builtin_function (\"__builtin_frame_address\", ptr_ftype_unsigned,\n \t\t    BUILT_IN_FRAME_ADDRESS, BUILT_IN_NORMAL, NULL_PTR);\n \n+#ifdef EH_RETURN_DATA_REGNO\n+  builtin_function (\"__builtin_eh_return_data_regno\", int_ftype_int,\n+\t\t    BUILT_IN_EH_RETURN_DATA_REGNO, BUILT_IN_NORMAL, NULL_PTR);\n+#endif\n+\n   builtin_function (\"__builtin_alloca\", ptr_ftype_sizetype,\n \t\t    BUILT_IN_ALLOCA, BUILT_IN_NORMAL, \"alloca\");\n   builtin_function_2 (\"__builtin_ffs\", \"ffs\","}, {"sha": "a8c1d300b2bd4674fde8995f2079cc4222a8b475", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -3084,12 +3084,11 @@ init_decl_processing ()\n   builtin_function\n     (\"__builtin_eh_return\",\n      build_function_type (void_type_node,\n-\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t  tree_cons (NULL_TREE,\n+\t\t\t\t     type_for_mode (ptr_mode, 0),\n \t\t\t\t     tree_cons (NULL_TREE,\n-\t\t\t\t\t\ttype_for_mode (ptr_mode, 0),\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_type_node,\n-\t\t\t\t\t\t\t   endlink)))),\n+\t\t\t\t\t\tptr_type_node,\n+\t\t\t\t\t\tendlink))),\n      BUILT_IN_EH_RETURN, BUILT_IN_NORMAL, NULL_PTR);\n \n   pedantic_lvalues = pedantic;"}, {"sha": "228d9b8e112fdbf0c66385d4db15afd286d8d6a2", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -204,7 +204,6 @@ static void compute_argument_addresses\t\tPARAMS ((struct arg_data *,\n static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n static void load_register_parameters\t\tPARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t int, rtx *, int));\n-static int libfunc_nothrow\t\t\tPARAMS ((rtx));\n static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx,\n \t\t\t\t\t\t\t enum libcall_type,\n \t\t\t\t\t\t\t enum machine_mode,\n@@ -3444,22 +3443,6 @@ expand_call (exp, target, ignore)\n   return target;\n }\n \f\n-/* Returns nonzero if FUN is the symbol for a library function which can\n-   not throw.  */\n-\n-static int\n-libfunc_nothrow (fun)\n-     rtx fun;\n-{\n-  if (fun == throw_libfunc\n-      || fun == rethrow_libfunc\n-      || fun == sjthrow_libfunc\n-      || fun == sjpopnthrow_libfunc)\n-    return 0;\n-\n-  return 1;\n-}\n-\f\n /* Output a library call to function FUN (a SYMBOL_REF rtx).\n    The RETVAL parameter specifies whether return value needs to be saved, other\n    parameters are documented in the emit_library_call function bellow.  */\n@@ -3501,7 +3484,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   rtx valreg;\n   int pcc_struct_value = 0;\n   int struct_value_size = 0;\n-  int flags = 0;\n+  int flags;\n   int reg_parm_stack_space = 0;\n   int needed;\n   rtx before_call;\n@@ -3525,6 +3508,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #endif\n #endif\n \n+  /* No library functions can throw.  */\n+  flags = ECF_NOTHROW;\n+\n   if (fn_type == LCT_CONST_MAKE_BLOCK)\n     flags |= ECF_CONST;\n   else if (fn_type == LCT_PURE_MAKE_BLOCK)\n@@ -3533,9 +3519,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n     flags |= ECF_NORETURN;\n   fun = orgfun;\n \n-  if (libfunc_nothrow (fun))\n-    flags |= ECF_NOTHROW;\n-\n #ifdef PREFERRED_STACK_BOUNDARY\n   /* Ensure current function's preferred stack boundary is at least\n      what we need.  */"}, {"sha": "0db7144ee0f44d2ce6ae78a568aa3c1bf2f33ff0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,3 +1,59 @@\n+2001-03-28  Richard Henderson  <rth@redhat.com>\n+\n+\tIA-64 ABI Exception Handling:\n+\t* cp-tree.def (EH_SPEC_BLOCK): New.\n+\t(MUST_NOT_THROW_EXPR): New.\n+\t* cp-tree.h: Update changed function declarations.\n+\t(CPTI_PUSH_EXCEPTION_IDENTIFIER): Remove.\n+\t(CPTI_CALL_UNEXPECTED): New.\n+\t(struct cp_language_function): Rename x_eh_spec_try_block\n+\tto x_eh_spec_block.\n+\t(EH_SPEC_STMTS, EH_SPEC_RAISES): New.\n+\t* decl.c (current_binding_level): If no current function \n+\tbindings, revert to scope_chain.\n+\t(initialize_predefined_identifiers): Remove __cp_push_exception.\n+\t(store_parm_decls): Use begin_eh_spec_block.\n+\t(finish_function): Use finish_eh_spec_block.\n+\t(mark_lang_function): Update for name changes.\n+\t* decl2.c (finish_file): No mark_all_runtime_matches.\n+\t* dump.c (cp_dump_tree): Handle new tree codes.\n+\t* error.c (dump_expr) [BIND_EXPR]: Fix typo.\n+\t* except.c (catch_language_init, catch_language): Remove.\n+\t(init_exception_processing): Don't set language code.\n+\tInitialize call_unexpected_node, protect_cleanup_actions,\n+\teh_personality_libfunc, lang_eh_runtime_type.\n+\t(call_eh_info, push_eh_info, get_eh_info, get_eh_value): Remove.\n+\t(get_eh_type, get_eh_caught, get_eh_handlers): Remove.\n+\t(prepare_eh_type): Split out type canonicalizations ...\n+\t(build_eh_type_type): ... from here.\n+\t(build_eh_type_type_ref): Remove.\n+\t(mark_all_runtime_matches): Remove.\n+\t(build_exc_ptr): New.\n+\t(do_begin_catch, do_end_catch): New.\n+\t(do_pop_exception): Remove.\n+\t(build_terminate_handler): Remove.\n+\t(choose_personality_routine): Split out language choice from ...\n+\t(initialize_handler_parm): ... here.\n+\tUse MUST_NOT_THROW_EXPR.\n+\t(expand_start_catch_block): Use do_begin_catch.  Simplify Java\n+\texception object handling.\n+\t(expand_start_eh_spec, expand_end_eh_spec): Remove.\n+\t(expand_exception_blocks, alloc_eh_object): Remove.\n+\t(begin_eh_spec_block, finish_eh_spec_block): New.\n+\t(do_allocate_exception, do_free_exception): New.\n+\t(expand_throw): Merge into ...\n+\t(build_throw): ... here.  Update for abi.\n+\t* expr.c (cplus_expand_expr): No expand_internal_throw.\n+\tHandle MUST_NOT_THROW_EXPR.\n+\t* pt.c (tsubst_expr): Handle EH_SPEC_BLOCK.\n+\t* semantics.c (*) Update for except.h name changes.\n+\t(genrtl_try_block): No protect_with_terminate.\n+\t(genrtl_eh_spec_block): New.\n+\t(genrtl_handler): Don't emit the goto here.\n+\t(cp_expand_stmt): Handle EH_SPEC_BLOCK.\n+\t(genrtl_finish_function): Don't expand_exception_blocks.\n+\t* tree.c (cp_statement_code_p): Handle EH_SPEC_BLOCK.\n+\n 2001-03-28  Richard Henderson  <rth@redhat.com>\n \n \t* decl.c (struct named_label_list): Rename eh_region to"}, {"sha": "5e89189774dcdd7bdace96e2cb1507bcb2b7d611", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -236,8 +236,13 @@ DEFTREECODE (START_CATCH_STMT, \"start_catch_stmt\", 'e', 0)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)\n+DEFTREECODE (EH_SPEC_BLOCK, \"eh_spec_block\", 'e', 2)\n DEFTREECODE (HANDLER, \"handler\", 'e', 2)\n \n+/* A MUST_NOT_THROW_EXPR wraps an expression that may not\n+   throw, and must call terminate if it does.  */\n+DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", 'e', 1)\n+\n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n /* And some codes for expressing conversions for overload resolution.  */"}, {"sha": "449a3bda565266a7f6e5ed81d94fd35d1a624293", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -616,7 +616,6 @@ enum cp_tree_index\n     CPTI_PFN_IDENTIFIER,\n     CPTI_PFN_OR_DELTA2_IDENTIFIER,\n     CPTI_VPTR_IDENTIFIER,\n-    CPTI_PUSH_EXCEPTION_IDENTIFIER,\n     CPTI_STD_IDENTIFIER,\n \n     CPTI_LANG_NAME_C,\n@@ -627,6 +626,7 @@ enum cp_tree_index\n     CPTI_NULL,\n     CPTI_JCLASS,\n     CPTI_TERMINATE,\n+    CPTI_CALL_UNEXPECTED,\n     CPTI_ATEXIT,\n     CPTI_DSO_HANDLE,\n     CPTI_DCAST,\n@@ -740,9 +740,6 @@ extern tree cp_global_trees[CPTI_MAX];\n #define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n #define pfn_or_delta2_identifier        cp_global_trees[CPTI_PFN_OR_DELTA2_IDENTIFIER]\n #define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n-/* The name of the function to call to push an exception onto the\n-   exception stack.  */\n-#define cp_push_exception_identifier    cp_global_trees[CPTI_PUSH_EXCEPTION_IDENTIFIER]\n /* The name of the std namespace.  */\n #define std_identifier                  cp_global_trees[CPTI_STD_IDENTIFIER]\n #define lang_name_c                     cp_global_trees[CPTI_LANG_NAME_C]\n@@ -761,6 +758,9 @@ extern tree cp_global_trees[CPTI_MAX];\n /* The declaration for `std::terminate'.  */\n #define terminate_node                  cp_global_trees[CPTI_TERMINATE]\n \n+/* The declaration for \"__cxa_call_unexpected\".  */\n+#define call_unexpected_node            cp_global_trees[CPTI_CALL_UNEXPECTED]\n+\n /* A pointer to `std::atexit'.  */\n #define atexit_node                     cp_global_trees[CPTI_ATEXIT]\n \n@@ -872,7 +872,7 @@ struct cp_language_function\n   tree x_dtor_label;\n   tree x_current_class_ptr;\n   tree x_current_class_ref;\n-  tree x_eh_spec_try_block;\n+  tree x_eh_spec_block;\n   tree x_in_charge_parm;\n   tree x_vtt_parm;\n \n@@ -916,10 +916,10 @@ struct cp_language_function\n #define current_class_ref \\\n   (cfun ? cp_function_chain->x_current_class_ref : NULL_TREE)\n \n-/* The TRY_BLOCK for the exception-specifiers for the current\n+/* The EH_SPEC_BLOCK for the exception-specifiers for the current\n    function, if any.  */\n \n-#define current_eh_spec_try_block cp_function_chain->x_eh_spec_try_block\n+#define current_eh_spec_block cp_function_chain->x_eh_spec_block\n \n /* The `__in_chrg' parameter for the current function.  Only used for\n    constructors and destructors.  */\n@@ -3035,6 +3035,9 @@ extern int flag_new_for_scope;\n #define TRY_STMTS(NODE)         TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n #define TRY_HANDLERS(NODE)      TREE_OPERAND (TRY_BLOCK_CHECK (NODE), 1)\n \n+#define EH_SPEC_STMTS(NODE)     TREE_OPERAND (EH_SPEC_BLOCK_CHECK (NODE), 0)\n+#define EH_SPEC_RAISES(NODE)    TREE_OPERAND (EH_SPEC_BLOCK_CHECK (NODE), 1)\n+\n /* Nonzero if this try block is a function try block.  */\n #define FN_TRY_BLOCK_P(NODE)    TREE_LANG_FLAG_3 (TRY_BLOCK_CHECK (NODE))\n #define HANDLER_PARMS(NODE)     TREE_OPERAND (HANDLER_CHECK (NODE), 0)\n@@ -4000,9 +4003,9 @@ extern void init_exception_processing\t\tPARAMS ((void));\n extern tree expand_start_catch_block\t\tPARAMS ((tree));\n extern void expand_end_catch_block\t\tPARAMS ((tree));\n extern void expand_builtin_throw\t\tPARAMS ((void));\n-extern tree expand_start_eh_spec\t\tPARAMS ((void));\n-extern void expand_end_eh_spec\t\t        PARAMS ((tree, tree));\n+extern void expand_eh_spec_block\t        PARAMS ((tree));\n extern void expand_exception_blocks\t\tPARAMS ((void));\n+extern tree build_exc_ptr\t\t\tPARAMS ((void));\n extern tree build_throw\t\t\t\tPARAMS ((tree));\n extern void mark_all_runtime_matches            PARAMS ((void));\n extern int nothrow_libfn_p\t\t\tPARAMS ((tree));\n@@ -4256,6 +4259,8 @@ extern tree finish_case_label                   PARAMS ((tree, tree));\n extern tree finish_goto_stmt                    PARAMS ((tree));\n extern tree begin_try_block                     PARAMS ((void));\n extern void finish_try_block                    PARAMS ((tree));\n+extern tree begin_eh_spec_block\t\t\tPARAMS ((void));\n+extern void finish_eh_spec_block\t\tPARAMS ((tree, tree));\n extern void finish_handler_sequence             PARAMS ((tree));\n extern tree begin_function_try_block            PARAMS ((void));\n extern void finish_function_try_block           PARAMS ((tree));"}, {"sha": "b96545dc91afe71cc4ae670b77799e4c41eb6058", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -478,7 +478,7 @@ struct binding_level\n /* The binding level currently in effect.  */\n \n #define current_binding_level\t\t\t\\\n-  (cfun\t\t\t\t\t\t\\\n+  (cfun && cp_function_chain->bindings\t\t\\\n    ? cp_function_chain->bindings\t\t\\\n    : scope_chain->bindings)\n \n@@ -6306,7 +6306,6 @@ initialize_predefined_identifiers ()\n     { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n     { \"__pfn_or_delta2\", &pfn_or_delta2_identifier, 0 },\n     { \"_vptr\", &vptr_identifier, 0 },\n-    { \"__cp_push_exception\", &cp_push_exception_identifier, 0 },\n     { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n     { \"std\", &std_identifier, 0 },\n     { NULL, NULL, 0 }\n@@ -13721,7 +13720,7 @@ store_parm_decls (current_function_parms)\n   if (flag_exceptions && !processing_template_decl\n       && flag_enforce_eh_specs\n       && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n-    current_eh_spec_try_block = expand_start_eh_spec ();\n+    current_eh_spec_block = begin_eh_spec_block ();\n }\n \n \f\n@@ -13966,9 +13965,9 @@ finish_function (flags)\n       if (flag_exceptions && !processing_template_decl\n \t  && flag_enforce_eh_specs\n \t  && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n-\texpand_end_eh_spec (TYPE_RAISES_EXCEPTIONS\n-\t\t\t    (TREE_TYPE (current_function_decl)),\n-\t\t\t    current_eh_spec_try_block);\n+\tfinish_eh_spec_block (TYPE_RAISES_EXCEPTIONS\n+\t\t\t      (TREE_TYPE (current_function_decl)),\n+\t\t\t      current_eh_spec_block);\n     }\n \n   /* If we're saving up tree structure, tie off the function now.  */\n@@ -14395,7 +14394,7 @@ mark_lang_function (p)\n   ggc_mark_tree (p->x_dtor_label);\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);\n-  ggc_mark_tree (p->x_eh_spec_try_block);\n+  ggc_mark_tree (p->x_eh_spec_block);\n   ggc_mark_tree_varray (p->x_local_names);\n \n   mark_named_label_lists (&p->x_named_labels, &p->x_named_label_uses);"}, {"sha": "35c8ca77e9eb34853efd6953297961409f8c4a5e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -3621,10 +3621,6 @@ finish_file ()\n \t    }\n \t}\n \n-      /* Mark all functions that might deal with exception-handling as\n-\t referenced.  */\n-      mark_all_runtime_matches ();\n-\n       /* We lie to the back-end, pretending that some functions are\n \t not defined when they really are.  This keeps these functions\n \t from being put out unnecessarily.  But, we must stop lying"}, {"sha": "a4033c3db530d00a204244c579ae5608ebbd4632", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -188,6 +188,13 @@ cp_dump_tree (di, t)\n       dump_next_stmt (di, t);\n       break;\n \n+    case EH_SPEC_BLOCK:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", EH_SPEC_STMTS (t));\n+      dump_child (\"raises\", EH_SPEC_RAISES (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n     case PTRMEM_CST:\n       dump_child (\"clas\", PTRMEM_CST_CLASS (t));\n       dump_child (\"mbr\", PTRMEM_CST_MEMBER (t));\n@@ -227,6 +234,12 @@ cp_dump_tree (di, t)\n       dump_next_stmt (di, t);\n       break;\n \n+    case MUST_NOT_THROW_EXPR:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", TREE_OPERAND (t, 0));\n+      dump_next_stmt (di, t);\n+      break;\n+\n     case SUBOBJECT:\n       dump_stmt (di, t);\n       dump_child (\"clnp\", TREE_OPERAND (t, 0));"}, {"sha": "7d2f1fab7cd007e0070bfd2e302843ecc9297ef3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -2104,7 +2104,7 @@ dump_expr (t, flags)\n       break;\n \n     case BIND_EXPR:\n-      output_add_character (scratch_buffer, '}');\n+      output_add_character (scratch_buffer, '{');\n       dump_expr (TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n       output_add_character (scratch_buffer, '}');\n       break;"}, {"sha": "600a21abd3f2c2079ebb576960f477bbeb0509ae", "filename": "gcc/cp/except.c", "status": "modified", "additions": 318, "deletions": 652, "changes": 970, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -34,299 +34,67 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n-#include \"eh-common.h\"\n \n static void push_eh_cleanup PARAMS ((tree));\n+static tree prepare_eh_type PARAMS ((tree));\n static tree build_eh_type_type PARAMS ((tree));\n-static tree call_eh_info PARAMS ((void));\n-static void push_eh_info PARAMS ((void));\n-static tree get_eh_info PARAMS ((void));\n-static tree get_eh_value PARAMS ((void));\n-#if 0\n-static tree get_eh_type PARAMS ((void));\n-static tree get_eh_caught PARAMS ((void));\n-static tree get_eh_handlers PARAMS ((void));\n-#endif\n+static tree do_begin_catch PARAMS ((void));\n static int dtor_nothrow PARAMS ((tree));\n-static tree do_pop_exception PARAMS ((tree));\n-static tree build_eh_type_type_ref PARAMS ((tree));\n-static tree build_terminate_handler PARAMS ((void));\n-static tree alloc_eh_object PARAMS ((tree));\n+static tree do_end_catch PARAMS ((tree));\n+static void push_eh_cleanup PARAMS ((tree));\n+static bool decl_is_java_type PARAMS ((tree decl, int err));\n+static void choose_personality_routine PARAMS ((bool));\n+static void initialize_handler_parm PARAMS ((tree, tree));\n+static tree do_allocate_exception PARAMS ((tree));\n+static tree do_free_exception PARAMS ((tree));\n static int complete_ptr_ref_or_void_ptr_p PARAMS ((tree, tree));\n static bool is_admissible_throw_operand PARAMS ((tree));\n static int can_convert_eh PARAMS ((tree, tree));\n static void check_handlers_1 PARAMS ((tree, tree));\n-static void initialize_handler_parm PARAMS ((tree));\n-static tree expand_throw PARAMS ((tree));\n-static int decl_is_java_type PARAMS ((tree decl, int err));\n \n #include \"decl.h\"\n #include \"obstack.h\"\n \n-/* In a given translation unit we are constrained to catch only C++\n-   types or only Java types.  `catch_language' holds the current type,\n-   and `catch_language_init' registers whether `catch_language' has\n-   been set.  */\n-\n-static int catch_language_init = 0;\n-static int catch_language;\n-\n-/* ======================================================================\n-   Briefly the algorithm works like this:\n-\n-     When a constructor or start of a try block is encountered,\n-     push_eh_entry (&eh_stack) is called.  Push_eh_entry () creates a\n-     new entry in the unwind protection stack and returns a label to\n-     output to start the protection for that block.\n-\n-     When a destructor or end try block is encountered, pop_eh_entry\n-     (&eh_stack) is called.  Pop_eh_entry () returns the eh_entry it\n-     created when push_eh_entry () was called.  The eh_entry structure\n-     contains three things at this point.  The start protect label,\n-     the end protect label, and the exception handler label.  The end\n-     protect label should be output before the call to the destructor\n-     (if any). If it was a destructor, then its parse tree is stored\n-     in the finalization variable in the eh_entry structure.  Otherwise\n-     the finalization variable is set to NULL to reflect the fact that\n-     it is the end of a try block.  Next, this modified eh_entry node\n-     is enqueued in the finalizations queue by calling\n-     enqueue_eh_entry (&queue,entry).\n-\n-\t+---------------------------------------------------------------+\n-\t|XXX: Will need modification to deal with partially\t\t|\n-\t|\t\t\tconstructed arrays of objects\t\t|\n-\t|\t\t\t\t\t\t\t\t|\n-\t|\tBasically, this consists of keeping track of how many\t|\n-\t|\tof the objects have been constructed already (this\t|\n-\t|\tshould be in a register though, so that shouldn't be a\t|\n-\t|\tproblem.\t\t\t\t\t\t|\n-\t+---------------------------------------------------------------+\n-\n-     When a catch block is encountered, there is a lot of work to be\n-     done.\n-\n-     Since we don't want to generate the catch block inline with the\n-     regular flow of the function, we need to have some way of doing\n-     so.  Luckily, we can use sequences to defer the catch sections.\n-     When the start of a catch block is encountered, we start the\n-     sequence.  After the catch block is generated, we end the\n-     sequence.\n-\n-     Next we must insure that when the catch block is executed, all\n-     finalizations for the matching try block have been completed.  If\n-     any of those finalizations throw an exception, we must call\n-     terminate according to the ARM (section r.15.6.1).  What this\n-     means is that we need to dequeue and emit finalizations for each\n-     entry in the eh_queue until we get to an entry with a NULL\n-     finalization field.  For any of the finalization entries, if it\n-     is not a call to terminate (), we must protect it by giving it\n-     another start label, end label, and exception handler label,\n-     setting its finalization tree to be a call to terminate (), and\n-     enqueue'ing this new eh_entry to be output at an outer level.\n-     Finally, after all that is done, we can get around to outputting\n-     the catch block which basically wraps all the \"catch (...) {...}\"\n-     statements in a big if/then/else construct that matches the\n-     correct block to call.\n-     \n-     ===================================================================== */\n-\n-/* ====================================================================== */\n-\n-/* sets up all the global eh stuff that needs to be initialized at the\n+/* Sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.  */\n \n void\n init_exception_processing ()\n {\n-  /* void vtype () */\n-  tree vtype = build_function_type (void_type_node, void_list_node);\n-  \n+  tree tmp;\n+\n   if (flag_honor_std)\n     push_namespace (std_identifier);\n-  terminate_node = build_cp_library_fn_ptr (\"terminate\", vtype);\n+\n+  /* void std::terminate (); */\n+  tmp = build_function_type (void_type_node, void_list_node);\n+  terminate_node = build_cp_library_fn_ptr (\"terminate\", tmp);\n   TREE_THIS_VOLATILE (terminate_node) = 1;\n   TREE_NOTHROW (terminate_node) = 1;\n   if (flag_honor_std)\n     pop_namespace ();\n \n-  set_exception_lang_code (EH_LANG_C_plus_plus);\n-  set_exception_version_code (1);\n-\n-  /* If we use setjmp/longjmp EH, arrange for all cleanup actions to\n-     be protected with __terminate.  */\n-  protect_cleanup_actions_with_terminate = 1;\n-}\n-\n-/* Retrieve a pointer to the cp_eh_info node for the current exception.  */\n-\n-static tree\n-call_eh_info ()\n-{\n-  tree fn;\n-\n-  fn = get_identifier (\"__start_cp_handler\");\n-  if (IDENTIFIER_GLOBAL_VALUE (fn))\n-    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n-  else\n-    {\n-      tree eh_info_type;\n-      tree cleanup_fn_type;\n-      tree matcher_fn_type;\n-      tree cp_eh_info_type;\n-      tree exception_desc_type;\n-      tree fields[8];\n-\n-      eh_info_type = make_aggr_type (RECORD_TYPE);\n-      exception_desc_type = make_aggr_type (RECORD_TYPE);\n-      \n-      /* void * (*) (__eh_info *, void *, exception_descriptor *); */\n-      matcher_fn_type = tree_cons\n-          (NULL_TREE, build_pointer_type (eh_info_type), tree_cons\n-            (NULL_TREE, ptr_type_node, tree_cons\n-              (NULL_TREE, build_pointer_type (exception_desc_type),\n-                void_list_node)));\n-      matcher_fn_type = build_function_type (ptr_type_node, matcher_fn_type);\n-      matcher_fn_type = build_pointer_type (matcher_fn_type);\n-\n-      /* void (*) (void *); */\n-      cleanup_fn_type = tree_cons\n-          (NULL_TREE, ptr_type_node, void_list_node);\n-      cleanup_fn_type = build_function_type (void_type_node, cleanup_fn_type);\n-      cleanup_fn_type = build_pointer_type (cleanup_fn_type);\n-\n-      /* eh-common.h\n-        struct __eh_info \n-        {\n-          __eh_matcher match_function;\n-          short language;\n-          short version;\n-        };  */\n-      fields[0] = build_decl (FIELD_DECL,\n-\t\t    get_identifier (\"match_function\"), ptr_type_node);\n-      fields[1] = build_decl (FIELD_DECL, \n-                    get_identifier (\"language\"), short_integer_type_node);\n-      fields[2] = build_decl (FIELD_DECL, \n-                    get_identifier (\"version\"), short_integer_type_node);\n-      /* N.B.: The fourth field LEN is expected to be\n-\t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (eh_info_type, \"__eh_info\", fields, 2, ptr_type_node);\n-      \n-      /* exception_support.h\n-        struct cp_eh_info\n-        {\n-          __eh_info eh_info;\n-          void *value;\n-          void *type;\n-          cleanup_fn cleanup;\n-          bool caught;\n-          cp_eh_info *next;\n-          long handlers;\n-          void *original_value;\n-        };  */\n-      cp_eh_info_type = make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_decl (FIELD_DECL, get_identifier (\"eh_info\"),\n-                              eh_info_type);\n-      fields[1] = build_decl (FIELD_DECL, get_identifier (\"value\"),\n-\t\t\t      ptr_type_node);\n-      fields[2] = build_decl (FIELD_DECL, get_identifier (\"type\"),\n-\t\t\t      ptr_type_node);\n-      fields[3] = build_decl (FIELD_DECL, get_identifier (\"cleanup\"),\n-                              cleanup_fn_type);\n-      fields[4] = build_decl (FIELD_DECL, get_identifier (\"caught\"),\n-\t\t\t      boolean_type_node);\n-      fields[5] = build_decl (FIELD_DECL, get_identifier (\"next\"),\n-\t\t\t      build_pointer_type (cp_eh_info_type));\n-      fields[6] = build_decl (FIELD_DECL, get_identifier (\"handlers\"),\n-                              long_integer_type_node);\n-      fields[7] = build_decl (FIELD_DECL, get_identifier (\"original_value\"),\n-                              ptr_type_node);\n-      /* N.B.: The fourth field LEN is expected to be\n-\t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (cp_eh_info_type, \"cp_eh_info\", fields, 7, ptr_type_node);\n-\n-      /* And now the function.  */\n-      fn = push_library_fn (fn,\n-              build_function_type (build_pointer_type (cp_eh_info_type),\n-                                   void_list_node));\n-    }\n-  return build_function_call (fn, NULL_TREE);\n-}\n-\n-/* Retrieve a pointer to the cp_eh_info node for the current exception\n-   and save it in the current binding level.  */\n-\n-static void\n-push_eh_info ()\n-{\n-  tree decl, fn = call_eh_info ();\n-\n-  /* Remember the pointer to the current exception info; it won't change\n-     during this catch block.  */\n-  decl = build_decl (VAR_DECL, get_identifier (\"__exception_info\"),\n-\t\t     TREE_TYPE (fn));\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_INITIAL (decl) = fn;\n-  decl = pushdecl (decl);\n-  cp_finish_decl (decl, fn, NULL_TREE, 0);\n-}\n-\n-/* Returns a reference to the cp_eh_info node for the current exception.  */\n-\n-static tree\n-get_eh_info ()\n-{\n-  /* Look for the pointer pushed in push_eh_info.  */\n-  tree t = lookup_name (get_identifier (\"__exception_info\"), 0);\n-  return build_indirect_ref (t, NULL_PTR);\n-}\n-\n-/* Returns a reference to the current exception object.  */\n+  protect_cleanup_actions = build_call (terminate_node, NULL_TREE);\n \n-static tree\n-get_eh_value ()\n-{\n-  return build_component_ref (get_eh_info (), get_identifier (\"value\"),\n-\t\t\t      NULL_TREE, 0);\n-}\n+  /* void __cxa_call_unexpected(void *); */\n+  tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+  tmp = build_function_type (void_type_node, tmp);\n+  call_unexpected_node\n+    = push_throw_library_fn (get_identifier (\"__cxa_call_unexpected\"), tmp);\n \n-/* Returns a reference to the current exception type.  */\n+  eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t\t\t     ? \"__gxx_personality_sj0\"\n+\t\t\t\t\t     : \"__gxx_personality_v0\");\n \n-#if 0\n-static tree\n-get_eh_type ()\n-{\n-  return build_component_ref (get_eh_info (), get_identifier (\"type\"),\n-\t\t\t      NULL_TREE, 0);\n+  lang_eh_runtime_type = build_eh_type_type;\n }\n \n-/* Returns a reference to whether or not the current exception\n-   has been caught.  */\n-\n static tree\n-get_eh_caught ()\n-{\n-  return build_component_ref (get_eh_info (), get_identifier (\"caught\"),\n-\t\t\t      NULL_TREE, 0);\n-}\n-\n-/* Returns a reference to whether or not the current exception\n-   has been caught.  */\n-\n-static tree\n-get_eh_handlers ()\n-{\n-  return build_component_ref (get_eh_info (), get_identifier (\"handlers\"),\n-\t\t\t      NULL_TREE, 0);\n-}\n-#endif\n-\n-/* Build a type value for use at runtime for a type that is matched\n-   against by the exception handling system.  */\n-\n-static tree\n-build_eh_type_type (type)\n+prepare_eh_type (type)\n      tree type;\n {\n+  if (type == NULL_TREE)\n+    return type;\n   if (type == error_mark_node)\n     return error_mark_node;\n \n@@ -337,62 +105,58 @@ build_eh_type_type (type)\n   /* Peel off cv qualifiers.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  return build1 (ADDR_EXPR, ptr_type_node, get_typeid_1 (type));\n+  return type;\n }\n \n /* Build the address of a typeinfo decl for use in the runtime\n-   matching field of the new exception model */\n+   matching field of the exception model.   */\n \n static tree\n-build_eh_type_type_ref (type)\n+build_eh_type_type (type)\n      tree type;\n {\n   tree exp;\n \n   if (type == NULL_TREE || type == error_mark_node)\n     return type;\n \n-  /* peel back references, so they match.  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  /* Peel off cv qualifiers.  */\n-  type = TYPE_MAIN_VARIANT (type);\n+  if (decl_is_java_type (type, 0))\n+    exp = build_java_class_ref (TREE_TYPE (type));\n+  else\n+    exp = get_tinfo_decl (type);\n \n-  exp = get_tinfo_decl (type);\n   mark_used (exp);\n   exp = build1 (ADDR_EXPR, ptr_type_node, exp);\n \n-  return (exp);\n+  return exp;\n+}\n+\n+tree\n+build_exc_ptr ()\n+{\n+  return build (EXC_PTR_EXPR, ptr_type_node);\n }\n \n-/* This routine is called to mark all the symbols representing runtime\n-   type functions in the exception table as having been referenced.\n-   This will make sure code is emitted for them. Called from finish_file. */\n+/* Build up a call to __cxa_begin_catch, to tell the runtime that the\n+   exception has been handled.  */\n \n-void \n-mark_all_runtime_matches () \n+static tree\n+do_begin_catch ()\n {\n-  int x,num;\n-  void **ptr;\n-  tree exp;\n-  \n-  num = find_all_handler_type_matches (&ptr);\n-  if (num == 0 || ptr == NULL)\n-    return;\n-  \n-  for (x=0; x <num; x++)\n+  tree fn;\n+\n+  fn = get_identifier (\"__cxa_begin_catch\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n     {\n-      exp = (tree) ptr[x];\n-      if (TREE_CODE (exp) == ADDR_EXPR)\n-        {\n-          exp = TREE_OPERAND (exp, 0);\n-          if (TREE_CODE (exp) == FUNCTION_DECL)\n-            TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (exp)) = 1;\n-        }\n+      /* Declare void* __cxa_begin_catch (void *).  */\n+      tree tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+      fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n-  \n-  free (ptr);\n+\n+  return build_function_call (fn, tree_cons (NULL_TREE, build_exc_ptr (),\n+\t\t\t\t\t     NULL_TREE));\n }\n \n /* Returns nonzero if cleaning up an exception of type TYPE (which can be\n@@ -415,32 +179,29 @@ dtor_nothrow (type)\n   return TREE_NOTHROW (fn);\n }\n \n-/* Build up a call to __cp_pop_exception, to destroy the exception object\n+/* Build up a call to __cxa_end_catch, to destroy the exception object\n    for the current catch block if no others are currently using it.  */\n \n static tree\n-do_pop_exception (type)\n+do_end_catch (type)\n      tree type;\n {\n   tree fn, cleanup;\n-  fn = get_identifier (\"__cp_pop_exception\");\n+\n+  fn = get_identifier (\"__cxa_end_catch\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      /* Declare void __cp_pop_exception (void *),\n-\t as defined in exception.cc. */\n-      fn = push_void_library_fn\n-\t(fn, tree_cons (NULL_TREE, ptr_type_node, void_list_node));\n+      /* Declare void __cxa_end_catch ().  */\n+      fn = push_void_library_fn (fn, void_list_node);\n       /* This can throw if the destructor for the exception throws.  */\n       TREE_NOTHROW (fn) = 0;\n     }\n \n-  /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n-  cleanup = lookup_name (get_identifier (\"__exception_info\"), 0);\n-  cleanup = build_function_call (fn, tree_cons\n-\t\t\t\t (NULL_TREE, cleanup, NULL_TREE));\n+  cleanup = build_function_call (fn, NULL_TREE);\n   TREE_NOTHROW (cleanup) = dtor_nothrow (type);\n+\n   return cleanup;\n }\n \n@@ -450,29 +211,20 @@ static void\n push_eh_cleanup (type)\n      tree type;\n {\n-  finish_decl_cleanup (NULL_TREE, do_pop_exception (type));\n-}\n-\n-/* Build up a call to terminate on the function obstack, for use as an\n-   exception handler.  */\n-\n-static tree\n-build_terminate_handler ()\n-{\n-  return build_function_call (terminate_node, NULL_TREE);\n+  finish_decl_cleanup (NULL_TREE, do_end_catch (type));\n }\n \n /* Return nonzero value if DECL is a Java type suitable for catch or\n    throw.  */\n \n-static int\n+static bool\n decl_is_java_type (decl, err)\n      tree decl;\n      int err;\n {\n-  int r = (TREE_CODE (decl) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n-\t   && TYPE_FOR_JAVA (TREE_TYPE (decl)));\n+  bool r = (TREE_CODE (decl) == POINTER_TYPE\n+\t    && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n+\t    && TYPE_FOR_JAVA (TREE_TYPE (decl)));\n \n   if (err)\n     {\n@@ -508,71 +260,74 @@ decl_is_java_type (decl, err)\n   return r;\n }\n \n+static void\n+choose_personality_routine (is_java)\n+     bool is_java;\n+{\n+  static enum {\n+    chose_none,\n+    chose_cpp,\n+    chose_java,\n+    gave_error\n+  } state;\n+\n+  switch (state)\n+    {\n+    case chose_none:\n+      /* We defaulted to C++ in init_exception_processing.\n+\t Reconfigure for Java if we changed our minds.  */\n+      if (is_java)\n+\teh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t\t\t\t   ? \"__gcj_personality_sj0\"\n+\t\t\t\t\t\t   : \"__gcj_personality_v0\");\n+      state = (is_java ? chose_java : chose_cpp);\n+      break;\n+\n+    case chose_cpp:\n+    case chose_java:\n+      if (state != (is_java ? chose_java : chose_cpp))\n+\t{\n+\t  error (\"mixing C++ and Java catches in a single translation unit\");\n+\t  state = gave_error;\n+\t}\n+      break;\n+\n+    case gave_error:\n+      break;\n+    }\n+}\n+\n /* Initialize the catch parameter DECL.  */\n \n static void \n-initialize_handler_parm (decl)\n+initialize_handler_parm (decl, exp)\n      tree decl;\n+     tree exp;\n {\n-  tree exp;\n   tree init;\n   tree init_type;\n-  int lang;\n \n   /* Make sure we mark the catch param as used, otherwise we'll get a\n      warning about an unused ((anonymous)).  */\n   TREE_USED (decl) = 1;\n \n-  /* Figure out the type that the initializer is.  */\n+  /* Figure out the type that the initializer is.  Pointers are returned\n+     adjusted by value from __cxa_begin_catch.  Others are returned by \n+     reference.  */\n   init_type = TREE_TYPE (decl);\n-  if (TREE_CODE (init_type) != REFERENCE_TYPE\n-      && TREE_CODE (init_type) != POINTER_TYPE)\n+  if (TREE_CODE (init_type) != POINTER_TYPE\n+      && TREE_CODE (init_type) != REFERENCE_TYPE)\n     init_type = build_reference_type (init_type);\n \n-  if (decl_is_java_type (init_type, 0))\n-    {\n-      tree fn\n-\t= builtin_function (\"_Jv_exception_info\", \n-\t\t\t    build_function_type (ptr_type_node,\n-\t\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t    void_type_node,\n-\t\t\t\t\t\t\t    NULL_TREE)),\n-\t\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-\n-      exp = build (CALL_EXPR, ptr_type_node,\n-\t\t   build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t   fn),\n-\t\t   NULL_TREE, NULL_TREE);\n-      TREE_SIDE_EFFECTS (exp) = 1;\n-      lang = EH_LANG_Java;\n-\n-      set_exception_lang_code (EH_LANG_Java);\n-      set_exception_version_code (1);\n-    }\n-  else\n-    {\n-      exp = get_eh_value ();\n-      lang = EH_LANG_C_plus_plus;\n-    }\n-\n-  if (catch_language_init)\n-    {\n-      if (lang != catch_language)\n-\terror (\"mixing C++ and Java `catch'es in single translation unit\");\n-    }\n-  else\n-    {\n-      catch_language_init = 1;\n-      catch_language = lang;\n-    }\n+  choose_personality_routine (decl_is_java_type (init_type, 0));\n \n   /* Since pointers are passed by value, initialize a reference to\n-     pointer catch parm with the address of the value slot.  */ \n+     pointer catch parm with the address of the temporary.  */\n   if (TREE_CODE (init_type) == REFERENCE_TYPE \n       && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)\n     exp = build_unary_op (ADDR_EXPR, exp, 1);\n \n-  exp = ocp_convert (init_type , exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+  exp = ocp_convert (init_type, exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n \n   init = convert_from_reference (exp);\n \n@@ -584,8 +339,7 @@ initialize_handler_parm (decl)\n \t See also expand_default_init.  */\n       init = ocp_convert (TREE_TYPE (decl), init,\n \t\t\t  CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n-      init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n-\t\t    build_terminate_handler ());\n+      init = build1 (MUST_NOT_THROW_EXPR, TREE_TYPE (init), init);\n     }\n \n   /* Let `cp_finish_decl' know that this initializer is ok.  */\n@@ -605,6 +359,9 @@ expand_start_catch_block (decl)\n {\n   tree compound_stmt_1;\n   tree compound_stmt_2;\n+  tree exp = NULL_TREE;\n+  tree type;\n+  bool is_java;\n \n   if (! doing_eh (1))\n     return NULL_TREE;\n@@ -618,34 +375,54 @@ expand_start_catch_block (decl)\n   compound_stmt_1 = begin_compound_stmt (/*has_no_scope=*/0);\n   note_level_for_catch ();\n \n-  if (! decl || ! decl_is_java_type (TREE_TYPE (decl), 1))\n+  if (decl)\n+    type = prepare_eh_type (TREE_TYPE (decl));\n+  else\n+    type = NULL_TREE;\n+  begin_catch_block (type);\n+\n+  is_java = false;\n+  if (decl)\n     {\n-      /* The ordinary C++ case.  */\n-      tree type;\n+      tree init;\n \n-      if (decl)\n-\ttype = TREE_TYPE (decl);\n+      if (decl_is_java_type (type, 1))\n+\t{\n+\t  /* Java only passes object via pointer and doesn't require\n+\t     adjusting.  The java object is immediately before the\n+\t     generic exception header.  */\n+\t  init = build_exc_ptr ();\n+\t  init = build1 (NOP_EXPR, build_pointer_type (type), init);\n+\t  init = build (MINUS_EXPR, TREE_TYPE (init), init,\n+\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (init)));\n+\t  init = build_indirect_ref (init, NULL_PTR);\n+\t  is_java = true;\n+\t}\n       else\n-\ttype = NULL_TREE;\n-      begin_catch_block (build_eh_type_type_ref (type));\n-\n-      push_eh_info ();\n-      push_eh_cleanup (type);\n+\t{\n+\t  /* C++ requires that we call __cxa_begin_catch to get the\n+\t     pointer to the actual object.  */\n+\t  init = do_begin_catch ();\n+\t}\n+\t  \n+      exp = create_temporary_var (ptr_type_node);\n+      DECL_REGISTER (exp) = 1;\n+      cp_finish_decl (exp, init, NULL_TREE, LOOKUP_ONLYCONVERTING);\n+      finish_expr_stmt (build_modify_expr (exp, INIT_EXPR, init));\n     }\n   else\n-    {\n-      /* The Java case.  In this case, the match_info is a pointer to\n-\t the Java class object.  We assume that the class is a\n-\t compiled class.  */\n-      tree ref = build_java_class_ref (TREE_TYPE (TREE_TYPE (decl)));\n-      begin_catch_block (build1 (ADDR_EXPR, jclass_node, ref));\n-    }\n+    finish_expr_stmt (do_begin_catch ());\n+\n+  /* C++ requires that we call __cxa_end_catch at the end of\n+     processing the exception.  */\n+  if (! is_java)\n+    push_eh_cleanup (type);\n \n   /* Create a binding level for the parm.  */\n   compound_stmt_2 = begin_compound_stmt (/*has_no_scope=*/0);\n \n   if (decl)\n-    initialize_handler_parm (decl);\n+    initialize_handler_parm (decl, exp);\n \n   return build_tree_list (compound_stmt_1, compound_stmt_2);\n }\n@@ -678,366 +455,255 @@ expand_end_catch_block (blocks)\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt_1);\n }\n \n-/* An exception spec is implemented more or less like:\n-\n-   try {\n-     function body;\n-   } catch (...) {\n-     void *p[] = { typeid(raises) };\n-     __check_eh_spec (p, count);\n-   }\n-\n-   __check_eh_spec in exception.cc handles all the details.  */\n-\n tree\n-expand_start_eh_spec ()\n+begin_eh_spec_block ()\n {\n-  return begin_try_block ();\n+  tree r = build_stmt (EH_SPEC_BLOCK, NULL_TREE, NULL_TREE);\n+  add_stmt (r);\n+  return r;\n }\n \n void\n-expand_end_eh_spec (raises, try_block)\n-     tree raises;\n-     tree try_block;\n+finish_eh_spec_block (raw_raises, eh_spec_block)\n+     tree raw_raises;\n+     tree eh_spec_block;\n {\n-  tree tmp, fn, decl, types = NULL_TREE;\n-  tree blocks;\n-  tree handler;\n-  int count = 0;\n-\n-  finish_try_block (try_block);\n-  handler = begin_handler ();\n-  blocks = finish_handler_parms (NULL_TREE, handler);\n-\n-  if (TREE_VALUE (raises) == NULL_TREE)\n-    {\n-      fn = get_identifier (\"__check_null_eh_spec\");\n-      if (IDENTIFIER_GLOBAL_VALUE (fn))\n-\tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n-      else\n-\t{\n-\t  tmp = build_function_type (void_type_node, void_list_node);\n-\t  fn = push_throw_library_fn (fn, tmp);\n-\t  /* Since the spec doesn't allow any exceptions, this call will\n-\t     never throw.  We use push_throw_library_fn because we do want\n-\t     TREE_THIS_VOLATILE to be set.  */\n-\t  TREE_NOTHROW (fn) = 1;\n-\t}\n-      tmp = NULL_TREE;\n-    }\n-  else\n-    {\n-      /* Build up an array of type_infos.  */\n-      for (; raises && TREE_VALUE (raises); raises = TREE_CHAIN (raises))\n-\t{\n-\t  types = tree_cons\n-\t    (NULL_TREE, build_eh_type_type (TREE_VALUE (raises)), types);\n-\t  ++count;\n-\t}\n-\n-      types = build_nt (CONSTRUCTOR, NULL_TREE, types);\n-      TREE_HAS_CONSTRUCTOR (types) = 1;\n-\n-      /* We can't pass the CONSTRUCTOR directly, so stick it in a variable.  */\n-      tmp = build_cplus_array_type (const_ptr_type_node, NULL_TREE);\n-      decl = build_decl (VAR_DECL, NULL_TREE, tmp);\n-      DECL_ARTIFICIAL (decl) = 1;\n-      DECL_INITIAL (decl) = types;\n-      DECL_CONTEXT (decl) = current_function_decl;\n-      cp_finish_decl (decl, types, NULL_TREE, 0);\n-\n-      decl = decay_conversion (decl);\n-\n-      fn = get_identifier (\"__check_eh_spec\");\n-      if (IDENTIFIER_GLOBAL_VALUE (fn))\n-\tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n-      else\n-\t{\n-\t  tmp = tree_cons\n-\t    (NULL_TREE, integer_type_node, tree_cons\n-\t     (NULL_TREE, TREE_TYPE (decl), void_list_node));\n-\t  tmp = build_function_type (void_type_node, tmp);\n-\n-\t  fn = push_throw_library_fn (fn, tmp);\n-\t}\n+  tree raises;\n \n-      tmp = tree_cons (NULL_TREE, build_int_2 (count, 0), \n-\t\t       tree_cons (NULL_TREE, decl, NULL_TREE));\n-    }\n+  RECHAIN_STMTS (eh_spec_block, EH_SPEC_STMTS (eh_spec_block));\n \n-  tmp = build_call (fn, tmp);\n-  finish_expr_stmt (tmp);\n+  /* Strip cv quals, etc, from the specification types.  */\n+  for (raises = NULL_TREE;\n+       raw_raises && TREE_VALUE (raw_raises);\n+       raw_raises = TREE_CHAIN (raw_raises))\n+    raises = tree_cons (NULL_TREE, prepare_eh_type (TREE_VALUE (raw_raises)),\n+\t\t\traises);\n \n-  finish_handler (blocks, handler);\n-  finish_handler_sequence (try_block);\n+  EH_SPEC_RAISES (eh_spec_block) = raises;\n }\n \n-/* This is called to expand all the toplevel exception handling\n-   finalization for a function.  It should only be called once per\n-   function.  */\n+/* Return a pointer to a buffer for an exception object of type TYPE.  */\n \n-void\n-expand_exception_blocks ()\n+static tree\n+do_allocate_exception (type)\n+     tree type;\n {\n-  do_pending_stack_adjust ();\n+  tree fn;\n \n-  if (catch_clauses)\n+  fn = get_identifier (\"__cxa_allocate_exception\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n     {\n-      rtx funcend = gen_label_rtx ();\n-      emit_jump (funcend);\n-\n-      /* We cannot protect n regions this way if we must flow into the\n-\t EH region through the top of the region, as we have to with\n-\t the setjmp/longjmp approach.  */\n-      if (USING_SJLJ_EXCEPTIONS == 0)\n-\texpand_eh_region_start ();\n-\n-      emit_insns (catch_clauses);\n-      catch_clauses = catch_clauses_last = NULL_RTX;\n-\n-      if (USING_SJLJ_EXCEPTIONS == 0)\n-\texpand_eh_region_end (build_terminate_handler ());\n-\n-      emit_insns (catch_clauses);\n-      catch_clauses = catch_clauses_last = NULL_RTX;\n-      emit_label (funcend);\n+      /* Declare void *__cxa_allocate_exception(size_t).  */\n+      tree tmp = tree_cons (NULL_TREE, c_size_type_node, void_list_node);\n+      fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n+  \n+  return build_function_call (fn, tree_cons (NULL_TREE, size_in_bytes (type),\n+\t\t\t\t\t     NULL_TREE));\n }\n \n-/* Return a pointer to a buffer for an exception object of type TYPE.  */\n+/* Call __cxa_free_exception from a cleanup.  This is invoked when\n+   a constructor for a thrown object throws.  */\n \n static tree\n-alloc_eh_object (type)\n-     tree type;\n+do_free_exception (ptr)\n+     tree ptr;\n {\n-  tree fn, exp;\n+  tree fn;\n \n-  fn = get_identifier (\"__eh_alloc\");\n+  fn = get_identifier (\"__cxa_free_exception\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      /* Declare __eh_alloc (size_t), as defined in exception.cc.  */\n-      tree tmp = tree_cons (NULL_TREE, sizetype, void_list_node);\n-      fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n+      /* Declare void __cxa_free_exception (void *).  */\n+      fn = push_void_library_fn (fn, tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\tvoid_list_node));\n     }\n \n-  exp = build_function_call (fn, tree_cons\n-\t\t\t     (NULL_TREE, size_in_bytes (type), NULL_TREE));\n-  exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n-  return exp;\n+  return build_function_call (fn, tree_cons (NULL_TREE, ptr, NULL_TREE));\n }\n \n-/* Expand a throw statement.  This follows the following\n-   algorithm:\n-\n-\t1. Allocate space to save the current PC onto the stack.\n-\t2. Generate and emit a label and save its address into the\n-\t\tnewly allocated stack space since we can't save the pc directly.\n-\t3. If this is the first call to throw in this function:\n-\t\tgenerate a label for the throw block\n-\t4. jump to the throw block label.  */\n+/* Build a throw expression.  */\n \n-static tree\n-expand_throw (exp)\n+tree\n+build_throw (exp)\n      tree exp;\n {\n   tree fn;\n \n+  if (exp == error_mark_node)\n+    return exp;\n+\n+  if (processing_template_decl)\n+    return build_min (THROW_EXPR, void_type_node, exp);\n+\n+  if (exp == null_node)\n+    cp_warning (\"throwing NULL, which has integral, not pointer type\");\n+  \n+  if (exp != NULL_TREE)\n+    {\n+      if (!is_admissible_throw_operand (exp))\n+        return error_mark_node;\n+    }\n+\n   if (! doing_eh (1))\n     return error_mark_node;\n \n-  if (exp\n-      && decl_is_java_type (TREE_TYPE (exp), 1))\n+  if (exp && decl_is_java_type (TREE_TYPE (exp), 1))\n     {\n-      /* A Java `throw' statement.  */\n-      tree args = tree_cons (NULL_TREE, exp, NULL);\n-\n-      fn = get_identifier (USING_SJLJ_EXCEPTIONS\n-\t\t\t   ? \"_Jv_Sjlj_Throw\"\n-\t\t\t   : \"_Jv_Throw\");\n+      tree fn = get_identifier (\"_Jv_Throw\");\n       if (IDENTIFIER_GLOBAL_VALUE (fn))\n \tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n       else\n \t{\n-\t  /* Declare _Jv_Throw (void *), as defined in Java's\n-\t     exception.cc.  */\n+\t  /* Declare void _Jv_Throw (void *).  */\n \t  tree tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n \t  tmp = build_function_type (ptr_type_node, tmp);\n \t  fn = push_throw_library_fn (fn, tmp);\n \t}\n \n-      exp = build_function_call (fn, args);\n+      exp = build_function_call (fn, tree_cons (NULL_TREE, exp, NULL_TREE));\n     }\n   else if (exp)\n     {\n       tree throw_type;\n-      tree cleanup = NULL_TREE, e;\n+      tree cleanup;\n       tree stmt_expr;\n       tree compound_stmt;\n       tree try_block;\n+      tree object, ptr;\n+      tree tmp;\n+\n+      fn = get_identifier (\"__cxa_throw\");\n+      if (IDENTIFIER_GLOBAL_VALUE (fn))\n+\tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n+      else\n+\t{\n+\t  /* The CLEANUP_TYPE is the internal type of a destructor.  */\n+\t  if (cleanup_type == NULL_TREE)\n+\t    {\n+\t      tmp = void_list_node;\n+\t      tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);\n+\t      tmp = build_function_type (void_type_node, tmp);\n+\t      cleanup_type = build_pointer_type (tmp);\n+\t    }\n+\n+\t  /* Declare void __cxa_throw (void*, void*, void (*)(void*)).  */\n+\t  /* ??? Second argument is supposed to be \"std::type_info*\".  */\n+\t  tmp = void_list_node;\n+\t  tmp = tree_cons (NULL_TREE, cleanup_type, tmp);\n+\t  tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);\n+\t  tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);\n+\t  tmp = build_function_type (void_type_node, tmp);\n+\t  fn = push_throw_library_fn (fn, tmp);\n+\t}\n \n       begin_init_stmts (&stmt_expr, &compound_stmt);\n \n       /* throw expression */\n       /* First, decay it.  */\n       exp = decay_conversion (exp);\n \n-      /* The CLEANUP_TYPE is the internal type of a destructor.  Under\n-\t the old ABI, destructors are two-argument functions; under\n-\t the new ABI they take only one argument.  */\n-      if (cleanup_type == NULL_TREE)\n+      /* OK, this is kind of wacky.  The standard says that we call\n+\t terminate when the exception handling mechanism, after\n+\t completing evaluation of the expression to be thrown but\n+\t before the exception is caught (_except.throw_), calls a\n+\t user function that exits via an uncaught exception.\n+\n+\t So we have to protect the actual initialization of the\n+\t exception object with terminate(), but evaluate the\n+\t expression first.  Since there could be temps in the\n+\t expression, we need to handle that, too.  We also expand\n+\t the call to __cxa_allocate_exception first (which doesn't\n+\t matter, since it can't throw).  */\n+\n+      my_friendly_assert (stmts_are_full_exprs_p () == 1, 19990926);\n+\n+      /* Store the throw expression into a temp.  This can be less\n+\t efficient than storing it into the allocated space directly, but\n+\t if we allocated the space first we would have to deal with\n+\t cleaning it up if evaluating this expression throws.  */\n+      if (TREE_SIDE_EFFECTS (exp))\n \t{\n-\t  tree arg_types;\n-\t  \n-\t  arg_types = void_list_node;\n-\t  arg_types = tree_cons (NULL_TREE, ptr_type_node, arg_types);\n-\t  cleanup_type = (build_pointer_type \n-\t\t\t  (build_function_type (void_type_node, arg_types)));\n+\t  tmp = create_temporary_var (TREE_TYPE (exp));\n+\t  DECL_INITIAL (tmp) = exp;\n+\t  cp_finish_decl (tmp, exp, NULL_TREE, LOOKUP_ONLYCONVERTING);\n+\t  exp = tmp;\n \t}\n \n-      if (TYPE_PTR_P (TREE_TYPE (exp)))\n-\tthrow_type = build_eh_type_type (TREE_TYPE (exp));\n-      else\n-\t{\n-\t  tree object, ptr;\n-\n-\t  /* OK, this is kind of wacky.  The standard says that we call\n-\t     terminate when the exception handling mechanism, after\n-\t     completing evaluation of the expression to be thrown but\n-\t     before the exception is caught (_except.throw_), calls a\n-\t     user function that exits via an uncaught exception.\n-\n-\t     So we have to protect the actual initialization of the\n-\t     exception object with terminate(), but evaluate the\n-\t     expression first.  Since there could be temps in the\n-\t     expression, we need to handle that, too.  We also expand\n-\t     the call to __eh_alloc first (which doesn't matter, since\n-\t     it can't throw).  */\n-\n-\t  my_friendly_assert (stmts_are_full_exprs_p () == 1, 19990926);\n-\n-\t  /* Store the throw expression into a temp.  This can be less\n-\t     efficient than storing it into the allocated space directly, but\n-\t     if we allocated the space first we would have to deal with\n-\t     cleaning it up if evaluating this expression throws.  */\n-\t  if (TREE_SIDE_EFFECTS (exp))\n-\t    {\n-\t      tree temp = create_temporary_var (TREE_TYPE (exp));\n-\t      DECL_INITIAL (temp) = exp;\n-\t      cp_finish_decl (temp, exp, NULL_TREE, LOOKUP_ONLYCONVERTING);\n-\t      exp = temp;\n-\t    }\n+      /* Allocate the space for the exception.  */\n+      ptr = create_temporary_var (ptr_type_node);\n+      DECL_REGISTER (ptr) = 1;\n+      cp_finish_decl (ptr, NULL_TREE, NULL_TREE, LOOKUP_ONLYCONVERTING);\n+      tmp = do_allocate_exception (TREE_TYPE (exp));\n+      tmp = build_modify_expr (ptr, INIT_EXPR, tmp);\n+      finish_expr_stmt (tmp);\n \n-\t  /* Allocate the space for the exception.  */\n-\t  ptr = save_expr (alloc_eh_object (TREE_TYPE (exp)));\n-\t  finish_expr_stmt (ptr);\n+      object = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (exp)), ptr);\n+      object = build_indirect_ref (object, NULL_PTR);\n \n-\t  try_block = begin_try_block ();\n-\t  object = build_indirect_ref (ptr, NULL_PTR);\n-\t  exp = build_modify_expr (object, INIT_EXPR, exp);\n+      try_block = begin_try_block ();\n \n-\t  if (exp == error_mark_node)\n-\t    error (\"  in thrown expression\");\n+      exp = build_modify_expr (object, INIT_EXPR, exp);\n+      if (exp == error_mark_node)\n+\terror (\"  in thrown expression\");\n \n-\t  finish_expr_stmt (exp);\n-\t  finish_cleanup_try_block (try_block);\n-\t  finish_cleanup (build_terminate_handler (), try_block);\n+      finish_expr_stmt (exp);\n+      finish_cleanup_try_block (try_block);\n+      finish_cleanup (do_free_exception (ptr), try_block);\n \n-\t  throw_type = build_eh_type_type (TREE_TYPE (object));\n-\n-\t  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n-\t    {\n-\t      cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n-\t\t\t\t\t complete_dtor_identifier,\n-\t\t\t\t\t 0);\n-\t      cleanup = TREE_VALUE (cleanup);\n-\t      mark_used (cleanup);\n-\t      mark_addressable (cleanup);\n-\t      /* Pretend it's a normal function.  */\n-\t      cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);\n-\t    }\n+      throw_type = build_eh_type_type (prepare_eh_type (TREE_TYPE (object)));\n \n-\t  exp = ptr;\n+      if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n+\t{\n+\t  cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n+\t\t\t\t     complete_dtor_identifier, 0);\n+\t  cleanup = TREE_VALUE (cleanup);\n+\t  mark_used (cleanup);\n+\t  mark_addressable (cleanup);\n+\t  /* Pretend it's a normal function.  */\n+\t  cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);\n \t}\n-\n-      /* Cast EXP to `void *' so that it will match the prototype for\n-\t __cp_push_exception.  */\n-      exp = convert (ptr_type_node, exp);\n-\n-      if (cleanup == NULL_TREE)\n+      else\n \t{\n \t  cleanup = build_int_2 (0, 0);\n \t  TREE_TYPE (cleanup) = cleanup_type;\n \t}\n \n-      fn = cp_push_exception_identifier;\n-      if (IDENTIFIER_GLOBAL_VALUE (fn))\n-\tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n-      else\n-\t{\n-\t  /* Declare __cp_push_exception (void*, void*, void (*)(void*, int)),\n-\t     as defined in exception.cc.  */\n-\t  tree tmp;\n-\t  tmp = tree_cons\n-\t    (NULL_TREE, ptr_type_node, tree_cons\n-\t     (NULL_TREE, ptr_type_node, tree_cons\n-\t      (NULL_TREE, cleanup_type, void_list_node)));\n-\t  fn = push_void_library_fn (fn, tmp);\n-\t}\n+      tmp = tree_cons (NULL_TREE, cleanup, NULL_TREE);\n+      tmp = tree_cons (NULL_TREE, throw_type, tmp);\n+      tmp = tree_cons (NULL_TREE, ptr, tmp);\n+      tmp = build_function_call (fn, tmp);\n+\n+      /* ??? Indicate that this function call throws throw_type.  */\n \n-      e = tree_cons (NULL_TREE, exp, tree_cons\n-\t\t     (NULL_TREE, throw_type, tree_cons\n-\t\t      (NULL_TREE, cleanup, NULL_TREE)));\n-      finish_expr_stmt (build_function_call (fn, e));\n+      finish_expr_stmt (tmp);\n \n       exp = finish_init_stmts (stmt_expr, compound_stmt);\n     }\n   else\n     {\n-      /* rethrow current exception; note that it's no longer caught.  */\n+      /* Rethrow current exception.  */\n \n-      tree fn = get_identifier (\"__uncatch_exception\");\n+      tree fn = get_identifier (\"__cxa_rethrow\");\n       if (IDENTIFIER_GLOBAL_VALUE (fn))\n \tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n       else\n-\t/* Declare void __uncatch_exception (void)\n-\t   as defined in exception.cc. */\n-\tfn = push_void_library_fn (fn, void_list_node);\n+\t{\n+\t  /* Declare void __cxa_rethrow (void).  */\n+\t  fn = push_throw_library_fn\n+\t    (fn, build_function_type (void_type_node, void_list_node));\n+\t}\n \n       exp = build_function_call (fn, NULL_TREE);\n     }\n \n-  return exp;\n-}\n+  exp = build1 (THROW_EXPR, void_type_node, exp);\n \n-/* Build a throw expression.  */\n-\n-tree\n-build_throw (e)\n-     tree e;\n-{\n-  if (e == error_mark_node)\n-    return e;\n-\n-  if (processing_template_decl)\n-    return build_min (THROW_EXPR, void_type_node, e);\n-\n-  if (e == null_node)\n-    cp_warning (\"throwing NULL, which has integral, not pointer type\");\n-  \n-  if (e != NULL_TREE)\n-    {\n-      if (!is_admissible_throw_operand (e))\n-        return error_mark_node;\n-    }\n-\n-  e = expand_throw (e);\n-  e = build1 (THROW_EXPR, void_type_node, e);\n-  TREE_SIDE_EFFECTS (e) = 1;\n-  TREE_USED (e) = 1;\n-\n-  return e;\n+  return exp;\n }\n \n /* Make sure TYPE is complete, pointer to complete, reference to"}, {"sha": "9a9eb86f52645dae6f3879c1460b49ca6b8d39ed", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -88,6 +88,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n   tree type = TREE_TYPE (exp);\n   register enum machine_mode mode = TYPE_MODE (type);\n   register enum tree_code code = TREE_CODE (exp);\n+  rtx ret;\n \n   /* No sense saving up arithmetic to be done\n      if it's all in the wrong mode to form part of an address.\n@@ -103,16 +104,19 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t\t\t  target, tmode, modifier);\n \n     case OFFSET_REF:\n-      {\n-\treturn expand_expr (default_conversion (resolve_offset_ref (exp)),\n-\t\t\t    target, tmode, EXPAND_NORMAL);\n-      }\n+      return expand_expr (default_conversion (resolve_offset_ref (exp)),\n+\t\t\t  target, tmode, EXPAND_NORMAL);\n \n     case THROW_EXPR:\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n-      expand_internal_throw ();\n       return NULL;\n \n+    case MUST_NOT_THROW_EXPR:\n+      expand_eh_region_start ();\n+      ret = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n+      expand_eh_region_end_must_not_throw (build_call (terminate_node, 0));\n+      return ret;\n+\n     case EMPTY_CLASS_EXPR:\n       /* We don't need to generate any code for an empty class.  */\n       return const0_rtx;"}, {"sha": "6990e2c37679088953f359128a1a0a9f774e9f33", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -51,6 +51,7 @@ static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n static void deferred_type_access_control PARAMS ((void));\n static void emit_associated_thunks PARAMS ((tree));\n static void genrtl_try_block PARAMS ((tree));\n+static void genrtl_eh_spec_block PARAMS ((tree));\n static void genrtl_handler PARAMS ((tree));\n static void genrtl_catch_block PARAMS ((tree));\n static void genrtl_ctor_stmt PARAMS ((tree));\n@@ -575,14 +576,14 @@ genrtl_try_block (t)\n     {\n       expand_eh_region_start ();\n       expand_stmt (TRY_STMTS (t));\n-      expand_eh_region_end (protect_with_terminate (TRY_HANDLERS (t)));\n+      expand_eh_region_end_cleanup (TRY_HANDLERS (t));\n     }\n   else\n     {\n       if (!FN_TRY_BLOCK_P (t)) \n \temit_line_note (input_filename, lineno);\n-      expand_start_try_stmts ();\n \n+      expand_eh_region_start ();\n       expand_stmt (TRY_STMTS (t));\n \n       if (FN_TRY_BLOCK_P (t))\n@@ -603,6 +604,21 @@ genrtl_try_block (t)\n     }\n }\n \n+/* Generate the RTL for T, which is an EH_SPEC_BLOCK. */\n+\n+static void \n+genrtl_eh_spec_block (t)\n+     tree t;\n+{\n+  expand_eh_region_start ();\n+  expand_stmt (EH_SPEC_STMTS (t));\n+  expand_eh_region_end_allowed (EH_SPEC_RAISES (t),\n+\t\t\t\tbuild_call (call_unexpected_node,\n+\t\t\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t\t\t       build_exc_ptr (),\n+\t\t\t\t\t\t       NULL_TREE)));\n+}\n+\n /* Begin a try-block.  Returns a newly-created TRY_BLOCK if\n    appropriate.  */\n \n@@ -706,13 +722,7 @@ genrtl_handler (t)\n   genrtl_do_pushlevel ();\n   expand_stmt (HANDLER_BODY (t));\n   if (!processing_template_decl)\n-    {\n-      /* Fall to outside the try statement when done executing\n-\t handler and we fall off end of handler.  This is jump\n-\t Lresume in the documentation.  */\n-      expand_goto (top_label_entry (&caught_return_label_stack));\n-      end_catch_handler ();\n-    }\n+    expand_end_catch ();\n }\n \n /* Begin a handler.  Returns a HANDLER if appropriate.  */\n@@ -757,13 +767,13 @@ finish_handler_parms (decl, handler)\n   return blocks;\n }\n \n-/* Generate the RTL for a CATCH_BLOCK. */\n+/* Generate the RTL for a START_CATCH_STMT. */\n \n static void\n genrtl_catch_block (type)\n      tree type;\n {\n-  start_catch_handler (type);\n+  expand_start_catch (type);\n }\n \n /* Note the beginning of a handler for TYPE.  This function is called\n@@ -2209,6 +2219,10 @@ cp_expand_stmt (t)\n       genrtl_try_block (t);\n       break;\n \n+    case EH_SPEC_BLOCK:\n+      genrtl_eh_spec_block (t);\n+      break;\n+\n     case HANDLER:\n       genrtl_handler (t);\n       break;\n@@ -2615,9 +2629,6 @@ genrtl_finish_function (fn)\n       && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n     no_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n-  if (flag_exceptions)\n-    expand_exception_blocks ();\n-\n   /* If this function is supposed to return a value, ensure that\n      we do not fall into the cleanups by mistake.  The end of our\n      function will look like this:"}, {"sha": "5f67840ec817e70fd3c8f5260101acf073521e35", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1037,6 +1037,7 @@ cp_statement_code_p (code)\n     case RETURN_INIT:\n     case TRY_BLOCK:\n     case HANDLER:\n+    case EH_SPEC_BLOCK:\n       return 1;\n \n     default:"}, {"sha": "2e18e5a6d07d355a6d2f1f7db53b52881529b984", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -60,15 +60,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"auto-host.h\"\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n-#include \"frame.h\"\n+#include \"unwind-dw2-fde.h\"\n \n #ifndef CRT_CALL_STATIC_FUNCTION\n # define CRT_CALL_STATIC_FUNCTION(func) func ()\n #endif\n \n /* We do not want to add the weak attribute to the declarations of these\n-   routines in frame.h because that will cause the definition of these\n-   symbols to be weak as well.\n+   routines in unwind-dw2-fde.h because that will cause the definition of\n+   these symbols to be weak as well.\n \n    This exposes a core issue, how to handle creating weak references vs\n    how to create weak definitions.  Either we have to have the definition"}, {"sha": "e6148a367663c0418a84d034c58a73bbc32941e6", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -501,9 +501,14 @@ enum dwarf_call_frame_info\n     DW_CFA_def_cfa_offset = 0x0e,\n     DW_CFA_def_cfa_expression = 0x0f,\n     DW_CFA_expression = 0x10,\n+    /* Dwarf 2.1 */\n+    DW_CFA_offset_extended_sf = 0x11,\n+    DW_CFA_def_cfa_sf = 0x12,\n+    DW_CFA_def_cfa_offset_sf = 0x13,\n+\n     /* SGI/MIPS specific */\n     DW_CFA_MIPS_advance_loc8 = 0x1d,\n-\n+    \n     /* GNU extensions */\n     DW_CFA_GNU_window_save = 0x2d,\n     DW_CFA_GNU_args_size = 0x2e,\n@@ -554,3 +559,26 @@ enum dwarf_macinfo_record_type\n     DW_MACINFO_end_file = 4,\n     DW_MACINFO_vendor_ext = 255\n   };\n+\n+\f\n+/* @@@ For use with GNU frame unwind information.  */\n+\n+#define DW_EH_PE_absptr\t\t0x00\n+#define DW_EH_PE_omit\t\t0xff\n+\n+#define DW_EH_PE_uleb128\t0x01\n+#define DW_EH_PE_udata2\t\t0x02\n+#define DW_EH_PE_udata4\t\t0x03\n+#define DW_EH_PE_udata8\t\t0x04\n+#define DW_EH_PE_sleb128\t0x09\n+#define DW_EH_PE_sdata2\t\t0x0A\n+#define DW_EH_PE_sdata4\t\t0x0B\n+#define DW_EH_PE_sdata8\t\t0x0C\n+#define DW_EH_PE_signed\t\t0x08\n+\n+#define DW_EH_PE_pcrel\t\t0x10\n+#define DW_EH_PE_textrel\t0x20\n+#define DW_EH_PE_datarel\t0x30\n+#define DW_EH_PE_funcrel\t0x40\n+\n+#define DW_EH_PE_indirect\t0x80"}, {"sha": "6f8d335d5eb627df0eb337e46df5110f9cabdd8c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"insn-config.h\"\n #include \"reload.h\"\n+#include \"function.h\"\n #include \"output.h\"\n #include \"expr.h\"\n #include \"except.h\"\n@@ -150,7 +151,9 @@ typedef struct dw_fde_struct\n   const char *dw_fde_current_label;\n   const char *dw_fde_end;\n   dw_cfi_ref dw_fde_cfi;\n-  int nothrow;\n+  unsigned funcdef_number;\n+  unsigned nothrow : 1;\n+  unsigned uses_eh_lsda : 1;\n }\n dw_fde_node;\n \n@@ -217,7 +220,7 @@ static dw_cfi_ref cie_cfi_head;\n    maximum number of function definitions contained within the current\n    compilation unit.  These numbers are used to create unique label id's\n    unique to each function definition.  */\n-static unsigned current_funcdef_number = 0;\n+unsigned current_funcdef_number = 0;\n \n /* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram\n    attribute that accelerates the lookup of the FDE associated\n@@ -1684,22 +1687,22 @@ output_call_frame_info (for_eh)\n   register dw_fde_ref fde;\n   register dw_cfi_ref cfi;\n   char l1[20], l2[20];\n-#ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-  char ld[20];\n-#endif\n-\n-  /* Do we want to include a pointer to the exception table?  */\n-  int eh_ptr = for_eh && exception_table_p ();\n+  int any_lsda_needed = 0;\n+  char augmentation[6];\n \n   /* If we don't have any functions we'll want to unwind out of, don't\n      emit any EH unwind information.  */\n   if (for_eh)\n     {\n+      int any_eh_needed = 0;\n       for (i = 0; i < fde_table_in_use; ++i)\n-\tif (! fde_table[i].nothrow)\n-\t  goto found;\n-      return;\n-    found:;\n+\tif (fde_table[i].uses_eh_lsda)\n+\t  any_eh_needed = any_lsda_needed = 1;\n+\telse if (! fde_table[i].nothrow)\n+\t  any_eh_needed = 1;\n+\n+      if (! any_eh_needed)\n+\treturn;\n     }\n \n   /* We're going to be generating comments, so turn on app.  */\n@@ -1726,14 +1729,8 @@ output_call_frame_info (for_eh)\n   /* Output the CIE.  */\n   ASM_GENERATE_INTERNAL_LABEL (l1, CIE_AFTER_SIZE_LABEL, for_eh);\n   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);\n-#ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-  ASM_GENERATE_INTERNAL_LABEL (ld, CIE_LENGTH_LABEL, for_eh);\n-  dw2_asm_output_offset (for_eh ? 4 : DWARF_OFFSET_SIZE, ld,\n-\t\t\t\"Length of Common Information Entry\");\n-#else\n   dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n \t\t\t\"Length of Common Information Entry\");\n-#endif\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   /* Now that the CIE pointer is PC-relative for EH,\n@@ -1744,20 +1741,23 @@ output_call_frame_info (for_eh)\n \n   dw2_asm_output_data (1, DW_CIE_VERSION, \"CIE Version\");\n \n-  if (eh_ptr)\n-    {\n-      /* The CIE contains a pointer to the exception region info for the\n-         frame.  Make the augmentation string three bytes (including the\n-         trailing null) so the pointer is 4-byte aligned.  The Solaris ld\n-         can't handle unaligned relocs.  */\n-      dw2_asm_output_nstring (\"eh\", -1, \"CIE Augmentation\");\n-      dw2_asm_output_addr (DWARF2_ADDR_SIZE, \"__EXCEPTION_TABLE__\",\n-\t\t\t   \"pointer to exception region info\");\n-    }\n-  else\n+  augmentation[0] = 0;\n+  if (for_eh)\n     {\n-      dw2_asm_output_data (1, 0, \"CIE Augmentation (none)\");\n+      /* Augmentation:\n+\t z\tIndicates that a uleb128 is present to size the\n+\t \taugmentation section.\n+\t R\tIndicates a pointer encoding for CIE and FDE pointers.\n+\t P\tIndicates the presence of a language personality\n+\t \troutine in the CIE augmentation and an LSDA in the\n+\t\tFDE augmentation.  */\n+\n+      /* ??? Handle pointer encodings.  */\n+\n+      if (any_lsda_needed)\n+\tstrcpy (augmentation, \"zP\");\n     }\n+  dw2_asm_output_nstring (augmentation, -1, \"CIE Augmentation\");\n \n   dw2_asm_output_data_uleb128 (1, \"CIE Code Alignment Factor\");\n \n@@ -1766,38 +1766,37 @@ output_call_frame_info (for_eh)\n \n   dw2_asm_output_data (1, DWARF_FRAME_RETURN_COLUMN, \"CIE RA Column\");\n \n+  if (augmentation[0])\n+    {\n+      dw2_asm_output_data_uleb128 (DWARF2_ADDR_SIZE, \"Augmentation size\");\n+      if (eh_personality_libfunc)\n+\tdw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, eh_personality_libfunc,\n+\t\t\t\t \"Personality\");\n+      else\n+\tdw2_asm_output_data (DWARF2_ADDR_SIZE, 0, \"Personality (none)\");\n+    }\n+\n   for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n     output_cfi (cfi, NULL);\n \n   /* Pad the CIE out to an address sized boundary.  */\n   ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DWARF2_ADDR_SIZE));\n   ASM_OUTPUT_LABEL (asm_out_file, l2);\n-#ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-  ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL (asm_out_file, ld, l2, l1);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s CIE Length Symbol\", ASM_COMMENT_START);\n-  fputc ('\\n', asm_out_file);\n-#endif\n \n   /* Loop through all of the FDE's.  */\n   for (i = 0; i < fde_table_in_use; ++i)\n     {\n       fde = &fde_table[i];\n \n-      /* Don't emit EH unwind info for leaf functions.  */\n-      if (for_eh && fde->nothrow)\n+      /* Don't emit EH unwind info for leaf functions that don't need it.  */\n+      if (for_eh && fde->nothrow && ! fde->uses_eh_lsda)\n \tcontinue;\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, FDE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);\n-#ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-      ASM_GENERATE_INTERNAL_LABEL (ld, FDE_LENGTH_LABEL, for_eh + i * 2);\n-      dw2_asm_output_offset (for_eh ? 4 : DWARF_OFFSET_SIZE, ld, \"FDE Length\");\n-#else\n       dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n \t\t\t    \"FDE Length\");\n-#endif\n       ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n       /* ??? This always emits a 4 byte offset when for_eh is true, but it\n@@ -1821,6 +1820,21 @@ output_call_frame_info (for_eh)\n       dw2_asm_output_delta (DWARF2_ADDR_SIZE, fde->dw_fde_end,\n \t\t\t    fde->dw_fde_begin, \"FDE address range\");\n \n+      if (augmentation[0])\n+\t{\n+\t  dw2_asm_output_data_uleb128 (DWARF2_ADDR_SIZE, \"Augmentation size\");\n+\n+\t  if (fde->uses_eh_lsda)\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\", fde->funcdef_number);\n+\t      dw2_asm_output_offset (DWARF2_ADDR_SIZE, l1,\n+\t\t\t\t     \"Language Specific Data Area\");\n+\t    }\n+\t  else\n+\t    dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n+\t\t\t\t \"Language Specific Data Area (none)\");\n+\t}\n+\n       /* Loop through the Call Frame Instructions associated with\n \t this FDE.  */\n       fde->dw_fde_current_label = fde->dw_fde_begin;\n@@ -1830,12 +1844,6 @@ output_call_frame_info (for_eh)\n       /* Pad the FDE out to an address sized boundary.  */\n       ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DWARF2_ADDR_SIZE));\n       ASM_OUTPUT_LABEL (asm_out_file, l2);\n-#ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-      ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL (asm_out_file, ld, l2, l1);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s FDE Length Symbol\", ASM_COMMENT_START);\n-      fputc ('\\n', asm_out_file);\n-#endif\n     }\n \n #ifndef EH_FRAME_SECTION\n@@ -1888,7 +1896,9 @@ dwarf2out_begin_prologue ()\n   fde->dw_fde_current_label = NULL;\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n+  fde->funcdef_number = current_funcdef_number;\n   fde->nothrow = current_function_nothrow;\n+  fde->uses_eh_lsda = cfun->uses_eh_lsda;\n \n   args_size = old_args_size = 0;\n }"}, {"sha": "1f42626a066e6fd452b97c4f418fa40a7f4c5dd8", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -41,3 +41,5 @@ extern void debug_dwarf_die\t\tPARAMS ((struct die_struct *));\n extern void dwarf2out_set_demangle_name_func PARAMS ((const char *(*) (const char *)));\n extern void dwarf2out_abstract_function PARAMS ((tree));\n extern void dwarf2out_add_library_unit_info PARAMS ((const char *, const char *));\n+\n+extern unsigned current_funcdef_number;"}, {"sha": "dffe682a05b11593f3bc32ee1e63b416b061c35b", "filename": "gcc/eh-common.h", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1c98ea459813570b4588427030daa03958fda6/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1c98ea459813570b4588427030daa03958fda6/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=ce1c98ea459813570b4588427030daa03958fda6", "patch": "@@ -1,162 +0,0 @@\n-/* EH stuff\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n-\n-\n-/* This file contains the structures required for the language\n-   independent exception handling model. Both the static compiler and\n-   the runtime library share this file. */\n-\n-/* The runtime flag flag_new_exceptions is used to determine whether the \n-   compiler supports the new runtime typechecking mechanism or not. Under\n-   the new model, runtime info is contained in the exception table, and\n-   the __throw() library routine determines which handler to call based\n-   on the results of a call to a matching function provided by the expcetion\n-   thrower.  Otherwise the old scheme of calling any handler which matches\n-   an exception range is used, and the handler is responsible for all\n-   checking of runtime conditions. If the handler wasn't suppose to\n-   get the exception, it performs a re-throw. */\n-\n-\n-/* The handler_label field MUST be the first field in this structure. The \n-   __throw()  library routine expects uses __eh_stub() from except.c, which\n-   simply dereferences the context pointer to get the handler.\n-   The routine get_dynamic_handler_chain() also has a dependancy on\n-   the location of 'dynamic_handler_chain'. If its location is changed, \n-   that routine must be modified as well. */\n-#ifndef EH_ALLOC_SIZE\n-/* 192 bytes means the entire eh_context plus malloc overhead fits in 256\n-   bytes (assuming 8 byte pointers). 192 bytes gives an eh_info and object\n-   size limit of 96 bytes. This should be sufficient for throwing bad_alloc. */\n-#define EH_ALLOC_SIZE 192\n-#endif\n-#ifndef EH_ALLOC_ALIGN\n-/* We can't use BIGGEST_ALIGNMENT, because on some systems, that expands to\n-   a check on a compile time switch like\n-   'target_flags & MASK_ALIGN_DOUBLE ? 64 : 32'. There's no macro for\n-   'largest alignment for any code this compiler can build for', which is\n-   really what is needed. */\n-#define EH_ALLOC_ALIGN 16\n-#endif\n-\n-struct eh_context\n-{\n-  void *handler_label;\n-  void **dynamic_handler_chain;\n-  /* This is language dependent part of the eh context. */\n-  void *info;\n-  /* This is used to remember where we threw for re-throws */\n-  void *table_index;  /* address of exception table entry to rethrow from */\n-  /* emergency fallback space, if malloc fails during handling */\n-  char alloc_buffer[EH_ALLOC_SIZE]\n-      __attribute__((__aligned__(EH_ALLOC_ALIGN)));\n-  unsigned alloc_mask;\n-};\n-\n-#ifndef EH_TABLE_LOOKUP\n-\n-typedef struct old_exception_table \n-{\n-  void *start_region;\n-  void *end_region;\n-  void *exception_handler;\n-} old_exception_table;\n-\n-typedef struct exception_table \n-{\n-  void *start_region;\n-  void *end_region;\n-  void *exception_handler;\n-  void *match_info;              /* runtime type info */\n-} exception_table;\n-\n-\n-/* The language identifying portion of an exception table */\n-\n-typedef struct exception_lang_info \n-{\n-  short language;\n-  short version;  \n-} exception_lang_info;\n-\n-/* This value in the first field of the exception descriptor \n-   identifies the descriptor as the new model format. This value would never\n-   be present in this location under the old model */\n-\n-#define NEW_EH_RUNTIME  ((void *) -2)\n-\n-/* Each function has an exception_descriptor which contains the\n-   language info, and a table of exception ranges and handlers */\n-\n-typedef struct exception_descriptor \n-{\n-  void *runtime_id_field;    \n-  exception_lang_info lang;\n-  exception_table table[1];\n-} exception_descriptor;\n-\n-struct __eh_info; /* forward declaration */\n-\n-/* A pointer to a matching function is initialized at runtime by the \n-   specific language if run-time exceptions are supported. \n-   The function takes 3 parameters\n-    1 - runtime exception that has been thrown info. (__eh_info *)\n-    2 - Match info pointer from the region being considered (void *)\n-    3 - exception table region is in (exception descriptor *)\n-*/\n-\n-typedef void * (*__eh_matcher)\tPARAMS ((struct __eh_info *, void *,\n-\t\t\t\t\t struct exception_descriptor *));\n-\n-/* This value is to be checked as a 'match all' case in the runtime field. */\n-\n-#define CATCH_ALL_TYPE   ((void *) -1)\n-\n-/* This is the runtime exception information. This forms the minimum required\n-   information for an exception info pointer in an eh_context structure. */\n-\n-\n-typedef struct __eh_info \n-{\n-  __eh_matcher match_function;\n-  short language;\n-  short version;\n-} __eh_info;\n-\n-/* Convienient language codes for ID the originating language. Similar\n-   to the codes in dwarf2.h. */\n-\n-enum exception_source_language\n-  {\n-    EH_LANG_C89 = 0x0001,\n-    EH_LANG_C = 0x0002,\n-    EH_LANG_Ada83 = 0x0003,\n-    EH_LANG_C_plus_plus = 0x0004,\n-    EH_LANG_Cobol74 = 0x0005,\n-    EH_LANG_Cobol85 = 0x0006,\n-    EH_LANG_Fortran77 = 0x0007,\n-    EH_LANG_Fortran90 = 0x0008,\n-    EH_LANG_Pascal83 = 0x0009,\n-    EH_LANG_Modula2 = 0x000a,\n-    EH_LANG_Java = 0x000b,\n-    EH_LANG_Mips_Assembler = 0x8001\n-  };\n-\n-#endif  /* EH_TABLE_LOOKUP */\n-\n-"}, {"sha": "ec13ed044378b99ac57036ce8b65af3f79191dfd", "filename": "gcc/except.c", "status": "modified", "additions": 2956, "deletions": 2753, "changes": 5709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6"}, {"sha": "d1688a22cb9ad1ce515a0cb8c4e59a66fe4fe640", "filename": "gcc/except.h", "status": "modified", "additions": 112, "deletions": 441, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -19,516 +19,187 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#if !defined(NULL_RTX) && !defined(rtx)\n-typedef struct rtx_def *_except_rtx;\n-#define rtx _except_rtx\n-#endif\n-\n-#ifdef TREE_CODE\n-\n-/* A stack of labels. CHAIN points to the next entry in the stack.  */\n-\n-struct label_node {\n-  union {\n-    rtx rlabel;\n-    tree tlabel;\n-  } u;\n-  struct label_node *chain;\n-};\n-\n-/* An eh_entry is used to describe one exception handling region.\n-\n-   OUTER_CONTEXT is the label used for rethrowing into the outer context.\n-\n-   EXCEPTION_HANDLER_LABEL is the label corresponding to the handler\n-   for this region.\n-\n-   LABEL_USED indicates whether a CATCH block has already used this\n-   label or not. New ones are needed for additional catch blocks if\n-   it has.\n \n-   FALSE_LABEL is used when either setjmp/longjmp exceptions are in\n-   use, or old style table exceptions. It contains the label for \n-   branching to the next runtime type check as handlers are processed.\n-\n-   FINALIZATION is the tree codes for the handler, or is NULL_TREE if\n-   one hasn't been generated yet, or is integer_zero_node to mark the\n-   end of a group of try blocks.  */\n-\n-struct eh_entry {\n-  rtx outer_context;\n-  rtx exception_handler_label;\n-  tree finalization;\n-  int label_used;\n-  rtx false_label;\n-  rtx rethrow_label;\n-  /* If non-zero, this entry is for a handler created when we left an\n-     exception-region via goto.  */\n-  unsigned goto_entry_p : 1;\n-};\n-#else\n-struct label_node;\n-struct eh_entry;\n+#ifndef TREE_CODE\n+union tree_node;\n+#define tree union tree_node *\n #endif\n \n-/* A list of EH_ENTRYs. ENTRY is the entry; CHAIN points to the next\n-   entry in the list, or is NULL if this is the last entry.  */\n-\n-struct eh_node {\n-  struct eh_entry *entry;\n-  struct eh_node *chain;\n-};\n-\n-/* A stack of EH_ENTRYs. TOP is the topmost entry on the stack. TOP is\n-   NULL if the stack is empty.  */\n-\n-struct eh_stack {\n-  struct eh_node *top;\n-};\n-\n-/* A queue of EH_ENTRYs. HEAD is the front of the queue; TAIL is the\n-   end (the latest entry). HEAD and TAIL are NULL if the queue is\n-   empty.  */\n-\n-struct eh_queue {\n-  struct eh_node *head;\n-  struct eh_node *tail;\n-  struct eh_queue *next;\n-};\n-\n-/* Used to save exception handling status for each function.  */\n-struct eh_status\n-{\n-  /* A stack used for keeping track of the currently active exception\n-     handling region.  As each exception region is started, an entry\n-     describing the region is pushed onto this stack.  The current\n-     region can be found by looking at the top of the stack, and as we\n-     exit regions, the corresponding entries are popped. \n-\n-     Entries cannot overlap; they can be nested. So there is only one\n-     entry at most that corresponds to the current instruction, and that\n-     is the entry on the top of the stack.  */\n-  struct eh_stack x_ehstack;\n-  /* This stack is used to represent what the current eh region is\n-     for the catch blocks beings processed */\n-  struct eh_stack x_catchstack;\n-  /* A queue used for tracking which exception regions have closed.\n-     As we exit a region, we enqueue a new entry. The entries are then\n-     dequeued during expand_leftover_cleanups and\n-     expand_start_all_catch.  */\n-  struct eh_queue *x_ehqueue;\n-  /* Insns for all of the exception handlers for the current function.\n-     They are currently emitted by the frontend code.  */\n-  rtx x_catch_clauses;\n-  /* End of exception handler insn sequence.  */\n-  rtx x_catch_clauses_last;\n-  /* A random data area for the front end's own use.  */\n-  struct label_node *x_false_label_stack;\n-  /* Keeps track of the label to resume to should one want to resume\n-     normal control flow out of a handler (instead of, say, returning to\n-     the caller of the current function or exiting the program).  */\n-  struct label_node *x_caught_return_label_stack;\n-  /* A stack (TREE_LIST) of lists of handlers.  The TREE_VALUE of each\n-     node is itself a TREE_CHAINed list of handlers for regions that\n-     are not yet closed. The TREE_VALUE of each entry contains the\n-     handler for the corresponding entry on the ehstack.  */\n-  union tree_node *x_protect_list;\n-  /* The EH context.  Nonzero if the function has already\n-     fetched a pointer to the EH context  for exception handling.  */\n-  rtx ehc;\n-  /* The label generated by expand_builtin_eh_return.  */\n-  rtx x_eh_return_stub_label;\n-};\n-\n-#define ehstack (cfun->eh->x_ehstack)\n-#define catchstack (cfun->eh->x_catchstack)\n-#define ehqueue (cfun->eh->x_ehqueue)\n-#define catch_clauses (cfun->eh->x_catch_clauses)\n-#define catch_clauses_last (cfun->eh->x_catch_clauses_last)\n-#define false_label_stack (cfun->eh->x_false_label_stack)\n-#define caught_return_label_stack (cfun->eh->x_caught_return_label_stack)\n-#define protect_list (cfun->eh->x_protect_list)\n-#define current_function_ehc (cfun->eh->ehc)\n-#define eh_return_stub_label (cfun->eh->x_eh_return_stub_label)\n-\n-#ifdef TREE_CODE\n-/* Start an exception handling region.  All instructions emitted after\n-   this point are considered to be part of the region until\n-   expand_eh_region_end () is invoked.  */\n-\n-extern void expand_eh_region_start\t\tPARAMS ((void));\n-\n-/* Just like expand_eh_region_start, except if a cleanup action is\n-   entered on the cleanup chain, the TREE_PURPOSE of the element put\n-   on the chain is DECL.  DECL should be the associated VAR_DECL, if\n-   any, otherwise it should be NULL_TREE.  */\n-\n-extern void expand_eh_region_start_for_decl\tPARAMS ((tree));\n-\n-/* Start an exception handling region for the given cleanup action.\n-   All instructions emitted after this point are considered to be part\n-   of the region until expand_eh_region_end () is invoked.  CLEANUP is\n-   the cleanup action to perform.  The return value is true if the\n-   exception region was optimized away.  If that case,\n-   expand_eh_region_end does not need to be called for this cleanup,\n-   nor should it be.\n-\n-   This routine notices one particular common case in C++ code\n-   generation, and optimizes it so as to not need the exception\n-   region.  */\n-\n-extern int expand_eh_region_start_tree\t\tPARAMS ((tree, tree));\n-\n-/* End an exception handling region.  The information about the region\n-   is found on the top of ehstack.\n-\n-   HANDLER is either the cleanup for the exception region, or if we're\n-   marking the end of a try block, HANDLER is integer_zero_node.\n-\n-   HANDLER will be transformed to rtl when expand_leftover_cleanups ()\n-   is invoked.  */\n-\n-extern void expand_eh_region_end\t\tPARAMS ((tree));\n-\n-/* Push RLABEL or TLABEL onto LABELSTACK. Only one of RLABEL or TLABEL\n-   should be set; the other must be NULL.  */\n-\n-extern void push_label_entry\tPARAMS ((struct label_node **labelstack,\n-\t\t\t\t\t rtx rlabel, tree tlabel));\n-\n-/* Pop the topmost entry from LABELSTACK and return its value as an\n-   rtx node. If LABELSTACK is empty, return NULL.  */\n-\n-extern rtx pop_label_entry\tPARAMS ((struct label_node **labelstack));\n-\n-/* Return the topmost entry of LABELSTACK as a tree node, or return\n-   NULL_TREE if LABELSTACK is empty.  */\n-\n-extern tree top_label_entry\tPARAMS ((struct label_node **labelstack));\n-\n+#ifndef RTX_CODE\n+struct rtx_def;\n+#define rtx struct rtx_def *\n #endif\n \n-/* Test: is exception handling turned on? */\n-\n-extern int doing_eh\t\t\t        PARAMS ((int));\n-\n-/* Toplevel initialization for EH.  */\n-\n-void set_exception_lang_code                    PARAMS ((int));\n-void set_exception_version_code                 PARAMS ((int));\n-\n-/* A list of handlers asocciated with an exception region. HANDLER_LABEL\n-   is the the label that control should be transfered to if the data\n-   in TYPE_INFO matches an exception. a value of NULL_TREE for TYPE_INFO\n-   means This is a cleanup, and must always be called. A value of\n-   CATCH_ALL_TYPE works like a cleanup, but a call to the runtime matcher\n-   is still performed to avoid being caught by a different language\n-   exception. NEXT is a pointer to the next handler for this region. \n-   NULL means there are no more. */\n-\n-typedef struct handler_info \n-{\n-  rtx handler_label;\n-  int handler_number;\n-  void *type_info;\n-  struct handler_info *next;\n-} handler_info;\n-\n-\n-/* Add new handler information to an exception range. The  first parameter\n-   specifies the range number (returned from new_eh_entry()). The second\n-   parameter specifies the handler.  By default the handler is inserted at\n-   the end of the list. A handler list may contain only ONE NULL_TREE\n-   typeinfo entry. Regardless where it is positioned, a NULL_TREE entry\n-   is always output as the LAST handler in the exception table for a region. */\n-\n-void add_new_handler\t\t\tPARAMS ((int, struct handler_info *));\n-\n-/* Remove a handler label. The handler label is being deleted, so all\n-   regions which reference this handler should have it removed from their\n-   list of possible handlers. Any region which has the final handler\n-   removed can be deleted. */\n-\n-void remove_handler\t\t\tPARAMS ((rtx));\n-\n-/* Create a new handler structure initialized with the handler label and\n-   typeinfo fields passed in. */\n-\n-struct handler_info *get_new_handler            PARAMS ((rtx, void *));\n-\n-/* Make a duplicate of an exception region by copying all the handlers\n-   for an exception region. Return the new handler index. */\n-\n-int duplicate_eh_handlers\t\tPARAMS ((int, int, rtx (*)(rtx)));\n-\n-/* map symbol refs for rethrow */\n-\n-rtx rethrow_symbol_map                          PARAMS ((rtx, rtx (*)(rtx)));\n-\n-/* Is the rethrow label for a region used? */\n-\n-int rethrow_used                                PARAMS ((int));\n-\n-/* Update the rethrow references to reflect rethrows which have been\n-   optimized away.  */\n-\n-void update_rethrow_references\t\t\tPARAMS ((void));\n-\n-/* Get a pointer to the first handler in an exception region's list. */\n-\n-struct handler_info *get_first_handler          PARAMS ((int));\n-\n-/* Find all the runtime handlers type matches currently referenced */\n-\n-int find_all_handler_type_matches               PARAMS ((void ***));\n-\n-/* The eh_nesting_info structure is used to find a list of valid handlers\n-   for any arbitrary exception region.  When init_eh_nesting_info is called,\n-   the information is all pre-calculated and entered in this structure.\n-   REGION_INDEX is a vector over all possible region numbers.  Since the\n-   number of regions is typically much smaller than the range of block\n-   numbers, this is a sparse vector and the other data structures are \n-   represented as dense vectors.  Indexed with an exception region number, this\n-   returns the index to use in the other data structures to retreive the\n-   correct information.\n-   HANDLERS is an array of vectors which point to handler_info structures.\n-   when indexed, it gives the list of all possible handlers which can \n-   be reached by a throw from this exception region.\n-   NUM_HANDLERS is the equivilent array indicating how many handler\n-   pointers there are in the HANDLERS vector.\n-   OUTER_INDEX indicates which index represents the information for the\n-   outer block.  0 indicates there is no outer context.\n-   REGION_COUNT is the number of regions.  */\n-\n-typedef struct eh_nesting \n-{\n-  int *region_index;\n-  handler_info ***handlers;\n-  int *num_handlers;\n-  int *outer_index;\n-  int region_count;\n-} eh_nesting_info;\n-\n-/* Initialize the eh_nesting_info structure.  */\n-\n-eh_nesting_info *init_eh_nesting_info \t\tPARAMS ((void));\n-\n-/* Get a list of handlers reachable from a an exception region/insn.  */\n-\n-int reachable_handlers \t\t\tPARAMS ((int, eh_nesting_info *, rtx, \n-\t\t\t\t\t\t handler_info ***handlers));\n-\n-/* Free the eh_nesting_info structure.  */\n-\n-void free_eh_nesting_info \t\t\tPARAMS ((eh_nesting_info *));\n-\n-extern void init_eh\t\t\t\tPARAMS ((void));\n-\n-/* Initialization for the per-function EH data.  */\n-\n-extern void init_eh_for_function\t\tPARAMS ((void));\n-\n-/* Generate an exception label. Use instead of gen_label_rtx */\n-\n-extern rtx gen_exception_label                  PARAMS ((void));\n-\n-/* Adds an EH table entry for EH entry number N. Called from\n-   final_scan_insn for NOTE_INSN_EH_REGION_BEG.  */\n-\n-extern void add_eh_table_entry\t\t\tPARAMS ((int n));\n-\n-/* Start a catch clause, triggered by runtime value paramter. */\n-\n-#ifdef TREE_CODE\n-extern void start_catch_handler                 PARAMS ((tree));\n+#ifndef _VARRAY_H_\n+struct varray_head_tag;\n+#define varray_type struct varray_head_tag *\n #endif\n \n-/* End an individual catch clause. */\n-\n-extern void end_catch_handler                   PARAMS ((void));\n-\n-/* Returns a non-zero value if we need to output an exception table.  */\n-\n-extern int exception_table_p\t\t\tPARAMS ((void));\n-\n-/* Outputs the exception table if we have one.  */\n \n-extern void output_exception_table\t\tPARAMS ((void));\n-extern void output_exception_table_data\t\tPARAMS ((void));\n+/* Per-function EH data.  Used only in except.c, but GC and others\n+   manipulate pointers to the opaque type.  */\n+struct eh_status;\n \n-/* Free the exception table.  */\n+/* Internal structure describing a region.  */\n+struct eh_region;\n \n-extern void free_exception_table\t\tPARAMS((void));\n+/* Test: is exception handling turned on?  */\n+extern int doing_eh\t\t\t        PARAMS ((int));\n \n-/* Used by the ia64 unwind format to output data for an individual \n-   function.  */\n+/* Start an exception handling region.  All instructions emitted after\n+   this point are considered to be part of the region until an\n+   expand_eh_region_end variant is invoked.  */\n+extern void expand_eh_region_start\t\tPARAMS ((void));\n \n-extern void output_function_exception_table\tPARAMS((void));\n+/* End an exception handling region for a cleanup.  HANDLER is an\n+   expression to expand for the cleanup.  */\n+extern void expand_eh_region_end_cleanup\tPARAMS ((tree));\n \n-/* Given a return address in ADDR, determine the address we should use\n-   to find the corresponding EH region.  */\n+/* End an exception handling region for a try block, and prepares\n+   for subsequent calls to expand_start_catch.  */\n+extern void expand_start_all_catch\t\tPARAMS ((void));\n \n-extern rtx eh_outer_context\t\t\tPARAMS ((rtx addr));\n+/* Begin a catch clause.  TYPE is an object to be matched by the\n+   runtime, or null if this is a catch-all clause.  */\n+extern void expand_start_catch\t\t\tPARAMS ((tree));\n \n-/* Called at the start of a block of try statements for which there is\n-   a supplied catch handler.  */\n+/* End a catch clause.  Control will resume after the try/catch block.  */\n+extern void expand_end_catch\t\t\tPARAMS ((void));\n \n-extern void expand_start_try_stmts \t\tPARAMS ((void));\n+/* End a sequence of catch handlers for a try block.  */\n+extern void expand_end_all_catch\t\tPARAMS ((void));\n \n-/* Called at the start of a block of catch statements. It terminates the\n-   previous set of try statements.  */\n+/* End an exception region for an exception type filter.  ALLOWED is a\n+   TREE_LIST of TREE_VALUE objects to be matched by the runtime.\n+   FAILURE is a function to invoke if a mismatch ocurrs.  */\n+extern void expand_eh_region_end_allowed\tPARAMS ((tree, tree));\n \n-extern void expand_start_all_catch\t\tPARAMS ((void));\n+/* End an exception region for a must-not-throw filter.  FAILURE is a\n+   function to invoke if an uncaught exception propagates this far.  */\n+extern void expand_eh_region_end_must_not_throw\tPARAMS ((tree));\n \n-/* Called at the end of a block of catch statements.  */\n+/* End an exception region for a throw.  No handling goes on here,\n+   but it's the easiest way for the front-end to indicate what type\n+   is being thrown.  */\n+extern void expand_eh_region_end_throw\t\tPARAMS ((tree));\n \n-extern void expand_end_all_catch\t\tPARAMS ((void));\n+/* End a fixup region.  Within this region the cleanups for the immediately\n+   enclosing region are _not_ run.  This is used for goto cleanup to avoid\n+   destroying an object twice.  */\n+extern void expand_eh_region_end_fixup\t\tPARAMS ((tree));\n \n /* Begin a region that will contain entries created with\n    add_partial_entry.  */\n-\n extern void begin_protect_partials              PARAMS ((void));\n \n-#ifdef TREE_CODE\n /* Create a new exception region and add the handler for the region\n-   onto a list. These regions will be ended (and their handlers\n-   emitted) when end_protect_partials is invoked.  */\n-\n-extern void add_partial_entry\t\t\tPARAMS ((tree handler));\n-#endif\n+   onto a list. These regions will be ended (and their handlers emitted)\n+   when end_protect_partials is invoked.  */\n+extern void add_partial_entry\t\t\tPARAMS ((tree));\n \n /* End all of the pending exception regions that have handlers added with\n-   push_protect_entry ().  */\n-\n+   add_partial_entry.  */\n extern void end_protect_partials\t\tPARAMS ((void));\n \n-/* An internal throw.  */\n-\n-extern void expand_internal_throw\t\tPARAMS ((void));\n-\n-/* Called from expand_exception_blocks and expand_end_catch_block to\n-   expand and pending handlers.  */\n-\n-extern void expand_leftover_cleanups\t\tPARAMS ((void));\n-\n-/* If necessary, emit insns to get EH context for the current\n-   function. */\n-\n-extern void emit_eh_context\t\t\tPARAMS ((void));\n-\n-/* Builds a list of handler labels and puts them in the global\n-   variable exception_handler_labels.  */\n-\n-extern void find_exception_handler_labels\tPARAMS ((void));\n-\n-/* Determine if an arbitrary label is an exception label */\n-\n-extern int is_exception_handler_label           PARAMS ((int));\n-\n-/* Performs sanity checking on the check_exception_handler_labels\n-   list.  */\n-\n-extern void check_exception_handler_labels\tPARAMS ((void));\n-\n-/* Keeps track of the label used as the context of a throw to rethrow an\n-   exception to the outer exception region.  */\n-\n-extern struct label_node *outer_context_label_stack;\n-\n-/* A list of labels used for exception handlers. It is created by\n-   find_exception_handler_labels for the optimization passes.  */\n \n+/* A list of labels used for exception handlers.  */\n extern rtx exception_handler_labels;\n \n /* Determine if the given INSN can throw an exception.  */\n-\n-extern int can_throw_internal                   PARAMS ((rtx));\n+extern bool can_throw_internal\t\t\tPARAMS ((rtx));\n+extern bool can_throw_external\t\t\tPARAMS ((rtx));\n \n /* Return nonzero if nothing in this function can throw.  */\n+extern bool nothrow_function_p\t\t\tPARAMS ((void));\n \n-extern int nothrow_function_p\t\t\tPARAMS ((void));\n+/* After initial rtl generation, call back to finish generating\n+   exception support code.  */\n+extern void finish_eh_generation\t\tPARAMS ((void));\n \n-/* Performs optimizations for exception handling, such as removing\n-   unnecessary exception regions. Invoked from jump_optimize ().  */\n+extern void init_eh\t\t\t\tPARAMS ((void));\n+extern void init_eh_for_function\t\tPARAMS ((void));\n \n-extern void exception_optimize\t\t\tPARAMS ((void));\n+extern rtx reachable_handlers\t\t\tPARAMS ((rtx));\n+extern void maybe_remove_eh_handler\t\tPARAMS ((rtx));\n \n-/* Return EH context (and set it up once per fn).  */\n-extern rtx get_eh_context\t\t\tPARAMS ((void));\n+extern void convert_from_eh_region_ranges\tPARAMS ((void));\n+extern void convert_to_eh_region_ranges\t\tPARAMS ((void));\n+extern void find_exception_handler_labels\tPARAMS ((void));\n+extern void output_function_exception_table\tPARAMS ((void));\n \n-/* Get the dynamic handler chain.  */\n-extern rtx get_dynamic_handler_chain\t\tPARAMS ((void));\n+extern void expand_builtin_unwind_init\t\tPARAMS ((void));\n+extern rtx expand_builtin_eh_return_data_regno\tPARAMS ((tree));\n+extern rtx expand_builtin_extract_return_addr\tPARAMS ((tree));\n+extern rtx expand_builtin_frob_return_addr\tPARAMS ((tree));\n+extern void expand_builtin_eh_return\t\tPARAMS ((tree, tree));\n+extern void expand_eh_return\t\t\tPARAMS ((void));\n \n-/* Get the dynamic cleanup chain.  */\n-extern rtx get_dynamic_cleanup_chain\t\tPARAMS ((void));\n+extern rtx get_exception_pointer\t\tPARAMS ((void));\n \n-/* Throw an exception.  */\n+struct function;\n+struct inline_remap;\n+extern int duplicate_eh_regions\t\tPARAMS ((struct function *,\n+\t\t\t\t\t\t struct inline_remap *));\n \n-extern void emit_throw\t\t\t\tPARAMS ((void));\n+extern void sjlj_emit_function_exit_after\tPARAMS ((rtx));\n \n-/* Save away the current ehqueue.  */\n-extern void push_ehqueue                        PARAMS ((void));\n \n-/* Restore a previously pushed ehqueue.  */\n-extern void pop_ehqueue                         PARAMS ((void));\n+/* Nonzero to protect cleanup actions with must-not-throw regions.  */\n+extern tree protect_cleanup_actions;\n \n-/* One to protect cleanup actions with a handler that calls\n-   __terminate, zero otherwise.  */\n+/* Return true if type A catches type B.  */\n+int (*lang_eh_type_covers) PARAMS ((tree a, tree b));\n \n-extern int protect_cleanup_actions_with_terminate;\n+/* Map a type to a runtime object to match type.  */\n+tree (*lang_eh_runtime_type) PARAMS ((tree));\n \n-#ifdef TREE_CODE\n-extern tree protect_with_terminate\t\tPARAMS ((tree));\n+#ifndef TREE_CODE\n+#undef tree\n #endif\n \n-extern void expand_fixup_region_start\tPARAMS ((void));\n-#ifdef TREE_CODE\n-extern void expand_fixup_region_end\tPARAMS ((tree));\n+#ifndef RTX_CODE\n+#undef rtx\n #endif\n \n-/* Various hooks for the DWARF 2 __throw routine.  */\n-\n-void expand_builtin_unwind_init\t\tPARAMS ((void));\n-rtx expand_builtin_dwarf_fp_regnum\tPARAMS ((void));\n-#ifdef TREE_CODE\n-rtx expand_builtin_frob_return_addr\tPARAMS ((tree));\n-rtx expand_builtin_extract_return_addr\tPARAMS ((tree));\n-void expand_builtin_init_dwarf_reg_sizes\tPARAMS ((tree));\n-void expand_builtin_eh_return\t\tPARAMS ((tree, tree, tree));\n+#ifndef _VARRAY_H_\n+#undef varray_type\n #endif\n-void expand_eh_return\t\t\tPARAMS ((void));\n-\n-\n-/* Checking whether 2 instructions are within the same exception region. */\n \n-int in_same_eh_region                   PARAMS ((rtx, rtx));\n-void free_insn_eh_region                PARAMS ((void));\n-void init_insn_eh_region                PARAMS ((rtx, int));\n-\n-#ifdef rtx\n-#undef rtx\n-#endif\n \n /* Just because the user configured --with-sjlj-exceptions=no doesn't\n    mean that we can use call frame exceptions.  Detect that the target\n    has appropriate support.  */\n \n+#if !defined (EH_RETURN_DATA_REGNO)\t\t\\\n+    || !defined(EH_RETURN_STACKADJ_RTX)\t\t\\\n+    || ! (defined(EH_RETURN_HANDLER_RTX)\t\\\n+\t  || defined(HAVE_eh_return))\t\t\\\n+    || ! (defined(DWARF2_UNWIND_INFO)\t\t\\\n+\t  || defined(IA64_UNWIND_INFO))\n+#define MUST_USE_SJLJ_EXCEPTIONS\t1\n+#else\n+#define MUST_USE_SJLJ_EXCEPTIONS\t0\n+#endif\n+\n #ifdef CONFIG_SJLJ_EXCEPTIONS\n # if CONFIG_SJLJ_EXCEPTIONS == 1\n #  define USING_SJLJ_EXCEPTIONS\t\t1\n # endif\n # if CONFIG_SJLJ_EXCEPTIONS == 0\n #  define USING_SJLJ_EXCEPTIONS\t\t0\n+#  ifndef EH_RETURN_DATA_REGNO\n+    #error \"EH_RETURN_DATA_REGNO required\"\n+#  endif\n+#  ifndef EH_RETURN_STACKADJ_RTX\n+    #error \"EH_RETURN_STACKADJ_RTX required\"\n+#  endif\n+#  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)\n+    #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n+#  endif\n #  if !defined(DWARF2_UNWIND_INFO) && !defined(IA64_UNWIND_INFO)\n     #error \"{DWARF2,IA64}_UNWIND_INFO required\"\n #  endif\n # endif\n #else\n-# ifdef IA64_UNWIND_INFO\n-#  define USING_SJLJ_EXCEPTIONS\t\t(!IA64_UNWIND_INFO)\n-# else\n-#  ifdef DWARF2_UNWIND_INFO\n-#   define USING_SJLJ_EXCEPTIONS\t(!DWARF2_UNWIND_INFO)\n-#  endif\n-# endif\n+# define USING_SJLJ_EXCEPTIONS\t\tMUST_USE_SJLJ_EXCEPTIONS\n #endif"}, {"sha": "c2661722cb3a27ed8787aa10da2cf8f6ccc88bee", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -8741,7 +8741,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n \n-\texpand_eh_region_end (handler);\n+\texpand_eh_region_end_cleanup (handler);\n \n \treturn op0;\n       }\n@@ -8788,23 +8788,12 @@ expand_expr (exp, target, tmode, modifier)\n \treturn const0_rtx;\n       }\n \n-    case POPDCC_EXPR:\n-      {\n-\trtx dcc = get_dynamic_cleanup_chain ();\n-\temit_move_insn (dcc, validize_mem (gen_rtx_MEM (Pmode, dcc)));\n-\treturn const0_rtx;\n-      }\n-\n-    case POPDHC_EXPR:\n-      {\n-\trtx dhc = get_dynamic_handler_chain ();\n-\temit_move_insn (dhc, validize_mem (gen_rtx_MEM (Pmode, dhc)));\n-\treturn const0_rtx;\n-      }\n-\n     case VA_ARG_EXPR:\n       return expand_builtin_va_arg (TREE_OPERAND (exp, 0), type);\n \n+    case EXC_PTR_EXPR:\n+      return get_exception_pointer ();\n+\n     default:\n       return (*lang_expand_expr) (exp, original_target, tmode, modifier);\n     }"}, {"sha": "8d883017eb1848a7061e6f353dd784fa48718002", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -495,14 +495,12 @@ enum libfunc_index\n   LTI_memset,\n   LTI_bzero,\n \n-  LTI_throw,\n-  LTI_rethrow,\n-  LTI_sjthrow,\n-  LTI_sjpopnthrow,\n-  LTI_terminate,\n+  LTI_unwind_resume,\n+  LTI_eh_personality,\n   LTI_setjmp,\n   LTI_longjmp,\n-  LTI_eh_rtime_match,\n+  LTI_unwind_sjlj_register,\n+  LTI_unwind_sjlj_unregister,\n \n   LTI_eqhf2,\n   LTI_nehf2,\n@@ -628,14 +626,13 @@ extern rtx libfunc_table[LTI_MAX];\n #define memset_libfunc\t(libfunc_table[LTI_memset])\n #define bzero_libfunc\t(libfunc_table[LTI_bzero])\n \n-#define throw_libfunc\t(libfunc_table[LTI_throw])\n-#define rethrow_libfunc\t(libfunc_table[LTI_rethrow])\n-#define sjthrow_libfunc\t(libfunc_table[LTI_sjthrow])\n-#define sjpopnthrow_libfunc\t(libfunc_table[LTI_sjpopnthrow])\n-#define terminate_libfunc\t(libfunc_table[LTI_terminate])\n+#define unwind_resume_libfunc\t(libfunc_table[LTI_unwind_resume])\n+#define eh_personality_libfunc\t(libfunc_table[LTI_eh_personality])\n #define setjmp_libfunc\t(libfunc_table[LTI_setjmp])\n #define longjmp_libfunc\t(libfunc_table[LTI_longjmp])\n-#define eh_rtime_match_libfunc\t(libfunc_table[LTI_eh_rtime_match])\n+#define unwind_sjlj_register_libfunc (libfunc_table[LTI_unwind_sjlj_register])\n+#define unwind_sjlj_unregister_libfunc \\\n+  (libfunc_table[LTI_unwind_sjlj_unregister])\n \n #define eqhf2_libfunc\t(libfunc_table[LTI_eqhf2])\n #define nehf2_libfunc\t(libfunc_table[LTI_nehf2])"}, {"sha": "fef6641a3a63d194f04d5b4a38ab0d2d1e12d9e2", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1945,8 +1945,6 @@ final (first, file, optimize, prescan)\n   last_ignored_compare = 0;\n   new_block = 1;\n \n-  check_exception_handler_labels ();\n-\n   /* Make a map indicating which line numbers appear in this function.\n      When producing SDB debugging info, delete troublesome line number\n      notes from inlined functions in other files as well as duplicate\n@@ -2003,10 +2001,6 @@ final (first, file, optimize, prescan)\n #endif\n     }\n \n-  /* Initialize insn_eh_region table if eh is being used.  */\n-\n-  init_insn_eh_region (first, max_uid);\n-\n   init_recog ();\n \n   CC_STATUS_INIT;\n@@ -2040,7 +2034,6 @@ final (first, file, optimize, prescan)\n   if (profile_block_flag && new_block)\n     add_bb (file);\n \n-  free_insn_eh_region ();\n   free (line_note_exists);\n   line_note_exists = NULL;\n }\n@@ -2126,24 +2119,13 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  break;\n \n \tcase NOTE_INSN_EH_REGION_BEG:\n-\t  if (! USING_SJLJ_EXCEPTIONS)\n-\t    {\n-\t      ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHB\", NOTE_EH_HANDLER (insn));\n-#ifdef ASM_OUTPUT_EH_REGION_BEG\n-\t      ASM_OUTPUT_EH_REGION_BEG (file, NOTE_EH_HANDLER (insn));\n-#endif\n-\t    }\n+\t  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LEHB\",\n+\t\t\t\t  NOTE_EH_HANDLER (insn));\n \t  break;\n \n \tcase NOTE_INSN_EH_REGION_END:\n-\t  if (! USING_SJLJ_EXCEPTIONS)\n-\t    {\n-\t      ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHE\", NOTE_EH_HANDLER (insn));\n-\t      add_eh_table_entry (NOTE_EH_HANDLER (insn));\n-#ifdef ASM_OUTPUT_EH_REGION_END\n-\t      ASM_OUTPUT_EH_REGION_END (file, NOTE_EH_HANDLER (insn));\n-#endif\n-\t    }\n+\t  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LEHE\",\n+\t\t\t\t  NOTE_EH_HANDLER (insn));\n \t  break;\n \n \tcase NOTE_INSN_PROLOGUE_END:"}, {"sha": "d057bc5e264b4e8dc5f3ac0bdc05d9b8212712a6", "filename": "gcc/flow.c", "status": "modified", "additions": 108, "deletions": 309, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -204,7 +204,6 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* aux */\n     ENTRY_BLOCK,\t\t/* index */\n     0,\t\t\t\t/* loop_depth */\n-    -1, -1,\t\t\t/* eh_beg, eh_end */\n     0\t\t\t\t/* count */\n   },\n   {\n@@ -219,7 +218,6 @@ struct basic_block_def entry_exit_blocks[2]\n     NULL,\t\t\t/* aux */\n     EXIT_BLOCK,\t\t\t/* index */\n     0,\t\t\t\t/* loop_depth */\n-    -1, -1,\t\t\t/* eh_beg, eh_end */\n     0\t\t\t\t/* count */\n   }\n };\n@@ -368,16 +366,12 @@ static void clear_edges\t\t\tPARAMS ((void));\n static void make_edges\t\t\tPARAMS ((rtx));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t rtx, int));\n-static void make_eh_edge\t\tPARAMS ((sbitmap *, eh_nesting_info *,\n-\t\t\t\t\t\t basic_block, rtx, int));\n+static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n static void mark_critical_edges\t\tPARAMS ((void));\n-static void move_stray_eh_region_notes\tPARAMS ((void));\n-static void record_active_eh_regions\tPARAMS ((rtx));\n \n static void commit_one_edge_insertion\tPARAMS ((edge));\n \n static void delete_unreachable_blocks\tPARAMS ((void));\n-static void delete_eh_regions\t\tPARAMS ((void));\n static int can_delete_note_p\t\tPARAMS ((rtx));\n static void expunge_block\t\tPARAMS ((basic_block));\n static int can_delete_label_p\t\tPARAMS ((rtx));\n@@ -537,7 +531,6 @@ find_basic_blocks (f, nregs, file)\n   compute_bb_for_insn (max_uid);\n \n   /* Discover the edges of our cfg.  */\n-  record_active_eh_regions (f);\n   make_edges (label_value_list);\n \n   /* Do very simple cleanup now, for the benefit of code that runs between\n@@ -599,46 +592,45 @@ count_basic_blocks (f)\n   register rtx insn;\n   register RTX_CODE prev_code;\n   register int count = 0;\n-  int eh_region = 0;\n-  int call_had_abnormal_edge = 0;\n+  int saw_abnormal_edge = 0;\n \n   prev_code = JUMP_INSN;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      register RTX_CODE code = GET_CODE (insn);\n+      enum rtx_code code = GET_CODE (insn);\n \n       if (code == CODE_LABEL\n \t  || (GET_RTX_CLASS (code) == 'i'\n \t      && (prev_code == JUMP_INSN\n \t\t  || prev_code == BARRIER\n-\t\t  || (prev_code == CALL_INSN && call_had_abnormal_edge))))\n-\tcount++;\n+\t\t  || saw_abnormal_edge)))\n+\t{\n+\t  saw_abnormal_edge = 0;\n+\t  count++;\n+\t}\n \n-      /* Record whether this call created an edge.  */\n+      /* Record whether this insn created an edge.  */\n       if (code == CALL_INSN)\n \t{\n-\t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t  int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n-\n-\t  call_had_abnormal_edge = 0;\n-\n-\t  /* If there is an EH region or rethrow, we have an edge.  */\n-\t  if ((eh_region && region > 0)\n-\t      || find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n-\t    call_had_abnormal_edge = 1;\n-\t  else if (nonlocal_goto_handler_labels && region >= 0)\n-\t    /* If there is a nonlocal goto label and the specified\n-\t       region number isn't -1, we have an edge. (0 means\n-\t       no throw, but might have a nonlocal goto).  */\n-\t    call_had_abnormal_edge = 1;\n+\t  rtx note;\n+\n+\t  /* If there is a nonlocal goto label and the specified\n+\t     region number isn't -1, we have an edge.  */\n+\t  if (nonlocal_goto_handler_labels\n+\t      && ((note = find_reg_note (insn, REG_EH_REGION, NULL_RTX)) == 0\n+\t\t  || INTVAL (XEXP (note, 0)) >= 0))\n+\t    saw_abnormal_edge = 1;\n+\n+\t  else if (can_throw_internal (insn))\n+\t    saw_abnormal_edge = 1;\n \t}\n+      else if (flag_non_call_exceptions\n+\t       && code == INSN\n+\t       && can_throw_internal (insn))\n+\tsaw_abnormal_edge = 1;\n \n       if (code != NOTE)\n \tprev_code = code;\n-      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n-\t++eh_region;\n-      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n-\t--eh_region;\n     }\n \n   /* The rest of the compiler works a bit smoother when we don't have to\n@@ -672,9 +664,6 @@ find_label_refs (f, lvl)\n \t   Make a special exception for labels followed by an ADDR*VEC,\n \t   as this would be a part of the tablejump setup code.\n \n-\t   Make a special exception for the eh_return_stub_label, which\n-\t   we know isn't part of any otherwise visible control flow.\n-\n \t   Make a special exception to registers loaded with label\n \t   values just before jump insns that use them.  */\n \n@@ -683,9 +672,7 @@ find_label_refs (f, lvl)\n \t    {\n \t      rtx lab = XEXP (note, 0), next;\n \n-\t      if (lab == eh_return_stub_label)\n-\t\t;\n-\t      else if ((next = next_nonnote_insn (lab)) != NULL\n+\t      if ((next = next_nonnote_insn (lab)) != NULL\n \t\t       && GET_CODE (next) == JUMP_INSN\n \t\t       && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t\t\t   || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n@@ -815,7 +802,6 @@ find_basic_blocks_1 (f)\n   register rtx insn, next;\n   int i = 0;\n   rtx bb_note = NULL_RTX;\n-  rtx eh_list = NULL_RTX;\n   rtx lvl = NULL_RTX;\n   rtx trll = NULL_RTX;\n   rtx head = NULL_RTX;\n@@ -839,22 +825,11 @@ find_basic_blocks_1 (f)\n \t  {\n \t    int kind = NOTE_LINE_NUMBER (insn);\n \n-\t    /* Keep a LIFO list of the currently active exception notes.  */\n-\t    if (kind == NOTE_INSN_EH_REGION_BEG)\n-\t      eh_list = alloc_INSN_LIST (insn, eh_list);\n-\t    else if (kind == NOTE_INSN_EH_REGION_END)\n-\t      {\n-\t\trtx t = eh_list;\n-\n-\t\teh_list = XEXP (eh_list, 1);\n-\t\tfree_INSN_LIST_node (t);\n-\t      }\n-\n \t    /* Look for basic block notes with which to keep the\n \t       basic_block_info pointers stable.  Unthread the note now;\n \t       we'll put it back at the right place in create_basic_block.\n \t       Or not at all if we've already found a note in this block.  */\n-\t    else if (kind == NOTE_INSN_BASIC_BLOCK)\n+\t    if (kind == NOTE_INSN_BASIC_BLOCK)\n \t      {\n \t\tif (bb_note == NULL_RTX)\n \t\t  bb_note = insn;\n@@ -938,8 +913,7 @@ find_basic_blocks_1 (f)\n \t  {\n \t    /* Record whether this call created an edge.  */\n \t    rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t    int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n-\t    int call_has_abnormal_edge = 0;\n+\t    int region = (note ? INTVAL (XEXP (note, 0)) : 0);\n \n \t    if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t      {\n@@ -952,19 +926,10 @@ find_basic_blocks_1 (f)\n \t\t  trll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n \t      }\n \n-\t    /* If there is an EH region or rethrow, we have an edge.  */\n-\t    if ((eh_list && region > 0)\n-\t\t|| find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n-\t      call_has_abnormal_edge = 1;\n-\t    else if (nonlocal_goto_handler_labels && region >= 0)\n-\t      /* If there is a nonlocal goto label and the specified\n-\t\t region number isn't -1, we have an edge. (0 means\n-\t\t no throw, but might have a nonlocal goto).  */\n-\t      call_has_abnormal_edge = 1;\n-\n \t    /* A basic block ends at a call that can either throw or\n \t       do a non-local goto.  */\n-\t    if (call_has_abnormal_edge)\n+\t    if ((nonlocal_goto_handler_labels && region >= 0)\n+\t\t|| can_throw_internal (insn))\n \t      {\n \t      new_bb_inclusive:\n \t\tif (head == NULL_RTX)\n@@ -980,18 +945,21 @@ find_basic_blocks_1 (f)\n \t  }\n \t  /* Fall through.  */\n \n-\tdefault:\n-\t  if (GET_RTX_CLASS (code) == 'i')\n-\t    {\n-\t      if (head == NULL_RTX)\n-\t\thead = insn;\n-\t      end = insn;\n-\t    }\n+\tcase INSN:\n+\t  /* Non-call exceptions generate new blocks just like calls.  */\n+\t  if (flag_non_call_exceptions && can_throw_internal (insn))\n+\t    goto new_bb_inclusive;\n+\n+\t  if (head == NULL_RTX)\n+\t    head = insn;\n+\t  end = insn;\n \t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n \n-      if (GET_RTX_CLASS (code) == 'i'\n-\t  && GET_CODE (insn) != JUMP_INSN)\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx note;\n \n@@ -1000,9 +968,6 @@ find_basic_blocks_1 (f)\n \t     Make a special exception for labels followed by an ADDR*VEC,\n \t     as this would be a part of the tablejump setup code.\n \n-\t     Make a special exception for the eh_return_stub_label, which\n-\t     we know isn't part of any otherwise visible control flow.\n-\n \t     Make a special exception to registers loaded with label\n \t     values just before jump insns that use them.  */\n \n@@ -1011,9 +976,7 @@ find_basic_blocks_1 (f)\n \t      {\n \t\trtx lab = XEXP (note, 0), next;\n \n-\t\tif (lab == eh_return_stub_label)\n-\t\t  ;\n-\t\telse if ((next = next_nonnote_insn (lab)) != NULL\n+\t\tif ((next = next_nonnote_insn (lab)) != NULL\n \t\t\t && GET_CODE (next) == JUMP_INSN\n \t\t\t && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t\t\t     || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n@@ -1047,8 +1010,6 @@ void\n cleanup_cfg ()\n {\n   delete_unreachable_blocks ();\n-  move_stray_eh_region_notes ();\n-  record_active_eh_regions (get_insns ());\n   try_merge_blocks ();\n   mark_critical_edges ();\n \n@@ -1201,7 +1162,6 @@ make_edges (label_value_list)\n      rtx label_value_list;\n {\n   int i;\n-  eh_nesting_info *eh_nest_info = init_eh_nesting_info ();\n   sbitmap *edge_cache = NULL;\n \n   /* Assume no computed jump; revise as we create edges.  */\n@@ -1241,9 +1201,13 @@ make_edges (label_value_list)\n \t{\n \t  rtx tmp;\n \n+\t  /* Recognize exception handling placeholders.  */\n+\t  if (GET_CODE (PATTERN (insn)) == RESX)\n+\t    make_eh_edge (edge_cache, bb, insn);\n+\n \t  /* Recognize a non-local goto as a branch outside the\n \t     current function.  */\n-\t  if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+\t  else if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n \t    ;\n \n \t  /* ??? Recognize a tablejump and do the right thing.  */\n@@ -1318,37 +1282,15 @@ make_edges (label_value_list)\n \t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n \n       /* If this is a CALL_INSN, then mark it as reaching the active EH\n-\t handler for this CALL_INSN.  If we're handling asynchronous\n+\t handler for this CALL_INSN.  If we're handling non-call\n \t exceptions then any insn can reach any of the active handlers.\n \n \t Also mark the CALL_INSN as reaching any nonlocal goto handler.  */\n \n       else if (code == CALL_INSN || flag_non_call_exceptions)\n \t{\n-\t  /* Add any appropriate EH edges.  We do this unconditionally\n-\t     since there may be a REG_EH_REGION or REG_EH_RETHROW note\n-\t     on the call, and this needn't be within an EH region.  */\n-\t  make_eh_edge (edge_cache, eh_nest_info, bb, insn, bb->eh_end);\n-\n-\t  /* If we have asynchronous exceptions, do the same for *all*\n-\t     exception regions active in the block.  */\n-\t  if (flag_non_call_exceptions\n-\t      && bb->eh_beg != bb->eh_end)\n-\t    {\n-\t      if (bb->eh_beg >= 0)\n-\t\tmake_eh_edge (edge_cache, eh_nest_info, bb,\n-\t\t\t      NULL_RTX, bb->eh_beg);\n-\n-\t      for (x = bb->head; x != bb->end; x = NEXT_INSN (x))\n-\t\tif (GET_CODE (x) == NOTE\n-\t\t    && (NOTE_LINE_NUMBER (x) == NOTE_INSN_EH_REGION_BEG\n-\t\t        || NOTE_LINE_NUMBER (x) == NOTE_INSN_EH_REGION_END))\n-\t\t  {\n-\t\t    int region = NOTE_EH_HANDLER (x);\n-\t\t    make_eh_edge (edge_cache, eh_nest_info, bb,\n-\t\t\t\t  NULL_RTX, region);\n-\t\t  }\n-\t    }\n+\t  /* Add any appropriate EH edges.  */\n+\t  make_eh_edge (edge_cache, bb, insn);\n \n \t  if (code == CALL_INSN && nonlocal_goto_handler_labels)\n \t    {\n@@ -1369,14 +1311,6 @@ make_edges (label_value_list)\n \t    }\n \t}\n \n-      /* We know something about the structure of the function __throw in\n-\t libgcc2.c.  It is the only function that ever contains eh_stub\n-\t labels.  It modifies its return address so that the last block\n-\t returns to one of the eh_stub labels within it.  So we have to\n-\t make additional edges in the flow graph.  */\n-      if (i + 1 == n_basic_blocks && eh_return_stub_label != 0)\n-\tmake_label_edge (edge_cache, bb, eh_return_stub_label, EDGE_EH);\n-\n       /* Find out if we can drop through to the next block.  */\n       insn = next_nonnote_insn (insn);\n       if (!insn || (i + 1 == n_basic_blocks && force_fallthru))\n@@ -1391,7 +1325,6 @@ make_edges (label_value_list)\n \t}\n     }\n \n-  free_eh_nesting_info (eh_nest_info);\n   if (edge_cache)\n     sbitmap_vector_free (edge_cache);\n }\n@@ -1479,115 +1412,21 @@ make_label_edge (edge_cache, src, label, flags)\n /* Create the edges generated by INSN in REGION.  */\n \n static void\n-make_eh_edge (edge_cache, eh_nest_info, src, insn, region)\n+make_eh_edge (edge_cache, src, insn)\n      sbitmap *edge_cache;\n-     eh_nesting_info *eh_nest_info;\n      basic_block src;\n      rtx insn;\n-     int region;\n-{\n-  handler_info **handler_list;\n-  int num, is_call;\n-\n-  is_call = (insn && GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0);\n-  num = reachable_handlers (region, eh_nest_info, insn, &handler_list);\n-  while (--num >= 0)\n-    {\n-      make_label_edge (edge_cache, src, handler_list[num]->handler_label,\n-\t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n-    }\n-}\n-\n-/* EH_REGION notes appearing between basic blocks is ambiguous, and even\n-   dangerous if we intend to move basic blocks around.  Move such notes\n-   into the following block.  */\n-\n-static void\n-move_stray_eh_region_notes ()\n-{\n-  int i;\n-  basic_block b1, b2;\n-\n-  if (n_basic_blocks < 2)\n-    return;\n-\n-  b2 = BASIC_BLOCK (n_basic_blocks - 1);\n-  for (i = n_basic_blocks - 2; i >= 0; --i, b2 = b1)\n-    {\n-      rtx insn, next, list = NULL_RTX;\n-\n-      b1 = BASIC_BLOCK (i);\n-      for (insn = NEXT_INSN (b1->end); insn != b2->head; insn = next)\n-\t{\n-\t  next = NEXT_INSN (insn);\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t          || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n-\t    {\n-\t      /* Unlink from the insn chain.  */\n-\t      NEXT_INSN (PREV_INSN (insn)) = next;\n-\t      PREV_INSN (next) = PREV_INSN (insn);\n-\n-\t      /* Queue it.  */\n-\t      NEXT_INSN (insn) = list;\n-\t      list = insn;\n-\t    }\n-\t}\n-\n-      if (list == NULL_RTX)\n-\tcontinue;\n-\n-      /* Find where to insert these things.  */\n-      insn = b2->head;\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\tinsn = NEXT_INSN (insn);\n-\n-      while (list)\n-\t{\n-\t  next = NEXT_INSN (list);\n-\t  add_insn_after (list, insn);\n-\t  list = next;\n-\t}\n-    }\n-}\n-\n-/* Recompute eh_beg/eh_end for each basic block.  */\n-\n-static void\n-record_active_eh_regions (f)\n-     rtx f;\n {\n-  rtx insn, eh_list = NULL_RTX;\n-  int i = 0;\n-  basic_block bb = BASIC_BLOCK (0);\n+  int is_call = (GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0);\n+  rtx handlers, i;\n \n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (bb->head == insn)\n-\tbb->eh_beg = (eh_list ? NOTE_EH_HANDLER (XEXP (eh_list, 0)) : -1);\n+  handlers = reachable_handlers (insn);\n \n-      if (GET_CODE (insn) == NOTE)\n-\t{\n-\t  int kind = NOTE_LINE_NUMBER (insn);\n-\t  if (kind == NOTE_INSN_EH_REGION_BEG)\n-\t    eh_list = alloc_INSN_LIST (insn, eh_list);\n-\t  else if (kind == NOTE_INSN_EH_REGION_END)\n-\t    {\n-\t      rtx t = XEXP (eh_list, 1);\n-\t      free_INSN_LIST_node (eh_list);\n-\t      eh_list = t;\n-\t    }\n-\t}\n+  for (i = handlers; i; i = XEXP (i, 1))\n+    make_label_edge (edge_cache, src, XEXP (i, 0),\n+\t\t     EDGE_ABNORMAL | EDGE_EH | is_call);\n \n-      if (bb->end == insn)\n-\t{\n-\t  bb->eh_end = (eh_list ? NOTE_EH_HANDLER (XEXP (eh_list, 0)) : -1);\n-\t  i += 1;\n-\t  if (i == n_basic_blocks)\n-\t    break;\n-\t  bb = BASIC_BLOCK (i);\n-\t}\n-    }\n+  free_INSN_LIST_list (&handlers);\n }\n \n /* Identify critical edges and set the bits appropriately.  */\n@@ -2223,7 +2062,6 @@ static void\n delete_unreachable_blocks ()\n {\n   basic_block *worklist, *tos;\n-  int deleted_handler;\n   edge e;\n   int i, n;\n \n@@ -2261,10 +2099,9 @@ delete_unreachable_blocks ()\n \t  }\n     }\n \n-  /* Delete all unreachable basic blocks.  Count down so that we don't\n-     interfere with the block renumbering that happens in flow_delete_block.  */\n-\n-  deleted_handler = 0;\n+  /* Delete all unreachable basic blocks.  Count down so that we\n+     don't interfere with the block renumbering that happens in\n+     flow_delete_block.  */\n \n   for (i = n - 1; i >= 0; --i)\n     {\n@@ -2274,46 +2111,14 @@ delete_unreachable_blocks ()\n \t/* This block was found.  Tidy up the mark.  */\n \tb->aux = NULL;\n       else\n-\tdeleted_handler |= flow_delete_block (b);\n+\tflow_delete_block (b);\n     }\n \n   tidy_fallthru_edges ();\n \n-  /* If we deleted an exception handler, we may have EH region begin/end\n-     blocks to remove as well.  */\n-  if (deleted_handler)\n-    delete_eh_regions ();\n-\n   free (worklist);\n }\n \n-/* Find EH regions for which there is no longer a handler, and delete them.  */\n-\n-static void\n-delete_eh_regions ()\n-{\n-  rtx insn;\n-\n-  update_rethrow_references ();\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE)\n-      {\n-\tif ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n-\t    || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n-\t  {\n-\t    int num = NOTE_EH_HANDLER (insn);\n-\t    /* A NULL handler indicates a region is no longer needed,\n-\t       as long as its rethrow label isn't used.  */\n-\t    if (get_first_handler (num) == NULL && ! rethrow_used (num))\n-\t      {\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n-\t      }\n-\t  }\n-      }\n-}\n-\n /* Return true if NOTE is not one of the ones that must be kept paired,\n    so that we may simply delete them.  */\n \n@@ -2387,26 +2192,7 @@ flow_delete_block (b)\n   never_reached_warning (insn);\n \n   if (GET_CODE (insn) == CODE_LABEL)\n-    {\n-      rtx x, *prev = &exception_handler_labels;\n-\n-      for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-\t{\n-\t  if (XEXP (x, 0) == insn)\n-\t    {\n-\t      /* Found a match, splice this label out of the EH label list.  */\n-\t      *prev = XEXP (x, 1);\n-\t      XEXP (x, 1) = NULL_RTX;\n-\t      XEXP (x, 0) = NULL_RTX;\n-\n-\t      /* Remove the handler from all regions */\n-\t      remove_handler (insn);\n-\t      deleted_handler = 1;\n-\t      break;\n-\t    }\n-\t  prev = &XEXP (x, 1);\n-\t}\n-    }\n+    maybe_remove_eh_handler (insn);\n \n   /* Include any jump table following the basic block.  */\n   end = b->end;\n@@ -2804,7 +2590,6 @@ merge_blocks (e, b, c)\n   else\n     {\n       edge tmp_edge;\n-      basic_block d;\n       int c_has_outgoing_fallthru;\n       int b_has_incoming_fallthru;\n \n@@ -2832,37 +2617,22 @@ merge_blocks (e, b, c)\n \t  break;\n       b_has_incoming_fallthru = (tmp_edge != NULL);\n \n-      /* If B does not have an incoming fallthru, and the exception regions\n-\t match, then it can be moved immediately before C without introducing\n-\t or modifying jumps.\n-\n-\t C can not be the first block, so we do not have to worry about\n+      /* If B does not have an incoming fallthru, then it can be moved\n+\t immediately before C without introducing or modifying jumps.\n+\t C cannot be the first block, so we do not have to worry about\n \t accessing a non-existent block.  */\n-      d = BASIC_BLOCK (c->index - 1);\n-      if (! b_has_incoming_fallthru\n-\t  && d->eh_end == b->eh_beg\n-\t  && b->eh_end == c->eh_beg)\n+      if (! b_has_incoming_fallthru)\n \treturn merge_blocks_move_predecessor_nojumps (b, c);\n \n-      /* Otherwise, we're going to try to move C after B.  Make sure the\n-\t exception regions match.\n+      /* Otherwise, we're going to try to move C after B.  If C does\n+\t not have an outgoing fallthru, then it can be moved\n+\t immediately after B without introducing or modifying jumps.  */\n+      if (! c_has_outgoing_fallthru)\n+\treturn merge_blocks_move_successor_nojumps (b, c);\n \n-\t If B is the last basic block, then we must not try to access the\n-\t block structure for block B + 1.  Luckily in that case we do not\n-\t need to worry about matching exception regions.  */\n-      d = (b->index + 1 < n_basic_blocks ? BASIC_BLOCK (b->index + 1) : NULL);\n-      if (b->eh_end == c->eh_beg\n-\t  && (d == NULL || c->eh_end == d->eh_beg))\n-\t{\n-\t  /* If C does not have an outgoing fallthru, then it can be moved\n-\t     immediately after B without introducing or modifying jumps.  */\n-\t  if (! c_has_outgoing_fallthru)\n-\t    return merge_blocks_move_successor_nojumps (b, c);\n-\n-\t  /* Otherwise, we'll need to insert an extra jump, and possibly\n-\t     a new block to contain it.  */\n-\t  /* ??? Not implemented yet.  */\n-\t}\n+      /* Otherwise, we'll need to insert an extra jump, and possibly\n+\t a new block to contain it.  */\n+      /* ??? Not implemented yet.  */\n \n       return 0;\n     }\n@@ -3502,14 +3272,44 @@ mark_regs_live_at_end (set)\n     if (global_regs[i] || EPILOGUE_USES (i))\n       SET_REGNO_REG_SET (set, i);\n \n-  /* Mark all call-saved registers that we actaully used.  */\n   if (HAVE_epilogue && reload_completed)\n     {\n+      /* Mark all call-saved registers that we actually used.  */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (regs_ever_live[i] && ! call_used_regs[i] && ! LOCAL_REGNO (i))\n \t  SET_REGNO_REG_SET (set, i);\n     }\n \n+#ifdef EH_RETURN_DATA_REGNO\n+  /* Mark the registers that will contain data for the handler.  */\n+  if (reload_completed && current_function_calls_eh_return)\n+    for (i = 0; ; ++i)\n+      {\n+\tunsigned regno = EH_RETURN_DATA_REGNO(i);\n+\tif (regno == INVALID_REGNUM)\n+\t  break;\n+\tSET_REGNO_REG_SET (set, regno);\n+      }\n+#endif\n+#ifdef EH_RETURN_STACKADJ_RTX\n+  if ((! HAVE_epilogue || ! reload_completed)\n+      && current_function_calls_eh_return)\n+    {\n+      rtx tmp = EH_RETURN_STACKADJ_RTX;\n+      if (tmp && REG_P (tmp))\n+\tmark_reg (tmp, set);\n+    }\n+#endif\n+#ifdef EH_RETURN_HANDLER_RTX\n+  if ((! HAVE_epilogue || ! reload_completed)\n+      && current_function_calls_eh_return)\n+    {\n+      rtx tmp = EH_RETURN_HANDLER_RTX;\n+      if (tmp && REG_P (tmp))\n+\tmark_reg (tmp, set);\n+    }\n+#endif\n+\n   /* Mark function return value.  */\n   diddle_return_value (mark_reg, set);\n }\n@@ -4249,7 +4049,8 @@ init_propagate_block_info (bb, live, local_set, cond_local_set, flags)\n       && (flags & PROP_SCAN_DEAD_CODE)\n       && (bb->succ == NULL\n \t  || (bb->succ->succ_next == NULL\n-\t      && bb->succ->dest == EXIT_BLOCK_PTR)))\n+\t      && bb->succ->dest == EXIT_BLOCK_PTR\n+\t      && ! current_function_calls_eh_return)))\n     {\n       rtx insn, set;\n       for (insn = bb->end; insn != bb->head; insn = PREV_INSN (insn))\n@@ -6631,8 +6432,6 @@ dump_bb (bb, outf)\n \n   fprintf (outf, \";; Basic block %d, loop depth %d, count %d\",\n \t   bb->index, bb->loop_depth, bb->count);\n-  if (bb->eh_beg != -1 || bb->eh_end != -1)\n-    fprintf (outf, \", eh regions %d/%d\", bb->eh_beg, bb->eh_end);\n   putc ('\\n', outf);\n \n   fputs (\";; Predecessors: \", outf);"}, {"sha": "7fbcf87c6c8ad59155337dabd028b1bd9664ca88", "filename": "gcc/frame-dwarf2.c", "status": "removed", "additions": 0, "deletions": 778, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1c98ea459813570b4588427030daa03958fda6/gcc%2Fframe-dwarf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1c98ea459813570b4588427030daa03958fda6/gcc%2Fframe-dwarf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe-dwarf2.c?ref=ce1c98ea459813570b4588427030daa03958fda6", "patch": "@@ -1,778 +0,0 @@\n-/* Subroutines needed for unwinding DWARF 2 format stack frame info\n-   for exception handling.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n-   Contributed by Jason Merrill <jason@cygnus.com>.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* It is incorrect to include config.h here, because this file is being\n-   compiled for the target, and hence definitions concerning only the host\n-   do not apply.  */\n-\n-#include \"tconfig.h\"\n-#include \"tsystem.h\"\n-\n-#ifdef DWARF2_UNWIND_INFO\n-#include \"dwarf2.h\"\n-#include \"frame.h\"\n-#include \"gthr.h\"\n-\n-#ifdef __GTHREAD_MUTEX_INIT\n-static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n-#else\n-static __gthread_mutex_t object_mutex;\n-#endif\n-\n-/* Don't use `fancy_abort' here even if config.h says to use it.  */\n-#ifdef abort\n-#undef abort\n-#endif\n-\n-/* Some types used by the DWARF 2 spec.  */\n-\n-typedef          int  sword __attribute__ ((mode (SI)));\n-typedef unsigned int  uword __attribute__ ((mode (SI)));\n-typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n-typedef          int  saddr __attribute__ ((mode (pointer)));\n-typedef unsigned char ubyte;\n-\n-/* Terminology:\n-   CIE - Common Information Element\n-   FDE - Frame Descriptor Element\n-\n-   There is one per function, and it describes where the function code\n-   is located, and what the register lifetimes and stack layout are\n-   within the function.\n-\n-   The data structures are defined in the DWARF specfication, although\n-   not in a very readable way (see LITERATURE).\n-\n-   Every time an exception is thrown, the code needs to locate the FDE\n-   for the current function, and starts to look for exception regions\n-   from that FDE. This works in a two-level search:\n-   a) in a linear search, find the shared image (i.e. DLL) containing\n-      the PC\n-   b) using the FDE table for that shared object, locate the FDE using\n-      binary search (which requires the sorting).  */   \n-\n-/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n-   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n-   unit boundary, but the fields within are unaligned.  */\n-\n-struct dwarf_cie {\n-  uword length;\n-  sword CIE_id;\n-  ubyte version;\n-  char augmentation[0];\n-} __attribute__ ((packed, aligned (__alignof__ (void *))));\n-\n-/* The first few fields of an FDE.  */\n-\n-struct dwarf_fde {\n-  uword length;\n-  sword CIE_delta;\n-  void* pc_begin;\n-  uaddr pc_range;\n-} __attribute__ ((packed, aligned (__alignof__ (void *))));\n-\n-typedef struct dwarf_fde fde;\n-\n-/* Objects to be searched for frame unwind info.  */\n-\n-static struct object *objects;\n-\n-/* The information we care about from a CIE.  */\n-\n-struct cie_info {\n-  char *augmentation;\n-  void *eh_ptr;\n-  int code_align;\n-  int data_align;\n-  unsigned ra_regno;\n-};\n-\n-/* The current unwind state, plus a saved copy for DW_CFA_remember_state.  */\n-\n-struct frame_state_internal\n-{\n-  struct frame_state s;\n-  struct frame_state_internal *saved_state;\n-};\n-\f\n-/* This is undefined below if we need it to be an actual function.  */\n-#define init_object_mutex_once()\n-\n-#if __GTHREADS\n-#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n-\n-/* Helper for init_object_mutex_once.  */\n-\n-static void\n-init_object_mutex (void)\n-{\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n-}\n-\n-/* Call this to arrange to initialize the object mutex.  */\n-\n-#undef init_object_mutex_once\n-static void\n-init_object_mutex_once (void)\n-{\n-  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-  __gthread_once (&once, init_object_mutex);\n-}\n-\n-#endif /* __GTHREAD_MUTEX_INIT_FUNCTION */\n-#endif /* __GTHREADS */\n-\f  \n-/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n-   by R, and return the new value of BUF.  */\n-\n-static void *\n-decode_uleb128 (unsigned char *buf, unsigned *r)\n-{\n-  unsigned shift = 0;\n-  unsigned result = 0;\n-\n-  while (1)\n-    {\n-      unsigned byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      if ((byte & 0x80) == 0)\n-\tbreak;\n-      shift += 7;\n-    }\n-  *r = result;\n-  return buf;\n-}\n-\n-/* Decode the signed LEB128 constant at BUF into the variable pointed to\n-   by R, and return the new value of BUF.  */\n-\n-static void *\n-decode_sleb128 (unsigned char *buf, int *r)\n-{\n-  unsigned shift = 0;\n-  unsigned result = 0;\n-  unsigned byte;\n-\n-  while (1)\n-    {\n-      byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\tbreak;\n-    }\n-  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n-    result |= - (1 << shift);\n-\n-  *r = result;\n-  return buf;\n-}\n-\n-/* Read unaligned data from the instruction buffer.  */\n-\n-union unaligned {\n-  void *p;\n-  unsigned b2 __attribute__ ((mode (HI)));\n-  unsigned b4 __attribute__ ((mode (SI)));\n-  unsigned b8 __attribute__ ((mode (DI)));\n-} __attribute__ ((packed));\n-static inline void *\n-read_pointer (void *p)\n-{ union unaligned *up = p; return up->p; }\n-static inline unsigned\n-read_1byte (void *p)\n-{ return *(unsigned char *)p; }\n-static inline unsigned\n-read_2byte (void *p)\n-{ union unaligned *up = p; return up->b2; }\n-static inline unsigned\n-read_4byte (void *p)\n-{ union unaligned *up = p; return up->b4; }\n-static inline unsigned long\n-read_8byte (void *p)\n-{ union unaligned *up = p; return up->b8; }\n-\f\n-/* Ordering function for FDEs.  Functions can't overlap, so we just compare\n-   their starting addresses.  */\n-\n-static inline saddr\n-fde_compare (fde *x, fde *y)\n-{\n-  return (saddr)x->pc_begin - (saddr)y->pc_begin;\n-}\n-\n-/* Return the address of the FDE after P.  */\n-\n-static inline fde *\n-next_fde (fde *p)\n-{\n-  return (fde *)(((char *)p) + p->length + sizeof (p->length));\n-}\n-\n-#include \"frame.c\"\n-\n-static size_t\n-count_fdes (fde *this_fde)\n-{\n-  size_t count;\n-\n-  for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-\tcontinue;\n-\n-      ++count;\n-    }\n-\n-  return count;\n-}\n-\n-static void\n-add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n-{\n-  void *pc_begin = *beg_ptr;\n-  void *pc_end = *end_ptr;\n-\n-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-\tcontinue;\n-\n-      fde_insert (accu, this_fde);\n-\n-      if (this_fde->pc_begin < pc_begin)\n-\tpc_begin = this_fde->pc_begin;\n-      if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n-\tpc_end = this_fde->pc_begin + this_fde->pc_range;\n-    }\n-\n-  *beg_ptr = pc_begin;\n-  *end_ptr = pc_end;\n-}\n-\n-/* search this fde table for the one containing the pc */\n-static fde *\n-search_fdes (fde *this_fde, void *pc)\n-{\n-  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n-    {\n-      /* Skip CIEs and linked once FDE entries.  */\n-      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n-\tcontinue;\n-\n-      if ((uaddr)((char *)pc - (char *)this_fde->pc_begin) < this_fde->pc_range)\n-\treturn this_fde;\n-    }\n-  return NULL;\n-}\n-\n-/* Set up a sorted array of pointers to FDEs for a loaded object.  We\n-   count up the entries before allocating the array because it's likely to\n-   be faster.  We can be called multiple times, should we have failed to\n-   allocate a sorted fde array on a previous occasion.  */\n-\n-static void\n-frame_init (struct object* ob)\n-{\n-  size_t count;\n-  fde_accumulator accu;\n-  void *pc_begin, *pc_end;\n-  fde **array;\n-\n-  if (ob->pc_begin)\n-    count = ob->count;\n-  else if (ob->fde_array)\n-    {\n-      fde **p = ob->fde_array;\n-      for (count = 0; *p; ++p)\n-\tcount += count_fdes (*p);\n-    }\n-  else\n-    count = count_fdes (ob->fde_begin);\n-  ob->count = count;\n-\n-  if (!start_fde_sort (&accu, count) && ob->pc_begin)\n-    return;\n-\n-  pc_begin = (void*)(uaddr)-1;\n-  pc_end = 0;\n-\n-  if (ob->fde_array)\n-    {\n-      fde **p = ob->fde_array;\n-      for (; *p; ++p)\n-\tadd_fdes (*p, &accu, &pc_begin, &pc_end);\n-    }\n-  else\n-    add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n-\n-  array = end_fde_sort (&accu, count);\n-  if (array)\n-    ob->fde_array = array;\n-  ob->pc_begin = pc_begin;\n-  ob->pc_end = pc_end;\n-}\n-\n-/* Return a pointer to the FDE for the function containing PC.  */\n-\n-static fde *\n-find_fde (void *pc)\n-{\n-  struct object *ob;\n-  size_t lo, hi;\n-\n-  init_object_mutex_once ();\n-  __gthread_mutex_lock (&object_mutex);\n-\n-  /* Linear search through the objects, to find the one containing the pc. */\n-  for (ob = objects; ob; ob = ob->next)\n-    {\n-      if (ob->pc_begin == 0)\n-\tframe_init (ob);\n-      if (pc >= ob->pc_begin && pc < ob->pc_end)\n-\tbreak;\n-    }\n-\n-  if (ob == 0)\n-    {\n-      __gthread_mutex_unlock (&object_mutex);\n-      return 0;\n-    }\n-\n-  if (!ob->fde_array || (void *)ob->fde_array == (void *)ob->fde_begin)\n-    frame_init (ob);\n-\n-  if (ob->fde_array && (void *)ob->fde_array != (void *)ob->fde_begin)\n-    {\n-      __gthread_mutex_unlock (&object_mutex);\n-      \n-      /* Standard binary search algorithm.  */\n-      for (lo = 0, hi = ob->count; lo < hi; )\n-\t{\n-\t  size_t i = (lo + hi) / 2;\n-\t  fde *f = ob->fde_array[i];\n-\n-\t  if (pc < f->pc_begin)\n-\t    hi = i;\n-\t  else if (pc >= f->pc_begin + f->pc_range)\n-\t    lo = i + 1;\n-\t  else\n-\t    return f;\n-\t}\n-    }\n-  else\n-    {\n-      /* Long slow labourious linear search, cos we've no memory. */\n-      fde *f;\n-      \n-      if (ob->fde_array)\n-\t{\n-\t  fde **p = ob->fde_array;\n-\t  \n-\t  do\n-\t    {\n-\t      f = search_fdes (*p, pc);\n-\t      if (f)\n-\t\tbreak;\n-\t      p++;\n-\t    }\n-\t  while (*p);\n-\t}\n-      else\n-\tf = search_fdes (ob->fde_begin, pc);\n-      __gthread_mutex_unlock (&object_mutex);\n-      return f;\n-    }\n-  return 0;\n-}\n-\f\n-static inline struct dwarf_cie *\n-get_cie (fde *f)\n-{\n-  return ((void *)&f->CIE_delta) - f->CIE_delta;\n-}\n-\n-/* Extract any interesting information from the CIE for the translation\n-   unit F belongs to.  */\n-\n-static void *\n-extract_cie_info (fde *f, struct cie_info *c)\n-{\n-  void *p;\n-  int i;\n-\n-  c->augmentation = get_cie (f)->augmentation;\n-\n-  if (strcmp (c->augmentation, \"\") != 0\n-      && strcmp (c->augmentation, \"eh\") != 0\n-      && c->augmentation[0] != 'z')\n-    return 0;\n-\n-  p = c->augmentation + strlen (c->augmentation) + 1;\n-\n-  if (strcmp (c->augmentation, \"eh\") == 0)\n-    {\n-      c->eh_ptr = read_pointer (p);\n-      p += sizeof (void *);\n-    }\n-  else\n-    c->eh_ptr = 0;\n-\n-  p = decode_uleb128 (p, &c->code_align);\n-  p = decode_sleb128 (p, &c->data_align);\n-  c->ra_regno = *(unsigned char *)p++;\n-\n-  /* If the augmentation starts with 'z', we now see the length of the\n-     augmentation fields.  */\n-  if (c->augmentation[0] == 'z')\n-    {\n-      p = decode_uleb128 (p, &i);\n-      p += i;\n-    }\n-\n-  return p;\n-}\n-\n-/* Decode a DW_OP stack operation.  */\n-\n-static void *\n-decode_stack_op (unsigned char *buf, struct frame_state *state)\n-{\n-  enum dwarf_location_atom op;\n-  int offset;\n-\n-  op = *buf++;\n-  switch (op)\n-    {\n-    case DW_OP_reg0:\n-    case DW_OP_reg1:\n-    case DW_OP_reg2:\n-    case DW_OP_reg3:\n-    case DW_OP_reg4:\n-    case DW_OP_reg5:\n-    case DW_OP_reg6:\n-    case DW_OP_reg7:\n-    case DW_OP_reg8:\n-    case DW_OP_reg9:\n-    case DW_OP_reg10:\n-    case DW_OP_reg11:\n-    case DW_OP_reg12:\n-    case DW_OP_reg13:\n-    case DW_OP_reg14:\n-    case DW_OP_reg15:\n-    case DW_OP_reg16:\n-    case DW_OP_reg17:\n-    case DW_OP_reg18:\n-    case DW_OP_reg19:\n-    case DW_OP_reg20:\n-    case DW_OP_reg21:\n-    case DW_OP_reg22:\n-    case DW_OP_reg23:\n-    case DW_OP_reg24:\n-    case DW_OP_reg25:\n-    case DW_OP_reg26:\n-    case DW_OP_reg27:\n-    case DW_OP_reg28:\n-    case DW_OP_reg29:\n-    case DW_OP_reg30:\n-    case DW_OP_reg31:\n-      state->cfa_reg = op - DW_OP_reg0;\n-      break;\n-    case DW_OP_regx:\n-      buf = decode_sleb128 (buf, &offset);\n-      state->cfa_reg = offset;\n-      break;\n-    case DW_OP_breg0:\n-    case DW_OP_breg1:\n-    case DW_OP_breg2:\n-    case DW_OP_breg3:\n-    case DW_OP_breg4:\n-    case DW_OP_breg5:\n-    case DW_OP_breg6:\n-    case DW_OP_breg7:\n-    case DW_OP_breg8:\n-    case DW_OP_breg9:\n-    case DW_OP_breg10:\n-    case DW_OP_breg11:\n-    case DW_OP_breg12:\n-    case DW_OP_breg13:\n-    case DW_OP_breg14:\n-    case DW_OP_breg15:\n-    case DW_OP_breg16:\n-    case DW_OP_breg17:\n-    case DW_OP_breg18:\n-    case DW_OP_breg19:\n-    case DW_OP_breg20:\n-    case DW_OP_breg21:\n-    case DW_OP_breg22:\n-    case DW_OP_breg23:\n-    case DW_OP_breg24:\n-    case DW_OP_breg25:\n-    case DW_OP_breg26:\n-    case DW_OP_breg27:\n-    case DW_OP_breg28:\n-    case DW_OP_breg29:\n-    case DW_OP_breg30:\n-    case DW_OP_breg31:\n-      state->cfa_reg = op - DW_OP_breg0;\n-      buf = decode_sleb128 (buf, &offset);\n-      state->base_offset = offset;\n-      break;\n-    case DW_OP_bregx:\n-      buf = decode_sleb128 (buf, &offset);\n-      state->cfa_reg = offset;\n-      buf = decode_sleb128 (buf, &offset);\n-      state->base_offset = offset;\n-      break;\n-    case DW_OP_deref:\n-      state->indirect = 1;\n-      break;\n-    case DW_OP_plus_uconst:\n-      buf = decode_uleb128 (buf, &offset);\n-      state->cfa_offset = offset;\n-      break;\n-    default:\n-      abort ();\n-    }\n-  return buf;\n-}\n-/* Decode one instruction's worth of DWARF 2 call frame information.\n-   Used by __frame_state_for.  Takes pointers P to the instruction to\n-   decode, STATE to the current register unwind information, INFO to the\n-   current CIE information, and PC to the current PC value.  Returns a\n-   pointer to the next instruction.  */\n-\n-static void *\n-execute_cfa_insn (void *p, struct frame_state_internal *state,\n-\t\t  struct cie_info *info, void **pc)\n-{\n-  unsigned insn = *(unsigned char *)p++;\n-  unsigned reg;\n-  int offset;\n-\n-  if (insn & DW_CFA_advance_loc)\n-    *pc += ((insn & 0x3f) * info->code_align);\n-  else if (insn & DW_CFA_offset)\n-    {\n-      reg = (insn & 0x3f);\n-      p = decode_uleb128 (p, &offset);\n-      if (reg == state->s.cfa_reg)\n-\t/* Don't record anything about this register; it's only used to\n-\t   reload SP in the epilogue.  We don't want to copy in SP\n-\t   values for outer frames; we handle restoring SP specially.  */;\n-      else\n-\t{\n-\t  offset *= info->data_align;\n-\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n-\t  state->s.reg_or_offset[reg] = offset;\n-\t}\n-    }\n-  else if (insn & DW_CFA_restore)\n-    {\n-      reg = (insn & 0x3f);\n-      state->s.saved[reg] = REG_UNSAVED;\n-    }\n-  else switch (insn)\n-    {\n-    case DW_CFA_set_loc:\n-      *pc = read_pointer (p);\n-      p += sizeof (void *);\n-      break;\n-    case DW_CFA_advance_loc1:\n-      *pc += read_1byte (p);\n-      p += 1;\n-      break;\n-    case DW_CFA_advance_loc2:\n-      *pc += read_2byte (p);\n-      p += 2;\n-      break;\n-    case DW_CFA_advance_loc4:\n-      *pc += read_4byte (p);\n-      p += 4;\n-      break;\n-\n-    case DW_CFA_offset_extended:\n-      p = decode_uleb128 (p, &reg);\n-      p = decode_uleb128 (p, &offset);\n-      if (reg == state->s.cfa_reg)\n-\t/* Don't record anything; see above.  */;\n-      else\n-\t{\n-\t  offset *= info->data_align;\n-\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n-\t  state->s.reg_or_offset[reg] = offset;\n-\t}\n-      break;\n-    case DW_CFA_restore_extended:\n-      p = decode_uleb128 (p, &reg);\n-      state->s.saved[reg] = REG_UNSAVED;\n-      break;\n-\n-    case DW_CFA_undefined:\n-    case DW_CFA_same_value:\n-    case DW_CFA_nop:\n-      break;\n-\n-    case DW_CFA_register:\n-      {\n-\tunsigned reg2;\n-\tp = decode_uleb128 (p, &reg);\n-\tp = decode_uleb128 (p, &reg2);\n-\tstate->s.saved[reg] = REG_SAVED_REG;\n-\tstate->s.reg_or_offset[reg] = reg2;\n-      }\n-      break;\n-\n-    case DW_CFA_def_cfa:\n-      p = decode_uleb128 (p, &reg);\n-      p = decode_uleb128 (p, &offset);\n-      state->s.cfa_reg = reg;\n-      state->s.cfa_offset = offset;\n-      break;\n-    case DW_CFA_def_cfa_register:\n-      p = decode_uleb128 (p, &reg);\n-      state->s.cfa_reg = reg;\n-      break;\n-    case DW_CFA_def_cfa_offset:\n-      p = decode_uleb128 (p, &offset);\n-      state->s.cfa_offset = offset;\n-      break;\n-    case DW_CFA_def_cfa_expression:\n-      {\n-\tvoid *end;\n-\tstate->s.cfa_reg = 0;\n-\tstate->s.cfa_offset = 0;\n-\tstate->s.base_offset = 0;\n-\tstate->s.indirect = 0;\n-\n-\tp = decode_uleb128 (p, &offset);\n-\tend = p + offset;\n-\twhile (p < end)\n-\t  p = decode_stack_op (p, &(state->s));\n-\tbreak;\n-      }\n-      \n-    case DW_CFA_remember_state:\n-      {\n-\tstruct frame_state_internal *save =\n-\t  (struct frame_state_internal *)\n-\t  malloc (sizeof (struct frame_state_internal));\n-\tmemcpy (save, state, sizeof (struct frame_state_internal));\n-\tstate->saved_state = save;\n-      }\n-      break;\n-    case DW_CFA_restore_state:\n-      {\n-\tstruct frame_state_internal *save = state->saved_state;\n-\tmemcpy (state, save, sizeof (struct frame_state_internal));\n-\tfree (save);\n-      }\n-      break;\n-\n-      /* FIXME: Hardcoded for SPARC register window configuration.  */\n-    case DW_CFA_GNU_window_save:\n-      for (reg = 16; reg < 32; ++reg)\n-\t{\n-\t  state->s.saved[reg] = REG_SAVED_OFFSET;\n-\t  state->s.reg_or_offset[reg] = (reg - 16) * sizeof (void *);\n-\t}\n-      break;\n-\n-    case DW_CFA_GNU_args_size:\n-      p = decode_uleb128 (p, &offset);\n-      state->s.args_size = offset;\n-      break;\n-\n-    case DW_CFA_GNU_negative_offset_extended:\n-      p = decode_uleb128 (p, &reg);\n-      p = decode_uleb128 (p, &offset);\n-      offset *= info->data_align;\n-      state->s.saved[reg] = REG_SAVED_OFFSET;\n-      state->s.reg_or_offset[reg] = -offset;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-  return p;\n-}\n-\f\n-/* Called from __throw to find the registers to restore for a given\n-   PC_TARGET.  The caller should allocate a local variable of `struct\n-   frame_state' (declared in frame.h) and pass its address to STATE_IN.  */\n-\n-struct frame_state *\n-__frame_state_for (void *pc_target, struct frame_state *state_in)\n-{\n-  fde *f;\n-  void *insn, *end, *pc;\n-  struct cie_info info;\n-  struct frame_state_internal state;\n-\n-  f = find_fde (pc_target);\n-  if (f == 0)\n-    return 0;\n-\n-  insn = extract_cie_info (f, &info);\n-  if (insn == 0)\n-    return 0;\n-\n-  memset (&state, 0, sizeof (state));\n-  state.s.retaddr_column = info.ra_regno;\n-  state.s.eh_ptr = info.eh_ptr;\n-\n-  /* First decode all the insns in the CIE.  */\n-  end = next_fde ((fde*) get_cie (f));\n-  while (insn < end)\n-    insn = execute_cfa_insn (insn, &state, &info, 0);\n-\n-  insn = ((fde *)f) + 1;\n-\n-  if (info.augmentation[0] == 'z')\n-    {\n-      int i;\n-      insn = decode_uleb128 (insn, &i);\n-      insn += i;\n-    }\n-\n-  /* Then the insns in the FDE up to our target PC.  */\n-  end = next_fde (f);\n-  pc = f->pc_begin;\n-  while (insn < end && pc <= pc_target)\n-    insn = execute_cfa_insn (insn, &state, &info, &pc);\n-\n-  memcpy (state_in, &state.s, sizeof (state.s));\n-  return state_in;\n-}\n-#endif /* DWARF2_UNWIND_INFO */"}, {"sha": "2257d5256c56f5858c15e3268d40bbb0963b6140", "filename": "gcc/frame.h", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1c98ea459813570b4588427030daa03958fda6/gcc%2Fframe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1c98ea459813570b4588427030daa03958fda6/gcc%2Fframe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.h?ref=ce1c98ea459813570b4588427030daa03958fda6", "patch": "@@ -1,287 +0,0 @@\n-/* Header file for unwinding stack frames for exception handling.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-   Contributed by Jason Merrill <jason@cygnus.com>.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#ifndef DWARF_FRAME_REGISTERS\n-#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n-#endif\n-\n-typedef struct frame_state\n-{\n-  void *cfa;\n-  void *eh_ptr;\n-  long cfa_offset;\n-  long args_size;\n-  long reg_or_offset[DWARF_FRAME_REGISTERS+1];\n-  unsigned short cfa_reg;\n-  unsigned short retaddr_column;\n-  char saved[DWARF_FRAME_REGISTERS+1];\n-  long base_offset;\n-  char indirect;\n-} frame_state;\n-\n-/* Values for 'saved' above.  */\n-#define REG_UNSAVED 0\n-#define REG_SAVED_OFFSET 1\n-#define REG_SAVED_REG 2\n-\n-/* The representation for an \"object\" to be searched for frame unwind info.\n-   For targets with named sections, one object is an executable or shared\n-   library; for other targets, one object is one translation unit.\n-\n-   A copy of this structure declaration is printed by collect2.c;\n-   keep the copies synchronized!  */\n-\n-struct object {\n-#ifdef IA64_UNWIND_INFO\n-  void *pc_base;        /* This field will be set by find_fde. */\n-#endif\n-  void *pc_begin;\n-  void *pc_end;\n-  struct dwarf_fde *fde_begin;\n-#ifdef IA64_UNWIND_INFO\n-  struct dwarf_fde *fde_end;\n-#endif\n-  struct dwarf_fde **fde_array;\n-  size_t count;\n-  struct object *next;\n-};\n-\n-/* Note the following routines are exported interfaces from libgcc; do not\n-   change these interfaces.  Instead create new interfaces.  Also note\n-   references to these functions may be made weak in files where they\n-   are referenced.  */\n-\n-extern void __register_frame (void * );\n-extern void __register_frame_table (void *);\n-extern void __deregister_frame (void *);\n-\n-/* Called either from crtbegin.o or a static constructor to register the\n-   unwind info for an object or translation unit, respectively.  */\n-\n-extern void __register_frame_info (void *, struct object *);\n-\n-/* Similar, but BEGIN is actually a pointer to a table of unwind entries\n-   for different translation units.  Called from the file generated by\n-   collect2.  */\n-extern void __register_frame_info_table (void *, struct object *);\n-\n-/* Called from crtend.o to deregister the unwind info for an object.  */\n-\n-extern void *__deregister_frame_info (void *);\n-\n-/* Called from __throw to find the registers to restore for a given\n-   PC_TARGET.  The caller should allocate a local variable of `struct\n-   frame_state' (declared in frame.h) and pass its address to STATE_IN.\n-   Returns NULL on failure, otherwise returns STATE_IN.  */\n-\n-extern struct frame_state *__frame_state_for (void *, struct frame_state *);\n-\n-#ifdef IA64_UNWIND_INFO\n-\n-/* This is the information required for unwind records in an ia64\n-   object file. This is required by GAS and the compiler runtime. */\n-\n-/* These are the starting point masks for the various types of\n-   unwind records. To create a record of type R3 for instance, one\n-   starts by using the value UNW_R3 and or-ing in any other required values. \n-   These values are also unique (in context), so they can be used to identify \n-   the various record types as well. UNW_Bx and some UNW_Px do have the\n-   same value, but Px can only occur in a prologue context, and Bx in\n-   a body context.  */\n-\n-#define UNW_R1\t0x00\n-#define UNW_R2\t0x40\n-#define UNW_R3\t0x60\n-#define UNW_P1\t0x80\n-#define UNW_P2\t0xA0\n-#define UNW_P3\t0xB0\n-#define UNW_P4\t0xB8\n-#define UNW_P5\t0xB9\n-#define UNW_P6\t0xC0\n-#define UNW_P7\t0xE0\n-#define UNW_P8\t0xF0\n-#define UNW_P9\t0xF1\n-#define UNW_P10\t0xFF\n-#define UNW_X1\t0xF9\n-#define UNW_X2\t0xFA\n-#define UNW_X3\t0xFB\n-#define UNW_X4\t0xFC\n-#define UNW_B1\t0x80\n-#define UNW_B2\t0xC0\n-#define UNW_B3\t0xE0\n-#define UNW_B4\t0xF0\n-\n-/* These are all the various types of unwind records.  */\n-\n-typedef enum\n-{\n-  prologue, prologue_gr, body, mem_stack_f, mem_stack_v, psp_gr, psp_sprel,\n-  rp_when, rp_gr, rp_br, rp_psprel, rp_sprel, pfs_when, pfs_gr, pfs_psprel,\n-  pfs_sprel, preds_when, preds_gr, preds_psprel, preds_sprel,\n-  fr_mem, frgr_mem, gr_gr, gr_mem, br_mem, br_gr, spill_base, spill_mask,\n-  unat_when, unat_gr, unat_psprel, unat_sprel, lc_when, lc_gr, lc_psprel,\n-  lc_sprel, fpsr_when, fpsr_gr, fpsr_psprel, fpsr_sprel, \n-  priunat_when_gr, priunat_when_mem, priunat_gr, priunat_psprel, \n-  priunat_sprel, bsp_when, bsp_gr, bsp_psprel, bsp_sprel, bspstore_when,\n-  bspstore_gr, bspstore_psprel, bspstore_sprel, rnat_when, rnat_gr,\n-  rnat_psprel, rnat_sprel, epilogue, label_state, copy_state,\n-  spill_psprel, spill_sprel, spill_reg, spill_psprel_p, spill_sprel_p,\n-  spill_reg_p\n-} unw_record_type;\n-\n-\n-/* These structures declare the fields that can be used in each of the \n-   4 record formats, R, P, B and X.  */\n-\n-typedef struct unw_r_record\n-{\n-  unsigned long rlen;\n-  unsigned short mask;\n-  unsigned short grsave;\n-} unw_r_record;\n-\n-typedef struct unw_p_record\n-{\n-  void *imask;\n-  unsigned long t;\n-  unsigned long size;\n-  unsigned long spoff;\n-  unsigned long br;\n-  unsigned long pspoff;\n-  unsigned short gr;\n-  unsigned short rmask;\n-  unsigned short grmask;\n-  unsigned long frmask;\n-  unsigned short brmask;\n-} unw_p_record;\n-\n-typedef struct unw_b_record\n-{\n-  unsigned long t;\n-  unsigned long label;\n-  unsigned short ecount;\n-} unw_b_record;\n-\n-typedef struct unw_x_record\n-{\n-  unsigned long t;\n-  unsigned long spoff;\n-  unsigned long pspoff;\n-  unsigned short reg;\n-  unsigned short treg;\n-  unsigned short qp;\n-  unsigned short xy;   /* Value of the XY field..  */\n-} unw_x_record;\n-\n-/* This structure is used to determine the specific record type and \n-   its fields.  */\n-typedef struct unwind_record\n-{\n-  unw_record_type type;\n-  union {\n-    unw_r_record r;\n-    unw_p_record p;\n-    unw_b_record b;\n-    unw_x_record x;\n-  } record;\n-} unwind_record;\n-\n-#define IA64_UNW_LOC_TYPE_NONE\t\t0\n-#define IA64_UNW_LOC_TYPE_MEM\t\t1\n-#define IA64_UNW_LOC_TYPE_GR\t\t2\n-#define IA64_UNW_LOC_TYPE_FR\t\t3\n-#define IA64_UNW_LOC_TYPE_BR\t\t4\n-#define IA64_UNW_LOC_TYPE_SPOFF\t\t5\n-#define IA64_UNW_LOC_TYPE_PSPOFF\t6\n-#define IA64_UNW_LOC_TYPE_OFFSET\t7\n-#define IA64_UNW_LOC_TYPE_SPILLBASE\t8\n-\n-typedef struct ia64_reg_loc \n-{\n-  long when;\t\t/* PC relative offset from start of function. */\n-  union {\t\t/* In memory or another register?  */\n-    void *mem;\n-    int regno;\n-    int offset;\n-  } l;\n-  short loc_type;\t/* Where to find value.  */\n-  short reg_size;\n-} ia64_reg_loc;\n-\n-/* Frame information record.  */\n-\n-typedef struct ia64_frame_state\n-{\n-  ia64_reg_loc gr[4];\t/* gr4 to  gr7.  */\n-  ia64_reg_loc fr[20];\t/* fr2 to fr5, fr16 to fr31.  */\n-  ia64_reg_loc br[5];\t/* br1 to  br5.  */\n-  ia64_reg_loc rp;\n-  ia64_reg_loc fpsr;\n-  ia64_reg_loc bsp;\n-  ia64_reg_loc bspstore;\n-  ia64_reg_loc rnat;\n-  ia64_reg_loc pfs;\n-  ia64_reg_loc unat;\n-  ia64_reg_loc lc;\n-  ia64_reg_loc pr;\n-  ia64_reg_loc priunat;\n-  ia64_reg_loc sp;\n-  ia64_reg_loc psp;\n-  ia64_reg_loc spill_base;\n-  void *my_psp;\n-  void *my_sp;\n-  void *my_bsp;\n-} ia64_frame_state;\n-\n-/* This structure represents the start of an unwind information pointer.  \n-   'unwind_descriptors' is the beginninng of the unwind descriptors, which\n-   use up 'length' bytes of storage.  */\n-\n-typedef struct unwind_info_ptr \n-{\n-  unsigned long header; /* version, flags, & length */\n-  unsigned char unwind_descriptors[1];\n-} unwind_info_ptr;\n-\n-#define IA64_UNW_HDR_LENGTH(x)\t((x) & 0x00000000ffffffffUL)\n-#define IA64_UNW_HDR_FLAGS(x)\t(((x) >> 32) & 0xffffUL)\n-#define IA64_UNW_HDR_VERSION(x)\t(((x) >> 48) & 0xffffUL)\n-\n-/* Header flag bits, after extraction by IA64_UNW_HDR_FLAGS.  */\n-#define IA64_UNW_EHANDLER\t0x1\n-#define IA64_UNW_UHANDLER\t0x2\n-\n-extern void * __ia64_personality_v1 (void *pc, old_exception_table *table);\n-\n-extern unwind_info_ptr *__build_ia64_frame_state (unsigned char *, \n-\t\t\t\t\t\t  ia64_frame_state *,\n-\t\t\t\t\t\t  void *, void *,\n-\t\t\t\t\t\t  void **);\n-extern void *__get_real_reg_value (ia64_reg_loc *);\n-extern void *__get_personality (unwind_info_ptr *);\n-extern void *__get_except_table (unwind_info_ptr *);\n-extern void __set_real_reg_value (ia64_reg_loc *, void *);\n-void *__calc_caller_bsp (long, unsigned char *);\n-void __copy_saved_reg_state (ia64_frame_state *, ia64_frame_state *);\n-#endif   /* IA64_UNWIND_INFO  */\n-"}, {"sha": "6eebf34f2847e1da81a2f3ad6f09e5ea2b7b8114", "filename": "gcc/function.c", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1580,11 +1580,6 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n \t  end_sequence ();\n \t}\n     }\n-\n-  /* Scan the catch clauses for exception handling too.  */\n-  push_to_full_sequence (catch_clauses, catch_clauses_last);\n-  fixup_var_refs_insns (catch_clauses, var, promoted_mode, unsignedp, 0);\n-  end_full_sequence (&catch_clauses, &catch_clauses_last);\n }\n \f\n /* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is\n@@ -6315,20 +6310,10 @@ expand_function_start (subr, parms_have_cleanups)\n   else\n     cleanup_label = 0;\n \n-  /* Make the label for return statements to jump to, if this machine\n-     does not have a one-instruction return and uses an epilogue,\n-     or if it returns a structure, or if it has parm cleanups.  */\n-#ifdef HAVE_return\n-  if (cleanup_label == 0 && HAVE_return\n-      && ! current_function_instrument_entry_exit\n-      && ! current_function_returns_pcc_struct\n-      && ! (current_function_returns_struct && ! optimize))\n-    return_label = 0;\n-  else\n-    return_label = gen_label_rtx ();\n-#else\n+  /* Make the label for return statements to jump to.  Do not special\n+     case machines with special return instructions -- they will be\n+     handled later during jump, ifcvt, or epilogue creation.  */\n   return_label = gen_label_rtx ();\n-#endif\n \n   /* Initialize rtx used to return the value.  */\n   /* Do this before assign_parms so that we copy the struct value address\n@@ -6370,7 +6355,9 @@ expand_function_start (subr, parms_have_cleanups)\n   else if (DECL_MODE (DECL_RESULT (subr)) == VOIDmode)\n     /* If return mode is void, this decl rtl should not be used.  */\n     SET_DECL_RTL (DECL_RESULT (subr), NULL_RTX);\n-  else if (parms_have_cleanups || current_function_instrument_entry_exit)\n+  else if (parms_have_cleanups\n+\t   || current_function_instrument_entry_exit\n+\t   || (flag_exceptions && USING_SJLJ_EXCEPTIONS))\n     {\n       /* If function will end with cleanup code for parms,\n \t compute the return values into a pseudo reg,\n@@ -6801,27 +6788,6 @@ expand_function_end (filename, line, end_bindings)\n   if (end_bindings)\n     expand_end_bindings (0, 0, 0);\n \n-  /* Now handle any leftover exception regions that may have been\n-     created for the parameters.  */\n-  {\n-    rtx last = get_last_insn ();\n-    rtx label;\n-\n-    expand_leftover_cleanups ();\n-\n-    /* If there are any catch_clauses remaining, output them now.  */\n-    emit_insns (catch_clauses);\n-    catch_clauses = catch_clauses_last = NULL_RTX;\n-    /* If the above emitted any code, may sure we jump around it.  */\n-    if (last != get_last_insn ())\n-      {\n-\tlabel = gen_label_rtx ();\n-\tlast = emit_jump_insn_after (gen_jump (label), last);\n-\tlast = emit_barrier_after (last);\n-\temit_label (label);\n-      }\n-  }\n-\n   if (current_function_instrument_entry_exit)\n     {\n       rtx fun = DECL_RTL (current_function_decl);\n@@ -6837,6 +6803,11 @@ expand_function_end (filename, line, end_bindings)\n \t\t\t Pmode);\n     }\n \n+  /* Let except.c know where it should emit the call to unregister\n+     the function context for sjlj exceptions.  */\n+  if (flag_exceptions && USING_SJLJ_EXCEPTIONS)\n+    sjlj_emit_function_exit_after (get_last_insn ());\n+\n   /* If we had calls to alloca, and this machine needs\n      an accurate stack pointer to exit the function,\n      insert some code to save and restore the stack pointer.  */\n@@ -6944,16 +6915,16 @@ expand_function_end (filename, line, end_bindings)\n       current_function_return_rtx = outgoing;\n     }\n \n+  /* If this is an implementation of throw, do what's necessary to\n+     communicate between __builtin_eh_return and the epilogue.  */\n+  expand_eh_return ();\n+\n   /* ??? This should no longer be necessary since stupid is no longer with\n      us, but there are some parts of the compiler (eg reload_combine, and\n      sh mach_dep_reorg) that still try and compute their own lifetime info\n      instead of using the general framework.  */\n   use_return_register ();\n \n-  /* If this is an implementation of __throw, do what's necessary to\n-     communicate between __builtin_eh_return and the epilogue.  */\n-  expand_eh_return ();\n-\n   /* Output a return insn if we are using one.\n      Otherwise, let the rtl chain end here, to drop through\n      into the epilogue.  */"}, {"sha": "5621c6b581d63e89f536ed90f241cca63c4bd749", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -409,6 +409,9 @@ struct function\n      either as a subroutine or builtin.  */\n   unsigned int calls_alloca : 1;\n \n+  /* Nonzero if the function calls __builtin_eh_return.  */\n+  unsigned int calls_eh_return : 1;\n+\n   /* Nonzero if function being compiled receives nonlocal gotos\n      from nested functions.  */\n   unsigned int has_nonlocal_label : 1;\n@@ -488,6 +491,7 @@ extern struct function *all_functions;\n #define current_function_calls_setjmp (cfun->calls_setjmp)\n #define current_function_calls_alloca (cfun->calls_alloca)\n #define current_function_calls_longjmp (cfun->calls_longjmp)\n+#define current_function_calls_eh_return (cfun->calls_eh_return)\n #define current_function_has_computed_jump (cfun->has_computed_jump)\n #define current_function_contains_functions (cfun->contains_functions)\n #define current_function_is_thunk (cfun->is_thunk)"}, {"sha": "3297107493975bb0588c6423d1829a7b6f8b90cf", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1905,7 +1905,7 @@ find_if_block (test_bb, then_edge, else_edge)\n   /* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we\n      get the first condition for free, since we've already asserted that\n      there's a fallthru edge from IF to THEN.  */\n-  /* ??? As an enhancement, move the ELSE block.  Have to deal with EH and\n+  /* ??? As an enhancement, move the ELSE block.  Have to deal with\n      BLOCK notes, if by no other means than aborting the merge if they\n      exist.  Sticky enough I don't want to think about it now.  */\n   next_index = then_bb->index;\n@@ -2188,15 +2188,6 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n {\n   rtx head, end, jump, earliest, old_dest;\n \n-  /* No code movement can occur if we'd be scrogging EH regions.\n-     Within MERGE_BB, ensure that we've not got stray EH_BEG or EH_END\n-     notes within the block.  Between the blocks, checking that the end\n-     region numbers match ensures that we won't disrupt the nesting\n-     between regions.  */\n-  if (merge_bb->eh_beg != merge_bb->eh_end\n-      || merge_bb->eh_end != test_bb->eh_end)\n-    return FALSE;\n-\n   jump = test_bb->end;\n \n   /* Find the extent of the real code in the merge block.  */"}, {"sha": "ed6540e4bfd779a44b0630ffe78f8738bae71f76", "filename": "gcc/integrate.c", "status": "modified", "additions": 26, "deletions": 66, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -81,12 +81,12 @@ static void set_block_abstract_flags\tPARAMS ((tree, int));\n static void process_reg_param\t\tPARAMS ((struct inline_remap *, rtx,\n \t\t\t\t\t\t rtx));\n void set_decl_abstract_flags\t\tPARAMS ((tree, int));\n-static rtx expand_inline_function_eh_labelmap PARAMS ((rtx));\n static void mark_stores                 PARAMS ((rtx, rtx, void *));\n static void save_parm_insns\t\tPARAMS ((rtx, rtx));\n static void copy_insn_list              PARAMS ((rtx, struct inline_remap *,\n \t\t\t\t\t\t rtx));\n-static void copy_insn_notes\t\tPARAMS ((rtx, struct inline_remap *));\n+static void copy_insn_notes\t\tPARAMS ((rtx, struct inline_remap *,\n+\t\t\t\t\t\t int));\n static int compare_blocks               PARAMS ((const PTR, const PTR));\n static int find_block                   PARAMS ((const PTR, const PTR));\n \n@@ -152,6 +152,9 @@ function_cannot_inline_p (fndecl)\n   if (current_function_calls_setjmp)\n     return N_(\"function using setjmp cannot be inline\");\n \n+  if (current_function_calls_eh_return)\n+    return N_(\"function uses __builtin_eh_return\");\n+\n   if (current_function_contains_functions)\n     return N_(\"function with nested functions cannot be inline\");\n \n@@ -221,19 +224,6 @@ function_cannot_inline_p (fndecl)\n   if (current_function_has_nonlocal_goto)\n     return N_(\"function with nonlocal goto cannot be inline\");\n \n-  /* This is a hack, until the inliner is taught about eh regions at\n-     the start of the function.  */\n-  for (insn = get_insns ();\n-       insn\n-\t && ! (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG);\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (insn && GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n-\treturn N_(\"function with complex parameters cannot be inline\");\n-    }\n-\n   /* We can't inline functions that return a PARALLEL rtx.  */\n   if (DECL_RTL_SET_P (DECL_RESULT (fndecl)))\n     {\n@@ -548,17 +538,6 @@ process_reg_param (map, loc, copy)\n   map->reg_map[REGNO (loc)] = copy;\n }\n \n-/* Used by duplicate_eh_handlers to map labels for the exception table */\n-static struct inline_remap *eif_eh_map;\n-\n-static rtx\n-expand_inline_function_eh_labelmap (label)\n-     rtx label;\n-{\n-  int index = CODE_LABEL_NUMBER (label);\n-  return get_label_from_map (eif_eh_map, index);\n-}\n-\n /* Compare two BLOCKs for qsort.  The key we sort on is the\n    BLOCK_ABSTRACT_ORIGIN of the blocks.  */\n \n@@ -634,6 +613,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   rtvec arg_vector = (rtvec) inl_f->original_arg_vector;\n   rtx static_chain_value = 0;\n   int inl_max_uid;\n+  int eh_region_offset;\n \n   /* The pointer used to track the true location of the memory used\n      for MAP->LABEL_MAP.  */\n@@ -1140,8 +1120,14 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   /* Now copy the insns one by one.  */\n   copy_insn_list (insns, map, static_chain_value);\n \n+  /* Duplicate the EH regions.  This will create an offset from the\n+     region numbers in the function we're inlining to the region\n+     numbers in the calling function.  This must wait until after\n+     copy_insn_list, as we need the insn map to be complete.  */\n+  eh_region_offset = duplicate_eh_regions (inl_f, map);\n+\n   /* Now copy the REG_NOTES for those insns.  */\n-  copy_insn_notes (insns, map);\n+  copy_insn_notes (insns, map, eh_region_offset);\n \n   /* If the insn sequence required one, emit the return label.  */\n   if (map->local_return_label)\n@@ -1260,12 +1246,6 @@ copy_insn_list (insns, map, static_chain_value)\n \t       inline_target.  */\n \t    break;\n \n-\t  /* If the inline fn needs eh context, make sure that\n-\t     the current fn has one.  */\n-\t  if (GET_CODE (pattern) == USE\n-\t      && find_reg_note (insn, REG_EH_CONTEXT, 0) != 0)\n-\t    get_eh_context ();\n-\n \t  /* Ignore setting a function value that we don't want to use.  */\n \t  if (map->inline_target == 0\n \t      && set != 0\n@@ -1526,31 +1506,9 @@ copy_insn_list (insns, map, static_chain_value)\n \t      copy = emit_note (NOTE_SOURCE_FILE (insn),\n \t\t\t\tNOTE_LINE_NUMBER (insn));\n \t      if (copy\n-\t\t  && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n-\t\t      || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END))\n-\t\t{\n-\t\t  rtx label\n-\t\t    = get_label_from_map (map, NOTE_EH_HANDLER (copy));\n-\n-\t\t  /* We have to duplicate the handlers for the original.  */\n-\t\t  if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG)\n-\t\t    {\n-\t\t      /* We need to duplicate the handlers for the EH region\n-\t\t\t and we need to indicate where the label map is */\n-\t\t      eif_eh_map = map;\n-\t\t      duplicate_eh_handlers (NOTE_EH_HANDLER (copy),\n-\t\t\t\t\t     CODE_LABEL_NUMBER (label),\n-\t\t\t\t\t     expand_inline_function_eh_labelmap);\n-\t\t    }\n-\n-\t\t  /* We have to forward these both to match the new exception\n-\t\t     region.  */\n-\t\t  NOTE_EH_HANDLER (copy) = CODE_LABEL_NUMBER (label);\n-\t\t}\n-\t      else if (copy\n-\t\t       && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_BLOCK_BEG\n-\t\t\t   || NOTE_LINE_NUMBER (copy) == NOTE_INSN_BLOCK_END)\n-\t\t       && NOTE_BLOCK (insn))\n+\t\t  && (NOTE_LINE_NUMBER (copy) == NOTE_INSN_BLOCK_BEG\n+\t\t      || NOTE_LINE_NUMBER (copy) == NOTE_INSN_BLOCK_END)\n+\t\t  && NOTE_BLOCK (insn))\n \t\t{\n \t\t  tree *mapped_block_p;\n \n@@ -1587,9 +1545,10 @@ copy_insn_list (insns, map, static_chain_value)\n    that are valid across the entire function.  */\n \n static void\n-copy_insn_notes (insns, map)\n+copy_insn_notes (insns, map, eh_region_offset)\n      rtx insns;\n      struct inline_remap *map;\n+     int eh_region_offset;\n {\n   rtx insn, new_insn;\n \n@@ -1620,6 +1579,9 @@ copy_insn_notes (insns, map)\n \t      next = XEXP (note, 1);\n \t      if (REG_NOTE_KIND (note) == REG_LABEL)\n \t        remove_note (new_insn, note);\n+\t      else if (REG_NOTE_KIND (note) == REG_EH_REGION)\n+\t        XEXP (note, 0) = GEN_INT (INTVAL (XEXP (note, 0))\n+\t\t\t\t\t  + eh_region_offset);\n \t    }\n         }\n \n@@ -1628,8 +1590,12 @@ copy_insn_notes (insns, map)\n \t{\n \t  int i;\n \t  for (i = 0; i < 3; i++)\n-\t    copy_insn_notes (XEXP (PATTERN (insn), i), map);\n+\t    copy_insn_notes (XEXP (PATTERN (insn), i), map, eh_region_offset);\n \t}\n+\n+      if (GET_CODE (insn) == JUMP_INSN\n+\t  && GET_CODE (PATTERN (insn)) == RESX)\n+\tXINT (PATTERN (new_insn), 0) += eh_region_offset;\n     }\n }\n \f\n@@ -2071,12 +2037,6 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t\t\t  copy_rtx_and_substitute (constant, map, for_lhs)),\n \t\t\t 0);\n \t}\n-      else if (SYMBOL_REF_NEED_ADJUST (orig))\n-\t{\n-\t  eif_eh_map = map;\n-\t  return rethrow_symbol_map (orig,\n-\t\t\t\t     expand_inline_function_eh_labelmap);\n-\t}\n \n       return orig;\n "}, {"sha": "48dc795d4d5f7c2990e230a9f63308f62afab183", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,3 +1,34 @@\n+2001-03-28  Richard Henderson  <rth@redhat.com>\n+\n+\tIA-64 ABI Exception Handling:\n+\t* Make-lang.in (except.o): Don't depend on eh-common.h.\n+\t* check-init.c (check_init): Handle EXC_PTR_EXPR.\n+\t* decl.c (init_decl_processing) [throw_node]: No _Jv_Sjlj_Throw.\n+\t[soft_exceptioninfo_call_node]: Remove.\n+\t[eh_personality_libfunc, lang_eh_runtime_type]: New.\n+\t(end_java_method): No emit_handlers.\n+\t* except.c (java_set_exception_lang_code): Remove.\n+\t(method_init_exceptions): Don't call it.\n+\t(prepare_eh_table_type): No CATCH_ALL_TYPE.\n+\t(build_exception_object_ref): New.\n+\t(expand_end_java_handler): Update for except.h name changes.\n+\t(emit_handlers, expand_resume_after_catch): Remove.\n+\t* expr.c (java_lang_expand_expr): Update for except.h name changes.\n+\t(process_jvm_instruction): Use build_exception_object_ref.\n+\t* java-tree.h (JTI_SOFT_EXCEPTIONINFO_CALL_NODE): Remove.\n+\t(soft_exceptioninfo_call_node): Remove.\n+\t(build_exception_object_ref): Declare.\n+\t* jcf-write.c (generate_bytecode_insns) [CALL_EXPR]: No\n+\tsoft_exceptioninfo_call_node.  Move processing ...\n+\t[EXC_PTR_EXPR]: ... here.\n+\t* parse.h (BUILD_ASSIGN_EXCEPTION_INFO): Remove dead code.\n+\t* parse.y (catch_clause_parameter): Use build_exception_object_ref.\n+\t(source_end_java_method): No java_set_exception_lang_code or\n+\temit_handlers.\n+\t(build_dot_class_method): Use build_exception_object_ref.\n+\t(try_reference_assignconv): Check EXC_PTR_EXPR not\n+\tsoft_exceptioninfo_call_node.\n+\n 2001-03-28  Richard Henderson  <rth@redhat.com>\n \n \t* java-tree.h (throw_node): Define as a single member of"}, {"sha": "ebfbd73896d1f5637e963735b9a0dcdcea88314f", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -254,7 +254,7 @@ java/decl.o: java/decl.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   toplev.h $(SYSTEM_H) function.h gcc.h\n java/except.o: java/except.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h real.h \\\n   $(RTL_H) java/javaop.h java/java-opcodes.h except.h java/java-except.h \\\n-  eh-common.h toplev.h $(SYSTEM_H) function.h\n+  toplev.h $(SYSTEM_H) function.h\n java/expr.o: java/expr.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h real.h \\\n   $(RTL_H) $(EXPR_H) java/javaop.h java/java-opcodes.h except.h \\\n   java/java-except.h java/java-except.h java/parse.h toplev.h \\"}, {"sha": "c34822084ec245997b8552d15f23fe571585b0e7", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -681,6 +681,7 @@ check_init (exp, before)\n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n+    case EXC_PTR_EXPR:\n       break;\n \n     case NEW_CLASS_EXPR:"}, {"sha": "7d03f8a4f3e1a939345a973a5f1d75f40897679f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -29,12 +29,14 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"rtl.h\"\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"java-tree.h\"\n #include \"jcf.h\"\n #include \"toplev.h\"\n #include \"function.h\"\n+#include \"expr.h\"\n #include \"except.h\"\n #include \"java-except.h\"\n #include \"ggc.h\"\n@@ -725,13 +727,14 @@ init_decl_processing ()\n \t\t\t\t\t\t\t       t),\n \t\t\t\t\t  0, NOT_BUILT_IN,\n \t\t\t\t\t  NULL_PTR);\n-  throw_node = builtin_function ((USING_SJLJ_EXCEPTIONS\n-\t\t\t\t  ? \"_Jv_Throw\" : \"_Jv_Sjlj_Throw\"),\n+\n+  throw_node = builtin_function (\"_Jv_Throw\",\n \t\t\t\t build_function_type (ptr_type_node, t),\n \t\t\t\t 0, NOT_BUILT_IN, NULL_PTR);\n   /* Mark throw_nodes as `noreturn' functions with side effects.  */\n   TREE_THIS_VOLATILE (throw_node) = 1;\n   TREE_SIDE_EFFECTS (throw_node) = 1;\n+\n   t = build_function_type (int_type_node, endlink);\n   soft_monitorenter_node \n     = builtin_function (\"_Jv_MonitorEnter\", t, 0, NOT_BUILT_IN,\n@@ -834,15 +837,6 @@ init_decl_processing ()\n \t\t\tbuild_function_type (double_type_node, t),\n \t\t\tBUILT_IN_FMOD, BUILT_IN_NORMAL, \"fmod\");\n \n-  soft_exceptioninfo_call_node\n-    = build (CALL_EXPR, \n-\t     ptr_type_node,\n-\t     build_address_of \n-\t       (builtin_function (\"_Jv_exception_info\", \n-\t\t\t\t  build_function_type (ptr_type_node, endlink),\n-\t\t\t\t  0, NOT_BUILT_IN, NULL_PTR)),\n-\t     NULL_TREE, NULL_TREE);\n-  TREE_SIDE_EFFECTS (soft_exceptioninfo_call_node) = 1;\n #if 0\n   t = tree_cons (NULL_TREE, float_type_node,\n \t\t tree_cons (NULL_TREE, float_type_node, endlink));\n@@ -872,6 +866,12 @@ init_decl_processing ()\n \t\t\tbuild_function_type (long_type_node, t),\n \t\t\t0, NOT_BUILT_IN, NULL_PTR);\n \n+  /* Initialize variables for except.c.  */\n+  eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+                                             ? \"__gcj_personality_sj0\"\n+                                             : \"__gcj_personality_v0\");\n+  lang_eh_runtime_type = prepare_eh_table_type;\n+\n   init_jcf_parse ();\n \n   /* Register nodes with the garbage collector.  */\n@@ -1828,8 +1828,6 @@ end_java_method ()\n \n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n-  emit_handlers ();\n-\n   /* Generate rtl for function exit.  */\n   expand_function_end (input_filename, lineno, 0);\n "}, {"sha": "184f7e5a88be2b1d34966e4b4e8388ed62b15c15", "filename": "gcc/java/except.c", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -34,7 +34,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"function.h\"\n #include \"except.h\"\n #include \"java-except.h\"\n-#include \"eh-common.h\"\n #include \"toplev.h\"\n \n static void expand_start_java_handler PARAMS ((struct eh_range *));\n@@ -250,14 +249,6 @@ method_init_exceptions ()\n   whole_range.first_child = NULL;\n   whole_range.next_sibling = NULL;\n   cache_range_start = 0xFFFFFF;\n-  java_set_exception_lang_code ();\n-}\n-\n-void\n-java_set_exception_lang_code ()\n-{\n-  set_exception_lang_code (EH_LANG_Java);\n-  set_exception_version_code (1);\n }\n \n /* Add an exception range.  If we already have an exception range\n@@ -339,7 +330,7 @@ prepare_eh_table_type (type)\n    * (which yields a value with low-order bit 1). */\n \n   if (type == NULL_TREE)\n-    exp = CATCH_ALL_TYPE;\n+    exp = NULL_TREE;\n   else if (is_compiled_class (type))\n     exp = build_class_ref (type);\n   else\n@@ -350,7 +341,27 @@ prepare_eh_table_type (type)\n   return exp;\n }\n \n-/* if there are any handlers for this range, isssue end of range,\n+\n+/* Build a reference to the jthrowable object being carried in the\n+   exception header.  */\n+\n+tree\n+build_exception_object_ref (type)\n+     tree type;\n+{\n+  tree obj;\n+\n+  /* Java only passes object via pointer and doesn't require adjusting.\n+     The java object is immediately before the generic exception header.  */\n+  obj = build (EXC_PTR_EXPR, build_pointer_type (type));\n+  obj = build (MINUS_EXPR, TREE_TYPE (obj), obj,\n+\t       TYPE_SIZE_UNIT (TREE_TYPE (obj)));\n+  obj = build1 (INDIRECT_REF, type, obj);\n+\n+  return obj;\n+}\n+\n+/* If there are any handlers for this range, isssue end of range,\n    and then all handler blocks */\n static void\n expand_end_java_handler (range)\n@@ -361,11 +372,9 @@ expand_end_java_handler (range)\n   expand_start_all_catch ();\n   for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n     {\n-      start_catch_handler (prepare_eh_table_type (TREE_PURPOSE (handler)));\n-      /* Push the thrown object on the top of the stack */\n+      expand_start_catch (TREE_PURPOSE (handler));\n       expand_goto (TREE_VALUE (handler));\n-      expand_resume_after_catch ();\n-      end_catch_handler ();\n+      expand_end_catch ();\n     }\n   expand_end_all_catch ();\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n@@ -432,30 +441,3 @@ maybe_end_try (start_pc, end_pc)\n       current_range = current_range->outer;\n     }\n }\n-\n-/* Emit the handler labels and their code */\n-\n-void\n-emit_handlers ()\n-{\n-  if (catch_clauses)\n-    {\n-      rtx funcend = gen_label_rtx ();\n-      emit_jump (funcend);\n-\n-      emit_insns (catch_clauses);\n-      catch_clauses = catch_clauses_last = NULL_RTX;\n-      expand_leftover_cleanups ();\n-\n-      emit_label (funcend);\n-    }\n-}\n-\n-/* Resume executing at the statement immediately after the end of an\n-   exception region. */\n-\n-void\n-expand_resume_after_catch ()\n-{\n-  expand_goto (top_label_entry (&caught_return_label_stack));\n-}"}, {"sha": "072be6dea94910209d0c904b20ed94658c46d2cf", "filename": "gcc/java/expr.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -2502,15 +2502,13 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       for (current = TREE_OPERAND (exp, 1); current; \n \t   current = TREE_CHAIN (current))\n \t{\n-\t  tree type;\n \t  tree catch = TREE_OPERAND (current, 0);\n \t  tree decl = BLOCK_EXPR_DECLS (catch);\n-\t  type = (decl ? TREE_TYPE (TREE_TYPE (decl)) : NULL_TREE);\n-\t  start_catch_handler (prepare_eh_table_type (type));\n-\t  expand_expr_stmt (TREE_OPERAND (current, 0));\n+\t  tree type = (decl ? TREE_TYPE (TREE_TYPE (decl)) : NULL_TREE);\n \n-\t  expand_resume_after_catch ();\n-\t  end_catch_handler ();\n+\t  expand_start_catch (type);\n+\t  expand_expr_stmt (TREE_OPERAND (current, 0));\n+\t  expand_end_catch ();\n \t}\n       expand_end_all_catch ();\n       return const0_rtx;\n@@ -2812,7 +2810,7 @@ process_jvm_instruction (PC, byte_ops, length)\n   if (instruction_bits [PC] & BCODE_EXCEPTION_TARGET)\n     {\n       tree type = pop_type (ptr_type_node);\n-      push_value (build1 (NOP_EXPR, type, soft_exceptioninfo_call_node));\n+      push_value (build_exception_object_ref (type));\n     }\n \n   switch (byte_ops[PC++])"}, {"sha": "598caf4a46a75e6caff5925c9c1b1b9121410bbe", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -339,7 +339,6 @@ enum java_tree_index\n   JTI_SOFT_GETJNIENVNEWFRAME_NODE,\n   JTI_SOFT_JNIPOPSYSTEMFRAME_NODE,\n   JTI_SOFT_FMOD_NODE,\n-  JTI_SOFT_EXCEPTIONINFO_CALL_NODE,\n   JTI_SOFT_IDIV_NODE,\n   JTI_SOFT_IREM_NODE,\n   JTI_SOFT_LDIV_NODE,\n@@ -581,8 +580,6 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_SOFT_JNIPOPSYSTEMFRAME_NODE]\n #define soft_fmod_node \\\n   java_global_trees[JTI_SOFT_FMOD_NODE]\n-#define soft_exceptioninfo_call_node \\\n-  java_global_trees[JTI_SOFT_EXCEPTIONINFO_CALL_NODE]\n #define soft_idiv_node \\\n   java_global_trees[JTI_SOFT_IDIV_NODE]\n #define soft_irem_node \\\n@@ -1026,6 +1023,7 @@ extern tree build_instanceof PARAMS ((tree, tree));\n extern tree create_label_decl PARAMS ((tree));\n extern void push_labeled_block PARAMS ((tree));\n extern tree prepare_eh_table_type PARAMS ((tree));\n+extern tree build_exception_object_ref PARAMS ((tree));\n extern void java_set_exception_lang_code PARAMS ((void));\n extern tree generate_name PARAMS ((void));\n extern void pop_labeled_block PARAMS ((void));"}, {"sha": "79ac6916679e45a2d7cedec0599b725ac1192b51", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -2451,6 +2451,9 @@ generate_bytecode_insns (exp, target, state)\n \t  }\n       }\n       break;\n+    case EXC_PTR_EXPR:\n+      NOTE_PUSH (1);  /* Pushed by exception system. */\n+      break;\n     case NEW_CLASS_EXPR:\n       {\n \ttree class = TREE_TYPE (TREE_TYPE (exp));\n@@ -2527,11 +2530,6 @@ generate_bytecode_insns (exp, target, state)\n \t    NOTE_POP (1);\n \t    break;\n \t  }\n-\telse if (exp == soft_exceptioninfo_call_node)\n-\t  {\n-\t    NOTE_PUSH (1);  /* Pushed by exception system. */\n-\t    break;\n-\t  }\n \tfor ( ;  x != NULL_TREE;  x = TREE_CHAIN (x))\n \t  {\n \t    generate_bytecode_insns (TREE_VALUE (x), STACK_TARGET, state);"}, {"sha": "d17dbc0d1cb3818e1f36cb5d10074efa0c3557a3", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -661,14 +661,6 @@ typedef struct _jdeplist {\n   build_new_invocation (wfl_string_buffer, \t\t\t\t      \\\n \t\t\t(ARG ? build_tree_list (NULL, (ARG)) : NULL_TREE))\n \n-/* For exception handling, build diverse function calls */\n-#define BUILD_ASSIGN_EXCEPTION_INFO(WHERE, TO)\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    (WHERE) = build (MODIFY_EXPR, void_type_node, (TO),\t\\\n-\t\t     soft_exceptioninfo_call_node);\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\\\n-  }\n-\n #define BUILD_THROW(WHERE, WHAT)\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     (WHERE) = \t\t\t\t\t\t\t\\"}, {"sha": "d377e8fe59d7dc77fa396aa4fb7d64669a000acb", "filename": "gcc/java/parse.y", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1885,9 +1885,9 @@ catch_clause_parameter:\n \t\t     declared initialized by the appropriate function\n \t\t     call */\n \t\t  tree ccpb = enter_block ();\n-\t\t  tree init = build_assignment (ASSIGN_TK, $2.location, \n-\t\t\t\t\t\tTREE_PURPOSE ($3), \n-\t\t\t\t\t\tsoft_exceptioninfo_call_node);\n+\t\t  tree init = build_assignment\n+\t\t    (ASSIGN_TK, $2.location, TREE_PURPOSE ($3), \n+\t\t     build_exception_object_ref (ptr_type_node));\n \t\t  declare_local_variables (0, TREE_VALUE ($3),\n \t\t\t\t\t   build_tree_list (TREE_PURPOSE ($3),\n \t\t\t\t\t\t\t    init));\n@@ -7124,9 +7124,6 @@ source_end_java_method ()\n   java_parser_context_save_global ();\n   lineno = ctxp->last_ccb_indent1;\n \n-  /* Set EH language codes */\n-  java_set_exception_lang_code ();\n-\n   /* Turn function bodies with only a NOP expr null, so they don't get\n      generated at all and we won't get warnings when using the -W\n      -Wall flags. */\n@@ -7148,8 +7145,6 @@ source_end_java_method ()\n   if (! flag_emit_class_files && ! flag_emit_xref)\n     {\n       lineno = DECL_SOURCE_LINE_LAST (fndecl);\n-      /* Emit catch-finally clauses */\n-      emit_handlers ();\n       expand_function_end (input_filename, lineno, 0);\n \n       /* Run the optimizers and output assembler code for this function. */\n@@ -8405,7 +8400,7 @@ build_dot_class_method (class)\n   \n   /* We initialize the variable with the exception handler. */\n   catch = build (MODIFY_EXPR, NULL_TREE, catch_clause_param,\n-\t\t soft_exceptioninfo_call_node);\n+\t\t build_exception_object_ref (ptr_type_node));\n   add_stmt_to_block (catch_block, NULL_TREE, catch);\n \n   /* We add the statement throwing the new exception */\n@@ -12609,7 +12604,7 @@ try_reference_assignconv (lhs_type, rhs)\n       else if (valid_ref_assignconv_cast_p (rhs_type, lhs_type, 0))\n \tnew_rhs = rhs;\n       /* This is a magic assignment that we process differently */\n-      else if (rhs == soft_exceptioninfo_call_node)\n+      else if (TREE_CODE (rhs) == EXC_PTR_EXPR)\n \tnew_rhs = rhs;\n     }\n   return new_rhs;"}, {"sha": "2b111d4bd59b5327744091daaa69f00a6341cd86", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -213,12 +213,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n   cross_jump_death_matters = (cross_jump == 2);\n   max_uid = init_label_info (f) + 1;\n \n-  /* If we are performing cross jump optimizations, then initialize\n-     tables mapping UIDs to EH regions to avoid incorrect movement\n-     of insns from one EH region to another.  */\n-  if (flag_exceptions && cross_jump)\n-    init_insn_eh_region (f, max_uid);\n-\n   if (! mark_labels_only)\n     delete_barrier_successors (f);\n \n@@ -237,8 +231,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n     if (GET_CODE (XEXP (insn, 0)) == CODE_LABEL)\n       LABEL_NUSES (XEXP (insn, 0))++;\n \n-  check_exception_handler_labels ();\n-\n   /* Keep track of labels used for marking handlers for exception\n      regions; they cannot usually be deleted.  */\n \n@@ -251,9 +243,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n   if (mark_labels_only)\n     goto end;\n \n-  if (! minimal)\n-    exception_optimize ();\n-\n   last_insn = delete_unreferenced_labels (f);\n \n   if (noop_moves)\n@@ -1444,13 +1433,6 @@ find_cross_jump (e1, e2, minimum, f1, f2)\n       if (i2 == 0 || GET_CODE (i1) != GET_CODE (i2))\n \tbreak;\n \n-      /* Avoid moving insns across EH regions if either of the insns\n-\t can throw.  */\n-      if (flag_exceptions\n-\t  && (flag_non_call_exceptions || GET_CODE (i1) == CALL_INSN)\n-\t  && !in_same_eh_region (i1, i2))\n-\tbreak;\n-\n       p1 = PATTERN (i1);\n       p2 = PATTERN (i2);\n "}, {"sha": "483d95d0c4e395d0d8600b0afee4c9b755347c25", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -114,28 +114,27 @@ GCC_3.0 {\n   __gcc_bcmp\n \n   # EH symbols\n-  __default_terminate\n+  _Unwind_DeleteException\n+  _Unwind_ForcedUnwind\n+  _Unwind_GetGR\n+  _Unwind_GetIP\n+  _Unwind_GetLanguageSpecificData\n+  _Unwind_GetRegionStart\n+  _Unwind_RaiseException\n+  _Unwind_Resume\n+  _Unwind_SetGR\n+  _Unwind_SetIP\n   __deregister_frame\n   __deregister_frame_info\n-  __eh_alloc\n-  __eh_free\n-  __eh_rtime_match\n-  __frame_state_for\n-  __get_dynamic_handler_chain\n-  __get_eh_context\n-  __get_eh_info\n-  __get_eh_table_language\n-  __get_eh_table_version\n   __register_frame\n   __register_frame_info\n   __register_frame_info_table\n   __register_frame_table\n-  __rethrow\n-  __sjpopnthrow\n-  __sjthrow\n-  __terminate\n-  __terminate_set_func\n-  __throw\n-  __throw_type_match\n-  __unwinding_cleanup\n+\n+  # SjLj EH symbols\n+  _Unwind_SjLj_Register\n+  _Unwind_SjLj_Unregister\n+  _Unwind_SjLj_RaiseException\n+  _Unwind_SjLj_ForcedUnwind\n+  _Unwind_SjLj_Resume\n }"}, {"sha": "140f1f74fc37ba22a885eae45cd4b769756a47ef", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 0, "deletions": 1218, "changes": 1218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -3129,1221 +3129,3 @@ atexit (func_ptr func)\n #endif /* NEED_ATEXIT */\n \n #endif /* L_exit */\n-\f\n-#ifdef L_eh\n-\n-#include \"gthr.h\"\n-\n-/* Shared exception handling support routines.  */\n-\n-void\n-__default_terminate (void)\n-{\n-  abort ();\n-}\n-\n-static __terminate_func_ptr __terminate_func =\n-  __default_terminate;\n-\n-void __attribute__((__noreturn__))\n-__terminate (void)\n-{\n-  (*__terminate_func)();\n-}\n-\n-__terminate_func_ptr\n-__terminate_set_func (__terminate_func_ptr newfunc)\n-{\n-  __terminate_func_ptr oldfunc = __terminate_func;\n-\n-  __terminate_func = newfunc;\n-  return (oldfunc);\n-}\n-\n-void *\n-__throw_type_match (void *catch_type, void *throw_type, void *obj)\n-{\n-#if 0\n- printf (\"__throw_type_match (): catch_type = %s, throw_type = %s\\n\",\n-\t catch_type, throw_type);\n-#endif\n- if (strcmp ((const char *)catch_type, (const char *)throw_type) == 0)\n-   return obj;\n- return 0;\n-}\n-\n-void\n-__empty (void)\n-{\n-}\n-\f\n-\n-/* Include definitions of EH context and table layout */\n-\n-#include \"eh-common.h\"\n-#ifndef inhibit_libc\n-#include <stdio.h>\n-#endif\n-\n-/* Allocate and return a new EH context structure. */\n-\n-#if __GTHREADS\n-static void *\n-new_eh_context (void)\n-{\n-  struct eh_full_context {\n-    struct eh_context c;\n-    void *top_elt[2];\n-  } *ehfc = (struct eh_full_context *) malloc (sizeof *ehfc);\n-\n-  if (! ehfc)\n-    __terminate ();\n-\n-  memset (ehfc, 0, sizeof *ehfc);\n-\n-  ehfc->c.dynamic_handler_chain = (void **) ehfc->top_elt;\n-\n-  /* This should optimize out entirely.  This should always be true,\n-     but just in case it ever isn't, don't allow bogus code to be\n-     generated.  */\n-\n-  if ((void*)(&ehfc->c) != (void*)ehfc)\n-    __terminate ();\n-\n-  return &ehfc->c;\n-}\n-\n-static __gthread_key_t eh_context_key;\n-\n-/* Destructor for struct eh_context. */\n-static void\n-eh_context_free (void *ptr)\n-{\n-  __gthread_key_dtor (eh_context_key, ptr);\n-  if (ptr)\n-    free (ptr);\n-}\n-#endif\n-\n-/* Pointer to function to return EH context. */\n-\n-static struct eh_context *eh_context_initialize (void);\n-static struct eh_context *eh_context_static (void);\n-#if __GTHREADS\n-static struct eh_context *eh_context_specific (void);\n-#endif\n-\n-static struct eh_context *(*get_eh_context) (void) = &eh_context_initialize;\n-\n-/* Routine to get EH context.\n-   This one will simply call the function pointer. */\n-\n-void *\n-__get_eh_context (void)\n-{\n-  return (void *) (*get_eh_context) ();\n-}\n-\n-/* Get and set the language specific info pointer. */\n-\n-void **\n-__get_eh_info (void)\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  return &eh->info;\n-}\n-\f\n-#ifdef DWARF2_UNWIND_INFO\n-static int dwarf_reg_size_table_initialized = 0;\n-static char dwarf_reg_size_table[DWARF_FRAME_REGISTERS];\n-\n-static void\n-init_reg_size_table (void)\n-{\n-  __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);\n-  dwarf_reg_size_table_initialized = 1;\n-}\n-#endif\n-\n-#if __GTHREADS\n-static void\n-eh_threads_initialize (void)\n-{\n-  /* Try to create the key.  If it fails, revert to static method,\n-     otherwise start using thread specific EH contexts. */\n-  if (__gthread_key_create (&eh_context_key, &eh_context_free) == 0)\n-    get_eh_context = &eh_context_specific;\n-  else\n-    get_eh_context = &eh_context_static;\n-}\n-#endif /* no __GTHREADS */\n-\n-/* Initialize EH context.\n-   This will be called only once, since we change GET_EH_CONTEXT\n-   pointer to another routine. */\n-\n-static struct eh_context *\n-eh_context_initialize (void)\n-{\n-#if __GTHREADS\n-\n-  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-  /* Make sure that get_eh_context does not point to us anymore.\n-     Some systems have dummy thread routines in their libc that\n-     return a success (Solaris 2.6 for example). */\n-  if (__gthread_once (&once, eh_threads_initialize) != 0\n-      || get_eh_context == &eh_context_initialize)\n-    {\n-      /* Use static version of EH context. */\n-      get_eh_context = &eh_context_static;\n-    }\n-#ifdef DWARF2_UNWIND_INFO\n-  {\n-    static __gthread_once_t once_regsizes = __GTHREAD_ONCE_INIT;\n-    if (__gthread_once (&once_regsizes, init_reg_size_table) != 0\n-\t|| ! dwarf_reg_size_table_initialized)\n-      init_reg_size_table ();\n-  }\n-#endif\n-\n-#else /* no __GTHREADS */\n-\n-  /* Use static version of EH context. */\n-  get_eh_context = &eh_context_static;\n-\n-#ifdef DWARF2_UNWIND_INFO\n-  init_reg_size_table ();\n-#endif\n-\n-#endif /* no __GTHREADS */\n-\n-  return (*get_eh_context) ();\n-}\n-\n-/* Return a static EH context. */\n-\n-static struct eh_context *\n-eh_context_static (void)\n-{\n-  static struct eh_context eh;\n-  static int initialized;\n-  static void *top_elt[2];\n-\n-  if (! initialized)\n-    {\n-      initialized = 1;\n-      memset (&eh, 0, sizeof eh);\n-      eh.dynamic_handler_chain = top_elt;\n-    }\n-  return &eh;\n-}\n-\n-#if __GTHREADS\n-/* Return a thread specific EH context. */\n-\n-static struct eh_context *\n-eh_context_specific (void)\n-{\n-  struct eh_context *eh;\n-  eh = (struct eh_context *) __gthread_getspecific (eh_context_key);\n-  if (! eh)\n-    {\n-      eh = new_eh_context ();\n-      if (__gthread_setspecific (eh_context_key, (void *) eh) != 0)\n-\t__terminate ();\n-    }\n-\n-  return eh;\n-}\n-#endif /* __GTHREADS */\n-\f\n-/* Support routines for alloc/free during exception handling */\n-\n-/* __eh_alloc and __eh_free attempt allocation using malloc, but fall back to\n-   the small arena in the eh_context. This is needed because throwing an\n-   out-of-memory exception would fail otherwise. The emergency space is\n-   allocated in blocks of size EH_ALLOC_ALIGN, the\n-   minimum allocation being two blocks. A bitmask indicates which blocks\n-   have been allocated. To indicate the size of an allocation, the bit for\n-   the final block is not set. Hence each allocation is a run of 1s followed\n-   by a zero. */\n-void *\n-__eh_alloc (size_t size)\n-{\n-  void *p;\n-  \n-  if (!size)\n-    abort();\n-  p = malloc (size);\n-  if (p == 0)\n-    {\n-      struct eh_context *eh = __get_eh_context ();\n-      unsigned blocks = (size + EH_ALLOC_ALIGN - 1) / EH_ALLOC_ALIGN;\n-      unsigned real_mask = eh->alloc_mask | (eh->alloc_mask << 1);\n-      unsigned our_mask;\n-      unsigned ix;\n-      \n-      if (blocks > EH_ALLOC_SIZE / EH_ALLOC_ALIGN)\n-        __terminate ();\n-      blocks += blocks == 1;\n-      our_mask = (1 << blocks) - 1;\n-      \n-      for (ix = EH_ALLOC_SIZE / EH_ALLOC_ALIGN - blocks; ix; ix--)\n-\tif (! ((real_mask >> ix) & our_mask))\n-\t  {\n-\t    /* found some space */\n-\t    p = &eh->alloc_buffer[ix * EH_ALLOC_ALIGN];\n-\t    eh->alloc_mask |= (our_mask >> 1) << ix;\n-\t    return p;\n-\t  }\n-      __terminate ();\n-    }\n-  return p;\n-}\n-\n-/* Free the memory for an cp_eh_info and associated exception, given\n-   a pointer to the cp_eh_info.  */\n-void\n-__eh_free (void *p)\n-{\n-  struct eh_context *eh = __get_eh_context ();\n-\n-  ptrdiff_t  diff = (char *)p - &eh->alloc_buffer[0];\n-  if (diff >= 0 && diff < EH_ALLOC_SIZE)\n-    {\n-      unsigned mask = eh->alloc_mask;\n-      unsigned bit = 1 << (diff / EH_ALLOC_ALIGN);\n-      \n-      do\n-\t{\n-\t  mask ^= bit;\n-\t  bit <<= 1;\n-\t}\n-      while (mask & bit);\n-      eh->alloc_mask = mask;\n-    }\n-  else\n-    free (p);\n-}\n-\f\n-/* Support routines for setjmp/longjmp exception handling.  */\n-\n-/* Calls to __sjthrow are generated by the compiler when an exception\n-   is raised when using the setjmp/longjmp exception handling codegen\n-   method.  */\n-\n-#ifdef DONT_USE_BUILTIN_SETJMP\n-extern void longjmp (void *, int);\n-#endif\n-\n-/* Routine to get the head of the current thread's dynamic handler chain\n-   use for exception handling. */\n-\n-void ***\n-__get_dynamic_handler_chain (void)\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  return &eh->dynamic_handler_chain;\n-}\n-\n-/* This is used to throw an exception when the setjmp/longjmp codegen\n-   method is used for exception handling.\n-\n-   We call __terminate if there are no handlers left.  Otherwise we run the\n-   cleanup actions off the dynamic cleanup stack, and pop the top of the\n-   dynamic handler chain, and use longjmp to transfer back to the associated\n-   handler.  */\n-\n-void\n-__sjthrow (void)\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  void ***dhc = &eh->dynamic_handler_chain;\n-  void *jmpbuf;\n-  void (*func)(void *, int);\n-  void *arg;\n-  /* The cleanup chain is one word into the buffer.  Get the cleanup chain. */\n-  void ***cleanup = (void***)&(*dhc)[1];\n-\n-  /* If there are any cleanups in the chain, run them now.  */\n-  if (cleanup[0])\n-    {\n-      double store[200];\n-      void **buf = (void**)store;\n-      buf[1] = 0;\n-      buf[0] = (*dhc);\n-\n-      /* try { */\n-#ifdef DONT_USE_BUILTIN_SETJMP\n-      if (! setjmp (&buf[2]))\n-#else\n-      if (! __builtin_setjmp (&buf[2]))\n-#endif\n-\t{\n-\t  *dhc = buf;\n-\t  while (cleanup[0])\n-\t    {\n-\t      func = (void(*)(void*, int))cleanup[0][1];\n-\t      arg = (void*)cleanup[0][2];\n-\n-\t      /* Update this before running the cleanup.  */\n-\t      cleanup[0] = (void **)cleanup[0][0];\n-\n-\t      (*func)(arg, 2);\n-\t    }\n-\t  *dhc = buf[0];\n-\t}\n-      /* catch (...) */\n-      else\n-\t{\n-\t  __terminate ();\n-\t}\n-    }\n-  \n-  /* We must call terminate if we try and rethrow an exception, when\n-     there is no exception currently active and when there are no\n-     handlers left.  */\n-  if (! eh->info || (*dhc)[0] == 0)\n-    __terminate ();\n-    \n-  /* Find the jmpbuf associated with the top element of the dynamic\n-     handler chain.  The jumpbuf starts two words into the buffer.  */\n-  jmpbuf = &(*dhc)[2];\n-\n-  /* Then we pop the top element off the dynamic handler chain.  */\n-  *dhc = (void**)(*dhc)[0];\n-\n-  /* And then we jump to the handler.  */\n-\n-#ifdef DONT_USE_BUILTIN_SETJMP\n-  longjmp (jmpbuf, 1);\n-#else\n-  __builtin_longjmp (jmpbuf, 1);\n-#endif\n-}\n-\n-/* Run cleanups on the dynamic cleanup stack for the current dynamic\n-   handler, then pop the handler off the dynamic handler stack, and\n-   then throw.  This is used to skip the first handler, and transfer\n-   control to the next handler in the dynamic handler stack.  */\n-\n-void\n-__sjpopnthrow (void)\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  void ***dhc = &eh->dynamic_handler_chain;\n-  void (*func)(void *, int);\n-  void *arg;\n-  /* The cleanup chain is one word into the buffer.  Get the cleanup chain. */\n-  void ***cleanup = (void***)&(*dhc)[1];\n-\n-  /* If there are any cleanups in the chain, run them now.  */\n-  if (cleanup[0])\n-    {\n-      double store[200];\n-      void **buf = (void**)store;\n-      buf[1] = 0;\n-      buf[0] = (*dhc);\n-\n-      /* try { */\n-#ifdef DONT_USE_BUILTIN_SETJMP\n-      if (! setjmp (&buf[2]))\n-#else\n-      if (! __builtin_setjmp (&buf[2]))\n-#endif\n-\t{\n-\t  *dhc = buf;\n-\t  while (cleanup[0])\n-\t    {\n-\t      func = (void(*)(void*, int))cleanup[0][1];\n-\t      arg = (void*)cleanup[0][2];\n-\n-\t      /* Update this before running the cleanup.  */\n-\t      cleanup[0] = (void **)cleanup[0][0];\n-\n-\t      (*func)(arg, 2);\n-\t    }\n-\t  *dhc = buf[0];\n-\t}\n-      /* catch (...) */\n-      else\n-\t{\n-\t  __terminate ();\n-\t}\n-    }\n-\n-  /* Then we pop the top element off the dynamic handler chain.  */\n-  *dhc = (void**)(*dhc)[0];\n-\n-  __sjthrow ();\n-}\n-\f\n-/* Support code for all exception region-based exception handling.  */\n-\n-int\n-__eh_rtime_match (void *rtime)\n-{\n-  void *info;\n-  __eh_matcher matcher;\n-  void *ret;\n-\n-  info = *(__get_eh_info ());\n-  matcher = ((__eh_info *)info)->match_function;\n-  if (! matcher)\n-    {\n-#ifndef inhibit_libc\n-      fprintf (stderr, \"Internal Compiler Bug: No runtime type matcher.\");\n-#endif\n-      return 0;\n-    }\n-  ret = (*matcher) (info, rtime, (void *)0);\n-  return (ret != NULL);\n-}\n-\n-/* This value identifies the place from which an exception is being\n-   thrown.  */\n-\n-#ifdef EH_TABLE_LOOKUP\n-\n-EH_TABLE_LOOKUP\n-\n-#else\n-\n-#ifdef DWARF2_UNWIND_INFO\n-\n-/* Return the table version of an exception descriptor */\n-\n-short \n-__get_eh_table_version (exception_descriptor *table) \n-{\n-  return table->lang.version;\n-}\n-\n-/* Return the originating table language of an exception descriptor */\n-\n-short \n-__get_eh_table_language (exception_descriptor *table)\n-{\n-  return table->lang.language;\n-}\n-\n-/* This routine takes a PC and a pointer to the exception region TABLE for\n-   its translation unit, and returns the address of the exception handler\n-   associated with the closest exception table handler entry associated\n-   with that PC, or 0 if there are no table entries the PC fits in.\n-\n-   In the advent of a tie, we have to give the last entry, as it represents\n-   an inner block.  */\n-\n-static void *\n-old_find_exception_handler (void *pc, old_exception_table *table)\n-{\n-  if (table)\n-    {\n-      int pos;\n-      int best = -1;\n-\n-      /* We can't do a binary search because the table isn't guaranteed\n-         to be sorted from function to function.  */\n-      for (pos = 0; table[pos].start_region != (void *) -1; ++pos)\n-        {\n-          if (table[pos].start_region <= pc && table[pos].end_region > pc)\n-            {\n-              /* This can apply.  Make sure it is at least as small as\n-                 the previous best.  */\n-              if (best == -1 || (table[pos].end_region <= table[best].end_region\n-                        && table[pos].start_region >= table[best].start_region))\n-                best = pos;\n-            }\n-          /* But it is sorted by starting PC within a function.  */\n-          else if (best >= 0 && table[pos].start_region > pc)\n-            break;\n-        }\n-      if (best != -1)\n-        return table[best].exception_handler;\n-    }\n-\n-  return (void *) 0;\n-}\n-\n-/* find_exception_handler finds the correct handler, if there is one, to\n-   handle an exception.\n-   returns a pointer to the handler which controlled should be transferred\n-   to, or NULL if there is nothing left.\n-   Parameters:\n-   PC - pc where the exception originates. If this is a rethrow, \n-        then this starts out as a pointer to the exception table\n-\tentry we wish to rethrow out of.\n-   TABLE - exception table for the current module.\n-   EH_INFO - eh info pointer for this exception.\n-   RETHROW - 1 if this is a rethrow. (see incoming value of PC).\n-   CLEANUP - returned flag indicating whether this is a cleanup handler.\n-*/\n-static void *\n-find_exception_handler (void *pc, exception_descriptor *table, \n-                        __eh_info *eh_info, int rethrow, int *cleanup)\n-{\n-\n-  void *retval = NULL;\n-  *cleanup = 1;\n-  if (table)\n-    {\n-      int pos = 0;\n-      /* The new model assumed the table is sorted inner-most out so the\n-         first region we find which matches is the correct one */\n-\n-      exception_table *tab = &(table->table[0]);\n-\n-      /* Subtract 1 from the PC to avoid hitting the next region */\n-      if (rethrow) \n-        {\n-          /* pc is actually the region table entry to rethrow out of */\n-          pos = ((exception_table *) pc) - tab;\n-          pc = ((exception_table *) pc)->end_region - 1;\n-\n-          /* The label is always on the LAST handler entry for a region, \n-             so we know the next entry is a different region, even if the\n-             addresses are the same. Make sure its not end of table tho. */\n-          if (tab[pos].start_region != (void *) -1)\n-            pos++;\n-        }\n-      else\n-        pc--;\n-      \n-      /* We can't do a binary search because the table is in inner-most\n-         to outermost address ranges within functions */\n-      for ( ; tab[pos].start_region != (void *) -1; pos++)\n-        { \n-          if (tab[pos].start_region <= pc && tab[pos].end_region > pc)\n-            {\n-              if (tab[pos].match_info)\n-                {\n-                  __eh_matcher matcher = eh_info->match_function;\n-                  /* match info but no matcher is NOT a match */\n-                  if (matcher) \n-                    {\n-                      void *ret = (*matcher)((void *) eh_info, \n-                                             tab[pos].match_info, table);\n-                      if (ret) \n-                        {\n-                          if (retval == NULL)\n-                            retval = tab[pos].exception_handler;\n-                          *cleanup = 0;\n-                          break;\n-                        }\n-                    }\n-                }\n-              else\n-                {\n-                  if (retval == NULL)\n-                    retval = tab[pos].exception_handler;\n-                }\n-            }\n-        }\n-    }\n-  return retval;\n-}\n-#endif /* DWARF2_UNWIND_INFO */\n-#endif /* EH_TABLE_LOOKUP */\n-\f\n-#ifdef DWARF2_UNWIND_INFO\n-/* Support code for exception handling using static unwind information.  */\n-\n-#include \"frame.h\"\n-\n-/* This type is used in get_reg and put_reg to deal with ABIs where a void*\n-   is smaller than a word, such as the Irix 6 n32 ABI.  We cast twice to\n-   avoid a warning about casting between int and pointer of different\n-   sizes.  */\n-\n-typedef int ptr_type __attribute__ ((mode (pointer)));\n-\n-typedef struct\n-{\n-  word_type *reg[DWARF_FRAME_REGISTERS];\n-} saved_regs_t;\n-\n-#ifdef INCOMING_REGNO\n-/* Is the saved value for register REG in frame UDATA stored in a register\n-   window in the previous frame?  */\n-\n-/* ??? The Sparc INCOMING_REGNO references TARGET_FLAT.  This allows us\n-   to use the macro here.  One wonders, though, that perhaps TARGET_FLAT\n-   compiled functions won't work with the frame-unwind stuff here.  \n-   Perhaps the entireity of in_reg_window should be conditional on having\n-   seen a DW_CFA_GNU_window_save?  */\n-#define target_flags 0\n-\n-static int\n-in_reg_window (int reg, frame_state *udata)\n-{\n-  if (udata->saved[reg] == REG_SAVED_REG)\n-    return INCOMING_REGNO (reg) == reg;\n-  if (udata->saved[reg] != REG_SAVED_OFFSET)\n-    return 0;\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-  return udata->reg_or_offset[reg] > 0;\n-#else\n-  return udata->reg_or_offset[reg] < 0;\n-#endif\n-}\n-#else\n-static inline int\n-in_reg_window (int reg __attribute__ ((__unused__)),\n-\t       frame_state *udata __attribute__ ((__unused__)))\n-{\n-  return 0;\n-}\n-#endif /* INCOMING_REGNO */\n-\n-/* Get the address of register REG as saved in UDATA, where SUB_UDATA is a\n-   frame called by UDATA or 0.  */\n-\n-static word_type *\n-get_reg_addr (unsigned reg, frame_state *udata, frame_state *sub_udata)\n-{\n-  while (udata->saved[reg] == REG_SAVED_REG)\n-    {\n-      reg = udata->reg_or_offset[reg];\n-      if (in_reg_window (reg, udata))\n-\t{\n-          udata = sub_udata;\n-\t  sub_udata = NULL;\n-\t}\n-    }\n-  if (udata->saved[reg] == REG_SAVED_OFFSET)\n-    return (word_type *)(udata->cfa + udata->reg_or_offset[reg]);\n-  else\n-    /* We don't have a saved copy of this register.  */\n-    return NULL;\n-}\n-\n-/* Get the value of register REG as saved in UDATA, where SUB_UDATA is a\n-   frame called by UDATA or 0.  */\n-\n-static inline void *\n-get_reg (unsigned reg, frame_state *udata, frame_state *sub_udata)\n-{\n-  return (void *)(ptr_type) *get_reg_addr (reg, udata, sub_udata);\n-}\n-\n-/* Overwrite the saved value for register REG in frame UDATA with VAL.  */\n-\n-static inline void\n-put_reg (unsigned reg, void *val, frame_state *udata)\n-{\n-  *get_reg_addr (reg, udata, NULL) = (word_type)(ptr_type) val;\n-}\n-\n-/* Copy the saved value for register REG from PTREG to frame\n-   TARGET_UDATA.  Unlike the previous two functions, this can handle\n-   registers that are not one word large.  */\n-\n-static void\n-copy_reg (unsigned reg, word_type *preg, frame_state *target_udata)\n-{\n-  word_type *ptreg = get_reg_addr (reg, target_udata, NULL);\n-  memcpy (ptreg, preg, dwarf_reg_size_table [reg]);\n-}\n-\n-/* Retrieve the return address for frame UDATA.  */\n-\n-static inline void *\n-get_return_addr (frame_state *udata, frame_state *sub_udata)\n-{\n-  return __builtin_extract_return_addr\n-    (get_reg (udata->retaddr_column, udata, sub_udata));\n-}\n-\n-/* Overwrite the return address for frame UDATA with VAL.  */\n-\n-static inline void\n-put_return_addr (void *val, frame_state *udata)\n-{\n-  val = __builtin_frob_return_addr (val);\n-  put_reg (udata->retaddr_column, val, udata);\n-}\n-\n-/* Given the current frame UDATA and its return address PC, return the\n-   information about the calling frame in CALLER_UDATA and update the\n-   register array in SAVED_REGS.  */\n-\n-static void *\n-next_stack_level (void *pc, frame_state *udata, frame_state *caller_udata,\n-\t\t  saved_regs_t *saved_regs)\n-{\n-  int i;\n-  word_type *p;\n-\n-  /* Collect all of the registers for the current frame.  */\n-  for (i = 0; i < DWARF_FRAME_REGISTERS; i++)\n-    if (udata->saved[i])\n-      saved_regs->reg[i] = get_reg_addr (i, udata, caller_udata);\n-\n-  caller_udata = __frame_state_for (pc, caller_udata);\n-  if (! caller_udata)\n-    return 0;\n-\n-  /* Now go back to our caller's stack frame.  If our caller's CFA was\n-     saved in a register in this stack frame or a previous one, restore it;\n-     otherwise, assume CFA register is SP and restore it to our CFA value\n-     (which is defined to be the value of SP in the caller's frame).  */\n-\n-  p = saved_regs->reg[caller_udata->cfa_reg];\n-  if (p)\n-    caller_udata->cfa = (void *)(ptr_type)*p;\n-  else\n-    caller_udata->cfa = udata->cfa;\n- \n-  if (caller_udata->indirect)\n-    caller_udata->cfa = * (void **) ((unsigned char *)caller_udata->cfa \n-\t\t\t\t     + caller_udata->base_offset);\n-  caller_udata->cfa += caller_udata->cfa_offset;\n-\n-  return caller_udata;\n-}\n-\n-/* Hook to call before __terminate if only cleanup handlers remain. */\n-void \n-__unwinding_cleanup (void)\n-{\n-}\n-\n-/* throw_helper performs some of the common grunt work for a throw. This\n-   routine is called by throw and rethrows. This is pretty much split \n-   out from the old __throw routine. An addition has been added which allows\n-   for a dummy call to a routine __unwinding_cleanup() when there are nothing\n-   but cleanups remaining. This allows a debugger to examine the state\n-   at which the throw was executed, before any cleanups, rather than\n-   at the terminate point after the stack has been unwound.\n-\n-   EH is the current eh_context structure.\n-   PC is the address of the call to __throw.\n-   MY_UDATA is the unwind information for __throw.\n-   OFFSET_P is where we return the SP adjustment offset.  */\n-\n-static void *\n-throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n-\t      long *offset_p)\n-{\n-  frame_state ustruct2, *udata = &ustruct2;\n-  frame_state ustruct;\n-  frame_state *sub_udata = &ustruct;\n-  void *saved_pc = pc;\n-  void *handler;\n-  void *handler_p = 0;\n-  void *pc_p = 0;\n-  void *callee_cfa = 0;\n-  frame_state saved_ustruct;\n-  int new_eh_model;\n-  int cleanup = 0;\n-  int only_cleanup = 0;\n-  int rethrow = 0;\n-  int saved_state = 0;\n-  long args_size;\n-  saved_regs_t saved_regs, cleanup_regs;\n-  __eh_info *eh_info = (__eh_info *)eh->info;\n-  int i;\n-\n-  memset (saved_regs.reg, 0, sizeof saved_regs.reg);\n-  memset (sub_udata->saved, REG_UNSAVED, sizeof sub_udata->saved);\n-\n-  /* Do we find a handler based on a re-throw PC? */\n-  if (eh->table_index != (void *) 0)\n-    rethrow = 1;\n-\n-  memcpy (udata, my_udata, sizeof (*udata));\n-\n-  handler = (void *) 0;\n-  for (;;)\n-    { \n-      frame_state *p = udata;\n-\n-      udata = next_stack_level (pc, udata, sub_udata, &saved_regs);\n-      sub_udata = p;\n-\n-      /* If we couldn't find the next frame, we lose.  */\n-      if (! udata)\n-\tbreak;\n-\n-      if (udata->eh_ptr == NULL)\n-        new_eh_model = 0;\n-      else\n-        new_eh_model = (((exception_descriptor *)(udata->eh_ptr))->\n-\t\t\truntime_id_field == NEW_EH_RUNTIME);\n-\n-      if (rethrow) \n-        {\n-          rethrow = 0;\n-          handler = find_exception_handler (eh->table_index, udata->eh_ptr, \n-\t\t\t\t\t    eh_info, 1, &cleanup);\n-          eh->table_index = (void *)0;\n-        }\n-      else\n-        if (new_eh_model)\n-          handler = find_exception_handler (pc, udata->eh_ptr, eh_info, \n-                                            0, &cleanup);\n-        else\n-          handler = old_find_exception_handler (pc, udata->eh_ptr);\n-\n-      /* If we found one, we can stop searching, if its not a cleanup. \n-         for cleanups, we save the state, and keep looking. This allows\n-         us to call a debug hook if there are nothing but cleanups left. */\n-      if (handler)\n-\t{\n-\t  /* sub_udata now refers to the frame called by the handler frame.  */\n-\n-\t  if (cleanup)\n-\t    {\n-\t      if (!saved_state)\n-\t\t{\n-\t\t  saved_ustruct = *udata;\n-\t\t  cleanup_regs = saved_regs;\n-\t\t  handler_p = handler;\n-\t\t  pc_p = pc;\n-\t\t  saved_state = 1;\n-\t\t  only_cleanup = 1;\n-\t\t  /* Save the CFA of the frame called by the handler\n-                     frame.  */\n-\t\t  callee_cfa = sub_udata->cfa;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      only_cleanup = 0;\n-\t      if (!saved_state)\n-\t\tcallee_cfa = sub_udata->cfa;\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* Otherwise, we continue searching.  We subtract 1 from PC to avoid\n-\t hitting the beginning of the next region.  */\n-      pc = get_return_addr (udata, sub_udata) - 1;\n-    }\n-\n-  if (saved_state) \n-    {\n-      udata = &saved_ustruct;\n-      saved_regs = cleanup_regs;\n-      handler = handler_p;\n-      pc = pc_p;\n-      if (only_cleanup)\n-        __unwinding_cleanup ();\n-    }\n-\n-  /* If we haven't found a handler by now, this is an unhandled\n-     exception.  */\n-  if (! handler) \n-    __terminate();\n-\n-  eh->handler_label = handler;\n-\n-  args_size = udata->args_size;\n-\n-  /* We adjust SP by the difference between __throw's CFA and the CFA for\n-     the frame called by the handler frame, because those CFAs correspond\n-     to the SP values at the two call sites.  We need to further adjust by\n-     the args_size of the handler frame itself to get the handler frame's\n-     SP from before the args were pushed for that call.  */\n-#ifdef STACK_GROWS_DOWNWARD\n-  *offset_p = callee_cfa - my_udata->cfa + args_size;\n-#else\n-  *offset_p = my_udata->cfa - callee_cfa - args_size;\n-#endif\n-\t\t       \n-  /* If we found a handler in the throw context there's no need to\n-     unwind.  */\n-  if (pc != saved_pc)\n-    {\n-      /* Copy saved register values into our register save slots.  */\n-      for (i = 0; i < DWARF_FRAME_REGISTERS; i++)\n-\tif (i != udata->retaddr_column && saved_regs.reg[i])\n-\t  copy_reg (i, saved_regs.reg[i], my_udata);\n-    }\n-\n-  return handler;\n-}\n-\n-\n-/* We first search for an exception handler, and if we don't find\n-   it, we call __terminate on the current stack frame so that we may\n-   use the debugger to walk the stack and understand why no handler\n-   was found.\n-\n-   If we find one, then we unwind the frames down to the one that\n-   has the handler and transfer control into the handler.  */\n-\n-/*extern void __throw(void) __attribute__ ((__noreturn__));*/\n-\n-void\n-__throw (void)\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  void *pc, *handler;\n-  long offset;\n-\n-  /* XXX maybe make my_ustruct static so we don't have to look it up for\n-     each throw.  */\n-  frame_state my_ustruct, *my_udata = &my_ustruct;\n-\n-  /* This is required for C++ semantics.  We must call terminate if we\n-     try and rethrow an exception, when there is no exception currently\n-     active.  */\n-  if (! eh->info)\n-    __terminate ();\n-    \n-  /* Start at our stack frame.  */\n-label:\n-  my_udata = __frame_state_for (&&label, my_udata);\n-  if (! my_udata)\n-    __terminate ();\n-\n-  /* We need to get the value from the CFA register. */\n-  my_udata->cfa = __builtin_dwarf_cfa ();\n-\n-  /* Do any necessary initialization to access arbitrary stack frames.\n-     On the SPARC, this means flushing the register windows.  */\n-  __builtin_unwind_init ();\n-\n-  /* Now reset pc to the right throw point.  The return address points to\n-     the instruction after the call to __throw; we subtract 1 so that pc\n-     points into the call insn itself.  Since we work with PC ranges (as\n-     opposed to specific call sites), it isn't important for it to point to\n-     the very beginning of the call insn, and making it do so would be\n-     hard on targets with variable length call insns.  */\n-  pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n-\n-  handler = throw_helper (eh, pc, my_udata, &offset);\n-\n-  /* Now go!  */\n-\n-  __builtin_eh_return ((void *)eh, offset, handler);\n-\n-  /* Epilogue:  restore the handler frame's register values and return\n-     to the stub.  */\n-}\n-\n-/*extern void __rethrow(void *) __attribute__ ((__noreturn__));*/\n-\n-void\n-__rethrow (void *index)\n-{\n-  struct eh_context *eh = (*get_eh_context) ();\n-  void *pc, *handler;\n-  long offset;\n-\n-  /* XXX maybe make my_ustruct static so we don't have to look it up for\n-     each throw.  */\n-  frame_state my_ustruct, *my_udata = &my_ustruct;\n-\n-  /* This is required for C++ semantics.  We must call terminate if we\n-     try and rethrow an exception, when there is no exception currently\n-     active.  */\n-  if (! eh->info)\n-    __terminate ();\n-\n-  /* This is the table index we want to rethrow from. The value of\n-     the END_REGION label is used for the PC of the throw, and the\n-     search begins with the next table entry. */\n-  eh->table_index = index;\n-    \n-  /* Start at our stack frame.  */\n-label:\n-  my_udata = __frame_state_for (&&label, my_udata);\n-  if (! my_udata)\n-    __terminate ();\n-\n-  /* We need to get the value from the CFA register. */\n-  my_udata->cfa = __builtin_dwarf_cfa ();\n-\n-  /* Do any necessary initialization to access arbitrary stack frames.\n-     On the SPARC, this means flushing the register windows.  */\n-  __builtin_unwind_init ();\n-\n-  /* Now reset pc to the right throw point.  The return address points to\n-     the instruction after the call to __throw; we subtract 1 so that pc\n-     points into the call insn itself.  Since we work with PC ranges (as\n-     opposed to specific call sites), it isn't important for it to point to\n-     the very beginning of the call insn, and making it do so would be\n-     hard on targets with variable length call insns.  */\n-  pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n-\n-  handler = throw_helper (eh, pc, my_udata, &offset);\n-\n-  /* Now go!  */\n-\n-  __builtin_eh_return ((void *)eh, offset, handler);\n-\n-  /* Epilogue:  restore the handler frame's register values and return\n-     to the stub.  */\n-}\n-#endif /* DWARF2_UNWIND_INFO */\n-\n-#ifdef IA64_UNWIND_INFO\n-#include \"frame.h\"\n-\n-/* Return handler to which we want to transfer control, NULL if we don't\n-   intend to handle this exception here.  */\n-void *\n-__ia64_personality_v1 (void *pc, old_exception_table *table)\n-{\n-  if (table)\n-    {\n-      int pos;\n-      int best = -1;\n-\n-      for (pos = 0; table[pos].start_region != (void *) -1; ++pos)\n-        {\n-          if (table[pos].start_region <= pc && table[pos].end_region > pc)\n-            {\n-              /* This can apply.  Make sure it is at least as small as\n-                 the previous best.  */\n-              if (best == -1 || (table[pos].end_region <= table[best].end_region\n-                        && table[pos].start_region >= table[best].start_region))\n-                best = pos;\n-            }\n-          /* It is sorted by starting PC within a function.  */\n-          else if (best >= 0 && table[pos].start_region > pc)\n-            break;\n-        }\n-      if (best != -1)\n-        return table[best].exception_handler;\n-    }\n-  return (void *) 0;\n-}\n-\n-static void\n-ia64_throw_helper (ia64_frame_state *throw_frame, ia64_frame_state *caller,\n-\t\t   void *throw_bsp, void *throw_sp)\n-{\n-  void *throw_pc = __builtin_return_address (0);\n-  unwind_info_ptr *info;\n-  void *pc, *handler = NULL;\n-  void *pc_base;\n-  int frame_count;\n-  void *bsp;\n-\n-  __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */\n-\n-  /* Start at our stack frame, get our state.  */\n-  __build_ia64_frame_state (throw_pc, throw_frame, throw_bsp, throw_sp,\n-\t\t\t    &pc_base);\n-\n-  /* Now we have to find the proper frame for pc, and see if there\n-     is a handler for it. if not, we keep going back frames until\n-     we do find one. Otherwise we call uncaught ().  */\n-\n-  frame_count = 0;\n-  memcpy (caller, throw_frame, sizeof (*caller));\n-  while (!handler)\n-    {\n-      void *(*personality) (void *, old_exception_table *);\n-      void *eh_table;\n-\n-      frame_count++;\n-      /* We only care about the RP right now, so we dont need to keep\n-         any other information about a call frame right now.  */\n-      pc = __get_real_reg_value (&caller->rp) - 1;\n-      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs),\n-\t\t\t       caller->my_bsp);\n-      info = __build_ia64_frame_state (pc, caller, bsp, caller->my_psp,\n-\t\t\t\t       &pc_base);\n-\n-      /* If we couldn't find the next frame, we lose.  */\n-      if (! info)\n-\tbreak;\n-\n-      personality = __get_personality (info); \n-      /* TODO Haven't figured out how to actually load the personality address\n-         yet, so just always default to the one we expect for now.  */\n-      if (personality != 0)\n-\tpersonality = __ia64_personality_v1;\n-      eh_table = __get_except_table (info);\n-      /* If there is no personality routine, we'll keep unwinding.  */\n-      if (personality)\n-\t/* Pass a segment relative PC address to the personality routine,\n-\t   because the unwind_info section uses segrel relocs.  */\n-\thandler = personality ((void *)(pc - pc_base), eh_table);\n-    }\n-  \n-  if (!handler)\n-    __terminate ();\n-\n-  /* Handler is a segment relative address, so we must adjust it here.  */\n-  handler += (long) pc_base;\n-\n-  /* If we found a handler, we need to unwind the stack to that point.\n-     We do this by copying saved values from previous frames into the\n-     save slot for the throw_frame saved slots.  when __throw returns,\n-     it'll pickup the correct values.  */\n-  \n-  /* Start with where __throw saved things, and copy each saved register\n-     of each previous frame until we get to the one before we're \n-     throwing back to.  */\n-  memcpy (caller, throw_frame, sizeof (*caller));\n-  for ( ; frame_count > 0; frame_count--)\n-    {\n-      pc = __get_real_reg_value (&caller->rp) - 1;\n-      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs),\n-\t\t\t       caller->my_bsp);\n-      __build_ia64_frame_state (pc, caller, bsp, caller->my_psp, &pc_base);\n-      /* Any regs that were saved can be put in the throw frame now.  */\n-      /* We don't want to copy any saved register from the \n-         target destination, but we do want to load up it's frame.  */\n-      if (frame_count > 1)\n-\t__copy_saved_reg_state (throw_frame, caller);\n-    }\n-\n-  /* Set return address of the throw frame to the handler. */\n-  __set_real_reg_value (&throw_frame->rp, handler);\n-\n-  /* TODO, do we need to do anything to make the values we wrote 'stick'? */\n-  /* DO we need to go through the whole loadrs seqeunce?  */\n-}\n-\n-\n-void\n-__throw ()\n-{\n-  register void *stack_pointer __asm__(\"r12\");\n-  struct eh_context *eh = (*get_eh_context) ();\n-  ia64_frame_state my_frame;\n-  ia64_frame_state originator;\t/* For the context handler is in.  */\n-  void *bsp, *tmp_bsp;\n-  long offset;\n-\n-  /* This is required for C++ semantics.  We must call terminate if we\n-     try and rethrow an exception, when there is no exception currently\n-     active.  */\n-  if (! eh->info)\n-    __terminate ();\n-\n-  __builtin_unwind_init ();\n-\n-  /* We have to call another routine to actually process the frame \n-     information, which will force all of __throw's local registers into\n-     backing store.  */\n-\n-  /* Get the value of ar.bsp while we're here.  */\n-\n-  bsp = __builtin_ia64_bsp ();\n-  ia64_throw_helper (&my_frame, &originator, bsp, stack_pointer);\n-\n-  /* Now we have to fudge the bsp by the amount in our (__throw)\n-     frame marker, since the return is going to adjust it by that much. */\n-\n-  tmp_bsp = __calc_caller_bsp ((long)__get_real_reg_value (&my_frame.pfs), \n-\t\t\t     my_frame.my_bsp);\n-  offset = (char *)my_frame.my_bsp - (char *)tmp_bsp;\n-  tmp_bsp = (char *)originator.my_bsp + offset;\n-\n-  __builtin_eh_return (tmp_bsp, offset, originator.my_sp);\n-\n-  /* The return address was already set by throw_helper.  */\n-}\n-\n-#endif /* IA64_UNWIND_INFO  */\n-\n-#endif /* L_eh */"}, {"sha": "047f25669a858accec75c043ae243574fe53a1f5", "filename": "gcc/md.texi", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -2848,26 +2848,24 @@ You will not normally need to define this pattern unless you also define\n @code{builtin_setjmp_setup}.  The single argument is a pointer to the\n @code{jmp_buf}.\n \n-@cindex @code{eh_epilogue} instruction pattern\n-@item @samp{eh_epilogue}\n+@cindex @code{eh_return} instruction pattern\n+@item @samp{eh_return}\n This pattern, if defined, affects the way @code{__builtin_eh_return},\n-and thence @code{__throw} are built.  It is intended to allow communication\n-between the exception handling machinery and the normal epilogue code\n-for the target.\n-\n-The pattern takes three arguments.  The first is the exception context\n-pointer.  This will have already been copied to the function return\n-register appropriate for a pointer; normally this can be ignored.  The\n-second argument is an offset to be added to the stack pointer.  It will \n-have been copied to some arbitrary call-clobbered hard reg so that it\n-will survive until after reload to when the normal epilogue is generated. \n-The final argument is the address of the exception handler to which\n+and thence the call frame exception handling library routines, are\n+built.  It is intended to handle non-trivial actions needed along\n+the abnormal return path.\n+\n+The pattern takes two arguments.  The first is an offset to be applied\n+to the stack pointer.  It will have been copied to some appropriate\n+location (typically @code{EH_RETURN_STACKADJ_RTX}) which will survive\n+until after reload to when the normal epilogue is generated. \n+The second argument is the address of the exception handler to which\n the function should return.  This will normally need to copied by the\n-pattern to some special register.\n+pattern to some special register or memory location.\n \n-This pattern must be defined if @code{RETURN_ADDR_RTX} does not yield\n-something that can be reliably and permanently modified, i.e. a fixed\n-hard register or a stack memory reference.\n+This pattern only needs to be defined if call frame exception handling\n+is to be used, and simple moves to @code{EH_RETURN_STACKADJ_RTX} and\n+@code{EH_RETURN_HANDLER_RTX} are not sufficient.\n \n @cindex @code{prologue} instruction pattern\n @item @samp{prologue}"}, {"sha": "70fc55aa53c2611481e53b63bc945e051b3bb1ae", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -14,8 +14,9 @@\n # LIB1ASMFUNCS\n # LIB1FUNCS_EXTRA\n # LIB2FUNCS\n-# LIB2FUNCS_EH\n # LIB2ADD\n+# LIB2ADDEH\n+# LIB2ADDEHDEP\n # FPBIT\n # FPBIT_FUNCS\n # DPBIT\n@@ -79,7 +80,7 @@ make_compile='$(MAKE) GCC_FOR_TARGET=\"$(GCC_FOR_TARGET)\" \\\n libgcc1_c_dep='stmp-dirs $(srcdir)/libgcc1.c $(CONFIG_H)'\n \n # Dependancies for libgcc2.c\n-libgcc2_c_dep='stmp-dirs $(srcdir)/libgcc2.c $(CONFIG_H) $(MACHMODE_H) longlong.h frame.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h'\n+libgcc2_c_dep='stmp-dirs $(srcdir)/libgcc2.c $(CONFIG_H) $(MACHMODE_H) longlong.h gbl-ctors.h config.status stmp-int-hdrs tsystem.h'\" $LIB2ADDEHDEP\"\n \n # Dependancies for fp-bit.c\n fpbit_c_dep='stmp-dirs config.status tsystem.h'\n@@ -180,19 +181,6 @@ for name in $LIB2FUNCS; do\n   libgcc2_objs=\"$libgcc2_objs ${name}${objext}\"\n done\n \n-for name in $LIB2FUNCS_EH; do\n-  for ml in $MULTILIBS; do\n-    dir=`echo ${ml} | sed -e 's/;.*$//' -e 's/=/$(EQ)/g'`\n-    flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`;\n-    out=\"libgcc/${dir}/${name}${objext}\"\n-\n-    echo $out: $libgcc2_c_dep\n-    echo \"\t$gcc_compile\" '$(MAYBE_USE_COLLECT2)' -fexceptions \\\n-      $flags -DL$name -c '$(srcdir)/libgcc2.c' -o $out\n-  done\n-  libgcc2_objs=\"$libgcc2_objs ${name}${objext}\"\n-done\n-\n if [ \"$FPBIT\" ]; then\n   for name in $FPBIT_FUNCS; do\n     for ml in $MULTILIBS; do\n@@ -241,6 +229,24 @@ for file in $LIB2ADD; do\n   libgcc2_objs=\"$libgcc2_objs ${oname}${objext}\"\n done\n \n+for file in $LIB2ADDEH; do\n+  name=`echo $file | sed -e 's/[.][cSo]$//' -e 's/[.]asm$//' -e 's/[.]txt$//'`\n+  oname=`echo $name | sed -e 's,.*/,,'`\n+\n+  for ml in $MULTILIBS; do\n+    dir=`echo ${ml} | sed -e 's/;.*$//' -e 's/=/$(EQ)/g'`\n+    flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`;\n+    out=\"libgcc/${dir}/${oname}${objext}\"\n+    if [ ${name}.asm = ${file} ]; then\n+      flags=\"$flags -xassembler-with-cpp\"\n+    fi\n+\n+    echo $out: stmp-dirs $file\n+    echo \"\t$gcc_compile\" $flags -fexceptions -c $file -o $out\n+  done\n+  libgcc2_objs=\"$libgcc2_objs ${oname}${objext}\"\n+done\n+\n # SHLIB_MKMAP\n # SHLIB_MAPFILES\n for ml in $MULTILIBS; do"}, {"sha": "0be8d6a6bcedfddb9c16ee39d275495cabe281f5", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"flags.h\"\n #include \"function.h\"\n+#include \"except.h\"\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"reload.h\"\n@@ -4758,19 +4759,19 @@ init_optabs ()\n   memset_libfunc = init_one_libfunc (\"memset\");\n   bzero_libfunc = init_one_libfunc (\"bzero\");\n \n-  throw_libfunc = init_one_libfunc (\"__throw\");\n-  rethrow_libfunc = init_one_libfunc (\"__rethrow\");\n-  sjthrow_libfunc = init_one_libfunc (\"__sjthrow\");\n-  sjpopnthrow_libfunc = init_one_libfunc (\"__sjpopnthrow\");\n-  terminate_libfunc = init_one_libfunc (\"__terminate\");\n-  eh_rtime_match_libfunc = init_one_libfunc (\"__eh_rtime_match\");\n+  unwind_resume_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t\t\t    ? \"_Unwind_SjLj_Resume\"\n+\t\t\t\t\t    : \"_Unwind_Resume\");\n #ifndef DONT_USE_BUILTIN_SETJMP\n   setjmp_libfunc = init_one_libfunc (\"__builtin_setjmp\");\n   longjmp_libfunc = init_one_libfunc (\"__builtin_longjmp\");\n #else\n   setjmp_libfunc = init_one_libfunc (\"setjmp\");\n   longjmp_libfunc = init_one_libfunc (\"longjmp\");\n #endif\n+  unwind_sjlj_register_libfunc = init_one_libfunc (\"_Unwind_SjLj_Register\");\n+  unwind_sjlj_unregister_libfunc\n+    = init_one_libfunc (\"_Unwind_SjLj_Unregister\");\n \n   eqhf2_libfunc = init_one_libfunc (\"__eqhf2\");\n   nehf2_libfunc = init_one_libfunc (\"__nehf2\");"}, {"sha": "906255d2dcd9e4b5c2239839752b6061a53b7c00", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -547,6 +547,11 @@ DEF_RTL_EXPR(RETURN, \"return\", \"\", 'x')\n    For an unconditional trap, make the condition (const_int 1).  */\n DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", 'x')\n \n+/* Placeholder for _Unwind_Resume before we know if a function call\n+   or a branch is needed.  Operand 1 is the exception region from\n+   which control is flowing.  */\n+DEF_RTL_EXPR(RESX, \"resx\", \"i\", 'x')\n+\n /* ----------------------------------------------------------------------\n    Primitive values for use in expressions.\n    ---------------------------------------------------------------------- */"}, {"sha": "dbadd70f9583505e839bbcd71e8b22e00a6a2ab6", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -924,10 +924,6 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* Flag in a SYMBOL_REF for machine-specific purposes.  */\n #define SYMBOL_REF_FLAG(RTX) ((RTX)->volatil)\n \n-/* 1 in a SYMBOL_REF if it represents a symbol which might have to change\n-   if its inlined or unrolled. */\n-#define SYMBOL_REF_NEED_ADJUST(RTX)  ((RTX)->in_struct)\n-\n /* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n #define SYMBOL_REF_USED(RTX) ((RTX)->used)\n "}, {"sha": "12f1562cbf6b85e4df51b12daf983b8d7a0b4169", "filename": "gcc/stmt.c", "status": "modified", "additions": 16, "deletions": 106, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -4072,12 +4072,11 @@ expand_decl_cleanup (decl, cleanup)\n \t  start_sequence ();\n \t}\n \n-      /* If this was optimized so that there is no exception region for the\n-\t cleanup, then mark the TREE_LIST node, so that we can later tell\n-\t if we need to call expand_eh_region_end.  */\n-      if (! using_eh_for_cleanups_p\n-\t  || expand_eh_region_start_tree (decl, cleanup))\n+      if (! using_eh_for_cleanups_p)\n \tTREE_ADDRESSABLE (t) = 1;\n+      else\n+\texpand_eh_region_start ();\n+\n       /* If that started a new EH region, we're in a new block.  */\n       thisblock = block_stack;\n \n@@ -4106,82 +4105,6 @@ expand_decl_cleanup (decl, cleanup)\n     }\n   return 1;\n }\n-\n-/* Arrange for the top element of the dynamic cleanup chain to be\n-   popped if we exit the current binding contour.  DECL is the\n-   associated declaration, if any, otherwise NULL_TREE.  If the\n-   current contour is left via an exception, then __sjthrow will pop\n-   the top element off the dynamic cleanup chain.  The code that\n-   avoids doing the action we push into the cleanup chain in the\n-   exceptional case is contained in expand_cleanups.\n-\n-   This routine is only used by expand_eh_region_start, and that is\n-   the only way in which an exception region should be started.  This\n-   routine is only used when using the setjmp/longjmp codegen method\n-   for exception handling.  */\n-\n-int\n-expand_dcc_cleanup (decl)\n-     tree decl;\n-{\n-  struct nesting *thisblock;\n-  tree cleanup;\n-\n-  /* Error if we are not in any block.  */\n-  if (cfun == 0 || block_stack == 0)\n-    return 0;\n-  thisblock = block_stack;\n-\n-  /* Record the cleanup for the dynamic handler chain.  */\n-\n-  cleanup = make_node (POPDCC_EXPR);\n-\n-  /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n-  thisblock->data.block.cleanups\n-    = tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n-\n-  /* If this block has a cleanup, it belongs in stack_block_stack.  */\n-  stack_block_stack = thisblock;\n-  return 1;\n-}\n-\n-/* Arrange for the top element of the dynamic handler chain to be\n-   popped if we exit the current binding contour.  DECL is the\n-   associated declaration, if any, otherwise NULL_TREE.  If the current\n-   contour is left via an exception, then __sjthrow will pop the top\n-   element off the dynamic handler chain.  The code that avoids doing\n-   the action we push into the handler chain in the exceptional case\n-   is contained in expand_cleanups.\n-\n-   This routine is only used by expand_eh_region_start, and that is\n-   the only way in which an exception region should be started.  This\n-   routine is only used when using the setjmp/longjmp codegen method\n-   for exception handling.  */\n-\n-int\n-expand_dhc_cleanup (decl)\n-     tree decl;\n-{\n-  struct nesting *thisblock;\n-  tree cleanup;\n-\n-  /* Error if we are not in any block.  */\n-  if (cfun == 0 || block_stack == 0)\n-    return 0;\n-  thisblock = block_stack;\n-\n-  /* Record the cleanup for the dynamic handler chain.  */\n-\n-  cleanup = make_node (POPDHC_EXPR);\n-\n-  /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n-  thisblock->data.block.cleanups\n-    = tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n-\n-  /* If this block has a cleanup, it belongs in stack_block_stack.  */\n-  stack_block_stack = thisblock;\n-  return 1;\n-}\n \f\n /* DECL is an anonymous union.  CLEANUP is a cleanup for DECL.\n    DECL_ELTS is the list of elements that belong to DECL's type.\n@@ -4286,20 +4209,8 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n \t  expand_cleanups (TREE_VALUE (tail), dont_do, in_fixup, reachable);\n \telse\n \t  {\n-\t    if (! in_fixup)\n-\t      {\n-\t\ttree cleanup = TREE_VALUE (tail);\n-\n-\t\t/* See expand_d{h,c}c_cleanup for why we avoid this.  */\n-\t\tif (TREE_CODE (cleanup) != POPDHC_EXPR\n-\t\t    && TREE_CODE (cleanup) != POPDCC_EXPR\n-\t\t    /* See expand_eh_region_start_tree for this case.  */\n-\t\t    && ! TREE_ADDRESSABLE (tail))\n-\t\t  {\n-\t\t    cleanup = protect_with_terminate (cleanup);\n-\t\t    expand_eh_region_end (cleanup);\n-\t\t  }\n-\t      }\n+\t    if (! in_fixup && using_eh_for_cleanups_p)\n+\t      expand_eh_region_end_cleanup (TREE_VALUE (tail));\n \n \t    if (reachable)\n \t      {\n@@ -4312,19 +4223,18 @@ expand_cleanups (list, dont_do, in_fixup, reachable)\n \t\t   times, the control paths are non-overlapping so the\n \t\t   cleanups will not be executed twice.  */\n \n-\t\t/* We may need to protect fixups with rethrow regions.  */\n-\t\tint protect = (in_fixup && ! TREE_ADDRESSABLE (tail));\n+\t\t/* We may need to protect from outer cleanups.  */\n+\t\tif (in_fixup && using_eh_for_cleanups_p)\n+\t\t  {\n+\t\t    expand_eh_region_start ();\n+\n+\t\t    expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n \n-\t\tif (protect)\n-\t\t  expand_fixup_region_start ();\n+\t\t    expand_eh_region_end_fixup (TREE_VALUE (tail));\n+\t\t  }\n+\t\telse\n+\t\t  expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n \n-\t\t/* The cleanup might contain try-blocks, so we have to\n-\t\t   preserve our current queue.  */\n-\t\tpush_ehqueue ();\n-\t\texpand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n-\t\tpop_ehqueue ();\n-\t\tif (protect)\n-\t\t  expand_fixup_region_end (TREE_VALUE (tail));\n \t\tfree_temp_slots ();\n \t      }\n \t  }"}, {"sha": "e3dd5309b20b8c3e0ab818b42efebb70b00520c6", "filename": "gcc/tm.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -2505,6 +2505,54 @@ You only need to define this macro if the default is incorrect, and you\n want to support call frame debugging information like that provided by\n DWARF 2.\n \n+@findex EH_RETURN_DATA_REGNO\n+@item EH_RETURN_DATA_REGNO (@var{N})\n+A C expression whose value is the @var{N}th register number used for\n+data by exception handlers, or @code{INVALID_REGNUM} if fewer than\n+@var{N} registers are usable.\n+\n+The exception handling library routines communicate with the exception\n+handlers via a set of agreed upon registers.  Ideally these registers\n+should be call-clobbered; it is possible to use call-saved registers,\n+but may negatively impact code size.  The target must support at least\n+2 data registers, but should define 4 if there are enough free registers.\n+\n+You must define this macro if you want to support call frame exception\n+handling like that provided by DWARF 2.\n+\n+@findex EH_RETURN_STACKADJ_RTX\n+@item EH_RETURN_STACKADJ_RTX\n+A C expression whose value is RTL representing a location in which\n+to store a stack adjustment to be applied before function return.\n+This is used to unwind the stack to an exception handler's call frame.\n+It will be assigned zero on code paths that return normally.\n+\n+Typically this is a call-clobbered hard register that is otherwise \n+untouched by the epilogue, but could also be a stack slot.\n+\n+You must define this macro if you want to support call frame exception\n+handling like that provided by DWARF 2.\n+\n+@findex EH_RETURN_HANDLER_RTX\n+@item EH_RETURN_HANDLER_RTX\n+A C expression whose value is RTL representing a location in which\n+to store the address of an exception handler to which we should \n+return.  It will not be assigned on code paths that return normally.\n+\n+Typically this is the location in the call frame at which the normal\n+return address is stored.  For targets that return by popping an \n+address off the stack, this might be a memory address just below \n+the @emph{target} call frame rather than inside the current call\n+frame.  @code{EH_RETURN_STACKADJ_RTX} will have already been assigned,\n+so it may be used to calculate the location of the target call frame.\n+\n+Some targets have more complex requirements than storing to an\n+address calculable during initial code generation.  In that case\n+the @code{eh_return} instruction pattern should be used instead.\n+\n+If you want to support call frame exception handling, you must\n+define either this macro or the @code{eh_return} instruction pattern.\n+\n @findex SMALL_STACK\n @item SMALL_STACK\n Define this macro if the stack size for the target is very small.  This"}, {"sha": "b029c70642b2a288603d321fb605c8a6d13314e8", "filename": "gcc/toplev.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -252,6 +252,7 @@ enum dump_file_index\n {\n   DFI_rtl,\n   DFI_sibling,\n+  DFI_eh,\n   DFI_jump,\n   DFI_cse,\n   DFI_addressof,\n@@ -289,14 +290,15 @@ enum dump_file_index\n \n    Remaining -d letters:\n \n-\t\"       h      o q   u     \"\n+\t\"              o q   u     \"\n \t\"       H  K   OPQ  TUVW YZ\"\n */\n \n struct dump_file_info dump_file[DFI_MAX] =\n {\n   { \"rtl\",\t'r', 0, 0, 0 },\n   { \"sibling\",  'i', 0, 0, 0 },\n+  { \"eh\",\t'h', 0, 0, 0 },\n   { \"jump\",\t'j', 0, 0, 0 },\n   { \"cse\",\t's', 0, 0, 0 },\n   { \"addressof\", 'F', 0, 0, 0 },\n@@ -2162,9 +2164,9 @@ compile_file (name)\n   init_regs ();\n   init_alias_once ();\n   init_decl_processing ();\n+  init_eh ();\n   init_optabs ();\n   init_stmt ();\n-  init_eh ();\n   init_loop ();\n   init_reload ();\n   init_function_once ();\n@@ -2402,14 +2404,6 @@ compile_file (name)\n        loop above.  */\n     output_func_start_profiler ();\n \n-    /* Now that all possible functions have been output, we can dump\n-       the exception table.  */\n-\n-#ifndef IA64_UNWIND_INFO\n-    output_exception_table ();\n-#endif\n-    free_exception_table ();\n-\n     check_global_declarations (vec, len);\n \n     /* Clean up.  */\n@@ -2805,6 +2799,11 @@ rest_of_compilation (decl)\n \t  close_dump_file (DFI_rtl, print_rtl, insns);\n \t}\n \n+      /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n+\t sorts of eh initialization.  Delay this until after the\n+         initial rtl dump so that we can see the original nesting.  */\n+      convert_from_eh_region_ranges ();\n+\n       /* If function is inline, and we don't yet know whether to\n \t compile it by itself, defer decision till end of compilation.\n \t finish_compilation will call rest_of_compilation again\n@@ -2884,9 +2883,6 @@ rest_of_compilation (decl)\n   if ((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n     goto exit_rest_of_compilation;\n \n-  /* Emit code to get eh context, if needed. */\n-  emit_eh_context ();\n-\n   /* We may have potential sibling or tail recursion sites.  Select one\n      (of possibly multiple) methods of performing the call.  */\n   if (flag_optimize_sibling_calls)\n@@ -2900,6 +2896,19 @@ rest_of_compilation (decl)\n       timevar_pop (TV_JUMP);\n     }\n \n+  /* Complete generation of exception handling code.  */\n+  find_exception_handler_labels ();\n+  if (doing_eh (0))\n+    {\n+      timevar_push (TV_JUMP);\n+      open_dump_file (DFI_eh, decl);\n+\n+      finish_eh_generation ();\n+\n+      close_dump_file (DFI_eh, print_rtl, get_insns ());\n+      timevar_pop (TV_JUMP);\n+    }\n+\n #ifdef FINALIZE_PIC\n   /* If we are doing position-independent code generation, now\n      is the time to output special prologues and epilogues.\n@@ -2923,9 +2932,6 @@ rest_of_compilation (decl)\n   /* Instantiate all virtual registers.  */\n   instantiate_virtual_regs (current_function_decl, insns);\n \n-  /* Find all the EH handlers.  */\n-  find_exception_handler_labels ();\n-\n   open_dump_file (DFI_jump, decl);\n \n   /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n@@ -3679,6 +3685,12 @@ rest_of_compilation (decl)\n     }\n #endif\n \n+#ifndef STACK_REGS\n+  /* ??? Do this before shorten branches so that we aren't creating\n+     insns too late and fail sanity checks in final. */\n+  convert_to_eh_region_ranges ();\n+#endif\n+\n   /* Shorten branches.\n \n      Note this must run before reg-stack because of death note (ab)use\n@@ -3697,6 +3709,8 @@ rest_of_compilation (decl)\n   timevar_pop (TV_REG_STACK);\n \n   ggc_collect ();\n+\n+  convert_to_eh_region_ranges ();\n #endif\n \n   current_function_nothrow = nothrow_function_p ();\n@@ -3728,6 +3742,9 @@ rest_of_compilation (decl)\n     final (insns, asm_out_file, optimize, 0);\n     final_end_function (insns, asm_out_file, optimize);\n     assemble_end_function (decl, fnname);\n+\n+    output_function_exception_table ();\n+\n     if (! quiet_flag)\n       fflush (asm_out_file);\n "}, {"sha": "760600bcd2fa821fa508510958a9ee3a56873356", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -770,17 +770,6 @@ DEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 'e', 2)\n    Operand 1 is the rtx for a variable in which to store the address\n    of where the subroutine should return to.  */\n DEFTREECODE (GOTO_SUBROUTINE_EXPR, \"goto_subroutine\", 'e', 2)\n-\n-/* Pop the top element off the dynamic handler chain.  Used in\n-   conjunction with setjmp/longjmp based exception handling, see\n-   except.c for more details.  This is meant to be used only by the\n-   exception handling backend, expand_dhc_cleanup specifically.  */\n-DEFTREECODE (POPDHC_EXPR, \"popdhc_expr\", 's', 0)\n-\n-/* Pop the top element off the dynamic cleanup chain.  Used in\n-   conjunction with the exception handling.  This is meant to be used\n-   only by the exception handling backend.  */\n-DEFTREECODE (POPDCC_EXPR, \"popdcc_expr\", 's', 0)\n \f\n /* These types of expressions have no useful value,\n    and always have side effects.  */\n@@ -834,6 +823,10 @@ DEFTREECODE (EXPR_WITH_FILE_LOCATION, \"expr_with_file_location\", 'e', 3)\n    Operand 1 contains the case values. The way they're organized is\n    front-end implementation defined. */\n DEFTREECODE (SWITCH_EXPR, \"switch_expr\", 'e', 2)\n+\n+/* The exception object from the runtime.  */\n+DEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", 'e', 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "6f450c59bcee1b55e8ba357bd57c72916f3d10a1", "filename": "gcc/unwind-dw2-fde.c", "status": "renamed", "additions": 270, "deletions": 65, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,6 +1,5 @@\n /* Subroutines needed for unwinding stack frames for exception handling.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Jason Merrill <jason@cygnus.com>.\n \n This file is part of GNU CC.\n@@ -29,6 +28,129 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"unwind-dw2-fde.h\"\n+#include \"gthr.h\"\n+\n+static struct object *objects;\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t object_mutex;\n+#endif\n+\n+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n+static void \n+init_object_mutex (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);\n+}\n+\n+static void\n+init_object_mutex_once (void)\n+{\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  __gthread_once (&once, init_object_mutex);\n+}\n+#else\n+#define init_object_mutex_once()\n+#endif\n+\n+/* Called from crtbegin.o to register the unwind info for an object.  */\n+\n+void\n+__register_frame_info (void *begin, struct object *ob)\n+{\n+  ob->pc_begin = ob->pc_end = 0;\n+  ob->fde_begin = begin;\n+  ob->fde_array = 0;\n+  ob->count = 0;\n+\n+  init_object_mutex_once ();\n+  __gthread_mutex_lock (&object_mutex);\n+\n+  ob->next = objects;\n+  objects = ob;\n+\n+  __gthread_mutex_unlock (&object_mutex);\n+}\n+\n+void\n+__register_frame (void *begin)\n+{\n+  struct object *ob = (struct object *) malloc (sizeof (struct object));\n+  __register_frame_info (begin, ob);                       \n+}\n+\n+/* Similar, but BEGIN is actually a pointer to a table of unwind entries\n+   for different translation units.  Called from the file generated by\n+   collect2.  */\n+\n+void\n+__register_frame_info_table (void *begin, struct object *ob)\n+{\n+  ob->pc_begin = ob->pc_end = 0;\n+  ob->fde_begin = begin;\n+  ob->fde_array = begin;\n+  ob->count = 0;\n+\n+  init_object_mutex_once ();\n+  __gthread_mutex_lock (&object_mutex);\n+\n+  ob->next = objects;\n+  objects = ob;\n+\n+  __gthread_mutex_unlock (&object_mutex);\n+}\n+\n+void\n+__register_frame_table (void *begin)\n+{\n+  struct object *ob = (struct object *) malloc (sizeof (struct object));\n+  __register_frame_info_table (begin, ob);\n+}\n+\n+/* Called from crtbegin.o to deregister the unwind info for an object.  */\n+\n+void *\n+__deregister_frame_info (void *begin)\n+{\n+  struct object **p;\n+\n+  init_object_mutex_once ();\n+  __gthread_mutex_lock (&object_mutex);\n+\n+  p = &objects;\n+  while (*p)\n+    {\n+      if ((*p)->fde_begin == begin)\n+\t{\n+\t  struct object *ob = *p;\n+\t  *p = (*p)->next;\n+\n+\t  /* If we've run init_frame for this object, free the FDE array.  */\n+\t  if (ob->fde_array && ob->fde_array != begin)\n+\t    free (ob->fde_array);\n+\n+\t  __gthread_mutex_unlock (&object_mutex);\n+\t  return (void *) ob;\n+\t}\n+      p = &((*p)->next);\n+    }\n+\n+  __gthread_mutex_unlock (&object_mutex);\n+  abort ();\n+}\n+\n+void\n+__deregister_frame (void *begin)\n+{\n+  free (__deregister_frame_info (begin));\n+}\n+\n+\f\n /* Sorting an array of FDEs by address.\n    (Ideally we would have the linker sort the FDEs so we don't have to do\n    it at run time. But the linkers are not yet prepared for this.)  */\n@@ -56,6 +178,12 @@ typedef struct fde_accumulator\n   fde_vector erratic;\n } fde_accumulator;\n \n+static inline saddr\n+fde_compare (fde *x, fde *y)\n+{\n+  return (saddr)x->pc_begin - (saddr)y->pc_begin;\n+}\n+\n static inline int\n start_fde_sort (fde_accumulator *accu, size_t count)\n {\n@@ -241,97 +369,174 @@ end_fde_sort (fde_accumulator *accu, size_t count)\n   return accu->linear.array;\n }\n \n-/* Called from crtbegin.o to register the unwind info for an object.  */\n+\f\n+static size_t\n+count_fdes (fde *this_fde)\n+{\n+  size_t count;\n \n-void\n-__register_frame_info (void *begin, struct object *ob)\n+  for (count = 0; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    /* Skip CIEs and omitted link-once FDE entries.  */\n+    if (this_fde->CIE_delta != 0 && this_fde->pc_begin != 0)\n+      ++count;\n+\n+  return count;\n+}\n+\n+static void\n+add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n {\n-  ob->fde_begin = begin;\n+  void *pc_begin = *beg_ptr;\n+  void *pc_end = *end_ptr;\n \n-  ob->pc_begin = ob->pc_end = 0;\n-  ob->fde_array = 0;\n-  ob->count = 0;\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n+        continue;\n \n-  init_object_mutex_once ();\n-  __gthread_mutex_lock (&object_mutex);\n+      fde_insert (accu, this_fde);\n \n-  ob->next = objects;\n-  objects = ob;\n+      if (this_fde->pc_begin < pc_begin)\n+        pc_begin = this_fde->pc_begin;\n+      if (this_fde->pc_begin + this_fde->pc_range > pc_end)\n+        pc_end = this_fde->pc_begin + this_fde->pc_range;\n+    }\n \n-  __gthread_mutex_unlock (&object_mutex);\n+  *beg_ptr = pc_begin;\n+  *end_ptr = pc_end;\n }\n \n-void\n-__register_frame (void *begin)\n+static fde *\n+search_fdes (fde *this_fde, void *pc)\n {\n-  struct object *ob = (struct object *) malloc (sizeof (struct object));\n-  __register_frame_info (begin, ob);                       \n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n+        continue;\n+\n+      if ((uaddr)((char *)pc - (char *)this_fde->pc_begin) < this_fde->pc_range)\n+        return this_fde;\n+    }\n+  return NULL;\n }\n \n-/* Similar, but BEGIN is actually a pointer to a table of unwind entries\n-   for different translation units.  Called from the file generated by\n-   collect2.  */\n+/* Set up a sorted array of pointers to FDEs for a loaded object.  We\n+   count up the entries before allocating the array because it's likely to\n+   be faster.  We can be called multiple times, should we have failed to\n+   allocate a sorted fde array on a previous occasion.  */\n \n-void\n-__register_frame_info_table (void *begin, struct object *ob)\n+static void\n+frame_init (struct object* ob)\n {\n-  ob->fde_begin = begin;\n-  ob->fde_array = begin;\n-\n-  ob->pc_begin = ob->pc_end = 0;\n-  ob->count = 0;\n+  size_t count;\n+  fde_accumulator accu;\n+  void *pc_begin, *pc_end;\n+  fde **array;\n \n-  init_object_mutex_once ();\n-  __gthread_mutex_lock (&object_mutex);\n+  if (ob->pc_begin)\n+    count = ob->count;\n+  else if (ob->fde_array)\n+    {\n+      fde **p = ob->fde_array;\n+      for (count = 0; *p; ++p)\n+        count += count_fdes (*p);\n+    }\n+  else\n+    count = count_fdes (ob->fde_begin);\n+  ob->count = count;\n \n-  ob->next = objects;\n-  objects = ob;\n+  if (!start_fde_sort (&accu, count) && ob->pc_begin)\n+    return;\n \n-  __gthread_mutex_unlock (&object_mutex);\n-}\n+  pc_begin = (void*)(uaddr)-1;\n+  pc_end = 0;\n \n-void\n-__register_frame_table (void *begin)\n-{\n-  struct object *ob = (struct object *) malloc (sizeof (struct object));\n-  __register_frame_info_table (begin, ob);\n+  if (ob->fde_array)\n+    {\n+      fde **p = ob->fde_array;\n+      for (; *p; ++p)\n+        add_fdes (*p, &accu, &pc_begin, &pc_end);\n+    }\n+  else\n+    add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n+  array = end_fde_sort (&accu, count);\n+  if (array)\n+    ob->fde_array = array;\n+  ob->pc_begin = pc_begin;\n+  ob->pc_end = pc_end;\n }\n \n-/* Called from crtbegin.o to deregister the unwind info for an object.  */\n-\n-void *\n-__deregister_frame_info (void *begin)\n+fde *\n+_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n {\n-  struct object **p;\n+  struct object *ob;\n+  size_t lo, hi;\n \n   init_object_mutex_once ();\n   __gthread_mutex_lock (&object_mutex);\n \n-  p = &objects;\n-  while (*p)\n+  /* Linear search through the objects, to find the one containing the pc. */\n+  for (ob = objects; ob; ob = ob->next)\n     {\n-      if ((*p)->fde_begin == begin)\n-\t{\n-\t  struct object *ob = *p;\n-\t  *p = (*p)->next;\n+      if (ob->pc_begin == 0)\n+        frame_init (ob);\n+      if (pc >= ob->pc_begin && pc < ob->pc_end)\n+        break;\n+    }\n \n-\t  /* If we've run init_frame for this object, free the FDE array.  */\n-\t  if (ob->fde_array && ob->fde_array != begin)\n-\t    free (ob->fde_array);\n+  if (ob == 0)\n+    {\n+      __gthread_mutex_unlock (&object_mutex);\n+      return 0;\n+    }\n \n-\t  __gthread_mutex_unlock (&object_mutex);\n-\t  return (void *) ob;\n-\t}\n-      p = &((*p)->next);\n+  if (!ob->fde_array || (void *)ob->fde_array == (void *)ob->fde_begin)\n+    frame_init (ob);\n+\n+  if (ob->fde_array && (void *)ob->fde_array != (void *)ob->fde_begin)\n+    {\n+      __gthread_mutex_unlock (&object_mutex);\n+      \n+      /* Standard binary search algorithm.  */\n+      for (lo = 0, hi = ob->count; lo < hi; )\n+        {\n+          size_t i = (lo + hi) / 2;\n+          fde *f = ob->fde_array[i];\n+\n+          if (pc < f->pc_begin)\n+            hi = i;\n+          else if (pc >= f->pc_begin + f->pc_range)\n+            lo = i + 1;\n+          else\n+            return f;\n+        }\n     }\n+  else\n+    {\n+      /* Long slow labourious linear search, cos we've no memory. */\n+      fde *f;\n+      \n+      if (ob->fde_array)\n+        {\n+          fde **p = ob->fde_array;\n+          \n+          do\n+            {\n+              f = search_fdes (*p, pc);\n+              if (f)\n+                break;\n+              p++;\n+            }\n+          while (*p);\n+        }\n+      else\n+        f = search_fdes (ob->fde_begin, pc);\n \n-  __gthread_mutex_unlock (&object_mutex);\n-  abort ();\n-}\n+      __gthread_mutex_unlock (&object_mutex);\n+      return f;\n+    }\n \n-void\n-__deregister_frame (void *begin)\n-{\n-  free (__deregister_frame_info (begin));\n+  return 0;\n }\n-", "previous_filename": "gcc/frame.c"}, {"sha": "83b519a48b92587b85e78be324ee52a67311faf0", "filename": "gcc/unwind-dw2-fde.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-dw2-fde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-dw2-fde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,120 @@\n+/* Subroutines needed for unwinding stack frames for exception handling.  */\n+/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill <jason@cygnus.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* Describes data used to hold onto one shared object or object file.  */\n+struct object\n+{\n+  void *pc_begin;\n+  void *pc_end;\n+  struct dwarf_fde *fde_begin;\n+  struct dwarf_fde **fde_array;\n+  size_t count;\n+  struct object *next;\n+};\n+\n+struct dwarf_eh_bases\n+{\n+  void *tbase;\n+  void *dbase;\n+  void *func;\n+};\n+\n+\n+extern void __register_frame_info (void *, struct object *);\n+extern void __register_frame (void *);\n+extern void __register_frame_info_table (void *, struct object *);\n+extern void __register_frame_table (void *);\n+extern void *__deregister_frame_info (void *);\n+extern void __deregister_frame (void *);\n+\n+\f\n+typedef          int  sword __attribute__ ((mode (SI)));\n+typedef unsigned int  uword __attribute__ ((mode (SI)));\n+typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n+typedef          int  saddr __attribute__ ((mode (pointer)));\n+typedef unsigned char ubyte;\n+\n+/* Terminology:\n+   CIE - Common Information Element\n+   FDE - Frame Descriptor Element\n+\n+   There is one per function, and it describes where the function code\n+   is located, and what the register lifetimes and stack layout are\n+   within the function.\n+\n+   The data structures are defined in the DWARF specfication, although\n+   not in a very readable way (see LITERATURE).\n+\n+   Every time an exception is thrown, the code needs to locate the FDE\n+   for the current function, and starts to look for exception regions\n+   from that FDE. This works in a two-level search:\n+   a) in a linear search, find the shared image (i.e. DLL) containing\n+      the PC\n+   b) using the FDE table for that shared object, locate the FDE using\n+      binary search (which requires the sorting).  */   \n+\n+/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n+   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n+   unit boundary, but the fields within are unaligned.  */\n+struct dwarf_cie\n+{\n+  uword length;\n+  sword CIE_id;\n+  ubyte version;\n+  unsigned char augmentation[];\n+} __attribute__ ((packed, aligned (__alignof__ (void *))));\n+\n+/* The first few fields of an FDE.  */\n+struct dwarf_fde\n+{\n+  uword length;\n+  sword CIE_delta;\n+  void * pc_begin;\n+  uaddr pc_range;\n+} __attribute__ ((packed, aligned (__alignof__ (void *))));\n+\n+typedef struct dwarf_fde fde;\n+\n+/* Locate the CIE for a given FDE.  */\n+\n+static inline struct dwarf_cie *\n+get_cie (struct dwarf_fde *f)\n+{\n+  return (void *)&f->CIE_delta - f->CIE_delta;\n+}\n+\n+static inline fde *\n+next_fde (fde *f)\n+{\n+  return (fde *)((char *)f + f->length + sizeof (f->length));\n+}\n+\n+extern fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);"}, {"sha": "e2f20c9ee107306a6bd7db48fbb68a8476ad1ad4", "filename": "gcc/unwind-dw2.c", "status": "added", "additions": 1217, "deletions": 0, "changes": 1217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,1217 @@\n+/* DWARF2 exception handling and frame unwind runtime interface routines.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"dwarf2.h\"\n+#include \"unwind.h\"\n+#include \"unwind-dw2-fde.h\"\n+#include \"gthr.h\"\n+\n+\n+#if !USING_SJLJ_EXCEPTIONS\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+#define STACK_GROWS_DOWNWARD 0\n+#else\n+#undef STACK_GROWS_DOWNWARD\n+#define STACK_GROWS_DOWNWARD 1\n+#endif\n+\n+/* A target can override (perhaps for backward compatibility) how\n+   many dwarf2 columns are unwound.  */\n+#ifndef DWARF_FRAME_REGISTERS\n+#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n+#endif\n+\n+/* This is the register and unwind state for a particular frame.  */\n+struct _Unwind_Context\n+{\n+  void *reg[DWARF_FRAME_REGISTERS+1];\n+  void *cfa;\n+  void *ra;\n+  void *lsda;\n+  struct dwarf_eh_bases bases;\n+  _Unwind_Word args_size;\n+};\n+\n+/* Byte size of every register managed by these routines.  */\n+static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS];\n+\n+\f\n+/* The result of interpreting the frame unwind info for a frame.\n+   This is all symbolic at this point, as none of the values can\n+   be resolved until the target pc is located.  */\n+typedef struct\n+{\n+  /* Each register save state can be described in terms of a CFA slot,\n+     another register, or a location expression.  */\n+  struct frame_state_reg_info\n+  {\n+    struct {\n+      union {\n+\tunsigned int reg;\n+\t_Unwind_Sword offset;\n+\tunsigned char *exp;\n+      } loc;\n+      enum {\n+\tREG_UNSAVED,\n+\tREG_SAVED_OFFSET,\n+\tREG_SAVED_REG,\n+\tREG_SAVED_EXP,\n+      } how;\n+    } reg[DWARF_FRAME_REGISTERS+1];\n+\n+    /* Used to implement DW_CFA_remember_state.  */\n+    struct frame_state_reg_info *prev;\n+  } regs;\n+\n+  /* The CFA can be described in terms of a reg+offset or a\n+     location expression.  */\n+  _Unwind_Sword cfa_offset;\n+  _Unwind_Word cfa_reg;\n+  unsigned char *cfa_exp;\n+  enum {\n+    CFA_UNSET,\n+    CFA_REG_OFFSET,\n+    CFA_EXP,\n+  } cfa_how;\n+\n+  /* The PC described by the current frame state.  */\n+  void *pc;\n+\n+  /* The information we care about from the CIE/FDE.  */\n+  _Unwind_Personality_Fn personality;\n+  signed int data_align;\n+  unsigned int code_align;\n+  unsigned char retaddr_column;\n+  unsigned char addr_encoding;\n+  unsigned char saw_z;\n+  unsigned char saw_lsda;\n+} _Unwind_FrameState;\n+\f\n+/* Decode the unsigned LEB128 constant at BUF into the variable pointed to\n+   by R, and return the new value of BUF.  */\n+\n+static unsigned char *\n+read_uleb128 (unsigned char *buf, _Unwind_Word *r)\n+{\n+  unsigned shift = 0;\n+  _Unwind_Word result = 0;\n+\n+  while (1)\n+    {\n+      unsigned char byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+      shift += 7;\n+    }\n+  *r = result;\n+  return buf;\n+}\n+\n+/* Decode the signed LEB128 constant at BUF into the variable pointed to\n+   by R, and return the new value of BUF.  */\n+\n+static unsigned char *\n+read_sleb128 (unsigned char *buf, _Unwind_Sword *r)\n+{\n+  unsigned shift = 0;\n+  _Unwind_Sword result = 0;\n+  unsigned char byte;\n+\n+  while (1)\n+    {\n+      byte = *buf++;\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+    }\n+  if (shift < (sizeof (*r) * 8) && (byte & 0x40) != 0)\n+    result |= - (1 << shift);\n+\n+  *r = result;\n+  return buf;\n+}\n+\n+/* Read unaligned data from the instruction buffer.  */\n+\n+union unaligned\n+{\n+  void *p;\n+  unsigned u2 __attribute__ ((mode (HI)));\n+  unsigned u4 __attribute__ ((mode (SI)));\n+  unsigned u8 __attribute__ ((mode (DI)));\n+  signed s2 __attribute__ ((mode (HI)));\n+  signed s4 __attribute__ ((mode (SI)));\n+  signed s8 __attribute__ ((mode (DI)));\n+} __attribute__ ((packed));\n+\n+static inline void *\n+read_pointer (void *p) { union unaligned *up = p; return up->p; }\n+\n+static inline int\n+read_1u (void *p) { return *(unsigned char *)p; }\n+\n+static inline int\n+read_1s (void *p) { return *(signed char *)p; }\n+\n+static inline int\n+read_2u (void *p) { union unaligned *up = p; return up->u2; }\n+\n+static inline int\n+read_2s (void *p) { union unaligned *up = p; return up->s2; }\n+\n+static inline unsigned int\n+read_4u (void *p) { union unaligned *up = p; return up->u4; }\n+\n+static inline int\n+read_4s (void *p) { union unaligned *up = p; return up->s4; }\n+\n+static inline unsigned long\n+read_8u (void *p) { union unaligned *up = p; return up->u8; }\n+\n+static inline unsigned long\n+read_8s (void *p) { union unaligned *up = p; return up->s8; }\n+\n+static unsigned char *\n+read_encoded_pointer (unsigned char *p, unsigned char encoding,\n+\t\t      struct dwarf_eh_bases *bases, void **pptr)\n+{\n+  signed long val;\n+  unsigned char *ret;\n+  \n+  switch (encoding & 0x0f)\n+    {\n+    case DW_EH_PE_absptr:\n+      val = (_Unwind_Ptr) read_pointer (p);\n+      ret = p + sizeof (void *);\n+      break;\n+\n+    case DW_EH_PE_uleb128:\n+      ret = read_uleb128 (p, &val);\n+      break;\n+    case DW_EH_PE_sleb128:\n+      ret = read_sleb128 (p, &val);\n+      break;\n+\n+    case DW_EH_PE_udata2:\n+      val = read_2u (p);\n+      ret = p + 2;\n+      break;\n+    case DW_EH_PE_udata4:\n+      val = read_4u (p);\n+      ret = p + 4;\n+      break;\n+    case DW_EH_PE_udata8:\n+      val = read_8u (p);\n+      ret = p + 8;\n+      break;\n+\n+    case DW_EH_PE_sdata2:\n+      val = read_2s (p);\n+      ret = p + 2;\n+      break;\n+    case DW_EH_PE_sdata4:\n+      val = read_4s (p);\n+      ret = p + 4;\n+      break;\n+    case DW_EH_PE_sdata8:\n+      val = read_8s (p);\n+      ret = p + 8;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (val != 0)\n+    switch (encoding & 0xf0)\n+      {\n+      case DW_EH_PE_absptr:\n+\tbreak;\n+      case DW_EH_PE_pcrel:\n+\tval += (_Unwind_Ptr) p;\n+\tbreak;\n+      case DW_EH_PE_textrel:\n+\tval += (_Unwind_Ptr) bases->tbase;\n+\tbreak;\n+      case DW_EH_PE_datarel:\n+\tval += (_Unwind_Ptr) bases->dbase;\n+\tbreak;\n+      case DW_EH_PE_funcrel:\n+\tval += (_Unwind_Ptr) bases->func;\n+\tbreak;\n+      default:\n+\tabort ();\n+      }\n+\n+  *pptr = (void *) (_Unwind_Ptr) val;\n+  return ret;\n+}\n+\f\n+/* Get the value of register REG as saved in CONTEXT.  */\n+\n+inline _Unwind_Word\n+_Unwind_GetGR (struct _Unwind_Context *context, int index)\n+{\n+  /* This will segfault if the register hasn't been saved.  */\n+  return * (_Unwind_Word *) context->reg[index];\n+}\n+\n+/* Overwrite the saved value for register REG in CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n+{\n+  * (_Unwind_Word *) context->reg[index] = val;\n+}\n+\n+/* Retrieve the return address for CONTEXT.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIP (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->ra;\n+}\n+\n+/* Overwrite the return address for CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)\n+{\n+  context->ra = (void *) val;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)\n+{\n+  return context->lsda;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.func;\n+}\n+\n+\f\n+/* Extract any interesting information from the CIE for the translation\n+   unit F belongs to.  Return a pointer to the byte after the augmentation,\n+   or NULL if we encountered an undecipherable augmentation.  */\n+\n+static unsigned char *\n+extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n+\t\t  _Unwind_FrameState *fs)\n+{\n+  unsigned char *aug = cie->augmentation;\n+  unsigned char *p = aug + strlen (aug) + 1;\n+  unsigned char *ret = NULL;\n+  _Unwind_Word code_align;\n+  _Unwind_Sword data_align;\n+\n+  /* Immediately following the augmentation are the code and\n+     data alignment and return address column.  */\n+  p = read_uleb128 (p, &code_align);\n+  p = read_sleb128 (p, &data_align);\n+  fs->code_align = code_align;\n+  fs->data_align = data_align;\n+  fs->retaddr_column = *p++;\n+\n+  /* If the augmentation starts with 'z', then a uleb128 immediately\n+     follows containing the length of the augmentation field following\n+     the size.  */\n+  if (*aug == 'z')\n+    {\n+      _Unwind_Word i;\n+      p = read_uleb128 (p, &i);\n+      ret = p + i;\n+\n+      fs->saw_z = 1;\n+      ++aug;\n+    }\n+\n+  /* Iterate over recognized augmentation subsequences.  */\n+  while (*aug != '\\0')\n+    {\n+      /* \"eh\" was used by g++ v2; recognize and skip.  */\n+      if (aug[0] == 'e' && aug[1] == 'h')\n+\t{\n+\t  p += sizeof (void *);\n+\t  aug += 2;\n+\t}\n+\n+      /* \"R\" indicates a byte indicating how addresses are encoded.  */\n+      else if (aug[0] == 'R')\n+\t{\n+\t  fs->addr_encoding = *p++;\n+\t  aug += 1;\n+\t}\n+\n+      /* \"P\" indicates a personality routine in the CIE augmentation\n+\t and an lsda pointer in the FDE augmentation.  */\n+      else if (aug[0] == 'P')\n+\t{\n+\t  p = read_encoded_pointer (p, fs->addr_encoding, &context->bases,\n+\t\t\t\t    (void **) &fs->personality);\n+\t  fs->saw_lsda = 1;\n+\t  aug += 1;\n+\t}\n+\n+      /* Otherwise we have an unknown augmentation string.\n+\t Bail unless we saw a 'z' prefix.  */\n+      else\n+\treturn ret;\n+    }\n+\n+  return ret ? ret : p;\n+}\n+\n+\n+/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL\n+   onto the stack to start.  */\n+\n+static _Unwind_Word\n+execute_stack_op (unsigned char *op_ptr, unsigned char *op_end,\n+\t\t  struct _Unwind_Context *context, _Unwind_Word initial)\n+{\n+  _Unwind_Word stack[64];\t/* ??? Assume this is enough. */\n+  int stack_elt;\n+\n+  stack[0] = initial;\n+  stack_elt = 1;\n+\n+  while (op_ptr < op_end)\n+    {\n+      enum dwarf_location_atom op = *op_ptr++;\n+      _Unwind_Word result, reg;\n+      _Unwind_Sword offset;\n+\n+      switch (op)\n+\t{\n+\tcase DW_OP_lit0:\n+\tcase DW_OP_lit1:\n+\tcase DW_OP_lit2:\n+\tcase DW_OP_lit3:\n+\tcase DW_OP_lit4:\n+\tcase DW_OP_lit5:\n+\tcase DW_OP_lit6:\n+\tcase DW_OP_lit7:\n+\tcase DW_OP_lit8:\n+\tcase DW_OP_lit9:\n+\tcase DW_OP_lit10:\n+\tcase DW_OP_lit11:\n+\tcase DW_OP_lit12:\n+\tcase DW_OP_lit13:\n+\tcase DW_OP_lit14:\n+\tcase DW_OP_lit15:\n+\tcase DW_OP_lit16:\n+\tcase DW_OP_lit17:\n+\tcase DW_OP_lit18:\n+\tcase DW_OP_lit19:\n+\tcase DW_OP_lit20:\n+\tcase DW_OP_lit21:\n+\tcase DW_OP_lit22:\n+\tcase DW_OP_lit23:\n+\tcase DW_OP_lit24:\n+\tcase DW_OP_lit25:\n+\tcase DW_OP_lit26:\n+\tcase DW_OP_lit27:\n+\tcase DW_OP_lit28:\n+\tcase DW_OP_lit29:\n+\tcase DW_OP_lit30:\n+\tcase DW_OP_lit31:\n+\t  result = op - DW_OP_lit0;\n+\t  break;\n+\n+\tcase DW_OP_addr:\n+\t  result = (_Unwind_Word) (_Unwind_Ptr) read_pointer (op_ptr);\n+\t  op_ptr += sizeof (void *);\n+\t  break;\n+\n+\tcase DW_OP_const1u:\n+\t  result = read_1u (op_ptr);\n+\t  op_ptr += 1;\n+\t  break;\n+\tcase DW_OP_const1s:\n+\t  result = read_1s (op_ptr);\n+\t  op_ptr += 1;\n+\t  break;\n+\tcase DW_OP_const2u:\n+\t  result = read_2u (op_ptr);\n+\t  op_ptr += 2;\n+\t  break;\n+\tcase DW_OP_const2s:\n+\t  result = read_2s (op_ptr);\n+\t  op_ptr += 2;\n+\t  break;\n+\tcase DW_OP_const4u:\n+\t  result = read_4u (op_ptr);\n+\t  op_ptr += 4;\n+\t  break;\n+\tcase DW_OP_const4s:\n+\t  result = read_4s (op_ptr);\n+\t  op_ptr += 4;\n+\t  break;\n+\tcase DW_OP_const8u:\n+\t  result = read_8u (op_ptr);\n+\t  op_ptr += 8;\n+\t  break;\n+\tcase DW_OP_const8s:\n+\t  result = read_8s (op_ptr);\n+\t  op_ptr += 8;\n+\t  break;\n+\tcase DW_OP_constu:\n+\t  op_ptr = read_uleb128 (op_ptr, &result);\n+\t  break;\n+\tcase DW_OP_consts:\n+\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  result = offset;\n+\t  break;\n+\n+\tcase DW_OP_reg0:\n+\tcase DW_OP_reg1:\n+\tcase DW_OP_reg2:\n+\tcase DW_OP_reg3:\n+\tcase DW_OP_reg4:\n+\tcase DW_OP_reg5:\n+\tcase DW_OP_reg6:\n+\tcase DW_OP_reg7:\n+\tcase DW_OP_reg8:\n+\tcase DW_OP_reg9:\n+\tcase DW_OP_reg10:\n+\tcase DW_OP_reg11:\n+\tcase DW_OP_reg12:\n+\tcase DW_OP_reg13:\n+\tcase DW_OP_reg14:\n+\tcase DW_OP_reg15:\n+\tcase DW_OP_reg16:\n+\tcase DW_OP_reg17:\n+\tcase DW_OP_reg18:\n+\tcase DW_OP_reg19:\n+\tcase DW_OP_reg20:\n+\tcase DW_OP_reg21:\n+\tcase DW_OP_reg22:\n+\tcase DW_OP_reg23:\n+\tcase DW_OP_reg24:\n+\tcase DW_OP_reg25:\n+\tcase DW_OP_reg26:\n+\tcase DW_OP_reg27:\n+\tcase DW_OP_reg28:\n+\tcase DW_OP_reg29:\n+\tcase DW_OP_reg30:\n+\tcase DW_OP_reg31:\n+\t  result = _Unwind_GetGR (context, op - DW_OP_reg0);\n+\t  break;\n+\tcase DW_OP_regx:\n+\t  op_ptr = read_uleb128 (op_ptr, &reg);\n+\t  result = _Unwind_GetGR (context, reg);\n+\t  break;\n+\n+\tcase DW_OP_breg0:\n+\tcase DW_OP_breg1:\n+\tcase DW_OP_breg2:\n+\tcase DW_OP_breg3:\n+\tcase DW_OP_breg4:\n+\tcase DW_OP_breg5:\n+\tcase DW_OP_breg6:\n+\tcase DW_OP_breg7:\n+\tcase DW_OP_breg8:\n+\tcase DW_OP_breg9:\n+\tcase DW_OP_breg10:\n+\tcase DW_OP_breg11:\n+\tcase DW_OP_breg12:\n+\tcase DW_OP_breg13:\n+\tcase DW_OP_breg14:\n+\tcase DW_OP_breg15:\n+\tcase DW_OP_breg16:\n+\tcase DW_OP_breg17:\n+\tcase DW_OP_breg18:\n+\tcase DW_OP_breg19:\n+\tcase DW_OP_breg20:\n+\tcase DW_OP_breg21:\n+\tcase DW_OP_breg22:\n+\tcase DW_OP_breg23:\n+\tcase DW_OP_breg24:\n+\tcase DW_OP_breg25:\n+\tcase DW_OP_breg26:\n+\tcase DW_OP_breg27:\n+\tcase DW_OP_breg28:\n+\tcase DW_OP_breg29:\n+\tcase DW_OP_breg30:\n+\tcase DW_OP_breg31:\n+\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;\n+\t  break;\n+\tcase DW_OP_bregx:\n+\t  op_ptr = read_uleb128 (op_ptr, &reg);\n+\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  result = _Unwind_GetGR (context, reg) + offset;\n+\t  break;\n+\n+\tcase DW_OP_dup:\n+\t  if (stack_elt < 1)\n+\t    abort ();\n+\t  result = stack[stack_elt - 1];\n+\t  break;\n+\n+\tcase DW_OP_drop:\n+\t  if (--stack_elt < 0)\n+\t    abort ();\n+\t  goto no_push;\n+\n+\tcase DW_OP_pick:\n+\t  offset = *op_ptr++;\n+\t  if (offset >= stack_elt - 1)\n+\t    abort ();\n+\t  result = stack[stack_elt - 1 - offset];\n+\t  break;\n+\n+\tcase DW_OP_over:\n+\t  if (stack_elt < 2)\n+\t    abort ();\n+\t  result = stack[stack_elt - 2];\n+\t  break;\n+\n+\tcase DW_OP_rot:\n+\t  {\n+\t    _Unwind_Word t1, t2, t3;\n+\n+\t    if (stack_elt < 3)\n+\t      abort ();\n+\t    t1 = stack[stack_elt - 1];\n+\t    t2 = stack[stack_elt - 2];\n+\t    t3 = stack[stack_elt - 3];\n+\t    stack[stack_elt - 1] = t2;\n+\t    stack[stack_elt - 2] = t3;\n+\t    stack[stack_elt - 3] = t1;\n+\t    goto no_push;\n+\t  }\n+\n+\tcase DW_OP_deref:\n+\tcase DW_OP_deref_size:\n+\tcase DW_OP_abs:\n+\tcase DW_OP_neg:\n+\tcase DW_OP_not:\n+\tcase DW_OP_plus_uconst:\n+\t  /* Unary operations.  */\n+\t  if (--stack_elt < 0)\n+\t    abort ();\n+\t  result = stack[stack_elt];\n+\n+\t  switch (op)\n+\t    {\n+\t    case DW_OP_deref:\n+\t      {\n+\t\tvoid *ptr = (void *)(_Unwind_Ptr) result;\n+\t\tresult = (_Unwind_Ptr) read_pointer (ptr);\n+\t      }\n+\t      break;\n+\n+\t    case DW_OP_deref_size:\n+\t      {\n+\t\tvoid *ptr = (void *)(_Unwind_Ptr) result;\n+\t\tswitch (*op_ptr++)\n+\t\t  {\n+\t\t  case 1:\n+\t\t    result = read_1u (ptr);\n+\t\t    break;\n+\t\t  case 2:\n+\t\t    result = read_2u (ptr);\n+\t\t    break;\n+\t\t  case 4:\n+\t\t    result = read_4u (ptr);\n+\t\t    break;\n+\t\t  case 8:\n+\t\t    result = read_8u (ptr);\n+\t\t    break;\n+\t\t  default:\n+\t\t    abort ();\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    case DW_OP_abs:\n+\t      if ((_Unwind_Sword) result < 0)\n+\t\tresult = -result;\n+\t      break;\n+\t    case DW_OP_neg:\n+\t      result = -result;\n+\t      break;\n+\t    case DW_OP_not:\n+\t      result = ~result;\n+\t      break;\n+\t    case DW_OP_plus_uconst:\n+\t      op_ptr = read_uleb128 (op_ptr, &reg);\n+\t      result += reg;\n+\t      break;\n+\t    }\n+\t  break;\n+\n+\tcase DW_OP_and:\n+\tcase DW_OP_div:\n+\tcase DW_OP_minus:\n+\tcase DW_OP_mod:\n+\tcase DW_OP_mul:\n+\tcase DW_OP_or:\n+\tcase DW_OP_plus:\n+\tcase DW_OP_le:\n+\tcase DW_OP_ge:\n+\tcase DW_OP_eq:\n+\tcase DW_OP_lt:\n+\tcase DW_OP_gt:\n+\tcase DW_OP_ne:\n+\t  {\n+\t    /* Binary operations.  */\n+\t    _Unwind_Word first, second;\n+\t  if ((stack_elt -= 2) < 0)\n+\t    abort ();\n+\t  second = stack[stack_elt];\n+\t  first = stack[stack_elt + 1];\n+\n+\t  switch (op)\n+\t    {\n+\t    case DW_OP_and:\n+\t      result = second & first;\n+\t      break;\n+\t    case DW_OP_div:\n+\t      result = (_Unwind_Sword)second / (_Unwind_Sword)first;\n+\t      break;\n+\t    case DW_OP_minus:\n+\t      result = second - first;\n+\t      break;\n+\t    case DW_OP_mod:\n+\t      result = (_Unwind_Sword)second % (_Unwind_Sword)first;\n+\t      break;\n+\t    case DW_OP_mul:\n+\t      result = second * first;\n+\t      break;\n+\t    case DW_OP_or:\n+\t      result = second | first;\n+\t      break;\n+\t    case DW_OP_plus:\n+\t      result = second + first;\n+\t      break;\n+\t    case DW_OP_shl:\n+\t      result = second << first;\n+\t      break;\n+\t    case DW_OP_shr:\n+\t      result = second >> first;\n+\t      break;\n+\t    case DW_OP_shra:\n+\t      result = (_Unwind_Sword)second >> first;\n+\t      break;\n+\t    case DW_OP_xor:\n+\t      result = second ^ first;\n+\t      break;\n+\t    case DW_OP_le:\n+\t      result = (_Unwind_Sword)first <= (_Unwind_Sword)second;\n+\t      break;\n+\t    case DW_OP_ge:\n+\t      result = (_Unwind_Sword)first >= (_Unwind_Sword)second;\n+\t      break;\n+\t    case DW_OP_eq:\n+\t      result = (_Unwind_Sword)first == (_Unwind_Sword)second;\n+\t      break;\n+\t    case DW_OP_lt:\n+\t      result = (_Unwind_Sword)first < (_Unwind_Sword)second;\n+\t      break;\n+\t    case DW_OP_gt:\n+\t      result = (_Unwind_Sword)first > (_Unwind_Sword)second;\n+\t      break;\n+\t    case DW_OP_ne:\n+\t      result = (_Unwind_Sword)first != (_Unwind_Sword)second;\n+\t      break;\n+\t    }\n+\t  }\n+\t  break;\n+\n+\tcase DW_OP_skip:\n+\t  offset = read_2s (op_ptr);\n+\t  op_ptr += 2;\n+\t  op_ptr += offset;\n+\t  goto no_push;\n+\n+\tcase DW_OP_bra:\n+\t  if (--stack_elt < 0)\n+\t    abort ();\n+\t  offset = read_2s (op_ptr);\n+\t  op_ptr += 2;\n+\t  if (stack[stack_elt] != 0)\n+\t    op_ptr += offset;\n+\t  goto no_push;\n+\n+\tcase DW_OP_nop:\n+\t  goto no_push;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      /* Most things push a result value.  */\n+      if ((size_t) stack_elt >= sizeof(stack)/sizeof(*stack))\n+\tabort ();\n+      stack[++stack_elt] = result;\n+    no_push:;\n+    }\n+\n+  /* We were executing this program to get a value.  It should be\n+     at top of stack.  */\n+  if (--stack_elt < 0)\n+    abort ();\n+  return stack[stack_elt];\n+}\n+\n+\n+/* Decode DWARF 2 call frame information. Takes pointers the\n+   instruction sequence to decode, current register information and\n+   CIE info, and the PC range to evaluate.  */\n+\n+static void\n+execute_cfa_program (unsigned char *insn_ptr, unsigned char *insn_end,\n+\t\t     struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct frame_state_reg_info *unused_rs = NULL;\n+\n+  /* Don't allow remember/restore between CIE and FDE programs.  */\n+  fs->regs.prev = NULL;\n+\n+  while (insn_ptr < insn_end && fs->pc < context->ra)\n+    {\n+      unsigned char insn = *insn_ptr++;\n+      _Unwind_Word reg, uoffset;\n+      _Unwind_Sword offset;\n+\n+      if (insn & DW_CFA_advance_loc)\n+\tfs->pc += (insn & 0x3f) * fs->code_align;\n+      else if (insn & DW_CFA_offset)\n+\t{\n+\t  reg = insn & 0x3f;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  offset = (_Unwind_Sword)uoffset * fs->data_align;\n+\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[reg].loc.offset = offset;\n+\t}\n+      else if (insn & DW_CFA_restore)\n+\t{\n+\t  reg = insn & 0x3f;\n+\t  fs->regs.reg[reg].how = REG_UNSAVED;\n+\t}\n+      else switch (insn)\n+\t{\n+\tcase DW_CFA_set_loc:\n+\t  insn_ptr = read_encoded_pointer (insn_ptr, fs->addr_encoding,\n+\t\t\t\t\t   &context->bases, &fs->pc);\n+\t  break;\n+\n+\tcase DW_CFA_advance_loc1:\n+\t  fs->pc += read_1u (insn_ptr);\n+\t  insn_ptr += 1;\n+\t  break;\n+\tcase DW_CFA_advance_loc2:\n+\t  fs->pc += read_2u (insn_ptr);\n+\t  insn_ptr += 2;\n+\t  break;\n+\tcase DW_CFA_advance_loc4:\n+\t  fs->pc += read_4u (insn_ptr);\n+\t  insn_ptr += 4;\n+\t  break;\n+\n+\tcase DW_CFA_offset_extended:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  offset = (_Unwind_Sword)uoffset * fs->data_align;\n+\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[reg].loc.offset = offset;\n+\t  break;\n+\n+\tcase DW_CFA_restore_extended:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  fs->regs.reg[reg].how = REG_UNSAVED;\n+\t  break;\n+\n+\tcase DW_CFA_undefined:\n+\tcase DW_CFA_same_value:\n+\tcase DW_CFA_nop:\n+\t  break;\n+\n+\tcase DW_CFA_register:\n+\t  {\n+\t    _Unwind_Word reg2;\n+\t    insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t    insn_ptr = read_uleb128 (insn_ptr, &reg2);\n+\t    fs->regs.reg[reg].how = REG_SAVED_REG;\n+\t    fs->regs.reg[reg].loc.reg = reg2;\n+\t  }\n+\t  break;\n+      \n+\tcase DW_CFA_remember_state:\n+\t  {\n+\t    struct frame_state_reg_info *new_rs;\n+\t    if (unused_rs)\n+\t      {\n+\t\tnew_rs = unused_rs;\n+\t\tunused_rs = unused_rs->prev;\n+\t      }\n+\t    else\n+\t      new_rs = alloca (sizeof (struct frame_state_reg_info));\n+\n+\t    *new_rs = fs->regs;\n+\t    fs->regs.prev = new_rs;\n+\t  }\n+\t  break;\n+\n+\tcase DW_CFA_restore_state:\n+\t  {\n+\t    struct frame_state_reg_info *old_rs = fs->regs.prev;\n+\t    fs->regs = *old_rs;\n+\t    old_rs->prev = unused_rs;\n+\t    unused_rs = old_rs;\n+\t  }\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  fs->cfa_offset = uoffset;\n+\t  fs->cfa_how = CFA_REG_OFFSET;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_register:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n+\t  fs->cfa_how = CFA_REG_OFFSET;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_offset:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  fs->cfa_offset = uoffset;\n+\t  /* cfa_how deliberately not set.  */\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_expression:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  fs->cfa_exp = insn_ptr;\n+\t  fs->cfa_how = CFA_EXP;\n+\t  insn_ptr += uoffset;\n+\t  break;\n+\n+\tcase DW_CFA_expression:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  fs->regs.reg[reg].how = REG_SAVED_EXP;\n+\t  fs->regs.reg[reg].loc.exp = insn_ptr;\n+\t  insn_ptr += uoffset;\n+\t  break;\n+\n+\t  /* From the 2.1 draft.  */\n+\tcase DW_CFA_offset_extended_sf:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_sleb128 (insn_ptr, &offset);\n+\t  offset *= fs->data_align;\n+\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[reg].loc.offset = offset;\n+\t  break;\n+\t  \n+\tcase DW_CFA_def_cfa_sf:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n+\t  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);\n+\t  fs->cfa_how = CFA_REG_OFFSET;\n+\t  break;\n+\n+\tcase DW_CFA_def_cfa_offset_sf:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_offset);\n+\t  /* cfa_how deliberately not set.  */\n+\t  break;\n+\n+\tcase DW_CFA_GNU_window_save:\n+\t  /* ??? Hardcoded for SPARC register window configuration.  */\n+\t  for (reg = 16; reg < 32; ++reg)\n+\t    {\n+\t      fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t      fs->regs.reg[reg].loc.offset = (reg - 16) * sizeof (void *);\n+\t    }\n+\t  break;\n+\n+\tcase DW_CFA_GNU_args_size:\n+\t  insn_ptr = read_uleb128 (insn_ptr, &context->args_size);\n+\t  break;\n+\n+\tcase DW_CFA_GNU_negative_offset_extended:\n+\t  /* Obsoleted by DW_CFA_offset_extended_sf, but used by\n+\t     older PowerPC code.  */\n+\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  offset = (_Unwind_Sword)uoffset * fs->data_align;\n+\t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[reg].loc.offset = -offset;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+}\n+\f\n+static _Unwind_Reason_Code\n+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct dwarf_fde *fde;\n+  struct dwarf_cie *cie;\n+  unsigned char *aug, *insn, *end;\n+\n+  memset (fs, 0, sizeof (*fs));\n+  context->args_size = 0;\n+  context->lsda = 0;\n+\n+  fde = _Unwind_Find_FDE (context->ra - 1, &context->bases);\n+  if (fde == NULL)\n+    {\n+      /* Couldn't find frame unwind info for this function.  Try a\n+\t target-specific fallback mechanism.  This will necessarily\n+\t not profide a personality routine or LSDA.  */\n+#ifdef MD_FALLBACK_FRAME_STATE_FOR\n+      MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);\n+      return _URC_END_OF_STACK;\n+    success:\n+      return _URC_NO_REASON;\n+#else\n+      return _URC_END_OF_STACK;\n+#endif\n+    }\n+\n+  context->bases.func = fde->pc_begin;\n+  fs->pc = fde->pc_begin;\n+\n+  cie = get_cie (fde);\n+  insn = extract_cie_info (cie, context, fs);\n+  if (insn == NULL)\n+    /* CIE contained unknown augmentation.  */\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  /* First decode all the insns in the CIE.  */\n+  end = (unsigned char *) next_fde ((struct dwarf_fde *) cie);\n+  execute_cfa_program (insn, end, context, fs);\n+\n+  /* Locate augmentation for the fde.  */\n+  aug = (unsigned char *)fde + sizeof (*fde);\n+  insn = NULL;\n+  if (fs->saw_z)\n+    {\n+      _Unwind_Word i;\n+      aug = read_uleb128 (aug, &i);\n+      insn = aug + i;\n+    }\n+  if (fs->saw_lsda)\n+    aug = read_encoded_pointer (aug, fs->addr_encoding,\n+\t\t\t\t&context->bases, &context->lsda);\n+\n+  /* Then the insns in the FDE up to our target PC.  */\n+  if (insn == NULL)\n+    insn = aug;\n+  end = (unsigned char *) next_fde (fde);\n+  execute_cfa_program (insn, end, context, fs);\n+\n+  return _URC_NO_REASON;\n+}\n+\n+\n+static void\n+uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct _Unwind_Context orig_context = *context;\n+  void *cfa;\n+  long i;\n+\n+  /* Compute this frame's CFA.  */\n+  switch (fs->cfa_how)\n+    {\n+    case CFA_REG_OFFSET:\n+      /* Special handling here: Many machines do not use a frame pointer,\n+\t and track the CFA only through offsets from the stack pointer from\n+\t one frame to the next.  In this case, the stack pointer is never\n+\t stored, so it has no saved address in the context.  What we do \n+\t have is the CFA from the previous stack frame.  */\n+      if (context->reg[fs->cfa_reg] == NULL)\n+\tcfa = context->cfa;\n+      else\n+\tcfa = (void *) (_Unwind_Ptr) _Unwind_GetGR (context, fs->cfa_reg);\n+      cfa += fs->cfa_offset;\n+      break;\n+\n+    case CFA_EXP:\n+      /* ??? No way of knowing what register number is the stack pointer\n+\t to do the same sort of handling as above.  Assume that if the\n+\t CFA calculation is so complicated as to require a stack program\n+\t that this will not be a problem.  */\n+      {\n+\tunsigned char *exp = fs->cfa_exp;\n+\t_Unwind_Word len;\n+\n+\texp = read_uleb128 (exp, &len);\n+\tcfa = (void *) (_Unwind_Ptr)\n+\t  execute_stack_op (exp, exp + len, context, 0);\n+\tbreak;\n+      }\n+\n+    default:\n+      abort ();\n+    }\n+  context->cfa = cfa;\n+\n+  /* Compute the addresses of all registers saved in this frame.  */\n+  for (i = 0; i < DWARF_FRAME_REGISTERS + 1; ++i)\n+    switch (fs->regs.reg[i].how)\n+      {\n+      case REG_UNSAVED:\n+\tbreak;\n+      case REG_SAVED_OFFSET:\n+\tcontext->reg[i] = cfa + fs->regs.reg[i].loc.offset;\n+\tbreak;\n+      case REG_SAVED_REG:\n+\tcontext->reg[i] = orig_context.reg[fs->regs.reg[i].loc.reg];\n+\tbreak;\n+      case REG_SAVED_EXP:\n+\t{\n+\t  unsigned char *exp = fs->regs.reg[i].loc.exp;\n+\t  _Unwind_Word len;\n+\t  _Unwind_Ptr val;\n+\n+\t  exp = read_uleb128 (exp, &len);\n+\t  val = execute_stack_op (exp, exp + len, &orig_context,\n+\t\t\t\t  (_Unwind_Ptr) cfa);\n+\t  context->reg[i] = (void *) val;\n+\t}\n+\tbreak;\n+      }\n+}\n+\n+static void\n+uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  uw_update_context_1 (context, fs);\n+\n+  /* Compute the return address now, since the return address column\n+     can change from frame to frame.  */\n+  context->ra = __builtin_extract_return_addr\n+    ((void *) (_Unwind_Ptr) _Unwind_GetGR (context, fs->retaddr_column));\n+}\n+\f\n+/* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n+   level will be the return address and the CFA.  */\n+   \n+#define uw_init_context(CONTEXT)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  /* Do any necessary initialization to access arbitrary stack frames.\t\\\n+     On the SPARC, this means flushing the register windows.  */\t\\\n+  __builtin_unwind_init ();\t\t\t\t\t\t\\\n+  uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),\t\t\t\\\n+\t\t     __builtin_return_address (0));\t\t\t\\\n+} while (0)\n+\n+static void\n+uw_init_context_1 (struct _Unwind_Context *context,\n+\t\t   void *outer_cfa, void *outer_ra)\n+{\n+  void *ra = __builtin_extract_return_addr (__builtin_return_address (0));\n+  _Unwind_FrameState fs;\n+\n+  memset (context, 0, sizeof (struct _Unwind_Context));\n+  context->ra = ra;\n+\n+  if (uw_frame_state_for (context, &fs) != _URC_NO_REASON)\n+    abort ();\n+\n+  /* Force the frame state to use the known cfa value.  */\n+  context->cfa = outer_cfa;\n+  fs.cfa_how = CFA_REG_OFFSET;\n+  fs.cfa_reg = 0;\n+  fs.cfa_offset = 0;\n+\n+  uw_update_context_1 (context, &fs);\n+\n+  /* If the return address column was saved in a register in the\n+     initialization context, then we can't see it in the given\n+     call frame data.  So have the initialization context tell us.  */\n+  context->ra = __builtin_extract_return_addr (outer_ra);\n+}\n+\n+\n+/* Install TARGET into CURRENT so that we can return to it.  This is a\n+   macro because __builtin_eh_return must be invoked in the context of\n+   our caller.  */\n+\n+#define uw_install_context(CURRENT, TARGET)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  long offset = uw_install_context_1 ((CURRENT), (TARGET));\t\t\\\n+  void *handler = __builtin_frob_return_addr ((TARGET)->ra);\t\t\\\n+  __builtin_eh_return (offset, handler);\t\t\t\t\\\n+} while (0)\n+\n+static inline void\n+init_dwarf_reg_size_table (void)\n+{\n+  __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);\n+}\n+\n+static long\n+uw_install_context_1 (struct _Unwind_Context *current,\n+\t\t      struct _Unwind_Context *target)\n+{\n+  long i;\n+\n+#if __GTHREADS\n+  {\n+    static __gthread_once_t once_regsizes = __GTHREAD_ONCE_INIT;\n+    if (__gthread_once (&once_regsizes, init_dwarf_reg_size_table) != 0\n+\t|| dwarf_reg_size_table[0] == 0)\n+      init_dwarf_reg_size_table ();\n+  }\n+#else\n+  if (dwarf_reg_size_table[0] == 0)\n+    init_dwarf_reg_size_table ();\n+#endif\n+\n+  for (i = 0; i < DWARF_FRAME_REGISTERS; ++i)\n+    {\n+      void *c = current->reg[i];\n+      void *t = target->reg[i];\n+      if (t && c && t != c)\n+\tmemcpy (c, t, dwarf_reg_size_table[i]);\n+    }\n+\n+  /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */\n+  if (STACK_GROWS_DOWNWARD)\n+    return target->cfa - current->cfa + target->args_size;\n+  else\n+    return current->cfa - target->cfa - target->args_size;\n+}\n+\n+static inline _Unwind_Ptr\n+uw_identify_context (struct _Unwind_Context *context)\n+{\n+  return _Unwind_GetIP (context);\n+}\n+\n+\n+#include \"unwind.inc\"\n+\n+#endif /* !USING_SJLJ_EXCEPTIONS */"}, {"sha": "662968bd001665f0463e9c7829ba7a529e591f97", "filename": "gcc/unwind-sjlj.c", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-sjlj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind-sjlj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-sjlj.c?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,259 @@\n+/* DWARF2 exception handling and frame unwind runtime interface routines.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"unwind.h\"\n+#include \"gthr.h\"\n+\n+#if USING_SJLJ_EXCEPTIONS\n+\n+#ifdef DONT_USE_BUILTIN_SETJMP\n+#include <setjmp.h>\n+#else\n+#define setjmp __builtin_setjmp\n+#define longjmp __builtin_longjmp\n+#endif\n+\n+/* This structure is allocated on the stack of the target function.\n+   This must match the definition created in except.c:init_eh.  */\n+struct SjLj_Function_Context\n+{\n+  /* This is the chain through all registered contexts.  It is\n+     filled in by _Unwind_SjLj_Register.  */\n+  struct SjLj_Function_Context *prev;\n+\n+  /* This is assigned in by the target function before every call\n+     to the index of the call site in the lsda.  It is assigned by\n+     the personality routine to the landing pad index.  */\n+  int call_site;\n+\n+  /* This is how data is returned from the personality routine to\n+     the target function's handler.  */\n+  _Unwind_Word data[4];\n+\n+  /* These are filled in once by the target function before any\n+     exceptions are expected to be handled.  */\n+  _Unwind_Personality_Fn personality;\n+  void *lsda;\n+\n+#ifdef DONT_USE_BUILTIN_SETJMP\n+  /* We don't know what sort of alignment requirements the system\n+     jmp_buf has.  We over estimated in except.c, and now we have\n+     to match that here just in case the system *didn't* have more \n+     restrictive requirements.  */\n+  jmp_buf jbuf __attribute__((aligned));\n+#else\n+  void *jbuf[];\n+#endif\n+};\n+\n+struct _Unwind_Context\n+{\n+  struct SjLj_Function_Context *fc;\n+};\n+\n+typedef struct \n+{\n+  _Unwind_Personality_Fn personality;\n+} _Unwind_FrameState;\n+\n+\f\n+/* Manage the chain of registered function contexts.  */\n+\n+/* Single threaded fallback chain.  */\n+static struct SjLj_Function_Context *fc_static;\n+\n+#if __GTHREADS\n+static __gthread_key_t fc_key;\n+static int use_fc_key = -1;\n+\n+static void\n+fc_key_dtor (void *ptr)\n+{\n+  __gthread_key_dtor (fc_key, ptr);\n+}\n+\n+static void\n+fc_key_init (void)\n+{\n+  use_fc_key = __gthread_key_create (&fc_key, fc_key_dtor) == 0;\n+}\n+\n+static void\n+fc_key_init_once (void)\n+{\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  if (__gthread_once (&once, fc_key_init) != 0 || use_fc_key < 0)\n+    use_fc_key = 0;\n+}\n+#endif\n+\n+void\n+_Unwind_SjLj_Register (struct SjLj_Function_Context *fc)\n+{\n+#if __GTHREADS\n+  if (use_fc_key < 0)\n+    fc_key_init_once ();\n+\n+  if (use_fc_key)\n+    {\n+      fc->prev = __gthread_getspecific (fc_key);\n+      __gthread_setspecific (fc_key, fc);\n+    }\n+  else\n+#endif\n+    {\n+      fc->prev = fc_static;\n+      fc_static = fc;\n+    }\n+}\n+\n+static inline struct SjLj_Function_Context *\n+_Unwind_SjLj_GetContext (void)\n+{\n+#if __GTHREADS\n+  if (use_fc_key < 0)\n+    fc_key_init_once ();\n+\n+  if (use_fc_key)\n+    return __gthread_getspecific (fc_key);\n+#endif\n+  return fc_static;\n+}\n+\n+static inline void\n+_Unwind_SjLj_SetContext (struct SjLj_Function_Context *fc)\n+{\n+#if __GTHREADS\n+  if (use_fc_key < 0)\n+    fc_key_init_once ();\n+\n+  if (use_fc_key)\n+    __gthread_setspecific (fc_key, fc);\n+  else\n+#endif\n+    fc_static = fc;\n+}\n+\n+void\n+_Unwind_SjLj_Unregister (struct SjLj_Function_Context *fc)\n+{\n+  _Unwind_SjLj_SetContext (fc->prev);\n+}\n+\n+\f\n+/* Get/set the return data value at INDEX in CONTEXT.  */\n+\n+_Unwind_Word\n+_Unwind_GetGR (struct _Unwind_Context *context, int index)\n+{\n+  return context->fc->data[index];\n+}\n+\n+void\n+_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n+{\n+  context->fc->data[index] = val;\n+}\n+\n+/* Get the call-site index as saved in CONTEXT.  */\n+\n+_Unwind_Ptr\n+_Unwind_GetIP (struct _Unwind_Context *context)\n+{\n+  return context->fc->call_site + 1;\n+}\n+\n+/* Set the return landing pad index in CONTEXT.  */\n+\n+void\n+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)\n+{\n+  context->fc->call_site = val - 1;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)\n+{\n+  return context->fc->lsda;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (struct _Unwind_Context *context)\n+{\n+  return 0;\n+}\n+\n+\f\n+static inline _Unwind_Reason_Code\n+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  if (context->fc == NULL)\n+    {\n+      fs->personality = NULL;\n+      return _URC_END_OF_STACK;\n+    }\n+  else\n+    {\n+      fs->personality = context->fc->personality;\n+      return _URC_NO_REASON;\n+    }\n+}\n+\n+static inline void\n+uw_update_context (struct _Unwind_Context *context,\n+\t\t   _Unwind_FrameState *fs __attribute__((unused)) )\n+{\n+  context->fc = context->fc->prev;\n+}\n+\n+static inline void \n+uw_init_context (struct _Unwind_Context *context)\n+{\n+  context->fc = _Unwind_SjLj_GetContext ();\n+}\n+\n+/* ??? There appear to be bugs in integrate.c wrt __builtin_longjmp and\n+   virtual-stack-vars.  An inline version of this segfaults on Sparc.  */\n+#define uw_install_context(CURRENT, TARGET)\t\\\n+  do {\t\t\t\t\t\t\\\n+    _Unwind_SjLj_SetContext ((TARGET)->fc);\t\\\n+    longjmp ((TARGET)->fc->jbuf, 1);\t\t\\\n+  } while (0)\n+\n+\n+static inline _Unwind_Ptr\n+uw_identify_context (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->fc;\n+}\n+\n+\n+/* Play games with unwind symbols so that we can have call frame\n+   and sjlj symbols in the same shared library.  Not that you can\n+   use them simultaneously...  */\n+#define _Unwind_RaiseException\t\t_Unwind_SjLj_RaiseException\n+#define _Unwind_ForcedUnwind\t\t_Unwind_SjLj_ForcedUnwind\n+#define _Unwind_Resume\t\t\t_Unwind_SjLj_Resume\n+\n+#include \"unwind.inc\"\n+\n+#endif /* USING_SJLJ_EXCEPTIONS */"}, {"sha": "8df0930e9176a7bfbcd76abe2d0681e7b85598f6", "filename": "gcc/unwind.h", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,166 @@\n+/* Exception handling and frame unwind runtime interface routines.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This is derived from the C++ ABI for IA-64.  Where we diverge\n+   for cross-architecture compatibility are noted with \"@@@\".  */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Level 1: Base ABI  */\n+\n+/* @@@ The IA-64 ABI uses uint64 throughout.  Most places this is\n+   inefficient for 32-bit and smaller machines.  */\n+typedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));\n+typedef signed _Unwind_Sword __attribute__((__mode__(__word__)));\n+typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));\n+\n+/* @@@ The IA-64 ABI uses a 64-bit word to identify the producer and\n+   consumer of an exception.  We'll go along with this for now even on\n+   32-bit machines.  We'll need to provide some other option for\n+   16-bit machines and for machines with > 8 bits per byte.  */\n+typedef unsigned _Unwind_Exception_Class __attribute__((__mode__(__DI__)));\n+\n+/* The unwind interface uses reason codes in several contexts to\n+   identify the reasons for failures or other actions.  */\n+typedef enum\n+{\n+  _URC_NO_REASON = 0,\n+  _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+  _URC_FATAL_PHASE2_ERROR = 2,\n+  _URC_FATAL_PHASE1_ERROR = 3,\n+  _URC_NORMAL_STOP = 4,\n+  _URC_END_OF_STACK = 5,\n+  _URC_HANDLER_FOUND = 6,\n+  _URC_INSTALL_CONTEXT = 7,\n+  _URC_CONTINUE_UNWIND = 8\n+} _Unwind_Reason_Code;\n+\n+\n+/* The unwind interface uses a pointer to an exception header object\n+   as its representation of an exception being thrown. In general, the\n+   full representation of an exception object is language- and\n+   implementation-specific, but it will be prefixed by a header\n+   understood by the unwind interface.  */\n+\n+struct _Unwind_Exception;\n+\n+typedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,\n+\t\t\t\t\t      struct _Unwind_Exception *);\n+\n+struct _Unwind_Exception\n+{\n+  _Unwind_Exception_Class exception_class;\n+  _Unwind_Exception_Cleanup_Fn exception_cleanup;\n+  _Unwind_Word private_1;\n+  _Unwind_Word private_2;\n+\n+  /* @@@ The IA-64 ABI says that this structure must be double-word aligned.\n+     Taking that literally does not make much sense generically.  Instead we\n+     provide the maximum alignment required by any type for the machine.  */\n+} __attribute__((__aligned__));\n+\n+\n+/* The ACTIONS argument to the personality routine is a bitwise OR of one\n+   or more of the following constants.  */\n+typedef int _Unwind_Action;\n+\n+#define _UA_SEARCH_PHASE\t1\n+#define _UA_CLEANUP_PHASE\t2\n+#define _UA_HANDLER_FRAME\t4\n+#define _UA_FORCE_UNWIND\t8\n+\n+/* This is an opaque type used to refer to a system-specific data\n+   structure used by the system unwinder. This context is created and\n+   destroyed by the system, and passed to the personality routine\n+   during unwinding.  */\n+struct _Unwind_Context;\n+\n+/* Raise an exception, passing along the given exception object.  */\n+extern _Unwind_Reason_Code _Unwind_RaiseException (struct _Unwind_Exception *);\n+\n+/* Raise an exception for forced unwinding.  */\n+\n+typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)\n+     (int, _Unwind_Action, _Unwind_Exception_Class,\n+      struct _Unwind_Exception *, struct _Unwind_Context *, void *);\n+\n+extern _Unwind_Reason_Code _Unwind_ForcedUnwind (struct _Unwind_Exception *,\n+\t\t\t\t\t\t _Unwind_Stop_Fn,\n+\t\t\t\t\t\t void *);\n+\n+/* Helper to invoke the exception_cleanup routine.  */\n+extern void _Unwind_DeleteException (struct _Unwind_Exception *);\n+\n+/* Resume propagation of an existing exception.  This is used after\n+   e.g. executing cleanup code, and not to implement rethrowing.  */\n+extern void _Unwind_Resume (struct _Unwind_Exception *);\n+\n+/* These functions are used for communicating information about the unwind\n+   context (i.e. the unwind descriptors and the user register state) between\n+   the unwind library and the personality routine and landing pad.  Only\n+   selected registers maybe manipulated.  */\n+\n+extern _Unwind_Word _Unwind_GetGR (struct _Unwind_Context *, int);\n+extern void _Unwind_SetGR (struct _Unwind_Context *, int, _Unwind_Word);\n+\n+extern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);\n+extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);\n+\n+extern void *_Unwind_GetLanguageSpecificData (struct _Unwind_Context *);\n+\n+extern _Unwind_Ptr _Unwind_GetRegionStart (struct _Unwind_Context *);\n+\n+\n+/* The personality routine is the function in the C++ (or other language)\n+   runtime library which serves as an interface between the system unwind\n+   library and language-specific exception handling semantics.  It is\n+   specific to the code fragment described by an unwind info block, and\n+   it is always referenced via the pointer in the unwind info block, and\n+   hence it has no ABI-specified name. \n+\n+   Note that this implies that two different C++ implementations can\n+   use different names, and have different contents in the language\n+   specific data area.  Moreover, that the language specific data \n+   area contains no version info because name of the function invoked\n+   provides more effective versioning by detecting at link time the\n+   lack of code to handle the different data format.  */\n+   \n+typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)\n+     (int, _Unwind_Action, _Unwind_Exception_Class,\n+      struct _Unwind_Exception *, struct _Unwind_Context *);\n+\n+/* @@@ The following alternate entry points are for setjmp/longjmp\n+   based unwinding.  */\n+\n+struct SjLj_Function_Context;\n+extern void _Unwind_SjLj_Register (struct SjLj_Function_Context *);\n+extern void _Unwind_SjLj_Unregister (struct SjLj_Function_Context *);\n+\n+extern _Unwind_Reason_Code _Unwind_SjLj_RaiseException\n+     (struct _Unwind_Exception *);\n+extern _Unwind_Reason_Code _Unwind_SjLj_ForcedUnwind\n+     (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);\n+extern void _Unwind_SjLj_Resume (struct _Unwind_Exception *);\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "ba3153613095e877e8ffa711a46bd0eb952365dd", "filename": "gcc/unwind.inc", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/gcc%2Funwind.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.inc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,232 @@\n+/* Exception handling and frame unwind runtime interface routines.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This is derived from the C++ ABI for IA-64.  Where we diverge\n+   for cross-architecture compatibility are noted with \"@@@\".  \n+   This file is included from unwind-dw2.c or unwind-ia64.c.  */\n+\n+/* Subroutine of _Unwind_RaiseException also invoked from _Unwind_Resume. \n+\n+   Unwind the stack calling the personality routine to find both the\n+   exception handler and intermediary cleanup code.  We'll only locate\n+   the first such frame here.  Cleanup code will call back into\n+   _Unwind_Resume and we'll continue Phase 2 there.  */\n+\n+static _Unwind_Reason_Code\n+_Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,\n+\t\t\t      struct _Unwind_Context *context)\n+{\n+  _Unwind_Reason_Code code;\n+\n+  while (1)\n+    {\n+      _Unwind_FrameState fs;\n+      int match_handler;\n+\n+      code = uw_frame_state_for (context, &fs);\n+\n+      /* Identify when we've reached the designated handler context.  */\n+      match_handler = (uw_identify_context (context) == exc->private_2\n+\t\t       ? _UA_HANDLER_FRAME : 0);\n+\n+      if (code != _URC_NO_REASON)\n+\t/* Some error encountered.  Ususally the unwinder doesn't\n+\t   diagnose these and merely crashes.  */\n+\treturn _URC_FATAL_PHASE2_ERROR;\n+\n+      /* Unwind successful.  Run the personality routine, if any.  */\n+      if (fs.personality)\n+\t{\n+\t  code = (*fs.personality) (1, _UA_CLEANUP_PHASE | match_handler,\n+\t\t\t\t    exc->exception_class, exc, context);\n+\t  if (code == _URC_INSTALL_CONTEXT)\n+\t    break;\n+\t  if (code != _URC_CONTINUE_UNWIND) \n+\t    return _URC_FATAL_PHASE2_ERROR;\n+\t}\n+\n+      /* Don't let us unwind past the handler context.  */\n+      if (match_handler)\n+\tabort ();\n+\n+      uw_update_context (context, &fs);\n+    }\n+\n+  return code;\n+}\n+\n+\n+/* Raise an exception, passing along the given exception object.  */\n+\n+_Unwind_Reason_Code\n+_Unwind_RaiseException(struct _Unwind_Exception *exc)\n+{\n+  struct _Unwind_Context this_context, cur_context;\n+  _Unwind_Reason_Code code;\n+\n+  uw_init_context (&this_context);\n+  cur_context = this_context;\n+\n+  /* Phase 1: Search.  Unwind the stack, calling the personality routine\n+     with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */\n+  while (1)\n+    {\n+      _Unwind_FrameState fs;\n+\n+      code = uw_frame_state_for (&cur_context, &fs);\n+\n+      if (code == _URC_END_OF_STACK)\n+\t/* Hit end of stack with no handler found.  */\n+\treturn _URC_END_OF_STACK;\n+\n+      if (code != _URC_NO_REASON)\n+\t/* Some error encountered.  Ususally the unwinder doesn't\n+\t   diagnose these and merely crashes.  */\n+\treturn _URC_FATAL_PHASE1_ERROR;\n+\n+      /* Unwind successful.  Run the personality routine, if any.  */\n+      if (fs.personality)\n+\t{\n+\t  code = (*fs.personality) (1, _UA_SEARCH_PHASE, exc->exception_class,\n+\t\t\t\t    exc, &cur_context);\n+\t  if (code == _URC_HANDLER_FOUND)\n+\t    break;\n+\t  else if (code != _URC_CONTINUE_UNWIND)\n+\t    return _URC_FATAL_PHASE1_ERROR;\n+\t}\n+\n+      uw_update_context (&cur_context, &fs);\n+    }\n+\n+  /* Indicate to _Unwind_Resume and associated subroutines that this\n+     is not a forced unwind.  Further, note where we found a handler.  */\n+  exc->private_1 = 0;\n+  exc->private_2 = uw_identify_context (&cur_context);\n+\n+  cur_context = this_context;\n+  code = _Unwind_RaiseException_Phase2 (exc, &cur_context);\n+  if (code != _URC_INSTALL_CONTEXT)\n+    return code;\n+\n+  uw_install_context (&this_context, &cur_context);\n+}\n+\n+\n+/* Subroutine of _Unwind_ForcedUnwind also invoked from _Unwind_Resume.  */\n+\n+static _Unwind_Reason_Code\n+_Unwind_ForcedUnwind_Phase2(struct _Unwind_Exception *exc,\n+\t\t\t    struct _Unwind_Context *context)\n+{\n+  _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) exc->private_1;\n+  void *stop_argument = (void *) exc->private_2;\n+  _Unwind_Reason_Code code, stop_code;\n+\n+  while (1)\n+    {\n+      _Unwind_FrameState fs;\n+\n+      code = uw_frame_state_for (context, &fs);\n+      if (code != _URC_NO_REASON && code != _URC_END_OF_STACK)\n+\treturn _URC_FATAL_PHASE2_ERROR;\n+\n+      /* Unwind successful.  */\n+      stop_code = (*stop) (1, _UA_FORCE_UNWIND | _UA_CLEANUP_PHASE,\n+\t\t\t   exc->exception_class, exc, context, stop_argument);\n+      if (stop_code != _URC_NO_REASON)\n+\treturn _URC_FATAL_PHASE2_ERROR;\n+\n+      /* Stop didn't want to do anything.  Invoke the personality\n+\t handler, if applicable, to run cleanups.  */\n+      if (code == _URC_END_OF_STACK)\n+\tbreak;\n+\t\n+      if (fs.personality)\n+\t{\n+\t  code = (*fs.personality) (1, _UA_FORCE_UNWIND | _UA_CLEANUP_PHASE,\n+\t\t\t\t    exc->exception_class, exc, context);\n+\t  if (code == _URC_INSTALL_CONTEXT)\n+\t    break;\n+\t  if (code != _URC_CONTINUE_UNWIND) \n+\t    return _URC_FATAL_PHASE2_ERROR;\n+\t}\n+\n+      uw_update_context (context, &fs);\n+    }\n+\n+  return code;\n+}\n+\n+\n+/* Raise an exception for forced unwinding.  */\n+\n+_Unwind_Reason_Code\n+_Unwind_ForcedUnwind (struct _Unwind_Exception *exc,\n+\t\t      _Unwind_Stop_Fn stop, void * stop_argument)\n+{\n+  struct _Unwind_Context this_context, cur_context;\n+  _Unwind_Reason_Code code;\n+\n+  uw_init_context (&this_context);\n+  cur_context = this_context;\n+\n+  exc->private_1 = (_Unwind_Ptr) stop;\n+  exc->private_2 = (_Unwind_Ptr) stop_argument;\n+\n+  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n+  if (code != _URC_INSTALL_CONTEXT)\n+    return code;\n+\n+  uw_install_context (&this_context, &cur_context);\n+}\n+\n+\n+/* Resume propagation of an existing exception.  This is used after\n+   e.g. executing cleanup code, and not to implement rethrowing.  */\n+\n+void\n+_Unwind_Resume (struct _Unwind_Exception *exc)\n+{\n+  struct _Unwind_Context this_context, cur_context;\n+  _Unwind_Reason_Code code;\n+\n+  uw_init_context (&this_context);\n+  cur_context = this_context;\n+\n+  /* Choose between continuing to process _Unwind_RaiseException\n+     or _Unwind_ForcedUnwind.  */\n+  if (exc->private_1 == 0)\n+    code = _Unwind_RaiseException_Phase2 (exc, &cur_context);\n+  else\n+    code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n+\n+  if (code != _URC_INSTALL_CONTEXT)\n+    abort ();\n+\n+  uw_install_context (&this_context, &cur_context);\n+}\n+\n+/* A convenience function that calls the exception_cleanup field.  */\n+\n+void\n+_Unwind_DeleteException (struct _Unwind_Exception *exc)\n+{\n+  (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);\n+}"}, {"sha": "103147bece50f43f455e6bb8359e057fff220e2f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,3 +1,29 @@\n+2001-03-28  Richard Henderson  <rth@redhat.com>\n+\n+\tIA-64 ABI Exception Handling:\n+\t* Makefile.am (GCC_UNWIND_INCLUDE): Rename from EH_COMMON_INCLUDE.\n+\t(AM_CXXFLAGS): -fnon-call-exceptions not -fasynchronous-exceptions.\n+\tRemove EXCEPTIONSPEC.\n+\t* configure.host (libgcj_sjlj): Remove.\n+\t* configure.in (EXCEPTIONSPEC): Remove.\n+\t(enable-sjlj-exceptions): Detect if not specified.\n+\t(GCC_UNWIND_INCLUDE): Rename from EH_COMMON_INCLUDE; change\n+\twhat header we're looking for.\n+\t* libgcj.spec.in (jc1): Remove EXCEPTIONSPEC.\n+\t* Makefile.in, configure: Regenerate.\n+\t* exception.cc: Don't declare libgcc2 stuff.\n+\t(java_eh_info, _Jv_type_matcher, _Jv_exception_info): Remove.\n+\t(_Jv_eh_alloc, _Jv_eh_free, _Jv_setup_eh_info): Remove.\n+\t(win32_get_restart_frame): Remove.\n+\t(struct java_exception_header): New.\n+\t(__gcj_exception_class): New.\n+\t(get_exception_header_from_ue): New.\n+\t(_Jv_Throw): Rewrite for IA-64 ABI unwind routines.\n+\t(size_of_encoded_value, read_encoded_value): New.\n+\t(read_uleb128, read_sleb128, parse_lsda_header): New.\n+\t(get_ttype_entry, __gcj_personality_sj0): New.\n+\t* gcj/javaprims.h (_Jv_Sjlj_Throw): Remove.\n+\n 2001-03-27  Joerg Brunsmann  <joerg_brunsmann@yahoo.de>\n \n \t* javax/naming/InitialContext.java (init): Fix typo."}, {"sha": "66b91e21245d5823561f33b4ed428c49544d30a9", "filename": "libjava/Makefile.am", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -87,18 +87,15 @@ LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(\n \n JAVAC = $(GCJ_WITH_FLAGS) -C\n \n-EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n+GCC_UNWIND_INCLUDE = @GCC_UNWIND_INCLUDE@\n \n WARNINGS = -W -Wall\n ## We need _GNU_SOURCE defined for some Linux builds.  It doesn't hurt\n ## to always define it.\n-## Note that we need -fasynchronous-exceptions because gcc is\n-## currently broken with respect to exception handling in leaf\n-## functions.\n-AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n+AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fnon-call-exceptions \\\n ## Some systems don't allow `$' in identifiers by default, so we force it.\n \t-fdollars-in-identifiers \\\n-\t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n+\t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n if USING_GCC\n AM_CFLAGS = @LIBGCJ_CFLAGS@ $(WARNINGS)\n else\n@@ -112,7 +109,7 @@ LIBFFIINCS = -I$(top_srcdir)/../libffi/include -I$(MULTIBUILDTOP)../libffi/inclu\n \n INCLUDES = -I$(top_srcdir) -Iinclude -I$(top_srcdir)/include \\\n \t$(GCINCS) $(THREADINCS) $(INCLTDL) \\\n-\t$(EH_COMMON_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n+\t$(GCC_UNWIND_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n \n \n ## ################################################################"}, {"sha": "c5371f69e4a320ca88f183f292bfb41333f25128", "filename": "libjava/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -153,12 +153,12 @@ LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(\n \n JAVAC = $(GCJ_WITH_FLAGS) -C\n \n-EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n+GCC_UNWIND_INCLUDE = @GCC_UNWIND_INCLUDE@\n \n WARNINGS = -W -Wall\n-AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n+AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fnon-call-exceptions \\\n \t-fdollars-in-identifiers \\\n-\t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n+\t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n @USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n @USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n@@ -170,7 +170,7 @@ LIBFFIINCS = -I$(top_srcdir)/../libffi/include -I$(MULTIBUILDTOP)../libffi/inclu\n \n INCLUDES = -I$(top_srcdir) -Iinclude -I$(top_srcdir)/include \\\n \t$(GCINCS) $(THREADINCS) $(INCLTDL) \\\n-\t$(EH_COMMON_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n+\t$(GCC_UNWIND_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n \n \n nat_files = $(nat_source_files:.cc=.lo)"}, {"sha": "71dd1aba8637cbe909776626ce6b7f338e081667", "filename": "libjava/configure", "status": "modified", "additions": 406, "deletions": 370, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6"}, {"sha": "077825c88d09ffac60211efa3b2e924f01a1e5f4", "filename": "libjava/configure.host", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -23,7 +23,6 @@ libgcj_flags=\n libgcj_cflags=\n libgcj_cxxflags=\n libgcj_javaflags=\n-libgcj_sjlj=\n libgcj_interpreter=\n \n case \"${target_optspace}:${host}\" in\n@@ -67,18 +66,13 @@ case \"${host}\" in\n   alpha*-*)\n \tlibgcj_flags=\"${libgcj_flags} -mieee\"\n \tlibgcj_interpreter=yes\n-\tlibgcj_sjlj=yes\n \t;;\n   sparc-*)\n         ;;\n   ia64-*)\n         libgcj_flags=\"${libgcj_flags} -funwind-tables\"\n-\tlibgcj_sjlj=yes\n \tlibgcj_interpreter=yes\n \t;;\n-  *)\n-        libgcj_sjlj=yes\n-\t;;\n esac\n \n libgcj_cflags=\"${libgcj_cflags} ${libgcj_flags}\""}, {"sha": "89bbe7fb198d2c0ff5aeca7b67e70a2f74f80c3e", "filename": "libjava/configure.in", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -88,19 +88,51 @@ if test \"$libgcj_interpreter\" = yes; then\n    AC_DEFINE(INTERPRETER)\n fi\n \n-EXCEPTIONSPEC=\n-dnl See if we should use setjmp/longjmp exceptions\n+AC_MSG_CHECKING([for exception model to use])\n+AC_LANG_SAVE\n+AC_LANG_CPLUSPLUS\n AC_ARG_ENABLE(sjlj-exceptions,\n-[  --enable-sjlj-exceptions    use setjmp/longjmp exceptions],\n-  if test \"$enable_sjlj_exceptions\" = yes; then\n-     # This can be set in configure.host.\n-     libgcj_sjlj=yes\n-  fi)\n-\n-if test \"$libgcj_sjlj\" = yes; then\n-   EXCEPTIONSPEC=\"-fsjlj-exceptions\"\n-   AC_DEFINE(SJLJ_EXCEPTIONS)\n+[  --enable-sjlj-exceptions  force use of builtin_setjmp for exceptions],\n+[:],\n+[dnl Botheration.  Now we've got to detect the exception model.\n+dnl Link tests against libgcc.a are problematic since -- at least\n+dnl as of this writing -- we've not been given proper -L bits for\n+dnl single-tree newlib and libgloss.\n+dnl\n+dnl This is what AC_TRY_COMPILE would do if it didn't delete the\n+dnl conftest files before we got a change to grep them first.\n+cat > conftest.$ac_ext << EOF\n+[#]line __oline__ \"configure\"\n+struct S { ~S(); };\n+void bar();\n+void foo()\n+{\n+  S s;\n+  bar();\n+}\n+EOF\n+old_CXXFLAGS=\"$CXXFLAGS\"  \n+CXXFLAGS=-S\n+if AC_TRY_EVAL(ac_compile); then\n+  if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n+    enable_sjlj_exceptions=yes\n+  elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n+    enable_sjlj_exceptions=no\n+  fi\n+fi\n+CXXFLAGS=\"$old_CXXFLAGS\"\n+rm -f conftest*])\n+if test x$enable_sjlj_exceptions = xyes; then\n+  AC_DEFINE(SJLJ_EXCEPTIONS, 1,\n+\t[Define if the compiler is configured for setjmp/longjmp exceptions.])\n+  ac_exception_model_name=sjlj\n+elif test x$enable_sjlj_exceptions = xno; then\n+  ac_exception_model_name=\"call frame\"\n+else\n+  AC_MSG_ERROR([unable to detect exception model])\n fi\n+AC_LANG_RESTORE\n+AC_MSG_RESULT($ac_exception_model_name)\n \n AC_MSG_CHECKING([for data_start])\n LIBDATASTARTSPEC=\n@@ -349,16 +381,17 @@ CANADIAN=no\n NULL_TARGET=no\n NATIVE=yes\n \n-# Find eh-common.h and support headers.  If we're in the tree with\n+# Find unwind.h and support headers.  If we're in the tree with\n # gcc, then look there.  Otherwise look in compat-include.  If all else\n # fails, just hope the user has set things up somehow.\n-if test -r $srcdir/../gcc/eh-common.h; then\n-   EH_COMMON_INCLUDE='-I$(top_srcdir)/../gcc -I$(top_srcdir)/../include'\n+echo \"probing $srcdir/../gcc/unwind.h\"\n+if test -r $srcdir/../gcc/unwind.h; then\n+   GCC_UNWIND_INCLUDE='-I$(top_srcdir)/../gcc'\n else\n    if test -d $srcdir/../compat-include; then\n-      EH_COMMON_INCLUDE='-I$(top_srcdir)/../compat-include'\n+      GCC_UNWIND_INCLUDE='-I$(top_srcdir)/../compat-include'\n    else\n-      EH_COMMON_INCLUDE=\n+      GCC_UNWIND_INCLUDE=\n    fi\n fi\n \n@@ -389,7 +422,7 @@ if test -n \"${with_cross_host}\"; then\n    # directory.\n    if test \"$build\" != \"$with_cross_host\"; then\n       CANADIAN=yes\n-      EH_COMMON_INCLUDE=\n+      GCC_UNWIND_INCLUDE=\n       GCJ=\"${target_alias}-gcj\"\n    else\n       GCJ=\n@@ -623,14 +656,13 @@ AC_SUBST(ZLIBS)\n AC_SUBST(ZDEPS)\n AC_SUBST(ZINCS)\n AC_SUBST(DIVIDESPEC)\n-AC_SUBST(EXCEPTIONSPEC)\n \n AM_CONDITIONAL(CANADIAN, test \"$CANADIAN\" = yes)\n AM_CONDITIONAL(NULL_TARGET, test \"$NULL_TARGET\" = yes)\n AM_CONDITIONAL(NATIVE, test \"$NATIVE\" = yes || test \"$NULL_TARGET\" = yes)\n AM_CONDITIONAL(USE_LIBDIR, test -z \"$with_cross_host\")\n AM_CONDITIONAL(NEEDS_DATA_START, test \"$NEEDS_DATA_START\" = yes && test \"$NATIVE\" = yes)\n-AC_SUBST(EH_COMMON_INCLUDE)\n+AC_SUBST(GCC_UNWIND_INCLUDE)\n \n # Determine gcj version number.\n changequote(<<,>>)"}, {"sha": "41f7676063e4f755a16c0d0f60bbbdd12c46eb0d", "filename": "libjava/exception.cc", "status": "modified", "additions": 492, "deletions": 128, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,6 +1,6 @@\n // Functions for Exception Support for Java.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -18,182 +18,546 @@ details.  */\n #include <gcj/cni.h>\n #include <jvm.h>\n \n-// eh-common.h needs gansidecl.h.\n-#include \"gansidecl.h\"\n-#include \"eh-common.h\"\n-\n-typedef struct {\n-  __eh_info eh_info;\n-  jthrowable value;\n-} java_eh_info;\n+#include \"unwind.h\"\n \n+\f\n+// More nastiness: the GC wants to define TRUE and FALSE.  We don't\n+// need the Java definitions (themselves a hack), so we undefine them.\n+#undef TRUE\n+#undef FALSE\n \n-/* Language-specific EH info pointer, throw routine, and language/version\n-   info routines. All defined in libgcc2. */\n+extern \"C\"\n+{\n+#include <gc_priv.h>\n+#include <gc_mark.h>\n+#include <include/gc_gcj.h>\n+};\n \n-extern \"C\" java_eh_info **__get_eh_info (); \n-extern \"C\" void __throw () __attribute__ ((__noreturn__));\n-extern \"C\" void __sjthrow () __attribute__ ((__noreturn__));\n-extern \"C\" short __get_eh_table_version (void *table);\n-extern \"C\" short __get_eh_table_language (void *table);\n-extern \"C\" void *__get_eh_context ();\n+\f\n+struct alignment_test_struct\n+{\n+  char space;\n+  char end[0] __attribute__((aligned));\n+};\n \n-extern \"C\" void *\n-_Jv_type_matcher (java_eh_info *info, void* match_info, \n-\t\t  void *exception_table)\n+struct java_exception_header\n {\n-#ifndef SJLJ_EXCEPTIONS\n-  /* No exception table implies the old style mechanism, so don't check. */\n-  if (exception_table != NULL\n-      && __get_eh_table_language (exception_table) != EH_LANG_Java)\n-    return NULL;\n-#endif\n+  /* Cache handler details between Phase 1 and Phase 2.  */\n+  _Unwind_Ptr landingPad;\n+  int handlerSwitchValue;\n \n-  /* we don't worry about version info yet, there is only one version! */\n-  \n-  if (match_info != NULL)\n-    {\n-      // The match_info is either a (java::lang::Class*) or\n-      // match_info is one more than a (Utf8Const*).\n-      if (sizeof(void*) != sizeof(size_t))\n-\tabort();\n-      size_t mi = (size_t) match_info;\n-      if ((mi & 1) != 0)\n-\tmatch_info = _Jv_FindClass ((Utf8Const*) (mi - 1), NULL);\n-      if (! _Jv_IsInstanceOf (info->value, (jclass) match_info))\n-\treturn NULL;\n-    }\n+  /* The object being thrown.  Compiled code expects this to be immediately\n+     before the generic exception header.  Which is complicated by the fact\n+     that _Unwind_Exception is ((aligned)).  */\n+\n+  char pad[sizeof(jthrowable) < sizeof(alignment_test_struct)\n+\t   ? sizeof(alignment_test_struct) - sizeof(jthrowable) : 0]\n+    __attribute__((aligned));\n+\n+  jthrowable value;\n \n-  return info->value;\n+  /* The generic exception header.  */\n+  _Unwind_Exception unwindHeader;\n+};\n+\n+// This is the exception class we report -- \"GNUCJAVA\".\n+const _Unwind_Exception_Class __gcj_exception_class\n+= ((((((((_Unwind_Exception_Class) 'G' \n+         << 8 | (_Unwind_Exception_Class) 'N')\n+        << 8 | (_Unwind_Exception_Class) 'U')\n+       << 8 | (_Unwind_Exception_Class) 'C')\n+      << 8 | (_Unwind_Exception_Class) 'J')\n+     << 8 | (_Unwind_Exception_Class) 'A')\n+    << 8 | (_Unwind_Exception_Class) 'V')\n+   << 8 | (_Unwind_Exception_Class) 'A');\n+\n+\n+static inline java_exception_header *\n+get_exception_header_from_ue (_Unwind_Exception *exc)\n+{\n+  return reinterpret_cast<java_exception_header *>(exc + 1) - 1;\n }\n \n-/* Compiler hook to return a pointer to java exception object. The value\n-   is cleared, so if the exception needs to be rethrown, it should be set \n-   again */\n+/* Perform a throw, Java style. Throw will unwind through this call,\n+   so there better not be any handlers or exception thrown here. */\n \n-extern \"C\" void *\n-_Jv_exception_info (void)\n+extern \"C\" void\n+_Jv_Throw (jthrowable value)\n {\n-  java_eh_info *info = *(__get_eh_info ());\n-  void *ptr;\n+  /* FIXME: Use the proper API to the collector.  */\n+  java_exception_header *xh\n+    = static_cast<java_exception_header *>(GC_malloc (sizeof (*xh)));\n+\n+  if (value == NULL)\n+    value = new java::lang::NullPointerException ();\n+  xh->value = value;\n \n-  if (info == NULL)\n-    abort ();\n+  xh->unwindHeader.exception_class = __gcj_exception_class;\n+  xh->unwindHeader.exception_cleanup = NULL;\n \n-  ptr = info->value;\n+  /* We're happy with setjmp/longjmp exceptions or region-based\n+     exception handlers: entry points are provided here for both.  */\n+  _Unwind_Reason_Code code;\n+#ifdef SJLJ_EXCEPTIONS\n+  code = _Unwind_SjLj_RaiseException (&xh->unwindHeader);\n+#else\n+  code = _Unwind_RaiseException (&xh->unwindHeader);\n+#endif\n \n-  /* clear the value so another throw is an error */\n-  info->value = NULL;\n+  /* FIXME: If code == _URC_END_OF_STACK, then we reached top of\n+     stack without finding a handler for the exception.  I seem to\n+     recall that Java has specific rules to handle this. \n \n-  return ptr;\n+     If code is something else, we encountered some sort of heinous\n+     lossage, from which we could not recover.  As is the way of such\n+     things we'll almost certainly have crashed before now, rather\n+     than actually being able to diagnose the problem.  */\n+  abort ();\n }\n \n+\f\n+// ??? These ought to go somewhere else dwarf2 or dwarf2eh related.\n+\n+// Pointer encodings.\n+#define DW_EH_PE_absptr         0x00\n+#define DW_EH_PE_omit           0xff\n+\n+#define DW_EH_PE_uleb128        0x01\n+#define DW_EH_PE_udata2         0x02\n+#define DW_EH_PE_udata4         0x03\n+#define DW_EH_PE_udata8         0x04\n+#define DW_EH_PE_sleb128        0x09\n+#define DW_EH_PE_sdata2         0x0A\n+#define DW_EH_PE_sdata4         0x0B\n+#define DW_EH_PE_sdata8         0x0C\n+#define DW_EH_PE_signed         0x08\n+\n+#define DW_EH_PE_pcrel          0x10\n+#define DW_EH_PE_textrel        0x20\n+#define DW_EH_PE_datarel        0x30\n+#define DW_EH_PE_funcrel        0x40\n+\n+static unsigned int\n+size_of_encoded_value (unsigned char encoding)\n+{\n+  switch (encoding & 0x07)\n+    {\n+    case DW_EH_PE_absptr:\n+      return sizeof (void *);\n+    case DW_EH_PE_udata2:\n+      return 2;\n+    case DW_EH_PE_udata4:\n+      return 4;\n+    case DW_EH_PE_udata8:\n+      return 8;\n+    }\n+  abort ();\n+}\n \n+static const unsigned char *\n+read_encoded_value (_Unwind_Context *context, unsigned char encoding,\n+\t\t    const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  union unaligned\n+    {\n+      void *ptr;\n+      unsigned u2 __attribute__ ((mode (HI)));\n+      unsigned u4 __attribute__ ((mode (SI)));\n+      unsigned u8 __attribute__ ((mode (DI)));\n+      signed s2 __attribute__ ((mode (HI)));\n+      signed s4 __attribute__ ((mode (SI)));\n+      signed s8 __attribute__ ((mode (DI)));\n+    } __attribute__((__packed__));\n+\n+  union unaligned *u = (union unaligned *) p;\n+  _Unwind_Ptr result;\n+\n+  switch (encoding & 0x0f)\n+    {\n+    case DW_EH_PE_absptr:\n+      result = (_Unwind_Ptr) u->ptr;\n+      p += sizeof (void *);\n+      break;\n+\n+    case DW_EH_PE_uleb128:\n+      {\n+\tunsigned int shift = 0;\n+\tunsigned char byte;\n+\n+\tresult = 0;\n+\tdo\n+\t  {\n+\t    byte = *p++;\n+\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t    shift += 7;\n+\t  }\n+\twhile (byte & 0x80);\n+      }\n+      break;\n+\n+    case DW_EH_PE_sleb128:\n+      {\n+\tunsigned int shift = 0;\n+\tunsigned char byte;\n+\n+\tresult = 0;\n+\tdo\n+\t  {\n+\t    byte = *p++;\n+\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t    shift += 7;\n+\t  }\n+\twhile (byte & 0x80);\n+\n+\tif (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n+\t  result |= -(1L << shift);\n+      }\n+      break;\n+\n+    case DW_EH_PE_udata2:\n+      result = u->u2;\n+      p += 2;\n+      break;\n+    case DW_EH_PE_udata4:\n+      result = u->u4;\n+      p += 4;\n+      break;\n+    case DW_EH_PE_udata8:\n+      result = u->u8;\n+      p += 8;\n+      break;\n+\n+    case DW_EH_PE_sdata2:\n+      result = u->s2;\n+      p += 2;\n+      break;\n+    case DW_EH_PE_sdata4:\n+      result = u->s4;\n+      p += 4;\n+      break;\n+    case DW_EH_PE_sdata8:\n+      result = u->s8;\n+      p += 8;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n \n-/* Allocate an exception info structure for java. Called the first time\n-   an exception is thrown. */\n+  if (result != 0)\n+    switch (encoding & 0xf0)\n+      {\n+      case DW_EH_PE_absptr:\n+\tbreak;\n \n-extern \"C\" void\n-_Jv_eh_alloc ()\n-{\n-  /* FIXME: we should use _Jv_AllocBytes here.  However, libgcc2\n-     apparently can sometimes free() this value itself.  */\n-  java_eh_info *p = (java_eh_info *) malloc (sizeof (java_eh_info));\n-  if (p == 0)\n-    abort ();\n+      case DW_EH_PE_pcrel:\n+\t// Define as relative to the beginning of the pointer.\n+\tresult += (_Unwind_Ptr) u;\n+\tbreak;\n+\n+      case DW_EH_PE_textrel:\n+      case DW_EH_PE_datarel:\n+\t// FIXME.\n+\tabort ();\n \n-  p->value = 0;\n-  java_eh_info ** info_ptr = __get_eh_info ();\n+      case DW_EH_PE_funcrel:\n+\tresult += _Unwind_GetRegionStart (context);\n+\tbreak;\n \n-  /* There should NOT be an exception info pointer already. */\n-  if (*info_ptr != NULL)\n-    abort ();\n+      default:\n+\tabort ();\n+      }\n \n-  *info_ptr = p;\n+  *val = result;\n+  return p;\n }\n \n-/* Deallocate the current exception info structure. Called at shutdown time. */\n+static inline const unsigned char *\n+read_uleb128 (const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  return read_encoded_value (0, DW_EH_PE_uleb128, p, val);\n+}\n \n-extern \"C\" void\n-_Jv_eh_free ()\n+static inline const unsigned char *\n+read_sleb128 (const unsigned char *p, _Unwind_Ptr *val)\n {\n-  java_eh_info ** info_ptr = __get_eh_info ();\n-  if (*info_ptr == NULL)\n-    abort ();\n-  \n-  /* FIXME: ideally we should just let the GC handle this.  */\n-  free (*info_ptr);\n-  *info_ptr = NULL;\n+  return read_encoded_value (0, DW_EH_PE_sleb128, p, val);\n }\n \n-/* Initialize an __eh_info structure with this libraries matching info. */\n+\f\n+struct lsda_header_info\n+{\n+  _Unwind_Ptr Start;\n+  _Unwind_Ptr LPStart;\n+  const unsigned char *TType;\n+  const unsigned char *action_table;\n+  unsigned char ttype_encoding;\n+  unsigned char call_site_encoding;\n+};\n+\n+static const unsigned char *\n+parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n+\t\t   lsda_header_info *info)\n+{\n+  _Unwind_Ptr tmp;\n+  unsigned char lpstart_encoding;\n+\n+  info->Start = (context ? _Unwind_GetRegionStart (context) : 0);\n \n-extern \"C\" void\n-_Jv_setup_eh_info (__eh_info *)\n+  // Find @LPStart, the base to which landing pad offsets are relative.\n+  lpstart_encoding = *p++;\n+  if (lpstart_encoding != DW_EH_PE_omit)\n+    p = read_encoded_value (context, lpstart_encoding, p, &info->LPStart);\n+  else\n+    info->LPStart = info->Start;\n+\n+  // Find @TType, the base of the handler and exception spec type data.\n+  info->ttype_encoding = *p++;\n+  if (info->ttype_encoding != DW_EH_PE_omit)\n+    {\n+      p = read_uleb128 (p, &tmp);\n+      info->TType = p + tmp;\n+    }\n+  else\n+    info->TType = 0;\n+\n+  // The encoding and length of the call-site table; the action table\n+  // immediately follows.\n+  info->call_site_encoding = *p++;\n+  p = read_uleb128 (p, &tmp);\n+  info->action_table = p + tmp;\n+\n+  return p;\n+}\n+\n+static jclass\n+get_ttype_entry (_Unwind_Context *context, lsda_header_info *info, long i)\n {\n+  _Unwind_Ptr ptr;\n+\n+  i *= size_of_encoded_value (info->ttype_encoding);\n+  read_encoded_value (context, info->ttype_encoding, info->TType - i, &ptr);\n+\n+  return reinterpret_cast<jclass>(ptr);\n }\n \n-/* Perform a throw, Java style. Throw will unwind through this call,\n-   so there better not be any handlers or exception thrown here. */\n \n+// Using a different personality function name causes link failures\n+// when trying to mix code using different exception handling models.\n #ifdef SJLJ_EXCEPTIONS\n-#define _Jv_Throw _Jv_Sjlj_Throw\n+#define PERSONALITY_FUNCTION\t__gcj_personality_sj0\n+#define __builtin_eh_return_data_regno(x) x\n+#else\n+#define PERSONALITY_FUNCTION\t__gcj_personality_v0\n #endif\n \n-extern \"C\" void\n-_Jv_Throw (jthrowable value)\n+extern \"C\" _Unwind_Reason_Code\n+PERSONALITY_FUNCTION (int version,\n+\t\t      _Unwind_Action actions,\n+\t\t      _Unwind_Exception_Class exception_class,\n+\t\t      struct _Unwind_Exception *ue_header,\n+\t\t      struct _Unwind_Context *context)\n {\n-  if (value == NULL)\n-    value = new java::lang::NullPointerException;\n-  java_eh_info *ehinfo = *(__get_eh_info ());\n-  if (ehinfo == NULL)\n+  java_exception_header *xh = get_exception_header_from_ue (ue_header);\n+\n+  lsda_header_info info;\n+  const unsigned char *language_specific_data;\n+  const unsigned char *action_record;\n+  const unsigned char *p;\n+  _Unwind_Ptr landing_pad, ip;\n+  int handler_switch_value;\n+  bool saw_cleanup;\n+  bool saw_handler;\n+\n+\n+  // Interface version check.\n+  if (version != 1)\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  // Shortcut for phase 2 found handler for domestic exception.\n+  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n+      && exception_class == __gcj_exception_class)\n     {\n-      _Jv_eh_alloc ();\n-      ehinfo = *(__get_eh_info ());\n+      handler_switch_value = xh->handlerSwitchValue;\n+      landing_pad = xh->landingPad;\n+      goto install_context;\n     }\n-  ehinfo->eh_info.match_function = (__eh_matcher) _Jv_type_matcher;\n-  ehinfo->eh_info.language = EH_LANG_Java;\n-  ehinfo->eh_info.version = 1;\n-  ehinfo->value = value;\n \n-/* We're happy with setjmp/longjmp exceptions or region-based\n-   exception handlers: entry points are provided here for both.  */\n+  // FIXME: In Phase 1, record _Unwind_GetIP in xh->obj as a part of\n+  // the stack trace for this exception.  This will only collect Java\n+  // frames, but perhaps that is acceptable.\n+  // FIXME2: _Unwind_GetIP is nonsensical for SJLJ, being a call-site\n+  // index instead of a PC value.  We could perhaps arrange for\n+  // _Unwind_GetRegionStart to return context->fc->jbuf[1], which\n+  // is the address of the handler label for __builtin_longjmp, but\n+  // there is no solution for DONT_USE_BUILTIN_SETJMP.\n+\n+  language_specific_data = (const unsigned char *)\n+    _Unwind_GetLanguageSpecificData (context);\n+\n+  // If no LSDA, then there are no handlers or cleanups.\n+  if (! language_specific_data)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  // Parse the LSDA header.\n+  p = parse_lsda_header (context, language_specific_data, &info);\n+  ip = _Unwind_GetIP (context) - 1;\n+  landing_pad = 0;\n+  action_record = 0;\n+  handler_switch_value = 0;\n+\n #ifdef SJLJ_EXCEPTIONS\n-  __sjthrow ();\n+  // The given \"IP\" is an index into the call-site table, with two\n+  // exceptions -- -1 means no-action, and 0 means terminate.  But\n+  // since we're using uleb128 values, we've not got random access\n+  // to the array.\n+  if ((int) ip <= 0)\n+    return _URC_CONTINUE_UNWIND;\n+  else\n+    {\n+      _Unwind_Ptr cs_lp, cs_action;\n+      do\n+\t{\n+\t  p = read_uleb128 (p, &cs_lp);\n+\t  p = read_uleb128 (p, &cs_action);\n+\t}\n+      while (--ip);\n+\n+      // Can never have null landing pad for sjlj -- that would have\n+      // been indicated by a -1 call site index.\n+      landing_pad = cs_lp + 1;\n+      if (cs_action)\n+\taction_record = info.action_table + cs_action - 1;\n+      goto found_something;\n+    }\n #else\n-  __throw ();\n-#endif\n-}\n+  // Search the call-site table for the action associated with this IP.\n+  while (p < info.action_table)\n+    {\n+      _Unwind_Ptr cs_start, cs_len, cs_lp, cs_action;\n+\n+      // Note that all call-site encodings are \"absolute\" displacements.\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);\n+      p = read_uleb128 (p, &cs_action);\n+\n+      // The table is sorted, so if we've passed the ip, stop.\n+      if (ip < info.Start + cs_start)\n+\tp = info.action_table;\n+      else if (ip < info.Start + cs_start + cs_len)\n+\t{\n+\t  if (cs_lp)\n+\t    landing_pad = info.LPStart + cs_lp;\n+\t  if (cs_action)\n+\t    action_record = info.action_table + cs_action - 1;\n+\t  goto found_something;\n+\t}\n+    }\n+#endif // SJLJ_EXCEPTIONS\n \n-#ifdef USE_WIN32_SIGNALLING\n+  // If ip is not present in the table, C++ would call terminate.\n+  // ??? It is perhaps better to tweek the LSDA so that no-action\n+  // is mapped to no-entry for Java.\n+  return _URC_CONTINUE_UNWIND;\n \n-// This is a mangled version of _Jv_Throw and __sjthrow except\n-// rather than calling longjmp, it returns a pointer to the jmp buffer\n+ found_something:\n+  saw_cleanup = false;\n+  saw_handler = false;\n \n-extern \"C\" int *\n-win32_get_restart_frame (void *value)\n-{\n-  struct eh_context *eh = (struct eh_context *)__get_eh_context ();\n-  void ***dhc = &eh->dynamic_handler_chain;\n- \n-  java_eh_info *ehinfo = *(__get_eh_info ());\n-  if (ehinfo == NULL)\n+  if (landing_pad == 0)\n     {\n-      _Jv_eh_alloc ();\n-      ehinfo = *(__get_eh_info ());\n+      // If ip is present, and has a null landing pad, there are\n+      // no cleanups or handlers to be run.\n+    }\n+  else if (action_record == 0)\n+    {\n+      // If ip is present, has a non-null landing pad, and a null\n+      // action table offset, then there are only cleanups present.\n+      // Cleanups use a zero switch value, as set above.\n+      saw_cleanup = true;\n+    }\n+  else\n+    {\n+      // Otherwise we have a catch handler.\n+      signed long ar_filter, ar_disp;\n+\n+      while (1)\n+\t{\n+\t  _Unwind_Ptr tmp;\n+\n+\t  p = action_record;\n+\t  p = read_sleb128 (p, &tmp); ar_filter = tmp;\n+\t  read_sleb128 (p, &tmp); ar_disp = tmp;\n+\n+\t  if (ar_filter == 0)\n+\t    {\n+\t      // Zero filter values are cleanups.\n+\t      saw_cleanup = true;\n+\t    }\n+\n+\t  // During forced unwinding, we only run cleanups.  With a\n+\t  // foreign exception class, we have no class info to match.\n+\t  else if ((actions & _UA_FORCE_UNWIND)\n+\t      || exception_class != __gcj_exception_class)\n+\t    ;\n+\n+\t  else if (ar_filter > 0)\n+\t    {\n+\t      // Positive filter values are handlers.\n+\n+\t      jclass catch_type = get_ttype_entry (context, &info, ar_filter);\n+\n+\t      // The catch_type is either a (java::lang::Class*) or\n+\t      // is one more than a (Utf8Const*).\n+\t      if ((size_t)catch_type & 1)\n+\t\tcatch_type = _Jv_FindClass ((Utf8Const*)catch_type - 1, NULL);\n+\n+\t      if (_Jv_IsInstanceOf (xh->value, catch_type))\n+\t\t{\n+\t\t  handler_switch_value = ar_filter;\n+\t\t  saw_handler = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // Negative filter values are exception specifications,\n+\t      // which Java does not use.\n+\t      // ??? Perhaps better to make them an index into a table\n+\t      // of null-terminated strings instead of playing games\n+\t      // with Utf8Const+1 as above.\n+\t      abort ();\n+\t    }\n+\n+\t  if (ar_disp == 0)\n+\t    break;\n+\t  action_record = p + ar_disp;\n+\t}\n     }\n-  ehinfo->eh_info.match_function = (__eh_matcher) _Jv_type_matcher;\n-  ehinfo->eh_info.language = EH_LANG_Java;\n-  ehinfo->eh_info.version = 1;\n-  ehinfo->value = value;\n-\n-  // FIXME: Run clean ups?\n \n-  int *jmpbuf = (int*)&(*dhc)[2];\n+  if (! saw_handler && ! saw_cleanup)\n+    return _URC_CONTINUE_UNWIND;\n \n-  *dhc = (void**)(*dhc)[0];\n+  if (actions & _UA_SEARCH_PHASE)\n+    {\n+      if (! saw_handler)\n+\treturn _URC_CONTINUE_UNWIND;\n+\n+      // For domestic exceptions, we cache data from phase 1 for phase 2.\n+      if (exception_class == __gcj_exception_class)\n+        {\n+          xh->handlerSwitchValue = handler_switch_value;\n+          xh->landingPad = landing_pad;\n+\t}\n+      return _URC_HANDLER_FOUND;\n+    }\n \n-  return  jmpbuf;\n+ install_context:\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n+\t\t (_Unwind_Ptr) &xh->unwindHeader);\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n+\t\t handler_switch_value);\n+  _Unwind_SetIP (context, landing_pad);\n+  return _URC_INSTALL_CONTEXT;\n }\n-\n-#endif /* USE_WIN32_SIGNALLING */"}, {"sha": "62554514b54c191a6ff8bc0bb291f90da9879b41", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -369,7 +369,6 @@ extern \"C\" jsize _Jv_GetStringUTFLength (jstring);\n extern \"C\" jsize _Jv_GetStringUTFRegion (jstring, jsize, jsize, char *);\n \n extern \"C\" void _Jv_Throw (jthrowable) __attribute__ ((__noreturn__));\n-extern \"C\" void _Jv_Sjlj_Throw (jthrowable) __attribute__ ((__noreturn__));\n extern \"C\" void* _Jv_Malloc (jsize) __attribute__((__malloc__));\n extern \"C\" void* _Jv_Realloc (void *, jsize);\n extern \"C\" void _Jv_Free (void*);"}, {"sha": "5a21e7a699a28acf532c71f4e6fa73715ef1cea3", "filename": "libjava/libgcj.spec.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Flibgcj.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libjava%2Flibgcj.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flibgcj.spec.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -6,7 +6,7 @@\n %rename lib liborig\n *lib: -lgcj -lm @GCSPEC@ @THREADSPEC@ @ZLIBSPEC@ @SYSTEMSPEC@ %(libgcc) %(liborig)\n \n-*jc1:  @DIVIDESPEC@ @EXCEPTIONSPEC@ @JC1GCSPEC@ -fasynchronous-exceptions\n+*jc1:  @DIVIDESPEC@ @JC1GCSPEC@\n \n #\n # On some systems we force in a data_start symbol so that the GC will work"}, {"sha": "ac698159be6e7d149e6b1affaa8380669bc97f5b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1,3 +1,23 @@\n+2001-03-28  Richard Henderson  <rth@redhat.com>\n+\n+\tIA-64 ABI Exception Handling:\n+\t* acinclude.m4 (GLIBCPP_ENABLE_SJLJ_EXCEPTIONS): New.\n+\t* configure.in: Use it.\n+\t* Makefile.in, aclocal.m4, config.h.in, configure: Regenerate.\n+        * libsupc++/Makefile.am (sources): Update files list.\n+        * libsupc++/Makefile.in: Regenerate.\n+        * libsupc++/eh_alloc.cc, libsupc++/eh_aux_runtime.cc: New files.\n+        * libsupc++/eh_catch.cc, libsupc++/eh_exception.cc: New files.\n+\t* libsupc++/eh_globals.cc, libsupc++/eh_personality.cc: New files.\n+        * libsupc++/eh_terminate.cc, libsupc++/eh_throw.cc: New files.\n+        * libsupc++/exception_support.cc: Remove.\n+        * libsupc++/exception_support.h: Remove.\n+        * libsupc++/pure.cc: Use std::terminate.\n+        * libsupc++/tinfo2.cc (__throw_type_match_rtti_2): Remove.\n+        (__is_pointer): Remove.\n+        * libsupc++/unwind-cxx.h: New file.\n+        * libsupc++/vec.cc (uncatch_exception): Update for new abi.\n+\n 2001-03-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* libsupc++/Makefile.am (CXXLINK): Use CXX again, and choose"}, {"sha": "29ebfd1f730c87f12162dbe6c9116fa38095fbb4", "filename": "libstdc++-v3/Makefile.in", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -134,48 +134,7 @@ MULTICLEAN = true\n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"EXPECT=$(EXPECT)\" \\\n-\t\"RUNTEST=$(RUNTEST)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"includedir=$(includedir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \\\n-\t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \\\n-\t\"DESTDIR=$(DESTDIR)\" \\\n-\t\"WERROR=$(WERROR)\" \n+AM_MAKEFLAGS =  \t\"AR_FLAGS=$(AR_FLAGS)\" \t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \t\"CFLAGS=$(CFLAGS)\" \t\"CXXFLAGS=$(CXXFLAGS)\" \t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \t\"INSTALL=$(INSTALL)\" \t\"INSTALL_DATA=$(INSTALL_DATA)\" \t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \t\"LDFLAGS=$(LDFLAGS)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \t\"MAKE=$(MAKE)\" \t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \t\"SHELL=$(SHELL)\" \t\"EXPECT=$(EXPECT)\" \t\"RUNTEST=$(RUNTEST)\" \t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \t\"exec_prefix=$(exec_prefix)\" \t\"infodir=$(infodir)\" \t\"libdir=$(libdir)\" \t\"includedir=$(includedir)\" \t\"prefix=$(prefix)\" \t\"tooldir=$(tooldir)\" \t\"AR=$(AR)\" \t\"AS=$(AS)\" \t\"CC=$(CC)\" \t\"CXX=$(CXX)\" \t\"LD=$(LD)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"RANLIB=$(RANLIB)\" \t\"NM=$(NM)\" \t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \t\"DESTDIR=$(DESTDIR)\" \t\"WERROR=$(WERROR)\" \n \n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n CONFIG_HEADER = config.h\n@@ -353,7 +312,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "2ba509f70bf8303217c19ba72be6c14a309d10cd", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1257,6 +1257,66 @@ AC_DEFUN(GLIBCPP_ENABLE_THREADS, [\n ])\n \n \n+dnl\n+dnl Check for exception handling support.  If an explicit enable/disable\n+dnl sjlj exceptions is given, we don't have to detect.  Otherwise the\n+dnl target may or may not support call frame exceptions.\n+dnl\n+dnl GLIBCPP_ENABLE_SJLJ_EXCEPTIONS\n+dnl --enable-sjlj-exceptions forces the use of builtin setjmp.\n+dnl --disable-sjlj-exceptions forces the use of call frame unwinding.\n+dnl\n+dnl Define _GLIBCPP_SJLJ_EXCEPTIONS if the compiler is configured for it.\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_SJLJ_EXCEPTIONS, [\n+  AC_MSG_CHECKING([for exception model to use])\n+  AC_LANG_SAVE\n+  AC_LANG_CPLUSPLUS\n+  AC_ARG_ENABLE(sjlj-exceptions,\n+  [  --enable-sjlj-exceptions  force use of builtin_setjmp for exceptions],\n+  [:],\n+  [dnl Botheration.  Now we've got to detect the exception model.\n+   dnl Link tests against libgcc.a are problematic since -- at least\n+   dnl as of this writing -- we've not been given proper -L bits for\n+   dnl single-tree newlib and libgloss.\n+   dnl\n+   dnl This is what AC_TRY_COMPILE would do if it didn't delete the\n+   dnl conftest files before we got a change to grep them first.\n+   cat > conftest.$ac_ext << EOF\n+[#]line __oline__ \"configure\"\n+struct S { ~S(); };\n+void bar();\n+void foo()\n+{\n+  S s;\n+  bar();\n+}\n+EOF\n+   old_CXXFLAGS=\"$CXXFLAGS\"  \n+   CXXFLAGS=-S\n+   if AC_TRY_EVAL(ac_compile); then\n+     if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n+       enable_sjlj_exceptions=yes\n+     elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n+       enable_sjlj_exceptions=no\n+     fi\n+   fi\n+   CXXFLAGS=\"$old_CXXFLAGS\"\n+   rm -f conftest*])\n+   if test x$enable_sjlj_exceptions = xyes; then\n+     AC_DEFINE(_GLIBCPP_SJLJ_EXCEPTIONS, 1,\n+\t[Define if the compiler is configured for setjmp/longjmp exceptions.])\n+     ac_exception_model_name=sjlj\n+   elif test x$enable_sjlj_exceptions = xno; then\n+     ac_exception_model_name=\"call frame\"\n+   else\n+     AC_MSG_ERROR([unable to detect exception model])\n+   fi\n+   AC_LANG_RESTORE\n+   AC_MSG_RESULT($ac_exception_model_name)\n+])\n+\n+\n dnl\n dnl Check for template specializations for the 'long long' type extension.\n dnl"}, {"sha": "f16196a88874993063d6cdd395cf91a295725be5", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -1269,6 +1269,66 @@ AC_DEFUN(GLIBCPP_ENABLE_THREADS, [\n ])\n \n \n+dnl\n+dnl Check for exception handling support.  If an explicit enable/disable\n+dnl sjlj exceptions is given, we don't have to detect.  Otherwise the\n+dnl target may or may not support call frame exceptions.\n+dnl\n+dnl GLIBCPP_ENABLE_SJLJ_EXCEPTIONS\n+dnl --enable-sjlj-exceptions forces the use of builtin setjmp.\n+dnl --disable-sjlj-exceptions forces the use of call frame unwinding.\n+dnl\n+dnl Define _GLIBCPP_SJLJ_EXCEPTIONS if the compiler is configured for it.\n+dnl\n+AC_DEFUN(GLIBCPP_ENABLE_SJLJ_EXCEPTIONS, [\n+  AC_MSG_CHECKING([for exception model to use])\n+  AC_LANG_SAVE\n+  AC_LANG_CPLUSPLUS\n+  AC_ARG_ENABLE(sjlj-exceptions,\n+  [  --enable-sjlj-exceptions  force use of builtin_setjmp for exceptions],\n+  [:],\n+  [dnl Botheration.  Now we've got to detect the exception model.\n+   dnl Link tests against libgcc.a are problematic since -- at least\n+   dnl as of this writing -- we've not been given proper -L bits for\n+   dnl single-tree newlib and libgloss.\n+   dnl\n+   dnl This is what AC_TRY_COMPILE would do if it didn't delete the\n+   dnl conftest files before we got a change to grep them first.\n+   cat > conftest.$ac_ext << EOF\n+[#]line __oline__ \"configure\"\n+struct S { ~S(); };\n+void bar();\n+void foo()\n+{\n+  S s;\n+  bar();\n+}\n+EOF\n+   old_CXXFLAGS=\"$CXXFLAGS\"  \n+   CXXFLAGS=-S\n+   if AC_TRY_EVAL(ac_compile); then\n+     if grep _Unwind_SjLj_Resume conftest.s >/dev/null 2>&1 ; then\n+       enable_sjlj_exceptions=yes\n+     elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n+       enable_sjlj_exceptions=no\n+     fi\n+   fi\n+   CXXFLAGS=\"$old_CXXFLAGS\"\n+   rm -f conftest*])\n+   if test x$enable_sjlj_exceptions = xyes; then\n+     AC_DEFINE(_GLIBCPP_SJLJ_EXCEPTIONS, 1,\n+\t[Define if the compiler is configured for setjmp/longjmp exceptions.])\n+     ac_exception_model_name=sjlj\n+   elif test x$enable_sjlj_exceptions = xno; then\n+     ac_exception_model_name=\"call frame\"\n+   else\n+     AC_MSG_ERROR([unable to detect exception model])\n+   fi\n+   AC_LANG_RESTORE\n+   AC_MSG_RESULT($ac_exception_model_name)\n+])\n+\n+\n dnl\n dnl Check for template specializations for the 'long long' type extension.\n dnl"}, {"sha": "a16c1e1148cafe78a99f2c8f63170897a86f5358", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -546,6 +546,9 @@\n /* Version number of package */\n #undef VERSION\n \n+/* Define if the compiler is configured for setjmp/longjmp exceptions. */\n+#undef _GLIBCPP_SJLJ_EXCEPTIONS\n+\n /* Define if sigsetjmp is available.   */\n #undef HAVE_SIGSETJMP\n "}, {"sha": "dfdd9d41919c0aa587018da60ddaa65c8f2983fb", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 862, "deletions": 812, "changes": 1674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6"}, {"sha": "1de7539fdfce7b576868a81908a5dbddf5ae5d30", "filename": "libstdc++-v3/configure.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -68,6 +68,7 @@ GLIBCPP_ENABLE_LONG_LONG([no])\n GLIBCPP_ENABLE_CHEADERS([c_std])\n GLIBCPP_ENABLE_THREADS\n GLIBCPP_ENABLE_CXX_FLAGS([none])\n+GLIBCPP_ENABLE_SJLJ_EXCEPTIONS\n \n if test -n \"$with_cross_host\"; then\n "}, {"sha": "2f203f7eb742d3dabf4ede2424cfd827d9f020b2", "filename": "libstdc++-v3/libio/Makefile.in", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -110,7 +110,7 @@ toplevel_srcdir = @toplevel_srcdir@\n AUTOMAKE_OPTIONS = 1.3 cygnus\n \n mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n-@GLIBCPP_BUILD_LIBIO_TRUE@noinst_LTLIBRARIES = @GLIBCPP_BUILD_LIBIO_TRUE@libio.la\n+@GLIBCPP_BUILD_LIBIO_TRUE@noinst_LTLIBRARIES = libio.la\n @GLIBCPP_BUILD_LIBIO_FALSE@noinst_LTLIBRARIES = \n \n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n@@ -122,21 +122,14 @@ LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n LIBIO_INCLUDES = @LIBIO_INCLUDES@\n CSHADOW_INCLUDES = @CSHADOW_INCLUDES@\n \n-INCLUDES = \\\n-\t-nostdinc++ \\\n-\t-I$(top_builddir)/include -I$(GLIBCPP_INCLUDE_DIR) \\\n-\t$(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n+INCLUDES =  \t-nostdinc++ \t-I$(top_builddir)/include -I$(GLIBCPP_INCLUDE_DIR) \t$(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n \n \n-libio_headers = \\\n-        libio.h libioP.h iolibio.h\n+libio_headers =          libio.h libioP.h iolibio.h\n \n-@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = @GLIBCPP_NEED_LIBIO_TRUE@\\\n-@GLIBCPP_NEED_LIBIO_TRUE@\tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c \\\n-@GLIBCPP_NEED_LIBIO_TRUE@\tiofclose.c iofopen.c \n+@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = \tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c \tiofclose.c iofopen.c \n @GLIBCPP_NEED_LIBIO_FALSE@LIBIO_SRCS = \n-@GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = @GLIBCPP_NEED_WLIBIO_TRUE@\\\n-@GLIBCPP_NEED_WLIBIO_TRUE@\twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n+@GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = \twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n @GLIBCPP_NEED_WLIBIO_FALSE@LIBIO_WSRCS = \n \n EXTRA_DIST = iostreamP.h\n@@ -299,7 +292,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "0ff3b818409dcaf8aa281ecfc48fe7b34a2df99d", "filename": "libstdc++-v3/libmath/Makefile.in", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -113,24 +113,18 @@ mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n \n noinst_LTLIBRARIES = libmath.la\n \n-EXTRA_LONG_DOUBLE_yes = \\\n-\thypotl.c signbitl.c\n+EXTRA_LONG_DOUBLE_yes =  \thypotl.c signbitl.c\n \n \n-EXTRA_DIST = \\\n-\thypot.c hypotf.c atan2f.c expf.c \\\n-\t$(EXTRA_LONG_DOUBLE_yes) \n+EXTRA_DIST =  \thypot.c hypotf.c atan2f.c expf.c \t$(EXTRA_LONG_DOUBLE_yes) \n \n \n-libmath_la_LIBADD = \\\n-\t@LIBMATHOBJS@ \\\n-\t$(EXTRA_LONG_DOUBLE_$(USE_COMPLEX_LONG_DOUBLE)) \n+libmath_la_LIBADD =  \t@LIBMATHOBJS@ \t$(EXTRA_LONG_DOUBLE_$(USE_COMPLEX_LONG_DOUBLE)) \n \n \n libmath_la_DEPENDENCIES = $(libmath_la_LIBADD)\n \n-libmath_la_SOURCES = \\\n-\tsignbit.c signbitf.c\n+libmath_la_SOURCES =  \tsignbit.c signbitf.c\n \n \n LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n@@ -144,9 +138,7 @@ LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n LIBIO_INCLUDES = @LIBIO_INCLUDES@\n CSHADOW_INCLUDES = @CSHADOW_INCLUDES@\n \n-INCLUDES = \\\n-\t-I$(GLIBCPP_INCLUDE_DIR) -I$(top_builddir)/include  \\\n-\t$(TOPLEVEL_INCLUDES) \n+INCLUDES =  \t-I$(GLIBCPP_INCLUDE_DIR) -I$(top_builddir)/include  \t$(TOPLEVEL_INCLUDES) \n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = \n@@ -277,7 +269,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "ad08c0e6ee666dd20c45a2ad115bc3ac5623f95b", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -75,7 +75,14 @@ sources = \\\n \tdel_opnt.cc \\\n \tdel_opv.cc \\\n \tdel_opvnt.cc \\\n-\texception_support.cc \\\n+\teh_alloc.cc \\\n+\teh_aux_runtime.cc \\\n+\teh_catch.cc \\\n+\teh_exception.cc \\\n+\teh_globals.cc \\\n+\teh_personality.cc \\\n+\teh_terminate.cc \\\n+\teh_throw.cc \\\n \tnew_handler.cc \\\n \tnew_op.cc \\\n \tnew_opnt.cc \\"}, {"sha": "bdc131604500942bdd7be64ab1e8afec3242cec4", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -127,13 +127,11 @@ OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n # These bits are all figured out from configure. Look in acinclude.m4\n # or configure.in to see how they are set. See GLIBCPP_EXPORT_FLAGS\n # NB: DEBUGFLAGS have to be at the end so that -O2 can be overridden.\n-CONFIG_CXXFLAGS = \\\n-\t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n+CONFIG_CXXFLAGS =  \t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n \n \n # Warning flags to use.\n-WARN_CXXFLAGS = \\\n-\t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n+WARN_CXXFLAGS =  \t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n \n \n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n@@ -145,31 +143,13 @@ LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n LIBIO_INCLUDES = @LIBIO_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n-INCLUDES = \\\n-\t-I$(toplevel_srcdir)/gcc -I$(toplevel_srcdir)/include \\\n-\t-I$(GLIBCPP_INCLUDE_DIR) $(CSTD_INCLUDES) -I$(top_builddir)/include \\\n-\t $(LIBSUPCXX_INCLUDES)\n+INCLUDES =  \t-I$(toplevel_srcdir)/gcc -I$(toplevel_srcdir)/include \t-I$(GLIBCPP_INCLUDE_DIR) $(CSTD_INCLUDES) -I$(top_builddir)/include \t $(LIBSUPCXX_INCLUDES)\n \n \n-headers = \\\n-\texception new typeinfo cxxabi.h exception_defines.h \n+headers =  \texception new typeinfo cxxabi.h exception_defines.h \n \n \n-sources = \\\n-\tdel_op.cc \\\n-\tdel_opnt.cc \\\n-\tdel_opv.cc \\\n-\tdel_opvnt.cc \\\n-\texception_support.cc \\\n-\tnew_handler.cc \\\n-\tnew_op.cc \\\n-\tnew_opnt.cc \\\n-\tnew_opv.cc \\\n-\tnew_opvnt.cc \\\n-\tpure.cc \\\n-\ttinfo.cc \\\n-\ttinfo2.cc \\\n-\tvec.cc\n+sources =  \tdel_op.cc \tdel_opnt.cc \tdel_opv.cc \tdel_opvnt.cc \teh_alloc.cc \teh_aux_runtime.cc \teh_catch.cc \teh_exception.cc \teh_globals.cc \teh_personality.cc \teh_terminate.cc \teh_throw.cc \tnew_handler.cc \tnew_op.cc \tnew_opnt.cc \tnew_opv.cc \tnew_opvnt.cc \tpure.cc \ttinfo.cc \ttinfo2.cc \tvec.cc\n \n \n libsupc___la_SOURCES = $(sources)\n@@ -187,12 +167,7 @@ LIBSUPCXX_CXXFLAGS = -prefer-pic\n # set this option because CONFIG_CXXFLAGS has to be after\n # OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n # as the occasion call for it. (ie, --enable-debug)\n-AM_CXXFLAGS = \\\n-\t-fno-implicit-templates \\\n-\t$(LIBSUPCXX_CXXFLAGS) \\\n-\t$(WARN_CXXFLAGS) \\\n-\t$(OPTIMIZE_CXXFLAGS) \\\n-\t$(CONFIG_CXXFLAGS) \n+AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS) \t$(OPTIMIZE_CXXFLAGS) \t$(CONFIG_CXXFLAGS) \n \n \n # libstdc++ libtool notes\n@@ -216,9 +191,7 @@ AM_CXXFLAGS = \\\n #\n # We have to put --tag disable-shared after --tag CXX lest things\n # CXX undo the affect of disable-shared.\n-LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared \\\n-               --mode=compile $(CXX) $(INCLUDES) \\\n-\t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n+LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared                --mode=compile $(CXX) $(INCLUDES) \t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n \n \n # 3) We'd have a problem when building the shared libstdc++ object if\n@@ -227,8 +200,7 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared \\\n # course is problematic at this point.  So, we get the top-level\n # directory to configure libstdc++-v3 to use gcc as the C++\n # compilation driver.\n-CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \\\n-\t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = \n@@ -242,13 +214,16 @@ LIBS = @LIBS@\n libsupc__convenience_la_LDFLAGS = \n libsupc__convenience_la_LIBADD = \n libsupc__convenience_la_OBJECTS =  del_op.lo del_opnt.lo del_opv.lo \\\n-del_opvnt.lo exception_support.lo new_handler.lo new_op.lo new_opnt.lo \\\n-new_opv.lo new_opvnt.lo pure.lo tinfo.lo tinfo2.lo vec.lo\n+del_opvnt.lo eh_alloc.lo eh_aux_runtime.lo eh_catch.lo eh_exception.lo \\\n+eh_globals.lo eh_personality.lo eh_terminate.lo eh_throw.lo \\\n+new_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo pure.lo \\\n+tinfo.lo tinfo2.lo vec.lo\n libsupc___la_LDFLAGS = \n libsupc___la_LIBADD = \n libsupc___la_OBJECTS =  del_op.lo del_opnt.lo del_opv.lo del_opvnt.lo \\\n-exception_support.lo new_handler.lo new_op.lo new_opnt.lo new_opv.lo \\\n-new_opvnt.lo pure.lo tinfo.lo tinfo2.lo vec.lo\n+eh_alloc.lo eh_aux_runtime.lo eh_catch.lo eh_exception.lo eh_globals.lo \\\n+eh_personality.lo eh_terminate.lo eh_throw.lo new_handler.lo new_op.lo \\\n+new_opnt.lo new_opv.lo new_opvnt.lo pure.lo tinfo.lo tinfo2.lo vec.lo\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)\n@@ -417,7 +392,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "61dc75d159b1270a6fc95bd879799007bfacf335", "filename": "libstdc++-v3/libsupc++/eh_alloc.cc", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,157 @@\n+// -*- C++ -*- Allocate exception objects.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This is derived from the C++ ABI for IA-64.  Where we diverge\n+// for cross-architecture compatibility are noted with \"@@@\".\n+\n+#include <exception>\n+#include <cstdlib>\n+#include <cstring>\n+#include <limits.h>\n+#include \"unwind-cxx.h\"\n+#include \"gthr.h\"\n+\n+using namespace __cxxabiv1;\n+\n+\n+// ??? How to control these parameters.\n+\n+// Guess from the size of basic types how large a buffer is reasonable.\n+// Note that the basic c++ exception header has 13 pointers and 2 ints,\n+// so on a system with PSImode pointers we're talking about 56 bytes\n+// just for overhead.\n+\n+#if INT_MAX == 32767\n+# define EMERGENCY_OBJ_SIZE\t128\n+# define EMERGENCY_OBJ_COUNT\t16\n+#elif LONG_MAX == 2147483647\n+# define EMERGENCY_OBJ_SIZE\t512\n+# define EMERGENCY_OBJ_COUNT\t32\n+#else\n+# define EMERGENCY_OBJ_SIZE\t1024\n+# define EMERGENCY_OBJ_COUNT\t64\n+#endif\n+\n+#ifndef __GTHREADS\n+# undef EMERGENCY_OBJ_COUNT\n+# define EMERGENCY_OBJ_COUNT\t4\n+#endif\n+\n+#if INT_MAX == 32767 || EMERGENCY_OBJ_COUNT <= 32\n+typedef unsigned int bitmask_type;\n+#else\n+typedef unsigned long bitmask_type;\n+#endif\n+\n+\n+typedef char one_buffer[EMERGENCY_OBJ_SIZE] __attribute__((aligned));\n+static one_buffer emergency_buffer[EMERGENCY_OBJ_COUNT];\n+static bitmask_type emergency_used;\n+\n+\n+#ifdef __GTHREADS\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t emergency_mutex =__GTHREAD_MUTEX_INIT;\n+#else \n+static __gthread_mutex_t emergency_mutex;\n+#endif\n+\n+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n+static void\n+emergency_mutex_init ()\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&emergency_mutex);\n+}\n+#endif\n+#endif\n+\n+\n+extern \"C\" void *\n+__cxa_allocate_exception(std::size_t thrown_size)\n+{\n+  void *ret;\n+\n+  thrown_size += sizeof (__cxa_exception);\n+  ret = malloc (thrown_size);\n+\n+  if (! ret)\n+    {\n+#ifdef __GTHREADS\n+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n+      static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+      __gthread_once (&once, emergency_mutex_init);\n+#endif\n+      __gthread_mutex_lock (&emergency_mutex);\n+#endif\n+\n+      bitmask_type used = emergency_used;\n+      unsigned int which = 0;\n+\n+      while (used & 1)\n+\t{\n+\t  used >>= 1;\n+\t  if (++which >= EMERGENCY_OBJ_COUNT)\n+\t    std::terminate ();\n+\t}\n+\n+      emergency_used |= (bitmask_type)1 << which;\n+      ret = &emergency_buffer[which][0];\n+\n+#ifdef __GTHREADS\n+      __gthread_mutex_unlock (&emergency_mutex);\n+#endif\n+    }\n+\n+  memset (ret, 0, sizeof (__cxa_exception));\n+\n+  return (void *)((char *)ret + sizeof (__cxa_exception));\n+}\n+\n+\n+extern \"C\" void\n+__cxa_free_exception(void *vptr)\n+{\n+  char *ptr = (char *) vptr;\n+  if (ptr >= &emergency_buffer[0][0]\n+      && ptr < &emergency_buffer[0][0] + sizeof (emergency_buffer))\n+    {\n+      unsigned int which\n+\t= (unsigned)(ptr - &emergency_buffer[0][0]) / EMERGENCY_OBJ_SIZE;\n+\n+#ifdef __GTHREADS\n+      __gthread_mutex_lock (&emergency_mutex);\n+      emergency_used &= ~((bitmask_type)1 << which);\n+      __gthread_mutex_unlock (&emergency_mutex);\n+#else\n+      emergency_used &= ~((bitmask_type)1 << which);\n+#endif\n+    }\n+  else\n+    free (ptr - sizeof (__cxa_exception));\n+}"}, {"sha": "b10a21986e6efb5fd78042a57ba306306d7016f5", "filename": "libstdc++-v3/libsupc++/eh_aux_runtime.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_aux_runtime.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,56 @@\n+// -*- C++ -*- Common throw conditions.\n+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001 \n+// Free Software Foundation\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"typeinfo\"\n+#include \"exception\"\n+#include <cstddef>\n+#include \"unwind-cxx.h\"\n+#include \"exception_defines.h\"\n+\n+\n+extern \"C\" void\n+__cxa_bad_cast ()\n+{\n+#ifdef __EXCEPTIONS  \n+  throw std::bad_cast();\n+#else\n+  std::abort();\n+#endif\n+}\n+\n+extern \"C\" void\n+__cxa_bad_typeid ()\n+{\n+#ifdef __EXCEPTIONS  \n+  throw std::bad_typeid();\n+#else\n+  std::abort();\n+#endif\n+}"}, {"sha": "4f55d68e47736044f97e33ed46db2885909d0ab5", "filename": "libstdc++-v3/libsupc++/eh_catch.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_catch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_catch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_catch.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,103 @@\n+// -*- C++ -*- Exception handling routines for catching.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+#include <cstdlib>\n+#include \"unwind-cxx.h\"\n+\n+using namespace __cxxabiv1;\n+\n+\n+extern \"C\" void *\n+__cxa_begin_catch (_Unwind_Exception *exceptionObject)\n+{\n+  // ??? Foreign exceptions can't be stacked here, and there doesn't\n+  // appear to be any place to store for __cxa_end_catch to destroy.\n+\n+  __cxa_exception *header = __get_exception_header_from_ue (exceptionObject);\n+  __cxa_eh_globals *globals = __cxa_get_globals ();\n+  __cxa_exception *prev = globals->caughtExceptions;\n+  int count = header->handlerCount;\n+\n+  if (count < 0)\n+    // This exception was rethrown from an immediately enclosing region.\n+    count = -count + 1;\n+  else\n+    count += 1;\n+  header->handlerCount = count;\n+\n+  globals->uncaughtExceptions -= 1;\n+  if (header != prev)\n+    {\n+      header->nextException = prev;\n+      globals->caughtExceptions = header;\n+    }\n+\n+  return header->adjustedPtr;\n+}\n+\n+\n+extern \"C\" void\n+__cxa_end_catch ()\n+{\n+  __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n+  __cxa_exception *header = globals->caughtExceptions;\n+  int count = header->handlerCount;\n+\n+  if (count < 0)\n+    {\n+      // This exception was rethrown.  Decrement the (inverted) catch\n+      // count and remove it from the chain when it reaches zero.\n+      if (++count == 0)\n+\t{\n+\t  globals->uncaughtExceptions += 1;\n+\t  globals->caughtExceptions = header->nextException;\n+\t}\n+    }\n+  else if (--count == 0)\n+    {\n+      // Handling for this exception is complete.  Destroy the object.\n+      globals->caughtExceptions = header->nextException;\n+      _Unwind_DeleteException (&header->unwindHeader);\n+      return;\n+    }\n+  else if (count < 0)\n+    // A bug in the exception handling library or compiler.\n+    abort ();\n+\n+  header->handlerCount = count;\n+}\n+\n+\n+bool\n+std::uncaught_exception() throw()\n+{\n+  __cxa_eh_globals *globals = __cxa_get_globals ();\n+  return globals->uncaughtExceptions != 0;\n+}"}, {"sha": "3c1a7a44ccb0ce1e52e47bb3e93071183c6a3d8f", "filename": "libstdc++-v3/libsupc++/eh_exception.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_exception.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,44 @@\n+// -*- C++ -*- std::exception implementation.\n+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001 \n+// Free Software Foundation\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+#include \"typeinfo\"\n+#include \"exception\"\n+#include \"unwind-cxx.h\"\n+\n+std::exception::~exception() throw() { }\n+\n+std::bad_exception::~bad_exception() throw() { }\n+\n+const char* \n+std::exception::what() const throw()\n+{\n+  return typeid (*this).name ();\n+}"}, {"sha": "a247b842f591fff5442f1e7b4cfe3914b19b5ced", "filename": "libstdc++-v3/libsupc++/eh_globals.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_globals.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,120 @@\n+// -*- C++ -*- Manage the thread-local exception globals.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+#include <exception>\n+#include \"unwind-cxx.h\"\n+#include \"gthr.h\"\n+\n+using namespace __cxxabiv1;\n+\n+\n+// Single-threaded fallback buffer.\n+static __cxa_eh_globals globals_static;\n+\n+#if __GTHREADS\n+static __gthread_key_t globals_key;\n+static int use_thread_key = -1;\n+\n+static void\n+get_globals_dtor (void *ptr)\n+{\n+  __gthread_key_dtor (globals_key, ptr);\n+  if (ptr)\n+    free (ptr);\n+}\n+\n+static void\n+get_globals_init ()\n+{\n+  use_thread_key =\n+    (__gthread_key_create (&globals_key, get_globals_dtor) == 0);\n+}\n+\n+static void\n+get_globals_init_once ()\n+{\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  if (__gthread_once (&once, get_globals_init) != 0\n+      || use_thread_key < 0)\n+    use_thread_key = 0;\n+}\n+#endif\n+\n+extern \"C\" __cxa_eh_globals *\n+__cxa_get_globals_fast ()\n+{\n+#if __GTHREADS\n+  if (use_thread_key)\n+    return (__cxa_eh_globals *) __gthread_getspecific (globals_key);\n+  else\n+    return &globals_static;\n+#else\n+  return &globals_static;\n+#endif\n+}\n+\n+extern \"C\" __cxa_eh_globals *\n+__cxa_get_globals ()\n+{\n+#if __GTHREADS\n+  __cxa_eh_globals *g;\n+\n+  if (use_thread_key == 0)\n+    return &globals_static;\n+\n+  if (use_thread_key < 0)\n+    get_globals_init_once ();\n+\n+  g = (__cxa_eh_globals *) __gthread_getspecific (globals_key);\n+  if (! g)\n+    {\n+      static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+\n+      // Make sure use_thread_key got initialized.  Some systems have\n+      // dummy thread routines in their libc that return a success.\n+      if (__gthread_once (&once, eh_threads_initialize) != 0\n+\t  || use_thread_key < 0)\n+\t{\n+\t  use_thread_key = 0;\n+\t  return &globals_static;\n+\t}\n+      \n+      if ((g = malloc (sizeof (__cxa_eh_globals))) == 0\n+\t  || __gthread_setspecific (eh_context_key, (void *) g) != 0)\n+        std::terminate ();\n+      g->caughtExceptions = 0;\n+      g->uncaughtExceptions = 0;\n+    }\n+\n+  return g;\n+#else\n+  return &globals_static;\n+#endif\n+}"}, {"sha": "5dfadc944388dcdf73558f65553334b5fb71b8eb", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,599 @@\n+// -*- C++ -*- The GNU C++ exception personality routine.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+#include <bits/c++config.h>\n+#include <cstdlib>\n+#include \"unwind-cxx.h\"\n+\n+using namespace __cxxabiv1;\n+\n+\n+\f\n+// ??? These ought to go somewhere else dwarf2 or dwarf2eh related.\n+\n+// Pointer encodings.\n+#define DW_EH_PE_absptr         0x00\n+#define DW_EH_PE_omit           0xff\n+\n+#define DW_EH_PE_uleb128        0x01\n+#define DW_EH_PE_udata2         0x02\n+#define DW_EH_PE_udata4         0x03\n+#define DW_EH_PE_udata8         0x04\n+#define DW_EH_PE_sleb128        0x09\n+#define DW_EH_PE_sdata2         0x0A\n+#define DW_EH_PE_sdata4         0x0B\n+#define DW_EH_PE_sdata8         0x0C\n+#define DW_EH_PE_signed         0x08\n+\n+#define DW_EH_PE_pcrel          0x10\n+#define DW_EH_PE_textrel        0x20\n+#define DW_EH_PE_datarel        0x30\n+#define DW_EH_PE_funcrel        0x40\n+\n+static unsigned int\n+size_of_encoded_value (unsigned char encoding)\n+{\n+  switch (encoding & 0x07)\n+    {\n+    case DW_EH_PE_absptr:\n+      return sizeof (void *);\n+    case DW_EH_PE_udata2:\n+      return 2;\n+    case DW_EH_PE_udata4:\n+      return 4;\n+    case DW_EH_PE_udata8:\n+      return 8;\n+    }\n+  abort ();\n+}\n+\n+static const unsigned char *\n+read_encoded_value (_Unwind_Context *context, unsigned char encoding,\n+\t\t    const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  union unaligned\n+    {\n+      void *ptr;\n+      unsigned u2 __attribute__ ((mode (HI)));\n+      unsigned u4 __attribute__ ((mode (SI)));\n+      unsigned u8 __attribute__ ((mode (DI)));\n+      signed s2 __attribute__ ((mode (HI)));\n+      signed s4 __attribute__ ((mode (SI)));\n+      signed s8 __attribute__ ((mode (DI)));\n+    } __attribute__((__packed__));\n+\n+  union unaligned *u = (union unaligned *) p;\n+  _Unwind_Ptr result;\n+\n+  switch (encoding & 0x0f)\n+    {\n+    case DW_EH_PE_absptr:\n+      result = (_Unwind_Ptr) u->ptr;\n+      p += sizeof (void *);\n+      break;\n+\n+    case DW_EH_PE_uleb128:\n+      {\n+\tunsigned int shift = 0;\n+\tunsigned char byte;\n+\n+\tresult = 0;\n+\tdo\n+\t  {\n+\t    byte = *p++;\n+\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t    shift += 7;\n+\t  }\n+\twhile (byte & 0x80);\n+      }\n+      break;\n+\n+    case DW_EH_PE_sleb128:\n+      {\n+\tunsigned int shift = 0;\n+\tunsigned char byte;\n+\n+\tresult = 0;\n+\tdo\n+\t  {\n+\t    byte = *p++;\n+\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t    shift += 7;\n+\t  }\n+\twhile (byte & 0x80);\n+\n+\tif (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n+\t  result |= -(1L << shift);\n+      }\n+      break;\n+\n+    case DW_EH_PE_udata2:\n+      result = u->u2;\n+      p += 2;\n+      break;\n+    case DW_EH_PE_udata4:\n+      result = u->u4;\n+      p += 4;\n+      break;\n+    case DW_EH_PE_udata8:\n+      result = u->u8;\n+      p += 8;\n+      break;\n+\n+    case DW_EH_PE_sdata2:\n+      result = u->s2;\n+      p += 2;\n+      break;\n+    case DW_EH_PE_sdata4:\n+      result = u->s4;\n+      p += 4;\n+      break;\n+    case DW_EH_PE_sdata8:\n+      result = u->s8;\n+      p += 8;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (result != 0)\n+    switch (encoding & 0xf0)\n+      {\n+      case DW_EH_PE_absptr:\n+\tbreak;\n+\n+      case DW_EH_PE_pcrel:\n+\t// Define as relative to the beginning of the pointer.\n+\tresult += (_Unwind_Ptr) u;\n+\tbreak;\n+\n+      case DW_EH_PE_textrel:\n+      case DW_EH_PE_datarel:\n+\t// FIXME.\n+\tabort ();\n+\n+      case DW_EH_PE_funcrel:\n+\tresult += _Unwind_GetRegionStart (context);\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+\n+  *val = result;\n+  return p;\n+}\n+\n+static inline const unsigned char *\n+read_uleb128 (const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  return read_encoded_value (0, DW_EH_PE_uleb128, p, val);\n+}\n+\n+static inline const unsigned char *\n+read_sleb128 (const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  return read_encoded_value (0, DW_EH_PE_sleb128, p, val);\n+}\n+\n+\f\n+struct lsda_header_info\n+{\n+  _Unwind_Ptr Start;\n+  _Unwind_Ptr LPStart;\n+  const unsigned char *TType;\n+  const unsigned char *action_table;\n+  unsigned char ttype_encoding;\n+  unsigned char call_site_encoding;\n+};\n+\n+static const unsigned char *\n+parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n+\t\t   lsda_header_info *info)\n+{\n+  _Unwind_Ptr tmp;\n+  unsigned char lpstart_encoding;\n+\n+  info->Start = (context ? _Unwind_GetRegionStart (context) : 0);\n+\n+  // Find @LPStart, the base to which landing pad offsets are relative.\n+  lpstart_encoding = *p++;\n+  if (lpstart_encoding != DW_EH_PE_omit)\n+    p = read_encoded_value (context, lpstart_encoding, p, &info->LPStart);\n+  else\n+    info->LPStart = info->Start;\n+\n+  // Find @TType, the base of the handler and exception spec type data.\n+  info->ttype_encoding = *p++;\n+  if (info->ttype_encoding != DW_EH_PE_omit)\n+    {\n+      p = read_uleb128 (p, &tmp);\n+      info->TType = p + tmp;\n+    }\n+  else\n+    info->TType = 0;\n+\n+  // The encoding and length of the call-site table; the action table\n+  // immediately follows.\n+  info->call_site_encoding = *p++;\n+  p = read_uleb128 (p, &tmp);\n+  info->action_table = p + tmp;\n+\n+  return p;\n+}\n+\n+static const std::type_info *\n+get_ttype_entry (_Unwind_Context *context, lsda_header_info *info, long i)\n+{\n+  _Unwind_Ptr ptr;\n+\n+  i *= size_of_encoded_value (info->ttype_encoding);\n+  read_encoded_value (context, info->ttype_encoding, info->TType - i, &ptr);\n+\n+  return reinterpret_cast<const std::type_info *>(ptr);\n+}\n+\n+static bool\n+check_exception_spec (_Unwind_Context *context, lsda_header_info *info,\n+\t\t      const std::type_info *throw_type, long filter_value)\n+{\n+  const unsigned char *e = info->TType - filter_value - 1;\n+\n+  while (1)\n+    {\n+      const std::type_info *catch_type;\n+      _Unwind_Ptr tmp;\n+      void *dummy;\n+\n+      e = read_uleb128 (e, &tmp);\n+\n+      // Zero signals the end of the list.  If we've not found\n+      // a match by now, then we've failed the specification.\n+      if (tmp == 0)\n+        return false;\n+\n+      // Match a ttype entry.\n+      catch_type = get_ttype_entry (context, info, tmp);\n+      if (catch_type->__do_catch (throw_type, &dummy, 1))\n+\treturn true;\n+    }\n+}\n+\n+// Using a different personality function name causes link failures\n+// when trying to mix code using different exception handling models.\n+#ifdef _GLIBCPP_SJLJ_EXCEPTIONS\n+#define PERSONALITY_FUNCTION\t__gxx_personality_sj0\n+#define __builtin_eh_return_data_regno(x) x\n+#else\n+#define PERSONALITY_FUNCTION\t__gxx_personality_v0\n+#endif\n+\n+extern \"C\" _Unwind_Reason_Code\n+PERSONALITY_FUNCTION (int version,\n+\t\t      _Unwind_Action actions,\n+\t\t      _Unwind_Exception_Class exception_class,\n+\t\t      struct _Unwind_Exception *ue_header,\n+\t\t      struct _Unwind_Context *context)\n+{\n+  __cxa_exception *xh = __get_exception_header_from_ue (ue_header);\n+\n+  enum found_handler_type\n+  {\n+    found_nothing,\n+    found_terminate,\n+    found_cleanup,\n+    found_handler\n+  } found_type;\n+\n+  lsda_header_info info;\n+  const unsigned char *language_specific_data;\n+  const unsigned char *action_record;\n+  const unsigned char *p;\n+  _Unwind_Ptr landing_pad, ip;\n+  int handler_switch_value;\n+  void *adjusted_ptr = xh + 1;\n+\n+  // Interface version check.\n+  if (version != 1)\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  // Shortcut for phase 2 found handler for domestic exception.\n+  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n+      && exception_class == __gxx_exception_class)\n+    {\n+      handler_switch_value = xh->handlerSwitchValue;\n+      landing_pad = (_Unwind_Ptr) xh->catchTemp;\n+      found_type = (landing_pad == 0 ? found_terminate : found_handler);\n+      goto install_context;\n+    }\n+\n+  language_specific_data = (const unsigned char *)\n+    _Unwind_GetLanguageSpecificData (context);\n+\n+  // If no LSDA, then there are no handlers or cleanups.\n+  if (! language_specific_data)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  // Parse the LSDA header.\n+  p = parse_lsda_header (context, language_specific_data, &info);\n+  ip = _Unwind_GetIP (context) - 1;\n+  landing_pad = 0;\n+  action_record = 0;\n+  handler_switch_value = 0;\n+\n+#ifdef _GLIBCPP_SJLJ_EXCEPTIONS\n+  // The given \"IP\" is an index into the call-site table, with two\n+  // exceptions -- -1 means no-action, and 0 means terminate.  But\n+  // since we're using uleb128 values, we've not got random access\n+  // to the array.\n+  if ((int) ip < 0)\n+    return _URC_CONTINUE_UNWIND;\n+  else if (ip == 0)\n+    {\n+      // Fall through to set found_terminate.\n+    }\n+  else\n+    {\n+      _Unwind_Ptr cs_lp, cs_action;\n+      do\n+\t{\n+\t  p = read_uleb128 (p, &cs_lp);\n+\t  p = read_uleb128 (p, &cs_action);\n+\t}\n+      while (--ip);\n+\n+      // Can never have null landing pad for sjlj -- that would have\n+      // been indicated by a -1 call site index.\n+      landing_pad = cs_lp + 1;\n+      if (cs_action)\n+\taction_record = info.action_table + cs_action - 1;\n+      goto found_something;\n+    }\n+#else\n+  // Search the call-site table for the action associated with this IP.\n+  while (p < info.action_table)\n+    {\n+      _Unwind_Ptr cs_start, cs_len, cs_lp, cs_action;\n+\n+      // Note that all call-site encodings are \"absolute\" displacements.\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);\n+      p = read_uleb128 (p, &cs_action);\n+\n+      // The table is sorted, so if we've passed the ip, stop.\n+      if (ip < info.Start + cs_start)\n+\tp = info.action_table;\n+      else if (ip < info.Start + cs_start + cs_len)\n+\t{\n+\t  if (cs_lp)\n+\t    landing_pad = info.LPStart + cs_lp;\n+\t  if (cs_action)\n+\t    action_record = info.action_table + cs_action - 1;\n+\t  goto found_something;\n+\t}\n+    }\n+#endif // _GLIBCPP_SJLJ_EXCEPTIONS\n+\n+  // If ip is not present in the table, call terminate.  This is for\n+  // a destructor inside a cleanup, or a library routine the compiler\n+  // was not expecting to throw.\n+  found_type = (actions & _UA_FORCE_UNWIND ? found_nothing : found_terminate);\n+  goto do_something;\n+\n+ found_something:\n+  if (landing_pad == 0)\n+    {\n+      // If ip is present, and has a null landing pad, there are\n+      // no cleanups or handlers to be run.\n+      found_type = found_nothing;\n+    }\n+  else if (action_record == 0)\n+    {\n+      // If ip is present, has a non-null landing pad, and a null\n+      // action table offset, then there are only cleanups present.\n+      // Cleanups use a zero switch value, as set above.\n+      found_type = found_cleanup;\n+    }\n+  else\n+    {\n+      // Otherwise we have a catch handler or exception specification.\n+\n+      signed long ar_filter, ar_disp;\n+      const std::type_info *throw_type, *catch_type;\n+      bool saw_cleanup = false;\n+      bool saw_handler = false;\n+\n+      // During forced unwinding, we only run cleanups.  With a foreign\n+      // exception class, there's no exception type.\n+      // ??? What to do about GNU Java and GNU Ada exceptions.\n+\n+      if ((actions & _UA_FORCE_UNWIND)\n+\t  || exception_class != __gxx_exception_class)\n+\tthrow_type = 0;\n+      else\n+\tthrow_type = xh->exceptionType;\n+\n+      while (1)\n+\t{\n+\t  _Unwind_Ptr tmp;\n+\n+\t  p = action_record;\n+\t  p = read_sleb128 (p, &tmp); ar_filter = tmp;\n+\t  read_sleb128 (p, &tmp); ar_disp = tmp;\n+\n+\t  if (ar_filter == 0)\n+\t    {\n+\t      // Zero filter values are cleanups.\n+\t      saw_cleanup = true;\n+\t    }\n+\t  else if (ar_filter > 0)\n+\t    {\n+\t      // Positive filter values are handlers.\n+\t      catch_type = get_ttype_entry (context, &info, ar_filter);\n+\t      adjusted_ptr = xh + 1;\n+\n+\t      // Null catch type is a catch-all handler.  We can catch\n+\t      // foreign exceptions with this.\n+\t      if (! catch_type)\n+\t\t{\n+\t\t  if (!(actions & _UA_FORCE_UNWIND))\n+\t\t    {\n+\t\t      saw_handler = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else if (throw_type)\n+\t\t{\n+\t\t  // Pointer types need to adjust the actual pointer, not\n+\t\t  // the pointer to pointer that is the exception object.\n+\t\t  // This also has the effect of passing pointer types\n+\t\t  // \"by value\" through the __cxa_begin_catch return value.\n+\t\t  if (throw_type->__is_pointer_p ())\n+\t\t    adjusted_ptr = *(void **) adjusted_ptr;\n+\n+\t\t  if (catch_type->__do_catch (throw_type, &adjusted_ptr, 1))\n+\t\t    {\n+\t\t      saw_handler = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // Negative filter values are exception specifications.\n+\t      // ??? How do foreign exceptions fit in?  As far as I can\n+\t      // see we can't match because there's no __cxa_exception\n+\t      // object to stuff bits in for __cxa_call_unexpected to use.\n+\t      if (throw_type\n+\t\t  && ! check_exception_spec (context, &info, throw_type,\n+\t\t\t\t\t     ar_filter))\n+\t\t{\n+\t\t  saw_handler = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (ar_disp == 0)\n+\t    break;\n+\t  action_record = p + ar_disp;\n+\t}\n+\n+      if (saw_handler)\n+\t{\n+\t  handler_switch_value = ar_filter;\n+\t  found_type = found_handler;\n+\t}\n+      else\n+\tfound_type = (saw_cleanup ? found_cleanup : found_nothing);\n+    }\n+\n+ do_something:\n+   if (found_type == found_nothing)\n+     return _URC_CONTINUE_UNWIND;\n+\n+  if (actions & _UA_SEARCH_PHASE)\n+    {\n+      if (found_type == found_cleanup)\n+\treturn _URC_CONTINUE_UNWIND;\n+\n+      // For domestic exceptions, we cache data from phase 1 for phase 2.\n+      if (exception_class == __gxx_exception_class)\n+        {\n+          xh->handlerSwitchValue = handler_switch_value;\n+          xh->actionRecord = action_record;\n+          xh->languageSpecificData = language_specific_data;\n+          xh->adjustedPtr = adjusted_ptr;\n+\n+          // ??? Completely unknown what this field is supposed to be for.\n+          // ??? Need to cache TType encoding base for call_unexpected.\n+          xh->catchTemp = (void *) (_Unwind_Ptr) landing_pad;\n+\t}\n+      return _URC_HANDLER_FOUND;\n+    }\n+\n+ install_context:\n+  if (found_type == found_terminate)\n+    {\n+      __cxa_begin_catch (&xh->unwindHeader);\n+      __terminate (xh->terminateHandler);\n+    }\n+\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n+\t\t (_Unwind_Ptr) &xh->unwindHeader);\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n+\t\t handler_switch_value);\n+  _Unwind_SetIP (context, landing_pad);\n+  return _URC_INSTALL_CONTEXT;\n+}\n+\n+extern \"C\" void\n+__cxa_call_unexpected (_Unwind_Exception *exc_obj)\n+{\n+  __cxa_begin_catch (exc_obj);\n+\n+  // This function is a handler for our exception argument.  If we exit\n+  // by throwing a different exception, we'll need the original cleaned up.\n+  struct end_catch_protect\n+  {\n+    end_catch_protect() { }\n+    ~end_catch_protect() { __cxa_end_catch(); }\n+  } end_catch_protect_obj;\n+\n+  __cxa_exception *xh = __get_exception_header_from_ue (exc_obj);\n+\n+  try {\n+    __unexpected (xh->unexpectedHandler);\n+  } catch (...) {\n+    // Get the exception thrown from unexpected.\n+    // ??? Foreign exceptions can't be stacked this way.\n+\n+    __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n+    __cxa_exception *new_xh = globals->caughtExceptions;\n+\n+    // We don't quite have enough stuff cached; re-parse the LSDA.\n+    lsda_header_info info;\n+    parse_lsda_header (0, xh->languageSpecificData, &info);\n+\n+    // If this new exception meets the exception spec, allow it.\n+    if (check_exception_spec (0, &info, new_xh->exceptionType,\n+\t\t\t      xh->handlerSwitchValue))\n+      throw;\n+\n+    // If the exception spec allows std::bad_exception, throw that.\n+    const std::type_info &bad_exc = typeid (std::bad_exception);\n+    if (check_exception_spec (0, &info, &bad_exc, xh->handlerSwitchValue))\n+      throw std::bad_exception ();\n+\n+    // Otherwise, die.\n+    __terminate(xh->terminateHandler);\n+  }\n+}"}, {"sha": "11d5829f5deb622d6d19d1629c4ccd564be339fd", "filename": "libstdc++-v3/libsupc++/eh_terminate.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_terminate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_terminate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_terminate.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,87 @@\n+// -*- C++ -*- std::terminate, std::unexpected and friends.\n+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001 \n+// Free Software Foundation\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"typeinfo\"\n+#include \"exception\"\n+#include <cstdlib>\n+#include \"unwind-cxx.h\"\n+#include \"exception_defines.h\"\n+\n+using namespace __cxxabiv1;\n+\n+/* The current installed user handlers.  */\n+std::terminate_handler __cxxabiv1::__terminate_handler = abort;\n+std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;\n+\n+void\n+__cxxabiv1::__terminate (std::terminate_handler handler)\n+{\n+  try {\n+    handler ();\n+    abort ();\n+  } catch (...) {\n+    abort ();\n+  }\n+}\n+\n+void\n+std::terminate ()\n+{\n+  __terminate (__terminate_handler);\n+}\n+\n+void\n+__cxxabiv1::__unexpected (std::unexpected_handler handler)\n+{\n+  handler();\n+  std::terminate ();\n+}\n+\n+void\n+std::unexpected ()\n+{\n+  __unexpected (__unexpected_handler);\n+}\n+\n+std::terminate_handler\n+std::set_terminate (std::terminate_handler func) throw()\n+{\n+  std::terminate_handler old = __terminate_handler;\n+  __terminate_handler = func;\n+  return old;\n+}\n+\n+std::unexpected_handler\n+std::set_unexpected (std::unexpected_handler func) throw()\n+{\n+  std::unexpected_handler old = __unexpected_handler;\n+  __unexpected_handler = func;\n+  return old;\n+}"}, {"sha": "a8e9ba34557aa282a5193145b4ccdbc98f2ad0ad", "filename": "libstdc++-v3/libsupc++/eh_throw.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,102 @@\n+// -*- C++ -*- Exception handling routines for throwing.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+\n+#include <bits/c++config.h>\n+#include \"unwind-cxx.h\"\n+\n+\n+using namespace __cxxabiv1;\n+\n+\n+static void\n+__gxx_exception_cleanup (_Unwind_Reason_Code code, _Unwind_Exception *exc)\n+{\n+  __cxa_exception *header = __get_exception_header_from_ue (exc);\n+\n+  // If we havn't been caught by a foreign handler, then this is\n+  // some sort of unwind error.  In that case just die immediately.\n+  if (code != _URC_FOREIGN_EXCEPTION_CAUGHT)\n+    __terminate (header->terminateHandler);\n+\n+  if (header->exceptionDestructor)\n+    header->exceptionDestructor (header + 1);\n+\n+  __cxa_free_exception (header + 1);\n+}\n+\n+\n+extern \"C\" void\n+__cxa_throw (void *obj, std::type_info *tinfo, void (*dest) (void *))\n+{\n+  __cxa_exception *header = __get_exception_header_from_obj (obj);\n+  header->exceptionType = tinfo;\n+  header->exceptionDestructor = dest;\n+  header->unexpectedHandler = __unexpected_handler;\n+  header->terminateHandler = __terminate_handler;\n+  header->unwindHeader.exception_class = __gxx_exception_class;\n+  header->unwindHeader.exception_cleanup = __gxx_exception_cleanup;\n+\n+  __cxa_eh_globals *globals = __cxa_get_globals ();\n+  globals->uncaughtExceptions += 1;\n+\n+#ifdef _GLIBCPP_SJLJ_EXCEPTIONS\n+  _Unwind_SjLj_RaiseException (&header->unwindHeader);\n+#else\n+  _Unwind_RaiseException (&header->unwindHeader);\n+#endif\n+\n+  // Some sort of unwinding error.  Note that terminate is a handler.\n+  __cxa_begin_catch (&header->unwindHeader);\n+  std::terminate ();\n+}\n+\n+extern \"C\" void\n+__cxa_rethrow ()\n+{\n+  __cxa_eh_globals *globals = __cxa_get_globals ();\n+  __cxa_exception *header = globals->caughtExceptions;\n+\n+  // Watch for luser rethrowing with no active exception.\n+  if (header)\n+    {\n+      // Tell __cxa_end_catch this is a rethrow.\n+      header->handlerCount = -header->handlerCount;\n+\n+#ifdef _GLIBCPP_SJLJ_EXCEPTIONS\n+      _Unwind_SjLj_RaiseException (&header->unwindHeader);\n+#else\n+      _Unwind_RaiseException (&header->unwindHeader);\n+#endif\n+  \n+      // Some sort of unwinding error.  Note that terminate is a handler.\n+      __cxa_begin_catch (&header->unwindHeader);\n+    }\n+  std::terminate ();\n+}"}, {"sha": "48adafa4ab907baf5829b8072a64da8dc1902694", "filename": "libstdc++-v3/libsupc++/exception_support.cc", "status": "removed", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1c98ea459813570b4588427030daa03958fda6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1c98ea459813570b4588427030daa03958fda6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.cc?ref=ce1c98ea459813570b4588427030daa03958fda6", "patch": "@@ -1,388 +0,0 @@\n-// Functions for Exception Support for -*- C++ -*-\n-\n-// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001 \n-// Free Software Foundation\n-//\n-// This file is part of GNU CC.\n-//\n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include \"typeinfo\"\n-#include \"exception\"\n-#include <cstddef>\n-#include \"exception_support.h\"\n-#include \"exception_defines.h\"\n-\n-/* Define terminate, unexpected, set_terminate, set_unexpected as\n-   well as the default terminate func and default unexpected func.  */\n-\n-/* __terminate and __terminate_set_func, defined in libgcc2. */\n-typedef void (*__terminate_func_ptr)(void) __attribute__ ((__noreturn__));\n-extern \"C\" void __terminate (void) __attribute__ ((__noreturn__));\n-extern \"C\" __terminate_func_ptr __terminate_set_func (__terminate_func_ptr);\n-\n-using std::terminate;\n-\n-void\n-std::terminate ()\n-{\n-  __terminate ();\n-}\n-\n-void\n-__default_unexpected ()\n-{\n-  terminate ();\n-}\n-\n-static std::unexpected_handler __unexpected_func __attribute__((__noreturn__))\n-  = __default_unexpected;\n-\n-std::terminate_handler\n-std::set_terminate (std::terminate_handler func) throw()\n-{\n-  return __terminate_set_func (func);\n-}\n-\n-std::unexpected_handler\n-std::set_unexpected (std::unexpected_handler func) throw()\n-{\n-  std::unexpected_handler old = __unexpected_func;\n-\n-  __unexpected_func = func;\n-  return old;\n-}\n-\n-void\n-std::unexpected ()\n-{\n-  __unexpected_func ();\n-}\n-\n-/* Language-specific EH info pointer, defined in libgcc2. */\n-extern \"C\" cp_eh_info **__get_eh_info (); \t// actually void **\n-#define CP_EH_INFO ((cp_eh_info *) *__get_eh_info ())\n-\n-/* Exception allocate and free, defined in libgcc2. */\n-extern \"C\" void *__eh_alloc(std::size_t);\n-extern \"C\" void __eh_free(void *);\n-\n-/* Is P the type_info node for a pointer of some kind?  */\n-extern bool __is_pointer (void *);\n-\n-\n-#ifdef __EXCEPTIONS\n-/* OLD Compiler hook to return a pointer to the info for the current exception.\n-   Used by get_eh_info ().  This fudges the actualy returned value to\n-   point to the beginning of what USE to be the cp_eh_info structure.\n-   THis is so that old code that dereferences this pointer will find\n-   things where it expects it to be.*/\n-extern \"C\" void *\n-__cp_exception_info (void)\n-{\n-  return &((*__get_eh_info ())->value);\n-}\n-\n-/* Old Compiler hook to return a pointer to the info for the current exception.\n-   Used by get_eh_info ().  */\n-\n-extern \"C\" cp_eh_info *\n-__cp_eh_info (void)\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  return p;\n-}\n-\n-/* Compiler hook to return a pointer to the info for the current exception,\n-   Set the caught bit, and increment the number of handlers that are\n-   looking at this exception. This makes handlers smaller. */\n-\n-extern \"C\" cp_eh_info *\n-__start_cp_handler (void)\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  p->caught = 1;\n-  p->handlers++;\n-  return p;\n-}\n-\n-extern \"C\" int __throw_type_match_rtti_2 (const void *, const void *,\n-\t\t\t\t\t void *, void **);\n-\n-extern \"C\" void *\n-__cplus_type_matcher (__eh_info *info_, void *match_info,\n-\t\t      exception_descriptor *exception_table)\n-{\n-  cp_eh_info *info = (cp_eh_info *)info_;\n-\n-  /* No exception table implies the old style mechanism, so don't check. */\n-  if (exception_table != NULL \n-      && exception_table->lang.language != EH_LANG_C_plus_plus)\n-    return NULL;\n-\n-  if (match_info == CATCH_ALL_TYPE)\n-    return (void *)1;\n-\n-  /* we don't worry about version info yet, there is only one version! */\n-  \n-  void *match_type = match_info;\n-  \n-  if (__throw_type_match_rtti_2 (match_type, info->type,\n-\t\t\t\t info->original_value, &info->value))\n-    // Arbitrary non-null pointer.\n-    return (void *)1;\n-  else\n-    return NULL;\n-}\n-\n-/* Compiler hook to push a new exception onto the stack.\n-   Used by expand_throw().  */\n-\n-extern \"C\" void\n-__cp_push_exception (void *value, void *type, cleanup_fn cleanup)\n-{\n-  cp_eh_info *p = (cp_eh_info *) __eh_alloc (sizeof (cp_eh_info));\n-\n-  p->value = value;\n-  p->type = type;\n-  p->cleanup = cleanup;\n-  p->handlers = 0;\n-  p->caught = false;\n-  p->original_value = value;\n-\n-  p->eh_info.match_function = __cplus_type_matcher;\n-  p->eh_info.language = EH_LANG_C_plus_plus;\n-  p->eh_info.version = 1;\n-\n-  cp_eh_info **q = __get_eh_info ();\n-\n-  p->next = *q;\n-  *q = p;\n-}\n-\n-/* Compiler hook to pop an exception that has been finalized.  Used by\n-   push_eh_cleanup().  P is the info for the exception caught by the\n-   current catch block.  */\n-\n-extern \"C\" void\n-__cp_pop_exception (void* p_)\n-{\n-  cp_eh_info *p = static_cast <cp_eh_info *> (p_);\n-  cp_eh_info **stack = __get_eh_info ();\n-  cp_eh_info **q = stack;\n-\n-  --p->handlers;\n-\n-  /* Do nothing if our exception is being rethrown (i.e. if the active\n-     exception is our exception and it is uncaught).  */\n-  if (p == *q && !p->caught)\n-    return;\n-\n-  /* Don't really pop if there are still active handlers for our exception;\n-     rather, push it down past any uncaught exceptions.  */\n-  if (p->handlers != 0)\n-    {\n-      if (p == *q && p->next && !p->next->caught)\n-\t{\n-\t  q = &(p->next);\n-\t  while (1)\n-\t    {\n-\t      if (*q == 0 || (*q)->caught)\n-\t\tbreak;\n-\n-\t      q = &((*q)->next);\n-\t    }\n-\t  *stack = p->next;\n-\t  p->next = *q;\n-\t  *q = p;\n-\t}\n-      return;\n-    }\n-\n-  for (; *q; q = &((*q)->next))\n-    if (*q == p)\n-      break;\n-\n-  if (! *q)\n-    terminate ();\n-\n-  *q = p->next;\n-\n-  if (p->cleanup)\n-    // value may have been adjusted.\n-    CALL_CLEANUP (p->cleanup, p->original_value);\n-\n-  if (! __is_pointer (p->type))\n-    __eh_free (p->original_value);  // value may have been adjusted.\n-\n-  __eh_free (p);\n-}\n-\n-/* We're doing a rethrow.  Find the currently handled exception, mark it\n-   uncaught, and move it to the top of the EH stack.  */\n-\n-extern \"C\" cp_eh_info *\n-__uncatch_exception (void)\n-{\n-  cp_eh_info **stack = __get_eh_info ();\n-  cp_eh_info **q = stack;\n-  cp_eh_info *p;\n-\n-  while (1)\n-    {\n-      p = *q;\n-\n-      if (p == 0)\n-\tterminate ();\n-      if (p->caught)\n-\tbreak;\n-\n-      q = &(p->next);\n-    }\n-\n-  if (q != stack)\n-    {\n-      *q = p->next;\n-      p->next = *stack;\n-      *stack = p;\n-    }\n-\n-  p->caught = false;\n-\n-  return p;\n-}\n-\n-/* Mark P as caught after we previously marked it as uncaught.  */\n-\n-extern \"C\" void\n-__recatch_exception (cp_eh_info *p)\n-{\n-  p->caught = true;\n-}\n-\n-/* As per [except.unexpected]:\n-   If an exception is thrown, we check it against the spec.  If it doesn't\n-   match, we call unexpected ().  If unexpected () throws, we check that\n-   exception against the spec.  If it doesn't match, if the spec allows\n-   bad_exception we throw that; otherwise we call terminate ().\n-\n-   The compiler treats an exception spec as a try block with a generic\n-   handler that just calls this function with a list of the allowed\n-   exception types, so we have an active exception that can be rethrown.\n-\n-   This function does not return.  */   \n-\n-extern \"C\" void\n-__check_eh_spec (int n, const void **spec)\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  void *d;\n-\n-  for (int i = 0; i < n; ++i)\n-    {\n-      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n-\tthrow;\n-    }\n-\n-  try\n-    {\n-      std::unexpected ();\n-    }\n-  catch (...)\n-    {\n-      // __exception_info is an artificial var pushed into each catch block.\n-      if (p != __exception_info)\n-\t{\n-\t  p = __exception_info;\n-\t  for (int i = 0; i < n; ++i)\n-\t    {\n-\t      if (__throw_type_match_rtti_2 (spec[i], p->type, p->value, &d))\n-\t\tthrow;\n-\t    }\n-\t}\n-\n-      const std::type_info &bad_exc = typeid (std::bad_exception);\n-      for (int i = 0; i < n; ++i)\n-\t{\n-\t  if (__throw_type_match_rtti_2 (spec[i], &bad_exc, p->value, &d))\n-\t    throw std::bad_exception ();\n-\t}\n-\n-      terminate ();\n-    }\n-}\n-\n-/* Special case of the above for throw() specs.  */\n-\n-extern \"C\" void\n-__check_null_eh_spec (void)\n-{\n-  __check_eh_spec (0, 0);\n-}\n-#endif //__EXCEPTIONS\n-\n-// Helpers for rtti. Although these don't return, we give them return types so\n-// that the type system is not broken.\n-extern \"C\" void *\n-__cxa_bad_cast ()\n-{\n-#ifdef __EXCEPTIONS  \n-  throw std::bad_cast();\n-#else\n-  std::abort();\n-#endif\n-  return 0;\n-}\n-\n-extern \"C\" std::type_info const &\n-__cxa_bad_typeid ()\n-{\n-#ifdef __EXCEPTIONS  \n-  throw std::bad_typeid();\n-#else\n-  std::abort();\n-#endif\n-  return typeid (void);\n-}\n-\n-/* Has the current exception been caught?  */\n-bool\n-std::uncaught_exception() throw()\n-{\n-  cp_eh_info *p = CP_EH_INFO;\n-  return p && ! p->caught;\n-}\n-\n-std::exception::~exception() throw() { }\n-\n-std::bad_exception::~bad_exception() throw() { }\n-\n-const char* \n-std::exception::what() const throw()\n-{ return typeid (*this).name (); }\n-\n-\n-\n-"}, {"sha": "cc781192ddba19584ce8eb2bf6d9dec5f6052a0d", "filename": "libstdc++-v3/libsupc++/exception_support.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1c98ea459813570b4588427030daa03958fda6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1c98ea459813570b4588427030daa03958fda6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_support.h?ref=ce1c98ea459813570b4588427030daa03958fda6", "patch": "@@ -1,65 +0,0 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n-// \n-// GNU CC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// GNU CC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GNU CC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 59 Temple Place - Suite 330,\n-// Boston, MA 02111-1307, USA. \n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include \"gansidecl.h\" /* Needed to support macros used in eh-common.h. */\n-#include \"eh-common.h\"\n-\n-/* The type of a function called to clean up an exception object.\n-   (These will be destructors.)  Under the old ABI, these take a\n-   second argument (the `in-charge' argument), that indicates whether\n-   or not do delete the object, and whether or not to destroy virtual\n-   bases.  Under the new ABI, there is no second argument.  */\n-#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n-typedef void (*cleanup_fn)(void *, int);\n-/* The `2' is the value for the in-charge parameter that indicates\n-   that virtual bases should be destroyed.  */\n-#define CALL_CLEANUP(FN, THIS) FN (THIS, 2)\n-#else\n-typedef void (*cleanup_fn)(void *);\n-#define CALL_CLEANUP(FN, THIS) FN (THIS)\n-#endif\n-\n-/* C++-specific state about the current exception.  This must match\n-   init_exception_processing().\n-\n-   Note that handlers and caught are not redundant; when rethrown, an\n-   exception can have multiple active handlers and still be considered\n-   uncaught.  */\n-\n-struct cp_eh_info\n-{\n-  __eh_info eh_info;\n-  void *value;\n-  void *type;\n-  cleanup_fn cleanup;\n-  bool caught;\n-  cp_eh_info *next;\n-  long handlers;\n-  void *original_value;\n-};\n-\n-extern \"C\" cp_eh_info *__uncatch_exception (void);\n-extern \"C\" void __recatch_exception (cp_eh_info *);"}, {"sha": "5f9b3c868ccb91c56d57c0e0bb3ad3310ebcc99e", "filename": "libstdc++-v3/libsupc++/pure.cc", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpure.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpure.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpure.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -28,6 +28,7 @@\n // the GNU General Public License.\n \n #include <bits/c++config.h>\n+#include \"unwind-cxx.h\"\n \n #ifdef _GLIBCPP_HAVE_UNISTD_H\n # include <unistd.h>\n@@ -42,15 +43,9 @@\n # define writestr(str)\tfputs(str, stderr)\n #endif\n \n-extern \"C\" {\n-\n-extern void __terminate(void) __attribute__ ((__noreturn__));\n-\n-void\n+extern \"C\" void\n __cxa_pure_virtual (void)\n {\n   writestr (\"pure virtual method called\\n\");\n-  __terminate ();\n-}\n-\n+  std::terminate ();\n }"}, {"sha": "8f3d6319c3826c530cf7ca3fc360369cdca9fb68", "filename": "libstdc++-v3/libsupc++/tinfo2.cc", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -165,31 +165,3 @@ __pointer_catch (const __pbase_type_info *thr_type,\n }\n \n } // namespace std\n-\n-// Entry points for the compiler.\n-\n-/* Low level match routine used by compiler to match types of catch\n-   variables and thrown objects.  */\n-\n-extern \"C\" int\n-__throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n-\t\t\t void *objptr, void **valp)\n-{\n-  const type_info &catch_type = *(const type_info *)catch_type_r;\n-  const type_info &throw_type = *(const type_info *)throw_type_r;\n-\n-  *valp = objptr;\n-\n-  return catch_type.__do_catch (&throw_type, valp, 1);\n-}\n-\n-/* Called from __cp_pop_exception.  Is P the type_info node for a pointer\n-   of some kind?  */\n-\n-bool\n-__is_pointer (void *p)\n-{\n-  const type_info *t = reinterpret_cast <const type_info *>(p);\n-  return t->__is_pointer_p ();\n-}\n-"}, {"sha": "ce897b91f8c4c5a430bee1ade9d33c57d5961993", "filename": "libstdc++-v3/libsupc++/unwind-cxx.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -0,0 +1,163 @@\n+// -*- C++ -*- Exception handling and frame unwind runtime interface routines.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of GNU CC.\n+//\n+// GNU CC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// GNU CC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GNU CC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330,\n+// Boston, MA 02111-1307, USA.\n+\n+// This is derived from the C++ ABI for IA-64.  Where we diverge\n+// for cross-architecture compatibility are noted with \"@@@\".\n+\n+#ifndef __UNWIND_CXX_H\n+#define __UNWIND_CXX_H 1\n+\n+// Level 2: C++ ABI\n+\n+#include <typeinfo>\n+#include <exception>\n+#include <cstddef>\n+#include \"unwind.h\"\n+\n+namespace __cxxabiv1\n+{\n+\n+// A C++ exception object consists of a header, which is a wrapper around\n+// an unwind object header with additional C++ specific information,\n+// followed by the exception object itself.\n+\n+struct __cxa_exception\n+{ \n+  // Manage the exception object itself.\n+  std::type_info *exceptionType;\n+  void (*exceptionDestructor)(void *); \n+\n+  // The C++ standard has entertaining rules wrt calling set_terminate\n+  // and set_unexpected in the middle of the exception cleanup process.\n+  std::unexpected_handler unexpectedHandler;\n+  std::terminate_handler terminateHandler;\n+\n+  // The caught exception stack threads through here.\n+  __cxa_exception *nextException;\n+\n+  // How many nested handlers have caught this exception.  A negated\n+  // value is a signal that this object has been rethrown.\n+  int handlerCount;\n+\n+  // Cache parsed handler data from the personality routine Phase 1\n+  // for Phase 2 and __cxa_call_unexpected.\n+  int handlerSwitchValue;\n+  const unsigned char *actionRecord;\n+  const unsigned char *languageSpecificData;\n+  void *catchTemp;\n+  void *adjustedPtr;\n+\n+  // The generic exception header.  Must be last.\n+  _Unwind_Exception unwindHeader;\n+};\n+\n+// Each thread in a C++ program has access to a __cxa_eh_globals object.\n+struct __cxa_eh_globals\n+{\n+  __cxa_exception *caughtExceptions;\n+  unsigned int uncaughtExceptions;\n+};\n+\n+\n+// The __cxa_eh_globals for the current thread can be obtained by using\n+// either of the following functions.  The \"fast\" version assumes at least\n+// one prior call of __cxa_get_globals has been made from the current\n+// thread, so no initialization is necessary.\n+extern \"C\" __cxa_eh_globals *__cxa_get_globals () throw();\n+extern \"C\" __cxa_eh_globals *__cxa_get_globals_fast () throw();\n+\n+// Allocate memory for the exception plus the thown object.\n+extern \"C\" void *__cxa_allocate_exception(std::size_t thrown_size) throw();\n+\n+// Free the space allocated for the exception.\n+extern \"C\" void __cxa_free_exception(void *thrown_exception) throw();\n+\n+// Throw the exception.\n+extern \"C\" void __cxa_throw (void *thrown_exception,\n+\t\t\t     std::type_info *tinfo,\n+\t\t\t     void (*dest) (void *))\n+     __attribute__((noreturn));\n+\n+// Used to implement exception handlers.\n+extern \"C\" void *__cxa_begin_catch (_Unwind_Exception *) throw();\n+extern \"C\" void __cxa_end_catch ();\n+extern \"C\" void __cxa_rethrow () __attribute__((noreturn));\n+\n+// These facilitate code generation for recurring situations.\n+extern \"C\" void __cxa_bad_cast ();\n+extern \"C\" void __cxa_bad_typeid ();\n+\n+// @@@ These are not directly specified by the IA-64 C++ ABI.\n+\n+// Handles re-checking the exception specification if unexpectedHandler\n+// throws, and if bad_exception needs to be thrown.  Called from the\n+// compiler.\n+extern \"C\" void __cxa_call_unexpected (_Unwind_Exception *)\n+     __attribute__((noreturn));\n+\n+// Invokes given handler, dying appropriately if the user handler was\n+// so inconsiderate as to return.\n+extern void __terminate(std::terminate_handler) __attribute__((noreturn));\n+extern void __unexpected(std::unexpected_handler) __attribute__((noreturn));\n+\n+// The current installed user handlers.\n+extern std::terminate_handler __terminate_handler;\n+extern std::unexpected_handler __unexpected_handler;\n+\n+// These are explicitly GNU C++ specific.\n+\n+// This is the exception class we report -- \"GNUCC++\\0\".\n+const _Unwind_Exception_Class __gxx_exception_class\n+= ((((((((_Unwind_Exception_Class) 'G' \n+\t << 8 | (_Unwind_Exception_Class) 'N')\n+\t<< 8 | (_Unwind_Exception_Class) 'U')\n+       << 8 | (_Unwind_Exception_Class) 'C')\n+      << 8 | (_Unwind_Exception_Class) 'C')\n+     << 8 | (_Unwind_Exception_Class) '+')\n+    << 8 | (_Unwind_Exception_Class) '+')\n+   << 8 | (_Unwind_Exception_Class) '\\0');\n+\n+// GNU C++ personality routine, Version 0.\n+extern \"C\" _Unwind_Reason_Code __gxx_personality_v0\n+     (int, _Unwind_Action, _Unwind_Exception_Class,\n+      struct _Unwind_Exception *, struct _Unwind_Context *);\n+\n+// GNU C++ sjlj personality routine, Version 0.\n+extern \"C\" _Unwind_Reason_Code __gxx_personality_sj0\n+     (int, _Unwind_Action, _Unwind_Exception_Class,\n+      struct _Unwind_Exception *, struct _Unwind_Context *);\n+\n+// Acquire the C++ exception header from the C++ object.\n+static inline __cxa_exception *\n+__get_exception_header_from_obj (void *ptr)\n+{\n+  return reinterpret_cast<__cxa_exception *>(ptr) - 1;\n+}\n+\n+// Acquire the C++ exception header from the generic exception header.\n+static inline __cxa_exception *\n+__get_exception_header_from_ue (_Unwind_Exception *exc)\n+{\n+  return reinterpret_cast<__cxa_exception *>(exc + 1) - 1;\n+}\n+\n+} /* namespace __cxxabiv1 */\n+\n+#endif // __UNWIND_CXX_H"}, {"sha": "5bd8ec8a47b35d4ceda632b12746725aa3b10ab2", "filename": "libstdc++-v3/libsupc++/vec.cc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -35,19 +35,29 @@\n #include <exception>\n #include <exception_defines.h>\n \n-#include \"exception_support.h\"\n+#include \"unwind-cxx.h\"\n \n namespace __cxxabiv1\n {\n   namespace \n   {\n     struct uncatch_exception \n     {\n-      uncatch_exception () { p = __uncatch_exception (); }\n-      ~uncatch_exception () { __recatch_exception (p); }\n+      uncatch_exception ();\n+      ~uncatch_exception () { __cxa_begin_catch (&p->unwindHeader); }\n       \n-      cp_eh_info *p;\n+      __cxa_exception *p;\n     };\n+\n+    uncatch_exception::uncatch_exception ()\n+    {\n+      __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n+\n+      p = globals->caughtExceptions;\n+      p->handlerCount -= 1;\n+      globals->caughtExceptions = p->nextException;\n+      globals->uncaughtExceptions += 1;\n+    }\n   }\n \n   // Allocate and construct array."}, {"sha": "7d2619e38279730b37615daaede2d5ddaab99405", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 28, "deletions": 126, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a11cbfcf0cfb32628b6953588b6af4037ac0b6/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=52a11cbfcf0cfb32628b6953588b6af4037ac0b6", "patch": "@@ -120,13 +120,11 @@ OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n # These bits are all figured out from configure. Look in acinclude.m4\n # or configure.in to see how they are set. See GLIBCPP_EXPORT_FLAGS\n # NB: DEBUGFLAGS have to be at the end so that -O2 can be overridden.\n-CONFIG_CXXFLAGS = \\\n-\t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n+CONFIG_CXXFLAGS =  \t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n \n \n # Warning flags to use.\n-WARN_CXXFLAGS = \\\n-\t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n+WARN_CXXFLAGS =  \t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n \n \n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n@@ -138,133 +136,44 @@ LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n LIBIO_INCLUDES = @LIBIO_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n-INCLUDES = \\\n-\t-nostdinc++ \\\n-\t-I$(GLIBCPP_INCLUDE_DIR) $(CSTD_INCLUDES) -I$(top_builddir)/include \\\n-\t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \\\n-\t$(TOPLEVEL_INCLUDES)\n-\n-\n-base_headers = \\\n-\tbits/cpp_type_traits.h bits/char_traits.h bits/codecvt.h \\\n-\tbits/stringfwd.h bits/std_string.h bits/basic_string.h \\\n-\tbits/basic_string.tcc \\\n-\tbits/generic_shadow.h bits/std_utility.h \\\n-\tbits/std_complex.h \\\n-\tbits/valarray_array.h bits/valarray_array.tcc bits/valarray_meta.h \\\n-\tbits/std_valarray.h bits/mask_array.h bits/slice.h bits/slice_array.h \\\n-\tbits/gslice.h bits/gslice_array.h bits/indirect_array.h \\\n-\tbits/std_fstream.h bits/std_iomanip.h \\\n-\tbits/ios_base.h bits/fpos.h bits/basic_ios.h bits/basic_ios.tcc \\\n-\tbits/std_ios.h bits/std_iosfwd.h bits/std_iostream.h \\\n-\tbits/std_istream.h bits/istream.tcc bits/std_locale.h \\\n-\tbits/fstream.tcc bits/ostream.tcc bits/sbuf_iter.h bits/sstream.tcc \\\n-\tbits/std_ostream.h bits/std_sstream.h bits/std_streambuf.h \\\n-\tbits/streambuf.tcc bits/basic_file.h \\\n-\tbits/locale_facets.h bits/locale_facets.tcc bits/localefwd.h \\\n-\tbits/stl_pthread_alloc.h bits/pthread_allocimpl.h \\\n-\tbits/stl_threads.h bits/stl_iterator_base.h \\\n-\tbits/std_bitset.h bits/std_deque.h bits/std_functional.h \\\n-\tbits/std_iterator.h bits/std_list.h \\\n-\tbits/std_map.h bits/std_memory.h bits/std_numeric.h \\\n-\tbits/std_queue.h bits/std_set.h bits/std_stack.h \\\n-\tbits/std_stdexcept.h bits/functexcept.h bits/std_vector.h \\\n-\tbits/stl_algo.h bits/stl_algobase.h bits/stl_alloc.h \\\n-\tbits/stl_deque.h bits/stl_function.h \\\n-\tbits/stl_heap.h bits/stl_iterator.h bits/stl_list.h bits/stl_map.h \\\n-\tbits/stl_multimap.h bits/stl_multiset.h bits/stl_numeric.h \\\n-\tbits/stl_pair.h bits/stl_queue.h bits/stl_raw_storage_iter.h \\\n-\tbits/stl_relops.h bits/stl_set.h \\\n-\tbits/stl_stack.h bits/stl_tempbuf.h \\\n-\tbits/stl_tree.h bits/stl_uninitialized.h bits/stl_vector.h \\\n-\tbits/type_traits.h bits/std_algorithm.h \\\n-\tbits/concept_checks.h bits/container_concepts.h \\\n-\tbits/sequence_concepts.h bits/stl_construct.h\n-\n-\n-backward_headers = \\\n-\tbackward/complex.h backward/iomanip.h backward/istream.h \\\n-\tbackward/ostream.h backward/stream.h backward/streambuf.h \\\n-\tbackward/algo.h backward/algobase.h backward/alloc.h \\\n-\tbackward/bvector.h backward/defalloc.h backward/deque.h \\\n-\tbackward/function.h backward/hash_map.h backward/hash_set.h \\\n-\tbackward/hashtable.h backward/heap.h backward/iterator.h \\\n-\tbackward/list.h backward/map.h backward/multimap.h backward/new.h \\\n-\tbackward/multiset.h backward/pair.h backward/iostream.h \\\n-\tbackward/rope.h backward/set.h backward/slist.h backward/stack.h \\\n-\tbackward/tempbuf.h backward/tree.h backward/vector.h \\\n-\tbackward/fstream.h backward/strstream.h backward/strstream\n-\n-\n-ext_headers = \\\n-\text/ropeimpl.h ext/stl_rope.h \\\n-\text/stl_bvector.h ext/stl_hashtable.h ext/stl_hash_fun.h \\\n-\text/hash_map ext/hash_set ext/rope ext/slist \\\n-\text/tree ext/bvector \n-\n-\n-c_base_headers = \\\n-\tbits/std_cassert.h bits/std_cctype.h bits/std_cerrno.h \\\n-\tbits/std_cfloat.h bits/std_climits.h bits/std_clocale.h \\\n-\tbits/std_cmath.h bits/std_csetjmp.h bits/std_csignal.h \\\n-\tbits/std_cstdarg.h bits/std_cstddef.h bits/std_cstdio.h \\\n-\tbits/std_cstdlib.h bits/std_cstring.h bits/std_ctime.h \\\n-\tbits/std_cwchar.h bits/std_cwctype.h bits/cmath.tcc\n-\n-@GLIBCPP_USE_CSHADOW_TRUE@c_shadow_headers = @GLIBCPP_USE_CSHADOW_TRUE@\\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tassert.h ctype.h errno.h float.h limits.h locale.h math.h setjmp.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tsignal.h stdarg.h stddef.h stdio.h stdlib.h string.h time.h wchar.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\twctype.h fcntl.h libio.h iolibio.h libioP.h pthread.h iconv.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tfeatures.h langinfo.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tbits/wrap_libio.h bits/wrap_iolibio.h bits/wrap_libioP.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tbits/wrap_iconv.h bits/wrap_fcntl.h bits/wrap_pthread.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tbits/wrap_features.h bits/wrap_langinfo.h \\\n-@GLIBCPP_USE_CSHADOW_TRUE@\tsys/cdefs.h \n+INCLUDES =  \t-nostdinc++ \t-I$(GLIBCPP_INCLUDE_DIR) $(CSTD_INCLUDES) -I$(top_builddir)/include \t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \t$(TOPLEVEL_INCLUDES)\n+\n+\n+base_headers =  \tbits/cpp_type_traits.h bits/char_traits.h bits/codecvt.h \tbits/stringfwd.h bits/std_string.h bits/basic_string.h \tbits/basic_string.tcc \tbits/generic_shadow.h bits/std_utility.h \tbits/std_complex.h \tbits/valarray_array.h bits/valarray_array.tcc bits/valarray_meta.h \tbits/std_valarray.h bits/mask_array.h bits/slice.h bits/slice_array.h \tbits/gslice.h bits/gslice_array.h bits/indirect_array.h \tbits/std_fstream.h bits/std_iomanip.h \tbits/ios_base.h bits/fpos.h bits/basic_ios.h bits/basic_ios.tcc \tbits/std_ios.h bits/std_iosfwd.h bits/std_iostream.h \tbits/std_istream.h bits/istream.tcc bits/std_locale.h \tbits/fstream.tcc bits/ostream.tcc bits/sbuf_iter.h bits/sstream.tcc \tbits/std_ostream.h bits/std_sstream.h bits/std_streambuf.h \tbits/streambuf.tcc bits/basic_file.h \tbits/locale_facets.h bits/locale_facets.tcc bits/localefwd.h \tbits/stl_pthread_alloc.h bits/pthread_allocimpl.h \tbits/stl_threads.h bits/stl_iterator_base.h \tbits/std_bitset.h bits/std_deque.h bits/std_functional.h \tbits/std_iterator.h bits/std_list.h \tbits/std_map.h bits/std_memory.h bits/std_numeric.h \tbits/std_queue.h bits/std_set.h bits/std_stack.h \tbits/std_stdexcept.h bits/functexcept.h bits/std_vector.h \tbits/stl_algo.h bits/stl_algobase.h bits/stl_alloc.h \tbits/stl_deque.h bits/stl_function.h \tbits/stl_heap.h bits/stl_iterator.h bits/stl_list.h bits/stl_map.h \tbits/stl_multimap.h bits/stl_multiset.h bits/stl_numeric.h \tbits/stl_pair.h bits/stl_queue.h bits/stl_raw_storage_iter.h \tbits/stl_relops.h bits/stl_set.h \tbits/stl_stack.h bits/stl_tempbuf.h \tbits/stl_tree.h bits/stl_uninitialized.h bits/stl_vector.h \tbits/type_traits.h bits/std_algorithm.h \tbits/concept_checks.h bits/container_concepts.h \tbits/sequence_concepts.h bits/stl_construct.h\n+\n+\n+backward_headers =  \tbackward/complex.h backward/iomanip.h backward/istream.h \tbackward/ostream.h backward/stream.h backward/streambuf.h \tbackward/algo.h backward/algobase.h backward/alloc.h \tbackward/bvector.h backward/defalloc.h backward/deque.h \tbackward/function.h backward/hash_map.h backward/hash_set.h \tbackward/hashtable.h backward/heap.h backward/iterator.h \tbackward/list.h backward/map.h backward/multimap.h backward/new.h \tbackward/multiset.h backward/pair.h backward/iostream.h \tbackward/rope.h backward/set.h backward/slist.h backward/stack.h \tbackward/tempbuf.h backward/tree.h backward/vector.h \tbackward/fstream.h backward/strstream.h backward/strstream\n+\n+\n+ext_headers =  \text/ropeimpl.h ext/stl_rope.h \text/stl_bvector.h ext/stl_hashtable.h ext/stl_hash_fun.h \text/hash_map ext/hash_set ext/rope ext/slist \text/tree ext/bvector \n+\n+\n+c_base_headers =  \tbits/std_cassert.h bits/std_cctype.h bits/std_cerrno.h \tbits/std_cfloat.h bits/std_climits.h bits/std_clocale.h \tbits/std_cmath.h bits/std_csetjmp.h bits/std_csignal.h \tbits/std_cstdarg.h bits/std_cstddef.h bits/std_cstdio.h \tbits/std_cstdlib.h bits/std_cstring.h bits/std_ctime.h \tbits/std_cwchar.h bits/std_cwctype.h bits/cmath.tcc\n+\n+@GLIBCPP_USE_CSHADOW_TRUE@c_shadow_headers = \tassert.h ctype.h errno.h float.h limits.h locale.h math.h setjmp.h \tsignal.h stdarg.h stddef.h stdio.h stdlib.h string.h time.h wchar.h \twctype.h fcntl.h libio.h iolibio.h libioP.h pthread.h iconv.h \tfeatures.h langinfo.h \tbits/wrap_libio.h bits/wrap_iolibio.h bits/wrap_libioP.h \tbits/wrap_iconv.h bits/wrap_fcntl.h bits/wrap_pthread.h \tbits/wrap_features.h bits/wrap_langinfo.h \tsys/cdefs.h \n @GLIBCPP_USE_CSHADOW_FALSE@c_shadow_headers = \n \n-std_headers = \\\n-\talgorithm bitset complex deque fstream functional \\\n-\tiomanip ios iosfwd iostream istream iterator limits list locale \\\n-\tmap memory numeric ostream queue set sstream stack stdexcept \\\n-\tstreambuf string utility valarray vector \\\n-\tcassert cctype cerrno cfloat climits clocale ciso646 \\\n-\tcmath csetjmp csignal cstdarg cstddef cstdio cstdlib \\\n-\tcstring ctime cwchar cwctype\n-\n-@GLIBCPP_NEED_LIBIO_TRUE@libio_headers = @GLIBCPP_NEED_LIBIO_TRUE@\\\n-@GLIBCPP_NEED_LIBIO_TRUE@\t$(top_srcdir)/libio/_G_config.h $(top_srcdir)/libio/libio.h\n+std_headers =  \talgorithm bitset complex deque fstream functional \tiomanip ios iosfwd iostream istream iterator limits list locale \tmap memory numeric ostream queue set sstream stack stdexcept \tstreambuf string utility valarray vector \tcassert cctype cerrno cfloat climits clocale ciso646 \tcmath csetjmp csignal cstdarg cstddef cstdio cstdlib \tcstring ctime cwchar cwctype\n+\n+@GLIBCPP_NEED_LIBIO_TRUE@libio_headers = \t$(top_srcdir)/libio/_G_config.h $(top_srcdir)/libio/libio.h\n @GLIBCPP_NEED_LIBIO_FALSE@libio_headers = \n \n-build_headers = \\\n-\tbits/std_limits.h \\\n-\tbits/c++config.h bits/c++io.h bits/c++locale.h bits/c++threads.h \\\n-\tbits/basic_file_model.h \\\n-\tbits/atomicity.h bits/os_defines.h \\\n-\tbits/ctype_base.h bits/ctype_noninline.h bits/ctype_inline.h \n+build_headers =  \tbits/std_limits.h \tbits/c++config.h bits/c++io.h bits/c++locale.h bits/c++threads.h \tbits/basic_file_model.h \tbits/atomicity.h bits/os_defines.h \tbits/ctype_base.h bits/ctype_noninline.h bits/ctype_inline.h \n \n \n-sources = \\\n-\tlimitsMEMBERS.cc \\\n-\tstdexcept.cc functexcept.cc bitset.cc \\\n-\tglobals.cc \\\n-\tbasic_file.cc ios.cc complex_io.cc strstream.cc \\\n-\tc++locale.cc locale.cc localename.cc codecvt.cc \\\n-\tlocale-inst.cc stl-inst.cc misc-inst.cc valarray-inst.cc \\\n-\tstring-inst.cc wstring-inst.cc \n+sources =  \tlimitsMEMBERS.cc \tstdexcept.cc functexcept.cc bitset.cc \tglobals.cc \tbasic_file.cc ios.cc complex_io.cc strstream.cc \tc++locale.cc locale.cc localename.cc codecvt.cc \tlocale-inst.cc stl-inst.cc misc-inst.cc valarray-inst.cc \tstring-inst.cc wstring-inst.cc \n \n VPATH =  $(top_srcdir) $(top_srcdir)/src $(GLIBCPP_INCLUDE_DIR)  $(GLIBCPP_INCLUDE_DIR)/std $(C_INCLUDE_DIR)\n \n libstdc___la_SOURCES = $(sources)\n \n-libstdc___la_LIBADD = \\\n-\t../libmath/libmath.la @libio_la@ \\\n-\t../libsupc++/libsupc++convenience.la\n+libstdc___la_LIBADD =  \t../libmath/libmath.la @libio_la@ \t../libsupc++/libsupc++convenience.la\n \n \n libstdc___la_LDFLAGS = -version-info 3:0:0 -lm\n \n libstdc___la_DEPENDENCIES = $(libstdc___la_LIBADD)\n-@GLIBCPP_USE_CSHADOW_TRUE@CSHADOW_H = @GLIBCPP_USE_CSHADOW_TRUE@$(top_builddir)/stamp-cshadow\n+@GLIBCPP_USE_CSHADOW_TRUE@CSHADOW_H = $(top_builddir)/stamp-cshadow\n @GLIBCPP_USE_CSHADOW_FALSE@CSHADOW_H = \n \n # Check for various configure bits that change where the headers get installed.\n@@ -283,12 +192,7 @@ c_incdir = @C_INCLUDE_DIR@\n # set this option because CONFIG_CXXFLAGS has to be after\n # OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n # as the occasion call for it. (ie, --enable-debug)\n-AM_CXXFLAGS = \\\n-\t-fno-implicit-templates \\\n-\t$(LIBSUPCXX_CXXFLAGS) \\\n-\t$(WARN_CXXFLAGS) \\\n-\t$(OPTIMIZE_CXXFLAGS) \\\n-\t$(CONFIG_CXXFLAGS) \n+AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS) \t$(OPTIMIZE_CXXFLAGS) \t$(CONFIG_CXXFLAGS) \n \n \n # libstdc++ libtool notes\n@@ -309,8 +213,7 @@ AM_CXXFLAGS = \\\n # correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n # CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n # attempt to infer which configuration to use\n-LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \\\n-\t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n+LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n \n \n # 3) We'd have a problem when building the shared libstdc++ object if\n@@ -319,8 +222,7 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \\\n # course is problematic at this point.  So, we get the top-level\n # directory to configure libstdc++-v3 to use gcc as the C++\n # compilation driver.\n-CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \\\n-\t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = \n@@ -475,7 +377,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}]}