{"sha": "2e721daadf386fce372229a407784ec21cf80e8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU3MjFkYWFkZjM4NmZjZTM3MjIyOWE0MDc3ODRlYzIxY2Y4MGU4YQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@cavium.com", "date": "2016-10-22T03:40:06Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2016-10-22T03:40:06Z"}, "message": "aarch64-cores.def: Rewrite so IMP and PART are integer constants.\n\n2016-10-21  Andrew Pinski  <apinski@cavium.com>\n\n        * config/aarch64/aarch64-cores.def: Rewrite so IMP and PART are\n        integer constants.\n        * config/aarch64/driver-aarch64.c (struct aarch64_core_data): Change\n        implementer_id to unsigned char.\n        Change part_no to unsigned int.\n        (AARCH64_BIG_LITTLE): New define.\n        (INVALID_IMP): New define.\n        (INVALID_CORE): New define.\n        (cpu_data): Change the last element's implementer_id and part_no to\n        integers.\n        (valid_bL_string_p): Rewrite to ..\n        (valid_bL_core_p): this for integers instead of strings.\n        (parse_field): New function.\n        (contains_string_p): Rewrite to ...\n        (contains_core_p): this for integers and only for the part_no.\n        (host_detect_local_cpu): Rewrite handling of implementation and\n        par num to be integers; simplifying the code.\n\nFrom-SVN: r241437", "tree": {"sha": "35b06b312f814df36b0cb218e18207eed589fbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35b06b312f814df36b0cb218e18207eed589fbfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e721daadf386fce372229a407784ec21cf80e8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e721daadf386fce372229a407784ec21cf80e8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e721daadf386fce372229a407784ec21cf80e8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e721daadf386fce372229a407784ec21cf80e8a/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1454b8c6023095f9fc1d8dfe91d99b0f21e41b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1454b8c6023095f9fc1d8dfe91d99b0f21e41b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1454b8c6023095f9fc1d8dfe91d99b0f21e41b4"}], "stats": {"total": 160, "additions": 95, "deletions": 65}, "files": [{"sha": "2849ce84e691e55b26d4ba51ccdfa2c9932cf832", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e721daadf386fce372229a407784ec21cf80e8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e721daadf386fce372229a407784ec21cf80e8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e721daadf386fce372229a407784ec21cf80e8a", "patch": "@@ -1,3 +1,23 @@\n+2016-10-21  Andrew Pinski  <apinski@cavium.com>\n+\n+\t* config/aarch64/aarch64-cores.def: Rewrite so IMP and PART are\n+\tinteger constants.\n+\t* config/aarch64/driver-aarch64.c (struct aarch64_core_data): Change\n+\timplementer_id to unsigned char.\n+\tChange part_no to unsigned int.\n+\t(AARCH64_BIG_LITTLE): New define.\n+\t(INVALID_IMP): New define.\n+\t(INVALID_CORE): New define.\n+\t(cpu_data): Change the last element's implementer_id and part_no to\n+\tintegers.\n+\t(valid_bL_string_p): Rewrite to ..\n+\t(valid_bL_core_p): this for integers instead of strings.\n+\t(parse_field): New function.\n+\t(contains_string_p): Rewrite to ...\n+\t(contains_core_p): this for integers and only for the part_no.\n+\t(host_detect_local_cpu): Rewrite handling of implementation and\n+\tpar num to be integers; simplifying the code.\n+\n 2016-10-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Create nonzero"}, {"sha": "f9b75524fcf87d39ce2f3b77837ba47e458a4239", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e721daadf386fce372229a407784ec21cf80e8a/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e721daadf386fce372229a407784ec21cf80e8a/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=2e721daadf386fce372229a407784ec21cf80e8a", "patch": "@@ -32,43 +32,46 @@\n    FLAGS are the bitwise-or of the traits that apply to that core.\n    This need not include flags implied by the architecture.\n    COSTS is the name of the rtx_costs routine to use.\n-   IMP is the implementer ID of the CPU vendor.  On a GNU/Linux system it can\n-   be found in /proc/cpuinfo.\n-   PART is the part number of the CPU.  On a GNU/Linux system it can be found\n-   in /proc/cpuinfo.  For big.LITTLE systems this should have the form at of\n-   \"<big core part number>.<LITTLE core part number>\".  */\n+   IMP is the implementer ID of the CPU vendor.  On a GNU/Linux system it\n+   can be found in /proc/cpuinfo. A partial list of implementer IDs is\n+   given in the ARM Architecture Reference Manual ARMv8, for\n+   ARMv8-A architecture profile.\n+   PART is the part number of the CPU.  On a GNU/Linux system it can be\n+   found in /proc/cpuinfo.  For big.LITTLE systems this should use the\n+   macro AARCH64_BIG_LITTLE where the big part number comes as the first\n+   argument to the macro and little is the second.  */\n \n /* V8 Architecture Processors.  */\n \n /* ARM ('A') cores. */\n-AARCH64_CORE(\"cortex-a35\",  cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa35, \"0x41\", \"0xd04\")\n-AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, \"0x41\", \"0xd03\")\n-AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07\")\n-AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, \"0x41\", \"0xd08\")\n-AARCH64_CORE(\"cortex-a73\",  cortexa73, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, \"0x41\", \"0xd09\")\n+AARCH64_CORE(\"cortex-a35\",  cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa35, 0x41, 0xd04)\n+AARCH64_CORE(\"cortex-a53\",  cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa53, 0x41, 0xd03)\n+AARCH64_CORE(\"cortex-a57\",  cortexa57, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, 0x41, 0xd07)\n+AARCH64_CORE(\"cortex-a72\",  cortexa72, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, 0x41, 0xd08)\n+AARCH64_CORE(\"cortex-a73\",  cortexa73, cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, 0x41, 0xd09)\n \n /* Samsung ('S') cores. */\n-AARCH64_CORE(\"exynos-m1\",   exynosm1,  exynosm1,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, exynosm1,  \"0x53\", \"0x001\")\n+AARCH64_CORE(\"exynos-m1\",   exynosm1,  exynosm1,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, exynosm1,  0x53, 0x001)\n \n /* Qualcomm ('Q') cores. */\n-AARCH64_CORE(\"qdf24xx\",     qdf24xx,   cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, qdf24xx,   \"0x51\", \"0x800\")\n+AARCH64_CORE(\"qdf24xx\",     qdf24xx,   cortexa57, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, qdf24xx,   0x51, 0x800)\n \n /* Cavium ('C') cores. */\n-AARCH64_CORE(\"thunderx\",    thunderx,  thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  \"0x43\", \"0x0a1\")\n+AARCH64_CORE(\"thunderx\",    thunderx,  thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a1)\n \n /* APM ('P') cores. */\n-AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8A,  AARCH64_FL_FOR_ARCH8, xgene1, \"0x50\", \"0x000\")\n+AARCH64_CORE(\"xgene1\",      xgene1,    xgene1,    8A,  AARCH64_FL_FOR_ARCH8, xgene1, 0x50, 0x000)\n \n /* V8.1 Architecture Processors.  */\n \n /* Broadcom ('B') cores. */\n-AARCH64_CORE(\"vulcan\",  vulcan, cortexa57, 8_1A,  AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_CRYPTO, vulcan, \"0x42\", \"0x516\")\n+AARCH64_CORE(\"vulcan\",  vulcan, cortexa57, 8_1A,  AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_CRYPTO, vulcan, 0x42, 0x516)\n \n /* V8 big.LITTLE implementations.  */\n \n-AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, \"0x41\", \"0xd07.0xd03\")\n-AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, \"0x41\", \"0xd08.0xd03\")\n-AARCH64_CORE(\"cortex-a73.cortex-a35\",  cortexa73cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, \"0x41\", \"0xd09.0xd04\")\n-AARCH64_CORE(\"cortex-a73.cortex-a53\",  cortexa73cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, \"0x41\", \"0xd09.0xd03\")\n+AARCH64_CORE(\"cortex-a57.cortex-a53\",  cortexa57cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa57, 0x41, AARCH64_BIG_LITTLE (0xd07, 0xd03))\n+AARCH64_CORE(\"cortex-a72.cortex-a53\",  cortexa72cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa72, 0x41, AARCH64_BIG_LITTLE (0xd08, 0xd03))\n+AARCH64_CORE(\"cortex-a73.cortex-a35\",  cortexa73cortexa35, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd09, 0xd04))\n+AARCH64_CORE(\"cortex-a73.cortex-a53\",  cortexa73cortexa53, cortexa53, 8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC, cortexa73, 0x41, AARCH64_BIG_LITTLE (0xd09, 0xd03))\n \n #undef AARCH64_CORE"}, {"sha": "658a4cd72e99d7d961daef8afbe553ba46b040c9", "filename": "gcc/config/aarch64/driver-aarch64.c", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e721daadf386fce372229a407784ec21cf80e8a/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e721daadf386fce372229a407784ec21cf80e8a/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fdriver-aarch64.c?ref=2e721daadf386fce372229a407784ec21cf80e8a", "patch": "@@ -46,18 +46,23 @@ struct aarch64_core_data\n {\n   const char* name;\n   const char* arch;\n-  const char* implementer_id;\n-  const char* part_no;\n+  unsigned char implementer_id; /* Exactly 8 bits */\n+  unsigned int part_no; /* 12 bits + 12 bits */\n   const unsigned long flags;\n };\n \n+#define AARCH64_BIG_LITTLE(BIG, LITTLE) \\\n+  (((BIG)&0xFFFu) << 12 | ((LITTLE) & 0xFFFu))\n+#define INVALID_IMP ((unsigned char) -1)\n+#define INVALID_CORE ((unsigned)-1)\n+\n #define AARCH64_CORE(CORE_NAME, CORE_IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART) \\\n   { CORE_NAME, #ARCH, IMP, PART, FLAGS },\n \n static struct aarch64_core_data aarch64_cpu_data[] =\n {\n #include \"aarch64-cores.def\"\n-  { NULL, NULL, NULL, NULL, 0 }\n+  { NULL, NULL, INVALID_IMP, INVALID_CORE, 0 }\n };\n \n \n@@ -95,32 +100,42 @@ get_arch_from_id (const char* id)\n   return NULL;\n }\n \n-/* Check wether the string CORE contains the same CPU part numbers\n-   as BL_STRING.  For example CORE=\"{0xd03, 0xd07}\" and BL_STRING=\"0xd07.0xd03\"\n-   should return true.  */\n+/* Check wether the CORE array is the same as the big.LITTLE BL_CORE.\n+   For an example CORE={0xd08, 0xd03} and\n+   BL_CORE=AARCH64_BIG_LITTLE (0xd08, 0xd03) will return true.  */\n \n static bool\n-valid_bL_string_p (const char** core, const char* bL_string)\n+valid_bL_core_p (unsigned int *core, unsigned int bL_core)\n+{\n+  return AARCH64_BIG_LITTLE (core[0], core[1]) == bL_core\n+         || AARCH64_BIG_LITTLE (core[1], core[0]) == bL_core;\n+}\n+\n+/* Returns the hex integer that is after ':' for the FIELD.\n+   Returns -1 is returned if there was problem parsing the integer. */\n+static unsigned\n+parse_field (const char *field)\n {\n-  return strstr (bL_string, core[0]) != NULL\n-    && strstr (bL_string, core[1]) != NULL;\n+  const char *rest = strchr (field, ':');\n+  char *after;\n+  unsigned fint = strtol (rest + 1, &after, 16);\n+  if (after == rest + 1)\n+    return -1;\n+  return fint;\n }\n \n-/*  Return true iff ARR contains STR in one of its two elements.  */\n+/*  Return true iff ARR contains CORE, in either of the two elements. */\n \n static bool\n-contains_string_p (const char** arr, const char* str)\n+contains_core_p (unsigned *arr, unsigned core)\n {\n-  bool res = false;\n-\n-  if (arr[0] != NULL)\n+  if (arr[0] != INVALID_CORE)\n     {\n-      res = strstr (arr[0], str) != NULL;\n-      if (res)\n-        return res;\n+      if (arr[0] == core)\n+        return true;\n \n-      if (arr[1] != NULL)\n-        return strstr (arr[1], str) != NULL;\n+      if (arr[1] != INVALID_CORE)\n+        return arr[1] == core;\n     }\n \n   return false;\n@@ -155,10 +170,9 @@ host_detect_local_cpu (int argc, const char **argv)\n   bool cpu = false;\n   unsigned int i = 0;\n   unsigned int core_idx = 0;\n-  const char* imps[2] = { NULL, NULL };\n-  const char* cores[2] = { NULL, NULL };\n+  unsigned char imp = INVALID_IMP;\n+  unsigned int cores[2] = { INVALID_CORE, INVALID_CORE };\n   unsigned int n_cores = 0;\n-  unsigned int n_imps = 0;\n   bool processed_exts = false;\n   const char *ext_string = \"\";\n   unsigned long extension_flags = 0;\n@@ -191,31 +205,28 @@ host_detect_local_cpu (int argc, const char **argv)\n     {\n       if (strstr (buf, \"implementer\") != NULL)\n \t{\n-\t  for (i = 0; aarch64_cpu_data[i].name != NULL; i++)\n-\t    if (strstr (buf, aarch64_cpu_data[i].implementer_id) != NULL\n-\t\t&& !contains_string_p (imps,\n-\t\t\t\t       aarch64_cpu_data[i].implementer_id))\n-\t      {\n-\t\tif (n_imps == 2)\n-\t\t  goto not_found;\n-\n-\t\timps[n_imps++] = aarch64_cpu_data[i].implementer_id;\n-\n-\t\tbreak;\n-\t      }\n-\t  continue;\n+\t  unsigned cimp = parse_field (buf);\n+\t  if (cimp == INVALID_IMP)\n+\t    goto not_found;\n+\n+\t  if (imp == INVALID_IMP)\n+\t    imp = cimp;\n+\t  /* FIXME: BIG.little implementers are always equal. */\n+\t  else if (imp != cimp)\n+\t    goto not_found;\n \t}\n \n       if (strstr (buf, \"part\") != NULL)\n \t{\n+\t  unsigned ccore = parse_field (buf);\n \t  for (i = 0; aarch64_cpu_data[i].name != NULL; i++)\n-\t    if (strstr (buf, aarch64_cpu_data[i].part_no) != NULL\n-\t\t&& !contains_string_p (cores, aarch64_cpu_data[i].part_no))\n+\t    if (ccore == aarch64_cpu_data[i].part_no\n+\t\t&& !contains_core_p (cores, ccore))\n \t      {\n \t\tif (n_cores == 2)\n \t\t  goto not_found;\n \n-\t\tcores[n_cores++] = aarch64_cpu_data[i].part_no;\n+\t\tcores[n_cores++] = ccore;\n \t\tcore_idx = i;\n \t\tarch_id = aarch64_cpu_data[i].arch;\n \t\tbreak;\n@@ -262,7 +273,7 @@ host_detect_local_cpu (int argc, const char **argv)\n   f = NULL;\n \n   /* Weird cpuinfo format that we don't know how to handle.  */\n-  if (n_cores == 0 || n_cores > 2 || n_imps != 1)\n+  if (n_cores == 0 || n_cores > 2 || imp == INVALID_IMP)\n     goto not_found;\n \n   if (arch && !arch_id)\n@@ -284,11 +295,8 @@ host_detect_local_cpu (int argc, const char **argv)\n     {\n       for (i = 0; aarch64_cpu_data[i].name != NULL; i++)\n \t{\n-\t  if (strchr (aarch64_cpu_data[i].part_no, '.') != NULL\n-\t      && strncmp (aarch64_cpu_data[i].implementer_id,\n-\t\t\t  imps[0],\n-\t\t\t  strlen (imps[0]) - 1) == 0\n-\t      && valid_bL_string_p (cores, aarch64_cpu_data[i].part_no))\n+\t  if (aarch64_cpu_data[i].implementer_id == imp\n+\t      && valid_bL_core_p (cores, aarch64_cpu_data[i].part_no))\n \t    {\n \t      res = concat (\"-m\",\n \t\t\t    cpu ? \"cpu\" : \"tune\", \"=\",\n@@ -304,8 +312,7 @@ host_detect_local_cpu (int argc, const char **argv)\n   /* The simple, non-big.LITTLE case.  */\n   else\n     {\n-      if (strncmp (aarch64_cpu_data[core_idx].implementer_id, imps[0],\n-\t\t   strlen (imps[0]) - 1) != 0)\n+      if (aarch64_cpu_data[core_idx].implementer_id != imp)\n \tgoto not_found;\n \n       res = concat (\"-m\", cpu ? \"cpu\" : \"tune\", \"=\","}]}