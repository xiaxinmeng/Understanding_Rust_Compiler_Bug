{"sha": "096ab9eaaf2daba6c9cc0bc29565565560f11941", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk2YWI5ZWFhZjJkYWJhNmM5Y2MwYmMyOTU2NTU2NTU2MGYxMTk0MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T10:49:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T10:49:07Z"}, "message": "Initial revision\n\nFrom-SVN: r14420", "tree": {"sha": "9425bd269c1b669db862794c5e4130530a4b2f9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9425bd269c1b669db862794c5e4130530a4b2f9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/096ab9eaaf2daba6c9cc0bc29565565560f11941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096ab9eaaf2daba6c9cc0bc29565565560f11941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096ab9eaaf2daba6c9cc0bc29565565560f11941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096ab9eaaf2daba6c9cc0bc29565565560f11941/comments", "author": null, "committer": null, "parents": [{"sha": "8b8b2c1c00699cedf94f14ae176aebda92aab1a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8b2c1c00699cedf94f14ae176aebda92aab1a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8b2c1c00699cedf94f14ae176aebda92aab1a7"}], "stats": {"total": 822, "additions": 822, "deletions": 0}, "files": [{"sha": "70845c06d1031e34f3cf93623e8cee6018ea844f", "filename": "gcc/bitmap.c", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096ab9eaaf2daba6c9cc0bc29565565560f11941/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096ab9eaaf2daba6c9cc0bc29565565560f11941/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=096ab9eaaf2daba6c9cc0bc29565565560f11941", "patch": "@@ -0,0 +1,583 @@\n+/* Functions to support general ended bitmaps.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"obstack.h\"\n+#include \"regs.h\"\n+#include \"basic-block.h\"\n+\n+/* The contents of the current function definition are allocated\n+   in this obstack, and all are freed at the end of the function.\n+   For top-level functions, this is temporary_obstack.\n+   Separate obstacks are made for nested functions.  */\n+\n+extern struct obstack *function_obstack;\n+\n+\f\n+#ifndef INLINE\n+#ifndef __GNUC__\n+#define INLINE\n+#else\n+#define INLINE __inline__\n+#endif\n+#endif\n+\n+/* Global data */\n+bitmap_element bitmap_zero;\t\t/* An element of all zero bits. */\n+bitmap_element *bitmap_free;\t\t/* Freelist of bitmap elements. */\n+\n+static void bitmap_element_free\t\tPROTO((bitmap, bitmap_element *));\n+static bitmap_element *bitmap_element_allocate PROTO((bitmap));\n+static int bitmap_element_zerop\t\tPROTO((bitmap_element *));\n+static void bitmap_element_link\t\tPROTO((bitmap, bitmap_element *));\n+static bitmap_element *bitmap_find_bit\tPROTO((bitmap, unsigned int));\n+\f\n+/* Free a bitmap element */\n+\n+static INLINE void\n+bitmap_element_free (head, elt)\n+     bitmap head;\n+     bitmap_element *elt;\n+{\n+  bitmap_element *next = elt->next;\n+  bitmap_element *prev = elt->prev;\n+\n+  if (prev)\n+    prev->next = next;\n+\n+  if (next)\n+    next->prev = prev;\n+\n+  if (head->first == elt)\n+    head->first = next;\n+\n+  /* Since the first thing we try is to insert before current,\n+     make current the next entry in preference to the previous.  */\n+  if (head->current == elt)\n+    head->current = next != 0 ? next : prev;\n+\n+  elt->next = bitmap_free;\n+  bitmap_free = elt;\n+}\n+\f\n+/* Allocate a bitmap element.  The bits are cleared, but nothing else is.  */\n+\n+static INLINE bitmap_element *\n+bitmap_element_allocate (head)\n+     bitmap head;\n+{\n+  bitmap_element *element;\n+  int i;\n+\n+  if (bitmap_free != 0)\n+    {\n+      element = bitmap_free;\n+      bitmap_free = element->next;\n+    }\n+  else\n+    element = (bitmap_element *) obstack_alloc (function_obstack,\n+\t\t\t\t\t\tsizeof (bitmap_element));\n+\n+#if BITMAP_ELEMENT_WORDS == 2\n+  element->bits[0] = element->bits[1] = 0;\n+#else\n+  for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n+    element->bits[i] = 0;\n+#endif\n+\n+  return element;\n+}\n+\n+/* Return nonzero if all bits in an element are zero.  */\n+\n+static INLINE int\n+bitmap_element_zerop (element)\n+     bitmap_element *element;\n+{\n+#if BITMAP_ELEMENT_WORDS == 2\n+  return (element->bits[0] | element->bits[1]) == 0;\n+#else\n+  int i;\n+\n+  for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n+    if (element->bits[i] != 0)\n+      return 0;\n+\n+  return 1;\n+#endif\n+}\n+\f\n+/* Link the bitmap element into the current bitmap linked list.  */\n+\n+static INLINE void\n+bitmap_element_link (head, element)\n+     bitmap head;\n+     bitmap_element *element;\n+{\n+  unsigned int indx = element->indx;\n+  bitmap_element *ptr;\n+\n+  /* If this is the first and only element, set it in.  */\n+  if (head->first == 0)\n+    {\n+      element->next = element->prev = 0;\n+      head->first = element;\n+    }\n+\n+  /* If this index is less than that of the current element, it goes someplace\n+     before the current element.  */\n+  else if (indx < head->indx)\n+    {\n+      for (ptr = head->current;\n+\t   ptr->prev != 0 && ptr->prev->indx > indx;\n+\t   ptr = ptr->prev)\n+\t;\n+\n+      if (ptr->prev)\n+\tptr->prev->next = element;\n+      else\n+\thead->first = element;\n+\n+      element->prev = ptr->prev;\n+      element->next = ptr;\n+      ptr->prev = element;\n+    }\n+\n+  /* Otherwise, it must go someplace after the current element.  */\n+  else\n+    {\n+      for (ptr = head->current;\n+\t   ptr->next != 0 && ptr->next->indx < indx;\n+\t   ptr = ptr->next)\n+\t;\n+\n+      if (ptr->next)\n+\tptr->next->prev = element;\n+\n+      element->next = ptr->next;\n+      element->prev = ptr;\n+      ptr->next = element;\n+    }\n+\n+  /* Set up so this is the first element searched.  */\n+  head->current = element;\n+  head->indx = indx;\n+}\n+\f\n+/* Clear a bitmap by freeing the linked list.  */\n+\n+void INLINE\n+bitmap_clear (head)\n+     bitmap head;\n+{\n+  bitmap_element *element, *next;\n+\n+  for (element = head->first; element != 0; element = next)\n+    {\n+      next = element->next;\n+      element->next = bitmap_free;\n+      bitmap_free = element;\n+    }\n+\n+  head->first = head->current =  0;\n+}\n+\f\n+/* Copy a bitmap to another bitmap */\n+\n+void\n+bitmap_copy (to, from)\n+     bitmap to;\n+     bitmap from;\n+{\n+  bitmap_element *from_ptr, *to_ptr = 0;\n+  int i;\n+\n+  bitmap_clear (to);\n+\n+  /* Copy elements in forward direction one at a time */\n+  for (from_ptr = from->first; from_ptr; from_ptr = from_ptr->next)\n+    {\n+      bitmap_element *to_elt = bitmap_element_allocate (to);\n+\n+      to_elt->indx = from_ptr->indx;\n+\n+#if BITMAP_ELEMENT_WORDS == 2\n+      to_elt->bits[0] = from_ptr->bits[0];\n+      to_elt->bits[1] = from_ptr->bits[1];\n+#else\n+      for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n+\tto_elt->bits[i] = from_ptr->bits[i];\n+#endif\n+\n+      /* Here we have a special case of bitmap_element_link, for the case\n+\t where we know the links are being entered in sequence.  */\n+      if (to_ptr == 0)\n+\t{\n+\t  to->first = to->current = to_elt;\n+\t  to->indx = from_ptr->indx;\n+\t  to_elt->next = to_elt->prev = 0;\n+\t}\n+      else\n+\t{\n+\t  to_elt->prev = to_ptr;\n+\t  to_elt->next = 0;\n+\t  to_ptr->next = to_elt;\n+\t}\n+\n+      to_ptr = to_elt;\n+    }\n+}\n+\f\n+/* Find a bitmap element that would hold a bitmap's bit.\n+   Update the `current' field even if we can't find an element that\n+   would hold the bitmap's bit to make eventual allocation\n+   faster.  */\n+\n+static INLINE bitmap_element *\n+bitmap_find_bit (head, bit)\n+     bitmap head;\n+     unsigned int bit;\n+{\n+  bitmap_element *element;\n+  unsigned HOST_WIDE_INT indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+\n+  if (head->current == 0)\n+    return 0;\n+\n+  if (head->indx > indx)\n+    for (element = head->current;\n+\t element->prev != 0 && element->indx > indx;\n+\t element = element->prev)\n+      ;\n+\n+  else\n+    for (element = head->current;\n+\t element->next != 0 && element->indx < indx;\n+\t element = element->next)\n+      ;\n+\n+  /* `element' is the nearest to the one we want.  If it's not the one we\n+     want, the one we want doesn't exist.  */\n+  head->current = element;\n+  head->indx = element->indx;\n+  if (element != 0 && element->indx != indx)\n+    element = 0;\n+\n+  return element;\n+}\n+\f\n+/* Clear a single bit in a bitmap.  */\n+\n+void\n+bitmap_clear_bit (head, bit)\n+     bitmap head;\n+     int bit;\n+{\n+  bitmap_element *ptr = bitmap_find_bit (head, bit);\n+\n+  if (ptr != 0)\n+    {\n+      unsigned bit_num  = bit % (unsigned) HOST_BITS_PER_WIDE_INT;\n+      unsigned word_num = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT)\n+\t\t\t   % BITMAP_ELEMENT_WORDS);\n+      ptr->bits[word_num] &= ~ (((unsigned HOST_WIDE_INT) 1) << bit_num);\n+\n+      /* If we cleared the entire word, free up the element */\n+      if (bitmap_element_zerop (ptr))\n+\tbitmap_element_free (head, ptr);\n+    }\n+}\n+\n+\f\n+/* Set a single bit in a bitmap.  */\n+\n+void\n+bitmap_set_bit (head, bit)\n+     bitmap head;\n+     int bit;\n+{\n+  bitmap_element *ptr = bitmap_find_bit (head, bit);\n+  unsigned word_num\n+    = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT) % BITMAP_ELEMENT_WORDS);\n+  unsigned bit_num  = bit % (unsigned) HOST_BITS_PER_WIDE_INT;\n+  unsigned HOST_WIDE_INT bit_val = ((unsigned HOST_WIDE_INT) 1) << bit_num;\n+\n+  if (ptr == 0)\n+    {\n+      ptr = bitmap_element_allocate (head);\n+      ptr->indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+      ptr->bits[word_num] = bit_val;\n+      bitmap_element_link (head, ptr);\n+    }\n+  else\n+    ptr->bits[word_num] |= bit_val;\n+}\n+\f\n+/* Return whether a bit is set within a bitmap.  */\n+\n+int\n+bitmap_bit_p (head, bit)\n+     bitmap head;\n+     int bit;\n+{\n+  bitmap_element *ptr;\n+  unsigned bit_num;\n+  unsigned word_num;\n+\n+  ptr = bitmap_find_bit (head, bit);\n+  if (ptr == 0)\n+    return 0;\n+\n+  bit_num = bit % (unsigned) HOST_BITS_PER_WIDE_INT;\n+  word_num\n+    = ((bit / (unsigned) HOST_BITS_PER_WIDE_INT) % BITMAP_ELEMENT_WORDS);\n+\n+  return\n+    (ptr->bits[word_num] & (((unsigned HOST_WIDE_INT) 1) << bit_num)) != 0;\n+}\n+\f\n+/* Store in bitmap TO the result of combining bitmap FROM1 and\n+   FROM2 using a specific bit manipulation.  */\n+\n+void\n+bitmap_operation (to, from1, from2, operation)\n+     bitmap to;\n+     bitmap from1;\n+     bitmap from2;\n+     enum bitmap_bits operation;\n+{\n+  bitmap_element *delete_list = 0;\n+  bitmap_element *from1_ptr = from1->first;\n+  bitmap_element *from2_ptr = from2->first;\n+  unsigned int indx1\n+    = (from1_ptr) ? from1_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+  unsigned int indx2\n+    = (from2_ptr) ? from2_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+  bitmap_element *to_ptr = 0;\n+  bitmap_element *from1_tmp;\n+  bitmap_element *from2_tmp;\n+  unsigned int indx;\n+  int i;\n+\n+  /* To simplify things, always create a new list.  If the old list was one\n+     of the inputs, free it later.  Otherwise, free it now.  */\n+  if (to == from1 || to == from2)\n+    {\n+      delete_list = to->first;\n+      to->first = 0;\n+    }\n+  else\n+    bitmap_clear (to);\n+\n+  while (from1_ptr != 0 || from2_ptr != 0)\n+    {\n+      /* Figure out whether we need to substitute zero elements for\n+\t missing links.  */\n+      if (indx1 == indx2)\n+\t{\n+\t  indx = indx1;\n+\t  from1_tmp = from1_ptr;\n+\t  from2_tmp = from2_ptr;\n+\t  from1_ptr = from1_ptr->next;\n+\t  indx1 = (from1_ptr) ? from1_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t  from2_ptr = from2_ptr->next;\n+\t  indx2 = (from2_ptr) ? from2_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t}\n+      else if (indx1 < indx2)\n+\t{\n+\t  indx = indx1;\n+\t  from1_tmp = from1_ptr;\n+\t  from2_tmp = &bitmap_zero;\n+\t  from1_ptr = from1_ptr->next;\n+\t  indx1 = (from1_ptr) ? from1_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t}\n+      else\n+\t{\n+\t  indx = indx2;\n+\t  from1_tmp = &bitmap_zero;\n+\t  from2_tmp = from2_ptr;\n+\t  from2_ptr = from2_ptr->next;\n+\t  indx2 = (from2_ptr) ? from2_ptr->indx : ~ (unsigned HOST_WIDE_INT) 0;\n+\t}\n+\n+      if (to_ptr == 0)\n+\tto_ptr = bitmap_element_allocate (to);\n+\n+      /* Do the operation, and if any bits are set, link it into the\n+\t linked list.  */\n+      switch (operation)\n+\t{\n+\tdefault:\n+\t  abort ();\n+\n+\tcase BITMAP_AND:\n+#if BITMAP_ELEMENT_WORDS == 2\n+\t  to_ptr->bits[0] = from1_tmp->bits[0] & from2_tmp->bits[0];\n+\t  to_ptr->bits[1] = from1_tmp->bits[1] & from2_tmp->bits[1];\n+#else\n+\t  for (i = BITMAP_ELEMENT_WORDS - 1; i >= 0; i--)\n+\t    to_ptr->bits[i] = from1_tmp->bits[i] & from2_tmp->bits[i];\n+#endif\n+\t  break;\n+\n+\tcase BITMAP_AND_COMPL:\n+#if BITMAP_ELEMENT_WORDS == 2\n+\t  to_ptr->bits[0] = from1_tmp->bits[0] & ~ from2_tmp->bits[0];\n+\t  to_ptr->bits[1] = from1_tmp->bits[1] & ~ from2_tmp->bits[1];\n+#else\n+\t  for (i = BITMAP_ELEMENT_WORDS - 1; i >= 0; i--)\n+\t    to_ptr->bits[i] = from1_tmp->bits[i] & ~ from2_tmp->bits[i];\n+#endif\n+\t  break;\n+\n+\tcase BITMAP_IOR:\n+#if BITMAP_ELEMENT_WORDS == 2\n+\t  to_ptr->bits[0] = from1_tmp->bits[0] | from2_tmp->bits[0];\n+\t  to_ptr->bits[1] = from1_tmp->bits[1] | from2_tmp->bits[1];\n+#else\n+\t  for (i = BITMAP_ELEMENT_WORDS - 1; i >= 0; i--)\n+\t    to_ptr->bits[i] = from1_tmp->bits[i] | from2_tmp->bits[i];\n+#endif\n+\t  break;\n+\t}\n+\n+      if (! bitmap_element_zerop (to_ptr))\n+\t{\n+\t  to_ptr->indx = indx;\n+\t  bitmap_element_link (to, to_ptr);\n+\t  to_ptr = 0;\n+\t}\n+    }\n+\n+  /* If we have an unallocated element due to the last element being 0,\n+     release it back to the free pool.  Don't bother calling\n+     bitmap_element_free since it was never linked into a bitmap.  */\n+  if (to_ptr != 0)\n+    {\n+      to_ptr->next = bitmap_free;\n+      bitmap_free = to_ptr;\n+    }\n+\n+  /* If the output bitmap was one of the inputs, free up its\n+     elements now that we're done.  */\n+  for (; delete_list != 0; delete_list = to_ptr)\n+    {\n+      to_ptr = delete_list->next;\n+      delete_list->next = bitmap_free;\n+      bitmap_free = delete_list;\n+    }\n+}\n+\f\n+/* Or into bitmap TO bitmap FROM1 and'ed with the complement of\n+   bitmap FROM2. */\n+\n+void\n+bitmap_ior_and_compl (to, from1, from2)\n+     bitmap to;\n+     bitmap from1;\n+     bitmap from2;\n+{\n+  bitmap_head tmp;\n+\n+  tmp.first = tmp.current = 0;\n+\n+  bitmap_operation (&tmp, from1, from2, BITMAP_AND_COMPL);\n+  bitmap_operation (to, to, &tmp, BITMAP_IOR);\n+  bitmap_clear (&tmp);\n+}\n+\f\n+/* Initialize a bitmap header.  */\n+\n+bitmap\n+bitmap_initialize (head)\n+     bitmap head;\n+{\n+  head->first = head->current = 0;\n+\n+  return head;\n+}\n+\f\n+/* Debugging function to print out the contents of a bitmap.  */\n+\n+void\n+bitmap_debug_file (file, head)\n+     FILE *file;\n+     bitmap head;\n+{\n+  bitmap_element *ptr;\n+\n+  fprintf (file, \"\\nfirst = \");\n+  fprintf (file, HOST_PTR_PRINTF, (HOST_WIDE_INT) head->first);\n+  fprintf (file, \" current = \");\n+  fprintf (file, HOST_PTR_PRINTF, (HOST_WIDE_INT) head->current);\n+  fprintf (file, \" indx = %u\\n\", head->indx);\n+\n+  for (ptr = head->first; ptr; ptr = ptr->next)\n+    {\n+      int i, j, col = 26;\n+\n+      fprintf (file, \"\\t\");\n+      fprintf (file, HOST_PTR_PRINTF, (HOST_WIDE_INT) ptr);\n+      fprintf (file, \" next = \");\n+      fprintf (file, HOST_PTR_PRINTF, (HOST_WIDE_INT) ptr->next);\n+      fprintf (file, \" prev = \");\n+      fprintf (file, HOST_PTR_PRINTF, (HOST_WIDE_INT) ptr->prev);\n+      fprintf (file, \" indx = %u\\n\\t\\tbits = {\", ptr->indx);\n+\n+      for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n+\tfor (j = 0; j < HOST_BITS_PER_WIDE_INT; j++)\n+\t  if ((ptr->bits[i] & (((unsigned HOST_WIDE_INT) 1) << j)) != 0)\n+\t    {\n+\t      if (col > 70)\n+\t\t{\n+\t\t  fprintf (file, \"\\n\\t\\t\\t\");\n+\t\t  col = 24;\n+\t\t}\n+\n+\t      fprintf (file, \" %u\", (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n+\t\t\t\t     + i * HOST_BITS_PER_WIDE_INT + j));\n+\t      col += 4;\n+\t    }\n+\n+      fprintf (file, \" }\\n\");\n+    }\n+}\n+\f\n+/* Function to be called from the debugger to print the contents\n+   of a bitmap.  */\n+\n+void\n+debug_bitmap (head)\n+     bitmap head;\n+{\n+  bitmap_debug_file (stdout, head);\n+}\n+\f\n+/* Release any memory allocated by bitmaps.  Since we allocate off of the\n+   function_obstack, just zap the free list.  */\n+\n+void\n+bitmap_release_memory ()\n+{\n+  bitmap_free = 0;\n+}"}, {"sha": "a01e398c2876346e255431b4333d9b75311bbc79", "filename": "gcc/bitmap.h", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096ab9eaaf2daba6c9cc0bc29565565560f11941/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096ab9eaaf2daba6c9cc0bc29565565560f11941/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=096ab9eaaf2daba6c9cc0bc29565565560f11941", "patch": "@@ -0,0 +1,239 @@\n+/* Functions to support general ended bitmaps.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Number of words to use for each element in the linked list.  */\n+\n+#ifndef BITMAP_ELEMENT_WORDS\n+#define BITMAP_ELEMENT_WORDS 2\n+#endif\n+\n+/* Number of bits in each actual element of a bitmap.  We get slightly better\n+   code for bit % BITMAP_ELEMENT_ALL_BITS and bit / BITMAP_ELEMENT_ALL_BITS if\n+   bits is unsigned, assuming it is a power of 2.  */\n+\n+#define BITMAP_ELEMENT_ALL_BITS \\\n+  ((unsigned) (BITMAP_ELEMENT_WORDS * HOST_BITS_PER_WIDE_INT))\n+\n+/* Bitmap set element.  We use a linked list to hold only the bits that\n+   are set.  This allows for use to grow the bitset dynamically without\n+   having to realloc and copy a giant bit array.  The `prev' field is\n+   undefined for an element on the free list.  */\n+\n+typedef struct bitmap_element_def\n+{\n+  struct bitmap_element_def *next;\t\t/* Next element. */\n+  struct bitmap_element_def *prev;\t\t/* Previous element. */\n+  unsigned int indx;\t\t\t/* regno/BITMAP_ELEMENT_ALL_BITS. */\n+  unsigned HOST_WIDE_INT bits[BITMAP_ELEMENT_WORDS]; /* Bits that are set. */\n+} bitmap_element;\n+\n+/* Head of bitmap linked list.  */\n+typedef struct bitmap_head_def {\n+  bitmap_element *first;\t/* First element in linked list. */\n+  bitmap_element *current;\t/* Last element looked at. */\n+  int indx;\t\t\t/* Index of last element looked at. */\n+} bitmap_head, *bitmap;\n+\n+/* Enumeration giving the various operations we support.  */\n+enum bitmap_bits {\n+  BITMAP_AND,\t\t\t/* TO = FROM1 & FROM2 */\n+  BITMAP_AND_COMPL,\t\t/* TO = FROM1 & ~ FROM2 */\n+  BITMAP_IOR\t\t\t/* TO = FROM1 | FROM2 */\n+};\n+\n+/* Global data */\n+extern bitmap_element *bitmap_free;\t/* Freelist of bitmap elements */\n+extern bitmap_element bitmap_zero;\t/* Zero bitmap element */\n+\n+/* Clear a bitmap by freeing up the linked list.  */\n+extern void bitmap_clear PROTO((bitmap));\n+\n+/* Copy a bitmap to another bitmap. */\n+extern void bitmap_copy PROTO((bitmap, bitmap));\n+\n+/* Perform an operation on two bitmaps, yielding a third.  */\n+extern void bitmap_operation PROTO((bitmap, bitmap, bitmap, enum bitmap_bits));\n+\n+/* `or' into one bitmap the `and' of a second bitmap witih the complement\n+   of a third.  */\n+extern void bitmap_ior_and_compl PROTO((bitmap, bitmap, bitmap));\n+\n+/* Clear a single register in a register set.  */\n+extern void bitmap_clear_bit PROTO((bitmap, int));\n+\n+/* Set a single register in a register set.  */\n+extern void bitmap_set_bit PROTO((bitmap, int));\n+\n+/* Return true if a register is set in a register set.  */\n+extern int bitmap_bit_p PROTO((bitmap, int));\n+\n+/* Debug functions to print a bitmap linked list.  */\n+extern void bitmap_debug PROTO((bitmap));\n+extern void bitmap_debug_file STDIO_PROTO((FILE *, bitmap));\n+\n+/* Initialize a bitmap header.  */\n+extern bitmap bitmap_initialize PROTO((bitmap));\n+\n+/* Release all memory held by bitmaps.  */\n+extern void bitmap_release_memory PROTO((void));\n+\n+/* Allocate a bitmap with oballoc.  */\n+#define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\\n+  bitmap_initialize ((bitmap) obstack_alloc (OBSTACK, sizeof (bitmap_head)))\n+\n+/* Allocate a bitmap with alloca.  */\n+#define BITMAP_ALLOCA()\t\t\t\t\t\t\\\n+  bitmap_initialize ((bitmap) alloca (sizeof (bitmap_head)))\n+\n+/* Do any cleanup needed on a bitmap when it is no longer used.  */\n+#define BITMAP_FREE(BITMAP)\t\t\t\t\t\\\n+do {\t\t\t\t\\\n+  if (BITMAP)\t\t\t\\\n+    {\t\t\t\t\\\n+      bitmap_clear (BITMAP);\t\\\n+      (BITMAP) = 0;\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Do any one-time initializations needed for bitmaps.  */\n+#define BITMAP_INIT_ONCE()\n+\n+/* Loop over all bits in BITMAP, starting with MIN, setting BITNUM to the\n+   bit number and executing CODE for all bits that are set. */\n+\n+#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, CODE)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  bitmap_element *ptr_ = (BITMAP)->first;\t\t\t\t\\\n+  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n+  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n+  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n+\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Find the block the minimum bit is in.  */\t\t\t\t\\\n+  while (ptr_ != 0 && ptr_->indx < indx_)\t\t\t\t\\\n+    ptr_ = ptr_->next;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (ptr_ != 0 && ptr_->indx != indx_)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bit_num_ = 0;\t\t\t\t\t\t\t\\\n+      word_num_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (; ptr_ != 0; ptr_ = ptr_->next)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  unsigned HOST_WIDE_INT word_ = ptr_->bits[word_num_];\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (word_ != 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n+\t\t    = ((unsigned HOST_WIDE_INT) 1) << bit_num_;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n+\t\t      (BITNUM) = (ptr_->indx * BITMAP_ELEMENT_ALL_BITS  \\\n+\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n+\t\t\t\t  + bit_num_);\t\t\t\t\\\n+\t\t      CODE;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t      if (word_ == 0)\t\t\t\t\t\\\n+\t\t\tbreak;\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      word_num_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n+   BITNUM to the bit number and executing CODE for all bits that are set in\n+   the first bitmap and not set in the second. */\n+\n+#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n+  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n+  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n+  unsigned bit_num_ = (MIN) % ((unsigned) HOST_BITS_PER_WIDE_INT);\t\\\n+  unsigned word_num_ = (((MIN) / ((unsigned) HOST_BITS_PER_WIDE_INT))\t\\\n+\t\t\t% BITMAP_ELEMENT_WORDS);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n+  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n+    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bit_num_ = 0;\t\t\t\t\t\t\t\\\n+      word_num_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Advance BITMAP2 to the equivalent link, using an all\t\t\\\n+\t zero element if an equavialent link doesn't exist.  */\t\t\\\n+      bitmap_element *tmp2_;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n+\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      tmp2_ = ((ptr2_ != 0 && ptr2_->indx == ptr1_->indx)\t\t\\\n+\t       ? ptr2_ : &bitmap_zero); \t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  unsigned HOST_WIDE_INT word_ = (ptr1_->bits[word_num_]\t\\\n+\t\t\t\t\t  & ~ tmp2_->bits[word_num_]);\t\\\n+\t  if (word_ != 0)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      for (; bit_num_ < HOST_BITS_PER_WIDE_INT; bit_num_++)\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  unsigned HOST_WIDE_INT mask_\t\t\t\t\\\n+\t\t    = ((unsigned HOST_WIDE_INT)1) << bit_num_;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n+\t\t    {\t\t\t\t\t\t\t\\\n+\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n+\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n+\t\t\t\t  + word_num_ * HOST_BITS_PER_WIDE_INT  \\\n+\t\t\t\t  + bit_num_);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\t      CODE;\t\t\t\t\t\t\\\n+\t\t      if (word_ == 0)\t\t\t\t\t\\\n+\t\t\tbreak;\t\t\t\t\t\t\\\n+\t\t    }\t\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      word_num_ = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)"}]}