{"sha": "f710f868cbda44939f994e843d33e85c7ea1bdb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxMGY4NjhjYmRhNDQ5MzlmOTk0ZTg0M2QzM2U4NWM3ZWExYmRiNQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-14T14:11:34Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-14T14:11:34Z"}, "message": "sparc.c (sparc_emit_set_const64_quick2, [...]): Fix more bugs in 64-bit constant formation.\n\n\t* config/sparc/sparc.c (sparc_emit_set_const64_quick2,\n\tsparc_emit_set_const64_longway, const64_is_2insns,\n\tcreate_simple_focus_bits, sparc_emit_set_const64): Fix more bugs\n\tin 64-bit constant formation.\n\t* config/sparc/sparc.md (snesi_zero_extend split): Generate\n\trtl for addx not subx.\n\t(define_insn movdi_const64_special): Make available even when\n\tHOST_BITS_PER_WIDE_INT is not 64.\n\t(movdi_lo_sum_sp64_cint, movdi_high_sp64_cint): Remove.\n\t(losum_di_medlow, sethm, setlo): Make op2 symbolic_operand.\n\t(cmp_siqi_trunc_set, cmp_diqi_trunc_set): Encapsulate both\n\tinstances of operand 1 inside a QI subreg.\n\t(xordi3_sp64_dbl): Remove '%' constraint for op1.\n\t(one_cmpldi2_sp64): Fix output string.\n\t(one_cmplsi2_not_liveg0): Rewrite to remove unneeded extra\n\talternative case.\n\t(unnamed arch64 ashift DI): Truncate shift count if greater than\n\t63, not 31.\n\nFrom-SVN: r21733", "tree": {"sha": "176b68dd1f1878e42c85fd731676e89530abc669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/176b68dd1f1878e42c85fd731676e89530abc669"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f710f868cbda44939f994e843d33e85c7ea1bdb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f710f868cbda44939f994e843d33e85c7ea1bdb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f710f868cbda44939f994e843d33e85c7ea1bdb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f710f868cbda44939f994e843d33e85c7ea1bdb5/comments", "author": null, "committer": null, "parents": [{"sha": "6036acbbf2daa09fde4b435fd053adcf88fe492a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6036acbbf2daa09fde4b435fd053adcf88fe492a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6036acbbf2daa09fde4b435fd053adcf88fe492a"}], "stats": {"total": 181, "additions": 99, "deletions": 82}, "files": [{"sha": "dd51f8da19e581c58615356644257f7a6463c4e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710f868cbda44939f994e843d33e85c7ea1bdb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710f868cbda44939f994e843d33e85c7ea1bdb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f710f868cbda44939f994e843d33e85c7ea1bdb5", "patch": "@@ -1,3 +1,24 @@\n+Fri Aug 14 12:58:21 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (sparc_emit_set_const64_quick2,\n+\tsparc_emit_set_const64_longway, const64_is_2insns,\n+\tcreate_simple_focus_bits, sparc_emit_set_const64): Fix more bugs\n+\tin 64-bit constant formation.\n+\t* config/sparc/sparc.md (snesi_zero_extend split): Generate\n+\trtl for addx not subx.\n+\t(define_insn movdi_const64_special): Make available even when\n+\tHOST_BITS_PER_WIDE_INT is not 64.\n+\t(movdi_lo_sum_sp64_cint, movdi_high_sp64_cint): Remove.\n+\t(losum_di_medlow, sethm, setlo): Make op2 symbolic_operand.\n+\t(cmp_siqi_trunc_set, cmp_diqi_trunc_set): Encapsulate both\n+\tinstances of operand 1 inside a QI subreg.\n+\t(xordi3_sp64_dbl): Remove '%' constraint for op1.\n+\t(one_cmpldi2_sp64): Fix output string.\n+\t(one_cmplsi2_not_liveg0): Rewrite to remove unneeded extra\n+\talternative case.\n+\t(unnamed arch64 ashift DI): Truncate shift count if greater than\n+\t63, not 31.\n+\n Fri Aug 14 21:52:53 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* expr.c (store_expr): Don't optimize away load-store pair"}, {"sha": "6651ee3a75e0871b4393d8a20de8cfa0547c9af6", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710f868cbda44939f994e843d33e85c7ea1bdb5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710f868cbda44939f994e843d33e85c7ea1bdb5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f710f868cbda44939f994e843d33e85c7ea1bdb5", "patch": "@@ -1229,7 +1229,7 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n \t{\n \t  /* Getting this right wrt. reloading is really tricky.\n \t     We _MUST_ have a seperate temporary at this point,\n-\t     if we don't barf immediately instead of generating\n+\t     so we barf immediately instead of generating\n \t     incorrect code.  */\n \t  if (temp1 == op0)\n \t    abort ();\n@@ -1369,7 +1369,7 @@ sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n     }\n   else\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, temp, GEN_INT (high_bits)));\n+      emit_insn (gen_safe_SET64 (temp, high_bits));\n       temp2 = temp;\n     }\n \n@@ -1416,7 +1416,7 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n     }\n   else\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, temp, GEN_INT (high_bits)));\n+      emit_insn (gen_safe_SET64 (temp, high_bits));\n       sub_temp = temp;\n     }\n \n@@ -1432,10 +1432,17 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n \n       sparc_emit_set_safe_HIGH64 (temp2, low_bits);\n       if ((low_bits & ~0xfffffc00) != 0)\n-\temit_insn (gen_rtx_SET (VOIDmode, temp3,\n-\t\t\t\tgen_safe_OR64 (temp2, (low_bits & 0x3ff))));\n-      emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t      gen_rtx_PLUS (DImode, temp4, temp3)));\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp3,\n+\t\t\t\t  gen_safe_OR64 (temp2, (low_bits & 0x3ff))));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t\t  gen_rtx_PLUS (DImode, temp4, temp3)));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t\t  gen_rtx_PLUS (DImode, temp4, temp2)));\n+\t}\n     }\n   else\n     {\n@@ -1572,17 +1579,14 @@ const64_is_2insns (high_bits, low_bits)\n \t\t\t  &highest_bit_set, &lowest_bit_set,\n \t\t\t  &all_bits_between_are_set);\n \n-  if (highest_bit_set == 63\n+  if ((highest_bit_set == 63\n+       || lowest_bit_set == 0)\n       && all_bits_between_are_set != 0)\n     return 1;\n \n   if ((highest_bit_set - lowest_bit_set) < 21)\n     return 1;\n \n-  if (high_bits == 0\n-      || high_bits == 0xffffffff)\n-    return 1;\n-\n   return 0;\n }\n \n@@ -1595,7 +1599,7 @@ create_simple_focus_bits (high_bits, low_bits, highest_bit_set, lowest_bit_set,\n      unsigned HOST_WIDE_INT high_bits, low_bits;\n      int highest_bit_set, lowest_bit_set, shift;\n {\n-  int hi, lo;\n+  HOST_WIDE_INT hi, lo;\n \n   if (lowest_bit_set < 32)\n     {\n@@ -1634,13 +1638,14 @@ sparc_emit_set_const64 (op0, op1)\n \t  && REGNO (op0) <= SPARC_LAST_V9_FP_REG))\n     abort ();\n \n+  if (reload_in_progress || reload_completed)\n+    temp = op0;\n+  else\n+    temp = gen_reg_rtx (DImode);\n+\n   if (GET_CODE (op1) != CONST_DOUBLE\n       && GET_CODE (op1) != CONST_INT)\n     {\n-      if (reload_in_progress || reload_completed)\n-\ttemp = op0;\n-      else\n-\ttemp = gen_reg_rtx (DImode);\n       sparc_emit_set_symbolic_const64 (op0, op1, temp);\n       return;\n     }\n@@ -1671,11 +1676,6 @@ sparc_emit_set_const64 (op0, op1)\n   /* low_bits\tbits 0  --> 31\n      high_bits\tbits 32 --> 63  */\n \n-  if (reload_in_progress || reload_completed)\n-    temp = op0;\n-  else\n-    temp = gen_reg_rtx (DImode);\n-\n   analyze_64bit_constant (high_bits, low_bits,\n \t\t\t  &highest_bit_set, &lowest_bit_set,\n \t\t\t  &all_bits_between_are_set);\n@@ -1699,15 +1699,9 @@ sparc_emit_set_const64 (op0, op1)\n       HOST_WIDE_INT the_const = -1;\n       int shift = lowest_bit_set;\n \n-      if (highest_bit_set == lowest_bit_set)\n-\t{\n-\t  /* There is no way to get here like this, because this case\n-\t     can be done in one instruction.  */\n-\t  if (lowest_bit_set < 32)\n-\t    abort ();\n-\t  the_const = 1;\n-\t}\n-      else if (all_bits_between_are_set == 0)\n+      if ((highest_bit_set != 63\n+\t   && lowest_bit_set != 0)\n+\t  || all_bits_between_are_set == 0)\n \t{\n \t  the_const =\n \t    create_simple_focus_bits (high_bits, low_bits,\n@@ -1717,6 +1711,9 @@ sparc_emit_set_const64 (op0, op1)\n       else if (lowest_bit_set == 0)\n \tshift = -(63 - highest_bit_set);\n \n+      if (! SPARC_SIMM13_P (the_const))\n+\tabort ();\n+\n       emit_insn (gen_safe_SET64 (temp, the_const));\n       if (shift > 0)\n \temit_insn (gen_rtx_SET (VOIDmode,\n@@ -1746,6 +1743,10 @@ sparc_emit_set_const64 (op0, op1)\n       unsigned HOST_WIDE_INT focus_bits =\n \tcreate_simple_focus_bits (high_bits, low_bits,\n \t\t\t\t  highest_bit_set, lowest_bit_set, 10);\n+\n+      if (! SPARC_SETHI_P (focus_bits))\n+\t abort ();\n+\n       sparc_emit_set_safe_HIGH64 (temp, focus_bits);\n \n       /* If lowest_bit_set == 10 then a sethi alone could have done it.  */\n@@ -1777,20 +1778,20 @@ sparc_emit_set_const64 (op0, op1)\n       return;\n     }\n \n+  /* Now, try 3-insn sequences.  */\n+\n   /* 1) sethi\t%hi(high_bits), %reg\n    *    or\t%reg, %lo(high_bits), %reg\n    *    sllx\t%reg, 32, %reg\n    */\n-  if (low_bits == 0\n-      || (SPARC_SIMM13_P(low_bits)\n-\t  && ((HOST_WIDE_INT)low_bits > 0)))\n+  if (low_bits == 0)\n     {\n-      sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_bits, 32);\n+      sparc_emit_set_const64_quick2 (op0, temp, high_bits, 0, 32);\n       return;\n     }\n \n-  /* Now, try 3-insn sequences.  But first we may be able to do something\n-     quick when the constant is negated, so try that.  */\n+  /* We may be able to do something quick\n+     when the constant is negated, so try that.  */\n   if (const64_is_2insns ((~high_bits) & 0xffffffff,\n \t\t\t (~low_bits) & 0xfffffc00))\n     {\n@@ -1832,10 +1833,15 @@ sparc_emit_set_const64 (op0, op1)\n   /* 1) sethi\t%hi(xxx), %reg\n    *    or\t%reg, %lo(xxx), %reg\n    *\tsllx\t%reg, yyy, %reg\n+   *\n+   * ??? This is just a generalized version of the low_bits==0\n+   * thing above, FIXME...\n    */\n   if ((highest_bit_set - lowest_bit_set) < 32)\n     {\n-      unsigned HOST_WIDE_INT hi, lo, focus_bits;\n+      unsigned HOST_WIDE_INT focus_bits =\n+\tcreate_simple_focus_bits (high_bits, low_bits,\n+\t\t\t\t  highest_bit_set, lowest_bit_set, 0);\n \n       /* We can't get here in this state.  */\n       if (highest_bit_set < 32\n@@ -1844,17 +1850,24 @@ sparc_emit_set_const64 (op0, op1)\n \n       /* So what we know is that the set bits straddle the\n \t middle of the 64-bit word.  */\n-      hi = (low_bits >> lowest_bit_set);\n-      lo = (high_bits << (32 - lowest_bit_set));\n-      if (hi & lo)\n-\tabort ();\n-      focus_bits = (hi | lo);\n       sparc_emit_set_const64_quick2 (op0, temp,\n \t\t\t\t     focus_bits, 0,\n \t\t\t\t     lowest_bit_set);\n       return;\n     }\n \n+  /* 1) sethi\t%hi(high_bits), %reg\n+   *    or\t%reg, %lo(high_bits), %reg\n+   *    sllx\t%reg, 32, %reg\n+   *\tor\t%reg, low_bits, %reg\n+   */\n+  if (SPARC_SIMM13_P(low_bits)\n+      && ((int)low_bits > 0))\n+    {\n+      sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_bits, 32);\n+      return;\n+    }\n+\n   /* The easiest way when all else fails, is full decomposition. */\n #if 0\n   printf (\"sparc_emit_set_const64: Hard constant [%08lx%08lx] neg[%08lx%08lx]\\n\","}, {"sha": "72795121ec0236fd65ebe5ea45c794dfddd501bc", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710f868cbda44939f994e843d33e85c7ea1bdb5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710f868cbda44939f994e843d33e85c7ea1bdb5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f710f868cbda44939f994e843d33e85c7ea1bdb5", "patch": "@@ -1097,10 +1097,10 @@\n    && reload_completed\"\n   [(set (reg:CC_NOOV 100) (compare:CC_NOOV (minus:SI (const_int 0) (match_dup 1))\n                                            (const_int 0)))\n-   (set (match_dup 0) (zero_extend:DI (minus:SI (minus:SI (const_int 0)\n-                                                          (const_int 0))\n-                                                (ltu:SI (reg:CC_NOOV 100)\n-                                                        (const_int 0)))))]\n+   (set (match_dup 0) (zero_extend:DI (plus:SI (plus:SI (const_int 0)\n+                                                        (const_int 0))\n+                                               (ltu:SI (reg:CC_NOOV 100)\n+                                                       (const_int 0)))))]\n   \"\")\n \n (define_insn \"*snedi_zero\"\n@@ -2332,6 +2332,7 @@\n   [(set_attr \"type\" \"store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n    (set_attr \"length\" \"1,1,2,2,2,2,1,1,2,2,2\")])\n \n+;; The following are generated by sparc_emit_set_const64\n (define_insn \"*movdi_sp64_dbl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (match_operand:DI 1 \"const64_operand\" \"\"))]\n@@ -2341,11 +2342,12 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n+;; This is needed to show CSE exactly which bits are set\n+;; in a 64-bit register by sethi instructions.\n (define_insn \"*movdi_const64_special\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(match_operand:DI 1 \"const64_high_operand\" \"\"))]\n-  \"(TARGET_ARCH64\n-    && HOST_BITS_PER_WIDE_INT != 64)\"\n+  \"TARGET_ARCH64\"\n   \"sethi\\\\t%%hi(%a1), %0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n@@ -2368,24 +2370,6 @@\n   [(set_attr \"type\" \"move,move,move,load,store,fpmove,fpload,fpstore\")\n    (set_attr \"length\" \"1\")])\n \n-;; The following are generated by sparc_emit_set_const64\n-(define_insn \"*movdi_lo_sum_sp64_cint\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                   (match_operand:DI 2 \"const_int_operand\" \"in\")))]\n-  \"TARGET_ARCH64\"\n-  \"or\\\\t%1, %%lo(%a2), %0\"\n-  [(set_attr \"type\" \"ialu\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"*movdi_high_sp64_cint\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(high:DI (match_operand:DI 1 \"const_int_operand\" \"in\")))]\n-  \"TARGET_ARCH64\"\n-  \"sethi\\\\t%%hi(%a1), %0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n-\n ;; ??? revisit this...\n (define_insn \"move_label_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -2439,7 +2423,7 @@\n (define_insn \"*losum_di_medlow\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                   (match_operand:DI 2 \"\" \"\")))]\n+                   (match_operand:DI 2 \"symbolic_operand\" \"\")))]\n   \"TARGET_CM_MEDLOW\"\n   \"or\\\\t%1, %%lo(%a2), %0\"\n   [(set_attr \"length\" \"1\")])\n@@ -2488,15 +2472,15 @@\n (define_insn \"sethm\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                   (unspec:DI [(match_operand:DI 2 \"\" \"\")] 18)))]\n+                   (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")] 18)))]\n   \"TARGET_CM_MEDANY\"\n   \"or\\\\t%1, %%hm(%a2), %0\"\n   [(set_attr \"length\" \"1\")])\n \n (define_insn \"setlo\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-                   (match_operand:DI 2 \"\" \"\")))]\n+                   (match_operand:DI 2 \"symbolic_operand\" \"\")))]\n   \"TARGET_CM_MEDANY\"\n   \"or\\\\t%1, %%lo(%a2), %0\"\n   [(set_attr \"length\" \"1\")])\n@@ -3915,7 +3899,7 @@\n \t(compare:CC (subreg:QI (match_operand:SI 1 \"register_operand\" \"r\") 0)\n \t\t    (const_int 0)))\n    (set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_dup 1))]\n+\t(subreg:QI (match_dup 1) 0))]\n   \"\"\n   \"andcc\\\\t%1, 0xff, %0\"\n   [(set_attr \"type\" \"compare\")\n@@ -3935,7 +3919,7 @@\n \t(compare:CC (subreg:QI (match_operand:DI 1 \"register_operand\" \"r\") 0)\n \t\t    (const_int 0)))\n    (set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_dup 1))]\n+\t(subreg:QI (match_dup 1) 0))]\n   \"TARGET_ARCH64\"\n   \"andcc\\\\t%1, 0xff, %0\"\n   [(set_attr \"type\" \"compare\")\n@@ -4149,7 +4133,7 @@\n             (GET_CODE (operands[2]) == CONST_INT\n              ? INTVAL (operands[2])\n              : CONST_DOUBLE_LOW (operands[2])) - len;\n-  unsigned mask = ((1 << len) - 1) << pos;\n+  HOST_WIDE_INT mask = ((1 << len) - 1) << pos;\n \n   operands[1] = GEN_INT (mask);\n   return \\\"andcc\\\\t%0, %1, %%g0\\\";\n@@ -4178,7 +4162,7 @@\n             (GET_CODE (operands[2]) == CONST_INT\n              ? INTVAL (operands[2])\n              : CONST_DOUBLE_LOW (operands[2])) - len;\n-  unsigned HOST_WIDE_INT mask = (((unsigned HOST_WIDE_INT) 1 << len) - 1) << pos;\n+  HOST_WIDE_INT mask = (((unsigned HOST_WIDE_INT) 1 << len) - 1) << pos;\n \n   operands[1] = GEN_INT (mask);\n   return \\\"andcc\\\\t%0, %1, %%g0\\\";\n@@ -5644,7 +5628,7 @@\n \n (define_insn \"*xordi3_sp64_dbl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t(match_operand:DI 2 \"const64_operand\" \"\")))]\n   \"(TARGET_ARCH64\n     && HOST_BITS_PER_WIDE_INT != 64)\"\n@@ -6058,7 +6042,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI\")))]\n   \"TARGET_ARCH64\"\n-  \"xnor\\\\t%1, 0, %0\"\n+  \"xnor\\\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"1\")])\n \n@@ -6085,15 +6069,14 @@\n }\")\n \n (define_insn \"*one_cmplsi2_not_liveg0\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,d\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r,I,d\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"rI,d\")))]\n   \"! TARGET_LIVE_G0\"\n   \"@\n-  xnor\\\\t%1, 0, %0\n   xnor\\\\t%%g0, %1, %0\n   fnot1s\\\\t%1, %0\"\n-  [(set_attr \"type\" \"unary,unary,fp\")\n-   (set_attr \"length\" \"1,1,1\")])\n+  [(set_attr \"type\" \"unary,fp\")\n+   (set_attr \"length\" \"1,1\")])\n \n (define_insn \"*one_cmplsi2_liveg0\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n@@ -6434,7 +6417,7 @@\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n-      && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) > 31)\n+      && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) > 63)\n     operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n \n   return \\\"sllx\\\\t%1, %2, %0\\\";"}]}