{"sha": "cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VjMDdjNDc1OWU4YWY0NGNhNzdhMmJlYjkzMTJlNGUzMGQxY2M3YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T22:25:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T22:25:58Z"}, "message": "compiler, runtime: call gcWriteBarrier instead of writebarrierptr\n    \n    In 1.11 writebarrierptr is going away, so change the compiler to call\n    gcWriteBarrier instead.  We weren't using gcWriteBarrier before;\n    adjust the implementation to use the putFast method.\n    \n    This revealed a problem in the kickoff function.  When using cgo,\n    kickoff can be called on the g0 of an m allocated by newExtraM.  In\n    that case the m will generally have a p, but systemstack may be called\n    by wbBufFlush as part of flushing the write barrier buffer.  At that\n    point the buffer is full, so we can not do a write barrier.  So adjust\n    the existing code in kickoff so that in the case where we are g0,\n    don't do any write barrier at all.\n    \n    Reviewed-on: https://go-review.googlesource.com/131395\n\nFrom-SVN: r264295", "tree": {"sha": "38fe52c7aeba372693d83041bf5037d8fbb2c311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38fe52c7aeba372693d83041bf5037d8fbb2c311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/comments", "author": null, "committer": null, "parents": [{"sha": "38fab7369d19fd545eb8510ec198e73949a2c75d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fab7369d19fd545eb8510ec198e73949a2c75d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38fab7369d19fd545eb8510ec198e73949a2c75d"}], "stats": {"total": 57, "additions": 31, "deletions": 26}, "files": [{"sha": "67ed6589ad14a859bb4ef0996aba9ec0090e2534", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "patch": "@@ -1,4 +1,4 @@\n-82d7205ba9e5c1fe38fd24f89a45caf2e974975b\n+218c9159635e06e39ae43d0efe1ac1e694fead2e\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ed759e80780ddbfe0733e859762b06b8ccee629a", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "patch": "@@ -302,7 +302,7 @@ DEF_GO_RUNTIME(IFACEEFACEEQ, \"runtime.ifaceefaceeq\", P2(IFACE, EFACE),\n \n \n // Set *dst = src where dst is a pointer to a pointer and src is a pointer.\n-DEF_GO_RUNTIME(WRITEBARRIERPTR, \"runtime.writebarrierptr\",\n+DEF_GO_RUNTIME(GCWRITEBARRIER, \"runtime.gcWriteBarrier\",\n \t       P2(POINTER, POINTER), R0())\n \n // Set *dst = *src for an arbitrary type."}, {"sha": "4f84d9950f1a2808f45fcbe92141d546666437bd", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "patch": "@@ -380,7 +380,7 @@ Gogo::propagate_writebarrierrec()\n // This is compatible with the definition in the runtime package.\n //\n // For types that are pointer shared (pointers, maps, chans, funcs),\n-// we replaced the call to typedmemmove with writebarrierptr(&A, B).\n+// we replaced the call to typedmemmove with gcWriteBarrier(&A, B).\n // As far as the GC is concerned, all pointers are the same, so it\n // doesn't need the type descriptor.\n //\n@@ -391,7 +391,7 @@ Gogo::propagate_writebarrierrec()\n // runtime package, so we could optimize by only testing it once\n // between function calls.\n //\n-// A slice could be handled with a call to writebarrierptr plus two\n+// A slice could be handled with a call to gcWriteBarrier plus two\n // integer moves.\n \n // Traverse the IR adding write barriers.\n@@ -824,7 +824,7 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n     case Type::TYPE_MAP:\n     case Type::TYPE_CHANNEL:\n       // These types are all represented by a single pointer.\n-      call = Runtime::make_call(Runtime::WRITEBARRIERPTR, loc, 2, lhs, rhs);\n+      call = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2, lhs, rhs);\n       break;\n \n     case Type::TYPE_STRING:"}, {"sha": "b396d35146cb77c609fdfb2d7b1bc9158f0f3e96", "filename": "libgo/go/runtime/mgc_gccgo.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/libgo%2Fgo%2Fruntime%2Fmgc_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/libgo%2Fgo%2Fruntime%2Fmgc_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc_gccgo.go?ref=cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "patch": "@@ -11,6 +11,11 @@ import (\n \t\"unsafe\"\n )\n \n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname gcWriteBarrier runtime.gcWriteBarrier\n+\n // gcRoot is a single GC root: a variable plus a ptrmask.\n //go:notinheap\n type gcRoot struct {\n@@ -188,12 +193,7 @@ func checkPreempt() {\n //go:nowritebarrier\n func gcWriteBarrier(dst *uintptr, src uintptr) {\n \tbuf := &getg().m.p.ptr().wbBuf\n-\tnext := buf.next\n-\tnp := next + 2*sys.PtrSize\n-\tbuf.next = np\n-\t*(*uintptr)(unsafe.Pointer(next)) = src\n-\t*(*uintptr)(unsafe.Pointer(next + sys.PtrSize)) = *dst\n-\tif np >= buf.end {\n+\tif !buf.putFast(src, *dst) {\n \t\twbBufFlush(dst, src)\n \t}\n \t*dst = src"}, {"sha": "4fc45dd4f64c59d31ac3c7765260832c79cdbf08", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cec07c4759e8af44ca77a2beb9312e4e30d1cc7a/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=cec07c4759e8af44ca77a2beb9312e4e30d1cc7a", "patch": "@@ -1146,24 +1146,29 @@ func kickoff() {\n \n \tfv := gp.entry\n \tparam := gp.param\n-\tgp.entry = nil\n \n \t// When running on the g0 stack we can wind up here without a p,\n-\t// for example from mcall(exitsyscall0) in exitsyscall.\n-\t// Setting gp.param = nil will call a write barrier, and if\n-\t// there is no p that write barrier will crash. When called from\n-\t// mcall the gp.param value will be a *g, which we don't need to\n-\t// shade since we know it will be kept alive elsewhere. In that\n-\t// case clear the field using uintptr so that the write barrier\n-\t// does nothing.\n-\tif gp.m.p == 0 {\n-\t\tif gp == gp.m.g0 && gp.param == unsafe.Pointer(gp.m.curg) {\n-\t\t\t*(*uintptr)(unsafe.Pointer(&gp.param)) = 0\n-\t\t} else {\n-\t\t\tthrow(\"no p in kickoff\")\n-\t\t}\n+\t// for example from mcall(exitsyscall0) in exitsyscall, in\n+\t// which case we can not run a write barrier.\n+\t// It is also possible for us to get here from the systemstack\n+\t// call in wbBufFlush, at which point the write barrier buffer\n+\t// is full and we can not run a write barrier.\n+\t// Setting gp.entry = nil or gp.param = nil will try to run a\n+\t// write barrier, so if we are on the g0 stack due to mcall\n+\t// (systemstack calls mcall) then clear the field using uintptr.\n+\t// This is OK when gp.param is gp.m.curg, as curg will be kept\n+\t// alive elsewhere, and gp.entry always points into g, or\n+\t// to a statically allocated value, or (in the case of mcall)\n+\t// to the stack.\n+\tif gp == gp.m.g0 && gp.param == unsafe.Pointer(gp.m.curg) {\n+\t\t*(*uintptr)(unsafe.Pointer(&gp.entry)) = 0\n+\t\t*(*uintptr)(unsafe.Pointer(&gp.param)) = 0\n+\t} else if gp.m.p == 0 {\n+\t\tthrow(\"no p in kickoff\")\n+\t} else {\n+\t\tgp.entry = nil\n+\t\tgp.param = nil\n \t}\n-\tgp.param = nil\n \n \tfv(param)\n \tgoexit1()"}]}