{"sha": "185082a7b82a6ca848ab81301d2638964a78b815", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg1MDgyYTdiODJhNmNhODQ4YWI4MTMwMWQyNjM4OTY0YTc4YjgxNQ==", "commit": {"author": {"name": "Seongbae Park", "email": "seongbae.park@gmail.com", "date": "2008-01-17T20:02:56Z"}, "committer": {"name": "Seongbae Park", "email": "spark@gcc.gnu.org", "date": "2008-01-17T20:02:56Z"}, "message": "re PR middle-end/34400 (bad interaction between DF and SJLJ exceptions)\n\n2008-01-17  Seongbae Park  <seongbae.park@gmail.com>\n\n\tPR rtl-optimization/34400\n\t* df-core.c (df_worklist_dataflow_overeager,\n\tdf_worklist_dataflow_doublequeue): New functions.\n\t(df_worklist_dataflow): Two different worklist solvers.\n\t* params.def (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR):\n\tNew param.\n\nFrom-SVN: r131608", "tree": {"sha": "63cf6649d86eefb583c5a2b946231255d4b60dcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63cf6649d86eefb583c5a2b946231255d4b60dcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/185082a7b82a6ca848ab81301d2638964a78b815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/185082a7b82a6ca848ab81301d2638964a78b815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/185082a7b82a6ca848ab81301d2638964a78b815", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/185082a7b82a6ca848ab81301d2638964a78b815/comments", "author": null, "committer": null, "parents": [{"sha": "01a550c20d68194fb3c2f4557236b0aecd7c534d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a550c20d68194fb3c2f4557236b0aecd7c534d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01a550c20d68194fb3c2f4557236b0aecd7c534d"}], "stats": {"total": 159, "additions": 141, "deletions": 18}, "files": [{"sha": "c7e5849c0052347f7cbab669dd9f83fb7b7d0d6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185082a7b82a6ca848ab81301d2638964a78b815/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185082a7b82a6ca848ab81301d2638964a78b815/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=185082a7b82a6ca848ab81301d2638964a78b815", "patch": "@@ -1,3 +1,12 @@\n+2008-01-17  Seongbae Park  <seongbae.park@gmail.com>\n+\n+\tPR rtl-optimization/34400\n+\t* df-core.c (df_worklist_dataflow_overeager,\n+\tdf_worklist_dataflow_doublequeue): New functions.\n+\t(df_worklist_dataflow): Two different worklist solvers.\n+\t* params.def (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR):\n+\tNew param.\n+\n 2008-01-16  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR testsuite/34821"}, {"sha": "5404000ef3972f753041ec55fa200f8e04e0db79", "filename": "gcc/df-core.c", "status": "modified", "additions": 127, "deletions": 18, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185082a7b82a6ca848ab81301d2638964a78b815/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185082a7b82a6ca848ab81301d2638964a78b815/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=185082a7b82a6ca848ab81301d2638964a78b815", "patch": "@@ -399,6 +399,7 @@ are write-only operations.\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"tree-pass.h\"\n+#include \"params.h\"\n \n static void *df_get_bb_info (struct dataflow *, unsigned int);\n static void df_set_bb_info (struct dataflow *, unsigned int, void *);\n@@ -931,6 +932,105 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n }\n \n \n+\n+/* This will free \"pending\". */\n+static void \n+df_worklist_dataflow_overeager (struct dataflow *dataflow,\n+\t\t\t\tbitmap pending,\n+                                sbitmap considered,\n+                                int *blocks_in_postorder,\n+\t\t\t\tunsigned *bbindex_to_postorder)\n+{\n+  enum df_flow_dir dir = dataflow->problem->dir;\n+  int count = 0;\n+\n+  while (!bitmap_empty_p (pending))\n+    {\n+      unsigned bb_index;\n+      int index;\n+      count++;\n+\n+      index = bitmap_first_set_bit (pending);\n+      bitmap_clear_bit (pending, index);\n+\n+      bb_index = blocks_in_postorder[index];\n+\n+      if (dir == DF_FORWARD)\n+\tdf_worklist_propagate_forward (dataflow, bb_index,\n+\t\t\t\t       bbindex_to_postorder,\n+\t\t\t\t       pending, considered);\n+      else \n+\tdf_worklist_propagate_backward (dataflow, bb_index,\n+\t\t\t\t\tbbindex_to_postorder,\n+\t\t\t\t\tpending, considered);\n+    }\n+\n+  BITMAP_FREE (pending);\n+\n+  /* Dump statistics. */\n+  if (dump_file)\n+    fprintf (dump_file, \"df_worklist_dataflow_overeager:\"\n+\t     \"n_basic_blocks %d n_edges %d\"\n+\t     \" count %d (%5.2g)\\n\",\n+\t     n_basic_blocks, n_edges,\n+\t     count, count / (float)n_basic_blocks);\n+}\n+\n+static void \n+df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n+\t\t\t  \t  bitmap pending,\n+                                  sbitmap considered,\n+                                  int *blocks_in_postorder,\n+\t\t\t\t  unsigned *bbindex_to_postorder)\n+{\n+  enum df_flow_dir dir = dataflow->problem->dir;\n+  int dcount = 0;\n+  bitmap worklist = BITMAP_ALLOC (&df_bitmap_obstack);\n+\n+  /* Double-queueing. Worklist is for the current iteration,\n+     and pending is for the next. */\n+  while (!bitmap_empty_p (pending))\n+    {\n+      /* Swap pending and worklist. */\n+      bitmap temp = worklist;\n+      worklist = pending;\n+      pending = temp;\n+\n+      do\n+\t{\n+\t  int index;\n+\t  unsigned bb_index;\n+\t  dcount++;\n+\n+\t  index = bitmap_first_set_bit (worklist);\n+\t  bitmap_clear_bit (worklist, index);\n+\n+\t  bb_index = blocks_in_postorder[index];\n+\n+\t  if (dir == DF_FORWARD)\n+\t    df_worklist_propagate_forward (dataflow, bb_index,\n+\t\t\t\t\t   bbindex_to_postorder,\n+\t\t\t\t\t   pending, considered);\n+\t  else \n+\t    df_worklist_propagate_backward (dataflow, bb_index,\n+\t\t\t\t\t    bbindex_to_postorder,\n+\t\t\t\t\t    pending, considered);\n+\t}\n+      while (!bitmap_empty_p (worklist));\n+    }\n+\n+  BITMAP_FREE (worklist);\n+  BITMAP_FREE (pending);\n+\n+  /* Dump statistics. */\n+  if (dump_file)\n+    fprintf (dump_file, \"df_worklist_dataflow_doublequeue:\"\n+\t     \"n_basic_blocks %d n_edges %d\"\n+\t     \" count %d (%5.2g)\\n\",\n+\t     n_basic_blocks, n_edges,\n+\t     dcount, dcount / (float)n_basic_blocks);\n+}\n+\n /* Worklist-based dataflow solver. It uses sbitmap as a worklist,\n    with \"n\"-th bit representing the n-th block in the reverse-postorder order. \n    This is so-called over-eager algorithm where it propagates\n@@ -942,7 +1042,14 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n    iterative algorithm by some margin overall.  \n    Note that this is slightly different from the traditional textbook worklist solver,\n    in that the worklist is effectively sorted by the reverse postorder.\n-   For CFGs with no nested loops, this is optimal.  */\n+   For CFGs with no nested loops, this is optimal. \n+   \n+   The overeager algorithm while works well for typical inputs,\n+   it could degenerate into excessive iterations given CFGs with high loop nests\n+   and unstructured loops. To cap the excessive iteration on such case,\n+   we switch to double-queueing when the original algorithm seems to \n+   get into such.\n+   */\n \n void \n df_worklist_dataflow (struct dataflow *dataflow,\n@@ -983,29 +1090,31 @@ df_worklist_dataflow (struct dataflow *dataflow,\n       bitmap_set_bit (pending, i);\n     }\n \n+  /* Initialize the problem. */\n   if (dataflow->problem->init_fun)\n     dataflow->problem->init_fun (blocks_to_consider);\n \n-  while (!bitmap_empty_p (pending))\n+  /* Solve it. Determine the solving algorithm\n+     based on a simple heuristic. */\n+  if (n_edges > PARAM_VALUE (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR)\n+      * n_basic_blocks)\n     {\n-      unsigned bb_index;\n-\n-      index = bitmap_first_set_bit (pending);\n-      bitmap_clear_bit (pending, index);\n-\n-      bb_index = blocks_in_postorder[index];\n-\n-      if (dir == DF_FORWARD)\n-        df_worklist_propagate_forward (dataflow, bb_index,\n-                                       bbindex_to_postorder,\n-                                       pending, considered);\n-      else \n-        df_worklist_propagate_backward (dataflow, bb_index,\n-                                        bbindex_to_postorder,\n-                                        pending, considered);\n+      /* High average connectivity, meaning dense graph\n+         with more likely deep nested loops\n+\t or unstructured loops. */\n+      df_worklist_dataflow_doublequeue (dataflow, pending, considered,\n+\t\t\t\t\tblocks_in_postorder,\n+\t\t\t\t\tbbindex_to_postorder);\n+    }\n+  else \n+    {\n+      /* Most inputs fall into this case\n+        with relatively flat or structured CFG. */\n+      df_worklist_dataflow_overeager (dataflow, pending, considered,\n+\t\t\t\t      blocks_in_postorder,\n+\t\t\t\t      bbindex_to_postorder);\n     }\n \n-  BITMAP_FREE (pending);\n   sbitmap_free (considered);\n   free (bbindex_to_postorder);\n }"}, {"sha": "0baff3d1d6106dd82fd18e9da0d7acd01c83413a", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/185082a7b82a6ca848ab81301d2638964a78b815/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/185082a7b82a6ca848ab81301d2638964a78b815/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=185082a7b82a6ca848ab81301d2638964a78b815", "patch": "@@ -724,6 +724,11 @@ DEFPARAM (PARAM_SCCVN_MAX_SCC_SIZE,\n \t  10000, 10, 0)\n \n \n+DEFPARAM (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR,\n+\t  \"df-double-queue-threshold-factor\",\n+\t  \"Multiplier used for determining the double-queueing threshold\",\n+\t  2, 0, 0)\n+\n /*\n Local variables:\n mode:c"}]}