{"sha": "284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg0ZDg2ZTlmMGMxNDBkOTUwMGYxZDkwN2QxYzFkNDgzYzRhNDBlZA==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-04-18T01:24:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-04-18T01:24:59Z"}, "message": "sparc.c, [...]: Many changes related to V9 code generation.\n\nSat Apr 18 01:23:11 1998  John Carr  <jfc@mit.edu>\n        * sparc.c, sparc.h, sparc.md, sol2.h: Many changes related to V9\n        code generation.  Use 64 bit instructions in 32 bit mode when\n        possible.  Use V9 return instruction.  UltraSPARC optimizations.\n        * sparc.h: Change gen_rtx (CODE to gen_rtx_CODE (.\n\nFrom-SVN: r19278", "tree": {"sha": "4c1a46be2073c826aee2bacd4601da897875c0df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c1a46be2073c826aee2bacd4601da897875c0df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f4c81730d81f5899761de6895da0c845153bc095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c81730d81f5899761de6895da0c845153bc095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4c81730d81f5899761de6895da0c845153bc095"}], "stats": {"total": 1674, "additions": 1088, "deletions": 586}, "files": [{"sha": "3100c60a769501ab56d55df18dee42b37748c08d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "patch": "@@ -1,3 +1,11 @@\n+Sat Apr 18 01:23:11 1998  John Carr  <jfc@mit.edu>\n+\n+\t* sparc.c, sparc.h, sparc.md, sol2.h: Many changes related to V9\n+\tcode generation.  Use 64 bit instructions in 32 bit mode when\n+\tpossible.  Use V9 return instruction.  UltraSPARC optimizations.\n+\n+        * sparc.h: Change gen_rtx (CODE to gen_rtx_CODE (.\n+\n Fri Apr 17 22:38:17 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* global.c (global_alloc): Don't pass HARD_CONST (0) to find_reg,"}, {"sha": "2c8c5f3f97bba8e5b42b4fc86b720e88600afc42", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "patch": "@@ -198,3 +198,9 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_LIVE_G0\t0\n #undef TARGET_BROKEN_SAVERESTORE\n #define TARGET_BROKEN_SAVERESTORE 0\n+\n+/* Solaris allows 64 bit out and global registers in 32 bit mode.\n+   sparc_override_options will disable V8+ if not generating V9 code.  */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU + MASK_V8PLUS)\n+"}, {"sha": "caebb088fa844df3a5e7fe11b0d63da3938f81fb", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 399, "deletions": 147, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "patch": "@@ -22,17 +22,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-#ifdef HAVE_STRING_H\n-#include <string.h>\n-#else\n-#ifdef HAVE_STRINGS_H\n-#include <strings.h>\n-#endif\n-#endif\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -208,11 +198,9 @@ sparc_override_options ()\n     { \"sparclet\",   PROCESSOR_SPARCLET, MASK_ISA, MASK_SPARCLET },\n     /* TEMIC sparclet */\n     { \"tsc701\",     PROCESSOR_TSC701, MASK_ISA, MASK_SPARCLET },\n-    /* \"v8plus\" is what Sun calls Solaris2.5 running on UltraSPARC's.  */\n-    { \"v8plus\",     PROCESSOR_V8PLUS, MASK_ISA, MASK_V8PLUS },\n     { \"v9\",         PROCESSOR_V9, MASK_ISA, MASK_V9 },\n     /* TI ultrasparc */\n-    { \"ultrasparc\", PROCESSOR_ULTRASPARC, MASK_ISA, MASK_V8PLUS },\n+    { \"ultrasparc\", PROCESSOR_ULTRASPARC, MASK_ISA, MASK_V9 },\n     { 0 }\n   };\n   struct cpu_table *cpu;\n@@ -288,6 +276,10 @@ sparc_override_options ()\n   if (TARGET_V9 && TARGET_ARCH32)\n     target_flags |= MASK_DEPRECATED_V8_INSNS;\n \n+  /* V8PLUS requires V9 */\n+  if (! TARGET_V9)\n+    target_flags &= ~MASK_V8PLUS;\n+\n   /* Validate -malign-loops= value, or provide default.  */\n   if (sparc_align_loops_string)\n     {\n@@ -333,40 +325,6 @@ sparc_override_options ()\n   sparc_init_modes ();\n }\n \f\n-/* Float conversions (v9 only).\n-\n-   The floating point registers cannot hold DImode values because SUBREG's\n-   on them get the wrong register.   \"(subreg:SI (reg:DI M int-reg) 0)\" is the\n-   same as \"(subreg:SI (reg:DI N float-reg) 1)\", but gcc doesn't know how to\n-   turn the \"0\" to a \"1\".  Therefore, we must explicitly do the conversions\n-   to/from int/fp regs.  `sparc64_fpconv_stack_slot' is the address of an\n-   8 byte stack slot used during the transfer.\n-   ??? I could have used [%fp-16] but I didn't want to add yet another\n-   dependence on this.  */\n-/* ??? Can we use assign_stack_temp here?  */\n-\n-static rtx fpconv_stack_temp;\n-\n-/* Called once for each function.  */\n-\n-void\n-sparc_init_expanders ()\n-{\n-  fpconv_stack_temp = NULL_RTX;\n-}\n-\n-/* Assign a stack temp for fp/int DImode conversions.  */\n-\n-rtx\n-sparc64_fpconv_stack_temp ()\n-{\n-  if (fpconv_stack_temp == NULL_RTX)\n-    fpconv_stack_temp =\n-      assign_stack_local (DImode, GET_MODE_SIZE (DImode), 0);\n-\n-  return fpconv_stack_temp;\n-}\n-\f\n /* Miscellaneous utilities.  */\n \n /* Nonzero if CODE, a comparison, is suitable for use in v9 conditional move\n@@ -380,6 +338,14 @@ v9_regcmp_p (code)\n \t  || code == LE || code == GT);\n }\n \n+/* 32 bit registers are zero extended so only zero/non-zero comparisons\n+   work.  */\n+int\n+v8plus_regcmp_p (code)\n+     enum rtx_code code;\n+{\n+  return (code == EQ || code == NE);\n+}\n \f\n /* Operand constraints.  */\n \n@@ -798,6 +764,16 @@ v9_regcmp_op (op, mode)\n   return v9_regcmp_p (code);\n }\n \n+int\n+v8plus_regcmp_op (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (code == EQ || code == NE);\n+}\n+\n /* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */\n \n int\n@@ -848,8 +824,13 @@ arith_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n+  int val;\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  val = INTVAL (op) & 0xffffffff;\n+  return SPARC_SIMM13_P (val);\n }\n \n /* Return true if OP is a register, or is a CONST_INT that can fit in a\n@@ -1059,8 +1040,15 @@ gen_compare_reg (code, x, y)\n   else\n     cc_reg = gen_rtx (REG, mode, SPARC_ICC_REG);\n \n-  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n-\t\t      gen_rtx (COMPARE, mode, x, y)));\n+  if (TARGET_V8PLUS && mode == CCXmode)\n+    {\n+      emit_insn (gen_cmpdi_v8plus (x, y));\n+    }\n+  else\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n+\t\t\t  gen_rtx (COMPARE, mode, x, y)));\n+    }\n \n   return cc_reg;\n }\n@@ -1287,14 +1275,53 @@ eligible_for_epilogue_delay (trial, slot)\n \t       || register_operand (XEXP (src, 1), DImode)))\n     return 1;\n \n-  /* This matches \"*return_subsi\".  */\n-  else if (GET_CODE (src) == MINUS\n-      && register_operand (XEXP (src, 0), SImode)\n-      && small_int (XEXP (src, 1), VOIDmode)\n-      && INTVAL (XEXP (src, 1)) != -4096)\n+  return 0;\n+}\n+\n+static int\n+check_return_regs (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      return IN_OR_GLOBAL_P (x);\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n     return 1;\n \n+    case SET:\n+    case IOR:\n+    case AND:\n+    case XOR:\n+    case PLUS:\n+    case MINUS:\n+      if (check_return_regs (XEXP (x, 1)) == 0)\n   return 0;\n+    case NOT:\n+    case NEG:\n+    case MEM:\n+      return check_return_regs (XEXP (x, 0));\n+      \n+    default:\n+      return 0;\n+    }\n+\n+}\n+\n+/* Return 1 if TRIAL references only in and global registers.  */\n+int\n+eligible_for_return_delay (trial)\n+     rtx trial;\n+{\n+  if (GET_CODE (PATTERN (trial)) != SET)\n+    return 0;\n+\n+  return check_return_regs (PATTERN (trial));\n }\n \n int\n@@ -1346,6 +1373,10 @@ reg_unused_after (reg, insn)\n /* The table we use to reference PIC data.  */\n static rtx global_offset_table;\n \n+/* The function we use to get at it.  */\n+static rtx get_pc_symbol;\n+static char get_pc_symbol_name[256];\n+\n /* Ensure that we are not using patterns that are not OK with PIC.  */\n \n int\n@@ -1499,61 +1530,11 @@ initialize_pic ()\n static rtx\n pic_setup_code ()\n {\n-  rtx pic_pc_rtx;\n-  rtx l1, l2;\n   rtx seq;\n \n   start_sequence ();\n-\n-  /* If -O0, show the PIC register remains live before this.  */\n-  if (obey_regdecls)\n-    emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n-    \n-  l1 = gen_label_rtx ();\n-\n-  pic_pc_rtx = gen_rtx (CONST, Pmode,\n-\t\t\tgen_rtx (MINUS, Pmode,\n-\t\t\t\t global_offset_table,\n-\t\t\t\t gen_rtx (CONST, Pmode,\n-\t\t\t\t\t  gen_rtx (MINUS, Pmode,\n-\t\t\t\t\t\t   gen_rtx (LABEL_REF,\n-\t\t\t\t\t\t\t    VOIDmode, l1),\n-\t\t\t\t\t\t   pc_rtx))));\n-\n-  /* sparc64: the RDPC instruction doesn't pair, and puts 4 bubbles in the\n-     pipe to boot.  So don't use it here, especially when we're\n-     doing a save anyway because of %l7.  */\n-\n-  l2 = gen_label_rtx ();\n-  emit_label (l1);\n-\n-  /* Iff we are doing delay branch optimization, slot the sethi up\n-     here so that it will fill the delay slot of the call.  */\n-  if (flag_delayed_branch)\n-    emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t\tgen_rtx (HIGH, Pmode, pic_pc_rtx)));\n-\n-  /* Note that we pun calls and jumps here!  */\n-  emit_jump_insn (gen_get_pc_via_call (l2, l1));\n-\n-  emit_label (l2);\n-\n-  if (!flag_delayed_branch)\n-    emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n-\t\t\tgen_rtx (HIGH, Pmode, pic_pc_rtx)));\n-\n-  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t      pic_offset_table_rtx,\n-\t\t      gen_rtx (LO_SUM, Pmode,\n-\t\t\t       pic_offset_table_rtx, pic_pc_rtx)));\n-  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t      pic_offset_table_rtx,\n-\t\t      gen_rtx (PLUS, Pmode,\n-\t\t\t       pic_offset_table_rtx,\n-\t\t\t       gen_rtx (REG, Pmode, 15))));\n-\n-  /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n-\n+  emit_insn (gen_get_pc (pic_offset_table_rtx, global_offset_table,\n+\t\t\t get_pc_symbol));\n   seq = gen_sequence ();\n   end_sequence ();\n \n@@ -1575,9 +1556,21 @@ finalize_pic ()\n   if (! flag_pic)\n     abort ();\n \n+  /* If we havn't emitted the special get_pc helper function, do so now.  */\n+  if (get_pc_symbol_name[0] == 0)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (get_pc_symbol_name, \"LGETPC\", 0);\n+\n+      text_section ();\n+      ASM_OUTPUT_ALIGN (asm_out_file, 3);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LGETPC\", 0);\n+      fputs (\"\\tretl\\n\\tadd %o7,%l7,%l7\\n\", asm_out_file);\n+    }\n+\n   /* Initialize every time through, since we can't easily\n      know this to be permanent.  */\n   global_offset_table = gen_rtx (SYMBOL_REF, Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  get_pc_symbol = gen_rtx (SYMBOL_REF, Pmode, get_pc_symbol_name);\n   flag_pic = 0;\n \n   emit_insn_after (pic_setup_code (), get_insns ());\n@@ -1618,6 +1611,15 @@ emit_move_sequence (operands, mode)\n   /* Handle most common case first: storing into a register.  */\n   if (register_operand (operand0, mode))\n     {\n+      /* Integer constant to FP register. */\n+      if (GET_CODE (operand0) == REG\n+\t  && REGNO (operand0) >= 32\n+\t  && REGNO (operand0) < FIRST_PSEUDO_REGISTER\n+\t  && CONSTANT_P (operand1))\n+\t{\n+\t  operand1 = validize_mem (force_const_mem (GET_MODE (operand0), operand1));\n+\t}\n+\n       if (register_operand (operand1, mode)\n \t  || (GET_CODE (operand1) == CONST_INT && SMALL_INT (operand1))\n \t  || (GET_CODE (operand1) == CONST_DOUBLE\n@@ -1683,6 +1685,7 @@ emit_move_sequence (operands, mode)\n \t}\n       else if (GET_CODE (operand1) == CONST_INT\n \t       ? (! SMALL_INT (operand1)\n+\t\t  && INTVAL (operand1) != -4096\n \t\t  && ! SPARC_SETHI_P (INTVAL (operand1)))\n \t       : GET_CODE (operand1) == CONST_DOUBLE\n \t       ? ! arith_double_operand (operand1, DImode)\n@@ -1704,16 +1707,20 @@ emit_move_sequence (operands, mode)\n \t  rtx temp = ((reload_in_progress || mode == DImode)\n \t\t      ? operand0 : gen_reg_rtx (mode));\n \n+\t  if (mode == SImode)\n+\t    {\n+\t      if (GET_CODE (operand1) == CONST_INT)\n+\t\toperand1 = GEN_INT (INTVAL (operand1) & 0xffffffff);\n+\t      else if (GET_CODE (operand1) == CONST_DOUBLE)\n+\t\toperand1 = GEN_INT (CONST_DOUBLE_LOW (operand1) & 0xffffffff);\n+\t    }\n+\n \t  if (TARGET_ARCH64 && mode == DImode)\n \t    emit_insn (gen_sethi_di_sp64 (temp, operand1));\n \t  else\n \t    emit_insn (gen_rtx (SET, VOIDmode, temp,\n \t\t\t\tgen_rtx (HIGH, mode, operand1)));\n \n-\t  if (GET_CODE (operand1) == CONST_INT)\n-\t    operand1 = GEN_INT (INTVAL (operand1) & 0xffffffff);\n-\t  else if (GET_CODE (operand1) == CONST_DOUBLE)\n-\t    operand1 = GEN_INT (CONST_DOUBLE_LOW (operand1) & 0xffffffff);\n \t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n \t}\n     }\n@@ -1763,10 +1770,16 @@ singlemove_string (operands)\n       else\n \treturn \"sethi %%hi(%a1),%0\";\n     }\n-  else if (GET_CODE (operands[1]) == CONST_INT\n-\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+  else if (GET_CODE (operands[1]) == CONST_INT)\n     {\n-      HOST_WIDE_INT i = INTVAL (operands[1]);\n+      /* Only consider the low 32 bits of the constant. */\n+      int i = INTVAL (operands[1]) & 0xffffffff;\n+\n+      if (SPARC_SIMM13_P (i))\n+\treturn \"mov %1,%0\";\n+\n+      if (i == 4096)\n+\treturn \"sub %%g0,-4096,%0\";\n \n       /* If all low order 10 bits are clear, then we only need a single\n \t sethi insn to load the constant.  */\n@@ -2291,9 +2304,9 @@ output_move_quad (operands)\n \t  operands[2] = adj_offsettable_operand (mem, 8);\n \t  /* ??? In arch64 case, shouldn't we use ldd/std for fp regs.  */\n \t  if (mem == op1)\n-\t    return TARGET_ARCH64 ? \"ldx %1,%0;ldx %2,%R0\" : \"ldd %1,%0;ldd %2,%S0\";\n+\t    return TARGET_ARCH64 ? \"ldx %1,%0\\n\\tldx %2,%R0\" : \"ldd %1,%0\\n\\tldd %2,%S0\";\n \t  else\n-\t    return TARGET_ARCH64 ? \"stx %1,%0;stx %R1,%2\" : \"std %1,%0;std %S1,%2\";\n+\t    return TARGET_ARCH64 ? \"stx %1,%0\\n\\tstx %R1,%2\" : \"std %1,%0\\n\\tstd %S1,%2\";\n \t}\n     }\n \n@@ -2968,13 +2981,10 @@ enum sparc_mode_class {\n /* Modes for double-float and smaller quantities.  */\n #define DF_MODES (S_MODES | D_MODES)\n \n-/* ??? Sparc64 fp regs cannot hold DImode values.  */\n-#define DF_MODES64 (SF_MODES | (1 << (int) DF_MODE) /* | (1 << (int) D_MODE)*/)\n+#define DF_MODES64 DF_MODES\n \n /* Modes for double-float only quantities.  */\n-/* ??? Sparc64 fp regs cannot hold DImode values.\n-   See fix_truncsfdi2.  */\n-#define DF_ONLY_MODES ((1 << (int) DF_MODE) /*| (1 << (int) D_MODE)*/)\n+#define DF_ONLY_MODES ((1 << (int) DF_MODE) | (1 << (int) D_MODE))\n \n /* Modes for double-float and larger quantities.  */\n #define DF_UP_MODES (DF_ONLY_MODES | TF_ONLY_MODES)\n@@ -2985,8 +2995,6 @@ enum sparc_mode_class {\n /* Modes for quad-float and smaller quantities.  */\n #define TF_MODES (DF_MODES | TF_ONLY_MODES)\n \n-/* ??? Sparc64 fp regs cannot hold DImode values.\n-   See fix_truncsfdi2.  */\n #define TF_MODES64 (DF_MODES64 | TF_ONLY_MODES)\n \n /* Modes for condition codes.  */\n@@ -3115,7 +3123,9 @@ sparc_init_modes ()\n   /* Initialize the array used by REGNO_REG_CLASS.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      if (i < 32)\n+      if (i < 16 && TARGET_V8PLUS)\n+\tsparc_regno_reg_class[i] = I64_REGS;\n+      else if (i < 32)\n \tsparc_regno_reg_class[i] = GENERAL_REGS;\n       else if (i < 64)\n \tsparc_regno_reg_class[i] = FP_REGS;\n@@ -3584,6 +3594,8 @@ output_function_epilogue (file, size, leaf_function)\n \t\t\t\t\t\t   PATTERN (insn)));\n \t      final_scan_insn (insn, file, 1, 0, 1);\n \t    }\n+\t  else if (TARGET_V9 && ! SKIP_CALLERS_UNIMP_P)\n+\t    fputs (\"\\treturn %i7+8\\n\\tnop\\n\", file);\n \t  else\n \t    fprintf (file, \"\\t%s\\n\\trestore\\n\", ret);\n \t}\n@@ -4566,22 +4578,77 @@ output_v9branch (op, reg, label, reversed, annul, noop)\n   return string;\n }\n \n-/* Output assembler code to return from a function.  */\n+/* Renumber registers in delay slot.  Replace registers instead of\n+   renumbering because they may be shared.\n \n-/* ??? v9: Update to use the new `return' instruction.  Also, add patterns to\n-   md file for the `return' instruction.  */\n+   This does not handle instructions other than move.  */\n+\n+static void\n+epilogue_renumber (where)\n+     rtx *where;\n+{\n+  rtx x = *where;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      *where = x = copy_rtx (x);\n+      epilogue_renumber (&XEXP (x, 0));\n+      return;\n+\n+    case REG:\n+      {\n+\tint regno = REGNO (x);\n+\tif (regno > 8 && regno < 24)\n+\t  abort ();\n+\tif (regno >= 24 && regno < 32)\n+\t  *where = gen_rtx_REG (GET_MODE (x), regno - 16);\n+\treturn;\n+      }\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return;\n+\n+    case IOR:\n+    case AND:\n+    case XOR:\n+    case PLUS:\n+    case MINUS:\n+      epilogue_renumber (&XEXP (x, 1));\n+    case NEG:\n+    case NOT:\n+      epilogue_renumber (&XEXP (x, 0));\n+      return;\n+\n+    default:\n+      debug_rtx (*where);\n+      abort();\n+    }\n+}\n+\n+/* Output assembler code to return from a function.  */\n \n char *\n output_return (operands)\n      rtx *operands;\n {\n+  rtx delay = final_sequence ? XVECEXP (final_sequence, 0, 1) : 0;\n+\n   if (leaf_label)\n     {\n       operands[0] = leaf_label;\n-      return \"b,a %l0\";\n+      return \"b%* %l0%(\";\n     }\n   else if (leaf_function)\n     {\n+      /* No delay slot in a leaf function.  */\n+      if (delay)\n+\tabort ();\n+\n       /* If we didn't allocate a frame pointer for the current function,\n \t the stack pointer might have been adjusted.  Output code to\n \t restore it now.  */\n@@ -4621,8 +4688,22 @@ output_return (operands)\n \t    return \"sethi %%hi(%a0),%%g1\\n\\tretl\\n\\tadd %%sp,%%g1,%%sp\";\n \t}\n     }\n+  else if (TARGET_V9)\n+    {\n+      if (delay)\n+\t{\n+\t  epilogue_renumber (&SET_DEST (PATTERN (delay)));\n+\t  epilogue_renumber (&SET_SRC (PATTERN (delay)));\n+\t}\n+      if (SKIP_CALLERS_UNIMP_P)\n+\treturn \"return %%i7+12%#\";\n+      else\n+\treturn \"return %%i7+8%#\";\n+    }\n   else\n     {\n+      if (delay)\n+\tabort ();\n       if (SKIP_CALLERS_UNIMP_P)\n \treturn \"jmp %%i7+12\\n\\trestore\";\n       else\n@@ -4795,14 +4876,14 @@ print_operand (file, x, code)\n       /* On UltraSPARC, a branch in a delay slot causes a pipeline flush.\n \t Always emit a nop in case the next instruction is a branch.  */\n       if (dbr_sequence_length () == 0\n-\t  && (optimize && (int)sparc_cpu < PROCESSOR_V8PLUS))\n+\t  && (optimize && (int)sparc_cpu < PROCESSOR_V9))\n \tfputs (\",a\", file);\n       return;\n     case '(':\n       /* Output a 'nop' if there's nothing for the delay slot and we are\n \t not optimizing.  This is always used with '*' above.  */\n       if (dbr_sequence_length () == 0\n-\t  && ! (optimize && (int)sparc_cpu < PROCESSOR_V8PLUS))\n+\t  && ! (optimize && (int)sparc_cpu < PROCESSOR_V9))\n \tfputs (\"\\n\\tnop\", file);\n       return;\n     case '_':\n@@ -6066,7 +6147,8 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n   dep_type = get_attr_type (dep_insn);                  \n \n #define SLOW_FP(dep_type) \\\n-(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)   \n+(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)\n+\n   switch (REG_NOTE_KIND (link))\n     {                                              \n     case 0:                                        \n@@ -6080,16 +6162,16 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n \tcase TYPE_FPSTORE:\n \t  if (! SLOW_FP (dep_type))        \n \t    return 0;                                     \n-\t  break;\n+\t  return cost;\n \n \tcase TYPE_STORE:                                  \n \t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n \t    return cost;     \n \n+\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n \t  /* The dependency between the two instructions is on the data\n \t     that is being stored.  Assume that the address of the store\n \t     is not also dependent.  */\n-\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n \t    return 0;                                \n \t  return cost;                                   \n \n@@ -6109,15 +6191,15 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n \t\t compensate for a dependency which might not really    \n \t\t exist, and 0.  */                                      \n \t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n-\t\t  || GET_CODE (SET_DEST (pat)) != MEM         \n-\t\t  || GET_CODE (SET_SRC (dep_pat)) != MEM\n-\t\t  || ! rtx_equal_p (XEXP (SET_DEST (pat), 0),\n-\t\t\t\t    XEXP (SET_SRC (dep_pat), 0)))\n+\t\t  || GET_CODE (SET_SRC (pat)) != MEM\n+\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM\n+\t\t  || ! rtx_equal_p (XEXP (SET_SRC (pat), 0),\n+\t\t\t\t    XEXP (SET_DEST (dep_pat), 0)))\n \t\treturn cost + 2;\n \n \t      return cost + 8;         \n \t    }                                                                   \n-\t  break;                                                                \n+\t  return cost;\n \n \tcase TYPE_BRANCH:                                  \n \t  /* Compare to branch latency is 0.  There is no benefit from\n@@ -6128,16 +6210,15 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n \t     compare to conditional move.  */                        \n \t  if (dep_type == TYPE_FPCMP)                             \n \t    return cost - 1;                                           \n-\t  break;                                                        \n+\t  return cost;\n \n \tcase TYPE_FPCMOVE:                                    \n \t  /* FMOVR class instructions can not issue in the same cycle\n \t     or the cycle after an instruction which writes any\n \t     integer register.  Model this as cost 2 for dependent\n \t     instructions.  */  \n-\t  if (GET_CODE (PATTERN (insn)) == SET\n-\t      && (GET_MODE (SET_DEST (PATTERN (insn))) == SFmode\n-\t          || GET_MODE (SET_DEST (PATTERN (insn))) == DFmode)            \n+\t  if ((dep_type == TYPE_IALU || dep_type == TYPE_UNARY\n+\t       || dep_type == TYPE_BINARY)\n \t      && cost < 2)                                                      \n \t    return 2;\n \t  /* Otherwise check as for integer conditional moves. */\n@@ -6149,7 +6230,7 @@ ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n \t     to model.  */                        \n \t  if (dep_type == TYPE_LOAD || dep_type == TYPE_SLOAD)                  \n \t    return cost + 3;                                           \n-\t  break;                                                        \n+\t  return cost;\n \n \tdefault:\n \t  break;\n@@ -6190,13 +6271,184 @@ sparc_issue_rate ()\n     {\n     default:                                 \n       return 1;                                                    \n-    case PROCESSOR_V8PLUS:                                         \n     case PROCESSOR_V9:                                                \n-      /* Assume these generic V9 types are capable of at least dual-issue.  */\n+      /* Assume V9 processors are capable of at least dual-issue.  */\n       return 2;\n     case PROCESSOR_SUPERSPARC:                                        \n       return 3;                                                      \n     case PROCESSOR_ULTRASPARC:                                            \n       return 4;                                                    \n     }\n }\n+\n+static int\n+set_extends(x, insn)\n+     rtx x, insn;\n+{\n+  register rtx pat = PATTERN (insn);\n+\n+  switch (GET_CODE (SET_SRC (pat)))\n+    {\n+      /* Load and some shift instructions zero extend. */\n+    case MEM:\n+    case ZERO_EXTEND:\n+      /* sethi clears the high bits */\n+    case HIGH:\n+      /* LO_SUM is used with sethi.  sethi cleared the high\n+\t bits and the values used with lo_sum are positive */\n+    case LO_SUM:\n+      /* UNSPEC is v8plus_clear_high */\n+    case UNSPEC:\n+      /* Store flag stores 0 or 1 */\n+    case LT: case LTU:\n+    case GT: case GTU:\n+    case LE: case LEU:\n+    case GE: case GEU:\n+    case EQ:\n+    case NE:\n+      return 1;\n+    case AND:\n+      {\n+\trtx op1 = XEXP (SET_SRC (pat), 1);\n+\tif (GET_CODE (op1) == CONST_INT)\n+\t  return INTVAL (op1) >= 0;\n+\tif (GET_CODE (XEXP (SET_SRC (pat), 0)) == REG\n+\t    && sparc_check_64 (XEXP (SET_SRC (pat), 0), insn) == 1)\n+\t  return 1;\n+\tif (GET_CODE (op1) == REG\n+\t    && sparc_check_64 ((op1), insn) == 1)\n+\t  return 1;\n+      }\n+    case ASHIFT:\n+    case LSHIFTRT:\n+      return GET_MODE (SET_SRC (pat)) == SImode;\n+      /* Positive integers leave the high bits zero. */\n+    case CONST_DOUBLE:\n+      return ! (CONST_DOUBLE_LOW (x) & 0x80000000);\n+    case CONST_INT:\n+      return ! (INTVAL (x) & 0x80000000);\n+    case ASHIFTRT:\n+    case SIGN_EXTEND:\n+      return - (GET_MODE (SET_SRC (pat)) == SImode);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 0 if the high 32 bits of X (the low word of X, if DImode) are\n+   unknown.  Return 1 if the high bits are zero, -1 if the register is\n+   sign extended.  */\n+int\n+sparc_check_64 (x, insn)\n+     rtx x, insn;\n+{\n+  /* If a register is set only once it is safe to ignore insns this\n+     code does not know how to handle.  The loop will either recognize\n+     the single set and return the correct value or fail to recognize\n+     it and return 0.  */\n+  int set_once = 0;\n+\n+  if (GET_CODE (x) == REG\n+      && flag_expensive_optimizations\n+      && REG_N_SETS (REGNO (x)) == 1)\n+    set_once = 1;\n+\n+  if (insn == 0)\n+    if (set_once)\n+      insn = get_last_insn_anywhere ();\n+    else\n+      return 0;\n+\n+  while (insn = PREV_INSN (insn))\n+    {\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase JUMP_INSN:\n+\tcase NOTE:\n+\t  break;\n+\tcase CODE_LABEL:\n+\tcase CALL_INSN:\n+\tdefault:\n+\t  if (! set_once)\n+\t    return 0;\n+\t  break;\n+\tcase INSN:\n+\t  {\n+\t    rtx pat = PATTERN (insn);\n+\t    if (GET_CODE (pat) != SET)\n+\t      return 0;\n+\t    if (rtx_equal_p (x, SET_DEST (pat)))\n+\t      return set_extends (x, insn);\n+\t    if (reg_overlap_mentioned_p (SET_DEST (pat), x))\n+\t      return 0;\n+\t  }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+char *\n+sparc_v8plus_shift (operands, insn, opcode)\n+     rtx *operands;\n+     rtx insn;\n+     char *opcode;\n+{\n+  static char asm_code[60];\n+\n+  if (GET_CODE (operands[3]) == SCRATCH)\n+    operands[3] = operands[0];\n+  output_asm_insn (\"sllx %H1,32,%3\", operands);\n+  if (sparc_check_64 (operands[1], insn) <= 0)\n+    output_asm_insn (\"srl %L1,0,%L1\", operands);\n+  output_asm_insn (\"or %L1,%3,%3\", operands);\n+\n+  strcpy(asm_code, opcode);\n+  if (which_alternative != 2)\n+    return strcat (asm_code, \" %0,%2,%L0\\n\\tsrlx %L0,32,%H0\");\n+  else\n+    return strcat (asm_code, \" %3,%2,%3\\n\\tsrlx %3,32,%H0\\n\\tmov %3,%L0\");\n+}\n+\n+\n+/* Return 1 if DEST and SRC reference only global and in registers. */\n+\n+int\n+sparc_return_peephole_ok (dest, src)\n+     rtx dest, src;\n+{\n+  if (! TARGET_V9)\n+    return 0;\n+  if (leaf_function)\n+    return 0;\n+  if (GET_CODE (src) != CONST_INT\n+      && (GET_CODE (src) != REG || ! IN_OR_GLOBAL_P (src)))\n+    return 0;\n+  return IN_OR_GLOBAL_P (dest);\n+}\n+\n+int\n+delay_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+    case CONST_INT:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+\n+    case MEM:\n+      return delay_operand (XEXP (op, 0), Pmode);\n+\n+    case REG:\n+      return IN_OR_GLOBAL_P (op);\n+\n+    case PLUS:\n+      return delay_operand (XEXP (op, 0), Pmode) && delay_operand (XEXP (op, 1), Pmode);\n+\n+    default:\n+      return 0;\n+    }\n+}"}, {"sha": "c573f40d20a4803bb7dc8b325dec75fa767d0cf5", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 101, "deletions": 87, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "patch": "@@ -158,7 +158,6 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mcpu=f930:-D__sparclite__} %{mcpu=f934:-D__sparclite__} \\\n %{mcpu=v8:-D__sparc_v8__} \\\n %{mcpu=supersparc:-D__supersparc__ -D__sparc_v8__} \\\n-%{mcpu=v8plus:-D__sparc_v9__} \\\n %{mcpu=v9:-D__sparc_v9__} \\\n %{mcpu=ultrasparc:-D__sparc_v9__} \\\n %{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(cpp_cpu_default)}}}}}}} \\\n@@ -209,9 +208,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{mf930:-Asparclite} %{mf934:-Asparclite} \\\n %{mcpu=sparclite:-Asparclite} \\\n %{mcpu=f930:-Asparclite} %{mcpu=f934:-Asparclite} \\\n-%{mcpu=v8plus:-Av8plus} \\\n+%{mv8plus:-Av8plus} \\\n %{mcpu=v9:-Av9} \\\n-%{mcpu=ultrasparc:-Av9a} \\\n+%{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \\\n %{!mcpu*:%{!mcypress:%{!msparclite:%{!mf930:%{!mf934:%{!mv8:%{!msupersparc:%(asm_cpu_default)}}}}}}} \\\n \"\n \n@@ -453,13 +452,17 @@ extern int target_flags;\n #define MASK_VIS 0x1000000          \n #define TARGET_VIS (target_flags & MASK_VIS)\n \n-/* Compile for Solaris V8+.  64 bit instructions are available but the\n-   high 32 bits of all registers except the globals and current outs may\n-   be cleared at any time.  */                 \n+/* Compile for Solaris V8+.  32 bit Solaris preserves the high bits of\n+   the current out and global registers.  Linux saves the high bits on\n+   context switches but not signals.  */\n #define MASK_V8PLUS 0x2000000                 \n #define TARGET_V8PLUS (target_flags & MASK_V8PLUS)                            \n \n-/* See sparc.md */\n+/* TARGET_HARD_MUL: Use hardware multiply instructions but not %y.\n+   TARGET_HARD_MUL32: Use hardware multiply instructions with rd %y\n+   to get high 32 bits.  False in V8+ or V9 because multiply stores\n+   a 64 bit result in a register.  */\n+\n #define TARGET_HARD_MUL32\t\t\t\t\\\n   ((TARGET_V8 || TARGET_SPARCLITE\t\t\t\\\n     || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS)\t\\\n@@ -495,14 +498,15 @@ extern int target_flags;\n     {\"no-app-regs\", -MASK_APP_REGS},\t\\\n     {\"hard-quad-float\", MASK_HARD_QUAD}, \\\n     {\"soft-quad-float\", -MASK_HARD_QUAD}, \\\n+    {\"v8plus\", MASK_V8PLUS},\t\t\\\n+    {\"no-v8plus\", -MASK_V8PLUS},\t\\\n     {\"vis\", MASK_VIS},\t\t\t\\\n     /* ??? These are deprecated, coerced to -mcpu=.  Delete in 2.9.  */ \\\n     {\"cypress\", 0},\t\t\t\\\n     {\"sparclite\", 0},\t\t\t\\\n     {\"f930\", 0},\t\t\t\\\n     {\"f934\", 0},\t\t\t\\\n     {\"v8\", 0},\t\t\t\t\\\n-    {\"v8plus\", 0},\t\t\t\\\n     {\"supersparc\", 0},\t\t\t\\\n     /* End of deprecated options.  */\t\\\n     /* -mptrNN exists for *experimental* purposes.  */ \\\n@@ -535,7 +539,6 @@ enum processor_type {\n   PROCESSOR_F934,\n   PROCESSOR_SPARCLET,\n   PROCESSOR_TSC701,\n-  PROCESSOR_V8PLUS,\n   PROCESSOR_V9,\n   PROCESSOR_ULTRASPARC\n };\n@@ -977,6 +980,12 @@ while (0)\n        : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n+/* A subreg in 64 bit mode will have the wrong offset for a floating point\n+   register.  The least significant part is at offset 1, compared to 0 for\n+   integer registers.  */\n+#define ALTER_HARD_SUBREG(TMODE, WORD, FMODE, REGNO)\t\t\t\\\n+     (TARGET_ARCH64 && (REGNO) >= 32 && (REGNO) < 96 && (TMODE) == SImode ? 1 : ((REGNO) + (WORD)))\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    See sparc.c for how we initialize this.  */\n extern int *hard_regno_mode_classes;\n@@ -1093,14 +1102,14 @@ extern int sparc_mode_class[];\n #define STRUCT_VALUE \\\n   (TARGET_ARCH64\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\\\n-   : gen_rtx (MEM, Pmode,\t\t\t\t\\\n-\t      gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\\\n+   : gen_rtx_MEM (Pmode,\t\t\t\t\\\n+\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx, \\\n \t\t       GEN_INT (STRUCT_VALUE_OFFSET))))\n #define STRUCT_VALUE_INCOMING \\\n   (TARGET_ARCH64\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\\\n-   : gen_rtx (MEM, Pmode,\t\t\t\t\\\n-\t      gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n+   : gen_rtx_MEM (Pmode,\t\t\t\t\\\n+\t\t  gen_rtx_PLUS (Pmode, frame_pointer_rtx, \\\n \t\t       GEN_INT (STRUCT_VALUE_OFFSET))))\n \f\n /* Define the classes of registers for register constraints in the\n@@ -1157,24 +1166,25 @@ extern int sparc_mode_class[];\n    ??? Should %fcc[0123] be handled similarly?\n */\n \n-enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n-\t\t GENERAL_OR_FP_REGS, GENERAL_OR_EXTRA_FP_REGS,\n+enum reg_class { NO_REGS, FPCC_REGS, I64_REGS, GENERAL_REGS, FP_REGS,\n+\t\t EXTRA_FP_REGS, GENERAL_OR_FP_REGS, GENERAL_OR_EXTRA_FP_REGS,\n \t\t ALL_REGS, LIM_REG_CLASSES };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n-  { \"NO_REGS\", \"FPCC_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"EXTRA_FP_REGS\", \\\n-    \"GENERAL_OR_FP_REGS\", \"GENERAL_OR_EXTRA_FP_REGS\", \"ALL_REGS\" }\n+  { \"NO_REGS\", \"FPCC_REGS\", \"I64_REGS\", \"GENERAL_REGS\", \"FP_REGS\",\t\\\n+     \"EXTRA_FP_REGS\", \"GENERAL_OR_FP_REGS\", \"GENERAL_OR_EXTRA_FP_REGS\",\t\\\n+     \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS \\\n-  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, \\\n+  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {0xffff, 0, 0, 0}, \\\n    {-1, 0, 0, 0}, {0, -1, 0, 0}, {0, -1, -1, 0}, \\\n    {-1, -1, 0, 0}, {-1, -1, -1, 0}, {-1, -1, -1, 0x1f}}\n \n@@ -1266,15 +1276,18 @@ extern char leaf_reg_remap[];\n /* Get reg_class from a letter such as appears in the machine description.\n    In the not-v9 case, coerce v9's 'e' class to 'f', so we can use 'e' in the\n    .md file for v8 and v9.\n-   Use 'd' and 'b' for single precision VIS operations if TARGET_VIS.  */\n+   'd' and 'b' are used for single and double precision VIS operations,\n+   if TARGET_VIS.\n+   'h' is used for V8+ 64 bit global and out registers. */\n \n #define REG_CLASS_FROM_LETTER(C)\t\t\\\n (TARGET_V9\t\t\t\t\t\\\n  ? ((C) == 'f' ? FP_REGS\t\t\t\\\n     : (C) == 'e' ? EXTRA_FP_REGS \t\t\\\n     : (C) == 'c' ? FPCC_REGS\t\t\t\\\n-    : ((C) == 'd' && TARGET_VIS) ? FP_REGS\t\\\n-    : ((C) == 'b' && TARGET_VIS) ? FP_REGS\t\\\n+    : ((C) == 'd' && TARGET_VIS) ? FP_REGS\\\n+    : ((C) == 'b' && TARGET_VIS) ? EXTRA_FP_REGS\\\n+    : ((C) == 'h' && TARGET_V8PLUS) ? I64_REGS\\\n     : NO_REGS)\t\t\t\t\t\\\n  : ((C) == 'f' ? FP_REGS\t\t\t\\\n     : (C) == 'e' ? FP_REGS\t\t\t\\\n@@ -1299,6 +1312,8 @@ extern char leaf_reg_remap[];\n /* 10 and 11 bit immediates are only used for a few specific insns.\n    SMALL_INT is used throughout the port so we continue to use it.  */\n #define SMALL_INT(X) (SPARC_SIMM13_P (INTVAL (X)))\n+/* 13 bit immediate, considering only the low 32 bits */\n+#define SMALL_INT32(X) (SPARC_SIMM13_P ((int)INTVAL (X) & 0xffffffff))\n #define SPARC_SETHI_P(X) \\\n (((unsigned HOST_WIDE_INT) (X) & ~(unsigned HOST_WIDE_INT) 0xfffffc00) == 0)\n \n@@ -1366,7 +1381,7 @@ extern char leaf_reg_remap[];\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n   (get_frame_size () == 0\t\t\t\t\t\t\\\n    ? assign_stack_local (MODE, GET_MODE_SIZE (MODE), 0)\t\t\t\\\n-   : gen_rtx (MEM, MODE, gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n+   : gen_rtx_MEM (MODE, gen_rtx_PLUS (Pmode, frame_pointer_rtx,\t\\\n \t\t\t\t  GEN_INT (STARTING_FRAME_OFFSET))))\n \n /* Get_secondary_mem widens it's argument to BITS_PER_WORD which loses on v9\n@@ -1501,18 +1516,18 @@ extern char leaf_reg_remap[];\n /* On SPARC the value is found in the first \"output\" register.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n \n /* But the called function leaves it in the first \"input\" register.  */\n \n #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_OUTGOING_VALUE_REG (TYPE_MODE (VALTYPE)))\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), BASE_OUTGOING_VALUE_REG (TYPE_MODE (VALTYPE)))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE)\t\\\n-  gen_rtx (REG, MODE, BASE_RETURN_VALUE_REG (MODE))\n+  gen_rtx_REG (MODE, BASE_RETURN_VALUE_REG (MODE))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.\n@@ -1615,7 +1630,7 @@ function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n    to pad out an argument with extra space.  The value should be of type\n    `enum direction': either `upward' to pad above the argument,\n    `downward' to pad below, or `none' to inhibit padding.  */\n-extern enum direction function_arg_padding ();\n+\n #define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n function_arg_padding ((MODE), (TYPE))\n \n@@ -1630,17 +1645,6 @@ function_arg_padding ((MODE), (TYPE))\n       || ((TYPE) && TYPE_ALIGN (TYPE) == 128)))\t\\\n  ? 128 : PARM_BOUNDARY)\n \f\n-/* Initialize data used by insn expanders.  This is called from\n-   init_emit, once for each function, before code is generated.\n-   For v9, clear the temp slot used by float/int DImode conversions.\n-   ??? There is the 16 bytes at [%fp-16], however we'd like to delete this\n-   space at some point.\n-   ??? Use assign_stack_temp?  */\n-\n-extern void sparc_init_expanders ();\n-extern struct rtx_def *sparc64_fpconv_stack_temp ();\n-#define INIT_EXPANDERS sparc_init_expanders ()\n-\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n@@ -1691,8 +1695,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n extern int leaf_function;\n #define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-  (TARGET_FLAT ? sparc_flat_output_function_prologue (FILE, SIZE) \\\n-   : output_function_prologue (FILE, SIZE, leaf_function))\n+  (TARGET_FLAT ? sparc_flat_output_function_prologue (FILE, (int)SIZE) \\\n+   : output_function_prologue (FILE, (int)SIZE, leaf_function))\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.\n@@ -2070,8 +2074,8 @@ extern int current_function_outgoing_args_size;\n extern union tree_node *current_function_decl;\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-  (TARGET_FLAT ? sparc_flat_output_function_epilogue (FILE, SIZE) \\\n-   : output_function_epilogue (FILE, SIZE, leaf_function))\n+  (TARGET_FLAT ? sparc_flat_output_function_epilogue (FILE, (int)SIZE) \\\n+   : output_function_epilogue (FILE, (int)SIZE, leaf_function))\n \n #define DELAY_SLOTS_FOR_EPILOGUE \\\n   (TARGET_FLAT ? sparc_flat_epilogue_delay_slots () : 1)\n@@ -2120,11 +2124,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n-      ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n-      ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n+      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n+      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n+      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n       ASM_OUTPUT_INT (FILE, GEN_INT (0x81C04000));\t\\\n-      ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n+      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n@@ -2175,7 +2179,7 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    that holds the dynamic chain--the previous frame's address.\n    ??? -mflat support? */\n #define DYNAMIC_CHAIN_ADDRESS(frame) \\\n-  gen_rtx (PLUS, Pmode, frame, GEN_INT (14 * UNITS_PER_WORD))\n+  gen_rtx_PLUS (Pmode, frame, GEN_INT (14 * UNITS_PER_WORD))\n \n /* The return address isn't on the stack, it is in a register, so we can't\n    access it from the current frame pointer.  We can access it from the\n@@ -2194,16 +2198,16 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    returns, and +12 for structure returns.  */\n #define RETURN_ADDR_RTX(count, frame)\t\t\\\n   ((count == -1)\t\t\t\t\\\n-   ? gen_rtx (REG, Pmode, 31)\t\t\t\\\n-   : gen_rtx (MEM, Pmode,\t\t\t\\\n+   ? gen_rtx_REG (Pmode, 31)\t\t\t\\\n+   : gen_rtx_MEM (Pmode,\t\t\t\\\n \t      memory_address (Pmode, plus_constant (frame, 15 * UNITS_PER_WORD))))\n \n /* Before the prologue, the return address is %o7 + 8.  OK, sometimes it's\n    +12, but always using +8 is close enough for frame unwind purposes.\n    Actually, just using %o7 is close enough for unwinding, but %o7+8\n    is something you can return to.  */\n #define INCOMING_RETURN_ADDR_RTX \\\n-  gen_rtx (PLUS, word_mode, gen_rtx (REG, word_mode, 15), GEN_INT (8))\n+  gen_rtx_PLUS (word_mode, gen_rtx_REG (word_mode, 15), GEN_INT (8))\n \n /* The offset from the incoming value of %sp to the top of the stack frame\n    for the current function.  On sparc64, we have to account for the stack\n@@ -2250,6 +2254,9 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n /* 1 if X is an fp register.  */\n \n #define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\n+/* Is X, a REG, an in or global register?  i.e. is regno 0..7 or 24..31 */\n+#define IN_OR_GLOBAL_P(X) (REGNO (X) < 8 || (REGNO (X) >= 24 && REGNO (X) <= 31))\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -2439,30 +2446,30 @@ extern struct rtx_def *legitimize_pic_address ();\n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n { rtx sparc_x = (X);\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 1),\t\t\t\\\n+    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),\t\t\t\\\n \t\t   force_operand (XEXP (X, 0), NULL_RTX));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n+    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n \t\t   force_operand (XEXP (X, 1), NULL_RTX));\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n-    (X) = gen_rtx (PLUS, Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n+    (X) = gen_rtx_PLUS (Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n \t\t   XEXP (X, 1));\t\t\t\t\\\n   if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n-    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n+    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n \t\t   force_operand (XEXP (X, 1), NULL_RTX));\t\\\n   if (sparc_x != (X) && memory_address_p (MODE, X))\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\\\n   if (flag_pic) (X) = legitimize_pic_address (X, MODE, 0);\t\\\n   else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n+    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n \t\t   copy_to_mode_reg (Pmode, XEXP (X, 1)));\t\\\n   else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 1),\t\t\t\\\n+    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),\t\t\t\\\n \t\t   copy_to_mode_reg (Pmode, XEXP (X, 0)));\t\\\n   else if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n \t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n-    (X) = gen_rtx (LO_SUM, Pmode,\t\t\t\t\\\n-\t\t   copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode, X)), X); \\\n+    (X) = gen_rtx_LO_SUM (Pmode,\t\t\t\t\\\n+\t\t\t  copy_to_mode_reg (Pmode, gen_rtx_HIGH (Pmode, X)), X); \\\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN; }\n \n@@ -2512,7 +2519,7 @@ extern struct rtx_def *legitimize_pic_address ();\n \n /* This is how to refer to the variable errno.  */\n #define GEN_ERRNO_RTX \\\n-  gen_rtx (MEM, SImode, gen_rtx (SYMBOL_REF, Pmode, \"errno\"))\n+  gen_rtx_MEM (SImode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"))\n #endif /* 0 */\n \n /* Define if operations between registers always perform the operation\n@@ -2585,7 +2592,7 @@ extern struct rtx_def *legitimize_pic_address ();\n    : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\t\\\n        || GET_CODE (X) == NEG || GET_CODE (X) == ASHIFT)\t\t\\\n       ? (TARGET_ARCH64 && GET_MODE (X) == DImode ? CCX_NOOVmode : CC_NOOVmode) \\\n-      : (TARGET_ARCH64 && GET_MODE (X) == DImode ? CCXmode : CCmode)))\n+      : ((TARGET_ARCH64 || TARGET_V8PLUS) && GET_MODE (X) == DImode ? CCXmode : CCmode)))\n \n /* Return non-zero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n@@ -2645,32 +2652,32 @@ extern struct rtx_def *legitimize_pic_address ();\n #define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     add_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, ADDTF3_LIBCALL);\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, ADDTF3_LIBCALL);\t\t\t\\\n     sub_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, SUBTF3_LIBCALL);\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, SUBTF3_LIBCALL);\t\t\t\\\n     neg_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, NEGTF2_LIBCALL);\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, NEGTF2_LIBCALL);\t\t\t\\\n     smul_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, MULTF3_LIBCALL);\t\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, MULTF3_LIBCALL);\t\t\t\\\n     flodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, DIVTF3_LIBCALL);\t\t\t\\\n-    eqtf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, EQTF2_LIBCALL);\t\t\\\n-    netf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, NETF2_LIBCALL);\t\t\\\n-    gttf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, GTTF2_LIBCALL);\t\t\\\n-    getf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, GETF2_LIBCALL);\t\t\\\n-    lttf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, LTTF2_LIBCALL);\t\t\\\n-    letf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, LETF2_LIBCALL);\t\t\\\n-    trunctfsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, TRUNCTFSF2_LIBCALL);   \\\n-    trunctfdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, TRUNCTFDF2_LIBCALL);   \\\n-    extendsftf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, EXTENDSFTF2_LIBCALL); \\\n-    extenddftf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, EXTENDDFTF2_LIBCALL); \\\n-    floatsitf_libfunc = gen_rtx (SYMBOL_REF, Pmode, FLOATSITF2_LIBCALL);    \\\n-    fixtfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, FIX_TRUNCTFSI2_LIBCALL);  \\\n+      = gen_rtx_SYMBOL_REF (Pmode, DIVTF3_LIBCALL);\t\t\t\\\n+    eqtf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EQTF2_LIBCALL);\t\t\\\n+    netf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, NETF2_LIBCALL);\t\t\\\n+    gttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, GTTF2_LIBCALL);\t\t\\\n+    getf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, GETF2_LIBCALL);\t\t\\\n+    lttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, LTTF2_LIBCALL);\t\t\\\n+    letf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, LETF2_LIBCALL);\t\t\\\n+    trunctfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, TRUNCTFSF2_LIBCALL);   \\\n+    trunctfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, TRUNCTFDF2_LIBCALL);   \\\n+    extendsftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EXTENDSFTF2_LIBCALL); \\\n+    extenddftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, EXTENDDFTF2_LIBCALL); \\\n+    floatsitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, FLOATSITF2_LIBCALL);    \\\n+    fixtfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, FIX_TRUNCTFSI2_LIBCALL);  \\\n     fixunstfsi_libfunc\t\t\t\t\t\t\t\\\n-      = gen_rtx (SYMBOL_REF, Pmode, FIXUNS_TRUNCTFSI2_LIBCALL);\t\t\\\n+      = gen_rtx_SYMBOL_REF (Pmode, FIXUNS_TRUNCTFSI2_LIBCALL);\t\t\\\n     if (TARGET_FPU)\t\t\t\t\t\t\t\\\n       sqrt_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n-\t= gen_rtx (SYMBOL_REF, Pmode, \"_Q_sqrt\");\t\t\t\\\n+\t= gen_rtx_SYMBOL_REF (Pmode, \"_Q_sqrt\");\t\t\t\\\n     INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n   } while (0)\n \n@@ -2709,12 +2716,12 @@ extern struct rtx_def *legitimize_pic_address ();\n \n /* Compute extra cost of moving data between one register class\n    and another.  */\n+#define GENERAL_OR_I64(C) ((C) == GENERAL_REGS || (C) == I64_REGS)\n #define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\\\n-  (((FP_REG_CLASS_P (CLASS1) && (CLASS2) == GENERAL_REGS)\t\\\n-    || ((CLASS1) == GENERAL_REGS && FP_REG_CLASS_P (CLASS2))\t\\\n+  (((FP_REG_CLASS_P (CLASS1) && GENERAL_OR_I64 (CLASS2)) \\\n+    || (GENERAL_OR_I64 (CLASS1) && FP_REG_CLASS_P (CLASS2)) \\\n     || (CLASS1) == FPCC_REGS || (CLASS2) == FPCC_REGS)\t\t\\\n-   ? (sparc_cpu == PROCESSOR_ULTRASPARC ? 12 : 6)\t\t\\\n-   : 2)\n+   ? (sparc_cpu == PROCESSOR_ULTRASPARC ? 12 : 6) : 2)\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  The purpose for the cost of MULT is to encourage\n@@ -2741,20 +2748,17 @@ extern struct rtx_def *legitimize_pic_address ();\n \n /* Adjust the cost of dependencies.  */\n #define ADJUST_COST(INSN,LINK,DEP,COST)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n   if (sparc_cpu == PROCESSOR_SUPERSPARC)\t\t\t\\\n     (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n   else if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\\\n     (COST) = ultrasparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n-} while (0)\n+  else\n \n /* Conditional branches with empty delay slots have a length of two.  */\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (INSN) == CALL_INSN\t\t\t\t\t\\\n       || (GET_CODE (INSN) == JUMP_INSN && ! simplejump_p (insn)))\t\\\n-    LENGTH += 1;\t\t\t\t\t\t\t\\\n-} while (0)\n+    LENGTH += 1; else\n \f\n /* Control the assembler format that we output.  */\n \n@@ -3252,6 +3256,16 @@ extern int v9_regcmp_p ();\n extern unsigned long sparc_flat_compute_frame_size ();\n extern unsigned long sparc_type_code ();\n \n+extern char *sparc_v8plus_shift ();\n+\n+#ifdef __STDC__\n+/* Function used for V8+ code generation.  Returns 1 if the high\n+   32 bits of REG are 0 before INSN.  */   \n+extern int sparc_check_64 (struct rtx_def *, struct rtx_def *);\n+extern int sparc_return_peephole_ok (struct rtx_def *, struct rtx_def *);\n+extern int compute_frame_size (int, int);\n+#endif\n+\n /* Defined in flags.h, but insn-emit.c does not include flags.h.  */\n \n extern int flag_pic;"}, {"sha": "8ef692d4e632856d2b12d0cd02ea850f3f380c94", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 574, "deletions": 352, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/284d86e9f0c140d9500f1d907d1c1d483c4a40ed/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=284d86e9f0c140d9500f1d907d1c1d483c4a40ed", "patch": "@@ -34,7 +34,7 @@\n \n ;; Attribute for cpu type.\n ;; These must match the values for enum processor_type in sparc.h.\n-(define_attr \"cpu\" \"v7,cypress,v8,supersparc,sparclite,f930,f934,sparclet,tsc701,v8plus,v9,ultrasparc\"\n+(define_attr \"cpu\" \"v7,cypress,v8,supersparc,sparclite,f930,f934,sparclet,tsc701,v9,ultrasparc\"\n   (const (symbol_ref \"sparc_cpu_attr\")))\n \n ;; Attribute for the instruction set.\n@@ -67,7 +67,7 @@\n ;; type \"call_no_delay_slot\" is a call followed by an unimp instruction.\n \n (define_attr \"type\"\n-  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrt,cmove,multi,misc\"\n+  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,return,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrt,cmove,multi,misc\"\n   (const_string \"binary\"))\n \n ;; Set true if insn uses call-clobbered intermediate register.\n@@ -110,7 +110,7 @@\n ;; Attributes for instruction and branch scheduling\n \n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,call_no_delay_slot,multi\")\n+  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,call_no_delay_slot,return,multi\")\n \t \t(const_string \"false\")\n \t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n \t \t(if_then_else (eq_attr \"length\" \"1\")\n@@ -127,6 +127,22 @@\n (define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n+(define_attr \"leaf_function\" \"false,true\"\n+  (const (symbol_ref \"leaf_function\")))\n+\n+\n+(define_attr \"in_return_delay\" \"false,true\"\n+  (if_then_else (and (and (and (eq_attr \"type\" \"move,load,sload,store,binary,ialu\")\n+\t\t\t       (eq_attr \"length\" \"1\"))\n+\t\t\t  (eq_attr \"leaf_function\" \"false\"))\n+\t\t     (match_insn \"eligible_for_return_delay\"))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+(define_delay (and (eq_attr \"type\" \"return\")\n+\t\t   (eq_attr \"isa\" \"v9\"))\n+  [(eq_attr \"in_return_delay\" \"true\") (nil) (nil)])\n+\n ;; ??? Should implement the notion of predelay slots for floating point\n ;; branches.  This would allow us to remove the nop always inserted before\n ;; a floating point branch.\n@@ -356,7 +372,7 @@\n \n (define_function_unit \"ieu\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"ialu,shift,compare,cmove,call\"))\n+    (eq_attr \"type\" \"ialu,binary,shift,compare,cmove,call\"))\n   1 1)\n \n (define_function_unit \"ieu_shift\" 1 0\n@@ -370,12 +386,15 @@\n   2 1)\n \n ;; Timings; throughput/latency\n-;; ?? FADD     1/3    add/sub, format conv, compar, abs, neg\n-;; ?? FMUL     1/3\n-;; ?? FDIVs    1/12\n-;; ?? FDIVd    1/22\n-;; ?? FSQRTs   1/12\n-;; ?? FSQRTd   1/22\n+;; FMOV     1/1    fmov, fabs, fneg\n+;; FMOVcc   1/2\n+;; FADD     1/4    add/sub, format conv, compar\n+;; FMUL     1/4\n+;; FDIVs    12/12\n+;; FDIVd    22/22\n+;; FSQRTs   12/12\n+;; FSQRTd   22/22\n+;; FCMP takes 1 cycle to branch, 2 cycles to conditional move.\n \n (define_function_unit \"fadd\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n@@ -456,7 +475,7 @@\n   [(set (reg:CCX 100)\n \t(compare:CCX (match_operand:DI 0 \"register_operand\" \"\")\n \t\t     (match_operand:DI 1 \"arith_double_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n+  \"TARGET_ARCH64 || TARGET_V8PLUS\"\n   \"\n {\n   sparc_compare_op0 = operands[0];\n@@ -521,6 +540,37 @@\n   \"cmp %0,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n+(define_insn \"cmpdi_v8plus\"\n+  [(set (reg:CCX 100)\n+\t(compare:CCX (match_operand:DI 0 \"register_operand\" \"r,r,r\")\n+\t\t     (match_operand:DI 1 \"arith_double_operand\" \"J,I,r\")))\n+   (clobber (match_scratch:SI 2 \"=&h,&h,&h\"))\n+   (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"*\n+{\n+  /* The srl can be omitted if the value in the %L0 or %L1 is already\n+     zero extended.  */\n+\n+  output_asm_insn (\\\"sllx %H0,32,%2\\\", operands);\n+\n+  if (sparc_check_64 (operands[0], insn) <= 0)\n+    output_asm_insn (\\\"srl %L0,0,%L0\\\", operands);\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"orcc %L0,%2,%%g0\\\";\n+    case 1:\n+      return \\\"or %L0,%2,%2\\;cmp %2,%1\\\";\n+    case 2:\n+      if (sparc_check_64 (operands[1], insn) <= 0)\n+\toutput_asm_insn (\\\"srl %L1,0,%L1\\\", operands);\n+      return \\\"sllx %H1,32,%3\\;or %L0,%2,%2\\;or %L1,%3,%3\\;cmp %2,%3\\\";\n+    }\n+}\"\n+  [(set_attr \"length\" \"3,4,7\")])\n+\n (define_insn \"*cmpsf_fpe\"\n   [(set (match_operand:CCFPE 0 \"fcc_reg_operand\" \"=c\")\n \t(compare:CCFPE (match_operand:SF 1 \"register_operand\" \"f\")\n@@ -1008,7 +1058,7 @@\n \t       (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrnz %1,1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"cmove\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*neg_snedi_zero\"\n@@ -1017,7 +1067,7 @@\n \t\t       (const_int 0))))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrnz %1,-1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"cmove\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*snedi_zero_trunc\"\n@@ -1026,7 +1076,7 @@\n \t       (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrnz %1,1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"cmove\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*seqsi_zero\"\n@@ -1065,7 +1115,7 @@\n \t       (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrz %1,1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"cmove\")\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"*neg_seqdi_zero\"\n@@ -1074,7 +1124,7 @@\n \t\t       (const_int 0))))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrz %1,-1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"cmove\")\n    (set_attr \"length\" \"2\")]) \n \n (define_insn \"*seqdi_zero_trunc\"\n@@ -1083,7 +1133,7 @@\n \t       (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"mov 0,%0\\;movrz %1,1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"cmove\")\n    (set_attr \"length\" \"2\")])\n \n ;; We can also do (x + (i == 0)) and related, so put them in.\n@@ -1645,15 +1695,16 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"get_pc_via_call\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n-   (set (reg:SI 15) (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"call %l0%#\"\n-  [(set_attr \"type\" \"uncond_branch\")])\n+(define_insn \"get_pc\"\n+  [(clobber (reg:SI 15))\n+   (set (match_operand 0 \"register_operand\" \"=r\")\n+\t(unspec [(match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")] 2))]\n+  \"flag_pic && REGNO (operands[0]) == 23\"\n+  \"sethi %%hi(%a1-4),%0\\;call %a2\\;add %0,%%lo(%a1+4),%0\"\n+  [(set_attr \"length\" \"3\")])\n \n (define_insn \"get_pc_via_rdpc\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\") (pc))]\n+  [(set (match_operand 0 \"register_operand\" \"=r\") (pc))]\n   \"TARGET_V9\"\n   \"rd %%pc,%0\"\n   [(set_attr \"type\" \"move\")])\n@@ -2089,7 +2140,10 @@\n   \"! TARGET_LIVE_G0\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n-       || operands[1] == const0_rtx)\"\n+       || operands[1] == const0_rtx)\n+   && (GET_CODE (operands[0]) != REG || ! CONSTANT_P (operands[1])\n+       || REGNO (operands[0]) < 32\n+       || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\"\n   \"@\n    mov %1,%0\n    fmovs %1,%0\n@@ -2099,7 +2153,7 @@\n    st %r1,%0\n    st %1,%0\n    fzeros %0\"\n-  [(set_attr \"type\" \"move,fp,move,load,fpload,store,fpstore,fpmove\")\n+  [(set_attr \"type\" \"move,fpmove,move,load,fpload,store,fpstore,fpmove\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movsi_insn_liveg0\"\n@@ -2141,16 +2195,20 @@\n     DONE;\n }\")\n \n-;; V8+ movdi is like regular 32 bit except that a 64 bit zero can be stored\n-;; to aligned memory with a single instruction and the ldd/std instructions\n-;; are not used.\n-(define_insn \"*movdi_v8plus\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,Q,r,r,f,f,Q,b\")\n-      (match_operand:DI 1 \"general_operand\" \"r,J,r,Q,i,?f,?Q,?f,?J\"))]\n-  \"TARGET_V8PLUS\n+;; 32 bit V9 movdi is like regular 32 bit except: a 64 bit zero can be stored\n+;; to aligned memory with a single instruction, the ldd/std instructions\n+;; are not used, and constants can not be moved to floating point registers.\n+\n+(define_insn \"*movdi_sp32_v9\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,Q,r,r,?e,?e,?Q,?b\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,J,r,Q,i,e,Q,e,J\"))]\n+  \"TARGET_V9\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n-       || operands[1] == const0_rtx)\"\n+       || operands[1] == const0_rtx)\n+   && (GET_CODE (operands[0]) != REG || ! CONSTANT_P (operands[1])\n+       || REGNO (operands[0]) < 32\n+       || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\"\n   \"*\n {\n   if (which_alternative == 1)\n@@ -2164,13 +2222,11 @@\n   [(set_attr \"type\" \"move,store,store,load,multi,fp,fpload,fpstore,fpmove\")\n    (set_attr \"length\" \"2,1,3,3,3,2,3,3,1\")])\n \n-;; ??? The Haifa scheduler does not split instructions after reload if\n-;; it also ran before reload.\n-\n+;; SPARC V9 deprecates std.  Split it here.\n (define_split\n   [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n       (match_operand:DI 1 \"register_operand\" \"r\"))]\n-  \"TARGET_V8PLUS && !TARGET_ARCH64 && reload_completed\n+  \"TARGET_V9 && ! TARGET_ARCH64 && reload_completed\n    && REGNO (operands[1]) < 32 && ! MEM_VOLATILE_P (operands[0])\n    && offsettable_memref_p (operands[0])\"\n   [(set (match_dup 2) (match_dup 3))\n@@ -2182,10 +2238,10 @@\n    operands[2] = copy_rtx (operands[0]);\n    PUT_MODE (operands[2], SImode);\")\n \n-(define_insn \"*movdi_sp32_insn\"\n+(define_insn \"*movdi_sp32\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,U,Q,r,r,?f,?f,?Q\")\n \t(match_operand:DI 1 \"general_operand\" \"r,U,T,r,Q,i,f,Q,f\"))]\n-  \"! TARGET_ARCH64\n+  \"! TARGET_V9\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n        || operands[1] == const0_rtx)\"\n@@ -2207,8 +2263,8 @@\n ;;; This needs the original value of operands[1], not the inverted value.\n \n (define_insn \"*movdi_sp64_insn\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q,?f,?f,?Q\")\n-\t(match_operand:DI 1 \"move_operand\" \"rI,K,Q,rJ,f,Q,f\"))]\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q,?e,?e,?Q\")\n+\t(match_operand:DI 1 \"move_operand\" \"rI,K,Q,rJ,e,Q,e\"))]\n   \"TARGET_ARCH64\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n@@ -2693,24 +2749,22 @@\n   \"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (GET_MODE (sparc_compare_op0) == DImode\n-      && ! TARGET_ARCH64)\n-    FAIL;\n+  enum machine_mode op0_mode = GET_MODE (sparc_compare_op0);\n \n   if (sparc_compare_op1 == const0_rtx\n       && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n-      && v9_regcmp_p (code))\n+      && ((TARGET_ARCH64 && op0_mode == DImode && v9_regcmp_p (code))\n+\t  || (op0_mode == SImode && v8plus_regcmp_p (code))))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, op0_mode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg),\n+\t\t\t\t    cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -2729,14 +2783,15 @@\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, DImode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg),\n+\t\t\t\t    cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -2963,6 +3018,57 @@\n    movr%d1 %2,%r4,%0\"\n   [(set_attr \"type\" \"cmove\")])\n \n+;; On UltraSPARC this is slightly worse than cmp/mov %icc if the register\n+;; needs to be zero extended but better on average.\n+(define_insn \"*movsi_cc_reg_v8plus\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:SI (match_operator 1 \"v8plus_regcmp_op\"\n+\t\t\t\t[(match_operand:SI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:SI 3 \"arith10_operand\" \"rM,0\")\n+\t\t      (match_operand:SI 4 \"arith10_operand\" \"0,rM\")))]\n+  \"TARGET_V9\"\n+  \"*\n+{\n+  if (! sparc_check_64 (operands[2], insn))\n+    output_asm_insn (\\\"srl %2,0,%2\\\", operands);\n+  if (which_alternative == 0)\n+    return \\\"movr%D1 %2,%r3,%0\\\";\n+  return \\\"movr%d1 %2,%r4,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"cmove\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; To work well this needs to know the current insn, but that is not an\n+;; argument to gen_split_*.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:SI (match_operator 1 \"v8plus_regcmp_op\"\n+\t\t\t\t[(match_operand:SI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+\t\t      (match_operand:SI 3 \"arith10_operand\" \"rM,0\")\n+\t\t      (match_operand:SI 4 \"arith10_operand\" \"0,rM\")))]\n+  \"reload_completed\"\n+  [(set (match_dup 0)\n+\t(unspec:SI [(match_dup 1) (match_dup 3) (match_dup 4)] 9))]\n+  \"if (! sparc_check_64 (operands[2], NULL_RTX))\n+     emit_insn (gen_v8plus_clear_high (operands[2], operands[2]));\")\n+\n+;; A conditional move with the condition argument known to be zero extended\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(unspec:SI [(match_operator 1 \"v8plus_regcmp_op\"\n+\t\t\t\t    [(match_operand:SI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t     (const_int 0)])\n+\t\t    (match_operand:SI 3 \"arith10_operand\" \"rM,0\")\n+\t\t    (match_operand:SI 4 \"arith10_operand\" \"0,rM\")] 9))]\n+  \"TARGET_V9\"\n+  \"@\n+   movr%D1 %2,%r3,%0\n+   movr%d1 %2,%r4,%0\"\n+  [(set_attr \"type\" \"cmove\")])\n+\n ;; ??? The constraints of operands 3,4 need work.\n (define_insn \"*movdi_cc_reg_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -3130,6 +3236,7 @@\n   \"lduh %1,%0\"\n   [(set_attr \"type\" \"load\")])\n \n+\n ;; ??? Write truncdisi pattern using sra?\n \n (define_expand \"zero_extendsidi2\"\n@@ -3148,6 +3255,20 @@\n   [(set_attr \"type\" \"unary,load\")\n    (set_attr \"length\" \"1\")])\n \n+;; Zero extend a 32 bit value in a 64 bit register.\n+(define_insn \"v8plus_clear_high\"\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,Q\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r,r\")] 10))]\n+  \"TARGET_V9\"\n+  \"*\n+if (which_alternative == 1)\n+  return \\\"st %1,%0\\\";\n+if (sparc_check_64 (operands[1], insn) > 0)\n+  return \\\"nop\\\";\n+return \\\"srl %1,0,%0\\\";\n+\"\n+  [(set_attr \"type\" \"shift,store\")])\n+\n ;; Simplify comparisons of extended values.\n \n (define_insn \"*cmp_zero_extendqisi2\"\n@@ -3480,115 +3601,25 @@\n   [(set_attr \"type\" \"fp\")])\n \n ;; Now the same for 64 bit sources.\n-;; ??? We cannot put DImode values in fp regs (see below near fix_truncdfsi2).\n-\n-(define_expand \"floatdisf2\"\n-  [(parallel [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t   (float:SF (match_operand:DI 1 \"general_operand\" \"\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = sparc64_fpconv_stack_temp ();\n-}\")\n-\n-(define_expand \"floatdidf2\"\n-  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t   (float:DF (match_operand:DI 1 \"general_operand\" \"\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = sparc64_fpconv_stack_temp ();\n-}\")\n-\n-(define_expand \"floatditf2\"\n-  [(parallel [(set (match_operand:TF 0 \"register_operand\" \"\")\n-\t\t   (float:TF (match_operand:DI 1 \"general_operand\" \"\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = sparc64_fpconv_stack_temp ();\n-}\")\n-\n-(define_insn \"*floatdisf2_insn\"\n-  [(parallel [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t\t   (float:SF (match_operand:DI 1 \"general_operand\" \"rm\")))\n-\t      (clobber (match_operand:DF 2 \"register_operand\" \"=&e\"))\n-\t      (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == MEM)\n-    output_asm_insn (\\\"ldd %1,%2\\\", operands);\n-  else\n-    output_asm_insn (\\\"stx %1,%3\\;ldd %3,%2\\\", operands);\n-  return \\\"fxtos %2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"length\" \"3\")])\n-\n-(define_insn \"*floatdidf2_insn\"\n-  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n-\t\t   (float:DF (match_operand:DI 1 \"general_operand\" \"rm\")))\n-\t      (clobber (match_operand:DF 2 \"register_operand\" \"=&e\"))\n-\t      (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == MEM)\n-    output_asm_insn (\\\"ldd %1,%2\\\", operands);\n-  else\n-    output_asm_insn (\\\"stx %1,%3\\;ldd %3,%2\\\", operands);\n-  return \\\"fxtod %2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"length\" \"3\")])\n \n-(define_insn \"*floatditf2_insn\"\n-  [(parallel [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-\t\t   (float:TF (match_operand:DI 1 \"general_operand\" \"rm\")))\n-\t      (clobber (match_operand:DF 2 \"register_operand\" \"=&e\"))\n-\t      (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))])]\n-  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == MEM)\n-    output_asm_insn (\\\"ldd %1,%2\\\", operands);\n-  else\n-    output_asm_insn (\\\"stx %1,%3\\;ldd %3,%2\\\", operands);\n-  return \\\"fxtoq %2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"length\" \"3\")])\n-\n-;; ??? Ideally, these are what we would like to use.\n-\n-(define_insn \"floatdisf2_sp64\"\n+(define_insn \"floatdisf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float:SF (match_operand:DI 1 \"register_operand\" \"e\")))]\n-  \"0 && TARGET_ARCH64 && TARGET_FPU\"\n+  \"TARGET_V9 && TARGET_FPU\"\n   \"fxtos %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"floatdidf2_sp64\"\n+(define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(float:DF (match_operand:DI 1 \"register_operand\" \"e\")))]\n-  \"0 && TARGET_ARCH64 && TARGET_FPU\"\n+  \"TARGET_V9 && TARGET_FPU\"\n   \"fxtod %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"floatditf2_sp64\"\n+(define_insn \"floatditf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(float:TF (match_operand:DI 1 \"register_operand\" \"e\")))]\n-  \"0 && TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fxtoq %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -3616,121 +3647,26 @@\n   \"fqtoi %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-;; Now the same, for 64-bit targets\n-;; ??? We try to work around an interesting problem.\n-;; If gcc tries to do a subreg on the result it will get the wrong answer:\n-;; \"(subreg:SI (reg:DI M int-reg) 0)\" is the same as\n-;; \"(subreg:SI (reg:DI N float-reg) 1)\", but gcc does not know how to change\n-;; the \"0\" to a \"1\".  One could enhance alter_subreg but it is not clear how to\n-;; do this cleanly.\n-\n-(define_expand \"fix_truncsfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"\"))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = sparc64_fpconv_stack_temp ();\n-}\")\n-\n-(define_expand \"fix_truncdfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"\"))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = sparc64_fpconv_stack_temp ();\n-}\")\n+;; Now the same, for V9 targets\n \n-(define_expand \"fix_trunctfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"\"))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = sparc64_fpconv_stack_temp ();\n-}\")\n-\n-(define_insn \"*fix_truncsfdi2_insn\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n-\t\t   (fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))\n-\t      (clobber (match_operand:DF 2 \"register_operand\" \"=&e\"))\n-\t      (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"*\n-{\n-  output_asm_insn (\\\"fstox %1,%2\\\", operands);\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"std %2,%0\\\";\n-  else\n-    return \\\"std %2,%3\\;ldx %3,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"length\" \"3\")])\n-\n-(define_insn \"*fix_truncdfdi2_insn\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n-\t\t   (fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"e\"))))\n-\t      (clobber (match_operand:DF 2 \"register_operand\" \"=&e\"))\n-\t      (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))])]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"*\n-{\n-  output_asm_insn (\\\"fdtox %1,%2\\\", operands);\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"std %2,%0\\\";\n-  else\n-    return \\\"std %2,%3\\;ldx %3,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"length\" \"3\")])\n-\n-(define_insn \"*fix_trunctfdi2_insn\"\n-  [(parallel [(set (match_operand:DI 0 \"general_operand\" \"=rm\")\n-\t\t   (fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))\n-\t      (clobber (match_operand:DF 2 \"register_operand\" \"=&e\"))\n-\t      (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))])]\n-  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"*\n-{\n-  output_asm_insn (\\\"fqtox %1,%2\\\", operands);\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"std %2,%0\\\";\n-  else\n-    return \\\"std %2,%3\\;ldx %3,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"length\" \"3\")])\n-\n-;; ??? Ideally, these are what we would like to use.\n-\n-(define_insn \"fix_truncsfdi2_sp64\"\n+(define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n \t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n-  \"0 && TARGET_ARCH64 && TARGET_FPU\"\n+  \"TARGET_V9 && TARGET_FPU\"\n   \"fstox %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"fix_truncdfdi2_sp64\"\n+(define_insn \"fix_truncdfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n \t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"e\"))))]\n-  \"0 && TARGET_ARCH64 && TARGET_FPU\"\n+  \"TARGET_V9 && TARGET_FPU\"\n   \"fdtox %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"fix_trunctfdi2_sp64\"\n+(define_insn \"fix_trunctfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n \t(fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n-  \"0 && TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fqtox %1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \f\n@@ -3785,6 +3721,77 @@\n }\"\n   [(set_attr \"length\" \"2\")])\n \n+\n+;; Split DImode arithmetic\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n+   (clobber (reg:SI 100))]\n+  \"! TARGET_ARCH64 && reload_completed\"\n+  [(parallel [(set (reg:CC_NOOV 100)\n+\t\t   (compare:CC_NOOV (plus:SI (match_dup 4)\n+\t\t\t\t\t     (match_dup 5))\n+\t\t\t\t    (const_int 0)))\n+\t      (set (match_dup 3)\n+\t\t   (plus:SI (match_dup 4) (match_dup 5)))])\n+   (set (match_dup 6)\n+\t(plus:SI (plus:SI (match_dup 7)\n+\t\t\t  (match_dup 8))\n+\t\t (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n+  \"operands[3] = gen_lowpart (SImode, operands[0]);\n+   operands[4] = gen_lowpart (SImode, operands[1]);\n+   operands[5] = gen_lowpart (SImode, operands[2]);\n+   operands[6] = gen_highpart (SImode, operands[0]);\n+   operands[7] = gen_highpart (SImode, operands[1]);\n+   if (GET_CODE (operands[2]) == CONST_INT)\n+     operands[8] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n+   else\n+     operands[8] = gen_highpart (SImode, operands[2]);\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"arith_double_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n+   (clobber (reg:SI 100))]\n+  \"! TARGET_ARCH64 && reload_completed\"\n+  [(parallel [(set (reg:CC_NOOV 100)\n+\t\t   (compare:CC_NOOV (minus:SI (match_dup 4)\n+\t\t\t\t\t      (match_dup 5))\n+\t\t\t\t    (const_int 0)))\n+\t      (set (match_dup 3)\n+\t\t   (minus:SI (match_dup 4) (match_dup 5)))])\n+   (set (match_dup 6)\n+\t(minus:SI (minus:SI (match_dup 7)\n+\t\t\t    (match_dup 8))\n+\t\t  (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n+  \"operands[3] = gen_lowpart (SImode, operands[0]);\n+   operands[4] = gen_lowpart (SImode, operands[1]);\n+   operands[5] = gen_lowpart (SImode, operands[2]);\n+   operands[6] = gen_highpart (SImode, operands[0]);\n+   operands[7] = gen_highpart (SImode, operands[1]);\n+   operands[8] = gen_highpart (SImode, operands[2]);\")\n+\n+;; LTU here means \"carry set\"\n+(define_insn \"*addx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n+  \"\"\n+  \"addx %1,%2,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"*subx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t  (ltu:SI (reg:CC_NOOV 100) (const_int 0))))]\n+  \"\"\n+  \"subx %1,%2,%0\"\n+  [(set_attr \"type\" \"unary\")])\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n       (plus:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n@@ -3976,13 +3983,50 @@\n   \"smul %1,%2,%0\"\n   [(set_attr \"type\" \"imul\")])\n \n-(define_insn \"muldi3\"\n+(define_expand \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  \"TARGET_ARCH64 || TARGET_V8PLUS\"\n+  \"\n+{\n+  if (TARGET_V8PLUS)\n+    {\n+      emit_insn (gen_muldi3_v8plus (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*muldi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n   \"TARGET_ARCH64\"\n   \"mulx %1,%2,%0\")\n \n+;; V8plus wide multiply.\n+(define_insn \"muldi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,h\")\n+\t(mult:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,0\")\n+\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI,rHI\")))\n+   (clobber (match_scratch:SI 3 \"=&h,X\"))\n+   (clobber (match_scratch:SI 4 \"=&h,X\"))]\n+  \"TARGET_V8PLUS\"\n+  \"*\n+{\n+  if (sparc_check_64 (operands[1], insn) <= 0)\n+    output_asm_insn (\\\"srl %L1,0,%L1\\\", operands);\n+  if (which_alternative == 1)\n+    output_asm_insn (\\\"sllx %H1,32,%H1\\\", operands);\n+  if (sparc_check_64 (operands[2], insn) <= 0)\n+    output_asm_insn (\\\"srl %L2,0,%L2\\\", operands);\n+  if (which_alternative == 1)\n+    return \\\"or %L1,%H1,%H1\\;sllx %H2,32,%L1\\;or %L2,%L1,%L1\\;mulx %H1,%L1,%L0\\;srlx %L0,32,%H0\\\";\n+  else\n+    return \\\"sllx %H1,32,%3\\;sllx %H2,32,%4\\;or %L1,%3,%3\\;or %L2,%4,%4\\;mulx %3,%4,%3\\;srlx %3,32,%H0\\;mov %3,%L0\\\";\n+}\"\n+  [(set_attr \"length\" \"9,8\")])\n+\n ;; It is not known whether this will match.\n \n (define_insn \"*cmp_mul_set\"\n@@ -4010,11 +4054,35 @@\n     }\n }\")\n \n+;; V9 puts the 64 bit product in a 64 bit register.  Only out or global\n+;; registers can hold 64 bit values in the V8plus environment.\n+(define_insn \"*mulsidi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\"))))\n+   (clobber (match_scratch:SI 3 \"=X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   smul %1,%2,%L0\\;srlx %L0,32,%H0\n+   smul %1,%2,%3\\;srlx %3,32,%H0\\;mov %3,%L0\"\n+  [(set_attr \"length\" \"2,3\")])\n+\n+(define_insn \"*const_mulsidi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t (match_operand:SI 2 \"small_int\" \"I,I\")))\n+   (clobber (match_scratch:SI 3 \"=X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   smul %1,%2,%L0\\;srlx %L0,32,%H0\n+   smul %1,%2,%3\\;srlx %3,32,%H0\\;mov %3,%L0\"\n+  [(set_attr \"length\" \"2,3\")])\n+\n (define_insn \"*mulsidi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_HARD_MUL\"\n+  \"TARGET_HARD_MUL32\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"smuld %1,%2,%L0\\\" : \\\"smul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -4052,15 +4120,34 @@\n       emit_insn (gen_const_smulsi3_highpart (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n+  if (TARGET_V8PLUS)\n+    {\n+      emit_insn (gen_smulsidi3_highpart_v8plus (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2], GEN_INT (32)));\n+      DONE;\n+    }\n }\")\n \n+(define_insn \"smulsidi3_highpart_v8plus\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n+\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+   (clobber (match_scratch:SI 4 \"=X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   smul %1,%2,%0\\;srlx %0,%3,%0\n+   smul %1,%2,%4\\;srlx %4,%3,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n (define_insn \"*smulsidi3_highpart_sp32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_HARD_MUL\"\n+  \"TARGET_HARD_MUL32\"\n   \"smul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -4070,7 +4157,7 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (match_operand:SI 2 \"register_operand\" \"r\"))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL32\"\n   \"smul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -4086,13 +4173,29 @@\n       emit_insn (gen_const_umulsidi3 (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n+  if (TARGET_V8PLUS)\n+    {\n+      emit_insn (gen_umulsidi3_v8plus (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n }\")\n \n+(define_insn \"umulsidi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\"))))\n+   (clobber (match_scratch:SI 3 \"=X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   umul %1,%2,%L0\\;srlx %L0,32,%H0\n+   umul %1,%2,%3\\;srlx %3,32,%H0\\;mov %3,%L0\"\n+  [(set_attr \"length\" \"2,3\")])\n+\n (define_insn \"*umulsidi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_HARD_MUL\"\n+  \"TARGET_HARD_MUL32\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"umuld %1,%2,%L0\\\" : \\\"umul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -4107,7 +4210,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"uns_small_int\" \"\")))]\n-  \"TARGET_HARD_MUL\"\n+  \"TARGET_HARD_MUL32\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"umuld %1,%2,%L0\\\" : \\\"umul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -4116,6 +4219,17 @@\n \t(if_then_else (eq_attr \"isa\" \"sparclet\")\n \t\t      (const_int 1) (const_int 2)))])\n \n+(define_insn \"const_umulsidi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t (match_operand:SI 2 \"uns_small_int\" \"\")))\n+   (clobber (match_scratch:SI 3 \"=X,h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   umul %1,%2,%L0\\;srlx %L0,32,%H0\n+   umul %1,%2,%3\\;srlx %3,32,%H0\\;mov %3,%L0\"\n+  [(set_attr \"length\" \"2,3\")])\n+\n (define_expand \"umulsi3_highpart\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(truncate:SI\n@@ -4125,20 +4239,52 @@\n   \"TARGET_HARD_MUL\"\n   \"\n {\n+  if (TARGET_V8PLUS)\n+    {\n+      emit_insn (gen_umulsidi3_highpart_v8plus (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2], GEN_INT (32)));\n+      DONE;\n+    }\n   if (CONSTANT_P (operands[2]))\n     {\n       emit_insn (gen_const_umulsi3_highpart (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n }\")\n \n+(define_insn \"umulsidi3_highpart_v8plus\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n+\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+   (clobber (match_scratch:SI 4 \"=X,h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   umul %1,%2,%0\\;srlx %0,%3,%0\n+   umul %1,%2,%4\\;srlx %4,%3,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"const_umulsi3_highpart_v8plus\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t\t       (match_operand:SI 2 \"uns_small_int\" \"\"))\n+\t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n+   (clobber (match_scratch:SI 4 \"=X,h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   umul %1,%2,%0\\;srlx %0,%3,%0\n+   umul %1,%2,%4\\;srlx %4,%3,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n (define_insn \"*umulsidi3_highpart_sp32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_HARD_MUL\"\n+  \"TARGET_HARD_MUL32\"\n   \"umul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -4148,29 +4294,35 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (match_operand:SI 2 \"uns_small_int\" \"\"))\n \t\t      (const_int 32))))]\n-  \"TARGET_HARD_MUL\"\n+  \"TARGET_HARD_MUL32\"\n   \"umul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n ;; The v8 architecture specifies that there must be 3 instructions between\n ;; a y register write and a use of it for correct results.\n \n (define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n-   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:SI 2 \"move_operand\" \"rI,m\")))\n+   (clobber (match_scratch:SI 3 \"=&r,&r\"))]\n   \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n   \"*\n {\n+  if (which_alternative == 0)\n   if (TARGET_V9)\n     return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;sdiv %1,%2,%0\\\";\n   else\n     return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdiv %1,%2,%0\\\";\n+  else\n+    if (TARGET_V9)\n+      return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;ld %2,%3\\;sdiv %1,%3,%0\\\";\n+    else\n+      return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;ld %2,%3\\;nop\\;nop\\;sdiv %1,%3,%0\\\";\n }\"\n   [(set (attr \"length\")\n \t(if_then_else (eq_attr \"isa\" \"v9\")\n-\t\t      (const_int 3) (const_int 6)))])\n+\t\t      (const_int 4) (const_int 7)))])\n \n (define_insn \"divdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4202,19 +4354,28 @@\n \t\t      (const_int 3) (const_int 6)))])\n \n (define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,&r,&r\")\n+\t(udiv:SI (match_operand:SI 1 \"reg_or_nonsymb_mem_operand\" \"r,r,m\")\n+\t\t (match_operand:SI 2 \"move_operand\" \"rI,m,r\")))]\n   \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n   \"*\n {\n+  output_asm_insn (\\\"wr %%g0,%%g0,%%y\\\", operands);\n+  switch (which_alternative)\n+    {\n+    default:\n   if (TARGET_V9)\n-    return \\\"wr %%g0,%%g0,%%y\\;udiv %1,%2,%0\\\";\n-  else\n-    return \\\"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udiv %1,%2,%0\\\";\n+\treturn \\\"udiv %1,%2,%0\\\";\n+      return \\\"nop\\;nop\\;nop\\;udiv %1,%2,%0\\\";\n+    case 1:\n+      return \\\"ld %2,%0\\;nop\\;nop\\;udiv %1,%0,%0\\\";\n+    case 2:\n+      return \\\"ld %1,%0\\;nop\\;nop\\;udiv %0,%2,%0\\\";\n+    }\n }\"\n   [(set (attr \"length\")\n-\t(if_then_else (eq_attr \"isa\" \"v9\")\n+\t(if_then_else (and (eq_attr \"isa\" \"v9\")\n+\t\t\t   (eq_attr \"alternative\" \"0\"))\n \t\t      (const_int 2) (const_int 5)))])\n \n (define_insn \"udivdi3\"\n@@ -4341,13 +4502,13 @@\n \t\t(match_operand:SI 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n+   && !SMALL_INT32 (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 1)))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]));\n+  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n }\")\n \n (define_insn \"*and_not_di_sp32\"\n@@ -4436,13 +4597,13 @@\n \t\t(match_operand:SI 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n+   && !SMALL_INT32 (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (ior:SI (not:SI (match_dup 3)) (match_dup 1)))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]));\n+  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n }\")\n \n (define_insn \"*or_not_di_sp32\"\n@@ -4479,7 +4640,7 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*xorsi3_sp32\"\n+(define_insn \"*xordi3_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n \t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n \t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n@@ -4506,7 +4667,8 @@\n     }\n   return \\\"xor %1,%2,%0\\;xor %R1,%R2,%R0\\\";\n }\"\n-  [(set_attr \"length\" \"2,1\")])\n+  [(set_attr \"length\" \"2,1\")\n+   (set_attr \"type\" \"ialu,fp\")])\n \n (define_insn \"*xordi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4531,13 +4693,13 @@\n \t\t(match_operand:SI 2 \"\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n+   && !SMALL_INT32 (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (not:SI (xor:SI (match_dup 3) (match_dup 1))))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]));\n+  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n }\")\n \n (define_split\n@@ -4546,13 +4708,13 @@\n \t\t\t(match_operand:SI 2 \"\" \"\"))))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"GET_CODE (operands[2]) == CONST_INT\n-   && !SMALL_INT (operands[2])\n+   && !SMALL_INT32 (operands[2])\n    && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (xor:SI (match_dup 3) (match_dup 1)))]\n   \"\n {\n-  operands[4] = GEN_INT (~INTVAL (operands[2]));\n+  operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n }\")\n \n ;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).\n@@ -4849,7 +5011,7 @@\n {\n   if (which_alternative == 0)\n     return \\\"xnor %1,0,%0\\\";\n-  if (which_alternative == 1)\n+  if (which_alternative == 2)\n     return \\\"fnot1s %1,%0\\\";\n   if (TARGET_LIVE_G0)\n     output_asm_insn (\\\"and %%g0,0,%%g0\\\", operands);\n@@ -5138,7 +5300,23 @@\n }\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"ashldi3\"\n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 || TARGET_V8PLUS\"\n+  \"\n+{\n+  if (! TARGET_ARCH64)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\tFAIL;\n+      emit_insn (gen_ashldi3_v8plus (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n@@ -5152,6 +5330,15 @@\n   return \\\"sllx %1,%2,%0\\\";\n }\")\n \n+(define_insn \"ashldi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&h,&h,r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r,0,r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"*return sparc_v8plus_shift (operands, insn, \\\"sllx\\\");\"\n+  [(set_attr \"length\" \"5,5,6\")])\n+\n (define_insn \"*cmp_cc_ashift_1\"\n   [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n@@ -5186,7 +5373,21 @@\n }\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"ashrdi3\"\n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 || TARGET_V8PLUS\"\n+  \"\n+if (! TARGET_ARCH64)\n+  {\n+    if (GET_CODE (operands[2]) == CONST_INT)\n+      FAIL;\t/* prefer generic code in this case */\n+    emit_insn (gen_ashrdi3_v8plus (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\")\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n@@ -5200,6 +5401,15 @@\n   return \\\"srax %1,%2,%0\\\";\n }\")\n \n+(define_insn \"ashrdi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&h,&h,r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,0,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"*return sparc_v8plus_shift (operands, insn, \\\"srax\\\");\"\n+  [(set_attr \"length\" \"5,5,6\")])\n+\n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -5215,7 +5425,21 @@\n }\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"lshrdi3\"\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_ARCH64 || TARGET_V8PLUS\"\n+  \"\n+if (! TARGET_ARCH64)\n+  {\n+    if (GET_CODE (operands[2]) == CONST_INT)\n+      FAIL;\n+    emit_insn (gen_lshrdi3_v8plus (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\")\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n@@ -5228,6 +5452,15 @@\n \n   return \\\"srlx %1,%2,%0\\\";\n }\")\n+\n+(define_insn \"lshrdi3_v8plus\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&h,&h,r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,0,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"*return sparc_v8plus_shift (operands, insn, \\\"srlx\\\");\"\n+  [(set_attr \"length\" \"5,5,6\")])\n \f\n ;; Unconditional and other jump instructions\n ;; On the Sparc, by setting the annul bit on an unconditional branch, the\n@@ -5658,7 +5891,15 @@\n    (use (reg:SI 31))]\n   \"! TARGET_EPILOGUE\"\n   \"* return output_return (operands);\"\n-  [(set_attr \"type\" \"multi\")])\n+  [(set_attr \"type\" \"return\")])\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"arith_operand\" \"rI\"))\n+   (parallel [(return)\n+\t      (use (reg:SI 31))])]\n+  \"sparc_return_peephole_ok (operands[0], operands[1])\"\n+  \"return %%i7+8\\;mov %Y1,%Y0\")\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -5684,10 +5925,10 @@\n \n ;; ??? Doesn't work with -mflat.\n (define_expand \"nonlocal_goto\"\n-  [(match_operand:SI 0 \"\" \"\")\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n    (match_operand:SI 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"general_operand\" \"\")\n-   (match_operand:SI 3 \"general_operand\" \"\")]\n+   (match_operand:SI 3 \"\" \"\")]\n   \"\"\n   \"\n {\n@@ -5715,15 +5956,20 @@\n      and reload the appropriate value into %fp.  */\n   emit_move_insn (frame_pointer_rtx, stack);\n \n-  /* Put in the static chain register the nonlocal label address.  */\n-  emit_move_insn (static_chain_rtx, chain);\n-\n   /* USE of frame_pointer_rtx added for consistency; not clear if\n      really needed.  */\n-  emit_insn (gen_rtx (USE, VOIDmode, frame_pointer_rtx));\n+  /*emit_insn (gen_rtx (USE, VOIDmode, frame_pointer_rtx));*/\n   emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n-  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n   /* Return, restoring reg window and jumping to goto handler.  */\n+  if (TARGET_V9 && GET_CODE (chain) == CONST_INT)\n+    {\n+      emit_insn (gen_goto_handler_and_restore_v9 (static_chain_rtx, chain));\n+      emit_barrier ();\n+      DONE;\n+    }\n+  /* Put in the static chain register the nonlocal label address.  */\n+  emit_move_insn (static_chain_rtx, chain);\n+  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n   emit_insn (gen_goto_handler_and_restore ());\n   emit_barrier ();\n   DONE;\n@@ -5733,22 +5979,32 @@\n (define_insn \"flush_register_windows\"\n   [(unspec_volatile [(const_int 0)] 1)]\n   \"\"\n-  ;; ??? Use TARGET_V9 instead?\n-  \"* return TARGET_ARCH64 ? \\\"flushw\\\" : \\\"ta 3\\\";\"\n+  \"* return TARGET_V9 ? \\\"flushw\\\" : \\\"ta 3\\\";\"\n   [(set_attr \"type\" \"misc\")])\n \n (define_insn \"goto_handler_and_restore\"\n-  [(unspec_volatile [(const_int 0)] 2)\n-   (use (reg:SI 8))]\n-  \"\"\n+  [(unspec_volatile [(reg:SI 8)] 2)]\n+  \"! TARGET_V9\"\n   \"jmp %%o0+0\\;restore\"\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2\")])\n \n-;; Implement setjmp.  Step one, set up the buffer.\n+(define_insn \"goto_handler_and_restore_v9\"\n+  [(unspec_volatile [(reg:SI 8)\n+\t\t     (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t\t     (match_operand:SI 1 \"const_int_operand\" \"I,n\")] 3)]\n+  \"TARGET_V9\"\n+  \"@\n+   return %%o0+0\\;mov %1,%Y0\n+   sethi %%hi(%1),%0\\;return %%o0+0\\;or %Y0,%%lo(%1),%Y0\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"2,3\")])\n+\n+;; Pattern for use after a setjmp to store FP and the return register\n+;; into the stack area.\n \n-(define_expand \"builtin_setjmp_setup\"\n-  [(unspec [(match_operand 0 \"\" \"\")] 3)]\n+(define_expand \"setjmp\"\n+  [(const_int 0)]\n   \"\"\n   \"\n {\n@@ -6146,54 +6402,6 @@\n    && ! FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n   \"orcc %1,0,%0\")\n \n-;; Do {sign,zero}-extended compares somewhat more efficiently.\n-;; ??? Is this now the Right Way to do this?  Or will SCRATCH\n-;;     eventually have some impact here?\n-\n-(define_peephole\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(match_operand:HI 1 \"memory_operand\" \"\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_dup 0)))\n-   (set (reg:CC 100)\n-\t(compare:CC (match_dup 2)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  \"ldsh %1,%0\\;orcc %0,0,%2\")\n-\n-(define_peephole\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(match_operand:HI 1 \"memory_operand\" \"\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"\")\n-\t(sign_extend:DI (match_dup 0)))\n-   (set (reg:CCX 100)\n-\t(compare:CCX (match_dup 2)\n-\t\t     (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  \"ldsh %1,%0\\;orcc %0,0,%2\")\n-\n-(define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(match_operand:QI 1 \"memory_operand\" \"\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_dup 0)))\n-   (set (reg:CC 100)\n-\t(compare:CC (match_dup 2)\n-\t\t    (const_int 0)))]\n-  \"\"\n-  \"ldsb %1,%0\\;orcc %0,0,%2\")\n-\n-(define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(match_operand:QI 1 \"memory_operand\" \"\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"\")\n-\t(sign_extend:DI (match_dup 0)))\n-   (set (reg:CCX 100)\n-\t(compare:CCX (match_dup 2)\n-\t\t     (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  \"ldsb %1,%0\\;orcc %0,0,%2\")\n-\n ;; Floating-point move peepholes\n ;; ??? v9: Do we want similar ones?\n \n@@ -6235,6 +6443,9 @@\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n     return \\\"jmp %%i7+12\\;restore %%g0,%1,%Y0\\\";\n+  else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n+\t\t\t || IN_OR_GLOBAL_P (operands[1])))\n+    return \\\"return %%i7+8\\;mov %Y1,%Y0\\\";\n   else\n     return \\\"ret\\;restore %%g0,%1,%Y0\\\";\n }\"\n@@ -6249,6 +6460,9 @@\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n     return \\\"jmp %%i7+12\\;restore %%g0,%1,%Y0\\\";\n+  else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n+\t\t\t || IN_OR_GLOBAL_P (operands[1])))\n+    return \\\"return %%i7+8\\;mov %Y1,%Y0\\\";\n   else\n     return \\\"ret\\;restore %%g0,%1,%Y0\\\";\n }\"\n@@ -6263,6 +6477,9 @@\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n     return \\\"jmp %%i7+12\\;restore %%g0,%1,%Y0\\\";\n+  else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n+\t\t\t || IN_OR_GLOBAL_P (operands[1])))\n+    return \\\"return %%i7+8\\;mov %Y1,%Y0\\\";\n   else\n     return \\\"ret\\;restore %%g0,%1,%Y0\\\";\n }\"\n@@ -6280,23 +6497,28 @@\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n     return \\\"jmp %%i7+12\\;restore %%g0,%1,%Y0\\\";\n+  else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1]))\n+    return \\\"return %%i7+8\\;mov %Y1,%Y0\\\";\n   else\n     return \\\"ret\\;restore %%g0,%1,%Y0\\\";\n }\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"*return_addsi\"\n   [(set (match_operand:SI 0 \"restore_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n    (return)]\n-  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\n-   && (register_operand (operands[1], SImode)\n-       || register_operand (operands[2], SImode))\"\n+  \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\"\n   \"*\n {\n   if (! TARGET_ARCH64 && current_function_returns_struct)\n     return \\\"jmp %%i7+12\\;restore %r1,%2,%Y0\\\";\n+  /* If operands are global or in registers, can use return */\n+  else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1])\n+\t   && (GET_CODE (operands[2]) == CONST_INT\n+\t       || IN_OR_GLOBAL_P (operands[2])))\n+    return \\\"return %%i7+8\\;add %Y1,%Y2,%Y0\\\";\n   else\n     return \\\"ret\\;restore %r1,%2,%Y0\\\";\n }\""}]}