{"sha": "d3b1cbddab28e0b7188257f59acbbec5d47f1eb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNiMWNiZGRhYjI4ZTBiNzE4ODI1N2Y1OWFjYmJlYzVkNDdmMWViNQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2015-05-28T12:52:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-28T12:52:55Z"}, "message": "sem_util.adb (Requires_Transient_Scope): Avoid returning function results on the secondary stack in so many cases.\n\n2015-05-28  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.adb (Requires_Transient_Scope): Avoid returning\n\tfunction results on the secondary stack in so many cases.\n\nFrom-SVN: r223814", "tree": {"sha": "624d834c6cd9508d145381a6eabb39fb0a0f2cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/624d834c6cd9508d145381a6eabb39fb0a0f2cae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98fc3d49dab880e42163a9e661048fdf9e8a5995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98fc3d49dab880e42163a9e661048fdf9e8a5995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98fc3d49dab880e42163a9e661048fdf9e8a5995"}], "stats": {"total": 198, "additions": 181, "deletions": 17}, "files": [{"sha": "7975d323f5db84790fca4f2d4ed785786a85bc68", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d3b1cbddab28e0b7188257f59acbbec5d47f1eb5", "patch": "@@ -1,3 +1,8 @@\n+2015-05-28  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.adb (Requires_Transient_Scope): Avoid returning\n+\tfunction results on the secondary stack in so many cases.\n+\n 2015-05-28  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_util.adb (Wrong_Type): In any instance, do not emit error"}, {"sha": "ecead06b4f81c532aa67b0dc911e0387cf52fa34", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 176, "deletions": 17, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1cbddab28e0b7188257f59acbbec5d47f1eb5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d3b1cbddab28e0b7188257f59acbbec5d47f1eb5", "patch": "@@ -16951,13 +16951,49 @@ package body Sem_Util is\n    ------------------------------\n \n    --  A transient scope is required when variable-sized temporaries are\n-   --  allocated in the primary or secondary stack, or when finalization\n-   --  actions must be generated before the next instruction.\n+   --  allocated on the secondary stack, or when finalization actions must be\n+   --  generated before the next instruction.\n+\n+   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n+   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n+   --  ???We retain the old and new algorithms for Requires_Transient_Scope for\n+   --  the time being. New_Requires_Transient_Scope is used by default; the\n+   --  debug switch -gnatdQ can be used to do Old_Requires_Transient_Scope\n+   --  instead. The intent is to use this temporarily to measure before/after\n+   --  efficiency. Note: when this temporary code is removed, the documentation\n+   --  of dQ in debug.adb should be removed.\n \n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n-      Typ : constant Entity_Id := Underlying_Type (Id);\n+      Old_Result : constant Boolean := Old_Requires_Transient_Scope (Id);\n+\n+   begin\n+      if Debug_Flag_QQ then\n+         return Old_Result;\n+      end if;\n+\n+      declare\n+         New_Result : constant Boolean := New_Requires_Transient_Scope (Id);\n+\n+      begin\n+         --  Assert that we're not putting things on the secondary stack if we\n+         --  didn't before; we are trying to AVOID secondary stack when\n+         --  possible.\n+\n+         if not Old_Result then\n+            pragma Assert (not New_Result);\n+            null;\n+         end if;\n+\n+         return New_Result;\n+      end;\n+   end Requires_Transient_Scope;\n+\n+   ----------------------------------\n+   -- Old_Requires_Transient_Scope --\n+   ----------------------------------\n \n-   --  Start of processing for Requires_Transient_Scope\n+   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n+      Typ : constant Entity_Id := Underlying_Type (Id);\n \n    begin\n       --  This is a private type which is not completed yet. This can only\n@@ -16989,28 +17025,28 @@ package body Sem_Util is\n       --  returned value is allocated on the secondary stack. Controlled\n       --  type temporaries need finalization.\n \n-      elsif Is_Tagged_Type (Typ)\n-        or else Has_Controlled_Component (Typ)\n-      then\n+      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n          return not Is_Value_Type (Typ);\n \n       --  Record type\n \n       elsif Is_Record_Type (Typ) then\n          declare\n             Comp : Entity_Id;\n+\n          begin\n             Comp := First_Entity (Typ);\n             while Present (Comp) loop\n                if Ekind (Comp) = E_Component then\n+\n                   --  ???It's not clear we need a full recursive call to\n-                  --  Requires_Transient_Scope here. Note that the following\n-                  --  can't happen.\n+                  --  Old_Requires_Transient_Scope here. Note that the\n+                  --  following can't happen.\n \n                   pragma Assert (Is_Definite_Subtype (Etype (Comp)));\n                   pragma Assert (not Has_Controlled_Component (Etype (Comp)));\n \n-                  if Requires_Transient_Scope (Etype (Comp)) then\n+                  if Old_Requires_Transient_Scope (Etype (Comp)) then\n                      return True;\n                   end if;\n                end if;\n@@ -17033,7 +17069,7 @@ package body Sem_Util is\n \n          --  If component type requires a transient scope, the array does too\n \n-         if Requires_Transient_Scope (Component_Type (Typ)) then\n+         if Old_Requires_Transient_Scope (Component_Type (Typ)) then\n             return True;\n \n          --  Otherwise, we only need a transient scope if the size depends on\n@@ -17049,7 +17085,132 @@ package body Sem_Util is\n          pragma Assert (Is_Protected_Type (Typ) or else Is_Task_Type (Typ));\n          return False;\n       end if;\n-   end Requires_Transient_Scope;\n+   end Old_Requires_Transient_Scope;\n+\n+   ----------------------------------\n+   -- New_Requires_Transient_Scope --\n+   ----------------------------------\n+\n+   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n+\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n+      --  This is called for untagged records and protected types, with\n+      --  nondefaulted discriminants. Returns True if the size of function\n+      --  results is known at the call site, False otherwise. Returns False\n+      --  if there is a variant part that depends on the discriminants of\n+      --  this type, or if there is an array constrained by the discriminants\n+      --  of this type. ???Currently, this is overly conservative (the array\n+      --  could be nested inside some other record that is constrained by\n+      --  nondiscriminants). That is, the recursive calls are too conservative.\n+\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+      begin\n+         if Has_Variant_Part (Typ) and then not Is_Definite_Subtype (Typ) then\n+            return False;\n+         end if;\n+\n+         declare\n+            Comp : Entity_Id := First_Entity (Typ);\n+\n+         begin\n+            while Present (Comp) loop\n+\n+               --  Only look at E_Component entities. No need to look at\n+               --  E_Discriminant entities, and we must ignore internal\n+               --  subtypes generated for constrained components.\n+\n+               if Ekind (Comp) = E_Component then\n+                  declare\n+                     Comp_Type : constant Entity_Id :=\n+                                   Underlying_Type (Etype (Comp));\n+\n+                  begin\n+                     if Is_Record_Type (Comp_Type)\n+                           or else\n+                        Is_Protected_Type (Comp_Type)\n+                     then\n+                        if not Caller_Known_Size_Record (Comp_Type) then\n+                           return False;\n+                        end if;\n+\n+                     elsif Is_Array_Type (Comp_Type) then\n+                        if Size_Depends_On_Discriminant (Comp_Type) then\n+                           return False;\n+                        end if;\n+                     end if;\n+                  end;\n+               end if;\n+\n+               Next_Entity (Comp);\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Caller_Known_Size_Record;\n+\n+      --  Local deeclarations\n+\n+      Typ : constant Entity_Id := Underlying_Type (Id);\n+\n+   --  Start of processing for New_Requires_Transient_Scope\n+\n+   begin\n+      --  This is a private type which is not completed yet. This can only\n+      --  happen in a default expression (of a formal parameter or of a\n+      --  record component). Do not expand transient scope in this case\n+\n+      if No (Typ) then\n+         return False;\n+\n+      --  Do not expand transient scope for non-existent procedure return or\n+      --  string literal types.\n+\n+      elsif Typ = Standard_Void_Type\n+        or else Ekind (Typ) = E_String_Literal_Subtype\n+      then\n+         return False;\n+\n+      --  Functions returning tagged types may dispatch on result so their\n+      --  returned value is allocated on the secondary stack, even in the\n+      --  definite case. Is_Tagged_Type includes controlled types and\n+      --  class-wide types. Controlled type temporaries need finalization.\n+      --  ???It's not clear why we need to return noncontrolled types with\n+      --  controlled components on the secondary stack. Also, it's not clear\n+      --  why nonprimitive tagged type functions need the secondary stack,\n+      --  since they can't be called via dispatching.\n+\n+      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n+         return not Is_Value_Type (Typ);\n+\n+      --  Indefinite (discriminated) untagged record or protected type\n+\n+      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n+         return not Caller_Known_Size_Record (Typ);\n+         --  ???Should come after Is_Definite_Subtype below\n+\n+      --  Untagged definite subtypes are known size. This includes all\n+      --  elementary [sub]types. Tasks are known size even if they have\n+      --  discriminants.\n+\n+      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n+         if Is_Array_Type (Typ) -- ???Shouldn't be necessary\n+           and then New_Requires_Transient_Scope\n+                      (Underlying_Type (Component_Type (Typ)))\n+         then\n+            return True;\n+         end if;\n+\n+         return False;\n+\n+      --  Unconstrained array\n+\n+      else\n+         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n+         return True;\n+      end if;\n+   end New_Requires_Transient_Scope;\n \n    --------------------------\n    -- Reset_Analyzed_Flags --\n@@ -19028,14 +19189,12 @@ package body Sem_Util is\n          then\n             return;\n \n-         --  Conversely, type of expression may be the private one.\n+         --  Conversely, type of expression may be the private one\n \n          elsif Is_Private_Type (Base_Type (Etype (Expr)))\n-           and then Full_View (Base_Type (Etype (Expr))) =\n-             Expected_Type\n+           and then Full_View (Base_Type (Etype (Expr))) = Expected_Type\n          then\n             return;\n-\n          end if;\n       end if;\n \n@@ -19049,11 +19208,11 @@ package body Sem_Util is\n         and then Has_One_Matching_Field\n       then\n          Error_Msg_N (\"positional aggregate cannot have one component\", Expr);\n+\n          if Present (Matching_Field) then\n             if Is_Array_Type (Expec_Type) then\n                Error_Msg_NE\n                  (\"\\write instead `&''First ='> ...`\", Expr, Matching_Field);\n-\n             else\n                Error_Msg_NE\n                  (\"\\write instead `& ='> ...`\", Expr, Matching_Field);"}]}