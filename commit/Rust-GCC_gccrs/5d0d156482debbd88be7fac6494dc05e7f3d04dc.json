{"sha": "5d0d156482debbd88be7fac6494dc05e7f3d04dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwZDE1NjQ4MmRlYmJkODhiZTdmYWM2NDk0ZGMwNWU3ZjNkMDRkYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-10-27T11:18:45Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-27T11:18:45Z"}, "message": "w32-unwind.h (i386_w32_fallback_frame_state): Fix regnum of EBP.\n\n\t* config/i386/w32-unwind.h (i386_w32_fallback_frame_state): Fix regnum\n\tof EBP.  Do not restore reg #9.  Remove +1 adjustment to EIP and set\n\tfs->signal_frame instead.\n\nCo-Authored-By: Olivier Hainque <hainque@adacore.com>\n\nFrom-SVN: r165998", "tree": {"sha": "4b3a23d80a8f27ba5e5d904c6d346b0bb704cca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b3a23d80a8f27ba5e5d904c6d346b0bb704cca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d0d156482debbd88be7fac6494dc05e7f3d04dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0d156482debbd88be7fac6494dc05e7f3d04dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d0d156482debbd88be7fac6494dc05e7f3d04dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0d156482debbd88be7fac6494dc05e7f3d04dc/comments", "author": null, "committer": null, "parents": [{"sha": "200290f23991f50e04f2ac5c4341f055db72bea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200290f23991f50e04f2ac5c4341f055db72bea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200290f23991f50e04f2ac5c4341f055db72bea5"}], "stats": {"total": 35, "additions": 17, "deletions": 18}, "files": [{"sha": "3702140518d589c5fab3dfc2515c7b2c99c03fb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0d156482debbd88be7fac6494dc05e7f3d04dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0d156482debbd88be7fac6494dc05e7f3d04dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d0d156482debbd88be7fac6494dc05e7f3d04dc", "patch": "@@ -1,3 +1,10 @@\n+2010-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n+            Olivier Hainque  <hainque@adacore.com>\n+\n+\t* config/i386/w32-unwind.h (i386_w32_fallback_frame_state): Fix regnum\n+\tof EBP.  Do not restore reg #9.  Remove +1 adjustment to EIP and set\n+\tfs->signal_frame instead.\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-parser.c (c_parser_objc_at_property_declaration): Recognize"}, {"sha": "449e9a9c5d6211127858014e1a1312524efa5616", "filename": "gcc/config/i386/w32-unwind.h", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0d156482debbd88be7fac6494dc05e7f3d04dc/gcc%2Fconfig%2Fi386%2Fw32-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0d156482debbd88be7fac6494dc05e7f3d04dc/gcc%2Fconfig%2Fi386%2Fw32-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fw32-unwind.h?ref=5d0d156482debbd88be7fac6494dc05e7f3d04dc", "patch": "@@ -1,5 +1,5 @@\n-/* Definitions for Dwarf2 EH unwind support for Windows32 targets \n-   Copyright (C) 2007, 2009\n+/* Definitions for Dwarf2 EH unwind support for Windows32 targets\n+   Copyright (C) 2007, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Pascal Obry  <obry@adacore.com>\n \n@@ -129,7 +129,6 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,\n \n   /* In the test below we look for two specific patterns found\n      experimentally to be in the Windows signal handler.  */\n-\n   if (SIG_PAT1 || SIG_PAT2 || SIG_SEH1 || SIG_SEH2)\n     {\n       PEXCEPTION_POINTERS weinfo_;\n@@ -147,14 +146,12 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,\n \t}\n \n       /* The new context frame address is the stack pointer.  */\n-\n       new_cfa_ = proc_ctx_->Esp;\n       fs->regs.cfa_how = CFA_REG_OFFSET;\n       fs->regs.cfa_reg = __builtin_dwarf_sp_column();\n       fs->regs.cfa_offset = new_cfa_ - (long) ctx_cfa_;\n \n-      /* Save some registers.  */\n-\n+      /* Restore registers.  */\n       fs->regs.reg[0].how = REG_SAVED_OFFSET;\n       fs->regs.reg[0].loc.offset = (long)&proc_ctx_->Eax - new_cfa_;\n       fs->regs.reg[3].how = REG_SAVED_OFFSET;\n@@ -167,26 +164,20 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,\n       fs->regs.reg[6].loc.offset = (long)&proc_ctx_->Esi - new_cfa_;\n       fs->regs.reg[7].how = REG_SAVED_OFFSET;\n       fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;\n-      fs->regs.reg[9].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[9].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;\n-      fs->regs.reg[4].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[4].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;\n-\n-      /* Set the return address to Eip + 1. As we can be called multiple\n-\t times we use another register for this.  */\n-      \n-      proc_ctx_->Dr0 = proc_ctx_->Eip + 1;\n+      fs->regs.reg[5].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[5].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;\n       fs->regs.reg[8].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Dr0 - new_cfa_;\n+      fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;\n       fs->retaddr_column = 8;\n+      fs->signal_frame = 1;\n+\n       return _URC_NO_REASON;\n     }\n \n   /* Unwinding through _alloca, propagating from a trap triggered by\n      one of it's probes prior to the real SP adjustment. The only\n      operations of interest performed is \"pushl %ecx\", followed by\n      ecx clobbering.  */\n-\n   else if (SIG_ALLOCA) \n     {\n       /* Only one push between entry in _alloca and the probe trap.  */ \n@@ -204,7 +195,8 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,\n       fs->retaddr_column = 8;\n       fs->regs.reg[8].how = REG_SAVED_OFFSET;\n       fs->regs.reg[8].loc.offset = 0;\n- \n+      fs->signal_frame = 1;\n+\n       return _URC_NO_REASON;\n     }\n   else"}]}