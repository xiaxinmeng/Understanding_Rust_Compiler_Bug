{"sha": "2094f1fcd65fc95e28f2704da10d367700e96571", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5NGYxZmNkNjVmYzk1ZTI4ZjI3MDRkYTEwZDM2NzcwMGU5NjU3MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-07-02T20:45:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-07-02T20:45:00Z"}, "message": "ipa-split.c (verify_non_ssa_vars): Break out from ......\n\n\n\t* ipa-split.c (verify_non_ssa_vars): Break out from ...; perform DFS walk\n\tbackwards from entry_bb to check only those basic block of header\n\tthat might lead to execution of split part.\n\t(consider_split) ... here.\n\t(find_return_bb): Allow assignment in return BB.\n\t(find_retval): New.\n\t(split_function): Fix name of cloned function; take care of updating return\n\tvalue in return_bb containing move.\n\n\t* gcc.dg/tree-ssa/ipa-split-5.c: New function.\n\nFrom-SVN: r161744", "tree": {"sha": "a069aef035ff71c61c1fb53b85efe763eac1e131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a069aef035ff71c61c1fb53b85efe763eac1e131"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2094f1fcd65fc95e28f2704da10d367700e96571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2094f1fcd65fc95e28f2704da10d367700e96571", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2094f1fcd65fc95e28f2704da10d367700e96571", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2094f1fcd65fc95e28f2704da10d367700e96571/comments", "author": null, "committer": null, "parents": [{"sha": "c21ae2bfce8a4b50b6f87224809c6685999def30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21ae2bfce8a4b50b6f87224809c6685999def30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21ae2bfce8a4b50b6f87224809c6685999def30"}], "stats": {"total": 285, "additions": 209, "deletions": 76}, "files": [{"sha": "1f797b72fec060c9ef3f37a72e67d85180c40125", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2094f1fcd65fc95e28f2704da10d367700e96571", "patch": "@@ -1,3 +1,14 @@\n+2010-07-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-split.c (verify_non_ssa_vars): Break out from ...; perform DFS walk\n+\tbackwards from entry_bb to check only those basic block of header\n+\tthat might lead to execution of split part.\n+\t(consider_split) ... here.\n+\t(find_return_bb): Allow assignment in return BB.\n+\t(find_retval): New.\n+\t(split_function): Fix name of cloned function; take care of updating return\n+\tvalue in return_bb containing move.\n+\n 2010-07-02  Andreas Schwab  <schwab@linux-m68k.org>\n \n \tPR target/44771"}, {"sha": "0cec0b82907643d8189be8fc30ec9e4d2947e46e", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 157, "deletions": 76, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=2094f1fcd65fc95e28f2704da10d367700e96571", "patch": "@@ -159,6 +159,91 @@ dump_split_point (FILE * file, struct split_point *current)\n   dump_bitmap (file, current->ssa_names_to_pass);\n }\n \n+/* Look for all BBs in header that might lead to split part and verify that\n+   they are not defining any of SSA vars used by split part. \n+   Parameters are the same as for consider_split.  */\n+\n+static bool\n+verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n+\t\t     basic_block return_bb)\n+{\n+  bitmap seen = BITMAP_ALLOC (NULL);\n+  VEC (basic_block,heap) *worklist = NULL;\n+  edge e;\n+  edge_iterator ei;\n+  bool ok = true;\n+  \n+  FOR_EACH_EDGE (e, ei, current->entry_bb->preds)\n+    if (e->src != ENTRY_BLOCK_PTR\n+\t&& !bitmap_bit_p (current->split_bbs, e->src->index))\n+      {\n+        VEC_safe_push (basic_block, heap, worklist, e->src);\n+\tbitmap_set_bit (seen, e->src->index);\n+      }\n+  \n+  while (!VEC_empty (basic_block, worklist))\n+    {\n+      gimple_stmt_iterator bsi;\n+      basic_block bb = VEC_pop (basic_block, worklist);\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->src != ENTRY_BLOCK_PTR\n+\t    && !bitmap_bit_p (seen, e->src->index))\n+\t  {\n+\t    gcc_checking_assert (!bitmap_bit_p (current->split_bbs,\n+\t\t\t\t\t        e->src->index));\n+\t    VEC_safe_push (basic_block, heap, worklist, e->src);\n+\t    bitmap_set_bit (seen, e->src->index);\n+\t  }\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  if (is_gimple_debug (gsi_stmt (bsi)))\n+\t    continue;\n+\t  if (walk_stmt_load_store_addr_ops\n+\t      (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n+\t       test_nonssa_use, test_nonssa_use))\n+\t    {\n+\t      ok = false;\n+\t      goto done;\n+\t    }\n+\t}\n+      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  if (walk_stmt_load_store_addr_ops\n+\t      (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n+\t       test_nonssa_use, test_nonssa_use))\n+\t    {\n+\t      ok = false;\n+\t      goto done;\n+\t    }\n+\t}\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->dest != return_bb)\n+\t    continue;\n+\t  for (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi);\n+\t       gsi_next (&bsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (bsi);\n+\t      tree op = gimple_phi_arg_def (stmt, e->dest_idx);\n+\n+\t      if (!is_gimple_reg (gimple_phi_result (stmt)))\n+\t\tcontinue;\n+\t      if (TREE_CODE (op) != SSA_NAME\n+\t\t  && test_nonssa_use (stmt, op, non_ssa_vars))\n+\t\t{\n+\t\t  ok = false;\n+\t\t  goto done;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+done:\n+  BITMAP_FREE (seen);\n+  VEC_free (basic_block, heap, worklist);\n+  return ok;\n+}\n+\n /* We found an split_point CURRENT.  NON_SSA_VARS is bitmap of all non ssa\n    variables used and RETURN_BB is return basic block.\n    See if we can split function here.  */\n@@ -292,63 +377,12 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   /* When there are non-ssa vars used in the split region, see if they\n      are used in the header region.  If so, reject the split.\n      FIXME: we can use nested function support to access both.  */\n-  if (!bitmap_empty_p (non_ssa_vars))\n+  if (!bitmap_empty_p (non_ssa_vars)\n+      && !verify_non_ssa_vars (current, non_ssa_vars, return_bb))\n     {\n-      basic_block bb;\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  gimple_stmt_iterator bsi;\n-\t  if (!bitmap_bit_p (current->split_bbs, bb->index))\n-\t    continue;\n-\t  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t    {\n-\t      if (is_gimple_debug (gsi_stmt (bsi)))\n-\t\tcontinue;\n-\t      if (walk_stmt_load_store_addr_ops\n-\t\t  (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n-\t\t   test_nonssa_use, test_nonssa_use))\n-\t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"  Refused: split part has non-ssa uses\\n\");\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t    {\n-\t      if (walk_stmt_load_store_addr_ops\n-\t\t  (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n-\t\t   test_nonssa_use, test_nonssa_use))\n-\t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"  Refused: split part has non-ssa uses\\n\");\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      if (e->dest != return_bb)\n-\t\tcontinue;\n-\t      for (bsi = gsi_start_phis (return_bb); !gsi_end_p (bsi);\n-\t\t   gsi_next (&bsi))\n-\t\t{\n-\t\t  gimple stmt = gsi_stmt (bsi);\n-\t\t  tree op = gimple_phi_arg_def (stmt, e->dest_idx);\n-\n-\t\t  if (!is_gimple_reg (gimple_phi_result (stmt)))\n-\t\t    continue;\n-\t\t  if (TREE_CODE (op) != SSA_NAME\n-\t\t      && test_nonssa_use (stmt, op, non_ssa_vars))\n-\t\t    {\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"  Refused: split part has non-ssa uses\\n\");\n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  }\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: split part has non-ssa uses\\n\");\n       return;\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -379,10 +413,20 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n     }\n }\n \n-/* Return basic block containing RETURN statement, or EXIT_BLOCK_PTR if none\n-   found. \n+/* Return basic block containing RETURN statement.  We allow basic blocks\n+   of the form:\n+   <retval> = tmp_var;\n+   return <retval>\n+   but return_bb can not be more complex than this.\n+   If nothing is found, return EXIT_BLOCK_PTR.\n+\n    When there are multiple RETURN statement, chose one with return value,\n    since that one is more likely shared by multiple code paths.\n+\n+   Return BB is special, because for function splitting it is the only\n+   basic block that is duplicated in between header and split part of the\n+   function.\n+\n    TODO: We might support multiple return blocks.  */\n \n static basic_block\n@@ -399,16 +443,29 @@ find_return_bb (void)\n \tbool found_return = false;\n \ttree retval = NULL_TREE;\n \n-\tfor (bsi = gsi_start_bb (e->src); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t  if (gimple_code (gsi_stmt (bsi)) != GIMPLE_RETURN\n-\t      && gimple_code (gsi_stmt (bsi)) != GIMPLE_LABEL\n-\t      && !is_gimple_debug (gsi_stmt (bsi)))\n-\t    break;\n-\t  else if (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n-\t    {\n-\t      found_return = true;\n-\t      retval = gimple_return_retval (gsi_stmt (bsi));\n-\t    }\n+\tfor (bsi = gsi_last_bb (e->src); !gsi_end_p (bsi); gsi_prev (&bsi))\n+\t  {\n+\t    gimple stmt = gsi_stmt (bsi);\n+\t    if (gimple_code (stmt) == GIMPLE_LABEL\n+\t\t|| is_gimple_debug (stmt))\n+\t      ;\n+\t    else if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t     && found_return\n+\t\t     && gimple_assign_single_p (stmt)\n+\t\t     && (auto_var_in_fn_p (gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t   current_function_decl)\n+\t\t\t || is_gimple_min_invariant\n+\t\t\t      (gimple_assign_rhs1 (stmt)))\n+\t\t     && retval == gimple_assign_lhs (stmt))\n+\t      ;\n+\t    else if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t      {\n+\t\tfound_return = true;\n+\t\tretval = gimple_return_retval (stmt);\n+\t      }\n+\t    else\n+\t      break;\n+\t  }\n \tif (gsi_end_p (bsi) && found_return)\n \t  {\n \t    if (retval)\n@@ -420,6 +477,20 @@ find_return_bb (void)\n   return return_bb;\n }\n \n+/* Given return basicblock RETURN_BB, see where return value is really\n+   stored.  */\n+static tree\n+find_retval (basic_block return_bb)\n+{\n+  gimple_stmt_iterator bsi;\n+  for (bsi = gsi_start_bb (return_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n+      return gimple_return_retval (gsi_stmt (bsi));\n+    else if (gimple_code (gsi_stmt (bsi)) == GIMPLE_ASSIGN)\n+      return gimple_assign_rhs1 (gsi_stmt (bsi));\n+  return NULL;\n+}\n+\n /* Callback for walk_stmt_load_store_addr_ops.  If T is non-ssa automatic\n    variable, mark it as used in bitmap passed via DATA. \n    Return true when access to T prevents splitting the function.  */\n@@ -844,7 +915,7 @@ split_function (struct split_point *split_point)\n \t\t\t\t     NULL, NULL,\n \t\t\t\t     args_to_skip,\n \t\t\t\t     split_point->split_bbs,\n-\t\t\t\t     split_point->entry_bb, \"_part\");\n+\t\t\t\t     split_point->entry_bb, \"part\");\n   /* For usual cloning it is enough to clear builtin only when signature\n      changes.  For partial inlining we however can not expect the part\n      of builtin implementation to have same semantic as the whole.  */\n@@ -891,17 +962,15 @@ split_function (struct split_point *split_point)\n       e->probability = REG_BR_PROB_BASE;\n       if (return_bb != EXIT_BLOCK_PTR)\n \t{\n-\t  gimple return_stmt = gsi_stmt (gsi_last_bb (return_bb));\n-\t  gcc_assert (gimple_code (return_stmt) == GIMPLE_RETURN);\n-\n-\t  if ((real_retval = retval = gimple_return_retval (return_stmt))\n+\t  real_retval = retval = find_retval (return_bb);\n+\t  if (real_retval\n \t      && !is_gimple_min_invariant (retval)\n \t      && (TREE_CODE (retval) != SSA_NAME\n \t\t  || !SSA_NAME_IS_DEFAULT_DEF (retval)))\n \t    {\n \t      gimple_stmt_iterator psi;\n \n-\t      /* See if there is PHI definind return value.  */\n+\t      /* See if there is PHI defining return value.  */\n \t      for (psi = gsi_start_phis (return_bb);\n \t\t   !gsi_end_p (psi); gsi_next (&psi))\n \t\tif (is_gimple_reg (gimple_phi_result (gsi_stmt (psi))))\n@@ -917,8 +986,20 @@ split_function (struct split_point *split_point)\n \t\t    add_phi_arg (gsi_stmt (psi), retval, e, UNKNOWN_LOCATION);\n \t\t  else if (TREE_CODE (retval) == SSA_NAME)\n \t\t    {\n-\t\t      gimple_return_set_retval (return_stmt, retval);\n-\t\t      update_stmt (return_stmt);\n+\t\t      gimple_stmt_iterator bsi;\n+\t\t      for (bsi = gsi_start_bb (return_bb); !gsi_end_p (bsi);\n+\t\t\t   gsi_next (&bsi))\n+\t\t\tif (gimple_code (gsi_stmt (bsi)) == GIMPLE_RETURN)\n+\t\t\t  {\n+\t\t\t    gimple_return_set_retval (gsi_stmt (bsi), retval);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\telse if (gimple_code (gsi_stmt (bsi)) == GIMPLE_ASSIGN)\n+\t\t\t  {\n+\t\t\t    gimple_assign_set_rhs1 (gsi_stmt (bsi), retval);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      update_stmt (gsi_stmt (bsi));\n \t\t    }\n \t\t}\n \t      gimple_call_set_lhs (call, retval);"}, {"sha": "dc2a4ae8e5ea2d9be7416190bc5f5fc55b26432b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2094f1fcd65fc95e28f2704da10d367700e96571", "patch": "@@ -1,3 +1,7 @@\n+2010-07-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/ipa-split-5.c: New function.\n+\n 2010-07-02  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* objc-obj-c++-shared/Object1.h: Correct Line endings."}, {"sha": "bf0714902a6e4bcf77974738702382b881c8c79f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-split-5.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2094f1fcd65fc95e28f2704da10d367700e96571/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-5.c?ref=2094f1fcd65fc95e28f2704da10d367700e96571", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-fnsplit -fdump-tree-optimized\" } */\n+\n+struct a {int a,b;};\n+struct a make_me_big (int a);\n+struct a split_me (int a)\n+{\n+  struct a retval;\n+  if (__builtin_expect (a!=0,1))\n+    {\n+      retval.a = 0;\n+      retval.b = 0;\n+      return retval;\n+    }\n+  else\n+    {\n+      struct a retval = make_me_big (a);\n+      retval = make_me_big (a);\n+      retval = make_me_big (a);\n+      retval = make_me_big (a);\n+      retval = make_me_big (a);\n+      retval = make_me_big (a);\n+      return retval;\n+    }\n+}\n+int val;\n+test()\n+{\n+  split_me (val);\n+  split_me (val);\n+  split_me (val);\n+  split_me (val);\n+}\n+/* { dg-final { scan-tree-dump-times \"Splitting function\" 1 \"fnsplit\"} } */\n+/* { dg-final { cleanup-tree-dump \"fnsplit\" } } */\n+/* { dg-final { scan-tree-dump \"part\" \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}