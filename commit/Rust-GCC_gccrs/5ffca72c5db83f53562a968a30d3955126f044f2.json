{"sha": "5ffca72c5db83f53562a968a30d3955126f044f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZmY2E3MmM1ZGI4M2Y1MzU2MmE5NjhhMzBkMzk1NTEyNmYwNDRmMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:52:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:52:50Z"}, "message": "poly_int: indirect_refs_may_alias_p\n\nThis patch makes indirect_refs_may_alias_p use ranges_may_overlap_p\nrather than ranges_overlap_p.  Unlike the former, the latter can handle\nnegative offsets, so the fix for PR44852 should no longer be necessary.\nIt can also handle offset_int, so avoids unchecked truncations to\nHOST_WIDE_INT.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p)\n\t(indirect_refs_may_alias_p): Use ranges_may_overlap_p\n\tinstead of ranges_overlap_p.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255871", "tree": {"sha": "bb7b663dcf920a1865d4d09bbed71529f3be5e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb7b663dcf920a1865d4d09bbed71529f3be5e80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ffca72c5db83f53562a968a30d3955126f044f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffca72c5db83f53562a968a30d3955126f044f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ffca72c5db83f53562a968a30d3955126f044f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffca72c5db83f53562a968a30d3955126f044f2/comments", "author": null, "committer": null, "parents": [{"sha": "b506575ff66ca6e62494b000ae68c182c7b22573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b506575ff66ca6e62494b000ae68c182c7b22573", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b506575ff66ca6e62494b000ae68c182c7b22573"}], "stats": {"total": 57, "additions": 18, "deletions": 39}, "files": [{"sha": "d69e2441aede892b060ddde7a8c8c3b3ae52d861", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffca72c5db83f53562a968a30d3955126f044f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffca72c5db83f53562a968a30d3955126f044f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ffca72c5db83f53562a968a30d3955126f044f2", "patch": "@@ -1,3 +1,11 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p)\n+\t(indirect_refs_may_alias_p): Use ranges_may_overlap_p\n+\tinstead of ranges_overlap_p.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8717a1f356c449d3facbdcb2b75b9efadcecaa61", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ffca72c5db83f53562a968a30d3955126f044f2/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ffca72c5db83f53562a968a30d3955126f044f2/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=5ffca72c5db83f53562a968a30d3955126f044f2", "patch": "@@ -1135,23 +1135,13 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n {\n   tree ptr1;\n   tree ptrtype1, dbase2;\n-  HOST_WIDE_INT offset1p = offset1, offset2p = offset2;\n-  HOST_WIDE_INT doffset1, doffset2;\n \n   gcc_checking_assert ((TREE_CODE (base1) == MEM_REF\n \t\t\t|| TREE_CODE (base1) == TARGET_MEM_REF)\n \t\t       && DECL_P (base2));\n \n   ptr1 = TREE_OPERAND (base1, 0);\n-\n-  /* The offset embedded in MEM_REFs can be negative.  Bias them\n-     so that the resulting offset adjustment is positive.  */\n-  offset_int moff = mem_ref_offset (base1);\n-  moff <<= LOG2_BITS_PER_UNIT;\n-  if (wi::neg_p (moff))\n-    offset2p += (-moff).to_short_addr ();\n-  else\n-    offset1p += moff.to_short_addr ();\n+  offset_int moff = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n \n   /* If only one reference is based on a variable, they cannot alias if\n      the pointer access is beyond the extent of the variable access.\n@@ -1160,7 +1150,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n      ???  IVOPTs creates bases that do not honor this restriction,\n      so do not apply this optimization for TARGET_MEM_REFs.  */\n   if (TREE_CODE (base1) != TARGET_MEM_REF\n-      && !ranges_overlap_p (MAX (0, offset1p), -1, offset2p, max_size2))\n+      && !ranges_maybe_overlap_p (offset1 + moff, -1, offset2, max_size2))\n     return false;\n   /* They also cannot alias if the pointer may not point to the decl.  */\n   if (!ptr_deref_may_alias_decl_p (ptr1, base2))\n@@ -1213,18 +1203,11 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   dbase2 = ref2;\n   while (handled_component_p (dbase2))\n     dbase2 = TREE_OPERAND (dbase2, 0);\n-  doffset1 = offset1;\n-  doffset2 = offset2;\n+  HOST_WIDE_INT doffset1 = offset1;\n+  offset_int doffset2 = offset2;\n   if (TREE_CODE (dbase2) == MEM_REF\n       || TREE_CODE (dbase2) == TARGET_MEM_REF)\n-    {\n-      offset_int moff = mem_ref_offset (dbase2);\n-      moff <<= LOG2_BITS_PER_UNIT;\n-      if (wi::neg_p (moff))\n-\tdoffset1 -= (-moff).to_short_addr ();\n-      else\n-\tdoffset2 -= moff.to_short_addr ();\n-    }\n+    doffset2 -= mem_ref_offset (dbase2) << LOG2_BITS_PER_UNIT;\n \n   /* If either reference is view-converted, give up now.  */\n   if (same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) != 1\n@@ -1241,7 +1224,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if ((TREE_CODE (base1) != TARGET_MEM_REF\n        || (!TMR_INDEX (base1) && !TMR_INDEX2 (base1)))\n       && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1)\n-    return ranges_overlap_p (doffset1, max_size1, doffset2, max_size2);\n+    return ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2);\n \n   if (ref1 && ref2\n       && nonoverlapping_component_refs_p (ref1, ref2))\n@@ -1313,22 +1296,10 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t      && operand_equal_p (TMR_INDEX2 (base1),\n \t\t\t\t\t  TMR_INDEX2 (base2), 0))))))\n     {\n-      offset_int moff;\n-      /* The offset embedded in MEM_REFs can be negative.  Bias them\n-\t so that the resulting offset adjustment is positive.  */\n-      moff = mem_ref_offset (base1);\n-      moff <<= LOG2_BITS_PER_UNIT;\n-      if (wi::neg_p (moff))\n-\toffset2 += (-moff).to_short_addr ();\n-      else\n-\toffset1 += moff.to_shwi ();\n-      moff = mem_ref_offset (base2);\n-      moff <<= LOG2_BITS_PER_UNIT;\n-      if (wi::neg_p (moff))\n-\toffset1 += (-moff).to_short_addr ();\n-      else\n-\toffset2 += moff.to_short_addr ();\n-      return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n+      offset_int moff1 = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n+      offset_int moff2 = mem_ref_offset (base2) << LOG2_BITS_PER_UNIT;\n+      return ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n+\t\t\t\t     offset2 + moff2, max_size2);\n     }\n   if (!ptr_derefs_may_alias_p (ptr1, ptr2))\n     return false;"}]}