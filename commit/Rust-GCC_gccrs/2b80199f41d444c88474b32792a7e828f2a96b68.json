{"sha": "2b80199f41d444c88474b32792a7e828f2a96b68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI4MDE5OWY0MWQ0NDRjODg0NzRiMzI3OTJhN2U4MjhmMmE5NmI2OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-03-28T23:53:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-03-28T23:53:46Z"}, "message": "re PR debug/48203 (ICE in dwarf2out.c while building eglibc.)\n\n\tPR debug/48203\n\t* cfgexpand.c (expand_debug_expr) <case SSA_NAME>: Only\n\tcreate ENTRY_VALUE if incoming or address of incoming's MEM\n\tis a hard REG.\n\t* dwarf2out.c (mem_loc_descriptor): Don't emit\n\tDW_OP_GNU_entry_value of DW_OP_fbreg.\n\t* var-tracking.c (vt_add_function_parameter): Ensure cselib_lookup\n\ton ENTRY_VALUE is able to find the canonical parameter VALUE.\n\t* cselib.c (rtx_equal_for_cselib_1) <case ENTRY_VALUE>: Use\n\trtx_equal_p instead of rtx_equal_for_cselib_1 to compare\n\tENTRY_VALUE_EXPs.\n\t(cselib_hash_rtx) <case ENTRY_VALUE>: If ENTRY_VALUE_EXP\n\tis a REG_P or MEM_P with REG_P address, compute hash directly\n\tinstead of calling cselib_hash_rtx on ENTRY_VALUE_EXP.\n\t(preserve_only_constants): Don't clear VALUES forwaring\n\tENTRY_VALUE to some other VALUE.\n\n\t* gcc.dg/pr48203.c: New test.\n\nFrom-SVN: r171640", "tree": {"sha": "7d5601e9e49e4f8fa5cf78fc46ce899d76d94f4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d5601e9e49e4f8fa5cf78fc46ce899d76d94f4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b80199f41d444c88474b32792a7e828f2a96b68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b80199f41d444c88474b32792a7e828f2a96b68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b80199f41d444c88474b32792a7e828f2a96b68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b80199f41d444c88474b32792a7e828f2a96b68/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9da60aea69647fd7957dc328a8431412157d3a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9da60aea69647fd7957dc328a8431412157d3a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9da60aea69647fd7957dc328a8431412157d3a7"}], "stats": {"total": 153, "additions": 145, "deletions": 8}, "files": [{"sha": "f3ee4b54af9a73aa92ff9835c59745d2763aabb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -1,3 +1,22 @@\n+2011-03-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/48203\n+\t* cfgexpand.c (expand_debug_expr) <case SSA_NAME>: Only\n+\tcreate ENTRY_VALUE if incoming or address of incoming's MEM\n+\tis a hard REG.\n+\t* dwarf2out.c (mem_loc_descriptor): Don't emit\n+\tDW_OP_GNU_entry_value of DW_OP_fbreg.\n+\t* var-tracking.c (vt_add_function_parameter): Ensure cselib_lookup\n+\ton ENTRY_VALUE is able to find the canonical parameter VALUE.\n+\t* cselib.c (rtx_equal_for_cselib_1) <case ENTRY_VALUE>: Use\n+\trtx_equal_p instead of rtx_equal_for_cselib_1 to compare\n+\tENTRY_VALUE_EXPs.\n+\t(cselib_hash_rtx) <case ENTRY_VALUE>: If ENTRY_VALUE_EXP\n+\tis a REG_P or MEM_P with REG_P address, compute hash directly\n+\tinstead of calling cselib_hash_rtx on ENTRY_VALUE_EXP.\n+\t(preserve_only_constants): Don't clear VALUES forwaring\n+\tENTRY_VALUE to some other VALUE.\n+\n 2011-03-28  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* builtins.c (expand_builtin_memset_args): Use gen_int_mode"}, {"sha": "e075c53a461f98f26ebff57713e252504082dcbb", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -3172,8 +3172,10 @@ expand_debug_expr (tree exp)\n \t\t    rtx incoming = DECL_INCOMING_RTL (SSA_NAME_VAR (exp));\n \t\t    if (incoming\n \t\t\t&& GET_MODE (incoming) != BLKmode\n-\t\t\t&& (REG_P (incoming)\n-\t\t\t    || (MEM_P (incoming) && REG_P (XEXP (incoming, 0)))))\n+\t\t\t&& ((REG_P (incoming) && HARD_REGISTER_P (incoming))\n+\t\t\t    || (MEM_P (incoming)\n+\t\t\t\t&& REG_P (XEXP (incoming, 0))\n+\t\t\t\t&& HARD_REGISTER_P (XEXP (incoming, 0)))))\n \t\t      {\n \t\t\top0 = gen_rtx_ENTRY_VALUE (GET_MODE (incoming));\n \t\t\tENTRY_VALUE_EXP (op0) = incoming;"}, {"sha": "dff096752f5295fba0d4d83a3c6aed9b476a2c11", "filename": "gcc/cselib.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -305,7 +305,8 @@ cselib_clear_table (void)\n   cselib_reset_table (1);\n }\n \n-/* Remove from hash table all VALUEs except constants.  */\n+/* Remove from hash table all VALUEs except constants\n+   and function invariants.  */\n \n static int\n preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n@@ -329,6 +330,14 @@ preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n \t    return 1;\n \t}\n     }\n+  /* Keep around VALUEs that forward function invariant ENTRY_VALUEs\n+     to corresponding parameter VALUEs.  */\n+  if (v->locs != NULL\n+      && v->locs->next != NULL\n+      && v->locs->next->next == NULL\n+      && GET_CODE (v->locs->next->loc) == ENTRY_VALUE\n+      && GET_CODE (v->locs->loc) == VALUE)\n+    return 1;\n \n   htab_clear_slot (cselib_hash_table, x);\n   return 1;\n@@ -804,8 +813,9 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, enum machine_mode memmode)\n \t     == DEBUG_IMPLICIT_PTR_DECL (y);\n \n     case ENTRY_VALUE:\n-      return rtx_equal_for_cselib_1 (ENTRY_VALUE_EXP (x), ENTRY_VALUE_EXP (y),\n-\t\t\t\t     memmode);\n+      /* ENTRY_VALUEs are function invariant, it is thus undesirable to\n+\t use rtx_equal_for_cselib_1 to compare the operands.  */\n+      return rtx_equal_p (ENTRY_VALUE_EXP (x), ENTRY_VALUE_EXP (y));\n \n     case LABEL_REF:\n       return XEXP (x, 0) == XEXP (y, 0);\n@@ -954,7 +964,22 @@ cselib_hash_rtx (rtx x, int create, enum machine_mode memmode)\n       return hash ? hash : (unsigned int) DEBUG_IMPLICIT_PTR;\n \n     case ENTRY_VALUE:\n-      hash += cselib_hash_rtx (ENTRY_VALUE_EXP (x), create, memmode);\n+      /* ENTRY_VALUEs are function invariant, thus try to avoid\n+\t recursing on argument if ENTRY_VALUE is one of the\n+\t forms emitted by expand_debug_expr, otherwise\n+\t ENTRY_VALUE hash would depend on the current value\n+\t in some register or memory.  */\n+      if (REG_P (ENTRY_VALUE_EXP (x)))\n+\thash += (unsigned int) REG\n+\t\t+ (unsigned int) GET_MODE (ENTRY_VALUE_EXP (x))\n+\t\t+ (unsigned int) REGNO (ENTRY_VALUE_EXP (x));\n+      else if (MEM_P (ENTRY_VALUE_EXP (x))\n+\t       && REG_P (XEXP (ENTRY_VALUE_EXP (x), 0)))\n+\thash += (unsigned int) MEM\n+\t\t+ (unsigned int) GET_MODE (XEXP (ENTRY_VALUE_EXP (x), 0))\n+\t\t+ (unsigned int) REGNO (XEXP (ENTRY_VALUE_EXP (x), 0));\n+      else\n+\thash += cselib_hash_rtx (ENTRY_VALUE_EXP (x), create, memmode);\n       return hash ? hash : (unsigned int) ENTRY_VALUE;\n \n     case CONST_INT:"}, {"sha": "182a894666c8c98e33fe93c5b869bdd7a32acef9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -13891,7 +13891,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  dw_loc_descr_ref ref\n \t    = mem_loc_descriptor (ENTRY_VALUE_EXP (rtl), GET_MODE (rtl),\n \t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\t  if (ref == NULL)\n+\t  if (ref == NULL || ref->dw_loc_opc == DW_OP_fbreg)\n \t    return NULL;\n \t  mem_loc_result->dw_loc_oprnd1.v.val_loc = ref;\n \t}"}, {"sha": "513805d02082e09acca08f9ca13f8a334ccc5017", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -1,3 +1,8 @@\n+2011-03-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/48203\n+\t* gcc.dg/pr48203.c: New test.\n+\n 2011-03-28  Jeff Law <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/ssa-dom-thread-3.c: New test."}, {"sha": "b4b2b084ddb9de7edfc16b0851d46a739e6745b1", "filename": "gcc/testsuite/gcc.dg/pr48203.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48203.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48203.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48203.c?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -0,0 +1,51 @@\n+/* PR debug/48203 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g\" } */\n+\n+volatile int v;\n+\n+void\n+foo (long a, long b, long c, long d, long e, long f, long g, long h,\n+     long i, long j, long k, long l, long m, long n, long o, long p)\n+{\n+  long a2 = a;\n+  long b2 = b;\n+  long c2 = c;\n+  long d2 = d;\n+  long e2 = e;\n+  long f2 = f;\n+  long g2 = g;\n+  long h2 = h;\n+  long i2 = i;\n+  long j2 = j;\n+  long k2 = k;\n+  long l2 = l;\n+  long m2 = m;\n+  long n2 = n;\n+  long o2 = o;\n+  long p2 = p;\n+  v++;\n+}\n+\n+void\n+bar (int a, int b, int c, int d, int e, int f, int g, int h,\n+     int i, int j, int k, int l, int m, int n, int o, int p)\n+{\n+  int a2 = a;\n+  int b2 = b;\n+  int c2 = c;\n+  int d2 = d;\n+  int e2 = e;\n+  int f2 = f;\n+  int g2 = g;\n+  int h2 = h;\n+  int i2 = i;\n+  int j2 = j;\n+  int k2 = k;\n+  int l2 = l;\n+  int m2 = m;\n+  int n2 = n;\n+  int o2 = o;\n+  int p2 = p;\n+  v++;\n+}"}, {"sha": "972995644aec9a1ec40c154127b9c35a6ca703d8", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b80199f41d444c88474b32792a7e828f2a96b68/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=2b80199f41d444c88474b32792a7e828f2a96b68", "patch": "@@ -8472,7 +8472,7 @@ vt_add_function_parameter (tree parm)\n \t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n       if (dv_is_value_p (dv))\n \t{\n-\t  cselib_val *val = CSELIB_VAL_PTR (dv_as_value (dv));\n+\t  cselib_val *val = CSELIB_VAL_PTR (dv_as_value (dv)), *val2;\n \t  struct elt_loc_list *el;\n \t  el = (struct elt_loc_list *)\n \t    ggc_alloc_cleared_atomic (sizeof (*el));\n@@ -8481,6 +8481,23 @@ vt_add_function_parameter (tree parm)\n \t  ENTRY_VALUE_EXP (el->loc) = incoming;\n \t  el->setting_insn = get_insns ();\n \t  val->locs = el;\n+\t  val2 = cselib_lookup_from_insn (el->loc, GET_MODE (incoming),\n+\t\t\t\t\t  true, VOIDmode, get_insns ());\n+\t  if (val2\n+\t      && val2 != val\n+\t      && val2->locs\n+\t      && rtx_equal_p (val2->locs->loc, el->loc))\n+\t    {\n+\t      struct elt_loc_list *el2;\n+\n+\t      preserve_value (val2);\n+\t      el2 = (struct elt_loc_list *)\n+\t\tggc_alloc_cleared_atomic (sizeof (*el2));\n+\t      el2->next = val2->locs;\n+\t      el2->loc = dv_as_value (dv);\n+\t      el2->setting_insn = get_insns ();\n+\t      val2->locs = el2;\n+\t    }\n \t  if (TREE_CODE (TREE_TYPE (parm)) == REFERENCE_TYPE\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (parm))))\n \t    {\n@@ -8499,6 +8516,24 @@ vt_add_function_parameter (tree parm)\n \t\t  ENTRY_VALUE_EXP (el->loc) = mem;\n \t\t  el->setting_insn = get_insns ();\n \t\t  val->locs = el;\n+\t\t  val2 = cselib_lookup_from_insn (el->loc, GET_MODE (mem),\n+\t\t\t\t\t\t  true, VOIDmode,\n+\t\t\t\t\t\t  get_insns ());\n+\t\t  if (val2\n+\t\t      && val2 != val\n+\t\t      && val2->locs\n+\t\t      && rtx_equal_p (val2->locs->loc, el->loc))\n+\t\t    {\n+\t\t      struct elt_loc_list *el2;\n+\n+\t\t      preserve_value (val2);\n+\t\t      el2 = (struct elt_loc_list *)\n+\t\t\tggc_alloc_cleared_atomic (sizeof (*el2));\n+\t\t      el2->next = val2->locs;\n+\t\t      el2->loc = val->val_rtx;\n+\t\t      el2->setting_insn = get_insns ();\n+\t\t      val2->locs = el2;\n+\t\t    }\n \t\t}\n \t    }\n \t}"}]}