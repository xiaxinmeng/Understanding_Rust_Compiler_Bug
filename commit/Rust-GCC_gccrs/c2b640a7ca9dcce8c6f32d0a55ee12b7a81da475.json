{"sha": "c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiNjQwYTdjYTlkY2NlOGM2ZjMyZDBhNTVlZTEyYjdhODFkYTQ3NQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2011-08-26T09:53:06Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2011-08-26T09:53:06Z"}, "message": "arm.c (struct four_ints): New type.\n\n2011-08-26  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.c (struct four_ints): New type.\n\t(count_insns_for_constant): Delete function.\n\t(find_best_start): Delete function.\n\t(optimal_immediate_sequence): New function.\n\t(optimal_immediate_sequence_1): New function.\n\t(arm_gen_constant): Move constant splitting code to\n\toptimal_immediate_sequence.\n\tRewrite constant negation/invertion code.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/thumb2-replicated-constant1.c: New file.\n\t* gcc.target/arm/thumb2-replicated-constant2.c: New file.\n\t* gcc.target/arm/thumb2-replicated-constant3.c: New file.\n\t* gcc.target/arm/thumb2-replicated-constant4.c: New file.\n\n2011-08-26  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm-protos.h (const_ok_for_op): Add prototype.\n\t* config/arm/arm.c (const_ok_for_op): Add support for addw/subw.\n\tRemove prototype. Remove static function type.\n\t* config/arm/arm.md (*arm_addsi3): Add addw/subw support.\n\tAdd arch attribute.\n\t* config/arm/constraints.md (Pj, PJ): New constraints.\n\nFrom-SVN: r178099", "tree": {"sha": "d78657a83d7593350ed745d3bd7215b38b2dab50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d78657a83d7593350ed745d3bd7215b38b2dab50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58a2bda0e5d919cec4491a7fed2bd88cfb7411b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58a2bda0e5d919cec4491a7fed2bd88cfb7411b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58a2bda0e5d919cec4491a7fed2bd88cfb7411b9"}], "stats": {"total": 655, "additions": 482, "deletions": 173}, "files": [{"sha": "55a5a84f386eb58ca3493b4e1fce158741f67ef9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -1,3 +1,23 @@\n+2011-08-26  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/arm/arm.c (struct four_ints): New type.\n+\t(count_insns_for_constant): Delete function.\n+\t(find_best_start): Delete function.\n+\t(optimal_immediate_sequence): New function.\n+\t(optimal_immediate_sequence_1): New function.\n+\t(arm_gen_constant): Move constant splitting code to\n+\toptimal_immediate_sequence.\n+\tRewrite constant negation/invertion code.\n+\n+2011-08-26  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/arm/arm-protos.h (const_ok_for_op): Add prototype.\n+\t* config/arm/arm.c (const_ok_for_op): Add support for addw/subw.\n+\tRemove prototype. Remove static function type.\n+\t* config/arm/arm.md (*arm_addsi3): Add addw/subw support.\n+\tAdd arch attribute.\n+\t* config/arm/constraints.md (Pj, PJ): New constraints.\n+\n 2011-08-26  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n        * config/arm/cortex-a9.md (\"cortex_a9_mult_long\"): New."}, {"sha": "4093c5688c4211a98d315c4fef073c2d03092476", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -47,6 +47,7 @@ extern bool arm_vector_mode_supported_p (enum machine_mode);\n extern bool arm_small_register_classes_for_mode_p (enum machine_mode);\n extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n+extern int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,\n \t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, rtx *, rtx *);"}, {"sha": "c3249b345ade5814d36852cfb2699763c02b344d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 278, "deletions": 165, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -64,6 +64,11 @@ typedef struct minipool_fixup   Mfix;\n \n void (*arm_lang_output_object_attributes_hook)(void);\n \n+struct four_ints\n+{\n+  int i[4];\n+};\n+\n /* Forward function declarations.  */\n static bool arm_needs_doubleword_align (enum machine_mode, const_tree);\n static int arm_compute_static_chain_stack_bytes (void);\n@@ -82,7 +87,6 @@ inline static int thumb1_index_register_rtx_p (rtx, int);\n static bool arm_legitimate_address_p (enum machine_mode, rtx, bool);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n-static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n static rtx emit_sfm (int, int);\n static unsigned arm_size_return_regs (void);\n static bool arm_assemble_integer (rtx, unsigned int, int);\n@@ -129,7 +133,13 @@ static void arm_output_function_prologue (FILE *, HOST_WIDE_INT);\n static int arm_comp_type_attributes (const_tree, const_tree);\n static void arm_set_default_type_attributes (tree);\n static int arm_adjust_cost (rtx, rtx, rtx, int);\n-static int count_insns_for_constant (HOST_WIDE_INT, int);\n+static int optimal_immediate_sequence (enum rtx_code code,\n+\t\t\t\t       unsigned HOST_WIDE_INT val,\n+\t\t\t\t       struct four_ints *return_sequence);\n+static int optimal_immediate_sequence_1 (enum rtx_code code,\n+\t\t\t\t\t unsigned HOST_WIDE_INT val,\n+\t\t\t\t\t struct four_ints *return_sequence,\n+\t\t\t\t\t int i);\n static int arm_get_strip_length (int);\n static bool arm_function_ok_for_sibcall (tree, tree);\n static enum machine_mode arm_promote_function_mode (const_tree,\n@@ -2375,7 +2385,7 @@ const_ok_for_arm (HOST_WIDE_INT i)\n }\n \n /* Return true if I is a valid constant for the operation CODE.  */\n-static int\n+int\n const_ok_for_op (HOST_WIDE_INT i, enum rtx_code code)\n {\n   if (const_ok_for_arm (i))\n@@ -2392,6 +2402,13 @@ const_ok_for_op (HOST_WIDE_INT i, enum rtx_code code)\n \treturn const_ok_for_arm (ARM_SIGN_EXTEND (~i));\n \n     case PLUS:\n+      /* See if we can use addw or subw.  */\n+      if (TARGET_THUMB2\n+\t  && ((i & 0xfffff000) == 0\n+\t      || ((-i) & 0xfffff000) == 0))\n+\treturn 1;\n+      /* else fall through.  */\n+\n     case COMPARE:\n     case EQ:\n     case NE:\n@@ -2507,68 +2524,41 @@ arm_split_constant (enum rtx_code code, enum machine_mode mode, rtx insn,\n \t\t\t   1);\n }\n \n-/* Return the number of instructions required to synthesize the given\n-   constant, if we start emitting them from bit-position I.  */\n+/* Return a sequence of integers, in RETURN_SEQUENCE that fit into\n+   ARM/THUMB2 immediates, and add up to VAL.\n+   Thr function return value gives the number of insns required.  */\n static int\n-count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n-{\n-  HOST_WIDE_INT temp1;\n-  int step_size = TARGET_ARM ? 2 : 1;\n-  int num_insns = 0;\n-\n-  gcc_assert (TARGET_ARM || i == 0);\n-\n-  do\n-    {\n-      int end;\n-\n-      if (i <= 0)\n-\ti += 32;\n-      if (remainder & (((1 << step_size) - 1) << (i - step_size)))\n-\t{\n-\t  end = i - 8;\n-\t  if (end < 0)\n-\t    end += 32;\n-\t  temp1 = remainder & ((0x0ff << end)\n-\t\t\t\t    | ((i < end) ? (0xff >> (32 - end)) : 0));\n-\t  remainder &= ~temp1;\n-\t  num_insns++;\n-\t  i -= 8 - step_size;\n-\t}\n-      i -= step_size;\n-    } while (remainder);\n-  return num_insns;\n-}\n-\n-static int\n-find_best_start (unsigned HOST_WIDE_INT remainder)\n+optimal_immediate_sequence (enum rtx_code code, unsigned HOST_WIDE_INT val,\n+\t\t\t    struct four_ints *return_sequence)\n {\n   int best_consecutive_zeros = 0;\n   int i;\n   int best_start = 0;\n+  int insns1, insns2;\n+  struct four_ints tmp_sequence;\n \n   /* If we aren't targetting ARM, the best place to start is always at\n-     the bottom.  */\n-  if (! TARGET_ARM)\n-    return 0;\n-\n-  for (i = 0; i < 32; i += 2)\n+     the bottom, otherwise look more closely.  */\n+  if (TARGET_ARM)\n     {\n-      int consecutive_zeros = 0;\n-\n-      if (!(remainder & (3 << i)))\n+      for (i = 0; i < 32; i += 2)\n \t{\n-\t  while ((i < 32) && !(remainder & (3 << i)))\n-\t    {\n-\t      consecutive_zeros += 2;\n-\t      i += 2;\n-\t    }\n-\t  if (consecutive_zeros > best_consecutive_zeros)\n+\t  int consecutive_zeros = 0;\n+\n+\t  if (!(val & (3 << i)))\n \t    {\n-\t      best_consecutive_zeros = consecutive_zeros;\n-\t      best_start = i - consecutive_zeros;\n+\t      while ((i < 32) && !(val & (3 << i)))\n+\t\t{\n+\t\t  consecutive_zeros += 2;\n+\t\t  i += 2;\n+\t\t}\n+\t      if (consecutive_zeros > best_consecutive_zeros)\n+\t\t{\n+\t\t  best_consecutive_zeros = consecutive_zeros;\n+\t\t  best_start = i - consecutive_zeros;\n+\t\t}\n+\t      i -= 2;\n \t    }\n-\t  i -= 2;\n \t}\n     }\n \n@@ -2595,13 +2585,161 @@ find_best_start (unsigned HOST_WIDE_INT remainder)\n      the constant starting from `best_start', and also starting from\n      zero (i.e. with bit 31 first to be output).  If `best_start' doesn't\n      yield a shorter sequence, we may as well use zero.  */\n+  insns1 = optimal_immediate_sequence_1 (code, val, return_sequence, best_start);\n   if (best_start != 0\n-      && ((((unsigned HOST_WIDE_INT) 1) << best_start) < remainder)\n-      && (count_insns_for_constant (remainder, 0) <=\n-\t  count_insns_for_constant (remainder, best_start)))\n-    best_start = 0;\n+      && ((((unsigned HOST_WIDE_INT) 1) << best_start) < val))\n+    {\n+      insns2 = optimal_immediate_sequence_1 (code, val, &tmp_sequence, 0);\n+      if (insns2 <= insns1)\n+\t{\n+\t  *return_sequence = tmp_sequence;\n+\t  insns1 = insns2;\n+\t}\n+    }\n \n-  return best_start;\n+  return insns1;\n+}\n+\n+/* As for optimal_immediate_sequence, but starting at bit-position I.  */\n+static int\n+optimal_immediate_sequence_1 (enum rtx_code code, unsigned HOST_WIDE_INT val,\n+\t\t\t     struct four_ints *return_sequence, int i)\n+{\n+  int remainder = val & 0xffffffff;\n+  int insns = 0;\n+\n+  /* Try and find a way of doing the job in either two or three\n+     instructions.\n+     \n+     In ARM mode we can use 8-bit constants, rotated to any 2-bit aligned\n+     location.  We start at position I.  This may be the MSB, or\n+     optimial_immediate_sequence may have positioned it at the largest block \n+     of zeros that are aligned on a 2-bit boundary. We then fill up the temps,\n+     wrapping around to the top of the word when we drop off the bottom.\n+     In the worst case this code should produce no more than four insns.\n+\n+     In Thumb2 mode, we can use 32/16-bit replicated constants, and 8-bit\n+     constants, shifted to any arbitrary location.  We should always start\n+     at the MSB.  */\n+  do\n+    {\n+      int end;\n+      int b1, b2, b3, b4;\n+      unsigned HOST_WIDE_INT result;\n+      int loc;\n+\n+      gcc_assert (insns < 4);\n+\n+      if (i <= 0)\n+\ti += 32;\n+\n+      /* First, find the next normal 12/8-bit shifted/rotated immediate.  */\n+      if (remainder & ((TARGET_ARM ? (3 << (i - 2)) : (1 << (i - 1)))))\n+\t{\n+\t  loc = i;\n+\t  if (i <= 12 && TARGET_THUMB2 && code == PLUS)\n+\t    /* We can use addw/subw for the last 12 bits.  */\n+\t    result = remainder;\n+\t  else\n+\t    {\n+\t      /* Use an 8-bit shifted/rotated immediate.  */\n+\t      end = i - 8;\n+\t      if (end < 0)\n+\t\tend += 32;\n+\t      result = remainder & ((0x0ff << end)\n+\t\t\t\t   | ((i < end) ? (0xff >> (32 - end))\n+\t\t\t\t\t\t: 0));\n+\t      i -= 8;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Arm allows rotates by a multiple of two. Thumb-2 allows\n+\t     arbitrary shifts.  */\n+\t  i -= TARGET_ARM ? 2 : 1;\n+\t  continue;\n+\t}\n+\n+      /* Next, see if we can do a better job with a thumb2 replicated\n+\t constant.\n+       \n+         We do it this way around to catch the cases like 0x01F001E0 where\n+\t two 8-bit immediates would work, but a replicated constant would\n+\t make it worse.\n+       \n+         TODO: 16-bit constants that don't clear all the bits, but still win.\n+         TODO: Arithmetic splitting for set/add/sub, rather than bitwise.  */\n+      if (TARGET_THUMB2)\n+\t{\n+\t  b1 = (remainder & 0xff000000) >> 24;\n+\t  b2 = (remainder & 0x00ff0000) >> 16;\n+\t  b3 = (remainder & 0x0000ff00) >> 8;\n+\t  b4 = remainder & 0xff;\n+\n+\t  if (loc > 24)\n+\t    {\n+\t      /* The 8-bit immediate already found clears b1 (and maybe b2),\n+\t\t but must leave b3 and b4 alone.  */\n+\n+\t      /* First try to find a 32-bit replicated constant that clears\n+\t\t almost everything.  We can assume that we can't do it in one,\n+\t\t or else we wouldn't be here.  */\n+\t      unsigned int tmp = b1 & b2 & b3 & b4;\n+\t      unsigned int tmp2 = tmp + (tmp << 8) + (tmp << 16)\n+\t\t\t\t  + (tmp << 24);\n+\t      unsigned int matching_bytes = (tmp == b1) + (tmp == b2)\n+\t\t\t\t\t    + (tmp == b3) + (tmp == b4);\n+\t      if (tmp\n+\t\t  && (matching_bytes >= 3\n+\t\t      || (matching_bytes == 2\n+\t\t\t  && const_ok_for_op (remainder & ~tmp2, code))))\n+\t\t{\n+\t\t  /* At least 3 of the bytes match, and the fourth has at \n+\t\t     least as many bits set, or two of the bytes match\n+\t\t     and it will only require one more insn to finish.  */\n+\t\t  result = tmp2;\n+\t\t  i = tmp != b1 ? 32\n+\t\t      : tmp != b2 ? 24\n+\t\t      : tmp != b3 ? 16\n+\t\t      : 8;\n+\t\t}\n+\n+\t      /* Second, try to find a 16-bit replicated constant that can\n+\t\t leave three of the bytes clear.  If b2 or b4 is already\n+\t\t zero, then we can.  If the 8-bit from above would not\n+\t\t clear b2 anyway, then we still win.  */\n+\t      else if (b1 == b3 && (!b2 || !b4\n+\t\t\t       || (remainder & 0x00ff0000 & ~result)))\n+\t\t{\n+\t\t  result = remainder & 0xff00ff00;\n+\t\t  i = 24;\n+\t\t}\n+\t    }\n+\t  else if (loc > 16)\n+\t    {\n+\t      /* The 8-bit immediate already found clears b2 (and maybe b3)\n+\t\t and we don't get here unless b1 is alredy clear, but it will\n+\t\t leave b4 unchanged.  */\n+\n+\t      /* If we can clear b2 and b4 at once, then we win, since the\n+\t\t 8-bits couldn't possibly reach that far.  */\n+\t      if (b2 == b4)\n+\t\t{\n+\t\t  result = remainder & 0x00ff00ff;\n+\t\t  i = 16;\n+\t\t}\n+\t    }\n+\t}\n+\n+      return_sequence->i[insns++] = result;\n+      remainder &= ~result;\n+\n+      if (code == SET || code == MINUS)\n+\tcode = PLUS;\n+    }\n+  while (remainder);\n+\n+  return insns;\n }\n \n /* Emit an instruction with the indicated PATTERN.  If COND is\n@@ -2618,7 +2756,6 @@ emit_constant_insn (rtx cond, rtx pattern)\n \n /* As above, but extra parameter GENERATE which, if clear, suppresses\n    RTL generation.  */\n-/* ??? This needs more work for thumb2.  */\n \n static int\n arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n@@ -2629,15 +2766,15 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n   int can_negate = 0;\n   int final_invert = 0;\n   int i;\n-  int num_bits_set = 0;\n   int set_sign_bit_copies = 0;\n   int clear_sign_bit_copies = 0;\n   int clear_zero_bit_copies = 0;\n   int set_zero_bit_copies = 0;\n-  int insns = 0;\n+  int insns = 0, neg_insns, inv_insns;\n   unsigned HOST_WIDE_INT temp1, temp2;\n   unsigned HOST_WIDE_INT remainder = val & 0xffffffff;\n-  int step_size = TARGET_ARM ? 2 : 1;\n+  struct four_ints *immediates;\n+  struct four_ints pos_immediates, neg_immediates, inv_immediates;\n \n   /* Find out which operations are safe for a given CODE.  Also do a quick\n      check for degenerate cases; these can occur when DImode operations\n@@ -2646,7 +2783,6 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n     {\n     case SET:\n       can_invert = 1;\n-      can_negate = 1;\n       break;\n \n     case PLUS:\n@@ -2714,6 +2850,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t\t\t\t     gen_rtx_NOT (mode, source)));\n \t  return 1;\n \t}\n+      final_invert = 1;\n       break;\n \n     case MINUS:\n@@ -2736,7 +2873,6 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t\t\t\t\t\t    source)));\n \t  return 1;\n \t}\n-      can_negate = 1;\n \n       break;\n \n@@ -3148,120 +3284,97 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n       break;\n     }\n \n-  for (i = 0; i < 32; i++)\n-    if (remainder & (1 << i))\n-      num_bits_set++;\n-\n-  if ((code == AND) || (can_invert && num_bits_set > 16))\n-    remainder ^= 0xffffffff;\n-  else if (code == PLUS && num_bits_set > 16)\n-    remainder = (-remainder) & 0xffffffff;\n-\n-  /* For XOR, if more than half the bits are set and there's a sequence\n-     of more than 8 consecutive ones in the pattern then we can XOR by the\n-     inverted constant and then invert the final result; this may save an\n-     instruction and might also lead to the final mvn being merged with\n-     some other operation.  */\n-  else if (code == XOR && num_bits_set > 16\n-\t   && (count_insns_for_constant (remainder ^ 0xffffffff,\n-\t\t\t\t\t find_best_start\n-\t\t\t\t\t (remainder ^ 0xffffffff))\n-\t       < count_insns_for_constant (remainder,\n-\t\t\t\t\t   find_best_start (remainder))))\n-    {\n-      remainder ^= 0xffffffff;\n-      final_invert = 1;\n+  /* Calculate what the instruction sequences would be if we generated it\n+     normally, negated, or inverted.  */\n+  if (code == AND)\n+    /* AND cannot be split into multiple insns, so invert and use BIC.  */\n+    insns = 99;\n+  else\n+    insns = optimal_immediate_sequence (code, remainder, &pos_immediates);\n+\n+  if (can_negate)\n+    neg_insns = optimal_immediate_sequence (code, (-remainder) & 0xffffffff,\n+\t\t\t\t\t    &neg_immediates);\n+  else\n+    neg_insns = 99;\n+\n+  if (can_invert || final_invert)\n+    inv_insns = optimal_immediate_sequence (code, remainder ^ 0xffffffff,\n+\t\t\t\t\t    &inv_immediates);\n+  else\n+    inv_insns = 99;\n+\n+  immediates = &pos_immediates;\n+\n+  /* Is the negated immediate sequence more efficient?  */\n+  if (neg_insns < insns && neg_insns <= inv_insns)\n+    {\n+      insns = neg_insns;\n+      immediates = &neg_immediates;\n+    }\n+  else\n+    can_negate = 0;\n+\n+  /* Is the inverted immediate sequence more efficient?\n+     We must allow for an extra NOT instruction for XOR operations, although\n+     there is some chance that the final 'mvn' will get optimized later.  */\n+  if ((inv_insns + 1) < insns || (!final_invert && inv_insns < insns))\n+    {\n+      insns = inv_insns;\n+      immediates = &inv_immediates;\n     }\n   else\n     {\n       can_invert = 0;\n-      can_negate = 0;\n+      final_invert = 0;\n     }\n \n-  /* Now try and find a way of doing the job in either two or three\n-     instructions.\n-     We start by looking for the largest block of zeros that are aligned on\n-     a 2-bit boundary, we then fill up the temps, wrapping around to the\n-     top of the word when we drop off the bottom.\n-     In the worst case this code should produce no more than four insns.\n-     Thumb-2 constants are shifted, not rotated, so the MSB is always the\n-     best place to start.  */\n+  /* Now output the chosen sequence as instructions.  */\n+  if (generate)\n+    {\n+      for (i = 0; i < insns; i++)\n+\t{\n+\t  rtx new_src, temp1_rtx;\n \n-  /* ??? Use thumb2 replicated constants when the high and low halfwords are\n-     the same.  */\n-  {\n-    /* Now start emitting the insns.  */\n-    i = find_best_start (remainder);\n-    do\n-      {\n-\tint end;\n+\t  temp1 = immediates->i[i];\n \n-\tif (i <= 0)\n-\t  i += 32;\n-\tif (remainder & (3 << (i - 2)))\n-\t  {\n-\t    end = i - 8;\n-\t    if (end < 0)\n-\t      end += 32;\n-\t    temp1 = remainder & ((0x0ff << end)\n-\t\t\t\t | ((i < end) ? (0xff >> (32 - end)) : 0));\n-\t    remainder &= ~temp1;\n-\n-\t    if (generate)\n-\t      {\n-\t\trtx new_src, temp1_rtx;\n+\t  if (code == SET || code == MINUS)\n+\t    new_src = (subtargets ? gen_reg_rtx (mode) : target);\n+\t  else if ((final_invert || i < (insns - 1)) && subtargets)\n+\t    new_src = gen_reg_rtx (mode);\n+\t  else\n+\t    new_src = target;\n \n-\t\tif (code == SET || code == MINUS)\n-\t\t  {\n-\t\t    new_src = (subtargets ? gen_reg_rtx (mode) : target);\n-\t\t    if (can_invert && code != MINUS)\n-\t\t      temp1 = ~temp1;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    if ((final_invert || remainder) && subtargets)\n-\t\t      new_src = gen_reg_rtx (mode);\n-\t\t    else\n-\t\t      new_src = target;\n-\t\t    if (can_invert)\n-\t\t      temp1 = ~temp1;\n-\t\t    else if (can_negate)\n-\t\t      temp1 = -temp1;\n-\t\t  }\n+\t  if (can_invert)\n+\t    temp1 = ~temp1;\n+\t  else if (can_negate)\n+\t    temp1 = -temp1;\n \n-\t\ttemp1 = trunc_int_for_mode (temp1, mode);\n-\t\ttemp1_rtx = GEN_INT (temp1);\n+\t  temp1 = trunc_int_for_mode (temp1, mode);\n+\t  temp1_rtx = GEN_INT (temp1);\n \n-\t\tif (code == SET)\n-\t\t  ;\n-\t\telse if (code == MINUS)\n-\t\t  temp1_rtx = gen_rtx_MINUS (mode, temp1_rtx, source);\n-\t\telse\n-\t\t  temp1_rtx = gen_rtx_fmt_ee (code, mode, source, temp1_rtx);\n+\t  if (code == SET)\n+\t    ;\n+\t  else if (code == MINUS)\n+\t    temp1_rtx = gen_rtx_MINUS (mode, temp1_rtx, source);\n+\t  else\n+\t    temp1_rtx = gen_rtx_fmt_ee (code, mode, source, temp1_rtx);\n \n-\t\temit_constant_insn (cond,\n-\t\t\t\t    gen_rtx_SET (VOIDmode, new_src,\n-\t\t\t\t\t\t temp1_rtx));\n-\t\tsource = new_src;\n-\t      }\n+\t  emit_constant_insn (cond,\n+\t\t\t      gen_rtx_SET (VOIDmode, new_src,\n+\t\t\t\t\t   temp1_rtx));\n+\t  source = new_src;\n \n-\t    if (code == SET)\n-\t      {\n-\t\tcan_invert = 0;\n-\t\tcode = PLUS;\n-\t      }\n-\t    else if (code == MINUS)\n+\t  if (code == SET)\n+\t    {\n+\t      can_invert = 0;\n+\t      can_negate = 1;\n \t      code = PLUS;\n-\n-\t    insns++;\n-\t    i -= 8 - step_size;\n-\t  }\n-\t/* Arm allows rotates by a multiple of two. Thumb-2 allows arbitrary\n-\t   shifts.  */\n-\ti -= step_size;\n-      }\n-    while (remainder);\n-  }\n+\t    }\n+\t  else if (code == MINUS)\n+\t    code = PLUS;\n+\t}\n+    }\n \n   if (final_invert)\n     {"}, {"sha": "53542a1695d25c23b8c2a67889f2299c4d24dab4", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -708,21 +708,24 @@\n ;;  (plus (reg rN) (reg sp)) into (reg rN).  In this case reload will\n ;; put the duplicated register first, and not try the commutative version.\n (define_insn_and_split \"*arm_addsi3\"\n-  [(set (match_operand:SI          0 \"s_register_operand\" \"=r, k,r,r, k,r\")\n-\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%rk,k,r,rk,k,rk\")\n-\t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI,rI,k,L, L,?n\")))]\n+  [(set (match_operand:SI          0 \"s_register_operand\" \"=r, k,r,r, k, r, k,r, k, r\")\n+\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%rk,k,r,rk,k, rk,k,rk,k, rk\")\n+\t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI,rI,k,Pj,Pj,L, L,PJ,PJ,?n\")))]\n   \"TARGET_32BIT\"\n   \"@\n    add%?\\\\t%0, %1, %2\n    add%?\\\\t%0, %1, %2\n    add%?\\\\t%0, %2, %1\n+   addw%?\\\\t%0, %1, %2\n+   addw%?\\\\t%0, %1, %2\n    sub%?\\\\t%0, %1, #%n2\n    sub%?\\\\t%0, %1, #%n2\n+   subw%?\\\\t%0, %1, #%n2\n+   subw%?\\\\t%0, %1, #%n2\n    #\"\n   \"TARGET_32BIT\n    && GET_CODE (operands[2]) == CONST_INT\n-   && !(const_ok_for_arm (INTVAL (operands[2]))\n-        || const_ok_for_arm (-INTVAL (operands[2])))\n+   && !const_ok_for_op (INTVAL (operands[2]), PLUS)\n    && (reload_completed || !arm_eliminable_register (operands[1]))\"\n   [(clobber (const_int 0))]\n   \"\n@@ -731,8 +734,9 @@\n \t\t      operands[1], 0);\n   DONE;\n   \"\n-  [(set_attr \"length\" \"4,4,4,4,4,16\")\n-   (set_attr \"predicable\" \"yes\")]\n+  [(set_attr \"length\" \"4,4,4,4,4,4,4,4,4,16\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"arch\" \"*,*,*,t2,t2,*,*,t2,t2,*\")]\n )\n \n (define_insn_and_split \"*thumb1_addsi3\""}, {"sha": "22df032108ef80927d630e245c6117e5a9acba61", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -31,7 +31,7 @@\n ;; The following multi-letter normal constraints have been used:\n ;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy, Di, Dz\n ;; in Thumb-1 state: Pa, Pb, Pc, Pd\n-;; in Thumb-2 state: Ps, Pt, Pu, Pv, Pw, Px, Py\n+;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py\n \n ;; The following memory constraints have been used:\n ;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Um, Us\n@@ -75,6 +75,18 @@\n \t   (and (match_code \"const_int\")\n                 (match_test \"(ival & 0xffff0000) == 0\")))))\n \n+(define_constraint \"Pj\"\n+ \"@internal A 12-bit constant suitable for an ADDW or SUBW instruction. (Thumb-2)\"\n+ (and (match_code \"const_int\")\n+      (and (match_test \"TARGET_THUMB2\")\n+\t   (match_test \"(ival & 0xfffff000) == 0\"))))\n+\n+(define_constraint \"PJ\"\n+ \"@internal A constant that satisfies the Pj constrant if negated.\"\n+ (and (match_code \"const_int\")\n+      (and (match_test \"TARGET_THUMB2\")\n+\t   (match_test \"((-ival) & 0xfffff000) == 0\"))))\n+\n (define_register_constraint \"k\" \"STACK_REG\"\n  \"@internal The stack register.\")\n "}, {"sha": "15a365cca80ca6ac803b3fc65ea80639941cbd7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -1,3 +1,10 @@\n+2011-08-26  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* gcc.target/arm/thumb2-replicated-constant1.c: New file.\n+\t* gcc.target/arm/thumb2-replicated-constant2.c: New file.\n+\t* gcc.target/arm/thumb2-replicated-constant3.c: New file.\n+\t* gcc.target/arm/thumb2-replicated-constant4.c: New file.\n+\n 2011-08-25  Mikael Morin  <mikael.morin@gcc.gnu.org>\n \n \tPR fortran/50050"}, {"sha": "e10ea03758b3987b181bbb94e14996a1a7552b2e", "filename": "gcc/testsuite/gcc.target/arm/thumb2-replicated-constant1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant1.c?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -0,0 +1,27 @@\n+/* Ensure simple replicated constant immediates work.  */\n+/* { dg-options \"-mthumb -O2\" } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+\n+int\n+foo1 (int a)\n+{\n+  return a + 0xfefefefe;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#-16843010\" } } */\n+\n+int\n+foo2 (int a)\n+{\n+  return a - 0xab00ab00;\n+}\n+\n+/* { dg-final { scan-assembler \"sub.*#-1426019584\" } } */\n+\n+int\n+foo3 (int a)\n+{\n+  return a & 0x00cd00cd;\n+}\n+\n+/* { dg-final { scan-assembler \"and.*#13435085\" } } */"}, {"sha": "3739adba59d01e040d032e09dddfdb66d83ee4be", "filename": "gcc/testsuite/gcc.target/arm/thumb2-replicated-constant2.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant2.c?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -0,0 +1,75 @@\n+/* Ensure split constants can use replicated patterns.  */\n+/* { dg-options \"-mthumb -O2\" } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+\n+int\n+foo1 (int a)\n+{\n+  return a + 0xfe00fe01;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#-33489408\" } } */\n+/* { dg-final { scan-assembler \"add.*#1\" } } */\n+\n+int\n+foo2 (int a)\n+{\n+  return a + 0xdd01dd00;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#-587145984\" } } */\n+/* { dg-final { scan-assembler \"add.*#65536\" } } */\n+\n+int\n+foo3 (int a)\n+{\n+  return a + 0x00443344;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#4456516\" } } */\n+/* { dg-final { scan-assembler \"add.*#13056\" } } */\n+\n+int\n+foo4 (int a)\n+{\n+  return a + 0x77330033;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#1996488704\" } } */\n+/* { dg-final { scan-assembler \"add.*#3342387\" } } */\n+\n+int\n+foo5 (int a)\n+{\n+  return a + 0x11221122;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#285217024\" } } */\n+/* { dg-final { scan-assembler \"add.*#2228258\" } } */\n+\n+int\n+foo6 (int a)\n+{\n+  return a + 0x66666677;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#1717986918\" } } */\n+/* { dg-final { scan-assembler \"add.*#17\" } } */\n+\n+int\n+foo7 (int a)\n+{\n+  return a + 0x99888888;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#-2004318072\" } } */\n+/* { dg-final { scan-assembler \"add.*#285212672\" } } */\n+\n+int\n+foo8 (int a)\n+{\n+  return a + 0xdddddfff;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#-572662307\" } } */\n+/* { dg-final { scan-assembler \"addw.*#546\" } } */"}, {"sha": "eb6ad443c539d40d11a364882bd5e426b9d8f7da", "filename": "gcc/testsuite/gcc.target/arm/thumb2-replicated-constant3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant3.c?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -0,0 +1,28 @@\n+/* Ensure negated/inverted replicated constant immediates work.  */\n+/* { dg-options \"-mthumb -O2\" } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+\n+int\n+foo1 (int a)\n+{\n+  return a | 0xffffff00;\n+}\n+\n+/* { dg-final { scan-assembler \"orn.*#255\" } } */\n+\n+int\n+foo2 (int a)\n+{\n+  return a & 0xffeeffee;\n+}\n+\n+/* { dg-final { scan-assembler \"bic.*#1114129\" } } */\n+\n+int\n+foo3 (int a)\n+{\n+  return a & 0xaaaaaa00;\n+}\n+\n+/* { dg-final { scan-assembler \"and.*#-1431655766\" } } */\n+/* { dg-final { scan-assembler \"bic.*#170\" } } */"}, {"sha": "24efdcf34e2f56fe1240f59bd672dcc19152e429", "filename": "gcc/testsuite/gcc.target/arm/thumb2-replicated-constant4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb2-replicated-constant4.c?ref=c2b640a7ca9dcce8c6f32d0a55ee12b7a81da475", "patch": "@@ -0,0 +1,22 @@\n+/* Ensure replicated constants don't make things worse.  */\n+/* { dg-options \"-mthumb -O2\" } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+\n+int\n+foo1 (int a)\n+{\n+  /* It might be tempting to use 0x01000100, but it wouldn't help. */\n+  return a + 0x01f001e0;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#32505856\" } } */\n+/* { dg-final { scan-assembler \"add.*#480\" } } */\n+\n+int\n+foo2 (int a)\n+{\n+  return a + 0x0f100e10;\n+}\n+\n+/* { dg-final { scan-assembler \"add.*#252706816\" } } */\n+/* { dg-final { scan-assembler \"add.*#3600\" } } */"}]}