{"sha": "abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlNjAxYzdjYmYwNWQxZGJkMmM5Mjk3M2U2NWFiNTY5MGMyZGRjYQ==", "commit": {"author": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-11-06T22:18:54Z"}, "committer": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-11-06T22:18:54Z"}, "message": "re PR fortran/29630 (\"Unclassifiable statement\" with vector subscripts in initialization)\n\nfortran/\n2006-11-06  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        PR fortran/29630\n        PR fortran/29679\n        * expr.c (find_array_section): Support vector subscripts.  Don't\n        add sizes for dimen_type == DIMEN_ELEMENT to the shape array.\n\n\ntestsuite/\n2006-11-06  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        PR fortran/29630\n        PR fortran/29679\n        * gfortran.dg/initialization_2.f90: Test PRs 29630 and 29679 too.\n        * gfortran.dg/initialization_3.f90: New.\n\nFrom-SVN: r118528", "tree": {"sha": "496ab103b1490e7e829f666a00ffc8c5b2933745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/496ab103b1490e7e829f666a00ffc8c5b2933745"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/comments", "author": null, "committer": null, "parents": [{"sha": "841745310d4ec60ca9f157fe99993f7f5b1dc893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/841745310d4ec60ca9f157fe99993f7f5b1dc893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/841745310d4ec60ca9f157fe99993f7f5b1dc893"}], "stats": {"total": 227, "additions": 159, "deletions": 68}, "files": [{"sha": "b8a628bbb19d7155df8f2864eedc39202e236c1c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "patch": "@@ -1,3 +1,10 @@\n+2006-11-06  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\tPR fortran/29630\n+\tPR fortran/29679\n+\t* expr.c (find_array_section): Support vector subscripts.  Don't\n+\t  add sizes for dimen_type == DIMEN_ELEMENT to the shape array.\n+\n 2006-11-05  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \tPR fortran/21061"}, {"sha": "9c25e5aab242b7612c9c38738dc96be91a063d47", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 110, "deletions": 61, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "patch": "@@ -1013,7 +1013,9 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   int idx;\n   int rank;\n   int d;\n+  int shape_i;\n   long unsigned one = 1;\n+  bool incr_ctr;\n   mpz_t start[GFC_MAX_DIMENSIONS];\n   mpz_t end[GFC_MAX_DIMENSIONS];\n   mpz_t stride[GFC_MAX_DIMENSIONS];\n@@ -1023,7 +1025,6 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   mpz_t tmp_mpz;\n   mpz_t nelts;\n   mpz_t ptr;\n-  mpz_t stop;\n   mpz_t index;\n   gfc_constructor *cons;\n   gfc_constructor *base;\n@@ -1032,6 +1033,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   gfc_expr *step;\n   gfc_expr *upper;\n   gfc_expr *lower;\n+  gfc_constructor *vecsub[GFC_MAX_DIMENSIONS], *c;\n   try t;\n \n   t = SUCCESS;\n@@ -1057,9 +1059,11 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       mpz_init (end[d]);\n       mpz_init (ctr[d]);\n       mpz_init (stride[d]);\n+      vecsub[d] = NULL;\n     }\n \n   /* Build the counters to clock through the array reference.  */\n+  shape_i = 0;\n   for (d = 0; d < rank; d++)\n     {\n       /* Make this stretch of code easier on the eye!  */\n@@ -1069,64 +1073,95 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       lower = ref->u.ar.as->lower[d];\n       upper = ref->u.ar.as->upper[d];\n \n-      if ((begin && begin->expr_type != EXPR_CONSTANT)\n-\t    || (finish && finish->expr_type != EXPR_CONSTANT)\n-\t    || (step && step->expr_type != EXPR_CONSTANT))\n-\t{\n-\t  t = FAILURE;\n-\t  goto cleanup;\n-\t}\n-\n-      /* Obtain the stride.  */\n-      if (step)\n-\tmpz_set (stride[d], step->value.integer);\n+      if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */\n+        {\n+          gcc_assert(begin);\n+\t  gcc_assert(begin->expr_type == EXPR_ARRAY); \n+\t  gcc_assert(begin->rank == 1);\n+\t  gcc_assert(begin->shape);\n+\n+\t  vecsub[d] = begin->value.constructor;\n+\t  mpz_set (ctr[d], vecsub[d]->expr->value.integer);\n+\t  mpz_mul (nelts, nelts, begin->shape[0]);\n+\t  mpz_set (expr->shape[shape_i++], begin->shape[0]);\n+\n+\t  /* Check bounds.  */\n+\t  for (c = vecsub[d]; c; c = c->next)\n+\t    {\n+\t      if (mpz_cmp (c->expr->value.integer, upper->value.integer) > 0\n+\t          || mpz_cmp (c->expr->value.integer, lower->value.integer) < 0)\n+\t\t{\n+\t\t  gfc_error (\"index in dimension %d is out of bounds \"\n+\t\t\t     \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n+\t\t  t = FAILURE;\n+\t\t  goto cleanup;\n+\t\t}\n+\t    }\n+        }\n       else\n-\tmpz_set_ui (stride[d], one);\n+        {\n+\t  if ((begin && begin->expr_type != EXPR_CONSTANT)\n+\t\t|| (finish && finish->expr_type != EXPR_CONSTANT)\n+\t\t|| (step && step->expr_type != EXPR_CONSTANT))\n+\t    {\n+\t      t = FAILURE;\n+\t      goto cleanup;\n+\t    }\n \n-      if (mpz_cmp_ui (stride[d], 0) == 0)\n-\tmpz_set_ui (stride[d], one);\n+\t  /* Obtain the stride.  */\n+\t  if (step)\n+\t    mpz_set (stride[d], step->value.integer);\n+\t  else\n+\t    mpz_set_ui (stride[d], one);\n \n-      /* Obtain the start value for the index.  */\n-      if (begin)\n-\t  mpz_set (start[d], begin->value.integer);\n-      else\n-\tmpz_set (start[d], lower->value.integer);\n+\t  if (mpz_cmp_ui (stride[d], 0) == 0)\n+\t    mpz_set_ui (stride[d], one);\n \n-      mpz_set (ctr[d], start[d]);\n+\t  /* Obtain the start value for the index.  */\n+\t  if (begin)\n+\t    mpz_set (start[d], begin->value.integer);\n+\t  else\n+\t    mpz_set (start[d], lower->value.integer);\n \n-      /* Obtain the end value for the index.  */\n-      if (finish)\n-        mpz_set (end[d], finish->value.integer);\n-      else\n-\tmpz_set (end[d], upper->value.integer);\n+\t  mpz_set (ctr[d], start[d]);\n \n-      /* Separate 'if' because elements sometimes arrive with\n-\t non-null end.  */\n-      if (ref->u.ar.dimen_type[d] == DIMEN_ELEMENT)\n-\tmpz_set (end [d], begin->value.integer);\n+\t  /* Obtain the end value for the index.  */\n+\t  if (finish)\n+\t    mpz_set (end[d], finish->value.integer);\n+\t  else\n+\t    mpz_set (end[d], upper->value.integer);\n+\n+\t  /* Separate 'if' because elements sometimes arrive with\n+\t     non-null end.  */\n+\t  if (ref->u.ar.dimen_type[d] == DIMEN_ELEMENT)\n+\t    mpz_set (end [d], begin->value.integer);\n+\n+\t  /* Check the bounds.  */\n+\t  if (mpz_cmp (ctr[d], upper->value.integer) > 0\n+\t      || mpz_cmp (end[d], upper->value.integer) > 0\n+\t      || mpz_cmp (ctr[d], lower->value.integer) < 0\n+\t      || mpz_cmp (end[d], lower->value.integer) < 0)\n+\t    {\n+\t      gfc_error (\"index in dimension %d is out of bounds \"\n+\t\t\t \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n+\t      t = FAILURE;\n+\t      goto cleanup;\n+\t    }\n \n-      /* Check the bounds.  */\n-      if (mpz_cmp (ctr[d], upper->value.integer) > 0\n-\t    || mpz_cmp (end[d], upper->value.integer) > 0\n-\t    || mpz_cmp (ctr[d], lower->value.integer) < 0\n-\t    || mpz_cmp (end[d], lower->value.integer) < 0)\n-\t{\n-\t  gfc_error (\"index in dimension %d is out of bounds \"\n-\t\t     \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n-\t  t = FAILURE;\n-\t  goto cleanup;\n+\t  /* Calculate the number of elements and the shape.  */\n+\t  mpz_abs (tmp_mpz, stride[d]);\n+\t  mpz_div (tmp_mpz, stride[d], tmp_mpz);\n+\t  mpz_add (tmp_mpz, end[d], tmp_mpz);\n+\t  mpz_sub (tmp_mpz, tmp_mpz, ctr[d]);\n+\t  mpz_div (tmp_mpz, tmp_mpz, stride[d]);\n+\t  mpz_mul (nelts, nelts, tmp_mpz);\n+\n+\t  /* An element reference reduces the rank of the expression; don't add\n+\t     anything to the shape array.  */\n+\t  if (ref->u.ar.dimen_type[d] != DIMEN_ELEMENT) \n+\t    mpz_set (expr->shape[shape_i++], tmp_mpz);\n \t}\n \n-      /* Calculate the number of elements and the shape.  */\n-      mpz_abs (tmp_mpz, stride[d]);\n-      mpz_div (tmp_mpz, stride[d], tmp_mpz);\n-      mpz_add (tmp_mpz, end[d], tmp_mpz);\n-      mpz_sub (tmp_mpz, tmp_mpz, ctr[d]);\n-      mpz_div (tmp_mpz, tmp_mpz, stride[d]);\n-      mpz_mul (nelts, nelts, tmp_mpz);\n-\n-      mpz_set (expr->shape[d], tmp_mpz);\n-\n       /* Calculate the 'stride' (=delta) for conversion of the\n \t counter values into the index along the constructor.  */\n       mpz_set (delta[d], delta_mpz);\n@@ -1137,7 +1172,6 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n   mpz_init (index);\n   mpz_init (ptr);\n-  mpz_init (stop);\n   cons = base;\n \n   /* Now clock through the array reference, calculating the index in\n@@ -1150,24 +1184,40 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       else\n \tmpz_init_set_ui (ptr, 0);\n \n-      mpz_set_ui (stop, one);\n+      incr_ctr = true;\n       for (d = 0; d < rank; d++)\n \t{\n \t  mpz_set (tmp_mpz, ctr[d]);\n \t  mpz_sub_ui (tmp_mpz, tmp_mpz, one);\n \t  mpz_mul (tmp_mpz, tmp_mpz, delta[d]);\n \t  mpz_add (ptr, ptr, tmp_mpz);\n \n-\t  mpz_mul (tmp_mpz, stride[d], stop);\n-\t  mpz_add (ctr[d], ctr[d], tmp_mpz); \n+\t  if (!incr_ctr) continue;\n+\n+\t  if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */\n+\t    {\n+\t      gcc_assert(vecsub[d]);\n \n-\t  mpz_set (tmp_mpz, end[d]);\n-\t  if (mpz_cmp_ui (stride[d], 0) > 0 ?\n-\t\tmpz_cmp (ctr[d], tmp_mpz) > 0 :\n-\t\tmpz_cmp (ctr[d], tmp_mpz) < 0)\n-\t    mpz_set (ctr[d], start[d]);\n+\t      if (!vecsub[d]->next)\n+\t\tvecsub[d] = ref->u.ar.start[d]->value.constructor;\n+\t      else\n+\t\t{\n+\t\t  vecsub[d] = vecsub[d]->next;\n+\t\t  incr_ctr = false;\n+\t\t}\n+\t      mpz_set (ctr[d], vecsub[d]->expr->value.integer);\n+\t    }\n \t  else\n-\t    mpz_set_ui (stop, 0);\n+\t    {\n+\t      mpz_add (ctr[d], ctr[d], stride[d]); \n+\n+\t      if (mpz_cmp_ui (stride[d], 0) > 0 ?\n+\t\t    mpz_cmp (ctr[d], end[d]) > 0 :\n+\t\t    mpz_cmp (ctr[d], end[d]) < 0)\n+\t\tmpz_set (ctr[d], start[d]);\n+\t      else\n+\t\tincr_ctr = false;\n+\t    }\n \t}\n \n       /* There must be a better way of dealing with negative strides\n@@ -1189,7 +1239,6 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n   mpz_clear (ptr);\n   mpz_clear (index);\n-  mpz_clear (stop);\n \n cleanup:\n "}, {"sha": "ae0c6e4012d698546978bcade2fb83ab5d0baeb3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "patch": "@@ -1,3 +1,10 @@\n+2006-11-06  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\tPR fortran/29630\n+\tPR fortran/29679\n+\t* gfortran.dg/initialization_2.f90: Test PRs 29630 and 29679 too.\n+\t* gfortran.dg/initialization_3.f90: New.\n+\n 2006-11-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/25545"}, {"sha": "e13f38fb7240f3ee1e91b54a90683aef8bcc5428", "filename": "gcc/testsuite/gfortran.dg/initialization_2.f90", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_2.f90?ref=abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "patch": "@@ -1,7 +1,22 @@\n-! { dg-do compile }\n-! PR 29393: Ranks of PARAMETER-lhs in initializations\n-    integer, parameter ::   A(-3:7,2)=0 \n-    integer, parameter, dimension(3) :: V = (/ 2, 4, 6 /)\n-    integer, parameter, dimension(3) :: B = A(V,1) \n-    integer, parameter, dimension(3) :: C = A(0:2,1) \n-end\n+! {dg-do run }\n+! Vector subscripts, ranks and shapes of initialization expressions (PRs 29393,\n+! 29630 and 29679)\n+program test\n+\n+    implicit none\n+    integer :: i, j\n+    integer, parameter :: a(4,4,4) = reshape([ (i,i=1,64) ], [4,4,4])\n+    integer, parameter :: v(4) = [4, 1, 3, 2]\n+\n+    integer :: b1(3,3) = a(1:3, 2, 2:4)\n+    integer :: b2(1,3) = a(2:2, 4, [1,4,3])\n+    integer :: b2b(3) = a([1,4,3], 2, 4)\n+    integer :: b3(4) = a(1, v, 3)\n+    integer :: b4(3,3) = a(v([2,4,3]), 2, [2,3,4])\n+\n+    if (any(b1 /= reshape([21,22,23, 37,38,39, 53,54,55], [3,3]))) call abort()\n+    if (any(b2 /= reshape([14, 62, 46], [1,3]))) call abort()\n+    if (any(b2b /= [53, 56, 55])) call abort()\n+    if (any(b3 /= [45, 33, 41, 37])) call abort()\n+    if (any(b4 /= reshape([21,22,23, 37,38,39, 53,54,55], [3,3]))) call abort()\n+end program test"}, {"sha": "61b0f9f22b7a8bfddd5a8e898816742b3c9c6a95", "filename": "gcc/testsuite/gfortran.dg/initialization_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe601c7cbf05d1dbd2c92973e65ab5690c2ddca/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_3.f90?ref=abe601c7cbf05d1dbd2c92973e65ab5690c2ddca", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! Check that bounds are checked when using vector subscripts in initialization\n+! expressions. (PR 29630)\n+program test\n+\n+    implicit none\n+    integer :: i, j\n+    integer, parameter :: a(4,4,4) = reshape([ (i,i=1,64) ], [4,4,4])\n+    integer, parameter :: v(4) = [5, 1, -4, 2]\n+\n+    integer :: b2(3) = a(2, 4, [1,7,3]) ! { dg-error \"out of bounds\" }\n+    integer :: b3(4) = a(1, v, 3) ! { dg-error \"out of bounds\" }\n+end program test"}]}