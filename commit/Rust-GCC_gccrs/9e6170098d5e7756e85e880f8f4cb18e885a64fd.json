{"sha": "9e6170098d5e7756e85e880f8f4cb18e885a64fd", "node_id": "C_kwDOANBUbNoAKDllNjE3MDA5OGQ1ZTc3NTZlODVlODgwZjhmNGNiMThlODg1YTY0ZmQ", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-02-09T06:06:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-03-09T15:25:46Z"}, "message": "c++: fix alias CTAD [PR105841]\n\nIn my initial implementation of alias CTAD, I described a couple of\ndifferences from the specification that I thought would not have a practical\neffect; this testcase demonstrates that I was wrong.  One difference is\nresolved by the CPTK_IS_DEDUCIBLE commit; the other (adding too many of the\nalias template parameters to the new deduction guide) is fixed by this\npatch.\n\n\tPR c++/105841\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc\t(corresponding_template_parameter_list): Split out...\n\t(corresponding_template_parameter): ...from here.\n\t(find_template_parameters): Factor out...\n\t(find_template_parameter_info::find_in): ...this function.\n\t(find_template_parameter_info::find_in_recursive): New.\n\t(find_template_parameter_info::found): New.\n\t(alias_ctad_tweaks): Only add parms used in the deduced args.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/class-deduction-alias14.C: New test.\n\nCo-authored-by: Michael Spertus <mike@spertus.com>", "tree": {"sha": "02286e11adeedcb94780fb611027d9cad43b2371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02286e11adeedcb94780fb611027d9cad43b2371"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e6170098d5e7756e85e880f8f4cb18e885a64fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6170098d5e7756e85e880f8f4cb18e885a64fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e6170098d5e7756e85e880f8f4cb18e885a64fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6170098d5e7756e85e880f8f4cb18e885a64fd/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30556bf81f4385c2a9c449948865dbcf35664764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30556bf81f4385c2a9c449948865dbcf35664764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30556bf81f4385c2a9c449948865dbcf35664764"}], "stats": {"total": 146, "additions": 114, "deletions": 32}, "files": [{"sha": "8c73ea5b0fa5fcd8642888d000a01296a01ace6e", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 101, "deletions": 32, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6170098d5e7756e85e880f8f4cb18e885a64fd/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6170098d5e7756e85e880f8f4cb18e885a64fd/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=9e6170098d5e7756e85e880f8f4cb18e885a64fd", "patch": "@@ -10376,7 +10376,7 @@ lookup_and_finish_template_variable (tree templ, tree targs,\n    return NULL_TREE.  */\n \n static tree\n-corresponding_template_parameter (tree parms, int level, int index)\n+corresponding_template_parameter_list (tree parms, int level, int index)\n {\n   while (TMPL_PARMS_DEPTH (parms) > level)\n     parms = TREE_CHAIN (parms);\n@@ -10385,28 +10385,39 @@ corresponding_template_parameter (tree parms, int level, int index)\n       || TREE_VEC_LENGTH (TREE_VALUE (parms)) <= index)\n     return NULL_TREE;\n \n-  tree t = TREE_VALUE (TREE_VEC_ELT (TREE_VALUE (parms), index));\n-  /* As in template_parm_to_arg.  */\n-  if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == TEMPLATE_DECL)\n-    t = TREE_TYPE (t);\n-  else\n-    t = DECL_INITIAL (t);\n-\n-  gcc_assert (TEMPLATE_PARM_P (t));\n-  return t;\n+  return TREE_VEC_ELT (TREE_VALUE (parms), index);\n }\n \n-/* Return the template parameter from PARMS that positionally corresponds\n-   to the template parameter PARM, or else return NULL_TREE.  */\n+/* Return the TREE_LIST for the template parameter from PARMS that positionally\n+   corresponds to the template parameter PARM, or else return NULL_TREE.  */\n \n static tree\n-corresponding_template_parameter (tree parms, tree parm)\n+corresponding_template_parameter_list (tree parms, tree parm)\n {\n   int level, index;\n   template_parm_level_and_index (parm, &level, &index);\n-  return corresponding_template_parameter (parms, level, index);\n+  return corresponding_template_parameter_list (parms, level, index);\n }\n \n+/* As above, but pull out the actual parameter.  */\n+\n+static tree\n+corresponding_template_parameter (tree parms, tree parm)\n+{\n+  tree list = corresponding_template_parameter_list (parms, parm);\n+  if (!list)\n+    return NULL_TREE;\n+\n+  tree t = TREE_VALUE (list);\n+  /* As in template_parm_to_arg.  */\n+  if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == TEMPLATE_DECL)\n+    t = TREE_TYPE (t);\n+  else\n+    t = DECL_INITIAL (t);\n+\n+  gcc_assert (TEMPLATE_PARM_P (t));\n+  return t;\n+}\n \f\n struct pair_fn_data\n {\n@@ -10679,6 +10690,11 @@ struct find_template_parameter_info\n   tree *parm_list_tail = &parm_list;\n   tree ctx_parms;\n   int max_depth;\n+\n+  tree find_in (tree);\n+  tree find_in_recursive (tree);\n+  bool found (tree);\n+  unsigned num_found () { return parms.elements (); }\n };\n \n /* Appends the declaration of T to the list in DATA.  */\n@@ -10821,6 +10837,52 @@ any_template_parm_r (tree t, void *data)\n   return 0;\n }\n \n+/* Look through T for template parameters.  */\n+\n+tree\n+find_template_parameter_info::find_in (tree t)\n+{\n+  return for_each_template_parm (t, keep_template_parm, this, &visited,\n+\t\t\t\t /*include_nondeduced*/true,\n+\t\t\t\t any_template_parm_r);\n+}\n+\n+/* As above, but also recursively look into the default arguments of template\n+   parameters we found.  Used for alias CTAD.  */\n+\n+tree\n+find_template_parameter_info::find_in_recursive (tree t)\n+{\n+  if (tree r = find_in (t))\n+    return r;\n+  /* Since newly found parms are added to the end of the list, we\n+     can just walk it until we reach the end.  */\n+  for (tree pl = parm_list; pl; pl = TREE_CHAIN (pl))\n+    {\n+      tree parm = TREE_VALUE (pl);\n+      tree list = corresponding_template_parameter_list (ctx_parms, parm);\n+      if (tree r = find_in (TREE_PURPOSE (list)))\n+\treturn r;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* True if PARM was found by a previous call to find_in.  PARM can be a\n+   TREE_LIST, a DECL_TEMPLATE_PARM_P, or a TEMPLATE_PARM_P.  */\n+\n+bool\n+find_template_parameter_info::found (tree parm)\n+{\n+  if (TREE_CODE (parm) == TREE_LIST)\n+    parm = TREE_VALUE (parm);\n+  if (TREE_CODE (parm) == TYPE_DECL)\n+    parm = TREE_TYPE (parm);\n+  else\n+    parm = DECL_INITIAL (parm);\n+  gcc_checking_assert (TEMPLATE_PARM_P (parm));\n+  return parms.contains (parm);\n+}\n+\n /* Returns a list of unique template parameters found within T, where CTX_PARMS\n    are the template parameters in scope.  */\n \n@@ -10831,8 +10893,7 @@ find_template_parameters (tree t, tree ctx_parms)\n     return NULL_TREE;\n \n   find_template_parameter_info ftpi (ctx_parms);\n-  for_each_template_parm (t, keep_template_parm, &ftpi, &ftpi.visited,\n-\t\t\t  /*include_nondeduced*/true, any_template_parm_r);\n+  ftpi.find_in (t);\n   return ftpi.parm_list;\n }\n \n@@ -29986,22 +30047,11 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n      * The explicit-specifier of f' is the explicit-specifier of g (if\n      any).  */\n \n-  /* This implementation differs from the above in two significant ways:\n-\n-     1) We include all template parameters of A, not just some.\n-     2) [fixed] The added constraint is same_type instead of deducible.\n-\n-     I believe that while it's probably possible to construct a testcase that\n-     behaves differently with this simplification, it should have the same\n-     effect for real uses.  Including all template parameters means that we\n-     deduce all parameters of A when resolving the call, so when we're in the\n-     constraint we don't need to deduce them again, we can just check whether\n-     the deduction produced the desired result.  */\n-\n   tsubst_flags_t complain = tf_warning_or_error;\n   tree atype = TREE_TYPE (tmpl);\n   tree aguides = NULL_TREE;\n-  tree atparms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n+  tree fullatparms = DECL_TEMPLATE_PARMS (tmpl);\n+  tree atparms = INNERMOST_TEMPLATE_PARMS (fullatparms);\n   unsigned natparms = TREE_VEC_LENGTH (atparms);\n   tree utype = DECL_ORIGINAL_TYPE (DECL_TEMPLATE_RESULT (tmpl));\n   for (ovl_iterator iter (uguides); iter; ++iter)\n@@ -30031,16 +30081,27 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n \t  for (unsigned i = 0; i < len; ++i)\n \t    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n \t      ++ndlen;\n-\t  tree gtparms = make_tree_vec (natparms + ndlen);\n+\t  find_template_parameter_info ftpi (fullatparms);\n+\t  ftpi.find_in_recursive (targs);\n+\t  unsigned nusedatparms = ftpi.num_found ();\n+\t  unsigned nfparms = nusedatparms + ndlen;\n+\t  tree gtparms = make_tree_vec (nfparms);\n \n \t  /* Set current_template_parms as in build_deduction_guide.  */\n \t  auto ctp = make_temp_override (current_template_parms);\n \t  current_template_parms = copy_node (DECL_TEMPLATE_PARMS (tmpl));\n \t  TREE_VALUE (current_template_parms) = gtparms;\n \n+\t  j = 0;\n \t  /* First copy over the parms of A.  */\n-\t  for (j = 0; j < natparms; ++j)\n-\t    TREE_VEC_ELT (gtparms, j) = TREE_VEC_ELT (atparms, j);\n+\t  for (unsigned i = 0; i < natparms; ++i)\n+\t    {\n+\t      tree elt = TREE_VEC_ELT (atparms, i);\n+\t      if (ftpi.found (elt))\n+\t\tTREE_VEC_ELT (gtparms, j++) = elt;\n+\t    }\n+\t  gcc_checking_assert (j == nusedatparms);\n+\n \t  /* Now rewrite the non-deduced parms of f.  */\n \t  for (unsigned i = 0; ndlen && i < len; ++i)\n \t    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n@@ -30067,6 +30128,13 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n \t    }\n \t  if (g == error_mark_node)\n \t    continue;\n+\t  if (nfparms == 0)\n+\t    {\n+\t      /* The targs are all non-dependent, so g isn't a template.  */\n+\t      fprime = g;\n+\t      ret = TREE_TYPE (TREE_TYPE (fprime));\n+\t      goto non_template;\n+\t    }\n \t  DECL_USE_TEMPLATE (g) = 0;\n \t  fprime = build_template_decl (g, gtparms, false);\n \t  DECL_TEMPLATE_RESULT (fprime) = g;\n@@ -30103,6 +30171,7 @@ alias_ctad_tweaks (tree tmpl, tree uguides)\n \t{\n \t  /* For a non-template deduction guide, if the arguments of A aren't\n \t     deducible from the return type, don't add the candidate.  */\n+\tnon_template:\n \t  if (!type_targs_deducible_from (tmpl, ret))\n \t    continue;\n \t}"}, {"sha": "22b96bcd5d3429a03d7bce21cec36d80d72575ec", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-alias14.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6170098d5e7756e85e880f8f4cb18e885a64fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6170098d5e7756e85e880f8f4cb18e885a64fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-alias14.C?ref=9e6170098d5e7756e85e880f8f4cb18e885a64fd", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/105841\n+// { dg-do compile { target c++20 } }\n+\n+template<class T, int N>\n+struct A { A(...); };\n+\n+template<class T, class... Ts>\n+A(T, Ts...) -> A<T, sizeof...(Ts)>;\n+\n+template<class T, int N=0>\n+using B = A<T, N>;\n+\n+B b(0, 0);"}]}