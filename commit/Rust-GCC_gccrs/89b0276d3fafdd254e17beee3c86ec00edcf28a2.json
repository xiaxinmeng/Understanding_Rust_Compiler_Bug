{"sha": "89b0276d3fafdd254e17beee3c86ec00edcf28a2", "node_id": "C_kwDOANBUbNoAKDg5YjAyNzZkM2ZhZmRkMjU0ZTE3YmVlZTNjODZlYzAwZWRjZjI4YTI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-01T14:58:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-03T08:31:01Z"}, "message": "Flesh out unsupported_range.\n\nIt's cleaner to have the unsupported_range fully fleshed out, instead\nof trapping on every operation.  It can also serve as the basis for\nthe default vrange methods that frange and prange will inherit.\n\nThis patch implements most methods, including union and intersect, to\nhandle an UNDEFINED and a VARYING range.\n\nSince this can serve as the basis for other classes, I have moved\neverything into the vrange class, making the unsupported_range\ntrivial.\n\nNote that vrange is still an abstract class, as I have purposely left\nthe dump() method abstract.\n\nAlso, I have made the unsupported range in the temporary class\n(Value_Range) a method field, instead of a static member.  This way\nthe temporary can set UNDEFINED and VARYING as needed.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (vrange::contains_p): Implement.\n\t(vrange::type): Return void.\n\t(vrange::supports_type_p): Implement.\n\t(irange::fits_p): Same.\n\t(vrange::set_undefined): Same.\n\t(irange::set_nonnegative): Same.\n\t(vrange::set_varying): Same.\n\t(vrange::union_): Same.\n\t(unsupported_range::set): Move to vrange.\n\t(unsupported_range::type): Move to vrange.\n\t(vrange::intersect): Implement for varying and undefined.\n\t(vrange::zero_p): Implement.\n\t(unsupported_range::supports_type_p): Move to vrange.\n\t(vrange::nonzero_p): Implement.\n\t(unsupported_range::set_undefined): Move to vrange.\n\t(unsupported_range::set_varying): Same.\n\t(unsupported_range::dump): Same.\n\t(unsupported_range::union_): Same.  Implement for varying and\n\tundefined.\n\t(unsupported_range::intersect): Move to vrange.\n\t(unsupported_range::zero_p): Same.\n\t(unsupported_range::nonzero_p): Same.\n\t(unsupported_range::set_nonzero): Same.\n\t(unsupported_range::set_zero): Same.\n\t(unsupported_range::set_nonnegative): Same.\n\t(unsupported_range::fits_p): Same.\n\t* value-range.h (class vrange): Remove abstract markers for most\n\tmethods.\n\t(class unsupported_range): Remove most methods as they will now be\n\tinherited from vrange.", "tree": {"sha": "5fcc6c8fd7dbae658f1376faae0ce1bbd7140f14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fcc6c8fd7dbae658f1376faae0ce1bbd7140f14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89b0276d3fafdd254e17beee3c86ec00edcf28a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b0276d3fafdd254e17beee3c86ec00edcf28a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b0276d3fafdd254e17beee3c86ec00edcf28a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b0276d3fafdd254e17beee3c86ec00edcf28a2/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9058b08381cd76e8d21364f0f5ccddb3777c3fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9058b08381cd76e8d21364f0f5ccddb3777c3fd"}], "stats": {"total": 219, "additions": 106, "deletions": 113}, "files": [{"sha": "815cb783abc8231d195b9f17f9cf82f1e5d83e83", "filename": "gcc/value-range.cc", "status": "modified", "additions": 91, "deletions": 84, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0276d3fafdd254e17beee3c86ec00edcf28a2/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0276d3fafdd254e17beee3c86ec00edcf28a2/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=89b0276d3fafdd254e17beee3c86ec00edcf28a2", "patch": "@@ -66,176 +66,183 @@ debug (const Value_Range &r)\n   fprintf (stderr, \"\\n\");\n }\n \n-// Default implementation when none has been defined.\n+// Default vrange definitions.\n \n bool\n vrange::contains_p (tree) const\n {\n-  return false;\n+  return varying_p ();\n }\n \n-// Default implementation when none has been defined.\n-\n bool\n vrange::singleton_p (tree *) const\n {\n   return false;\n }\n \n-// Assignment operator for generic ranges.  Copying incompatible types\n-// is not allowed.\n-\n-vrange &\n-vrange::operator= (const vrange &src)\n+void\n+vrange::set (tree, tree, value_range_kind)\n {\n-  if (is_a <irange> (src))\n-    {\n-      as_a <irange> (*this) = as_a <irange> (src);\n-      return *this;\n-    }\n-  else\n-    gcc_unreachable ();\n }\n \n-// Equality operator for generic ranges.\n-\n-bool\n-vrange::operator== (const vrange &src) const\n+tree\n+vrange::type () const\n {\n-  if (is_a <irange> (src))\n-    return as_a <irange> (*this) == as_a <irange> (src);\n-  gcc_unreachable ();\n+  return void_type_node;\n }\n \n bool\n-irange::supports_type_p (tree type) const\n+vrange::supports_type_p (tree) const\n {\n-  return supports_p (type);\n+  return false;\n }\n \n-// Return TRUE if R fits in THIS.\n-\n-bool\n-irange::fits_p (const vrange &r) const\n+void\n+vrange::set_undefined ()\n {\n-  return m_max_ranges >= as_a <irange> (r).num_pairs ();\n+  m_kind = VR_UNDEFINED;\n }\n \n void\n-irange::set_nonnegative (tree type)\n+vrange::set_varying (tree)\n {\n-  set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n+  m_kind = VR_VARYING;\n }\n \n-unsupported_range::unsupported_range ()\n+bool\n+vrange::union_ (const vrange &r)\n {\n-  m_discriminator = VR_UNKNOWN;\n-  set_undefined ();\n+  if (r.undefined_p () || varying_p ())\n+    return false;\n+  if (undefined_p () || r.varying_p ())\n+    {\n+      operator= (r);\n+      return true;\n+    }\n+  gcc_unreachable ();\n+  return false;\n }\n \n-void\n-unsupported_range::set (tree, tree, value_range_kind)\n+bool\n+vrange::intersect (const vrange &r)\n {\n+  if (undefined_p () || r.varying_p ())\n+    return false;\n+  if (r.undefined_p ())\n+    {\n+      set_undefined ();\n+      return true;\n+    }\n+  if (varying_p ())\n+    {\n+      operator= (r);\n+      return true;\n+    }\n   gcc_unreachable ();\n+  return false;\n }\n \n-tree\n-unsupported_range::type () const\n+bool\n+vrange::zero_p () const\n {\n-  gcc_unreachable ();\n-  return nullptr;\n+  return false;\n }\n \n bool\n-unsupported_range::supports_type_p (tree) const\n+vrange::nonzero_p () const\n {\n   return false;\n }\n \n void\n-unsupported_range::set_undefined ()\n+vrange::set_nonzero (tree)\n {\n-  m_kind = VR_UNDEFINED;\n }\n \n void\n-unsupported_range::set_varying (tree)\n+vrange::set_zero (tree)\n {\n-  gcc_unreachable ();\n }\n \n void\n-unsupported_range::dump (FILE *file) const\n+vrange::set_nonnegative (tree)\n {\n-  fprintf (file, \"[unsupported_range] \");\n-  if (undefined_p ())\n-    {\n-      fprintf (file, \"UNDEFINED\");\n-      return;\n-    }\n-  if (varying_p ())\n-    {\n-      fprintf (file, \"VARYING\");\n-      return;\n-    }\n-  gcc_unreachable ();\n }\n \n bool\n-unsupported_range::union_ (const vrange &)\n+vrange::fits_p (const vrange &) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  return true;\n }\n \n-bool\n-unsupported_range::intersect (const vrange &)\n+// Assignment operator for generic ranges.  Copying incompatible types\n+// is not allowed.\n+\n+vrange &\n+vrange::operator= (const vrange &src)\n {\n-  gcc_unreachable ();\n-  return false;\n+  if (is_a <irange> (src))\n+    {\n+      as_a <irange> (*this) = as_a <irange> (src);\n+      return *this;\n+    }\n+  else\n+    gcc_unreachable ();\n }\n \n+// Equality operator for generic ranges.\n+\n bool\n-unsupported_range::zero_p () const\n+vrange::operator== (const vrange &src) const\n {\n+  if (is_a <irange> (src))\n+    return as_a <irange> (*this) == as_a <irange> (src);\n   gcc_unreachable ();\n-  return false;\n }\n \n bool\n-unsupported_range::nonzero_p () const\n+irange::supports_type_p (tree type) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  return supports_p (type);\n }\n \n-void\n-unsupported_range::set_nonzero (tree)\n+// Return TRUE if R fits in THIS.\n+\n+bool\n+irange::fits_p (const vrange &r) const\n {\n-  gcc_unreachable ();\n+  return m_max_ranges >= as_a <irange> (r).num_pairs ();\n }\n \n void\n-unsupported_range::set_zero (tree)\n+irange::set_nonnegative (tree type)\n {\n-  gcc_unreachable ();\n+  set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n }\n \n-void\n-unsupported_range::set_nonnegative (tree)\n+unsupported_range::unsupported_range ()\n {\n-  gcc_unreachable ();\n+  m_discriminator = VR_UNKNOWN;\n+  set_undefined ();\n }\n \n-bool\n-unsupported_range::fits_p (const vrange &) const\n+void\n+unsupported_range::dump (FILE *file) const\n {\n+  fprintf (file, \"[unsupported_range] \");\n+  if (undefined_p ())\n+    {\n+      fprintf (file, \"UNDEFINED\");\n+      return;\n+    }\n+  if (varying_p ())\n+    {\n+      fprintf (file, \"VARYING\");\n+      return;\n+    }\n   gcc_unreachable ();\n-  return false;\n }\n \n-unsupported_range Value_Range::m_unsupported;\n-\n // Here we copy between any two irange's.  The ranges can be legacy or\n // multi-ranges, and copying between any combination works correctly.\n "}, {"sha": "61e6a1887d5f0bf194a5faa9d06c9e14ac8d31d5", "filename": "gcc/value-range.h", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b0276d3fafdd254e17beee3c86ec00edcf28a2/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b0276d3fafdd254e17beee3c86ec00edcf28a2/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=89b0276d3fafdd254e17beee3c86ec00edcf28a2", "patch": "@@ -73,22 +73,22 @@ class vrange\n   template <typename T> friend bool is_a (vrange &);\n   friend class Value_Range;\n public:\n-  virtual void set (tree, tree, value_range_kind = VR_RANGE) = 0;\n-  virtual tree type () const = 0;\n-  virtual bool supports_type_p (tree type) const = 0;\n-  virtual void set_varying (tree type) = 0;\n-  virtual void set_undefined () = 0;\n+  virtual void set (tree, tree, value_range_kind = VR_RANGE);\n+  virtual tree type () const;\n+  virtual bool supports_type_p (tree type) const;\n+  virtual void set_varying (tree type);\n+  virtual void set_undefined ();\n   virtual void dump (FILE * = stderr) const = 0;\n-  virtual bool union_ (const vrange &) = 0;\n-  virtual bool intersect (const vrange &) = 0;\n+  virtual bool union_ (const vrange &);\n+  virtual bool intersect (const vrange &);\n   virtual bool singleton_p (tree *result = NULL) const;\n   virtual bool contains_p (tree cst) const;\n-  virtual bool zero_p () const = 0;\n-  virtual bool nonzero_p () const = 0;\n-  virtual void set_nonzero (tree type) = 0;\n-  virtual void set_zero (tree type) = 0;\n-  virtual void set_nonnegative (tree type) = 0;\n-  virtual bool fits_p (const vrange &r) const = 0;\n+  virtual bool zero_p () const;\n+  virtual bool nonzero_p () const;\n+  virtual void set_nonzero (tree type);\n+  virtual void set_zero (tree type);\n+  virtual void set_nonnegative (tree type);\n+  virtual bool fits_p (const vrange &r) const;\n \n   bool varying_p () const;\n   bool undefined_p () const;\n@@ -236,27 +236,13 @@ class GTY((user)) int_range : public irange\n };\n \n // Unsupported temporaries may be created by ranger before it's known\n-// they're unsupported, or by vr_values::get_value_range.  All\n-// operations except construction cause a trap.\n+// they're unsupported, or by vr_values::get_value_range.\n \n class unsupported_range : public vrange\n {\n public:\n   unsupported_range ();\n-  virtual void set (tree, tree, value_range_kind) override;\n-  virtual tree type () const override;\n-  virtual bool supports_type_p (tree type) const override;\n-  virtual void set_varying (tree type) override;\n-  virtual void set_undefined () override;\n   virtual void dump (FILE *) const override;\n-  virtual bool union_ (const vrange &) override;\n-  virtual bool intersect (const vrange &) override;\n-  virtual bool zero_p () const override;\n-  virtual bool nonzero_p () const override;\n-  virtual void set_nonzero (tree) override;\n-  virtual void set_zero (tree) override;\n-  virtual void set_nonnegative (tree) override;\n-  virtual bool fits_p (const vrange &) const override;\n };\n \n // Traits to implement vrange is_a<> and as_a<>.\n@@ -369,7 +355,7 @@ class Value_Range\n   wide_int upper_bound () const; // For irange/prange compatability.\n private:\n   void init (tree type);\n-  static unsupported_range m_unsupported;\n+  unsupported_range m_unsupported;\n   vrange *m_vrange;\n   int_range_max m_irange;\n   DISABLE_COPY_AND_ASSIGN (Value_Range);"}]}