{"sha": "a5d1cd099af2649bc92ba666eef17bbe68b03653", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVkMWNkMDk5YWYyNjQ5YmM5MmJhNjY2ZWVmMTdiYmU2OGIwMzY1Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-25T17:17:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-25T17:17:51Z"}, "message": "typeck.c (comp_cv_target_types): Split out...\n\n\t* typeck.c (comp_cv_target_types): Split out...\n\t(comp_target_types): From here.  Don't allow cv-qual changes under\n\ta pointer if nptrs == 0.  Fix OFFSET_TYPE handling.\n\t(build_ptrmemfunc): Pass 1 to nptrs.\n\t* cvt.c (perform_qualification_conversions): Use comp_ptr_ttypes.\n\nFrom-SVN: r21974", "tree": {"sha": "b47cf9a17b598b010e8a8539afea61f89a50c0a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b47cf9a17b598b010e8a8539afea61f89a50c0a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5d1cd099af2649bc92ba666eef17bbe68b03653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5d1cd099af2649bc92ba666eef17bbe68b03653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5d1cd099af2649bc92ba666eef17bbe68b03653", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5d1cd099af2649bc92ba666eef17bbe68b03653/comments", "author": null, "committer": null, "parents": [{"sha": "e94bc5f266e82c9c2f7c7441373cf63e859f932d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94bc5f266e82c9c2f7c7441373cf63e859f932d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e94bc5f266e82c9c2f7c7441373cf63e859f932d"}], "stats": {"total": 105, "additions": 76, "deletions": 29}, "files": [{"sha": "dfb6e518be7bdeee496896ab5e12aae0f5e6e158", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5d1cd099af2649bc92ba666eef17bbe68b03653/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5d1cd099af2649bc92ba666eef17bbe68b03653/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a5d1cd099af2649bc92ba666eef17bbe68b03653", "patch": "@@ -1,3 +1,11 @@\n+1998-08-25  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (comp_cv_target_types): Split out...\n+\t(comp_target_types): From here.  Don't allow cv-qual changes under\n+\ta pointer if nptrs == 0.  Fix OFFSET_TYPE handling.\n+\t(build_ptrmemfunc): Pass 1 to nptrs.\n+\t* cvt.c (perform_qualification_conversions): Use comp_ptr_ttypes.\n+\n 1998-08-25  Mark Mitchell  <mark@markmitchell.com>\n \n \t* search.c (dependent_base_p): Don't compare a binfo to"}, {"sha": "ff69fbfabafcbf59f27150f21d9f9dcf6b44a6ed", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5d1cd099af2649bc92ba666eef17bbe68b03653/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5d1cd099af2649bc92ba666eef17bbe68b03653/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a5d1cd099af2649bc92ba666eef17bbe68b03653", "patch": "@@ -1094,7 +1094,6 @@ type_promotes_to (type)\n   return cp_build_type_variant (type, constp, volatilep);\n }\n \n-\n /* The routines below this point are carefully written to conform to\n    the standard.  They use the same terminology, and follow the rules\n    closely.  Although they are used only in pt.c at the moment, they\n@@ -1109,7 +1108,9 @@ perform_qualification_conversions (type, expr)\n      tree type;\n      tree expr;\n {\n-  if (comp_target_types (type, TREE_TYPE (expr), 0) == 1)\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+      && comp_ptr_ttypes (TREE_TYPE (type), TREE_TYPE (TREE_TYPE (expr))))\n     return build1 (NOP_EXPR, type, expr);\n   else\n     return error_mark_node;"}, {"sha": "7859c0414018ee625372afae868eaf790f8f59e5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 65, "deletions": 27, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5d1cd099af2649bc92ba666eef17bbe68b03653/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5d1cd099af2649bc92ba666eef17bbe68b03653/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a5d1cd099af2649bc92ba666eef17bbe68b03653", "patch": "@@ -912,6 +912,31 @@ comptypes (type1, type2, strict)\n   return attrval == 2 && val == 1 ? 2 : val;\n }\n \n+/* Subroutine of comp_target-types.  Make sure that the cv-quals change\n+   only in the same direction as the target type.  */\n+\n+static int\n+comp_cv_target_types (ttl, ttr, nptrs)\n+     tree ttl, ttr;\n+     int nptrs;\n+{\n+  int t;\n+  int c = TYPE_READONLY (ttl) - TYPE_READONLY (ttr);\n+  int v = TYPE_VOLATILE (ttl) - TYPE_VOLATILE (ttr);\n+\n+  if ((c > 0 && v < 0) || (c < 0 && v > 0))\n+    return 0;\n+\n+  if (TYPE_MAIN_VARIANT (ttl) == TYPE_MAIN_VARIANT (ttr))\n+    return (c + v < 0) ? -1 : 1;\n+\n+  t = comp_target_types (ttl, ttr, nptrs);\n+  if ((t == 1 && c + v >= 0) || (t == -1 && c + v <= 0))\n+    return t;\n+\n+  return 0;\n+}\n+\n /* Return 1 or -1 if TTL and TTR are pointers to types that are equivalent,\n    ignoring their qualifiers, 0 if not. Return 1 means that TTR can be\n    converted to TTL. Return -1 means that TTL can be converted to TTR but\n@@ -937,15 +962,20 @@ comp_target_types (ttl, ttr, nptrs)\n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n \n-  if (TREE_CODE (ttr) == POINTER_TYPE\n-      || (TREE_CODE (ttr) == REFERENCE_TYPE))\n+  if ((TREE_CODE (ttr) == POINTER_TYPE\n+       || TREE_CODE (ttr) == REFERENCE_TYPE)\n+      /* If we get a pointer with nptrs == 0, we don't allow any tweaking\n+\t of the type pointed to.  This is necessary for reference init\n+\t semantics.  We won't get here from a previous call with nptrs == 1;\n+\t for multi-level pointers we end up in comp_ptr_ttypes.  */\n+      && nptrs > 0)\n     {\n       int is_ptr = TREE_CODE (ttr) == POINTER_TYPE;\n \n       ttl = TREE_TYPE (ttl);\n       ttr = TREE_TYPE (ttr);\n \n-      if (nptrs > 0 && is_ptr)\n+      if (is_ptr)\n \t{\n \t  if (TREE_CODE (ttl) == UNKNOWN_TYPE\n \t      || TREE_CODE (ttr) == UNKNOWN_TYPE)\n@@ -976,25 +1006,7 @@ comp_target_types (ttl, ttr, nptrs)\n       if (TREE_CODE (ttl) == FUNCTION_TYPE || TREE_CODE (ttl) == METHOD_TYPE)\n \treturn comp_target_types (ttl, ttr, nptrs - 1);\n \n-      /* Make sure that the cv-quals change only in the same direction as\n-\t the target type.  */\n-      {\n-\tint t;\n-\tint c = TYPE_READONLY (ttl) - TYPE_READONLY (ttr);\n-\tint v = TYPE_VOLATILE (ttl) - TYPE_VOLATILE (ttr);\n-\n-\tif ((c > 0 && v < 0) || (c < 0 && v > 0))\n-\t  return 0;\n-\n-\tif (TYPE_MAIN_VARIANT (ttl) == TYPE_MAIN_VARIANT (ttr))\n-\t  return (c + v < 0) ? -1 : 1;\n-\n-\tt = comp_target_types (ttl, ttr, nptrs - 1);\n-\tif ((t == 1 && c + v >= 0) || (t == -1 && c + v <= 0))\n-\t  return t;\n-\n-\treturn 0;\n-      }\n+      return comp_cv_target_types (ttl, ttr, nptrs - 1);\n     }\n \n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n@@ -1054,16 +1066,42 @@ comp_target_types (ttl, ttr, nptrs)\n   /* for C++ */\n   else if (TREE_CODE (ttr) == OFFSET_TYPE)\n     {\n+      int base;\n+      tree tmp;\n+\n       /* Contravariance: we can assign a pointer to base member to a pointer\n \t to derived member.  Note difference from simple pointer case, where\n \t we can pass a pointer to derived to a pointer to base.  */\n       if (comptypes (TYPE_OFFSET_BASETYPE (ttr),\n \t\t     TYPE_OFFSET_BASETYPE (ttl), 0))\n-\treturn comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n+\tbase = 1;\n       else if (comptypes (TYPE_OFFSET_BASETYPE (ttl),\n-\t\t\t  TYPE_OFFSET_BASETYPE (ttr), 0)\n-\t       && comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs))\n-\treturn -1;\n+\t\t\t  TYPE_OFFSET_BASETYPE (ttr), 0))\n+\t{\n+\t  tree tmp = ttl;\n+\t  ttl = ttr;\n+\t  ttr = tmp;\n+\t  base = -1;\n+\t}\n+      else\n+\treturn 0;\n+\n+      ttl = TREE_TYPE (ttl);\n+      ttr = TREE_TYPE (ttr);\n+\n+      if (TREE_CODE (ttl) == POINTER_TYPE\n+\t  || TREE_CODE (ttl) == ARRAY_TYPE)\n+\t{\n+\t  if (comp_ptr_ttypes (ttl, ttr))\n+\t    return base;\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  if (comp_cv_target_types (ttl, ttr, nptrs) == 1)\n+\t    return base;\n+\t  return 0;\n+\t}\n     }\n   else if (IS_AGGR_TYPE (ttl))\n     {\n@@ -6515,7 +6553,7 @@ build_ptrmemfunc (type, pfn, force)\n \n       pfn_type = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn));\n       if (!force\n-\t  && comp_target_types (type, pfn_type, 0) != 1)\n+\t  && comp_target_types (type, pfn_type, 1) != 1)\n \tcp_error (\"conversion to `%T' from `%T'\", type, pfn_type);\n \n       ndelta = cp_convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));"}]}