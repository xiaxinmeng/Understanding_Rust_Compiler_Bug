{"sha": "0299bc726138914291b0a5b2120e5e7b4e5127be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5OWJjNzI2MTM4OTE0MjkxYjBhNWIyMTIwZTVlN2I0ZTUxMjdiZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-11-10T00:04:03Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-11-10T00:04:03Z"}, "message": "constraints.md (wF constraint): New constraints for power9/toc fusion.\n\n[gcc]\n2015-11-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/constraints.md (wF constraint): New constraints\n\tfor power9/toc fusion.\n\t(wG constraint): Likewise.\n\n\t* config/rs6000/predicates.md (u6bit_cint_operand): New\n\tpredicate, recognize 0..63.\n\t(upper16_cint_operand): New predicate for power9 and toc fusion.\n\t(fpr_reg_operand): Likewise.\n\t(toc_fusion_or_p9_reg_operand): Likewise.\n\t(toc_fusion_mem_raw): Likewise.\n\t(toc_fusion_mem_wrapped): Likewise.\n\t(fusion_gpr_addis): If power9 fusion, allow fusion for a larger\n\taddress range.\n\t(fusion_gpr_mem_combo): Delete, use fusion_addis_mem_combo_load\n\tinstead.\n\t(fusion_addis_mem_combo_load): Add support for power9 fusion of\n\tfloating point loads, floating point stores, and gpr stores.\n\t(fusion_addis_mem_combo_store): Likewise.\n\t(fusion_offsettable_mem_operand): Likewise.\n\n\t* config/rs6000/rs6000-protos.h (emit_fusion_addis): Add\n\tdeclarations.\n\t(emit_fusion_load_store): Likewise.\n\t(fusion_p9_p): Likewise.\n\t(expand_fusion_p9_load): Likewise.\n\t(expand_fusion_p9_store): Likewise.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\t(fusion_wrap_memory_address): Likewise.\n\n\t* config/rs6000/rs6000.c (struct rs6000_reg_addr): Add new\n\telements for power9 fusion.\n\t(rs6000_debug_print_mode): Rework debug information to print more\n\tinformation about fusion.\n\t(rs6000_init_hard_regno_mode_ok): Setup for power9 fusion\n\tsupport.\n\t(rs6000_legitimate_address_p): Recognize toc fusion as a valid\n\toffsettable memory address.\n\t(rs6000_rtx_costs): Update costs for new ISA 3.0 instructions.\n\t(emit_fusion_gpr_load): Move most of the code from\n\temit_fusion_gpr_load into emit_fusion-addis that handles both\n\tpower8 and power9 fusion.\n\t(emit_fusion_addis): Likewise.\n\t(emit_fusion_load_store): Likewise.\n\t(fusion_wrap_memory_address): Add support for TOC fusion.\n\t(fusion_split_address): Likewise.\n\t(fusion_p9_p): Add support for power9 fusion.\n\t(expand_fusion_p9_load): Likewise.\n\t(expand_fusion_p9_store): Likewise.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\n\t* config/rs6000/rs6000.h (TARGET_EXTSWSLI): Macros for support for\n\tnew instructions in ISA 3.0.\n\t(TARGET_CTZ): Likewise.\n\t(TARGET_TOC_FUSION_INT): Macros for power9 fusion support.\n\t(TARGET_TOC_FUSION_FP): Likewise.\n\n\t* config/rs6000/rs6000.md (UNSPEC_FUSION_P9): New power9/toc\n\tfusion unspecs.\n\t(UNSPEC_FUSION_ADDIS): Likewise.\n\t(QHSI mode iterator): New iterator for power9 fusion.\n\t(GPR_FUSION): Likewise.\n\t(FPR_FUSION): Likewise.\n\t(mod<mode>3): Add support for ISA 3.0\n\tmodulus instructions.\n\t(umod<mode>3): Likewise.\n\t(divmod peephole): Likewise.\n\t(udivmod peephole): Likewise.\n\t(ctz<mode>2): Add support for ISA 3.0 count trailing zeros scalar\n\tinstructions.\n\t(ctz<mode>2_h): Likewise.\n\t(ashdi3_extswsli): Add support for ISA 3.0 EXTSWSLI instruction.\n\t(ashdi3_extswsli_dot): Likewise.\n\t(ashdi3_extswsli_dot2): Likewise.\n\t(power9 fusion splitter): New power9/toc fusion support.\n\t(toc_fusionload_<mode>): Likewise.\n\t(toc_fusionload_di): Likewise.\n\t(fusion_gpr_load_<mode>): Update predicate function.\n\t(power9 fusion peephole2s): New power9/toc fusion support.\n\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load): Likewise.\n\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store): Likewise.\n\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_load): Likewise.\n\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_store): Likewise.\n\t(fusion_p9_<mode>_constant): Likewise.\n\n[gcc/testsuite]\n2015-11-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* lib/target-supports.exp (check_p8vector_hw_available): Split\n\tlong line.\n\t(check_vsx_hw_available): Likewise.\n\t(check_p9vector_hw_available): Add new checks for ISA 3.0 hardware\n\tsupport and for PowerPC float128 support.\n\t(check_p9modulo_hw_available): Likewise.\n\t(check_ppc_float128_sw_available): Likewise.\n\t(check_ppc_float128_hw_available): Likewise.\n\t(check_effective_target_powerpc_p9vector_ok): Likewise.\n\t(check_effective_target_powerpc_p9modulo_ok): Likewise.\n\t(check_effective_target_powerpc_float128_sw_ok): Likewise.\n\t(check_effective_target_powerpc_float128_hw_ok): Likewise.\n\t(is-effective-target): Add new PowerPc targets.\n\t(is-effective-target-keyword): Likewise.\n\t(check_vect_support_and_set_flags): If we have ISA 3.0 vector\n\tinstructions, use it.\n\n\t* gcc.target/powerpc/mod-1.c: New test for ISA 3.0 instructions.\n\t* gcc.target/powerpc/mod-2.c: Likewise.\n\t* gcc.target/powerpc/ctz-1.c: Likewise.\n\t* gcc.target/powerpc/ctz-2.c: Likewise.\n\t* gcc.target/powerpc/extswsli-1.c: Likewise.\n\t* gcc.target/powerpc/extswsli-2.c: Likewise.\n\t* gcc.target/powerpc/extswsli-3.c: Likewise.\n\n\t* gcc.target/powerpc/fusion.c (fusion_vector): Move to fusion2.c\n\tand allow the test on PowerPC LE.\n\t* gcc.target/powerpc/fusion2.c (fusion_vector): Likewise.\n\t* gcc.target/powerpc/fusion3.c: New file, test power9 fusion.\n\n\t* gcc.target/powerpc/float128-call.c: Use powerpc_float128_sw_ok\n\tcheck instead of powerpc_vsx_ok.\n\t* gcc.target/powerpc/float128-mix.c: Likewise.\n\nFrom-SVN: r230066", "tree": {"sha": "699b2d43b4b4504fd6df5f3ead1a6e7262f886ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/699b2d43b4b4504fd6df5f3ead1a6e7262f886ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0299bc726138914291b0a5b2120e5e7b4e5127be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0299bc726138914291b0a5b2120e5e7b4e5127be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0299bc726138914291b0a5b2120e5e7b4e5127be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0299bc726138914291b0a5b2120e5e7b4e5127be/comments", "author": null, "committer": null, "parents": [{"sha": "cbb521e78efadb28cca43831c18aebed12501814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb521e78efadb28cca43831c18aebed12501814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb521e78efadb28cca43831c18aebed12501814"}], "stats": {"total": 2046, "additions": 1923, "deletions": 123}, "files": [{"sha": "08e176026ac27bf346bc684dc792d9ce8c1f55b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -1,3 +1,91 @@\n+2015-11-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/constraints.md (wF constraint): New constraints\n+\tfor power9/toc fusion.\n+\t(wG constraint): Likewise.\n+\n+\t* config/rs6000/predicates.md (u6bit_cint_operand): New\n+\tpredicate, recognize 0..63.\n+\t(upper16_cint_operand): New predicate for power9 and toc fusion.\n+\t(fpr_reg_operand): Likewise.\n+\t(toc_fusion_or_p9_reg_operand): Likewise.\n+\t(toc_fusion_mem_raw): Likewise.\n+\t(toc_fusion_mem_wrapped): Likewise.\n+\t(fusion_gpr_addis): If power9 fusion, allow fusion for a larger\n+\taddress range.\n+\t(fusion_gpr_mem_combo): Delete, use fusion_addis_mem_combo_load\n+\tinstead.\n+\t(fusion_addis_mem_combo_load): Add support for power9 fusion of\n+\tfloating point loads, floating point stores, and gpr stores.\n+\t(fusion_addis_mem_combo_store): Likewise.\n+\t(fusion_offsettable_mem_operand): Likewise.\n+\n+\t* config/rs6000/rs6000-protos.h (emit_fusion_addis): Add\n+\tdeclarations.\n+\t(emit_fusion_load_store): Likewise.\n+\t(fusion_p9_p): Likewise.\n+\t(expand_fusion_p9_load): Likewise.\n+\t(expand_fusion_p9_store): Likewise.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\t(fusion_wrap_memory_address): Likewise.\n+\n+\t* config/rs6000/rs6000.c (struct rs6000_reg_addr): Add new\n+\telements for power9 fusion.\n+\t(rs6000_debug_print_mode): Rework debug information to print more\n+\tinformation about fusion.\n+\t(rs6000_init_hard_regno_mode_ok): Setup for power9 fusion\n+\tsupport.\n+\t(rs6000_legitimate_address_p): Recognize toc fusion as a valid\n+\toffsettable memory address.\n+\t(rs6000_rtx_costs): Update costs for new ISA 3.0 instructions.\n+\t(emit_fusion_gpr_load): Move most of the code from\n+\temit_fusion_gpr_load into emit_fusion-addis that handles both\n+\tpower8 and power9 fusion.\n+\t(emit_fusion_addis): Likewise.\n+\t(emit_fusion_load_store): Likewise.\n+\t(fusion_wrap_memory_address): Add support for TOC fusion.\n+\t(fusion_split_address): Likewise.\n+\t(fusion_p9_p): Add support for power9 fusion.\n+\t(expand_fusion_p9_load): Likewise.\n+\t(expand_fusion_p9_store): Likewise.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\n+\t* config/rs6000/rs6000.h (TARGET_EXTSWSLI): Macros for support for\n+\tnew instructions in ISA 3.0.\n+\t(TARGET_CTZ): Likewise.\n+\t(TARGET_TOC_FUSION_INT): Macros for power9 fusion support.\n+\t(TARGET_TOC_FUSION_FP): Likewise.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_FUSION_P9): New power9/toc\n+\tfusion unspecs.\n+\t(UNSPEC_FUSION_ADDIS): Likewise.\n+\t(QHSI mode iterator): New iterator for power9 fusion.\n+\t(GPR_FUSION): Likewise.\n+\t(FPR_FUSION): Likewise.\n+\t(mod<mode>3): Add support for ISA 3.0\n+\tmodulus instructions.\n+\t(umod<mode>3): Likewise.\n+\t(divmod peephole): Likewise.\n+\t(udivmod peephole): Likewise.\n+\t(ctz<mode>2): Add support for ISA 3.0 count trailing zeros scalar\n+\tinstructions.\n+\t(ctz<mode>2_h): Likewise.\n+\t(ashdi3_extswsli): Add support for ISA 3.0 EXTSWSLI instruction.\n+\t(ashdi3_extswsli_dot): Likewise.\n+\t(ashdi3_extswsli_dot2): Likewise.\n+\t(power9 fusion splitter): New power9/toc fusion support.\n+\t(toc_fusionload_<mode>): Likewise.\n+\t(toc_fusionload_di): Likewise.\n+\t(fusion_gpr_load_<mode>): Update predicate function.\n+\t(power9 fusion peephole2s): New power9/toc fusion support.\n+\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load): Likewise.\n+\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store): Likewise.\n+\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_load): Likewise.\n+\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_store): Likewise.\n+\t(fusion_p9_<mode>_constant): Likewise.\n+\n 2015-11-09  Steve Ellcey  <sellcey@imgtec.com>\n \n \t* optabs.c (prepare_libcall_arg): New function."}, {"sha": "7c69b6c9e1d5bf986a2d0719532d53837c3476fa", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -137,6 +137,16 @@\n   (and (match_code \"const_int\")\n        (match_test \"TARGET_VSX && (ival == VECTOR_ELEMENT_SCALAR_64BIT)\")))\n \n+;; Extended fusion store\n+(define_memory_constraint \"wF\"\n+  \"Memory operand suitable for power9 fusion load/stores\"\n+  (match_operand 0 \"fusion_addis_mem_combo_load\"))\n+\n+;; Fusion gpr load.\n+(define_memory_constraint \"wG\"\n+  \"Memory operand suitable for TOC fusion memory references\"\n+  (match_operand 0 \"toc_fusion_mem_wrapped\"))\n+\n ;; Lq/stq validates the address for load/store quad\n (define_memory_constraint \"wQ\"\n   \"Memory operand suitable for the load/store quad instructions\""}, {"sha": "3b1a4561fba54a5598ab758b1bf94205b0b5f88b", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 197, "deletions": 6, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -142,6 +142,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 31\")))\n \n+;; Return 1 if op is a unsigned 6-bit constant integer.\n+(define_predicate \"u6bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 63\")))\n+\n ;; Return 1 if op is a signed 8-bit constant integer.\n ;; Integer multiplication complete more quickly\n (define_predicate \"s8bit_cint_operand\"\n@@ -163,6 +168,12 @@\n   (and (match_code \"const_int\")\n        (match_test \"satisfies_constraint_K (op)\")))\n \n+;; Return 1 if op is a constant integer that is a signed 16-bit constant\n+;; shifted left 16 bits\n+(define_predicate \"upper16_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_L (op)\")))\n+\n ;; Return 1 if op is a constant integer that cannot fit in a signed D field.\n (define_predicate \"non_short_cint_operand\"\n   (and (match_code \"const_int\")\n@@ -271,6 +282,70 @@\n   return (REGNO (op) != FIRST_GPR_REGNO);\n })\n \n+\n+;; Return true if this is a traditional floating point register\n+(define_predicate \"fpr_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  HOST_WIDE_INT r;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  r = REGNO (op);\n+  if (r >= FIRST_PSEUDO_REGISTER)\n+    return 1;\n+\n+  return FP_REGNO_P (r);\n+})\n+\n+;; Return true if this is a register that can has D-form addressing (GPR and\n+;; traditional FPR registers for scalars).  ISA 3.0 (power9) adds D-form\n+;; addressing for scalars in Altivec registers.\n+;;\n+;; If this is a pseudo only allow for GPR fusion in power8.  If we have the\n+;; power9 fusion allow the floating point types.\n+(define_predicate \"toc_fusion_or_p9_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  HOST_WIDE_INT r;\n+  bool gpr_p = (mode == QImode || mode == HImode || mode == SImode\n+\t\t|| mode == SFmode\n+\t\t|| (TARGET_POWERPC64 && (mode == DImode || mode == DFmode)));\n+  bool fpr_p = (TARGET_P9_FUSION\n+\t\t&& (mode == DFmode || mode == SFmode\n+\t\t    || (TARGET_POWERPC64 && mode == DImode)));\n+  bool vmx_p = (TARGET_P9_FUSION && TARGET_P9_VECTOR\n+\t\t&& (mode == DFmode || mode == SFmode));\n+\n+  if (!TARGET_P8_FUSION)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  r = REGNO (op);\n+  if (r >= FIRST_PSEUDO_REGISTER)\n+    return (gpr_p || fpr_p || vmx_p);\n+\n+  if (INT_REGNO_P (r))\n+    return gpr_p;\n+\n+  if (FP_REGNO_P (r))\n+    return fpr_p;\n+\n+  if (ALTIVEC_REGNO_P (r))\n+    return vmx_p;\n+\n+  return 0;\n+})\n+\n ;; Return 1 if op is a HTM specific SPR register.\n (define_predicate \"htm_spr_reg_operand\"\n   (match_operand 0 \"register_operand\")\n@@ -1598,6 +1673,35 @@\n   return GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_TOCREL;\n })\n \n+;; Match the TOC memory operand that can be fused with an addis instruction.\n+;; This is used in matching a potential fused address before register\n+;; allocation.\n+(define_predicate \"toc_fusion_mem_raw\"\n+  (match_code \"mem\")\n+{\n+  if (!TARGET_TOC_FUSION_INT || !can_create_pseudo_p ())\n+    return false;\n+\n+  return small_toc_ref (XEXP (op, 0), Pmode);\n+})\n+\n+;; Match the memory operand that has been fused with an addis instruction and\n+;; wrapped inside of an (unspec [...] UNSPEC_FUSION_ADDIS) wrapper.\n+(define_predicate \"toc_fusion_mem_wrapped\"\n+  (match_code \"mem\")\n+{\n+  rtx addr;\n+\n+  if (!TARGET_TOC_FUSION_INT)\n+    return false;\n+\n+  if (!MEM_P (op))\n+    return false;\n+\n+  addr = XEXP (op, 0);\n+  return (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_FUSION_ADDIS);\n+})\n+\n ;; Match the first insn (addis) in fusing the combination of addis and loads to\n ;; GPR registers on power8.\n (define_predicate \"fusion_gpr_addis\"\n@@ -1620,15 +1724,19 @@\n   else\n     return 0;\n \n-  /* Power8 currently will only do the fusion if the top 11 bits of the addis\n-     value are all 1's or 0's.  */\n   value = INTVAL (int_const);\n   if ((value & (HOST_WIDE_INT)0xffff) != 0)\n     return 0;\n \n   if ((value & (HOST_WIDE_INT)0xffff0000) == 0)\n     return 0;\n \n+  /* Power8 currently will only do the fusion if the top 11 bits of the addis\n+     value are all 1's or 0's.  Ignore this restriction if we are testing\n+     advanced fusion.  */\n+  if (TARGET_P9_FUSION)\n+    return 1;\n+\n   return (IN_RANGE (value >> 16, -32, 31));\n })\n \n@@ -1694,13 +1802,14 @@\n ;; Match a GPR load (lbz, lhz, lwz, ld) that uses a combined address in the\n ;; memory field with both the addis and the memory offset.  Sign extension\n ;; is not handled here, since lha and lwa are not fused.\n-(define_predicate \"fusion_gpr_mem_combo\"\n-  (match_code \"mem,zero_extend\")\n+;; With extended fusion, also match a FPR load (lfd, lfs) and float_extend\n+(define_predicate \"fusion_addis_mem_combo_load\"\n+  (match_code \"mem,zero_extend,float_extend\")\n {\n   rtx addr, base, offset;\n \n-  /* Handle zero extend.  */\n-  if (GET_CODE (op) == ZERO_EXTEND)\n+  /* Handle zero/float extend.  */\n+  if (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == FLOAT_EXTEND)\n     {\n       op = XEXP (op, 0);\n       mode = GET_MODE (op);\n@@ -1721,6 +1830,71 @@\n \treturn 0;\n       break;\n \n+    case SFmode:\n+    case DFmode:\n+      if (!TARGET_P9_FUSION)\n+\treturn 0;\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  addr = XEXP (op, 0);\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    return 0;\n+\n+  base = XEXP (addr, 0);\n+  if (!fusion_gpr_addis (base, GET_MODE (base)))\n+    return 0;\n+\n+  offset = XEXP (addr, 1);\n+  if (GET_CODE (addr) == PLUS)\n+    return satisfies_constraint_I (offset);\n+\n+  else if (GET_CODE (addr) == LO_SUM)\n+    {\n+      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n+\treturn small_toc_ref (offset, GET_MODE (offset));\n+\n+      else if (TARGET_ELF && !TARGET_POWERPC64)\n+\treturn CONSTANT_P (offset);\n+    }\n+\n+  return 0;\n+})\n+\n+;; Like fusion_addis_mem_combo_load, but for stores\n+(define_predicate \"fusion_addis_mem_combo_store\"\n+  (match_code \"mem\")\n+{\n+  rtx addr, base, offset;\n+\n+  if (!MEM_P (op) || !TARGET_P9_FUSION)\n+    return 0;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+    case HImode:\n+    case SImode:\n+      break;\n+\n+    case DImode:\n+      if (!TARGET_POWERPC64)\n+\treturn 0;\n+      break;\n+\n+    case SFmode:\n+      if (!TARGET_SF_FPR)\n+\treturn 0;\n+      break;\n+\n+    case DFmode:\n+      if (!TARGET_DF_FPR)\n+\treturn 0;\n+      break;\n+\n     default:\n       return 0;\n     }\n@@ -1748,3 +1922,20 @@\n \n   return 0;\n })\n+\n+;; Return true if the operand is a float_extend or zero extend of an\n+;; offsettable memory operand suitable for use in fusion\n+(define_predicate \"fusion_offsettable_mem_operand\"\n+  (match_code \"mem,zero_extend,float_extend\")\n+{\n+  if (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == FLOAT_EXTEND)\n+    {\n+      op = XEXP (op, 0);\n+      mode = GET_MODE (op);\n+    }\n+\n+  if (!memory_operand (op, mode))\n+    return 0;\n+\n+  return offsettable_nonstrict_memref_p (op);\n+})"}, {"sha": "9a149b9e29a4e576e394946f971ad68a09b781c2", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -87,7 +87,15 @@ extern bool direct_move_p (rtx, rtx);\n extern bool quad_load_store_p (rtx, rtx);\n extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx);\n extern void expand_fusion_gpr_load (rtx *);\n+extern void emit_fusion_addis (rtx, rtx, const char *, const char *);\n+extern void emit_fusion_load_store (rtx, rtx, rtx, const char *);\n extern const char *emit_fusion_gpr_load (rtx, rtx);\n+extern bool fusion_p9_p (rtx, rtx, rtx, rtx);\n+extern void expand_fusion_p9_load (rtx *);\n+extern void expand_fusion_p9_store (rtx *);\n+extern const char *emit_fusion_p9_load (rtx, rtx, rtx);\n+extern const char *emit_fusion_p9_store (rtx, rtx, rtx);\n+extern rtx fusion_wrap_memory_address (rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "ca93609bb6bda4c28420886d717ed53de05ec0e0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 743, "deletions": 93, "changes": 836, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -376,8 +376,18 @@ struct rs6000_reg_addr {\n   enum insn_code reload_fpr_gpr;\t/* INSN to move from FPR to GPR.  */\n   enum insn_code reload_gpr_vsx;\t/* INSN to move from GPR to VSX.  */\n   enum insn_code reload_vsx_gpr;\t/* INSN to move from VSX to GPR.  */\n+  enum insn_code fusion_gpr_ld;\t\t/* INSN for fusing gpr ADDIS/loads.  */\n+\t\t\t\t\t/* INSNs for fusing addi with loads\n+\t\t\t\t\t   or stores for each reg. class.  */\t\t\t\t\t   \n+  enum insn_code fusion_addi_ld[(int)N_RELOAD_REG];\n+  enum insn_code fusion_addi_st[(int)N_RELOAD_REG];\n+\t\t\t\t\t/* INSNs for fusing addis with loads\n+\t\t\t\t\t   or stores for each reg. class.  */\t\t\t\t\t   \n+  enum insn_code fusion_addis_ld[(int)N_RELOAD_REG];\n+  enum insn_code fusion_addis_st[(int)N_RELOAD_REG];\n   addr_mask_type addr_mask[(int)N_RELOAD_REG]; /* Valid address masks.  */\n   bool scalar_in_vmx_p;\t\t\t/* Scalar value can go in VMX.  */\n+  bool fused_toc;\t\t\t/* Mode supports TOC fusion.  */\n };\n \n static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];\n@@ -2026,25 +2036,113 @@ DEBUG_FUNCTION void\n rs6000_debug_print_mode (ssize_t m)\n {\n   ssize_t rc;\n+  int spaces = 0;\n+  bool fuse_extra_p;\n \n   fprintf (stderr, \"Mode: %-5s\", GET_MODE_NAME (m));\n   for (rc = 0; rc < N_RELOAD_REG; rc++)\n     fprintf (stderr, \" %s: %s\", reload_reg_map[rc].name,\n \t     rs6000_debug_addr_mask (reg_addr[m].addr_mask[rc], true));\n \n+  if ((reg_addr[m].reload_store != CODE_FOR_nothing)\n+      || (reg_addr[m].reload_load != CODE_FOR_nothing))\n+    fprintf (stderr, \"  Reload=%c%c\",\n+\t     (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',\n+\t     (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');\n+  else\n+    spaces += sizeof (\"  Reload=sl\") - 1;\n+\n+  if (reg_addr[m].scalar_in_vmx_p)\n+    {\n+      fprintf (stderr, \"%*s  Upper=y\", spaces, \"\");\n+      spaces = 0;\n+    }\n+  else\n+    spaces += sizeof (\"  Upper=y\") - 1;\n+\n+  fuse_extra_p = ((reg_addr[m].fusion_gpr_ld != CODE_FOR_nothing)\n+\t\t  || reg_addr[m].fused_toc);\n+  if (!fuse_extra_p)\n+    {\n+      for (rc = 0; rc < N_RELOAD_REG; rc++)\n+\t{\n+\t  if (rc != RELOAD_REG_ANY)\n+\t    {\n+\t      if (reg_addr[m].fusion_addi_ld[rc]     != CODE_FOR_nothing\n+\t\t  || reg_addr[m].fusion_addi_ld[rc]  != CODE_FOR_nothing\n+\t\t  || reg_addr[m].fusion_addi_st[rc]  != CODE_FOR_nothing\n+\t\t  || reg_addr[m].fusion_addis_ld[rc] != CODE_FOR_nothing\n+\t\t  || reg_addr[m].fusion_addis_st[rc] != CODE_FOR_nothing)\n+\t\t{\n+\t\t  fuse_extra_p = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (fuse_extra_p)\n+    {\n+      fprintf (stderr, \"%*s  Fuse:\", spaces, \"\");\n+      spaces = 0;\n+\n+      for (rc = 0; rc < N_RELOAD_REG; rc++)\n+\t{\n+\t  if (rc != RELOAD_REG_ANY)\n+\t    {\n+\t      char load, store;\n+\n+\t      if (reg_addr[m].fusion_addis_ld[rc] != CODE_FOR_nothing)\n+\t\tload = 'l';\n+\t      else if (reg_addr[m].fusion_addi_ld[rc] != CODE_FOR_nothing)\n+\t\tload = 'L';\n+\t      else\n+\t\tload = '-';\n+\n+\t      if (reg_addr[m].fusion_addis_st[rc] != CODE_FOR_nothing)\n+\t\tstore = 's';\n+\t      else if (reg_addr[m].fusion_addi_st[rc] != CODE_FOR_nothing)\n+\t\tstore = 'S';\n+\t      else\n+\t\tstore = '-';\n+\n+\t      if (load == '-' && store == '-')\n+\t\tspaces += 5;\n+\t      else\n+\t\t{\n+\t\t  fprintf (stderr, \"%*s%c=%c%c\", (spaces + 1), \"\",\n+\t\t\t   reload_reg_map[rc].name[0], load, store);\n+\t\t  spaces = 0;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (reg_addr[m].fusion_gpr_ld != CODE_FOR_nothing)\n+\t{\n+\t  fprintf (stderr, \"%*sP8gpr\", (spaces + 1), \"\");\n+\t  spaces = 0;\n+\t}\n+      else\n+\tspaces += sizeof (\" P8gpr\") - 1;\n+\n+      if (reg_addr[m].fused_toc)\n+\t{\n+\t  fprintf (stderr, \"%*sToc\", (spaces + 1), \"\");\n+\t  spaces = 0;\n+\t}\n+      else\n+\tspaces += sizeof (\" Toc\") - 1;\n+    }\n+  else\n+    spaces += sizeof (\"  Fuse: G=ls F=ls v=ls P8gpr Toc\") - 1;\n+\n   if (rs6000_vector_unit[m] != VECTOR_NONE\n-      || rs6000_vector_mem[m] != VECTOR_NONE\n-      || (reg_addr[m].reload_store != CODE_FOR_nothing)\n-      || (reg_addr[m].reload_load != CODE_FOR_nothing)\n-      || reg_addr[m].scalar_in_vmx_p)\n+      || rs6000_vector_mem[m] != VECTOR_NONE)\n     {\n-      fprintf (stderr,\n-\t       \"  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c Upper=%c\",\n+      fprintf (stderr, \"%*s  vector: arith=%-10s mem=%s\",\n+\t       spaces, \"\",\n \t       rs6000_debug_vector_unit (rs6000_vector_unit[m]),\n-\t       rs6000_debug_vector_unit (rs6000_vector_mem[m]),\n-\t       (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',\n-\t       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*',\n-\t       (reg_addr[m].scalar_in_vmx_p) ? 'y' : 'n');\n+\t       rs6000_debug_vector_unit (rs6000_vector_mem[m]));\n     }\n \n   fputs (\"\\n\", stderr);\n@@ -3019,6 +3117,130 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \treg_addr[SFmode].scalar_in_vmx_p = true;\n     }\n \n+  /* Setup the fusion operations.  */\n+  if (TARGET_P8_FUSION)\n+    {\n+      reg_addr[QImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_qi;\n+      reg_addr[HImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_hi;\n+      reg_addr[SImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_si;\n+      if (TARGET_64BIT)\n+\treg_addr[DImode].fusion_gpr_ld = CODE_FOR_fusion_gpr_load_di;\n+    }\n+\n+  if (TARGET_P9_FUSION)\n+    {\n+      struct fuse_insns {\n+\tenum machine_mode mode;\t\t\t/* mode of the fused type.  */\n+\tenum machine_mode pmode;\t\t/* pointer mode.  */\n+\tenum rs6000_reload_reg_type rtype;\t/* register type.  */\n+\tenum insn_code load;\t\t\t/* load insn.  */\n+\tenum insn_code store;\t\t\t/* store insn.  */\n+      };\n+\n+      static const struct fuse_insns addis_insns[] = {\n+\t{ SFmode, DImode, RELOAD_REG_FPR,\n+\t  CODE_FOR_fusion_fpr_di_sf_load,\n+\t  CODE_FOR_fusion_fpr_di_sf_store },\n+\n+\t{ SFmode, SImode, RELOAD_REG_FPR,\n+\t  CODE_FOR_fusion_fpr_si_sf_load,\n+\t  CODE_FOR_fusion_fpr_si_sf_store },\n+\n+\t{ DFmode, DImode, RELOAD_REG_FPR,\n+\t  CODE_FOR_fusion_fpr_di_df_load,\n+\t  CODE_FOR_fusion_fpr_di_df_store },\n+\n+\t{ DFmode, SImode, RELOAD_REG_FPR,\n+\t  CODE_FOR_fusion_fpr_si_df_load,\n+\t  CODE_FOR_fusion_fpr_si_df_store },\n+\n+\t{ DImode, DImode, RELOAD_REG_FPR,\n+\t  CODE_FOR_fusion_fpr_di_di_load,\n+\t  CODE_FOR_fusion_fpr_di_di_store },\n+\n+\t{ DImode, SImode, RELOAD_REG_FPR,\n+\t  CODE_FOR_fusion_fpr_si_di_load,\n+\t  CODE_FOR_fusion_fpr_si_di_store },\n+\n+\t{ QImode, DImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_di_qi_load,\n+\t  CODE_FOR_fusion_gpr_di_qi_store },\n+\n+\t{ QImode, SImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_si_qi_load,\n+\t  CODE_FOR_fusion_gpr_si_qi_store },\n+\n+\t{ HImode, DImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_di_hi_load,\n+\t  CODE_FOR_fusion_gpr_di_hi_store },\n+\n+\t{ HImode, SImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_si_hi_load,\n+\t  CODE_FOR_fusion_gpr_si_hi_store },\n+\n+\t{ SImode, DImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_di_si_load,\n+\t  CODE_FOR_fusion_gpr_di_si_store },\n+\n+\t{ SImode, SImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_si_si_load,\n+\t  CODE_FOR_fusion_gpr_si_si_store },\n+\n+\t{ SFmode, DImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_di_sf_load,\n+\t  CODE_FOR_fusion_gpr_di_sf_store },\n+\n+\t{ SFmode, SImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_si_sf_load,\n+\t  CODE_FOR_fusion_gpr_si_sf_store },\n+\n+\t{ DImode, DImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_di_di_load,\n+\t  CODE_FOR_fusion_gpr_di_di_store },\n+\n+\t{ DFmode, DImode, RELOAD_REG_GPR,\n+\t  CODE_FOR_fusion_gpr_di_df_load,\n+\t  CODE_FOR_fusion_gpr_di_df_store },\n+      };\n+\n+      enum machine_mode cur_pmode = Pmode;\n+      size_t i;\n+\n+      for (i = 0; i < ARRAY_SIZE (addis_insns); i++)\n+\t{\n+\t  enum machine_mode xmode = addis_insns[i].mode;\n+\t  enum rs6000_reload_reg_type rtype = addis_insns[i].rtype;\n+\n+\t  if (addis_insns[i].pmode != cur_pmode)\n+\t    continue;\n+\n+\t  if (rtype == RELOAD_REG_FPR\n+\t      && (!TARGET_HARD_FLOAT || !TARGET_FPRS))\n+\t    continue;\n+\n+\t  reg_addr[xmode].fusion_addis_ld[rtype] = addis_insns[i].load;\n+\t  reg_addr[xmode].fusion_addis_st[rtype] = addis_insns[i].store;\n+\t}\n+    }\n+\n+  /* Note which types we support fusing TOC setup plus memory insn.  We only do\n+     fused TOCs for medium/large code models.  */\n+  if (TARGET_P8_FUSION && TARGET_TOC_FUSION && TARGET_POWERPC64\n+      && (TARGET_CMODEL != CMODEL_SMALL))\n+    {\n+      reg_addr[QImode].fused_toc = true;\n+      reg_addr[HImode].fused_toc = true;\n+      reg_addr[SImode].fused_toc = true;\n+      reg_addr[DImode].fused_toc = true;\n+      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t{\n+\t  if (TARGET_SINGLE_FLOAT)\n+\t    reg_addr[SFmode].fused_toc = true;\n+\t  if (TARGET_DOUBLE_FLOAT)\n+\t    reg_addr[DFmode].fused_toc = true;\n+\t}\n+    }\n+\n   /* Precalculate HARD_REGNO_NREGS.  */\n   for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n@@ -8127,6 +8349,8 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n       && legitimate_constant_pool_address_p (x, mode,\n \t\t\t\t\t     reg_ok_strict || lra_in_progress))\n     return 1;\n+  if (reg_offset_p && reg_addr[mode].fused_toc && toc_fusion_mem_wrapped (x, mode))\n+    return 1;\n   /* For TImode, if we have load/store quad and TImode in VSX registers, only\n      allow register indirect addresses.  This will allow the values to go in\n      either GPRs or VSX registers without reloading.  The vector types would\n@@ -31851,12 +32075,15 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t  else\n \t    *total = rs6000_cost->divsi;\n \t}\n-      /* Add in shift and subtract for MOD. */\n-      if (code == MOD || code == UMOD)\n+      /* Add in shift and subtract for MOD unless we have a mod instruction. */\n+      if (!TARGET_MODULO && (code == MOD || code == UMOD))\n \t*total += COSTS_N_INSNS (2);\n       return false;\n \n     case CTZ:\n+      *total = COSTS_N_INSNS (TARGET_CTZ ? 1 : 4);\n+      return false;\n+\n     case FFS:\n       *total = COSTS_N_INSNS (4);\n       return false;\n@@ -31931,6 +32158,17 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       return false;\n \n     case ASHIFT:\n+      /* The EXTSWSLI instruction is a combined instruction.  Don't count both\n+\t the sign extend and shift separately within the insn.  */\n+      if (TARGET_EXTSWSLI && mode == DImode\n+\t  && GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == SImode)\n+\t{\n+\t  *total = 0;\n+\t  return false;\n+\t}\n+      /* fall through */\n+\t  \n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ROTATE:\n@@ -35202,72 +35440,21 @@ expand_fusion_gpr_load (rtx *operands)\n   return;\n }\n \n-/* Return a string to fuse an addis instruction with a gpr load to the same\n-   register that we loaded up the addis instruction.  The address that is used\n-   is the logical address that was formed during peephole2:\n-\t(lo_sum (high) (low-part))\n-\n-   The code is complicated, so we call output_asm_insn directly, and just\n-   return \"\".  */\n+/* Emit the addis instruction that will be part of a fused instruction\n+   sequence.  */\n \n-const char *\n-emit_fusion_gpr_load (rtx target, rtx mem)\n+void\n+emit_fusion_addis (rtx target, rtx addis_value, const char *comment,\n+\t\t   const char *mode_name)\n {\n-  rtx addis_value;\n   rtx fuse_ops[10];\n-  rtx addr;\n-  rtx load_offset;\n-  const char *addis_str = NULL;\n-  const char *load_str = NULL;\n-  const char *mode_name = NULL;\n   char insn_template[80];\n-  machine_mode mode;\n+  const char *addis_str = NULL;\n   const char *comment_str = ASM_COMMENT_START;\n \n-  if (GET_CODE (mem) == ZERO_EXTEND)\n-    mem = XEXP (mem, 0);\n-\n-  gcc_assert (REG_P (target) && MEM_P (mem));\n-\n   if (*comment_str == ' ')\n     comment_str++;\n \n-  addr = XEXP (mem, 0);\n-  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n-    gcc_unreachable ();\n-\n-  addis_value = XEXP (addr, 0);\n-  load_offset = XEXP (addr, 1);\n-\n-  /* Now emit the load instruction to the same register.  */\n-  mode = GET_MODE (mem);\n-  switch (mode)\n-    {\n-    case QImode:\n-      mode_name = \"char\";\n-      load_str = \"lbz\";\n-      break;\n-\n-    case HImode:\n-      mode_name = \"short\";\n-      load_str = \"lhz\";\n-      break;\n-\n-    case SImode:\n-      mode_name = \"int\";\n-      load_str = \"lwz\";\n-      break;\n-\n-    case DImode:\n-      gcc_assert (TARGET_POWERPC64);\n-      mode_name = \"long\";\n-      load_str = \"ld\";\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   /* Emit the addis instruction.  */\n   fuse_ops[0] = target;\n   if (satisfies_constraint_L (addis_value))\n@@ -35346,67 +35533,530 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n   if (!addis_str)\n     fatal_insn (\"Could not generate addis value for fusion\", addis_value);\n \n-  sprintf (insn_template, \"%s\\t\\t%s gpr load fusion, type %s\", addis_str,\n-\t   comment_str, mode_name);\n+  sprintf (insn_template, \"%s\\t\\t%s %s, type %s\", addis_str, comment_str,\n+\t   comment, mode_name);\n   output_asm_insn (insn_template, fuse_ops);\n+}\n \n-  /* Emit the D-form load instruction.  */\n-  if (CONST_INT_P (load_offset) && satisfies_constraint_I (load_offset))\n+/* Emit a D-form load or store instruction that is the second instruction\n+   of a fusion sequence.  */\n+\n+void\n+emit_fusion_load_store (rtx load_store_reg, rtx addis_reg, rtx offset,\n+\t\t\tconst char *insn_str)\n+{\n+  rtx fuse_ops[10];\n+  char insn_template[80];\n+\n+  fuse_ops[0] = load_store_reg;\n+  fuse_ops[1] = addis_reg;\n+\n+  if (CONST_INT_P (offset) && satisfies_constraint_I (offset))\n     {\n-      sprintf (insn_template, \"%s %%0,%%1(%%0)\", load_str);\n-      fuse_ops[1] = load_offset;\n+      sprintf (insn_template, \"%s %%0,%%2(%%1)\", insn_str);\n+      fuse_ops[2] = offset;\n       output_asm_insn (insn_template, fuse_ops);\n     }\n \n-  else if (GET_CODE (load_offset) == UNSPEC\n-\t   && XINT (load_offset, 1) == UNSPEC_TOCREL)\n+  else if (GET_CODE (offset) == UNSPEC\n+\t   && XINT (offset, 1) == UNSPEC_TOCREL)\n     {\n       if (TARGET_ELF)\n-\tsprintf (insn_template, \"%s %%0,%%1@toc@l(%%0)\", load_str);\n+\tsprintf (insn_template, \"%s %%0,%%2@toc@l(%%1)\", insn_str);\n \n       else if (TARGET_XCOFF)\n-\tsprintf (insn_template, \"%s %%0,%%1@l(%%0)\", load_str);\n+\tsprintf (insn_template, \"%s %%0,%%2@l(%%1)\", insn_str);\n \n       else\n \tgcc_unreachable ();\n \n-      fuse_ops[1] = XVECEXP (load_offset, 0, 0);\n+      fuse_ops[2] = XVECEXP (offset, 0, 0);\n       output_asm_insn (insn_template, fuse_ops);\n     }\n \n-  else if (GET_CODE (load_offset) == PLUS\n-\t   && GET_CODE (XEXP (load_offset, 0)) == UNSPEC\n-\t   && XINT (XEXP (load_offset, 0), 1) == UNSPEC_TOCREL\n-\t   && CONST_INT_P (XEXP (load_offset, 1)))\n+  else if (GET_CODE (offset) == PLUS\n+\t   && GET_CODE (XEXP (offset, 0)) == UNSPEC\n+\t   && XINT (XEXP (offset, 0), 1) == UNSPEC_TOCREL\n+\t   && CONST_INT_P (XEXP (offset, 1)))\n     {\n-      rtx tocrel_unspec = XEXP (load_offset, 0);\n+      rtx tocrel_unspec = XEXP (offset, 0);\n       if (TARGET_ELF)\n-\tsprintf (insn_template, \"%s %%0,%%1+%%2@toc@l(%%0)\", load_str);\n+\tsprintf (insn_template, \"%s %%0,%%2+%%3@toc@l(%%1)\", insn_str);\n \n       else if (TARGET_XCOFF)\n-\tsprintf (insn_template, \"%s %%0,%%1+%%2@l(%%0)\", load_str);\n+\tsprintf (insn_template, \"%s %%0,%%2+%%3@l(%%1)\", insn_str);\n \n       else\n \tgcc_unreachable ();\n \n-      fuse_ops[1] = XVECEXP (tocrel_unspec, 0, 0);\n-      fuse_ops[2] = XEXP (load_offset, 1);\n+      fuse_ops[2] = XVECEXP (tocrel_unspec, 0, 0);\n+      fuse_ops[3] = XEXP (offset, 1);\n       output_asm_insn (insn_template, fuse_ops);\n     }\n \n-  else if (TARGET_ELF && !TARGET_POWERPC64 && CONSTANT_P (load_offset))\n+  else if (TARGET_ELF && !TARGET_POWERPC64 && CONSTANT_P (offset))\n     {\n-      sprintf (insn_template, \"%s %%0,%%1@l(%%0)\", load_str);\n+      sprintf (insn_template, \"%s %%0,%%2@l(%%1)\", insn_str);\n \n-      fuse_ops[1] = load_offset;\n+      fuse_ops[2] = offset;\n       output_asm_insn (insn_template, fuse_ops);\n     }\n \n   else\n-    fatal_insn (\"Unable to generate load offset for fusion\", load_offset);\n+    fatal_insn (\"Unable to generate load/store offset for fusion\", offset);\n+\n+  return;\n+}\n+\n+/* Wrap a TOC address that can be fused to indicate that special fusion\n+   processing is needed.  */\n+\n+rtx\n+fusion_wrap_memory_address (rtx old_mem)\n+{\n+  rtx old_addr = XEXP (old_mem, 0);\n+  rtvec v = gen_rtvec (1, old_addr);\n+  rtx new_addr = gen_rtx_UNSPEC (Pmode, v, UNSPEC_FUSION_ADDIS);\n+  return replace_equiv_address_nv (old_mem, new_addr, false);\n+}\n+\n+/* Given an address, convert it into the addis and load offset parts.  Addresses\n+   created during the peephole2 process look like:\n+\t(lo_sum (high (unspec [(sym)] UNSPEC_TOCREL))\n+\t\t(unspec [(...)] UNSPEC_TOCREL))\n+\n+   Addresses created via toc fusion look like:\n+\t(unspec [(unspec [(...)] UNSPEC_TOCREL)] UNSPEC_FUSION_ADDIS))  */\n+\n+static void\n+fusion_split_address (rtx addr, rtx *p_hi, rtx *p_lo)\n+{\n+  rtx hi, lo;\n+\n+  if (GET_CODE (addr) == UNSPEC && XINT (addr, 1) == UNSPEC_FUSION_ADDIS)\n+    {\n+      lo = XVECEXP (addr, 0, 0);\n+      hi = gen_rtx_HIGH (Pmode, lo);\n+    }\n+  else if (GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM)\n+    {\n+      hi = XEXP (addr, 0);\n+      lo = XEXP (addr, 1);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  *p_hi = hi;\n+  *p_lo = lo;\n+}\n+\n+/* Return a string to fuse an addis instruction with a gpr load to the same\n+   register that we loaded up the addis instruction.  The address that is used\n+   is the logical address that was formed during peephole2:\n+\t(lo_sum (high) (low-part))\n+\n+   Or the address is the TOC address that is wrapped before register allocation:\n+\t(unspec [(addr) (toc-reg)] UNSPEC_FUSION_ADDIS)\n+\n+   The code is complicated, so we call output_asm_insn directly, and just\n+   return \"\".  */\n+\n+const char *\n+emit_fusion_gpr_load (rtx target, rtx mem)\n+{\n+  rtx addis_value;\n+  rtx addr;\n+  rtx load_offset;\n+  const char *load_str = NULL;\n+  const char *mode_name = NULL;\n+  machine_mode mode;\n+\n+  if (GET_CODE (mem) == ZERO_EXTEND)\n+    mem = XEXP (mem, 0);\n+\n+  gcc_assert (REG_P (target) && MEM_P (mem));\n+\n+  addr = XEXP (mem, 0);\n+  fusion_split_address (addr, &addis_value, &load_offset);\n+\n+  /* Now emit the load instruction to the same register.  */\n+  mode = GET_MODE (mem);\n+  switch (mode)\n+    {\n+    case QImode:\n+      mode_name = \"char\";\n+      load_str = \"lbz\";\n+      break;\n+\n+    case HImode:\n+      mode_name = \"short\";\n+      load_str = \"lhz\";\n+      break;\n+\n+    case SImode:\n+    case SFmode:\n+      mode_name = (mode == SFmode) ? \"float\" : \"int\";\n+      load_str = \"lwz\";\n+      break;\n+\n+    case DImode:\n+    case DFmode:\n+      gcc_assert (TARGET_POWERPC64);\n+      mode_name = (mode == DFmode) ? \"double\" : \"long\";\n+      load_str = \"ld\";\n+      break;\n+\n+    default:\n+      fatal_insn (\"Bad GPR fusion\", gen_rtx_SET (target, mem));\n+    }\n+\n+  /* Emit the addis instruction.  */\n+  emit_fusion_addis (target, addis_value, \"gpr load fusion\", mode_name);\n+\n+  /* Emit the D-form load instruction.  */\n+  emit_fusion_load_store (target, target, load_offset, load_str);\n \n   return \"\";\n }\n+\f\n+\n+/* Return true if the peephole2 can combine a load/store involving a\n+   combination of an addis instruction and the memory operation.  This was\n+   added to the ISA 3.0 (power9) hardware.  */\n+\n+bool\n+fusion_p9_p (rtx addis_reg,\t\t/* register set via addis.  */\n+\t     rtx addis_value,\t\t/* addis value.  */\n+\t     rtx dest,\t\t\t/* destination (memory or register). */\n+\t     rtx src)\t\t\t/* source (register or memory).  */\n+{\n+  rtx addr, mem, offset;\n+  enum machine_mode mode = GET_MODE (src);\n+\n+  /* Validate arguments.  */\n+  if (!base_reg_operand (addis_reg, GET_MODE (addis_reg)))\n+    return false;\n+\n+  if (!fusion_gpr_addis (addis_value, GET_MODE (addis_value)))\n+    return false;\n+\n+  /* Ignore extend operations that are part of the load.  */\n+  if (GET_CODE (src) == FLOAT_EXTEND || GET_CODE (src) == ZERO_EXTEND)\n+    src = XEXP (src, 0);\n+\n+  /* Test for memory<-register or register<-memory.  */\n+  if (fpr_reg_operand (src, mode) || int_reg_operand (src, mode))\n+    {\n+      if (!MEM_P (dest))\n+\treturn false;\n+\n+      mem = dest;\n+    }\n+\n+  else if (MEM_P (src))\n+    {\n+      if (!fpr_reg_operand (dest, mode) && !int_reg_operand (dest, mode))\n+\treturn false;\n+\n+      mem = src;\n+    }\n+\n+  else\n+    return false;\n+\n+  addr = XEXP (mem, 0);\t\t\t/* either PLUS or LO_SUM.  */\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (!rtx_equal_p (addis_reg, XEXP (addr, 0)))\n+\treturn false;\n+\n+      return satisfies_constraint_I (XEXP (addr, 1));\n+    }\n+\n+  else if (GET_CODE (addr) == LO_SUM)\n+    {\n+      if (!rtx_equal_p (addis_reg, XEXP (addr, 0)))\n+\treturn false;\n+\n+      offset = XEXP (addr, 1);\n+      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n+\treturn small_toc_ref (offset, GET_MODE (offset));\n+\n+      else if (TARGET_ELF && !TARGET_POWERPC64)\n+\treturn CONSTANT_P (offset);\n+    }\n+\n+  return false;\n+}\n+\n+/* During the peephole2 pass, adjust and expand the insns for an extended fusion\n+   load sequence.\n+\n+   The operands are:\n+\toperands[0]\tregister set with addis\n+\toperands[1]\tvalue set via addis\n+\toperands[2]\ttarget register being loaded\n+\toperands[3]\tD-form memory reference using operands[0].\n+\n+  This is similar to the fusion introduced with power8, except it scales to\n+  both loads/stores and does not require the result register to be the same as\n+  the base register.  At the moment, we only do this if register set with addis\n+  is dead.  */\n+\n+void\n+expand_fusion_p9_load (rtx *operands)\n+{\n+  rtx tmp_reg = operands[0];\n+  rtx addis_value = operands[1];\n+  rtx target = operands[2];\n+  rtx orig_mem = operands[3];\n+  rtx  new_addr, new_mem, orig_addr, offset, set, clobber, insn;\n+  enum rtx_code plus_or_lo_sum;\n+  machine_mode target_mode = GET_MODE (target);\n+  machine_mode extend_mode = target_mode;\n+  machine_mode ptr_mode = Pmode;\n+  enum rtx_code extend = UNKNOWN;\n+\n+  if (GET_CODE (orig_mem) == FLOAT_EXTEND || GET_CODE (orig_mem) == ZERO_EXTEND)\n+    {\n+      extend = GET_CODE (orig_mem);\n+      orig_mem = XEXP (orig_mem, 0);\n+      target_mode = GET_MODE (orig_mem);\n+    }\n+\n+  gcc_assert (MEM_P (orig_mem));\n+\n+  orig_addr = XEXP (orig_mem, 0);\n+  plus_or_lo_sum = GET_CODE (orig_addr);\n+  gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);\n+\n+  offset = XEXP (orig_addr, 1);\n+  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_value, offset);\n+  new_mem = replace_equiv_address_nv (orig_mem, new_addr, false);\n+\n+  if (extend != UNKNOWN)\n+    new_mem = gen_rtx_fmt_e (extend, extend_mode, new_mem);\n+\n+  new_mem = gen_rtx_UNSPEC (extend_mode, gen_rtvec (1, new_mem),\n+\t\t\t    UNSPEC_FUSION_P9);\n+\n+  set = gen_rtx_SET (target, new_mem);\n+  clobber = gen_rtx_CLOBBER (VOIDmode, tmp_reg);\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber));\n+  emit_insn (insn);\n+\n+  return;\n+}\n+\n+/* During the peephole2 pass, adjust and expand the insns for an extended fusion\n+   store sequence.\n+\n+   The operands are:\n+\toperands[0]\tregister set with addis\n+\toperands[1]\tvalue set via addis\n+\toperands[2]\ttarget D-form memory being stored to\n+\toperands[3]\tregister being stored\n+\n+  This is similar to the fusion introduced with power8, except it scales to\n+  both loads/stores and does not require the result register to be the same as\n+  the base register.  At the moment, we only do this if register set with addis\n+  is dead.  */\n+\n+void\n+expand_fusion_p9_store (rtx *operands)\n+{\n+  rtx tmp_reg = operands[0];\n+  rtx addis_value = operands[1];\n+  rtx orig_mem = operands[2];\n+  rtx src = operands[3];\n+  rtx  new_addr, new_mem, orig_addr, offset, set, clobber, insn, new_src;\n+  enum rtx_code plus_or_lo_sum;\n+  machine_mode target_mode = GET_MODE (orig_mem);\n+  machine_mode ptr_mode = Pmode;\n+\n+  gcc_assert (MEM_P (orig_mem));\n+\n+  orig_addr = XEXP (orig_mem, 0);\n+  plus_or_lo_sum = GET_CODE (orig_addr);\n+  gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);\n+\n+  offset = XEXP (orig_addr, 1);\n+  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_value, offset);\n+  new_mem = replace_equiv_address_nv (orig_mem, new_addr, false);\n+\n+  new_src = gen_rtx_UNSPEC (target_mode, gen_rtvec (1, src),\n+\t\t\t    UNSPEC_FUSION_P9);\n+\n+  set = gen_rtx_SET (new_mem, new_src);\n+  clobber = gen_rtx_CLOBBER (VOIDmode, tmp_reg);\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber));\n+  emit_insn (insn);\n+\n+  return;\n+}\n+\n+/* Return a string to fuse an addis instruction with a load using extended\n+   fusion.  The address that is used is the logical address that was formed\n+   during peephole2: (lo_sum (high) (low-part))\n+\n+   The code is complicated, so we call output_asm_insn directly, and just\n+   return \"\".  */\n+\n+const char *\n+emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n+{\n+  enum machine_mode mode = GET_MODE (reg);\n+  rtx hi;\n+  rtx lo;\n+  rtx addr;\n+  const char *load_string;\n+  int r;\n+\n+  if (GET_CODE (mem) == FLOAT_EXTEND || GET_CODE (mem) == ZERO_EXTEND)\n+    {\n+      mem = XEXP (mem, 0);\n+      mode = GET_MODE (mem);\n+    }\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      gcc_assert (SUBREG_BYTE (reg) == 0);\n+      reg = SUBREG_REG (reg);\n+    }\n+\n+  if (!REG_P (reg))\n+    fatal_insn (\"emit_fusion_p9_load, bad reg #1\", reg);\n+\n+  r = REGNO (reg);\n+  if (FP_REGNO_P (r))\n+    {\n+      if (mode == SFmode)\n+\tload_string = \"lfs\";\n+      else if (mode == DFmode || mode == DImode)\n+\tload_string = \"lfd\";\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (INT_REGNO_P (r))\n+    {\n+      switch (mode)\n+\t{\n+\tcase QImode:\n+\t  load_string = \"lbz\";\n+\t  break;\n+\tcase HImode:\n+\t  load_string = \"lhz\";\n+\t  break;\n+\tcase SImode:\n+\tcase SFmode:\n+\t  load_string = \"lwz\";\n+\t  break;\n+\tcase DImode:\n+\tcase DFmode:\n+\t  if (!TARGET_POWERPC64)\n+\t    gcc_unreachable ();\n+\t  load_string = \"ld\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    fatal_insn (\"emit_fusion_p9_load, bad reg #2\", reg);\n+\n+  if (!MEM_P (mem))\n+    fatal_insn (\"emit_fusion_p9_load not MEM\", mem);\n+\n+  addr = XEXP (mem, 0);\n+  fusion_split_address (addr, &hi, &lo);\n+\n+  /* Emit the addis instruction.  */\n+  emit_fusion_addis (tmp_reg, hi, \"power9 load fusion\", GET_MODE_NAME (mode));\n+\n+  /* Emit the D-form load instruction.  */\n+  emit_fusion_load_store (reg, tmp_reg, lo, load_string);\n+\n+  return \"\";\n+}\n+\n+/* Return a string to fuse an addis instruction with a store using extended\n+   fusion.  The address that is used is the logical address that was formed\n+   during peephole2: (lo_sum (high) (low-part))\n+\n+   The code is complicated, so we call output_asm_insn directly, and just\n+   return \"\".  */\n+\n+const char *\n+emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n+{\n+  enum machine_mode mode = GET_MODE (reg);\n+  rtx hi;\n+  rtx lo;\n+  rtx addr;\n+  const char *store_string;\n+  int r;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      gcc_assert (SUBREG_BYTE (reg) == 0);\n+      reg = SUBREG_REG (reg);\n+    }\n+\n+  if (!REG_P (reg))\n+    fatal_insn (\"emit_fusion_p9_store, bad reg #1\", reg);\n+\n+  r = REGNO (reg);\n+  if (FP_REGNO_P (r))\n+    {\n+      if (mode == SFmode)\n+\tstore_string = \"stfs\";\n+      else if (mode == DFmode)\n+\tstore_string = \"stfd\";\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (INT_REGNO_P (r))\n+    {\n+      switch (mode)\n+\t{\n+\tcase QImode:\n+\t  store_string = \"stb\";\n+\t  break;\n+\tcase HImode:\n+\t  store_string = \"sth\";\n+\t  break;\n+\tcase SImode:\n+\tcase SFmode:\n+\t  store_string = \"stw\";\n+\t  break;\n+\tcase DImode:\n+\tcase DFmode:\n+\t  if (!TARGET_POWERPC64)\n+\t    gcc_unreachable ();\n+\t  store_string = \"std\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    fatal_insn (\"emit_fusion_p9_store, bad reg #2\", reg);\n+\n+  if (!MEM_P (mem))\n+    fatal_insn (\"emit_fusion_p9_store not MEM\", mem);\n+\n+  addr = XEXP (mem, 0);\n+  fusion_split_address (addr, &hi, &lo);\n+\n+  /* Emit the addis instruction.  */\n+  emit_fusion_addis (tmp_reg, hi, \"power9 store fusion\", GET_MODE_NAME (mode));\n+\n+  /* Emit the D-form load instruction.  */\n+  emit_fusion_load_store (reg, tmp_reg, lo, store_string);\n+\n+  return \"\";\n+}\n+\n \f\n /* Analyze vector computations and remove unnecessary doubleword\n    swaps (xxswapdi instructions).  This pass is performed only"}, {"sha": "4ac4f3134d5be4d2cf672610fc53ec87dc816bc3", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -565,6 +565,8 @@ extern int rs6000_vector_align[];\n #define TARGET_FCFIDUS\tTARGET_POPCNTD\n #define TARGET_FCTIDUZ\tTARGET_POPCNTD\n #define TARGET_FCTIWUZ\tTARGET_POPCNTD\n+#define TARGET_CTZ\tTARGET_MODULO\n+#define TARGET_EXTSWSLI\t(TARGET_MODULO && TARGET_POWERPC64)\n \n #define TARGET_XSCVDPSPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n #define TARGET_XSCVSPDPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n@@ -701,6 +703,22 @@ extern int rs6000_vector_align[];\n \t\t\t && TARGET_DOUBLE_FLOAT \\\n \t\t\t && (TARGET_PPC_GFXOPT || VECTOR_UNIT_VSX_P (DFmode)))\n \n+/* Conditions to allow TOC fusion for loading/storing integers.  */\n+#define TARGET_TOC_FUSION_INT\t(TARGET_P8_FUSION\t\t\t\\\n+\t\t\t\t && TARGET_TOC_FUSION\t\t\t\\\n+\t\t\t\t && (TARGET_CMODEL != CMODEL_SMALL)\t\\\n+\t\t\t\t && TARGET_POWERPC64)\n+\n+/* Conditions to allow TOC fusion for loading/storing floating point.  */\n+#define TARGET_TOC_FUSION_FP\t(TARGET_P9_FUSION\t\t\t\\\n+\t\t\t\t && TARGET_TOC_FUSION\t\t\t\\\n+\t\t\t\t && (TARGET_CMODEL != CMODEL_SMALL)\t\\\n+\t\t\t\t && TARGET_POWERPC64\t\t\t\\\n+\t\t\t\t && TARGET_HARD_FLOAT\t\t\t\\\n+\t\t\t\t && TARGET_FPRS\t\t\t\t\\\n+\t\t\t\t && TARGET_SINGLE_FLOAT\t\t\t\\\n+\t\t\t\t && TARGET_DOUBLE_FLOAT)\n+\n /* Whether the various reciprocal divide/square root estimate instructions\n    exist, and whether we should automatically generate code for the instruction\n    by default.  */\n@@ -2095,8 +2113,12 @@ do {\t\t\t\t\t\t\t\t\t     \\\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n   ((VALUE) = ((MODE) == SImode ? 32 : 64), 1)\n \n-/* The CTZ patterns return -1 for input of zero.  */\n-#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = -1, 1)\n+/* The CTZ patterns that are implemented in terms of CLZ return -1 for input of\n+   zero.  The hardware instructions added in Power9 return 32 or 64.  */\n+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)\t\t\t\t\\\n+  ((!TARGET_CTZ)\t\t\t\t\t\t\t\\\n+   ? ((VALUE) = -1, 1)\t\t\t\t\t\t\t\\\n+   : ((VALUE) = ((MODE) == SImode ? 32 : 64), 1))\n \n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction"}, {"sha": "49c5c98f7d5aaf66902ce1549a72ad4498c02f7b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 428, "deletions": 11, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -141,6 +141,8 @@\n    UNSPEC_LSQ\n    UNSPEC_FUSION_GPR\n    UNSPEC_STACK_CHECK\n+   UNSPEC_FUSION_P9\n+   UNSPEC_FUSION_ADDIS\n   ])\n \n ;;\n@@ -327,12 +329,28 @@\n ; QImode or HImode for small atomic ops\n (define_mode_iterator QHI [QI HI])\n \n+; QImode, HImode, SImode for fused ops only for GPR loads\n+(define_mode_iterator QHSI [QI HI SI])\n+\n ; HImode or SImode for sign extended fusion ops\n (define_mode_iterator HSI [HI SI])\n \n ; SImode or DImode, even if DImode doesn't fit in GPRs.\n (define_mode_iterator SDI [SI DI])\n \n+; Types that can be fused with an ADDIS instruction to load or store a GPR\n+; register that has reg+offset addressing.\n+(define_mode_iterator GPR_FUSION [QI\n+\t\t\t\t  HI\n+\t\t\t\t  SI\n+\t\t\t\t  (DI\t\"TARGET_POWERPC64\")\n+\t\t\t\t  SF\n+\t\t\t\t  (DF\t\"TARGET_POWERPC64\")])\n+\n+; Types that can be fused with an ADDIS instruction to load or store a FPR\n+; register that has reg+offset addressing.\n+(define_mode_iterator FPR_FUSION [DI SF DF])\n+\n ; The size of a pointer.  Also, the size of the value that a record-condition\n ; (one with a '.') will compare; and the size used for arithmetic carries.\n (define_mode_iterator P [(SI \"TARGET_32BIT\") (DI \"TARGET_64BIT\")])\n@@ -2101,12 +2119,25 @@\n \t      (clobber (reg:GPR CA_REGNO))])]\n   \"\"\n {\n+  if (TARGET_CTZ)\n+    {\n+      emit_insn (gen_ctz<mode>2_hw (operands[0], operands[1]));\n+      DONE;\n+    }\n+\n   operands[2] = gen_reg_rtx (<MODE>mode);\n   operands[3] = gen_reg_rtx (<MODE>mode);\n   operands[4] = gen_reg_rtx (<MODE>mode);\n   operands[5] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) - 1);\n })\n \n+(define_insn \"ctz<mode>2_hw\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(ctz:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_CTZ\"\n+  \"cnttz<wd> %0,%1\"\n+  [(set_attr \"type\" \"cntlz\")])\n+\n (define_expand \"ffs<mode>2\"\n   [(set (match_dup 2)\n \t(neg:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")))\n@@ -2885,9 +2916,9 @@\n    (set_attr \"cell_micro\" \"not\")])\n \n (define_expand \"mod<mode>3\"\n-  [(use (match_operand:GPR 0 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:GPR 1 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:GPR 2 \"reg_or_cint_operand\" \"\"))]\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\")\n+\t(mod:GPR (match_operand:GPR 1 \"gpc_reg_operand\")\n+\t\t (match_operand:GPR 2 \"reg_or_cint_operand\")))]\n   \"\"\n {\n   int i;\n@@ -2897,16 +2928,93 @@\n   if (GET_CODE (operands[2]) != CONST_INT\n       || INTVAL (operands[2]) <= 0\n       || (i = exact_log2 (INTVAL (operands[2]))) < 0)\n-    FAIL;\n+    {\n+      if (!TARGET_MODULO)\n+\tFAIL;\n \n-  temp1 = gen_reg_rtx (<MODE>mode);\n-  temp2 = gen_reg_rtx (<MODE>mode);\n+      operands[2] = force_reg (<MODE>mode, operands[2]);\n+    }\n+  else\n+    {\n+      temp1 = gen_reg_rtx (<MODE>mode);\n+      temp2 = gen_reg_rtx (<MODE>mode);\n \n-  emit_insn (gen_div<mode>3 (temp1, operands[1], operands[2]));\n-  emit_insn (gen_ashl<mode>3 (temp2, temp1, GEN_INT (i)));\n-  emit_insn (gen_sub<mode>3 (operands[0], operands[1], temp2));\n-  DONE;\n+      emit_insn (gen_div<mode>3 (temp1, operands[1], operands[2]));\n+      emit_insn (gen_ashl<mode>3 (temp2, temp1, GEN_INT (i)));\n+      emit_insn (gen_sub<mode>3 (operands[0], operands[1], temp2));\n+      DONE;\n+    }\n })\n+\n+;; In order to enable using a peephole2 for combining div/mod to eliminate the\n+;; mod, prefer putting the result of mod into a different register\n+(define_insn \"*mod<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=&r\")\n+        (mod:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_MODULO\"\n+  \"mods<wd> %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")\n+   (set_attr \"size\" \"<bits>\")])\n+\n+\n+(define_insn \"umod<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=&r\")\n+        (umod:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_MODULO\"\n+  \"modu<wd> %0,%1,%2\"\n+  [(set_attr \"type\" \"div\")\n+   (set_attr \"size\" \"<bits>\")])\n+\n+;; On machines with modulo support, do a combined div/mod the old fashioned\n+;; method, since the multiply/subtract is faster than doing the mod instruction\n+;; after a divide.\n+\n+(define_peephole2\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+\t(div:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:GPR 2 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"\")\n+\t(mod:GPR (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"TARGET_MODULO\n+   && ! reg_mentioned_p (operands[0], operands[1])\n+   && ! reg_mentioned_p (operands[0], operands[2])\n+   && ! reg_mentioned_p (operands[3], operands[1])\n+   && ! reg_mentioned_p (operands[3], operands[2])\"\n+  [(set (match_dup 0)\n+\t(div:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 3)\n+\t(mult:GPR (match_dup 0)\n+\t\t  (match_dup 2)))\n+   (set (match_dup 3)\n+\t(minus:GPR (match_dup 1)\n+\t\t   (match_dup 3)))])\n+\n+(define_peephole2\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+\t(udiv:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"\")))\n+   (set (match_operand:GPR 3 \"gpc_reg_operand\" \"\")\n+\t(umod:GPR (match_dup 1)\n+\t\t  (match_dup 2)))]\n+  \"TARGET_MODULO\n+   && ! reg_mentioned_p (operands[0], operands[1])\n+   && ! reg_mentioned_p (operands[0], operands[2])\n+   && ! reg_mentioned_p (operands[3], operands[1])\n+   && ! reg_mentioned_p (operands[3], operands[2])\"\n+  [(set (match_dup 0)\n+\t(div:GPR (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 3)\n+\t(mult:GPR (match_dup 0)\n+\t\t  (match_dup 2)))\n+   (set (match_dup 3)\n+\t(minus:GPR (match_dup 1)\n+\t\t   (match_dup 3)))])\n+\n \f\n ;; Logical instructions\n ;; The logical instructions are mostly combined by using match_operator,\n@@ -3843,6 +3951,127 @@\n    (set_attr \"dot\" \"yes\")\n    (set_attr \"length\" \"4,8\")])\n \n+;; Pretend we have a memory form of extswsli until register allocation is done\n+;; so that we use LWZ to load the value from memory, instead of LWA.\n+(define_insn_and_split \"ashdi3_extswsli\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(ashift:DI\n+\t (sign_extend:DI (match_operand:SI 1 \"reg_or_mem_operand\" \"r,m\"))\n+\t (match_operand:DI 2 \"u6bit_cint_operand\" \"n,n\")))]\n+  \"TARGET_EXTSWSLI\"\n+  \"@\n+   extswsli %0,%1,%2\n+   #\"\n+  \"&& reload_completed && MEM_P (operands[1])\"\n+  [(set (match_dup 3)\n+\t(match_dup 1))\n+   (set (match_dup 0)\n+\t(ashift:DI (sign_extend:DI (match_dup 3))\n+\t\t   (match_dup 2)))]\n+{\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"no\")])\n+\n+\n+(define_insn_and_split \"ashdi3_extswsli_dot\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y,?x,??y\")\n+\t(compare:CC\n+\t (ashift:DI\n+\t  (sign_extend:DI (match_operand:SI 1 \"reg_or_mem_operand\" \"r,r,m,m\"))\n+\t  (match_operand:DI 2 \"u6bit_cint_operand\" \"n,n,n,n\"))\n+\t (const_int 0)))\n+   (clobber (match_scratch:DI 0 \"=r,r,r,r\"))]\n+  \"TARGET_EXTSWSLI\"\n+  \"@\n+   extswsli. %0,%1,%2\n+   #\n+   #\n+   #\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[3], CCmode)\n+       || memory_operand (operands[1], SImode))\"\n+  [(pc)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx shift = operands[2];\n+  rtx cr = operands[3];\n+  rtx src2;\n+\n+  if (!MEM_P (src))\n+    src2 = src;\n+  else\n+    {\n+      src2 = gen_lowpart (SImode, dest);\n+      emit_move_insn (src2, src);\n+    }\n+\n+  if (REGNO (cr) == CR0_REGNO)\n+    {\n+      emit_insn (gen_ashdi3_extswsli_dot (dest, src2, shift, cr));\n+      DONE;\n+    }\n+\n+  emit_insn (gen_ashdi3_extswsli (dest, src2, shift));\n+  emit_insn (gen_rtx_SET (cr, gen_rtx_COMPARE (CCmode, dest, const0_rtx)));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"no\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8,8,12\")])\n+\n+(define_insn_and_split \"ashdi3_extswsli_dot2\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y,?x,??y\")\n+\t(compare:CC\n+\t (ashift:DI\n+\t  (sign_extend:DI (match_operand:SI 1 \"reg_or_mem_operand\" \"r,r,m,m\"))\n+\t  (match_operand:DI 2 \"u6bit_cint_operand\" \"n,n,n,n\"))\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n+\t(ashift:DI (sign_extend:DI (match_dup 1))\n+\t\t   (match_dup 2)))]\n+  \"TARGET_EXTSWSLI\"\n+  \"@\n+   extswsli. %0,%1,%2\n+   #\n+   #\n+   #\"\n+  \"&& reload_completed\n+   && (cc_reg_not_cr0_operand (operands[3], CCmode)\n+       || memory_operand (operands[1], SImode))\"\n+  [(pc)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx shift = operands[2];\n+  rtx cr = operands[3];\n+  rtx src2;\n+\n+  if (!MEM_P (src))\n+    src2 = src;\n+  else\n+    {\n+      src2 = gen_lowpart (SImode, dest);\n+      emit_move_insn (src2, src);\n+    }\n+\n+  if (REGNO (cr) == CR0_REGNO)\n+    {\n+      emit_insn (gen_ashdi3_extswsli_dot2 (dest, src2, shift, cr));\n+      DONE;\n+    }\n+\n+  emit_insn (gen_ashdi3_extswsli (dest, src2, shift));\n+  emit_insn (gen_rtx_SET (cr, gen_rtx_COMPARE (CCmode, dest, const0_rtx)));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"maybe_var_shift\" \"no\")\n+   (set_attr \"dot\" \"yes\")\n+   (set_attr \"length\" \"4,8,8,12\")])\n \n (define_insn \"lshr<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n@@ -12381,6 +12610,66 @@\n ;; a GPR.  The addis instruction must be adjacent to the load, and use the same\n ;; register that is being loaded.  The fused ops must be physically adjacent.\n \n+;; There are two parts to addis fusion.  The support for fused TOCs occur\n+;; before register allocation, and is meant to reduce the lifetime for the\n+;; tempoary register that holds the ADDIS result.  On Power8 GPR loads, we try\n+;; to use the register that is being load.  The peephole2 then gathers any\n+;; other fused possibilities that it can find after register allocation.  If\n+;; power9 fusion is selected, we also fuse floating point loads/stores.\n+\n+;; Fused TOC support: Replace simple GPR loads with a fused form.  This is done\n+;; before register allocation, so that we can avoid allocating a temporary base\n+;; register that won't be used, and that we try to load into base registers,\n+;; and not register 0.  If we can't get a fused GPR load, generate a P9 fusion\n+;; (addis followed by load) even on power8.\n+\n+(define_split\n+  [(set (match_operand:INT1 0 \"toc_fusion_or_p9_reg_operand\" \"\")\n+\t(match_operand:INT1 1 \"toc_fusion_mem_raw\" \"\"))]\n+  \"TARGET_TOC_FUSION_INT && can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0) (match_dup 2))\n+\t      (unspec [(const_int 0)] UNSPEC_FUSION_ADDIS)\n+\t      (use (match_dup 3))\n+\t      (clobber (scratch:DI))])]\n+{\n+  operands[2] = fusion_wrap_memory_address (operands[1]);\n+  operands[3] = gen_rtx_REG (Pmode, TOC_REGISTER);\n+})\n+\n+(define_insn \"*toc_fusionload_<mode>\"\n+  [(set (match_operand:QHSI 0 \"int_reg_operand\" \"=&b,??r\")\n+\t(match_operand:QHSI 1 \"toc_fusion_mem_wrapped\" \"wG,wG\"))\n+   (unspec [(const_int 0)] UNSPEC_FUSION_ADDIS)\n+   (use (match_operand:DI 2 \"base_reg_operand\" \"r,r\"))\n+   (clobber (match_scratch:DI 3 \"=X,&b\"))]\n+  \"TARGET_TOC_FUSION_INT\"\n+{\n+  if (base_reg_operand (operands[0], <MODE>mode))\n+    return emit_fusion_gpr_load (operands[0], operands[1]);\n+\n+  return emit_fusion_p9_load (operands[0], operands[1], operands[3]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*toc_fusionload_di\"\n+  [(set (match_operand:DI 0 \"int_reg_operand\" \"=&b,??r,?d\")\n+\t(match_operand:DI 1 \"toc_fusion_mem_wrapped\" \"wG,wG,wG\"))\n+   (unspec [(const_int 0)] UNSPEC_FUSION_ADDIS)\n+   (use (match_operand:DI 2 \"base_reg_operand\" \"r,r,r\"))\n+   (clobber (match_scratch:DI 3 \"=X,&b,&b\"))]\n+  \"TARGET_TOC_FUSION_INT && TARGET_POWERPC64\n+   && (MEM_P (operands[1]) || int_reg_operand (operands[0], DImode))\"\n+{\n+  if (base_reg_operand (operands[0], DImode))\n+    return emit_fusion_gpr_load (operands[0], operands[1]);\n+\n+  return emit_fusion_p9_load (operands[0], operands[1], operands[3]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+\f\n ;; Find cases where the addis that feeds into a load instruction is either used\n ;; once or is the same as the target register, and replace it with the fusion\n ;; insn\n@@ -12404,7 +12693,7 @@\n \n (define_insn \"fusion_gpr_load_<mode>\"\n   [(set (match_operand:INT1 0 \"base_reg_operand\" \"=&b\")\n-\t(unspec:INT1 [(match_operand:INT1 1 \"fusion_gpr_mem_combo\" \"\")]\n+\t(unspec:INT1 [(match_operand:INT1 1 \"fusion_addis_mem_combo_load\" \"\")]\n \t\t     UNSPEC_FUSION_GPR))]\n   \"TARGET_P8_FUSION\"\n {\n@@ -12413,6 +12702,133 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n+\f\n+;; ISA 3.0 (power9) fusion support\n+;; Merge addis with floating load/store to FPRs (or GPRs).\n+(define_peephole2\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:SFDF 2 \"toc_fusion_or_p9_reg_operand\" \"\")\n+\t(match_operand:SFDF 3 \"fusion_offsettable_mem_operand\" \"\"))]\n+  \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n+   && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\"\n+  [(const_int 0)]\n+{\n+  expand_fusion_p9_load (operands);\n+  DONE;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n+\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n+   (set (match_operand:SFDF 2 \"offsettable_mem_operand\" \"\")\n+\t(match_operand:SFDF 3 \"toc_fusion_or_p9_reg_operand\" \"\"))]\n+  \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n+   && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\"\n+  [(const_int 0)]\n+{\n+  expand_fusion_p9_store (operands);\n+  DONE;\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SDI 0 \"int_reg_operand\" \"\")\n+\t(match_operand:SDI 1 \"upper16_cint_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(ior:SDI (match_dup 0)\n+\t\t (match_operand:SDI 2 \"u_short_cint_operand\" \"\")))]\n+  \"TARGET_P9_FUSION\"\n+  [(set (match_dup 0)\n+\t(unspec:SDI [(match_dup 1)\n+\t\t     (match_dup 2)] UNSPEC_FUSION_P9))])\n+\n+(define_peephole2\n+  [(set (match_operand:SDI 0 \"int_reg_operand\" \"\")\n+\t(match_operand:SDI 1 \"upper16_cint_operand\" \"\"))\n+   (set (match_operand:SDI 2 \"int_reg_operand\" \"\")\n+\t(ior:SDI (match_dup 0)\n+\t\t (match_operand:SDI 3 \"u_short_cint_operand\" \"\")))]\n+  \"TARGET_P9_FUSION\n+   && !rtx_equal_p (operands[0], operands[2])\n+   && peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 2)\n+\t(unspec:SDI [(match_dup 1)\n+\t\t     (match_dup 3)] UNSPEC_FUSION_P9))])\n+\n+;; Fusion insns, created by the define_peephole2 above (and eventually by\n+;; reload).  Because we want to eventually have secondary_reload generate\n+;; these, they have to have a single alternative that gives the register\n+;; classes.  This means we need to have separate gpr/fpr/altivec versions.\n+(define_insn \"fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load\"\n+  [(set (match_operand:GPR_FUSION 0 \"int_reg_operand\" \"=r\")\n+\t(unspec:GPR_FUSION\n+\t [(match_operand:GPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n+\t UNSPEC_FUSION_P9))\n+   (clobber (match_operand:P 2 \"base_reg_operand\" \"=&b\"))]\n+  \"TARGET_P9_FUSION\"\n+{\n+  /* This insn is a secondary reload insn, which cannot have alternatives.\n+     If we are not loading up register 0, use the power8 fusion instead.  */\n+  if (base_reg_operand (operands[0], <GPR_FUSION:MODE>mode))\n+    return emit_fusion_gpr_load (operands[0], operands[1]);\n+\n+  return emit_fusion_p9_load (operands[0], operands[1], operands[2]);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store\"\n+  [(set (match_operand:GPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n+\t(unspec:GPR_FUSION\n+\t [(match_operand:GPR_FUSION 1 \"int_reg_operand\" \"r\")]\n+\t UNSPEC_FUSION_P9))\n+   (clobber (match_operand:P 2 \"base_reg_operand\" \"=&b\"))]\n+  \"TARGET_P9_FUSION\"\n+{\n+  return emit_fusion_p9_store (operands[0], operands[1], operands[2]);\n+}\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"fusion_fpr_<P:mode>_<FPR_FUSION:mode>_load\"\n+  [(set (match_operand:FPR_FUSION 0 \"fpr_reg_operand\" \"=d\")\n+\t(unspec:FPR_FUSION\n+\t [(match_operand:FPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n+\t UNSPEC_FUSION_P9))\n+   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n+  \"TARGET_P9_FUSION\"\n+{\n+  return emit_fusion_p9_load (operands[0], operands[1], operands[2]);\n+}\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"fusion_fpr_<P:mode>_<FPR_FUSION:mode>_store\"\n+  [(set (match_operand:FPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n+\t(unspec:FPR_FUSION\n+\t [(match_operand:FPR_FUSION 1 \"fpr_reg_operand\" \"d\")]\n+\t UNSPEC_FUSION_P9))\n+   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n+  \"TARGET_P9_FUSION\"\n+{\n+  return emit_fusion_p9_store (operands[0], operands[1], operands[2]);\n+}\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"*fusion_p9_<mode>_constant\"\n+  [(set (match_operand:SDI 0 \"int_reg_operand\" \"=r\")\n+\t(unspec:SDI [(match_operand:SDI 1 \"upper16_cint_operand\" \"L\")\n+\t\t     (match_operand:SDI 2 \"u_short_cint_operand\" \"K\")]\n+\t\t    UNSPEC_FUSION_P9))]\t\n+  \"TARGET_P9_FUSION\"\n+{\n+  emit_fusion_addis (operands[0], operands[1], \"constant\", \"<MODE>\");\n+  return \"ori %0,%0,%2\";\n+}\n+  [(set_attr \"type\" \"two\")\n+   (set_attr \"length\" \"8\")])\n+\n \f\n ;; Miscellaneous ISA 2.06 (power7) instructions\n (define_insn \"addg6s\"\n@@ -12580,6 +12996,7 @@\n   \"xxpermdi %x0,%x1,%x2,0\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+\n \f\n \n (include \"sync.md\")"}, {"sha": "2875f15734fe5813721d096148df68d8d28f347f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -1,3 +1,39 @@\n+2015-11-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* lib/target-supports.exp (check_p8vector_hw_available): Split\n+\tlong line.\n+\t(check_vsx_hw_available): Likewise.\n+\t(check_p9vector_hw_available): Add new checks for ISA 3.0 hardware\n+\tsupport and for PowerPC float128 support.\n+\t(check_p9modulo_hw_available): Likewise.\n+\t(check_ppc_float128_sw_available): Likewise.\n+\t(check_ppc_float128_hw_available): Likewise.\n+\t(check_effective_target_powerpc_p9vector_ok): Likewise.\n+\t(check_effective_target_powerpc_p9modulo_ok): Likewise.\n+\t(check_effective_target_powerpc_float128_sw_ok): Likewise.\n+\t(check_effective_target_powerpc_float128_hw_ok): Likewise.\n+\t(is-effective-target): Add new PowerPc targets.\n+\t(is-effective-target-keyword): Likewise.\n+\t(check_vect_support_and_set_flags): If we have ISA 3.0 vector\n+\tinstructions, use it.\n+\n+\t* gcc.target/powerpc/mod-1.c: New test for ISA 3.0 instructions.\n+\t* gcc.target/powerpc/mod-2.c: Likewise.\n+\t* gcc.target/powerpc/ctz-1.c: Likewise.\n+\t* gcc.target/powerpc/ctz-2.c: Likewise.\n+\t* gcc.target/powerpc/extswsli-1.c: Likewise.\n+\t* gcc.target/powerpc/extswsli-2.c: Likewise.\n+\t* gcc.target/powerpc/extswsli-3.c: Likewise.\n+\n+\t* gcc.target/powerpc/fusion.c (fusion_vector): Move to fusion2.c\n+\tand allow the test on PowerPC LE.\n+\t* gcc.target/powerpc/fusion2.c (fusion_vector): Likewise.\n+\t* gcc.target/powerpc/fusion3.c: New file, test power9 fusion.\n+\n+\t* gcc.target/powerpc/float128-call.c: Use powerpc_float128_sw_ok\n+\tcheck instead of powerpc_vsx_ok.\n+\t* gcc.target/powerpc/float128-mix.c: Likewise.\n+\n 2015-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/sso/*.c: Robustify dg-output directives."}, {"sha": "9948ad7555b36c4cfe2eb30e10193bf80beb6f90", "filename": "gcc/testsuite/gcc.target/powerpc/ctz-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fctz-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fctz-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fctz-1.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+int i_trailing_zero (int a) { return __builtin_ctz (a); }\n+int l_trailing_zero (long a) { return __builtin_ctzl (a); }\n+int ll_trailing_zero (long long a) { return __builtin_ctzll (a); }\n+\n+/* { dg-final { scan-assembler     \"cnttzw \" } } */\n+/* { dg-final { scan-assembler     \"cnttzd \" } } */\n+/* { dg-final { scan-assembler-not \"cntlzw \" } } */\n+/* { dg-final { scan-assembler-not \"cntlzd \" } } */"}, {"sha": "7ee4d46195aa3780f1808bf69100ddfd0d454694", "filename": "gcc/testsuite/gcc.target/powerpc/ctz-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fctz-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fctz-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fctz-2.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+int i_trailing_zero (int a) { return __builtin_ctz (a); }\n+\n+/* { dg-final { scan-assembler     \"cnttzw \" } } */\n+/* { dg-final { scan-assembler-not \"cntlzw \" } } */"}, {"sha": "2d7aac331231c6fe017404e11f9a3ef77122efe1", "filename": "gcc/testsuite/gcc.target/powerpc/extswsli-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-1.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+static int mem;\n+int *ptr = &mem;\n+\n+long\n+add (long *p, int reg)\n+{\n+  __asm__ (\" #foo %0\" : \"+r\" (reg));\n+  return p[reg] + p[mem];\n+}\n+\n+/* { dg-final { scan-assembler-times \"extswsli \" 2 } } */\n+/* { dg-final { scan-assembler-times \"lwz \"      1 } } */\n+/* { dg-final { scan-assembler-not   \"lwa \"        } } */\n+/* { dg-final { scan-assembler-not   \"sldi \"       } } */\n+/* { dg-final { scan-assembler-not   \"extsw \"      } } */"}, {"sha": "b92a537b735d21383952c20cc42827042bd33cfa", "filename": "gcc/testsuite/gcc.target/powerpc/extswsli-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-2.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+long\n+func1 (int reg, int *is_zero)\n+{\n+  long value;\n+\n+  __asm__ (\" #foo %0\" : \"+r\" (reg));\n+  value = ((long)reg) << 4;\n+\n+  if (!value)\n+    *is_zero = 1;\n+\n+  return value;\n+}\n+\n+long\n+func2 (int *ptr, int *is_zero)\n+{\n+  int reg = *ptr;\n+  long value = ((long)reg) << 4;\n+\n+  if (!value)\n+    *is_zero = 1;\n+\n+  return value;\n+}\n+\n+/* { dg-final { scan-assembler     \"extswsli\\\\. \" } } */\n+/* { dg-final { scan-assembler     \"lwz \"         } } */\n+/* { dg-final { scan-assembler-not \"lwa \"         } } */\n+/* { dg-final { scan-assembler-not \"sldi \"        } } */\n+/* { dg-final { scan-assembler-not \"sldi\\\\. \"     } } */\n+/* { dg-final { scan-assembler-not \"extsw \"       } } */"}, {"sha": "d7e01e13bfefcee220555eef99b2d28472ff3376", "filename": "gcc/testsuite/gcc.target/powerpc/extswsli-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fextswsli-3.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+long\n+do_ext_add (int *p, long a, long b)\n+{\n+  long l = *p;\n+  long l2 = l << 4;\n+  return l2 + ((l2 == 0) ? a : b);\n+}\n+\n+long\n+do_ext (int *p, long a, long b)\n+{\n+  long l = *p;\n+  long l2 = l << 4;\n+  return ((l2 == 0) ? a : b);\n+}\n+\n+/* { dg-final { scan-assembler \"extswsli\\\\. \"} } */"}, {"sha": "bcb5d24e3795e61248cc664a174e876cb69b4374", "filename": "gcc/testsuite/gcc.target/powerpc/float128-call.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-call.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile { target { powerpc*-*-linux* } } } */\n-/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n-/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-require-effective-target powerpc_float128_sw_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n /* { dg-options \"-O2 -mcpu=power7 -mfloat128 -mno-regnames\" } */\n "}, {"sha": "23cb9d5f3a26d8d504ade0e0d5d9b247cf98c612", "filename": "gcc/testsuite/gcc.target/powerpc/float128-mix.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile { target { powerpc*-*-linux* } } } */\n-/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n-/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-require-effective-target powerpc_float128_sw_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n /* { dg-options \"-O2 -mcpu=power7 -mfloat128\" } */\n "}, {"sha": "ed35006f4d87330a780a2e05577e9943929e6926", "filename": "gcc/testsuite/gcc.target/powerpc/fusion.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile { target { powerpc*-*-* } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n-/* { dg-skip-if \"\" { powerpc*le-*-* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n /* { dg-options \"-mcpu=power7 -mtune=power8 -O3\" } */\n@@ -14,10 +13,7 @@ int fusion_short (short *p){ return p[LARGE]; }\n int fusion_int (int *p){ return p[LARGE]; }\n unsigned fusion_uns (unsigned *p){ return p[LARGE]; }\n \n-vector double fusion_vector (vector double *p) { return p[2]; }\n-\n /* { dg-final { scan-assembler-times \"gpr load fusion\"    6 } } */\n-/* { dg-final { scan-assembler-times \"vector load fusion\" 1 } } */\n /* { dg-final { scan-assembler-times \"lbz\"                2 } } */\n /* { dg-final { scan-assembler-times \"extsb\"              1 } } */\n /* { dg-final { scan-assembler-times \"lhz\"                2 } } */"}, {"sha": "bb74f882ea12ccec9cbe7e1616e813a7740aeddf", "filename": "gcc/testsuite/gcc.target/powerpc/fusion2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion2.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*le-*-* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -mtune=power8 -O3\" } */\n+\n+vector double fusion_vector (vector double *p) { return p[2]; }\n+\n+/* { dg-final { scan-assembler-times \"vector load fusion\" 1 } } */"}, {"sha": "8eca640d25747b0b8424326d1a8cfcad9aa7a34d", "filename": "gcc/testsuite/gcc.target/powerpc/fusion3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion3.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -mtune=power9 -O3\" } */\n+\n+#define LARGE 0x12345\n+\n+int fusion_float_read (float *p){ return p[LARGE]; }\n+int fusion_double_read (double *p){ return p[LARGE]; }\n+\n+void fusion_float_write (float *p, float f){ p[LARGE] = f; }\n+void fusion_double_write (double *p, double d){ p[LARGE] = d; }\n+\n+/* { dg-final { scan-assembler \"load fusion, type SF\"  } } */\n+/* { dg-final { scan-assembler \"load fusion, type DF\"  } } */\n+/* { dg-final { scan-assembler \"store fusion, type SF\" } } */\n+/* { dg-final { scan-assembler \"store fusion, type DF\" } } */"}, {"sha": "3954b09bdef53f571c6bd83fea146bb70f98fbc2", "filename": "gcc/testsuite/gcc.target/powerpc/mod-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmod-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmod-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmod-1.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+int ismod (int a, int b) { return a%b; }\n+long lsmod (long a, long b) { return a%b; }\n+unsigned int iumod (unsigned int a, unsigned int b) { return a%b; }\n+unsigned long lumod (unsigned long a, unsigned long b) { return a%b; }\n+\n+/* { dg-final { scan-assembler-times \"modsw \" 1 } } */\n+/* { dg-final { scan-assembler-times \"modsd \" 1 } } */\n+/* { dg-final { scan-assembler-times \"moduw \" 1 } } */\n+/* { dg-final { scan-assembler-times \"modud \" 1 } } */\n+/* { dg-final { scan-assembler-not   \"mullw \"   } } */\n+/* { dg-final { scan-assembler-not   \"mulld \"   } } */\n+/* { dg-final { scan-assembler-not   \"divw \"    } } */\n+/* { dg-final { scan-assembler-not   \"divd \"    } } */\n+/* { dg-final { scan-assembler-not   \"divwu \"   } } */\n+/* { dg-final { scan-assembler-not   \"divdu \"   } } */"}, {"sha": "7cf6a4f8aa28cc08b45caacf988ef3a5113a35c7", "filename": "gcc/testsuite/gcc.target/powerpc/mod-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmod-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmod-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmod-2.c?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+int ismod (int a, int b) { return a%b; }\n+unsigned int iumod (unsigned int a, unsigned int b) { return a%b; }\n+\n+/* { dg-final { scan-assembler-times \"modsw \" 1 } } */\n+/* { dg-final { scan-assembler-times \"moduw \" 1 } } */\n+/* { dg-final { scan-assembler-not   \"mullw \"   } } */\n+/* { dg-final { scan-assembler-not   \"divw \"    } } */\n+/* { dg-final { scan-assembler-not   \"divwu \"   } } */"}, {"sha": "75d506829221e3d02d454631c4bd2acd1a8cedf2", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 225, "deletions": 3, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0299bc726138914291b0a5b2120e5e7b4e5127be/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0299bc726138914291b0a5b2120e5e7b4e5127be", "patch": "@@ -1616,7 +1616,9 @@ proc check_p8vector_hw_available { } {\n     return [check_cached_effective_target p8vector_hw_available {\n \t# Some simulators are known to not support VSX/power8 instructions.\n \t# For now, disable on Darwin\n-\tif { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {\n+\tif { [istarget powerpc-*-eabi]\n+\t     || [istarget powerpc*-*-eabispe]\n+\t     || [istarget *-*-darwin*]} {\n \t    expr 0\n \t} else {\n \t    set options \"-mpower8-vector\"\n@@ -1635,14 +1637,122 @@ proc check_p8vector_hw_available { } {\n     }]\n }\n \n+# Return 1 if the target supports executing power9 vector instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_p9vector_hw_available { } {\n+    return [check_cached_effective_target p9vector_hw_available {\n+\t# Some simulators are known to not support VSX/power8/power9\n+\t# instructions.\tFor now, disable on Darwin.\n+\tif { [istarget powerpc-*-eabi]\n+\t     || [istarget powerpc*-*-eabispe]\n+\t     || [istarget *-*-darwin*]} {\n+\t    expr 0\n+\t} else {\n+\t    set options \"-mpower9-vector\"\n+\t    check_runtime_nocache p9vector_hw_available {\n+\t\tint main()\n+\t\t{\n+\t\t    long e = -1;\n+\t\t    vector double v = (vector double) { 0.0, 0.0 };\n+\t\t    asm (\"xsxexpdp %0,%1\" : \"+r\" (e) : \"wa\" (v));\n+\t\t    return e;\n+\t\t}\n+\t    } $options\n+\t}\n+    }]\n+}\n+\n+# Return 1 if the target supports executing power9 modulo instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_p9modulo_hw_available { } {\n+    return [check_cached_effective_target p9modulo_hw_available {\n+\t# Some simulators are known to not support VSX/power8/power9\n+\t# instructions.\tFor now, disable on Darwin.\n+\tif { [istarget powerpc-*-eabi]\n+\t     || [istarget powerpc*-*-eabispe]\n+\t     || [istarget *-*-darwin*]} {\n+\t    expr 0\n+\t} else {\n+\t    set options \"-mmodulo\"\n+\t    check_runtime_nocache p9modulo_hw_available {\n+\t\tint main()\n+\t\t{\n+\t\t    int i = 5, j = 3, r = -1;\n+\t\t    asm (\"modsw %0,%1,%2\" : \"+r\" (r) : \"r\" (i), \"r\" (j));\n+\t\t    return (r == 2);\n+\t\t}\n+\t    } $options\n+\t}\n+    }]\n+}\n+\n+# Return 1 if the target supports executing __float128 on PowerPC via software\n+# emulation, 0 otherwise.  Cache the result.\n+\n+proc check_ppc_float128_sw_available { } {\n+    return [check_cached_effective_target ppc_float128_sw_available {\n+\t# Some simulators are known to not support VSX/power8/power9\n+\t# instructions.\tFor now, disable on Darwin.\n+\tif { [istarget powerpc-*-eabi]\n+\t     || [istarget powerpc*-*-eabispe]\n+\t     || [istarget *-*-darwin*]} {\n+\t    expr 0\n+\t} else {\n+\t    set options \"-mfloat128 -mvsx\"\n+\t    check_runtime_nocache ppc_float128_sw_available {\n+\t\tvolatile __float128 x = 1.0q;\n+\t\tvolatile __float128 y = 2.0q;\n+\t\tint main()\n+\t\t{\n+\t\t    __float128 z = x + y;\n+\t\t    return (z == 3.0q);\n+\t\t}\n+\t    } $options\n+\t}\n+    }]\n+}\n+\n+# Return 1 if the target supports executing __float128 on PowerPC via power9\n+# hardware instructions, 0 otherwise.  Cache the result.\n+\n+proc check_ppc_float128_hw_available { } {\n+    return [check_cached_effective_target ppc_float128_hw_available {\n+\t# Some simulators are known to not support VSX/power8/power9\n+\t# instructions.\tFor now, disable on Darwin.\n+\tif { [istarget powerpc-*-eabi]\n+\t     || [istarget powerpc*-*-eabispe]\n+\t     || [istarget *-*-darwin*]} {\n+\t    expr 0\n+\t} else {\n+\t    set options \"-mfloat128-hardware\"\n+\t    check_runtime_nocache ppc_float128_hw_available {\n+\t\tvolatile __float128 x = 1.0q;\n+\t\tvolatile __float128 y = 2.0q;\n+\t\tint main()\n+\t\t{\n+\t\t    __float128 z = x + y;\n+\t\t    __float128 w = -1.0q;\n+\n+\t\t    __asm__ (\"xsaddqp %0,%1,%2\" : \"+v\" (w) : \"v\" (x), \"v\" (y));\n+\t\t    return ((z == 3.0q) && (z == w);\n+\t\t}\n+\t    } $options\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports executing VSX instructions, 0\n # otherwise.  Cache the result.\n \n proc check_vsx_hw_available { } {\n     return [check_cached_effective_target vsx_hw_available {\n \t# Some simulators are known to not support VSX instructions.\n \t# For now, disable on Darwin\n-\tif { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {\n+\tif { [istarget powerpc-*-eabi]\n+\t     || [istarget powerpc*-*-eabispe]\n+\t     || [istarget *-*-darwin*]} {\n \t    expr 0\n \t} else {\n \t    set options \"-mvsx\"\n@@ -3358,6 +3468,108 @@ proc check_effective_target_powerpc_p8vector_ok { } {\n     }\n }\n \n+# Return 1 if this is a PowerPC target supporting -mpower9-vector\n+\n+proc check_effective_target_powerpc_p9vector_ok { } {\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget rs6000-*-*] } {\n+\t# AltiVec is not supported on AIX before 5.3.\n+\tif { [istarget powerpc*-*-aix4*]\n+\t     || [istarget powerpc*-*-aix5.1*] \n+\t     || [istarget powerpc*-*-aix5.2*] } {\n+\t    return 0\n+\t}\n+\treturn [check_no_compiler_messages powerpc_p9vector_ok object {\n+\t    int main (void) {\n+\t\tlong e = -1;\n+\t\tvector double v = (vector double) { 0.0, 0.0 };\n+\t\tasm (\"xsxexpdp %0,%1\" : \"+r\" (e) : \"wa\" (v));\n+\t\treturn e;\n+\t    }\n+\t} \"-mpower9-vector\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n+# Return 1 if this is a PowerPC target supporting -mmodulo\n+\n+proc check_effective_target_powerpc_p9modulo_ok { } {\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget rs6000-*-*] } {\n+\t# AltiVec is not supported on AIX before 5.3.\n+\tif { [istarget powerpc*-*-aix4*]\n+\t     || [istarget powerpc*-*-aix5.1*] \n+\t     || [istarget powerpc*-*-aix5.2*] } {\n+\t    return 0\n+\t}\n+\treturn [check_no_compiler_messages powerpc_p9modulo_ok object {\n+\t    int main (void) {\n+\t\tint i = 5, j = 3, r = -1;\n+\t\tasm (\"modsw %0,%1,%2\" : \"+r\" (r) : \"r\" (i), \"r\" (j));\n+\t\treturn (r == 2);\n+\t    }\n+\t} \"-mmodulo\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n+# Return 1 if this is a PowerPC target supporting -mfloat128 via either\n+# software emulation on power7/power8 systems or hardware support on power9.\n+\n+proc check_effective_target_powerpc_float128_sw_ok { } {\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget rs6000-*-*] } {\n+\t# AltiVec is not supported on AIX before 5.3.\n+\tif { [istarget powerpc*-*-aix4*]\n+\t     || [istarget powerpc*-*-aix5.1*] \n+\t     || [istarget powerpc*-*-aix5.2*] } {\n+\t    return 0\n+\t}\n+\treturn [check_no_compiler_messages powerpc_float128_sw_ok object {\n+\t\tvolatile __float128 x = 1.0q;\n+\t\tvolatile __float128 y = 2.0q;\n+\t\tint main() {\n+\t\t    __float128 z = x + y;\n+\t\t    return (z == 3.0q);\n+\t\t}\n+\t    } \"-mfloat128 -mvsx\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n+# Return 1 if this is a PowerPC target supporting -mfloat128 via hardware\n+# support on power9.\n+\n+proc check_effective_target_powerpc_float128_hw_ok { } {\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget rs6000-*-*] } {\n+\t# AltiVec is not supported on AIX before 5.3.\n+\tif { [istarget powerpc*-*-aix4*]\n+\t     || [istarget powerpc*-*-aix5.1*] \n+\t     || [istarget powerpc*-*-aix5.2*] } {\n+\t    return 0\n+\t}\n+\treturn [check_no_compiler_messages powerpc_float128_hw_ok object {\n+\t\tvolatile __float128 x = 1.0q;\n+\t\tvolatile __float128 y = 2.0q;\n+\t\tint main() {\n+\t\t    __float128 z;\n+\t\t    __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (z) : \"v\" (x), \"v\" (y));\n+\t\t    return (z == 3.0q);\n+\t\t}\n+\t} \"-mfloat128-hardware\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n # Return 1 if this is a PowerPC target supporting -mvsx\n \n proc check_effective_target_powerpc_vsx_ok { } {\n@@ -5459,6 +5671,10 @@ proc is-effective-target { arg } {\n \t  \"vmx_hw\"         { set selected [check_vmx_hw_available] }\n \t  \"vsx_hw\"         { set selected [check_vsx_hw_available] }\n \t  \"p8vector_hw\"    { set selected [check_p8vector_hw_available] }\n+\t  \"p9vector_hw\"    { set selected [check_p9vector_hw_available] }\n+\t  \"p9modulo_hw\"    { set selected [check_p9modulo_hw_available] }\n+\t  \"ppc_float128_sw\" { set selected [check_ppc_float128_sw_available] }\n+\t  \"ppc_float128_hw\" { set selected [check_ppc_float128_hw_available] }\n \t  \"ppc_recip_hw\"   { set selected [check_ppc_recip_hw_available] }\n \t  \"dfp_hw\"         { set selected [check_dfp_hw_available] }\n \t  \"htm_hw\"         { set selected [check_htm_hw_available] }\n@@ -5483,6 +5699,10 @@ proc is-effective-target-keyword { arg } {\n \t  \"vmx_hw\"         { return 1 }\n \t  \"vsx_hw\"         { return 1 }\n \t  \"p8vector_hw\"    { return 1 }\n+\t  \"p9vector_hw\"    { return 1 }\n+\t  \"p9modulo_hw\"    { return 1 }\n+\t  \"ppc_float128_sw\" { return 1 }\n+\t  \"ppc_float128_hw\" { return 1 }\n \t  \"ppc_recip_hw\"   { return 1 }\n \t  \"dfp_hw\"         { return 1 }\n \t  \"htm_hw\"         { return 1 }\n@@ -6186,7 +6406,9 @@ proc check_vect_support_and_set_flags { } {\n         }\n \n         lappend DEFAULT_VECTCFLAGS \"-maltivec\"\n-        if [check_p8vector_hw_available] {\n+        if [check_p9vector_hw_available] {\n+            lappend DEFAULT_VECTCFLAGS \"-mpower9-vector\"\n+        } elseif [check_p8vector_hw_available] {\n             lappend DEFAULT_VECTCFLAGS \"-mpower8-vector\"\n         } elseif [check_vsx_hw_available] {\n             lappend DEFAULT_VECTCFLAGS \"-mvsx\" \"-mno-allow-movmisalign\""}]}