{"sha": "ebb5de23436436d4206766552e76cd4b802e0c74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiNWRlMjM0MzY0MzZkNDIwNjc2NjU1MmU3NmNkNGI4MDJlMGM3NA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-11T13:42:07Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-13T09:54:32Z"}, "message": "Add in ContinueExpr support\n\nWe made an implicit loop begin label that can be referenced in a goto to\nrestart the loop.\n\nFixes #188", "tree": {"sha": "fa7cf962d5c796e4a1c5e2dc72b6cf6345414671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa7cf962d5c796e4a1c5e2dc72b6cf6345414671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb5de23436436d4206766552e76cd4b802e0c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb5de23436436d4206766552e76cd4b802e0c74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb5de23436436d4206766552e76cd4b802e0c74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb5de23436436d4206766552e76cd4b802e0c74/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7366f6decf5ff3c652844913977582c9dec68d53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7366f6decf5ff3c652844913977582c9dec68d53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7366f6decf5ff3c652844913977582c9dec68d53"}], "stats": {"total": 420, "additions": 335, "deletions": 85}, "files": [{"sha": "a7e7f1d751527ddbde267be82642d8e276c01005", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 176, "deletions": 78, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -46,14 +46,14 @@ class LiteralExpr : public ExprWithoutBlock\n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n \n   LiteralExpr (std::string value_as_string, Literal::LitType type,\n-\t       PrimitiveCoreType type_hint,\n-\t       std::vector<Attribute> outer_attrs, Location locus)\n+\t       PrimitiveCoreType type_hint, std::vector<Attribute> outer_attrs,\n+\t       Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n       literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n-  LiteralExpr (Literal literal,\n-\t       std::vector<Attribute> outer_attrs, Location locus)\n+  LiteralExpr (Literal literal, std::vector<Attribute> outer_attrs,\n+\t       Location locus)\n     : outer_attrs (std::move (outer_attrs)), literal (std::move (literal)),\n       locus (locus)\n   {}\n@@ -78,7 +78,10 @@ class LiteralExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -252,7 +255,10 @@ class OperatorExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n };\n \n /* Unary prefix & or &mut (or && and &&mut) borrow operator. Cannot be\n@@ -880,7 +886,10 @@ class GroupedExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n   GroupedExpr (std::unique_ptr<Expr> parenthesised_expr,\n \t       std::vector<Attribute> inner_attribs,\n@@ -892,8 +901,8 @@ class GroupedExpr : public ExprWithoutBlock\n \n   // Copy constructor includes clone for expr_in_parens\n   GroupedExpr (GroupedExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr_in_parens != nullptr)\n@@ -1120,7 +1129,10 @@ class ArrayExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n   // Returns whether array expr has array elems or if it is just empty.\n   bool has_array_elems () const { return internal_elements != nullptr; }\n@@ -1136,8 +1148,9 @@ class ArrayExpr : public ExprWithoutBlock\n \n   // Copy constructor requires cloning ArrayElems for polymorphism to hold\n   ArrayExpr (ArrayExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n-      locus (other.locus), marked_for_strip (other.marked_for_strip)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      inner_attrs (other.inner_attrs), locus (other.locus),\n+      marked_for_strip (other.marked_for_strip)\n   {\n     if (other.has_array_elems ())\n       internal_elements = other.internal_elements->clone_array_elems ();\n@@ -1214,7 +1227,8 @@ class ArrayIndexExpr : public ExprWithoutBlock\n \n   // Copy constructor requires special cloning due to unique_ptr\n   ArrayIndexExpr (ArrayIndexExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.array_expr != nullptr)\n@@ -1280,7 +1294,10 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -1311,7 +1328,10 @@ class TupleExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n   TupleExpr (std::vector<std::unique_ptr<Expr> > tuple_elements,\n \t     std::vector<Attribute> inner_attribs,\n@@ -1323,8 +1343,9 @@ class TupleExpr : public ExprWithoutBlock\n \n   // copy constructor with vector clone\n   TupleExpr (TupleExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n-      locus (other.locus), marked_for_strip (other.marked_for_strip)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      inner_attrs (other.inner_attrs), locus (other.locus),\n+      marked_for_strip (other.marked_for_strip)\n   {\n     tuple_elems.reserve (other.tuple_elems.size ());\n     for (const auto &e : other.tuple_elems)\n@@ -1410,8 +1431,8 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   // Copy constructor requires a clone for tuple_expr\n   TupleIndexExpr (TupleIndexExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), tuple_index (other.tuple_index),\n-      locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      tuple_index (other.tuple_index), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.tuple_expr != nullptr)\n@@ -1458,7 +1479,10 @@ class TupleIndexExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -1499,7 +1523,10 @@ class StructExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n };\n \n // Actual AST node of the struct creator (with no fields). Not abstract!\n@@ -2010,7 +2037,10 @@ class EnumVariantExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n };\n \n /* Base AST node for a single enum expression field (in enum instance creation)\n@@ -2350,7 +2380,8 @@ class CallExpr : public ExprWithoutBlock\n \n   // copy constructor requires clone\n   CallExpr (CallExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.function != nullptr)\n@@ -2423,7 +2454,10 @@ class CallExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -2458,8 +2492,8 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   // copy constructor required due to cloning\n   MethodCallExpr (MethodCallExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), method_name (other.method_name),\n-      locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      method_name (other.method_name), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2533,7 +2567,10 @@ class MethodCallExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -2566,7 +2603,8 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   // Copy constructor required due to unique_ptr cloning\n   FieldAccessExpr (FieldAccessExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), field (other.field), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      field (other.field), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2615,7 +2653,10 @@ class FieldAccessExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -2740,7 +2781,10 @@ class ClosureExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n };\n \n // Represents a non-type-specified closure expression AST node\n@@ -2822,7 +2866,7 @@ class BlockExpr : public ExprWithBlock\n   std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n   std::vector<std::unique_ptr<Stmt> > statements;\n-  std::unique_ptr<ExprWithoutBlock> expr; \n+  std::unique_ptr<ExprWithoutBlock> expr;\n   Location locus;\n   bool marked_for_strip = false;\n \n@@ -2847,8 +2891,9 @@ class BlockExpr : public ExprWithBlock\n \n   // Copy constructor with clone\n   BlockExpr (BlockExpr const &other)\n-    : ExprWithBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n-      locus (other.locus), marked_for_strip (other.marked_for_strip)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      inner_attrs (other.inner_attrs), locus (other.locus),\n+      marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n     if (other.expr != nullptr)\n@@ -2934,7 +2979,10 @@ class BlockExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -3059,8 +3107,8 @@ class ContinueExpr : public ExprWithoutBlock\n   bool has_label () const { return !label.is_error (); }\n \n   // Constructor for a ContinueExpr with a label.\n-  ContinueExpr (Lifetime label,\n-\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+  ContinueExpr (Lifetime label, std::vector<Attribute> outer_attribs,\n+\t\tLocation locus)\n     : outer_attrs (std::move (outer_attribs)), label (std::move (label)),\n       locus (locus)\n   {}\n@@ -3077,7 +3125,12 @@ class ContinueExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n+  Lifetime &get_label () { return label; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -3111,17 +3164,16 @@ class BreakExpr : public ExprWithoutBlock\n   bool has_break_expr () const { return break_expr != nullptr; }\n \n   // Constructor for a break expression\n-  BreakExpr (Lifetime break_label,\n-\t     std::unique_ptr<Expr> expr_in_break,\n+  BreakExpr (Lifetime break_label, std::unique_ptr<Expr> expr_in_break,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : outer_attrs (std::move (outer_attribs)),\n-      label (std::move (break_label)), break_expr (std::move (expr_in_break)),\n-      locus (locus)\n+    : outer_attrs (std::move (outer_attribs)), label (std::move (break_label)),\n+      break_expr (std::move (expr_in_break)), locus (locus)\n   {}\n \n   // Copy constructor defined to use clone for unique pointer\n   BreakExpr (BreakExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), label (other.label), locus (other.locus),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      label (other.label), locus (other.locus),\n       marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -3170,8 +3222,11 @@ class BreakExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n-  \n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n   Lifetime &get_label () { return label; }\n \n protected:\n@@ -3197,7 +3252,10 @@ class RangeExpr : public ExprWithoutBlock\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   // should never be called - error if called\n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { rust_assert (false); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    rust_assert (false);\n+  }\n };\n \n // Range from (inclusive) and to (exclusive) expression AST node object\n@@ -3608,8 +3666,8 @@ class ReturnExpr : public ExprWithoutBlock\n \n   // Copy constructor with clone\n   ReturnExpr (ReturnExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus),\n-      marked_for_strip (other.marked_for_strip)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n     if (other.return_expr != nullptr)\n@@ -3656,7 +3714,10 @@ class ReturnExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -3689,7 +3750,8 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   // Copy constructor with clone\n   UnsafeBlockExpr (UnsafeBlockExpr const &other)\n-    : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -3735,7 +3797,10 @@ class UnsafeBlockExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -3801,7 +3866,8 @@ class BaseLoopExpr : public ExprWithBlock\n \n   // Copy constructor for BaseLoopExpr with clone\n   BaseLoopExpr (BaseLoopExpr const &other)\n-    : ExprWithBlock (other), outer_attrs (other.outer_attrs), loop_label (other.loop_label), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      loop_label (other.loop_label), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.loop_block != nullptr)\n@@ -3851,7 +3917,10 @@ class BaseLoopExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n };\n \n // 'Loop' expression (i.e. the infinite loop) AST node\n@@ -4105,13 +4174,15 @@ class IfExpr : public ExprWithBlock\n \n   IfExpr (std::unique_ptr<Expr> condition, std::unique_ptr<BlockExpr> if_block,\n \t  std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), condition (std::move (condition)), if_block (std::move (if_block)),\n-      locus (locus)\n+    : outer_attrs (std::move (outer_attrs)), condition (std::move (condition)),\n+      if_block (std::move (if_block)), locus (locus)\n   {}\n   // outer attributes are never allowed on IfExprs\n \n   // Copy constructor with clone\n-  IfExpr (IfExpr const &other) : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n+  IfExpr (IfExpr const &other)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.condition != nullptr)\n@@ -4187,7 +4258,10 @@ class IfExpr : public ExprWithBlock\n     return if_block == nullptr && condition == nullptr;\n   }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n@@ -4215,8 +4289,10 @@ class IfExprConseqElse : public IfExpr\n \n   IfExprConseqElse (std::unique_ptr<Expr> condition,\n \t\t    std::unique_ptr<BlockExpr> if_block,\n-\t\t    std::unique_ptr<BlockExpr> else_block, std::vector<Attribute> outer_attrs, Location locus)\n-    : IfExpr (std::move (condition), std::move (if_block), std::move (outer_attrs), locus),\n+\t\t    std::unique_ptr<BlockExpr> else_block,\n+\t\t    std::vector<Attribute> outer_attrs, Location locus)\n+    : IfExpr (std::move (condition), std::move (if_block),\n+\t      std::move (outer_attrs), locus),\n       else_block (std::move (else_block))\n   {}\n   // again, outer attributes not allowed\n@@ -4271,8 +4347,10 @@ class IfExprConseqIf : public IfExpr\n \n   IfExprConseqIf (std::unique_ptr<Expr> condition,\n \t\t  std::unique_ptr<BlockExpr> if_block,\n-\t\t  std::unique_ptr<IfExpr> conseq_if_expr, std::vector<Attribute> outer_attrs, Location locus)\n-    : IfExpr (std::move (condition), std::move (if_block), std::move (outer_attrs), locus),\n+\t\t  std::unique_ptr<IfExpr> conseq_if_expr,\n+\t\t  std::vector<Attribute> outer_attrs, Location locus)\n+    : IfExpr (std::move (condition), std::move (if_block),\n+\t      std::move (outer_attrs), locus),\n       conseq_if_expr (std::move (conseq_if_expr))\n   {}\n   // outer attributes not allowed\n@@ -4333,16 +4411,17 @@ class IfLetExpr : public ExprWithBlock\n   std::string as_string () const override;\n \n   IfLetExpr (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n-\t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block, std::vector<Attribute> outer_attrs,\n-\t     Location locus)\n+\t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n+\t     std::vector<Attribute> outer_attrs, Location locus)\n     : match_arm_patterns (std::move (match_arm_patterns)),\n       value (std::move (value)), if_block (std::move (if_block)), locus (locus)\n   {}\n   // outer attributes not allowed on if let exprs either\n \n   // copy constructor with clone\n   IfLetExpr (IfLetExpr const &other)\n-    : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.value != nullptr)\n@@ -4429,7 +4508,10 @@ class IfLetExpr : public ExprWithBlock\n     return match_arm_patterns;\n   }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n@@ -4460,9 +4542,10 @@ class IfExprConseqIfLet : public IfExpr\n \n   IfExprConseqIfLet (std::unique_ptr<Expr> condition,\n \t\t     std::unique_ptr<BlockExpr> if_block,\n-\t\t     std::unique_ptr<IfLetExpr> conseq_if_let_expr, std::vector<Attribute> outer_attrs,\n-\t\t     Location locus)\n-    : IfExpr (std::move (condition), std::move (if_block), std::move (outer_attrs), locus),\n+\t\t     std::unique_ptr<IfLetExpr> conseq_if_let_expr,\n+\t\t     std::vector<Attribute> outer_attrs, Location locus)\n+    : IfExpr (std::move (condition), std::move (if_block),\n+\t      std::move (outer_attrs), locus),\n       if_let_expr (std::move (conseq_if_let_expr))\n   {}\n   // outer attributes not allowed\n@@ -4517,7 +4600,8 @@ class IfLetExprConseqElse : public IfLetExpr\n   IfLetExprConseqElse (\n     std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n-    std::unique_ptr<BlockExpr> else_block, std::vector<Attribute> outer_attrs, Location locus)\n+    std::unique_ptr<BlockExpr> else_block, std::vector<Attribute> outer_attrs,\n+    Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n \t\t std::move (if_block), std::move (outer_attrs), locus),\n       else_block (std::move (else_block))\n@@ -4576,7 +4660,8 @@ class IfLetExprConseqIf : public IfLetExpr\n   IfLetExprConseqIf (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t\t     std::unique_ptr<Expr> value,\n \t\t     std::unique_ptr<BlockExpr> if_block,\n-\t\t     std::unique_ptr<IfExpr> if_expr, std::vector<Attribute> outer_attrs, Location locus)\n+\t\t     std::unique_ptr<IfExpr> if_expr,\n+\t\t     std::vector<Attribute> outer_attrs, Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n \t\t std::move (if_block), std::move (outer_attrs), locus),\n       if_expr (std::move (if_expr))\n@@ -4634,7 +4719,8 @@ class IfLetExprConseqIfLet : public IfLetExpr\n   IfLetExprConseqIfLet (\n     std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n-    std::unique_ptr<IfLetExpr> if_let_expr, std::vector<Attribute> outer_attrs, Location locus)\n+    std::unique_ptr<IfLetExpr> if_let_expr, std::vector<Attribute> outer_attrs,\n+    Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n \t\t std::move (if_block), std::move (outer_attrs), locus),\n       if_let_expr (std::move (if_let_expr))\n@@ -4970,8 +5056,9 @@ class MatchExpr : public ExprWithBlock\n \n   // Copy constructor requires clone due to unique_ptr\n   MatchExpr (MatchExpr const &other)\n-    : ExprWithBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n-      match_arms (other.match_arms), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      inner_attrs (other.inner_attrs), match_arms (other.match_arms),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.branch_value != nullptr)\n@@ -5016,7 +5103,10 @@ class MatchExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_scrutinee_expr ()\n@@ -5054,7 +5144,8 @@ class AwaitExpr : public ExprWithoutBlock\n \n   // copy constructor with clone\n   AwaitExpr (AwaitExpr const &other)\n-    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.awaited_expr != nullptr)\n@@ -5102,7 +5193,10 @@ class AwaitExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -5131,7 +5225,8 @@ class AsyncBlockExpr : public ExprWithBlock\n \n   // copy constructor with clone\n   AsyncBlockExpr (AsyncBlockExpr const &other)\n-    : ExprWithBlock (other), outer_attrs (other.outer_attrs), has_move (other.has_move), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs),\n+      has_move (other.has_move), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.block_expr != nullptr)\n@@ -5180,7 +5275,10 @@ class AsyncBlockExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather"}, {"sha": "76255b065c5e7ac228c441ba7c9c595905d29819", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -219,6 +219,20 @@ class Context\n     return back;\n   }\n \n+  void push_loop_begin_label (Blabel *label)\n+  {\n+    loop_begin_labels.push_back (label);\n+  }\n+\n+  Blabel *peek_loop_begin_label () { return loop_begin_labels.back (); }\n+\n+  Blabel *pop_loop_begin_label ()\n+  {\n+    Blabel *pop = loop_begin_labels.back ();\n+    loop_begin_labels.pop_back ();\n+    return pop;\n+  }\n+\n private:\n   ::Backend *backend;\n   Resolver::Resolver *resolver;\n@@ -235,6 +249,7 @@ class Context\n   std::vector< ::std::vector<Bstatement *> > statements;\n   std::vector< ::Bblock *> scope_stack;\n   std::vector< ::Bvariable *> loop_value_stack;\n+  std::vector< ::Blabel *> loop_begin_labels;\n \n   // To GCC middle-end\n   std::vector< ::Btype *> type_decls;"}, {"sha": "1e4aef6b9f86860ba92f34aae9d85fe590527468", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -625,6 +625,13 @@ class CompileExpr : public HIRCompileBase\n \t  loop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n       }\n \n+    Blabel *loop_begin_label\n+      = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n+    Bstatement *loop_begin_label_decl\n+      = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n+    ctx->add_statement (loop_begin_label_decl);\n+    ctx->push_loop_begin_label (loop_begin_label);\n+\n     Bblock *code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n     Bexpression *loop_expr\n@@ -639,6 +646,7 @@ class CompileExpr : public HIRCompileBase\n \ttranslated\n \t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n       }\n+    ctx->pop_loop_begin_label ();\n   }\n \n   void visit (HIR::WhileLoopExpr &expr)\n@@ -668,6 +676,13 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (loop_block);\n \n+    Blabel *loop_begin_label\n+      = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n+    Bstatement *loop_begin_label_decl\n+      = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n+    ctx->add_statement (loop_begin_label_decl);\n+    ctx->push_loop_begin_label (loop_begin_label);\n+\n     Bexpression *condition\n       = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n     Bexpression *exit_expr\n@@ -682,6 +697,7 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (code_block_stmt);\n \n+    ctx->pop_loop_begin_label ();\n     ctx->pop_block ();\n \n     Bexpression *loop_expr\n@@ -754,6 +770,45 @@ class CompileExpr : public HIRCompileBase\n       }\n   }\n \n+  void visit (HIR::ContinueExpr &expr)\n+  {\n+    Blabel *label = ctx->peek_loop_begin_label ();\n+    if (expr.has_label ())\n+      {\n+\tNodeId resolved_node_id = UNKNOWN_NODEID;\n+\tif (!ctx->get_resolver ()->lookup_resolved_label (\n+\t      expr.get_label ().get_mappings ().get_nodeid (),\n+\t      &resolved_node_id))\n+\t  {\n+\t    rust_error_at (\n+\t      expr.get_label ().get_locus (),\n+\t      \"failed to resolve compiled label for label %s\",\n+\t      expr.get_label ().get_mappings ().as_string ().c_str ());\n+\t    return;\n+\t  }\n+\n+\tHirId ref = UNKNOWN_HIRID;\n+\tif (!ctx->get_mappings ()->lookup_node_to_hir (\n+\t      expr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+\t  {\n+\t    rust_fatal_error (expr.get_locus (),\n+\t\t\t      \"reverse lookup label failure\");\n+\t    return;\n+\t  }\n+\n+\tif (!ctx->lookup_label_decl (ref, &label))\n+\t  {\n+\t    rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t   \"failed to lookup compiled label\");\n+\t    return;\n+\t  }\n+      }\n+\n+    Bstatement *goto_label\n+      = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n+    ctx->add_statement (goto_label);\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n "}, {"sha": "add969ab4996f344eee32f8b59050a91b55db867", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -66,10 +66,6 @@ class CompileStmt : public HIRCompileBase\n \treturn;\n       }\n \n-    // there is an ICE in GCC for void_node\n-    if (ty->get_kind () == TyTy::TypeKind::UNIT)\n-      return;\n-\n     Bvariable *var = nullptr;\n     if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n       {\n@@ -79,10 +75,21 @@ class CompileStmt : public HIRCompileBase\n       }\n \n     Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    if (init == nullptr)\n+      return;\n \n     auto fnctx = ctx->peek_fn ();\n-    auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n-    ctx->add_statement (s);\n+    if (ty->get_kind () == TyTy::TypeKind::UNIT)\n+      {\n+\tBstatement *expr_stmt\n+\t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, init);\n+\tctx->add_statement (expr_stmt);\n+      }\n+    else\n+      {\n+\tauto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n+\tctx->add_statement (s);\n+      }\n   }\n \n private:"}, {"sha": "6921e6d0effc250f0c560ef151d9911630d5c603", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -725,6 +725,21 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t     std::move (outer_attribs));\n   }\n \n+  void visit (AST::ContinueExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+    HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::ContinueExpr (mapping, expr.get_locus (),\n+\t\t\t\t\tstd ::move (break_label),\n+\t\t\t\t\tstd::move (outer_attribs));\n+  }\n+\n private:\n   ASTLoweringExpr ()\n     : ASTLoweringBase (), translated (nullptr),"}, {"sha": "95ba7f867e0f8dc030559701bebddef2c8626b20", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -2724,6 +2724,8 @@ class ContinueExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Lifetime &get_label () { return label; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "d7bd6abc846f3531fe32e2c614e429b42de01cd1", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -327,6 +327,30 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_loop_block ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::ContinueExpr &expr)\n+  {\n+    if (expr.has_label ())\n+      {\n+\tauto label = expr.get_label ();\n+\tif (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t  {\n+\t    rust_error_at (label.get_locus (),\n+\t\t\t   \"Labels must be a named lifetime value\");\n+\t    return;\n+\t  }\n+\n+\tNodeId resolved_node = UNKNOWN_NODEID;\n+\tif (!resolver->get_label_scope ().lookup (label.get_lifetime_name (),\n+\t\t\t\t\t\t  &resolved_node))\n+\t  {\n+\t    rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t   \"failed to resolve label\");\n+\t    return;\n+\t  }\n+\tresolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+      }\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "f8497db493d56ab1f0fd72d79114e9860f845e58", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -823,6 +823,18 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n   }\n \n+  void visit (HIR::ContinueExpr &expr)\n+  {\n+    if (!inside_loop)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"cannot `continue` outside of a loop\");\n+\treturn;\n+      }\n+\n+    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+  }\n+\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),"}, {"sha": "7f9bc699bd9ed73754557a87346d8510b1c329e8", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -127,7 +127,7 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     else if (resolved->get_kind () != TyTy::TypeKind::UNIT)\n       {\n \trust_error_at (s->get_locus_slow (), \"expected () got %s\",\n-\t\t       infered->as_string ().c_str ());\n+\t\t       resolved->as_string ().c_str ());\n       }\n \n     return true;"}, {"sha": "0cd844592b64d01f0dda16b0f4712e1225670812", "filename": "gcc/testsuite/rust.test/compilable/loop7.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop7.rs?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 1;\n+\n+    let _fib = loop {\n+        if (a % 2 == 0) {\n+            continue;\n+        }\n+        let c = a + b;\n+        a = b;\n+        b = c;\n+    };\n+}"}, {"sha": "2ec25a4b4a2b5d0b9c325e4f7c42aea61a6231f8", "filename": "gcc/testsuite/rust.test/fail_compilation/continue1.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fcontinue1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb5de23436436d4206766552e76cd4b802e0c74/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fcontinue1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fcontinue1.rs?ref=ebb5de23436436d4206766552e76cd4b802e0c74", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 1;\n+\n+    let _fib = {\n+        continue;\n+        123\n+    };\n+}"}]}