{"sha": "7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y1Nzg0M2ZiZWJjN2I1MGNmYWQ3Y2M1YmQzNDU5YTJkMTA3NzAzNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-08T05:30:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-08T05:30:12Z"}, "message": "runtime: System-specific hack fix for x86_64 Solaris 10.\n\nFixes problem in which setcontext changes all thread-specific\ninformation.\n\nFrom-SVN: r183993", "tree": {"sha": "c2a0810ed549d7918e5361e32b62c078b9961ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2a0810ed549d7918e5361e32b62c078b9961ff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/comments", "author": null, "committer": null, "parents": [{"sha": "3327318150635df73331b0ebdd7b7bc2628b3b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3327318150635df73331b0ebdd7b7bc2628b3b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3327318150635df73331b0ebdd7b7bc2628b3b21"}], "stats": {"total": 237, "additions": 237, "deletions": 0}, "files": [{"sha": "bd19873819c0a7fc673fc144f6ad2d2592e357f3", "filename": "libgo/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "patch": "@@ -189,6 +189,9 @@\n /* Define to the version of this package. */\n #undef PACKAGE_VERSION\n \n+/* Define if setcontext clobbers TLS variables */\n+#undef SETCONTEXT_CLOBBERS_TLS\n+\n /* Define to 1 if you have the ANSI C header files. */\n #undef STDC_HEADERS\n "}, {"sha": "9b65c2519a2f766115f1e7486341c6e911de67d1", "filename": "libgo/configure", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "patch": "@@ -14756,6 +14756,104 @@ $as_echo \"$libgo_cv_c_epoll_event_fd_offset\" >&6; }\n STRUCT_EPOLL_EVENT_FD_OFFSET=${libgo_cv_c_epoll_event_fd_offset}\n \n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether setcontext clobbers TLS variables\" >&5\n+$as_echo_n \"checking whether setcontext clobbers TLS variables... \" >&6; }\n+if test \"${libgo_cv_lib_setcontext_clobbers_tls+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  LIBS_hold=\"$LIBS\"\n+LIBS=\"$LIBS $PTHREAD_LIBS\"\n+if test \"$cross_compiling\" = yes; then :\n+  case \"$target\" in\n+  x86_64*-*-solaris2.10) libgo_cv_lib_setcontext_clobbers_tls=yes ;;\n+  *) libgo_cv_lib_setcontext_clobbers_tls=no ;;\n+ esac\n+\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <ucontext.h>\n+#include <unistd.h>\n+\n+__thread int tls;\n+\n+static char stack[10 * 1024 * 1024];\n+static ucontext_t c;\n+\n+/* Called via makecontext/setcontext.  */\n+\n+static void\n+cfn (void)\n+{\n+  exit (tls);\n+}\n+\n+/* Called via pthread_create.  */\n+\n+static void *\n+tfn (void *dummy)\n+{\n+  /* The thread should still see this value after calling\n+     setcontext.  */\n+  tls = 0;\n+\n+  setcontext (&c);\n+\n+  /* The call to setcontext should not return.  */\n+  abort ();\n+}\n+\n+int\n+main ()\n+{\n+  pthread_t tid;\n+\n+  /* The thread should not see this value.  */\n+  tls = 1;\n+\n+  if (getcontext (&c) < 0)\n+    abort ();\n+\n+  c.uc_stack.ss_sp = stack;\n+  c.uc_stack.ss_flags = 0;\n+  c.uc_stack.ss_size = sizeof stack;\n+  c.uc_link = NULL;\n+  makecontext (&c, cfn, 0);\n+\n+  if (pthread_create (&tid, NULL, tfn, NULL) != 0)\n+    abort ();\n+\n+  if (pthread_join (tid, NULL) != 0)\n+    abort ();\n+\n+  /* The thread should have called exit.  */\n+  abort ();\n+}\n+\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  libgo_cv_lib_setcontext_clobbers_tls=no\n+else\n+  libgo_cv_lib_setcontext_clobbers_tls=yes\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+LIBS=\"$LIBS_hold\"\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_lib_setcontext_clobbers_tls\" >&5\n+$as_echo \"$libgo_cv_lib_setcontext_clobbers_tls\" >&6; }\n+if test \"$libgo_cv_lib_setcontext_clobbers_tls\" = \"yes\"; then\n+\n+$as_echo \"#define SETCONTEXT_CLOBBERS_TLS 1\" >>confdefs.h\n+\n+fi\n+\n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n # tests run on this system so they can be shared between configure"}, {"sha": "3de5b4a2c8b3db1ec8782fca80869fa79af48ee7", "filename": "libgo/configure.ac", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "patch": "@@ -549,6 +549,87 @@ AC_CACHE_CHECK([epoll_event data.fd offset],\n STRUCT_EPOLL_EVENT_FD_OFFSET=${libgo_cv_c_epoll_event_fd_offset}\n AC_SUBST(STRUCT_EPOLL_EVENT_FD_OFFSET)\n \n+dnl See whether setcontext changes the value of TLS variables.\n+AC_CACHE_CHECK([whether setcontext clobbers TLS variables],\n+[libgo_cv_lib_setcontext_clobbers_tls],\n+[LIBS_hold=\"$LIBS\"\n+LIBS=\"$LIBS $PTHREAD_LIBS\"\n+AC_RUN_IFELSE(\n+  [AC_LANG_SOURCE([\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <ucontext.h>\n+#include <unistd.h>\n+\n+__thread int tls;\n+\n+static char stack[[10 * 1024 * 1024]];\n+static ucontext_t c;\n+\n+/* Called via makecontext/setcontext.  */\n+\n+static void\n+cfn (void)\n+{\n+  exit (tls);\n+}\n+\n+/* Called via pthread_create.  */\n+\n+static void *\n+tfn (void *dummy)\n+{\n+  /* The thread should still see this value after calling\n+     setcontext.  */\n+  tls = 0;\n+\n+  setcontext (&c);\n+\n+  /* The call to setcontext should not return.  */\n+  abort ();\n+}\n+\n+int\n+main ()\n+{\n+  pthread_t tid;\n+\n+  /* The thread should not see this value.  */\n+  tls = 1;\n+\n+  if (getcontext (&c) < 0)\n+    abort ();\n+\n+  c.uc_stack.ss_sp = stack;\n+  c.uc_stack.ss_flags = 0;\n+  c.uc_stack.ss_size = sizeof stack;\n+  c.uc_link = NULL;\n+  makecontext (&c, cfn, 0);\n+\n+  if (pthread_create (&tid, NULL, tfn, NULL) != 0)\n+    abort ();\n+\n+  if (pthread_join (tid, NULL) != 0)\n+    abort ();\n+\n+  /* The thread should have called exit.  */\n+  abort ();\n+}\n+])],\n+[libgo_cv_lib_setcontext_clobbers_tls=no],\n+[libgo_cv_lib_setcontext_clobbers_tls=yes],\n+[case \"$target\" in\n+  x86_64*-*-solaris2.10) libgo_cv_lib_setcontext_clobbers_tls=yes ;;\n+  *) libgo_cv_lib_setcontext_clobbers_tls=no ;;\n+ esac\n+])\n+LIBS=\"$LIBS_hold\"\n+])\n+if test \"$libgo_cv_lib_setcontext_clobbers_tls\" = \"yes\"; then\n+  AC_DEFINE(SETCONTEXT_CLOBBERS_TLS, 1,\n+\t    [Define if setcontext clobbers TLS variables])\n+fi\n+\n AC_CACHE_SAVE\n \n if test ${multilib} = yes; then"}, {"sha": "04412bd67e2b6fc925af13fe2fb7400af8b924c3", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f57843fbebc7b50cfad7cc5bd3459a2d1077035/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=7f57843fbebc7b50cfad7cc5bd3459a2d1077035", "patch": "@@ -60,6 +60,54 @@ G\truntime_g0;\t// idle goroutine for m0\n static __thread G *g;\n static __thread M *m;\n \n+#ifndef SETCONTEXT_CLOBBERS_TLS\n+\n+static inline void\n+initcontext(void)\n+{\n+}\n+\n+static inline void\n+fixcontext(ucontext_t *c __attribute__ ((unused)))\n+{\n+}\n+\n+# else\n+\n+# if defined(__x86_64__) && defined(__sun__)\n+\n+// x86_64 Solaris 10 and 11 have a bug: setcontext switches the %fs\n+// register to that of the thread which called getcontext.  The effect\n+// is that the address of all __thread variables changes.  This bug\n+// also affects pthread_self() and pthread_getspecific.  We work\n+// around it by clobbering the context field directly to keep %fs the\n+// same.\n+\n+static __thread greg_t fs;\n+\n+static inline void\n+initcontext(void)\n+{\n+\tucontext_t c;\n+\n+\tgetcontext(&c);\n+\tfs = c.uc_mcontext.gregs[REG_FSBASE];\n+}\n+\n+static inline void\n+fixcontext(ucontext_t* c)\n+{\n+\tc->uc_mcontext.gregs[REG_FSBASE] = fs;\n+}\n+\n+# else\n+\n+#  error unknown case for SETCONTEXT_CLOBBERS_TLS\n+\n+# endif\n+\n+#endif\n+\n // We can not always refer to the TLS variables directly.  The\n // compiler will call tls_get_addr to get the address of the variable,\n // and it may hold it in a register across a call to schedule.  When\n@@ -248,7 +296,9 @@ runtime_gogo(G* newg)\n #endif\n \tg = newg;\n \tnewg->fromgogo = true;\n+\tfixcontext(&newg->context);\n \tsetcontext(&newg->context);\n+\truntime_throw(\"gogo setcontext returned\");\n }\n \n // Save context and call fn passing g as a parameter.  This is like\n@@ -287,6 +337,7 @@ runtime_mcall(void (*pfn)(G*))\n \t\tm->g0->entry = (byte*)pfn;\n \t\tm->g0->param = g;\n \t\tg = m->g0;\n+\t\tfixcontext(&m->g0->context);\n \t\tsetcontext(&m->g0->context);\n \t\truntime_throw(\"runtime: mcall function returned\");\n \t}\n@@ -312,6 +363,8 @@ runtime_schedinit(void)\n \tm->curg = g;\n \tg->m = m;\n \n+\tinitcontext();\n+\n \tm->nomemprof++;\n \truntime_mallocinit();\n \tmcommoninit(m);\n@@ -844,6 +897,8 @@ runtime_mstart(void* mp)\n \tm = (M*)mp;\n \tg = m->g0;\n \n+\tinitcontext();\n+\n \tg->entry = nil;\n \tg->param = nil;\n "}]}