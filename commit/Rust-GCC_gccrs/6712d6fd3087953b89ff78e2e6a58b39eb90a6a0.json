{"sha": "6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcxMmQ2ZmQzMDg3OTUzYjg5ZmY3OGUyZTZhNThiMzllYjkwYTZhMA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-06-02T21:58:24Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-06-02T21:58:24Z"}, "message": "rs6000-modes.def (IFmode): Define IFmode to provide access to the IBM extended double floating point mode...\n\n2015-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-modes.def (IFmode): Define IFmode to\n\tprovide access to the IBM extended double floating point mode if\n\tlong double is IEEE 128-bit floating point.\n\t(KFmode): Define KFmode to provide access to IEEE 128-bit floating\n\tpoint if long double is the IBM extended double type.\n\n\t* config/rs6000/rs6000.opt (-mfloat128-none): New switches to\n\tenable adding IEEE 128-bit floating point support.\n\t(-mfloat128-software): Likewise.\n\t(-mfloat128-sw): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Do not allow\n\t128-bit floating point types to occupy any register if\n\t-mlong-double-64.  Do not allow use of IFmode/KFmode unless\n\t-mfloat128-software is enabled.\n\t(rs6000_debug_reg_global): Add IEEE 128-bit floating point debug\n\tsupport.\n\t(rs6000_option_override_internal): Add -mfloat128-* support.\n\t(rs6000_init_builtins): Setup __ibm128 and __float128 type modes.\n\n\t* config/rs6000/rs6000.h (rs6000_builtin_type_index): Add ibm128\n\tand float128 type nodes.\n\t(ieee128_float_type_node): Likewise.\n\t(ibm128_float_type_node): Likewise.\n\nFrom-SVN: r224042", "tree": {"sha": "ad597f5e6ac1818c16e7adfdec1ffb7e420d3e94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad597f5e6ac1818c16e7adfdec1ffb7e420d3e94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/comments", "author": null, "committer": null, "parents": [{"sha": "6ac481556e7ce457d72eb44b9a07db3fae63ed8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac481556e7ce457d72eb44b9a07db3fae63ed8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ac481556e7ce457d72eb44b9a07db3fae63ed8a"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "fc87c1861484e4962d2597cb7ff7a1cfa5a67966", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "patch": "@@ -1,3 +1,30 @@\n+2015-06-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-modes.def (IFmode): Define IFmode to\n+\tprovide access to the IBM extended double floating point mode if\n+\tlong double is IEEE 128-bit floating point.\n+\t(KFmode): Define KFmode to provide access to IEEE 128-bit floating\n+\tpoint if long double is the IBM extended double type.\n+\n+\t* config/rs6000/rs6000.opt (-mfloat128-none): New switches to\n+\tenable adding IEEE 128-bit floating point support.\n+\t(-mfloat128-software): Likewise.\n+\t(-mfloat128-sw): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Do not allow\n+\t128-bit floating point types to occupy any register if\n+\t-mlong-double-64.  Do not allow use of IFmode/KFmode unless\n+\t-mfloat128-software is enabled.\n+\t(rs6000_debug_reg_global): Add IEEE 128-bit floating point debug\n+\tsupport.\n+\t(rs6000_option_override_internal): Add -mfloat128-* support.\n+\t(rs6000_init_builtins): Setup __ibm128 and __float128 type modes.\n+\n+\t* config/rs6000/rs6000.h (rs6000_builtin_type_index): Add ibm128\n+\tand float128 type nodes.\n+\t(ieee128_float_type_node): Likewise.\n+\t(ibm128_float_type_node): Likewise.\n+\n 2015-06-02  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \tPR target/66136"}, {"sha": "1cd3b94eee78881f3713ce0456a53fedcd6fa445", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "patch": "@@ -18,6 +18,13 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* IBM 128-bit floating point.  IFmode and KFmode use the fractional float\n+   support in order to declare 3 128-bit floating point types.  */\n+FRACTIONAL_FLOAT_MODE (IF, 106, 16, ibm_extended_format);\n+\n+/* Explicit IEEE 128-bit floating point.  */\n+FRACTIONAL_FLOAT_MODE (KF, 113, 16, ieee_quad_format);\n+\n /* 128-bit floating point.  ABI_V4 uses IEEE quad, AIX/Darwin\n    adjust this in rs6000_option_override_internal.  */\n FLOAT_MODE (TF, 16, ieee_quad_format);"}, {"sha": "201081d9e3a561293ac22e4cd50255373e73f1a4", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "patch": "@@ -79,6 +79,15 @@ enum fpu_type_t\n   FPU_DF_FULL\t\t\t/* Full Double Single Precision FPU */\n };\n \n+\n+/* Float128 support.  */\n+enum float128_type_t\n+{\n+  FLOAT128_UNSET\t= -1,\t/* Initial value.  */\n+  FLOAT128_NONE,\t\t/* No __float128 support.  */\n+  FLOAT128_SW\t\t\t/* software __float128 support.  */\n+};\n+\n /* Types of costly dependences.  */\n enum rs6000_dependence_cost\n {"}, {"sha": "2927e5ae740d61d4de9924097d0789428b6f1938", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "patch": "@@ -1817,6 +1817,16 @@ rs6000_hard_regno_mode_ok (int regno, machine_mode mode)\n \t    && IN_RANGE (last_regno, FIRST_GPR_REGNO, LAST_GPR_REGNO)\n \t    && ((regno & 1) == 0));\n \n+  /* If we don't allow 128-bit binary floating point, disallow the 128-bit\n+     types from going in any registers.  Similarly if __float128 is not\n+     supported, don't allow __float128/__ibm128 types.  */\n+  if (!TARGET_LONG_DOUBLE_128\n+      && (mode == TFmode || mode == KFmode || mode == IFmode))\n+    return false;\n+\n+  if (!TARGET_FLOAT128 && (mode == KFmode || mode == IFmode))\n+    return false;\n+\n   /* VSX registers that overlap the FPR registers are larger than for non-VSX\n      implementations.  Don't allow an item to be split between a FP register\n      and an Altivec register.  Allow TImode in all VSX registers if the user\n@@ -2086,6 +2096,7 @@ rs6000_debug_reg_global (void)\n   const char *trace_str;\n   const char *abi_str;\n   const char *cmodel_str;\n+  const char *float128_str;\n   struct cl_target_option cl_opts;\n \n   /* Modes we want tieable information on.  */\n@@ -2099,6 +2110,8 @@ rs6000_debug_reg_global (void)\n     SFmode,\n     DFmode,\n     TFmode,\n+    IFmode,\n+    KFmode,\n     SDmode,\n     DDmode,\n     TDmode,\n@@ -2445,6 +2458,15 @@ rs6000_debug_reg_global (void)\n   fprintf (stderr, DEBUG_FMT_S, \"e500_double\",\n \t   (TARGET_E500_DOUBLE ? \"true\" : \"false\"));\n \n+  switch (TARGET_FLOAT128)\n+    {\n+    case FLOAT128_NONE:\tfloat128_str = \"none\";\t\tbreak;\n+    case FLOAT128_SW:\tfloat128_str = \"software\";\tbreak;\n+    default:\t\tfloat128_str = \"unknown\";\tbreak;\n+    }\n+\n+  fprintf (stderr, DEBUG_FMT_S, \"float128\", float128_str);\n+\n   if (TARGET_LINK_STACK)\n     fprintf (stderr, DEBUG_FMT_S, \"link_stack\", \"true\");\n \n@@ -3703,6 +3725,13 @@ rs6000_option_override_internal (bool global_init_p)\n       && optimize >= 3)\n     rs6000_isa_flags |= OPTION_MASK_P8_FUSION_SIGN;\n \n+  /* Set the appropriate IEEE 128-bit floating option.  Do not enable float128\n+     support by default until the libgcc support is added.  */\n+  if (TARGET_FLOAT128 == FLOAT128_UNSET)\n+    TARGET_FLOAT128 = FLOAT128_NONE;\n+  else if (TARGET_FLOAT128 == FLOAT128_SW && !TARGET_VSX)\n+    error (\"-mfloat128-software requires VSX support\");\n+\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after defaults\", rs6000_isa_flags);\n \n@@ -14320,6 +14349,8 @@ rs6000_init_builtins (void)\n   tree tdecl;\n   tree ftype;\n   machine_mode mode;\n+  machine_mode ieee128_mode;\n+  machine_mode ibm128_mode;\n \n   if (TARGET_DEBUG_BUILTIN)\n     fprintf (stderr, \"rs6000_init_builtins%s%s%s%s\\n\",\n@@ -14387,6 +14418,32 @@ rs6000_init_builtins (void)\n   dfloat128_type_internal_node = dfloat128_type_node;\n   void_type_internal_node = void_type_node;\n \n+  /* 128-bit floating point support.  KFmode is IEEE 128-bit floating point.\n+     IFmode is the IBM extended 128-bit format that is a pair of doubles.\n+     TFmode will be either IEEE 128-bit floating point or the IBM double-double\n+     format that uses a pair of doubles, depending on the switches and\n+     defaults.  */\n+  if (TARGET_IEEEQUAD)\n+    {\n+      ieee128_mode = TFmode;\n+      ibm128_mode = IFmode;\n+    }\n+  else\n+    {\n+      ieee128_mode = KFmode;\n+      ibm128_mode = TFmode;\n+    }\n+\n+  ieee128_float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (ieee128_float_type_node) = 128;\n+  layout_type (ieee128_float_type_node);\n+  SET_TYPE_MODE (ieee128_float_type_node, ieee128_mode);\n+\n+  ibm128_float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (ibm128_float_type_node) = 128;\n+  layout_type (ibm128_float_type_node);\n+  SET_TYPE_MODE (ibm128_float_type_node, ibm128_mode);\n+\n   /* Initialize the modes for builtin_function_type, mapping a machine mode to\n      tree type node.  */\n   builtin_mode_to_type[QImode][0] = integer_type_node;\n@@ -14399,6 +14456,8 @@ rs6000_init_builtins (void)\n   builtin_mode_to_type[TImode][1] = unsigned_intTI_type_node;\n   builtin_mode_to_type[SFmode][0] = float_type_node;\n   builtin_mode_to_type[DFmode][0] = double_type_node;\n+  builtin_mode_to_type[IFmode][0] = ibm128_float_type_node;\n+  builtin_mode_to_type[KFmode][0] = ieee128_float_type_node;\n   builtin_mode_to_type[TFmode][0] = long_double_type_node;\n   builtin_mode_to_type[DDmode][0] = dfloat64_type_node;\n   builtin_mode_to_type[TDmode][0] = dfloat128_type_node;"}, {"sha": "1b1145fb59ec9529f54f2337459c95c554b6e1a2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "patch": "@@ -2715,6 +2715,8 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_dfloat64,\t\t /* dfloat64_type_node */\n   RS6000_BTI_dfloat128,\t\t /* dfloat128_type_node */\n   RS6000_BTI_void,\t         /* void_type_node */\n+  RS6000_BTI_ieee128_float,\t /* ieee 128-bit floating point */\n+  RS6000_BTI_ibm128_float,\t /* IBM 128-bit floating point */\n   RS6000_BTI_MAX\n };\n \n@@ -2769,6 +2771,8 @@ enum rs6000_builtin_type_index\n #define dfloat64_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_dfloat64])\n #define dfloat128_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_dfloat128])\n #define void_type_internal_node\t\t (rs6000_builtin_types[RS6000_BTI_void])\n+#define ieee128_float_type_node\t\t (rs6000_builtin_types[RS6000_BTI_ieee128_float])\n+#define ibm128_float_type_node\t\t (rs6000_builtin_types[RS6000_BTI_ibm128_float])\n \n extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];\n extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];"}, {"sha": "18ea27a3d909f046bacf52ba93bd0f331f32e901", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6712d6fd3087953b89ff78e2e6a58b39eb90a6a0/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=6712d6fd3087953b89ff78e2e6a58b39eb90a6a0", "patch": "@@ -600,3 +600,19 @@ Allow float/double variables in upper registers if cpu allows it\n moptimize-swaps\n Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save\n Analyze and remove doubleword swaps from VSX computations.\n+\n+mfloat128-\n+Target RejectNegative Joined Enum(float128_type_t) Var(TARGET_FLOAT128) Init(FLOAT128_UNSET) Save\n+-mfloat128-{software,none} - Specify how IEEE 128-bit floating point is used.\n+\n+Enum\n+Name(float128_type_t) Type(enum float128_type_t)\n+\n+EnumValue\n+Enum(float128_type_t) String(none) Value(FLOAT128_NONE)\n+\n+EnumValue\n+Enum(float128_type_t) String(software) Value(FLOAT128_SW)\n+\n+EnumValue\n+Enum(float128_type_t) String(sw) Value(FLOAT128_SW)"}]}