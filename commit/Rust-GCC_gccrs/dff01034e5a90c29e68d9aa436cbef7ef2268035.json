{"sha": "dff01034e5a90c29e68d9aa436cbef7ef2268035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZmMDEwMzRlNWE5MGMyOWU2OGQ5YWE0MzZjYmVmN2VmMjI2ODAzNQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-03-06T05:34:26Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-03-06T05:34:26Z"}, "message": "c-aux-info.c (data_type, [...]): Qualify a char* with the `const' keyword.\n\n        * c-aux-info.c (data_type, affix_data_type, gen_decl,\n        gen_formal_list_for_type, gen_formal_list_for_func_def, gen_type):\n        Qualify a char* with the `const' keyword.\n        * c-common.c (declare_hidden_char_array, add_attribute, if_elt,\n        declare_function_name, decl_attributes, format_char_info,\n        check_format_info, binary_op_error): Likewise.\n        * cexp.y (yyerror, error, pedwarn, warning, token): Likewise.\n        * gcse.c (dump_hash_table): Likewise.\n        * integrate.c (function_cannot_inline_p): Likewise\n        * optabs.c: Include insn-config.h earlier.\n        (init_libfuncs, init_integral_libfuncs, init_floating_libfuncs):\n        Qualify a char* with the `const' keyword.\n        * real.c (asctoe24, asctoe53, asctoe64, asctoe113, asctoe,\n        asctoeg, mtherr, ereal_atof): Likewise.\n        * real.h (ereal_atof): Likewise.\n        * sbitmap.c (dump_sbitmap_vector): Likewise.\n        * sbitmap.h (dump_sbitmap_vector): Likewise.\n        * stmt.c (nesting, n_occurrences, expand_start_case): Likewise.\n        * toplev.c (rest_of_compilation): Likewise.\n        * tree.h (function_cannot_inline_p, expand_start_case): Likewise.\n\nFrom-SVN: r25614", "tree": {"sha": "c772c985a70004b9455673e66fda09916b427de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c772c985a70004b9455673e66fda09916b427de1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dff01034e5a90c29e68d9aa436cbef7ef2268035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff01034e5a90c29e68d9aa436cbef7ef2268035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff01034e5a90c29e68d9aa436cbef7ef2268035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff01034e5a90c29e68d9aa436cbef7ef2268035/comments", "author": null, "committer": null, "parents": [{"sha": "3c2a0097066b2f122d4ae0a70bde6e8f1721081a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2a0097066b2f122d4ae0a70bde6e8f1721081a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2a0097066b2f122d4ae0a70bde6e8f1721081a"}], "stats": {"total": 316, "additions": 179, "deletions": 137}, "files": [{"sha": "28761f7e4c1eb9ed9bbfcff78f7b1e9cadb6637a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -1,3 +1,38 @@\n+Sat Mar  6 07:49:23 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-aux-info.c (data_type, affix_data_type, gen_decl, \n+ \tgen_formal_list_for_type, gen_formal_list_for_func_def, gen_type):\n+\tQualify a char* with the `const' keyword.\n+\n+\t* c-common.c (declare_hidden_char_array, add_attribute, if_elt,\n+ \tdeclare_function_name, decl_attributes, format_char_info,\n+ \tcheck_format_info, binary_op_error): Likewise.\n+\t\n+\t* cexp.y (yyerror, error, pedwarn, warning, token): Likewise.\n+\n+\t* gcse.c (dump_hash_table): Likewise.\n+\n+\t* integrate.c (function_cannot_inline_p): Likewise\n+\n+\t* optabs.c: Include insn-config.h earlier.\n+\t(init_libfuncs, init_integral_libfuncs, init_floating_libfuncs):\n+\tQualify a char* with the `const' keyword.\n+\t\n+\t* real.c (asctoe24, asctoe53, asctoe64, asctoe113, asctoe,\n+ \tasctoeg, mtherr, ereal_atof): Likewise.\n+\n+\t* real.h (ereal_atof): Likewise.\n+\n+\t* sbitmap.c (dump_sbitmap_vector): Likewise.\n+\n+\t* sbitmap.h (dump_sbitmap_vector): Likewise.\n+\n+\t* stmt.c (nesting, n_occurrences, expand_start_case): Likewise.\n+\n+\t* toplev.c (rest_of_compilation): Likewise.\n+\n+\t* tree.h (function_cannot_inline_p, expand_start_case): Likewise.\n+\t\n Fri Mar  5 23:16:42 1999  David Edelsohn  <edelsohn@mhpcc.edu>\n \n \t* rs6000.h (ASM_OUTPUT_REG_{PUSH,POP}): Add 64-bit support and do"}, {"sha": "f4238dd29e3892adc8670f2e04861ce70767f543", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -1,7 +1,7 @@\n /* Generate information regarding function declarations and definitions based\n    on information stored in GCC's tree structure.  This code implements the\n    -aux-info option.\n-   Copyright (C) 1989, 91, 94, 95, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 91, 94, 95, 97-98, 1999 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@segfault.us.com).\n \n This file is part of GNU CC.\n@@ -35,14 +35,14 @@ enum formals_style_enum {\n typedef enum formals_style_enum formals_style;\n \n \n-static char *data_type;\n+static const char *data_type;\n \n-static char *affix_data_type\t\tPROTO((char *));\n-static char *gen_formal_list_for_type\tPROTO((tree, formals_style));\n+static char *affix_data_type\t\tPROTO((const char *));\n+static const char *gen_formal_list_for_type PROTO((tree, formals_style));\n static int   deserves_ellipsis\t\tPROTO((tree));\n-static char *gen_formal_list_for_func_def PROTO((tree, formals_style));\n-static char *gen_type\t\t\tPROTO((char *, tree, formals_style));\n-static char *gen_decl\t\t\tPROTO((tree, int, formals_style));\n+static const char *gen_formal_list_for_func_def PROTO((tree, formals_style));\n+static const char *gen_type\t\tPROTO((const char *, tree, formals_style));\n+static const char *gen_decl\t\tPROTO((tree, int, formals_style));\n \f\n /* Concatenate a sequence of strings, returning the result.\n \n@@ -120,13 +120,16 @@ concat VPROTO((const char *first, ...))\n    that look as expected.  */\n \n static char *\n-affix_data_type (type_or_decl)\n-     char *type_or_decl;\n+affix_data_type (param)\n+     const char *param;\n {\n+  char *type_or_decl = (char *) alloca (strlen (param) + 1);\n   char *p = type_or_decl;\n   char *qualifiers_then_data_type;\n   char saved;\n \n+  strcpy (type_or_decl, param);\n+  \n   /* Skip as many leading const's or volatile's as there are.  */\n \n   for (;;)\n@@ -164,12 +167,12 @@ affix_data_type (type_or_decl)\n    we are currently aiming for is non-ansi, then we just return a pair\n    of empty parens here.  */\n \n-static char *\n+static const char *\n gen_formal_list_for_type (fntype, style)\n      tree fntype;\n      formals_style style;\n {\n-  char *formal_list = \"\";\n+  const char *formal_list = \"\";\n   tree formal_type;\n \n   if (style != ansi)\n@@ -178,7 +181,7 @@ gen_formal_list_for_type (fntype, style)\n   formal_type = TYPE_ARG_TYPES (fntype);\n   while (formal_type && TREE_VALUE (formal_type) != void_type_node)\n     {\n-      char *this_type;\n+      const char *this_type;\n \n       if (*formal_list)\n         formal_list = concat (formal_list, \", \", NULL_PTR);\n@@ -284,18 +287,18 @@ deserves_ellipsis (fntype)\n    This routine returns a string which is the source form for the entire\n    function formal parameter list.  */\n \n-static char *\n+static const char *\n gen_formal_list_for_func_def (fndecl, style)\n      tree fndecl;\n      formals_style style;\n {\n-  char *formal_list = \"\";\n+  const char *formal_list = \"\";\n   tree formal_decl;\n \n   formal_decl = DECL_ARGUMENTS (fndecl);\n   while (formal_decl)\n     {\n-      char *this_formal;\n+      const char *this_formal;\n \n       if (*formal_list && ((style == ansi) || (style == k_and_r_names)))\n         formal_list = concat (formal_list, \", \", NULL_PTR);\n@@ -359,9 +362,9 @@ gen_formal_list_for_func_def (fndecl, style)\n    to do at this point is for the initial caller to prepend the \"data_type\"\n    string onto the returned \"seed\".  */\n \n-static char *\n+static const char *\n gen_type (ret_val, t, style)\n-     char *ret_val;\n+     const char *ret_val;\n      tree t;\n      formals_style style;\n {\n@@ -533,13 +536,13 @@ gen_type (ret_val, t, style)\n    associated with a function definition.  In this case, we can assume that\n    an attached list of DECL nodes for function formal arguments is present.  */\n \n-static char *\n+static const char *\n gen_decl (decl, is_func_definition, style)\n      tree decl;\n      int is_func_definition;\n      formals_style style;\n {\n-  char *ret_val;\n+  const char *ret_val;\n \n   if (DECL_NAME (decl))\n     ret_val = IDENTIFIER_POINTER (DECL_NAME (decl));"}, {"sha": "5def64214ec789b125dcf7306acc53f8c0b26a3b", "filename": "gcc/c-common.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -60,8 +60,8 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n enum format_type { printf_format_type, scanf_format_type,\n \t\t   strftime_format_type };\n \n-static void declare_hidden_char_array\tPROTO((char *, char *));\n-static void add_attribute\t\tPROTO((enum attrs, char *,\n+static void declare_hidden_char_array\tPROTO((const char *, const char *));\n+static void add_attribute\t\tPROTO((enum attrs, const char *,\n \t\t\t\t\t       int, int, int));\n static void init_attributes\t\tPROTO((void));\n static void record_function_format\tPROTO((tree, tree, enum format_type,\n@@ -78,7 +78,7 @@ typedef struct\n {\n   int compstmt_count;\n   int line;\n-  char *file;\n+  const char *file;\n   int needs_warning;\n } if_elt;\n static void tfaff\t\t\tPROTO((void));\n@@ -170,7 +170,7 @@ c_expand_start_else ()\n void\n declare_function_name ()\n {\n-  char *name, *printable_name;\n+  const char *name, *printable_name;\n \n   if (current_function_decl == NULL)\n     {\n@@ -196,7 +196,7 @@ declare_function_name ()\n \n static void\n declare_hidden_char_array (name, value)\n-     char *name, *value;\n+     const char *name, *value;\n {\n   tree decl, type, init;\n   int vlen;\n@@ -355,7 +355,7 @@ static int attrtab_idx = 0;\n static void\n add_attribute (id, string, min_len, max_len, decl_req)\n      enum attrs id;\n-     char *string;\n+     const char *string;\n      int min_len, max_len;\n      int decl_req;\n {\n@@ -587,7 +587,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t  else\n \t    {\n \t      int j;\n-\t      char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n+\t      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n \t      int len = strlen (p);\n \t      enum machine_mode mode = VOIDmode;\n \t      tree typefm;\n@@ -719,7 +719,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t      }\n \t    else\n \t      {\n-\t\tchar *p = IDENTIFIER_POINTER (format_type_id);\n+\t\tconst char *p = IDENTIFIER_POINTER (format_type_id);\n \t\t\n \t\tif (!strcmp (p, \"printf\") || !strcmp (p, \"__printf__\"))\n \t\t  format_type = printf_format_type;\n@@ -1099,7 +1099,7 @@ strip_attrs (specs_attrs)\n #define T_ST    &sizetype\n \n typedef struct {\n-  char *format_chars;\n+  const char *format_chars;\n   int pointer_count;\n   /* Type of argument if no length modifier is used.  */\n   tree *nolen;\n@@ -1122,7 +1122,7 @@ typedef struct {\n      If NULL, then this modifier is not allowed.  */\n   tree *zlen;\n   /* List of other modifier characters allowed with these options.  */\n-  char *flag_chars;\n+  const char *flag_chars;\n } format_char_info;\n \n static format_char_info print_char_table[] = {\n@@ -1376,7 +1376,7 @@ check_format_info (info, params)\n   tree cur_type;\n   tree wanted_type;\n   tree first_fillin_param;\n-  char *format_chars;\n+  const char *format_chars;\n   format_char_info *fci = NULL;\n   char flag_chars[8];\n   int has_operand_number = 0;\n@@ -1540,7 +1540,7 @@ check_format_info (info, params)\n \t     it is an operand number, so set PARAMS to that operand.  */\n \t  if (*format_chars >= '0' && *format_chars <= '9')\n \t    {\n-\t      char *p = format_chars;\n+\t      const char *p = format_chars;\n \n \t      while (*p >= '0' && *p++ <= '9')\n \t\t;\n@@ -1899,8 +1899,8 @@ check_format_info (info, params)\n \t\t&& (TYPE_MAIN_VARIANT (cur_type) == signed_char_type_node\n \t\t    || TYPE_MAIN_VARIANT (cur_type) == unsigned_char_type_node)))\n \t{\n-\t  register char *this;\n-\t  register char *that;\n+\t  register const char *this;\n+\t  register const char *that;\n \n \t  this = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n \t  that = 0;\n@@ -2230,7 +2230,7 @@ void\n binary_op_error (code)\n      enum tree_code code;\n {\n-  register char *opname;\n+  register const char *opname;\n \n   switch (code)\n     {"}, {"sha": "82d8ebef0b11f5480f8fd3e81a539ed7a1a6acd9", "filename": "gcc/cexp.c", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -46,7 +46,8 @@ struct arglist {\n HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n-static void yyerror PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+static void yyerror PVPROTO((const char *, ...))\n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n static HOST_WIDEST_INT expression_value;\n #ifdef TEST_EXP_READER\n static int expression_signedp;\n@@ -131,9 +132,9 @@ struct constant;\n HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n struct hashnode *lookup PROTO((U_CHAR *, int, int));\n-void error PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n-void pedwarn PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n-void warning PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void pedwarn PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void warning PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n static int parse_number PROTO((int));\n static HOST_WIDEST_INT left_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n@@ -144,7 +145,7 @@ static void integer_overflow PROTO((void));\n #define SIGNED (~0)\n #define UNSIGNED 0\n \n-#line 152 \"cexp.y\"\n+#line 153 \"cexp.y\"\n typedef union {\n   struct constant {HOST_WIDEST_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n@@ -225,10 +226,10 @@ static const short yyrhs[] = {    35,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   182,   192,   193,   200,   205,   208,   210,   213,   217,   219,\n-   224,   229,   242,   259,   272,   278,   284,   290,   296,   299,\n-   302,   309,   316,   323,   330,   333,   336,   339,   342,   345,\n-   348,   351,   353,   356,   359,   361,   363,   371,   373,   386\n+   183,   193,   194,   201,   206,   209,   211,   214,   218,   220,\n+   225,   230,   243,   260,   273,   279,   285,   291,   297,   300,\n+   303,   310,   317,   324,   331,   334,   337,   340,   343,   346,\n+   349,   352,   354,   357,   360,   362,   364,   372,   374,   387\n };\n #endif\n \n@@ -832,7 +833,7 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 183 \"cexp.y\"\n+#line 184 \"cexp.y\"\n {\n \t\t  expression_value = yyvsp[0].integer.value;\n #ifdef TEST_EXP_READER\n@@ -841,55 +842,55 @@ case 1:\n \t\t;\n     break;}\n case 3:\n-#line 194 \"cexp.y\"\n+#line 195 \"cexp.y\"\n { if (pedantic)\n \t\t\t    pedwarn (\"comma operator in operand of `#if'\");\n \t\t\t  yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 4:\n-#line 201 \"cexp.y\"\n+#line 202 \"cexp.y\"\n { yyval.integer.value = - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp;\n \t\t\t  if ((yyval.integer.value & yyvsp[0].integer.value & yyval.integer.signedp) < 0)\n \t\t\t    integer_overflow (); ;\n     break;}\n case 5:\n-#line 206 \"cexp.y\"\n+#line 207 \"cexp.y\"\n { yyval.integer.value = ! yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 6:\n-#line 209 \"cexp.y\"\n+#line 210 \"cexp.y\"\n { yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 7:\n-#line 211 \"cexp.y\"\n+#line 212 \"cexp.y\"\n { yyval.integer.value = ~ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp; ;\n     break;}\n case 8:\n-#line 214 \"cexp.y\"\n+#line 215 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[0].name.address, yyvsp[0].name.length,\n \t\t\t\t\t\t      0, NULL_PTR);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 9:\n-#line 218 \"cexp.y\"\n+#line 219 \"cexp.y\"\n { keyword_parsing = 1; ;\n     break;}\n case 10:\n-#line 220 \"cexp.y\"\n+#line 221 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[-4].name.address, yyvsp[-4].name.length,\n \t\t\t\t\t\t      1, yyvsp[-1].keywords);\n \t\t\t  keyword_parsing = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 11:\n-#line 225 \"cexp.y\"\n+#line 226 \"cexp.y\"\n { yyval.integer = yyvsp[-1].integer; ;\n     break;}\n case 12:\n-#line 230 \"cexp.y\"\n+#line 231 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    {\n@@ -904,7 +905,7 @@ case 12:\n \t\t\t\t\t* yyvsp[0].integer.value); ;\n     break;}\n case 13:\n-#line 243 \"cexp.y\"\n+#line 244 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -923,7 +924,7 @@ case 13:\n \t\t\t\t\t/ yyvsp[0].integer.value); ;\n     break;}\n case 14:\n-#line 260 \"cexp.y\"\n+#line 261 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -938,49 +939,49 @@ case 14:\n \t\t\t\t\t% yyvsp[0].integer.value); ;\n     break;}\n case 15:\n-#line 273 \"cexp.y\"\n+#line 274 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value + yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyvsp[-2].integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyval.integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 16:\n-#line 279 \"cexp.y\"\n+#line 280 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyval.integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyvsp[-2].integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 17:\n-#line 285 \"cexp.y\"\n+#line 286 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 18:\n-#line 291 \"cexp.y\"\n+#line 292 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 19:\n-#line 297 \"cexp.y\"\n+#line 298 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value == yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 20:\n-#line 300 \"cexp.y\"\n+#line 301 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value != yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 21:\n-#line 303 \"cexp.y\"\n+#line 304 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value <= yyvsp[0].integer.value;\n@@ -989,7 +990,7 @@ case 21:\n \t\t\t\t\t<= yyvsp[0].integer.value); ;\n     break;}\n case 22:\n-#line 310 \"cexp.y\"\n+#line 311 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value >= yyvsp[0].integer.value;\n@@ -998,7 +999,7 @@ case 22:\n \t\t\t\t\t>= yyvsp[0].integer.value); ;\n     break;}\n case 23:\n-#line 317 \"cexp.y\"\n+#line 318 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value < yyvsp[0].integer.value;\n@@ -1007,7 +1008,7 @@ case 23:\n \t\t\t\t\t< yyvsp[0].integer.value); ;\n     break;}\n case 24:\n-#line 324 \"cexp.y\"\n+#line 325 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value > yyvsp[0].integer.value;\n@@ -1016,76 +1017,76 @@ case 24:\n \t\t\t\t\t> yyvsp[0].integer.value); ;\n     break;}\n case 25:\n-#line 331 \"cexp.y\"\n+#line 332 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value & yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 26:\n-#line 334 \"cexp.y\"\n+#line 335 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value ^ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 27:\n-#line 337 \"cexp.y\"\n+#line 338 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value | yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 28:\n-#line 340 \"cexp.y\"\n+#line 341 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 29:\n-#line 342 \"cexp.y\"\n+#line 343 \"cexp.y\"\n { skip_evaluation -= !yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value && yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 30:\n-#line 346 \"cexp.y\"\n+#line 347 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-1].integer.value; ;\n     break;}\n case 31:\n-#line 348 \"cexp.y\"\n+#line 349 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value || yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 32:\n-#line 352 \"cexp.y\"\n+#line 353 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 33:\n-#line 354 \"cexp.y\"\n+#line 355 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-4].integer.value - !yyvsp[-4].integer.value; ;\n     break;}\n case 34:\n-#line 356 \"cexp.y\"\n+#line 357 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-6].integer.value;\n \t\t\t  yyval.integer.value = yyvsp[-6].integer.value ? yyvsp[-3].integer.value : yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-3].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 35:\n-#line 360 \"cexp.y\"\n+#line 361 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 36:\n-#line 362 \"cexp.y\"\n+#line 363 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 37:\n-#line 364 \"cexp.y\"\n+#line 365 \"cexp.y\"\n { if (warn_undef && !skip_evaluation)\n \t\t\t    warning (\"`%.*s' is not defined\",\n \t\t\t\t     yyvsp[0].name.length, yyvsp[0].name.address);\n \t\t\t  yyval.integer.value = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 38:\n-#line 372 \"cexp.y\"\n+#line 373 \"cexp.y\"\n { yyval.keywords = 0; ;\n     break;}\n case 39:\n-#line 374 \"cexp.y\"\n+#line 375 \"cexp.y\"\n { struct arglist *temp;\n \t\t\t  yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->next = yyvsp[-2].keywords;\n@@ -1100,7 +1101,7 @@ case 39:\n \t\t\t  temp->next->length = 1; ;\n     break;}\n case 40:\n-#line 387 \"cexp.y\"\n+#line 388 \"cexp.y\"\n { yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->name = yyvsp[-1].name.address;\n \t\t\t  yyval.keywords->length = yyvsp[-1].name.length;\n@@ -1304,7 +1305,7 @@ case 40:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 392 \"cexp.y\"\n+#line 393 \"cexp.y\"\n \n \f\n /* During parsing of a C expression, the pointer to the next character\n@@ -1410,7 +1411,7 @@ parse_number (olen)\n }\n \n struct token {\n-  char *operator;\n+  const char *operator;\n   int token;\n };\n \n@@ -1917,17 +1918,17 @@ parse_c_expression (string, warn_undefined)\n }\n \n static void\n-yyerror VPROTO ((char * msgid, ...))\n+yyerror VPROTO ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msgid;\n+  const char * msgid;\n #endif\n   va_list args;\n \n   VA_START (args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (args, char *);\n+  msgid = va_arg (args, const char *);\n #endif\n \n   fprintf (stderr, \"error: \");"}, {"sha": "9ccc025374356d69229b7f7637b3bedb2f14491c", "filename": "gcc/cexp.y", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -1,5 +1,5 @@\n /* Parse C expressions for CCCP.\n-   Copyright (C) 1987, 92, 94, 95, 96, 97, 1998 Free Software Foundation.\n+   Copyright (C) 1987, 92, 94-98, 1999 Free Software Foundation.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -50,7 +50,8 @@ struct arglist {\n HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n-static void yyerror PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+static void yyerror PVPROTO((const char *, ...))\n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n static HOST_WIDEST_INT expression_value;\n #ifdef TEST_EXP_READER\n static int expression_signedp;\n@@ -135,9 +136,9 @@ struct constant;\n HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n struct hashnode *lookup PROTO((U_CHAR *, int, int));\n-void error PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n-void pedwarn PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n-void warning PVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void pedwarn PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void warning PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n static int parse_number PROTO((int));\n static HOST_WIDEST_INT left_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n@@ -494,7 +495,7 @@ parse_number (olen)\n }\n \n struct token {\n-  char *operator;\n+  const char *operator;\n   int token;\n };\n \n@@ -1001,17 +1002,17 @@ parse_c_expression (string, warn_undefined)\n }\n \n static void\n-yyerror VPROTO ((char * msgid, ...))\n+yyerror VPROTO ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msgid;\n+  const char * msgid;\n #endif\n   va_list args;\n \n   VA_START (args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (args, char *);\n+  msgid = va_arg (args, const char *);\n #endif\n \n   fprintf (stderr, \"error: \");"}, {"sha": "e9d4afae6613a46a6d0fceeb7b4b37313456868f", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -576,7 +576,7 @@ static void compute_set_hash_table    PROTO ((rtx));\n static void alloc_expr_hash_table     PROTO ((int));\n static void free_expr_hash_table      PROTO ((void));\n static void compute_expr_hash_table   PROTO ((rtx));\n-static void dump_hash_table           PROTO ((FILE *, char *, struct expr **, int, int));\n+static void dump_hash_table           PROTO ((FILE *, const char *, struct expr **, int, int));\n static struct expr *lookup_expr       PROTO ((rtx));\n static struct expr *lookup_set        PROTO ((int, rtx));\n static struct expr *next_set          PROTO ((int, struct expr *));\n@@ -1910,7 +1910,7 @@ hash_scan_insn (insn, set_p, in_libcall_block)\n static void\n dump_hash_table (file, name, table, table_size, total_size)\n      FILE *file;\n-     char *name;\n+     const char *name;\n      struct expr **table;\n      int table_size, total_size;\n {"}, {"sha": "1bcc2803a7e8384747b062f47691a7ff8c4ff786", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -110,7 +110,7 @@ get_label_from_map (map, i)\n    Nonzero means value is a warning msgid with a single %s\n    for the function's name.  */\n \n-char *\n+const char *\n function_cannot_inline_p (fndecl)\n      register tree fndecl;\n {"}, {"sha": "0ec9066126d5df7f9c8b25f5c09cbb9b56007b80", "filename": "gcc/optabs.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -21,13 +21,16 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+\n+/* Include insn-config.h before expr.h so that HAVE_conditional_move\n+   is properly defined. */\n+#include \"insn-config.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n #include \"expr.h\"\n-#include \"insn-config.h\"\n #include \"recog.h\"\n #include \"reload.h\"\n \n@@ -248,9 +251,9 @@ static enum insn_code can_float_p PROTO((enum machine_mode, enum machine_mode,\n \t\t\t\t\t int));\n static rtx ftruncify\tPROTO((rtx));\n static optab init_optab\tPROTO((enum rtx_code));\n-static void init_libfuncs PROTO((optab, int, int, char *, int));\n-static void init_integral_libfuncs PROTO((optab, char *, int));\n-static void init_floating_libfuncs PROTO((optab, char *, int));\n+static void init_libfuncs PROTO((optab, int, int, const char *, int));\n+static void init_integral_libfuncs PROTO((optab, const char *, int));\n+static void init_floating_libfuncs PROTO((optab, const char *, int));\n #ifdef HAVE_conditional_trap\n static void init_traps PROTO((void));\n #endif\n@@ -4085,7 +4088,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n     register optab optable;\n     register int first_mode;\n     register int last_mode;\n-    register char *opname;\n+    register const char *opname;\n     register int suffix;\n {\n   register int mode;\n@@ -4099,7 +4102,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n       register char *libfunc_name\n \t= (char *) xmalloc (2 + opname_len + mname_len + 1 + 1);\n       register char *p;\n-      register char *q;\n+      register const char *q;\n \n       p = libfunc_name;\n       *p++ = '_';\n@@ -4123,7 +4126,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n static void\n init_integral_libfuncs (optable, opname, suffix)\n     register optab optable;\n-    register char *opname;\n+    register const char *opname;\n     register int suffix;\n {\n   init_libfuncs (optable, SImode, TImode, opname, suffix);\n@@ -4137,7 +4140,7 @@ init_integral_libfuncs (optable, opname, suffix)\n static void\n init_floating_libfuncs (optable, opname, suffix)\n     register optab optable;\n-    register char *opname;\n+    register const char *opname;\n     register int suffix;\n {\n   init_libfuncs (optable, SFmode, TFmode, opname, suffix);"}, {"sha": "e6a15fed515a9608af25050cd48b4f8a15e82847", "filename": "gcc/real.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -414,12 +414,12 @@ static void e64toasc\tPROTO((unsigned EMUSHORT *, char *, int));\n static void e113toasc\tPROTO((unsigned EMUSHORT *, char *, int));\n #endif /* 0 */\n static void etoasc\tPROTO((unsigned EMUSHORT *, char *, int));\n-static void asctoe24\tPROTO((char *, unsigned EMUSHORT *));\n-static void asctoe53\tPROTO((char *, unsigned EMUSHORT *));\n-static void asctoe64\tPROTO((char *, unsigned EMUSHORT *));\n-static void asctoe113\tPROTO((char *, unsigned EMUSHORT *));\n-static void asctoe\tPROTO((char *, unsigned EMUSHORT *));\n-static void asctoeg\tPROTO((char *, unsigned EMUSHORT *, int));\n+static void asctoe24\tPROTO((const char *, unsigned EMUSHORT *));\n+static void asctoe53\tPROTO((const char *, unsigned EMUSHORT *));\n+static void asctoe64\tPROTO((const char *, unsigned EMUSHORT *));\n+static void asctoe113\tPROTO((const char *, unsigned EMUSHORT *));\n+static void asctoe\tPROTO((const char *, unsigned EMUSHORT *));\n+static void asctoeg\tPROTO((const char *, unsigned EMUSHORT *, int));\n static void efloor\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n #if 0\n static void efrexp\tPROTO((unsigned EMUSHORT *, int *,\n@@ -431,7 +431,7 @@ static void eremain\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *,\n \t\t\t       unsigned EMUSHORT *));\n #endif\n static void eiremain\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n-static void mtherr\tPROTO((char *, int));\n+static void mtherr\tPROTO((const char *, int));\n #ifdef DEC\n static void dectoe\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n static void etodec\tPROTO((unsigned EMUSHORT *, unsigned EMUSHORT *));\n@@ -691,7 +691,7 @@ etruncui (x)\n \n REAL_VALUE_TYPE\n ereal_atof (s, t)\n-     char *s;\n+     const char *s;\n      enum machine_mode t;\n {\n   unsigned EMUSHORT tem[NE], e[NE];\n@@ -5006,7 +5006,7 @@ etoasc (x, string, ndigs)\n \n static void\n asctoe24 (s, y)\n-     char *s;\n+     const char *s;\n      unsigned EMUSHORT *y;\n {\n   asctoeg (s, y, 24);\n@@ -5017,7 +5017,7 @@ asctoe24 (s, y)\n \n static void\n asctoe53 (s, y)\n-     char *s;\n+     const char *s;\n      unsigned EMUSHORT *y;\n {\n #if defined(DEC) || defined(IBM)\n@@ -5036,7 +5036,7 @@ asctoe53 (s, y)\n \n static void\n asctoe64 (s, y)\n-     char *s;\n+     const char *s;\n      unsigned EMUSHORT *y;\n {\n   asctoeg (s, y, 64);\n@@ -5046,7 +5046,7 @@ asctoe64 (s, y)\n \n static void\n asctoe113 (s, y)\n-     char *s;\n+     const char *s;\n      unsigned EMUSHORT *y;\n {\n   asctoeg (s, y, 113);\n@@ -5056,7 +5056,7 @@ asctoe113 (s, y)\n \n static void\n asctoe (s, y)\n-     char *s;\n+     const char *s;\n      unsigned EMUSHORT *y;\n {\n   asctoeg (s, y, NBITS);\n@@ -5067,7 +5067,7 @@ asctoe (s, y)\n \n static void\n asctoeg (ss, y, oprec)\n-     char *ss;\n+     const char *ss;\n      unsigned EMUSHORT *y;\n      int oprec;\n {\n@@ -5082,12 +5082,11 @@ asctoeg (ss, y, oprec)\n   /* Copy the input string.  */\n   lstr = (char *) alloca (strlen (ss) + 1);\n \n-  s = ss;\n-  while (*s == ' ')\t\t/* skip leading spaces */\n-    ++s;\n+  while (*ss == ' ')\t\t/* skip leading spaces */\n+    ++ss;\n \n   sp = lstr;\n-  while ((*sp++ = *s++) != '\\0')\n+  while ((*sp++ = *ss++) != '\\0')\n     ;\n   s = lstr;\n \n@@ -5664,7 +5663,7 @@ extern int merror;\n \n static void\n mtherr (name, code)\n-     char *name;\n+     const char *name;\n      int code;\n {\n   /* The string passed by the calling program is supposed to be the"}, {"sha": "f289379efd8329fd0784f571abb56e00eacb113a", "filename": "gcc/real.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of floating-point access for GNU compiler.\n-   Copyright (C) 1989, 91, 94, 96, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 91, 94, 96-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -132,7 +132,7 @@ extern void earith\t\tPROTO((REAL_VALUE_TYPE *, int,\n \t\t\t\t       REAL_VALUE_TYPE *, REAL_VALUE_TYPE *));\n extern REAL_VALUE_TYPE etrunci\tPROTO((REAL_VALUE_TYPE));\n extern REAL_VALUE_TYPE etruncui\tPROTO((REAL_VALUE_TYPE));\n-extern REAL_VALUE_TYPE ereal_atof PROTO((char *, enum machine_mode));\n+extern REAL_VALUE_TYPE ereal_atof PROTO((const char *, enum machine_mode));\n extern REAL_VALUE_TYPE ereal_negate PROTO((REAL_VALUE_TYPE));\n extern HOST_WIDE_INT efixi\tPROTO((REAL_VALUE_TYPE));\n extern unsigned HOST_WIDE_INT efixui PROTO((REAL_VALUE_TYPE));"}, {"sha": "2a4179223004a1be2818d988471de8aa01720556", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -454,7 +454,7 @@ dump_sbitmap (file, bmap)\n void\n dump_sbitmap_vector (file, title, subtitle, bmaps, n_maps)\n      FILE *file;\n-     char *title, *subtitle;\n+     const char *title, *subtitle;\n      sbitmap *bmaps;\n      int n_maps;\n {"}, {"sha": "ca475fa756c505262ac28870aaf1e9878b00590c", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -90,7 +90,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define sbitmap_vector_free(vec)\tfree(vec)\n \n extern void dump_sbitmap PROTO ((FILE *, sbitmap));\n-extern void dump_sbitmap_vector PROTO ((FILE *, char *, char *,\n+extern void dump_sbitmap_vector PROTO ((FILE *, const char *, const char *,\n \t\t\t\t\tsbitmap *, int));\n \n extern sbitmap sbitmap_alloc PROTO ((int));"}, {"sha": "15ac541c7fe84e38c776a2a7c5472002c3a94160", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -306,7 +306,7 @@ struct nesting\n \t  /* Number of range exprs in case statement.  */\n \t  int num_ranges;\n \t  /* Name of this kind of statement, for warnings.  */\n-\t  char *printname;\n+\t  const char *printname;\n \t  /* Used to save no_line_numbers till we see the first case label.\n \t     We set this to -1 when we see the first case label in this\n \t     case statement.  */\n@@ -425,7 +425,7 @@ struct label_chain\n static int using_eh_for_cleanups_p = 0;\n \n \n-static int n_occurrences\t\tPROTO((int, char *));\n+static int n_occurrences\t\tPROTO((int, const char *));\n static void expand_goto_internal\tPROTO((tree, rtx, rtx));\n static int expand_fixup\t\t\tPROTO((tree, rtx, rtx));\n static rtx expand_nl_handler_label\tPROTO((rtx, rtx));\n@@ -1120,7 +1120,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n static int\n n_occurrences (c, s)\n      int c;\n-     char *s;\n+     const char *s;\n {\n   int n = 0;\n   while (*s)\n@@ -4172,7 +4172,7 @@ expand_start_case (exit_flag, expr, type, printname)\n      int exit_flag;\n      tree expr;\n      tree type;\n-     char *printname;\n+     const char *printname;\n {\n   register struct nesting *thiscase = ALLOC_NESTING ();\n "}, {"sha": "c6dc50fcd44c4fa3e0b3de3bb1ffb22e5d972234", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -3497,7 +3497,7 @@ rest_of_compilation (decl)\n   if (DECL_SAVED_INSNS (decl) == 0)\n     {\n       int inlinable = 0;\n-      char *lose;\n+      const char *lose;\n \n       /* If requested, consider whether to make this function inline.  */\n       if (DECL_INLINE (decl) || flag_inline_functions)"}, {"sha": "e91902f46dfa984d4fb3211360609a8bc06328ab", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dff01034e5a90c29e68d9aa436cbef7ef2268035/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dff01034e5a90c29e68d9aa436cbef7ef2268035", "patch": "@@ -1805,7 +1805,7 @@ extern tree decl_type_context\t\tPROTO((tree));\n    Otherwise return a warning message with a single %s\n    for the function's name.  */\n \n-extern char *function_cannot_inline_p \tPROTO((tree));\n+extern const char *function_cannot_inline_p \tPROTO((tree));\n \n /* Return 1 if EXPR is the real constant zero.  */\n extern int real_zerop PROTO((tree));\n@@ -1946,7 +1946,7 @@ extern tree last_cleanup_this_contour\t\tPROTO((void));\n extern int expand_dhc_cleanup\t\t\tPROTO((tree));\n extern int expand_dcc_cleanup\t\t\tPROTO((tree));\n extern void expand_start_case\t\t\tPROTO((int, tree, tree,\n-\t\t\t\t\t\t       char *));\n+\t\t\t\t\t\t       const char *));\n extern void expand_end_case\t\t\tPROTO((tree));\n extern int pushcase\t\t\t\tPROTO((tree,\n \t\t\t\t\t\t       tree (*) (tree, tree),"}]}