{"sha": "b010117a6c6ee5bc80e0b7d57df2533d2c813763", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAxMDExN2E2YzZlZTViYzgwZTBiN2Q1N2RmMjUzM2QyYzgxMzc2Mw==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-05-18T11:27:51Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-05-18T11:27:51Z"}, "message": "re PR tree-optimization/41881 (Complete unrolling (inner) versus vectorization of reduction)\n\n\n\n        PR tree-optimization/41881\n        * tree-vectorizer.h (struct _loop_vec_info): Add new field\n        reduction_chains along with a macro for its access.\n        * tree-vect-loop.c (new_loop_vec_info): Initialize\n        reduction chains.\n        (destroy_loop_vec_info): Free reduction chains.\n        (vect_analyze_loop_2): Return false if\n        vect_analyze_slp() returns false.\n        (vect_is_slp_reduction): New function.\n        (vect_is_simple_reduction_1): Call\n        vect_is_slp_reduction.\n        (vect_create_epilog_for_reduction): Support SLP\n        reduction chains.\n        * tree-vect-slp.c (vect_get_and_check_slp_defs): Allow\n        different definition types for reduction chains.\n        (vect_supported_load_permutation_p): Don't allow\n        permutations for reduction chains.\n        (vect_analyze_slp_instance): Support reduction chains.\n        (vect_analyze_slp): Try to build SLP instance from\n        reduction chains.\n        (vect_get_constant_vectors):  Handle reduction chains.\n        (vect_schedule_slp_instance): Mark the first statement\n        of the reduction chain as reduction.\n\nFrom-SVN: r173856", "tree": {"sha": "63d6259a36cf4a5e8b5a741f419adf748426312f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63d6259a36cf4a5e8b5a741f419adf748426312f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b010117a6c6ee5bc80e0b7d57df2533d2c813763", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b010117a6c6ee5bc80e0b7d57df2533d2c813763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b010117a6c6ee5bc80e0b7d57df2533d2c813763", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b010117a6c6ee5bc80e0b7d57df2533d2c813763/comments", "author": null, "committer": null, "parents": [{"sha": "e14c1050008ecece4bff253a54eac0f15a6467bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14c1050008ecece4bff253a54eac0f15a6467bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e14c1050008ecece4bff253a54eac0f15a6467bb"}], "stats": {"total": 465, "additions": 410, "deletions": 55}, "files": [{"sha": "86d68134300a6c4dd3b573b2d6d861278408c50d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -1,3 +1,24 @@\n+2011-05-18  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/41881\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add new field\n+\treduction_chains along with a macro for its access.\n+\t* tree-vect-loop.c (new_loop_vec_info): Initialize reduction chains.\n+\t(destroy_loop_vec_info): Free reduction chains.\n+\t(vect_analyze_loop_2): Return false if vect_analyze_slp() returns false.\n+\t(vect_is_slp_reduction): New function.\n+\t(vect_is_simple_reduction_1): Call vect_is_slp_reduction.\n+\t(vect_create_epilog_for_reduction): Support SLP reduction chains.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Allow different\n+\tdefinition types for reduction chains.\n+\t(vect_supported_load_permutation_p): Don't allow permutations for\n+\treduction chains.\n+\t(vect_analyze_slp_instance): Support reduction chains.\n+\t(vect_analyze_slp): Try to build SLP instance from reduction chains.\n+\t(vect_get_constant_vectors):  Handle reduction chains.\n+\t(vect_schedule_slp_instance): Mark the first statement of the\n+\treduction chain as reduction.\n+\n 2011-05-18  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Use new"}, {"sha": "d2f848ddf05b28f7395df7b8f658c7de723ff42b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -1,3 +1,9 @@\n+2011-05-18  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/41881\n+\t* gcc.dg/vect/O3-pr41881.c: New test.\n+\t* gcc.dg/vect/O3-slp-reduc-10.c: New test.\n+\n 2011-05-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/49000"}, {"sha": "7180b4c2a92db8ca91d37ffc12690c780eb845e3", "filename": "gcc/testsuite/gcc.dg/vect/O3-pr41881.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2FO3-pr41881.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2FO3-pr41881.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2FO3-pr41881.c?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+\n+#define TYPE int\n+\n+TYPE fun1(TYPE *x, TYPE *y, unsigned int n)\n+{\n+  int i, j;\n+  TYPE dot = 0;\n+\n+  for (i = 0; i < n; i++)\n+    dot += *(x++) * *(y++);\n+\n+  return dot;\n+}\n+\n+TYPE fun2(TYPE *x, TYPE *y, unsigned int n)\n+{\n+  int i, j;\n+  TYPE dot = 0;\n+\n+  for (i = 0; i < n / 8; i++)\n+    for (j = 0; j < 8; j++)\n+      dot += *(x++) * *(y++);\n+\n+  return dot;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { vect_int_mult && {! vect_no_align } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "a35d90b3a0052737d1056af81e9e23a3e2859225", "filename": "gcc/testsuite/gcc.dg/vect/O3-slp-reduc-10.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2FO3-slp-reduc-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2FO3-slp-reduc-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2FO3-slp-reduc-10.c?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+#define TYPE int\n+#define RESULT 755918\n+\n+__attribute__ ((noinline)) TYPE fun2 (TYPE *x, TYPE *y, unsigned int n)\n+{\n+  int i, j;\n+  TYPE dot = 14;\n+\n+  for (i = 0; i < n / 2; i++)\n+    for (j = 0; j < 2; j++)\n+      dot += *(x++) * *(y++);\n+\n+  return dot;\n+}\n+\n+int main (void)\n+{\n+  TYPE a[N], b[N], dot;\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i+8;\n+    }\n+\n+  dot = fun2 (a, b, N);\n+  if (dot != RESULT)\n+    abort();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { vect_int_mult && {! vect_no_align } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9942ebe815189d4ef232d2e04cd1c96f63c31985", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 237, "deletions": 30, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -757,6 +757,7 @@ new_loop_vec_info (struct loop *loop)\n                PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n   LOOP_VINFO_STRIDED_STORES (res) = VEC_alloc (gimple, heap, 10);\n   LOOP_VINFO_REDUCTIONS (res) = VEC_alloc (gimple, heap, 10);\n+  LOOP_VINFO_REDUCTION_CHAINS (res) = VEC_alloc (gimple, heap, 10);\n   LOOP_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 10);\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n   LOOP_VINFO_PEELING_HTAB (res) = NULL;\n@@ -852,6 +853,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   VEC_free (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n   VEC_free (gimple, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo));\n   VEC_free (gimple, heap, LOOP_VINFO_REDUCTIONS (loop_vinfo));\n+  VEC_free (gimple, heap, LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo));\n \n   if (LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n     htab_delete (LOOP_VINFO_PEELING_HTAB (loop_vinfo));\n@@ -1541,6 +1543,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       /* Find stmts that need to be both vectorized and SLPed.  */\n       vect_detect_hybrid_slp (loop_vinfo);\n     }\n+  else\n+    return false;\n \n   /* Scan all the operations in the loop and make sure they are\n      vectorizable.  */\n@@ -1673,6 +1677,134 @@ report_vect_op (gimple stmt, const char *msg)\n }\n \n \n+/* Detect SLP reduction of the form:\n+\n+   #a1 = phi <a5, a0>\n+   a2 = operation (a1)\n+   a3 = operation (a2)\n+   a4 = operation (a3)\n+   a5 = operation (a4)\n+\n+   #a = phi <a5>\n+\n+   PHI is the reduction phi node (#a1 = phi <a5, a0> above)\n+   FIRST_STMT is the first reduction stmt in the chain\n+   (a2 = operation (a1)).\n+\n+   Return TRUE if a reduction chain was detected.  */\n+\n+static bool\n+vect_is_slp_reduction (loop_vec_info loop_info, gimple phi, gimple first_stmt)\n+{\n+  struct loop *loop = (gimple_bb (phi))->loop_father;\n+  struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n+  enum tree_code code;\n+  gimple current_stmt = NULL, use_stmt = NULL, first;\n+  stmt_vec_info use_stmt_info, current_stmt_info;\n+  tree lhs;\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  int nloop_uses, size = 0;\n+  bool found = false;\n+\n+  if (loop != vect_loop)\n+    return false;\n+\n+  lhs = PHI_RESULT (phi);\n+  code = gimple_assign_rhs_code (first_stmt);\n+  while (1)\n+    {\n+      nloop_uses = 0;\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+        {\n+          use_stmt = USE_STMT (use_p);\n+          if (is_gimple_debug (use_stmt))\n+            continue;\n+\n+          /* Check if we got back to the reduction phi.  */\n+          if (gimple_code (use_stmt) == GIMPLE_PHI\n+              && use_stmt == phi)\n+            {\n+              found = true;\n+              break;\n+            }\n+\n+          if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))\n+              && vinfo_for_stmt (use_stmt)\n+              && !is_pattern_stmt_p (vinfo_for_stmt (use_stmt))\n+              && use_stmt != first_stmt)\n+            nloop_uses++;\n+\n+          if (nloop_uses > 1)\n+            return false;\n+        }\n+\n+      if (found)\n+        break;\n+\n+      /* This is a loop exit phi, and we haven't reached the reduction phi.  */\n+      if (gimple_code (use_stmt) == GIMPLE_PHI)\n+        return false;\n+\n+      if (!is_gimple_assign (use_stmt)\n+          || code != gimple_assign_rhs_code (use_stmt)\n+          || !flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+        return false;\n+\n+      /* Insert USE_STMT into reduction chain.  */\n+      use_stmt_info = vinfo_for_stmt (use_stmt);\n+      if (current_stmt)\n+        {\n+          current_stmt_info = vinfo_for_stmt (current_stmt);\n+          GROUP_NEXT_ELEMENT (current_stmt_info) = use_stmt;\n+          GROUP_FIRST_ELEMENT (use_stmt_info)\n+            = GROUP_FIRST_ELEMENT (current_stmt_info);\n+        }\n+      else\n+          GROUP_FIRST_ELEMENT (use_stmt_info) = use_stmt;\n+\n+      lhs = gimple_assign_lhs (use_stmt);\n+      current_stmt = use_stmt;\n+      size++;\n+   }\n+\n+  if (!found || use_stmt != phi || size < 2)\n+    return false;\n+\n+  /* Save the chain for further analysis in SLP detection.  */\n+  first = GROUP_FIRST_ELEMENT (vinfo_for_stmt (current_stmt));\n+  VEC_safe_push (gimple, heap, LOOP_VINFO_REDUCTION_CHAINS (loop_info), first);\n+  GROUP_SIZE (vinfo_for_stmt (first)) = size;\n+\n+  /* Swap the operands, if needed, to make the reduction operand be the second\n+     operand.  */\n+  lhs = PHI_RESULT (phi);\n+  current_stmt = first;\n+  while (current_stmt)\n+    {\n+      if (get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS\n+          && gimple_assign_rhs2 (current_stmt) != lhs)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"swapping oprnds: \");\n+              print_gimple_stmt (vect_dump, current_stmt, 0, TDF_SLIM);\n+            }\n+\n+          swap_tree_operands (current_stmt,\n+\t\t\t      gimple_assign_rhs1_ptr (current_stmt),\n+                              gimple_assign_rhs2_ptr (current_stmt));\n+          mark_symbols_for_renaming (current_stmt);\n+        }\n+\n+      lhs = gimple_assign_lhs (current_stmt);\n+      current_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (current_stmt));\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Function vect_is_simple_reduction_1\n \n    (1) Detect a cross-iteration def-use cycle that represents a simple\n@@ -2033,17 +2165,18 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \treport_vect_op (def_stmt, \"detected reduction: \");\n       return def_stmt;\n     }\n-  else if (def1 && def1 == phi\n-\t   && (code == COND_EXPR\n-               || (def2 && flow_bb_inside_loop_p (loop, gimple_bb (def2))\n- \t           && (is_gimple_assign (def2)\n-\t\t       || is_gimple_call (def2)\n-\t               || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n-                           == vect_induction_def\n- \t               || (gimple_code (def2) == GIMPLE_PHI\n-\t\t           && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n-                               == vect_internal_def\n-\t\t           && !is_loop_header_bb_p (gimple_bb (def2)))))))\n+\n+  if (def1 && def1 == phi\n+      && (code == COND_EXPR\n+          || (def2 && flow_bb_inside_loop_p (loop, gimple_bb (def2))\n+ \t      && (is_gimple_assign (def2)\n+\t\t  || is_gimple_call (def2)\n+\t          || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n+                      == vect_induction_def\n+ \t          || (gimple_code (def2) == GIMPLE_PHI\n+\t\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2))\n+                          == vect_internal_def\n+\t\t      && !is_loop_header_bb_p (gimple_bb (def2)))))))\n     {\n       if (check_reduction)\n         {\n@@ -2065,13 +2198,20 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       return def_stmt;\n     }\n-  else\n+\n+  /* Try to find SLP reduction chain.  */\n+  if (vect_is_slp_reduction (loop_info, phi, def_stmt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\treport_vect_op (def_stmt, \"reduction: unknown pattern: \");\n+        report_vect_op (def_stmt, \"reduction: detected reduction chain: \");\n \n-      return NULL;\n+      return def_stmt;\n     }\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    report_vect_op (def_stmt, \"reduction: unknown pattern: \");\n+       \n+  return NULL;\n }\n \n /* Wrapper around vect_is_simple_reduction_1, that won't modify code\n@@ -2855,7 +2995,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \t\t\t\t\t\t   vec_def, vec_step);\n \t  vec_def = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, vec_def);\n-\n+ \n \t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n \t  if (!useless_type_conversion_p (resvectype, vectype))\n \t    {\n@@ -3216,6 +3356,8 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n   unsigned int group_size = 1, k, ratio;\n   VEC (tree, heap) *vec_initial_defs = NULL;\n   VEC (gimple, heap) *phis;\n+  bool slp_reduc = false;\n+  tree new_phi_result;\n \n   if (slp_node)\n     group_size = VEC_length (gimple, SLP_TREE_SCALAR_STMTS (slp_node)); \n@@ -3425,10 +3567,48 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n   if (nested_in_vect_loop && !double_reduc)\n     goto vect_finalize_reduction;\n \n+  /* SLP reduction without reduction chain, e.g.,\n+     # a1 = phi <a2, a0>\n+     # b1 = phi <b2, b0>\n+     a2 = operation (a1)\n+     b2 = operation (b1)  */\n+  slp_reduc = (slp_node && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n+\n+  /* In case of reduction chain, e.g.,\n+     # a1 = phi <a3, a0>\n+     a2 = operation (a1)\n+     a3 = operation (a2),\n+\n+     we may end up with more than one vector result.  Here we reduce them to\n+     one vector.  */\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    {\n+      tree first_vect = PHI_RESULT (VEC_index (gimple, new_phis, 0));\n+      tree tmp;\n+\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      for (k = 1; k < VEC_length (gimple, new_phis); k++)\n+        {\n+          gimple next_phi = VEC_index (gimple, new_phis, k);\n+          tree second_vect = PHI_RESULT (next_phi);\n+          gimple new_vec_stmt;\n+\n+          tmp = build2 (code, vectype,  first_vect, second_vect);\n+          new_vec_stmt = gimple_build_assign (vec_dest, tmp);\n+          first_vect = make_ssa_name (vec_dest, new_vec_stmt);\n+          gimple_assign_set_lhs (new_vec_stmt, first_vect);\n+          gsi_insert_before (&exit_gsi, new_vec_stmt, GSI_SAME_STMT);\n+        }\n+\n+      new_phi_result = first_vect;\n+    }\n+  else\n+    new_phi_result = PHI_RESULT (VEC_index (gimple, new_phis, 0));\n+ \n   /* 2.3 Create the reduction code, using one of the three schemes described\n          above. In SLP we simply need to extract all the elements from the \n          vector (without reducing them), so we use scalar shifts.  */\n-  if (reduc_code != ERROR_MARK && !slp_node)\n+  if (reduc_code != ERROR_MARK && !slp_reduc)\n     {\n       tree tmp;\n \n@@ -3439,8 +3619,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n         fprintf (vect_dump, \"Reduce using direct vector reduction.\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      new_phi = VEC_index (gimple, new_phis, 0);\n-      tmp = build1 (reduc_code, vectype,  PHI_RESULT (new_phi));\n+      tmp = build1 (reduc_code, vectype, new_phi_result);\n       epilog_stmt = gimple_build_assign (vec_dest, tmp);\n       new_temp = make_ssa_name (vec_dest, epilog_stmt);\n       gimple_assign_set_lhs (epilog_stmt, new_temp);\n@@ -3477,7 +3656,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n             have_whole_vector_shift = false;\n         }\n \n-      if (have_whole_vector_shift && !slp_node)\n+      if (have_whole_vector_shift && !slp_reduc)\n         {\n           /*** Case 2: Create:\n              for (offset = VS/2; offset >= element_size; offset/=2)\n@@ -3490,8 +3669,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n             fprintf (vect_dump, \"Reduce using vector shifts\");\n \n           vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-          new_phi = VEC_index (gimple, new_phis, 0);\n-          new_temp = PHI_RESULT (new_phi);\n+          new_temp = new_phi_result;\n           for (bit_offset = vec_size_in_bits/2;\n                bit_offset >= element_bitsize;\n                bit_offset /= 2)\n@@ -3543,7 +3721,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n               /* In SLP we don't need to apply reduction operation, so we just\n                  collect s' values in SCALAR_RESULTS.  */\n-              if (slp_node)\n+              if (slp_reduc)\n                 VEC_safe_push (tree, heap, scalar_results, new_temp);\n \n               for (bit_offset = element_bitsize;\n@@ -3559,7 +3737,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                   gimple_assign_set_lhs (epilog_stmt, new_name);\n                   gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \n-                  if (slp_node)\n+                  if (slp_reduc)\n                     {\n                       /* In SLP we don't need to apply reduction operation, so \n                          we just collect s' values in SCALAR_RESULTS.  */\n@@ -3581,7 +3759,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n              unrolling.  If the size of SCALAR_RESULTS is greater than\n              GROUP_SIZE, we reduce them combining elements modulo \n              GROUP_SIZE.  */\n-          if (slp_node)\n+          if (slp_reduc)\n             {\n               tree res, first_res, new_res;\n               gimple new_stmt;\n@@ -3644,7 +3822,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n   if (adjustment_def)\n     {\n-      gcc_assert (!slp_node);\n+      gcc_assert (!slp_reduc);\n       if (nested_in_vect_loop)\n \t{\n           new_phi = VEC_index (gimple, new_phis, 0);\n@@ -3709,6 +3887,19 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n           use <s_out4>  \n           use <s_out4> */\n \n+\n+  /* In SLP reduction chain we reduce vector results into one vector if\n+     necessary, hence we set here GROUP_SIZE to 1.  SCALAR_DEST is the LHS of\n+     the last stmt in the reduction chain, since we are looking for the loop\n+     exit phi node.  */\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    {\n+      scalar_dest = gimple_assign_lhs (VEC_index (gimple,\n+                                       SLP_TREE_SCALAR_STMTS (slp_node),\n+                                       group_size - 1));\n+      group_size = 1;\n+    }\n+\n   /* In SLP we may have several statements in NEW_PHIS and REDUCTION_PHIS (in \n      case that GROUP_SIZE is greater than vectorization factor).  Therefore, we\n      need to match SCALAR_RESULTS with corresponding statements.  The first\n@@ -3731,7 +3922,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n           reduction_phi = VEC_index (gimple, reduction_phis, k / ratio);\n         }\n \n-      if (slp_node)\n+      if (slp_reduc)\n         {\n           gimple current_stmt = VEC_index (gimple,\n                                        SLP_TREE_SCALAR_STMTS (slp_node), k);\n@@ -4000,6 +4191,12 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   int vec_num;\n   tree def0, def1, tem;\n \n+  /* In case of reduction chain we switch to the first stmt in the chain, but\n+     we don't update STMT_INFO, since only the last stmt is marked as reduction\n+     and has reduction properties.  */\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+\n   if (nested_in_vect_loop_p (loop, stmt))\n     {\n       outer_loop = loop;\n@@ -4008,8 +4205,10 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* 1. Is vectorizable reduction?  */\n-  /* Not supportable if the reduction variable is used in the loop.  */\n-  if (STMT_VINFO_RELEVANT (stmt_info) > vect_used_in_outer)\n+  /* Not supportable if the reduction variable is used in the loop, unless\n+     it's a reduction chain.  */\n+  if (STMT_VINFO_RELEVANT (stmt_info) > vect_used_in_outer\n+      && !GROUP_FIRST_ELEMENT (stmt_info))\n     return false;\n \n   /* Reductions that are not used even in an enclosing outer-loop,\n@@ -4107,6 +4306,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       if (!vectype_in)\n \tvectype_in = tem;\n       gcc_assert (is_simple_use);\n+\n       if (dt != vect_internal_def\n \t  && dt != vect_external_def\n \t  && dt != vect_constant_def\n@@ -4142,8 +4342,14 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n                                                        !nested_cycle,\n                                                        &dummy));\n   else\n-    gcc_assert (stmt == vect_is_simple_reduction (loop_vinfo, reduc_def_stmt,\n-                                                  !nested_cycle, &dummy));\n+    {\n+      gimple tmp = vect_is_simple_reduction (loop_vinfo, reduc_def_stmt,\n+                                             !nested_cycle, &dummy);\n+      /* We changed STMT to be the first stmt in reduction chain, hence we\n+         check that in this case the first element in the chain is STMT.  */\n+      gcc_assert (stmt == tmp\n+                  || GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == stmt);\n+    }\n \n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n@@ -4505,6 +4711,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           new_temp = make_ssa_name (vec_dest, new_stmt);\n           gimple_assign_set_lhs (new_stmt, new_temp);\n           vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n           if (slp_node)\n             {\n               VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);"}, {"sha": "b060935971edae32c4f8239d9c688eb462f4942c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 68, "deletions": 25, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -244,14 +244,21 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  else\n \t    {\n \t      /* Not first stmt of the group, check that the def-stmt/s match\n-\t\t the def-stmt/s of the first stmt.  */\n+\t\t the def-stmt/s of the first stmt.  Allow different definition\n+\t\t types for reduction chains: the first stmt must be a\n+\t\t vect_reduction_def (a phi node), and the rest\n+\t\t vect_internal_def.  */\n \t      if ((i == 0\n-\t\t   && (*first_stmt_dt0 != dt[i]\n+\t\t   && ((*first_stmt_dt0 != dt[i]\n+                        && !(*first_stmt_dt0 == vect_reduction_def\n+                             && dt[i] == vect_internal_def))\n \t\t       || (*first_stmt_def0_type && def\n \t\t\t   && !types_compatible_p (*first_stmt_def0_type,\n \t\t\t\t\t\t   TREE_TYPE (def)))))\n \t\t  || (i == 1\n-\t\t      && (*first_stmt_dt1 != dt[i]\n+\t\t      && ((*first_stmt_dt1 != dt[i]\n+                           && !(*first_stmt_dt1 == vect_reduction_def\n+                                && dt[i] == vect_internal_def))\n \t\t\t  || (*first_stmt_def1_type && def\n \t\t\t      && !types_compatible_p (*first_stmt_def1_type,\n \t\t\t\t\t\t      TREE_TYPE (def)))))\n@@ -974,8 +981,10 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n      GROUP_SIZE.  */\n   number_of_groups = VEC_length (int, load_permutation) / group_size;\n \n-  /* Reduction (there are no data-refs in the root).  */\n-  if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))\n+  /* Reduction (there are no data-refs in the root).\n+     In reduction chain the order of the loads is important.  */\n+  if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))\n+      && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       int first_group_load_index;\n \n@@ -1153,10 +1162,19 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   VEC (slp_tree, heap) *loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n \n-  if (dr)\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n-      scalar_type = TREE_TYPE (DR_REF (dr));\n-      vectype = get_vectype_for_scalar_type (scalar_type);\n+      if (dr)\n+        {\n+          scalar_type = TREE_TYPE (DR_REF (dr));\n+          vectype = get_vectype_for_scalar_type (scalar_type);\n+        }\n+      else\n+        {\n+          gcc_assert (loop_vinfo);\n+          vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+        }\n+\n       group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n     }\n   else\n@@ -1198,7 +1216,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Create a node (a root of the SLP tree) for the packed strided stores.  */\n   SLP_TREE_SCALAR_STMTS (node) = VEC_alloc (gimple, heap, group_size);\n   next = stmt;\n-  if (dr)\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n       while (next)\n@@ -1213,14 +1231,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       for (i = 0; VEC_iterate (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, \n                                next); \n            i++)\n-        {\n-          VEC_safe_push (gimple, heap, SLP_TREE_SCALAR_STMTS (node), next);\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"pushing reduction into node: \");\n-              print_gimple_stmt (vect_dump, next, 0, TDF_SLIM);\n-            }\n-        }\n+        VEC_safe_push (gimple, heap, SLP_TREE_SCALAR_STMTS (node), next);\n     }\n \n   SLP_TREE_VEC_STMTS (node) = NULL;\n@@ -1313,8 +1324,8 @@ bool\n vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n   unsigned int i;\n-  VEC (gimple, heap) *strided_stores, *reductions = NULL;\n-  gimple store;\n+  VEC (gimple, heap) *strided_stores, *reductions = NULL, *reduc_chains = NULL;\n+  gimple first_element;\n   bool ok = false;\n \n   if (vect_print_dump_info (REPORT_SLP))\n@@ -1323,14 +1334,15 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   if (loop_vinfo)\n     {\n       strided_stores = LOOP_VINFO_STRIDED_STORES (loop_vinfo);\n+      reduc_chains = LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo);\n       reductions = LOOP_VINFO_REDUCTIONS (loop_vinfo);\n     }\n   else\n     strided_stores = BB_VINFO_STRIDED_STORES (bb_vinfo);\n \n   /* Find SLP sequences starting from groups of strided stores.  */\n-  FOR_EACH_VEC_ELT (gimple, strided_stores, i, store)\n-    if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, store))\n+  FOR_EACH_VEC_ELT (gimple, strided_stores, i, first_element)\n+    if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element))\n       ok = true;\n \n   if (bb_vinfo && !ok)\n@@ -1341,6 +1353,21 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       return false;\n     }\n \n+  if (loop_vinfo\n+      && VEC_length (gimple, LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo)) > 0)\n+    {\n+      /* Find SLP sequences starting from reduction chains.  */\n+      FOR_EACH_VEC_ELT (gimple, reduc_chains, i, first_element)\n+        if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element))\n+          ok = true;\n+        else\n+          return false;\n+\n+      /* Don't try to vectorize SLP reductions if reduction chain was\n+         detected.  */\n+      return ok;\n+    }\n+\n   /* Find SLP sequences starting from groups of reductions.  */\n   if (loop_vinfo && VEC_length (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo)) > 1\n       && vect_analyze_slp_instance (loop_vinfo, bb_vinfo, \n@@ -1972,11 +1999,17 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n               gimple def_stmt = SSA_NAME_DEF_STMT (op);\n \n               gcc_assert (loop);\n-              /* Get the def before the loop.  */\n-              op = PHI_ARG_DEF_FROM_EDGE (def_stmt, \n-                                          loop_preheader_edge (loop));\n-              if (j != (number_of_copies - 1) && neutral_op)\n+\n+              /* Get the def before the loop.  In reduction chain we have only\n+                 one initial value.  */\n+              if ((j != (number_of_copies - 1)\n+                   || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+                       && i != 0))\n+                  && neutral_op)\n                 op = neutral_op;\n+              else\n+                op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n+                                            loop_preheader_edge (loop));\n             }\n \n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n@@ -2524,6 +2557,16 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       si = gsi_for_stmt (last_store);\n     }\n \n+  /* Mark the first element of the reduction chain as reduction to properly\n+     transform the node.  In the analysis phase only the last element of the\n+     chain is marked as reduction.  */\n+  if (GROUP_FIRST_ELEMENT (stmt_info) && !STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+      && GROUP_FIRST_ELEMENT (stmt_info) == stmt)\n+    {\n+      STMT_VINFO_DEF_TYPE (stmt_info) = vect_reduction_def;\n+      STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+    }\n+\n   is_store = vect_transform_stmt (stmt, &si, &strided_store, node, instance);\n   return is_store;\n }"}, {"sha": "a0aed8c849de2882c16257a6e507da455ba68f37", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b010117a6c6ee5bc80e0b7d57df2533d2c813763/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b010117a6c6ee5bc80e0b7d57df2533d2c813763", "patch": "@@ -248,6 +248,10 @@ typedef struct _loop_vec_info {\n   /* Reduction cycles detected in the loop. Used in loop-aware SLP.  */\n   VEC (gimple, heap) *reductions;\n \n+  /* All reduction chains in the loop, represented by the first\n+     stmt in the chain.  */\n+  VEC (gimple, heap) *reduction_chains;\n+\n   /* Hash table used to choose the best peeling option.  */\n   htab_t peeling_htab;\n \n@@ -277,6 +281,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_SLP_INSTANCES(L)        (L)->slp_instances\n #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor\n #define LOOP_VINFO_REDUCTIONS(L)           (L)->reductions\n+#define LOOP_VINFO_REDUCTION_CHAINS(L)     (L)->reduction_chains\n #define LOOP_VINFO_PEELING_HTAB(L)         (L)->peeling_htab\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\"}]}