{"sha": "f57aa6b04a190fdbacbe34d73b5414f44129c518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3YWE2YjA0YTE5MGZkYmFjYmUzNGQ3M2I1NDE0ZjQ0MTI5YzUxOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-26T20:32:42Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-26T20:32:42Z"}, "message": "Various scheduling strengthenings\n\ngcc/\n2014-08-26  David Malcolm  <dmalcolm@redhat.com>\n\n\t* sched-int.h (sched_init_insn_luid): Strengthen param 1 from rtx\n\tto rtx_insn *.\n\t(struct reg_use_data): Likewise for field \"insn\".\n\t(insn_cost): Likewise for param.\n\t(real_insn_for_shadow): Likewise for return type and param.\n\t(increase_insn_priority): Likewise for param 1.\n\t(debug_dependencies): Likewise for both params.\n\n\t* haifa-sched.c (insn_delay): Likewise for param \"insn\".\n\t(real_insn_for_shadow): Likewise for return type and param \"insn\".\n\t(update_insn_after_change): Likewise for param \"insn\".\n\t(recompute_todo_spec): Likewise for param \"next\" and locals \"pro\",\n\t\"other\".\n\t(insn_cost): Likewise for param \"insn\".\n\t(increase_insn_priority): Likewise.\n\t(calculate_reg_deaths): Likewise.\n\t(setup_insn_reg_pressure_info): Likewise.\n\t(model_schedule): Strengthen from vec<rtx> to vec<rtx_insn *>.\n\t(model_index): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(model_recompute): Likewise.\n\t(must_restore_pattern_p): Likewise for param \"next\".\n\t(model_excess_cost): Likewise for param \"insn\".\n\t(queue_remove): Likewise.\n\t(adjust_priority): Likewise for param \"prev\".\n\t(update_register_pressure): Likewise for param \"insn\".\n\t(setup_insn_max_reg_pressure): Likewise for local \"insn\".\n\t(update_reg_and_insn_max_reg_pressure): Likewise for param \"insn\".\n\t(model_add_to_schedule): Likewise.\n\t(model_reset_queue_indices): Likewise for local \"insn\".\n\t(unschedule_insns_until): Strengthen local \"recompute_vec\" from\n\tauto_vec<rtx> to auto_vec<rtx_insn *>.  Strengthen locals \"last\",\n\t\"con\" from rtx to rtx_insn *.\n\t(restore_last_backtrack_point): Likewise for both locals \"x\". Add\n\tchecked casts.\n\t(estimate_insn_tick): Likewise for param \"insn\".\n\t(commit_schedule): Likewise for params \"prev_head\", \"tail\" and\n\tlocal \"x\".\n\t(verify_shadows): Likewise for locals \"i1\", \"i2\".\n\t(dump_insn_stream): Likewise for params \"head\", \"tail\" and locals\n\t\"next_tail\", \"insn\".\n\t(schedule_block): Likewise for locals \"insn\", \"x\".  Add a checked\n\tcast.\n\t(fix_inter_tick): Likewise for params \"head\", \"tail\".\n\t(create_check_block_twin): Likewise for local \"jump\".\n\t(haifa_change_pattern): Likewise for param \"insn\".\n\t(haifa_speculate_insn): Likewise.\n\t(dump_new_block_header): Likewise for params \"head\", \"tail\".\n\t(fix_jump_move): Likewise for param \"jump\".\n\t(move_block_after_check): Likewise.\n\t(sched_init_insn_luid): Likewise for param \"insn\".\n\t(sched_init_luids): Likewise for local \"insn\".\n\t(insn_luid): Likewise for param \"insn\".\n\t(init_h_i_d): Likewise.\n\t(haifa_init_h_i_d): Likewise for local \"insn\".\n\t(haifa_init_insn): Likewise for param \"insn\".\n\t* sched-deps.c (add_dependence): Likewise for local \"real_pro\",\n\t\"other\".\n\t(create_insn_reg_use): Likewise for param \"insn\".\n\t(setup_insn_reg_uses): Likewise.  Add a checked cast.\n\t* sched-ebb.c (debug_ebb_dependencies): Strengthen params \"head\",\n\t\"tail\" from rtx to rtx_insn *.\n\t* sched-rgn.c (void debug_dependencies): Likewise, also for locals\n\t\"insn\", \"next_tail\".\n\nFrom-SVN: r214547", "tree": {"sha": "d3b483cb1caf90a87f24c8a17cd78d275ec1070a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3b483cb1caf90a87f24c8a17cd78d275ec1070a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57aa6b04a190fdbacbe34d73b5414f44129c518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57aa6b04a190fdbacbe34d73b5414f44129c518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57aa6b04a190fdbacbe34d73b5414f44129c518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57aa6b04a190fdbacbe34d73b5414f44129c518/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40a243d452c913fd0ac58ad39968d7993689967b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a243d452c913fd0ac58ad39968d7993689967b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40a243d452c913fd0ac58ad39968d7993689967b"}], "stats": {"total": 227, "additions": 147, "deletions": 80}, "files": [{"sha": "1a71dc5c1fb1b6f1d38c47c6740ec9dbc489bc8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f57aa6b04a190fdbacbe34d73b5414f44129c518", "patch": "@@ -1,3 +1,69 @@\n+2014-08-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* sched-int.h (sched_init_insn_luid): Strengthen param 1 from rtx\n+\tto rtx_insn *.\n+\t(struct reg_use_data): Likewise for field \"insn\".\n+\t(insn_cost): Likewise for param.\n+\t(real_insn_for_shadow): Likewise for return type and param.\n+\t(increase_insn_priority): Likewise for param 1.\n+\t(debug_dependencies): Likewise for both params.\n+\n+\t* haifa-sched.c (insn_delay): Likewise for param \"insn\".\n+\t(real_insn_for_shadow): Likewise for return type and param \"insn\".\n+\t(update_insn_after_change): Likewise for param \"insn\".\n+\t(recompute_todo_spec): Likewise for param \"next\" and locals \"pro\",\n+\t\"other\".\n+\t(insn_cost): Likewise for param \"insn\".\n+\t(increase_insn_priority): Likewise.\n+\t(calculate_reg_deaths): Likewise.\n+\t(setup_insn_reg_pressure_info): Likewise.\n+\t(model_schedule): Strengthen from vec<rtx> to vec<rtx_insn *>.\n+\t(model_index): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(model_recompute): Likewise.\n+\t(must_restore_pattern_p): Likewise for param \"next\".\n+\t(model_excess_cost): Likewise for param \"insn\".\n+\t(queue_remove): Likewise.\n+\t(adjust_priority): Likewise for param \"prev\".\n+\t(update_register_pressure): Likewise for param \"insn\".\n+\t(setup_insn_max_reg_pressure): Likewise for local \"insn\".\n+\t(update_reg_and_insn_max_reg_pressure): Likewise for param \"insn\".\n+\t(model_add_to_schedule): Likewise.\n+\t(model_reset_queue_indices): Likewise for local \"insn\".\n+\t(unschedule_insns_until): Strengthen local \"recompute_vec\" from\n+\tauto_vec<rtx> to auto_vec<rtx_insn *>.  Strengthen locals \"last\",\n+\t\"con\" from rtx to rtx_insn *.\n+\t(restore_last_backtrack_point): Likewise for both locals \"x\". Add\n+\tchecked casts.\n+\t(estimate_insn_tick): Likewise for param \"insn\".\n+\t(commit_schedule): Likewise for params \"prev_head\", \"tail\" and\n+\tlocal \"x\".\n+\t(verify_shadows): Likewise for locals \"i1\", \"i2\".\n+\t(dump_insn_stream): Likewise for params \"head\", \"tail\" and locals\n+\t\"next_tail\", \"insn\".\n+\t(schedule_block): Likewise for locals \"insn\", \"x\".  Add a checked\n+\tcast.\n+\t(fix_inter_tick): Likewise for params \"head\", \"tail\".\n+\t(create_check_block_twin): Likewise for local \"jump\".\n+\t(haifa_change_pattern): Likewise for param \"insn\".\n+\t(haifa_speculate_insn): Likewise.\n+\t(dump_new_block_header): Likewise for params \"head\", \"tail\".\n+\t(fix_jump_move): Likewise for param \"jump\".\n+\t(move_block_after_check): Likewise.\n+\t(sched_init_insn_luid): Likewise for param \"insn\".\n+\t(sched_init_luids): Likewise for local \"insn\".\n+\t(insn_luid): Likewise for param \"insn\".\n+\t(init_h_i_d): Likewise.\n+\t(haifa_init_h_i_d): Likewise for local \"insn\".\n+\t(haifa_init_insn): Likewise for param \"insn\".\n+\t* sched-deps.c (add_dependence): Likewise for local \"real_pro\",\n+\t\"other\".\n+\t(create_insn_reg_use): Likewise for param \"insn\".\n+\t(setup_insn_reg_uses): Likewise.  Add a checked cast.\n+\t* sched-ebb.c (debug_ebb_dependencies): Strengthen params \"head\",\n+\t\"tail\" from rtx to rtx_insn *.\n+\t* sched-rgn.c (void debug_dependencies): Likewise, also for locals\n+\t\"insn\", \"next_tail\".\n+\n 2014-08-26  David Malcolm  <dmalcolm@redhat.com>\n \n \t* haifa-sched.c (struct model_insn_info): Strengthen field \"insn\""}, {"sha": "bd13320f0a0c9f57e31012e439ef1e9b92bfa248", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f57aa6b04a190fdbacbe34d73b5414f44129c518", "patch": "@@ -419,7 +419,7 @@ basic_block (* sched_create_empty_bb) (basic_block);\n /* Return the number of cycles until INSN is expected to be ready.\n    Return zero if it already is.  */\n static int\n-insn_delay (rtx insn)\n+insn_delay (rtx_insn *insn)\n {\n   return MAX (INSN_TICK (insn) - clock_var, 0);\n }\n@@ -750,17 +750,17 @@ record_delay_slot_pair (rtx_insn *i1, rtx_insn *i2, int cycles, int stages)\n \n /* Examine the delay pair hashtable to see if INSN is a shadow for another,\n    and return the other insn if so.  Return NULL otherwise.  */\n-rtx\n-real_insn_for_shadow (rtx insn)\n+rtx_insn *\n+real_insn_for_shadow (rtx_insn *insn)\n {\n   struct delay_pair *pair;\n \n   if (!delay_htab)\n-    return NULL_RTX;\n+    return NULL;\n \n   pair = delay_htab_i2->find_with_hash (insn, htab_hash_pointer (insn));\n   if (!pair || pair->stages > 0)\n-    return NULL_RTX;\n+    return NULL;\n   return pair->i1;\n }\n \n@@ -831,7 +831,7 @@ static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx_insn **, int);\n static void queue_insn (rtx_insn *, int, const char *);\n static int schedule_insn (rtx_insn *);\n-static void adjust_priority (rtx);\n+static void adjust_priority (rtx_insn *);\n static void advance_one_cycle (void);\n static void extend_h_i_d (void);\n \n@@ -864,28 +864,28 @@ static int early_queue_to_ready (state_t, struct ready_list *);\n static rtx_insn *ready_remove (struct ready_list *, int);\n static void ready_remove_insn (rtx);\n \n-static void fix_inter_tick (rtx, rtx);\n+static void fix_inter_tick (rtx_insn *, rtx_insn *);\n static int fix_tick_ready (rtx_insn *);\n static void change_queue_index (rtx_insn *, int);\n \n /* The following functions are used to implement scheduling of data/control\n    speculative instructions.  */\n \n static void extend_h_i_d (void);\n-static void init_h_i_d (rtx);\n-static int haifa_speculate_insn (rtx, ds_t, rtx *);\n+static void init_h_i_d (rtx_insn *);\n+static int haifa_speculate_insn (rtx_insn *, ds_t, rtx *);\n static void generate_recovery_code (rtx_insn *);\n static void process_insn_forw_deps_be_in_spec (rtx, rtx_insn *, ds_t);\n static void begin_speculative_block (rtx_insn *);\n static void add_to_speculative_block (rtx_insn *);\n static void init_before_recovery (basic_block *);\n static void create_check_block_twin (rtx_insn *, bool);\n static void fix_recovery_deps (basic_block);\n-static bool haifa_change_pattern (rtx, rtx);\n-static void dump_new_block_header (int, basic_block, rtx, rtx);\n+static bool haifa_change_pattern (rtx_insn *, rtx);\n+static void dump_new_block_header (int, basic_block, rtx_insn *, rtx_insn *);\n static void restore_bb_notes (basic_block);\n-static void fix_jump_move (rtx);\n-static void move_block_after_check (rtx);\n+static void fix_jump_move (rtx_insn *);\n+static void move_block_after_check (rtx_insn *);\n static void move_succs (vec<edge, va_gc> **, basic_block);\n static void sched_remove_insn (rtx_insn *);\n static void clear_priorities (rtx_insn *, rtx_vec_t *);\n@@ -1144,7 +1144,7 @@ cond_clobbered_p (rtx_insn *insn, HARD_REG_SET set_regs)\n /* This function should be called after modifying the pattern of INSN,\n    to update scheduler data structures as needed.  */\n static void\n-update_insn_after_change (rtx insn)\n+update_insn_after_change (rtx_insn *insn)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -1184,7 +1184,7 @@ static void restore_pattern (dep_t, bool);\n    false.  */\n \n static ds_t\n-recompute_todo_spec (rtx next, bool for_backtrack)\n+recompute_todo_spec (rtx_insn *next, bool for_backtrack)\n {\n   ds_t new_ds;\n   sd_iterator_def sd_it;\n@@ -1268,7 +1268,8 @@ recompute_todo_spec (rtx next, bool for_backtrack)\n   \n   else if (n_control == 1 && n_replace == 0 && n_spec == 0)\n     {\n-      rtx pro, other, new_pat;\n+      rtx_insn *pro, *other;\n+      rtx new_pat;\n       rtx cond = NULL_RTX;\n       bool success;\n       rtx_insn *prev = NULL;\n@@ -1365,7 +1366,7 @@ static rtx_insn *nonscheduled_insns_begin;\n    This is the number of cycles between instruction issue and\n    instruction results.  */\n int\n-insn_cost (rtx insn)\n+insn_cost (rtx_insn *insn)\n {\n   int cost;\n \n@@ -1509,7 +1510,7 @@ dep_cost (dep_t link)\n /* Use this sel-sched.c friendly function in reorder2 instead of increasing\n    INSN_PRIORITY explicitly.  */\n void\n-increase_insn_priority (rtx insn, int amount)\n+increase_insn_priority (rtx_insn *insn, int amount)\n {\n   if (!sel_sched_p ())\n     {\n@@ -1687,7 +1688,7 @@ priority (rtx_insn *insn)\n    in that class that die in INSN.  */\n \n static void\n-calculate_reg_deaths (rtx insn, int *death)\n+calculate_reg_deaths (rtx_insn *insn, int *death)\n {\n   int i;\n   struct reg_use_data *use;\n@@ -1702,7 +1703,7 @@ calculate_reg_deaths (rtx insn, int *death)\n /* Setup info about the current register pressure impact of scheduling\n    INSN at the current scheduling point.  */\n static void\n-setup_insn_reg_pressure_info (rtx insn)\n+setup_insn_reg_pressure_info (rtx_insn *insn)\n {\n   int i, change, before, after, hard_regno;\n   int excess_cost_change;\n@@ -1876,7 +1877,7 @@ struct model_pressure_group {\n \n /* Index POINT gives the instruction at point POINT of the model schedule.\n    This array doesn't change during main scheduling.  */\n-static vec<rtx> model_schedule;\n+static vec<rtx_insn *> model_schedule;\n \n /* The list of instructions in the model worklist, sorted in order of\n    decreasing priority.  */\n@@ -1927,7 +1928,7 @@ static unsigned int model_next_priority;\n    doesn't belong to that schedule.  */\n \n static int\n-model_index (rtx insn)\n+model_index (rtx_insn *insn)\n {\n   if (INSN_MODEL_INDEX (insn) == 0)\n     return model_num_insns;\n@@ -2096,7 +2097,7 @@ model_update_pressure (struct model_pressure_group *group,\n /* INSN has just been scheduled.  Update the model schedule accordingly.  */\n \n static void\n-model_recompute (rtx insn)\n+model_recompute (rtx_insn *insn)\n {\n   struct {\n     int last_use;\n@@ -2229,7 +2230,7 @@ model_recompute (rtx insn)\n /* After DEP, which was cancelled, has been resolved for insn NEXT,\n    check whether the insn's pattern needs restoring.  */\n static bool\n-must_restore_pattern_p (rtx next, dep_t dep)\n+must_restore_pattern_p (rtx_insn *next, dep_t dep)\n {\n   if (QUEUE_INDEX (next) == QUEUE_SCHEDULED)\n     return false;\n@@ -2405,7 +2406,7 @@ model_excess_group_cost (struct model_pressure_group *group,\n    if PRINT_P.  */\n \n static int\n-model_excess_cost (rtx insn, bool print_p)\n+model_excess_cost (rtx_insn *insn, bool print_p)\n {\n   int point, pci, cl, cost, this_cost, delta;\n   struct reg_pressure_data *insn_reg_pressure;\n@@ -2781,7 +2782,7 @@ queue_insn (rtx_insn *insn, int n_cycles, const char *reason)\n \n /* Remove INSN from queue.  */\n static void\n-queue_remove (rtx insn)\n+queue_remove (rtx_insn *insn)\n {\n   gcc_assert (QUEUE_INDEX (insn) >= 0);\n   remove_free_INSN_LIST_elem (insn, &insn_queue[QUEUE_INDEX (insn)]);\n@@ -2981,7 +2982,7 @@ ready_sort (struct ready_list *ready)\n    provide a hook for the target to tweak itself.  */\n \n HAIFA_INLINE static void\n-adjust_priority (rtx prev)\n+adjust_priority (rtx_insn *prev)\n {\n   /* ??? There used to be code here to try and estimate how an insn\n      affected register lifetimes, but it did it by looking at REG_DEAD\n@@ -3027,7 +3028,7 @@ advance_one_cycle (void)\n \n /* Update register pressure after scheduling INSN.  */\n static void\n-update_register_pressure (rtx insn)\n+update_register_pressure (rtx_insn *insn)\n {\n   struct reg_use_data *use;\n   struct reg_set_data *set;\n@@ -3051,7 +3052,7 @@ setup_insn_max_reg_pressure (rtx after, bool update_p)\n {\n   int i, p;\n   bool eq_p;\n-  rtx insn;\n+  rtx_insn *insn;\n   static int max_reg_pressure[N_REG_CLASSES];\n \n   save_reg_pressure ();\n@@ -3091,7 +3092,7 @@ setup_insn_max_reg_pressure (rtx after, bool update_p)\n    also max register pressure for unscheduled insns of the current\n    BB.  */\n static void\n-update_reg_and_insn_max_reg_pressure (rtx insn)\n+update_reg_and_insn_max_reg_pressure (rtx_insn *insn)\n {\n   int i;\n   int before[N_REG_CLASSES];\n@@ -3332,7 +3333,7 @@ model_promote_insn (struct model_insn_info *insn)\n /* Add INSN to the end of the model schedule.  */\n \n static void\n-model_add_to_schedule (rtx insn)\n+model_add_to_schedule (rtx_insn *insn)\n {\n   unsigned int point;\n \n@@ -3692,7 +3693,7 @@ static void\n model_reset_queue_indices (void)\n {\n   unsigned int i;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   FOR_EACH_VEC_ELT (model_schedule, i, insn)\n     QUEUE_INDEX (insn) = MODEL_INSN_INFO (insn)->old_queue;\n@@ -4279,13 +4280,13 @@ undo_replacements_for_backtrack (struct haifa_saved_data *save)\n static void\n unschedule_insns_until (rtx insn)\n {\n-  auto_vec<rtx> recompute_vec;\n+  auto_vec<rtx_insn *> recompute_vec;\n \n   /* Make two passes over the insns to be unscheduled.  First, we clear out\n      dependencies and other trivial bookkeeping.  */\n   for (;;)\n     {\n-      rtx last;\n+      rtx_insn *last;\n       sd_iterator_def sd_it;\n       dep_t dep;\n \n@@ -4323,7 +4324,7 @@ unschedule_insns_until (rtx insn)\n      up-to-date.  */\n   while (!recompute_vec.is_empty ())\n     {\n-      rtx con;\n+      rtx_insn *con;\n \n       con = recompute_vec.pop ();\n       MUST_RECOMPUTE_SPEC_P (con) = 0;\n@@ -4384,7 +4385,7 @@ restore_last_backtrack_point (struct sched_block_state *psched_block)\n \n       for (link = insn_queue[q]; link; link = XEXP (link, 1))\n \t{\n-\t  rtx x = XEXP (link, 0);\n+\t  rtx_insn *x = as_a <rtx_insn *> (XEXP (link, 0));\n \t  QUEUE_INDEX (x) = QUEUE_NOWHERE;\n \t  INSN_TICK (x) = INVALID_TICK;\n \t}\n@@ -4416,7 +4417,7 @@ restore_last_backtrack_point (struct sched_block_state *psched_block)\n \n       for (link = insn_queue[q]; link; link = XEXP (link, 1))\n \t{\n-\t  rtx x = XEXP (link, 0);\n+\t  rtx_insn *x = as_a <rtx_insn *> (XEXP (link, 0));\n \t  QUEUE_INDEX (x) = i;\n \t  TODO_SPEC (x) = recompute_todo_spec (x, true);\n \t  INSN_TICK (x) = save->clock_var + i;\n@@ -4625,7 +4626,7 @@ perform_replacements_new_cycle (void)\n    reduced on recursive calls.  Return true if we produced a good\n    estimate, or false if we exceeded the budget.  */\n static bool\n-estimate_insn_tick (bitmap processed, rtx insn, int budget)\n+estimate_insn_tick (bitmap processed, rtx_insn *insn, int budget)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n@@ -5709,7 +5710,7 @@ choose_ready (struct ready_list *ready, bool first_cycle_insn_p,\n    block.  TARGET_BB is the argument passed to schedule_block.  */\n \n static void\n-commit_schedule (rtx_insn *prev_head, rtx tail, basic_block *target_bb)\n+commit_schedule (rtx_insn *prev_head, rtx_insn *tail, basic_block *target_bb)\n {\n   unsigned int i;\n   rtx_insn *insn;\n@@ -5726,7 +5727,7 @@ commit_schedule (rtx_insn *prev_head, rtx tail, basic_block *target_bb)\n \n \t  if (sched_verbose)\n \t    {\n-\t      rtx x;\n+\t      rtx_insn *x;\n \n \t      x = next_real_insn (last_scheduled_insn);\n \t      gcc_assert (x);\n@@ -5885,11 +5886,11 @@ verify_shadows (void)\n     {\n       int t;\n       struct delay_pair *pair = save->delay_pair;\n-      rtx i1 = pair->i1;\n+      rtx_insn *i1 = pair->i1;\n \n       for (; pair; pair = pair->next_same_i1)\n \t{\n-\t  rtx i2 = pair->i2;\n+\t  rtx_insn *i2 = pair->i2;\n \n \t  if (QUEUE_INDEX (i2) == QUEUE_SCHEDULED)\n \t    continue;\n@@ -5931,12 +5932,12 @@ verify_shadows (void)\n /* Print instructions together with useful scheduling information between\n    HEAD and TAIL (inclusive).  */\n static void\n-dump_insn_stream (rtx head, rtx tail)\n+dump_insn_stream (rtx_insn *head, rtx_insn *tail)\n {\n   fprintf (sched_dump, \";;\\t| insn | prio |\\n\");\n \n-  rtx next_tail = NEXT_INSN (tail);\n-  for (rtx insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+  rtx_insn *next_tail = NEXT_INSN (tail);\n+  for (rtx_insn *insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n       int priority = NOTE_P (insn) ? 0 : INSN_PRIORITY (insn);\n       const char *pattern = (NOTE_P (insn)\n@@ -6417,7 +6418,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       if (!must_backtrack)\n \tfor (i = 0; i < ready.n_ready; i++)\n \t  {\n-\t    rtx insn = ready_element (&ready, i);\n+\t    rtx_insn *insn = ready_element (&ready, i);\n \t    if (INSN_EXACT_TICK (insn) == clock_var)\n \t      {\n \t\tmust_backtrack = true;\n@@ -6482,7 +6483,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n     restart_debug_insn_loop:\n       for (i = ready.n_ready - 1; i >= 0; i--)\n \t{\n-\t  rtx x;\n+\t  rtx_insn *x;\n \n \t  x = ready_element (&ready, i);\n \t  if (DEPS_LIST_FIRST (INSN_HARD_BACK_DEPS (x)) != NULL\n@@ -6532,7 +6533,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n       /* We must maintain QUEUE_INDEX between blocks in region.  */\n       for (i = ready.n_ready - 1; i >= 0; i--)\n \t{\n-\t  rtx x;\n+\t  rtx_insn *x;\n \n \t  x = ready_element (&ready, i);\n \t  QUEUE_INDEX (x) = QUEUE_NOWHERE;\n@@ -6545,9 +6546,9 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t    rtx link;\n \t    for (link = insn_queue[i]; link; link = XEXP (link, 1))\n \t      {\n-\t\trtx x;\n+\t\trtx_insn *x;\n \n-\t\tx = XEXP (link, 0);\n+\t\tx = as_a <rtx_insn *> (XEXP (link, 0));\n \t\tQUEUE_INDEX (x) = QUEUE_NOWHERE;\n \t\tTODO_SPEC (x) = HARD_DEP;\n \t      }\n@@ -6946,7 +6947,7 @@ free_delay_pairs (void)\n    INSN_TICKs of their dependents.\n    HEAD and TAIL are the begin and the end of the current scheduled block.  */\n static void\n-fix_inter_tick (rtx head, rtx tail)\n+fix_inter_tick (rtx_insn *head, rtx_insn *tail)\n {\n   /* Set of instructions with corrected INSN_TICK.  */\n   bitmap_head processed;\n@@ -7413,7 +7414,7 @@ begin_speculative_block (rtx_insn *insn)\n   TODO_SPEC (insn) &= ~BEGIN_SPEC;\n }\n \n-static void haifa_init_insn (rtx);\n+static void haifa_init_insn (rtx_insn *);\n \n /* Generates recovery code for BE_IN speculative INSN.  */\n static void\n@@ -7899,7 +7900,7 @@ create_check_block_twin (rtx_insn *insn, bool mutate_p)\n     /* In case of branchy check, fix CFG.  */\n     {\n       basic_block first_bb, second_bb;\n-      rtx jump;\n+      rtx_insn *jump;\n \n       first_bb = BLOCK_FOR_INSN (check);\n       second_bb = sched_split_block (first_bb, check);\n@@ -8127,7 +8128,7 @@ fix_recovery_deps (basic_block rec)\n /* Change pattern of INSN to NEW_PAT.  Invalidate cached haifa\n    instruction data.  */\n static bool\n-haifa_change_pattern (rtx insn, rtx new_pat)\n+haifa_change_pattern (rtx_insn *insn, rtx new_pat)\n {\n   int t;\n \n@@ -8161,7 +8162,7 @@ sched_speculate_insn (rtx insn, ds_t request, rtx *new_pat)\n }\n \n static int\n-haifa_speculate_insn (rtx insn, ds_t request, rtx *new_pat)\n+haifa_speculate_insn (rtx_insn *insn, ds_t request, rtx *new_pat)\n {\n   gcc_assert (sched_deps_info->generate_spec_deps\n \t      && !IS_SPECULATION_CHECK_P (insn));\n@@ -8177,7 +8178,7 @@ haifa_speculate_insn (rtx insn, ds_t request, rtx *new_pat)\n    ends with TAIL, before scheduling it.\n    I is zero, if scheduler is about to start with the fresh ebb.  */\n static void\n-dump_new_block_header (int i, basic_block bb, rtx head, rtx tail)\n+dump_new_block_header (int i, basic_block bb, rtx_insn *head, rtx_insn *tail)\n {\n   if (!i)\n     fprintf (sched_dump,\n@@ -8288,7 +8289,7 @@ restore_bb_notes (basic_block first)\n    Fix CFG after both in- and inter-block movement of\n    control_flow_insn_p JUMP.  */\n static void\n-fix_jump_move (rtx jump)\n+fix_jump_move (rtx_insn *jump)\n {\n   basic_block bb, jump_bb, jump_bb_next;\n \n@@ -8319,7 +8320,7 @@ fix_jump_move (rtx jump)\n \n /* Fix CFG after interblock movement of control_flow_insn_p JUMP.  */\n static void\n-move_block_after_check (rtx jump)\n+move_block_after_check (rtx_insn *jump)\n {\n   basic_block bb, jump_bb, jump_bb_next;\n   vec<edge, va_gc> *t;\n@@ -8461,7 +8462,7 @@ sched_extend_luids (void)\n \n /* Initialize LUID for INSN.  */\n void\n-sched_init_insn_luid (rtx insn)\n+sched_init_insn_luid (rtx_insn *insn)\n {\n   int i = INSN_P (insn) ? 1 : common_sched_info->luid_for_non_insn (insn);\n   int luid;\n@@ -8489,7 +8490,7 @@ sched_init_luids (bb_vec_t bbs)\n   sched_extend_luids ();\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       FOR_BB_INSNS (bb, insn)\n \tsched_init_insn_luid (insn);\n@@ -8506,7 +8507,7 @@ sched_finish_luids (void)\n \n /* Return logical uid of INSN.  Helpful while debugging.  */\n int\n-insn_luid (rtx insn)\n+insn_luid (rtx_insn *insn)\n {\n   return INSN_LUID (insn);\n }\n@@ -8536,7 +8537,7 @@ extend_h_i_d (void)\n /* Initialize h_i_d entry of the INSN with default values.\n    Values, that are not explicitly initialized here, hold zero.  */\n static void\n-init_h_i_d (rtx insn)\n+init_h_i_d (rtx_insn *insn)\n {\n   if (INSN_LUID (insn) > 0)\n     {\n@@ -8559,7 +8560,7 @@ haifa_init_h_i_d (bb_vec_t bbs)\n   extend_h_i_d ();\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       FOR_BB_INSNS (bb, insn)\n \tinit_h_i_d (insn);\n@@ -8589,7 +8590,7 @@ haifa_finish_h_i_d (void)\n \n /* Init data for the new insn INSN.  */\n static void\n-haifa_init_insn (rtx insn)\n+haifa_init_insn (rtx_insn *insn)\n {\n   gcc_assert (insn != NULL);\n "}, {"sha": "98d189b831bb5d296309808950683b98623e7045", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=f57aa6b04a190fdbacbe34d73b5414f44129c518", "patch": "@@ -1524,8 +1524,8 @@ add_dependence (rtx_insn *con, rtx_insn *pro, enum reg_note dep_type)\n      condition.  */\n   if (dep_type == REG_DEP_CONTROL)\n     {\n-      rtx real_pro = pro;\n-      rtx other = real_insn_for_shadow (real_pro);\n+      rtx_insn *real_pro = pro;\n+      rtx_insn *other = real_insn_for_shadow (real_pro);\n       rtx cond;\n \n       if (other != NULL_RTX)\n@@ -1926,7 +1926,7 @@ ds_to_dt (ds_t ds)\n \n /* Allocate and return reg_use_data structure for REGNO and INSN.  */\n static struct reg_use_data *\n-create_insn_reg_use (int regno, rtx insn)\n+create_insn_reg_use (int regno, rtx_insn *insn)\n {\n   struct reg_use_data *use;\n \n@@ -1953,7 +1953,7 @@ create_insn_reg_set (int regno, rtx insn)\n \n /* Set up insn register uses for INSN and dependency context DEPS.  */\n static void\n-setup_insn_reg_uses (struct deps_desc *deps, rtx insn)\n+setup_insn_reg_uses (struct deps_desc *deps, rtx_insn *insn)\n {\n   unsigned i;\n   reg_set_iterator rsi;\n@@ -1980,7 +1980,7 @@ setup_insn_reg_uses (struct deps_desc *deps, rtx insn)\n       /* Create the cycle list of uses.  */\n       for (list = reg_last->uses; list; list = XEXP (list, 1))\n \t{\n-\t  use2 = create_insn_reg_use (i, XEXP (list, 0));\n+\t  use2 = create_insn_reg_use (i, as_a <rtx_insn *> (XEXP (list, 0)));\n \t  next = use->next_regno_use;\n \t  use->next_regno_use = use2;\n \t  use2->next_regno_use = next;"}, {"sha": "f50266835c0fa2a2e5557487a09fa1411dbc1e35", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=f57aa6b04a190fdbacbe34d73b5414f44129c518", "patch": "@@ -62,7 +62,7 @@ static int rank (rtx_insn *, rtx_insn *);\n static int ebb_contributes_to_priority (rtx_insn *, rtx_insn *);\n static basic_block earliest_block_with_similiar_load (basic_block, rtx);\n static void add_deps_for_risky_insns (rtx_insn *, rtx_insn *);\n-static void debug_ebb_dependencies (rtx, rtx);\n+static void debug_ebb_dependencies (rtx_insn *, rtx_insn *);\n \n static void ebb_add_remove_insn (rtx_insn *, int);\n static void ebb_add_block (basic_block, basic_block);\n@@ -98,7 +98,7 @@ schedule_more_p (void)\n \n /* Print dependency information about ebb between HEAD and TAIL.  */\n static void\n-debug_ebb_dependencies (rtx head, rtx tail)\n+debug_ebb_dependencies (rtx_insn *head, rtx_insn *tail)\n {\n   fprintf (sched_dump,\n \t   \";;   --------------- forward dependences: ------------ \\n\");"}, {"sha": "a3e9e46ce361755843095ddaf24259ec442947d6", "filename": "gcc/sched-int.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=f57aa6b04a190fdbacbe34d73b5414f44129c518", "patch": "@@ -47,7 +47,7 @@ typedef vec<rtx_insn *> rtx_vec_t;\n extern void sched_init_bbs (void);\n \n extern void sched_extend_luids (void);\n-extern void sched_init_insn_luid (rtx);\n+extern void sched_init_insn_luid (rtx_insn *);\n extern void sched_init_luids (bb_vec_t);\n extern void sched_finish_luids (void);\n \n@@ -774,7 +774,7 @@ struct reg_use_data\n   /* Regno used in the insn.  */\n   int regno;\n   /* Insn using the regno.  */\n-  rtx insn;\n+  rtx_insn *insn;\n   /* Cyclic list of elements with the same regno.  */\n   struct reg_use_data *next_regno_use;\n   /* List of elements with the same insn.  */\n@@ -1344,7 +1344,7 @@ extern void get_ebb_head_tail (basic_block, basic_block,\n \t\t\t       rtx_insn **, rtx_insn **);\n extern int no_real_insns_p (const_rtx, const_rtx);\n \n-extern int insn_cost (rtx);\n+extern int insn_cost (rtx_insn *);\n extern int dep_cost_1 (dep_t, dw_t);\n extern int dep_cost (dep_t);\n extern int set_priorities (rtx_insn *, rtx_insn *);\n@@ -1430,7 +1430,7 @@ extern bool sched_no_dce;\n \n extern void set_modulo_params (int, int, int, int);\n extern void record_delay_slot_pair (rtx_insn *, rtx_insn *, int, int);\n-extern rtx real_insn_for_shadow (rtx);\n+extern rtx_insn *real_insn_for_shadow (rtx_insn *);\n extern void discard_delay_pairs_above (int);\n extern void free_delay_pairs (void);\n extern void add_delay_dependencies (rtx_insn *);\n@@ -1446,9 +1446,9 @@ extern void extend_regions (void);\n extern void rgn_make_new_region_out_of_new_block (basic_block);\n \n extern void compute_priorities (void);\n-extern void increase_insn_priority (rtx, int);\n+extern void increase_insn_priority (rtx_insn *, int);\n extern void debug_rgn_dependencies (int);\n-extern void debug_dependencies (rtx, rtx);\n+extern void debug_dependencies (rtx_insn *, rtx_insn *);\n extern void free_rgn_deps (void);\n extern int contributes_to_priority (rtx_insn *, rtx_insn *);\n extern void extend_rgns (int *, int *, sbitmap, int *);"}, {"sha": "af3f4e52e731bb31f3a36eb9d9c2e9d4050bc522", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57aa6b04a190fdbacbe34d73b5414f44129c518/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=f57aa6b04a190fdbacbe34d73b5414f44129c518", "patch": "@@ -2806,10 +2806,10 @@ debug_rgn_dependencies (int from_bb)\n \n /* Print dependencies information for instructions between HEAD and TAIL.\n    ??? This function would probably fit best in haifa-sched.c.  */\n-void debug_dependencies (rtx head, rtx tail)\n+void debug_dependencies (rtx_insn *head, rtx_insn *tail)\n {\n-  rtx insn;\n-  rtx next_tail = NEXT_INSN (tail);\n+  rtx_insn *insn;\n+  rtx_insn *next_tail = NEXT_INSN (tail);\n \n   fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n \t   \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\","}]}