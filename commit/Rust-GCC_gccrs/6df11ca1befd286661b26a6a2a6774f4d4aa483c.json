{"sha": "6df11ca1befd286661b26a6a2a6774f4d4aa483c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmMTFjYTFiZWZkMjg2NjYxYjI2YTZhMmE2Nzc0ZjRkNGFhNDgzYw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-02-27T17:25:17Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-02-27T17:25:17Z"}, "message": "tree-ssa-structalias.c (get_constraint_for): Move code to deal with aggregates here.\n\n2006-02-27  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c (get_constraint_for): Move code to deal\n\twith aggregates here.\n\t(find_func_aliases): Remove code for &<aggregate> from here.\n\nFrom-SVN: r111487", "tree": {"sha": "96e2f8d02df730b6f48d1b5c2fbac3657761f0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e2f8d02df730b6f48d1b5c2fbac3657761f0ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df11ca1befd286661b26a6a2a6774f4d4aa483c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df11ca1befd286661b26a6a2a6774f4d4aa483c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df11ca1befd286661b26a6a2a6774f4d4aa483c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df11ca1befd286661b26a6a2a6774f4d4aa483c/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79ae22000f17f4cec1e1a6d27b6d648e0e37dbf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ae22000f17f4cec1e1a6d27b6d648e0e37dbf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ae22000f17f4cec1e1a6d27b6d648e0e37dbf5"}], "stats": {"total": 81, "additions": 30, "deletions": 51}, "files": [{"sha": "ca154bdd1fef59844fe36962807475f1bc60c161", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df11ca1befd286661b26a6a2a6774f4d4aa483c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df11ca1befd286661b26a6a2a6774f4d4aa483c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6df11ca1befd286661b26a6a2a6774f4d4aa483c", "patch": "@@ -1,3 +1,9 @@\n+2006-02-27  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c (get_constraint_for): Move code to deal\n+\twith aggregates here.\n+\t(find_func_aliases): Remove code for &<aggregate> from here.\n+\n 2006-02-26  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold_binary) <EQ_EXPR>:  Fold (~X & C) eq/ne 0 as"}, {"sha": "79d4f90b1af9804023937400a42f74feea974e4a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 24, "deletions": 51, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df11ca1befd286661b26a6a2a6774f4d4aa483c/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df11ca1befd286661b26a6a2a6774f4d4aa483c/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=6df11ca1befd286661b26a6a2a6774f4d4aa483c", "patch": "@@ -2484,6 +2484,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t      struct constraint_expr *c;\n \t      unsigned int i;\n \t      tree exp = TREE_OPERAND (t, 0);\n+\t      tree pttype = TREE_TYPE (TREE_TYPE (t));\n \n \t      get_constraint_for (exp, results);\n \t      /* Make sure we capture constraints to all elements\n@@ -2507,6 +2508,26 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t\t      VEC_safe_push (ce_s, heap, *results, &tmp);\n \t\t    }\n \t\t}\n+\t      else if (VEC_length (ce_s, *results) == 1\n+\t\t       && (AGGREGATE_TYPE_P (pttype)\n+\t\t\t   || TREE_CODE (pttype) == COMPLEX_TYPE))\n+\t\t{\n+\t\t  struct constraint_expr *origrhs;\n+\t\t  varinfo_t origvar;\n+\t\t  struct constraint_expr tmp;\n+\n+\t\t  gcc_assert (VEC_length (ce_s, *results) == 1);\n+\t\t  origrhs = VEC_last (ce_s, *results);\n+\t\t  tmp = *origrhs;\n+\t\t  VEC_pop (ce_s, *results);\n+\t\t  origvar = get_varinfo (origrhs->var);\n+\t\t  for (; origvar; origvar = origvar->next)\n+\t\t    {\n+\t\t      tmp.var = origvar->id;\n+\t\t      VEC_safe_push (ce_s, heap, *results, &tmp);\n+\t\t    }\n+\t\t}\n+\t      \n \t      for (i = 0; VEC_iterate (ce_s, *results, i, c); i++)\n \t\t{\n \t\t  if (c->type == DEREF)\n@@ -3220,10 +3241,11 @@ find_func_aliases (tree origt)\n   /* Now build constraints expressions.  */\n   if (TREE_CODE (t) == PHI_NODE)\n     {\n+      gcc_assert (!AGGREGATE_TYPE_P (TREE_TYPE (PHI_RESULT (t))));\n+\n       /* Only care about pointers and structures containing\n \t pointers.  */\n       if (POINTER_TYPE_P (TREE_TYPE (PHI_RESULT (t)))\n-\t  || AGGREGATE_TYPE_P (TREE_TYPE (PHI_RESULT (t)))\n \t  || TREE_CODE (TREE_TYPE (PHI_RESULT (t))) == COMPLEX_TYPE)\n \t{\n \t  int i;\n@@ -3241,27 +3263,6 @@ find_func_aliases (tree origt)\n \t      rhstype = TREE_TYPE (strippedrhs);\n \t      get_constraint_for (PHI_ARG_DEF (t, i), &rhsc);\n \n-\t      if (TREE_CODE (strippedrhs) == ADDR_EXPR\n-\t\t && (AGGREGATE_TYPE_P (TREE_TYPE (rhstype))\n-\t\t     || TREE_CODE (TREE_TYPE (rhstype)) == COMPLEX_TYPE)\n-\t\t && VEC_length (ce_s, rhsc) == 1)\n-\t\t{\n-\t\t  struct constraint_expr *origrhs;\n-\t\t  varinfo_t origvar;\n-\t\t  struct constraint_expr tmp;\n-\n-\t\t  gcc_assert (VEC_length (ce_s, rhsc) == 1);\n-\t\t  origrhs = VEC_last (ce_s, rhsc);\n-\t\t  tmp = *origrhs;\n-\t\t  VEC_pop (ce_s, rhsc);\n-\t\t  origvar = get_varinfo (origrhs->var);\n-\t\t  for (; origvar; origvar = origvar->next)\n-\t\t    {\n-\t\t      tmp.var = origvar->id;\n-\t\t      VEC_safe_push (ce_s, heap, rhsc, &tmp);\n-\t\t    }\n-\t\t}\n-\n \t      for (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n \t\t{\n \t\t  struct constraint_expr *c2;\n@@ -3413,36 +3414,8 @@ find_func_aliases (tree origt)\n \t\t  case tcc_unary:\n \t\t      {\n \t\t\tunsigned int j;\n-\t\t\ttree strippedrhs = rhsop;\n-\t\t\ttree rhstype;\n-\n-\t\t\t/* XXX: Push this back into the ADDR_EXPR\n-\t\t\t   case, and remove anyoffset handling.  */\n-\t\t\tSTRIP_NOPS (strippedrhs);\n-\t\t\trhstype = TREE_TYPE (strippedrhs);\n-\t\t\t\n-\t\t\tget_constraint_for (rhsop, &rhsc);\n-\t\t\tif (TREE_CODE (strippedrhs) == ADDR_EXPR\n-\t\t\t    && (AGGREGATE_TYPE_P (TREE_TYPE (rhstype))\n-\t\t\t\t|| TREE_CODE (TREE_TYPE (rhstype)) == COMPLEX_TYPE)\n-\t\t\t    && VEC_length (ce_s, rhsc) == 1)\n-\t\t\t  {\n-\t\t\t    struct constraint_expr *origrhs;\n-\t\t\t    varinfo_t origvar;\n-\t\t\t    struct constraint_expr tmp;\n-\n-\t\t\t    gcc_assert (VEC_length (ce_s, rhsc) == 1);\n-\t\t\t    origrhs = VEC_last (ce_s, rhsc);\n-\t\t\t    tmp = *origrhs;\n-\t\t\t    VEC_pop (ce_s, rhsc);\n-\t\t\t    origvar = get_varinfo (origrhs->var);\n-\t\t\t    for (; origvar; origvar = origvar->next)\n-\t\t\t      {\n-\t\t\t\ttmp.var = origvar->id;\n-\t\t\t\tVEC_safe_push (ce_s, heap, rhsc, &tmp);\n-\t\t\t      }\n-\t\t\t  }\n \n+\t\t\tget_constraint_for (rhsop, &rhsc);\n \t\t\tfor (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n \t\t\t  {\n \t\t\t    struct constraint_expr *c2;"}]}