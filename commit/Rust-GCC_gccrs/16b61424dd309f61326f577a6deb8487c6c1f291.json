{"sha": "16b61424dd309f61326f577a6deb8487c6c1f291", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZiNjE0MjRkZDMwOWY2MTMyNmY1NzdhNmRlYjg0ODdjNmMxZjI5MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-10-21T19:45:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-10-21T19:45:45Z"}, "message": "re PR c++/77656 (64-bit integral template parameter gets incorrectly sized as 32-bits)\n\n\tPR c++/77656\n\t* pt.c (convert_template_argument): Call convert_nontype_argument\n\ton value-dependent but not type-dependent arguments.\n\t(convert_nontype_argument): Handle value-dependent arguments.\n\t(canonicalize_expr_argument): New.\n\t(deducible_expression, unify): Skip CONVERT_EXPR.\n\t* error.c (dump_template_argument): Likewise.\n\t* mangle.c (write_expression): Likewise.\n\nFrom-SVN: r241425", "tree": {"sha": "6c7926ef82590c0dc45a976fca3d534b08b3b791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c7926ef82590c0dc45a976fca3d534b08b3b791"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16b61424dd309f61326f577a6deb8487c6c1f291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b61424dd309f61326f577a6deb8487c6c1f291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b61424dd309f61326f577a6deb8487c6c1f291", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b61424dd309f61326f577a6deb8487c6c1f291/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7564a05ff6a64cd1536a903e5f5fad50fed6973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7564a05ff6a64cd1536a903e5f5fad50fed6973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7564a05ff6a64cd1536a903e5f5fad50fed6973"}], "stats": {"total": 132, "additions": 94, "deletions": 38}, "files": [{"sha": "d9135369a02d926d94358ac6902e3807a58235c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -1,5 +1,14 @@\n 2016-10-21  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/77656\n+\t* pt.c (convert_template_argument): Call convert_nontype_argument\n+\ton value-dependent but not type-dependent arguments.\n+\t(convert_nontype_argument): Handle value-dependent arguments.\n+\t(canonicalize_expr_argument): New.\n+\t(deducible_expression, unify): Skip CONVERT_EXPR.\n+\t* error.c (dump_template_argument): Likewise.\n+\t* mangle.c (write_expression): Likewise.\n+\n \t* ptree.c (cxx_print_xnode) [TEMPLATE_PARM_INDEX]: Dump the decl.\n \n 2016-10-21  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "917a448ad34f025dcf5413123d846af88d2805d6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -171,6 +171,10 @@ dump_template_argument (cxx_pretty_printer *pp, tree arg, int flags)\n       if (TREE_CODE (arg) == TREE_LIST)\n \targ = TREE_VALUE (arg);\n \n+      /* Strip implicit conversions.  */\n+      while (CONVERT_EXPR_P (arg))\n+\targ = TREE_OPERAND (arg, 0);\n+\n       dump_expr (pp, arg, (flags | TFF_EXPR_IN_PARENS) & ~TFF_CLASS_KEY_OR_ENUM);\n     }\n }"}, {"sha": "cb2f260c2d1f38b40225b3b6d579cfdf53b7dba9", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -2774,10 +2774,9 @@ write_expression (tree expr)\n {\n   enum tree_code code = TREE_CODE (expr);\n \n-  /* Skip NOP_EXPRs.  They can occur when (say) a pointer argument\n-     is converted (via qualification conversions) to another\n-     type.  */\n-  while (TREE_CODE (expr) == NOP_EXPR\n+  /* Skip NOP_EXPR and CONVERT_EXPR.  They can occur when (say) a pointer\n+     argument is converted (via qualification conversions) to another type.  */\n+  while (CONVERT_EXPR_CODE_P (code)\n \t /* Parentheses aren't mangled.  */\n \t || code == PAREN_EXPR\n \t || TREE_CODE (expr) == NON_LVALUE_EXPR)"}, {"sha": "aa126a0b94c62d0ec429f5fae7f982bd8711d230", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -214,6 +214,7 @@ static tree tsubst_template_parm (tree, tree, tsubst_flags_t);\n static tree instantiate_alias_template (tree, tree, tsubst_flags_t);\n static bool complex_alias_template_p (const_tree tmpl);\n static tree tsubst_attributes (tree, tree, tsubst_flags_t, tree);\n+static tree canonicalize_expr_argument (tree, tsubst_flags_t);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -6297,6 +6298,9 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n   if (non_dep)\n     expr = instantiate_non_dependent_expr_internal (expr, complain);\n \n+  if (value_dependent_expression_p (expr))\n+    expr = canonicalize_expr_argument (expr, complain);\n+\n   /* 14.3.2/5: The null pointer{,-to-member} conversion is applied\n      to a non-type argument of \"nullptr\".  */\n   if (expr == nullptr_node && TYPE_PTR_OR_PTRMEM_P (type))\n@@ -6405,7 +6409,8 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n       /* Notice that there are constant expressions like '4 % 0' which\n \t do not fold into integer constants.  */\n-      if (TREE_CODE (expr) != INTEGER_CST)\n+      if (TREE_CODE (expr) != INTEGER_CST\n+\t  && !value_dependent_expression_p (expr))\n \t{\n \t  if (complain & tf_error)\n \t    {\n@@ -6452,7 +6457,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \tHere, we do not care about functions, as they are invalid anyway\n \tfor a parameter of type pointer-to-object.  */\n \n-      if (DECL_P (expr) && DECL_TEMPLATE_PARM_P (expr))\n+      if (value_dependent_expression_p (expr))\n \t/* Non-type template parameters are OK.  */\n \t;\n       else if (cxx_dialect >= cxx11 && integer_zerop (expr))\n@@ -6567,27 +6572,30 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t    }\n \t}\n \n-      if (!DECL_P (expr))\n+      if (!value_dependent_expression_p (expr))\n \t{\n-\t  if (complain & tf_error)\n-\t    error (\"%qE is not a valid template argument for type %qT \"\n-\t\t   \"because it is not an object with linkage\",\n-\t\t   expr, type);\n-\t  return NULL_TREE;\n-\t}\n+\t  if (!DECL_P (expr))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument for type %qT \"\n+\t\t       \"because it is not an object with linkage\",\n+\t\t       expr, type);\n+\t      return NULL_TREE;\n+\t    }\n \n-      /* DR 1155 allows internal linkage in C++11 and up.  */\n-      linkage_kind linkage = decl_linkage (expr);\n-      if (linkage < (cxx_dialect >= cxx11 ? lk_internal : lk_external))\n-\t{\n-\t  if (complain & tf_error)\n-\t    error (\"%qE is not a valid template argument for type %qT \"\n-\t\t   \"because object %qD does not have linkage\",\n-\t\t   expr, type, expr);\n-\t  return NULL_TREE;\n-\t}\n+\t  /* DR 1155 allows internal linkage in C++11 and up.  */\n+\t  linkage_kind linkage = decl_linkage (expr);\n+\t  if (linkage < (cxx_dialect >= cxx11 ? lk_internal : lk_external))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"%qE is not a valid template argument for type %qT \"\n+\t\t       \"because object %qD does not have linkage\",\n+\t\t       expr, type, expr);\n+\t      return NULL_TREE;\n+\t    }\n \n-      expr = build_nop (type, build_address (expr));\n+\t  expr = build_nop (type, build_address (expr));\n+\t}\n     }\n   /* [temp.arg.nontype]/5, bullet 4\n \n@@ -6611,7 +6619,8 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t/* Null pointer values are OK in C++11.  */\n \treturn perform_qualification_conversions (type, expr);\n \n-      expr = convert_nontype_argument_function (type, expr, complain);\n+      if (!value_dependent_expression_p (expr))\n+\texpr = convert_nontype_argument_function (type, expr, complain);\n       if (!expr || expr == error_mark_node)\n \treturn expr;\n     }\n@@ -6635,7 +6644,8 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t  return NULL_TREE;\n \t}\n \n-      expr = convert_nontype_argument_function (type, expr, complain);\n+      if (!value_dependent_expression_p (expr))\n+\texpr = convert_nontype_argument_function (type, expr, complain);\n       if (!expr || expr == error_mark_node)\n \treturn expr;\n \n@@ -6655,7 +6665,8 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \n       /* [temp.arg.nontype] bullet 1 says the pointer to member\n          expression must be a pointer-to-member constant.  */\n-      if (!check_valid_ptrmem_cst_expr (type, expr, complain))\n+      if (!value_dependent_expression_p (expr)\n+\t  && !check_valid_ptrmem_cst_expr (type, expr, complain))\n \treturn error_mark_node;\n \n       /* There is no way to disable standard conversions in\n@@ -6690,7 +6701,8 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n     {\n       /* [temp.arg.nontype] bullet 1 says the pointer to member\n          expression must be a pointer-to-member constant.  */\n-      if (!check_valid_ptrmem_cst_expr (type, expr, complain))\n+      if (!value_dependent_expression_p (expr)\n+\t  && !check_valid_ptrmem_cst_expr (type, expr, complain))\n \treturn error_mark_node;\n \n       expr = perform_qualification_conversions (type, expr);\n@@ -6993,6 +7005,22 @@ canonicalize_type_argument (tree arg, tsubst_flags_t complain)\n   return canon;\n }\n \n+/* And from inside dependent non-type arguments like sizeof(Type).  */\n+\n+static tree\n+canonicalize_expr_argument (tree arg, tsubst_flags_t complain)\n+{\n+  if (!arg || arg == error_mark_node)\n+    return arg;\n+  bool removed_attributes = false;\n+  tree canon = strip_typedefs_expr (arg, &removed_attributes);\n+  if (removed_attributes\n+      && (complain & tf_warning))\n+    warning (OPT_Wignored_attributes,\n+\t     \"ignoring attributes in template argument %qE\", arg);\n+  return canon;\n+}\n+\n // A template declaration can be substituted for a constrained\n // template template parameter only when the argument is more\n // constrained than the parameter.\n@@ -7278,7 +7306,7 @@ convert_template_argument (tree parm,\n \t      val = error_mark_node;\n \t    }\n \t}\n-      else if (!dependent_template_arg_p (orig_arg)\n+      else if (!type_dependent_expression_p (orig_arg)\n \t       && !uses_template_parms (t))\n \t/* We used to call digest_init here.  However, digest_init\n \t   will report errors, which we don't want when complain\n@@ -7292,10 +7320,7 @@ convert_template_argument (tree parm,\n \t   argument specification is valid.  */\n \tval = convert_nontype_argument (t, orig_arg, complain);\n       else\n-\t{\n-\t  bool removed_attr = false;\n-\t  val = strip_typedefs_expr (orig_arg, &removed_attr);\n-\t}\n+\tval = canonicalize_expr_argument (orig_arg, complain);\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n@@ -13187,8 +13212,10 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\treturn cp_build_qualified_type_real\n \t\t  (r, cp_type_quals (t) | cp_type_quals (r), complain);\n \t      }\n+\t    else if (code == TEMPLATE_TEMPLATE_PARM)\n+\t      return arg;\n \t    else\n-\t      /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */\n+\t      /* TEMPLATE_PARM_INDEX.  */\n \t      return convert_from_reference (unshare_expr (arg));\n \t  }\n \n@@ -18225,6 +18252,9 @@ static bool uses_deducible_template_parms (tree type);\n static bool\n deducible_expression (tree expr)\n {\n+  /* Strip implicit conversions.  */\n+  while (CONVERT_EXPR_P (expr))\n+    expr = TREE_OPERAND (expr, 0);\n   return (TREE_CODE (expr) == TEMPLATE_PARM_INDEX);\n }\n \n@@ -19567,7 +19597,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n      But the only case I've seen it in so far has been array bounds, where\n      signedness is the only information lost, and I think that will be\n      okay.  */\n-  while (TREE_CODE (parm) == NOP_EXPR)\n+  while (CONVERT_EXPR_P (parm))\n     parm = TREE_OPERAND (parm, 0);\n \n   if (arg == error_mark_node)\n@@ -20056,7 +20086,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n       /* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */\n       /* Type INTEGER_CST can come from ordinary constant template args.  */\n     case INTEGER_CST:\n-      while (TREE_CODE (arg) == NOP_EXPR)\n+      while (CONVERT_EXPR_P (arg))\n \targ = TREE_OPERAND (arg, 0);\n \n       if (TREE_CODE (arg) != INTEGER_CST)"}, {"sha": "2a55943dd65eb518351fcf689f23d9564dd92e9c", "filename": "gcc/testsuite/g++.dg/template/crash53.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash53.C?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -5,7 +5,7 @@ template<int> struct A {};\n \n template<typename T> struct B\n {\n-  template<T I> B(A<I>);  // { dg-error \"template non-type parameter\" }\n+  template<T I> B(A<I>);  // { dg-error \"\" }\n };\n \n B<double> a=A<0>();  // { dg-error \"non-scalar type\" }"}, {"sha": "3d0d8812dce7fb1dc0041a3a9f8cbfefa97fa1b5", "filename": "gcc/testsuite/g++.dg/template/nontype28.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype28.C?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/77656\n+// { dg-do compile { target stdint_types } }\n+\n+#include <stdint.h>\n+\n+template<uint64_t _Val,\n+\t int _Val2 = (_Val >> 32)>\n+class Test {};\n+\n+template<uint32_t _X>\n+class Test2 : Test<_X> {};\n+\n+template<uint32_t _X>\n+class Test3 : Test<(uint64_t) _X> {};"}, {"sha": "2269e0faca387e2fb9ca25327fcb2e7be5380ecc", "filename": "gcc/testsuite/g++.dg/template/nontype3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype3.C?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -16,7 +16,7 @@ template <int *PI>\n void dep6(bar<PI+1> *); // { dg-error \"\" \"integral or enumeration\" }\n \n template <int I>\n-void dep7(bar<I+1> *);\n+void dep7(bar<I+1> *);\t\t// { dg-error \"\" }\n \n template <int *PI>\n void dep8(foo< *PI > *); // { dg-error \"\" \"integral or enumeration\" }"}]}