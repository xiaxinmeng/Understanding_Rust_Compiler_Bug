{"sha": "b748c3d1b7223cc1dd83a6965d51914968dd0d60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0OGMzZDFiNzIyM2NjMWRkODNhNjk2NWQ1MTkxNDk2OGRkMGQ2MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-05-29T14:30:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:22Z"}, "message": "[Ada] Further improve the expansion of array aggregates\n\ngcc/ada/\n\n\t* exp_aggr.adb\n\t(Convert_To_Positional): Add Dims local variable\n\tand pass it in calls to Is_Flat and Flatten.\n\t(Check_Static_Components): Pass Dims in call to\n\tIs_Static_Element.\n\t(Nonflattenable_Next_Aggr): New predicate.\n\t(Flatten): Add Dims parameter and Expr local variable.  Call\n\tNonflattenable_Next_Aggr in a couple of places.  In the case\n\twhen an Others choice is present, check that the element is\n\teither static or a nested aggregate that can be flattened,\n\tbefore disregarding the replication limit for elaboration\n\tpurposes.  Check that a nested array is flattenable in the case\n\tof a multidimensional array in any position.  Remove redundant\n\tcheck in the Others case and pass Dims in call to\n\tIs_Static_Element.  Use Expr variable.\n\t(Is_Flat): Change type of Dims parameter from Int to Nat.\n\t(Is_Static_Element): Add Dims parameter.  Replace tests on\n\tliterals with call to Compile_Time_Known_Value.  If everything\n\telse failed and the dimension is 1, preanalyze the expression\n\tbefore calling again Compile_Time_Known_Value on it.  Return\n\ttrue for null.\n\t(Late_Expansion): Do not expand further if the assignment to the\n\ttarget can be done directly by the back end.", "tree": {"sha": "c3c87cca0d8999941a9bb039124f795c84c23f88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3c87cca0d8999941a9bb039124f795c84c23f88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b748c3d1b7223cc1dd83a6965d51914968dd0d60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b748c3d1b7223cc1dd83a6965d51914968dd0d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b748c3d1b7223cc1dd83a6965d51914968dd0d60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b748c3d1b7223cc1dd83a6965d51914968dd0d60/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98af369b9489b0e8080d603239ef441051529dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98af369b9489b0e8080d603239ef441051529dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98af369b9489b0e8080d603239ef441051529dce"}], "stats": {"total": 198, "additions": 125, "deletions": 73}, "files": [{"sha": "47a080814f529256e72e639bb5b7b2582a3d28ef", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 125, "deletions": 73, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b748c3d1b7223cc1dd83a6965d51914968dd0d60/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b748c3d1b7223cc1dd83a6965d51914968dd0d60/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b748c3d1b7223cc1dd83a6965d51914968dd0d60", "patch": "@@ -4954,6 +4954,7 @@ package body Exp_Aggr is\n       Handle_Bit_Packed : Boolean := False)\n    is\n       Typ                  : constant Entity_Id := Etype (N);\n+      Dims                 : constant Nat := Number_Dimensions (Typ);\n       Max_Others_Replicate : constant Nat := Max_Aggregate_Size (Typ);\n \n       Static_Components : Boolean := True;\n@@ -4964,18 +4965,19 @@ package body Exp_Aggr is\n       --  expansion.\n \n       function Flatten\n-        (N   : Node_Id;\n-         Ix  : Node_Id;\n-         Ixb : Node_Id) return Boolean;\n+        (N    : Node_Id;\n+         Dims : Nat;\n+         Ix   : Node_Id;\n+         Ixb  : Node_Id) return Boolean;\n       --  Convert the aggregate into a purely positional form if possible. On\n       --  entry the bounds of all dimensions are known to be static, and the\n       --  total number of components is safe enough to expand.\n \n-      function Is_Flat (N : Node_Id; Dims : Int) return Boolean;\n-      --  Return True iff the array N is flat (which is not trivial in the case\n-      --  of multidimensional aggregates).\n+      function Is_Flat (N : Node_Id; Dims : Nat) return Boolean;\n+      --  Return True if the aggregate N is flat (which is not trivial in the\n+      --  case of multidimensional aggregates).\n \n-      function Is_Static_Element (N : Node_Id) return Boolean;\n+      function Is_Static_Element (N : Node_Id; Dims : Nat) return Boolean;\n       --  Return True if N, an element of a component association list, i.e.\n       --  N_Component_Association or N_Iterated_Component_Association, has a\n       --  compile-time known value and can be passed as is to the back-end\n@@ -5019,7 +5021,7 @@ package body Exp_Aggr is\n          then\n             Assoc := First (Component_Associations (N));\n             while Present (Assoc) loop\n-               if not Is_Static_Element (Assoc) then\n+               if not Is_Static_Element (Assoc, Dims) then\n                   Static_Components := False;\n                   exit;\n                end if;\n@@ -5034,18 +5036,39 @@ package body Exp_Aggr is\n       -------------\n \n       function Flatten\n-        (N   : Node_Id;\n-         Ix  : Node_Id;\n-         Ixb : Node_Id) return Boolean\n+        (N    : Node_Id;\n+         Dims : Nat;\n+         Ix   : Node_Id;\n+         Ixb  : Node_Id) return Boolean\n       is\n          Loc : constant Source_Ptr := Sloc (N);\n          Blo : constant Node_Id    := Type_Low_Bound (Etype (Ixb));\n          Lo  : constant Node_Id    := Type_Low_Bound (Etype (Ix));\n          Hi  : constant Node_Id    := Type_High_Bound (Etype (Ix));\n-         Lov : Uint;\n-         Hiv : Uint;\n \n-         Others_Present : Boolean := False;\n+         function Cannot_Flatten_Next_Aggr (Expr : Node_Id) return Boolean;\n+         --  Return true if Expr is an aggregate for the next dimension that\n+         --  cannot be recursively flattened.\n+\n+         ------------------------------\n+         -- Cannot_Flatten_Next_Aggr --\n+         ------------------------------\n+\n+         function Cannot_Flatten_Next_Aggr (Expr : Node_Id) return Boolean is\n+         begin\n+            return Nkind (Expr) = N_Aggregate\n+              and then Present (Next_Index (Ix))\n+              and then not\n+                Flatten (Expr, Dims - 1, Next_Index (Ix), Next_Index (Ixb));\n+         end Cannot_Flatten_Next_Aggr;\n+\n+         --  Local variables\n+\n+         Lov            : Uint;\n+         Hiv            : Uint;\n+         Others_Present : Boolean;\n+\n+      --  Start of processing for Flatten\n \n       begin\n          if Nkind (Original_Node (N)) = N_String_Literal then\n@@ -5063,6 +5086,8 @@ package body Exp_Aggr is\n \n          --  Check if there is an others choice\n \n+         Others_Present := False;\n+\n          if Present (Component_Associations (N)) then\n             declare\n                Assoc   : Node_Id;\n@@ -5123,6 +5148,7 @@ package body Exp_Aggr is\n             --  Used to validate Max_Others_Replicate limit\n \n             Elmt         : Node_Id;\n+            Expr         : Node_Id;\n             Num          : Int := UI_To_Int (Lov);\n             Choice_Index : Int;\n             Choice       : Node_Id;\n@@ -5132,11 +5158,10 @@ package body Exp_Aggr is\n             if Present (Expressions (N)) then\n                Elmt := First (Expressions (N));\n                while Present (Elmt) loop\n-                  if Nkind (Elmt) = N_Aggregate\n-                    and then Present (Next_Index (Ix))\n-                    and then\n-                      not Flatten (Elmt, Next_Index (Ix), Next_Index (Ixb))\n-                  then\n+                  --  In the case of a multidimensional array, check that the\n+                  --  aggregate can be recursively flattened.\n+\n+                  if Cannot_Flatten_Next_Aggr (Elmt) then\n                      return False;\n                   end if;\n \n@@ -5155,17 +5180,16 @@ package body Exp_Aggr is\n \n             Elmt := First (Component_Associations (N));\n \n-            if Nkind (Expression (Elmt)) = N_Aggregate then\n-               if Present (Next_Index (Ix))\n-                 and then\n-                   not Flatten\n-                         (Expression (Elmt), Next_Index (Ix), Next_Index (Ixb))\n-               then\n+            Component_Loop : while Present (Elmt) loop\n+               Expr := Expression (Elmt);\n+\n+               --  In the case of a multidimensional array, check that the\n+               --  aggregate can be recursively flattened.\n+\n+               if Cannot_Flatten_Next_Aggr (Expr) then\n                   return False;\n                end if;\n-            end if;\n \n-            Component_Loop : while Present (Elmt) loop\n                Choice := First (Choice_List (Elmt));\n                Choice_Loop : while Present (Choice) loop\n \n@@ -5179,19 +5203,18 @@ package body Exp_Aggr is\n                      --  a loop, we must generate individual assignments and\n                      --  no flattening is possible.\n \n-                     if Nkind (Expression (Elmt)) = N_Quantified_Expression\n-                     then\n+                     if Nkind (Expr) = N_Quantified_Expression then\n                         return False;\n                      end if;\n \n                      for J in Vals'Range loop\n                         if No (Vals (J)) then\n-                           Vals (J)  := New_Copy_Tree (Expression (Elmt));\n+                           Vals (J)  := New_Copy_Tree (Expr);\n                            Rep_Count := Rep_Count + 1;\n \n                            --  Check for maximum others replication. Note that\n                            --  we skip this test if either of the restrictions\n-                           --  No_Elaboration_Code or No_Implicit_Loops is\n+                           --  No_Implicit_Loops or No_Elaboration_Code is\n                            --  active, if this is a preelaborable unit or\n                            --  a predefined unit, or if the unit must be\n                            --  placed in data memory. This also ensures that\n@@ -5207,37 +5230,39 @@ package body Exp_Aggr is\n                               --  Check if duplication is always OK and, if so,\n                               --  continue processing.\n \n-                              if Restriction_Active (No_Elaboration_Code)\n-                                or else Restriction_Active (No_Implicit_Loops)\n+                              if Restriction_Active (No_Implicit_Loops) then\n+                                 null;\n+\n+                              --  If duplication is not always OK, continue\n+                              --  only if either the element is static or is\n+                              --  an aggregate (we already know it is OK).\n+\n+                              elsif not Is_Static_Element (Elmt, Dims)\n+                                and then Nkind (Expr) /= N_Aggregate\n+                              then\n+                                 return False;\n+\n+                              --  Check if duplication is OK for elaboration\n+                              --  purposes and, if so, continue processing.\n+\n+                              elsif Restriction_Active (No_Elaboration_Code)\n                                 or else\n                                   (Ekind (Current_Scope) = E_Package\n-                                    and then Static_Elaboration_Desired\n-                                               (Current_Scope))\n+                                    and then\n+                                   Static_Elaboration_Desired (Current_Scope))\n                                 or else Is_Preelaborated (P)\n                                 or else (Ekind (P) = E_Package_Body\n                                           and then\n-                                            Is_Preelaborated (Spec_Entity (P)))\n+                                         Is_Preelaborated (Spec_Entity (P)))\n                                 or else\n                                   Is_Predefined_Unit (Get_Source_Unit (P))\n                               then\n                                  null;\n \n-                              --  If duplication is not always OK, continue\n-                              --  only if either the element is static or is\n-                              --  an aggregate which can itself be flattened,\n-                              --  and the replication count is not too high.\n-\n-                              elsif (Is_Static_Element (Elmt)\n-                                       or else\n-                                     (Nkind (Expression (Elmt)) = N_Aggregate\n-                                       and then Present (Next_Index (Ix))))\n-                                and then Rep_Count <= Max_Others_Replicate\n-                              then\n-                                 null;\n-\n-                              --  Return False in all the other cases\n+                              --  Otherwise, check that the replication count\n+                              --  is not too high.\n \n-                              else\n+                              elsif Rep_Count > Max_Others_Replicate then\n                                  return False;\n                               end if;\n                            end;\n@@ -5282,8 +5307,7 @@ package body Exp_Aggr is\n                         Choice_Index := UI_To_Int (Expr_Value (Choice));\n \n                         if Choice_Index in Vals'Range then\n-                           Vals (Choice_Index) :=\n-                             New_Copy_Tree (Expression (Elmt));\n+                           Vals (Choice_Index) := New_Copy_Tree (Expr);\n                            goto Continue;\n \n                         --  Choice is statically out-of-range, will be\n@@ -5307,7 +5331,7 @@ package body Exp_Aggr is\n                      for J in UI_To_Int (Expr_Value (Lo)) ..\n                               UI_To_Int (Expr_Value (Hi))\n                      loop\n-                        Vals (J) := New_Copy_Tree (Expression (Elmt));\n+                        Vals (J) := New_Copy_Tree (Expr);\n                      end loop;\n                   end if;\n \n@@ -5335,7 +5359,7 @@ package body Exp_Aggr is\n       -- Is_Flat --\n       -------------\n \n-      function Is_Flat (N : Node_Id; Dims : Int) return Boolean is\n+      function Is_Flat (N : Node_Id; Dims : Nat) return Boolean is\n          Elmt : Node_Id;\n \n       begin\n@@ -5367,17 +5391,13 @@ package body Exp_Aggr is\n       --  Is_Static_Element  --\n       -------------------------\n \n-      function Is_Static_Element (N : Node_Id) return Boolean is\n+      function Is_Static_Element (N : Node_Id; Dims : Nat) return Boolean is\n          Expr : constant Node_Id := Expression (N);\n \n       begin\n-         if Nkind_In (Expr, N_Integer_Literal, N_Real_Literal) then\n-            return True;\n+         --  In most cases the interesting expressions are unambiguously static\n \n-         elsif Is_Entity_Name (Expr)\n-           and then Present (Entity (Expr))\n-           and then Ekind (Entity (Expr)) = E_Enumeration_Literal\n-         then\n+         if Compile_Time_Known_Value (Expr) then\n             return True;\n \n          elsif Nkind (N) = N_Iterated_Component_Association then\n@@ -5389,6 +5409,14 @@ package body Exp_Aggr is\n          then\n             return True;\n \n+         --  However, one may write static expressions that are syntactically\n+         --  ambiguous, so preanalyze the expression before checking it again,\n+         --  but only at the innermost level for a multidimensional array.\n+\n+         elsif Dims = 1 then\n+            Preanalyze_And_Resolve (Expr, Component_Type (Typ));\n+            return Compile_Time_Known_Value (Expr);\n+\n          else\n             return False;\n          end if;\n@@ -5418,7 +5446,7 @@ package body Exp_Aggr is\n       --  elaboration code, so that the aggregate can be used as the\n       --  initial value of a thread-local variable.\n \n-      if Is_Flat (N, Number_Dimensions (Typ)) then\n+      if Is_Flat (N, Dims) then\n          if Static_Array_Aggregate (N) then\n             Set_Compile_Time_Known_Aggregate (N);\n          end if;\n@@ -5453,7 +5481,8 @@ package body Exp_Aggr is\n       --  it will eventually be able to treat such aggregates statically???\n \n       if Aggr_Size_OK (N, Typ)\n-        and then Flatten (N, First_Index (Typ), First_Index (Base_Type (Typ)))\n+        and then\n+          Flatten (N, Dims, First_Index (Typ), First_Index (Base_Type (Typ)))\n       then\n          if Static_Components then\n             Set_Compile_Time_Known_Aggregate (N);\n@@ -8112,17 +8141,40 @@ package body Exp_Aggr is\n       Target : Node_Id) return List_Id\n    is\n       Aggr_Code : List_Id;\n+      New_Aggr  : Node_Id;\n \n    begin\n-      if Is_Array_Type (Etype (N)) then\n-         Aggr_Code :=\n-           Build_Array_Aggr_Code\n-             (N           => N,\n-              Ctype       => Component_Type (Etype (N)),\n-              Index       => First_Index (Typ),\n-              Into        => Target,\n-              Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n-              Indexes     => No_List);\n+      if Is_Array_Type (Typ) then\n+         --  If the assignment can be done directly by the back end, then\n+         --  reset Set_Expansion_Delayed and do not expand further.\n+\n+         if not CodePeer_Mode\n+           and then not Modify_Tree_For_C\n+           and then not Possible_Bit_Aligned_Component (Target)\n+           and then not Is_Possibly_Unaligned_Slice (Target)\n+           and then Aggr_Assignment_OK_For_Backend (N)\n+         then\n+            New_Aggr := New_Copy_Tree (N);\n+            Set_Expansion_Delayed (New_Aggr, False);\n+\n+            Aggr_Code :=\n+              New_List (\n+                Make_OK_Assignment_Statement (Sloc (New_Aggr),\n+                  Name       => Target,\n+                  Expression => New_Aggr));\n+\n+         --  Or else, generate component assignments to it\n+\n+         else\n+            Aggr_Code :=\n+              Build_Array_Aggr_Code\n+                (N           => N,\n+                 Ctype       => Component_Type (Typ),\n+                 Index       => First_Index (Typ),\n+                 Into        => Target,\n+                 Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n+                 Indexes     => No_List);\n+         end if;\n \n       --  Directly or indirectly (e.g. access protected procedure) a record\n "}]}