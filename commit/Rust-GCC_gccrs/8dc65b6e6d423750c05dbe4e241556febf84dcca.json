{"sha": "8dc65b6e6d423750c05dbe4e241556febf84dcca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjNjViNmU2ZDQyMzc1MGMwNWRiZTRlMjQxNTU2ZmViZjg0ZGNjYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-12-23T16:39:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-12-23T16:39:36Z"}, "message": "stor-layout.c (update_alignment_for_field): Correct handling of unnamed bitfields on PCC_BITFIELD_TYPE_MATTERS machines.\n\n\t* stor-layout.c (update_alignment_for_field): Correct handling of\n\tunnamed bitfields on PCC_BITFIELD_TYPE_MATTERS machines.\n\t* doc/tm.texi (PCC_BITFIELD_TYPE_MATTERS): Note that an unnamed\n\tbitfield does not affect alignment.\n\n\t* testsuite/gcc.dg/i386-bitfield3.c: New test.\n\nFrom-SVN: r60439", "tree": {"sha": "159cad292d86d5201b0631ba807629fb2759076d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/159cad292d86d5201b0631ba807629fb2759076d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc65b6e6d423750c05dbe4e241556febf84dcca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc65b6e6d423750c05dbe4e241556febf84dcca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc65b6e6d423750c05dbe4e241556febf84dcca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc65b6e6d423750c05dbe4e241556febf84dcca/comments", "author": null, "committer": null, "parents": [{"sha": "7c02ae17fed20316d9790f679903b274f6abe77d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c02ae17fed20316d9790f679903b274f6abe77d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c02ae17fed20316d9790f679903b274f6abe77d"}], "stats": {"total": 82, "additions": 62, "deletions": 20}, "files": [{"sha": "607b179155e5896d64e63518afab41fa648e36a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dc65b6e6d423750c05dbe4e241556febf84dcca", "patch": "@@ -1,3 +1,10 @@\n+2002-12-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* stor-layout.c (update_alignment_for_field): Correct handling of\n+\tunnamed bitfields on PCC_BITFIELD_TYPE_MATTERS machines.\n+\t* doc/tm.texi (PCC_BITFIELD_TYPE_MATTERS): Note that an unnamed\n+\tbitfield does not affect alignment.\n+\n 2002-12-23  David Edelsohn  <edelsohn@gnu.org>\n \n \t* expr.c (expand_assignment): Apply special treatment to"}, {"sha": "8436e8996663beb96f2f2f077c77fef894e27104", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8dc65b6e6d423750c05dbe4e241556febf84dcca", "patch": "@@ -1181,17 +1181,19 @@ go slower in that case, define this macro as 0.\n Define this if you wish to imitate the way many other C compilers handle\n alignment of bit-fields and the structures that contain them.\n \n-The behavior is that the type written for a bit-field (@code{int},\n-@code{short}, or other integer type) imposes an alignment for the\n-entire structure, as if the structure really did contain an ordinary\n-field of that type.  In addition, the bit-field is placed within the\n-structure so that it would fit within such a field, not crossing a\n-boundary for it.\n-\n-Thus, on most machines, a bit-field whose type is written as @code{int}\n-would not cross a four-byte boundary, and would force four-byte\n-alignment for the whole structure.  (The alignment used may not be four\n-bytes; it is controlled by the other alignment parameters.)\n+The behavior is that the type written for a named bit-field (@code{int},\n+@code{short}, or other integer type) imposes an alignment for the entire\n+structure, as if the structure really did contain an ordinary field of\n+that type.  In addition, the bit-field is placed within the structure so\n+that it would fit within such a field, not crossing a boundary for it.\n+\n+Thus, on most machines, a named bit-field whose type is written as\n+@code{int} would not cross a four-byte boundary, and would force\n+four-byte alignment for the whole structure.  (The alignment used may\n+not be four bytes; it is controlled by the other alignment parameters.)\n+\n+An unnamed bit-field will not affect the alignment of the containing\n+structure.\n \n If the macro is defined, its definition should be a C expression;\n a nonzero value for the expression enables this behavior."}, {"sha": "6c81924b69d165bf673b93641e6ab47fb828a7ae", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=8dc65b6e6d423750c05dbe4e241556febf84dcca", "patch": "@@ -715,22 +715,18 @@ update_alignment_for_field (rli, field, known_align)\n       && DECL_BIT_FIELD_TYPE (field)\n       && ! integer_zerop (TYPE_SIZE (type)))\n     {\n-      /* For these machines, a zero-length field does not\n-\t affect the alignment of the structure as a whole.\n-\t It does, however, affect the alignment of the next field\n-\t within the structure.  */\n-      if (! integer_zerop (DECL_SIZE (field)))\n-\trli->record_align = MAX (rli->record_align, desired_align);\n-      else if (! DECL_PACKED (field))\n+      /* A zero-length bit-field affects the alignment of the next\n+\t field.  */\n+      if (!DECL_PACKED (field) && integer_zerop (DECL_SIZE (field)))\n \t{\n \t  desired_align = TYPE_ALIGN (type);\n #ifdef ADJUST_FIELD_ALIGN\n \t  desired_align = ADJUST_FIELD_ALIGN (field, desired_align);\n #endif\n \t}\n \n-      /* A named bit field of declared type `int'\n-\t forces the entire structure to have `int' alignment.  */\n+      /* Named bit-fields cause the entire structure to have the\n+\t alignment implied by their type.  */\n       if (DECL_NAME (field) != 0)\n \t{\n \t  unsigned int type_align = TYPE_ALIGN (type);\n@@ -745,7 +741,14 @@ update_alignment_for_field (rli, field, known_align)\n \t  else if (DECL_PACKED (field))\n \t    type_align = MIN (type_align, BITS_PER_UNIT);\n \n+\t  /* The alignment of the record is increased to the maximum\n+\t     of the current alignment, the alignment indicated on the\n+\t     field (i.e., the alignment specified by an __aligned__\n+\t     attribute), and the alignment indicated by the type of\n+\t     the field.  */\n+\t  rli->record_align = MAX (rli->record_align, desired_align);\n \t  rli->record_align = MAX (rli->record_align, type_align);\n+\n \t  rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n \t  if (warn_packed)\n \t    rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));"}, {"sha": "c4011100dacf1faa93b86c36f54dcc94b499cc31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8dc65b6e6d423750c05dbe4e241556febf84dcca", "patch": "@@ -1,3 +1,9 @@\n+2002-12-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* testsuite/gcc.dg/i386-bitfield3.c: New test.\n+\t\n+\t* testsuite/gcc.dg/i386-bitfield2.c: New test.\n+\t\n 2002-12-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/parse/conv_op1.C: New test."}, {"sha": "781c2f7ba4eead29675745ceb7ad5dd52280f608", "filename": "gcc/testsuite/gcc.dg/i386-bitfield3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-bitfield3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc65b6e6d423750c05dbe4e241556febf84dcca/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-bitfield3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-bitfield3.c?ref=8dc65b6e6d423750c05dbe4e241556febf84dcca", "patch": "@@ -0,0 +1,24 @@\n+// Test for bitfield alignment in structs on IA-32\n+// { dg-do run { target i?86-*-* } }\n+// { dg-options \"-O2\" }\n+// { dg-options \"-mno-align-double -mno-ms-bitfields\" { target *-*-interix* } }\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+struct X {\n+  int : 32;\n+};\n+\n+struct Y {\n+  int i : 32;\n+};\n+\n+int main () {\n+  if (__alignof__(struct X) != 1)\n+    abort ();\n+  if (__alignof__(struct Y) != 4)\n+    abort ();\n+  \n+  exit (0);\n+}"}]}