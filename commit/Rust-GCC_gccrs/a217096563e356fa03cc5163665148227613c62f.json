{"sha": "a217096563e356fa03cc5163665148227613c62f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxNzA5NjU2M2UzNTZmYTAzY2M1MTYzNjY1MTQ4MjI3NjEzYzYyZg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2017-07-28T15:11:25Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2017-07-28T15:11:25Z"}, "message": "2017-07-28  Tamar Christina  <tamar.christina@arm.com>\n\n\t* config/aarch64/aarch64.c\n\t(aarch64_simd_container_mode): Add prototype.\n\t(aarch64_expand_mov_immediate): Add HI support.\n\t(aarch64_reinterpret_float_as_int, aarch64_float_const_rtx_p: New.\n\t(aarch64_can_const_movi_rtx_p): New.\n\t(aarch64_preferred_reload_class):\n\tRemove restrictions of using FP registers for certain SIMD operations.\n\t(aarch64_rtx_costs): Added new cost for CONST_DOUBLE moves.\n\t(aarch64_valid_floating_const): Add integer move validation.\n\t(aarch64_simd_imm_scalar_p): Remove.\n\t(aarch64_output_scalar_simd_mov_immediate): Generalize function.\n\t(aarch64_legitimate_constant_p): Expand list of supported cases.\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_float_const_rtx_p, aarch64_can_const_movi_rtx_p): New.\n\t(aarch64_reinterpret_float_as_int): New.\n\t(aarch64_simd_imm_scalar_p): Remove.\n\t* config/aarch64/constraints.md (Uvi): New.\n\t(Dd): Split into Ds and new Dd.\n\t* config/aarch64/aarch64.md (*movsi_aarch64):\n\tAdd SIMD mov case.\n\t(*movdi_aarch64): Add SIMD mov case.\n\nFrom-SVN: r250672", "tree": {"sha": "2963cee770d72575de78475ef6ee296e53fe7835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2963cee770d72575de78475ef6ee296e53fe7835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a217096563e356fa03cc5163665148227613c62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a217096563e356fa03cc5163665148227613c62f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a217096563e356fa03cc5163665148227613c62f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a217096563e356fa03cc5163665148227613c62f/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ff50cef10f8fb7fa8e44c3feb7b4a85a8fae56"}], "stats": {"total": 253, "additions": 207, "deletions": 46}, "files": [{"sha": "8b62fd56b08053f638ac9239627d101102717e31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a217096563e356fa03cc5163665148227613c62f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a217096563e356fa03cc5163665148227613c62f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a217096563e356fa03cc5163665148227613c62f", "patch": "@@ -1,3 +1,27 @@\n+2017-07-28  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_simd_container_mode): Add prototype.\n+\t(aarch64_expand_mov_immediate): Add HI support.\n+\t(aarch64_reinterpret_float_as_int, aarch64_float_const_rtx_p: New.\n+\t(aarch64_can_const_movi_rtx_p): New.\n+\t(aarch64_preferred_reload_class):\n+\tRemove restrictions of using FP registers for certain SIMD operations.\n+\t(aarch64_rtx_costs): Added new cost for CONST_DOUBLE moves.\n+\t(aarch64_valid_floating_const): Add integer move validation.\n+\t(aarch64_simd_imm_scalar_p): Remove.\n+\t(aarch64_output_scalar_simd_mov_immediate): Generalize function.\n+\t(aarch64_legitimate_constant_p): Expand list of supported cases.\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_float_const_rtx_p, aarch64_can_const_movi_rtx_p): New.\n+\t(aarch64_reinterpret_float_as_int): New.\n+\t(aarch64_simd_imm_scalar_p): Remove.\n+\t* config/aarch64/constraints.md (Uvi): New.\n+\t(Dd): Split into Ds and new Dd.\n+\t* config/aarch64/aarch64.md (*movsi_aarch64):\n+\tAdd SIMD mov case.\n+\t(*movdi_aarch64): Add SIMD mov case.\n+\n 2017-07-28  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-predcom.c: (struct chain): Handle store-store chain in which"}, {"sha": "beff28e2272b7c771c5ae5f3e17f10fc5f9711d0", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a217096563e356fa03cc5163665148227613c62f", "patch": "@@ -319,13 +319,15 @@ unsigned HOST_WIDE_INT aarch64_and_split_imm2 (HOST_WIDE_INT val_in);\n bool aarch64_and_bitmask_imm (unsigned HOST_WIDE_INT val_in, machine_mode mode);\n int aarch64_branch_cost (bool, bool);\n enum aarch64_symbol_type aarch64_classify_symbolic_expression (rtx);\n+bool aarch64_can_const_movi_rtx_p (rtx x, machine_mode mode);\n bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);\n bool aarch64_constant_address_p (rtx);\n bool aarch64_emit_approx_div (rtx, rtx, rtx);\n bool aarch64_emit_approx_sqrt (rtx, rtx, bool);\n void aarch64_expand_call (rtx, rtx, bool);\n bool aarch64_expand_movmem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);\n+bool aarch64_float_const_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);\n bool aarch64_fusion_enabled_p (enum aarch64_fusion_pairs);\n bool aarch64_gen_movmemqi (rtx *);\n@@ -351,9 +353,9 @@ bool aarch64_pad_arg_upward (machine_mode, const_tree);\n bool aarch64_pad_reg_upward (machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n bool aarch64_regno_ok_for_index_p (int, bool);\n+bool aarch64_reinterpret_float_as_int (rtx value, unsigned HOST_WIDE_INT *fail);\n bool aarch64_simd_check_vect_par_cnst_half (rtx op, machine_mode mode,\n \t\t\t\t\t    bool high);\n-bool aarch64_simd_imm_scalar_p (rtx x, machine_mode mode);\n bool aarch64_simd_imm_zero_p (rtx, machine_mode);\n bool aarch64_simd_scalar_immediate_valid_for_move (rtx, machine_mode);\n bool aarch64_simd_shift_imm_p (rtx, machine_mode, bool);"}, {"sha": "af6e6523098138c88f4057f4bc00be5a89fbacea", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 155, "deletions": 36, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a217096563e356fa03cc5163665148227613c62f", "patch": "@@ -147,6 +147,8 @@ static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t\t\t const_tree type,\n \t\t\t\t\t\t\t int misalignment,\n \t\t\t\t\t\t\t bool is_packed);\n+static machine_mode\n+aarch64_simd_container_mode (machine_mode mode, unsigned width);\n \n /* Major revision number of the ARM Architecture implemented by the target.  */\n unsigned aarch64_architecture_version;\n@@ -4677,6 +4679,69 @@ aarch64_legitimize_address_displacement (rtx *disp, rtx *off, machine_mode mode)\n   return true;\n }\n \n+/* Return the binary representation of floating point constant VALUE in INTVAL.\n+   If the value cannot be converted, return false without setting INTVAL.\n+   The conversion is done in the given MODE.  */\n+bool\n+aarch64_reinterpret_float_as_int (rtx value, unsigned HOST_WIDE_INT *intval)\n+{\n+\n+  /* We make a general exception for 0.  */\n+  if (aarch64_float_const_zero_rtx_p (value))\n+    {\n+      *intval = 0;\n+      return true;\n+    }\n+\n+  machine_mode mode = GET_MODE (value);\n+  if (GET_CODE (value) != CONST_DOUBLE\n+      || !SCALAR_FLOAT_MODE_P (mode)\n+      || GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT\n+      /* Only support up to DF mode.  */\n+      || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (DFmode))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT ival = 0;\n+\n+  long res[2];\n+  real_to_target (res,\n+\t\t  CONST_DOUBLE_REAL_VALUE (value),\n+\t\t  REAL_MODE_FORMAT (mode));\n+\n+  ival = zext_hwi (res[0], 32);\n+  if (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (DFmode))\n+    ival |= (zext_hwi (res[1], 32) << 32);\n+\n+  *intval = ival;\n+  return true;\n+}\n+\n+/* Return TRUE if rtx X is an immediate constant that can be moved using a\n+   single MOV(+MOVK) followed by an FMOV.  */\n+bool\n+aarch64_float_const_rtx_p (rtx x)\n+{\n+  machine_mode mode = GET_MODE (x);\n+  if (mode == VOIDmode)\n+    return false;\n+\n+  /* Determine whether it's cheaper to write float constants as\n+     mov/movk pairs over ldr/adrp pairs.  */\n+  unsigned HOST_WIDE_INT ival;\n+\n+  if (GET_CODE (x) == CONST_DOUBLE\n+      && SCALAR_FLOAT_MODE_P (mode)\n+      && aarch64_reinterpret_float_as_int (x, &ival))\n+    {\n+      machine_mode imode = mode == HFmode ? SImode : int_mode_for_mode (mode);\n+      int num_instr = aarch64_internal_mov_immediate\n+\t\t\t(NULL_RTX, gen_int_mode (ival, imode), false, imode);\n+      return num_instr < 3;\n+    }\n+\n+  return false;\n+}\n+\n /* Return TRUE if rtx X is immediate constant 0.0 */\n bool\n aarch64_float_const_zero_rtx_p (rtx x)\n@@ -4689,6 +4754,49 @@ aarch64_float_const_zero_rtx_p (rtx x)\n   return real_equal (CONST_DOUBLE_REAL_VALUE (x), &dconst0);\n }\n \n+/* Return TRUE if rtx X is immediate constant that fits in a single\n+   MOVI immediate operation.  */\n+bool\n+aarch64_can_const_movi_rtx_p (rtx x, machine_mode mode)\n+{\n+  if (!TARGET_SIMD)\n+     return false;\n+\n+  /* We make a general exception for 0.  */\n+  if (aarch64_float_const_zero_rtx_p (x))\n+      return true;\n+\n+  machine_mode vmode, imode;\n+  unsigned HOST_WIDE_INT ival;\n+\n+  if (GET_CODE (x) == CONST_DOUBLE\n+      && SCALAR_FLOAT_MODE_P (mode))\n+    {\n+      if (!aarch64_reinterpret_float_as_int (x, &ival))\n+\treturn false;\n+\n+      imode = int_mode_for_mode (mode);\n+    }\n+  else if (GET_CODE (x) == CONST_INT\n+\t   && SCALAR_INT_MODE_P (mode))\n+    {\n+       imode = mode;\n+       ival = INTVAL (x);\n+    }\n+  else\n+    return false;\n+\n+   /* use a 64 bit mode for everything except for DI/DF mode, where we use\n+     a 128 bit vector mode.  */\n+  int width = GET_MODE_BITSIZE (mode) == 64 ? 128 : 64;\n+\n+  vmode = aarch64_simd_container_mode (imode, width);\n+  rtx v_op = aarch64_simd_gen_const_vector_dup (vmode, ival);\n+\n+  return aarch64_simd_valid_immediate (v_op, vmode, false, NULL);\n+}\n+\n+\n /* Return the fixed registers used for condition codes.  */\n \n static bool\n@@ -5883,12 +5991,6 @@ aarch64_preferred_reload_class (rtx x, reg_class_t regclass)\n       return NO_REGS;\n     }\n \n-  /* If it's an integer immediate that MOVI can't handle, then\n-     FP_REGS is not an option, so we return NO_REGS instead.  */\n-  if (CONST_INT_P (x) && reg_class_subset_p (regclass, FP_REGS)\n-      && !aarch64_simd_imm_scalar_p (x, GET_MODE (x)))\n-    return NO_REGS;\n-\n   /* Register eliminiation can result in a request for\n      SP+constant->FP_REGS.  We cannot support such operations which\n      use SP as source and an FP_REG as destination, so reject out\n@@ -6838,6 +6940,25 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n       return true;\n \n     case CONST_DOUBLE:\n+\n+      /* First determine number of instructions to do the move\n+\t  as an integer constant.  */\n+      if (!aarch64_float_const_representable_p (x)\n+\t   && !aarch64_can_const_movi_rtx_p (x, mode)\n+\t   && aarch64_float_const_rtx_p (x))\n+\t{\n+\t  unsigned HOST_WIDE_INT ival;\n+\t  bool succeed = aarch64_reinterpret_float_as_int (x, &ival);\n+\t  gcc_assert (succeed);\n+\n+\t  machine_mode imode = mode == HFmode ? SImode\n+\t\t\t\t\t      : int_mode_for_mode (mode);\n+\t  int ncost = aarch64_internal_mov_immediate\n+\t\t(NULL_RTX, gen_int_mode (ival, imode), false, imode);\n+\t  *cost += COSTS_N_INSNS (ncost);\n+\t  return true;\n+\t}\n+\n       if (speed)\n \t{\n \t  /* mov[df,sf]_aarch64.  */\n@@ -10182,18 +10303,16 @@ aarch64_legitimate_pic_operand_p (rtx x)\n /* Return true if X holds either a quarter-precision or\n      floating-point +0.0 constant.  */\n static bool\n-aarch64_valid_floating_const (machine_mode mode, rtx x)\n+aarch64_valid_floating_const (rtx x)\n {\n   if (!CONST_DOUBLE_P (x))\n     return false;\n \n-  if (aarch64_float_const_zero_rtx_p (x))\n+  /* This call determines which constants can be used in mov<mode>\n+     as integer moves instead of constant loads.  */\n+  if (aarch64_float_const_rtx_p (x))\n     return true;\n \n-  /* We only handle moving 0.0 to a TFmode register.  */\n-  if (!(mode == SFmode || mode == DFmode))\n-    return false;\n-\n   return aarch64_float_const_representable_p (x);\n }\n \n@@ -10205,11 +10324,15 @@ aarch64_legitimate_constant_p (machine_mode mode, rtx x)\n   if (TARGET_SIMD && aarch64_vect_struct_mode_p (mode))\n     return false;\n \n-  /* This could probably go away because\n-     we now decompose CONST_INTs according to expand_mov_immediate.  */\n+  /* For these cases we never want to use a literal load.\n+     As such we have to prevent the compiler from forcing these\n+     to memory.  */\n   if ((GET_CODE (x) == CONST_VECTOR\n        && aarch64_simd_valid_immediate (x, mode, false, NULL))\n-      || CONST_INT_P (x) || aarch64_valid_floating_const (mode, x))\n+      || CONST_INT_P (x)\n+      || aarch64_valid_floating_const (x)\n+      || aarch64_can_const_movi_rtx_p (x, mode)\n+      || aarch64_float_const_rtx_p (x))\n \treturn !targetm.cannot_force_const_mem (mode, x);\n \n   if (GET_CODE (x) == HIGH\n@@ -11491,23 +11614,6 @@ aarch64_mask_from_zextract_ops (rtx width, rtx pos)\n   return GEN_INT (mask << UINTVAL (pos));\n }\n \n-bool\n-aarch64_simd_imm_scalar_p (rtx x, machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT imm = INTVAL (x);\n-  int i;\n-\n-  for (i = 0; i < 8; i++)\n-    {\n-      unsigned int byte = imm & 0xff;\n-      if (byte != 0xff && byte != 0)\n-       return false;\n-      imm >>= 8;\n-    }\n-\n-  return true;\n-}\n-\n bool\n aarch64_mov_operand_p (rtx x, machine_mode mode)\n {\n@@ -12899,15 +13005,28 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n }\n \n char*\n-aarch64_output_scalar_simd_mov_immediate (rtx immediate,\n-\t\t\t\t\t  machine_mode mode)\n+aarch64_output_scalar_simd_mov_immediate (rtx immediate,  machine_mode mode)\n {\n+\n+  /* If a floating point number was passed and we desire to use it in an\n+     integer mode do the conversion to integer.  */\n+  if (CONST_DOUBLE_P (immediate) && GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      unsigned HOST_WIDE_INT ival;\n+      if (!aarch64_reinterpret_float_as_int (immediate, &ival))\n+\t  gcc_unreachable ();\n+      immediate = gen_int_mode (ival, mode);\n+    }\n+\n   machine_mode vmode;\n+  /* use a 64 bit mode for everything except for DI/DF mode, where we use\n+     a 128 bit vector mode.  */\n+  int width = GET_MODE_BITSIZE (mode) == 64 ? 128 : 64;\n \n   gcc_assert (!VECTOR_MODE_P (mode));\n-  vmode = aarch64_simd_container_mode (mode, 64);\n+  vmode = aarch64_simd_container_mode (mode, width);\n   rtx v_op = aarch64_simd_gen_const_vector_dup (vmode, INTVAL (immediate));\n-  return aarch64_output_simd_mov_immediate (v_op, vmode, 64);\n+  return aarch64_output_simd_mov_immediate (v_op, vmode, width);\n }\n \n /* Split operands into moves from op[1] + op[2] into op[0].  */"}, {"sha": "43876beb4d00f808964b6c673105c0deef99444d", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=a217096563e356fa03cc5163665148227613c62f", "patch": "@@ -920,8 +920,8 @@\n )\n \n (define_insn_and_split \"*movsi_aarch64\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,k,r,r,r,r,*w,m,  m,r,r  ,*w,r,*w\")\n-\t(match_operand:SI 1 \"aarch64_mov_operand\"  \" r,r,k,M,n,m, m,rZ,*w,Usa,Ush,rZ,w,*w\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,k,r,r,r,r,*w,m,  m,r,r  ,*w, r,*w,w\")\n+\t(match_operand:SI 1 \"aarch64_mov_operand\"  \" r,r,k,M,n,m, m,rZ,*w,Usa,Ush,rZ,w,*w,Ds\"))]\n   \"(register_operand (operands[0], SImode)\n     || aarch64_reg_or_zero (operands[1], SImode))\"\n   \"@\n@@ -938,17 +938,19 @@\n    adrp\\\\t%x0, %A1\n    fmov\\\\t%s0, %w1\n    fmov\\\\t%w0, %s1\n-   fmov\\\\t%s0, %s1\"\n-   \"CONST_INT_P (operands[1]) && !aarch64_move_imm (INTVAL (operands[1]), SImode)\n+   fmov\\\\t%s0, %s1\n+   * return aarch64_output_scalar_simd_mov_immediate (operands[1], SImode);\"\n+  \"CONST_INT_P (operands[1]) && !aarch64_move_imm (INTVAL (operands[1]), SImode)\n     && REG_P (operands[0]) && GP_REGNUM_P (REGNO (operands[0]))\"\n    [(const_int 0)]\n    \"{\n        aarch64_expand_mov_immediate (operands[0], operands[1]);\n        DONE;\n     }\"\n   [(set_attr \"type\" \"mov_reg,mov_reg,mov_reg,mov_imm,mov_imm,load1,load1,store1,store1,\\\n-                     adr,adr,f_mcr,f_mrc,fmov\")\n-   (set_attr \"fp\" \"*,*,*,*,*,*,yes,*,yes,*,*,yes,yes,yes\")]\n+\t\t    adr,adr,f_mcr,f_mrc,fmov,neon_move\")\n+   (set_attr \"fp\" \"*,*,*,*,*,*,yes,*,yes,*,*,yes,yes,yes,*\")\n+   (set_attr \"simd\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes\")]\n )\n \n (define_insn_and_split \"*movdi_aarch64\"\n@@ -971,7 +973,7 @@\n    fmov\\\\t%d0, %x1\n    fmov\\\\t%x0, %d1\n    fmov\\\\t%d0, %d1\n-   movi\\\\t%d0, %1\"\n+   * return aarch64_output_scalar_simd_mov_immediate (operands[1], DImode);\"\n    \"(CONST_INT_P (operands[1]) && !aarch64_move_imm (INTVAL (operands[1]), DImode))\n     && REG_P (operands[0]) && GP_REGNUM_P (REGNO (operands[0]))\"\n    [(const_int 0)]"}, {"sha": "9ce3d4efaf31a301dfb7c1772a6b685fb2cbd2ee", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a217096563e356fa03cc5163665148227613c62f/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=a217096563e356fa03cc5163665148227613c62f", "patch": "@@ -176,6 +176,12 @@\n   (and (match_code \"const_double\")\n        (match_test \"aarch64_float_const_representable_p (op)\")))\n \n+(define_constraint \"Uvi\"\n+  \"A floating point constant which can be used with a\\\n+   MOVI immediate operation.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"aarch64_can_const_movi_rtx_p (op, GET_MODE (op))\")))\n+\n (define_constraint \"Dn\"\n   \"@internal\n  A constraint that matches vector of immediates.\"\n@@ -220,9 +226,17 @@\n \n (define_constraint \"Dd\"\n   \"@internal\n- A constraint that matches an immediate operand valid for AdvSIMD scalar.\"\n+ A constraint that matches an integer immediate operand valid\\\n+ for AdvSIMD scalar operations in DImode.\"\n+ (and (match_code \"const_int\")\n+      (match_test \"aarch64_can_const_movi_rtx_p (op, DImode)\")))\n+\n+(define_constraint \"Ds\"\n+  \"@internal\n+ A constraint that matches an integer immediate operand valid\\\n+ for AdvSIMD scalar operations in SImode.\"\n  (and (match_code \"const_int\")\n-      (match_test \"aarch64_simd_imm_scalar_p (op, GET_MODE (op))\")))\n+      (match_test \"aarch64_can_const_movi_rtx_p (op, SImode)\")))\n \n (define_address_constraint \"Dp\"\n   \"@internal"}]}