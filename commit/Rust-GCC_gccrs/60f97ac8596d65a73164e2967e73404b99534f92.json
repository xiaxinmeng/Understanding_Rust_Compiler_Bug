{"sha": "60f97ac8596d65a73164e2967e73404b99534f92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBmOTdhYzg1OTZkNjVhNzMxNjRlMjk2N2U3MzQwNGI5OTUzNGY5Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-03-29T22:26:17Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-03-29T22:26:17Z"}, "message": "re PR fortran/35203 (OPTIONAL, VALUE actual argument cannot be an INTEGER 0)\n\n2013-03-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/35203\n        * trans-decl.c (create_function_arglist): Pass hidden argument\n        for passed-by-value optional+value dummies.\n        * trans-expr.c (gfc_conv_expr_present,\n        gfc_conv_procedure_call): Handle those.\n\n2013-03-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/35203\n        * gfortran.dg/optional_absent_3.f90: New.\n\nFrom-SVN: r197252", "tree": {"sha": "5c179c350d8b5c238071125bf8bc0ecb063eff87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c179c350d8b5c238071125bf8bc0ecb063eff87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60f97ac8596d65a73164e2967e73404b99534f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f97ac8596d65a73164e2967e73404b99534f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f97ac8596d65a73164e2967e73404b99534f92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f97ac8596d65a73164e2967e73404b99534f92/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e10fa881de2b9fd82f83bc0c4c24227e2a4a97"}], "stats": {"total": 200, "additions": 193, "deletions": 7}, "files": [{"sha": "ab23bcaecdaad673a329b6c45635daab7726d94d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=60f97ac8596d65a73164e2967e73404b99534f92", "patch": "@@ -1,3 +1,11 @@\n+2013-03-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/35203\n+\t* trans-decl.c (create_function_arglist): Pass hidden argument\n+\tfor passed-by-value optional+value dummies.\n+\t* trans-expr.c (gfc_conv_expr_present,\n+\tgfc_conv_procedure_call): Handle those.\n+\n 2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45159"}, {"sha": "fafde89f37baf923a02b64ca9093d8eccff99d28", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=60f97ac8596d65a73164e2967e73404b99534f92", "patch": "@@ -2142,6 +2142,27 @@ create_function_arglist (gfc_symbol * sym)\n \t\ttype = gfc_sym_type (f->sym);\n \t    }\n \t}\n+      /* For noncharacter scalar intrinsic types, VALUE passes the value,\n+\t hence, the optional status cannot be transfered via a NULL pointer.\n+\t Thus, we will use a hidden argument in that case.  */\n+      else if (f->sym->attr.optional && f->sym->attr.value\n+\t       && !f->sym->attr.dimension && !f->sym->ts.type != BT_CLASS\n+\t       && f->sym->ts.type != BT_DERIVED)\n+\t{\n+          tree tmp;\n+          strcpy (&name[1], f->sym->name);\n+          name[0] = '_';\n+          tmp = build_decl (input_location,\n+\t\t\t    PARM_DECL, get_identifier (name),\n+\t\t\t    boolean_type_node);\n+\n+          hidden_arglist = chainon (hidden_arglist, tmp);\n+          DECL_CONTEXT (tmp) = fndecl;\n+          DECL_ARTIFICIAL (tmp) = 1;\n+          DECL_ARG_TYPE (tmp) = boolean_type_node;\n+          TREE_READONLY (tmp) = 1;\n+          gfc_finish_decl (tmp);\n+\t}\n \n       /* For non-constant length array arguments, make sure they use\n \t a different type node from TYPE_ARG_TYPES type.  */"}, {"sha": "98a54d9f6885a93925e1c09cc50a05e94c742ec2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=60f97ac8596d65a73164e2967e73404b99534f92", "patch": "@@ -1126,8 +1126,32 @@ gfc_conv_expr_present (gfc_symbol * sym)\n   tree decl, cond;\n \n   gcc_assert (sym->attr.dummy);\n-\n   decl = gfc_get_symbol_decl (sym);\n+\n+  /* Intrinsic scalars with VALUE attribute which are passed by value\n+     use a hidden argument to denote the present status.  */\n+  if (sym->attr.value && sym->ts.type != BT_CHARACTER\n+      && sym->ts.type != BT_CLASS && sym->ts.type != BT_DERIVED\n+      && !sym->attr.dimension)\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN + 2];\n+      tree tree_name;\n+\n+      gcc_assert (TREE_CODE (decl) == PARM_DECL);\n+      name[0] = '_';\n+      strcpy (&name[1], sym->name);\n+      tree_name = get_identifier (name);\n+\n+      /* Walk function argument list to find hidden arg.  */\n+      cond = DECL_ARGUMENTS (DECL_CONTEXT (decl));\n+      for ( ; cond != NULL_TREE; cond = TREE_CHAIN (cond))\n+\tif (DECL_NAME (cond) == tree_name)\n+\t  break;\n+\n+      gcc_assert (cond);\n+      return cond;\n+    }\n+\n   if (TREE_CODE (decl) != PARM_DECL)\n     {\n       /* Array parameters use a temporary descriptor, we want the real\n@@ -3729,6 +3753,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   tree len;\n   tree base_object;\n   vec<tree, va_gc> *stringargs;\n+  vec<tree, va_gc> *optionalargs;\n   tree result = NULL;\n   gfc_formal_arglist *formal;\n   gfc_actual_arglist *arg;\n@@ -3747,6 +3772,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   arglist = NULL;\n   retargs = NULL;\n   stringargs = NULL;\n+  optionalargs = NULL;\n   var = NULL_TREE;\n   len = NULL_TREE;\n   gfc_clear_ts (&ts);\n@@ -3835,11 +3861,27 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    }\n \t  else\n \t    {\n-\t      /* Pass a NULL pointer for an absent arg.  */\n \t      gfc_init_se (&parmse, NULL);\n-\t      parmse.expr = null_pointer_node;\n-\t      if (arg->missing_arg_type == BT_CHARACTER)\n-\t\tparmse.string_length = build_int_cst (gfc_charlen_type_node, 0);\n+\n+\t      /* For scalar arguments with VALUE attribute which are passed by\n+\t\t value, pass \"0\" and a hidden argument gives the optional\n+\t\t status.  */\n+\t      if (fsym && fsym->attr.optional && fsym->attr.value\n+\t\t  && !fsym->attr.dimension && fsym->ts.type != BT_CHARACTER\n+\t\t  && fsym->ts.type != BT_CLASS && fsym->ts.type != BT_DERIVED)\n+\t\t{\n+\t\t  parmse.expr = fold_convert (gfc_sym_type (fsym),\n+\t\t\t\t\t      integer_zero_node);\n+\t\t  vec_safe_push (optionalargs, boolean_false_node);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Pass a NULL pointer for an absent arg.  */\n+\t\t  parmse.expr = null_pointer_node;\n+\t\t  if (arg->missing_arg_type == BT_CHARACTER)\n+\t\t    parmse.string_length = build_int_cst (gfc_charlen_type_node,\n+\t\t\t\t\t\t\t  0);\n+\t\t}\n \t    }\n \t}\n       else if (arg->expr->expr_type == EXPR_NULL\n@@ -4010,7 +4052,31 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\tgfc_conv_expr (&parmse, e);\n \t\t    }\n \t\t  else\n+\t\t    {\n \t\t    gfc_conv_expr (&parmse, e);\n+\t\t    if (fsym->attr.optional\n+\t\t\t&& fsym->ts.type != BT_CLASS\n+\t\t\t&& fsym->ts.type != BT_DERIVED)\n+\t\t      {\n+\t\t\tif (e->expr_type != EXPR_VARIABLE\n+\t\t\t    || !e->symtree->n.sym->attr.optional\n+\t\t\t    || e->ref != NULL)\n+\t\t\t  vec_safe_push (optionalargs, boolean_true_node);\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    tmp = gfc_conv_expr_present (e->symtree->n.sym);\n+\t\t\t    if (!e->symtree->n.sym->attr.value)\n+\t\t\t      parmse.expr\n+\t\t\t\t= fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\tTREE_TYPE (parmse.expr),\n+\t\t\t\t\ttmp, parmse.expr,\n+\t\t\t\t\tfold_convert (TREE_TYPE (parmse.expr),\n+\t\t\t\t\t\t      integer_zero_node));\n+\n+\t\t\t    vec_safe_push (optionalargs, tmp);\n+\t\t\t  }\n+\t\t      }\n+\t\t    }\n \t\t}\n \t      else if (arg->name && arg->name[0] == '%')\n \t\t/* Argument list functions %VAL, %LOC and %REF are signalled\n@@ -4844,13 +4910,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   gfc_free_interface_mapping (&mapping);\n \n   /* We need to glom RETARGS + ARGLIST + STRINGARGS + APPEND_ARGS.  */\n-  arglen = (vec_safe_length (arglist) + vec_safe_length (stringargs)\n-\t    + vec_safe_length (append_args));\n+  arglen = (vec_safe_length (arglist) + vec_safe_length (optionalargs)\n+\t    + vec_safe_length (stringargs) + vec_safe_length (append_args));\n   vec_safe_reserve (retargs, arglen);\n \n   /* Add the return arguments.  */\n   retargs->splice (arglist);\n \n+  /* Add the hidden present status for optional+value to the arguments.  */\n+  retargs->splice (optionalargs);\n+\n   /* Add the hidden string length parameters to the arguments.  */\n   retargs->splice (stringargs);\n "}, {"sha": "776a0318001387ad828eb1dcba4ea78ccbd7aade", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60f97ac8596d65a73164e2967e73404b99534f92", "patch": "@@ -3,6 +3,11 @@\n \t* gcc.target/i386/avx2-vbroadcastsi128-1.c: Fix intrinsic name.\n \t* gcc.target/i386/avx2-vbroadcastsi128-1.c: Ditto.\n \n+2013-03-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/35203\n+\t* gfortran.dg/optional_absent_3.f90: New.\n+\n 2013-03-29  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/56737"}, {"sha": "f03b4798b3dd91f29d85e8b5bc96318b4ac333b6", "filename": "gcc/testsuite/gfortran.dg/optional_absent_3.f90", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_absent_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60f97ac8596d65a73164e2967e73404b99534f92/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_absent_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_absent_3.f90?ref=60f97ac8596d65a73164e2967e73404b99534f92", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do run }\n+!\n+! PR fortran/35203\n+!\n+! Test VALUE + OPTIONAL\n+! for integer/real/complex/logical which are passed by value\n+!\n+program main\n+  implicit none\n+  call value_test ()\n+contains\n+  subroutine value_test (ii, rr, cc, ll, ii2, rr2, cc2, ll2)\n+    integer, optional :: ii, ii2\n+    real,    optional :: rr, rr2\n+    complex, optional :: cc, cc2\n+    logical, optional :: ll, ll2\n+    value :: ii, rr, cc, ll\n+\n+    call int_test (.false., 0)\n+    call int_test (.false., 0, ii)\n+    call int_test (.false., 0, ii2)\n+    call int_test (.true., 0, 0)\n+    call int_test (.true., 2, 2)\n+\n+    call real_test (.false., 0.0)\n+    call real_test (.false., 0.0, rr)\n+    call real_test (.false., 0.0, rr2)\n+    call real_test (.true., 0.0, 0.0)\n+    call real_test (.true., 2.0, 2.0)\n+\n+    call cmplx_test (.false., cmplx (0.0))\n+    call cmplx_test (.false., cmplx (0.0), cc)\n+    call cmplx_test (.false., cmplx (0.0), cc2)\n+    call cmplx_test (.true., cmplx (0.0), cmplx (0.0))\n+    call cmplx_test (.true., cmplx (2.0), cmplx (2.0))\n+\n+    call bool_test (.false., .false.)\n+    call bool_test (.false., .false., ll)\n+    call bool_test (.false., .false., ll2)\n+    call bool_test (.true., .false., .false.)\n+    call bool_test (.true., .true., .true.)\n+  end subroutine value_test\n+\n+  subroutine int_test (ll, val, x)\n+    logical, value :: ll\n+    integer, value :: val\n+    integer, value, optional :: x\n+    if (ll .neqv. present(x)) call abort\n+    if (present(x)) then\n+      if (x /= val) call abort ()\n+    endif\n+  end subroutine int_test\n+\n+  subroutine real_test (ll, val, x)\n+    logical, value :: ll\n+    real, value :: val\n+    real, value, optional :: x\n+    if (ll .neqv. present(x)) call abort\n+    if (present(x)) then\n+      if (x /= val) call abort ()\n+    endif\n+  end subroutine real_test\n+\n+  subroutine cmplx_test (ll, val, x)\n+    logical, value :: ll\n+    complex, value :: val\n+    complex, value, optional :: x\n+    if (ll .neqv. present(x)) call abort\n+    if (present(x)) then\n+      if (x /= val) call abort ()\n+    endif\n+  end subroutine cmplx_test\n+\n+  subroutine bool_test (ll, val, x)\n+    logical, value :: ll\n+    logical, value :: val\n+    logical, value, optional :: x\n+    if (ll .neqv. present(x)) call abort\n+    if (present(x)) then\n+      if (x .neqv. val) call abort ()\n+    endif\n+  end subroutine bool_test\n+end program main"}]}