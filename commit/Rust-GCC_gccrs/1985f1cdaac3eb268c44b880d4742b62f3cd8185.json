{"sha": "1985f1cdaac3eb268c44b880d4742b62f3cd8185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk4NWYxY2RhYWMzZWIyNjhjNDRiODgwZDQ3NDJiNjJmM2NkODE4NQ==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2004-07-28T16:37:20Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2004-07-28T16:37:20Z"}, "message": "stl_construct.h (_Destroy): New three-argument overload that takes an allocator argument.\n\n\t* include/bits/stl_construct.h (_Destroy): New three-argument\n\toverload that takes an allocator argument.  Another inline\n\tthree-argument overload that takes std::allocator and dispatches\n\tto the two-argument version.\n\t* include/bits/stl_uninitialized.h (__uninitialized_fill_n_aux):\n\tChange return type to void to match uninitialized_fill_n.\n\t(__uninitialized_copy_a_): New function.  Like uninitialized_copy\n\texcept that it takes an allocator and uses it for construct and\n\tdestroy.  If the allocator is std::allocator, dispatches to\n\tuninitialized_copy.\n\t(__uninitialized_fill_a): Likewise.\n\t(__uninitialized_fill_n_a): Likewise.\n\t(__uninitialized_copy_copy): Give it an allocator argument.\n\t(__uninitialized_fill_copy): Likewise.\n\t(__uninitialized_copy_fill): Likewise.\n\t* include/bits/deque.tcc: Use new forms defined in stl_construct.h\n\tand stl_uninitialized.h.  Replace use of single-argument _Construct\n\tand _Destroy with use of allocator's construct and destroy methods.\n\t* include/bits/list.tcc: Likewise.\n\t* include/bits/stl_deque.h: Likewise.\n\t* include/bits/stl_list.h: Likewise.\n\t* include/bits/stl_tree.h: Likewise.\n\t* include/bits/stl_vector.h: Likewise.\n\t* include/bits/vector.tcc: Likewise.\n\t* include/ext/hashtable.h: Use rebind so that allocator_type\n\thas correct type for a container's allocator.  Replace use of\n\tsingle-argument _Construct and _Destroy with use of allocator's\n\tconstruct and destroy methods.\n\t* include/ext/memory (__uninitialized_copy_n_a): New function.\n\tLike uninitialized_copy_n except that it takes an extra parameter,\n\tan allocator, and uses it for construct and destroy operations.\n\t* include/ext/rope: Use new forms defined in stl_construct.h,\n\tstl_uninitialized.h, and ext/memory.  Replace use of single-argument\n\t_Construct and _Destroy with allocator construct and destroy methods.\n\t* include/ext/ropeimpl.h: Likewise.\n\t* include/ext/slist.h: Likewise.\n\t* testsuite/testsuite_allocator.h (check_construct_destroy): New.\n\t* testsuite/testsuite_allocator.cc (check_construct_destroy): New.\n\t* testsuite/23_containers/deque/check_construct_destroy.cc: New.\n\t* testsuite/23_containers/list/check_construct_destroy.cc: New.\n\t* testsuite/23_containers/set/check_construct_destroy.cc: New.\n\t* testsuite/23_containers/vector/check_construct_destroy.cc: New.\n\t* testsuite/ext/hash_check_construct_destroy.cc: New.\n\t* testsuite/ext/slist_check_construct_destroy.cc: New.\n\nFrom-SVN: r85265", "tree": {"sha": "1c1e052f56fe594ac2a2f7349bea7763b2fdca24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c1e052f56fe594ac2a2f7349bea7763b2fdca24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1985f1cdaac3eb268c44b880d4742b62f3cd8185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1985f1cdaac3eb268c44b880d4742b62f3cd8185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1985f1cdaac3eb268c44b880d4742b62f3cd8185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1985f1cdaac3eb268c44b880d4742b62f3cd8185/comments", "author": null, "committer": null, "parents": [{"sha": "6fea55e979fdde5cda078fed67abf0c6e37dfce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fea55e979fdde5cda078fed67abf0c6e37dfce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fea55e979fdde5cda078fed67abf0c6e37dfce9"}], "stats": {"total": 1146, "additions": 977, "deletions": 169}, "files": [{"sha": "124f514df12f360bfad63fd434720bad8b44ba85", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -1,3 +1,50 @@\n+2004-07-28  Matt Austern  <austern@apple.com>\n+\n+\t* include/bits/stl_construct.h (_Destroy): New three-argument\n+\toverload that takes an allocator argument.  Another inline\n+\tthree-argument overload that takes std::allocator and dispatches\n+\tto the two-argument version.\n+\t* include/bits/stl_uninitialized.h (__uninitialized_fill_n_aux):\n+\tChange return type to void to match uninitialized_fill_n.\n+\t(__uninitialized_copy_a_): New function.  Like uninitialized_copy\n+\texcept that it takes an allocator and uses it for construct and\n+\tdestroy.  If the allocator is std::allocator, dispatches to\n+\tuninitialized_copy.\n+\t(__uninitialized_fill_a): Likewise.\n+\t(__uninitialized_fill_n_a): Likewise.\n+\t(__uninitialized_copy_copy): Give it an allocator argument.\n+\t(__uninitialized_fill_copy): Likewise.\n+\t(__uninitialized_copy_fill): Likewise.\n+\t* include/bits/deque.tcc: Use new forms defined in stl_construct.h\n+\tand stl_uninitialized.h.  Replace use of single-argument _Construct\n+\tand _Destroy with use of allocator's construct and destroy methods.\n+\t* include/bits/list.tcc: Likewise.\n+\t* include/bits/stl_deque.h: Likewise.\n+\t* include/bits/stl_list.h: Likewise.\n+\t* include/bits/stl_tree.h: Likewise.\n+\t* include/bits/stl_vector.h: Likewise.\n+\t* include/bits/vector.tcc: Likewise.\n+\t* include/ext/hashtable.h: Use rebind so that allocator_type\n+\thas correct type for a container's allocator.  Replace use of \n+\tsingle-argument _Construct and _Destroy with use of allocator's \n+\tconstruct and destroy methods.\n+\t* include/ext/memory (__uninitialized_copy_n_a): New function.\n+\tLike uninitialized_copy_n except that it takes an extra parameter,\n+\tan allocator, and uses it for construct and destroy operations.\n+\t* include/ext/rope: Use new forms defined in stl_construct.h,\n+\tstl_uninitialized.h, and ext/memory.  Replace use of single-argument \n+\t_Construct and _Destroy with allocator construct and destroy methods.\n+\t* include/ext/ropeimpl.h: Likewise.\n+\t* include/ext/slist.h: Likewise.\n+\t* testsuite/testsuite_allocator.h (check_construct_destroy): New.\n+\t* testsuite/testsuite_allocator.cc (check_construct_destroy): New.\n+\t* testsuite/23_containers/deque/check_construct_destroy.cc: New.\n+\t* testsuite/23_containers/list/check_construct_destroy.cc: New.\n+\t* testsuite/23_containers/set/check_construct_destroy.cc: New.\t\n+\t* testsuite/23_containers/vector/check_construct_destroy.cc: New. \n+\t* testsuite/ext/hash_check_construct_destroy.cc\n+\t* testsuite/ext/slist_check_construct_destroy.cc\n+\t\n 2004-07-28  Alexandre Oliva  <aoliva@redhat.com>\n \n \t2003-10-01  Eric Christopher  <echristo@redhat.com>"}, {"sha": "6b87c3b6ba6735c8b1b70afb51a8f1d5cd224117", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -146,7 +146,8 @@ namespace _GLIBCXX_STD\n \t    {\n \t      std::copy_backward(this->_M_impl._M_start, __first, __last);\n \t      iterator __new_start = this->_M_impl._M_start + __n;\n-\t      std::_Destroy(this->_M_impl._M_start, __new_start);\n+\t      std::_Destroy(this->_M_impl._M_start, __new_start,\n+\t\t\t    this->get_allocator());\n \t      _M_destroy_nodes(this->_M_impl._M_start._M_node,\n \t\t\t       __new_start._M_node);\n \t      this->_M_impl._M_start = __new_start;\n@@ -155,7 +156,8 @@ namespace _GLIBCXX_STD\n \t    {\n \t      std::copy(__last, this->_M_impl._M_finish, __first);\n \t      iterator __new_finish = this->_M_impl._M_finish - __n;\n-\t      std::_Destroy(__new_finish, this->_M_impl._M_finish);\n+\t      std::_Destroy(__new_finish, this->_M_impl._M_finish,\n+\t\t\t    this->get_allocator());\n \t      _M_destroy_nodes(__new_finish._M_node + 1,\n \t\t\t       this->_M_impl._M_finish._M_node + 1);\n \t      this->_M_impl._M_finish = __new_finish;\n@@ -173,21 +175,25 @@ namespace _GLIBCXX_STD\n            __node < this->_M_impl._M_finish._M_node;\n            ++__node)\n \t{\n-\t  std::_Destroy(*__node, *__node + _S_buffer_size());\n+\t  std::_Destroy(*__node, *__node + _S_buffer_size(),\n+\t\t\tthis->get_allocator());\n \t  _M_deallocate_node(*__node);\n \t}\n \n       if (this->_M_impl._M_start._M_node != this->_M_impl._M_finish._M_node)\n \t{\n \t  std::_Destroy(this->_M_impl._M_start._M_cur,\n-\t\t\tthis->_M_impl._M_start._M_last);\n+\t\t\tthis->_M_impl._M_start._M_last,\n+\t\t\tthis->get_allocator());\n \t  std::_Destroy(this->_M_impl._M_finish._M_first,\n-\t\t\tthis->_M_impl._M_finish._M_cur);\n+\t\t\tthis->_M_impl._M_finish._M_cur,\n+\t\t\tthis->get_allocator());\n \t  _M_deallocate_node(this->_M_impl._M_finish._M_first);\n \t}\n       else\n         std::_Destroy(this->_M_impl._M_start._M_cur,\n-\t\t      this->_M_impl._M_finish._M_cur);\n+\t\t      this->_M_impl._M_finish._M_cur,\n+\t\t      this->get_allocator());\n \n       this->_M_impl._M_finish = this->_M_impl._M_start;\n     }\n@@ -218,7 +224,9 @@ namespace _GLIBCXX_STD\n \t  iterator __new_start = _M_reserve_elements_at_front(__n);\n \t  try\n \t    {\n-\t      std::uninitialized_fill(__new_start, this->_M_impl._M_start, __x);\n+\t      std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,\n+\t\t\t\t\t  __x,\n+\t\t\t\t\t  this->get_allocator());\n \t      this->_M_impl._M_start = __new_start;\n \t    }\n \t  catch(...)\n@@ -233,8 +241,9 @@ namespace _GLIBCXX_STD\n \t  iterator __new_finish = _M_reserve_elements_at_back(__n);\n \t  try\n \t    {\n-\t      std::uninitialized_fill(this->_M_impl._M_finish,\n-\t\t\t\t      __new_finish, __x);\n+\t      std::__uninitialized_fill_a(this->_M_impl._M_finish,\n+\t\t\t\t\t  __new_finish, __x,\n+\t\t\t\t\t  this->get_allocator());\n \t      this->_M_impl._M_finish = __new_finish;\n \t    }\n \t  catch(...)\n@@ -259,14 +268,17 @@ namespace _GLIBCXX_STD\n           for (__cur = this->_M_impl._M_start._M_node;\n \t       __cur < this->_M_impl._M_finish._M_node;\n \t       ++__cur)\n-            std::uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n-          std::uninitialized_fill(this->_M_impl._M_finish._M_first,\n-\t\t\t\t  this->_M_impl._M_finish._M_cur,\n-\t\t\t\t  __value);\n+            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(), __value,\n+\t\t\t\t\tthis->get_allocator());\n+          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,\n+\t\t\t\t      this->_M_impl._M_finish._M_cur,\n+\t\t\t\t      __value,\n+\t\t\t\t      this->get_allocator());\n         }\n       catch(...)\n         {\n-          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur));\n+          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),\n+\t\t\tthis->get_allocator());\n           __throw_exception_again;\n         }\n     }\n@@ -310,16 +322,19 @@ namespace _GLIBCXX_STD\n             {\n               _ForwardIterator __mid = __first;\n               std::advance(__mid, _S_buffer_size());\n-              std::uninitialized_copy(__first, __mid, *__cur_node);\n+              std::__uninitialized_copy_a(__first, __mid, *__cur_node,\n+\t\t\t\t\t  this->get_allocator());\n               __first = __mid;\n             }\n-            std::uninitialized_copy(__first, __last,\n-\t\t\t\t    this->_M_impl._M_finish._M_first);\n+            std::__uninitialized_copy_a(__first, __last,\n+\t\t\t\t\tthis->_M_impl._M_finish._M_first,\n+\t\t\t\t\tthis->get_allocator());\n           }\n         catch(...)\n           {\n             std::_Destroy(this->_M_impl._M_start,\n-\t\t\t  iterator(*__cur_node, __cur_node));\n+\t\t\t  iterator(*__cur_node, __cur_node),\n+\t\t\t  this->get_allocator());\n             __throw_exception_again;\n           }\n       }\n@@ -335,7 +350,7 @@ namespace _GLIBCXX_STD\n       *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();\n       try\n         {\n-          std::_Construct(this->_M_impl._M_finish._M_cur, __t_copy);\n+          this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t_copy);\n           this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node\n \t\t\t\t\t      + 1);\n           this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;\n@@ -361,7 +376,7 @@ namespace _GLIBCXX_STD\n           this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node\n \t\t\t\t\t     - 1);\n           this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;\n-          std::_Construct(this->_M_impl._M_start._M_cur, __t_copy);\n+          this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t_copy);\n         }\n       catch(...)\n         {\n@@ -379,7 +394,7 @@ namespace _GLIBCXX_STD\n       _M_deallocate_node(this->_M_impl._M_finish._M_first);\n       this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);\n       this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;\n-      std::_Destroy(this->_M_impl._M_finish._M_cur);\n+      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);\n     }\n \n   // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.\n@@ -391,7 +406,7 @@ namespace _GLIBCXX_STD\n     void deque<_Tp, _Alloc>::\n     _M_pop_front_aux()\n     {\n-      std::_Destroy(this->_M_impl._M_start._M_cur);\n+      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);\n       _M_deallocate_node(this->_M_impl._M_start._M_first);\n       this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);\n       this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;\n@@ -420,7 +435,8 @@ namespace _GLIBCXX_STD\n \t    iterator __new_start = _M_reserve_elements_at_front(__n);\n \t    try\n \t      {\n-\t\tstd::uninitialized_copy(__first, __last, __new_start);\n+\t\tstd::__uninitialized_copy_a(__first, __last, __new_start,\n+\t\t\t\t\t    this->get_allocator());\n \t\tthis->_M_impl._M_start = __new_start;\n \t      }\n \t    catch(...)\n@@ -435,8 +451,9 @@ namespace _GLIBCXX_STD\n \t    iterator __new_finish = _M_reserve_elements_at_back(__n);\n \t    try\n \t      {\n-\t\tstd::uninitialized_copy(__first, __last,\n-\t\t\t\t\tthis->_M_impl._M_finish);\n+\t\tstd::__uninitialized_copy_a(__first, __last,\n+\t\t\t\t\t    this->_M_impl._M_finish,\n+\t\t\t\t\t    this->get_allocator());\n \t\tthis->_M_impl._M_finish = __new_finish;\n \t      }\n \t    catch(...)\n@@ -502,8 +519,9 @@ namespace _GLIBCXX_STD\n \t\t{\n \t\t  iterator __start_n = (this->_M_impl._M_start\n \t\t\t\t\t+ difference_type(__n));\n-\t\t  std::uninitialized_copy(this->_M_impl._M_start, __start_n,\n-\t\t\t\t\t  __new_start);\n+\t\t  std::__uninitialized_copy_a(this->_M_impl._M_start, __start_n,\n+\t\t\t\t\t      __new_start,\n+\t\t\t\t\t      this->get_allocator());\n \t\t  this->_M_impl._M_start = __new_start;\n \t\t  std::copy(__start_n, __pos, __old_start);\n \t\t  fill(__pos - difference_type(__n), __pos, __x_copy);\n@@ -513,7 +531,8 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_copy_fill(this->_M_impl._M_start,\n \t\t\t\t\t\t __pos, __new_start,\n \t\t\t\t\t\t this->_M_impl._M_start,\n-\t\t\t\t\t\t __x_copy);\n+\t\t\t\t\t\t __x_copy,\n+\t\t\t\t\t\t this->get_allocator());\n \t\t  this->_M_impl._M_start = __new_start;\n \t\t  std::fill(__old_start, __pos, __x_copy);\n \t\t}\n@@ -538,8 +557,9 @@ namespace _GLIBCXX_STD\n \t\t{\n \t\t  iterator __finish_n = (this->_M_impl._M_finish\n \t\t\t\t\t - difference_type(__n));\n-\t\t  std::uninitialized_copy(__finish_n, this->_M_impl._M_finish,\n-\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  std::__uninitialized_copy_a(__finish_n, this->_M_impl._M_finish,\n+\t\t\t\t\t      this->_M_impl._M_finish,\n+\t\t\t\t\t      this->get_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n \t\t  std::fill(__pos, __pos + difference_type(__n), __x_copy);\n@@ -549,7 +569,8 @@ namespace _GLIBCXX_STD\n \t\t  std::__uninitialized_fill_copy(this->_M_impl._M_finish,\n \t\t\t\t\t\t __pos + difference_type(__n),\n \t\t\t\t\t\t __x_copy, __pos,\n-\t\t\t\t\t\t this->_M_impl._M_finish);\n+\t\t\t\t\t\t this->_M_impl._M_finish,\n+\t\t\t\t\t\t this->get_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::fill(__pos, __old_finish, __x_copy);\n \t\t}\n@@ -584,8 +605,9 @@ namespace _GLIBCXX_STD\n \t\t  {\n \t\t    iterator __start_n = (this->_M_impl._M_start\n \t\t\t\t\t  + difference_type(__n));\n-\t\t    std::uninitialized_copy(this->_M_impl._M_start, __start_n,\n-\t\t\t\t\t    __new_start);\n+\t\t    std::__uninitialized_copy_a(this->_M_impl._M_start, __start_n,\n+\t\t\t\t\t\t__new_start,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t    this->_M_impl._M_start = __new_start;\n \t\t    std::copy(__start_n, __pos, __old_start);\n \t\t    std::copy(__first, __last, __pos - difference_type(__n));\n@@ -596,7 +618,8 @@ namespace _GLIBCXX_STD\n \t\t    std::advance(__mid, difference_type(__n) - __elemsbefore);\n \t\t    std::__uninitialized_copy_copy(this->_M_impl._M_start,\n \t\t\t\t\t\t   __pos, __first, __mid,\n-\t\t\t\t\t\t   __new_start);\n+\t\t\t\t\t\t   __new_start,\n+\t\t\t\t\t\t   this->get_allocator());\n \t\t    this->_M_impl._M_start = __new_start;\n \t\t    std::copy(__mid, __last, __old_start);\n \t\t  }\n@@ -621,9 +644,10 @@ namespace _GLIBCXX_STD\n \t\t{\n \t\t  iterator __finish_n = (this->_M_impl._M_finish\n \t\t\t\t\t - difference_type(__n));\n-\t\t  std::uninitialized_copy(__finish_n,\n-\t\t\t\t\t  this->_M_impl._M_finish,\n-\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  std::__uninitialized_copy_a(__finish_n,\n+\t\t\t\t\t      this->_M_impl._M_finish,\n+\t\t\t\t\t      this->_M_impl._M_finish,\n+\t\t\t\t\t      this->get_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n \t\t  std::copy(__first, __last, __pos);\n@@ -634,7 +658,8 @@ namespace _GLIBCXX_STD\n \t\t  std::advance(__mid, __elemsafter);\n \t\t  std::__uninitialized_copy_copy(__mid, __last, __pos,\n \t\t\t\t\t\t this->_M_impl._M_finish,\n-\t\t\t\t\t\t this->_M_impl._M_finish);\n+\t\t\t\t\t\t this->_M_impl._M_finish,\n+\t\t\t\t\t\t this->get_allocator());\n \t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy(__first, __mid, __pos);\n \t\t}"}, {"sha": "3362fe0e555bbbab53f5e6e904e057d2ce66fdd8", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -74,7 +74,7 @@ namespace _GLIBCXX_STD\n       {\n         _Node* __tmp = __cur;\n         __cur = static_cast<_Node*>(__cur->_M_next);\n-        std::_Destroy(&__tmp->_M_data);\n+        this->get_allocator().destroy(&__tmp->_M_data);\n         _M_put_node(__tmp);\n       }\n     }"}, {"sha": "112276e27384a82501c67bf4ced2faefd6dc6974", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -154,6 +154,35 @@ namespace std\n \n       std::__destroy_aux(__first, __last, _Has_trivial_destructor());\n     }\n+\n+  /**\n+   * @if maint\n+   * Destroy a range of objects using the supplied allocator.  For\n+   * nondefault allocators we do not optimize away invocation of \n+   * destroy() even if _Tp has a trivial destructor.\n+   * @endif\n+   */\n+\n+  template <typename _Tp> class allocator;\n+\n+  template<typename _ForwardIterator, typename _Allocator>\n+    void\n+    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n+\t     _Allocator __alloc)\n+    {\n+      for (; __first != __last; ++__first)\n+\t__alloc.destroy(&*__first);\n+    }\n+\n+  template<typename _ForwardIterator, typename _Allocator, typename _Tp>\n+    inline void\n+    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n+\t     allocator<_Tp>)\n+    {\n+      _Destroy(__first, __last);\n+    }\n+   \n+\n } // namespace std\n \n #endif /* _STL_CONSTRUCT_H */"}, {"sha": "36a7f39799e0b01f99960a51cd2624f2d3a27c19", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -677,8 +677,8 @@ namespace _GLIBCXX_STD\n        */\n       deque(const deque& __x)\n       : _Base(__x.get_allocator(), __x.size())\n-      { std::uninitialized_copy(__x.begin(), __x.end(),\n-\t\t\t\tthis->_M_impl._M_start); }\n+      { std::__uninitialized_copy_a(__x.begin(), __x.end(), this->_M_impl._M_start,\n+\t\t\t\t    this->get_allocator()); }\n \n       /**\n        *  @brief  Builds a %deque from a range.\n@@ -710,7 +710,8 @@ namespace _GLIBCXX_STD\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n       ~deque()\n-      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }\n+      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t      this->get_allocator()); }\n \n       /**\n        *  @brief  %Deque assignment operator.\n@@ -1004,7 +1005,7 @@ namespace _GLIBCXX_STD\n       {\n \tif (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n \t  {\n-\t    std::_Construct(this->_M_impl._M_start._M_cur - 1, __x);\n+\t    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);\n \t    --this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -1025,7 +1026,7 @@ namespace _GLIBCXX_STD\n \tif (this->_M_impl._M_finish._M_cur\n \t    != this->_M_impl._M_finish._M_last - 1)\n \t  {\n-\t    std::_Construct(this->_M_impl._M_finish._M_cur, __x);\n+\t    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);\n \t    ++this->_M_impl._M_finish._M_cur;\n \t  }\n \telse\n@@ -1046,7 +1047,7 @@ namespace _GLIBCXX_STD\n \tif (this->_M_impl._M_start._M_cur\n \t    != this->_M_impl._M_start._M_last - 1)\n \t  {\n-\t    std::_Destroy(this->_M_impl._M_start._M_cur);\n+\t    this->_M_impl.destroy(this->_M_impl._M_start._M_cur);\n \t    ++this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -1068,7 +1069,7 @@ namespace _GLIBCXX_STD\n \t    != this->_M_impl._M_finish._M_first)\n \t  {\n \t    --this->_M_impl._M_finish._M_cur;\n-\t    std::_Destroy(this->_M_impl._M_finish._M_cur);\n+\t    this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);\n \t  }\n \telse\n \t  _M_pop_back_aux();"}, {"sha": "49df1093ab522af46de46c304597ab989d908111", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -435,7 +435,7 @@ namespace _GLIBCXX_STD\n \t_Node* __p = this->_M_get_node();\n \ttry\n \t  {\n-\t    std::_Construct(&__p->_M_data, __x);\n+\t    this->get_allocator().construct(&__p->_M_data, __x);\n \t  }\n \tcatch(...)\n \t  {\n@@ -457,7 +457,7 @@ namespace _GLIBCXX_STD\n \t_Node* __p = this->_M_get_node();\n \ttry\n \t  {\n-\t    std::_Construct(&__p->_M_data);\n+\t    this->get_allocator().construct(&__p->_M_data);\n \t  }\n \tcatch(...)\n \t  {\n@@ -1170,7 +1170,7 @@ namespace _GLIBCXX_STD\n       {\n         __position._M_node->unhook();\n         _Node* __n = static_cast<_Node*>(__position._M_node);\n-        std::_Destroy(&__n->_M_data);\n+        this->get_allocator().destroy(&__n->_M_data);\n         _M_put_node(__n);\n       }\n     };"}, {"sha": "8ddb8984c16a3106128bc5812d3946267537f2b7", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -362,7 +362,7 @@ namespace std\n       {\n \t_Link_type __tmp = _M_get_node();\n \ttry\n-\t  { std::_Construct(&__tmp->_M_value_field, __x); }\n+\t  { get_allocator().construct(&__tmp->_M_value_field, __x); }\n \tcatch(...)\n \t  {\n \t    _M_put_node(__tmp);\n@@ -384,7 +384,7 @@ namespace std\n       void\n       destroy_node(_Link_type __p)\n       {\n-\tstd::_Destroy(&__p->_M_value_field);\n+\tget_allocator().destroy(&__p->_M_value_field);\n \t_M_put_node(__p);\n       }\n "}, {"sha": "5c65a26bac10b4944e081364906f796392cdc191", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 122, "deletions": 22, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -177,13 +177,13 @@ namespace std\n   // Valid if copy construction is equivalent to assignment, and if the\n   //  destructor is trivial.\n   template<typename _ForwardIterator, typename _Size, typename _Tp>\n-    inline _ForwardIterator\n+    inline void\n     __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,\n \t\t\t       const _Tp& __x, __true_type)\n-    { return std::fill_n(__first, __n, __x); }\n+    { std::fill_n(__first, __n, __x); }\n \n   template<typename _ForwardIterator, typename _Size, typename _Tp>\n-    _ForwardIterator\n+    void\n     __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,\n \t\t\t       const _Tp& __x, __false_type)\n     {\n@@ -192,7 +192,6 @@ namespace std\n \t{\n \t  for (; __n > 0; --__n, ++__cur)\n \t    std::_Construct(&*__cur, __x);\n-\t  return __cur;\n \t}\n       catch(...)\n \t{\n@@ -219,75 +218,176 @@ namespace std\n       std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());\n     }\n \n+  // Extensions: versions of uninitialized_copy, uninitialized_fill,\n+  //  and uninitialized_fill_n that take an allocator parameter.\n+  //  We dispatch back to the standard versions when we're given the\n+  //  default allocator.  For nondefault allocators we do not use \n+  //  any of the POD optimizations.\n+\n+  template<typename _InputIterator, typename _ForwardIterator,\n+\t   typename _Allocator>\n+    _ForwardIterator\n+    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,\n+\t\t\t   _ForwardIterator __result,\n+\t\t\t   _Allocator __alloc)\n+    {\n+      _ForwardIterator __cur = __result;\n+      try\n+\t{\n+\t  for (; __first != __last; ++__first, ++__cur)\n+\t    __alloc.construct(&*__cur, *__first);\n+\t  return __cur;\n+\t}\n+      catch(...)\n+\t{\n+\t  std::_Destroy(__result, __cur, __alloc);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>\n+    inline _ForwardIterator\n+    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,\n+\t\t\t   _ForwardIterator __result,\n+\t\t\t   allocator<_Tp>)\n+    {\n+      return std::uninitialized_copy(__first, __last, __result);\n+    }\n+\n+  template<typename _ForwardIterator, typename _Tp, typename _Allocator>\n+    void\n+    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\t   const _Tp& __x, _Allocator __alloc)\n+    {\n+      _ForwardIterator __cur = __first;\n+      try\n+\t{\n+\t  for (; __cur != __last; ++__cur)\n+\t    __alloc.construct(&*__cur, __x);\n+\t}\n+      catch(...)\n+\t{\n+\t  std::_Destroy(__first, __cur, __alloc);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _ForwardIterator, typename _Tp, typename _Tp2>\n+    inline void\n+    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\t   const _Tp& __x, allocator<_Tp2>)\n+    {\n+      std::uninitialized_fill(__first, __last, __x);\n+    }\n+\n+  template<typename _ForwardIterator, typename _Size, typename _Tp,\n+\t   typename _Allocator>\n+    void\n+    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, \n+\t\t\t     const _Tp& __x,\n+\t\t\t     _Allocator __alloc)\n+    {\n+      _ForwardIterator __cur = __first;\n+      try\n+\t{\n+\t  for (; __n > 0; --__n, ++__cur)\n+\t    __alloc.construct(&*__cur, __x);\n+\t}\n+      catch(...)\n+\t{\n+\t  std::_Destroy(__first, __cur, __alloc);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _ForwardIterator, typename _Size, typename _Tp,\n+\t   typename _Tp2>\n+    void\n+    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, \n+\t\t\t     const _Tp& __x,\n+\t\t\t     allocator<_Tp2>)\n+    {\n+      std::uninitialized_fill_n(__first, __n, __x);\n+    }\n+\n+\n   // Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill,\n-  // __uninitialized_fill_copy.\n+  // __uninitialized_fill_copy.  All of these algorithms take a user-\n+  // supplied allocator, which is used for construction and destruction.\n \n   // __uninitialized_copy_copy\n   // Copies [first1, last1) into [result, result + (last1 - first1)), and\n   //  copies [first2, last2) into\n   //  [result, result + (last1 - first1) + (last2 - first2)).\n \n   template<typename _InputIterator1, typename _InputIterator2,\n-\t   typename _ForwardIterator>\n+\t   typename _ForwardIterator, typename _Allocator>\n     inline _ForwardIterator\n     __uninitialized_copy_copy(_InputIterator1 __first1,\n \t\t\t      _InputIterator1 __last1,\n \t\t\t      _InputIterator2 __first2,\n \t\t\t      _InputIterator2 __last2,\n-\t\t\t      _ForwardIterator __result)\n+\t\t\t      _ForwardIterator __result,\n+\t\t\t      _Allocator __alloc)\n     {\n-      _ForwardIterator __mid = std::uninitialized_copy(__first1, __last1,\n-\t\t\t\t\t\t       __result);\n+      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,\n+\t\t\t\t\t\t\t   __result,\n+\t\t\t\t\t\t\t   __alloc);\n       try\n \t{\n-\t  return std::uninitialized_copy(__first2, __last2, __mid);\n+\t  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);\n \t}\n       catch(...)\n \t{\n-\t  std::_Destroy(__result, __mid);\n+\t  std::_Destroy(__result, __mid, __alloc);\n \t  __throw_exception_again;\n \t}\n     }\n \n   // __uninitialized_fill_copy\n   // Fills [result, mid) with x, and copies [first, last) into\n   //  [mid, mid + (last - first)).\n-  template<typename _ForwardIterator, typename _Tp, typename _InputIterator>\n+  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,\n+\t   typename _Allocator>\n     inline _ForwardIterator\n     __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,\n \t\t\t      const _Tp& __x, _InputIterator __first,\n-\t\t\t      _InputIterator __last)\n+\t\t\t      _InputIterator __last,\n+\t\t\t      _Allocator __alloc)\n     {\n-      std::uninitialized_fill(__result, __mid, __x);\n+      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);\n       try\n \t{\n-\t  return std::uninitialized_copy(__first, __last, __mid);\n+\t  return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);\n \t}\n       catch(...)\n \t{\n-\t  std::_Destroy(__result, __mid);\n+\t  std::_Destroy(__result, __mid, __alloc);\n \t  __throw_exception_again;\n \t}\n     }\n \n   // __uninitialized_copy_fill\n   // Copies [first1, last1) into [first2, first2 + (last1 - first1)), and\n   //  fills [first2 + (last1 - first1), last2) with x.\n-  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>\n+  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,\n+\t   typename _Allocator>\n     inline void\n     __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,\n \t\t\t      _ForwardIterator __first2,\n-\t\t\t      _ForwardIterator __last2, const _Tp& __x)\n+\t\t\t      _ForwardIterator __last2, const _Tp& __x,\n+\t\t\t      _Allocator __alloc)\n     {\n-      _ForwardIterator __mid2 = std::uninitialized_copy(__first1, __last1,\n-\t\t\t\t\t\t\t__first2);\n+      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,\n+\t\t\t\t\t\t\t    __first2,\n+\t\t\t\t\t\t\t    __alloc);\n       try\n \t{\n-\t  std::uninitialized_fill(__mid2, __last2, __x);\n+\t  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);\n \t}\n       catch(...)\n \t{\n-\t  std::_Destroy(__first2, __mid2);\n+\t  std::_Destroy(__first2, __mid2, __alloc);\n \t  __throw_exception_again;\n \t}\n     }"}, {"sha": "10433f9ad13ba6d6a970141e89b188d8af5f45f2", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -200,7 +200,8 @@ namespace _GLIBCXX_STD\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n       {\n-\tstd::uninitialized_fill_n(this->_M_impl._M_start, __n, __value);\n+\tstd::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,\n+\t\t\t\t      this->get_allocator());\n \tthis->_M_impl._M_finish = this->_M_impl._M_start + __n;\n       }\n \n@@ -215,7 +216,8 @@ namespace _GLIBCXX_STD\n       vector(size_type __n)\n       : _Base(__n, allocator_type())\n       {\n-\tstd::uninitialized_fill_n(this->_M_impl._M_start, __n, value_type());\n+\tstd::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, value_type(),\n+\t\t\t\t      this->get_allocator());\n \tthis->_M_impl._M_finish = this->_M_impl._M_start + __n;\t\n       }\n \n@@ -230,10 +232,11 @@ namespace _GLIBCXX_STD\n        */\n       vector(const vector& __x)\n       : _Base(__x.size(), __x.get_allocator())\n-      { this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(),\n-\t\t\t\t\t\t\t  __x.end(),\n-\t\t\t\t\t\t\t  this->\n-\t\t\t\t\t\t\t  _M_impl._M_start); }\n+      { this->_M_impl._M_finish =\n+\t  std::__uninitialized_copy_a(__x.begin(), __x.end(),\n+\t\t\t\t      this->_M_impl._M_start,\n+\t\t\t\t      this->get_allocator());\n+      }\n \n       /**\n        *  @brief  Builds a %vector from a range.\n@@ -267,7 +270,9 @@ namespace _GLIBCXX_STD\n        *  responsibilty.\n        */\n       ~vector()\n-      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }\n+      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t      this->get_allocator());\n+      }\n \n       /**\n        *  @brief  %Vector assignment operator.\n@@ -598,7 +603,7 @@ namespace _GLIBCXX_STD\n       {\n \tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t  {\n-\t    std::_Construct(this->_M_impl._M_finish, __x);\n+\t    this->_M_impl.construct(this->_M_impl._M_finish, __x);\n \t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n@@ -618,7 +623,7 @@ namespace _GLIBCXX_STD\n       pop_back()\n       {\n \t--this->_M_impl._M_finish;\n-\tstd::_Destroy(this->_M_impl._M_finish);\n+\tthis->_M_impl.destroy(this->_M_impl._M_finish);\n       }\n \n       /**\n@@ -758,7 +763,8 @@ namespace _GLIBCXX_STD\n \t  pointer __result = this->_M_allocate(__n);\n \t  try\n \t    {\n-\t      std::uninitialized_copy(__first, __last, __result);\n+\t      std::__uninitialized_copy_a(__first, __last, __result,\n+\t\t\t\t\t  this->get_allocator());\n \t      return __result;\n \t    }\n \t  catch(...)\n@@ -778,7 +784,8 @@ namespace _GLIBCXX_STD\n         {\n \t  this->_M_impl._M_start = _M_allocate(__n);\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n-\t  std::uninitialized_fill_n(this->_M_impl._M_start, __n, __value);\n+\t  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,\n+\t\t\t\t\tthis->get_allocator());\n \t  this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;\n \t}\n \n@@ -812,9 +819,10 @@ namespace _GLIBCXX_STD\n \t  const size_type __n = std::distance(__first, __last);\n \t  this->_M_impl._M_start = this->_M_allocate(__n);\n \t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n-\t  this->_M_impl._M_finish = std::uninitialized_copy(__first, __last,\n-\t\t\t\t\t\t\t    this->\n-\t\t\t\t\t\t\t    _M_impl._M_start);\n+\t  this->_M_impl._M_finish =\n+\t    std::__uninitialized_copy_a(__first, __last,\n+\t\t\t\t\tthis->_M_impl._M_start,\n+\t\t\t\t\tthis->get_allocator());\n \t}\n \n "}, {"sha": "4231715fb11b6bf55063b92e37a2928177a29691", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 87, "deletions": 66, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -76,7 +76,8 @@ namespace _GLIBCXX_STD\n \t  pointer __tmp = _M_allocate_and_copy(__n,\n \t\t\t\t\t       this->_M_impl._M_start,\n \t\t\t\t\t       this->_M_impl._M_finish);\n-\t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\tthis->get_allocator());\n \t  _M_deallocate(this->_M_impl._M_start,\n \t\t\tthis->_M_impl._M_end_of_storage\n \t\t\t- this->_M_impl._M_start);\n@@ -95,7 +96,7 @@ namespace _GLIBCXX_STD\n       if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage\n \t  && __position == end())\n \t{\n-\t  std::_Construct(this->_M_impl._M_finish, __x);\n+\t  this->_M_impl.construct(this->_M_impl._M_finish, __x);\n \t  ++this->_M_impl._M_finish;\n \t}\n       else\n@@ -111,7 +112,7 @@ namespace _GLIBCXX_STD\n       if (__position + 1 != end())\n         std::copy(__position + 1, end(), __position);\n       --this->_M_impl._M_finish;\n-      std::_Destroy(this->_M_impl._M_finish);\n+      this->_M_impl.destroy(this->_M_impl._M_finish);\n       return __position;\n     }\n \n@@ -121,7 +122,7 @@ namespace _GLIBCXX_STD\n     erase(iterator __first, iterator __last)\n     {\n       iterator __i(copy(__last, end(), __first));\n-      std::_Destroy(__i, end());\n+      std::_Destroy(__i, end(), this->get_allocator());\n       this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);\n       return __first;\n     }\n@@ -138,8 +139,8 @@ namespace _GLIBCXX_STD\n \t    {\n \t      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),\n \t\t\t\t\t\t   __x.end());\n-\t      std::_Destroy(this->_M_impl._M_start,\n-\t\t\t    this->_M_impl._M_finish);\n+\t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t    this->get_allocator());\n \t      _M_deallocate(this->_M_impl._M_start,\n \t\t\t    this->_M_impl._M_end_of_storage\n \t\t\t    - this->_M_impl._M_start);\n@@ -149,14 +150,15 @@ namespace _GLIBCXX_STD\n \t  else if (size() >= __xlen)\n \t    {\n \t      iterator __i(copy(__x.begin(), __x.end(), begin()));\n-\t      std::_Destroy(__i, end());\n+\t      std::_Destroy(__i, end(), this->get_allocator());\n \t    }\n \t  else\n \t    {\n \t      std::copy(__x.begin(), __x.begin() + size(),\n \t\t\tthis->_M_impl._M_start);\n-\t      std::uninitialized_copy(__x.begin() + size(),\n-\t\t\t\t      __x.end(), this->_M_impl._M_finish);\n+\t      std::__uninitialized_copy_a(__x.begin() + size(),\n+\t\t\t\t\t  __x.end(), this->_M_impl._M_finish,\n+\t\t\t\t\t  this->get_allocator());\n \t    }\n \t  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;\n \t}\n@@ -176,8 +178,9 @@ namespace _GLIBCXX_STD\n       else if (__n > size())\n \t{\n \t  std::fill(begin(), end(), __val);\n-\t  std::uninitialized_fill_n(this->_M_impl._M_finish,\n-\t\t\t\t    __n - size(), __val);\n+\t  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,\n+\t\t\t\t\t__n - size(), __val,\n+\t\t\t\t\tthis->get_allocator());\n \t  this->_M_impl._M_finish += __n - size();\n \t}\n       else\n@@ -212,7 +215,8 @@ namespace _GLIBCXX_STD\n \tif (__len > capacity())\n \t  {\n \t    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-\t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t  this->get_allocator());\n \t    _M_deallocate(this->_M_impl._M_start,\n \t\t\t  this->_M_impl._M_end_of_storage\n \t\t\t  - this->_M_impl._M_start);\n@@ -224,18 +228,18 @@ namespace _GLIBCXX_STD\n \t  {\n \t    iterator __new_finish(copy(__first, __last,\n \t\t\t\t       this->_M_impl._M_start));\n-\t    std::_Destroy(__new_finish, end());\n+\t    std::_Destroy(__new_finish, end(), this->get_allocator());\n \t    this->_M_impl._M_finish = __new_finish.base();\n \t  }\n \telse\n \t  {\n \t    _ForwardIterator __mid = __first;\n \t    std::advance(__mid, size());\n \t    std::copy(__first, __mid, this->_M_impl._M_start);\n-\t    this->_M_impl._M_finish = std::uninitialized_copy(__mid,\n-\t\t\t\t\t\t\t      __last,\n-\t\t\t\t\t\t\t      this->_M_impl.\n-\t\t\t\t\t\t\t      _M_finish);\n+\t    this->_M_impl._M_finish =\n+\t      std::__uninitialized_copy_a(__mid, __last,\n+\t\t\t\t\t  this->_M_impl._M_finish,\n+\t\t\t\t\t  this->get_allocator());\n \t  }\n       }\n \n@@ -246,8 +250,8 @@ namespace _GLIBCXX_STD\n     {\n       if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t{\n-\t  std::_Construct(this->_M_impl._M_finish,\n-\t\t\t  *(this->_M_impl._M_finish - 1));\n+\t  this->_M_impl.construct(this->_M_impl._M_finish,\n+\t\t\t\t  *(this->_M_impl._M_finish - 1));\n \t  ++this->_M_impl._M_finish;\n \t  _Tp __x_copy = __x;\n \t  std::copy_backward(__position,\n@@ -263,24 +267,26 @@ namespace _GLIBCXX_STD\n \t  iterator __new_finish(__new_start);\n \t  try\n \t    {\n-\t      __new_finish = std::uninitialized_copy(iterator(this->\n-\t\t\t\t\t\t\t      _M_impl._M_start),\n-\t\t\t\t\t\t     __position,\n-\t\t\t\t\t\t     __new_start);\n-\t      std::_Construct(__new_finish.base(), __x);\n+\t      __new_finish =\n+\t\tstd::__uninitialized_copy_a(iterator(this->_M_impl._M_start),\n+\t\t\t\t\t    __position,\n+\t\t\t\t\t    __new_start,\n+\t\t\t\t\t    this->get_allocator());\n+\t      this->_M_impl.construct(__new_finish.base(), __x);\n \t      ++__new_finish;\n-\t      __new_finish = std::uninitialized_copy(__position,\n-\t\t\t\t\t\t     iterator(this->_M_impl.\n-\t\t\t\t\t\t\t      _M_finish),\n-\t\t\t\t\t\t     __new_finish);\n+\t      __new_finish =\n+\t\tstd::__uninitialized_copy_a(__position,\n+\t\t\t\t\t    iterator(this->_M_impl._M_finish),\n+\t\t\t\t\t    __new_finish,\n+\t\t\t\t\t    this->get_allocator());\n           }\n \t  catch(...)\n \t    {\n-\t      std::_Destroy(__new_start,__new_finish);\n+\t      std::_Destroy(__new_start, __new_finish, this->get_allocator());\n \t      _M_deallocate(__new_start.base(),__len);\n \t      __throw_exception_again;\n \t    }\n-\t  std::_Destroy(begin(), end());\n+\t  std::_Destroy(begin(), end(), this->get_allocator());\n \t  _M_deallocate(this->_M_impl._M_start,\n \t\t\tthis->_M_impl._M_end_of_storage\n \t\t\t- this->_M_impl._M_start);\n@@ -305,22 +311,25 @@ namespace _GLIBCXX_STD\n \t      iterator __old_finish(this->_M_impl._M_finish);\n \t      if (__elems_after > __n)\n \t\t{\n-\t\t  std::uninitialized_copy(this->_M_impl._M_finish - __n,\n-\t\t\t\t\t  this->_M_impl._M_finish,\n-\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,\n+\t\t\t\t\t      this->_M_impl._M_finish,\n+\t\t\t\t\t      this->_M_impl._M_finish,\n+\t\t\t\t\t      this->get_allocator());\n \t\t  this->_M_impl._M_finish += __n;\n \t\t  std::copy_backward(__position, __old_finish - __n,\n \t\t\t\t     __old_finish);\n \t\t  std::fill(__position, __position + __n, __x_copy);\n \t\t}\n \t      else\n \t\t{\n-\t\t  std::uninitialized_fill_n(this->_M_impl._M_finish,\n-\t\t\t\t\t    __n - __elems_after,\n-\t\t\t\t\t    __x_copy);\n+\t\t  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,\n+\t\t\t\t\t\t__n - __elems_after,\n+\t\t\t\t\t\t__x_copy,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t  this->_M_impl._M_finish += __n - __elems_after;\n-\t\t  std::uninitialized_copy(__position, __old_finish,\n-\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  std::__uninitialized_copy_a(__position, __old_finish,\n+\t\t\t\t\t      this->_M_impl._M_finish,\n+\t\t\t\t\t      this->get_allocator());\n \t\t  this->_M_impl._M_finish += __elems_after;\n \t\t  std::fill(__position, __old_finish, __x_copy);\n \t\t}\n@@ -333,20 +342,26 @@ namespace _GLIBCXX_STD\n \t      iterator __new_finish(__new_start);\n \t      try\n \t\t{\n-\t\t  __new_finish = std::uninitialized_copy(begin(), __position,\n-\t\t\t\t\t\t\t __new_start);\n-\t\t  std::uninitialized_fill_n(__new_finish, __n, __x);\n+\t\t  __new_finish =\n+\t\t    std::__uninitialized_copy_a(begin(), __position,\n+\t\t\t\t\t\t__new_start,\n+\t\t\t\t\t\tthis->get_allocator());\n+\t\t  std::__uninitialized_fill_n_a(__new_finish, __n, __x,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t  __new_finish += __n;\n-\t\t  __new_finish = std::uninitialized_copy(__position, end(),\n-\t\t\t\t\t\t\t __new_finish);\n+\t\t  __new_finish =\n+\t\t    std::__uninitialized_copy_a(__position, end(), __new_finish,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t}\n \t      catch(...)\n \t\t{\n-\t\t  std::_Destroy(__new_start, __new_finish);\n+\t\t  std::_Destroy(__new_start, __new_finish,\n+\t\t\t\tthis->get_allocator());\n \t\t  _M_deallocate(__new_start.base(), __len);\n \t\t  __throw_exception_again;\n \t\t}\n-\t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t    this->get_allocator());\n \t      _M_deallocate(this->_M_impl._M_start,\n \t\t\t    this->_M_impl._M_end_of_storage\n \t\t\t    - this->_M_impl._M_start);\n@@ -387,9 +402,10 @@ namespace _GLIBCXX_STD\n \t\titerator __old_finish(this->_M_impl._M_finish);\n \t\tif (__elems_after > __n)\n \t\t  {\n-\t\t    std::uninitialized_copy(this->_M_impl._M_finish - __n,\n-\t\t\t\t\t    this->_M_impl._M_finish,\n-\t\t\t\t\t    this->_M_impl._M_finish);\n+\t\t    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,\n+\t\t\t\t\t\tthis->_M_impl._M_finish,\n+\t\t\t\t\t\tthis->_M_impl._M_finish,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t    this->_M_impl._M_finish += __n;\n \t\t    std::copy_backward(__position, __old_finish - __n,\n \t\t\t\t       __old_finish);\n@@ -399,11 +415,13 @@ namespace _GLIBCXX_STD\n \t\t  {\n \t\t    _ForwardIterator __mid = __first;\n \t\t    std::advance(__mid, __elems_after);\n-\t\t    std::uninitialized_copy(__mid, __last,\n-\t\t\t\t\t    this->_M_impl._M_finish);\n+\t\t    std::__uninitialized_copy_a(__mid, __last,\n+\t\t\t\t\t\tthis->_M_impl._M_finish,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t    this->_M_impl._M_finish += __n - __elems_after;\n-\t\t    std::uninitialized_copy(__position, __old_finish,\n-\t\t\t\t\t    this->_M_impl._M_finish);\n+\t\t    std::__uninitialized_copy_a(__position, __old_finish,\n+\t\t\t\t\t\tthis->_M_impl._M_finish,\n+\t\t\t\t\t\tthis->get_allocator());\n \t\t    this->_M_impl._M_finish += __elems_after;\n \t\t    std::copy(__first, __mid, __position);\n \t\t  }\n@@ -416,26 +434,29 @@ namespace _GLIBCXX_STD\n \t\titerator __new_finish(__new_start);\n \t\ttry\n \t\t  {\n-\t\t    __new_finish = std::uninitialized_copy(iterator(this->\n-\t\t\t\t\t\t\t\t    _M_impl.\n-\t\t\t\t\t\t\t\t    _M_start),\n-\t\t\t\t\t\t\t   __position,\n-\t\t\t\t\t\t\t   __new_start);\n-\t\t    __new_finish = std::uninitialized_copy(__first, __last,\n-\t\t\t\t\t\t\t   __new_finish);\n-\t\t    __new_finish = std::uninitialized_copy(__position,\n-\t\t\t\t\t\t\t   iterator(this->\n-\t\t\t\t\t\t\t\t    _M_impl.\n-\t\t\t\t\t\t\t\t    _M_finish),\n-\t\t\t\t\t\t\t   __new_finish);\n+\t\t    __new_finish =\n+\t\t      std::__uninitialized_copy_a(iterator(this->_M_impl._M_start),\n+\t\t\t\t\t\t  __position,\n+\t\t\t\t\t\t  __new_start,\n+\t\t\t\t\t\t  this->get_allocator());\n+\t\t    __new_finish =\n+\t\t      std::__uninitialized_copy_a(__first, __last, __new_finish,\n+\t\t\t\t\t\t  this->get_allocator());\n+\t\t    __new_finish =\n+\t\t      std::__uninitialized_copy_a(__position,\n+\t\t\t\t\t\t  iterator(this->_M_impl._M_finish),\n+\t\t\t\t\t\t  __new_finish,\n+\t\t\t\t\t\t  this->get_allocator());\n \t\t  }\n \t\tcatch(...)\n \t\t  {\n-\t\t    std::_Destroy(__new_start,__new_finish);\n+\t\t    std::_Destroy(__new_start,__new_finish,\n+\t\t\t\t  this->get_allocator());\n \t\t    _M_deallocate(__new_start.base(), __len);\n \t\t    __throw_exception_again;\n \t\t  }\n-\t\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t\tstd::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,\n+\t\t\t      this->get_allocator());\n \t\t_M_deallocate(this->_M_impl._M_start,\n \t\t\t      this->_M_impl._M_end_of_storage\n \t\t\t      - this->_M_impl._M_start);"}, {"sha": "6f3aee48bf4d04319358002f4a8a19e763f14a12", "filename": "libstdc++-v3/include/ext/hashtable.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhashtable.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -281,7 +281,7 @@ namespace __gnu_cxx\n       typedef _Hashtable_node<_Val> _Node;\n \n     public:\n-      typedef _Alloc allocator_type;\n+      typedef typename _Alloc::template rebind<value_type>::other allocator_type;\n       allocator_type\n       get_allocator() const\n       { return _M_node_allocator; }\n@@ -607,7 +607,7 @@ namespace __gnu_cxx\n \t__n->_M_next = 0;\n \ttry\n \t  {\n-\t    _Construct(&__n->_M_val, __obj);\n+\t    this->get_allocator().construct(&__n->_M_val, __obj);\n \t    return __n;\n \t  }\n \tcatch(...)\n@@ -620,7 +620,7 @@ namespace __gnu_cxx\n       void\n       _M_delete_node(_Node* __n)\n       {\n-\t_Destroy(&__n->_M_val);\n+\tthis->get_allocator().destroy(&__n->_M_val);\n \t_M_put_node(__n);\n       }\n       "}, {"sha": "dc04657180d68b4f9a8e2c93ebb6f3e2284510fe", "filename": "libstdc++-v3/include/ext/memory", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -128,6 +128,40 @@ namespace __gnu_cxx\n     { return __uninitialized_copy_n(__first, __count, __result,\n \t\t\t\t    __iterator_category(__first)); }\n \n+\n+  // An alternative version of uninitialized_copy_n that constructs\n+  // and destroys objects with a user-provided allocator.\n+  template<typename _InputIter, typename _Size, typename _ForwardIter,\n+           typename _Allocator>\n+    pair<_InputIter, _ForwardIter>\n+    __uninitialized_copy_n_a(_InputIter __first, _Size __count,\n+\t\t\t     _ForwardIter __result,\n+\t\t\t     _Allocator __alloc)\n+    {\n+      _ForwardIter __cur = __result;\n+      try\n+\t{\n+\t  for (; __count > 0 ; --__count, ++__first, ++__cur)\n+\t    __alloc.construct(&*__cur, *__first);\n+\t  return pair<_InputIter, _ForwardIter>(__first, __cur);\n+\t}\n+      catch(...)\n+\t{\n+\t  std::_Destroy(__result, __cur, __alloc);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _InputIter, typename _Size, typename _ForwardIter,\n+           typename _Tp>\n+    inline pair<_InputIter, _ForwardIter>\n+    __uninitialized_copy_n_a(_InputIter __first, _Size __count,\n+\t\t\t     _ForwardIter __result,\n+\t\t\t     std::allocator<_Tp>)\n+    {\n+      return uninitialized_copy_n(__first, __count, __result);\n+    }\n+\n   /**\n    *  This class provides similar behavior and semantics of the standard\n    *  functions get_temporary_buffer() and return_temporary_buffer(), but"}, {"sha": "ff9e3bd277b3c59a3a044eb99e694dcbacbcfdf9", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -1642,7 +1642,7 @@ protected:\n \t  return 0;\n \t_CharT* __buf = __a.allocate(_S_rounded_up_size(__size));\n \t\n-\tuninitialized_copy_n(__s, __size, __buf);\n+\t__uninitialized_copy_n_a(__s, __size, __buf, __a);\n \t_S_cond_store_eos(__buf[__size]);\n \ttry\n \t  { return _S_new_RopeLeaf(__buf, __size, __a); }\n@@ -1790,7 +1790,7 @@ protected:\n       {\n \t_CharT* __buf = this->_Data_allocate(_S_rounded_up_size(1));\n \t\n-\tstd::_Construct(__buf, __c);\n+\tget_allocator().construct(__buf, __c);\n \ttry\n \t  { this->_M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a); }\n \tcatch(...)\n@@ -1905,7 +1905,7 @@ protected:\n       void\n       copy(_CharT* __buffer) const\n       {\n-\t_Destroy(__buffer, __buffer + size());\n+\t_Destroy(__buffer, __buffer + size(), get_allocator());\n \t_S_flatten(this->_M_tree_ptr, __buffer);\n       }\n \n@@ -1920,7 +1920,7 @@ protected:\n \tsize_t __size = size();\n \tsize_t __len = (__pos + __n > __size? __size - __pos : __n);\n \t\n-\t_Destroy(__buffer, __buffer + __len);\n+\t_Destroy(__buffer, __buffer + __len, get_allocator());\n \t_S_flatten(this->_M_tree_ptr, __pos, __len, __buffer);\n \treturn __len;\n       }"}, {"sha": "7463196c0e93380441eb1236d90512e89e7c77f6", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -346,7 +346,7 @@ namespace __gnu_cxx\n       if (0 != __cstr)\n \t{\n \t  size_t __size = this->_M_size + 1;\n-\t  _Destroy(__cstr, __cstr + __size);\n+\t  _Destroy(__cstr, __cstr + __size, get_allocator());\n \t  this->_Data_deallocate(__cstr, __size);\n \t}\n     }\n@@ -357,7 +357,7 @@ namespace __gnu_cxx\n     _S_free_string(_CharT* __s, size_t __n, allocator_type __a)\n     {\n       if (!_S_is_basic_char_type((_CharT*)0))\n-\t_Destroy(__s, __s + __n);\n+\t_Destroy(__s, __s + __n, __a);\n       \n       //  This has to be a static member, so this gets a bit messy\n       __a.deallocate(__s,\n@@ -1547,7 +1547,8 @@ namespace __gnu_cxx\n       else\n \t{\n \t  __rest_buffer = this->_Data_allocate(_S_rounded_up_size(__rest));\n-\t  uninitialized_fill_n(__rest_buffer, __rest, __c);\n+\t  __uninitialized_fill_n_a(__rest_buffer, __rest, __c,\n+\t\t\t\t   get_allocator());\n \t  _S_cond_store_eos(__rest_buffer[__rest]);\n \t  try\n \t    { __remainder = _S_new_RopeLeaf(__rest_buffer, __rest, __a); }\n@@ -1564,7 +1565,8 @@ namespace __gnu_cxx\n \t    this->_Data_allocate(_S_rounded_up_size(__exponentiate_threshold));\n \t  _RopeLeaf* __base_leaf;\n \t  rope __base_rope;\n-\t  uninitialized_fill_n(__base_buffer, __exponentiate_threshold, __c);\n+\t  __uninitialized_fill_n_a(__base_buffer, __exponentiate_threshold, __c,\n+\t\t\t\t   get_allocator());\n \t  _S_cond_store_eos(__base_buffer[__exponentiate_threshold]);\n \t  try\n \t    {"}, {"sha": "470e7a98718c2dff71926108320d925cd48573be", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -260,7 +260,7 @@ namespace __gnu_cxx\n \t_Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);\n \t_Slist_node_base* __next_next = __next->_M_next;\n \t__pos->_M_next = __next_next;\n-\t_Destroy(&__next->_M_data);\n+\tget_allocator().destroy(&__next->_M_data);\n \t_M_put_node(__next);\n \treturn __next_next;\n       }\n@@ -277,7 +277,7 @@ namespace __gnu_cxx\n \t{\n \t  _Slist_node<_Tp>* __tmp = __cur;\n \t  __cur = (_Slist_node<_Tp>*) __cur->_M_next;\n-\t  _Destroy(&__tmp->_M_data);\n+\t  get_allocator().destroy(&__tmp->_M_data);\n \t  _M_put_node(__tmp);\n \t}\n       __before_first->_M_next = __last_node;\n@@ -327,7 +327,7 @@ namespace __gnu_cxx\n \t_Node* __node = this->_M_get_node();\n \ttry\n \t  {\n-\t    _Construct(&__node->_M_data, __x);\n+\t    get_allocator().construct(&__node->_M_data, __x);\n \t    __node->_M_next = 0;\n \t  }\n \tcatch(...)\n@@ -344,7 +344,7 @@ namespace __gnu_cxx\n \t_Node* __node = this->_M_get_node();\n \ttry\n \t  {\n-\t    _Construct(&__node->_M_data);\n+\t    get_allocator().construct(&__node->_M_data);\n \t    __node->_M_next = 0;\n \t  }\n \tcatch(...)\n@@ -490,7 +490,7 @@ namespace __gnu_cxx\n       {\n \t_Node* __node = (_Node*) this->_M_head._M_next;\n \tthis->_M_head._M_next = __node->_M_next;\n-\t_Destroy(&__node->_M_data);\n+\tget_allocator().destroy(&__node->_M_data);\n \tthis->_M_put_node(__node);\n       }\n "}, {"sha": "ecd797993dc10fa8058a1ceb48bdd718a4545364", "filename": "libstdc++-v3/testsuite/23_containers/deque/check_construct_destroy.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcheck_construct_destroy.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -0,0 +1,82 @@\n+// 2004-07-26  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <deque>\n+#include <testsuite_allocator.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  typedef std::deque<int, tracker_alloc<int> > Container;\n+  const int arr10[10] = { 2, 4, 1, 7, 3, 8, 10, 5, 9, 6 };\n+  bool ok = true;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c;\n+    ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    ok = check_construct_destroy(\"Construct from range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Construct from range\", 10, 10) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin(), arr10[0]);\n+    ok = check_construct_destroy(\"Insert element\", 1, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert element\", 1, 11) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin() + 5, arr10, arr10+3);\n+    ok = check_construct_destroy(\"Insert short range\", 3, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert short range\", 3, 13) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin() + 7, arr10, arr10+10);\n+    ok = check_construct_destroy(\"Insert long range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert long range\", 10, 20) && ok;\n+\n+  return ok ? 0 : 1;;\n+}\n+"}, {"sha": "023724cc11f8fbf6b6525c6a26dc953d7914e9da", "filename": "libstdc++-v3/testsuite/23_containers/list/check_construct_destroy.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcheck_construct_destroy.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -0,0 +1,87 @@\n+// 2004-07-26  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <list>\n+#include <iterator>\n+#include <testsuite_allocator.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  typedef std::list<int, tracker_alloc<int> > Container;\n+  const int arr10[10] = { 2, 4, 1, 7, 3, 8, 10, 5, 9, 6 };\n+  bool ok = true;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c;\n+    ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    ok = check_construct_destroy(\"Construct from range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Construct from range\", 10, 10) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin(), arr10[0]);\n+    ok = check_construct_destroy(\"Insert element\", 1, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert element\", 1, 11) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    Container::iterator i5 = c.begin();\n+    std::advance(i5, 5);\n+    c.insert(i5, arr10, arr10+3);\n+    ok = check_construct_destroy(\"Insert short range\", 3, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert short range\", 3, 13) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    Container::iterator i7 = c.begin();\n+    std::advance(i7, 5);\n+    c.insert(i7, arr10, arr10+10);\n+    ok = check_construct_destroy(\"Insert long range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert long range\", 10, 20) && ok;\n+\n+  return ok ? 0 : 1;\n+}\n+"}, {"sha": "0f6d866a533e05009f234cc42b37c4bbf7b049d4", "filename": "libstdc++-v3/testsuite/23_containers/set/check_construct_destroy.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fcheck_construct_destroy.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -0,0 +1,85 @@\n+// 2004-07-26  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <set>\n+#include <functional>\n+#include <iterator>\n+#include <testsuite_allocator.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  typedef std::set<int, std::less<int>, tracker_alloc<int> > Container;\n+  const int arr10[10]  = { 2, 4, 1, 7, 3, 8, 10, 5, 9, 6 };\n+  const int arr10a[10] = { 31, 23, 82, 46, 13, 17, 30, 71, 22, 51 };\n+  bool ok = true;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c;\n+    ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    ok = check_construct_destroy(\"Construct from range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Construct from range\", 10, 10) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(arr10a[0]);\n+    ok = check_construct_destroy(\"Insert element\", 1, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert element\", 1, 11) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(arr10a, arr10a+3);\n+    ok = check_construct_destroy(\"Insert short range\", 3, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert short range\", 3, 13) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(arr10a, arr10a+10);\n+    ok = check_construct_destroy(\"Insert long range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert long range\", 10, 20) && ok;\n+\n+  return ok ? 0 : 1;\n+}\n+"}, {"sha": "6c3123567f648e5a7a2bdd29714a03d381e069ac", "filename": "libstdc++-v3/testsuite/23_containers/vector/check_construct_destroy.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcheck_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcheck_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcheck_construct_destroy.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -0,0 +1,85 @@\n+// 2004-07-26  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <vector>\n+#include <testsuite_allocator.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  typedef std::vector<int, tracker_alloc<int> > Container;\n+  const int arr10[10] = { 2, 4, 1, 7, 3, 8, 10, 5, 9, 6 };\n+  bool ok = true;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c;\n+    ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    ok = check_construct_destroy(\"Construct from range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Construct from range\", 10, 10) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    c.reserve(100);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin(), arr10[0]);\n+    ok = check_construct_destroy(\"Insert element\", 1, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert element\", 1, 11) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    c.reserve(100);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin() + 5, arr10, arr10+3);\n+    ok = check_construct_destroy(\"Insert short range\", 3, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert short range\", 3, 13) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    c.reserve(100);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin() + 7, arr10, arr10+10);\n+    ok = check_construct_destroy(\"Insert long range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert long range\", 10, 20) && ok;\n+\n+  return ok ? 0 : 1;\n+}\n+"}, {"sha": "d95273e26e6cb23596c1f7f978005416316763ce", "filename": "libstdc++-v3/testsuite/ext/hash_check_construct_destroy.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fhash_check_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fhash_check_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fhash_check_construct_destroy.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -0,0 +1,91 @@\n+// 2004-07-26  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <ext/hash_set>\n+#include <functional>\n+#include <iterator>\n+#include <testsuite_allocator.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  typedef __gnu_cxx::hash_set<int, __gnu_cxx::hash<int>, std::equal_to<int>,\n+                              tracker_alloc<int> >\n+    Container;\n+\n+  const int arr10[10]  = { 2, 4, 1, 7, 3, 8, 10, 5, 9, 6 };\n+  const int arr10a[10] = { 31, 23, 82, 46, 13, 17, 30, 71, 22, 51 };\n+  bool ok = true;\n+\n+  int buckets;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c;\n+    buckets = c.bucket_count();\n+    ok = check_construct_destroy(\"empty container\", buckets, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"empty container\", buckets, buckets) && ok;\n+\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    ok = check_construct_destroy(\"Construct from range\", buckets+10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Construct from range\", buckets+10, buckets+10) && ok;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    c.insert(arr10a[0]);\n+    ok = check_construct_destroy(\"Insert element\", buckets+11, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert element\", buckets+11, buckets+11) && ok;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    c.insert(arr10a, arr10a+3);\n+    ok = check_construct_destroy(\"Insert short range\", buckets+13, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert short range\", buckets+13, buckets+13) && ok;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    c.insert(arr10a, arr10a+10);\n+    ok = check_construct_destroy(\"Insert long range\", buckets+20, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert long range\", buckets+20, buckets+20) && ok;\n+\n+  return ok ? 0 : 1;\n+}\n+"}, {"sha": "174c4da69fcb70f86315c867445aa1a6f1803c8f", "filename": "libstdc++-v3/testsuite/ext/slist_check_construct_destroy.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fslist_check_construct_destroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fslist_check_construct_destroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fslist_check_construct_destroy.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -0,0 +1,87 @@\n+// 2004-07-26  Matt Austern  <austern@apple.com>\n+//\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <ext/slist>\n+#include <iterator>\n+#include <testsuite_allocator.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  typedef __gnu_cxx::slist<int, tracker_alloc<int> > Container;\n+  const int arr10[10] = { 2, 4, 1, 7, 3, 8, 10, 5, 9, 6 };\n+  bool ok = true;\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c;\n+    ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"empty container\", 0, 0) && ok;\n+\n+\n+  allocation_tracker::resetCounts();\n+  {\n+    Container c(arr10, arr10 + 10);\n+    ok = check_construct_destroy(\"Construct from range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Construct from range\", 10, 10) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    c.insert(c.begin(), arr10[0]);\n+    ok = check_construct_destroy(\"Insert element\", 1, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert element\", 1, 11) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    Container::iterator i5 = c.begin();\n+    std::advance(i5, 5);\n+    c.insert(i5, arr10, arr10+3);\n+    ok = check_construct_destroy(\"Insert short range\", 3, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert short range\", 3, 13) && ok;\n+\n+  {\n+    Container c(arr10, arr10 + 10);\n+    allocation_tracker::resetCounts();\n+    Container::iterator i7 = c.begin();\n+    std::advance(i7, 5);\n+    c.insert(i7, arr10, arr10+10);\n+    ok = check_construct_destroy(\"Insert long range\", 10, 0) && ok;\n+  }\n+  ok = check_construct_destroy(\"Insert long range\", 10, 20) && ok;\n+\n+  return ok ? 0 : 1;\n+}\n+"}, {"sha": "6856226c2392fb97417529fa7c7a09099adde444", "filename": "libstdc++-v3/testsuite/testsuite_allocator.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -28,6 +28,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n+#include <iostream>\n #include <testsuite_allocator.h>\n \n namespace __gnu_test\n@@ -36,5 +37,24 @@ namespace __gnu_test\n   allocation_tracker::size_type allocation_tracker::deallocationTotal_ = 0;\n   int allocation_tracker::constructCount_    = 0;\n   int allocation_tracker::destructCount_     = 0;\n+\n+  bool\n+  check_construct_destroy(const char* tag, int expected_c, int expected_d)\n+  {\n+    if (allocation_tracker::constructCount() == expected_c &&\n+\tallocation_tracker::destructCount() == expected_d)\n+      return true;\n+\n+    else {\n+      std::cerr << tag << \": \"\n+\t\t<< \" construct = \" << allocation_tracker::constructCount()\n+\t\t<< \" (should be \" << expected_c << \"),\"\n+\t\t<< \" destroy = \" << allocation_tracker::destructCount()\n+\t\t<< \" (should be \" << expected_d << \")\"\n+\t\t<< std::endl;\n+      return false;\n+    }\n+  }\n+\n }; // namespace __cxx_test\n "}, {"sha": "46b7891e9bd841798379202c86871bf9cd9344af", "filename": "libstdc++-v3/testsuite/testsuite_allocator.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1985f1cdaac3eb268c44b880d4742b62f3cd8185/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h?ref=1985f1cdaac3eb268c44b880d4742b62f3cd8185", "patch": "@@ -169,6 +169,10 @@ namespace __gnu_test\n     bool\n     operator!=(const tracker_alloc<T1>&, const tracker_alloc<T2>&) throw()\n     { return false; }\n+\n+   bool\n+   check_construct_destroy(const char* tag, int expected_c, int expected_d);\n+\n }; // namespace __gnu_test\n \n #endif // _GLIBCXX_TESTSUITE_ALLOCATOR_H"}]}