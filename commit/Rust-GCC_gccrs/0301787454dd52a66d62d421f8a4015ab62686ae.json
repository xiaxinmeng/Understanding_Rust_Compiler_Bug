{"sha": "0301787454dd52a66d62d421f8a4015ab62686ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMwMTc4NzQ1NGRkNTJhNjZkNjJkNDIxZjhhNDAxNWFiNjI2ODZhZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-02-21T16:38:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-21T16:38:23Z"}, "message": "cp-tree.h (CLASSTYPE_METHOD_VEC): Adjust comment.\n\n1999-02-19  Mark Mitchell  <mark@markmitchell.com>\n\t* cp-tree.h (CLASSTYPE_METHOD_VEC): Adjust comment.\n\t(fn_type_unification): Adjust prototype.\n\t(lookup_fnfields_1): Declare.\n\t* call.c (add_template_candidate_real): Adjust call to\n\tfn_type_unification.\n\t* class.c (add_method): Don't allow duplicate declarations of\n\tconstructors or destructors.\n\t(resolve_address_of_overloaded_function): Remove unused variable.\n\tAdjust call to fn_type_unification.\n\t* decl.c (grokfndecl): Be more robust in the face of illegal\n\tspecializations.\n\t* decl2.c (check_classfn): Remove hokey handling of member\n\ttemplates.\n\t* pt.c (determine_specialization): Improve comments.  Adjust to\n\thandle template argument deduction as per the standard.\n\t(check_explicit_specialization): Fix comment spacing.  Handle\n\ttype-conversion operators correctly.  Improve error-recovery.\n\t(fn_type_unification): Remove EXTRA_FN_ARG parameter.\n\t(get_bindings_real): Simplify handling of static members.\n\t* search.c (lookup_fnfields_1): Make it have external linkage.\n\t* typeck.c (compparms): Fix comment.\n\t(build_unary_op): Don't try to figure out which template\n\tspecialization is being referred to when when the address-of\n\toperator is used with a template function.\n\nFrom-SVN: r25347", "tree": {"sha": "9879deb76a90b4e04d62efe164cc744e1ef07a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9879deb76a90b4e04d62efe164cc744e1ef07a24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0301787454dd52a66d62d421f8a4015ab62686ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0301787454dd52a66d62d421f8a4015ab62686ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0301787454dd52a66d62d421f8a4015ab62686ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0301787454dd52a66d62d421f8a4015ab62686ae/comments", "author": null, "committer": null, "parents": [{"sha": "939d7216dca76eac6675e54f10154ad5d2898cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939d7216dca76eac6675e54f10154ad5d2898cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939d7216dca76eac6675e54f10154ad5d2898cfa"}], "stats": {"total": 751, "additions": 451, "deletions": 300}, "files": [{"sha": "3a8d0db46adcf16672d3b8cd6da6e89b53d8cfe3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -1,3 +1,30 @@\n+1999-02-19  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (CLASSTYPE_METHOD_VEC): Adjust comment.\n+\t(fn_type_unification): Adjust prototype.\n+\t(lookup_fnfields_1): Declare.\n+\t* call.c (add_template_candidate_real): Adjust call to\n+\tfn_type_unification.\n+\t* class.c (add_method): Don't allow duplicate declarations of\n+\tconstructors or destructors.\n+\t(resolve_address_of_overloaded_function): Remove unused variable.\n+\tAdjust call to fn_type_unification.\n+\t* decl.c (grokfndecl): Be more robust in the face of illegal\n+\tspecializations.\n+\t* decl2.c (check_classfn): Remove hokey handling of member\n+\ttemplates.\n+\t* pt.c (determine_specialization): Improve comments.  Adjust to\n+\thandle template argument deduction as per the standard.\n+\t(check_explicit_specialization): Fix comment spacing.  Handle\n+\ttype-conversion operators correctly.  Improve error-recovery.\n+\t(fn_type_unification): Remove EXTRA_FN_ARG parameter.\n+\t(get_bindings_real): Simplify handling of static members.\n+\t* search.c (lookup_fnfields_1): Make it have external linkage.\n+\t* typeck.c (compparms): Fix comment.\n+\t(build_unary_op): Don't try to figure out which template\n+\tspecialization is being referred to when when the address-of\n+\toperator is used with a template function.\n+\t\n Thu Feb 18 23:40:01 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp-tree.h (lvalue_or_else): Qualify a char* with the `const'"}, {"sha": "1e43233ab1cf23806765bda86799973587d6470f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -1948,7 +1948,7 @@ add_template_candidate_real (candidates, tmpl, explicit_targs,\n   tree fn;\n \n   i = fn_type_unification (tmpl, explicit_targs, targs, arglist,\n-\t\t\t   return_type, strict, NULL_TREE);\n+\t\t\t   return_type, strict);\n \n   if (i != 0)\n     return candidates;"}, {"sha": "d2eaa9751eaf69caa898ed6003a8e89425b1d0aa", "filename": "gcc/cp/class.c", "status": "modified", "additions": 95, "deletions": 105, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -1136,6 +1136,7 @@ add_method (type, fields, method)\n   else \n     {\n       int len;\n+      int slot;\n       tree method_vec;\n \n       if (!CLASSTYPE_METHOD_VEC (type))\n@@ -1157,27 +1158,20 @@ add_method (type, fields, method)\n       len = TREE_VEC_LENGTH (method_vec);\n \n       if (DECL_NAME (method) == constructor_name (type))\n-\t{\n-\t  /* A new constructor or destructor.  Constructors go in \n-\t     slot 0; destructors go in slot 1.  */\n-\t  int slot \n-\t    = DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method)) ? 1 : 0;\n-\n-\t  TREE_VEC_ELT (method_vec, slot)\n-\t    = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n-\t}\n+\t/* A new constructor or destructor.  Constructors go in \n+\t   slot 0; destructors go in slot 1.  */\n+\tslot = DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method)) ? 1 : 0;\n       else\n \t{\n-\t  int i;\n-\n \t  /* See if we already have an entry with this name.  */\n-\t  for (i = 2; i < len; ++i)\n-\t    if (!TREE_VEC_ELT (method_vec, i)\n-\t\t|| (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i))) \n+\t  for (slot = 2; slot < len; ++slot)\n+\t    if (!TREE_VEC_ELT (method_vec, slot)\n+\t\t|| (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, \n+\t\t\t\t\t\t\t  slot))) \n \t\t    == DECL_NAME (method)))\n \t      break;\n \t\t\n-\t  if (i == len)\n+\t  if (slot == len)\n \t    {\n \t      /* We need a bigger method vector.  */\n \t      tree new_vec = make_method_vec (2 * len);\n@@ -1188,119 +1182,116 @@ add_method (type, fields, method)\n \t      len = 2 * len;\n \t      method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n \t    }\n-\t  else if (template_class_depth (type))\n-\t    /* TYPE is a template class.  Don't issue any errors now;\n-\t       wait until instantiation time to complain.  */\n-\t      ;\n-\t  else\n-\t    {\n-\t      tree fns;\n-\n-\t      /* Check to see if we've already got this method.  */\n-\t      for (fns = TREE_VEC_ELT (method_vec, i);\n-\t\t   fns;\n-\t\t   fns = OVL_NEXT (fns))\n-\t\t{\n-\t\t  tree fn = OVL_CURRENT (fns);\n-\t\t \n-\t\t  if (TREE_CODE (fn) != TREE_CODE (method))\n-\t\t    continue;\n-\n-\t\t  if (TREE_CODE (method) != TEMPLATE_DECL)\n-\t\t    {\n-\t\t      /* [over.load] Member function declarations with the\n-\t\t\t same name and the same parameter types cannot be\n-\t\t\t overloaded if any of them is a static member\n-\t\t\t function declaration.  */\n-\t\t      if (DECL_STATIC_FUNCTION_P (fn)\n-\t\t\t  != DECL_STATIC_FUNCTION_P (method))\n-\t\t\t{\n-\t\t\t  tree parms1 = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t\t\t  tree parms2 = TYPE_ARG_TYPES (TREE_TYPE (method));\n-\n-\t\t\t  if (! DECL_STATIC_FUNCTION_P (fn))\n-\t\t\t    parms1 = TREE_CHAIN (parms1);\n-\t\t\t  else\n-\t\t\t    parms2 = TREE_CHAIN (parms2);\n-\n-\t\t\t  if (compparms (parms1, parms2))\n-\t\t\t    cp_error (\"`%#D' and `%#D' cannot be overloaded\",\n-\t\t\t\t      fn, method);\n-\t\t\t}\n-\n-\t\t      /* Since this is an ordinary function in a\n-\t\t\t non-template class, it's mangled name can be\n-\t\t\t used as a unique identifier.  This technique\n-\t\t\t is only an optimization; we would get the\n-\t\t\t same results if we just used decls_match\n-\t\t\t here.  */\n-\t\t      if (DECL_ASSEMBLER_NAME (fn) \n-\t\t\t  != DECL_ASSEMBLER_NAME (method))\n-\t\t\tcontinue;\n-\t\t    }\n-\t\t  else if (!decls_match (fn, method))\n-\t\t    continue;\n-\n-\t\t  /* There has already been a declaration of this\n-\t\t     method or member template.  */\n-\t\t  cp_error_at (\"`%D' has already been declared in `%T'\", \n-\t\t\t       method, type);\n-\n-\t\t  /* We don't call duplicate_decls here to merege the\n-\t\t     declarations because that will confuse things if\n-\t\t     the methods have inline definitions In\n-\t\t     particular, we will crash while processing the\n-\t\t     definitions.  */\n-\t\t  return;\n-\t\t}\n-\t    }\n \n-\t  if (TREE_VEC_ELT (method_vec, i))\n-\t    /* We found a match.  */;\n-\t  else if (DECL_CONV_FN_P (method))\n+\t  if (DECL_CONV_FN_P (method) && !TREE_VEC_ELT (method_vec, slot))\n \t    {\n \t      /* Type conversion operators have to come before\n \t\t ordinary methods; add_conversions depends on this to\n \t\t speed up looking for conversion operators.  So, if\n \t\t necessary, we slide some of the vector elements up.\n \t\t In theory, this makes this algorithm O(N^2) but we\n \t\t don't expect many conversion operators.  */\n-\t      for (i = 2; i < len; ++i)\n+\t      for (slot = 2; slot < len; ++slot)\n \t\t{\n-\t\t  tree fn = TREE_VEC_ELT (method_vec, i);\n-\n+\t\t  tree fn = TREE_VEC_ELT (method_vec, slot);\n+  \n \t\t  if (!fn)\n \t\t    /* There are no more entries in the vector, so we\n \t\t       can insert the new conversion operator here.  */\n \t\t    break;\n-\t\t  \n-\t\t  if (! DECL_CONV_FN_P (OVL_CURRENT (fn)))\n-\t\t    /* We can insert the new function right at the Ith\n-\t\t       position.  */\n+  \t\t  \n+\t\t  if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+\t\t    /* We can insert the new function right at the\n+\t\t       SLOTth position.  */\n \t\t    break;\n \t\t}\n-\n-\t      if (!TREE_VEC_ELT (method_vec, i))\n+  \n+\t      if (!TREE_VEC_ELT (method_vec, slot))\n \t\t/* There is nothing in the Ith slot, so we can avoid\n \t\t   moving anything.  */\n \t\t; \n \t      else\n \t\t{\n \t\t  /* We know the last slot in the vector is empty\n-\t\t     because we know that at this point there's room for\n-\t\t     a new function.  */\n-\t\t  bcopy ((PTR) &TREE_VEC_ELT (method_vec, i),\n-\t\t\t (PTR) &TREE_VEC_ELT (method_vec, i + 1),\n-\t\t\t (len - i - 1) * sizeof (tree));\n-\t\t  TREE_VEC_ELT (method_vec, i) = NULL_TREE;\n+\t\t     because we know that at this point there's room\n+\t\t     for a new function.  */\n+\t\t  bcopy ((PTR) &TREE_VEC_ELT (method_vec, slot),\n+\t\t\t (PTR) &TREE_VEC_ELT (method_vec, slot + 1),\n+\t\t\t (len - slot - 1) * sizeof (tree));\n+\t\t  TREE_VEC_ELT (method_vec, slot) = NULL_TREE;\n \t\t}\n \t    }\n-\n-\t  /* Actually insert the new method.  */\n-\t  TREE_VEC_ELT (method_vec, i) \n-\t    = build_overload (method, TREE_VEC_ELT (method_vec, i));\n \t}\n       \n+      if (template_class_depth (type))\n+\t/* TYPE is a template class.  Don't issue any errors now; wait\n+\t   until instantiation time to complain.  */\n+\t  ;\n+      else\n+\t{\n+\t  tree fns;\n+\n+\t  /* Check to see if we've already got this method.  */\n+\t  for (fns = TREE_VEC_ELT (method_vec, slot);\n+\t       fns;\n+\t       fns = OVL_NEXT (fns))\n+\t    {\n+\t      tree fn = OVL_CURRENT (fns);\n+\t\t \n+\t      if (TREE_CODE (fn) != TREE_CODE (method))\n+\t\tcontinue;\n+\n+\t      if (TREE_CODE (method) != TEMPLATE_DECL)\n+\t\t{\n+\t\t  /* [over.load] Member function declarations with the\n+\t\t     same name and the same parameter types cannot be\n+\t\t     overloaded if any of them is a static member\n+\t\t     function declaration.  */\n+\t\t  if (DECL_STATIC_FUNCTION_P (fn)\n+\t\t      != DECL_STATIC_FUNCTION_P (method))\n+\t\t    {\n+\t\t      tree parms1 = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t\t      tree parms2 = TYPE_ARG_TYPES (TREE_TYPE (method));\n+\n+\t\t      if (! DECL_STATIC_FUNCTION_P (fn))\n+\t\t\tparms1 = TREE_CHAIN (parms1);\n+\t\t      else\n+\t\t\tparms2 = TREE_CHAIN (parms2);\n+\n+\t\t      if (compparms (parms1, parms2))\n+\t\t\tcp_error (\"`%#D' and `%#D' cannot be overloaded\",\n+\t\t\t\t  fn, method);\n+\t\t    }\n+\n+\t\t  /* Since this is an ordinary function in a\n+\t\t     non-template class, it's mangled name can be used\n+\t\t     as a unique identifier.  This technique is only\n+\t\t     an optimization; we would get the same results if\n+\t\t     we just used decls_match here.  */\n+\t\t  if (DECL_ASSEMBLER_NAME (fn) \n+\t\t      != DECL_ASSEMBLER_NAME (method))\n+\t\t    continue;\n+\t\t}\n+\t      else if (!decls_match (fn, method))\n+\t\tcontinue;\n+\n+\t      /* There has already been a declaration of this method\n+\t\t or member template.  */\n+\t      cp_error_at (\"`%D' has already been declared in `%T'\", \n+\t\t\t   method, type);\n+\n+\t      /* We don't call duplicate_decls here to merge the\n+\t\t declarations because that will confuse things if the\n+\t\t methods have inline definitions In particular, we\n+\t\t will crash while processing the definitions.  */\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Actually insert the new method.  */\n+      TREE_VEC_ELT (method_vec, slot) \n+\t= build_overload (method, TREE_VEC_ELT (method_vec, slot));\n+\n       if (TYPE_BINFO_BASETYPES (type) && CLASSTYPE_BASELINK_VEC (type))\n \t{\n \t  /* ??? May be better to know whether these can be extended?  */\n@@ -5115,7 +5106,6 @@ resolve_address_of_overloaded_function (target_type,\n       for (fns = overload; fns; fns = OVL_CHAIN (fns))\n \t{\n \t  tree fn = OVL_FUNCTION (fns);\n-\t  tree fn_arg_types;\n \t  tree instantiation;\n \t  tree instantiation_type;\n \t  tree targs;\n@@ -5134,7 +5124,7 @@ resolve_address_of_overloaded_function (target_type,\n \t  targs = make_scratch_vec (DECL_NTPARMS (fn));\n \t  if (fn_type_unification (fn, explicit_targs, targs,\n \t\t\t\t   target_arg_types, NULL_TREE,\n-\t\t\t\t   DEDUCE_EXACT, NULL_TREE) != 0)\n+\t\t\t\t   DEDUCE_EXACT) != 0)\n \t    /* Argument deduction failed.  */\n \t    continue;\n "}, {"sha": "861f395470071d419db41c2dd0fcebc0576b17ab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -887,11 +887,11 @@ struct lang_type\n #define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3(NODE))\n \n /* Vector member functions defined in this class.  Each element is\n-   either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  The first\n+   either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  All\n+   functions with the same name end up in the same slot.  The first\n    two elements are for constructors, and destructors, respectively.\n-   Any user-defined conversion operators follow these.  These are\n-   followed by ordinary member functions.  There may be empty entries\n-   at the end of the vector.  */\n+   These are followed by ordinary member functions.  There may be\n+   empty entries at the end of the vector.  */\n #define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n \n /* The first type conversion operator in the class (the others can be\n@@ -3068,7 +3068,7 @@ extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n-extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, unification_kind_t, tree));\n+extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, unification_kind_t));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree, tree));\n@@ -3126,6 +3126,7 @@ extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n extern tree compute_access\t\t\tPROTO((tree, tree));\n extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n+extern int lookup_fnfields_1                    PROTO((tree, tree));\n extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n extern tree lookup_member\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));"}, {"sha": "95bd6f9a90bbdde7827ef85b7f81c50a081bc84c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -8599,8 +8599,11 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t    cp_error (\"definition of implicitly-declared `%D'\", tmp);\n \t  if (tmp)\n \t    {\n+\t      /* Attempt to merge the declarations.  This can fail, in\n+\t\t the case of some illegal specialization declarations.  */\n \t      if (!duplicate_decls (decl, tmp))\n-\t\tmy_friendly_abort (892);\n+\t\tcp_error (\"no `%#D' member function declared in class `%T'\",\n+\t\t\t  decl, ctype);\n \t      return tmp;\n \t    }\n \t}"}, {"sha": "70120de1a64fb803aabfd64f05c79010e55e41e8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -1309,8 +1309,21 @@ check_classfn (ctype, function)\n   tree method_vec = CLASSTYPE_METHOD_VEC (complete_type (ctype));\n   tree *methods = 0;\n   tree *end = 0;\n-  tree templates = NULL_TREE;\n-\n+  \n+  if (DECL_USE_TEMPLATE (function)\n+      && is_member_template (DECL_TI_TEMPLATE (function)))\n+    /* Since this is a specialization of a member template,\n+       we're not going to find the declaration in the class.\n+       For example, in:\n+       \n+         struct S { template <typename T> void f(T); };\n+         template <> void S::f(int);\n+       \n+       we're not going to find `S::f(int)', but there's no\n+       reason we should, either.  We let our callers know we didn't\n+       find the method, but we don't complain.  */\n+    return NULL_TREE;\n+      \n   if (method_vec != 0)\n     {\n       methods = &TREE_VEC_ELT (method_vec, 0);\n@@ -1375,36 +1388,13 @@ check_classfn (ctype, function)\n \t\t\t      || (DECL_TI_TEMPLATE (function) \n \t\t\t\t  == DECL_TI_TEMPLATE (fndecl))))\n \t\t\treturn fndecl;\n-\n-\t\t      if (is_member_template (fndecl))\n-\t\t\t/* This function might be an instantiation\n-\t\t\t   or specialization of fndecl.  */\n-\t\t\ttemplates = \n-\t\t\t  scratch_tree_cons (NULL_TREE, fndecl, templates);\n \t\t    }\n \t\t}\n \t      break;\t\t/* loser */\n \t    }\n-\t  else if (TREE_CODE (OVL_CURRENT (fndecl)) == TEMPLATE_DECL \n-\t\t   && DECL_CONV_FN_P (OVL_CURRENT (fndecl))\n-\t\t   && DECL_CONV_FN_P (function))\n-\t    /* The method in the class is a member template\n-\t       conversion operator.  We are declaring another\n-\t       conversion operator.  It is possible that even though\n-\t       the names don't match, there is some specialization\n-\t       occurring.  */\n-\t    templates = \n-\t      scratch_tree_cons (NULL_TREE, fndecl, templates);\n \t}\n     }\n \n-  if (templates)\n-    /* This function might be an instantiation or a specialization.\n-       We should verify that this is possible.  For now, we simply\n-       return NULL_TREE, which lets the caller know that this function\n-       is new, but we don't print an error message.  */\n-    return NULL_TREE;\n-\n   if (methods != end && *methods)\n     {\n       tree fndecl = *methods;"}, {"sha": "905bdf6fe143ff47229fd503a83eb58b5b3e731c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 209, "deletions": 123, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -906,13 +906,19 @@ print_candidates (fns)\n \n /* Returns the template (one of the functions given by TEMPLATE_ID)\n    which can be specialized to match the indicated DECL with the\n-   explicit template args given in TEMPLATE_ID.  If\n-   NEED_MEMBER_TEMPLATE is true the function is a specialization of a\n-   member template.  The template args (those explicitly specified and\n-   those deduced) are output in a newly created vector *TARGS_OUT.  If\n-   it is impossible to determine the result, an error message is\n-   issued, unless COMPLAIN is 0.  The DECL may be NULL_TREE if none is\n-   available.  */\n+   explicit template args given in TEMPLATE_ID.  The DECL may be\n+   NULL_TREE if none is available.  In that case, the functions in\n+   TEMPLATE_ID are non-members.\n+\n+   If NEED_MEMBER_TEMPLATE is non-zero the function is known to be a\n+   specialization of a member template.\n+\n+   The template args (those explicitly specified and those deduced)\n+   are output in a newly created vector *TARGS_OUT.\n+\n+   If it is impossible to determine the result, an error message is\n+   issued, unless COMPLAIN is 0.  In any case, error_mark_node is\n+   returned to indicate failure.  */\n \n tree\n determine_specialization (template_id, decl, targs_out, \n@@ -924,17 +930,20 @@ determine_specialization (template_id, decl, targs_out,\n      int need_member_template;\n      int complain;\n {\n-  tree fns, targs_in;\n-  tree templates = NULL_TREE;\n   tree fn;\n+  tree fns;\n+  tree targs;\n+  tree explicit_targs;\n+  tree candidates = NULL_TREE;\n+  tree templates = NULL_TREE;\n \n   *targs_out = NULL_TREE;\n \n   if (template_id == error_mark_node)\n     return error_mark_node;\n \n   fns = TREE_OPERAND (template_id, 0);\n-  targs_in = TREE_OPERAND (template_id, 1);\n+  explicit_targs = TREE_OPERAND (template_id, 1);\n \n   if (fns == error_mark_node)\n     return error_mark_node;\n@@ -948,96 +957,166 @@ determine_specialization (template_id, decl, targs_out,\n       tree tmpl;\n \n       fn = OVL_CURRENT (fns);\n-      if (!need_member_template \n-\t  && TREE_CODE (fn) == FUNCTION_DECL \n-\t  && DECL_FUNCTION_MEMBER_P (fn)\n-\t  && DECL_USE_TEMPLATE (fn)\n-\t  && DECL_TI_TEMPLATE (fn))\n-\t/* We can get here when processing something like:\n-\t     template <class T> class X { void f(); }\n-\t     template <> void X<int>::f() {}\n-\t   We're specializing a member function, but not a member\n-\t   template.  */\n-\ttmpl = DECL_TI_TEMPLATE (fn);\n-      else if (TREE_CODE (fn) != TEMPLATE_DECL\n-\t       || (need_member_template && !is_member_template (fn)))\n+\n+      if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t/* DECL might be a specialization of FN.  */\n+\ttmpl = fn;\n+      else if (need_member_template)\n+\t/* FN is an ordinary member function, and we need a\n+\t   specialization of a member template.  */\n+\tcontinue;\n+      else if (TREE_CODE (fn) != FUNCTION_DECL)\n+\t/* We can get IDENTIFIER_NODEs here in certain erroneous\n+\t   cases.  */\n+\tcontinue;\n+      else if (!DECL_FUNCTION_MEMBER_P (fn))\n+\t/* This is just an ordinary non-member function.  Nothing can\n+\t   be a specialization of that.  */\n+\tcontinue;\n+      else if (!decl)\n+\t/* When there's no DECL to match, we know we're looking for\n+\t   non-members.  */\n \tcontinue;\n       else\n-\ttmpl = fn;\n+\t{\n+\t  tree decl_arg_types;\n \n-      if (list_length (targs_in) > DECL_NTPARMS (tmpl))\n-\tcontinue;\n+\t  /* This is an ordinary member function.  However, since\n+\t     we're here, we can assume it's enclosing class is a\n+\t     template class.  For example,\n+\t     \n+\t       template <typename T> struct S { void f(); };\n+\t       template <> void S<int>::f() {}\n+\n+\t     Here, S<int>::f is a non-template, but S<int> is a\n+\t     template class.  If FN has the same type as DECL, we\n+\t     might be in business.  */\n+\t  if (!same_type_p (TREE_TYPE (TREE_TYPE (decl)),\n+\t\t\t    TREE_TYPE (TREE_TYPE (fn))))\n+\t    /* The return types differ.  */\n+\t    continue;\n+\n+\t  /* Adjust the type of DECL in case FN is a static member.  */\n+\t  decl_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+\t  if (DECL_STATIC_FUNCTION_P (fn) \n+\t      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+\t    decl_arg_types = TREE_CHAIN (decl_arg_types);\n+\n+\t  if (compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)), \n+\t\t\t decl_arg_types))\n+\t    /* They match!  */\n+\t    candidates = tree_cons (NULL_TREE, fn, candidates);\n+\n+\t  continue;\n+\t}\n \n       if (decl == NULL_TREE)\n \t{\n \t  /* Unify against ourselves to make sure that the args we have\n \t     make sense and there aren't any undeducible parms.  It's OK if\n \t     not all the parms are specified; they might be deduced\n \t     later. */\n-\t  tree targs = get_bindings_overload (tmpl, DECL_RESULT (tmpl),\n-\t\t\t\t\t      targs_in);\n-\n-\t  if (targs) \n-\t    /* Unification was successful.  */\n-\t    templates = scratch_tree_cons (targs, tmpl, templates);\n+\t  targs = get_bindings_overload (tmpl, DECL_RESULT (tmpl),\n+\t\t\t\t\t explicit_targs);\n+\t  if (uses_template_parms (targs))\n+\t    /* We couldn't deduce all the arguments.  */\n+\t    continue;\n \t}\n       else\n-\ttemplates = scratch_tree_cons (NULL_TREE, tmpl, templates);\n-    }\n-  \n-  if (decl != NULL_TREE)\n-    {\n-      tree tmpl = most_specialized (templates, decl, targs_in);\n-      tree inner_args;\n-      tree tmpl_args;\n+\t/* See whether this function might be a specialization of this\n+\t   template.  */\n+\ttargs = get_bindings (tmpl, decl, explicit_targs);\n \n-      if (tmpl == error_mark_node) \n-\tgoto ambiguous;\n-      else if (tmpl == NULL_TREE)\n-\tgoto no_match;\n+      if (!targs)\n+\t/* Wwe cannot deduce template arguments that when used to\n+\t   specialize TMPL will produce DECL.  */\n+\tcontinue;\n \n-      inner_args = get_bindings (tmpl, decl, targs_in);\n-      tmpl_args = DECL_TI_ARGS (DECL_RESULT (tmpl));\n-      if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (tmpl_args))\n-\t{\n-\t  *targs_out = copy_node (tmpl_args);\n-\t  SET_TMPL_ARGS_LEVEL (*targs_out, \n-\t\t\t       TMPL_ARGS_DEPTH (*targs_out),\n-\t\t\t       inner_args);\n-\t}\n-      else\n-\t*targs_out = inner_args;\n-      \n-      return tmpl;\n+      /* Save this template, and the arguments deduced.  */\n+      templates = scratch_tree_cons (targs, tmpl, templates);\n     }\n \n-  if (templates == NULL_TREE)\n+  if (decl && templates && TREE_CHAIN (templates))\n+    {\n+      /* We have:\n+\t \n+\t   [temp.expl.spec]\n+\n+\t   It is possible for a specialization with a given function\n+\t   signature to be instantiated from more than one function\n+\t   template.  In such cases, explicit specification of the\n+\t   template arguments must be used to uniquely identify the\n+\t   function template specialization being specialized.\n+\n+\t Note that here, there's no suggestion that we're supposed to\n+\t determine which of the candidate templates is most\n+\t specialized.  However, we, also have:\n+\n+\t   [temp.func.order]\n+\n+\t   Partial ordering of overloaded function template\n+\t   declarations is used in the following contexts to select\n+\t   the function template to which a function template\n+\t   specialization refers: \n+\n+           -- when an explicit specialization refers to a function\n+\t      template. \n+\n+\t So, we do use the partial ordering rules, at least for now.\n+\t This extension can only serve to make illegal programs legal,\n+\t so it's safe.  And, there is strong anecdotal evidence that\n+\t the committee intended the partial ordering rules to apply;\n+\t the EDG front-end has that behavior, and John Spicer claims\n+\t that the committee simply forgot to delete the wording in\n+\t [temp.expl.spec].  */\n+     tree tmpl = most_specialized (templates, decl, explicit_targs);\n+     if (tmpl && tmpl != error_mark_node)\n+       {\n+\t targs = get_bindings (tmpl, decl, explicit_targs);\n+\t templates = scratch_tree_cons (targs, tmpl, NULL_TREE);\n+       }\n+    }\n+\n+  if (templates == NULL_TREE && candidates == NULL_TREE)\n     {\n-    no_match:\n       if (complain)\n-\t{\n-\t  cp_error_at (\"template-id `%D' for `%+D' does not match any template declaration\",\n-\t\t       template_id, decl);\n-\t  return error_mark_node;\n-\t}\n-      return NULL_TREE;\n+\tcp_error_at (\"template-id `%D' for `%+D' does not match any template declaration\",\n+\t\t     template_id, decl);\n+      return error_mark_node;\n     }\n-  else if (TREE_CHAIN (templates) != NULL_TREE\n-\t   || uses_template_parms (TREE_PURPOSE (templates)))\n+  else if ((templates && TREE_CHAIN (templates))\n+\t   || (candidates && TREE_CHAIN (candidates)))\n     {\n-    ambiguous:\n       if (complain)\n \t{\n \t  cp_error_at (\"ambiguous template specialization `%D' for `%+D'\",\n \t\t       template_id, decl);\n-\t  print_candidates (templates);\n-\t  return error_mark_node;\n+\t  chainon (candidates, templates);\n+\t  print_candidates (candidates);\n \t}\n-      return NULL_TREE;\n+      return error_mark_node;\n     }\n \n   /* We have one, and exactly one, match. */\n-  *targs_out = TREE_PURPOSE (templates);\n+  if (candidates)\n+    {\n+      /* It was a specialization of an ordinary member function in a\n+\t template class.  */\n+      *targs_out = copy_node (DECL_TI_ARGS (TREE_VALUE (candidates)));\n+      return DECL_TI_TEMPLATE (TREE_VALUE (candidates));\n+    }\n+\n+  /* It was a specialization of a template.  */\n+  targs = DECL_TI_ARGS (DECL_RESULT (TREE_VALUE (templates)));\n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (targs))\n+    {\n+      *targs_out = copy_node (targs);\n+      SET_TMPL_ARGS_LEVEL (*targs_out, \n+\t\t\t   TMPL_ARGS_DEPTH (*targs_out),\n+\t\t\t   TREE_PURPOSE (templates));\n+    }\n+  else\n+    *targs_out = TREE_PURPOSE (templates);\n   return TREE_VALUE (templates);\n }\n       \n@@ -1047,7 +1126,9 @@ determine_specialization (template_id, decl, targs_out,\n    instantiation at this point.\n \n    Returns DECL, or an equivalent declaration that should be used\n-   instead. \n+   instead if all goes well.  Issues an error message if something is\n+   amiss.  Returns error_mark_node if the error is not easily\n+   recoverable.\n    \n    FLAGS is a bitmask consisting of the following flags: \n \n@@ -1101,10 +1182,9 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  /* There were more template headers than qualifying template\n \t     classes.  */\n \t  if (template_header_count - template_count > 1)\n-\t    /* There shouldn't be that many template parameter\n-\t\t   lists.  There can be at most one parameter list for\n-\t\t   every qualifying class, plus one for the function\n-\t\t   itself.  */\n+\t    /* There shouldn't be that many template parameter lists.\n+\t       There can be at most one parameter list for every\n+\t       qualifying class, plus one for the function itself.  */\n \t    cp_error (\"too many template parameter lists in declaration of `%D'\", decl);\n \n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n@@ -1284,8 +1364,9 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  /* Find the list of functions in ctype that have the same\n \t     name as the declared function.  */\n \t  tree name = TREE_OPERAND (declarator, 0);\n-\t  tree fns;\n-\t  \n+\t  tree fns = NULL_TREE;\n+\t  int idx;\n+\n \t  if (name == constructor_name (ctype) \n \t      || name == constructor_name_full (ctype))\n \t    {\n@@ -1303,21 +1384,52 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t\t     Similar language is found in [temp.explicit].  */\n \t\t  cp_error (\"specialization of implicitly-declared special member function\");\n-\n-\t\t  return decl;\n+\t\t  return error_mark_node;\n \t\t}\n \n \t      name = is_constructor ? ctor_identifier : dtor_identifier;\n \t    }\n \n-\t  fns = lookup_fnfields (TYPE_BINFO (ctype), name, 1);\n-\t  \n+\t  if (!IDENTIFIER_TYPENAME_P (name))\n+\t    {\n+\t      idx = lookup_fnfields_1 (ctype, name);\n+\t      if (idx >= 0)\n+\t\tfns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (ctype), idx);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree methods;\n+\n+\t      /* For a type-conversion operator, we cannot do a\n+\t\t name-based lookup.  We might be looking for `operator\n+\t\t int' which will be a specialization of `operator T'.\n+\t\t So, we find *all* the conversion operators, and then\n+\t\t select from them.  */\n+\t      fns = NULL_TREE;\n+\n+\t      methods = CLASSTYPE_METHOD_VEC (ctype);\n+\t      if (methods)\n+\t\tfor (idx = 2; idx < TREE_VEC_LENGTH (methods); ++idx) \n+\t\t  {\n+\t\t    tree ovl = TREE_VEC_ELT (methods, idx);\n+\n+\t\t    if (!ovl || !DECL_CONV_FN_P (OVL_CURRENT (ovl)))\n+\t\t      /* There are no more conversion functions.  */\n+\t\t      break;\n+\n+\t\t    /* Glue all these conversion functions together\n+\t\t       with those we already have.  */\n+\t\t    for (; ovl; ovl = OVL_NEXT (ovl))\n+\t\t      fns = ovl_cons (OVL_CURRENT (ovl), fns);\n+\t\t  }\n+\t    }\n+\t      \n \t  if (fns == NULL_TREE) \n \t    {\n \t      cp_error (\"no member function `%s' declared in `%T'\",\n \t\t\tIDENTIFIER_POINTER (name),\n \t\t\tctype);\n-\t      return decl;\n+\t      return error_mark_node;\n \t    }\n \t  else\n \t    TREE_OPERAND (declarator, 0) = fns;\n@@ -1336,7 +1448,11 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t\t\t       member_specialization,\n \t\t\t\t       1);\n \t    \n-      if (tmpl && tmpl != error_mark_node)\n+      if (!tmpl || tmpl == error_mark_node)\n+\t/* We couldn't figure out what this declaration was\n+\t   specializing.  */\n+\treturn error_mark_node;\n+      else\n \t{\n \t  gen_tmpl = most_general_template (tmpl);\n \n@@ -1390,8 +1506,6 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  /* Register this specialization so that we can find it\n \t     again.  */\n \t  decl = register_specialization (decl, gen_tmpl, targs);\n-\n-\t  return decl;\n \t}\n     }\n   \n@@ -7123,17 +7237,13 @@ overload_template_name (type)\n      [temp.expl.spec], or when taking the address of a function\n      template, as in [temp.deduct.funcaddr]. \n \n-   The EXTRA_FN_ARG, if any, is the type of an additional\n-   parameter to be added to the beginning of FN's parameter list.  \n-\n    The other arguments are as for type_unification.  */\n \n int\n fn_type_unification (fn, explicit_targs, targs, args, return_type,\n-\t\t     strict, extra_fn_arg)\n+\t\t     strict)\n      tree fn, explicit_targs, targs, args, return_type;\n      unification_kind_t strict;\n-     tree extra_fn_arg;\n {\n   tree parms;\n   tree fntype;\n@@ -7174,11 +7284,6 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n       if (fntype == error_mark_node)\n \treturn 1;\n \n-      extra_fn_arg = tsubst (extra_fn_arg, converted_args,\n-\t\t\t     /*complain=*/0, NULL_TREE);\n-      if (extra_fn_arg == error_mark_node)\n-\treturn 1;\n-\n       /* Place the explicitly specified arguments in TARGS.  */\n       for (i = 0; i < TREE_VEC_LENGTH (targs); i++)\n \tTREE_VEC_ELT (targs, i) = TREE_VEC_ELT (converted_args, i);\n@@ -7195,9 +7300,6 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n       args = scratch_tree_cons (NULL_TREE, return_type, args);\n     }\n \n-  if (extra_fn_arg != NULL_TREE)\n-    parms = scratch_tree_cons (NULL_TREE, extra_fn_arg, parms);\n-\n   /* We allow incomplete unification without an error message here\n      because the standard doesn't seem to explicitly prohibit it.  Our\n      callers must be ready to deal with unification failures in any\n@@ -8355,9 +8457,8 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_scratch_vec (ntparms);\n-  tree decl_arg_types;\n-  tree extra_fn_arg = NULL_TREE;\n   tree decl_type;\n+  tree decl_arg_types;\n   int i;\n \n   /* Substitute the explicit template arguments into the type of DECL.\n@@ -8389,32 +8490,17 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n \treturn NULL_TREE;\n     }\n \n+  /* If FN is a static member function, adjust the type of DECL\n+     appropriately.  */\n   decl_arg_types = TYPE_ARG_TYPES (decl_type);\n-\n   if (DECL_STATIC_FUNCTION_P (fn) \n       && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n-    {\n-      /* Sometimes we are trying to figure out what's being\n-\t specialized by a declaration that looks like a method, and it\n-\t turns out to be a static member function.  */\n-      if (CLASSTYPE_TEMPLATE_INFO (DECL_REAL_CONTEXT (fn))\n-\t  && !is_member_template (fn))\n-\t/* The natural thing to do here seems to be to remove the\n-\t   spurious `this' parameter from the DECL, but that prevents\n-\t   unification from making use of the class type.  So,\n-\t   instead, we have fn_type_unification add to the parameters\n-\t   for FN.  */\n-\textra_fn_arg = build_pointer_type (DECL_REAL_CONTEXT (fn));\n-      else\n-\t/* In this case, though, adding the extra_fn_arg can confuse\n-\t   things, so we remove from decl_arg_types instead.  */\n-\tdecl_arg_types = TREE_CHAIN (decl_arg_types);\n-    }\n+    decl_arg_types = TREE_CHAIN (decl_arg_types);\n \n   i = fn_type_unification (fn, explicit_args, targs, \n-\t\t\t   decl_arg_types, TREE_TYPE (decl_type),\n-\t\t\t   DEDUCE_EXACT,\n-\t\t\t   extra_fn_arg);\n+\t\t\t   decl_arg_types,\n+\t\t\t   TREE_TYPE (decl_type),\n+\t\t\t   DEDUCE_EXACT);\n \n   if (i != 0)\n     return NULL_TREE;"}, {"sha": "33842c6bf6ed0fc1a018967f950b1498217e6a85", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -81,7 +81,6 @@ static tree get_vbase_1 PROTO((tree, tree, unsigned int *));\n static tree convert_pointer_to_vbase PROTO((tree, tree));\n static tree lookup_field_1 PROTO((tree, tree));\n static tree convert_pointer_to_single_level PROTO((tree, tree));\n-static int lookup_fnfields_1 PROTO((tree, tree));\n static int lookup_fnfields_here PROTO((tree, tree));\n static int is_subobject_of_p PROTO((tree, tree));\n static int hides PROTO((tree, tree));\n@@ -1284,7 +1283,7 @@ lookup_nested_field (name, complain)\n /* TYPE is a class type. Return the index of the fields within\n    the method vector with name NAME, or -1 is no such field exists.  */\n \n-static int\n+int\n lookup_fnfields_1 (type, name)\n      tree type, name;\n {"}, {"sha": "83d13f195ee14eb197cf044c8110d227729ae9b2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -1185,15 +1185,12 @@ common_base_type (tt1, tt2)\n \f\n /* Subroutines of `comptypes'.  */\n \n-/* Return 1 if two parameter type lists PARMS1 and PARMS2\n-   are equivalent in the sense that functions with those parameter types\n-   can have equivalent types.\n-   If either list is empty, we win.\n-   Otherwise, the two lists must be equivalent, element by element.\n+/* Return 1 if two parameter type lists PARMS1 and PARMS2 are\n+   equivalent in the sense that functions with those parameter types\n+   can have equivalent types.  The two lists must be equivalent,\n+   element by element.\n \n-   C++: See comment above about TYPE1, TYPE2.\n-\n-   STRICT is no longer used.  */\n+   C++: See comment above about TYPE1, TYPE2.  */\n \n int\n compparms (parms1, parms2)\n@@ -4559,30 +4556,7 @@ build_unary_op (code, xarg, noconvert)\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n \n-      if (TREE_CODE (arg) == TEMPLATE_ID_EXPR)\n-\t{\n-\t  tree targs;\n-\t  tree fn;\n-\t  \n-\t  /* We don't require a match here; it's possible that the\n-\t     context (like a cast to a particular type) will resolve\n-\t     the particular choice of template.  */\n-\t  fn = determine_specialization (arg,\n-\t\t\t\t\t NULL_TREE,\n-\t\t\t\t\t &targs, \n-\t\t\t\t\t 0, \n-\t\t\t\t\t 0);\n-\n-\t  if (fn)\n-\t    {\n-\t      fn = instantiate_template (fn, targs);\n-\t      mark_addressable (fn);\n-\t      return build_unary_op (ADDR_EXPR, fn, 0);\n-\t    }\n-\n-\t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n-\t}\n-      else if (type_unknown_p (arg))\n+      if (type_unknown_p (arg))\n \treturn build1 (ADDR_EXPR, unknown_type_node, arg);\n \n       /* Handle complex lvalues (when permitted)"}, {"sha": "7dcdeb4cbe814c2542569442c13a88a94ea0a5b9", "filename": "gcc/testsuite/g++.old-deja/g++.other/redecl2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fredecl2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fredecl2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fredecl2.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -0,0 +1,9 @@\n+// Build don't link:\n+\n+struct S {\n+  S(int);\n+  S(int); // ERROR - already declared\n+\n+  ~S();\n+  ~S(); // ERROR - already declared\n+};"}, {"sha": "d218474ec8bc6a90063e87f66defb7cccacd5da7", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit1.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -5,5 +5,5 @@ void foo(T t) {}\n \n void bar()\n {\n-  &foo<double>;\n+  (void (*)(double)) &foo<double>;\n }"}, {"sha": "73880315b64b7261c9c18e40fc9413677d33a5ee", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit2.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -5,5 +5,5 @@ void foo(T t) {}\n \n void bar()\n {\n-  (void (*)(int)) &foo<double>;\n+  (void (*)(int)) (void (*)(double)) &foo<double>;\n }"}, {"sha": "7d1616255b21560b42d774cabdc9674e4250d2cd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit26.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit26.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -8,5 +8,5 @@ int foo(int i) { return 0; }\n \n int main()\n {\n-  &foo<int>;\n+  (int (*)(int)) &foo<int>;\n }"}, {"sha": "a8d82211fc26745e4c575d477c0ddc0253329752", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit27.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit27.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -8,5 +8,5 @@ void foo(int i) {}\n \n int main()\n {\n-  &foo<int>;\n+  (void (*)(int)) &foo<int>;\n }"}, {"sha": "0133f16c5af5b1f7fdf6e2bdbd75616a0e78ef94", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit28.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -8,5 +8,5 @@ int foo(int i) { return 0; }\n \n int main()\n {\n-  return (*&foo<int>)(3);\n+  return (*((int (*)(int)) &foo<int>))(3);\n }"}, {"sha": "468dd7914b6a272dc80c6994a514d5611d5cad8a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit30.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit30.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -7,5 +7,5 @@ void foo(T, T*);\n void bar()\n {\n   double d;\n-  (*((void (*)(int, double*)) &foo<int>))(3, &d);\n+  (*((void (*)(int, double*)) (void (*)(int, int*)) &foo<int>))(3, &d);\n }"}, {"sha": "9f27a8e53a3055b4a76930a2b28144f37cc8ef45", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec29.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec29.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -0,0 +1,31 @@\n+char c;\n+\n+struct S {\n+  template <typename T>\n+  operator T*();\n+\n+  template <typename T>\n+  operator T();\n+};\n+\n+template <>\n+S::operator int()\n+{\n+  return 2;\n+}\n+\n+template <>\n+S::operator char*()\n+{\n+  return &c;\n+}\n+\n+int main()\n+{\n+  S s;\n+  int i = s;\n+  char* cp = s;\n+\n+  if (i != 2 || cp != &c)\n+    return 1;\n+}"}, {"sha": "5d36e254a4002dd50c41309bcf576d8c4ce0077b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec30.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0301787454dd52a66d62d421f8a4015ab62686ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec30.C?ref=0301787454dd52a66d62d421f8a4015ab62686ae", "patch": "@@ -0,0 +1,41 @@\n+#include <cstddef>\n+\n+template <class T>\t\n+struct S {\n+  void *operator new (size_t);\n+  void *operator new (size_t, int);\n+  void operator delete (void*);\n+};\n+\n+static void* s[2];\n+\n+template <>\n+void* S<int>::operator new (size_t b) \n+{ \n+  s[0] = ::operator new(b);\n+  return s[0];\n+}\n+\n+template <>\n+void* S<int>::operator new (size_t b, int)\n+{\n+  s[1] = ::operator new(b);\n+  return s[1];\n+}\n+\n+template <>\n+void S<int>::operator delete (void*) \n+{\n+}\n+\n+int main()\n+{\n+  S<int>* s1 = new S<int>;\n+  S<int>* s2 = new(3) S<int>;\n+\n+  if (s1 != s[0] || s2 != s[1])\n+    return 1;\n+\n+  delete s1;\n+  delete s2;\n+}"}]}