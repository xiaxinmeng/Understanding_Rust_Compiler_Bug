{"sha": "1b0b9fcb928042bf30fb2e42247912d226f85513", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIwYjlmY2I5MjgwNDJiZjMwZmIyZTQyMjQ3OTEyZDIyNmY4NTUxMw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2015-09-02T14:51:40Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2015-09-02T14:51:40Z"}, "message": "PR 67414 Better diagnostics on backtrace failure, gf_strerror bugfix\n\n2015-09-02  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libfortran/67414\n\t* io/write.c (gfc_itoa): Move to runtime/string.c.\n\t* libgfortran.h (show_backtrace): Make arg bool.\n\t(gfc_itoa): New prototype.\n\t* runtime/backtrace.c (struct mystate): Change type of try_simple\n\tfield, add in_signal_handler field.\n\t(error_callback): Print out error number, or if not in a signal\n\thandler, the error message.\n\t(show_backtrace): Change type of arg, change initialization of\n\tstruct mystate.\n\t(backtrace): Call show_backtrace with correct arg type.\n\t* runtime/compile_options.c (backtrace_handler): Call with correct\n\targ type.\n\t* runtime/error.c (sys_abort): Likewise.\n\t(gf_strerror): Handle newlocale() failure.\n\t* runtime/string.c (gfc_itoa): Function moved here from\n\tio/write.c.\n\nFrom-SVN: r227404", "tree": {"sha": "10abb98957304dbdbbb310cad62b7d3c654bb167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10abb98957304dbdbbb310cad62b7d3c654bb167"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b0b9fcb928042bf30fb2e42247912d226f85513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0b9fcb928042bf30fb2e42247912d226f85513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b0b9fcb928042bf30fb2e42247912d226f85513", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0b9fcb928042bf30fb2e42247912d226f85513/comments", "author": null, "committer": null, "parents": [{"sha": "710465235b06be5b74b7fda1c8e2092b43d83e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710465235b06be5b74b7fda1c8e2092b43d83e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710465235b06be5b74b7fda1c8e2092b43d83e01"}], "stats": {"total": 169, "additions": 113, "deletions": 56}, "files": [{"sha": "0958ca76863b51e047ef8ee11df81076e8240cc4", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -1,3 +1,23 @@\n+2015-09-02  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/67414\n+\t* io/write.c (gfc_itoa): Move to runtime/string.c.\n+\t* libgfortran.h (show_backtrace): Make arg bool.\n+\t(gfc_itoa): New prototype.\n+\t* runtime/backtrace.c (struct mystate): Change type of try_simple\n+\tfield, add in_signal_handler field.\n+\t(error_callback): Print out error number, or if not in a signal\n+\thandler, the error message.\n+\t(show_backtrace): Change type of arg, change initialization of\n+\tstruct mystate.\n+\t(backtrace): Call show_backtrace with correct arg type.\n+\t* runtime/compile_options.c (backtrace_handler): Call with correct\n+\targ type.\n+\t* runtime/error.c (sys_abort): Likewise.\n+\t(gf_strerror): Handle newlocale() failure.\n+\t* runtime/string.c (gfc_itoa): Function moved here from\n+\tio/write.c.\n+\n 2015-08-31  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR libfortran/47571"}, {"sha": "e226236a4b5821f2e72b96f6f41fe5eb082e5516", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -1032,47 +1032,6 @@ ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n   return buffer;\n }\n \n-/* gfc_itoa()-- Integer to decimal conversion.\n-   The itoa function is a widespread non-standard extension to standard\n-   C, often declared in <stdlib.h>.  Even though the itoa defined here\n-   is a static function we take care not to conflict with any prior\n-   non-static declaration.  Hence the 'gfc_' prefix, which is normally\n-   reserved for functions with external linkage.  */\n-\n-static const char *\n-gfc_itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)\n-{\n-  int negative;\n-  char *p;\n-  GFC_UINTEGER_LARGEST t;\n-\n-  assert (len >= GFC_ITOA_BUF_SIZE);\n-\n-  if (n == 0)\n-    return \"0\";\n-\n-  negative = 0;\n-  t = n;\n-  if (n < 0)\n-    {\n-      negative = 1;\n-      t = -n; /*must use unsigned to protect from overflow*/\n-    }\n-\n-  p = buffer + GFC_ITOA_BUF_SIZE - 1;\n-  *p = '\\0';\n-\n-  while (t != 0)\n-    {\n-      *--p = '0' + (t % 10);\n-      t /= 10;\n-    }\n-\n-  if (negative)\n-    *--p = '-';\n-  return p;\n-}\n-\n \n void\n write_i (st_parameter_dt *dtp, const fnode *f, const char *p, int len)"}, {"sha": "3eb0d85fa245bc676c765c0fac8503fe9f2e9c7d", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -651,7 +651,7 @@ export_proto(store_exe_path);\n \n /* backtrace.c */\n \n-extern void show_backtrace (int);\n+extern void show_backtrace (bool);\n internal_proto(show_backtrace);\n \n \n@@ -838,6 +838,9 @@ internal_proto(fc_strdup);\n extern char *fc_strdup_notrim(const char *, gfc_charlen_type);\n internal_proto(fc_strdup_notrim);\n \n+extern const char *gfc_itoa(GFC_INTEGER_LARGEST, char *, size_t);\n+internal_proto(gfc_itoa);\n+\n /* io/intrinsics.c */\n \n extern void flush_all_units (void);"}, {"sha": "12ad76aac12b3f448e087244ea362c6dfb1e665d", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include <string.h>\n #include <stdlib.h>\n+#include <errno.h>\n \n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n@@ -38,8 +39,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Store our own state while backtracing.  */\n struct mystate\n {\n-  int try_simple;\n   int frame;\n+  bool try_simple;\n+  bool in_signal_handler;\n };\n \n \n@@ -65,15 +67,35 @@ static void\n error_callback (void *data, const char *msg, int errnum)\n {\n   struct mystate *state = (struct mystate *) data;\n+#define ERRHDR \"\\nCould not print backtrace: \"\n+\n   if (errnum < 0)\n     {\n-      state->try_simple = 1;\n+      state->try_simple = true;\n       return;\n     }\n-\n-  estr_write (\"\\nSomething went wrong while printing the backtrace: \");\n-  estr_write (msg);\n-  estr_write (\"\\n\");\n+  else if (errnum == 0)\n+    {\n+      estr_write (ERRHDR);\n+      estr_write (msg);\n+      estr_write (\"\\n\");\n+    }\n+  else\n+    {\n+      char errbuf[256];\n+      if (state->in_signal_handler)\n+\t{\n+\t  estr_write (ERRHDR);\n+\t  estr_write (msg);\n+\t  estr_write (\", errno: \");\n+\t  const char *p = gfc_itoa (errnum, errbuf, sizeof (errbuf));\n+\t  estr_write (p);\n+\t  estr_write (\"\\n\");\n+\t}\n+      else\n+\tst_printf (ERRHDR \"%s: %s\\n\", msg,\n+\t\t  gf_strerror (errnum, errbuf, sizeof (errbuf)));\n+    }\n }\n \n static int\n@@ -110,10 +132,10 @@ full_callback (void *data, uintptr_t pc, const char *filename,\n /* Display the backtrace.  */\n \n void\n-show_backtrace (int in_signal_handler)\n+show_backtrace (bool in_signal_handler)\n {\n   struct backtrace_state *lbstate;\n-  struct mystate state = { 0, 0 };\n+  struct mystate state = { 0, false, in_signal_handler };\n  \n   lbstate = backtrace_create_state (NULL, 1, error_callback, NULL);\n \n@@ -147,6 +169,6 @@ export_proto (backtrace);\n void\n backtrace (void)\n {\n-  show_backtrace (0);\n+  show_backtrace (false);\n }\n "}, {"sha": "087c070d3de216c98468d4db7e51256546c7a54c", "filename": "libgfortran/runtime/compile_options.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Fcompile_options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Fcompile_options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fcompile_options.c?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -126,7 +126,7 @@ backtrace_handler (int signum)\n \n   show_signal (signum);\n   estr_write (\"\\nBacktrace for this error:\\n\");\n-  show_backtrace (1);\n+  show_backtrace (true);\n \n   /* Now reraise the signal.  We reactivate the signal's\n      default handling, which is to terminate the process."}, {"sha": "4aabe4a4a744d85d4a23d99e8d7393745a02ac3a", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -173,7 +173,7 @@ sys_abort (void)\n       || (options.backtrace == -1 && compile_options.backtrace == 1))\n     {\n       estr_write (\"\\nProgram aborted. Backtrace:\\n\");\n-      show_backtrace (0);\n+      show_backtrace (false);\n       signal (SIGABRT, SIG_DFL);\n     }\n \n@@ -221,8 +221,16 @@ gf_strerror (int errnum,\n #ifdef HAVE_STRERROR_L\n   locale_t myloc = newlocale (LC_CTYPE_MASK | LC_MESSAGES_MASK, \"\",\n \t\t\t      (locale_t) 0);\n-  char *p = strerror_l (errnum, myloc);\n-  freelocale (myloc);\n+  char *p;\n+  if (myloc)\n+    {\n+      p = strerror_l (errnum, myloc);\n+      freelocale (myloc);\n+    }\n+  else\n+    /* newlocale might fail e.g. due to running out of memory, fall\n+       back to the simpler strerror.  */\n+    p = strerror (errnum);\n   return p;\n #elif defined(HAVE_STRERROR_R)\n #ifdef HAVE_USELOCALE"}, {"sha": "5bd0f61928e09869b2c1a538bc4abfd2be2e8f87", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0b9fcb928042bf30fb2e42247912d226f85513/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=1b0b9fcb928042bf30fb2e42247912d226f85513", "patch": "@@ -1,7 +1,7 @@\n /* Copyright (C) 2002-2015 Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -167,3 +167,48 @@ find_option (st_parameter_common *cmp, const char *s1, gfc_charlen_type s1_len,\n \n   return -1;\n }\n+\n+\n+/* gfc_itoa()-- Integer to decimal conversion.\n+   The itoa function is a widespread non-standard extension to\n+   standard C, often declared in <stdlib.h>.  Even though the itoa\n+   defined here is a static function we take care not to conflict with\n+   any prior non-static declaration.  Hence the 'gfc_' prefix, which\n+   is normally reserved for functions with external linkage.  Notably,\n+   in contrast to the *printf() family of functions, this ought to be\n+   async-signal-safe.  */\n+\n+const char *\n+gfc_itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)\n+{\n+  int negative;\n+  char *p;\n+  GFC_UINTEGER_LARGEST t;\n+\n+  if (len < GFC_ITOA_BUF_SIZE)\n+    sys_abort ();\n+\n+  if (n == 0)\n+    return \"0\";\n+\n+  negative = 0;\n+  t = n;\n+  if (n < 0)\n+    {\n+      negative = 1;\n+      t = -n; /*must use unsigned to protect from overflow*/\n+    }\n+\n+  p = buffer + GFC_ITOA_BUF_SIZE - 1;\n+  *p = '\\0';\n+\n+  while (t != 0)\n+    {\n+      *--p = '0' + (t % 10);\n+      t /= 10;\n+    }\n+\n+  if (negative)\n+    *--p = '-';\n+  return p;\n+}"}]}