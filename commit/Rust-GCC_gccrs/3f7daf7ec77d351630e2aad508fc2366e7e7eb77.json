{"sha": "3f7daf7ec77d351630e2aad508fc2366e7e7eb77", "node_id": "C_kwDOANBUbNoAKDNmN2RhZjdlYzc3ZDM1MTYzMGUyYWFkNTA4ZmMyMzY2ZTdlN2ViNzc", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-31T20:48:59Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-31T20:48:59Z"}, "message": "c++: use auto_timevar instead of timevar_push/pop\n\nr12-5487-g9bf69a8558638c replaced uses of timevar_cond_push/pop with\nauto_cond_timevar and removed now unnecessary wrapper functions.  This\npatch does the same with timevar_push/pop and auto_timevar.\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc: Use auto_timevar instead of timevar_push/pop.\n\tRemove wrapper functions.\n\t* pt.cc: Likewise.", "tree": {"sha": "3c11c3ff30325cb3ccb880c026849a046d477158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c11c3ff30325cb3ccb880c026849a046d477158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f7daf7ec77d351630e2aad508fc2366e7e7eb77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f7daf7ec77d351630e2aad508fc2366e7e7eb77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f7daf7ec77d351630e2aad508fc2366e7e7eb77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f7daf7ec77d351630e2aad508fc2366e7e7eb77/comments", "author": null, "committer": null, "parents": [{"sha": "6013fc2567c1d38ac4e1f57b3cd2483b7513aa59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6013fc2567c1d38ac4e1f57b3cd2483b7513aa59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6013fc2567c1d38ac4e1f57b3cd2483b7513aa59"}], "stats": {"total": 98, "additions": 25, "deletions": 73}, "files": [{"sha": "0eefa740dc56a15b8c13ee41169c98dfe750552d", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f7daf7ec77d351630e2aad508fc2366e7e7eb77/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f7daf7ec77d351630e2aad508fc2366e7e7eb77/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=3f7daf7ec77d351630e2aad508fc2366e7e7eb77", "patch": "@@ -19106,7 +19106,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   cp_decl_specifier_seq decl_specifiers;\n   tree extension_specifier = NULL_TREE;\n \n-  timevar_push (TV_TEMPLATE_INST);\n+  auto_timevar tv (TV_TEMPLATE_INST);\n \n   /* Look for an (optional) storage-class-specifier or\n      function-specifier.  */\n@@ -19207,8 +19207,6 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n-  timevar_pop (TV_TEMPLATE_INST);\n-\n   cp_finalize_omp_declare_simd (parser, &odsd);\n }\n \n@@ -20966,7 +20964,8 @@ cp_parser_enum_specifier (cp_parser* parser)\n      elaborated-type-specifier.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n-      timevar_push (TV_PARSE_ENUM);\n+      auto_timevar tv (TV_PARSE_ENUM);\n+\n       if (nested_name_specifier\n \t  && nested_name_specifier != error_mark_node)\n \t{\n@@ -21072,7 +21071,6 @@ cp_parser_enum_specifier (cp_parser* parser)\n \n       if (scoped_enum_p)\n \tfinish_scope ();\n-      timevar_pop (TV_PARSE_ENUM);\n     }\n   else\n     {\n@@ -25927,9 +25925,11 @@ pop_injected_parms (void)\n \n    Returns the TREE_TYPE representing the class.  */\n \n-static tree\n-cp_parser_class_specifier_1 (cp_parser* parser)\n+tree\n+cp_parser_class_specifier (cp_parser* parser)\n {\n+  auto_timevar tv (TV_PARSE_STRUCT);\n+\n   tree type;\n   tree attributes = NULL_TREE;\n   bool nested_name_specifier_p;\n@@ -26321,16 +26321,6 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n   return type;\n }\n \n-static tree\n-cp_parser_class_specifier (cp_parser* parser)\n-{\n-  tree ret;\n-  timevar_push (TV_PARSE_STRUCT);\n-  ret = cp_parser_class_specifier_1 (parser);\n-  timevar_pop (TV_PARSE_STRUCT);\n-  return ret;\n-}\n-\n /* Parse a class-head.\n \n    class-head:\n@@ -31276,15 +31266,10 @@ cp_parser_function_definition_from_specifiers_and_declarator\n     }\n   else\n     {\n-      timevar_id_t tv;\n-      if (DECL_DECLARED_INLINE_P (current_function_decl))\n-        tv = TV_PARSE_INLINE;\n-      else\n-        tv = TV_PARSE_FUNC;\n-      timevar_push (tv);\n+      auto_timevar tv (DECL_DECLARED_INLINE_P (current_function_decl)\n+\t\t       ? TV_PARSE_INLINE : TV_PARSE_FUNC);\n       fn = cp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t\t /*inline_p=*/false);\n-      timevar_pop (tv);\n     }\n \n   return fn;\n@@ -32276,7 +32261,8 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n static void\n cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n {\n-  timevar_push (TV_PARSE_INMETH);\n+  auto_timevar tv (TV_PARSE_INMETH);\n+\n   /* If this member is a template, get the underlying\n      FUNCTION_DECL.  */\n   if (DECL_FUNCTION_TEMPLATE_P (member_function))\n@@ -32346,7 +32332,6 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n \n   /* Restore the queue.  */\n   pop_unparsed_function_queues (parser);\n-  timevar_pop (TV_PARSE_INMETH);\n }\n \n /* If DECL contains any default args, remember it on the unparsed"}, {"sha": "4f0ace2644b5b37a2c8d17977f91c81cedae50f2", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f7daf7ec77d351630e2aad508fc2366e7e7eb77/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f7daf7ec77d351630e2aad508fc2366e7e7eb77/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=3f7daf7ec77d351630e2aad508fc2366e7e7eb77", "patch": "@@ -9812,10 +9812,12 @@ maybe_get_template_decl_from_type_decl (tree decl)\n    that we want to avoid. It also causes some problems with argument\n    coercion (see convert_nontype_argument for more information on this).  */\n \n-static tree\n-lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n-\t\t\t int entering_scope, tsubst_flags_t complain)\n+tree\n+lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n+\t\t       int entering_scope, tsubst_flags_t complain)\n {\n+  auto_timevar tv (TV_TEMPLATE_INST);\n+\n   tree templ = NULL_TREE, parmlist;\n   tree t;\n   spec_entry **slot;\n@@ -10353,20 +10355,6 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n     }\n }\n \n-/* Wrapper for lookup_template_class_1.  */\n-\n-tree\n-lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n-                       int entering_scope, tsubst_flags_t complain)\n-{\n-  tree ret;\n-  timevar_push (TV_TEMPLATE_INST);\n-  ret = lookup_template_class_1 (d1, arglist, in_decl, context,\n-                                 entering_scope, complain);\n-  timevar_pop (TV_TEMPLATE_INST);\n-  return ret;\n-}\n-\n /* Return a TEMPLATE_ID_EXPR for the given variable template and ARGLIST.  */\n \n tree\n@@ -11871,9 +11859,11 @@ perform_instantiation_time_access_checks (tree tmpl, tree targs)\n       }\n }\n \n-static tree\n-instantiate_class_template_1 (tree type)\n+tree\n+instantiate_class_template (tree type)\n {\n+  auto_timevar tv (TV_TEMPLATE_INST);\n+\n   tree templ, args, pattern, t, member;\n   tree typedecl;\n   tree pbinfo;\n@@ -12395,18 +12385,6 @@ instantiate_class_template_1 (tree type)\n   return type;\n }\n \n-/* Wrapper for instantiate_class_template_1.  */\n-\n-tree\n-instantiate_class_template (tree type)\n-{\n-  tree ret;\n-  timevar_push (TV_TEMPLATE_INST);\n-  ret = instantiate_class_template_1 (type);\n-  timevar_pop (TV_TEMPLATE_INST);\n-  return ret;\n-}\n-\n tree\n tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n@@ -21545,9 +21523,11 @@ recheck_decl_substitution (tree d, tree tmpl, tree args)\n /* Instantiate the indicated variable, function, or alias template TMPL with\n    the template arguments in TARG_PTR.  */\n \n-static tree\n-instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n+tree\n+instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n {\n+  auto_timevar tv (TV_TEMPLATE_INST);\n+\n   tree targ_ptr = orig_args;\n   tree fndecl;\n   tree gen_tmpl;\n@@ -21719,18 +21699,6 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n   return fndecl;\n }\n \n-/* Wrapper for instantiate_template_1.  */\n-\n-tree\n-instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n-{\n-  tree ret;\n-  timevar_push (TV_TEMPLATE_INST);\n-  ret = instantiate_template_1 (tmpl, orig_args,  complain);\n-  timevar_pop (TV_TEMPLATE_INST);\n-  return ret;\n-}\n-\n /* Instantiate the alias template TMPL with ARGS.  Also push a template\n    instantiation level, which instantiate_template doesn't do because\n    functions and variables have sufficient context established by the\n@@ -26568,7 +26536,7 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n   if (! push_tinst_level (d))\n     return d;\n \n-  timevar_push (TV_TEMPLATE_INST);\n+  auto_timevar tv (TV_TEMPLATE_INST);\n \n   /* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern\n      for the instantiation.  */\n@@ -26734,7 +26702,6 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n     }\n \n   pop_deferring_access_checks ();\n-  timevar_pop (TV_TEMPLATE_INST);\n   pop_tinst_level ();\n   input_location = saved_loc;\n   cp_unevaluated_operand = saved_unevaluated_operand;"}]}