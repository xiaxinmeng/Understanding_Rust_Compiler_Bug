{"sha": "7ceb899e9343493f646434f74a149395f3913d9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NlYjg5OWU5MzQzNDkzZjY0NjQzNGY3NGExNDkzOTVmMzkxM2Q5YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-18T16:27:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-18T16:45:46Z"}, "message": "preprocessor: Add support for header unit translation\n\n\tlibcpp/\n\t* files.c (struct _cpp_file): Add header_unit field.\n\t(_cpp_stack_file): Add header unit support.\n\t(cpp_find_header_unit): New.\n\t* include/cpplib.h (cpp_find_header_unit): Declare.", "tree": {"sha": "3cd22087dc51f0cdd8a7e4f60a47f7332601c2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cd22087dc51f0cdd8a7e4f60a47f7332601c2f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ceb899e9343493f646434f74a149395f3913d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ceb899e9343493f646434f74a149395f3913d9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ceb899e9343493f646434f74a149395f3913d9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ceb899e9343493f646434f74a149395f3913d9a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db87f19ae3cfc126fb39616515b57dea4df02e6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db87f19ae3cfc126fb39616515b57dea4df02e6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db87f19ae3cfc126fb39616515b57dea4df02e6d"}], "stats": {"total": 158, "additions": 118, "deletions": 40}, "files": [{"sha": "b5d9f30297ed4ad9455a2f4926da65ee4dcf9ca1", "filename": "libcpp/files.c", "status": "modified", "additions": 115, "deletions": 40, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ceb899e9343493f646434f74a149395f3913d9a/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ceb899e9343493f646434f74a149395f3913d9a/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=7ceb899e9343493f646434f74a149395f3913d9a", "patch": "@@ -111,6 +111,9 @@ struct _cpp_file\n \n   /* If this file is implicitly preincluded.  */\n   bool implicit_preinclude : 1;\n+\n+  /* > 0: Known C++ Module header unit, <0: known not.  ==0, unknown  */\n+  int header_unit : 2;\n };\n \n /* A singly-linked list for all searches for a given file name, with\n@@ -891,69 +894,114 @@ has_unique_contents (cpp_reader *pfile, _cpp_file *file, bool import,\n }\n \n /* Place the file referenced by FILE into a new buffer on the buffer\n-   stack if possible.  IMPORT is true if this stacking attempt is\n-   because of a #import directive.  Returns true if a buffer is\n-   stacked.  Use LOC for any diagnostics.  */\n+   stack if possible.  Returns true if a buffer is stacked.  Use LOC\n+   for any diagnostics.  */\n+\n bool\n _cpp_stack_file (cpp_reader *pfile, _cpp_file *file, include_type type,\n \t\t location_t loc)\n {\n   if (is_known_idempotent_file (pfile, file, type == IT_IMPORT))\n     return false;\n \n-  if (!read_file (pfile, file, loc))\n-    return false;\n+  int sysp = 0;\n+  char *buf = nullptr;\n \n-  if (!has_unique_contents (pfile, file, type == IT_IMPORT, loc))\n-    return false;\n+  /* Check C++ module include translation.  */\n+  if (!file->header_unit && type < IT_HEADER_HWM\n+      /* Do not include translate include-next.  */\n+      && type != IT_INCLUDE_NEXT\n+      && pfile->cb.translate_include)\n+    buf = (pfile->cb.translate_include\n+\t   (pfile, pfile->line_table, loc, file->path));\n \n-  int sysp = 0;\n-  if (pfile->buffer && file->dir)\n-    sysp = MAX (pfile->buffer->sysp, file->dir->sysp);\n-\n-  /* Add the file to the dependencies on its first inclusion.  */\n-  if (CPP_OPTION (pfile, deps.style) > (sysp != 0)\n-      && !file->stack_count\n-      && file->path[0]\n-      && !(file->main_file && CPP_OPTION (pfile, deps.ignore_main_file)))\n-    deps_add_dep (pfile->deps, file->path);\n-\n-  /* Clear buffer_valid since _cpp_clean_line messes it up.  */\n-  file->buffer_valid = false;\n-  file->stack_count++;\n-\n-  /* Stack the buffer.  */\n-  cpp_buffer *buffer\n-    = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n-\t\t       CPP_OPTION (pfile, preprocessed)\n-\t\t       && !CPP_OPTION (pfile, directives_only));\n-  buffer->file = file;\n-  buffer->sysp = sysp;\n-  buffer->to_free = file->buffer_start;\n-\n-  /* Initialize controlling macro state.  */\n-  pfile->mi_valid = true;\n-  pfile->mi_cmacro = 0;\n+  if (buf)\n+    {\n+      /* We don't increment the line number at the end of a buffer,\n+\t because we don't usually need that location (we're popping an\n+\t include file).  However in this case we do want to do the\n+\t increment.  So push a writable buffer of two newlines to acheive\n+\t that.  */\n+      static uchar newlines[] = \"\\n\\n\";\n+      cpp_push_buffer (pfile, newlines, 2, true);\n+\n+      cpp_buffer *buffer\n+\t= cpp_push_buffer (pfile, reinterpret_cast<unsigned char *> (buf),\n+\t\t\t   strlen (buf), true);\n+      buffer->to_free = buffer->buf;\n+\n+      file->header_unit = +1;\n+      _cpp_mark_file_once_only (pfile, file);\n+    }\n+  else\n+    {\n+      /* Not a header unit, and we know it.  */\n+      file->header_unit = -1;\n+\n+      if (!read_file (pfile, file, loc))\n+\treturn false;\n+\n+      if (!has_unique_contents (pfile, file, type == IT_IMPORT, loc))\n+\treturn false;\n+\n+      if (pfile->buffer && file->dir)\n+\tsysp = MAX (pfile->buffer->sysp, file->dir->sysp);\n+\n+      /* Add the file to the dependencies on its first inclusion.  */\n+      if (CPP_OPTION (pfile, deps.style) > (sysp != 0)\n+\t  && !file->stack_count\n+\t  && file->path[0]\n+\t  && !(file->main_file && CPP_OPTION (pfile, deps.ignore_main_file)))\n+\tdeps_add_dep (pfile->deps, file->path);\n+\n+      /* Clear buffer_valid since _cpp_clean_line messes it up.  */\n+      file->buffer_valid = false;\n+      file->stack_count++;\n+\n+      /* Stack the buffer.  */\n+      cpp_buffer *buffer\n+\t= cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n+\t\t\t   CPP_OPTION (pfile, preprocessed)\n+\t\t\t   && !CPP_OPTION (pfile, directives_only));\n+      buffer->file = file;\n+      buffer->sysp = sysp;\n+      buffer->to_free = file->buffer_start;\n+\n+      /* Initialize controlling macro state.  */\n+      pfile->mi_valid = true;\n+      pfile->mi_cmacro = 0;\n+    }\n \n   /* In the case of a normal #include, we're now at the start of the\n      line *following* the #include.  A separate location_t for this\n      location makes no sense, until we do the LC_LEAVE.\n \n      This does not apply if we found a PCH file, we're not a regular\n      include, or we ran out of locations.  */\n-  if (file->pchname == NULL\n-      && type < IT_DIRECTIVE_HWM\n-      && pfile->line_table->highest_location != LINE_MAP_MAX_LOCATION - 1)\n+  bool decrement = (file->pchname == NULL\n+\t\t    && type < IT_DIRECTIVE_HWM\n+\t\t    && (pfile->line_table->highest_location\n+\t\t\t!= LINE_MAP_MAX_LOCATION - 1));\n+  if (decrement)\n     pfile->line_table->highest_location--;\n \n-  /* Add line map and do callbacks.  */\n-  _cpp_do_file_change (pfile, LC_ENTER, file->path,\n+  if (file->header_unit <= 0)\n+    /* Add line map and do callbacks.  */\n+    _cpp_do_file_change (pfile, LC_ENTER, file->path,\n \t\t       /* With preamble injection, start on line zero,\n \t\t\t  so the preamble doesn't appear to have been\n \t\t\t  included from line 1.  Likewise when\n \t\t\t  starting preprocessed, we expect an initial\n \t\t\t  locating line.  */\n-\t\t       type == IT_PRE_MAIN ? 0 : 1, sysp);\n+\t\t\t type == IT_PRE_MAIN ? 0 : 1, sysp);\n+  else if (decrement)\n+    {\n+      /* Adjust the line back one so we appear on the #include line itself.  */\n+      const line_map_ordinary *map\n+\t= LINEMAPS_LAST_ORDINARY_MAP (pfile->line_table);\n+      linenum_type line = SOURCE_LINE (map, pfile->line_table->highest_line);\n+      linemap_line_start (pfile->line_table, line - 1, 0);\n+    }\n \n   return true;\n }\n@@ -1058,6 +1106,33 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n   return _cpp_stack_file (pfile, file, type, loc);\n }\n \n+/* NAME is a header file name, find the path we'll use to open it.  */\n+\n+const char *\n+cpp_find_header_unit (cpp_reader *pfile, const char *name, bool angle,\n+\t\t      location_t loc)\n+{\n+  cpp_dir *dir = search_path_head (pfile, name, angle, IT_INCLUDE);\n+  if (!dir)\n+    return NULL;\n+\n+  _cpp_file *file = _cpp_find_file (pfile, name, dir, angle,\n+\t\t\t\t    _cpp_FFK_NORMAL, loc);\n+  if (!file)\n+    return NULL;\n+\n+  if (file->fd > 0)\n+    {\n+      /* Don't leave it open.  */\n+      close (file->fd);\n+      file->fd = 0;\n+    }\n+\n+  file->header_unit = +1;\n+  _cpp_mark_file_once_only (pfile, file);\n+  return file->path;\n+}\n+\n /* Could not open FILE.  The complication is dependency output.  */\n static void\n open_file_failed (cpp_reader *pfile, _cpp_file *file, int angle_brackets,"}, {"sha": "389af32bc5c1f358ea688494c3f90dcd3563928c", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ceb899e9343493f646434f74a149395f3913d9a/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ceb899e9343493f646434f74a149395f3913d9a/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=7ceb899e9343493f646434f74a149395f3913d9a", "patch": "@@ -983,6 +983,9 @@ extern cpp_callbacks *cpp_get_callbacks (cpp_reader *) ATTRIBUTE_PURE;\n extern void cpp_set_callbacks (cpp_reader *, cpp_callbacks *);\n extern class mkdeps *cpp_get_deps (cpp_reader *) ATTRIBUTE_PURE;\n \n+extern const char *cpp_find_header_unit (cpp_reader *, const char *file,\n+\t\t\t\t\t bool angle_p,  location_t);\n+\n /* This function reads the file, but does not start preprocessing.  It\n    returns the name of the original file; this is the same as the\n    input file, except for preprocessed input.  This will generate at"}]}