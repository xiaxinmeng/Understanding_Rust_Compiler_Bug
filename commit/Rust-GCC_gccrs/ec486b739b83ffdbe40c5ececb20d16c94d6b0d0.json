{"sha": "ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "node_id": "C_kwDOANBUbNoAKGVjNDg2YjczOWI4M2ZmZGJlNDBjNWVjZWNiMjBkMTZjOTRkNmIwZDA", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-13T08:41:57Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-06-13T09:38:10Z"}, "message": "d: Merge upstream dmd 821ed393d, druntime 454471d8, phobos 1206fc94f.\n\nD front-end changes:\n\n    - Import latest bug fixes to mainline.\n\nD runtime changes:\n\n    - Fix duplicate Elf64_Dyn definitions on Solaris.\n    - _d_newThrowable has been converted to a template.\n\nPhobos changes:\n\n    - Import latest bug fixes to mainline.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 821ed393d.\n\t* expr.cc (ExprVisitor::visit (NewExp *)): Remove handled of\n\tallocating `@nogc' throwable object.\n\t* runtime.def (NEWTHROW): Remove.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 454471d8.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add\n\tcore/sync/package.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 1206fc94f.", "tree": {"sha": "9a3c04628df45a6dca9288e2c44b089c957e426d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a3c04628df45a6dca9288e2c44b089c957e426d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13ea4a6e830da1f245136601e636dec62e74d1a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13ea4a6e830da1f245136601e636dec62e74d1a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13ea4a6e830da1f245136601e636dec62e74d1a7"}], "stats": {"total": 1741, "additions": 1029, "deletions": 712}, "files": [{"sha": "d39658a808e33734133a7d04f3ac07a439807ab2", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1,4 +1,4 @@\n-4d07f22f29d098869ad937f0499d8895df089a71\n+821ed393d428c7db5a48623e77d43f5647d5c6a2\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "b569a9c3b466811dd63e67d2fa84530331758113", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1274,14 +1274,14 @@ extern (C++) final class StaticForeachDeclaration : AttribDeclaration\n  * declarations.\n  */\n \n-extern(C++) final class ForwardingAttribDeclaration: AttribDeclaration\n+extern(C++) final class ForwardingAttribDeclaration : AttribDeclaration\n {\n     ForwardingScopeDsymbol sym = null;\n \n     this(Dsymbols* decl)\n     {\n         super(decl);\n-        sym = new ForwardingScopeDsymbol(null);\n+        sym = new ForwardingScopeDsymbol();\n         sym.symtab = new DsymbolTable();\n     }\n \n@@ -1298,7 +1298,7 @@ extern(C++) final class ForwardingAttribDeclaration: AttribDeclaration\n      */\n     override void addMember(Scope* sc, ScopeDsymbol sds)\n     {\n-        parent = sym.parent = sym.forward = sds;\n+        sym.parent = sds;\n         return super.addMember(sc, sym);\n     }\n "}, {"sha": "62ba889cc1329b13e90e64af8fbde6b6f04cb9e3", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -5156,26 +5156,80 @@ final class CParser(AST) : Parser!AST\n                 {\n                     auto id = n.ident;\n                     scan(&n);\n-                    if (n.value == TOK.endOfLine)       // #define identifier\n-                    {\n-                        nextDefineLine();\n-                        continue;\n-                    }\n-                    if (n.value == TOK.int32Literal)\n+\n+                    AST.Type t;\n+\n+                    switch (n.value)\n                     {\n-                        const value = n.intvalue;\n-                        scan(&n);\n-                        if (n.value == TOK.endOfLine)\n-                        {\n-                            /* Declare manifest constant:\n-                             *  enum id = value;\n-                             */\n-                            AST.Expression e = new AST.IntegerExp(scanloc, value, AST.Type.tint32);\n-                            auto v = new AST.VarDeclaration(scanloc, AST.Type.tint32, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n-                            symbols.push(v);\n+                        case TOK.endOfLine:     // #define identifier\n                             nextDefineLine();\n                             continue;\n-                        }\n+\n+                        case TOK.int32Literal:\n+                        case TOK.charLiteral:       t = AST.Type.tint32;    goto Linteger;\n+                        case TOK.uns32Literal:      t = AST.Type.tuns32;    goto Linteger;\n+                        case TOK.int64Literal:      t = AST.Type.tint64;    goto Linteger;\n+                        case TOK.uns64Literal:      t = AST.Type.tuns64;    goto Linteger;\n+\n+                        Linteger:\n+                            const intvalue = n.intvalue;\n+                            scan(&n);\n+                            if (n.value == TOK.endOfLine)\n+                            {\n+                                /* Declare manifest constant:\n+                                 *  enum id = intvalue;\n+                                 */\n+                                AST.Expression e = new AST.IntegerExp(scanloc, intvalue, t);\n+                                auto v = new AST.VarDeclaration(scanloc, t, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n+                                symbols.push(v);\n+                                nextDefineLine();\n+                                continue;\n+                            }\n+                            break;\n+\n+                        case TOK.float32Literal:      t = AST.Type.tfloat32;     goto Lfloat;\n+                        case TOK.float64Literal:      t = AST.Type.tfloat64;     goto Lfloat;\n+                        case TOK.float80Literal:      t = AST.Type.tfloat80;     goto Lfloat;\n+                        case TOK.imaginary32Literal:  t = AST.Type.timaginary32; goto Lfloat;\n+                        case TOK.imaginary64Literal:  t = AST.Type.timaginary64; goto Lfloat;\n+                        case TOK.imaginary80Literal:  t = AST.Type.timaginary80; goto Lfloat;\n+\n+                        Lfloat:\n+                            const floatvalue = n.floatvalue;\n+                            scan(&n);\n+                            if (n.value == TOK.endOfLine)\n+                            {\n+                                /* Declare manifest constant:\n+                                 *  enum id = floatvalue;\n+                                 */\n+                                AST.Expression e = new AST.RealExp(scanloc, floatvalue, t);\n+                                auto v = new AST.VarDeclaration(scanloc, t, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n+                                symbols.push(v);\n+                                nextDefineLine();\n+                                continue;\n+                            }\n+                            break;\n+\n+                        case TOK.string_:\n+                            const str = n.ustring;\n+                            const len = n.len;\n+                            const postfix = n.postfix;\n+                            scan(&n);\n+                            if (n.value == TOK.endOfLine)\n+                            {\n+                                /* Declare manifest constant:\n+                                 *  enum id = \"string\";\n+                                 */\n+                                AST.Expression e = new AST.StringExp(scanloc, str[0 .. len], len, 1, postfix);\n+                                auto v = new AST.VarDeclaration(scanloc, null, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n+                                symbols.push(v);\n+                                nextDefineLine();\n+                                continue;\n+                            }\n+                            break;\n+\n+                        default:\n+                            break;\n                     }\n                 }\n                 skipToNextLine();"}, {"sha": "fed83b8f403885cde4beed8c2d642b8c5a6f9d1e", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1318,7 +1318,7 @@ private final class CppMangleVisitor : Visitor\n             Type t = fparam.type.merge2();\n             if (fparam.isReference())\n                 t = t.referenceTo();\n-            else if (fparam.storageClass & STC.lazy_)\n+            else if (fparam.isLazy())\n             {\n                 // Mangle as delegate\n                 auto tf = new TypeFunction(ParameterList(), t, LINK.d);"}, {"sha": "12051d9221583d1d3239a2603c3bf1b73f6c45d6", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -916,7 +916,7 @@ MATCH implicitConvTo(Expression e, Type t)\n             if (i - j < nparams)\n             {\n                 Parameter fparam = tf.parameterList[i - j];\n-                if (fparam.storageClass & STC.lazy_)\n+                if (fparam.isLazy())\n                     return result; // not sure what to do with this\n                 Type tparam = fparam.type;\n                 if (!tparam)\n@@ -1224,7 +1224,7 @@ MATCH implicitConvTo(Expression e, Type t)\n                 if (i - j < nparams)\n                 {\n                     Parameter fparam = tf.parameterList[i - j];\n-                    if (fparam.storageClass & STC.lazy_)\n+                    if (fparam.isLazy())\n                         return MATCH.nomatch; // not sure what to do with this\n                     Type tparam = fparam.type;\n                     if (!tparam)"}, {"sha": "bb25210019f35fd467740725d8bd74623188ee66", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -492,7 +492,7 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n             if (CTFEExp.isCantExp(earg))\n                 return earg;\n         }\n-        else if (fparam.storageClass & STC.lazy_)\n+        else if (fparam.isLazy())\n         {\n         }\n         else\n@@ -5000,6 +5000,27 @@ public:\n             printf(\"%s CommaExp::interpret() %s\\n\", e.loc.toChars(), e.toChars());\n         }\n \n+        bool isNewThrowableHook()\n+        {\n+            auto de = e.e1.isDeclarationExp();\n+            if (de is null)\n+                return false;\n+\n+            auto vd = de.declaration.isVarDeclaration();\n+            if (vd is null)\n+                return false;\n+\n+            auto ei = vd._init.isExpInitializer();\n+            if (ei is null)\n+                return false;\n+\n+            auto ce = ei.exp.isConstructExp();\n+            if (ce is null)\n+                return false;\n+\n+            return isRuntimeHook(ce.e2, Id._d_newThrowable) !is null;\n+        }\n+\n         if (auto ce = isRuntimeHook(e.e1, Id._d_arrayappendcTX))\n         {\n             // In expressionsem.d `arr ~= elem` was lowered to\n@@ -5018,6 +5039,21 @@ public:\n             result = interpret(cae, istate);\n             return;\n         }\n+        else if (isNewThrowableHook())\n+        {\n+            // In expressionsem.d `throw new Exception(args)` was lowered to\n+            // `throw (tmp = _d_newThrowable!Exception(), tmp.ctor(args), tmp)`.\n+            // The following code will rewrite it back to `throw new Exception(args)`\n+            // and then interpret this expression instead.\n+            auto ce = e.e2.isCallExp();\n+            assert(ce);\n+\n+            auto ne = new NewExp(e.loc, null, e.type, ce.arguments);\n+            ne.type = e.e1.type;\n+\n+            result = interpret(ne, istate);\n+            return;\n+        }\n \n         // If it creates a variable, and there's no context for\n         // the variable to be created in, we need to create one now."}, {"sha": "9c30978551b1df880be1842ecffc86eec2f1b639", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -754,7 +754,6 @@ struct Scope\n             //    assert(0);\n         }\n     }\n-\n     /******************************\n      */\n     structalign_t alignment()\n@@ -771,13 +770,13 @@ struct Scope\n             return sa;\n         }\n     }\n-\n+    @safe @nogc pure nothrow const:\n     /**********************************\n     * Checks whether the current scope (or any of its parents) is deprecated.\n     *\n     * Returns: `true` if this or any parent scope is deprecated, `false` otherwise`\n     */\n-    extern(C++) bool isDeprecated() @safe @nogc pure nothrow const\n+    extern(C++) bool isDeprecated()\n     {\n         for (const(Dsymbol)* sp = &(this.parent); *sp; sp = &(sp.parent))\n         {\n@@ -799,4 +798,16 @@ struct Scope\n         }\n         return false;\n     }\n+    /**\n+     * dmd relies on mutation of state during semantic analysis, however\n+     * sometimes semantic is being performed in a speculative context that should\n+     * not have any visible effect on the rest of the compilation: for example when compiling\n+     * a typeof() or __traits(compiles).\n+     *\n+     * Returns: `true` if this `Scope` is known to be from one of these speculative contexts\n+     */\n+    extern(C++) bool isFromSpeculativeSemanticContext() scope\n+    {\n+        return this.intypeof || this.flags & SCOPE.compile;\n+    }\n }"}, {"sha": "2b608f6974c9a70bd252bd515c07cb458eddccba", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -2184,20 +2184,13 @@ extern (C++) final class OverloadSet : Dsymbol\n  */\n extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n {\n-    /*************************\n-     * Symbol to forward insertions to.\n-     * Can be `null` before being lazily initialized.\n-     */\n-    ScopeDsymbol forward;\n-    extern (D) this(ScopeDsymbol forward) nothrow\n+    extern (D) this() nothrow\n     {\n-        super(null);\n-        this.forward = forward;\n+        super();\n     }\n \n     override Dsymbol symtabInsert(Dsymbol s) nothrow\n     {\n-        assert(forward);\n         if (auto d = s.isDeclaration())\n         {\n             if (d.storage_class & STC.local)\n@@ -2212,6 +2205,8 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n                 return super.symtabInsert(s); // insert locally\n             }\n         }\n+        auto forward = parent.isScopeDsymbol();\n+        assert(forward);\n         if (!forward.symtab)\n         {\n             forward.symtab = new DsymbolTable();\n@@ -2228,7 +2223,6 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n      */\n     override Dsymbol symtabLookup(Dsymbol s, Identifier id) nothrow\n     {\n-        assert(forward);\n         // correctly diagnose clashing foreach loop variables.\n         if (auto d = s.isDeclaration())\n         {\n@@ -2243,6 +2237,8 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n         }\n         // Declarations within `static foreach` do not clash with\n         // `static foreach` loop variables.\n+        auto forward = parent.isScopeDsymbol();\n+        assert(forward);\n         if (!forward.symtab)\n         {\n             forward.symtab = new DsymbolTable();\n@@ -2252,6 +2248,8 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n \n     override void importScope(Dsymbol s, Visibility visibility)\n     {\n+        auto forward = parent.isScopeDsymbol();\n+        assert(forward);\n         forward.importScope(s, visibility);\n     }\n "}, {"sha": "bea4b776ec5be0f0bf8b250caa3535e88c0be534", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -391,8 +391,6 @@ class OverloadSet final : public Dsymbol\n class ForwardingScopeDsymbol final : public ScopeDsymbol\n {\n public:\n-    ScopeDsymbol *forward;\n-\n     Dsymbol *symtabInsert(Dsymbol *s) override;\n     Dsymbol *symtabLookup(Dsymbol *s, Identifier *id) override;\n     void importScope(Dsymbol *s, Visibility visibility) override;"}, {"sha": "6dbc129baaf1637b1f65885b65262d7a73f57752", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -3276,13 +3276,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if ((funcdecl.storage_class & STC.auto_) && !f.isref && !funcdecl.inferRetType)\n             funcdecl.error(\"storage class `auto` has no effect if return type is not inferred\");\n \n-        /* Functions can only be 'scope' if they have a 'this'\n-         */\n-        if (f.isScopeQual && !funcdecl.isNested() && !ad)\n-        {\n-            funcdecl.error(\"functions cannot be `scope`\");\n-        }\n-\n         if (f.isreturn && !funcdecl.needThis() && !funcdecl.isNested())\n         {\n             /* Non-static nested functions have a hidden 'this' pointer to which"}, {"sha": "c0a8e9f4664def6d6acf70ddaf7c1ec2ff4451db", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1632,7 +1632,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                             if (farg.op == EXP.error || farg.type.ty == Terror)\n                                 return nomatch();\n \n-                            if (!(fparam.storageClass & STC.lazy_) && farg.type.ty == Tvoid)\n+                            if (!fparam.isLazy() && farg.type.ty == Tvoid)\n                                 return nomatch();\n \n                             Type tt;\n@@ -1837,7 +1837,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                     }\n                     Type argtype = farg.type;\n \n-                    if (!(fparam.storageClass & STC.lazy_) && argtype.ty == Tvoid && farg.op != EXP.function_)\n+                    if (!fparam.isLazy() && argtype.ty == Tvoid && farg.op != EXP.function_)\n                         return nomatch();\n \n                     // https://issues.dlang.org/show_bug.cgi?id=12876\n@@ -1958,7 +1958,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                         if (!farg.type.isMutable()) // https://issues.dlang.org/show_bug.cgi?id=11916\n                             return nomatch();\n                     }\n-                    if (m == MATCH.nomatch && (fparam.storageClass & STC.lazy_) && prmtype.ty == Tvoid && farg.type.ty != Tvoid)\n+                    if (m == MATCH.nomatch && fparam.isLazy() && prmtype.ty == Tvoid && farg.type.ty != Tvoid)\n                         m = MATCH.convert;\n                     if (m != MATCH.nomatch)\n                     {\n@@ -7723,7 +7723,7 @@ extern (C++) final class TemplateMixin : TemplateInstance\n             }\n             if (!tempdecl)\n             {\n-                error(\"`%s` isn't a template\", s.toChars());\n+                error(\"- `%s` is a %s, not a template\", s.toChars(), s.kind());\n                 return false;\n             }\n         }"}, {"sha": "dcc5b5095ed990051ba6348a683827a76f4dc491", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 82, "deletions": 18, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -443,7 +443,7 @@ private Expression searchUFCS(Scope* sc, UnaExp ue, Identifier ident)\n     }\n \n     if (!s)\n-        return ue.e1.type.Type.getProperty(sc, loc, ident, 0);\n+        return ue.e1.type.getProperty(sc, loc, ident, 0);\n \n     FuncDeclaration f = s.isFuncDeclaration();\n     if (f)\n@@ -1856,7 +1856,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             }\n \n         L1:\n-            if (!(p.storageClass & STC.lazy_ && p.type.ty == Tvoid))\n+            if (!(p.isLazy() && p.type.ty == Tvoid))\n             {\n                 if (ubyte wm = arg.type.deduceWild(p.type, p.isReference()))\n                 {\n@@ -1953,7 +1953,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             Type targ = arg.type;               // keep original type for isCopyable() because alias this\n                                                 // resolution may hide an uncopyable type\n \n-            if (!(p.storageClass & STC.lazy_ && p.type.ty == Tvoid))\n+            if (!(p.isLazy() && p.type.ty == Tvoid))\n             {\n                 Type tprm = p.type.hasWild()\n                     ? p.type.substWildTo(wildmatch)\n@@ -2018,7 +2018,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                 }\n                 arg = arg.toLvalue(sc, arg);\n             }\n-            else if (p.storageClass & STC.lazy_)\n+            else if (p.isLazy())\n             {\n                 // Convert lazy argument to a delegate\n                 auto t = (p.type.ty == Tvoid) ? p.type : arg.type;\n@@ -2050,7 +2050,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             // Turning heap allocations into stack allocations is dangerous without dip1000, since `scope` inference\n             // may be unreliable when scope violations only manifest as deprecation warnings.\n             // However, existing `@nogc` code may rely on it, so still do it when the parameter is explicitly marked `scope`\n-            const explicitScope = (p.storageClass & STC.lazy_) ||\n+            const explicitScope = p.isLazy() ||\n                 ((p.storageClass & STC.scope_) && !(p.storageClass & STC.scopeinferred));\n             if ((pStc & (STC.scope_ | STC.lazy_)) &&\n                 ((global.params.useDIP1000 == FeatureState.enabled) || explicitScope) &&\n@@ -2261,7 +2261,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             if (arg.type.needsDestruction())\n             {\n                 Parameter p = (i >= nparams ? null : tf.parameterList[i]);\n-                if (!(p && (p.storageClass & (STC.lazy_ | STC.ref_ | STC.out_))))\n+                if (!(p && (p.isLazy() || p.isReference())))\n                 {\n                     if (firstdtor == -1)\n                         firstdtor = i;\n@@ -2302,7 +2302,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n \n             Parameter parameter = (i >= nparams ? null : tf.parameterList[i]);\n             const bool isRef = parameter && parameter.isReference();\n-            const bool isLazy = (parameter && (parameter.storageClass & STC.lazy_));\n+            const bool isLazy = parameter && parameter.isLazy();\n \n             /* Skip lazy parameters\n              */\n@@ -3722,6 +3722,36 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     }\n                 }\n             }\n+\n+            // When using `@nogc` exception handling, lower `throw new E(args)` to\n+            // `throw (__tmp = _d_newThrowable!E(), __tmp.__ctor(args), __tmp)`.\n+            if (global.params.ehnogc && exp.thrownew &&\n+                !cd.isCOMclass() && !cd.isCPPclass())\n+            {\n+                assert(cd.ctor);\n+\n+                Expression id = new IdentifierExp(exp.loc, Id.empty);\n+                id = new DotIdExp(exp.loc, id, Id.object);\n+\n+                auto tiargs = new Objects();\n+                tiargs.push(exp.newtype);\n+                id = new DotTemplateInstanceExp(exp.loc, id, Id._d_newThrowable, tiargs);\n+                id = new CallExp(exp.loc, id).expressionSemantic(sc);\n+\n+                Expression idVal;\n+                Expression tmp = extractSideEffect(sc, \"__tmpThrowable\", idVal, id, true);\n+                // auto castTmp = new CastExp(exp.loc, tmp, exp.type);\n+\n+                auto ctor = new DotIdExp(exp.loc, tmp, Id.ctor).expressionSemantic(sc);\n+                auto ctorCall = new CallExp(exp.loc, ctor, exp.arguments);\n+\n+                id = Expression.combine(idVal, exp.argprefix).expressionSemantic(sc);\n+                id = Expression.combine(id, ctorCall).expressionSemantic(sc);\n+                // id = Expression.combine(id, castTmp).expressionSemantic(sc);\n+\n+                result = id.expressionSemantic(sc);\n+                return;\n+            }\n         }\n         else if (auto ts = tb.isTypeStruct())\n         {\n@@ -6582,6 +6612,14 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             result = e;\n             return;\n         }\n+        else if (auto ad = exp.var.isAliasDeclaration())\n+        {\n+            if (auto t = ad.getType())\n+            {\n+                result = new TypeExp(exp.loc, t).expressionSemantic(sc);\n+                return;\n+            }\n+        }\n \n         exp.e1 = exp.e1.addDtorHook(sc);\n \n@@ -7006,9 +7044,19 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 /* Because nested functions cannot be overloaded,\n                  * mark here that we took its address because castTo()\n                  * may not be called with an exact match.\n+                 *\n+                 * https://issues.dlang.org/show_bug.cgi?id=19285 :\n+                 * We also need to make sure we aren't inside a typeof. Ideally the compiler\n+                 * would do typeof(...) semantic analysis speculatively then collect information\n+                 * about what it used rather than relying on what are effectively semantically-global\n+                 * variables but it doesn't.\n                  */\n-                if (!ve.hasOverloads || (f.isNested() && !f.needThis()))\n+                if (!sc.isFromSpeculativeSemanticContext() && (!ve.hasOverloads || (f.isNested() && !f.needThis())))\n+                {\n+                    // TODO: Refactor to use a proper interface that can keep track of causes.\n                     f.tookAddressOf++;\n+                }\n+\n                 if (f.isNested() && !f.needThis())\n                 {\n                     if (f.isFuncLiteralDeclaration())\n@@ -12855,11 +12903,8 @@ Expression semanticY(DotTemplateInstanceExp exp, Scope* sc, int flag)\n \n         if (Declaration v = exp.ti.toAlias().isDeclaration())\n         {\n-            if (v.isFuncDeclaration() || v.isVarDeclaration())\n-            {\n-                return new DotVarExp(exp.loc, exp.e1, v)\n-                       .expressionSemantic(sc);\n-            }\n+            return new DotVarExp(exp.loc, exp.e1, v)\n+                   .expressionSemantic(sc);\n         }\n         return new DotExp(exp.loc, exp.e1, new ScopeExp(exp.loc, exp.ti))\n                .expressionSemantic(sc);\n@@ -12966,8 +13011,19 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n \n         bool visitVar(VarExp e)\n         {\n-            if (!allowRef && e.var.type.isShared())\n+            // https://issues.dlang.org/show_bug.cgi?id=22626\n+            // Synchronized functions don't need to use core.atomic\n+            // when accessing `this`.\n+            if (sc.func && sc.func.isSynchronized())\n+            {\n+                if (e.var.isThisDeclaration())\n+                    return false;\n+                else\n+                    return sharedError(e);\n+            }\n+            else if (!allowRef && e.var.type.isShared())\n                 return sharedError(e);\n+\n             return false;\n         }\n \n@@ -12987,15 +13043,22 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n             return check(e.e1, false);\n         }\n \n+        bool visitThis(ThisExp e)\n+        {\n+            if (sc.func && sc.func.isSynchronized())\n+                return false;\n+\n+            return sharedError(e);\n+        }\n+\n         bool visitDotVar(DotVarExp e)\n         {\n+            //printf(\"dotvarexp = %s\\n\", e.toChars());\n             auto fd = e.var.isFuncDeclaration();\n             const sharedFunc = fd && fd.type.isShared;\n-\n-            if (!allowRef && e.type.isShared() && !sharedFunc)\n-                return sharedError(e);\n-\n             // Allow using `DotVarExp` within value types\n+            if (!allowRef && e.type.isShared() && !sharedFunc && !(sc.func && sc.func.isSynchronized()))\n+                return sharedError(e);\n             if (e.e1.type.isTypeSArray() || e.e1.type.isTypeStruct())\n                 return check(e.e1, allowRef);\n \n@@ -13044,6 +13107,7 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n             case EXP.star:        return visitPtr(e.isPtrExp());\n             case EXP.dotVariable: return visitDotVar(e.isDotVarExp());\n             case EXP.index:       return visitIndex(e.isIndexExp());\n+            case EXP.this_:       return visitThis(e.isThisExp());\n         }\n     }\n "}, {"sha": "d42925990a98f5c6bbb36485c36e06a31401d90e", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1773,7 +1773,7 @@ extern (C++) class FuncDeclaration : Declaration\n             if (!tp)\n                 continue;\n \n-            if (fparam.storageClass & (STC.lazy_ | STC.out_ | STC.ref_))\n+            if (fparam.isLazy() || fparam.isReference())\n             {\n                 if (!traverseIndirections(tp, t))\n                     return false;\n@@ -2528,7 +2528,7 @@ extern (C++) class FuncDeclaration : Declaration\n             foreach (n, p; parameterList)\n             {\n                 p = p.syntaxCopy();\n-                if (!(p.storageClass & STC.lazy_))\n+                if (!p.isLazy())\n                     p.storageClass = (p.storageClass | STC.ref_) & ~STC.out_;\n                 p.defaultArg = null; // won't be the same with ref\n                 result.push(p);"}, {"sha": "5142daa5137faff73d3b3391fd8daaeb00d2cff2", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -311,6 +311,7 @@ immutable Msgtable[] msgtable =\n     { \"__ArrayPostblit\" },\n     { \"__ArrayDtor\" },\n     { \"_d_delThrowable\" },\n+    { \"_d_newThrowable\" },\n     { \"_d_assert_fail\" },\n     { \"dup\" },\n     { \"_aaApply\" },"}, {"sha": "6b5389dfebbaab0e02d9022066e824b62c4cd21c", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -529,7 +529,6 @@ extern (C++) abstract class Type : ASTNode\n      * Returns:\n      *     An enum value of either `Covariant.yes` or a reason it's not covariant.\n      */\n-    extern (D)\n     final Covariant covariant(Type t, StorageClass* pstc = null, bool cppCovariant = false)\n     {\n         version (none)\n@@ -4361,7 +4360,7 @@ extern (C++) final class TypeFunction : TypeNext\n     {\n         foreach (i, fparam; parameterList)\n         {\n-            if (fparam.storageClass & STC.lazy_)\n+            if (fparam.isLazy())\n                 return true;\n         }\n         return false;\n@@ -4675,7 +4674,7 @@ extern (C++) final class TypeFunction : TypeNext\n             Type tprm = p.type;\n             Type targ = arg.type;\n \n-            if (!(p.storageClass & STC.lazy_ && tprm.ty == Tvoid && targ.ty != Tvoid))\n+            if (!(p.isLazy() && tprm.ty == Tvoid && targ.ty != Tvoid))\n             {\n                 const isRef = p.isReference();\n                 wildmatch |= targ.deduceWild(tprm, isRef);\n@@ -4718,7 +4717,7 @@ extern (C++) final class TypeFunction : TypeNext\n                 Type targ = arg.type;\n                 Type tprm = wildmatch ? p.type.substWildTo(wildmatch) : p.type;\n \n-                if (p.storageClass & STC.lazy_ && tprm.ty == Tvoid && targ.ty != Tvoid)\n+                if (p.isLazy() && tprm.ty == Tvoid && targ.ty != Tvoid)\n                     m = MATCH.convert;\n                 else\n                 {\n@@ -6825,6 +6824,12 @@ extern (C++) final class Parameter : ASTNode\n         return null;\n     }\n \n+    /// Returns: Whether the function parameter is lazy\n+    bool isLazy() const @safe pure nothrow @nogc\n+    {\n+        return (this.storageClass & (STC.lazy_)) != 0;\n+    }\n+\n     /// Returns: Whether the function parameter is a reference (out / ref)\n     bool isReference() const @safe pure nothrow @nogc\n     {"}, {"sha": "3e614d88180ba22deb655293c8f3b054a34f4f6c", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -128,6 +128,14 @@ enum VarArgValues\n };\n typedef unsigned char VarArg;\n \n+enum class Covariant\n+{\n+    distinct = 0, /// types are distinct\n+    yes = 1,      /// types are covariant\n+    no = 2,       /// arguments match as far as overloading goes, but types are not covariant\n+    fwdref = 3,   /// cannot determine covariance because of forward references\n+};\n+\n class Type : public ASTNode\n {\n public:\n@@ -218,6 +226,7 @@ class Type : public ASTNode\n     // kludge for template.isType()\n     DYNCAST dyncast() const override final { return DYNCAST_TYPE; }\n     size_t getUniqueID() const;\n+    Covariant covariant(Type *, StorageClass * = NULL, bool = false);\n     const char *toChars() const override;\n     char *toPrettyChars(bool QualifyTypes = false);\n     static void _init();\n@@ -560,6 +569,8 @@ class Parameter final : public ASTNode\n                              Expression *defaultArg, UserAttributeDeclaration *userAttribDecl);\n     Parameter *syntaxCopy();\n     Type *isLazyArray();\n+    bool isLazy() const;\n+    bool isReference() const;\n     // kludge for template.isType()\n     DYNCAST dyncast() const override { return DYNCAST_PARAMETER; }\n     void accept(Visitor *v) override { v->visit(this); }"}, {"sha": "89f8ae3470f5076798fdf6f37b338cbbf0098ae2", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1460,7 +1460,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n         if (token.value != TOK.leftCurly)\n         {\n-            error(\"members of template declaration expected\");\n+            error(\"`{` expected after template parameter list, not `%s`\", token.toChars());\n             goto Lerr;\n         }\n         decldefs = parseBlock(null);"}, {"sha": "b29c59943f3ab52c9eeb11ff46c3a5c69996dad6", "filename": "gcc/d/dmd/scope.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fscope.h?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -147,4 +147,5 @@ struct Scope\n     structalign_t alignment();\n \n     bool isDeprecated() const;\n+    bool isFromSpeculativeSemanticContext() const;\n };"}, {"sha": "a519f3b4c4c3e94bc0f1d5045705d33898bbbfc0", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -761,7 +761,7 @@ extern (C++) final class ForwardingStatement : Statement\n \n     extern (D) this(const ref Loc loc, Statement statement)\n     {\n-        auto sym = new ForwardingScopeDsymbol(null);\n+        auto sym = new ForwardingScopeDsymbol();\n         sym.symtab = new DsymbolTable();\n         this(loc, sym, statement);\n     }"}, {"sha": "06e28a4819d15e2119c53e1090b77c2a7387ad6a", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -502,10 +502,10 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n     override void visit(ForwardingStatement ss)\n     {\n         assert(ss.sym);\n-        for (Scope* csc = sc; !ss.sym.forward; csc = csc.enclosing)\n+        for (Scope* csc = sc; !ss.sym.parent; csc = csc.enclosing)\n         {\n             assert(csc);\n-            ss.sym.forward = csc.scopesym;\n+            ss.sym.parent = csc.scopesym;\n         }\n         sc = sc.push(ss.sym);\n         sc.sbreak = ss;\n@@ -2891,7 +2891,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             /* Void-return function can have void / noreturn typed expression\n              * on return statement.\n              */\n-            const convToVoid = rs.exp.type.ty == Tvoid || rs.exp.type.ty == Tnoreturn;\n+            auto texp = rs.exp.type;\n+            const convToVoid = texp.ty == Tvoid || texp.ty == Tnoreturn;\n \n             if (tbret && tbret.ty == Tvoid || convToVoid)\n             {\n@@ -2903,6 +2904,15 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                     rs.exp = rs.exp.expressionSemantic(sc);\n                 }\n \n+                // https://issues.dlang.org/show_bug.cgi?id=23063\n+                if (texp.isTypeNoreturn() && !rs.exp.isAssertExp() && !rs.exp.isThrowExp() && !rs.exp.isCallExp())\n+                {\n+                    auto msg = new StringExp(rs.exp.loc, \"Accessed expression of type `noreturn`\");\n+                    msg.type = Type.tstring;\n+                    rs.exp = new AssertExp(rs.loc, IntegerExp.literal!0, msg);\n+                    rs.exp.type = texp;\n+                }\n+\n                 /* Replace:\n                  *      return exp;\n                  * with:\n@@ -3698,6 +3708,13 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n \n         if (oss.tok != TOK.onScopeExit)\n         {\n+            // https://issues.dlang.org/show_bug.cgi?id=23159\n+            if (!global.params.useExceptions)\n+            {\n+                oss.error(\"`%s` cannot be used with -betterC\", Token.toChars(oss.tok));\n+                return setError();\n+            }\n+\n             // scope(success) and scope(failure) are rewritten to try-catch(-finally) statement,\n             // so the generated catch block cannot be placed in finally block.\n             // See also Catch::semantic.\n@@ -4312,7 +4329,7 @@ public auto makeTupleForeach(Scope* sc, bool isStatic, bool isDecl, ForeachState\n         if (!skip && dim == 2)\n         {\n             // Declare key\n-            if (p.storageClass & (STC.out_ | STC.ref_ | STC.lazy_))\n+            if (p.isReference() || p.isLazy())\n             {\n                 fs.error(\"no storage class for key `%s`\", p.ident.toChars());\n                 return returnEarly();"}, {"sha": "31ecbd246e69c04e99a324a9d848aa5d5c931339", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 241, "deletions": 230, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -64,48 +64,6 @@ import dmd.sideeffect;\n import dmd.target;\n import dmd.tokens;\n \n-/**************************\n- * This evaluates exp while setting length to be the number\n- * of elements in the tuple t.\n- */\n-private Expression semanticLength(Scope* sc, Type t, Expression exp)\n-{\n-    if (auto tt = t.isTypeTuple())\n-    {\n-        ScopeDsymbol sym = new ArrayScopeSymbol(sc, tt);\n-        sym.parent = sc.scopesym;\n-        sc = sc.push(sym);\n-        sc = sc.startCTFE();\n-        exp = exp.expressionSemantic(sc);\n-        exp = resolveProperties(sc, exp);\n-        sc = sc.endCTFE();\n-        sc.pop();\n-    }\n-    else\n-    {\n-        sc = sc.startCTFE();\n-        exp = exp.expressionSemantic(sc);\n-        exp = resolveProperties(sc, exp);\n-        sc = sc.endCTFE();\n-    }\n-    return exp;\n-}\n-\n-private Expression semanticLength(Scope* sc, TupleDeclaration tup, Expression exp)\n-{\n-    ScopeDsymbol sym = new ArrayScopeSymbol(sc, tup);\n-    sym.parent = sc.scopesym;\n-\n-    sc = sc.push(sym);\n-    sc = sc.startCTFE();\n-    exp = exp.expressionSemantic(sc);\n-    exp = resolveProperties(sc, exp);\n-    sc = sc.endCTFE();\n-    sc.pop();\n-\n-    return exp;\n-}\n-\n /*************************************\n  * Resolve a tuple index, `s[oindex]`, by figuring out what `s[oindex]` represents.\n  * Setting one of pe/pt/ps.\n@@ -452,101 +410,6 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n         pt = t.merge();\n }\n \n-/************************************\n- * Transitively search a type for all function types.\n- * If any function types with parameters are found that have parameter identifiers\n- * or default arguments, remove those and create a new type stripped of those.\n- * This is used to determine the \"canonical\" version of a type which is useful for\n- * comparisons.\n- * Params:\n- *      t = type to scan\n- * Returns:\n- *      `t` if no parameter identifiers or default arguments found, otherwise a new type that is\n- *      the same as t but with no parameter identifiers or default arguments.\n- */\n-private Type stripDefaultArgs(Type t)\n-{\n-    static Parameters* stripParams(Parameters* parameters)\n-    {\n-        static Parameter stripParameter(Parameter p)\n-        {\n-            Type t = stripDefaultArgs(p.type);\n-            return (t != p.type || p.defaultArg || p.ident || p.userAttribDecl)\n-                ? new Parameter(p.storageClass, t, null, null, null)\n-                : null;\n-        }\n-\n-        if (parameters)\n-        {\n-            foreach (i, p; *parameters)\n-            {\n-                Parameter ps = stripParameter(p);\n-                if (ps)\n-                {\n-                    // Replace params with a copy we can modify\n-                    Parameters* nparams = new Parameters(parameters.dim);\n-\n-                    foreach (j, ref np; *nparams)\n-                    {\n-                        Parameter pj = (*parameters)[j];\n-                        if (j < i)\n-                            np = pj;\n-                        else if (j == i)\n-                            np = ps;\n-                        else\n-                        {\n-                            Parameter nps = stripParameter(pj);\n-                            np = nps ? nps : pj;\n-                        }\n-                    }\n-                    return nparams;\n-                }\n-            }\n-        }\n-        return parameters;\n-    }\n-\n-    if (t is null)\n-        return t;\n-\n-    if (auto tf = t.isTypeFunction())\n-    {\n-        Type tret = stripDefaultArgs(tf.next);\n-        Parameters* params = stripParams(tf.parameterList.parameters);\n-        if (tret == tf.next && params == tf.parameterList.parameters)\n-            return t;\n-        TypeFunction tr = tf.copy().isTypeFunction();\n-        tr.parameterList.parameters = params;\n-        tr.next = tret;\n-        //printf(\"strip %s\\n   <- %s\\n\", tr.toChars(), t.toChars());\n-        return tr;\n-    }\n-    else if (auto tt = t.isTypeTuple())\n-    {\n-        Parameters* args = stripParams(tt.arguments);\n-        if (args == tt.arguments)\n-            return t;\n-        TypeTuple tr = t.copy().isTypeTuple();\n-        tr.arguments = args;\n-        return tr;\n-    }\n-    else if (t.ty == Tenum)\n-    {\n-        // TypeEnum::nextOf() may be != NULL, but it's not necessary here.\n-        return t;\n-    }\n-    else\n-    {\n-        Type tn = t.nextOf();\n-        Type n = stripDefaultArgs(tn);\n-        if (n == tn)\n-            return t;\n-        TypeNext tr = cast(TypeNext)t.copy();\n-        tr.next = n;\n-        return tr;\n-    }\n-}\n-\n /******************************************\n  * We've mistakenly parsed `t` as a type.\n  * Redo `t` as an Expression only if there are no type modifiers.\n@@ -603,53 +466,6 @@ Expression typeToExpression(Type t)\n     }\n }\n \n-/* Helper function for `typeToExpression`. Contains common code\n- * for TypeQualified derived classes.\n- */\n-Expression typeToExpressionHelper(TypeQualified t, Expression e, size_t i = 0)\n-{\n-    //printf(\"toExpressionHelper(e = %s %s)\\n\", EXPtoString(e.op).ptr, e.toChars());\n-    foreach (id; t.idents[i .. t.idents.dim])\n-    {\n-        //printf(\"\\t[%d] e: '%s', id: '%s'\\n\", i, e.toChars(), id.toChars());\n-\n-        final switch (id.dyncast())\n-        {\n-            // ... '. ident'\n-            case DYNCAST.identifier:\n-                e = new DotIdExp(e.loc, e, cast(Identifier)id);\n-                break;\n-\n-            // ... '. name!(tiargs)'\n-            case DYNCAST.dsymbol:\n-                auto ti = (cast(Dsymbol)id).isTemplateInstance();\n-                assert(ti);\n-                e = new DotTemplateInstanceExp(e.loc, e, ti.name, ti.tiargs);\n-                break;\n-\n-            // ... '[type]'\n-            case DYNCAST.type:          // https://issues.dlang.org/show_bug.cgi?id=1215\n-                e = new ArrayExp(t.loc, e, new TypeExp(t.loc, cast(Type)id));\n-                break;\n-\n-            // ... '[expr]'\n-            case DYNCAST.expression:    // https://issues.dlang.org/show_bug.cgi?id=1215\n-                e = new ArrayExp(t.loc, e, cast(Expression)id);\n-                break;\n-\n-            case DYNCAST.object:\n-            case DYNCAST.tuple:\n-            case DYNCAST.parameter:\n-            case DYNCAST.statement:\n-            case DYNCAST.condition:\n-            case DYNCAST.templateparameter:\n-            case DYNCAST.initializer:\n-                assert(0);\n-        }\n-    }\n-    return e;\n-}\n-\n /******************************************\n  * Perform semantic analysis on a type.\n  * Params:\n@@ -1431,7 +1247,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                         errors = true;\n                     }\n                 }\n-                else if (!(fparam.storageClass & STC.lazy_) && t.ty == Tvoid)\n+                else if (!fparam.isLazy() && t.ty == Tvoid)\n                 {\n                     .error(loc, \"cannot have parameter of type `%s`\", fparam.type.toChars());\n                     errors = true;\n@@ -2157,47 +1973,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n     }\n }\n \n-/******************************************\n- * Compile the MixinType, returning the type or expression AST.\n- *\n- * Doesn't run semantic() on the returned object.\n- * Params:\n- *      tm = mixin to compile as a type or expression\n- *      loc = location for error messages\n- *      sc = context\n- * Return:\n- *      null if error, else RootObject AST as parsed\n- */\n-RootObject compileTypeMixin(TypeMixin tm, Loc loc, Scope* sc)\n-{\n-    OutBuffer buf;\n-    if (expressionsToString(buf, sc, tm.exps))\n-        return null;\n-\n-    const errors = global.errors;\n-    const len = buf.length;\n-    buf.writeByte(0);\n-    const str = buf.extractSlice()[0 .. len];\n-    scope p = new Parser!ASTCodegen(loc, sc._module, str, false);\n-    p.nextToken();\n-    //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n-\n-    auto o = p.parseTypeOrAssignExp(TOK.endOfFile);\n-    if (errors != global.errors)\n-    {\n-        assert(global.errors != errors); // should have caught all these cases\n-        return null;\n-    }\n-    if (p.token.value != TOK.endOfFile)\n-    {\n-        .error(loc, \"incomplete mixin type `%s`\", str.ptr);\n-        return null;\n-    }\n-\n-    return o;\n-}\n-\n-\n /************************************\n  * If an identical type to `type` is in `type.stringtable`, return\n  * the latter one. Otherwise, add it to `type.stringtable`.\n@@ -3243,6 +3018,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n         {\n             pt = mt.obj.isType();\n             ps = mt.obj.isDsymbol();\n+            pe = mt.obj.isExpression();\n             return;\n         }\n \n@@ -3310,22 +3086,30 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n             case EXP.overloadSet:\n                 mt.obj = e.isOverExp().type;\n                 break;\n+            case EXP.error:\n+                break;\n             default:\n+                mt.obj = e;\n                 break;\n             }\n         }\n \n         if (mt.obj)\n         {\n             if (auto t = mt.obj.isType())\n-                returnType(t.addMod(mt.mod));\n+            {\n+                t = t.addMod(mt.mod);\n+                mt.obj = t;\n+                returnType(t);\n+            }\n             else if (auto s = mt.obj.isDsymbol())\n                 returnSymbol(s);\n-            else\n-                assert(0);\n+            else if (auto e = mt.obj.isExpression())\n+                returnExp(e);\n         }\n         else\n         {\n+            assert(global.errors);\n             mt.obj = Type.terror;\n             return returnError();\n         }\n@@ -4817,6 +4601,193 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n     }\n }\n \n+/******************************* Private *****************************************/\n+\n+private:\n+\n+/* Helper function for `typeToExpression`. Contains common code\n+ * for TypeQualified derived classes.\n+ */\n+Expression typeToExpressionHelper(TypeQualified t, Expression e, size_t i = 0)\n+{\n+    //printf(\"toExpressionHelper(e = %s %s)\\n\", EXPtoString(e.op).ptr, e.toChars());\n+    foreach (id; t.idents[i .. t.idents.dim])\n+    {\n+        //printf(\"\\t[%d] e: '%s', id: '%s'\\n\", i, e.toChars(), id.toChars());\n+\n+        final switch (id.dyncast())\n+        {\n+            // ... '. ident'\n+            case DYNCAST.identifier:\n+                e = new DotIdExp(e.loc, e, cast(Identifier)id);\n+                break;\n+\n+            // ... '. name!(tiargs)'\n+            case DYNCAST.dsymbol:\n+                auto ti = (cast(Dsymbol)id).isTemplateInstance();\n+                assert(ti);\n+                e = new DotTemplateInstanceExp(e.loc, e, ti.name, ti.tiargs);\n+                break;\n+\n+            // ... '[type]'\n+            case DYNCAST.type:          // https://issues.dlang.org/show_bug.cgi?id=1215\n+                e = new ArrayExp(t.loc, e, new TypeExp(t.loc, cast(Type)id));\n+                break;\n+\n+            // ... '[expr]'\n+            case DYNCAST.expression:    // https://issues.dlang.org/show_bug.cgi?id=1215\n+                e = new ArrayExp(t.loc, e, cast(Expression)id);\n+                break;\n+\n+            case DYNCAST.object:\n+            case DYNCAST.tuple:\n+            case DYNCAST.parameter:\n+            case DYNCAST.statement:\n+            case DYNCAST.condition:\n+            case DYNCAST.templateparameter:\n+            case DYNCAST.initializer:\n+                assert(0);\n+        }\n+    }\n+    return e;\n+}\n+\n+/**************************\n+ * This evaluates exp while setting length to be the number\n+ * of elements in the tuple t.\n+ */\n+Expression semanticLength(Scope* sc, Type t, Expression exp)\n+{\n+    if (auto tt = t.isTypeTuple())\n+    {\n+        ScopeDsymbol sym = new ArrayScopeSymbol(sc, tt);\n+        sym.parent = sc.scopesym;\n+        sc = sc.push(sym);\n+        sc = sc.startCTFE();\n+        exp = exp.expressionSemantic(sc);\n+        exp = resolveProperties(sc, exp);\n+        sc = sc.endCTFE();\n+        sc.pop();\n+    }\n+    else\n+    {\n+        sc = sc.startCTFE();\n+        exp = exp.expressionSemantic(sc);\n+        exp = resolveProperties(sc, exp);\n+        sc = sc.endCTFE();\n+    }\n+    return exp;\n+}\n+\n+Expression semanticLength(Scope* sc, TupleDeclaration tup, Expression exp)\n+{\n+    ScopeDsymbol sym = new ArrayScopeSymbol(sc, tup);\n+    sym.parent = sc.scopesym;\n+\n+    sc = sc.push(sym);\n+    sc = sc.startCTFE();\n+    exp = exp.expressionSemantic(sc);\n+    exp = resolveProperties(sc, exp);\n+    sc = sc.endCTFE();\n+    sc.pop();\n+\n+    return exp;\n+}\n+\n+/************************************\n+ * Transitively search a type for all function types.\n+ * If any function types with parameters are found that have parameter identifiers\n+ * or default arguments, remove those and create a new type stripped of those.\n+ * This is used to determine the \"canonical\" version of a type which is useful for\n+ * comparisons.\n+ * Params:\n+ *      t = type to scan\n+ * Returns:\n+ *      `t` if no parameter identifiers or default arguments found, otherwise a new type that is\n+ *      the same as t but with no parameter identifiers or default arguments.\n+ */\n+Type stripDefaultArgs(Type t)\n+{\n+    static Parameters* stripParams(Parameters* parameters)\n+    {\n+        static Parameter stripParameter(Parameter p)\n+        {\n+            Type t = stripDefaultArgs(p.type);\n+            return (t != p.type || p.defaultArg || p.ident || p.userAttribDecl)\n+                ? new Parameter(p.storageClass, t, null, null, null)\n+                : null;\n+        }\n+\n+        if (parameters)\n+        {\n+            foreach (i, p; *parameters)\n+            {\n+                Parameter ps = stripParameter(p);\n+                if (ps)\n+                {\n+                    // Replace params with a copy we can modify\n+                    Parameters* nparams = new Parameters(parameters.dim);\n+\n+                    foreach (j, ref np; *nparams)\n+                    {\n+                        Parameter pj = (*parameters)[j];\n+                        if (j < i)\n+                            np = pj;\n+                        else if (j == i)\n+                            np = ps;\n+                        else\n+                        {\n+                            Parameter nps = stripParameter(pj);\n+                            np = nps ? nps : pj;\n+                        }\n+                    }\n+                    return nparams;\n+                }\n+            }\n+        }\n+        return parameters;\n+    }\n+\n+    if (t is null)\n+        return t;\n+\n+    if (auto tf = t.isTypeFunction())\n+    {\n+        Type tret = stripDefaultArgs(tf.next);\n+        Parameters* params = stripParams(tf.parameterList.parameters);\n+        if (tret == tf.next && params == tf.parameterList.parameters)\n+            return t;\n+        TypeFunction tr = tf.copy().isTypeFunction();\n+        tr.parameterList.parameters = params;\n+        tr.next = tret;\n+        //printf(\"strip %s\\n   <- %s\\n\", tr.toChars(), t.toChars());\n+        return tr;\n+    }\n+    else if (auto tt = t.isTypeTuple())\n+    {\n+        Parameters* args = stripParams(tt.arguments);\n+        if (args == tt.arguments)\n+            return t;\n+        TypeTuple tr = t.copy().isTypeTuple();\n+        tr.arguments = args;\n+        return tr;\n+    }\n+    else if (t.ty == Tenum)\n+    {\n+        // TypeEnum::nextOf() may be != NULL, but it's not necessary here.\n+        return t;\n+    }\n+    else\n+    {\n+        Type tn = t.nextOf();\n+        Type n = stripDefaultArgs(tn);\n+        if (n == tn)\n+            return t;\n+        TypeNext tr = cast(TypeNext)t.copy();\n+        tr.next = n;\n+        return tr;\n+    }\n+}\n \n /******************************\n  * Get the value of the .max/.min property of `ed` as an Expression.\n@@ -4829,7 +4800,7 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfi\n  * Returns:\n  *      corresponding value of .max/.min\n  */\n-private Expression getMaxMinValue(EnumDeclaration ed, const ref Loc loc, Identifier id)\n+Expression getMaxMinValue(EnumDeclaration ed, const ref Loc loc, Identifier id)\n {\n     //printf(\"EnumDeclaration::getMaxValue()\\n\");\n \n@@ -4935,3 +4906,43 @@ private Expression getMaxMinValue(EnumDeclaration ed, const ref Loc loc, Identif\n     }\n     return ed.errors ? errorReturn() : pvalToResult(*pval, loc);\n }\n+\n+/******************************************\n+ * Compile the MixinType, returning the type or expression AST.\n+ *\n+ * Doesn't run semantic() on the returned object.\n+ * Params:\n+ *      tm = mixin to compile as a type or expression\n+ *      loc = location for error messages\n+ *      sc = context\n+ * Return:\n+ *      null if error, else RootObject AST as parsed\n+ */\n+RootObject compileTypeMixin(TypeMixin tm, Loc loc, Scope* sc)\n+{\n+    OutBuffer buf;\n+    if (expressionsToString(buf, sc, tm.exps))\n+        return null;\n+\n+    const errors = global.errors;\n+    const len = buf.length;\n+    buf.writeByte(0);\n+    const str = buf.extractSlice()[0 .. len];\n+    scope p = new Parser!ASTCodegen(loc, sc._module, str, false);\n+    p.nextToken();\n+    //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n+\n+    auto o = p.parseTypeOrAssignExp(TOK.endOfFile);\n+    if (errors != global.errors)\n+    {\n+        assert(global.errors != errors); // should have caught all these cases\n+        return null;\n+    }\n+    if (p.token.value != TOK.endOfFile)\n+    {\n+        .error(loc, \"incomplete mixin type `%s`\", str.ptr);\n+        return null;\n+    }\n+\n+    return o;\n+}"}, {"sha": "b701be38e426b39355a46fbe00a4e1b21ef49d20", "filename": "gcc/d/dmd/typinf.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Ftypinf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fdmd%2Ftypinf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypinf.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,7 @@ import dmd.dscope;\n import dmd.dclass;\n import dmd.dstruct;\n import dmd.errors;\n+import dmd.expression;\n import dmd.globals;\n import dmd.gluelayer;\n import dmd.mtype;\n@@ -28,11 +29,12 @@ import core.stdc.stdio;\n  * Generates the `TypeInfo` object associated with `torig` if it\n  * hasn't already been generated\n  * Params:\n+ *      e     = if not null, then expression for pretty-printing errors\n  *      loc   = the location for reporting line numbers in errors\n  *      torig = the type to generate the `TypeInfo` object for\n  *      sc    = the scope\n  */\n-extern (C++) void genTypeInfo(const ref Loc loc, Type torig, Scope* sc)\n+extern (C++) void genTypeInfo(Expression e, const ref Loc loc, Type torig, Scope* sc)\n {\n     // printf(\"genTypeInfo() %s\\n\", torig.toChars());\n \n@@ -43,7 +45,10 @@ extern (C++) void genTypeInfo(const ref Loc loc, Type torig, Scope* sc)\n     {\n         if (!global.params.useTypeInfo)\n         {\n-            .error(loc, \"`TypeInfo` cannot be used with -betterC\");\n+            if (e)\n+                .error(loc, \"expression `%s` uses the GC and cannot be used with switch `-betterC`\", e.toChars());\n+            else\n+                .error(loc, \"`TypeInfo` cannot be used with -betterC\");\n             fatal();\n         }\n     }"}, {"sha": "179f9a5f4fd3cd8871a7d95751f53237f4c9d763", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -2238,13 +2238,17 @@ class ExprVisitor : public Visitor\n \t    new_call = build_nop (type, build_address (var));\n \t    setup_exp = modify_expr (var, aggregate_initializer_decl (cd));\n \t  }\n+\telse if (global.params.ehnogc && e->thrownew)\n+\t  {\n+\t    /* Allocating a `@nogc' Exception with `_d_newThrowable' has already\n+\t       been handled by the front-end.  */\n+\t    gcc_unreachable ();\n+\t  }\n \telse\n \t  {\n \t    /* Generate: _d_newclass()  */\n \t    tree arg = build_address (get_classinfo_decl (cd));\n-\t    libcall_fn libcall = (global.params.ehnogc && e->thrownew)\n-\t      ? LIBCALL_NEWTHROW : LIBCALL_NEWCLASS;\n-\t    new_call = build_libcall (libcall, tb, 1, arg);\n+\t    new_call = build_libcall (LIBCALL_NEWCLASS, tb, 1, arg);\n \t  }\n \n \t/* Set the context pointer for nested classes.  */"}, {"sha": "459a28386a055109e9fe607c5fdd97b656f62406", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -61,7 +61,6 @@ DEF_D_RUNTIME (ARRAYBOUNDS_INDEXP, \"_d_arraybounds_indexp\", RT(VOID),\n \n /* Used when calling new on a class.  */\n DEF_D_RUNTIME (NEWCLASS, \"_d_newclass\", RT(OBJECT), P1(CONST_CLASSINFO), 0)\n-DEF_D_RUNTIME (NEWTHROW, \"_d_newThrowable\", RT(OBJECT), P1(CONST_CLASSINFO), 0)\n \n /* Used when calling delete on a stack-allocated class or interface.  */\n DEF_D_RUNTIME (CALLFINALIZER, \"_d_callfinalizer\", RT(VOID), P1(VOIDPTR), 0)"}, {"sha": "6bd0736654432b0fef451a5671aaf4ecc4da5229", "filename": "gcc/testsuite/gdc.test/compilable/imports/defines.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefines.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefines.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefines.c?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,28 @@\n+/* */\n+\n+#define CC 'c'\n+_Static_assert(CC == 'c', \"1\");\n+\n+#define I32 3\n+_Static_assert(I32 == 3, \"3\");\n+\n+#define U32 4U\n+_Static_assert(U32 == 4U, \"4\");\n+\n+#define I64 5L\n+_Static_assert(I64 == 5U, \"5\");\n+\n+#define U64 6UL\n+_Static_assert(U64 == 6UL, \"6\");\n+\n+#define F32 7.0f\n+_Static_assert(F32 == 7.0f, \"7\");\n+\n+#define F64 8.0f\n+_Static_assert(F64 == 8.0, \"8\");\n+\n+#define F80 9.0f\n+_Static_assert(F80 == 9.0L, \"9\");\n+\n+#define SSS \"hello\"\n+_Static_assert(SSS[0] == 'h', \"10\");"}, {"sha": "6ce5094371f63a41f7d1dd5dcd767328691a60b5", "filename": "gcc/testsuite/gdc.test/compilable/nogc.d", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnogc.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -109,3 +109,12 @@ auto foo13550() @nogc\n     }\n     return &bar;\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=19285\n+\n+void f(bool cond, string s) @nogc {\n+    auto inner() { return s; }\n+    alias Unused1 = typeof(inner); // OK\n+    alias Unused2 = typeof(&inner); // (Does not) INFERS GC (anymore)\n+    enum Unused3 = __traits(compiles , &inner);\n+}"}, {"sha": "5f72eb635c05179396cf694c6be7483eb51e8dd2", "filename": "gcc/testsuite/gdc.test/compilable/test22626.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22626.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22626.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22626.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,23 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22626\n+// REQUIRED_ARGS: -preview=nosharedaccess\n+\n+shared int k;\n+\n+class Oops\n+{\n+    shared int a;\n+    shared int* pa;\n+    synchronized void oops()\n+    {\n+        // this should compile since the function is synchronized\n+        // and `a` is accessed through `this`.\n+        a = 2;\n+\n+        // this shouldn't compile because synchronized guards\n+        // only accesses to the first level of dereferencing\n+        static assert (!__traits(compiles, *pa = 2));\n+\n+        // this shouldn't compile `k` is a field of class `Oops`\n+        static assert (!__traits(compiles, k = 2));\n+    }\n+}"}, {"sha": "10a0c2f1601535f944268bc723f5f34063cc6465", "filename": "gcc/testsuite/gdc.test/compilable/test23076.d", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23076.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23076.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23076.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,38 @@\n+/* REQUIRED_ARGS: -O -inline\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23076\n+\n+struct S\n+{\n+    int depthLow = 0;\n+    int depthHigh = 30000;\n+\n+    void fun(int* pixels)\n+    {\n+        float b = depthLow;\n+        int depthA = cast(int)(b);\n+        int depthB = cast(short)(cast(float)depthHigh * cast(float)depthLow);\n+        pixels[depthA] = depthB;\n+    }\n+}\n+\n+/**********************/\n+\n+float mul3(float a, float b, float t)\n+{\n+    return t * b * a;\n+}\n+\n+class A\n+{\n+    ushort depthLow = 0;\n+    ushort depthHigh = 30000;\n+\n+    void fun(short* pixels)\n+    {\n+        short depthA = (cast(short)(mul3(depthHigh, depthLow, 0)));\n+        short depthB = (cast(short)(mul3(depthLow, depthHigh, 0)));\n+        pixels[depthA] = depthB;\n+    }\n+}"}, {"sha": "28bb69169784bad39201eef9ffbbce631552311b", "filename": "gcc/testsuite/gdc.test/compilable/test23142.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23142.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23142.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23142.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,19 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23142\n+\n+struct Foo\n+{\n+    int x;\n+\n+scope:\n+    void func()\n+    {\n+    }\n+\n+    unittest\n+    {\n+    }\n+\n+    static void func2()\n+    {\n+    }\n+}"}, {"sha": "9047fd7f8a95d78929a631132a0d45645e6b8bb4", "filename": "gcc/testsuite/gdc.test/compilable/test23174.d", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23174.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23174.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23174.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,58 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23174\n+\n+alias AliasSeq(T...) = T;\n+\n+template staticMap(alias fun, args...)\n+{\n+    alias staticMap = AliasSeq!();\n+    static foreach(arg; args)\n+        staticMap = AliasSeq!(staticMap, fun!arg);\n+}\n+\n+template Filter(alias pred, args...)\n+{\n+    alias Filter = AliasSeq!();\n+    static foreach (arg; args)\n+        static if (pred!arg)\n+            Filter = AliasSeq!(Filter, arg);\n+}\n+\n+struct Fields(T)\n+{\n+    private static alias toField(alias e) = Field!(__traits(identifier, e));\n+    alias fields = staticMap!(toField, T.tupleof);\n+\n+    static alias map(alias F) = staticMap!(F, fields);\n+    static alias filter(alias pred) = Filter!(pred, fields);\n+}\n+\n+struct Field(string n)\n+{\n+    enum name = n;\n+}\n+\n+struct Foo\n+{\n+    int a;\n+}\n+\n+void test23174()\n+{\n+    Foo value;\n+\n+    enum toName(alias e) = e.name;\n+    enum pred(alias e) = true;\n+\n+    alias a = Fields!(Foo).filter!(pred); // works\n+    static assert(is(a == AliasSeq!(Field!\"a\")));\n+\n+    alias b = Fields!(Foo).map!(toName); // works\n+    static assert(b == AliasSeq!(\"a\"));\n+\n+    alias c = Fields!(Foo).init.filter!(pred); // works\n+    static assert(is(c == AliasSeq!(Field!\"a\")));\n+\n+    // OK <- Error: alias `d` cannot alias an expression `Fields().tuple(\"a\")`\n+    alias d = Fields!(Foo).init.map!(toName);\n+    static assert(d == AliasSeq!(\"a\"));\n+}"}, {"sha": "4507266c75174b9e8d9a03ef6e4f0415ab1132e6", "filename": "gcc/testsuite/gdc.test/compilable/testdefines.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestdefines.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestdefines.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestdefines.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,14 @@\n+// EXTRA_FILES: imports/defines.c\n+import imports.defines;\n+\n+static assert(CC == 'c');\n+static assert(I32 == 3);\n+static assert(U32 == 4);\n+static assert(I64 == 5);\n+static assert(U64 == 6);\n+\n+static assert(F32 == 7.0f);\n+static assert(F64 == 8.0);\n+static assert(F80 == 9.0L);\n+\n+static assert(SSS == \"hello\");"}, {"sha": "54d404c993f89992ef241fdc9213fe1b4e8e86fe", "filename": "gcc/testsuite/gdc.test/compilable/testdip1008.d", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestdip1008.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestdip1008.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestdip1008.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -13,9 +13,28 @@ int bar()\n     }\n }\n \n+void throwQualifiers() @safe @nogc pure\n+{\n+    throw new Exception(\"baz\");\n+}\n+\n+bool testThrowQualifiers()\n+{\n+    try\n+    {\n+        throwQualifiers();\n+    } catch (Exception e)\n+    {\n+        return true;\n+    }\n+\n+    return false;\n+}\n \n void foo()\n {\n     enum r = bar();\n     static assert(r == 7);\n+\n+    static assert(testThrowQualifiers());\n }"}, {"sha": "b088da88e3addc3b7f2fe03145eca5639ae8fbdf", "filename": "gcc/testsuite/gdc.test/fail_compilation/mixin_template.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixin_template.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixin_template.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixin_template.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,10 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/mixin_template.d(10): Error: mixin `mixin_template.f!1` - `f` is a function, not a template\n+---\n+*/\n+string f() {\n+    return \"int i;\";\n+}\n+mixin f!1;"}, {"sha": "d47d44917baf16dc22d1aa3e35f16a034e5d00ad", "filename": "gcc/testsuite/gdc.test/fail_compilation/noreturn.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -118,3 +118,21 @@ enum forceInClassRef = inClassRef();\n */\n \n enum throwEnum = throw new Exception(\"\");\n+\n+\n+/*\n+https://issues.dlang.org/show_bug.cgi?id=23063\n+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn.d(135): Error: `\"Accessed expression of type `noreturn`\"`\n+fail_compilation/noreturn.d(138):        called from here: `func()`\n+---\n+*/\n+noreturn func()\n+{\n+    noreturn a;\n+    return a;\n+}\n+\n+enum f = func();"}, {"sha": "d986dd65065f6cd9ec2bb8c94a5021155bff450e", "filename": "gcc/testsuite/gdc.test/fail_compilation/template_decl.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftemplate_decl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftemplate_decl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftemplate_decl.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,9 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/template_decl.d(8): Error: `{` expected after template parameter list, not `(`\n+fail_compilation/template_decl.d(8): Error: declaration expected, not `(`\n+---\n+*/\n+template b(alias d)() {\n+}"}, {"sha": "c9c7c7fcd507603d7754d8f35bd20907a1d61658", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21477.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21477.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21477.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21477.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,16 @@\n+/* REQUIRED_ARGS: -betterC\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21477.d(103): Error: expression `[1]` uses the GC and cannot be used with switch `-betterC`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21477\n+\n+#line 100\n+\n+int test()\n+{\n+    int[] foo = [1];\n+    return 0;\n+}"}, {"sha": "cdafc613b59d763a3030cc2304a732f0b6c0a23d", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23159.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23159.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23159.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23159.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23159\n+\n+// REQUIRED_ARGS: -betterC\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23159.d(14): Error: `scope(failure)` cannot be used with -betterC\n+fail_compilation/test23159.d(18): Error: `scope(success)` cannot be used with -betterC\n+---\n+*/\n+\n+void main()\n+{\n+    scope(failure)\n+    {\n+        int a;\n+    }\n+    scope(success)\n+    {\n+        int a;\n+    }\n+}"}, {"sha": "21f3f57edd521fa223184e215048058c49dbf5ca", "filename": "gcc/testsuite/gdc.test/fail_compilation/traits.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -116,3 +116,21 @@ pragma(msg, __traits(hasCopyConstructor));\n pragma(msg, __traits(hasCopyConstructor, S()));\n pragma(msg, __traits(hasPostblit));\n pragma(msg, __traits(hasPostblit, S()));\n+\n+/********************************************\n+https://issues.dlang.org/show_bug.cgi?id=23178\n+\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits.d(701): Error: alias `traits.a` cannot alias an expression `true`\n+fail_compilation/traits.d(702): Error: alias `traits.b` cannot alias an expression `false`\n+fail_compilation/traits.d(703): Error: alias `traits.c` cannot alias an expression `\"Object\"`\n+fail_compilation/traits.d(704):        while evaluating `pragma(msg, a)`\n+---\n+*/\n+#line 700\n+\n+alias a = __traits(compiles, 1);\n+alias b = __traits(isIntegral, 1.1);\n+alias c = __traits(identifier, Object);\n+pragma(msg, a, b, c);"}, {"sha": "8b2839da46c80c2d402036fccca2d0c337f28463", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1,4 +1,4 @@\n-f89da31331ef5df50d3bc7a26efd1b7acdefde8c\n+454471d8077d12ec6bf0ae8fcd9571aad1bce7be\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "d963aa9bd3dad2972675be097cbda8293f03283e", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -200,9 +200,9 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/stdc/tgmath.d core/stdc/time.d core/stdc/wchar_.d \\\n \tcore/stdc/wctype.d core/sync/barrier.d core/sync/condition.d \\\n \tcore/sync/config.d core/sync/event.d core/sync/exception.d \\\n-\tcore/sync/mutex.d core/sync/rwmutex.d core/sync/semaphore.d \\\n-\tcore/thread/context.d core/thread/fiber.d core/thread/osthread.d \\\n-\tcore/thread/package.d core/thread/threadbase.d \\\n+\tcore/sync/mutex.d core/sync/package.d core/sync/rwmutex.d \\\n+\tcore/sync/semaphore.d core/thread/context.d core/thread/fiber.d \\\n+\tcore/thread/osthread.d core/thread/package.d core/thread/threadbase.d \\\n \tcore/thread/threadgroup.d core/thread/types.d core/time.d \\\n \tcore/vararg.d core/volatile.d gcc/attribute.d gcc/attributes.d \\\n \tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\"}, {"sha": "45e086a5f0d1818822435e8b6ee90a4eae1bb85a", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -226,17 +226,18 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/stdc/tgmath.lo core/stdc/time.lo core/stdc/wchar_.lo \\\n \tcore/stdc/wctype.lo core/sync/barrier.lo \\\n \tcore/sync/condition.lo core/sync/config.lo core/sync/event.lo \\\n-\tcore/sync/exception.lo core/sync/mutex.lo core/sync/rwmutex.lo \\\n-\tcore/sync/semaphore.lo core/thread/context.lo \\\n-\tcore/thread/fiber.lo core/thread/osthread.lo \\\n-\tcore/thread/package.lo core/thread/threadbase.lo \\\n-\tcore/thread/threadgroup.lo core/thread/types.lo core/time.lo \\\n-\tcore/vararg.lo core/volatile.lo gcc/attribute.lo \\\n-\tgcc/attributes.lo gcc/backtrace.lo gcc/builtins.lo gcc/deh.lo \\\n-\tgcc/emutls.lo gcc/gthread.lo gcc/sections/common.lo \\\n-\tgcc/sections/elf.lo gcc/sections/macho.lo \\\n-\tgcc/sections/package.lo gcc/sections/pecoff.lo \\\n-\tgcc/unwind/arm.lo gcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n+\tcore/sync/exception.lo core/sync/mutex.lo core/sync/package.lo \\\n+\tcore/sync/rwmutex.lo core/sync/semaphore.lo \\\n+\tcore/thread/context.lo core/thread/fiber.lo \\\n+\tcore/thread/osthread.lo core/thread/package.lo \\\n+\tcore/thread/threadbase.lo core/thread/threadgroup.lo \\\n+\tcore/thread/types.lo core/time.lo core/vararg.lo \\\n+\tcore/volatile.lo gcc/attribute.lo gcc/attributes.lo \\\n+\tgcc/backtrace.lo gcc/builtins.lo gcc/deh.lo gcc/emutls.lo \\\n+\tgcc/gthread.lo gcc/sections/common.lo gcc/sections/elf.lo \\\n+\tgcc/sections/macho.lo gcc/sections/package.lo \\\n+\tgcc/sections/pecoff.lo gcc/unwind/arm.lo \\\n+\tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n \trt/arrayassign.lo rt/arraycat.lo rt/cast_.lo rt/config.lo \\\n@@ -866,9 +867,9 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/stdc/tgmath.d core/stdc/time.d core/stdc/wchar_.d \\\n \tcore/stdc/wctype.d core/sync/barrier.d core/sync/condition.d \\\n \tcore/sync/config.d core/sync/event.d core/sync/exception.d \\\n-\tcore/sync/mutex.d core/sync/rwmutex.d core/sync/semaphore.d \\\n-\tcore/thread/context.d core/thread/fiber.d core/thread/osthread.d \\\n-\tcore/thread/package.d core/thread/threadbase.d \\\n+\tcore/sync/mutex.d core/sync/package.d core/sync/rwmutex.d \\\n+\tcore/sync/semaphore.d core/thread/context.d core/thread/fiber.d \\\n+\tcore/thread/osthread.d core/thread/package.d core/thread/threadbase.d \\\n \tcore/thread/threadgroup.d core/thread/types.d core/time.d \\\n \tcore/vararg.d core/volatile.d gcc/attribute.d gcc/attributes.d \\\n \tgcc/backtrace.d gcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n@@ -1305,6 +1306,7 @@ core/sync/config.lo: core/sync/$(am__dirstamp)\n core/sync/event.lo: core/sync/$(am__dirstamp)\n core/sync/exception.lo: core/sync/$(am__dirstamp)\n core/sync/mutex.lo: core/sync/$(am__dirstamp)\n+core/sync/package.lo: core/sync/$(am__dirstamp)\n core/sync/rwmutex.lo: core/sync/$(am__dirstamp)\n core/sync/semaphore.lo: core/sync/$(am__dirstamp)\n core/thread/$(am__dirstamp):"}, {"sha": "8a1dc8add894023873ace68264d1ed5d2e7129ec", "filename": "libphobos/libdruntime/core/attribute.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fattribute.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fattribute.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fattribute.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -76,14 +76,14 @@ else\n  *      The attribute can only be attached to methods or constructors which\n  *      have Objective-C linkage. That is, a method or a constructor in a\n  *      class or interface declared as $(D_CODE extern(Objective-C)).\n- *  ),\n+ *  )\n  *\n- *  $(LI It cannot be attached to a method or constructor that is a template),\n+ *  $(LI It cannot be attached to a method or constructor that is a template)\n  *\n  *  $(LI\n  *      The number of colons in the string need to match the number of\n  *      arguments the method accept.\n- *  ),\n+ *  )\n  *\n  *  $(LI It can only be used once in a method declaration)\n  * )\n@@ -181,21 +181,21 @@ version (UdaOptional)\n  * $(UL\n  *  $(LI\n  *      There can only be one such attribute per symbol.\n- *  ),\n+ *  )\n  *  $(LI\n  *      The attribute can only be attached to an `extern(C++)` symbol\n  *      (`struct`, `class`, `enum`, function, and their templated counterparts).\n- *  ),\n+ *  )\n  *  $(LI\n  *      The attribute cannot be applied to C++ namespaces.\n  *      This is to prevent confusion with the C++ semantic, which allows it to\n  *      be applied to namespaces.\n- *  ),\n+ *  )\n  *  $(LI\n  *      The string arguments must only contain valid characters\n  *      for C++ name mangling which currently include alphanumerics\n  *      and the underscore character.\n- *  ),\n+ *  )\n  * )\n  *\n  * This UDA is not transitive, and inner scope do not inherit outer scopes'\n@@ -252,11 +252,11 @@ version (UdaGNUAbiTag) struct gnuAbiTag\n  *  $(LI\n  *      the expression is the top-level expression in a statement or the\n  *      left-hand expression in a comma expression, and\n- *  ),\n+ *  )\n  *  $(LI\n  *      the expression is not an assignment (`=`, `+=`, etc.), increment\n  *      (`++`), or decrement (`--`) expression.\n- *  ),\n+ *  )\n  * )\n  *\n  * If the declaration of a `struct` or `union` type has the `@mustuse`"}, {"sha": "d3fdd65579669d99a4de3a404efc9b4a741a4b31", "filename": "libphobos/libdruntime/core/internal/array/equality.d", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fequality.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fequality.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fequality.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -21,8 +21,7 @@ bool __equals(T1, T2)(scope const T1[] lhs, scope const T2[] rhs)\n @nogc nothrow pure @trusted\n if (__traits(isScalar, T1) && __traits(isScalar, T2))\n {\n-    if (lhs.length != rhs.length)\n-        return false;\n+    const length = lhs.length;\n \n     static if (T1.sizeof == T2.sizeof\n         // Signedness needs to match for types that promote to int.\n@@ -31,20 +30,21 @@ if (__traits(isScalar, T1) && __traits(isScalar, T2))\n         && (T1.sizeof >= 4 || __traits(isUnsigned, T1) == __traits(isUnsigned, T2))\n         && !__traits(isFloating, T1) && !__traits(isFloating, T2))\n     {\n-        if (!__ctfe)\n+        if (__ctfe)\n+            return length == rhs.length && isEqual(lhs.ptr, rhs.ptr, length);\n+        else\n         {\n             // This would improperly allow equality of integers and pointers\n             // but the CTFE branch will stop this function from compiling then.\n             import core.stdc.string : memcmp;\n-            return lhs.length == 0 ||\n-                0 == memcmp(cast(const void*) lhs.ptr, cast(const void*) rhs.ptr, lhs.length * T1.sizeof);\n+            return length == rhs.length &&\n+                (!length || 0 == memcmp(cast(const void*) lhs.ptr, cast(const void*) rhs.ptr, length * T1.sizeof));\n         }\n     }\n-\n-    foreach (const i; 0 .. lhs.length)\n-        if (lhs.ptr[i] != rhs.ptr[i])\n-            return false;\n-    return true;\n+    else\n+    {\n+        return length == rhs.length && isEqual(lhs.ptr, rhs.ptr, length);\n+    }\n }\n \n bool __equals(T1, T2)(scope T1[] lhs, scope T2[] rhs)\n@@ -89,6 +89,19 @@ if (!__traits(isScalar, T1) || !__traits(isScalar, T2))\n     }\n }\n \n+/******************************\n+ * Helper function for __equals().\n+ * Outlined to enable __equals() to be inlined, as dmd cannot inline loops.\n+ */\n+private\n+bool isEqual(T1, T2)(scope const T1* t1, scope const T2* t2, size_t length)\n+{\n+    foreach (const i; 0 .. length)\n+        if (t1[i] != t2[i])\n+            return false;\n+    return true;\n+}\n+\n @safe unittest\n {\n     assert(__equals([], []));"}, {"sha": "371308def7974b3ed49bd3a07d4bf392d6fc9821", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -2648,16 +2648,19 @@ if (!Init.length ||\n }\n \n /**\n- * Allocate an exception of type `T` from the exception pool and call its constructor.\n- * It has the same interface as `rt.lifetime._d_newclass()`.\n- * `T` must be Throwable or derived from it, must declare an explicit ctor\n- * and cannot be a COM or C++ class.\n+ * Allocate an exception of type `T` from the exception pool.\n+ * `T` must be `Throwable` or derived from it and cannot be a COM or C++ class.\n+ *\n+ * Note:\n+ *  This function does not call the constructor of `T` because that would require\n+ *  `forward!args`, which causes errors with -dip1008. This inconvenience will be\n+ *  removed once -dip1008 works as intended.\n+ *\n  * Returns:\n- *      constructed instance of the type\n+ *   allocated instance of type `T`\n  */\n-T _d_newThrowable(T, Args...)(auto ref Args args) @trusted\n-    if (is(T : Throwable) && is(typeof(T.__ctor(forward!args))) &&\n-        __traits(getLinkage, T) == \"D\")\n+T _d_newThrowable(T)() @trusted\n+    if (is(T : Throwable) && __traits(getLinkage, T) == \"D\")\n {\n     debug(PRINTF) printf(\"_d_newThrowable(%s)\\n\", cast(char*) T.stringof);\n \n@@ -2687,33 +2690,22 @@ T _d_newThrowable(T, Args...)(auto ref Args args) @trusted\n \n     (cast(Throwable) p).refcount() = 1;\n \n-    auto t = cast(T) p;\n-    t.__ctor(forward!args);\n-\n-    return t;\n+    return cast(T) p;\n }\n \n @system unittest\n {\n     class E : Exception\n     {\n-        int x;\n-\n-        this(int x, string msg = \"\", Throwable nextInChain = null)\n+        this(string msg = \"\", Throwable nextInChain = null)\n         {\n             super(msg, nextInChain);\n-            this.x = x;\n         }\n     }\n \n-    auto exc = _d_newThrowable!Exception(\"Exception\");\n-    assert(exc.refcount() == 1);\n-    assert(exc.msg == \"Exception\");\n-\n-    static assert(!__traits(compiles, _d_newThrowable!E()));\n+    Throwable exc = _d_newThrowable!Exception();\n+    Throwable e = _d_newThrowable!E();\n \n-    auto e = _d_newThrowable!E(42, \"E\", null);\n+    assert(exc.refcount() == 1);\n     assert(e.refcount() == 1);\n-    assert(e.x == 42);\n-    assert(e.msg == \"E\");\n }"}, {"sha": "0142d0b9455feb4155488373218fefda3152f0e9", "filename": "libphobos/libdruntime/core/stdcpp/xutility.d", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fxutility.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fxutility.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fxutility.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -23,14 +23,27 @@ else\n     enum StdNamespace = \"std\";\n }\n \n+/**\n+ * Possible values of the `__cplusplus` macro provided by C++ compilers\n+ *\n+ * For foolproofness, use ordering comparison, e.g. `__cplusplus >= CppStdRevision.cpp17`.\n+ */\n enum CppStdRevision : uint\n {\n     cpp98 = 199711,\n     cpp11 = 201103,\n     cpp14 = 201402,\n-    cpp17 = 201703\n+    cpp17 = 201703,\n+    cpp20 = 202002,\n }\n \n+/**\n+ * Returns the target C++ version, encoded as C++ compilers do\n+ *\n+ * C++ compilers provide a `__cplusplus` macro which returns an integer\n+ * representing the targetted standard. This manifest provides the same\n+ * interface, retrieved from the compiler via a `__traits`.\n+ */\n enum __cplusplus = __traits(getTargetInfo, \"cppStd\");\n \n // wrangle C++ features"}, {"sha": "c796cd8fa7459344779609ef0f8a59f0dea844a6", "filename": "libphobos/libdruntime/core/sys/dragonflybsd/sys/elf32.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fsys%2Felf32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fsys%2Felf32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fsys%2Felf32.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,16 @@ alias Elf32_Word Elf32_Hashelt;\n alias Elf32_Word Elf32_Size;\n alias Elf32_Sword Elf32_Ssize;\n \n+struct Elf32_Dyn\n+{\n+  Elf32_Sword   d_tag;\n+  union _d_un\n+  {\n+      Elf32_Word d_val;\n+      Elf32_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n alias Elf_Note Elf32_Nhdr;\n \n struct Elf32_Cap"}, {"sha": "89e3ca38a89e93310cf37c0875bdc00b678f0d5e", "filename": "libphobos/libdruntime/core/sys/dragonflybsd/sys/elf64.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fsys%2Felf64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fsys%2Felf64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fsys%2Felf64.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,16 @@ alias Elf64_Word Elf64_Hashelt;\n alias Elf64_Xword Elf64_Size;\n alias Elf64_Sxword Elf64_Ssize;\n \n+struct Elf64_Dyn\n+{\n+  Elf64_Sxword  d_tag;\n+  union _d_un\n+  {\n+      Elf64_Xword d_val;\n+      Elf64_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n extern (D) pure\n {\n     auto ELF64_R_TYPE_DATA(I)(I i) { return (cast(Elf64_Xword) i << 32) >> 40; }"}, {"sha": "69e52093dc3695137d949ed496dd533eba3def71", "filename": "libphobos/libdruntime/core/sys/elf/package.d", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Felf%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Felf%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Felf%2Fpackage.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -617,26 +617,6 @@ enum PF_R =            (1 << 2);\n enum PF_MASKOS =       0x0ff00000;\n enum PF_MASKPROC =     0xf0000000;\n \n-struct Elf32_Dyn\n-{\n-  Elf32_Sword   d_tag;\n-  union _d_un\n-  {\n-      Elf32_Word d_val;\n-      Elf32_Addr d_ptr;\n-  } _d_un d_un;\n-}\n-\n-struct Elf64_Dyn\n-{\n-  Elf64_Sxword  d_tag;\n-  union _d_un\n-  {\n-      Elf64_Xword d_val;\n-      Elf64_Addr d_ptr;\n-  } _d_un d_un;\n-}\n-\n enum DT_NULL =         0;\n enum DT_NEEDED =       1;\n enum DT_PLTRELSZ =     2;"}, {"sha": "4e8ae2843fbbf91937abb33f6d7c3750ca92eafb", "filename": "libphobos/libdruntime/core/sys/freebsd/sys/elf32.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fsys%2Felf32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fsys%2Felf32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fsys%2Felf32.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,16 @@ alias Elf32_Word Elf32_Hashelt;\n alias Elf32_Word Elf32_Size;\n alias Elf32_Sword Elf32_Ssize;\n \n+struct Elf32_Dyn\n+{\n+  Elf32_Sword   d_tag;\n+  union _d_un\n+  {\n+      Elf32_Word d_val;\n+      Elf32_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n alias Elf_Note Elf32_Nhdr;\n \n struct Elf32_Cap"}, {"sha": "c56460c123bf815dbf6cb4da4f33848da8221b44", "filename": "libphobos/libdruntime/core/sys/freebsd/sys/elf64.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fsys%2Felf64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fsys%2Felf64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fsys%2Felf64.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,16 @@ alias Elf64_Word Elf64_Hashelt;\n alias Elf64_Xword Elf64_Size;\n alias Elf64_Sxword Elf64_Ssize;\n \n+struct Elf64_Dyn\n+{\n+  Elf64_Sxword  d_tag;\n+  union _d_un\n+  {\n+      Elf64_Xword d_val;\n+      Elf64_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n extern (D)\n {\n     auto ELF64_R_TYPE_DATA(I)(I i) { return (cast(Elf64_Xword) i << 32) >> 40; }"}, {"sha": "168b936f921f55b59d823ae29708522085c213b4", "filename": "libphobos/libdruntime/core/sys/linux/elf.d", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Felf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Felf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Felf.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -75,6 +75,26 @@ enum NT_ARM_HW_WATCH = 0x403;\n \n enum NT_VERSION =      1;\n \n+struct Elf32_Dyn\n+{\n+  Elf32_Sword   d_tag;\n+  union _d_un\n+  {\n+      Elf32_Word d_val;\n+      Elf32_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n+struct Elf64_Dyn\n+{\n+  Elf64_Sxword  d_tag;\n+  union _d_un\n+  {\n+      Elf64_Xword d_val;\n+      Elf64_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n enum NT_GNU_ABI_TAG =      1;\n enum NT_GNU_HWCAP =        2;\n enum NT_GNU_BUILD_ID =     3;"}, {"sha": "48386f60212ef3de84a07366e4040310de3a109b", "filename": "libphobos/libdruntime/core/sys/netbsd/sys/elf32.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fsys%2Felf32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fsys%2Felf32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fsys%2Felf32.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,16 @@ alias Elf32_Word Elf32_Hashelt;\n alias Elf32_Word Elf32_Size;\n alias Elf32_Sword Elf32_Ssize;\n \n+struct Elf32_Dyn\n+{\n+  Elf32_Sword   d_tag;\n+  union _d_un\n+  {\n+      Elf32_Word d_val;\n+      Elf32_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n alias Elf_Note Elf32_Nhdr;\n \n struct Elf32_Cap"}, {"sha": "3eeaa90cf1087f043044ca335583858df07de1b9", "filename": "libphobos/libdruntime/core/sys/netbsd/sys/elf64.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fsys%2Felf64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fsys%2Felf64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fsys%2Felf64.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,6 +18,16 @@ alias Elf64_Word Elf64_Hashelt;\n alias Elf64_Xword Elf64_Size;\n alias Elf64_Sxword Elf64_Ssize;\n \n+struct Elf64_Dyn\n+{\n+  Elf64_Sxword  d_tag;\n+  union _d_un\n+  {\n+      Elf64_Xword d_val;\n+      Elf64_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n extern (D)\n {\n     auto ELF64_R_TYPE_DATA(I)(I i) { return (cast(Elf64_Xword) i << 32) >> 40; }"}, {"sha": "c56112186aa6bed4c661d1fd41853e46703a1f72", "filename": "libphobos/libdruntime/core/sys/openbsd/sys/elf32.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Felf32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Felf32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Felf32.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -19,6 +19,16 @@ alias Elf32_Word Elf32_Hashelt;\n alias Elf32_Word Elf32_Size;\n alias Elf32_Sword Elf32_Ssize;\n \n+struct Elf32_Dyn\n+{\n+  Elf32_Sword   d_tag;\n+  union _d_un\n+  {\n+      Elf32_Word d_val;\n+      Elf32_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n alias Elf_Note Elf32_Nhdr;\n \n struct Elf32_Cap"}, {"sha": "47f84d44daf5162df45e8c7d4fcceb2da4c6dca4", "filename": "libphobos/libdruntime/core/sys/openbsd/sys/elf64.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Felf64.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Felf64.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Felf64.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -19,6 +19,16 @@ alias Elf64_Word Elf64_Hashelt;\n alias Elf64_Xword Elf64_Size;\n alias Elf64_Sxword Elf64_Ssize;\n \n+struct Elf64_Dyn\n+{\n+  Elf64_Sxword  d_tag;\n+  union _d_un\n+  {\n+      Elf64_Xword d_val;\n+      Elf64_Addr d_ptr;\n+  } _d_un d_un;\n+}\n+\n extern (D) pure\n {\n     auto ELF64_R_TYPE_DATA(I)(I i) { return (cast(Elf64_Xword) i << 32) >> 40; }"}, {"sha": "fe8cfef3958860ab1962e8b06b2bf73ceaefd531", "filename": "libphobos/libdruntime/core/sys/solaris/sys/elftypes.d", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felftypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felftypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felftypes.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -11,18 +11,12 @@ nothrow:\n \n import core.stdc.stdint;\n \n-alias uint32_t Elf32_Addr;\n-alias uint16_t Elf32_Half;\n-alias uint32_t Elf32_Off;\n-alias int32_t  Elf32_Sword;\n-alias uint32_t Elf32_Word;\n+public import core.sys.elf :\n+ Elf32_Addr, Elf32_Half, Elf32_Off,\n+ Elf32_Sword, Elf32_Word,\n+ Elf64_Addr, Elf64_Half, Elf64_Off,\n+ Elf64_Sword, Elf64_Sxword,\n+ Elf64_Word, Elf64_Xword;\n \n-alias uint64_t Elf64_Addr;\n-alias uint16_t Elf64_Half;\n-alias uint64_t Elf64_Off;\n-alias int32_t  Elf64_Sword;\n-alias int64_t  Elf64_Sxword;\n-alias uint32_t Elf64_Word;\n-alias uint64_t Elf64_Xword;\n alias uint64_t Elf64_Lword;\n alias uint64_t Elf32_Lword;"}, {"sha": "9176b1794f9a2afd0d37bceb162be315ef2bc702", "filename": "libphobos/libdruntime/core/sys/solaris/sys/link.d", "status": "modified", "additions": 1, "deletions": 234, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Flink.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Flink.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Flink.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -10,6 +10,7 @@ extern (C):\n nothrow:\n \n public import core.sys.solaris.sys.elftypes;\n+public import core.sys.elf;\n import core.stdc.config;\n \n struct Elf32_Dyn\n@@ -33,45 +34,8 @@ struct Elf64_Dyn\n     } _d_un d_un;\n }\n \n-enum DT_NULL         = 0;\n-enum DT_NEEDED       = 1;\n-enum DT_PLTRELSZ     = 2;\n-enum DT_PLTGOT       = 3;\n-enum DT_HASH         = 4;\n-enum DT_STRTAB       = 5;\n-enum DT_SYMTAB       = 6;\n-enum DT_RELA         = 7;\n-enum DT_RELASZ       = 8;\n-enum DT_RELAENT      = 9;\n-enum DT_STRSZ        = 10;\n-enum DT_SYMENT       = 11;\n-enum DT_INIT         = 12;\n-enum DT_FINI         = 13;\n-enum DT_SONAME       = 14;\n-enum DT_RPATH        = 15;\n-enum DT_SYMBOLIC     = 16;\n-enum DT_REL          = 17;\n-enum DT_RELSZ        = 18;\n-enum DT_RELENT       = 19;\n-enum DT_PLTREL       = 20;\n-enum DT_DEBUG        = 21;\n-enum DT_TEXTREL      = 22;\n-enum DT_JMPREL       = 23;\n-enum DT_BIND_NOW     = 24;\n-enum DT_INIT_ARRAY   = 25;\n-enum DT_FINI_ARRAY   = 26;\n-enum DT_INIT_ARRAYSZ = 27;\n-enum DT_FINI_ARRAYSZ = 28;\n-enum DT_RUNPATH      = 29;\n-enum DT_FLAGS        = 30;\n-\n-enum DT_ENCODING        = 32;\n-enum DT_PREINIT_ARRAY   = 32;\n-enum DT_PREINIT_ARRAYSZ = 33;\n-\n enum DT_MAXPOSTAGS = 34;\n \n-enum DT_LOOS           = 0x6000000d;\n enum DT_SUNW_AUXILIARY = 0x6000000d;\n enum DT_SUNW_RTLDINF   = 0x6000000e;\n enum DT_SUNW_FILTER    = 0x6000000f;\n@@ -92,221 +56,24 @@ enum DT_SUNW_LDMACH      = 0x6000001b;\n enum DT_SUNW_CAPCHAINENT = 0x6000001d;\n enum DT_SUNW_CAPCHAINSZ  = 0x6000001f;\n \n-enum DT_HIOS = 0x6ffff000;\n-\n enum DT_DEPRECATED_SPARC_REGISTER = 0x7000001;\n \n-enum DT_VALRNGLO = 0x6ffffd00;\n-\n-enum DT_GNU_PRELINKED  = 0x6ffffdf5;\n-enum DT_GNU_CONFLICTSZ = 0x6ffffdf6;\n-enum DT_GNU_LIBLISTSZ  = 0x6ffffdf7;\n-enum DT_CHECKSUM       = 0x6ffffdf8;\n-enum DT_PLTPADSZ       = 0x6ffffdf9;\n-enum DT_MOVEENT        = 0x6ffffdfa;\n-enum DT_MOVESZ         = 0x6ffffdfb;\n-enum DT_FEATURE_1      = 0x6ffffdfc;\n-enum DT_POSFLAG_1      = 0x6ffffdfd;\n-enum DT_SYMINSZ        = 0x6ffffdfe;\n-enum DT_SYMINENT       = 0x6ffffdff;\n-enum DT_VALRNGHI       = 0x6ffffdff;\n-\n-enum DT_ADDRRNGLO = 0x6ffffe00;\n-\n-enum DT_GNU_HASH     = 0x6ffffef5;\n-enum DT_TLSDESC_PLT  = 0x6ffffef6;\n-enum DT_TLSDESC_GOT  = 0x6ffffef7;\n-enum DT_GNU_CONFLICT = 0x6ffffef8;\n-enum DT_GNU_LIBLIST  = 0x6ffffef9;\n-\n-enum DT_CONFIG    = 0x6ffffefa;\n-enum DT_DEPAUDIT  = 0x6ffffefb;\n-enum DT_AUDIT     = 0x6ffffefc;\n-enum DT_PLTPAD    = 0x6ffffefd;\n-enum DT_MOVETAB   = 0x6ffffefe;\n-enum DT_SYMINFO   = 0x6ffffeff;\n-enum DT_ADDRRNGHI = 0x6ffffeff;\n-\n-enum DT_VERSYM = 0x6ffffff0;\n-\n-enum DT_RELACOUNT  = 0x6ffffff9;\n-enum DT_RELCOUNT   = 0x6ffffffa;\n-enum DT_FLAGS_1    = 0x6ffffffb;\n-enum DT_VERDEF     = 0x6ffffffc;\n-enum DT_VERDEFNUM  = 0x6ffffffd;\n-enum DT_VERNEED    = 0x6ffffffe;\n-enum DT_VERNEEDNUM = 0x6fffffff;\n-\n-enum DT_LOPROC    = 0x70000000;\n-enum DT_AUXILIARY = 0x7ffffffd;\n enum DT_USED      = 0x7ffffffe;\n-enum DT_FILTER    = 0x7fffffff;\n-enum DT_HIPROC    = 0x7fffffff;\n \n-enum DF_ORIGIN     = 0x00000001;\n-enum DF_SYMBOLIC   = 0x00000002;\n-enum DF_TEXTREL    = 0x00000004;\n-enum DF_BIND_NOW   = 0x00000008;\n-enum DF_STATIC_TLS = 0x00000010;\n-\n-enum DF_P1_LAZYLOAD  = 0x00000001;\n-enum DF_P1_GROUPPERM = 0x00000002;\n enum DF_P1_DEFERRED  = 0x00000004;\n \n-enum DF_1_NOW        = 0x00000001;\n-enum DF_1_GLOBAL     = 0x00000002;\n-enum DF_1_GROUP      = 0x00000004;\n-enum DF_1_NODELETE   = 0x00000008;\n-enum DF_1_LOADFLTR   = 0x00000010;\n-enum DF_1_INITFIRST  = 0x00000020;\n-enum DF_1_NOOPEN     = 0x00000040;\n-enum DF_1_ORIGIN     = 0x00000080;\n-enum DF_1_DIRECT     = 0x00000100;\n-enum DF_1_TRANS      = 0x00000200;\n-enum DF_1_INTERPOSE  = 0x00000400;\n-enum DF_1_NODEFLIB   = 0x00000800;\n-enum DF_1_NODUMP     = 0x00001000;\n-enum DF_1_CONFALT    = 0x00002000;\n-enum DF_1_ENDFILTEE  = 0x00004000;\n-enum DF_1_DISPRELDNE = 0x00008000;\n-enum DF_1_DISPRELPND = 0x00010000;\n-enum DF_1_NODIRECT   = 0x00020000;\n-enum DF_1_IGNMULDEF  = 0x00040000;\n-enum DF_1_NOKSYMS    = 0x00080000;\n-enum DF_1_NOHDR      = 0x00100000;\n-enum DF_1_EDITED     = 0x00200000;\n-enum DF_1_NORELOC    = 0x00400000;\n-enum DF_1_SYMINTPOSE = 0x00800000;\n-enum DF_1_GLOBAUDIT  = 0x01000000;\n-enum DF_1_SINGLETON  = 0x02000000;\n-\n-enum DTF_1_PARINIT = 0x00000001;\n-enum DTF_1_CONFEXP = 0x00000002;\n-\n-struct Elf32_Verdef\n-{\n-    Elf32_Half  vd_version;\n-    Elf32_Half  vd_flags;\n-    Elf32_Half  vd_ndx;\n-    Elf32_Half  vd_cnt;\n-    Elf32_Word  vd_hash;\n-    Elf32_Word  vd_aux;\n-    Elf32_Word  vd_next;\n-}\n-\n-struct Elf32_Verdaux\n-{\n-    Elf32_Word  vda_name;\n-    Elf32_Word  vda_next;\n-}\n-\n-struct Elf32_Verneed\n-{\n-    Elf32_Half  vn_version;\n-    Elf32_Half  vn_cnt;\n-    Elf32_Word  vn_file;\n-    Elf32_Word  vn_aux;\n-    Elf32_Word  vn_next;\n-}\n-\n-struct Elf32_Vernaux\n-{\n-    Elf32_Word  vna_hash;\n-    Elf32_Half  vna_flags;\n-    Elf32_Half  vna_other;\n-    Elf32_Word  vna_name;\n-    Elf32_Word  vna_next;\n-}\n-\n-alias Elf32_Half  Elf32_Versym;\n-\n-struct Elf32_Syminfo\n-{\n-    Elf32_Half  si_boundto;\n-    Elf32_Half  si_flags;\n-}\n-\n-struct Elf64_Verdef\n-{\n-    Elf64_Half  vd_version;\n-    Elf64_Half  vd_flags;\n-    Elf64_Half  vd_ndx;\n-    Elf64_Half  vd_cnt;\n-    Elf64_Word  vd_hash;\n-    Elf64_Word  vd_aux;\n-    Elf64_Word  vd_next;\n-}\n-\n-struct Elf64_Verdaux\n-{\n-    Elf64_Word  vda_name;\n-    Elf64_Word  vda_next;\n-}\n-\n-struct Elf64_Verneed\n-{\n-    Elf64_Half  vn_version;\n-    Elf64_Half  vn_cnt;\n-    Elf64_Word  vn_file;\n-    Elf64_Word  vn_aux;\n-    Elf64_Word  vn_next;\n-}\n-\n-struct Elf64_Vernaux\n-{\n-    Elf64_Word  vna_hash;\n-    Elf64_Half  vna_flags;\n-    Elf64_Half  vna_other;\n-    Elf64_Word  vna_name;\n-    Elf64_Word  vna_next;\n-}\n-\n-alias Elf64_Half  Elf64_Versym;\n-\n-struct Elf64_Syminfo\n-{\n-    Elf64_Half  si_boundto;\n-    Elf64_Half  si_flags;\n-}\n-\n-enum VER_NDX_LOCAL     = 0;\n-enum VER_NDX_GLOBAL    = 1;\n-enum VER_NDX_LORESERVE = 0xff00;\n-enum VER_NDX_ELIMINATE = 0xff01;\n-\n-enum VER_FLG_BASE = 0x1;\n-enum VER_FLG_WEAK = 0x2;\n enum VER_FLG_INFO = 0x4;\n \n-enum VER_DEF_NONE    = 0;\n-enum VER_DEF_CURRENT = 1;\n-enum VER_DEF_NUM     = 2;\n-\n-enum VER_NEED_NONE    = 0;\n-enum VER_NEED_CURRENT = 1;\n-enum VER_NEED_NUM     = 2;\n-\n-enum SYMINFO_FLG_DIRECT      = 0x0001;\n enum SYMINFO_FLG_FILTER      = 0x0002;\n-enum SYMINFO_FLG_PASSTHRU    = SYMINFO_FLG_FILTER;\n-enum SYMINFO_FLG_COPY        = 0x0004;\n-enum SYMINFO_FLG_LAZYLOAD    = 0x0008;\n enum SYMINFO_FLG_DIRECTBIND  = 0x0010;\n enum SYMINFO_FLG_NOEXTDIRECT = 0x0020;\n enum SYMINFO_FLG_AUXILIARY   = 0x0040;\n enum SYMINFO_FLG_INTERPOSE   = 0x0080;\n enum SYMINFO_FLG_CAP         = 0x0100;\n enum SYMINFO_FLG_DEFERRED    = 0x0200;\n \n-enum SYMINFO_BT_SELF       = 0xffff;\n-enum SYMINFO_BT_PARENT     = 0xfffe;\n enum SYMINFO_BT_NONE       = 0xfffd;\n enum SYMINFO_BT_EXTERN     = 0xfffc;\n-enum SYMINFO_BT_LOWRESERVE = 0xff00;\n-\n-enum SYMINFO_NONE    = 0;\n-enum SYMINFO_CURRENT = 1;\n-enum SYMINFO_NUM     = 2;\n \n alias link_map Link_map;\n "}, {"sha": "217a33a0cf041a38b2c3de33e5101c6d26ab45d7", "filename": "libphobos/libdruntime/core/thread/threadbase.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -109,7 +109,7 @@ class ThreadBase\n     }\n \n     this(void delegate() dg, size_t sz = 0) @trusted pure nothrow @nogc\n-    in( cast(void delegate() const) dg)\n+    in( cast(const void delegate()) dg)\n     {\n         this(sz);\n         m_call = dg;"}, {"sha": "65f92e3d015a5b7f2961589b1342910889665ab9", "filename": "libphobos/libdruntime/rt/ehalloc.d", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Frt%2Fehalloc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Flibdruntime%2Frt%2Fehalloc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fehalloc.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -18,51 +18,6 @@ debug(PRINTF)\n     import core.stdc.stdio;\n }\n \n-/**********************************************\n- * Allocate an exception of type `ci` from the exception pool.\n- * It has the same interface as `rt.lifetime._d_newclass()`.\n- * The class type must be Throwable or derived from it,\n- * and cannot be a COM or C++ class. The compiler must enforce\n- * this.\n- * Returns:\n- *      default initialized instance of the type\n- */\n-\n-extern (C) Throwable _d_newThrowable(const TypeInfo_Class ci)\n-{\n-    debug(PRINTF) printf(\"_d_newThrowable(ci = %p, %s)\\n\", ci, cast(char *)ci.name);\n-\n-    assert(!(ci.m_flags & TypeInfo_Class.ClassFlags.isCOMclass));\n-    assert(!(ci.m_flags & TypeInfo_Class.ClassFlags.isCPPclass));\n-\n-    import core.stdc.stdlib : malloc;\n-    auto init = ci.initializer;\n-    void* p = malloc(init.length);\n-    if (!p)\n-    {\n-        import core.exception : onOutOfMemoryError;\n-        onOutOfMemoryError();\n-    }\n-\n-    debug(PRINTF) printf(\" p = %p\\n\", p);\n-\n-    // initialize it\n-    p[0 .. init.length] = init[];\n-\n-    if (!(ci.m_flags & TypeInfo_Class.ClassFlags.noPointers))\n-    {\n-        // Inform the GC about the pointers in the object instance\n-        import core.memory : GC;\n-\n-        GC.addRange(p, init.length, ci);\n-    }\n-\n-    debug(PRINTF) printf(\"initialization done\\n\");\n-    Throwable t = cast(Throwable)p;\n-    t.refcount() = 1;\n-    return t;\n-}\n-\n \n /********************************************\n  * Delete exception instance `t` from the exception pool."}, {"sha": "30e9e80092fb15b3a10d0ada746a1f50e36139ae", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1,4 +1,4 @@\n-d46814c86392007ebb4fb73cb684ef9e8caa605a\n+1206fc94f967b0183667a109049cbf596deaa696\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "f8f8a9088b6b5ec4f22e9715cdadf6175a4c5a9c", "filename": "libphobos/src/std/mmfile.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Fsrc%2Fstd%2Fmmfile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Fsrc%2Fstd%2Fmmfile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmmfile.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -71,21 +71,21 @@ class MmFile\n      *  - On POSIX, $(REF ErrnoException, std, exception).\n      *  - On Windows, $(REF WindowsException, std, windows, syserror).\n      */\n-    this(string filename)\n+    this(string filename) scope\n     {\n         this(filename, Mode.read, 0, null);\n     }\n \n     version (linux) this(File file, Mode mode = Mode.read, ulong size = 0,\n-            void* address = null, size_t window = 0)\n+            void* address = null, size_t window = 0) scope\n     {\n         // Save a copy of the File to make sure the fd stays open.\n         this.file = file;\n         this(file.fileno, mode, size, address, window);\n     }\n \n     version (linux) private this(int fildes, Mode mode, ulong size,\n-            void* address, size_t window)\n+            void* address, size_t window) scope\n     {\n         int oflag;\n         int fmode;\n@@ -169,7 +169,7 @@ class MmFile\n      *  - On Windows, $(REF WindowsException, std, windows, syserror).\n      */\n     this(string filename, Mode mode, ulong size, void* address,\n-            size_t window = 0)\n+            size_t window = 0) scope\n     {\n         this.filename = filename;\n         this.mMode = mode;\n@@ -364,7 +364,7 @@ class MmFile\n     /**\n      * Flushes pending output and closes the memory mapped file.\n      */\n-    ~this()\n+    ~this() scope\n     {\n         debug (MMFILE) printf(\"MmFile.~this()\\n\");\n         unmap();"}, {"sha": "f3d3152b347896c112441932f886c7b4802388c4", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec486b739b83ffdbe40c5ececb20d16c94d6b0d0/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=ec486b739b83ffdbe40c5ececb20d16c94d6b0d0", "patch": "@@ -1313,6 +1313,7 @@ version (D_BetterC) {} else\n // Types with invariants\n // Disabled in BetterC due to use of exceptions\n version (D_BetterC) {} else\n+version (D_Invariants)\n @system unittest\n {\n     import std.exception : assertThrown;\n@@ -1330,22 +1331,13 @@ version (D_BetterC) {} else\n         invariant { assert(i >= 0); }\n     }\n \n-    // Only run test if contract checking is enabled\n-    try\n-    {\n-        S probe = S(-1);\n-        assert(&probe);\n-    }\n-    catch (AssertError _)\n-    {\n-        SumType!S x;\n-        x.match!((ref v) { v.i = -1; });\n-        assertThrown!AssertError(assert(&x));\n+    SumType!S x;\n+    x.match!((ref v) { v.i = -1; });\n+    assertThrown!AssertError(assert(&x));\n \n-        SumType!C y = new C();\n-        y.match!((ref v) { v.i = -1; });\n-        assertThrown!AssertError(assert(&y));\n-    }\n+    SumType!C y = new C();\n+    y.match!((ref v) { v.i = -1; });\n+    assertThrown!AssertError(assert(&y));\n }\n \n // Calls value postblit on self-assignment"}]}