{"sha": "df06757229f5824ec4e9fc365843cf6f857d4da8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYwNjc1NzIyOWY1ODI0ZWM0ZTlmYzM2NTg0M2NmNmY4NTdkNGRhOA==", "commit": {"author": {"name": "Yury Gribov", "email": "tetra2005@gmail.com", "date": "2017-06-13T11:16:15Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2017-06-13T11:16:15Z"}, "message": "tree-vrp.c (is_masked_range_test): New function.\n\n2017-06-13  Yury Gribov  <tetra2005@gmail.com>\n\ngcc/\n\t* tree-vrp.c (is_masked_range_test): New function.\n\t(register_edge_assert_for): Determine ranges for\n\tsome bit tests.\n\nFrom-SVN: r249150", "tree": {"sha": "c39fe1c7bdd8074b9af78225f7ff502118f039f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c39fe1c7bdd8074b9af78225f7ff502118f039f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df06757229f5824ec4e9fc365843cf6f857d4da8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df06757229f5824ec4e9fc365843cf6f857d4da8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df06757229f5824ec4e9fc365843cf6f857d4da8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df06757229f5824ec4e9fc365843cf6f857d4da8/comments", "author": {"login": "yugr", "id": 1101391, "node_id": "MDQ6VXNlcjExMDEzOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1101391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yugr", "html_url": "https://github.com/yugr", "followers_url": "https://api.github.com/users/yugr/followers", "following_url": "https://api.github.com/users/yugr/following{/other_user}", "gists_url": "https://api.github.com/users/yugr/gists{/gist_id}", "starred_url": "https://api.github.com/users/yugr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yugr/subscriptions", "organizations_url": "https://api.github.com/users/yugr/orgs", "repos_url": "https://api.github.com/users/yugr/repos", "events_url": "https://api.github.com/users/yugr/events{/privacy}", "received_events_url": "https://api.github.com/users/yugr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16842d34e7fceebcecc24910e9219a1581fffb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16842d34e7fceebcecc24910e9219a1581fffb32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16842d34e7fceebcecc24910e9219a1581fffb32"}], "stats": {"total": 100, "additions": 100, "deletions": 0}, "files": [{"sha": "4567036291cafbbbd35b01a400e44330bb64b17c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df06757229f5824ec4e9fc365843cf6f857d4da8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df06757229f5824ec4e9fc365843cf6f857d4da8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df06757229f5824ec4e9fc365843cf6f857d4da8", "patch": "@@ -1,3 +1,9 @@\n+2017-06-13  Yury Gribov  <tetra2005@gmail.com>\n+\n+\t* tree-vrp.c (is_masked_range_test): New function.\n+\t(register_edge_assert_for): Determine ranges for\n+\tsome bit tests.\n+\n 2017-06-13  Yury Gribov  <tetra2005@gmail.com>\n \n \tPR tree-optimization/67328"}, {"sha": "a7424a3f8e2b7e6ae6c97776809da268fd1858ad", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df06757229f5824ec4e9fc365843cf6f857d4da8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df06757229f5824ec4e9fc365843cf6f857d4da8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=df06757229f5824ec4e9fc365843cf6f857d4da8", "patch": "@@ -5628,6 +5628,82 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n     }\n }\n \n+/* Check if comparison\n+     NAME COND_OP INTEGER_CST\n+   has a form of\n+     (X & 11...100..0) COND_OP XX...X00...0\n+   Such comparison can yield assertions like\n+     X >= XX...X00...0\n+     X <= XX...X11...1\n+   in case of COND_OP being NE_EXPR or\n+     X < XX...X00...0\n+     X > XX...X11...1\n+   in case of EQ_EXPR.  */\n+\n+static bool\n+is_masked_range_test (tree name, tree valt, enum tree_code cond_code,\n+\t\t      tree *new_name, tree *low, enum tree_code *low_code,\n+\t\t      tree *high, enum tree_code *high_code)\n+{\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+  if (!is_gimple_assign (def_stmt)\n+      || gimple_assign_rhs_code (def_stmt) != BIT_AND_EXPR)\n+    return false;\n+\n+  tree maskt = gimple_assign_rhs2 (def_stmt);\n+  if (TREE_CODE (maskt) != INTEGER_CST)\n+    return false;\n+\n+  wide_int mask = maskt;\n+  wide_int inv_mask = ~mask;\n+  wide_int val = valt;  // Assume VALT is INTEGER_CST\n+\n+  if ((inv_mask & (inv_mask + 1)) != 0\n+      || (val & mask) != val)\n+    return false;\n+\n+  tree t = gimple_assign_rhs1 (def_stmt);\n+  tree type = TREE_TYPE (t);\n+\n+  bool is_range = cond_code == EQ_EXPR;\n+\n+  wide_int min = wi::min_value (type),\n+    max = wi::max_value (type);\n+\n+  if (is_range)\n+    {\n+      *low_code = val == min ? ERROR_MARK : GE_EXPR;\n+      *high_code = val == max ? ERROR_MARK : LE_EXPR;\n+    }\n+  else\n+    {\n+      /* We can still generate assertion if one of alternatives\n+\t is known to always be false.  */\n+      if (val == min)\n+\t{\n+\t  *low_code = (enum tree_code) 0;\n+\t  *high_code = GT_EXPR;\n+\t}\n+      else if ((val | inv_mask) == max)\n+\t{\n+\t  *low_code = LT_EXPR;\n+\t  *high_code = (enum tree_code) 0;\n+\t}\n+      else\n+\treturn false;\n+    }\n+\n+  *new_name = t;\n+  *low = wide_int_to_tree (type, val);\n+  *high = wide_int_to_tree (type, val | inv_mask);\n+\n+  if (wi::neg_p (val, TYPE_SIGN (type)))\n+    std::swap (*low, *high);\n+\n+  return true;\n+}\n+\n /* Try to register an edge assertion for SSA name NAME on edge E for\n    the condition COND contributing to the conditional jump pointed to by\n    SI.  */\n@@ -5700,6 +5776,24 @@ register_edge_assert_for (tree name, edge e,\n \t  register_edge_assert_for_1 (op1, EQ_EXPR, e, asserts);\n \t}\n     }\n+\n+  /* Sometimes we can infer ranges from (NAME & MASK) == VALUE.  */\n+  if ((comp_code == EQ_EXPR || comp_code == NE_EXPR)\n+      && TREE_CODE (val) == INTEGER_CST)\n+    {\n+      enum tree_code low_code, high_code;\n+      tree low, high;\n+      if (is_masked_range_test (name, val, comp_code, &name, &low,\n+\t\t\t\t&low_code, &high, &high_code))\n+\t{\n+\t  if (low_code != ERROR_MARK)\n+\t    register_edge_assert_for_2 (name, e, low_code, name,\n+\t\t\t\t\tlow, /*invert*/false, asserts);\n+\t  if (high_code != ERROR_MARK)\n+\t    register_edge_assert_for_2 (name, e, high_code, name,\n+\t\t\t\t\thigh, /*invert*/false, asserts);\n+\t}\n+    }\n }\n \n /* Finish found ASSERTS for E and register them at GSI.  */"}]}