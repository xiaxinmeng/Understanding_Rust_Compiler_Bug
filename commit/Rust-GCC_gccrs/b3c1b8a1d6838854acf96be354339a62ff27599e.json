{"sha": "b3c1b8a1d6838854acf96be354339a62ff27599e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjMWI4YTFkNjgzODg1NGFjZjk2YmUzNTQzMzlhNjJmZjI3NTk5ZQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2011-02-18T19:52:16Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-02-18T19:52:16Z"}, "message": "re PR fortran/45586 (ICE non-trivial conversion at assignment)\n\n\tPR fortran/45586\n\t* gfortran.h (struct gfc_component): Add norestrict_decl member.\n\t* trans.h (struct lang_type): Add nonrestricted_type member.\n\t* trans-expr.c (gfc_conv_component_ref): Search fields with correct\n\tparent type.\n\t* trans-types.c (mirror_fields, gfc_nonrestricted_type): New.\n\t(gfc_sym_type): Use it.\n\ntestsuite/\n\tPR fortran/45586\n\t* gfortran.dg/lto/pr45586_0.f90: New test.\n\t* gfortran.dg/typebound_proc_20.f90: Ditto.\n\t* gfortran.dg/typebound_proc_21.f90: Ditto.\n\nFrom-SVN: r170284", "tree": {"sha": "ed9bae538119f7a14e04f53cad9c5316df51293e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed9bae538119f7a14e04f53cad9c5316df51293e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3c1b8a1d6838854acf96be354339a62ff27599e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c1b8a1d6838854acf96be354339a62ff27599e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c1b8a1d6838854acf96be354339a62ff27599e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c1b8a1d6838854acf96be354339a62ff27599e/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "430aa86819b6a4e6a806220886a77a08e5afc0f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430aa86819b6a4e6a806220886a77a08e5afc0f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430aa86819b6a4e6a806220886a77a08e5afc0f8"}], "stats": {"total": 327, "additions": 327, "deletions": 0}, "files": [{"sha": "c0b8d5afd143db4077d821c9705dd84301371335", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -1,3 +1,13 @@\n+2011-02-18  Michael Matz  <matz@suse.de>\n+\n+\tPR fortran/45586\n+\t* gfortran.h (struct gfc_component): Add norestrict_decl member.\n+\t* trans.h (struct lang_type): Add nonrestricted_type member.\n+\t* trans-expr.c (gfc_conv_component_ref): Search fields with correct\n+\tparent type.\n+\t* trans-types.c (mirror_fields, gfc_nonrestricted_type): New.\n+\t(gfc_sym_type): Use it.\n+\n 2011-02-18  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47768"}, {"sha": "b64fa2014e51878f2cb78b0568d6f23a54246d5d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -934,6 +934,10 @@ typedef struct gfc_component\n   gfc_array_spec *as;\n \n   tree backend_decl;\n+  /* Used to cache a FIELD_DECL matching this same component\n+     but applied to a different backend containing type that was\n+     generated by gfc_nonrestricted_type.  */\n+  tree norestrict_decl;\n   locus loc;\n   struct gfc_expr *initializer;\n   struct gfc_component *next;"}, {"sha": "3cf8df56e4a1ef0bd65dd333d715e249bc5b8f3b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -504,6 +504,26 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   field = c->backend_decl;\n   gcc_assert (TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n+\n+  /* Components can correspond to fields of different containing\n+     types, as components are created without context, whereas\n+     a concrete use of a component has the type of decl as context.\n+     So, if the type doesn't match, we search the corresponding\n+     FIELD_DECL in the parent type.  To not waste too much time\n+     we cache this result in norestrict_decl.  */\n+\n+  if (DECL_FIELD_CONTEXT (field) != TREE_TYPE (decl))\n+    {\n+      tree f2 = c->norestrict_decl;\n+      if (!f2 || DECL_FIELD_CONTEXT (f2) != TREE_TYPE (decl))\n+\tfor (f2 = TYPE_FIELDS (TREE_TYPE (decl)); f2; f2 = DECL_CHAIN (f2))\n+\t  if (TREE_CODE (f2) == FIELD_DECL\n+\t      && DECL_NAME (f2) == DECL_NAME (field))\n+\t    break;\n+      gcc_assert (f2);\n+      c->norestrict_decl = f2;\n+      field = f2;\n+    }\n   tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t decl, field, NULL_TREE);\n "}, {"sha": "0626a87ac468aac5e1e1b08fa7db1a0b50518582", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -1746,6 +1746,171 @@ gfc_build_pointer_type (gfc_symbol * sym, tree type)\n   else\n     return build_pointer_type (type);\n }\n+\n+static tree gfc_nonrestricted_type (tree t);\n+/* Given two record or union type nodes TO and FROM, ensure\n+   that all fields in FROM have a corresponding field in TO,\n+   their type being nonrestrict variants.  This accepts a TO\n+   node that already has a prefix of the fields in FROM.  */\n+static void\n+mirror_fields (tree to, tree from)\n+{\n+  tree fto, ffrom;\n+  tree *chain;\n+\n+  /* Forward to the end of TOs fields.  */\n+  fto = TYPE_FIELDS (to);\n+  ffrom = TYPE_FIELDS (from);\n+  chain = &TYPE_FIELDS (to);\n+  while (fto)\n+    {\n+      gcc_assert (ffrom && DECL_NAME (fto) == DECL_NAME (ffrom));\n+      chain = &DECL_CHAIN (fto);\n+      fto = DECL_CHAIN (fto);\n+      ffrom = DECL_CHAIN (ffrom);\n+    }\n+\n+  /* Now add all fields remaining in FROM (starting with ffrom).  */\n+  for (; ffrom; ffrom = DECL_CHAIN (ffrom))\n+    {\n+      tree newfield = copy_node (ffrom);\n+      DECL_CONTEXT (newfield) = to;\n+      /* The store to DECL_CHAIN might seem redundant with the\n+\t stores to *chain, but not clearing it here would mean\n+\t leaving a chain into the old fields.  If ever\n+\t our called functions would look at them confusion\n+\t will arise.  */\n+      DECL_CHAIN (newfield) = NULL_TREE;\n+      *chain = newfield;\n+      chain = &DECL_CHAIN (newfield);\n+\n+      if (TREE_CODE (ffrom) == FIELD_DECL)\n+\t{\n+\t  tree elemtype = gfc_nonrestricted_type (TREE_TYPE (ffrom));\n+\t  TREE_TYPE (newfield) = elemtype;\n+\t}\n+    }\n+  *chain = NULL_TREE;\n+}\n+\n+/* Given a type T, returns a different type of the same structure,\n+   except that all types it refers to (recursively) are always\n+   non-restrict qualified types.  */\n+static tree\n+gfc_nonrestricted_type (tree t)\n+{\n+  tree ret = t;\n+\n+  /* If the type isn't layed out yet, don't copy it.  If something\n+     needs it for real it should wait until the type got finished.  */\n+  if (!TYPE_SIZE (t))\n+    return t;\n+\n+  if (!TYPE_LANG_SPECIFIC (t))\n+    TYPE_LANG_SPECIFIC (t)\n+      = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n+  /* If we're dealing with this very node already further up\n+     the call chain (recursion via pointers and struct members)\n+     we haven't yet determined if we really need a new type node.\n+     Assume we don't, return T itself.  */\n+  if (TYPE_LANG_SPECIFIC (t)->nonrestricted_type == error_mark_node)\n+    return t;\n+\n+  /* If we have calculated this all already, just return it.  */\n+  if (TYPE_LANG_SPECIFIC (t)->nonrestricted_type)\n+    return TYPE_LANG_SPECIFIC (t)->nonrestricted_type;\n+\n+  /* Mark this type.  */\n+  TYPE_LANG_SPECIFIC (t)->nonrestricted_type = error_mark_node;\n+\n+  switch (TREE_CODE (t))\n+    {\n+      default:\n+\tbreak;\n+\n+      case POINTER_TYPE:\n+      case REFERENCE_TYPE:\n+\t{\n+\t  tree totype = gfc_nonrestricted_type (TREE_TYPE (t));\n+\t  if (totype == TREE_TYPE (t))\n+\t    ret = t;\n+\t  else if (TREE_CODE (t) == POINTER_TYPE)\n+\t    ret = build_pointer_type (totype);\n+\t  else\n+\t    ret = build_reference_type (totype);\n+\t  ret = build_qualified_type (ret,\n+\t\t\t\t      TYPE_QUALS (t) & ~TYPE_QUAL_RESTRICT);\n+\t}\n+\tbreak;\n+\n+      case ARRAY_TYPE:\n+\t{\n+\t  tree elemtype = gfc_nonrestricted_type (TREE_TYPE (t));\n+\t  if (elemtype == TREE_TYPE (t))\n+\t    ret = t;\n+\t  else\n+\t    {\n+\t      ret = build_variant_type_copy (t);\n+\t      TREE_TYPE (ret) = elemtype;\n+\t      if (TYPE_LANG_SPECIFIC (t)\n+\t\t  && GFC_TYPE_ARRAY_DATAPTR_TYPE (t))\n+\t\t{\n+\t\t  tree dataptr_type = GFC_TYPE_ARRAY_DATAPTR_TYPE (t);\n+\t\t  dataptr_type = gfc_nonrestricted_type (dataptr_type);\n+\t\t  if (dataptr_type != GFC_TYPE_ARRAY_DATAPTR_TYPE (t))\n+\t\t    {\n+\t\t      TYPE_LANG_SPECIFIC (ret)\n+\t\t\t= ggc_alloc_cleared_lang_type (sizeof (struct\n+\t\t\t\t\t\t\t       lang_type));\n+\t\t      *TYPE_LANG_SPECIFIC (ret) = *TYPE_LANG_SPECIFIC (t);\n+\t\t      GFC_TYPE_ARRAY_DATAPTR_TYPE (ret) = dataptr_type;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\tbreak;\n+\n+      case RECORD_TYPE:\n+      case UNION_TYPE:\n+      case QUAL_UNION_TYPE:\n+\t{\n+\t  tree field;\n+\t  /* First determine if we need a new type at all.\n+\t     Careful, the two calls to gfc_nonrestricted_type per field\n+\t     might return different values.  That happens exactly when\n+\t     one of the fields reaches back to this very record type\n+\t     (via pointers).  The first calls will assume that we don't\n+\t     need to copy T (see the error_mark_node marking).  If there\n+\t     are any reasons for copying T apart from having to copy T,\n+\t     we'll indeed copy it, and the second calls to\n+\t     gfc_nonrestricted_type will use that new node if they\n+\t     reach back to T.  */\n+\t  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n+\t    if (TREE_CODE (field) == FIELD_DECL)\n+\t      {\n+\t\ttree elemtype = gfc_nonrestricted_type (TREE_TYPE (field));\n+\t\tif (elemtype != TREE_TYPE (field))\n+\t\t  break;\n+\t      }\n+\t  if (!field)\n+\t    break;\n+\t  ret = build_variant_type_copy (t);\n+\t  TYPE_FIELDS (ret) = NULL_TREE;\n+\n+\t  /* Here we make sure that as soon as we know we have to copy\n+\t     T, that also fields reaching back to us will use the new\n+\t     copy.  It's okay if that copy still contains the old fields,\n+\t     we won't look at them.  */\n+\t  TYPE_LANG_SPECIFIC (t)->nonrestricted_type = ret;\n+\t  mirror_fields (ret, t);\n+\t}\n+        break;\n+    }\n+\n+  TYPE_LANG_SPECIFIC (t)->nonrestricted_type = ret;\n+  return ret;\n+}\n+\n \f\n /* Return the type for a symbol.  Special handling is required for character\n    types to get the correct level of indirection.\n@@ -1796,6 +1961,9 @@ gfc_sym_type (gfc_symbol * sym)\n \n   restricted = !sym->attr.target && !sym->attr.pointer\n                && !sym->attr.proc_pointer && !sym->attr.cray_pointee;\n+  if (!restricted)\n+    type = gfc_nonrestricted_type (type);\n+\n   if (sym->attr.dimension)\n     {\n       if (gfc_is_nodesc_array (sym))"}, {"sha": "9695c5a4db14eec91cbc2f9493a34f40476a07fe", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -700,6 +700,7 @@ struct GTY((variable_size))\tlang_type\t {\n   tree dataptr_type;\n   tree span;\n   tree base_decl[2];\n+  tree nonrestricted_type;\n };\n \n struct GTY((variable_size)) lang_decl {"}, {"sha": "84f3633df744d44227cb47fece68519432716c88", "filename": "gcc/testsuite/gfortran.dg/lto/pr45586_0.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr45586_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr45586_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr45586_0.f90?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -0,0 +1,29 @@\n+! { dg-lto-do link }\n+      MODULE M1\n+      INTEGER, PARAMETER :: dp=8\n+      TYPE realspace_grid_type\n+\n+          REAL(KIND=dp), DIMENSION ( :, :, : ), ALLOCATABLE :: r\n+\n+      END TYPE realspace_grid_type\n+      END MODULE\n+\n+      MODULE M2\n+      USE m1\n+      CONTAINS\n+      SUBROUTINE S1(x)\n+      TYPE(realspace_grid_type), POINTER :: x\n+      REAL(dp), DIMENSION(:, :, :), POINTER    :: y\n+      y=>x%r\n+      y=0\n+\n+      END SUBROUTINE\n+      END MODULE\n+\n+      USE M2\n+      TYPE(realspace_grid_type), POINTER :: x\n+      ALLOCATE(x)\n+      ALLOCATE(x%r(10,10,10))\n+      CALL S1(x)\n+      write(6,*) x%r\n+      END"}, {"sha": "4fee2f3bab2f26f73f552acbad2b3625df027d50", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_20.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_20.f90?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do compile }\n+! TODO: make runtime testcase once bug is fixed\n+!\n+! PR fortran/47455\n+!\n+! Based on an example by Thomas Henlich\n+!\n+\n+module class_t\n+    type :: tx\n+        integer, dimension(:), allocatable :: i\n+    end type tx\n+    type :: t\n+        type(tx), pointer :: x\n+        type(tx) :: y\n+    contains\n+        procedure :: calc\n+        procedure :: find_x\n+        procedure :: find_y\n+    end type t\n+contains\n+    subroutine calc(this)\n+        class(t), target :: this\n+        type(tx), target :: that\n+        that%i = [1,2]\n+        this%x => this%find_x(that, .true.)\n+        if (associated (this%x)) call abort()\n+        this%x => this%find_x(that, .false.)\n+        if(any (this%x%i /= [5, 7])) call abort()\n+        if (.not.associated (this%x,that)) call abort()\n+        allocate(this%x)\n+        if (associated (this%x,that)) call abort()\n+        if (allocated(this%x%i)) call abort()\n+        this%x = this%find_x(that, .false.)\n+        that%i = [3,4]\n+        if(any (this%x%i /= [5, 7])) call abort() ! FAILS\n+\n+        if (allocated (this%y%i)) call abort()\n+        this%y = this%find_y()  ! FAILS\n+        if (.not.allocated (this%y%i)) call abort()\n+        if(any (this%y%i /= [6, 8])) call abort()\n+    end subroutine calc\n+    function find_x(this, that, l_null)\n+       class(t), intent(in) :: this\n+       type(tx), target  :: that\n+       type(tx), pointer :: find_x\n+       logical :: l_null\n+       if (l_null) then\n+         find_x => null()\n+       else\n+         find_x => that\n+         that%i = [5, 7]\n+       end if\n+    end function find_x\n+    function find_y(this) result(res)\n+        class(t), intent(in) :: this\n+        type(tx), allocatable :: res\n+        allocate(res)\n+        res%i = [6, 8]\n+   end function find_y\n+end module class_t\n+\n+use class_t\n+type(t) :: x\n+call x%calc()\n+end\n+\n+! { dg-final { cleanup-modules \"class_t\" } }"}, {"sha": "6c16d46ff2ce8bf855d969b52a28df88632d5e8e", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_21.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c1b8a1d6838854acf96be354339a62ff27599e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_21.f90?ref=b3c1b8a1d6838854acf96be354339a62ff27599e", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+!\n+! PR fortran/47455\n+!\n+module class_t\n+    type :: tx\n+        integer, dimension(:), allocatable :: i\n+    end type tx\n+    type :: t\n+        type(tx), pointer :: x\n+    contains\n+        procedure :: calc\n+        procedure :: find_x\n+    end type t\n+contains\n+    subroutine calc(this)\n+        class(t), target :: this\n+        this%x = this%find_x()\n+    end subroutine calc\n+    function find_x(this)\n+        class(t), intent(in) :: this\n+        type(tx), pointer :: find_x\n+        find_x => null()\n+    end function find_x\n+end module class_t\n+\n+! { dg-final { cleanup-modules \"class_t\" } }"}]}