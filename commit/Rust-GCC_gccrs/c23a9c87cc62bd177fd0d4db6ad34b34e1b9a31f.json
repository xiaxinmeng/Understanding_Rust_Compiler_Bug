{"sha": "c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f", "node_id": "C_kwDOANBUbNoAKGMyM2E5Yzg3Y2M2MmJkMTc3ZmQwZDRkYjZhZDM0YjM0ZTFiOWEzMWY", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-08-03T07:55:35Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-08-03T07:58:09Z"}, "message": "Some additional zero-extension related optimizations in simplify-rtx.\n\nThis patch implements some additional zero-extension and sign-extension\nrelated optimizations in simplify-rtx.cc.  The original motivation comes\nfrom PR rtl-optimization/71775, where in comment #2 Andrew Pinksi sees:\n\nFailed to match this instruction:\n(set (reg:DI 88 [ _1 ])\n    (sign_extend:DI (subreg:SI (ctz:DI (reg/v:DI 86 [ x ])) 0)))\n\nOn many platforms the result of DImode CTZ is constrained to be a\nsmall unsigned integer (between 0 and 64), hence the truncation to\n32-bits (using a SUBREG) and the following sign extension back to\n64-bits are effectively a no-op, so the above should ideally (often)\nbe simplified to \"(set (reg:DI 88) (ctz:DI (reg/v:DI 86 [ x ]))\".\n\nTo implement this, and some closely related transformations, we build\nupon the existing val_signbit_known_clear_p predicate.  In the first\nchunk, nonzero_bits knows that FFS and ABS can't leave the sign-bit\nbit set, so the simplification of of ABS (ABS (x)) and ABS (FFS (x))\ncan itself be simplified.  The second transformation is that we can\ncanonicalized SIGN_EXTEND to ZERO_EXTEND (as in the PR 71775 case above)\nwhen the operand's sign-bit is known to be clear.  The final two chunks\nare for SIGN_EXTEND of a truncating SUBREG, and ZERO_EXTEND of a\ntruncating SUBREG respectively.  The nonzero_bits of a truncating\nSUBREG pessimistically thinks that the upper bits may have an\narbitrary value (by taking the SUBREG), so we need look deeper at the\nSUBREG's operand to confirm that the high bits are known to be zero.\n\nUnfortunately, for PR rtl-optimization/71775, ctz:DI on x86_64 with\ndefault architecture options is undefined at zero, so we can't be sure\nthe upper bits of reg:DI 88 will be sign extended (all zeros or all ones).\nnonzero_bits knows this, so the above transformations don't trigger,\nbut the transformations themselves are perfectly valid for other\noperations such as FFS, POPCOUNT and PARITY, and on other targets/-march\nsettings where CTZ is defined at zero.\n\n2022-08-03  Roger Sayle  <roger@nextmovesoftware.com>\n\t    Segher Boessenkool  <segher@kernel.crashing.org>\n\t    Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/ChangeLog\n\t* simplify-rtx.cc (simplify_unary_operation_1) <ABS>: Add\n\toptimizations for CLRSB, PARITY, POPCOUNT, SS_ABS and LSHIFTRT\n\tthat are all positive to complement the existing FFS and\n\tidempotent ABS simplifications.\n\t<SIGN_EXTEND>: Canonicalize SIGN_EXTEND to ZERO_EXTEND when\n\tval_signbit_known_clear_p is true of the operand.\n\tSimplify sign extensions of SUBREG truncations of operands\n\tthat are already suitably (zero) extended.\n\t<ZERO_EXTEND>: Simplify zero extensions of SUBREG truncations\n\tof operands that are already suitably zero extended.", "tree": {"sha": "1e1d96a95e77c41191685cd94b10822b515fc248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e1d96a95e77c41191685cd94b10822b515fc248"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "969a989d2bc9c60b8815378837d153a524ae76af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969a989d2bc9c60b8815378837d153a524ae76af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969a989d2bc9c60b8815378837d153a524ae76af"}], "stats": {"total": 60, "additions": 57, "deletions": 3}, "files": [{"sha": "7d09bf7103d6bb8133ae579fb9fdd21922b12fb1", "filename": "gcc/simplify-rtx.cc", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f/gcc%2Fsimplify-rtx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f/gcc%2Fsimplify-rtx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.cc?ref=c23a9c87cc62bd177fd0d4db6ad34b34e1b9a31f", "patch": "@@ -1366,11 +1366,35 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n \tbreak;\n \n       /* If operand is something known to be positive, ignore the ABS.  */\n-      if (GET_CODE (op) == FFS || GET_CODE (op) == ABS\n-\t  || val_signbit_known_clear_p (GET_MODE (op),\n-\t\t\t\t\tnonzero_bits (op, GET_MODE (op))))\n+      if (val_signbit_known_clear_p (GET_MODE (op),\n+\t\t\t\t     nonzero_bits (op, GET_MODE (op))))\n \treturn op;\n \n+      /* Using nonzero_bits doesn't (currently) work for modes wider than\n+\t HOST_WIDE_INT, so the following transformations help simplify\n+\t ABS for TImode and wider.  */\n+      switch (GET_CODE (op))\n+\t{\n+\tcase ABS:\n+\tcase CLRSB:\n+\tcase FFS:\n+\tcase PARITY:\n+\tcase POPCOUNT:\n+\tcase SS_ABS:\n+\t  return op;\n+\n+\tcase LSHIFTRT:\n+\t  if (CONST_INT_P (XEXP (op, 1))\n+\t      && INTVAL (XEXP (op, 1)) > 0\n+\t      && is_a <scalar_int_mode> (mode, &int_mode)\n+\t      && INTVAL (XEXP (op, 1)) < GET_MODE_PRECISION (int_mode))\n+\t    return op;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n       /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n       if (is_a <scalar_int_mode> (mode, &int_mode)\n \t  && (num_sign_bit_copies (op, int_mode)\n@@ -1615,6 +1639,24 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n \t    }\n \t}\n \n+      /* We can canonicalize SIGN_EXTEND (op) as ZERO_EXTEND (op) when\n+         we know the sign bit of OP must be clear.  */\n+      if (val_signbit_known_clear_p (GET_MODE (op),\n+\t\t\t\t     nonzero_bits (op, GET_MODE (op))))\n+\treturn simplify_gen_unary (ZERO_EXTEND, mode, op, GET_MODE (op));\n+\n+      /* (sign_extend:DI (subreg:SI (ctz:DI ...))) is (ctz:DI ...).  */\n+      if (GET_CODE (op) == SUBREG\n+\t  && subreg_lowpart_p (op)\n+\t  && GET_MODE (SUBREG_REG (op)) == mode\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && is_a <scalar_int_mode> (GET_MODE (op), &op_mode)\n+\t  && GET_MODE_PRECISION (int_mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && GET_MODE_PRECISION (op_mode) < GET_MODE_PRECISION (int_mode)\n+\t  && (nonzero_bits (SUBREG_REG (op), mode)\n+\t      & ~(GET_MODE_MASK (op_mode) >> 1)) == 0)\n+\treturn SUBREG_REG (op);\n+\n #if defined(POINTERS_EXTEND_UNSIGNED)\n       /* As we do not know which address space the pointer is referring to,\n \t we can do this only if the target does not support different pointer\n@@ -1765,6 +1807,18 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,\n \t\t\t\t     op0_mode);\n \t}\n \n+      /* (zero_extend:DI (subreg:SI (ctz:DI ...))) is (ctz:DI ...).  */\n+      if (GET_CODE (op) == SUBREG\n+\t  && subreg_lowpart_p (op)\n+\t  && GET_MODE (SUBREG_REG (op)) == mode\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && is_a <scalar_int_mode> (GET_MODE (op), &op_mode)\n+\t  && GET_MODE_PRECISION (int_mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && GET_MODE_PRECISION (op_mode) < GET_MODE_PRECISION (int_mode)\n+\t  && (nonzero_bits (SUBREG_REG (op), mode)\n+\t      & ~GET_MODE_MASK (op_mode)) == 0)\n+\treturn SUBREG_REG (op);\n+\n #if defined(POINTERS_EXTEND_UNSIGNED)\n       /* As we do not know which address space the pointer is referring to,\n \t we can do this only if the target does not support different pointer"}]}