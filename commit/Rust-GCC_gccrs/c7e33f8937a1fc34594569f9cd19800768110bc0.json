{"sha": "c7e33f8937a1fc34594569f9cd19800768110bc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlMzNmODkzN2ExZmMzNDU5NDU2OWY5Y2QxOTgwMDc2ODExMGJjMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-11T05:22:55Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-11T05:22:55Z"}, "message": "(SLOW_UNALIGNED_ACCESS): Define, but allow override.\n\n(store_bit_field): Test that instead of STRICT_ALIGNMENT.\nAlso, allow fetching as non-bitfield if memory is aligned enough.\n(extract_bit_field): Install code here like that in store_bit_field.\n\nFrom-SVN: r5131", "tree": {"sha": "a99fc9b7a36209d544c9ac4cdceb6ac2a97eaf66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a99fc9b7a36209d544c9ac4cdceb6ac2a97eaf66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e33f8937a1fc34594569f9cd19800768110bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e33f8937a1fc34594569f9cd19800768110bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e33f8937a1fc34594569f9cd19800768110bc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e33f8937a1fc34594569f9cd19800768110bc0/comments", "author": null, "committer": null, "parents": [{"sha": "2abe5d9099672f3d811f8171fad5593fd546b6b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2abe5d9099672f3d811f8171fad5593fd546b6b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2abe5d9099672f3d811f8171fad5593fd546b6b5"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "1739e703c883125638d76a8ac05e07278c087ffd", "filename": "gcc/expmed.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e33f8937a1fc34594569f9cd19800768110bc0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e33f8937a1fc34594569f9cd19800768110bc0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c7e33f8937a1fc34594569f9cd19800768110bc0", "patch": "@@ -46,6 +46,10 @@ static rtx lshift_value ();\n \n static int sdiv_pow2_cheap, smod_pow2_cheap;\n \n+#ifndef SLOW_UNALIGNED_ACCESS\n+#define SLOW_UNALIGNED_ACCESS STRICT_ALIGNMENT\n+#endif\n+\n /* For compilers that support multiple targets with different word sizes,\n    MAX_BITS_PER_WORD contains the biggest value of BITS_PER_WORD.  An example\n    is the H8/300(H) compiler.  */\n@@ -230,17 +234,22 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   /* Note that the adjustment of BITPOS above has no effect on whether\n      BITPOS is 0 in a REG bigger than a word.  */\n   if (GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n-      && (! STRICT_ALIGNMENT || GET_CODE (op0) != MEM)\n+      && (GET_CODE (op0) != MEM\n+\t  || ! SLOW_UNALIGNED_ACCESS\n+\t  || (offset * BITS_PER_UNIT % bitsize == 0\n+\t      && align % GET_MODE_SIZE (fieldmode) == 0))\n       && bitpos == 0 && bitsize == GET_MODE_BITSIZE (fieldmode))\n     {\n       /* Storing in a full-word or multi-word field in a register\n \t can be done with just SUBREG.  */\n       if (GET_MODE (op0) != fieldmode)\n-\tif (GET_CODE (op0) == REG)\n-\t  op0 = gen_rtx (SUBREG, fieldmode, op0, offset);\n-\telse\n-\t  op0 = change_address (op0, fieldmode,\n-\t\t\t\tplus_constant (XEXP (op0, 0), offset));\n+\t{\n+\t  if (GET_CODE (op0) == REG)\n+\t    op0 = gen_rtx (SUBREG, fieldmode, op0, offset);\n+\t  else\n+\t    op0 = change_address (op0, fieldmode,\n+\t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n+\t}\n       emit_move_insn (op0, value);\n       return value;\n     }\n@@ -804,12 +813,16 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n #endif\n \n   /* Extracting a full-word or multi-word value\n-     from a structure in a register.\n+     from a structure in a register or aligned memory.\n      This can be done with just SUBREG.\n      So too extracting a subword value in\n      the least significant part of the register.  */\n \n-  if (GET_CODE (op0) == REG\n+  if ((GET_CODE (op0) == REG\n+       || (GET_CODE (op0) == MEM\n+\t   && (! SLOW_UNALIGNED_ACCESS\n+\t       || (offset * BITS_PER_UNIT % bitsize == 0\n+\t\t   && align * BITS_PER_UNIT % bitsize == 0))))\n       && ((bitsize >= BITS_PER_WORD && bitsize == GET_MODE_BITSIZE (mode)\n \t   && bitpos % BITS_PER_WORD == 0)\n \t  || (mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0) != BLKmode\n@@ -824,8 +837,13 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t= mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0);\n \n       if (mode1 != GET_MODE (op0))\n-\top0 = gen_rtx (SUBREG, mode1, op0, offset);\n-\n+\t{\n+\t  if (GET_CODE (op0) == REG)\n+\t    op0 = gen_rtx (SUBREG, mode1, op0, offset);\n+\t  else\n+\t    op0 = change_address (op0, mode1,\n+\t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n+\t}\n       if (mode1 != mode)\n \treturn convert_to_mode (tmode, op0, unsignedp);\n       return op0;"}]}