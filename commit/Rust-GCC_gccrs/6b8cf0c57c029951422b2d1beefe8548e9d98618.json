{"sha": "6b8cf0c57c029951422b2d1beefe8548e9d98618", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4Y2YwYzU3YzAyOTk1MTQyMmIyZDFiZWVmZTg1NDhlOWQ5ODYxOA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-15T08:12:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-15T08:12:29Z"}, "message": "basic-block.h: Remove all #defines and prototypes related to integer lists.\n\n        * basic-block.h: Remove all #defines and prototypes related to\n        integer lists.\n        (free_bb_mem, compute_preds_succs): Remove prototype.\n        * rtl.h (free_bb_mem): Remove prototype.\n        * flow.c (alloc_int_list_node); Remove function.\n        (add_inst_list_node, free_int_list, add_pred_succ): Likewise.\n        (compute_preds_succs, free_bb_mem): Likewise.\n        * gcse.c (gcse_main): Do not call free_bb_mem anymore.\n        * toplev.c (rest_of_compilation): Likewise.\n        * haifa-sched.c (build_control_flow): Use flow generated edge\n        list to build the haifa specific edge list.\n        (find_rgns): Use new CFG data structures instead of pred/succ lists.\n        (schedule_insns): Do not build pred/succ lists anymore.  Instead\n        build the edge table.\n\nFrom-SVN: r30531", "tree": {"sha": "fcd1ce3b1eaf01522a488fd1131c6709f6c06b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcd1ce3b1eaf01522a488fd1131c6709f6c06b82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8cf0c57c029951422b2d1beefe8548e9d98618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8cf0c57c029951422b2d1beefe8548e9d98618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8cf0c57c029951422b2d1beefe8548e9d98618", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8cf0c57c029951422b2d1beefe8548e9d98618/comments", "author": null, "committer": null, "parents": [{"sha": "38e90e6c3bf7ff3c4a80f95a8c405fc2a69745a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e90e6c3bf7ff3c4a80f95a8c405fc2a69745a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e90e6c3bf7ff3c4a80f95a8c405fc2a69745a7"}], "stats": {"total": 347, "additions": 82, "deletions": 265}, "files": [{"sha": "ca68fd2a2808bf14af5a9947189a5829f085566c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -1,5 +1,20 @@\n Sun Nov 14 23:11:05 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* basic-block.h: Remove all #defines and prototypes related to\n+\tinteger lists.\n+\t(free_bb_mem, compute_preds_succs): Remove prototype.\n+\t* rtl.h (free_bb_mem): Remove prototype.\n+\t* flow.c (alloc_int_list_node); Remove function.\n+\t(add_inst_list_node, free_int_list, add_pred_succ): Likewise.\n+\t(compute_preds_succs, free_bb_mem): Likewise.\n+\t* gcse.c (gcse_main): Do not call free_bb_mem anymore.\n+\t* toplev.c (rest_of_compilation): Likewise.\n+\t* haifa-sched.c (build_control_flow): Use flow generated edge\n+\tlist to build the haifa specific edge list.\n+\t(find_rgns): Use new CFG data structures instead of pred/succ lists.\n+\t(schedule_insns): Do not build pred/succ lists anymore.  Instead\n+\tbuild the edge table.\n+\n \t* basic-block.h (dump_bb_data): Remove declaration.\n \t* flow.c (dump_bb_data): Remove function.\n \t* sbitmap.c (sbitmap_intersect_of_predsucc): Delete function."}, {"sha": "40cc6022376c81bdc5d42d9f26629204fe30a972", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -184,46 +184,6 @@ extern regset regs_live_at_setjmp;\n #define REG_BLOCK_GLOBAL -2\n \n #define REG_BASIC_BLOCK(N) (VARRAY_REG (reg_n_info, N)->basic_block)\n-\n-/* List of integers.\n-   These are used for storing things like predecessors, etc.\n-\n-   This scheme isn't very space efficient, especially on 64 bit machines.\n-   The interface is designed so that the implementation can be replaced with\n-   something more efficient if desirable.  */\n-\n-typedef struct int_list {\n-  struct int_list *next;\n-  int val;\n-} int_list;\n-\n-typedef int_list *int_list_ptr;\n-\n-/* Integer list elements are allocated in blocks to reduce the frequency\n-   of calls to malloc and to reduce the associated space overhead.  */\n-\n-typedef struct int_list_block {\n-  struct int_list_block *next;\n-  int nodes_left;\n-#define INT_LIST_NODES_IN_BLK 500\n-  struct int_list nodes[INT_LIST_NODES_IN_BLK];\n-} int_list_block;\n-\n-/* Given a pointer to the list, return pointer to first element.  */\n-#define INT_LIST_FIRST(il) (il)\n-\n-/* Given a pointer to a list element, return pointer to next element.  */\n-#define INT_LIST_NEXT(p) ((p)->next)\n-\n-/* Return non-zero if P points to the end of the list.  */\n-#define INT_LIST_END(p) ((p) == NULL)\n-\n-/* Return element pointed to by P.  */\n-#define INT_LIST_VAL(p) ((p)->val)\n-\n-#define INT_LIST_SET_VAL(p, new_val) ((p)->val = (new_val))\n-\n-extern void free_int_list               PROTO ((int_list_block **));\n \f\n /* Stuff for recording basic block info.  */\n \n@@ -247,7 +207,6 @@ extern void compute_bb_for_insn\t\tPROTO ((int));\n extern void set_block_for_insn\t\tPROTO ((rtx, basic_block));\n extern void set_block_num\t\tPROTO ((rtx, int));\n \n-extern void free_bb_mem\t\t\tPROTO ((void));\n extern void free_basic_block_vars\tPROTO ((int));\n \n extern basic_block split_edge\t\tPROTO ((edge));\n@@ -290,8 +249,6 @@ void verify_edge_list\t\t\tPROTO ((FILE *, struct edge_list *));\n int find_edge_index\t\t\tPROTO ((struct edge_list *, \n \t\t\t\t\t\tbasic_block, basic_block));\n \n-extern void compute_preds_succs\t\tPROTO ((int_list_ptr *, int_list_ptr *,\n-\t\t\t\t\t\tint *, int *));\n extern void compute_flow_dominators\tPROTO ((sbitmap *, sbitmap *));\n extern void compute_immediate_dominators\tPROTO ((int *, sbitmap *));\n "}, {"sha": "894129e0aab26fe27c9c22bf6d62fdacee3947de", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -345,13 +345,6 @@ void dump_flow_info\t\t\tPROTO((FILE *));\n void debug_flow_info\t\t\tPROTO((void));\n static void dump_edge_info\t\tPROTO((FILE *, edge, int));\n \n-static int_list_ptr alloc_int_list_node PROTO ((int_list_block **));\n-static int_list_ptr add_int_list_node   PROTO ((int_list_block **,\n-\t\t\t\t\t\tint_list **, int));\n-\n-static void add_pred_succ\t\tPROTO ((int, int, int_list_ptr *,\n-\t\t\t\t\t\tint_list_ptr *, int *, int *));\n-\n static void count_reg_sets_1\t\tPROTO ((rtx));\n static void count_reg_sets\t\tPROTO ((rtx));\n static void count_reg_references\tPROTO ((rtx));\n@@ -5140,135 +5133,6 @@ print_rtl_with_bb (outf, rtx_first)\n     }\n }\n \n-\f\n-/* Integer list support.  */\n-\n-/* Allocate a node from list *HEAD_PTR.  */\n-\n-static int_list_ptr\n-alloc_int_list_node (head_ptr)\n-     int_list_block **head_ptr;\n-{\n-  struct int_list_block *first_blk = *head_ptr;\n-\n-  if (first_blk == NULL || first_blk->nodes_left <= 0)\n-    {\n-      first_blk = (struct int_list_block *) xmalloc (sizeof (struct int_list_block));\n-      first_blk->nodes_left = INT_LIST_NODES_IN_BLK;\n-      first_blk->next = *head_ptr;\n-      *head_ptr = first_blk;\n-    }\n-\n-  first_blk->nodes_left--;\n-  return &first_blk->nodes[first_blk->nodes_left];\n-}\n-\n-/* Pointer to head of predecessor/successor block list.  */\n-static int_list_block *pred_int_list_blocks;\n-\n-/* Add a new node to integer list LIST with value VAL.\n-   LIST is a pointer to a list object to allow for different implementations.\n-   If *LIST is initially NULL, the list is empty.\n-   The caller must not care whether the element is added to the front or\n-   to the end of the list (to allow for different implementations).  */\n-\n-static int_list_ptr\n-add_int_list_node (blk_list, list, val)\n-     int_list_block **blk_list;\n-     int_list **list;\n-     int val;\n-{\n-  int_list_ptr p = alloc_int_list_node (blk_list);\n-\n-  p->val = val;\n-  p->next = *list;\n-  *list = p;\n-  return p;\n-}\n-\n-/* Free the blocks of lists at BLK_LIST.  */\n-\n-void\n-free_int_list (blk_list)\n-     int_list_block **blk_list;\n-{\n-  int_list_block *p, *next;\n-\n-  for (p = *blk_list; p != NULL; p = next)\n-    {\n-      next = p->next;\n-      free (p);\n-    }\n-\n-  /* Mark list as empty for the next function we compile.  */\n-  *blk_list = NULL;\n-}\n-\f\n-/* Predecessor/successor computation.  */\n-\n-/* Mark PRED_BB a precessor of SUCC_BB,\n-   and conversely SUCC_BB a successor of PRED_BB.  */\n-\n-static void\n-add_pred_succ (pred_bb, succ_bb, s_preds, s_succs, num_preds, num_succs)\n-     int pred_bb;\n-     int succ_bb;\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n-     int *num_preds;\n-     int *num_succs;\n-{\n-  if (succ_bb != EXIT_BLOCK)\n-    {\n-      add_int_list_node (&pred_int_list_blocks, &s_preds[succ_bb], pred_bb);\n-      num_preds[succ_bb]++;\n-    }\n-  if (pred_bb != ENTRY_BLOCK)\n-    {\n-      add_int_list_node (&pred_int_list_blocks, &s_succs[pred_bb], succ_bb);\n-      num_succs[pred_bb]++;\n-    }\n-}\n-\n-/* Convert edge lists into pred/succ lists for backward compatibility.  */\n-\n-void\n-compute_preds_succs (s_preds, s_succs, num_preds, num_succs)\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n-     int *num_preds;\n-     int *num_succs;\n-{\n-  int i, n = n_basic_blocks;\n-  edge e;\n-\n-  memset (s_preds, 0, n_basic_blocks * sizeof (int_list_ptr));\n-  memset (s_succs, 0, n_basic_blocks * sizeof (int_list_ptr));\n-  memset (num_preds, 0, n_basic_blocks * sizeof (int));\n-  memset (num_succs, 0, n_basic_blocks * sizeof (int));\n-\n-  for (i = 0; i < n; ++i)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      \n-      for (e = bb->succ; e ; e = e->succ_next)\n-\tadd_pred_succ (i, e->dest->index, s_preds, s_succs,\n-\t\t       num_preds, num_succs);\n-    }\n-\n-  for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n-    add_pred_succ (ENTRY_BLOCK, e->dest->index, s_preds, s_succs,\n-\t\t   num_preds, num_succs);\n-}\n-\n-/* Free basic block data storage.  */\n-\n-void\n-free_bb_mem ()\n-{\n-  free_int_list (&pred_int_list_blocks);\n-}\n-\n /* Compute dominator relationships using new flow graph structures.  */\n void\n compute_flow_dominators (dominators, post_dominators)"}, {"sha": "701c5150955b94b8aca0f7b1372a0d86338a3eee", "filename": "gcc/gcse.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -813,8 +813,6 @@ gcse_main (f, file)\n   obstack_free (&gcse_obstack, NULL_PTR);\n   /* Free reg_set_table.  */\n   free_reg_set_mem ();\n-  /* Free storage used to record predecessor/successor data.  */\n-  free_bb_mem ();\n   /* Free storage allocated by find_basic_blocks.  */\n   free_basic_block_vars (0);\n   return run_jump_opt_after_gcse;"}, {"sha": "53209f15edd98f5d39b3f014c3caee444df6c8ae", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 67, "deletions": 81, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -473,8 +473,7 @@ static int *out_edges;\n \n \n static int is_cfg_nonregular PROTO ((void));\n-static int build_control_flow PROTO ((int_list_ptr *, int_list_ptr *,\n-\t\t\t\t      int *, int *));\n+static int build_control_flow PROTO ((struct edge_list *));\n static void new_edge PROTO ((int, int));\n \n \n@@ -513,8 +512,7 @@ static int *containing_rgn;\n \n void debug_regions PROTO ((void));\n static void find_single_block_region PROTO ((void));\n-static void find_rgns PROTO ((int_list_ptr *, int_list_ptr *,\n-\t\t\t      int *, int *, sbitmap *));\n+static void find_rgns PROTO ((struct edge_list *, sbitmap *));\n static int too_large PROTO ((int, int *, int *));\n \n extern void debug_live PROTO ((int, int));\n@@ -1060,48 +1058,45 @@ is_cfg_nonregular ()\n    prevent cross block scheduling.  */\n \n static int\n-build_control_flow (s_preds, s_succs, num_preds, num_succs)\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n-     int *num_preds;\n-     int *num_succs;\n+build_control_flow (edge_list)\n+     struct edge_list *edge_list;\n {\n-  int i;\n-  int_list_ptr succ;\n-  int unreachable;\n+  int i, unreachable, num_edges;\n \n-  /* Count the number of edges in the cfg.  */\n-  nr_edges = 0;\n+  /* This already accounts for entry/exit edges.  */\n+  num_edges = NUM_EDGES (edge_list);\n+\n+  /* Unreachable loops with more than one basic block are detected\n+     during the DFS traversal in find_rgns.\n+\n+     Unreachable loops with a single block are detected here.  This\n+     test is redundant with the one in find_rgns, but it's much\n+    cheaper to go ahead and catch the trivial case here.  */\n   unreachable = 0;\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-      nr_edges += num_succs[i];\n-\n-      /* Unreachable loops with more than one basic block are detected\n-\t during the DFS traversal in find_rgns.\n+      basic_block b = BASIC_BLOCK (i);\n \n-\t Unreachable loops with a single block are detected here.  This\n-\t test is redundant with the one in find_rgns, but it's much\n-\t cheaper to go ahead and catch the trivial case here.  */\n-      if (num_preds[i] == 0\n-\t  || (num_preds[i] == 1 && INT_LIST_VAL (s_preds[i]) == i))\n+      if (b->pred == NULL\n+\t  || (b->pred->dest == b\n+\t      && b->pred->pred_next == NULL))\n \tunreachable = 1;\n     }\n \n-  /* Account for entry/exit edges.  */\n-  nr_edges += 2;\n-\n+  /* ??? We can kill these soon.  */\n   in_edges = (int *) xcalloc (n_basic_blocks, sizeof (int));\n   out_edges = (int *) xcalloc (n_basic_blocks, sizeof (int));\n-  edge_table = (haifa_edge *) xcalloc (nr_edges, sizeof (haifa_edge));\n+  edge_table = (haifa_edge *) xcalloc (num_edges, sizeof (haifa_edge));\n \n   nr_edges = 0;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    for (succ = s_succs[i]; succ; succ = succ->next)\n-      {\n-\tif (INT_LIST_VAL (succ) != EXIT_BLOCK)\n-\t  new_edge (i, INT_LIST_VAL (succ));\n-      }\n+  for (i = 0; i < num_edges; i++)\n+    {\n+      edge e = INDEX_EDGE (edge_list, i);\n+\n+      if (e->dest != EXIT_BLOCK_PTR\n+\t  && e->src != ENTRY_BLOCK_PTR)\n+\tnew_edge (e->src->index, e->dest->index);\n+    }\n \n   /* Increment by 1, since edge 0 is unused.  */\n   nr_edges++;\n@@ -1391,11 +1386,8 @@ too_large (block, num_bbs, num_insns)\n    of edge tables.  That would simplify it somewhat.  */\n \n static void\n-find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n-     int *num_preds;\n-     int *num_succs;\n+find_rgns (edge_list, dom)\n+     struct edge_list *edge_list;\n      sbitmap *dom;\n {\n   int *max_hdr, *dfs_nr, *stack, *degree;\n@@ -1420,6 +1412,8 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n   /* Note if a block is in the block queue. */\n   sbitmap in_stack;\n \n+  int num_edges = NUM_EDGES (edge_list);\n+\n   /* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops\n      and a mapping from block to its loop header (if the block is contained\n      in a loop, else -1).\n@@ -1554,9 +1548,13 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n      to hold degree counts.  */\n   degree = dfs_nr;\n \n-  /* Compute the in-degree of every block in the graph.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    degree[i] = num_preds[i];\n+  for (i = 0; i < num_edges; i++)\n+    {\n+      edge e = INDEX_EDGE (edge_list, i);\n+\n+      if (e->src != ENTRY_BLOCK_PTR)\n+\tdegree[e->src->index]++;\n+    }\n \n   /* Do not perform region scheduling if there are any unreachable\n      blocks.  */\n@@ -1578,7 +1576,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t{\n \t  if (TEST_BIT (header, i) && TEST_BIT (inner, i))\n \t    {\n-\t      int_list_ptr ps;\n+\t      edge e;\n \t      int j;\n \n \t      /* Now check that the loop is reducible.  We do this separate\n@@ -1619,10 +1617,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \n \t      /* Decrease degree of all I's successors for topological\n \t\t ordering.  */\n-\t      for (ps = s_succs[i]; ps; ps = ps->next)\n-\t\tif (INT_LIST_VAL (ps) != EXIT_BLOCK\n-\t\t    && INT_LIST_VAL (ps) != ENTRY_BLOCK)\n-\t\t  --degree[INT_LIST_VAL(ps)];\n+\t      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\t  --degree[e->dest->index];\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n \t      num_bbs = 1;\n@@ -1639,8 +1636,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t  for (j = 0; j < n_basic_blocks; j++)\n \t\t    /* Leaf nodes have only a single successor which must\n \t\t       be EXIT_BLOCK.  */\n-\t\t    if (num_succs[j] == 1\n-\t\t\t&& INT_LIST_VAL (s_succs[j]) == EXIT_BLOCK)\n+\t\t    if (BASIC_BLOCK (j)->succ\n+\t\t\t&& BASIC_BLOCK (j)->succ->dest == EXIT_BLOCK_PTR\n+\t\t\t&& BASIC_BLOCK (j)->succ->succ_next == NULL)\n \t\t      {\n \t\t\tqueue[++tail] = j;\n \t\t\tSET_BIT (in_queue, j);\n@@ -1654,15 +1652,15 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t}\n \t      else\n \t\t{\n-\t\t  int_list_ptr ps;\n+\t\t  edge e;\n \n-\t\t  for (ps = s_preds[i]; ps; ps = ps->next)\n+\t\t  for (e = BASIC_BLOCK (i)->pred; e; e = e->pred_next)\n \t\t    {\n-\t\t      node = INT_LIST_VAL (ps);\n-\n-\t\t      if (node == ENTRY_BLOCK || node == EXIT_BLOCK)\n+\t\t      if (e->src == ENTRY_BLOCK_PTR)\n \t\t\tcontinue;\n- \n+\n+\t\t      node = e->src->index;\n+\n \t\t      if (max_hdr[node] == loop_head && node != i)\n \t\t\t{\n \t\t\t  /* This is a loop latch.  */\n@@ -1712,16 +1710,16 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\n \t      while (head < tail && !too_large_failure)\n \t\t{\n-\t\t  int_list_ptr ps;\n+\t\t  edge e;\n \t\t  child = queue[++head];\n \n-\t\t  for (ps = s_preds[child]; ps; ps = ps->next)\n+\t\t  for (e = BASIC_BLOCK (child)->pred; e; e = e->pred_next)\n \t\t    {\n-\t\t      node = INT_LIST_VAL (ps);\n+\t\t      node = e->src->index;\n \n \t\t      /* See discussion above about nodes not marked as in\n \t\t\t this loop during the initial DFS traversal.  */\n-\t\t      if (node == ENTRY_BLOCK || node == EXIT_BLOCK\n+\t\t      if (e->src == ENTRY_BLOCK_PTR\n \t\t\t  || max_hdr[node] != loop_head)\n \t\t\t{\n \t\t\t  tail = -1;\n@@ -1757,23 +1755,24 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t     the region.  */\n \t\t  while (tail >= 0)\n \t\t    {\n-\t\t      int_list_ptr ps;\n-\n \t\t      if (head < 0)\n \t\t\thead = tail;\n \t\t      child = queue[head];\n \t\t      if (degree[child] == 0)\n \t\t\t{\n+\t\t\t  edge e;\n+\n \t\t\t  degree[child] = -1;\n \t\t\t  rgn_bb_table[idx++] = child;\n \t\t\t  BLOCK_TO_BB (child) = ++count;\n \t\t\t  CONTAINING_RGN (child) = nr_regions;\n \t\t\t  queue[head] = queue[tail--];\n \n-\t\t\t  for (ps = s_succs[child]; ps; ps = ps->next)\n-\t\t\t    if (INT_LIST_VAL (ps) != ENTRY_BLOCK\n-\t\t\t\t&& INT_LIST_VAL (ps) != EXIT_BLOCK)\n-\t\t\t      --degree[INT_LIST_VAL (ps)];\n+\t\t\t  for (e = BASIC_BLOCK (child)->succ;\n+\t\t\t       e;\n+\t\t\t       e = e->succ_next)\n+\t\t\t    if (e->dest != EXIT_BLOCK_PTR)\n+\t\t\t      --degree[e->dest->index];\n \t\t\t}\n \t\t      else\n \t\t\t--head;\n@@ -6963,16 +6962,9 @@ schedule_insns (dump_file)\n \t}\n       else\n \t{\n-\t  int_list_ptr *s_preds, *s_succs;\n-\t  int *num_preds, *num_succs;\n \t  sbitmap *dom;\n+\t  struct edge_list *edge_list;\n \n-\t  s_preds = (int_list_ptr *) xmalloc (n_basic_blocks\n-\t\t\t\t\t      * sizeof (int_list_ptr));\n-\t  s_succs = (int_list_ptr *) xmalloc (n_basic_blocks\n-\t\t\t\t\t      * sizeof (int_list_ptr));\n-\t  num_preds = (int *) xmalloc (n_basic_blocks * sizeof (int));\n-\t  num_succs = (int *) xmalloc (n_basic_blocks * sizeof (int));\n \t  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n \n \t  /* The scheduler runs after flow; therefore, we can't blindly call\n@@ -6986,8 +6978,7 @@ schedule_insns (dump_file)\n \n \t     We could (should?) recompute register live information.  Doing\n \t     so may even be beneficial.  */\n-\n-\t  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n+\t  edge_list = create_edge_list ();\n \n \t  /* Compute the dominators and post dominators.  We don't\n \t     currently use post dominators, but we should for\n@@ -6997,22 +6988,17 @@ schedule_insns (dump_file)\n \t  /* build_control_flow will return nonzero if it detects unreachable\n \t     blocks or any other irregularity with the cfg which prevents\n \t     cross block scheduling.  */\n-\t  if (build_control_flow (s_preds, s_succs, num_preds, num_succs) != 0)\n+\t  if (build_control_flow (edge_list) != 0)\n \t    find_single_block_region ();\n \t  else\n-\t    find_rgns (s_preds, s_succs, num_preds, num_succs, dom);\n+\t    find_rgns (edge_list, dom);\n \n \t  if (sched_verbose >= 3)\n \t    debug_regions ();\n \n \t  /* For now.  This will move as more and more of haifa is converted\n \t     to using the cfg code in flow.c.  */\n-\t  free_bb_mem ();\n \t  free (dom);\n-\t  free (s_preds);\n-\t  free (s_succs);\n-\t  free (num_preds);\n-\t  free (num_succs);\n \t}\n     }\n "}, {"sha": "dedbe99d65033fb826d7d042e010451dfad668fe", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -1539,7 +1539,6 @@ extern void recompute_reg_usage\t\tPROTO ((rtx, int));\n extern void print_rtl_with_bb\t\tPROTO ((FILE *, rtx));\n extern void dump_flow_info\t\tPROTO ((FILE *));\n #endif\n-extern void free_bb_mem\t\t\tPROTO ((void));\n \n /* In expmed.c */\n extern void init_expmed\t\t\tPROTO ((void));"}, {"sha": "19d30917f35bac0e121e1ed6a1e7626bef13481a", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8cf0c57c029951422b2d1beefe8548e9d98618/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6b8cf0c57c029951422b2d1beefe8548e9d98618", "patch": "@@ -4464,8 +4464,6 @@ rest_of_compilation (decl)\n \n  exit_rest_of_compilation:\n \n-  free_bb_mem ();\n-\n   /* In case the function was not output,\n      don't leave any temporary anonymous types\n      queued up for sdb output.  */"}]}