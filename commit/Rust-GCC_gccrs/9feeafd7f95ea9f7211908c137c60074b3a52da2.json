{"sha": "9feeafd7f95ea9f7211908c137c60074b3a52da2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlZWFmZDdmOTVlYTlmNzIxMTkwOGMxMzdjNjAwNzRiM2E1MmRhMg==", "commit": {"author": {"name": "Alejandro Martinez", "email": "alejandro.martinezvicente@arm.com", "date": "2019-05-02T09:58:00Z"}, "committer": {"name": "Alejandro Martinez", "email": "alejandro@gcc.gnu.org", "date": "2019-05-02T09:58:00Z"}, "message": "[Aarch64][SVE] Dot product support\n\nThis patch does two things. For the general vectoriser, it adds support to\nperform fully masked reductions over expressions that don't support masking.\nThis is achieved by using VEC_COND_EXPR where possible.  At the moment this is\nimplemented for DOT_PROD_EXPR only, but the framework is there to extend it to\nother expressions.\n\nRelated to that, this patch adds support to vectorize dot product using SVE.  It\nalso uses the new functionality to ensure that the resulting loop is masked.\n\nGiven this input code:\n\nuint32_t\ndotprod (uint8_t *restrict x, uint8_t *restrict y, int n)\n{\n  uint32_t sum = 0;\n\n  for (int i = 0; i < n; i++)\n    {\n      sum += x[i] * y[i];\n    }\n\n  return sum;\n}\n\nThe resulting SVE code is:\n\n0000000000000000 <dotprod>:\n   0:\t7100005f \tcmp\tw2, #0x0\n   4:\t5400024d \tb.le\t4c <dotprod+0x4c>\n   8:\td2800003 \tmov\tx3, #0x0                   \t// #0\n   c:\t93407c42 \tsxtw\tx2, w2\n  10:\t2538c001 \tmov\tz1.b, #0\n  14:\t25221fe0 \twhilelo\tp0.b, xzr, x2\n  18:\t2538c003 \tmov\tz3.b, #0\n  1c:\td503201f \tnop\n  20:\ta4034002 \tld1b\t{z2.b}, p0/z, [x0, x3]\n  24:\ta4034020 \tld1b\t{z0.b}, p0/z, [x1, x3]\n  28:\t0430e3e3 \tincb\tx3\n  2c:\t0523c000 \tsel\tz0.b, p0, z0.b, z3.b\n  30:\t25221c60 \twhilelo\tp0.b, x3, x2\n  34:\t44820401 \tudot\tz1.s, z0.b, z2.b\n  38:\t54ffff41 \tb.ne\t20 <dotprod+0x20>  // b.any\n  3c:\t2598e3e0 \tptrue\tp0.s\n  40:\t04812021 \tuaddv\td1, p0, z1.s\n  44:\t1e260020 \tfmov\tw0, s1\n  48:\td65f03c0 \tret\n  4c:\t1e2703e1 \tfmov\ts1, wzr\n  50:\t1e260020 \tfmov\tw0, s1\n  54:\td65f03c0 \tret\n\nNotice how udot is used inside a fully masked loop.\n\nI tested this patch in an aarch64 machine bootstrapping the compiler and\nrunning the checks.\ngcc/Changelog:\n\n2019-05-02  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n\n\t* config/aarch64/aarch64-sve.md (<sur>dot_prod<vsi2qi>): Taken from SVE\n\tACLE branch.\n\t* config/aarch64/iterators.md: Copied Vetype_fourth, VSI2QI and vsi2qi from\n\tSVE ACLE branch.\n\t* tree-vect-loop.c (use_mask_by_cond_expr_p): New function to check if a\n\tVEC_COND_EXPR be inserted to emulate a conditional internal function.\n\t(build_vect_cond_expr): Emit the VEC_COND_EXPR.\n\t(vectorizable_reduction): Use the functions above to vectorize in a\n\tfully masked loop codes that don't have a conditional internal\n\tfunction.\n\ngcc/testsuite/Changelog:\n \n2019-05-02  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n\n\t* gcc.target/aarch64/sve/dot_1.c: New test for dot product.\n\nFrom-SVN: r270790", "tree": {"sha": "a7afe6148066fd48b611f16c45c07b16a7ca6eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7afe6148066fd48b611f16c45c07b16a7ca6eee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9feeafd7f95ea9f7211908c137c60074b3a52da2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9feeafd7f95ea9f7211908c137c60074b3a52da2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9feeafd7f95ea9f7211908c137c60074b3a52da2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9feeafd7f95ea9f7211908c137c60074b3a52da2/comments", "author": null, "committer": null, "parents": [{"sha": "cc2a672a60ff7476b3e4751ba41cb77c7fc85b09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2a672a60ff7476b3e4751ba41cb77c7fc85b09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2a672a60ff7476b3e4751ba41cb77c7fc85b09"}], "stats": {"total": 142, "additions": 139, "deletions": 3}, "files": [{"sha": "720627bc70293f56e99485623b8d8720cb2ff943", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9feeafd7f95ea9f7211908c137c60074b3a52da2", "patch": "@@ -1,3 +1,16 @@\n+2019-05-02  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n+\n+\t* config/aarch64/aarch64-sve.md (<sur>dot_prod<vsi2qi>): Taken from SVE\n+\tACLE branch.\n+\t* config/aarch64/iterators.md: Copied Vetype_fourth, VSI2QI and vsi2qi from\n+\tSVE ACLE branch.\n+\t* tree-vect-loop.c (use_mask_by_cond_expr_p): New function to check if a\n+\tVEC_COND_EXPR be inserted to emulate a conditional internal function.\n+\t(build_vect_cond_expr): Emit the VEC_COND_EXPR.\n+\t(vectorizable_reduction): Use the functions above to vectorize in a\n+\tfully masked loop codes that don't have a conditional internal\n+\tfunction.\n+\n 2019-05-02  Martin Liska  <mliska@suse.cz>\n \n \t* cgraphclones.c: Call valid_attribute_p with 1 for"}, {"sha": "02d33b7276fb690ab97adcec623a65aabd5b8994", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=9feeafd7f95ea9f7211908c137c60074b3a52da2", "patch": "@@ -3132,3 +3132,19 @@\n     DONE;\n   }\n )\n+\n+;; Unpredicated DOT product.\n+(define_insn \"<sur>dot_prod<vsi2qi>\"\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w, ?&w\")\n+\t(plus:SVE_SDI\n+\t  (unspec:SVE_SDI\n+\t    [(match_operand:<VSI2QI> 1 \"register_operand\" \"w, w\")\n+\t     (match_operand:<VSI2QI> 2 \"register_operand\" \"w, w\")]\n+\t    DOTPROD)\n+\t  (match_operand:SVE_SDI 3 \"register_operand\" \"0, w\")))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sur>dot\\\\t%0.<Vetype>, %1.<Vetype_fourth>, %2.<Vetype_fourth>\n+   movprfx\\t%0, %3\\;<sur>dot\\\\t%0.<Vetype>, %1.<Vetype_fourth>, %2.<Vetype_fourth>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)"}, {"sha": "b3b2d6e470a81c9727c0e8452e14794ef594bf04", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=9feeafd7f95ea9f7211908c137c60074b3a52da2", "patch": "@@ -663,6 +663,9 @@\n \t\t\t  (QI \"b\")   (HI \"h\")\n \t\t\t  (SI \"s\")   (DI \"d\")])\n \n+;; Like Vetype, but map to types that are a quarter of the element size.\n+(define_mode_attr Vetype_fourth [(VNx4SI \"b\") (VNx2DI \"h\")])\n+\n ;; Equivalent of \"size\" for a vector element.\n (define_mode_attr Vesize [(VNx16QI \"b\")\n \t\t\t  (VNx8HI  \"h\") (VNx8HF  \"h\")\n@@ -1029,8 +1032,10 @@\n \t\t      (V2SF \"p\") (V4SF  \"v\")\n \t\t      (V4HF \"v\") (V8HF  \"v\")])\n \n-(define_mode_attr vsi2qi [(V2SI \"v8qi\") (V4SI \"v16qi\")])\n-(define_mode_attr VSI2QI [(V2SI \"V8QI\") (V4SI \"V16QI\")])\n+(define_mode_attr vsi2qi [(V2SI \"v8qi\") (V4SI \"v16qi\")\n+\t\t\t  (VNx4SI \"vnx16qi\") (VNx2DI \"vnx8hi\")])\n+(define_mode_attr VSI2QI [(V2SI \"V8QI\") (V4SI \"V16QI\")\n+\t\t\t  (VNx4SI \"VNx16QI\") (VNx2DI \"VNx8HI\")])\n \n \n ;; Register suffix for DOTPROD input types from the return type."}, {"sha": "37edbeada5a2ba445f1895cd8910063987edd5f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9feeafd7f95ea9f7211908c137c60074b3a52da2", "patch": "@@ -1,3 +1,7 @@\n+2019-05-02  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n+\n+\t* gcc.target/aarch64/sve/dot_1.c: New test for dot product.\n+\n 2019-05-02  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.target/i386/funcspec-4.c: Update scanned pattern."}, {"sha": "8ff66714e9bbf109a64ba7273319f786a4c3a5ba", "filename": "gcc/testsuite/gcc.target/aarch64/sve/dot_1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fdot_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fdot_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fdot_1.c?ref=9feeafd7f95ea9f7211908c137c60074b3a52da2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define DEF_DOT(TYPE1, TYPE2)\t\t\t\t\t\t\\\n+TYPE1 __attribute__ ((noinline, noclone))\t\t\t\t\\\n+dot_##TYPE1##_##TYPE2 (TYPE2 *restrict x, TYPE2 *restrict y, int n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  TYPE1 sum = 0;\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; i++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      sum += x[i] * y[i];\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  return sum;\t\t\t\t\t\t\t\t\\\n+}\n+\n+DEF_DOT(uint32_t, uint8_t)\n+DEF_DOT(int32_t, int8_t)\n+DEF_DOT(int64_t, int16_t)\n+\n+/* The uint16_t->uint64_t dot product requires a casting to satisfy the C\n+   language rules.  */\n+uint64_t __attribute__ ((noinline, noclone))\n+dot_uint64_t_uint16_t (uint16_t *restrict x, uint16_t *restrict y, int n)\n+{\n+  uint64_t sum = 0;\n+  for (int i = 0; i < n; i++)\n+    {\n+      sum += (unsigned int)x[i] * y[i];\n+    }\n+  return sum;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tudot\\tz[0-9]+\\.s, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsdot\\tz[0-9]+\\.s, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudot\\tz[0-9]+\\.d, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsdot\\tz[0-9]+\\.d, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\t} 8 } } */"}, {"sha": "493c1ab8c71ed1dce8f4e4c254498350d0c6ad3b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9feeafd7f95ea9f7211908c137c60074b3a52da2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9feeafd7f95ea9f7211908c137c60074b3a52da2", "patch": "@@ -5958,6 +5958,55 @@ is_nonwrapping_integer_induction (stmt_vec_info stmt_vinfo, struct loop *loop)\n \t  <= TYPE_PRECISION (lhs_type));\n }\n \n+/* Check if masking can be supported by inserting a conditional expression.\n+   CODE is the code for the operation.  COND_FN is the conditional internal\n+   function, if it exists.  VECTYPE_IN is the type of the vector input.  */\n+static bool\n+use_mask_by_cond_expr_p (enum tree_code code, internal_fn cond_fn,\n+\t\t\t tree vectype_in)\n+{\n+  if (cond_fn != IFN_LAST\n+      && direct_internal_fn_supported_p (cond_fn, vectype_in,\n+\t\t\t\t\t OPTIMIZE_FOR_SPEED))\n+    return false;\n+\n+  switch (code)\n+    {\n+    case DOT_PROD_EXPR:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Insert a conditional expression to enable masked vectorization.  CODE is the\n+   code for the operation.  VOP is the array of operands.  MASK is the loop\n+   mask.  GSI is a statement iterator used to place the new conditional\n+   expression.  */\n+static void\n+build_vect_cond_expr (enum tree_code code, tree vop[3], tree mask,\n+\t\t      gimple_stmt_iterator *gsi)\n+{\n+  switch (code)\n+    {\n+    case DOT_PROD_EXPR:\n+      {\n+\ttree vectype = TREE_TYPE (vop[1]);\n+\ttree zero = build_zero_cst (vectype);\n+\ttree masked_op1 = make_temp_ssa_name (vectype, NULL, \"masked_op1\");\n+\tgassign *select = gimple_build_assign (masked_op1, VEC_COND_EXPR,\n+\t\t\t\t\t       mask, vop[1], zero);\n+\tgsi_insert_before (gsi, select, GSI_SAME_STMT);\n+\tvop[1] = masked_op1;\n+\tbreak;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Function vectorizable_reduction.\n \n    Check if STMT_INFO performs a reduction operation that can be vectorized.\n@@ -6931,13 +6980,15 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   internal_fn cond_fn = get_conditional_internal_fn (code);\n   vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n+  bool mask_by_cond_expr = use_mask_by_cond_expr_p (code, cond_fn, vectype_in);\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       vect_model_reduction_cost (stmt_info, reduc_fn, ncopies, cost_vec);\n       if (loop_vinfo && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \t{\n \t  if (reduction_type != FOLD_LEFT_REDUCTION\n+\t      && !mask_by_cond_expr\n \t      && (cond_fn == IFN_LAST\n \t\t  || !direct_internal_fn_supported_p (cond_fn, vectype_in,\n \t\t\t\t\t\t      OPTIMIZE_FOR_SPEED)))\n@@ -7101,7 +7152,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n         {\n \t  tree vop[3] = { def0, vec_oprnds1[i], NULL_TREE };\n-\t  if (masked_loop_p)\n+\t  if (masked_loop_p && !mask_by_cond_expr)\n \t    {\n \t      /* Make sure that the reduction accumulator is vop[0].  */\n \t      if (reduc_index == 1)\n@@ -7125,6 +7176,14 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      if (op_type == ternary_op)\n \t\tvop[2] = vec_oprnds2[i];\n \n+\t      if (masked_loop_p && mask_by_cond_expr)\n+\t\t{\n+\t\t  tree mask = vect_get_loop_mask (gsi, masks,\n+\t\t\t\t\t\t  vec_num * ncopies,\n+\t\t\t\t\t\t  vectype_in, i * ncopies + j);\n+\t\t  build_vect_cond_expr (code, vop, mask, gsi);\n+\t\t}\n+\n \t      gassign *new_stmt = gimple_build_assign (vec_dest, code,\n \t\t\t\t\t\t       vop[0], vop[1], vop[2]);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);"}]}