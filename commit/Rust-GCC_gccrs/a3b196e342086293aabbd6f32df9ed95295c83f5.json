{"sha": "a3b196e342086293aabbd6f32df9ed95295c83f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNiMTk2ZTM0MjA4NjI5M2FhYmJkNmYzMmRmOWVkOTUyOTVjODNmNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-03-21T21:01:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-03-21T21:01:42Z"}, "message": "tree-vrp.c (extract_range_from_unary_expr): Derive ranges for type conversions of a VR_VARYING source to a wider type.\n\n\n\t* tree-vrp.c (extract_range_from_unary_expr): Derive ranges for\n\ttype conversions of a VR_VARYING source to a wider type.\n\n\t* gcc.dg/tree-ssa/vrp28.c: New test.\n\nFrom-SVN: r112256", "tree": {"sha": "8da33b4204779d57062fb867c60614ce5f2ad2a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8da33b4204779d57062fb867c60614ce5f2ad2a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3b196e342086293aabbd6f32df9ed95295c83f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b196e342086293aabbd6f32df9ed95295c83f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b196e342086293aabbd6f32df9ed95295c83f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b196e342086293aabbd6f32df9ed95295c83f5/comments", "author": null, "committer": null, "parents": [{"sha": "ec23ed606daa42ee11510be00add6f2a6350d565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec23ed606daa42ee11510be00add6f2a6350d565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec23ed606daa42ee11510be00add6f2a6350d565"}], "stats": {"total": 98, "additions": 81, "deletions": 17}, "files": [{"sha": "0a8feca8275089f03f8ed06b6d77a25d2b9fbfc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3b196e342086293aabbd6f32df9ed95295c83f5", "patch": "@@ -1,3 +1,8 @@\n+2006-03-21  Jeff Law  <law@redhat.com>\n+\n+\t* tree-vrp.c (extract_range_from_unary_expr): Derive ranges for\n+\ttype conversions of a VR_VARYING source to a wider type.\n+\n 2006-03-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config.gcc (i[34567]86-*-solaris2*): Add config/sol2-10.h to\n@@ -106,7 +111,6 @@\n \t* tree-ssa-structalias.c (intra_create_variable_infos): Fortran\n \talias semantics is specified by flag_argument_noalias > 2.\n \n-2006-03-20  Jeff Law  <law@redhat.com>\n \n \t* tree-pass.h (pass_phi_only_copy_prop): Delete.\n \t(pass_phi_only_cprop): Declare."}, {"sha": "47260202238664c9f70cb455e740890a668c1aab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3b196e342086293aabbd6f32df9ed95295c83f5", "patch": "@@ -1,3 +1,7 @@\n+2006-03-21  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp28.c: New test.\n+\n 2006-03-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/builtins-config.h (Solaris case): Define HAVE_C99_RUNTIME"}, {"sha": "6b2a1fd6b75ea7ebc87b1cda9b958b969a39f132", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp28.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp28.c?ref=a3b196e342086293aabbd6f32df9ed95295c83f5", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int f(_Bool a)\n+{\n+  int t = a;\n+  if (t != 2)\n+   return 0;\n+  return 1;\n+}\n+\n+int f1(unsigned char a)\n+{\n+  int t = a;\n+  if (t != 256)\n+   return 0;\n+  return 1;\n+}\n+\n+int f3 (unsigned char c)\n+{\n+  int i = c;\n+  if (i < 0 || i > 255)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"vrp1\" } } * /\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */\n+\n+"}, {"sha": "d3d57edb55fc5b3bc1583c56d5a48610c0c9f898", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b196e342086293aabbd6f32df9ed95295c83f5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=a3b196e342086293aabbd6f32df9ed95295c83f5", "patch": "@@ -1641,14 +1641,12 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n       return;\n     }\n \n-  /* Refuse to operate on varying and symbolic ranges.  Also, if the\n-     operand is neither a pointer nor an integral type, set the\n-     resulting range to VARYING.  TODO, in some cases we may be able\n-     to derive anti-ranges (like nonzero values).  */\n-  if (vr0.type == VR_VARYING\n-      || (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-\t  && !POINTER_TYPE_P (TREE_TYPE (op0)))\n-      || symbolic_range_p (&vr0))\n+  /* Refuse to operate on symbolic ranges, or if neither operand is\n+     a pointer or integral type.  */\n+  if ((!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+       && !POINTER_TYPE_P (TREE_TYPE (op0)))\n+      || (vr0.type != VR_VARYING\n+\t  && symbolic_range_p (&vr0)))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -1681,20 +1679,36 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t or equal to the new max, then we can safely use the newly\n \t computed range for EXPR.  This allows us to compute\n \t accurate ranges through many casts.  */\n-      if (vr0.type == VR_RANGE)\n+      if (vr0.type == VR_RANGE\n+\t  || (vr0.type == VR_VARYING\n+\t      && TYPE_PRECISION (outer_type) > TYPE_PRECISION (inner_type)))\n \t{\n-\t  tree new_min, new_max;\n+\t  tree new_min, new_max, orig_min, orig_max;\n \n-\t  /* Convert VR0's min/max to OUTER_TYPE.  */\n-\t  new_min = fold_convert (outer_type, vr0.min);\n-\t  new_max = fold_convert (outer_type, vr0.max);\n+\t  /* Convert the input operand min/max to OUTER_TYPE.   If\n+\t     the input has no range information, then use the min/max\n+\t     for the input's type.  */\n+\t  if (vr0.type == VR_RANGE)\n+\t    {\n+\t      orig_min = vr0.min;\n+\t      orig_max = vr0.max;\n+\t    }\n+\t  else\n+\t    {\n+\t      orig_min = TYPE_MIN_VALUE (inner_type);\n+\t      orig_max = TYPE_MAX_VALUE (inner_type);\n+\t    }\n+\n+\t  new_min = fold_convert (outer_type, orig_min);\n+\t  new_max = fold_convert (outer_type, orig_max);\n \n \t  /* Verify the new min/max values are gimple values and\n-\t     that they compare equal to VR0's min/max values.  */\n+\t     that they compare equal to the orignal input's\n+\t     min/max values.  */\n \t  if (is_gimple_val (new_min)\n \t      && is_gimple_val (new_max)\n-\t      && tree_int_cst_equal (new_min, vr0.min)\n-\t      && tree_int_cst_equal (new_max, vr0.max)\n+\t      && tree_int_cst_equal (new_min, orig_min)\n+\t      && tree_int_cst_equal (new_max, orig_max)\n \t      && compare_values (new_min, new_max) <= 0\n \t      && compare_values (new_min, new_max) >= -1)\n \t    {\n@@ -1717,6 +1731,16 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t}\n     }\n \n+  /* Conversion of a VR_VARYING value to a wider type can result\n+     in a usable range.  So wait until after we've handled conversions\n+     before dropping the result to VR_VARYING if we had a source\n+     operand that is VR_VARYING.  */\n+  if (vr0.type == VR_VARYING)\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+\n   /* Apply the operation to each end of the range and see what we end\n      up with.  */\n   if (code == NEGATE_EXPR"}]}