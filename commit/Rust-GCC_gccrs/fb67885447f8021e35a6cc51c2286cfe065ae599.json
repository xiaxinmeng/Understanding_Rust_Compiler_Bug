{"sha": "fb67885447f8021e35a6cc51c2286cfe065ae599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI2Nzg4NTQ0N2Y4MDIxZTM1YTZjYzUxYzIyODZjZmUwNjVhZTU5OQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-09-13T23:21:25Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-09-13T23:21:25Z"}, "message": "Implement std::money_get.\n\n\n2001-09-13   Benjamin Kosnik  <bkoz@redhat.com>\n\n\tImplement std::money_get.\n\t* include/bits/locale_facets.tcc (money_get::do_get): Implement.\n\t* include/bits/locale_facets.h (money_get): Correct signatures.\n\t* testsuite/22_locale/money_get.cc: New file.\n\t* testsuite/22_locale/money_get_members_char.cc: New file.\n\n\t* include/bits/locale_facets.tcc (__verify_grouping): New\n\tfunction. Consolidate num_get and money_get group checking into\n\tone function.\n\t(money_get): Use it.\n\t* src/locale.cc (num_get::_M_extract): Use it.\n\t* src/locale-inst.cc: Add instantiation.\n\nFrom-SVN: r45585", "tree": {"sha": "71f51fbe376cd500205783c3af35a35cc79c431f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71f51fbe376cd500205783c3af35a35cc79c431f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb67885447f8021e35a6cc51c2286cfe065ae599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb67885447f8021e35a6cc51c2286cfe065ae599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb67885447f8021e35a6cc51c2286cfe065ae599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb67885447f8021e35a6cc51c2286cfe065ae599/comments", "author": null, "committer": null, "parents": [{"sha": "6a3d403114ac013e8a5e9a8f9496b6d8fd6a8f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3d403114ac013e8a5e9a8f9496b6d8fd6a8f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a3d403114ac013e8a5e9a8f9496b6d8fd6a8f99"}], "stats": {"total": 867, "additions": 720, "deletions": 147}, "files": [{"sha": "66a4b8e759c663d954a007e54e66972e3bb29e4f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -1,3 +1,18 @@\n+2001-09-13   Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tImplement std::money_get.\n+\t* include/bits/locale_facets.tcc (money_get::do_get): Implement.\n+\t* include/bits/locale_facets.h (money_get): Correct signatures.\n+\t* testsuite/22_locale/money_get.cc: New file.\n+\t* testsuite/22_locale/money_get_members_char.cc: New file.\n+\n+\t* include/bits/locale_facets.tcc (__verify_grouping): New\n+\tfunction. Consolidate num_get and money_get group checking into\n+\tone function.\n+\t(money_get): Use it.\n+\t* src/locale.cc (num_get::_M_extract): Use it.\n+\t* src/locale-inst.cc: Add instantiation.\n+\t\n 2001-09-12  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n \t* include/bits/std_limits.h (numeric_limits<float>::radix,"}, {"sha": "9b813369cc4528e39a37fe54841f67b9bc2ef859", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 80, "deletions": 82, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -1212,88 +1212,6 @@ namespace std\n     };\n \n \n-  template<typename _CharT, typename _InIter>\n-    class money_get : public locale::facet\n-    {\n-    public:\n-      typedef _CharT        char_type;\n-      typedef _InIter       iter_type;\n-      typedef basic_string<_CharT> string_type;\n-\n-      static locale::id id;\n-\n-      explicit \n-      money_get(size_t __refs = 0) : locale::facet(__refs) { }\n-\n-      iter_type \n-      get(iter_type __s, iter_type __end, bool __intl,\n-\t  ios_base& __f, ios_base::iostate& __err, long double& __units) const\n-      { return do_get(__s, __end, __intl, __f, __err, __units); }\n-\n-      iter_type \n-      get(iter_type __s, iter_type __end, bool __intl, ios_base& __f, \n-\t   ios_base::iostate& __err, string_type& __digits) const\n-      { return do_get(__s, __end, __intl, __f, __err, __digits); }\n-\n-    protected:\n-      virtual \n-      ~money_get() { }\n-\n-      virtual iter_type \n-      do_get(iter_type __s, iter_type /*__end*/, bool /*__intl*/,\n-             ios_base& /*__io*/, ios_base::iostate& /*__err*/,\n-             long double& /*__units*/) const\n-      { return __s; }\n-\n-      virtual iter_type \n-      do_get(iter_type __s, iter_type /*__end*/, bool /*__intl*/,\n-             ios_base& /*__io*/, ios_base::iostate& /*__err*/,\n-             string_type& /*__digits*/) const\n-      { return __s; }\n-    };\n-\n-  template<typename _CharT, typename _InIter>\n-    locale::id money_get<_CharT, _InIter>::id;\n-\n-  template<typename _CharT, typename _OutIter>\n-    class money_put : public locale::facet\n-    {\n-    public:\n-      typedef _CharT              char_type;\n-      typedef _OutIter            iter_type;\n-      typedef basic_string<_CharT> string_type;\n-\n-      static locale::id id;\n-\n-      explicit \n-      money_put(size_t __refs = 0) : locale::facet(__refs) { }\n-\n-      iter_type \n-      put(iter_type __s, bool __intl, ios_base& __f,\n-\t  char_type __fill, long double __units) const\n-      { return this->do_put(__s, __intl, __f, __fill, __units); }\n-\n-      iter_type \n-      put(iter_type __s, bool __intl, ios_base& __f,\n-\t  char_type __fill, const string_type& __digits) const\n-      { return this->do_put(__s, __intl, __f, __fill, __digits); }\n-\n-    protected:\n-      virtual \n-      ~money_put() { }\n-\n-      virtual iter_type\n-      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t     long double __units) const;\n-\n-      virtual iter_type\n-      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t     const string_type& __digits) const;\n-    };\n-\n-  template<typename _CharT, typename _OutIter>\n-    locale::id money_put<_CharT, _OutIter>::id;\n-\n   struct money_base\n   {\n     enum part { none, space, symbol, sign, value };\n@@ -1477,6 +1395,86 @@ namespace std\n   template<typename _CharT, bool _Intl>\n     const bool moneypunct_byname<_CharT, _Intl>::intl;\n \n+  template<typename _CharT, typename _InIter>\n+    class money_get : public locale::facet\n+    {\n+    public:\n+      typedef _CharT        \t\tchar_type;\n+      typedef _InIter       \t\titer_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      money_get(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      get(iter_type __s, iter_type __end, bool __intl,\n+\t  ios_base& __f, ios_base::iostate& __err, long double& __units) const\n+      { return this->do_get(__s, __end, __intl, __f, __err, __units); }\n+\n+      iter_type \n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __f, \n+\t  ios_base::iostate& __err, string_type& __digits) const\n+      { return this->do_get(__s, __end, __intl, __f, __err, __digits); }\n+\n+    protected:\n+      virtual \n+      ~money_get() { }\n+\n+      virtual iter_type \n+      do_get(iter_type __s, iter_type __end, bool __intl,\n+             ios_base& __io, ios_base::iostate& __err,\n+             long double& __units) const;\n+\n+      virtual iter_type \n+      do_get(iter_type __s, iter_type __end, bool __intl,\n+             ios_base& __io, ios_base::iostate& __err,\n+             string_type& __digits) const;\n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id money_get<_CharT, _InIter>::id;\n+\n+  template<typename _CharT, typename _OutIter>\n+    class money_put : public locale::facet\n+    {\n+    public:\n+      typedef _CharT              \tchar_type;\n+      typedef _OutIter            \titer_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      money_put(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      put(iter_type __s, bool __intl, ios_base& __f,\n+\t  char_type __fill, long double __units) const\n+      { return this->do_put(__s, __intl, __f, __fill, __units); }\n+\n+      iter_type \n+      put(iter_type __s, bool __intl, ios_base& __f,\n+\t  char_type __fill, const string_type& __digits) const\n+      { return this->do_put(__s, __intl, __f, __fill, __digits); }\n+\n+    protected:\n+      virtual \n+      ~money_put() { }\n+\n+      virtual iter_type\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     long double __units) const;\n+\n+      virtual iter_type\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     const string_type& __digits) const;\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    locale::id money_put<_CharT, _OutIter>::id;\n+\n \n   struct messages_base\n   {"}, {"sha": "ccf227e19cd0095a7c4d303e5743c23b3bfe28ed", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 284, "deletions": 43, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -227,19 +227,227 @@ namespace std\n       return __ncp;\n     }\n \n+  template<typename _CharT, typename _InIter>\n+    money_get<_CharT, _InIter>::iter_type \n+    money_get<_CharT, _InIter>::do_get(iter_type __s, iter_type __end, \n+\t\t\t\t       bool __intl, ios_base& __io, \n+\t\t\t\t       ios_base::iostate& __err,\n+\t\t\t\t       long double& __units) const\n+    { \n+      string_type __str;\n+      this->do_get(__s, __end, __intl, __io, __err, __str); \n+\n+      const int __n = numeric_limits<long double>::digits10;\n+      char* __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __n));\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const _CharT* __wcs = __str.c_str();\n+      __ctype.narrow(__wcs, __wcs + __str.size() + 1, char(), __cs);      \n+\n+      char* __sanity;\n+      errno = 0;\n+      long double __ld = strtold(__cs, &__sanity);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __cs && *__sanity == '\\0' && errno == 0)\n+        __units = __ld;\n+      return __s;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    money_get<_CharT, _InIter>::iter_type \n+    money_get<_CharT, _InIter>::do_get(iter_type __s, iter_type __end, \n+\t\t\t\t       bool __intl, ios_base& __io, \n+\t\t\t\t       ios_base::iostate& __err,\n+\t\t\t\t       string_type& __units) const\n+    { \n+      // These contortions are quite unfortunate.\n+      typedef moneypunct<_CharT, true> \t\t__money_true;\n+      typedef moneypunct<_CharT, false> \t__money_false;\n+      typedef money_base::part \t\t\tpart;\n+      typedef typename string_type::size_type \tsize_type;\n+\n+      const locale __loc = __io.getloc();\n+      const __money_true& __mpt = use_facet<__money_true>(__loc); \n+      const __money_false& __mpf = use_facet<__money_false>(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+\n+      const money_base::pattern __p = __intl ? __mpt.neg_format() \n+\t\t\t\t\t     : __mpf.neg_format();\n+\n+      const string_type __pos_sign =__intl ? __mpt.positive_sign() \n+\t\t\t\t\t   : __mpf.positive_sign();\n+      const string_type __neg_sign =__intl ? __mpt.negative_sign() \n+\t\t\t\t\t   : __mpf.negative_sign();\n+      const char_type __d = __intl ? __mpt.decimal_point() \n+  \t    \t       \t\t   : __mpf.decimal_point();\n+      const char_type __sep = __intl ? __mpt.thousands_sep() \n+\t\t    \t\t     : __mpf.thousands_sep();\n+\n+      const string __grouping = __intl ? __mpt.grouping() \n+\t\t\t\t       : __mpf.grouping();\n+\n+      // Set to deduced positive or negative sign, depending.\n+      string_type __sign;\n+      // String of grouping info from thousands_sep plucked from __units.\n+      string __grouping_tmp; \n+      // Marker for thousands_sep position.\n+      int __sep_pos = 0;\n+      // If input iterator is in a valid state.\n+      bool __testvalid = true;\n+      // Flag marking when a decimal point is found.\n+      bool __testdecfound = false; \n+\n+      char_type __c = *__s;\n+      char_type __eof = static_cast<char_type>(char_traits<char_type>::eof());\n+      for (int __i = 0; __s != __end && __i < 4 && __testvalid; ++__i)\n+\t{\n+\t  part __which = static_cast<part>(__p.field[__i]);\n+\t  switch (__which)\n+\t\t{\n+\t\tcase money_base::symbol:\n+\t\t  if (__io.flags() & ios_base::showbase)\n+\t\t    {\n+\t\t      // Symbol is required.\n+\t\t      const string_type __symbol = __intl ? __mpt.curr_symbol()\n+\t\t\t\t\t\t    \t : __mpf.curr_symbol();\n+\t\t      size_type __len = __symbol.size();\n+\t\t      size_type __i = 0;\n+\t\t      while (__s != __end \n+\t\t\t     && __i < __len && __symbol[__i] == __c)\n+\t\t\t{\n+\t\t\t  __c = *(++__s);\n+\t\t\t  ++__i;\n+\t\t\t}\n+\t\t      if (__i != __len)\n+\t\t\t__testvalid = false;\n+\t\t    }\n+\t\t  break;\n+\t\tcase money_base::sign:\t\t    \n+\t\t  // Sign might not exist, or be more than one character long. \n+\t\t  if (__pos_sign.size() && __neg_sign.size())\n+\t\t  {\n+\t\t    // Sign is mandatory.\n+\t\t    if (__c == __pos_sign[0])\n+\t\t      {\n+\t\t\t__sign = __pos_sign;\n+\t\t\t__c = *(++__s);\n+\t\t      }\n+\t\t    else if (__c == __neg_sign[0])\n+\t\t      {\n+\t\t\t__sign = __neg_sign;\n+\t\t\t__c = *(++__s);\n+\t\t      }\n+\t\t    else\n+\t\t      __testvalid = false;\n+\t\t  }\n+\t\t  else if (__pos_sign.size() && __c == __pos_sign[0])\n+\t\t    {\n+\t\t      __sign = __pos_sign;\n+\t\t      __c = *(++__s);\n+\t\t    }\n+\t\t  else if (__neg_sign.size() && __c == __neg_sign[0])\n+\t\t    {\n+\t\t      __sign = __neg_sign;\n+\t\t      __c = *(++__s);\n+\t\t    }\n+\t\t  break;\n+\t\tcase money_base::value:\n+\t\t  // Extract digits, remove and stash away the\n+\t\t  // grouping of found thousands separators.\n+\t\t  while (__s != __end \n+\t\t\t && (__ctype.is(ctype_base::digit, __c) \n+\t\t\t     || (__c == __d && !__testdecfound)\n+\t\t\t     || __c == __sep))\n+\t\t    {\n+\t\t      if (__c == __d)\n+\t\t\t{\n+\t\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t\t  __sep_pos = 0;\n+\t\t\t  __testdecfound = true;\n+\t\t\t}\n+\t\t      else if (__c == __sep)\n+\t\t\t{\n+\t\t\t  if (__grouping.size())\n+\t\t\t    {\n+\t\t\t      // Mark position for later analysis.\n+\t\t\t      __grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t\t      __sep_pos = 0;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      __testvalid = false;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  __units += __c;\n+\t\t\t  ++__sep_pos;\n+\t\t\t}\n+\t\t      __c = *(++__s);\n+\t\t    }\n+\t\t  break;\n+\t\tcase money_base::space:\n+\t\tcase money_base::none:\n+\t\t  // Only if not at the end of the pattern.\n+\t\t  if (__i != 3)\n+\t\t    while (__s != __end && __ctype.is(ctype_base::space, __c))\n+\t\t      __c = *(++__s);\n+\t\t  break;\n+\t\t}\n+\t}\n+\n+      // Need to get the rest of the sign characters, if they exist.\n+      if (__sign.size() > 1)\n+\t{\n+\t  size_type __len = __sign.size();\n+\t  size_type __i = 1;\n+\t  for (; __c != __eof && __i < __len; ++__i)\n+\t    while (__s != __end && __c != __sign[__i])\n+\t      __c = *(++__s);\n+\t  \n+\t  if (__i != __len)\n+\t    __testvalid = false;\n+\t}\n+\n+      // Strip leading zeros.\n+      while (__units[0] == __ctype.widen('0'))\n+\t__units.erase(__units.begin());\n+\n+      if (__sign == __neg_sign)\n+\t__units.insert(__units.begin(), __ctype.widen('-'));\n+\n+      // Test for grouping fidelity.\n+      if (__grouping.size() && __grouping_tmp.size())\n+\t{\n+\t  if (!__verify_grouping(__grouping, __grouping_tmp))\n+\t    __testvalid = false;\n+\t}\n+\n+      // Iff no more characters are available.      \n+      if (__c == __eof)\n+\t__err |= ios_base::eofbit;\n+\n+      // Iff valid sequence is not recognized.\n+      if (!__testvalid || !__units.size())\n+\t__err |= ios_base::failbit;\n+\n+      return __s; \n+    }\n+\n   template<typename _CharT, typename _OutIter>\n     money_put<_CharT, _OutIter>::iter_type\n     money_put<_CharT, _OutIter>::do_put(iter_type __s, bool __intl, \n \t\t\t\t\tios_base& __io, char_type __fill,\n \t\t\t\t\tlong double __units) const\n     { \n-      locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc); \n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n       const int __n = numeric_limits<long double>::digits10;\n       char* __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __n));\n       _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n       int __len = sprintf(__cs, \"%.01Lf\", __units);\n-      __ct.widen(__cs, __cs + __len, __ws);\n+      __ctype.widen(__cs, __cs + __len, __ws);\n       string_type __digits(__ws);\n       return this->do_put(__s, __intl, __io, __fill, __digits); \n     }\n@@ -250,25 +458,26 @@ namespace std\n \t\t \t\t\tios_base& __io, char_type __fill,\n \t\t\t\t\tconst string_type& __digits) const\n     { \n-      typedef typename string_type::size_type size_type;\n+      typedef typename string_type::size_type \tsize_type;\n+      typedef money_base::part \t\t\tpart;\n \n-      locale __loc = __io.getloc();\n-      size_type __width = static_cast<size_type>(__io.width());\n+      const locale __loc = __io.getloc();\n+      const size_type __width = static_cast<size_type>(__io.width());\n \n       // These contortions are quite unfortunate.\n       typedef moneypunct<_CharT, true> __money_true;\n       typedef moneypunct<_CharT, false> __money_false;\n       const __money_true& __mpt = use_facet<__money_true>(__loc); \n       const __money_false& __mpf = use_facet<__money_false>(__loc); \n-      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n \n       // Determine if negative or positive formats are to be used, and\n       // discard leading negative_sign if it is present.\n       const char_type* __beg = __digits.data();\n       const char_type* __end = __beg + __digits.size();\n       money_base::pattern __p;\n       string_type __sign;\n-      if (*__beg != __ct.widen('-'))\n+      if (*__beg != __ctype.widen('-'))\n \t{\n \t  __p = __intl ? __mpt.pos_format() : __mpf.pos_format();\n \t  __sign =__intl ? __mpt.positive_sign() : __mpf.positive_sign();\n@@ -281,23 +490,24 @@ namespace std\n \t}\n       \n       // Look for valid numbers in the current ctype facet within input digits.\n-      __end = __ct.scan_not(ctype_base::digit, __beg, __end);\n+      __end = __ctype.scan_not(ctype_base::digit, __beg, __end);\n       if (__beg != __end)\n \t{\n \t  // Assume valid input, and attempt to format.\n \t  // Break down input numbers into base components, as follows:\n \t  //   final_value = grouped units + (decimal point) + (digits)\n \t  string_type __res;\n \t  string_type __value;\n-\t  string_type __symbol = __intl \n-\t    \t\t\t ? __mpt.curr_symbol() : __mpf.curr_symbol();\n+\t  const string_type __symbol = __intl ? __mpt.curr_symbol() \n+\t    \t\t\t\t      : __mpf.curr_symbol();\n \n \t  // Deal with decimal point, decimal digits.\n-\t  int __frac = __intl ? __mpt.frac_digits() : __mpf.frac_digits();\n+\t  const int __frac = __intl ? __mpt.frac_digits() \n+\t    \t\t\t    : __mpf.frac_digits();\n \t  if (__frac > 0)\n \t    {\n-\t      char_type __d = __intl \n-\t\t\t      ? __mpt.decimal_point() : __mpf.decimal_point();\n+\t      const char_type __d = __intl ? __mpt.decimal_point() \n+\t\t\t\t\t   : __mpf.decimal_point();\n \t      if (__end - __beg >= __frac)\n \t\t{\n \t\t  __value = string_type(__end - __frac, __end);\n@@ -309,7 +519,7 @@ namespace std\n \t\t  // Have to pad zeros in the decimal position.\n \t\t  __value = string_type(__beg, __end);\n \t\t  int __paddec = __frac - (__end - __beg);\n-\t\t  char_type __zero = __ct.widen('0');\n+\t\t  char_type __zero = __ctype.widen('0');\n \t\t  __value.insert(__value.begin(), __paddec, __zero);\n \t\t  __value.insert(__value.begin(), __d);\n \t\t  __beg = __end;\n@@ -320,11 +530,12 @@ namespace std\n \t  // grouping rules.\n \t  if (__beg != __end)\n \t    {\n-\t      string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();\n+\t      const string __grouping = __intl ? __mpt.grouping() \n+\t\t\t\t\t       : __mpf.grouping();\n \t      if (__grouping.size())\n \t\t{\n-\t\t  char_type __sep = __intl ? __mpt.thousands_sep() \n-\t\t    \t\t\t   : __mpf.thousands_sep();\n+\t\t  const char_type __sep = __intl ? __mpt.thousands_sep() \n+\t\t    \t\t\t         : __mpf.thousands_sep();\n \t\t  const char* __gbeg = __grouping.data();\n \t\t  const char* __gend = __gbeg + __grouping.size();\n \t\t  const int __n = numeric_limits<long double>::digits10 * 2;\n@@ -346,7 +557,6 @@ namespace std\n \t  // Fit formatted digits into the required pattern.\n \t  for (int __i = 0; __i < 4; ++__i)\n \t    {\n-\t      typedef money_base::part part;\n \t      part __which = static_cast<part>(__p.field[__i]);\n \t      switch (__which)\n \t\t{\n@@ -371,7 +581,7 @@ namespace std\n \t\t  if (__testipad)\n \t\t    __res += string_type(__width - __len, __fill);\n \t\t  else\n-\t\t    __res += __ct.widen(' ');\n+\t\t    __res += __ctype.widen(' ');\n \t\t  break;\n \t\tcase money_base::none:\n \t\t  if (__testipad)\n@@ -888,11 +1098,11 @@ namespace std\n     }\n \n   // __pad is specialized for ostreambuf_iterator, random access iterator.\n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     inline _OutIter\n     __pad(_OutIter __s, _CharT __fill, int __padding);\n \n-  template <typename _CharT, typename _RaIter>\n+  template<typename _CharT, typename _RaIter>\n     _RaIter\n     __pad(_RaIter __s, _CharT __fill, int __padding, \n \t  random_access_iterator_tag)\n@@ -901,23 +1111,23 @@ namespace std\n       return __s + __padding;\n     }\n \n-  template <typename _CharT, typename _OutIter, typename _Tag>\n+  template<typename _CharT, typename _OutIter, typename _Tag>\n     _OutIter\n     __pad(_OutIter __s, _CharT __fill, int __padding, _Tag)\n     {\n       while (--__padding >= 0) { *__s = __fill; ++__s; }\n       return __s;\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     inline _OutIter\n     __pad(_OutIter __s, _CharT __fill, int __padding)\n     {\n       return __pad(__s, __fill, __padding, \n \t\t   typename iterator_traits<_OutIter>::iterator_category());\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     __pad_numeric(_OutIter __s, ios_base::fmtflags /*__flags*/,\n \t\t  _CharT /*__fill*/, int /*__width*/, \n@@ -929,7 +1139,7 @@ namespace std\n     }\n \n   // Partial specialization for ostreambuf_iterator.\n-  template <typename _CharT>   \n+  template<typename _CharT>   \n     ostreambuf_iterator<_CharT>\n     __pad_numeric(ostreambuf_iterator<_CharT> __s, ios_base::fmtflags __flags,\n \t\t  _CharT __fill, int __width, _CharT const* __first,\n@@ -966,7 +1176,7 @@ namespace std\n       return __s3;\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n@@ -998,11 +1208,42 @@ namespace std\n       return __s;\n     }\n \n-  // __group_digits inserts \"group separator\" characters into an array\n-  // of characters.  It's recursive, one iteration per group.  It moves\n-  // the characters in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".\n-  // Call this only with __gbeg != __gend.\n-  template <typename _CharT>\n+  // Check to make sure that the __grouping_tmp string constructed in\n+  // money_get or num_get matches the canonical grouping for a given\n+  // locale.\n+  // __grouping_tmp is parsed L to R\n+  // 1,222,444 == __grouping_tmp of \"/1/3/3\"\n+  // __grouping is parsed R to L\n+  // 1,222,444 == __grouping of \"/3\" == \"/3/3/3\"\n+  template<typename _CharT>\n+    bool\n+    __verify_grouping(const basic_string<_CharT>& __grouping, \n+\t\t      basic_string<_CharT>& __grouping_tmp)\n+    {         \n+      int __i = 0;\n+      int __j = 0;\n+      const int __len = __grouping.size();\n+      const int __n = __grouping_tmp.size();\n+      bool __test = true;\n+      \n+      // Parsed number groupings have to match the\n+      // numpunct::grouping string exactly, starting at the\n+      // right-most point of the parsed sequence of elements ...\n+      while (__test && __i < __n - 1)\n+\tfor (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)\n+\t  __test &= __grouping[__j] == __grouping_tmp[__n - __i - 1];\n+      // ... but the last parsed grouping can be <= numpunct\n+      // grouping.\n+      __j == __len ? __j = 0 : __j;\n+      __test &= __grouping[__j] >= __grouping_tmp[__n - __i - 1];\n+      return __test;\n+    }\n+\n+  // Inserts \"group separator\" characters into an array of characters.\n+  // It's recursive, one iteration per group.  It moves the characters\n+  // in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".  Call this\n+  // only with __gbeg != __gend.\n+  template<typename _CharT>\n     _CharT*\n     __group_digits(_CharT* __s, _CharT __sep,  \n \t\t   const char* __gbeg, const char* __gend, \n@@ -1024,7 +1265,7 @@ namespace std\n       return __s;\n     }\n \n-  template <typename _CharT, typename _OutIter, typename _ValueT>\n+  template<typename _CharT, typename _OutIter, typename _ValueT>\n     _OutIter\n     __output_integer(_OutIter __s, ios_base& __io, _CharT __fill, bool __neg,\n \t\t     _ValueT __v)\n@@ -1097,7 +1338,7 @@ namespace std\n \t\t\t   __digits, __p, __digits_end);\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n@@ -1112,15 +1353,15 @@ namespace std\n       return __output_integer(__s, __io, __fill, __neg, __uv);\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long __v) const\n     { return __output_integer(__s, __io, __fill, false, __v); }\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n@@ -1135,7 +1376,7 @@ namespace std\n       return __output_integer(__s, __b, __fill, __neg, __uv);\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n@@ -1162,7 +1403,7 @@ namespace std\n       size_t __padding = __io.width() > streamsize(__slen) ?\n                          __io.width() -__slen : 0;\n       locale __loc = __io.getloc();\n-      ctype<_CharT> const& __ct = use_facet<ctype<_CharT> >(__loc);\n+      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n       ios_base::fmtflags __adjfield = __io.flags() & ios_base::adjustfield;\n       const char* const __eptr = __sptr + __slen;\n       // [22.2.2.2.2.19] Table 61\n@@ -1171,7 +1412,7 @@ namespace std\n          // [22.2.2.2.2.14]; widen()\n          if (__sptr < __eptr && (*__sptr == '+' || *__sptr == '-'))\n            {\n-             __s = __ct.widen(*__sptr);\n+             __s = __ctype.widen(*__sptr);\n              ++__s;\n              ++__sptr;\n            }\n@@ -1193,7 +1434,7 @@ namespace std\n            __s = __fmt->_M_decimal_point;\n          // [22.2.2.2.2.14]; widen()\n          else\n-           __s = __ct.widen(*__sptr);\n+           __s = __ctype.widen(*__sptr);\n        }\n       // [22.2.2.2.2.19] Table 61\n       if (__padding)\n@@ -1206,7 +1447,7 @@ namespace std\n   __build_float_format(ios_base& __io, char* __fptr, char __modifier,\n \t\t       streamsize __prec);\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n@@ -1229,7 +1470,7 @@ namespace std\n       return __output_float(__s, __io, __fill, __sbuf, __slen);\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n@@ -1254,7 +1495,7 @@ namespace std\n       return __output_float(__s, __io, __fill, __sbuf, __slen);\n     }\n \n-  template <typename _CharT, typename _OutIter>\n+  template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,"}, {"sha": "df0a3af48668c10e8bde67edf9d7bcde7d63b276", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -264,6 +264,10 @@ namespace std\n     __group_digits<char>(char*, char, char const*, char const*, \n \t\t\t char const*, char const*);\n \n+  template\n+    bool\n+    __verify_grouping<char>(const basic_string<char>&, basic_string<char>&);\n+\n   template \n     ostreambuf_iter\n     __output_integer<char, ostreambuf_iter, unsigned long>\n@@ -298,6 +302,10 @@ namespace std\n     wchar_t*\n     __group_digits<wchar_t>(wchar_t*, wchar_t, char const*, char const*, \n \t\t\t    wchar_t const*, wchar_t const*);\n+  template\n+    bool\n+    __verify_grouping<wchar_t>(const basic_string<wchar_t>&, \n+\t\t\t       basic_string<wchar_t>&);\n \n   template \n     wostreambuf_iter"}, {"sha": "d69e7e6245598f8d7fdd0a401260bd2853f543e2", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -646,28 +646,7 @@ namespace std\n           // Add the ending grouping\n           __grp += static_cast<char>(__sep_pos);\n \n-          // __grp is parsed L to R\n-          // 1,222,444 == __grp of \"/1/3/3\"\n-          // __fmt->_M_grouping is parsed R to L\n-          // 1,222,444 == __fmt->_M_grouping of \"/3\" == \"/3/3/3\"\n-          int __i = 0;\n-          int __j = 0;\n-          const int __len = __fmt->_M_grouping.size();\n-          int __n = __grp.size();\n-          bool __test = true;\n-\n-          // Parsed number groupings have to match the\n-          // numpunct::grouping string exactly, starting at the\n-          // right-most point of the parsed sequence of elements ...\n-          while (__test && __i < __n - 1)\n-            for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)\n-              __test &= __fmt->_M_grouping[__j] == __grp[__n - __i - 1];\n-          // ... but the last parsed grouping can be <= numpunct\n-          // grouping.\n-          __j == __len ? __j = 0 : __j;\n-          __test &= __fmt->_M_grouping[__j] >= __grp[__n - __i - 1];\n-\n-          if (!__test)\n+          if (!__verify_grouping(__fmt->_M_grouping, __grp))\n             {\n               __err |= ios_base::failbit;\n               __xtrc[__pos] = '\\0';"}, {"sha": "333af26c22d8c3297a2f06703f69b1b64e9c4a10", "filename": "libstdc++-v3/testsuite/22_locale/money_get.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get.cc?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -0,0 +1,53 @@\n+// 2001-09-12  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.1  Template class money_get\n+\n+#include <locale>\n+\n+void test01()\n+{\n+  // Check for required base class.\n+  typedef std::money_get<char> test_type;\n+  typedef std::locale::facet base_type;\n+  const test_type& obj = std::use_facet<test_type>(std::locale()); \n+  const base_type* base = &obj;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type char_type;\n+  typedef test_type::string_type string_type;\n+  typedef test_type::iter_type iter_type;\n+}\n+\n+// Should be able to instantiate this for other types besides char, wchar_t\n+class gnu_money_get: public std::money_get<unsigned char> \n+{ };\n+\n+void test02()\n+{ \n+  gnu_money_get facet01;\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "6b035e534d758fc7cbb7eb894af4795fb0683d35", "filename": "libstdc++-v3/testsuite/22_locale/money_get_members_char.cc", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get_members_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb67885447f8021e35a6cc51c2286cfe065ae599/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get_members_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get_members_char.cc?ref=fb67885447f8021e35a6cc51c2286cfe065ae599", "patch": "@@ -0,0 +1,279 @@\n+// 2001-09-12 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.1.1 money_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+// test string version\n+void test01()\n+{\n+  using namespace std;\n+  typedef money_base::part part;\n+  typedef money_base::pattern pattern;\n+  typedef istreambuf_iterator<char> iterator_type;\n+\n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_hk(\"en_HK\");\n+  str = loc_hk.name();\n+  VERIFY( loc_c != loc_hk );\n+\n+  locale loc_fr(\"fr_FR@euro\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+  VERIFY( loc_c != loc_de );\n+\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the moneypunct facets\n+  typedef moneypunct<char, true> __money_true;\n+  typedef moneypunct<char, false> __money_false;\n+  const __money_true& monpunct_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monpunct_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monpunct_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monpunct_de_f = use_facet<__money_false>(loc_de); \n+  const __money_true& monpunct_hk_t = use_facet<__money_true>(loc_hk); \n+  const __money_false& monpunct_hk_f = use_facet<__money_false>(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const string empty;\n+\n+  // total EPA budget FY 2002\n+  const string digits1(\"720000000000\");\n+\n+  // est. cost, national missle \"defense\", expressed as a loss in USD 2001\n+  const string digits2(\"-10000000000000\");  \n+\n+  // not valid input\n+  const string digits3(\"-A\"); \n+\n+  // input less than frac_digits\n+  const string digits4(\"-1\");\n+  \n+  iterator_type end;\n+  istringstream iss;\n+  iss.imbue(loc_de);\n+  // cache the money_get facet\n+  const money_get<char>& mon_get = use_facet<money_get<char> >(iss.getloc()); \n+\n+\n+  iss.str(\"7.200.000.000,00 \");\n+  iterator_type is_it01(iss);\n+  string result1;\n+  ios_base::iostate err01 = ios_base::goodbit;\n+  mon_get.get(is_it01, end, true, iss, err01, result1);\n+  VERIFY( result1 == digits1 );\n+  VERIFY( err01 == ios_base::eofbit );\n+\n+  iss.str(\"7.200.000.000,00  \");\n+  iterator_type is_it02(iss);\n+  string result2;\n+  ios_base::iostate err02 = ios_base::goodbit;\n+  mon_get.get(is_it02, end, true, iss, err02, result2);\n+  VERIFY( result2 == digits1 );\n+  VERIFY( err02 == ios_base::eofbit );\n+\n+  iss.str(\"7.200.000.000,00  a\");\n+  iterator_type is_it03(iss);\n+  string result3;\n+  ios_base::iostate err03 = ios_base::goodbit;\n+  mon_get.get(is_it03, end, true, iss, err03, result3);\n+  VERIFY( result3 == digits1 );\n+  VERIFY( err03 == ios_base::goodbit );\n+\n+  iss.str(\"\");\n+  iterator_type is_it04(iss);\n+  string result4;\n+  ios_base::iostate err04 = ios_base::goodbit;\n+  mon_get.get(is_it04, end, true, iss, err04, result4);\n+  VERIFY( result4 == empty );\n+  VERIFY( err04 == ios_base::failbit | ios_base::eofbit );\n+\n+  iss.str(\"working for enlightenment and peace in a mad world\");\n+  iterator_type is_it05(iss);\n+  string result5;\n+  ios_base::iostate err05 = ios_base::goodbit;\n+  mon_get.get(is_it05, end, true, iss, err05, result5);\n+  VERIFY( result5 == empty );\n+  VERIFY( err05 == ios_base::failbit );\n+\n+  // now try with showbase, to get currency symbol in format\n+  iss.setf(ios_base::showbase);\n+\n+  iss.str(\"7.200.000.000,00 DEM \");\n+  iterator_type is_it06(iss);\n+  string result6;\n+  ios_base::iostate err06 = ios_base::goodbit;\n+  mon_get.get(is_it06, end, true, iss, err06, result6);\n+  VERIFY( result6 == digits1 );\n+  VERIFY( err06 == ios_base::eofbit );\n+\n+  iss.str(\"7.200.000.000,00 DEM  \"); // Extra space.\n+  iterator_type is_it07(iss);\n+  string result7;\n+  ios_base::iostate err07 = ios_base::goodbit;\n+  mon_get.get(is_it07, end, true, iss, err07, result7);\n+  VERIFY( result7 == digits1 );\n+  VERIFY( err07 == ios_base::goodbit );\n+\n+  iss.str(\"7.200.000.000,00 DM\"); \n+  iterator_type is_it08(iss);\n+  string result8;\n+  ios_base::iostate err08 = ios_base::goodbit;\n+  mon_get.get(is_it08, end, false, iss, err08, result8);\n+  VERIFY( result8 == digits1 );\n+  VERIFY( err08 == ios_base::eofbit );\n+\n+  iss.imbue(loc_hk);\n+  iss.str(\"HK$7,200,000,000.00\"); \n+  iterator_type is_it09(iss);\n+  string result9;\n+  ios_base::iostate err09 = ios_base::goodbit;\n+  mon_get.get(is_it09, end, false, iss, err09, result9);\n+  VERIFY( result9 == digits1 );\n+  VERIFY( err09 == ios_base::eofbit );\n+\n+  iss.str(\"(HKD 100,000,000,000.00)\"); \n+  iterator_type is_it10(iss);\n+  string result10;\n+  ios_base::iostate err10 = ios_base::goodbit;\n+  mon_get.get(is_it10, end, true, iss, err10, result10);\n+  VERIFY( result10 == digits2 );\n+  VERIFY( err10 == ios_base::goodbit );\n+\n+  iss.str(\"(HKD .01)\"); \n+  iterator_type is_it11(iss);\n+  string result11;\n+  ios_base::iostate err11 = ios_base::goodbit;\n+  mon_get.get(is_it11, end, true, iss, err11, result11);\n+  VERIFY( result11 == digits4 );\n+  VERIFY( err11 == ios_base::goodbit );\n+}\n+\n+// test double/string versions\n+void test02()\n+{\n+  using namespace std;\n+  typedef money_base::part part;\n+  typedef money_base::pattern pattern;\n+  typedef istreambuf_iterator<char> iterator_type;\n+\n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_hk(\"en_HK\");\n+  str = loc_hk.name();\n+  VERIFY( loc_c != loc_hk );\n+\n+  locale loc_fr(\"fr_FR@euro\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+  VERIFY( loc_c != loc_de );\n+\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the moneypunct facets\n+  typedef moneypunct<char, true> __money_true;\n+  typedef moneypunct<char, false> __money_false;\n+  const __money_true& monpunct_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monpunct_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monpunct_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monpunct_de_f = use_facet<__money_false>(loc_de); \n+  const __money_true& monpunct_hk_t = use_facet<__money_true>(loc_hk); \n+  const __money_false& monpunct_hk_f = use_facet<__money_false>(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const string empty;\n+\n+  // total EPA budget FY 2002\n+  const long double  digits1 = 720000000000;\n+\n+  // est. cost, national missle \"defense\", expressed as a liss in USD 2001\n+  const long double digits2 = -10000000000000;  \n+\n+  // input less than frac_digits\n+  const long double digits4 = -1;\n+  \n+  iterator_type end;\n+  istringstream iss;\n+  iss.imbue(loc_de);\n+  // cache the money_get facet\n+  const money_get<char>& mon_get = use_facet<money_get<char> >(iss.getloc()); \n+\n+  iss.str(\"7.200.000.000,00 \");\n+  iterator_type is_it01(iss);\n+  long double result1;\n+  ios_base::iostate err01 = ios_base::goodbit;\n+  mon_get.get(is_it01, end, true, iss, err01, result1);\n+  VERIFY( result1 == digits1 );\n+  VERIFY( err01 == ios_base::eofbit );\n+\n+  iss.str(\"7.200.000.000,00 \");\n+  iterator_type is_it02(iss);\n+  long double result2;\n+  ios_base::iostate err02 = ios_base::goodbit;\n+  mon_get.get(is_it02, end, false, iss, err02, result2);\n+  VERIFY( result2 == digits1 );\n+  VERIFY( err02 == ios_base::eofbit );\n+\n+  // now try with showbase, to get currency symbol in format\n+  iss.setf(ios_base::showbase);\n+\n+  iss.imbue(loc_hk);\n+  iss.str(\"(HKD .01)\"); \n+  iterator_type is_it03(iss);\n+  long double result3;\n+  ios_base::iostate err03 = ios_base::goodbit;\n+  mon_get.get(is_it03, end, true, iss, err03, result3);\n+  VERIFY( result3 == digits4 );\n+  VERIFY( err03 == ios_base::goodbit );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}