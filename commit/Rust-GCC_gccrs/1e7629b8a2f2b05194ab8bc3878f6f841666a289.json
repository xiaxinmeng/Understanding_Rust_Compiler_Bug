{"sha": "1e7629b8a2f2b05194ab8bc3878f6f841666a289", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU3NjI5YjhhMmYyYjA1MTk0YWI4YmMzODc4ZjZmODQxNjY2YTI4OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-29T09:36:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-29T09:36:51Z"}, "message": "[Ada] Implement machine parsable format for -gnatR output\n\nThis adds a new variant to the -gnatR switch, namely -gnatRj, which causes\nthe compiler to output representation information to a file in the JSON\ndata interchange format.  It can be combined with -gnatR0/1/2/3/m (but is\nincompatible with -gnaRe and -gnatRs).\n\nThe information output in this mode is a superset of that output in the\ntraditional -gnatR mode, but is otherwise equivalent for the common part.\n\n2018-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst (Alphabetical\n\tList of All Switches): Document -gnatRj.\n\t(Debugging Control): Likewise.\n\t* gnat_ugn.texi: Regenerate.\n\t* opt.ads (List_Representation_Info_To_JSON): New boolean variable.\n\t* osint-c.adb (Create_Repinfo_File): Use the .json instead of .rep\n\textension if List_Representation_Info_To_JSON is true.\n\t* repinfo.ads: Document the JSON output format.\n\t* repinfo.adb (List_Location): New procedure.\n\t(List_Array_Info): Add support for JSON output.\n\t(List_Entities): Likewise.\n\t(Unop): Likewise.\n\t(Binop): Likewise.\n\t(Print_Expr): Likewise.\n\t(List_Linker_Section): Likewise.\n\t(List_Mechanisms): Likewise.\n\t(List_Name): Likewise.\n\t(List_Object_Info): Likewise.\n\t(List_Record_Info): Likewise.\n\t(List_Component_Layout): Likewise.  Add Indent parameter.\n\t(List_Structural_Record_Layout): New procedure.\n\t(List_Attr): Add support for JSON output.\n\t(List_Type_Info): Likewise.\n\t(Write_Unknown_Val): Likewise.\n\t* switch-c.adb (Scan_Front_End_Switches) <R>: Deal with 'j'.\n\t* usage.adb (Usage): List -gnatRj.\n\nFrom-SVN: r260868", "tree": {"sha": "1efd669ea62ee925e3ed67e0fff0b0193d000568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1efd669ea62ee925e3ed67e0fff0b0193d000568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e7629b8a2f2b05194ab8bc3878f6f841666a289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7629b8a2f2b05194ab8bc3878f6f841666a289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7629b8a2f2b05194ab8bc3878f6f841666a289", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7629b8a2f2b05194ab8bc3878f6f841666a289/comments", "author": null, "committer": null, "parents": [{"sha": "7883c42e3ffab6c1a87e22637384cf2c80193055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7883c42e3ffab6c1a87e22637384cf2c80193055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7883c42e3ffab6c1a87e22637384cf2c80193055"}], "stats": {"total": 984, "additions": 798, "deletions": 186}, "files": [{"sha": "cc6ae0e17ebc9f67e4fd93962f84cffe27322bd7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -1,3 +1,32 @@\n+2018-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst (Alphabetical\n+\tList of All Switches): Document -gnatRj.\n+\t(Debugging Control): Likewise.\n+\t* gnat_ugn.texi: Regenerate.\n+\t* opt.ads (List_Representation_Info_To_JSON): New boolean variable.\n+\t* osint-c.adb (Create_Repinfo_File): Use the .json instead of .rep\n+\textension if List_Representation_Info_To_JSON is true.\n+\t* repinfo.ads: Document the JSON output format.\n+\t* repinfo.adb (List_Location): New procedure.\n+\t(List_Array_Info): Add support for JSON output.\n+\t(List_Entities): Likewise.\n+\t(Unop): Likewise.\n+\t(Binop): Likewise.\n+\t(Print_Expr): Likewise.\n+\t(List_Linker_Section): Likewise.\n+\t(List_Mechanisms): Likewise.\n+\t(List_Name): Likewise.\n+\t(List_Object_Info): Likewise.\n+\t(List_Record_Info): Likewise.\n+\t(List_Component_Layout): Likewise.  Add Indent parameter.\n+\t(List_Structural_Record_Layout): New procedure.\n+\t(List_Attr): Add support for JSON output.\n+\t(List_Type_Info): Likewise.\n+\t(Write_Unknown_Val): Likewise.\n+\t* switch-c.adb (Scan_Front_End_Switches) <R>: Deal with 'j'.\n+\t* usage.adb (Usage): List -gnatRj.\n+\n 2018-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* repinfo.adb (List_Component_Layout): New procedure extracted from..."}, {"sha": "bbcef082c5cef8f95cec94c731b613a5187beab6", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -2024,7 +2024,7 @@ Alphabetical List of All Switches\n \n .. index:: -gnatR  (gcc)\n \n-:switch:`-gnatR[0/1/2/3][e][m][s]`\n+:switch:`-gnatR[0|1|2|3][e][j][m][s]`\n   Output representation information for declared types, objects and\n   subprograms. Note that this switch is not allowed if a previous\n   :switch:`-gnatD` switch has been given, since these two switches\n@@ -5786,7 +5786,7 @@ Debugging Control\n \n .. index:: -gnatR  (gcc)\n \n-:switch:`-gnatR[0|1|2|3][e][m][s]`\n+:switch:`-gnatR[0|1|2|3][e][j][m][s]`\n   This switch controls output from the compiler of a listing showing\n   representation information for declared types, objects and subprograms.\n   For :switch:`-gnatR0`, no information is output (equivalent to omitting\n@@ -5817,6 +5817,13 @@ Debugging Control\n   the output is to a file with the name :file:`file.rep` where file is\n   the name of the corresponding source file.\n \n+  If the switch is followed by a ``j`` (e.g., :switch:`-gnatR3j`), then\n+  the output is to a file with the name :file:`file.json` where file is\n+  the name of the corresponding source file, and it uses the JSON data\n+  interchange format specified by the ECMA-404 standard. The semantic\n+  description of this JSON output is available in the specification of\n+  the Repinfo unit present in the compiler sources.\n+\n   Note that it is possible for record components to have zero size. In\n   this case, the component clause uses an obvious extension of permitted\n   Ada syntax, for example ``at 0 range 0 .. -1``."}, {"sha": "3fb6af5ac1247762dacd5f71bb00e0666357455a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -9898,7 +9898,7 @@ Treat pragma Restrictions as Restriction_Warnings.\n \n @table @asis\n \n-@item @code{-gnatR[0/1/2/3][e][m][s]}\n+@item @code{-gnatR[0|1|2|3][e][j][m][s]}\n \n Output representation information for declared types, objects and\n subprograms. Note that this switch is not allowed if a previous\n@@ -15013,7 +15013,7 @@ restriction warnings rather than restrictions.\n \n @table @asis\n \n-@item @code{-gnatR[0|1|2|3][e][m][s]}\n+@item @code{-gnatR[0|1|2|3][e][j][m][s]}\n \n This switch controls output from the compiler of a listing showing\n representation information for declared types, objects and subprograms.\n@@ -15045,6 +15045,13 @@ If the switch is followed by an @code{s} (e.g., @code{-gnatR3s}), then\n the output is to a file with the name @code{file.rep} where file is\n the name of the corresponding source file.\n \n+If the switch is followed by a @code{j} (e.g., @code{-gnatR3j}), then\n+the output is to a file with the name @code{file.json} where file is\n+the name of the corresponding source file, and it uses the JSON data\n+interchange format specified by the ECMA-404 standard. The semantic\n+description of this JSON output is available in the specification of\n+the Repinfo unit present in the compiler sources.\n+\n Note that it is possible for record components to have zero size. In\n this case, the component clause uses an obvious extension of permitted\n Ada syntax, for example @code{at 0 range 0 .. -1}."}, {"sha": "235ca3d4a621fca954ceafaa1962947fffef6a32", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -1003,6 +1003,12 @@ package Opt is\n    --  of stdout. For example, if file x.adb is compiled using -gnatR2s then\n    --  representation info is written to x.adb.ref.\n \n+   List_Representation_Info_To_JSON : Boolean := False;\n+   --  GNAT\n+   --  Set true by -gnatRj switch. Causes information from -gnatR/1/2/3/m to be\n+   --  written to file.json (where file is the name of the source file) in the\n+   --  JSON data interchange format.\n+\n    List_Representation_Info_Mechanisms : Boolean := False;\n    --  GNAT\n    --  Set true by -gnatRm switch. Causes information on mechanisms to be"}, {"sha": "177c8dec836f10a6ea01699c1fbdf68698fdb800", "filename": "gcc/ada/osint-c.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fosint-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fosint-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-c.adb?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -273,8 +273,11 @@ package body Osint.C is\n    begin\n       Name_Buffer (1 .. Src'Length) := Src;\n       Name_Len := Src'Length;\n-      Discard := Create_Auxiliary_File (Name_Find, \"rep\");\n-      return;\n+      if List_Representation_Info_To_JSON then\n+         Discard := Create_Auxiliary_File (Name_Find, \"json\");\n+      else\n+         Discard := Create_Auxiliary_File (Name_Find, \"rep\");\n+      end if;\n    end Create_Repinfo_File;\n \n    ---------------------------"}, {"sha": "83267c879436ae15c7a484ab1256a2119d008ca7", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 602, "deletions": 150, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -153,6 +153,9 @@ package body Repinfo is\n    --  List linker section for Ent (caller has checked that Ent is an entity\n    --  for which the Linker_Section_Pragma field is defined).\n \n+   procedure List_Location (Ent : Entity_Id);\n+   --  List location information for Ent\n+\n    procedure List_Mechanisms (Ent : Entity_Id);\n    --  List mechanism information for parameters of Ent, which is subprogram,\n    --  subprogram type, or an entry or entry family.\n@@ -306,17 +309,33 @@ package body Repinfo is\n    procedure List_Array_Info (Ent : Entity_Id; Bytes_Big_Endian : Boolean) is\n    begin\n       Blank_Line;\n+\n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\"{\");\n+      end if;\n+\n       List_Type_Info (Ent);\n \n-      Write_Str (\"for \");\n-      List_Name (Ent);\n-      Write_Str (\"'Component_Size use \");\n-      Write_Val (Component_Size (Ent));\n-      Write_Line (\";\");\n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\",\");\n+         Write_Str (\"  \"\"Component_Size\"\": \");\n+         Write_Val (Component_Size (Ent));\n+      else\n+         Write_Str (\"for \");\n+         List_Name (Ent);\n+         Write_Str (\"'Component_Size use \");\n+         Write_Val (Component_Size (Ent));\n+         Write_Line (\";\");\n+      end if;\n \n       List_Scalar_Storage_Order (Ent, Bytes_Big_Endian);\n \n       List_Linker_Section (Ent);\n+\n+      if List_Representation_Info_To_JSON then\n+         Write_Eol;\n+         Write_Line (\"}\");\n+      end if;\n    end List_Array_Info;\n \n    -------------------\n@@ -428,8 +447,15 @@ package body Repinfo is\n                elsif Is_Type (E) then\n                   if List_Representation_Info >= 2 then\n                      Blank_Line;\n+                     if List_Representation_Info_To_JSON then\n+                        Write_Line (\"{\");\n+                     end if;\n                      List_Type_Info (E);\n                      List_Linker_Section (E);\n+                     if List_Representation_Info_To_JSON then\n+                        Write_Eol;\n+                        Write_Line (\"}\");\n+                     end if;\n                   end if;\n \n                elsif Ekind_In (E, E_Variable, E_Constant) then\n@@ -537,8 +563,20 @@ package body Repinfo is\n \n                procedure Unop (S : String) is\n                begin\n-                  Write_Str (S);\n-                  Print_Expr (Node.Op1);\n+                  if List_Representation_Info_To_JSON then\n+                     Write_Str (\"{ \"\"code\"\": \"\"\");\n+                     if S (S'Last) = ' ' then\n+                        Write_Str (S (S'First .. S'Last - 1));\n+                     else\n+                        Write_Str (S);\n+                     end if;\n+                     Write_Str (\"\"\", \"\"operands\"\": [ \");\n+                     Print_Expr (Node.Op1);\n+                     Write_Str (\" ] }\");\n+                  else\n+                     Write_Str (S);\n+                     Print_Expr (Node.Op1);\n+                  end if;\n                end Unop;\n \n                -----------\n@@ -547,25 +585,46 @@ package body Repinfo is\n \n                procedure Binop (S : String) is\n                begin\n-                  Write_Char ('(');\n-                  Print_Expr (Node.Op1);\n-                  Write_Str (S);\n-                  Print_Expr (Node.Op2);\n-                  Write_Char (')');\n+                  if List_Representation_Info_To_JSON then\n+                     Write_Str (\"{ \"\"code\"\": \"\"\");\n+                     Write_Str (S (S'First + 1 .. S'Last - 1));\n+                     Write_Str (\"\"\", \"\"operands\"\": [ \");\n+                     Print_Expr (Node.Op1);\n+                     Write_Str (\", \");\n+                     Print_Expr (Node.Op2);\n+                     Write_Str (\" ] }\");\n+                  else\n+                     Write_Char ('(');\n+                     Print_Expr (Node.Op1);\n+                     Write_Str (S);\n+                     Print_Expr (Node.Op2);\n+                     Write_Char (')');\n+                  end if;\n                end Binop;\n \n             --  Start of processing for Print_Expr\n \n             begin\n                case Node.Expr is\n                   when Cond_Expr =>\n-                     Write_Str (\"(if \");\n-                     Print_Expr (Node.Op1);\n-                     Write_Str (\" then \");\n-                     Print_Expr (Node.Op2);\n-                     Write_Str (\" else \");\n-                     Print_Expr (Node.Op3);\n-                     Write_Str (\" end)\");\n+                     if List_Representation_Info_To_JSON then\n+                        Write_Str (\"{ \"\"code\"\": \"\"?<>\"\"\");\n+                        Write_Str (\", \"\"operands\"\": [ \");\n+                        Print_Expr (Node.Op1);\n+                        Write_Str (\", \");\n+                        Print_Expr (Node.Op2);\n+                        Write_Str (\", \");\n+                        Print_Expr (Node.Op3);\n+                        Write_Str (\" ] }\");\n+                     else\n+                        Write_Str (\"(if \");\n+                        Print_Expr (Node.Op1);\n+                        Write_Str (\" then \");\n+                        Print_Expr (Node.Op2);\n+                        Write_Str (\" else \");\n+                        Print_Expr (Node.Op3);\n+                        Write_Str (\" end)\");\n+                     end if;\n \n                   when Plus_Expr =>\n                      Binop (\" + \");\n@@ -702,99 +761,136 @@ package body Repinfo is\n          Args := Pragma_Argument_Associations (Linker_Section_Pragma (Ent));\n          Sect := Expr_Value_S (Get_Pragma_Arg (Last (Args)));\n \n-         Write_Str (\"pragma Linker_Section (\");\n-         List_Name (Ent);\n-         Write_Str (\", \"\"\");\n+         if List_Representation_Info_To_JSON then\n+            Write_Line (\",\");\n+            Write_Str (\"  \"\"Linker_Section\"\": \"\"\");\n+         else\n+            Write_Str (\"pragma Linker_Section (\");\n+            List_Name (Ent);\n+            Write_Str (\", \"\"\");\n+         end if;\n \n          pragma Assert (Nkind (Sect) = N_String_Literal);\n          String_To_Name_Buffer (Strval (Sect));\n          Write_Str (Name_Buffer (1 .. Name_Len));\n-         Write_Str (\"\"\");\");\n-         Write_Eol;\n+         Write_Str (\"\"\"\");\n+         if not List_Representation_Info_To_JSON then\n+            Write_Line (\");\");\n+         end if;\n       end if;\n    end List_Linker_Section;\n \n+   -------------------\n+   -- List_Location --\n+   -------------------\n+\n+   procedure List_Location (Ent : Entity_Id) is\n+   begin\n+      pragma Assert (List_Representation_Info_To_JSON);\n+      Write_Str (\"  \"\"location\"\": \"\"\");\n+      Write_Location (Sloc (Ent));\n+      Write_Line (\"\"\",\");\n+   end List_Location;\n+\n    ---------------------\n    -- List_Mechanisms --\n    ---------------------\n \n    procedure List_Mechanisms (Ent : Entity_Id) is\n-      Plen : Natural;\n-      Form : Entity_Id;\n+      First : Boolean := True;\n+      Plen  : Natural;\n+      Form  : Entity_Id;\n \n    begin\n       Blank_Line;\n \n-      case Ekind (Ent) is\n-         when E_Function =>\n-            Write_Str (\"function \");\n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\"{\");\n+         Write_Str (\"  \"\"name\"\": \"\"\");\n+         List_Name (Ent);\n+         Write_Line (\"\"\",\");\n+         List_Location (Ent);\n \n-         when E_Operator =>\n-            Write_Str (\"operator \");\n+         Write_Str (\"  \"\"Convention\"\": \"\"\");\n+      else\n+         case Ekind (Ent) is\n+            when E_Function =>\n+               Write_Str (\"function \");\n \n-         when E_Procedure =>\n-            Write_Str (\"procedure \");\n+            when E_Operator =>\n+               Write_Str (\"operator \");\n \n-         when E_Subprogram_Type =>\n-            Write_Str (\"type \");\n+            when E_Procedure =>\n+               Write_Str (\"procedure \");\n \n-         when E_Entry\n-            | E_Entry_Family\n-         =>\n-            Write_Str (\"entry \");\n+            when E_Subprogram_Type =>\n+               Write_Str (\"type \");\n \n-         when others =>\n-            raise Program_Error;\n-      end case;\n+            when E_Entry\n+               | E_Entry_Family\n+            =>\n+               Write_Str (\"entry \");\n \n-      List_Name (Ent);\n-      Write_Str (\" declared at \");\n-      Write_Location (Sloc (Ent));\n-      Write_Eol;\n+            when others =>\n+               raise Program_Error;\n+         end case;\n \n-      Write_Str (\"convention : \");\n+         List_Name (Ent);\n+         Write_Str (\" declared at \");\n+         Write_Location (Sloc (Ent));\n+         Write_Eol;\n+\n+         Write_Str (\"convention : \");\n+      end if;\n \n       case Convention (Ent) is\n          when Convention_Ada =>\n-            Write_Line (\"Ada\");\n+            Write_Str (\"Ada\");\n \n          when Convention_Ada_Pass_By_Copy =>\n-            Write_Line (\"Ada_Pass_By_Copy\");\n+            Write_Str (\"Ada_Pass_By_Copy\");\n \n          when Convention_Ada_Pass_By_Reference =>\n-            Write_Line (\"Ada_Pass_By_Reference\");\n+            Write_Str (\"Ada_Pass_By_Reference\");\n \n          when Convention_Intrinsic =>\n-            Write_Line (\"Intrinsic\");\n+            Write_Str (\"Intrinsic\");\n \n          when Convention_Entry =>\n-            Write_Line (\"Entry\");\n+            Write_Str (\"Entry\");\n \n          when Convention_Protected =>\n-            Write_Line (\"Protected\");\n+            Write_Str (\"Protected\");\n \n          when Convention_Assembler =>\n-            Write_Line (\"Assembler\");\n+            Write_Str (\"Assembler\");\n \n          when Convention_C =>\n-            Write_Line (\"C\");\n+            Write_Str (\"C\");\n \n          when Convention_COBOL =>\n-            Write_Line (\"COBOL\");\n+            Write_Str (\"COBOL\");\n \n          when Convention_CPP =>\n-            Write_Line (\"C++\");\n+            Write_Str (\"C++\");\n \n          when Convention_Fortran =>\n-            Write_Line (\"Fortran\");\n+            Write_Str (\"Fortran\");\n \n          when Convention_Stdcall =>\n-            Write_Line (\"Stdcall\");\n+            Write_Str (\"Stdcall\");\n \n          when Convention_Stubbed =>\n-            Write_Line (\"Stubbed\");\n+            Write_Str (\"Stubbed\");\n       end case;\n \n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\"\"\",\");\n+         Write_Str (\"  \"\"formal\"\": [\");\n+      else\n+         Write_Eol;\n+      end if;\n+\n       --  Find max length of formal name\n \n       Plen := 0;\n@@ -815,29 +911,67 @@ package body Repinfo is\n       while Present (Form) loop\n          Get_Unqualified_Decoded_Name_String (Chars (Form));\n          Set_Casing (Unit_Casing);\n-         while Name_Len <= Plen loop\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := ' ';\n-         end loop;\n \n-         Write_Str (\"   \");\n-         Write_Str (Name_Buffer (1 .. Plen + 1));\n-         Write_Str (\": passed by \");\n+         if List_Representation_Info_To_JSON then\n+            if First then\n+               Write_Eol;\n+               First := False;\n+            else\n+               Write_Line (\",\");\n+            end if;\n+\n+            Write_Line (\"    {\");\n+            Write_Str (\"      \"\"name\"\": \"\"\");\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n+            Write_Line (\"\"\",\");\n+\n+            Write_Str (\"      \"\"mechanism\"\": \"\"\");\n+            Write_Mechanism (Mechanism (Form));\n+            Write_Line (\"\"\"\");\n+            Write_Str (\"    }\");\n+         else\n+            while Name_Len <= Plen loop\n+               Name_Len := Name_Len + 1;\n+               Name_Buffer (Name_Len) := ' ';\n+            end loop;\n+\n+            Write_Str (\"   \");\n+            Write_Str (Name_Buffer (1 .. Plen + 1));\n+            Write_Str (\": passed by \");\n+\n+            Write_Mechanism (Mechanism (Form));\n+            Write_Eol;\n+         end if;\n \n-         Write_Mechanism (Mechanism (Form));\n-         Write_Eol;\n          Next_Formal (Form);\n       end loop;\n \n-      if Etype (Ent) /= Standard_Void_Type then\n-         Write_Str (\"returns by \");\n-         Write_Mechanism (Mechanism (Ent));\n+      if List_Representation_Info_To_JSON then\n          Write_Eol;\n+         Write_Str (\"  ]\");\n+      end if;\n+\n+      if Etype (Ent) /= Standard_Void_Type then\n+         if List_Representation_Info_To_JSON then\n+            Write_Line (\",\");\n+            Write_Str (\"  \"\"mechanism\"\": \"\"\");\n+            Write_Mechanism (Mechanism (Ent));\n+            Write_Str (\"\"\"\");\n+         else\n+            Write_Str (\"returns by \");\n+            Write_Mechanism (Mechanism (Ent));\n+            Write_Eol;\n+         end if;\n       end if;\n \n       if not Is_Entry (Ent) then\n          List_Linker_Section (Ent);\n       end if;\n+\n+      if List_Representation_Info_To_JSON then\n+         Write_Eol;\n+         Write_Line (\"}\");\n+      end if;\n    end List_Mechanisms;\n \n    ---------------\n@@ -846,7 +980,14 @@ package body Repinfo is\n \n    procedure List_Name (Ent : Entity_Id) is\n    begin\n-      if not Is_Compilation_Unit (Scope (Ent)) then\n+      --  List the qualified name recursively, except\n+      --  at compilation unit level in default mode.\n+\n+      if Is_Compilation_Unit (Ent) then\n+         null;\n+      elsif not Is_Compilation_Unit (Scope (Ent))\n+        or else List_Representation_Info_To_JSON\n+      then\n          List_Name (Scope (Ent));\n          Write_Char ('.');\n       end if;\n@@ -864,19 +1005,40 @@ package body Repinfo is\n    begin\n       Blank_Line;\n \n-      Write_Str (\"for \");\n-      List_Name (Ent);\n-      Write_Str (\"'Size use \");\n-      Write_Val (Esize (Ent));\n-      Write_Line (\";\");\n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\"{\");\n+\n+         Write_Str (\"  \"\"name\"\": \"\"\");\n+         List_Name (Ent);\n+         Write_Line (\"\"\",\");\n+         List_Location (Ent);\n \n-      Write_Str (\"for \");\n-      List_Name (Ent);\n-      Write_Str (\"'Alignment use \");\n-      Write_Val (Alignment (Ent));\n-      Write_Line (\";\");\n+         Write_Str (\"  \"\"Size\"\": \");\n+         Write_Val (Esize (Ent));\n+         Write_Line (\",\");\n \n-      List_Linker_Section (Ent);\n+         Write_Str (\"  \"\"Alignment\"\": \");\n+         Write_Val (Alignment (Ent));\n+\n+         List_Linker_Section (Ent);\n+\n+         Write_Eol;\n+         Write_Line (\"}\");\n+      else\n+         Write_Str (\"for \");\n+         List_Name (Ent);\n+         Write_Str (\"'Size use \");\n+         Write_Val (Esize (Ent));\n+         Write_Line (\";\");\n+\n+         Write_Str (\"for \");\n+         List_Name (Ent);\n+         Write_Str (\"'Alignment use \");\n+         Write_Val (Alignment (Ent));\n+         Write_Line (\";\");\n+\n+         List_Linker_Section (Ent);\n+      end if;\n    end List_Object_Info;\n \n    ----------------------\n@@ -895,7 +1057,8 @@ package body Repinfo is\n         (Ent                : Entity_Id;\n          Starting_Position  : Uint := Uint_0;\n          Starting_First_Bit : Uint := Uint_0;\n-         Prefix             : String := \"\");\n+         Prefix             : String := \"\";\n+         Indent             : Natural := 0);\n       --  Procedure to display the layout of a single component\n \n       procedure List_Record_Layout\n@@ -905,6 +1068,12 @@ package body Repinfo is\n          Prefix             : String := \"\");\n       --  Internal recursive procedure to display the layout\n \n+      procedure List_Structural_Record_Layout\n+        (Ent     : Entity_Id;\n+         Variant : Node_Id := Empty;\n+         Indent  : Natural := 0);\n+      --  Internal recursive procedure to display the structural layout\n+\n       Max_Name_Length : Natural := 0;\n       Max_Spos_Length : Natural := 0;\n \n@@ -1017,7 +1186,8 @@ package body Repinfo is\n         (Ent                : Entity_Id;\n          Starting_Position  : Uint := Uint_0;\n          Starting_First_Bit : Uint := Uint_0;\n-         Prefix             : String := \"\")\n+         Prefix             : String := \"\";\n+         Indent             : Natural := 0)\n       is\n          Esiz  : constant Uint := Esize (Ent);\n          Npos  : constant Uint := Normalized_Position (Ent);\n@@ -1027,11 +1197,23 @@ package body Repinfo is\n          Lbit  : Uint;\n \n       begin\n-         Write_Str (\"   \");\n-         Write_Str (Prefix);\n-         Write_Str (Name_Buffer (1 .. Name_Len));\n-         Spaces (Max_Name_Length - Prefix'Length - Name_Len);\n-         Write_Str (\" at \");\n+         if List_Representation_Info_To_JSON then\n+            Spaces (Indent);\n+            Write_Line (\"    {\");\n+            Spaces (Indent);\n+            Write_Str (\"      \"\"name\"\": \"\"\");\n+            Write_Str (Prefix);\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n+            Write_Line (\"\"\",\");\n+            Spaces (Indent);\n+            Write_Str (\"      \"\"Position\"\": \");\n+         else\n+            Write_Str (\"   \");\n+            Write_Str (Prefix);\n+            Write_Str (Name_Buffer (1 .. Name_Len));\n+            Spaces (Max_Name_Length - Prefix'Length - Name_Len);\n+            Write_Str (\" at \");\n+         end if;\n \n          if Known_Static_Normalized_Position (Ent) then\n             Spos := Starting_Position  + Npos;\n@@ -1061,15 +1243,29 @@ package body Repinfo is\n             Write_Unknown_Val;\n          end if;\n \n-         Write_Str (\" range  \");\n+         if List_Representation_Info_To_JSON then\n+            Write_Line (\",\");\n+            Spaces (Indent);\n+            Write_Str (\"      \"\"First_Bit\"\": \");\n+         else\n+            Write_Str (\" range  \");\n+         end if;\n+\n          Sbit := Starting_First_Bit + Fbit;\n \n          if Sbit >= SSU then\n             Sbit := Sbit - SSU;\n          end if;\n \n          UI_Write (Sbit);\n-         Write_Str (\" .. \");\n+\n+         if List_Representation_Info_To_JSON then\n+            Write_Line (\", \");\n+            Spaces (Indent);\n+            Write_Str (\"      \"\"Size\"\": \");\n+         else\n+            Write_Str (\" .. \");\n+         end if;\n \n          --  Allowing Uint_0 here is an annoying special case. Really\n          --  this should be a fine Esize value but currently it means\n@@ -1082,11 +1278,15 @@ package body Repinfo is\n          then\n             Lbit := Sbit + Esiz - 1;\n \n-            if Lbit < 10 then\n-               Write_Char (' ');\n-            end if;\n+            if List_Representation_Info_To_JSON then\n+               UI_Write (Esiz);\n+            else\n+               if Lbit < 10 then\n+                  Write_Char (' ');\n+               end if;\n \n-            UI_Write (Lbit);\n+               UI_Write (Lbit);\n+            end if;\n \n          --  The test for Esize (Ent) not Uint_0 here is an annoying\n          --  special case. Officially a value of zero for Esize means\n@@ -1102,7 +1302,7 @@ package body Repinfo is\n          --  List_Representation >= 3 and Known_Esize (Ent)\n \n          else\n-            Write_Val (Esiz, Paren => True);\n+            Write_Val (Esiz, Paren => not List_Representation_Info_To_JSON);\n \n             --  If in front end layout mode, then dynamic size is stored\n             --  in storage units, so renormalize for output\n@@ -1114,19 +1314,27 @@ package body Repinfo is\n \n             --  Add appropriate first bit offset\n \n-            if Sbit = 0 then\n-               Write_Str (\" - 1\");\n+            if not List_Representation_Info_To_JSON then\n+               if Sbit = 0 then\n+                  Write_Str (\" - 1\");\n \n-            elsif Sbit = 1 then\n-               null;\n+               elsif Sbit = 1 then\n+                  null;\n \n-            else\n-               Write_Str (\" + \");\n-               Write_Int (UI_To_Int (Sbit) - 1);\n+               else\n+                  Write_Str (\" + \");\n+                  Write_Int (UI_To_Int (Sbit) - 1);\n+               end if;\n             end if;\n          end if;\n \n-         Write_Line (\";\");\n+         if List_Representation_Info_To_JSON then\n+            Write_Eol;\n+            Spaces (Indent);\n+            Write_Str (\"    }\");\n+         else\n+            Write_Line (\";\");\n+         end if;\n       end List_Component_Layout;\n \n       ------------------------\n@@ -1203,15 +1411,180 @@ package body Repinfo is\n          end loop;\n       end List_Record_Layout;\n \n+      -----------------------------------\n+      -- List_Structural_Record_Layout --\n+      -----------------------------------\n+\n+      procedure List_Structural_Record_Layout\n+        (Ent     : Entity_Id;\n+         Variant : Node_Id := Empty;\n+         Indent  : Natural := 0)\n+      is\n+         Comp       : Node_Id;\n+         Comp_List  : Node_Id;\n+         Var        : Node_Id;\n+         First      : Boolean := True;\n+\n+      begin\n+         --  If we are dealing with a variant, just process the components\n+\n+         if Present (Variant) then\n+            Comp_List := Component_List (Variant);\n+\n+         --  Otherwise, we are dealing with the full record and need to get\n+         --  to its definition in order to retrieve its structural layout.\n+\n+         else\n+            declare\n+               Definition : Node_Id :=\n+                 Type_Definition (Declaration_Node (Ent));\n+               Is_Extension : constant Boolean :=\n+                 Is_Tagged_Type (Ent)\n+                   and then\n+                 Nkind (Definition) = N_Derived_Type_Definition;\n+               Disc : Entity_Id;\n+            begin\n+               --  If this is an extension, first list the layout of the parent\n+               --  and then proceed to the extension part, if any.\n+\n+               if Is_Extension then\n+                  List_Structural_Record_Layout\n+                    (Base_Type (Parent_Subtype (Ent)), Variant, Indent);\n+\n+                  if Present (Record_Extension_Part (Definition)) then\n+                     Definition := Record_Extension_Part (Definition);\n+                  end if;\n+               end if;\n+\n+               --  If the record has discriminants and is not an unchecked\n+               --  union, then display them now.\n+\n+               if Has_Discriminants (Ent)\n+                 and then not Is_Unchecked_Union (Ent)\n+               then\n+                  Disc := First_Stored_Discriminant (Ent);\n+                  while Present (Disc) loop\n+\n+                     --  If this is a record extension and the discriminant is\n+                     --  the renaming of another discriminant, skip it.\n+\n+                     if Is_Extension\n+                       and then Present (Corresponding_Discriminant (Disc))\n+                     then\n+                        goto Continue_Disc;\n+                     end if;\n+\n+                     Get_Decoded_Name_String (Chars (Disc));\n+                     Set_Casing (Unit_Casing);\n+\n+                     if First then\n+                        Write_Eol;\n+                        First := False;\n+                     else\n+                        Write_Line (\",\");\n+                     end if;\n+\n+                     List_Component_Layout (Disc, Indent => Indent);\n+\n+                  <<Continue_Disc>>\n+                     Next_Stored_Discriminant (Disc);\n+                  end loop;\n+               end if;\n+\n+               Comp_List := Component_List (Definition);\n+            end;\n+         end if;\n+\n+         --  Bail out for the null record\n+\n+         if No (Comp_List) then\n+            return;\n+         end if;\n+\n+         --  Now deal with the regular components, if any\n+\n+         if Present (Component_Items (Comp_List)) then\n+            Comp := First_Non_Pragma (Component_Items (Comp_List));\n+            while Present (Comp) loop\n+\n+               --  Skip _Parent component in extension (to avoid overlap)\n+\n+               if Chars (Defining_Identifier (Comp)) = Name_uParent then\n+                  goto Continue_Comp;\n+               end if;\n+\n+               Get_Decoded_Name_String (Chars (Defining_Identifier (Comp)));\n+               Set_Casing (Unit_Casing);\n+\n+               if First then\n+                  Write_Eol;\n+                  First := False;\n+               else\n+                  Write_Line (\",\");\n+               end if;\n+\n+               List_Component_Layout\n+                 (Defining_Identifier (Comp), Indent => Indent);\n+\n+            <<Continue_Comp>>\n+               Next_Non_Pragma (Comp);\n+            end loop;\n+         end if;\n+\n+         --  We are done if there is no variant part\n+\n+         if No (Variant_Part (Comp_List)) then\n+            return;\n+         end if;\n+\n+         Write_Eol;\n+         Spaces (Indent);\n+         Write_Line (\"  ],\");\n+         Spaces (Indent);\n+         Write_Str (\"  \"\"variant\"\" : [\");\n+\n+         --  Otherwise we recurse on each variant\n+\n+         Var := First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n+         First := True;\n+         while Present (Var) loop\n+            if First then\n+               Write_Eol;\n+               First := False;\n+            else\n+               Write_Line (\",\");\n+            end if;\n+\n+            Spaces (Indent);\n+            Write_Line (\"    {\");\n+            Spaces (Indent);\n+            Write_Str (\"      \"\"present\"\": \");\n+            Write_Val (Present_Expr (Var));\n+            Write_Line (\",\");\n+            Spaces (Indent);\n+            Write_Str (\"      \"\"record\"\": [\");\n+\n+            List_Structural_Record_Layout (Ent, Var, Indent + 4);\n+\n+            Write_Eol;\n+            Spaces (Indent);\n+            Write_Line (\"      ]\");\n+            Spaces (Indent);\n+            Write_Str (\"    }\");\n+            Next_Non_Pragma (Var);\n+         end loop;\n+      end List_Structural_Record_Layout;\n+\n    --  Start of processing for List_Record_Info\n \n    begin\n       Blank_Line;\n-      List_Type_Info (Ent);\n \n-      Write_Str (\"for \");\n-      List_Name (Ent);\n-      Write_Line (\" use record\");\n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\"{\");\n+      end if;\n+\n+      List_Type_Info (Ent);\n \n       --  First find out max line length and max starting position\n       --  length, for the purpose of lining things up nicely.\n@@ -1220,13 +1593,32 @@ package body Repinfo is\n \n       --  Then do actual output based on those values\n \n-      List_Record_Layout (Ent);\n+      if List_Representation_Info_To_JSON then\n+         Write_Line (\",\");\n+         Write_Str (\"  \"\"record\"\": [\");\n+\n+         List_Structural_Record_Layout (Ent);\n+\n+         Write_Eol;\n+         Write_Str (\"  ]\");\n+      else\n+         Write_Str (\"for \");\n+         List_Name (Ent);\n+         Write_Line (\" use record\");\n+\n+         List_Record_Layout (Ent);\n \n-      Write_Line (\"end record;\");\n+         Write_Line (\"end record;\");\n+      end if;\n \n       List_Scalar_Storage_Order (Ent, Bytes_Big_Endian);\n \n       List_Linker_Section (Ent);\n+\n+      if List_Representation_Info_To_JSON then\n+         Write_Eol;\n+         Write_Line (\"}\");\n+      end if;\n    end List_Record_Info;\n \n    -------------------\n@@ -1246,7 +1638,9 @@ package body Repinfo is\n \n                --  Normal case, list to standard output\n \n-               if not List_Representation_Info_To_File then\n+               if not List_Representation_Info_To_File\n+                 and then not List_Representation_Info_To_JSON\n+               then\n                   Write_Eol;\n                   Write_Str (\"Representation information for unit \");\n                   Write_Unit_Name (Unit_Name (U));\n@@ -1294,17 +1688,27 @@ package body Repinfo is\n \n       procedure List_Attr (Attr_Name : String; Is_Reversed : Boolean) is\n       begin\n-         Write_Str (\"for \");\n-         List_Name (Ent);\n-         Write_Str (\"'\" & Attr_Name & \" use System.\");\n+         if List_Representation_Info_To_JSON then\n+            Write_Line (\",\");\n+            Write_Str (\"  \"\"\" & Attr_Name & \"\"\": \"\"System.\");\n+         else\n+            Write_Str (\"for \");\n+            List_Name (Ent);\n+            Write_Str (\"'\" & Attr_Name & \" use System.\");\n+         end if;\n \n          if Bytes_Big_Endian xor Is_Reversed then\n             Write_Str (\"High\");\n          else\n             Write_Str (\"Low\");\n          end if;\n \n-         Write_Line (\"_Order_First;\");\n+         Write_Str (\"_Order_First\");\n+         if List_Representation_Info_To_JSON then\n+            Write_Str (\"\"\"\");\n+         else\n+            Write_Line (\";\");\n+         end if;\n       end List_Attr;\n \n       List_SSO : constant Boolean :=\n@@ -1342,6 +1746,13 @@ package body Repinfo is\n \n    procedure List_Type_Info (Ent : Entity_Id) is\n    begin\n+      if List_Representation_Info_To_JSON then\n+         Write_Str (\"  \"\"name\"\": \"\"\");\n+         List_Name (Ent);\n+         Write_Line (\"\"\",\");\n+         List_Location (Ent);\n+      end if;\n+\n       --  Do not list size info for unconstrained arrays, not meaningful\n \n       if Is_Array_Type (Ent) and then not Is_Constrained (Ent) then\n@@ -1352,46 +1763,74 @@ package body Repinfo is\n          --  case, which we may as well list in simple form.\n \n          if Esize (Ent) = RM_Size (Ent) then\n-            Write_Str (\"for \");\n-            List_Name (Ent);\n-            Write_Str (\"'Size use \");\n-            Write_Val (Esize (Ent));\n-            Write_Line (\";\");\n+            if List_Representation_Info_To_JSON then\n+               Write_Str (\"  \"\"Size\"\": \");\n+               Write_Val (Esize (Ent));\n+               Write_Line (\",\");\n+            else\n+               Write_Str (\"for \");\n+               List_Name (Ent);\n+               Write_Str (\"'Size use \");\n+               Write_Val (Esize (Ent));\n+               Write_Line (\";\");\n+            end if;\n \n          --  Otherwise list size values separately\n \n          else\n-            Write_Str (\"for \");\n-            List_Name (Ent);\n-            Write_Str (\"'Object_Size use \");\n-            Write_Val (Esize (Ent));\n-            Write_Line (\";\");\n+            if List_Representation_Info_To_JSON then\n+               Write_Str (\"  \"\"Object_Size\"\": \");\n+               Write_Val (Esize (Ent));\n+               Write_Line (\",\");\n \n-            Write_Str (\"for \");\n-            List_Name (Ent);\n-            Write_Str (\"'Value_Size use \");\n-            Write_Val (RM_Size (Ent));\n-            Write_Line (\";\");\n+               Write_Str (\"  \"\"Value_Size\"\": \");\n+               Write_Val (RM_Size (Ent));\n+               Write_Line (\",\");\n+\n+            else\n+               Write_Str (\"for \");\n+               List_Name (Ent);\n+               Write_Str (\"'Object_Size use \");\n+               Write_Val (Esize (Ent));\n+               Write_Line (\";\");\n+\n+               Write_Str (\"for \");\n+               List_Name (Ent);\n+               Write_Str (\"'Value_Size use \");\n+               Write_Val (RM_Size (Ent));\n+               Write_Line (\";\");\n+            end if;\n          end if;\n       end if;\n \n-      Write_Str (\"for \");\n-      List_Name (Ent);\n-      Write_Str (\"'Alignment use \");\n-      Write_Val (Alignment (Ent));\n-      Write_Line (\";\");\n+      if List_Representation_Info_To_JSON then\n+         Write_Str (\"  \"\"Alignment\"\": \");\n+         Write_Val (Alignment (Ent));\n+      else\n+         Write_Str (\"for \");\n+         List_Name (Ent);\n+         Write_Str (\"'Alignment use \");\n+         Write_Val (Alignment (Ent));\n+         Write_Line (\";\");\n+      end if;\n \n       --  Special stuff for fixed-point\n \n       if Is_Fixed_Point_Type (Ent) then\n \n          --  Write small (always a static constant)\n \n-         Write_Str (\"for \");\n-         List_Name (Ent);\n-         Write_Str (\"'Small use \");\n-         UR_Write (Small_Value (Ent));\n-         Write_Line (\";\");\n+         if List_Representation_Info_To_JSON then\n+            Write_Line (\",\");\n+            Write_Str (\"  \"\"Small\"\": \");\n+            UR_Write (Small_Value (Ent));\n+         else\n+            Write_Str (\"for \");\n+            List_Name (Ent);\n+            Write_Str (\"'Small use \");\n+            UR_Write (Small_Value (Ent));\n+            Write_Line (\";\");\n+         end if;\n \n          --  Write range if static\n \n@@ -1403,13 +1842,22 @@ package body Repinfo is\n                  and then\n                Nkind (High_Bound (R)) = N_Real_Literal\n             then\n-               Write_Str (\"for \");\n-               List_Name (Ent);\n-               Write_Str (\"'Range use \");\n-               UR_Write (Realval (Low_Bound (R)));\n-               Write_Str (\" .. \");\n-               UR_Write (Realval (High_Bound (R)));\n-               Write_Line (\";\");\n+               if List_Representation_Info_To_JSON then\n+                  Write_Line (\",\");\n+                  Write_Str (\"  \"\"Range\"\": [ \");\n+                  UR_Write (Realval (Low_Bound (R)));\n+                  Write_Str (\", \");\n+                  UR_Write (Realval (High_Bound (R)));\n+                  Write_Str (\" ]\");\n+               else\n+                  Write_Str (\"for \");\n+                  List_Name (Ent);\n+                  Write_Str (\"'Range use \");\n+                  UR_Write (Realval (Low_Bound (R)));\n+                  Write_Str (\" .. \");\n+                  UR_Write (Realval (High_Bound (R)));\n+                  Write_Line (\";\");\n+               end if;\n             end if;\n          end;\n       end if;\n@@ -1695,7 +2143,11 @@ package body Repinfo is\n \n    procedure Write_Unknown_Val is\n    begin\n-      Write_Str (\"??\");\n+      if List_Representation_Info_To_JSON then\n+         Write_Str (\"\"\"??\"\"\");\n+      else\n+         Write_Str (\"??\");\n+      end if;\n    end Write_Unknown_Val;\n \n    ---------------"}, {"sha": "477ac0ead295bb91a90d18add9a6fe11c5c57bef", "filename": "gcc/ada/repinfo.ads", "status": "modified", "additions": 125, "deletions": 30, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Frepinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Frepinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.ads?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -141,48 +141,143 @@ package Repinfo is\n    --  tree.def. Only a subset of these tree codes can actually appear.\n    --  The names are the names from tree.def in Ada casing.\n \n-   --  name                             code   description           operands\n-\n-   Cond_Expr        : constant TCode :=  1; -- conditional              3\n-   Plus_Expr        : constant TCode :=  2; -- addition                 2\n-   Minus_Expr       : constant TCode :=  3; -- subtraction              2\n-   Mult_Expr        : constant TCode :=  4; -- multiplication           2\n-   Trunc_Div_Expr   : constant TCode :=  5; -- truncating division      2\n-   Ceil_Div_Expr    : constant TCode :=  6; -- division rounding up     2\n-   Floor_Div_Expr   : constant TCode :=  7; -- division rounding down   2\n-   Trunc_Mod_Expr   : constant TCode :=  8; -- mod for trunc_div        2\n-   Ceil_Mod_Expr    : constant TCode :=  9; -- mod for ceil_div         2\n-   Floor_Mod_Expr   : constant TCode := 10; -- mod for floor_div        2\n-   Exact_Div_Expr   : constant TCode := 11; -- exact division           2\n-   Negate_Expr      : constant TCode := 12; -- negation                 1\n-   Min_Expr         : constant TCode := 13; -- minimum                  2\n-   Max_Expr         : constant TCode := 14; -- maximum                  2\n-   Abs_Expr         : constant TCode := 15; -- absolute value           1\n-   Truth_And_Expr   : constant TCode := 16; -- boolean and              2\n-   Truth_Or_Expr    : constant TCode := 17; -- boolean or               2\n-   Truth_Xor_Expr   : constant TCode := 18; -- boolean xor              2\n-   Truth_Not_Expr   : constant TCode := 19; -- boolean not              1\n-   Lt_Expr          : constant TCode := 20; -- comparison <             2\n-   Le_Expr          : constant TCode := 21; -- comparison <=            2\n-   Gt_Expr          : constant TCode := 22; -- comparison >             2\n-   Ge_Expr          : constant TCode := 23; -- comparison >=            2\n-   Eq_Expr          : constant TCode := 24; -- comparison =             2\n-   Ne_Expr          : constant TCode := 25; -- comparison /=            2\n-   Bit_And_Expr     : constant TCode := 26; -- bitwise and              2\n+   --  name                             code   description     operands  symbol\n+\n+   Cond_Expr        : constant TCode :=  1; -- conditional          3      ?<>\n+   Plus_Expr        : constant TCode :=  2; -- addition             2        +\n+   Minus_Expr       : constant TCode :=  3; -- subtraction          2        -\n+   Mult_Expr        : constant TCode :=  4; -- multiplication       2        *\n+   Trunc_Div_Expr   : constant TCode :=  5; -- truncating div       2       /t\n+   Ceil_Div_Expr    : constant TCode :=  6; -- div rounding up      2       /c\n+   Floor_Div_Expr   : constant TCode :=  7; -- div rounding down    2       /f\n+   Trunc_Mod_Expr   : constant TCode :=  8; -- mod for trunc_div    2     modt\n+   Ceil_Mod_Expr    : constant TCode :=  9; -- mod for ceil_div     2     modc\n+   Floor_Mod_Expr   : constant TCode := 10; -- mod for floor_div    2     modf\n+   Exact_Div_Expr   : constant TCode := 11; -- exact div            2       /e\n+   Negate_Expr      : constant TCode := 12; -- negation             1        -\n+   Min_Expr         : constant TCode := 13; -- minimum              2      min\n+   Max_Expr         : constant TCode := 14; -- maximum              2      max\n+   Abs_Expr         : constant TCode := 15; -- absolute value       1      abs\n+   Truth_And_Expr   : constant TCode := 16; -- boolean and          2      and\n+   Truth_Or_Expr    : constant TCode := 17; -- boolean or           2       or\n+   Truth_Xor_Expr   : constant TCode := 18; -- boolean xor          2      xor\n+   Truth_Not_Expr   : constant TCode := 19; -- boolean not          1      not\n+   Lt_Expr          : constant TCode := 20; -- comparison <         2        <\n+   Le_Expr          : constant TCode := 21; -- comparison <=        2       <=\n+   Gt_Expr          : constant TCode := 22; -- comparison >         2        >\n+   Ge_Expr          : constant TCode := 23; -- comparison >=        2       >=\n+   Eq_Expr          : constant TCode := 24; -- comparison =         2       ==\n+   Ne_Expr          : constant TCode := 25; -- comparison /=        2       !=\n+   Bit_And_Expr     : constant TCode := 26; -- bitwise and          2        &\n \n    --  The following entry is used to represent a discriminant value in\n    --  the tree. It has a special tree code that does not correspond\n    --  directly to a GCC node. The single operand is the index number\n    --  of the discriminant in the record (1 = first discriminant).\n \n-   Discrim_Val      : constant TCode :=  0;  -- discriminant value      1\n+   Discrim_Val      : constant TCode :=  0;  -- discriminant value  1        #\n \n    --  The following entry is used to represent a value not known at\n    --  compile time in the tree, other than a discriminant value. It\n    --  has a special tree code that does not correspond directly to\n    --  a GCC node. The single operand is an arbitrary index number.\n \n-   Dynamic_Val      : constant TCode := 27;  -- dynamic value           1\n+   Dynamic_Val      : constant TCode := 27;  -- dynamic value       1      var\n+\n+   ----------------------------\n+   -- The JSON output format --\n+   ----------------------------\n+\n+   --  The representation information can be output to a file in the JSON\n+   --  data interchange format specified by the ECMA-404 standard. In the\n+   --  following description, the terminology is that of the JSON syntax\n+   --  from the ECMA document and of the JSON grammar from www.json.org.\n+\n+   --  The output is a concatenation of entities\n+\n+   --  An entity is an object whose members are pairs taken from:\n+\n+   --    \"name\"                 :  string\n+   --    \"location\"             :  string\n+   --    \"record\"               :  array of components\n+   --    \"variant\"              :  array of variants\n+   --    \"formal\"               :  array of formal parameters\n+   --    \"mechanism\"            :  string\n+   --    \"Size\"                 :  numerical expression\n+   --    \"Object_Size\"          :  numerical expression\n+   --    \"Value_Size\"           :  numerical expression\n+   --    \"Component_Size\"       :  numerical expression\n+   --    \"Range\"                :  array of numbers\n+   --    \"Small\"                :  number\n+   --    \"Alignment\"            :  number\n+   --    \"Convention\"           :  string\n+   --    \"Linker_Section\"       :  string\n+   --    \"Bit_Order\"            :  string\n+   --    \"Scalar_Storage_Order\" :  string\n+\n+   --    \"name\" and \"location\" are present for every entity and come from the\n+   --    declaration of the associated Ada entity. The value of \"name\" is the\n+   --    fully qualified Ada name. The value of \"location\" is the expanded\n+   --    chain of instantiation locations that contains the entity.\n+   --    \"record\" is present for every record type and its value is the list of\n+   --    components. \"variant\" is present only if the record type has a variant\n+   --    part and its value is the list of variants.\n+   --    \"formal\" is present for every subprogram and entry, and its value is\n+   --    the list of formal parameters. \"mechanism\" is present for functions\n+   --    only and its value is the return mechanim.\n+   --    The other pairs may be present when the eponymous aspect/attribute is\n+   --    defined for the Ada entity, and their value is set by the language.\n+\n+   --  A component is an object whose members are pairs taken from:\n+\n+   --    \"name\"                 :  string\n+   --    \"Position\"             :  numerical expression\n+   --    \"First_Bit\"            :  number\n+   --    \"Size\"                 :  numerical expression\n+\n+   --    The four pairs are present for every component. \"name\" comes from the\n+   --    declaration of the component in the record type and its value is the\n+   --    unqualified Ada name. The other three pairs come from the layout of\n+   --    the type and their value is that of the eponymous attribute set by\n+   --    the language.\n+\n+   --  A variant is an object whose members are pairs taken from:\n+\n+   --    \"present\"              :  numerical expression\n+   --    \"record\"               :  array of components\n+   --    \"variant\"              :  array of variants\n+\n+   --    \"present\" and \"record\" are present for every variant. The value of\n+   --    \"present\" is a boolean expression that evaluates to true when the\n+   --    components of the variant are contained in the record type and to\n+   --    false when they are not. The value of \"record\" is the list of\n+   --    components in the variant. \"variant\" is present only if the variant\n+   --    itself has a variant part and its value is the list of (sub)variants.\n+\n+   --  A formal parameter is an object whose members are pairs taken from:\n+\n+   --    \"name\"                 :  string\n+   --    \"mechanism\"            :  string\n+\n+   --    The two pairs are present for every formal parameter. \"name\" comes\n+   --    from the declaration of the parameter in the subprogram or entry\n+   --    and its value is the unqualified Ada name. The value of \"mechanism\"\n+   --    is the passing mechanism for the parameter set by the language.\n+\n+   --  A numerical expression is either a number or an object whose members\n+   --  are pairs taken from:\n+\n+   --    \"code\"                 :  string\n+   --    \"operands\"             :  array of numerical expressions\n+\n+   --    The two pairs are present for every such object. The value of \"code\"\n+   --    is a symbol taken from the table defining the TCode type above. The\n+   --    number of elements of the value of \"operands\" is specified by the\n+   --    operands column in the line associated with the symbol in the table.\n+\n+   --    As documented above, the full back annotation is only done in -gnatR3\n+   --    or ASIS mode. In the other cases, if the numerical expression is not\n+   --    a number, then it is replaced with the \"??\" string.\n \n    ------------------------\n    -- The gigi Interface --"}, {"sha": "be8fb61e50c61f9e97985cecef5370faa2e2bb0f", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -1211,6 +1211,9 @@ package body Switch.C is\n                   when 's' =>\n                      List_Representation_Info_To_File := True;\n \n+                  when 'j' =>\n+                     List_Representation_Info_To_JSON := True;\n+\n                   when 'm' =>\n                      List_Representation_Info_Mechanisms := True;\n \n@@ -1224,6 +1227,14 @@ package body Switch.C is\n                   Ptr := Ptr + 1;\n                end loop;\n \n+               if List_Representation_Info_To_JSON then\n+                  if List_Representation_Info_To_File then\n+                     Osint.Fail (\"-gnatRs is incompatible with -gnatRj\");\n+                  elsif List_Representation_Info_Extended then\n+                     Osint.Fail (\"-gnatRe is incompatible with -gnatRj\");\n+                  end if;\n+               end if;\n+\n             --  -gnats (syntax check only)\n \n             when 's' =>"}, {"sha": "a07629e0e0146d6530aae981bde0db9cf01b2abf", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7629b8a2f2b05194ab8bc3878f6f841666a289/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=1e7629b8a2f2b05194ab8bc3878f6f841666a289", "patch": "@@ -405,6 +405,8 @@ begin\n      (\"List rep info (?=0/1/2/3/e/m for none/types/all/symbolic/ext/mech)\");\n    Write_Switch_Char (\"R?s\");\n    Write_Line (\"List rep info to file.rep instead of standard output\");\n+   Write_Switch_Char (\"R?j\");\n+   Write_Line (\"List rep info to file.json instead of standard output\");\n \n    --  Line for -gnats switch\n "}]}