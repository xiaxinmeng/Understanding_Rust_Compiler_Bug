{"sha": "eb63c01f65d475f7f05d1979f66c1c41faa61da9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2M2MwMWY2NWQ0NzVmN2YwNWQxOTc5ZjY2YzFjNDFmYWE2MWRhOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-05-18T08:43:19Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-05-18T08:43:19Z"}, "message": "Radically simplify emission of balanced tree for switch statements.\n\n2018-05-18  Martin Liska  <mliska@suse.cz>\n\n\t* passes.def: Add pass_lower_switch and pass_lower_switch_O0.\n\t* tree-pass.h (make_pass_lower_switch_O0): New function.\n\t* tree-switch-conversion.c (node_has_low_bound): Remove.\n\t(node_has_high_bound): Likewise.\n\t(node_is_bounded): Likewise.\n\t(class pass_lower_switch): Make it a template type and create\n\ttwo instances.\n\t(pass_lower_switch::execute): Add template argument.\n\t(make_pass_lower_switch): New function.\n\t(make_pass_lower_switch_O0): New function.\n\t(do_jump_if_equal): Remove.\n\t(emit_case_nodes): Simplify to just handle all 3 cases and leave\n\tall the hard work to tree optimization passes.\n2018-05-18  Martin Liska  <mliska@suse.cz>\n\n\t* gcc.dg/tree-ssa/vrp104.c: Adjust dump file that is scanned.\n\t* gcc.dg/tree-prof/update-loopch.c: Likewise.\n\nFrom-SVN: r260350", "tree": {"sha": "853a097da531ab040ed871970f5fac8cc27d09cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/853a097da531ab040ed871970f5fac8cc27d09cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb63c01f65d475f7f05d1979f66c1c41faa61da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb63c01f65d475f7f05d1979f66c1c41faa61da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb63c01f65d475f7f05d1979f66c1c41faa61da9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb63c01f65d475f7f05d1979f66c1c41faa61da9/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cdc3b88343e3a306c37ddec9f6b546d412c6f3f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc3b88343e3a306c37ddec9f6b546d412c6f3f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdc3b88343e3a306c37ddec9f6b546d412c6f3f8"}], "stats": {"total": 633, "additions": 93, "deletions": 540}, "files": [{"sha": "8215995cb1427bc7c10237219a50b1519b6364e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -1,3 +1,19 @@\n+2018-05-18  Martin Liska  <mliska@suse.cz>\n+\n+\t* passes.def: Add pass_lower_switch and pass_lower_switch_O0.\n+\t* tree-pass.h (make_pass_lower_switch_O0): New function.\n+\t* tree-switch-conversion.c (node_has_low_bound): Remove.\n+\t(node_has_high_bound): Likewise.\n+\t(node_is_bounded): Likewise.\n+\t(class pass_lower_switch): Make it a template type and create\n+\ttwo instances.\n+\t(pass_lower_switch::execute): Add template argument.\n+\t(make_pass_lower_switch): New function.\n+\t(make_pass_lower_switch_O0): New function.\n+\t(do_jump_if_equal): Remove.\n+\t(emit_case_nodes): Simplify to just handle all 3 cases and leave\n+\tall the hard work to tree optimization passes.\n+\n 2018-05-18  Martin Liska  <mliska@suse.cz>\n \n \t* dbgcnt.c (limit_low): Renamed from limit."}, {"sha": "050009464ea9c0ead51fdfa3c0a66adb2c42837a", "filename": "gcc/passes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -317,6 +317,7 @@ along with GCC; see the file COPYING3.  If not see\n       POP_INSERT_PASSES ()\n       NEXT_PASS (pass_simduid_cleanup);\n       NEXT_PASS (pass_lower_vector_ssa);\n+      NEXT_PASS (pass_lower_switch);\n       NEXT_PASS (pass_cse_reciprocals);\n       NEXT_PASS (pass_sprintf_length, true);\n       NEXT_PASS (pass_reassoc, false /* insert_powi_p */);\n@@ -362,6 +363,7 @@ along with GCC; see the file COPYING3.  If not see\n       /* Lower remaining pieces of GIMPLE.  */\n       NEXT_PASS (pass_lower_complex);\n       NEXT_PASS (pass_lower_vector_ssa);\n+      NEXT_PASS (pass_lower_switch);\n       /* Perform simple scalar cleanup which is constant/copy propagation.  */\n       NEXT_PASS (pass_ccp, true /* nonzero_p */);\n       NEXT_PASS (pass_post_ipa_warn);\n@@ -397,6 +399,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_lower_vaarg);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_lower_complex_O0);\n+  NEXT_PASS (pass_lower_switch_O0);\n   NEXT_PASS (pass_sancov_O0);\n   NEXT_PASS (pass_lower_switch);\n   NEXT_PASS (pass_asan_O0);"}, {"sha": "765e08cf4c056912409289a7acc092514785ae33", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -1,3 +1,8 @@\n+2018-05-18  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/vrp104.c: Adjust dump file that is scanned.\n+\t* gcc.dg/tree-prof/update-loopch.c: Likewise.\n+\n 2018-05-18  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/ipa/ipa-icf-39.c: New test."}, {"sha": "15baada108112a63a164bafe6afc1bf6864854e2", "filename": "gcc/testsuite/gcc.dg/tree-prof/update-loopch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-ipa-profile-blocks-details -fdump-tree-switchlower-blocks-details\" } */\n+/* { dg-options \"-O2 -fdump-ipa-profile-blocks-details -fdump-tree-switchlower1-blocks-details\" } */\n int max = 33333;\n int a[8];\n int"}, {"sha": "71fa3bfa2cabeeb5e2aeb48ba6455e47d8c96eb9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp104.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -2,7 +2,7 @@\n /* { dg-options \"-O2 -fdump-tree-switchlower\" }  */\n /* We scan for 2 switches as the dump file reports a transformation,\n    IL really contains just a single.  */\n-/* { dg-final { scan-tree-dump-times \"switch \\\\(i_\" 2 \"switchlower\" } }  */\n+/* { dg-final { scan-tree-dump-times \"switch\" 2 \"switchlower1\" } }  */\n \n void foo (void);\n void bar (void);"}, {"sha": "7625d1963ff09210345699c142f576dc3c30ec6c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -413,6 +413,7 @@ extern gimple_opt_pass *make_pass_strip_predict_hints (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_complex_O0 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_complex (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_switch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_lower_switch_O0 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vector (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vector_ssa (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_omp (gcc::context *ctxt);"}, {"sha": "dc60b34f506171015e759df9f44bcd83f1671e5e", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 66, "deletions": 538, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb63c01f65d475f7f05d1979f66c1c41faa61da9/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=eb63c01f65d475f7f05d1979f66c1c41faa61da9", "patch": "@@ -1691,9 +1691,6 @@ typedef case_node *case_node_ptr;\n static basic_block emit_case_nodes (basic_block, tree, case_node_ptr,\n \t\t\t\t    basic_block, tree, profile_probability,\n \t\t\t\t    tree, hash_map<tree, tree> *);\n-static bool node_has_low_bound (case_node_ptr, tree);\n-static bool node_has_high_bound (case_node_ptr, tree);\n-static bool node_is_bounded (case_node_ptr, tree);\n \n /* Return the smallest number of different values for which it is best to use a\n    jump-table instead of a tree of conditional branches.  */\n@@ -2169,10 +2166,31 @@ try_switch_expansion (gswitch *stmt)\n \n namespace {\n \n-const pass_data pass_data_lower_switch =\n+template <bool O0> class pass_lower_switch: public gimple_opt_pass\n {\n-  GIMPLE_PASS, /* type */\n-  \"switchlower\", /* name */\n+public:\n+  pass_lower_switch (gcc::context *ctxt) : gimple_opt_pass (data, ctxt) {}\n+\n+  static const pass_data data;\n+  opt_pass *\n+  clone ()\n+  {\n+    return new pass_lower_switch<O0> (m_ctxt);\n+  }\n+\n+  virtual bool\n+  gate (function *)\n+  {\n+    return !O0 || !optimize;\n+  }\n+\n+  virtual unsigned int execute (function *fun);\n+}; // class pass_lower_switch\n+\n+template <bool O0>\n+const pass_data pass_lower_switch<O0>::data = {\n+  GIMPLE_PASS,\t\t       /* type */\n+  O0 ? \"switchlower_O0\" : \"switchlower\", /* name */\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_TREE_SWITCH_LOWERING, /* tv_id */\n   ( PROP_cfg | PROP_ssa ), /* properties_required */\n@@ -2182,21 +2200,9 @@ const pass_data pass_data_lower_switch =\n   TODO_update_ssa | TODO_cleanup_cfg, /* todo_flags_finish */\n };\n \n-class pass_lower_switch : public gimple_opt_pass\n-{\n-public:\n-  pass_lower_switch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_lower_switch, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return true; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_lower_switch\n-\n+template <bool O0>\n unsigned int\n-pass_lower_switch::execute (function *fun)\n+pass_lower_switch<O0>::execute (function *fun)\n {\n   basic_block bb;\n   bool expanded = false;\n@@ -2234,33 +2240,14 @@ pass_lower_switch::execute (function *fun)\n } // anon namespace\n \n gimple_opt_pass *\n-make_pass_lower_switch (gcc::context *ctxt)\n+make_pass_lower_switch_O0 (gcc::context *ctxt)\n {\n-  return new pass_lower_switch (ctxt);\n+  return new pass_lower_switch<true> (ctxt);\n }\n-\n-/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.\n-   PROB is the probability of jumping to LABEL.  */\n-static basic_block\n-do_jump_if_equal (basic_block bb, tree op0, tree op1, basic_block label_bb,\n-\t\t  profile_probability prob, hash_map<tree, tree> *phi_mapping)\n+gimple_opt_pass *\n+make_pass_lower_switch (gcc::context *ctxt)\n {\n-  gcond *cond = gimple_build_cond (EQ_EXPR, op0, op1, NULL_TREE, NULL_TREE);\n-  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  gsi_insert_before (&gsi, cond, GSI_SAME_STMT);\n-\n-  gcc_assert (single_succ_p (bb));\n-\n-  /* Make a new basic block where false branch will take place.  */\n-  edge false_edge = split_block (bb, cond);\n-  false_edge->flags = EDGE_FALSE_VALUE;\n-  false_edge->probability = prob.invert ();\n-\n-  edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n-  fix_phi_operands_for_edge (true_edge, phi_mapping);\n-  true_edge->probability = prob;\n-\n-  return false_edge->dest;\n+  return new pass_lower_switch<false> (ctxt);\n }\n \n /* Generate code to compare X with Y so that the condition codes are\n@@ -2323,511 +2310,52 @@ conditional_probability (profile_probability target_prob,\n /* Emit step-by-step code to select a case for the value of INDEX.\n    The thus generated decision tree follows the form of the\n    case-node binary tree NODE, whose nodes represent test conditions.\n-   INDEX_TYPE is the type of the index of the switch.\n-\n-   Care is taken to prune redundant tests from the decision tree\n-   by detecting any boundary conditions already checked by\n-   emitted rtx.  (See node_has_high_bound, node_has_low_bound\n-   and node_is_bounded, above.)\n-\n-   Where the test conditions can be shown to be redundant we emit\n-   an unconditional jump to the target code.  As a further\n-   optimization, the subordinates of a tree node are examined to\n-   check for bounded nodes.  In this case conditional and/or\n-   unconditional jumps as a result of the boundary check for the\n-   current node are arranged to target the subordinates associated\n-   code for out of bound conditions on the current node.\n-\n-   We can assume that when control reaches the code generated here,\n-   the index value has already been compared with the parents\n-   of this node, and determined to be on the same side of each parent\n-   as this node is.  Thus, if this node tests for the value 51,\n-   and a parent tested for 52, we don't need to consider\n-   the possibility of a value greater than 51.  If another parent\n-   tests for the value 50, then this node need not test anything.  */\n+   INDEX_TYPE is the type of the index of the switch.  */\n \n static basic_block\n emit_case_nodes (basic_block bb, tree index, case_node_ptr node,\n \t\t basic_block default_bb, tree default_label,\n \t\t profile_probability default_prob, tree index_type,\n \t\t hash_map<tree, tree> *phi_mapping)\n {\n-  /* If INDEX has an unsigned type, we must make unsigned branches.  */\n-  profile_probability probability;\n-  profile_probability prob = node->prob, subtree_prob = node->subtree_prob;\n-\n-  /* See if our parents have already tested everything for us.\n-     If they have, emit an unconditional jump for this node.  */\n-  if (node_is_bounded (node, index_type))\n-    {\n-      emit_jump (bb, node->case_bb, phi_mapping);\n-      return NULL;\n-    }\n-\n-  else if (tree_int_cst_equal (node->low, node->high))\n-    {\n-      probability = conditional_probability (prob, subtree_prob + default_prob);\n-      /* Node is single valued.  First see if the index expression matches\n-\t this node and then check our children, if any.  */\n-      bb = do_jump_if_equal (bb, index, node->low, node->case_bb, probability,\n-\t\t\t     phi_mapping);\n-      /* Since this case is taken at this point, reduce its weight from\n-\t subtree_weight.  */\n-      subtree_prob -= prob;\n-      if (node->right != 0 && node->left != 0)\n-\t{\n-\t  /* This node has children on both sides.\n-\t     Dispatch to one side or the other\n-\t     by comparing the index value with this node's value.\n-\t     If one subtree is bounded, check that one first,\n-\t     so we can avoid real branches in the tree.  */\n-\n-\t  if (node_is_bounded (node->right, index_type))\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (node->right->prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t    node->right->case_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t      bb = emit_case_nodes (bb, index, node->left, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t    }\n-\n-\t  else if (node_is_bounded (node->left, index_type))\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (node->left->prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, LT_EXPR,\n-\t\t\t\t\t    node->left->case_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t      bb = emit_case_nodes (bb, index, node->right, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t    }\n-\n-\t  /* If both children are single-valued cases with no\n-\t     children, finish up all the work.  This way, we can save\n-\t     one ordered comparison.  */\n-\t  else if (tree_int_cst_equal (node->right->low, node->right->high)\n-\t\t   && node->right->left == 0 && node->right->right == 0\n-\t\t   && tree_int_cst_equal (node->left->low, node->left->high)\n-\t\t   && node->left->left == 0 && node->left->right == 0)\n-\t    {\n-\t      /* Neither node is bounded.  First distinguish the two sides;\n-\t\t then emit the code for one side at a time.  */\n-\n-\t      /* See if the value matches what the right hand side\n-\t\t wants.  */\n-\t      probability\n-\t\t= conditional_probability (node->right->prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = do_jump_if_equal (bb, index, node->right->low,\n-\t\t\t\t     node->right->case_bb, probability,\n-\t\t\t\t     phi_mapping);\n-\n-\t      /* See if the value matches what the left hand side\n-\t\t wants.  */\n-\t      probability\n-\t\t= conditional_probability (node->left->prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = do_jump_if_equal (bb, index, node->left->low,\n-\t\t\t\t     node->left->case_bb, probability,\n-\t\t\t\t     phi_mapping);\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      /* Neither node is bounded.  First distinguish the two sides;\n-\t\t then emit the code for one side at a time.  */\n-\n-\t      basic_block test_bb = split_edge (single_succ_edge (bb));\n-\t      redirect_edge_succ (single_pred_edge (test_bb),\n-\t\t\t\t  single_succ_edge (bb)->dest);\n-\n-\t      /* The default label could be reached either through the right\n-\t\t subtree or the left subtree.  Divide the probability\n-\t\t equally.  */\n-\t      probability\n-\t\t= conditional_probability (node->right->subtree_prob\n-\t\t\t\t\t     + default_prob.apply_scale (1, 2),\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      /* See if the value is on the right.  */\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t    test_bb, probability, phi_mapping);\n-\t      default_prob = default_prob.apply_scale (1, 2);\n-\n-\t      /* Value must be on the left.\n-\t\t Handle the left-hand subtree.  */\n-\t      bb = emit_case_nodes (bb, index, node->left, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t      /* If left-hand subtree does nothing,\n-\t\t go to default.  */\n-\n-\t      if (bb && default_bb)\n-\t\temit_jump (bb, default_bb, phi_mapping);\n-\n-\t      /* Code branches here for the right-hand subtree.  */\n-\t      bb = emit_case_nodes (test_bb, index, node->right, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t    }\n-\t}\n-      else if (node->right != 0 && node->left == 0)\n-\t{\n-\t  /* Here we have a right child but no left so we issue a conditional\n-\t     branch to default and process the right child.\n-\n-\t     Omit the conditional branch to default if the right child\n-\t     does not have any children and is single valued; it would\n-\t     cost too much space to save so little time.  */\n-\n-\t  if (node->right->right || node->right->left\n-\t      || !tree_int_cst_equal (node->right->low, node->right->high))\n-\t    {\n-\t      if (!node_has_low_bound (node, index_type))\n-\t\t{\n-\t\t  probability\n-\t\t    = conditional_probability (default_prob.apply_scale (1, 2),\n-\t\t\t\t\t       subtree_prob + default_prob);\n-\t\t  bb = emit_cmp_and_jump_insns (bb, index, node->high, LT_EXPR,\n-\t\t\t\t\t\tdefault_bb, probability,\n-\t\t\t\t\t\tphi_mapping);\n-\t\t  default_prob = default_prob.apply_scale (1, 2);\n-\t\t}\n-\n-\t      bb = emit_case_nodes (bb, index, node->right, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t    }\n-\t  else\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (node->right->subtree_prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      /* We cannot process node->right normally\n-\t\t since we haven't ruled out the numbers less than\n-\t\t this node's value.  So handle node->right explicitly.  */\n-\t      bb = do_jump_if_equal (bb, index, node->right->low,\n-\t\t\t\t     node->right->case_bb, probability,\n-\t\t\t\t     phi_mapping);\n-\t    }\n-\t}\n-\n-      else if (node->right == 0 && node->left != 0)\n-\t{\n-\t  /* Just one subtree, on the left.  */\n-\t  if (node->left->left || node->left->right\n-\t      || !tree_int_cst_equal (node->left->low, node->left->high))\n-\t    {\n-\t      if (!node_has_high_bound (node, index_type))\n-\t\t{\n-\t\t  probability\n-\t\t    = conditional_probability (default_prob.apply_scale (1, 2),\n-\t\t\t\t\t       subtree_prob + default_prob);\n-\t\t  bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t\tdefault_bb, probability,\n-\t\t\t\t\t\tphi_mapping);\n-\t\t  default_prob = default_prob.apply_scale (1, 2);\n-\t\t}\n-\n-\t      bb = emit_case_nodes (bb, index, node->left, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t    }\n-\t  else\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (node->left->subtree_prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      /* We cannot process node->left normally\n-\t\t since we haven't ruled out the numbers less than\n-\t\t this node's value.  So handle node->left explicitly.  */\n-\t      do_jump_if_equal (bb, index, node->left->low, node->left->case_bb,\n-\t\t\t\tprobability, phi_mapping);\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      /* Node is a range.  These cases are very similar to those for a single\n-\t value, except that we do not start by testing whether this node\n-\t is the one to branch to.  */\n-\n-      if (node->right != 0 && node->left != 0)\n-\t{\n-\t  /* Node has subtrees on both sides.\n-\t     If the right-hand subtree is bounded,\n-\t     test for it first, since we can go straight there.\n-\t     Otherwise, we need to make a branch in the control structure,\n-\t     then handle the two subtrees.  */\n-\t  basic_block test_bb = NULL;\n-\n-\t  if (node_is_bounded (node->right, index_type))\n-\t    {\n-\t      /* Right hand node is fully bounded so we can eliminate any\n-\t\t testing and branch directly to the target code.  */\n-\t      probability\n-\t\t= conditional_probability (node->right->subtree_prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t    node->right->case_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Right hand node requires testing.\n-\t\t Branch to a label where we will handle it later.  */\n-\n-\t      test_bb = split_edge (single_succ_edge (bb));\n-\t      redirect_edge_succ (single_pred_edge (test_bb),\n-\t\t\t\t  single_succ_edge (bb)->dest);\n-\n-\t      probability\n-\t\t= conditional_probability (node->right->subtree_prob\n-\t\t\t\t\t     + default_prob.apply_scale (1, 2),\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t    test_bb, probability, phi_mapping);\n-\t      default_prob = default_prob.apply_scale (1, 2);\n-\t    }\n-\n-\t  /* Value belongs to this node or to the left-hand subtree.  */\n-\n-\t  probability\n-\t    = conditional_probability (prob, subtree_prob + default_prob);\n-\t  bb = emit_cmp_and_jump_insns (bb, index, node->low, GE_EXPR,\n-\t\t\t\t\tnode->case_bb, probability,\n-\t\t\t\t\tphi_mapping);\n-\n-\t  /* Handle the left-hand subtree.  */\n-\t  bb = emit_case_nodes (bb, index, node->left, default_bb,\n-\t\t\t\tdefault_label, default_prob, index_type,\n+  /* If node is null, we are done.  */\n+  if (node == NULL)\n+    return bb;\n+\n+  /* Branch to a label where we will handle it later.  */\n+  basic_block test_bb = split_edge (single_succ_edge (bb));\n+  redirect_edge_succ (single_pred_edge (test_bb),\n+\t\t      single_succ_edge (bb)->dest);\n+\n+  profile_probability probability\n+    = node->right ? node->right->subtree_prob : profile_probability::never ();\n+  probability\n+    = conditional_probability (probability + default_prob.apply_scale (1, 2),\n+\t\t\t       node->subtree_prob + default_prob);\n+  bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n+\t\t\t\ttest_bb, probability, phi_mapping);\n+  default_prob = default_prob.apply_scale (1, 2);\n+\n+  /* Value belongs to this node or to the left-hand subtree.  */\n+  probability\n+    = conditional_probability (node->prob, node->subtree_prob + default_prob);\n+  bb = emit_cmp_and_jump_insns (bb, index, node->low, GE_EXPR,\n+\t\t\t\tnode->case_bb, probability,\n \t\t\t\tphi_mapping);\n \n-\t  /* If right node had to be handled later, do that now.  */\n-\t  if (test_bb)\n-\t    {\n-\t      /* If the left-hand subtree fell through,\n-\t\t don't let it fall into the right-hand subtree.  */\n-\t      if (bb && default_bb)\n-\t\temit_jump (bb, default_bb, phi_mapping);\n-\n-\t      bb = emit_case_nodes (test_bb, index, node->right, default_bb,\n-\t\t\t\t    default_label, default_prob, index_type,\n-\t\t\t\t    phi_mapping);\n-\t    }\n-\t}\n-\n-      else if (node->right != 0 && node->left == 0)\n-\t{\n-\t  /* Deal with values to the left of this node,\n-\t     if they are possible.  */\n-\t  if (!node_has_low_bound (node, index_type))\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (default_prob.apply_scale (1, 2),\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->low, LT_EXPR,\n-\t\t\t\t\t    default_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t      default_prob = default_prob.apply_scale (1, 2);\n-\t    }\n-\n-\t  /* Value belongs to this node or to the right-hand subtree.  */\n-\n-\t  probability\n-\t    = conditional_probability (prob, subtree_prob + default_prob);\n-\t  bb = emit_cmp_and_jump_insns (bb, index, node->high, LE_EXPR,\n-\t\t\t\t\tnode->case_bb, probability,\n-\t\t\t\t\tphi_mapping);\n-\n-\t  bb = emit_case_nodes (bb, index, node->right, default_bb,\n-\t\t\t\tdefault_label, default_prob, index_type,\n-\t\t\t\tphi_mapping);\n-\t}\n-\n-      else if (node->right == 0 && node->left != 0)\n-\t{\n-\t  /* Deal with values to the right of this node,\n-\t     if they are possible.  */\n-\t  if (!node_has_high_bound (node, index_type))\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (default_prob.apply_scale (1, 2),\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t    default_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t      default_prob = default_prob.apply_scale (1, 2);\n-\t    }\n-\n-\t  /* Value belongs to this node or to the left-hand subtree.  */\n+  /* Handle the left-hand subtree.  */\n+  bb = emit_case_nodes (bb, index, node->left, default_bb,\n+\t\t\tdefault_label, default_prob, index_type,\n+\t\t\tphi_mapping);\n \n-\t  probability\n-\t    = conditional_probability (prob, subtree_prob + default_prob);\n-\t  bb = emit_cmp_and_jump_insns (bb, index, node->low, GE_EXPR,\n-\t\t\t\t\tnode->case_bb, probability,\n-\t\t\t\t\tphi_mapping);\n-\n-\t  bb = emit_case_nodes (bb, index, node->left, default_bb,\n-\t\t\t\tdefault_label, default_prob, index_type,\n-\t\t\t\tphi_mapping);\n-\t}\n-\n-      else\n-\t{\n-\t  /* Node has no children so we check low and high bounds to remove\n-\t     redundant tests.  Only one of the bounds can exist,\n-\t     since otherwise this node is bounded--a case tested already.  */\n-\t  bool high_bound = node_has_high_bound (node, index_type);\n-\t  bool low_bound = node_has_low_bound (node, index_type);\n-\n-\t  if (!high_bound && low_bound)\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (default_prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\t\t    default_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t    }\n-\n-\t  else if (!low_bound && high_bound)\n-\t    {\n-\t      probability\n-\t\t= conditional_probability (default_prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, index, node->low, LT_EXPR,\n-\t\t\t\t\t    default_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t    }\n-\t  else if (!low_bound && !high_bound)\n-\t    {\n-\t      tree lhs, rhs;\n-\t      generate_range_test (bb, index, node->low, node->high,\n-\t\t\t\t   &lhs, &rhs);\n-\t      probability\n-\t\t= conditional_probability (default_prob,\n-\t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, lhs, rhs, GT_EXPR,\n-\t\t\t\t\t    default_bb, probability,\n-\t\t\t\t\t    phi_mapping);\n-\t    }\n+  /* If the left-hand subtree fell through,\n+     don't let it fall into the right-hand subtree.  */\n+  if (default_bb)\n+    emit_jump (bb, default_bb, phi_mapping);\n \n-\t  emit_jump (bb, node->case_bb, phi_mapping);\n-\t  return NULL;\n-\t}\n-    }\n+  bb = emit_case_nodes (test_bb, index, node->right, default_bb,\n+\t\t\tdefault_label, default_prob, index_type,\n+\t\t\tphi_mapping);\n \n   return bb;\n }\n-\n-/* Search the parent sections of the case node tree\n-   to see if a test for the lower bound of NODE would be redundant.\n-   INDEX_TYPE is the type of the index expression.\n-\n-   The instructions to generate the case decision tree are\n-   output in the same order as nodes are processed so it is\n-   known that if a parent node checks the range of the current\n-   node minus one that the current node is bounded at its lower\n-   span.  Thus the test would be redundant.  */\n-\n-static bool\n-node_has_low_bound (case_node_ptr node, tree index_type)\n-{\n-  tree low_minus_one;\n-  case_node_ptr pnode;\n-\n-  /* If the lower bound of this node is the lowest value in the index type,\n-     we need not test it.  */\n-\n-  if (tree_int_cst_equal (node->low, TYPE_MIN_VALUE (index_type)))\n-    return true;\n-\n-  /* If this node has a left branch, the value at the left must be less\n-     than that at this node, so it cannot be bounded at the bottom and\n-     we need not bother testing any further.  */\n-\n-  if (node->left)\n-    return false;\n-\n-  low_minus_one = fold_build2 (MINUS_EXPR, TREE_TYPE (node->low), node->low,\n-\t\t\t       build_int_cst (TREE_TYPE (node->low), 1));\n-\n-  /* If the subtraction above overflowed, we can't verify anything.\n-     Otherwise, look for a parent that tests our value - 1.  */\n-\n-  if (!tree_int_cst_lt (low_minus_one, node->low))\n-    return false;\n-\n-  for (pnode = node->parent; pnode; pnode = pnode->parent)\n-    if (tree_int_cst_equal (low_minus_one, pnode->high))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Search the parent sections of the case node tree\n-   to see if a test for the upper bound of NODE would be redundant.\n-   INDEX_TYPE is the type of the index expression.\n-\n-   The instructions to generate the case decision tree are\n-   output in the same order as nodes are processed so it is\n-   known that if a parent node checks the range of the current\n-   node plus one that the current node is bounded at its upper\n-   span.  Thus the test would be redundant.  */\n-\n-static bool\n-node_has_high_bound (case_node_ptr node, tree index_type)\n-{\n-  tree high_plus_one;\n-  case_node_ptr pnode;\n-\n-  /* If there is no upper bound, obviously no test is needed.  */\n-\n-  if (TYPE_MAX_VALUE (index_type) == NULL)\n-    return true;\n-\n-  /* If the upper bound of this node is the highest value in the type\n-     of the index expression, we need not test against it.  */\n-\n-  if (tree_int_cst_equal (node->high, TYPE_MAX_VALUE (index_type)))\n-    return true;\n-\n-  /* If this node has a right branch, the value at the right must be greater\n-     than that at this node, so it cannot be bounded at the top and\n-     we need not bother testing any further.  */\n-\n-  if (node->right)\n-    return false;\n-\n-  high_plus_one = fold_build2 (PLUS_EXPR, TREE_TYPE (node->high), node->high,\n-\t\t\t       build_int_cst (TREE_TYPE (node->high), 1));\n-\n-  /* If the addition above overflowed, we can't verify anything.\n-     Otherwise, look for a parent that tests our value + 1.  */\n-\n-  if (!tree_int_cst_lt (node->high, high_plus_one))\n-    return false;\n-\n-  for (pnode = node->parent; pnode; pnode = pnode->parent)\n-    if (tree_int_cst_equal (high_plus_one, pnode->low))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Search the parent sections of the\n-   case node tree to see if both tests for the upper and lower\n-   bounds of NODE would be redundant.  */\n-\n-static bool\n-node_is_bounded (case_node_ptr node, tree index_type)\n-{\n-  return (node_has_low_bound (node, index_type)\n-\t  && node_has_high_bound (node, index_type));\n-}"}]}