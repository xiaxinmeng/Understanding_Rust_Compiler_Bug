{"sha": "973d3f1905307988ba17a4f93d9a95518b91fe42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczZDNmMTkwNTMwNzk4OGJhMTdhNGY5M2Q5YTk1NTE4YjkxZmU0Mg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2017-08-16T01:06:35Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2017-08-16T01:06:35Z"}, "message": "[RS6000] Don't restore fixed regs\n\n\t* config/rs6000/rs6000.c (rs6000_savres_strategy): Don't restore\n\tfixed regs.\n\nFrom-SVN: r251114", "tree": {"sha": "3f24168bf8319d40504517c3fa40d6e640f7e7bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f24168bf8319d40504517c3fa40d6e640f7e7bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/973d3f1905307988ba17a4f93d9a95518b91fe42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973d3f1905307988ba17a4f93d9a95518b91fe42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973d3f1905307988ba17a4f93d9a95518b91fe42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973d3f1905307988ba17a4f93d9a95518b91fe42/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9171123bfcd64715f85ed0e75085c3d0d31422a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9171123bfcd64715f85ed0e75085c3d0d31422a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9171123bfcd64715f85ed0e75085c3d0d31422a2"}], "stats": {"total": 84, "additions": 53, "deletions": 31}, "files": [{"sha": "4e6720faf9d6f80e063e2dd14828d729fc9b61c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973d3f1905307988ba17a4f93d9a95518b91fe42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973d3f1905307988ba17a4f93d9a95518b91fe42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=973d3f1905307988ba17a4f93d9a95518b91fe42", "patch": "@@ -1,3 +1,8 @@\n+2017-08-16  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_savres_strategy): Don't restore\n+\tfixed regs.\n+\n 2017-08-15  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR target/78460"}, {"sha": "5510306efdf2a33ec2964c06d4fe674c170c3b17", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973d3f1905307988ba17a4f93d9a95518b91fe42/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973d3f1905307988ba17a4f93d9a95518b91fe42/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=973d3f1905307988ba17a4f93d9a95518b91fe42", "patch": "@@ -24406,36 +24406,47 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t | SAVE_INLINE_GPRS\n \t\t | SAVE_INLINE_VRS);\n \n+  /* Don't ever restore fixed regs.  That means we can't use the\n+     out-of-line register restore functions if a fixed reg is in the\n+     range of regs restored.   */\n+  if (!(strategy & REST_INLINE_FPRS))\n+    for (int i = info->first_fp_reg_save; i < 64; i++)\n+      if (fixed_regs[i])\n+\t{\n+\t  strategy |= REST_INLINE_FPRS;\n+\t  break;\n+\t}\n+\n   /* We can only use the out-of-line routines to restore fprs if we've\n      saved all the registers from first_fp_reg_save in the prologue.\n      Otherwise, we risk loading garbage.  Of course, if we have saved\n      out-of-line then we know we haven't skipped any fprs.  */\n   if ((strategy & SAVE_INLINE_FPRS)\n       && !(strategy & REST_INLINE_FPRS))\n-    {\n-      int i;\n-\n-      for (i = info->first_fp_reg_save; i < 64; i++)\n-\tif (fixed_regs[i] || !save_reg_p (i))\n-\t  {\n-\t    strategy |= REST_INLINE_FPRS;\n-\t    break;\n-\t  }\n-    }\n+    for (int i = info->first_fp_reg_save; i < 64; i++)\n+      if (!save_reg_p (i))\n+\t{\n+\t  strategy |= REST_INLINE_FPRS;\n+\t  break;\n+\t}\n \n   /* Similarly, for altivec regs.  */\n+  if (!(strategy & REST_INLINE_VRS))\n+    for (int i = info->first_altivec_reg_save; i < LAST_ALTIVEC_REGNO + 1; i++)\n+      if (fixed_regs[i])\n+\t{\n+\t  strategy |= REST_INLINE_VRS;\n+\t  break;\n+\t}\n+\n   if ((strategy & SAVE_INLINE_VRS)\n       && !(strategy & REST_INLINE_VRS))\n-    {\n-      int i;\n-\n-      for (i = info->first_altivec_reg_save; i < LAST_ALTIVEC_REGNO + 1; i++)\n-\tif (fixed_regs[i] || !save_reg_p (i))\n-\t  {\n-\t    strategy |= REST_INLINE_VRS;\n-\t    break;\n-\t  }\n-    }\n+    for (int i = info->first_altivec_reg_save; i < LAST_ALTIVEC_REGNO + 1; i++)\n+      if (!save_reg_p (i))\n+\t{\n+\t  strategy |= REST_INLINE_VRS;\n+\t  break;\n+\t}\n \n   /* info->lr_save_p isn't yet set if the only reason lr needs to be\n      saved is an out-of-line save or restore.  Set up the value for\n@@ -24490,24 +24501,30 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t  }\n     }\n \n+  /* Don't ever restore fixed regs.  */\n+  if ((strategy & (REST_INLINE_GPRS | REST_MULTIPLE)) != REST_INLINE_GPRS)\n+    for (int i = info->first_gp_reg_save; i < 32; i++)\n+      if (fixed_reg_p (i))\n+\t{\n+\t  strategy |= REST_INLINE_GPRS;\n+\t  strategy &= ~REST_MULTIPLE;\n+\t  break;\n+\t}\n+\n   /* We can only use load multiple or the out-of-line routines to\n      restore gprs if we've saved all the registers from\n      first_gp_reg_save.  Otherwise, we risk loading garbage.\n      Of course, if we have saved out-of-line or used stmw then we know\n      we haven't skipped any gprs.  */\n   if ((strategy & (SAVE_INLINE_GPRS | SAVE_MULTIPLE)) == SAVE_INLINE_GPRS\n       && (strategy & (REST_INLINE_GPRS | REST_MULTIPLE)) != REST_INLINE_GPRS)\n-    {\n-      int i;\n-\n-      for (i = info->first_gp_reg_save; i < 32; i++)\n-\tif (fixed_reg_p (i) || !save_reg_p (i))\n-\t  {\n-\t    strategy |= REST_INLINE_GPRS;\n-\t    strategy &= ~REST_MULTIPLE;\n-\t    break;\n-\t  }\n-    }\n+    for (int i = info->first_gp_reg_save; i < 32; i++)\n+      if (!save_reg_p (i))\n+\t{\n+\t  strategy |= REST_INLINE_GPRS;\n+\t  strategy &= ~REST_MULTIPLE;\n+\t  break;\n+\t}\n \n   if (TARGET_ELF && TARGET_64BIT)\n     {"}]}