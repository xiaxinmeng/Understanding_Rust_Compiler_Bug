{"sha": "d199feb74801bcbcf2306ae4f40866814f1099dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5OWZlYjc0ODAxYmNiY2YyMzA2YWU0ZjQwODY2ODE0ZjEwOTlkYw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:12:45Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:12:45Z"}, "message": "MappedByteBuffer.java: (forceImpl...\n\n\n\t* java/nio/MappedByteBuffer.java: (forceImpl, isLoadedImpl, loadImpl,\n\tunmapImpl):  New dummy methods, to be overridden by subclass.\n\t(finalize, isLoaded, load, force):  New methods.\n\t* java/nio/MappedByteBufferImpl.java:  More-or-less rewrite.\n\tNow works, at least for read mapping.\n\nFrom-SVN: r78662", "tree": {"sha": "6155bc36cc7e756e68cb50c120caf6905518447d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6155bc36cc7e756e68cb50c120caf6905518447d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d199feb74801bcbcf2306ae4f40866814f1099dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d199feb74801bcbcf2306ae4f40866814f1099dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d199feb74801bcbcf2306ae4f40866814f1099dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d199feb74801bcbcf2306ae4f40866814f1099dc/comments", "author": null, "committer": null, "parents": [{"sha": "ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3"}], "stats": {"total": 150, "additions": 103, "deletions": 47}, "files": [{"sha": "29b0453cbba603f4413e05de18696a644aef0f9e", "filename": "libjava/java/nio/MappedByteBuffer.java", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d199feb74801bcbcf2306ae4f40866814f1099dc/libjava%2Fjava%2Fnio%2FMappedByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d199feb74801bcbcf2306ae4f40866814f1099dc/libjava%2Fjava%2Fnio%2FMappedByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FMappedByteBuffer.java?ref=d199feb74801bcbcf2306ae4f40866814f1099dc", "patch": "@@ -44,28 +44,46 @@\n  */\n public abstract class MappedByteBuffer extends ByteBuffer\n {\n-  private boolean loaded = false;\n-  \n   MappedByteBuffer (int capacity, int limit, int position, int mark)\n   {\n     super (capacity, limit, position, mark);\n   }\n   \n+  void forceImpl()\n+  {\n+  }\n+\n   public final MappedByteBuffer force ()\n   {\n-    // FIXME: Flush to disk here.\n+    forceImpl();\n     return this;\n   }\n     \n+  boolean isLoadedImpl()\n+  {\n+    load();\n+    return true;\n+  }\n+\n   public final boolean isLoaded ()\n   {\n-    return loaded;\n+    return isLoadedImpl();\n   }\n     \n+  void loadImpl()\n+  {\n+  }\n+\n   public final MappedByteBuffer load ()\n   {\n-    // FIXME: Try to load all pages into memory.\n-    loaded = true;\n+    loadImpl();\n     return this;\n   }\n+\n+  void unmapImpl ()\n+  {\n+    forceImpl();\n+  }\n+\n+  public void finalize () { unmapImpl(); }\n }"}, {"sha": "52996c23df4f80b7d1fff393232929dd89d54266", "filename": "libjava/java/nio/MappedByteBufferImpl.java", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d199feb74801bcbcf2306ae4f40866814f1099dc/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d199feb74801bcbcf2306ae4f40866814f1099dc/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FMappedByteBufferImpl.java?ref=d199feb74801bcbcf2306ae4f40866814f1099dc", "patch": "@@ -39,73 +39,80 @@\n package java.nio;\n \n import java.io.IOException;\n-import java.nio.channels.FileChannelImpl;\n+import gnu.java.nio.channels.FileChannelImpl;\n import gnu.gcj.RawData;\n \n-public class MappedByteBufferImpl extends MappedByteBuffer\n+class MappedByteBufferImpl extends MappedByteBuffer\n {\n   boolean readOnly;\n-  RawData map_address;\n-  public FileChannelImpl ch;\n+  RawData address;\n+\n+  /** Posix uses this for the pointer returned by mmap;\n+   * Win32 uses it for the pointer returned by MapViewOfFile. */\n+  public RawData implPtr;\n+  /** Posix uses this for the actual length passed to mmap;\n+   * Win32 uses it for the pointer returned by CreateFileMapping. */\n+  public long implLen;\n   \n-  public MappedByteBufferImpl (FileChannelImpl ch) throws IOException\n+  public MappedByteBufferImpl (RawData address, int size, boolean readOnly)\n+    throws IOException\n   {\n-    super ((int) ch.size (), (int) ch.size (), 0, -1);\n-    \n-    this.ch = ch;\n-    map_address = ch.map_address;\n-    long si = ch.size () / 1;\n-    limit ((int) si);\n-  }\n-\n-  public MappedByteBufferImpl (FileChannelImpl ch, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n-  {\n-    super (capacity, limit, position, mark);\n-\n-    this.ch = ch;\n-    this.array_offset = offset;\n+    super(size, size, 0, -1);\n+    this.address = address;\n     this.readOnly = readOnly;\n   }\n-  \n+\n   public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n   \n-  public static byte getImpl (FileChannelImpl ch, int index,\n-\t\t\t      int limit, RawData map_address)\n-  {\n-    throw new Error (\"Not implemented\");\n-  }\n-  \n-  public static void putImpl (FileChannelImpl ch, int index,\n-\t\t\t      int limit, byte value, RawData map_address)\n-  {\n-    throw new Error (\"Not implemented\");\n-  }\n-\n   public byte get ()\n   {\n-    byte result = get (position());\n-    position (position() + 1);\n+    int pos = position();\n+    if (pos >= limit())\n+      throw new BufferUnderflowException();\n+    byte result = DirectByteBufferImpl.getImpl(address, pos);\n+    position (pos + 1);\n     return result;\n   }\n \n   public ByteBuffer put (byte value)\n   {\n-    put (position(), value);\n-    position (position() + 1);\n+    int pos = position();\n+    if (pos >= limit())\n+      throw new BufferUnderflowException();\n+    DirectByteBufferImpl.putImpl(address, pos, value);\n+    position(pos + 1);\n     return this;\n   }\n \n   public byte get (int index)\n   {\n-    return getImpl (ch, index, limit (), map_address);\n+    if (index >= limit())\n+      throw new BufferUnderflowException();\n+    return DirectByteBufferImpl.getImpl(address, index);\n+  }\n+\n+  public ByteBuffer get (byte[] dst, int offset, int length)\n+  {\n+    if (offset < 0 || length < 0 || offset + length > dst.length)\n+      throw new IndexOutOfBoundsException ();\n+    if (length > remaining())\n+      throw new BufferUnderflowException();\n+\n+    int index = position();\n+    DirectByteBufferImpl.getImpl(address, index, dst, offset, length);\n+    position(index+length);\n+\n+    return this;\n   }\n \n   public ByteBuffer put (int index, byte value)\n   {\n-    putImpl (ch, index, limit (), value, map_address);\n+    if (index >= limit())\n+      throw new BufferUnderflowException();\n+    DirectByteBufferImpl.putImpl(address, index, value);\n     return this;\n   }\n \n@@ -129,17 +136,39 @@ public boolean isDirect ()\n \n   public ByteBuffer slice ()\n   {\n-    throw new Error (\"Not implemented\");\n+    int rem = remaining();\n+    return new DirectByteBufferImpl (this,\n+\t\t\t\t     DirectByteBufferImpl\n+\t\t\t\t     .adjustAddress(address, position()),\n+\t\t\t\t     rem, rem, 0, isReadOnly ());\n+  }\n+\n+  private ByteBuffer duplicate (boolean readOnly)\n+  {\n+    int pos = position();\n+    reset();\n+    int mark = position();\n+    position(pos);\n+    DirectByteBufferImpl result\n+      = new DirectByteBufferImpl (this, address, capacity (), limit (),\n+\t\t\t\t  pos, readOnly);\n+    if (mark != pos)\n+      {\n+\tresult.position(mark);\n+\tresult.mark();\n+\tresult.position(pos);\n+      }\n+    return result;\n   }\n \n   public ByteBuffer duplicate ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return duplicate(isReadOnly());\n   }\n \n   public ByteBuffer asReadOnlyBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return duplicate(true);\n   }\n \n   public CharBuffer asCharBuffer ()\n@@ -303,4 +332,13 @@ final public ByteBuffer putDouble (int index, double value)\n     ByteBufferHelper.putDouble (this, index, value, order());\n     return this;\n   }\n+\n+  // NOTE: In libgcj these methods are implemented in natFileChannelXxx.cc,\n+  // because they're small, and to put them next to FileChannelImpl::mapImpl.\n+  native void unmapImpl ();\n+  native boolean isLoadedImpl ();\n+    // FIXME: Try to load all pages into memory.\n+  native void loadImpl();\n+\n+  native void forceImpl();\n }"}]}