{"sha": "2f2782497acb6efa025c1f832a37a0afeb3925f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyNzgyNDk3YWNiNmVmYTAyNWMxZjgzMmEzN2EwYWZlYjM5MjVmNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-01-09T11:14:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-01-09T11:14:55Z"}, "message": "re PR tree-optimization/64410 (gcc 25% slower than clang 3.5 for adding complex numbers)\n\n2015-01-09  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/64410\n\t* tree-ssa.c (non_rewritable_lvalue_p): Allow REALPART/IMAGPART_EXPR\n\ton the LHS.\n\t(execute_update_addresses_taken): Deal with that.\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Use component-wise\n\tloads/stores for complex variables.\n\n\t* g++.dg/vect/pr64410.cc: New testcase.\n\nFrom-SVN: r219380", "tree": {"sha": "03add0605b49b2b5c0f9393c96db9dfd878e15e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03add0605b49b2b5c0f9393c96db9dfd878e15e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f2782497acb6efa025c1f832a37a0afeb3925f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2782497acb6efa025c1f832a37a0afeb3925f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2782497acb6efa025c1f832a37a0afeb3925f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2782497acb6efa025c1f832a37a0afeb3925f7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "520b30221300436cbc178a4110123c12ad3ee0ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520b30221300436cbc178a4110123c12ad3ee0ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520b30221300436cbc178a4110123c12ad3ee0ee"}], "stats": {"total": 193, "additions": 193, "deletions": 0}, "files": [{"sha": "7289e152af9115f2bcf84ef5aa90f7daaaa701f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f2782497acb6efa025c1f832a37a0afeb3925f7", "patch": "@@ -1,3 +1,12 @@\n+2015-01-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64410\n+\t* tree-ssa.c (non_rewritable_lvalue_p): Allow REALPART/IMAGPART_EXPR\n+\ton the LHS.\n+\t(execute_update_addresses_taken): Deal with that.\n+\t* tree-ssa-forwprop.c (pass_forwprop::execute): Use component-wise\n+\tloads/stores for complex variables.\n+\n 2015-01-09  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-icf-gimple.c (func_checker::compare_ssa_name): Enhance SSA"}, {"sha": "c962149b1bf3d2fce4b069a4c9bc190a61faa208", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f2782497acb6efa025c1f832a37a0afeb3925f7", "patch": "@@ -1,3 +1,8 @@\n+2015-01-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64410\n+\t* g++.dg/vect/pr64410.cc: New testcase.\n+\n 2015-01-09  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/ipa/ipa-icf-32.c: New test."}, {"sha": "6564745dce503c47fa1cae8e0ab88c88b7373018", "filename": "gcc/testsuite/g++.dg/vect/pr64410.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr64410.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr64410.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr64410.cc?ref=2f2782497acb6efa025c1f832a37a0afeb3925f7", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do compile }\n+\n+#include <vector>\n+#include <complex>\n+#include <iostream>\n+#include <cstdlib>\n+\n+using namespace std;\n+\n+int\n+main(int argc, char** argv)\n+{\n+  if (argc < 3)\n+    {\n+      cout << \"usage: size N\" << endl;\n+      return -1;\n+    }\n+\n+  const unsigned int size = atoi(argv[1]);\n+  const unsigned int N    = atoi(argv[2]);\n+\n+  cout << \"size = \" << size << endl;\n+  cout << \"N    = \" << N    << endl;\n+\n+  typedef complex<double> cx_double;\n+\n+  vector< cx_double > A(size);\n+  vector< cx_double > B(size);\n+  vector< cx_double > C(size);\n+\n+  cx_double* A_ptr = &A[0];\n+  cx_double* B_ptr = &B[0];\n+  cx_double* C_ptr = &C[0];\n+\n+  for (unsigned int i=0; i<size; ++i)\n+    {\n+      A_ptr[i] = cx_double( (double(rand())/RAND_MAX), (double(rand())/RAND_MAX) );\n+      B_ptr[i] = cx_double( (double(rand())/RAND_MAX), (double(rand())/RAND_MAX) );\n+      C_ptr[i] = cx_double( double(0), double(0) );\n+    }\n+\n+  for (unsigned int j=0; j<N; ++j)\n+    for (unsigned int i=0; i<size; ++i)\n+      C_ptr[i] = A_ptr[i] + B_ptr[i];\n+\n+  cout << C_ptr[0] << endl;\n+\n+  return 0;\n+}\n+\n+// { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" } }\n+// { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "a8fbccccd679a78b2cddd62d314d34599cd720d9", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2f2782497acb6efa025c1f832a37a0afeb3925f7", "patch": "@@ -2210,6 +2210,97 @@ pass_forwprop::execute (function *fun)\n \t      else\n \t\tgsi_next (&gsi);\n \t    }\n+\t  else if (TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE\n+\t\t   && gimple_assign_load_p (stmt)\n+\t\t   && !gimple_has_volatile_ops (stmt)\n+\t\t   && !stmt_can_throw_internal (stmt))\n+\t    {\n+\t      /* Rewrite loads used only in real/imagpart extractions to\n+\t         component-wise loads.  */\n+\t      use_operand_p use_p;\n+\t      imm_use_iterator iter;\n+\t      bool rewrite = true;\n+\t      FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n+\t\t{\n+\t\t  gimple use_stmt = USE_STMT (use_p);\n+\t\t  if (is_gimple_debug (use_stmt))\n+\t\t    continue;\n+\t\t  if (!is_gimple_assign (use_stmt)\n+\t\t      || (gimple_assign_rhs_code (use_stmt) != REALPART_EXPR\n+\t\t\t  && gimple_assign_rhs_code (use_stmt) != IMAGPART_EXPR))\n+\t\t    {\n+\t\t      rewrite = false;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (rewrite)\n+\t\t{\n+\t\t  gimple use_stmt;\n+\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+\t\t    {\n+\t\t      if (is_gimple_debug (use_stmt))\n+\t\t\t{\n+\t\t\t  if (gimple_debug_bind_p (use_stmt))\n+\t\t\t    {\n+\t\t\t      gimple_debug_bind_reset_value (use_stmt);\n+\t\t\t      update_stmt (use_stmt);\n+\t\t\t    }\n+\t\t\t  continue;\n+\t\t\t}\n+\n+\t\t      tree new_rhs = build1 (gimple_assign_rhs_code (use_stmt),\n+\t\t\t\t\t     TREE_TYPE (TREE_TYPE (rhs)),\n+\t\t\t\t\t     unshare_expr (rhs));\n+\t\t      gimple new_stmt\n+\t\t\t= gimple_build_assign (gimple_assign_lhs (use_stmt),\n+\t\t\t\t\t       new_rhs);\n+\n+\t\t      gimple_stmt_iterator gsi2 = gsi_for_stmt (use_stmt);\n+\t\t      unlink_stmt_vdef (use_stmt);\n+\t\t      gsi_remove (&gsi2, true);\n+\n+\t\t      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\t\t    }\n+\t\t  gsi_remove (&gsi, true);\n+\t\t}\n+\t      else\n+\t\tgsi_next (&gsi);\n+\t    }\n+\t  else if (code == COMPLEX_EXPR)\n+\t    {\n+\t      /* Rewrite stores of a single-use complex build expression\n+\t         to component-wise stores.  */\n+\t      use_operand_p use_p;\n+\t      gimple use_stmt;\n+\t      if (single_imm_use (lhs, &use_p, &use_stmt)\n+\t\t  && gimple_store_p (use_stmt)\n+\t\t  && !gimple_has_volatile_ops (use_stmt)\n+\t\t  && is_gimple_assign (use_stmt))\n+\t\t{\n+\t\t  tree use_lhs = gimple_assign_lhs (use_stmt);\n+\t\t  tree new_lhs = build1 (REALPART_EXPR,\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (use_lhs)),\n+\t\t\t\t\t unshare_expr (use_lhs));\n+\t\t  gimple new_stmt = gimple_build_assign (new_lhs, rhs);\n+\t\t  gimple_set_vuse (new_stmt, gimple_vuse (use_stmt));\n+\t\t  gimple_set_vdef (new_stmt, make_ssa_name (gimple_vop (cfun)));\n+\t\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+\t\t  gimple_set_vuse (use_stmt, gimple_vdef (new_stmt));\n+\t\t  gimple_stmt_iterator gsi2 = gsi_for_stmt (use_stmt);\n+\t\t  gsi_insert_before (&gsi2, new_stmt, GSI_SAME_STMT);\n+\n+\t\t  new_lhs = build1 (IMAGPART_EXPR,\n+\t\t\t\t    TREE_TYPE (TREE_TYPE (use_lhs)),\n+\t\t\t\t    unshare_expr (use_lhs));\n+\t\t  gimple_assign_set_lhs (use_stmt, new_lhs);\n+\t\t  gimple_assign_set_rhs1 (use_stmt, gimple_assign_rhs2 (stmt));\n+\t\t  update_stmt (use_stmt);\n+\n+\t\t  gsi_remove (&gsi, true);\n+\t\t}\n+\t      else\n+\t\tgsi_next (&gsi);\n+\t    }\n \t  else\n \t    gsi_next (&gsi);\n \t}"}, {"sha": "ba6d5dd502bcdbe79d480afaaaa0fb1c1c6bec56", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2782497acb6efa025c1f832a37a0afeb3925f7/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=2f2782497acb6efa025c1f832a37a0afeb3925f7", "patch": "@@ -1330,6 +1330,13 @@ non_rewritable_lvalue_p (tree lhs)\n   if (DECL_P (lhs))\n     return false;\n \n+  /* We can re-write REALPART_EXPR and IMAGPART_EXPR sets in\n+     a reasonably efficient manner... */\n+  if ((TREE_CODE (lhs) == REALPART_EXPR\n+       || TREE_CODE (lhs) == IMAGPART_EXPR)\n+      && DECL_P (TREE_OPERAND (lhs, 0)))\n+    return false;\n+\n   /* A decl that is wrapped inside a MEM-REF that covers\n      it full is also rewritable.\n      ???  The following could be relaxed allowing component\n@@ -1534,6 +1541,35 @@ execute_update_addresses_taken (void)\n \t\ttree rhs, *rhsp = gimple_assign_rhs1_ptr (stmt);\n \t\ttree sym;\n \n+\t\t/* Rewrite LHS IMAG/REALPART_EXPR similar to\n+\t\t   gimplify_modify_expr_complex_part.  */\n+\t\tif ((TREE_CODE (lhs) == IMAGPART_EXPR\n+\t\t     || TREE_CODE (lhs) == REALPART_EXPR)\n+\t\t    && DECL_P (TREE_OPERAND (lhs, 0))\n+\t\t    && bitmap_bit_p (suitable_for_renaming,\n+\t\t\t\t     DECL_UID (TREE_OPERAND (lhs, 0))))\n+\t\t  {\n+\t\t    tree other = make_ssa_name (TREE_TYPE (lhs));\n+\t\t    tree lrhs = build1 (TREE_CODE (lhs) == IMAGPART_EXPR\n+\t\t\t\t\t? REALPART_EXPR : IMAGPART_EXPR,\n+\t\t\t\t\tTREE_TYPE (other),\n+\t\t\t\t\tTREE_OPERAND (lhs, 0));\n+\t\t    gimple load = gimple_build_assign (other, lrhs);\n+\t\t    gimple_set_vuse (load, gimple_vuse (stmt));\n+\t\t    gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n+\t\t    gimple_assign_set_lhs (stmt, TREE_OPERAND (lhs, 0));\n+\t\t    gimple_assign_set_rhs_with_ops\n+\t\t      (&gsi, COMPLEX_EXPR,\n+\t\t       TREE_CODE (lhs) == IMAGPART_EXPR\n+\t\t       ? other : gimple_assign_rhs1 (stmt),\n+\t\t       TREE_CODE (lhs) == IMAGPART_EXPR\n+\t\t       ? gimple_assign_rhs1 (stmt) : other, NULL_TREE);\n+\t\t    stmt = gsi_stmt (gsi);\n+\t\t    unlink_stmt_vdef (stmt);\n+\t\t    update_stmt (stmt);\n+\t\t    continue;\n+\t\t  }\n+\n \t\t/* We shouldn't have any fancy wrapping of\n \t\t   component-refs on the LHS, but look through\n \t\t   VIEW_CONVERT_EXPRs as that is easy.  */"}]}