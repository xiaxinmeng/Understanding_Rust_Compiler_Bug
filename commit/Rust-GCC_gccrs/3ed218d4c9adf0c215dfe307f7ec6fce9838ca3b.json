{"sha": "3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VkMjE4ZDRjOWFkZjBjMjE1ZGZlMzA3ZjdlYzZmY2U5ODM4Y2EzYg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@redhat.com", "date": "2001-09-01T04:42:50Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-09-01T04:42:50Z"}, "message": "[multiple changes]\n\n2001-08-30  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* parse.y (patch_assignment): Don't verify final re-assignment here.\n\t(java_complete_lhs): Verify assignments to finals calling\n\tpatch_assignment. Verify re-assignments to finals before calling\n\tpatch_assignment.\n\n2001-08-29  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* parse.y (java_complete_lhs): Allow final locals in CASE_EXPRs.\n\tFixes PR java/1413\n\n2001-08-28  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* lex.c (java_lex): new local found_hex_digits. Set and then used\n\tin test to reject invalid hexadecimal numbers.\n\t* parse.y (java_complete_tree): Prevent unwanted cast with\n\tinitialized floating point finals.\n\t(patch_binop): Emit a warning when detecting a division by zero,\n\tmark result not constant, don't simplify non integer division.\n\n(http://gcc.gnu.org/ml/java-patches/2001-q3/msg00343.html )\n\nFrom-SVN: r45345", "tree": {"sha": "ce404748d0a009ff1a1dd22dda9c089f55db3980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce404748d0a009ff1a1dd22dda9c089f55db3980"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/comments", "author": null, "committer": null, "parents": [{"sha": "dee45a7f96660c4e19bef6462ff1b2d1932220e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee45a7f96660c4e19bef6462ff1b2d1932220e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee45a7f96660c4e19bef6462ff1b2d1932220e4"}], "stats": {"total": 67, "additions": 53, "deletions": 14}, "files": [{"sha": "3a92114ba54b7e7a31107b21f174f11f44750d51", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "patch": "@@ -41,6 +41,27 @@\n \n \t* jcf-dump.c (SPECIAL_IINC):  Remove unneeded casts to long.\n \n+2001-08-30  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* parse.y (patch_assignment): Don't verify final re-assignment here.\n+\t(java_complete_lhs): Verify assignments to finals calling\n+\tpatch_assignment. Verify re-assignments to finals before calling\n+\tpatch_assignment.\n+\n+2001-08-29  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* parse.y (java_complete_lhs): Allow final locals in CASE_EXPRs.\n+\tFixes PR java/1413\n+\n+2001-08-28  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* lex.c (java_lex): new local found_hex_digits. Set and then used\n+\tin test to reject invalid hexadecimal numbers.\n+\t* parse.y (java_complete_tree): Prevent unwanted cast with\n+\tinitialized floating point finals.\n+\t(patch_binop): Emit a warning when detecting a division by zero,\n+\tmark result not constant, don't simplify non integer division.\n+\n 2001-08-28  Per Bothner  <per@bothner.com>\n \n \t* jcf-write.c  (generate_bytecode_insns):  For increments and"}, {"sha": "d22147626326c76893028851607037ba327a48f9", "filename": "gcc/java/lex.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "patch": "@@ -991,6 +991,7 @@ java_lex (java_lval)\n       /* End borrowed section  */\n       char literal_token [256];\n       int  literal_index = 0, radix = 10, long_suffix = 0, overflow = 0, bytes;\n+      int  found_hex_digits = 0;\n       int  i;\n #ifndef JC1_LITE\n       int  number_beginning = ctxp->c_line->current;\n@@ -1060,6 +1061,10 @@ java_lex (java_lval)\n \t  int numeric = (RANGE (c, '0', '9') ? c-'0' : 10 +(c|0x20)-'a');\n \t  int count;\n \n+\t  /* Remember when we find a valid hexadecimal digit */\n+\t  if (radix == 16)\n+\t    found_hex_digits = 1;\n+\n \t  literal_token [literal_index++] = c;\n \t  /* This section of code if borrowed from gcc/c-lex.c  */\n \t  for (count = 0; count < TOTAL_PARTS; count++)\n@@ -1179,6 +1184,10 @@ java_lex (java_lval)\n \t    }\n \t} /* JAVA_ASCCI_FPCHAR (c) */\n \n+      if (radix == 16 && ! found_hex_digits)\n+\tjava_lex_error\n+\t  (\"0x must be followed by at least one hexadecimal digit\", 0);\n+\n       /* Here we get back to converting the integral literal.  */\n       if (c == 'L' || c == 'l')\n \tlong_suffix = 1;"}, {"sha": "09a4dcd6ce00e358387546e955076dad38c6f5b2", "filename": "gcc/java/parse.y", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=3ed218d4c9adf0c215dfe307f7ec6fce9838ca3b", "patch": "@@ -11401,7 +11401,8 @@ java_complete_tree (node)\n \t  /* fold_constant_for_init sometimes widen the original type\n              of the constant (i.e. byte to int.) It's not desirable,\n              especially if NODE is a function argument. */\n-\t  if (TREE_CODE (value) == INTEGER_CST\n+\t  if ((TREE_CODE (value) == INTEGER_CST\n+\t       || TREE_CODE (value) == REAL_CST)\n \t      && TREE_TYPE (node) != TREE_TYPE (value))\n \t    return convert (TREE_TYPE (node), value);\n \t  else\n@@ -11616,6 +11617,9 @@ java_complete_lhs (node)\n \t  cn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),\n \t\t\t\t       TREE_OPERAND (cn, 1));\n \t}\n+      /* Accept final locals too. */\n+      else if (TREE_CODE (cn) == VAR_DECL && LOCAL_FINAL (cn))\n+\tcn = fold_constant_for_init (DECL_INITIAL (cn), cn);\n \n       if (!TREE_CONSTANT (cn) && !flag_emit_xref)\n \t{\n@@ -11898,11 +11902,15 @@ java_complete_lhs (node)\n \t  \n \t  value = fold_constant_for_init (nn, nn);\n \n-\t  if (value != NULL_TREE)\n+\t  if (value != NULL_TREE &&\n+\t      (JPRIMITIVE_TYPE_P (TREE_TYPE (value)) || \n+\t       (TREE_TYPE (value) == string_ptr_type_node &&\n+\t\t! flag_emit_class_files)))\n \t    {\n-\t      tree type = TREE_TYPE (value);\n-\t      if (JPRIMITIVE_TYPE_P (type) || \n-\t\t  (type == string_ptr_type_node && ! flag_emit_class_files))\n+\t      TREE_OPERAND (node, 1) = value;\n+\t      if (patch_assignment (node, wfl_op1, value) == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      else\n \t\treturn empty_stmt_node;\n \t    }\n \t  if (! flag_emit_class_files)\n@@ -11986,6 +11994,9 @@ java_complete_lhs (node)\n \t}\n       else\n \t{\n+\t  /* Can't assign to a (blank) final. */\n+\t  if (check_final_assignment (TREE_OPERAND (node, 0), wfl_op1))\n+\t    return error_mark_node;\n \t  node = patch_assignment (node, wfl_op1, wfl_op2);\n \t  /* Reorganize the tree if necessary. */\n \t  if (flag && (!JREFERENCE_TYPE_P (TREE_TYPE (node)) \n@@ -12762,10 +12773,6 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   int error_found = 0;\n   int lvalue_from_array = 0;\n \n-  /* Can't assign to a (blank) final. */\n-  if (check_final_assignment (lvalue, wfl_op1))\n-    error_found = 1;\n-\n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n   /* Lhs can be a named variable */\n@@ -13491,18 +13498,20 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t      (TREE_CODE (op2) == INTEGER_CST &&\n \t       ! TREE_INT_CST_LOW (op2)  && ! TREE_INT_CST_HIGH (op2))))\n \t{\n-\t  parse_error_context (wfl_operator, \"Arithmetic exception\");\n-\t  error_found = 1;\n+\t  parse_warning_context (wfl_operator, \"Evaluating this expression will result in an arithmetic exception being thrown.\");\n+\t  TREE_CONSTANT (node) = 0;\n \t}\n \t  \n       /* Change the division operator if necessary */\n       if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)\n \tTREE_SET_CODE (node, TRUNC_DIV_EXPR);\n \n       /* Before divisions as is disapear, try to simplify and bail if\n-         applicable, otherwise we won't perform even simple simplifications\n-\t like (1-1)/3. */\n-      if (code == RDIV_EXPR && TREE_CONSTANT (op1) && TREE_CONSTANT (op2))\n+         applicable, otherwise we won't perform even simple\n+         simplifications like (1-1)/3. We can't do that with floating\n+         point number, folds can't handle them at this stage. */\n+      if (code == RDIV_EXPR && TREE_CONSTANT (op1) && TREE_CONSTANT (op2)\n+\t  && JINTEGRAL_TYPE_P (op1) && JINTEGRAL_TYPE_P (op2))\n \t{\n \t  TREE_TYPE (node) = prom_type;\n \t  node = fold (node);"}]}