{"sha": "3faa49284198625952a4420b889d5139710dab81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZhYTQ5Mjg0MTk4NjI1OTUyYTQ0MjBiODg5ZDUxMzk3MTBkYWI4MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-28T14:30:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-28T14:30:49Z"}, "message": "Oops, wrong file committed.\n\nFrom-SVN: r119293", "tree": {"sha": "55e0bdd475e6d801692ac666273ae85ba47fb920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55e0bdd475e6d801692ac666273ae85ba47fb920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3faa49284198625952a4420b889d5139710dab81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faa49284198625952a4420b889d5139710dab81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3faa49284198625952a4420b889d5139710dab81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faa49284198625952a4420b889d5139710dab81/comments", "author": null, "committer": null, "parents": [{"sha": "a1da787df346866e3a1f32b089a2ad5b68be53c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1da787df346866e3a1f32b089a2ad5b68be53c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1da787df346866e3a1f32b089a2ad5b68be53c8"}], "stats": {"total": 242, "additions": 1, "deletions": 241}, "files": [{"sha": "7098f83955d116b1d38c49f62a4d4511593a328a", "filename": "gcc/testsuite/gcc.dg/memcpy-1.c", "status": "modified", "additions": 1, "deletions": 241, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3faa49284198625952a4420b889d5139710dab81/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3faa49284198625952a4420b889d5139710dab81/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-1.c?ref=3faa49284198625952a4420b889d5139710dab81", "patch": "@@ -1,48 +1,3 @@\n-From gcc-patches-return-180556-listarch-gcc-patches=gcc dot gnu dot org at gcc dot gnu dot org Thu Oct 26 21:28:07 2006\n-Return-Path: <gcc-patches-return-180556-listarch-gcc-patches=gcc dot gnu dot org at gcc dot gnu dot org>\n-Delivered-To: listarch-gcc-patches at gcc dot gnu dot org\n-Received: (qmail 19726 invoked by alias); 26 Oct 2006 21:28:06 -0000\n-Received: (qmail 19713 invoked by uid 22791); 26 Oct 2006 21:28:05 -0000\n-X-Spam-Check-By: sourceware.org\n-Received: from nikam-dmz.ms.mff.cuni.cz (HELO nikam.ms.mff.cuni.cz) (195.113.20.16)     by sourceware.org (qpsmtpd/0.31) with ESMTP; Thu, 26 Oct 2006 21:28:02 +0000\n-Received: from occam.ms.mff.cuni.cz (occam.ms.mff.cuni.cz [195.113.18.121]) \tby nikam.ms.mff.cuni.cz (Postfix) with SMTP id F07CC5BA3F \tfor <gcc-patches@gcc.gnu.org>; Thu, 26 Oct 2006 23:27:59 +0200 (CEST)\n-Received: by occam.ms.mff.cuni.cz (sSMTP sendmail emulation); Thu, 26 Oct 2006 23:27:59 +0200\n-Date: Thu, 26 Oct 2006 23:27:59 +0200\n-From: Jan Hubicka <jh at suse dot cz>\n-To: gcc-patches at gcc dot gnu dot org\n-Subject: More memcpy folding\n-Message-ID: <20061026212759.GD6035@kam.mff.cuni.cz>\n-Mime-Version: 1.0\n-Content-Type: text/plain; charset=us-ascii\n-Content-Disposition: inline\n-User-Agent: Mutt/1.5.9i\n-Mailing-List: contact gcc-patches-help at gcc dot gnu dot org; run by ezmlm\n-Precedence: bulk\n-List-Archive: <http://gcc.gnu.org/ml/gcc-patches/>\n-List-Post: <mailto:gcc-patches at gcc dot gnu dot org>\n-List-Help: <mailto:gcc-patches-help at gcc dot gnu dot org>\n-Sender: gcc-patches-owner at gcc dot gnu dot org\n-Delivered-To: mailing list gcc-patches at gcc dot gnu dot org\n-\n-Hi,\n-this patch extends Jakub's code to fold memcpy into assignment to case of\n-structures to make GCC understand common low-level C idiom of\n-memcpy (&a, &b, sizeof (*a))\n-for copying structures.  This is of less academic interested as my previous\n-memmove folding since it matches quite few times during GCC bootstrap\n-and during SPEC build.  The transfomration often kills last place taking\n-address of the argument thus allowing SRA and other optimizations.\n-\n-I tried to cover as many cases as possible.  Unforutnately there are\n-aliasing issues as shown by execute/20060930-2.c, so I need to check\n-var_decl_component_p.  With little help from PTA we should be probably\n-able to do better here.\n-\n-Bootstrapped/regtested i686-linux, OK?\n-:ADDPATCH middle-end:\n-\n-Honza\n-\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-final { scan-tree-dump-times \"nasty_local\" 0 \"optimized\" } } */\n@@ -51,201 +6,6 @@ struct a {int a,b,c;} a;\n int test(struct a a)\n {\n struct a nasty_local;\n-memcpy (&nasty_local,&a, sizeof(a));\n+__builtin_memcpy (&nasty_local,&a, sizeof(a));\n return nasty_local.a;\n }\n-\t* builtins.c: Include tree-flow.h.\n-\t(fold_builtin_memory_op): Be more aggressive on converting memcpy to\n-\tassignment; convert memmove to memcpy for sizes greater than 1 where\n-\talignment of operands prohibit the partial overlap.\n-Index: builtins.c\n-===================================================================\n-*** builtins.c\t(revision 118067)\n---- builtins.c\t(working copy)\n-*************** Software Foundation, 51 Franklin Street,\n-*** 47,52 ****\n---- 47,53 ----\n-  #include \"langhooks.h\"\n-  #include \"basic-block.h\"\n-  #include \"tree-mudflap.h\"\n-+ #include \"tree-flow.h\"\n-  \n-  #ifndef PAD_VARARGS_DOWN\n-  #define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n-*************** static tree\n-*** 8029,8035 ****\n-  fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n-  {\n-    tree dest, src, len, destvar, srcvar, expr;\n--   unsigned HOST_WIDE_INT length;\n-  \n-    if (! validate_arglist (arglist,\n-  \t\t\t  POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n---- 8030,8035 ----\n-*************** fold_builtin_memory_op (tree arglist, tr\n-*** 8049,8060 ****\n-      expr = len;\n-    else\n-      {\n-        if (endp == 3)\n-  \t{\n-!           unsigned int src_align\n-! \t     = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-!           unsigned int dest_align\n-! \t     = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n-  \t  /* Both DEST and SRC must be pointer types. \n-  \t     ??? This is what old code did.  Is the testing for pointer types\n-  \t     really mandatory?\n---- 8049,8060 ----\n-      expr = len;\n-    else\n-      {\n-+       tree srctype, desttype;\n-        if (endp == 3)\n-  \t{\n-!           int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n-!           int dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n-! \n-  \t  /* Both DEST and SRC must be pointer types. \n-  \t     ??? This is what old code did.  Is the testing for pointer types\n-  \t     really mandatory?\n-*************** fold_builtin_memory_op (tree arglist, tr\n-*** 8062,8125 ****\n-  \t     If either SRC is readonly or length is 1, we can use memcpy.  */\n-  \t  if (dest_align && src_align\n-  \t      && (readonly_data_expr (src)\n-! \t\t  || integer_onep (len)))\n-  \t    {\n-  \t      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-  \t      if (!fn)\n-  \t\treturn 0;\n-  \t      return build_function_call_expr (fn, arglist);\n-  \t    }\n-  \t}\n--       if (! host_integerp (len, 1))\n-- \treturn 0;\n-- \n--       if (TREE_SIDE_EFFECTS (dest) || TREE_SIDE_EFFECTS (src))\n-- \treturn 0;\n-- \n--       destvar = dest;\n--       STRIP_NOPS (destvar);\n--       if (TREE_CODE (destvar) != ADDR_EXPR)\n-- \treturn 0;\n-- \n--       destvar = TREE_OPERAND (destvar, 0);\n--       if (TREE_THIS_VOLATILE (destvar))\n-- \treturn 0;\n-  \n-!       if (!INTEGRAL_TYPE_P (TREE_TYPE (destvar))\n-! \t  && !POINTER_TYPE_P (TREE_TYPE (destvar))\n-! \t  && !SCALAR_FLOAT_TYPE_P (TREE_TYPE (destvar)))\n-  \treturn 0;\n-! \n-!       if (! var_decl_component_p (destvar))\n-  \treturn 0;\n-  \n-!       srcvar = src;\n-!       STRIP_NOPS (srcvar);\n-!       if (TREE_CODE (srcvar) != ADDR_EXPR)\n-! \treturn 0;\n-  \n-!       srcvar = TREE_OPERAND (srcvar, 0);\n-        if (TREE_THIS_VOLATILE (srcvar))\n-  \treturn 0;\n-! \n-!       if (!INTEGRAL_TYPE_P (TREE_TYPE (srcvar))\n-! \t  && !POINTER_TYPE_P (TREE_TYPE (srcvar))\n-! \t  && !SCALAR_FLOAT_TYPE_P (TREE_TYPE (srcvar)))\n-  \treturn 0;\n-  \n-!       if (! var_decl_component_p (srcvar))\n-  \treturn 0;\n-! \n-!       length = tree_low_cst (len, 1);\n-!       if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (destvar))) != length\n-! \t  || get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n-! \t     < (int) length\n-! \t  || GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (srcvar))) != length\n-! \t  || get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n-! \t     < (int) length)\n-  \treturn 0;\n-  \n-!       if ((INTEGRAL_TYPE_P (TREE_TYPE (srcvar))\n-  \t   || POINTER_TYPE_P (TREE_TYPE (srcvar)))\n-  \t  && (INTEGRAL_TYPE_P (TREE_TYPE (destvar))\n-  \t      || POINTER_TYPE_P (TREE_TYPE (destvar))))\n---- 8062,8133 ----\n-  \t     If either SRC is readonly or length is 1, we can use memcpy.  */\n-  \t  if (dest_align && src_align\n-  \t      && (readonly_data_expr (src)\n-! \t          || (host_integerp (len, 1)\n-! \t\t      && (MIN (src_align, dest_align) / BITS_PER_UNIT <=\n-! \t\t\t  tree_low_cst (len, 1)))))\n-  \t    {\n-  \t      tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-  \t      if (!fn)\n-  \t\treturn 0;\n-  \t      return build_function_call_expr (fn, arglist);\n-  \t    }\n-+ \t  return 0;\n-  \t}\n-  \n-!       if (!host_integerp (len, 0))\n-  \treturn 0;\n-!       /* FIXME:\n-!          This logic lose for arguments like (type *)malloc (sizeof (type)),\n-!          since we strip the casts of up to VOID return value from malloc.\n-! \t Perhaps we ought to inherit type from non-VOID argument here?  */\n-!       STRIP_NOPS (src);\n-!       STRIP_NOPS (dest);\n-!       srctype = TREE_TYPE (TREE_TYPE (src));\n-!       desttype = TREE_TYPE (TREE_TYPE (dest));\n-!       if (!srctype || !desttype\n-! \t  || !TYPE_SIZE_UNIT (srctype)\n-! \t  || !TYPE_SIZE_UNIT (desttype)\n-! \t  || TREE_CODE (TYPE_SIZE_UNIT (srctype)) != INTEGER_CST\n-! \t  || TREE_CODE (TYPE_SIZE_UNIT (desttype)) != INTEGER_CST\n-! \t  || !operand_equal_p (TYPE_SIZE_UNIT (srctype), len, 0)\n-! \t  || !operand_equal_p (TYPE_SIZE_UNIT (desttype), len, 0))\n-! \treturn 0;\n-! \n-!       if (get_pointer_alignment (dest, BIGGEST_ALIGNMENT) \n-! \t  < (int) TYPE_ALIGN (desttype)\n-! \t  || (get_pointer_alignment (src, BIGGEST_ALIGNMENT) \n-! \t      < (int) TYPE_ALIGN (srctype)))\n-  \treturn 0;\n-  \n-!       if (!ignore)\n-!         dest = builtin_save_expr (dest);\n-  \n-!       srcvar = build_fold_indirect_ref (src);\n-        if (TREE_THIS_VOLATILE (srcvar))\n-  \treturn 0;\n-!       /* With memcpy, it is possible to bypass aliasing rules, so without\n-!          this check i. e. execute/20060930-2.c would be misoptimized, because\n-! \t it use conflicting alias set to hold argument for the memcpy call.\n-! \t This check is probably unnecesary with -fno-strict-aliasing. \n-! \t Similarly for destvar.  See also PR29286.  */\n-!       if (!var_decl_component_p (srcvar)\n-! \t  /* Accept: memcpy (*char_var, \"test\", 1); that simplify\n-! \t     to char_var='t';  */\n-! \t  || is_gimple_min_invariant (srcvar)\n-! \t  || readonly_data_expr (src))\n-  \treturn 0;\n-  \n-!       destvar = build_fold_indirect_ref (dest);\n-!       if (TREE_THIS_VOLATILE (destvar))\n-  \treturn 0;\n-!       if (!var_decl_component_p (destvar))\n-  \treturn 0;\n-  \n-!       if (srctype == desttype\n-! \t  || (in_ssa_p\n-! \t      && tree_ssa_useless_type_conversion_1 (desttype, srctype)))\n-! \texpr = srcvar;\n-!       else if ((INTEGRAL_TYPE_P (TREE_TYPE (srcvar))\n-  \t   || POINTER_TYPE_P (TREE_TYPE (srcvar)))\n-  \t  && (INTEGRAL_TYPE_P (TREE_TYPE (destvar))\n-  \t      || POINTER_TYPE_P (TREE_TYPE (destvar))))\n-"}]}