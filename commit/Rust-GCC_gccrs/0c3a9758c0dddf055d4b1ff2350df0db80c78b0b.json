{"sha": "0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzYTk3NThjMGRkZGYwNTVkNGIxZmYyMzUwZGYwZGI4MGM3OGIwYg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-10-09T14:17:48Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-10-09T14:17:48Z"}, "message": "alpha-protos.h (function_arg): Delete.\n\n\t* config/alpha/alpha-protos.h (function_arg): Delete.\n\t* config/alpha/alpha.h (FUNCTION_ARG, FUNCTION_ARG_ADVANCE): Delete.\n\t* config/alpha/vms.h (FUNCTION_ARG_ADVANCE): Delete.\n\t* config/alpha/alpha.c (function_arg): Rename to...\n\t(alpha_function_arg): ...this.  Make static.  Take a const_tree and\n\ta bool.  Delete TARGET_ABI_UNICOSMK code.\n\t(alpha_function_arg_advance): New function.\n\t(TARGET_FUNCTION_ARG, TARGET_FUNCTION_ARG_ADVANCE): Define.\n\nFrom-SVN: r165225", "tree": {"sha": "d8c34aff328045882624db3aa5fd703cdadec4c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c34aff328045882624db3aa5fd703cdadec4c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/comments", "author": null, "committer": null, "parents": [{"sha": "0851c6e3747e3b78dac903d3b5ce967af6cd13d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0851c6e3747e3b78dac903d3b5ce967af6cd13d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0851c6e3747e3b78dac903d3b5ce967af6cd13d2"}], "stats": {"total": 157, "additions": 43, "deletions": 114}, "files": [{"sha": "8a2015ce371884145645ff6fc528d793ce1a5d8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "patch": "@@ -1,3 +1,14 @@\n+2010-10-09  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* config/alpha/alpha-protos.h (function_arg): Delete.\n+\t* config/alpha/alpha.h (FUNCTION_ARG, FUNCTION_ARG_ADVANCE): Delete.\n+\t* config/alpha/vms.h (FUNCTION_ARG_ADVANCE): Delete.\n+\t* config/alpha/alpha.c (function_arg): Rename to...\n+\t(alpha_function_arg): ...this.  Make static.  Take a const_tree and\n+\ta bool.  Delete TARGET_ABI_UNICOSMK code.\n+\t(alpha_function_arg_advance): New function.\n+\t(TARGET_FUNCTION_ARG, TARGET_FUNCTION_ARG_ADVANCE): Define.\n+\n 2010-10-09  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/mep/mep-protos.h (mep_function_arg): Delete."}, {"sha": "7477169600719e3b1dd6decbcea3d79ecbef1f36", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "patch": "@@ -74,7 +74,6 @@ extern void print_operand_address (FILE *, rtx);\n extern void alpha_initialize_trampoline (rtx, rtx, rtx, int, int, int);\n \n extern rtx alpha_va_arg (tree, tree);\n-extern rtx function_arg (CUMULATIVE_ARGS, enum machine_mode, tree, int);\n extern rtx function_value (const_tree, const_tree, enum machine_mode);\n \n extern void alpha_start_function (FILE *, const char *, tree);"}, {"sha": "c6415d3a1dfc32cae2afc4c5b9368ef3545d8186", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 32, "deletions": 73, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "patch": "@@ -5634,9 +5634,9 @@ alpha_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    On Alpha the first 6 words of args are normally in registers\n    and the rest are pushed.  */\n \n-rtx\n-function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n-\t      int named ATTRIBUTE_UNUSED)\n+static rtx\n+alpha_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   int basereg;\n   int num_args;\n@@ -5661,87 +5661,22 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n     }\n \n   /* ??? Irritatingly, the definition of CUMULATIVE_ARGS is different for\n-     the three platforms, so we can't avoid conditional compilation.  */\n+     the two platforms, so we can't avoid conditional compilation.  */\n #if TARGET_ABI_OPEN_VMS\n     {\n       if (mode == VOIDmode)\n \treturn alpha_arg_info_reg_val (cum);\n \n-      num_args = cum.num_args;\n+      num_args = cum->num_args;\n       if (num_args >= 6\n \t  || targetm.calls.must_pass_in_stack (mode, type))\n \treturn NULL_RTX;\n     }\n-#elif TARGET_ABI_UNICOSMK\n-    {\n-      int size;\n-\n-      /* If this is the last argument, generate the call info word (CIW).  */\n-      /* ??? We don't include the caller's line number in the CIW because\n-\t I don't know how to determine it if debug infos are turned off.  */\n-      if (mode == VOIDmode)\n-\t{\n-\t  int i;\n-\t  HOST_WIDE_INT lo;\n-\t  HOST_WIDE_INT hi;\n-\t  rtx ciw;\n-\n-\t  lo = 0;\n-\n-\t  for (i = 0; i < cum.num_reg_words && i < 5; i++)\n-\t    if (cum.reg_args_type[i])\n-\t      lo |= (1 << (7 - i));\n-\n-\t  if (cum.num_reg_words == 6 && cum.reg_args_type[5])\n-\t    lo |= 7;\n-\t  else\n-\t    lo |= cum.num_reg_words;\n-\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  hi = (cum.num_args << 20) | cum.num_arg_words;\n-#else\n-\t  lo = lo | ((HOST_WIDE_INT) cum.num_args << 52)\n-\t    | ((HOST_WIDE_INT) cum.num_arg_words << 32);\n-\t  hi = 0;\n-#endif\n-\t  ciw = immed_double_const (lo, hi, DImode);\n-\n-\t  return gen_rtx_UNSPEC (DImode, gen_rtvec (1, ciw),\n-\t\t\t\t UNSPEC_UMK_LOAD_CIW);\n-\t}\n-\n-      size = ALPHA_ARG_SIZE (mode, type, named);\n-      num_args = cum.num_reg_words;\n-      if (cum.force_stack\n-\t  || cum.num_reg_words + size > 6\n-\t  || targetm.calls.must_pass_in_stack (mode, type))\n-\treturn NULL_RTX;\n-      else if (type && TYPE_MODE (type) == BLKmode)\n-\t{\n-\t  rtx reg1, reg2;\n-\n-\t  reg1 = gen_rtx_REG (DImode, num_args + 16);\n-\t  reg1 = gen_rtx_EXPR_LIST (DImode, reg1, const0_rtx);\n-\n-\t  /* The argument fits in two registers. Note that we still need to\n-\t     reserve a register for empty structures.  */\n-\t  if (size == 0)\n-\t    return NULL_RTX;\n-\t  else if (size == 1)\n-\t    return gen_rtx_PARALLEL (mode, gen_rtvec (1, reg1));\n-\t  else\n-\t    {\n-\t      reg2 = gen_rtx_REG (DImode, num_args + 17);\n-\t      reg2 = gen_rtx_EXPR_LIST (DImode, reg2, GEN_INT (8));\n-\t      return gen_rtx_PARALLEL (mode, gen_rtvec (2, reg1, reg2));\n-\t    }\n-\t}\n-    }\n #elif TARGET_ABI_OSF\n     {\n-      if (cum >= 6)\n+      if (*cum >= 6)\n \treturn NULL_RTX;\n-      num_args = cum;\n+      num_args = *cum;\n \n       /* VOID is passed as a special flag for \"last argument\".  */\n       if (type == void_type_node)\n@@ -5756,6 +5691,26 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n   return gen_rtx_REG (mode, num_args + basereg);\n }\n \n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+static void\n+alpha_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t    const_tree type, bool named)\n+{\n+  bool onstack = targetm.calls.must_pass_in_stack (mode, type);\n+  int increment = onstack ? 6 : ALPHA_ARG_SIZE (mode, type, named);\n+\n+#if TARGET_ABI_OSF\n+  *cum += increment;\n+#else\n+  if (!onstack && cum->num_args < 6)\n+    cum->atypes[cum->num_args] = alpha_arg_type (mode);\n+  cum->num_args += increment;\n+#endif\n+}\n+\n static int\n alpha_arg_partial_bytes (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n@@ -6183,7 +6138,7 @@ alpha_setup_incoming_varargs (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n   CUMULATIVE_ARGS cum = *pcum;\n \n   /* Skip the current argument.  */\n-  FUNCTION_ARG_ADVANCE (cum, mode, type, 1);\n+  targetm.calls.function_arg_advance (cum, mode, type, true);\n \n #if TARGET_ABI_UNICOSMK\n   /* On Unicos/Mk, the standard subroutine __T3E_MISMATCH stores all register\n@@ -11149,6 +11104,10 @@ alpha_init_libfuncs (void)\n #define TARGET_GIMPLIFY_VA_ARG_EXPR alpha_gimplify_va_arg\n #undef TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES alpha_arg_partial_bytes\n+#undef TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG alpha_function_arg\n+#undef TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE alpha_function_arg_advance\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT alpha_trampoline_init\n "}, {"sha": "66e215a5b36796d7e735f41b7f5ec60c7408608c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "patch": "@@ -749,34 +749,6 @@ extern int alpha_memory_latency;\n    : (((MODE) == BLKmode ? int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE)) \\\n       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  ((CUM) += \t\t\t\t\t\t\t\t\\\n-   (targetm.calls.must_pass_in_stack (MODE, TYPE))\t\t\t\\\n-    ? 6 : ALPHA_ARG_SIZE (MODE, TYPE, NAMED))\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-\n-   On Alpha the first 6 words of args are normally in registers\n-   and the rest are pushed.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-  function_arg((CUM), (MODE), (TYPE), (NAMED))\n-\n /* Make (or fake) .linkage entry for function call.\n    IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */\n "}, {"sha": "2c151a7e816ed7d51d056b2c88b305d650d2ad98", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c3a9758c0dddf055d4b1ff2350df0db80c78b0b/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=0c3a9758c0dddf055d4b1ff2350df0db80c78b0b", "patch": "@@ -175,18 +175,6 @@ typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n   (CUM).atypes[0] = (CUM).atypes[1] = (CUM).atypes[2] = I64;\t\\\n   (CUM).atypes[3] = (CUM).atypes[4] = (CUM).atypes[5] = I64;\n \n-#undef FUNCTION_ARG_ADVANCE\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  if (targetm.calls.must_pass_in_stack (MODE, TYPE))\t\t\t\\\n-    (CUM).num_args += 6;\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((CUM).num_args < 6)\t\t\t\t\t\t\\\n-        (CUM).atypes[(CUM).num_args] = alpha_arg_type (MODE);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-     (CUM).num_args += ALPHA_ARG_SIZE (MODE, TYPE, NAMED);\t\t\\\n-    }\n-\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n #undef  ASM_WEAKEN_LABEL"}]}