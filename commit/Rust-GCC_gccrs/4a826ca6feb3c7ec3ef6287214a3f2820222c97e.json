{"sha": "4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4MjZjYTZmZWIzYzdlYzNlZjYyODcyMTRhM2YyODIwMjIyYzk3ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-11-09T20:02:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-09T20:02:50Z"}, "message": "Implement P0127R2, Declaring non-type parameters with auto.\n\ngcc/cp/\n\t* cp-tree.h (enum auto_deduction_context): Add adc_unify.\n\t* decl.c (grokdeclarator): Allow 'auto' in C++17 template non-type\n\tparameter types.\n\t* pt.c (do_auto_deduction): Add outer_targs parameter.\n\t(convert_template_argument): Call do_auto_deduction.  If adc_unify,\n\tdon't give up on dependent init.\n\t(unify): Likewise.  In C++17, walk into the type of a\n\tTEMPLATE_PARM_INDEX.\n\t(for_each_template_parm): Add any_fn parameter.\n\t(struct pair_fn_data): Likewise.\n\t(for_each_template_parm_r): Call it for any tree.  In C++17, walk\n\tinto the type of a TEMPLATE_PARM_INDEX.\n\t(zero_r, array_deduction_r, try_array_deduction): New.\n\t(type_unification_real): Call try_array_deduction.\n\t(get_partial_spec_bindings): Likewise.\ngcc/c-family/\n\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_template_auto.\n\nFrom-SVN: r242017", "tree": {"sha": "760d23d9253039365e07de038db17dfe9aada879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/760d23d9253039365e07de038db17dfe9aada879"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff1f317b3c1fdcfb061e20f3474f77c183189830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff1f317b3c1fdcfb061e20f3474f77c183189830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff1f317b3c1fdcfb061e20f3474f77c183189830"}], "stats": {"total": 258, "additions": 240, "deletions": 18}, "files": [{"sha": "55c2e609606ffbd3c6223725871090a189004654", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -1,3 +1,7 @@\n+2016-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_template_auto.\n+\n 2016-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-ubsan.c (ubsan_instrument_shift): Handle split"}, {"sha": "70eade170e6417eed3666c9f2d5aaceb808dff4a", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -942,6 +942,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_aggregate_bases=201603\");\n \t  cpp_define (pfile, \"__cpp_deduction_guides=201606\");\n \t  cpp_define (pfile, \"__cpp_noexcept_function_type=201510\");\n+\t  cpp_define (pfile, \"__cpp_template_auto=201606\");\n \t}\n       if (flag_concepts)\n \tcpp_define (pfile, \"__cpp_concepts=201507\");"}, {"sha": "e220c5f85628371fef07249334e1af4c6d20b26e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -1,3 +1,22 @@\n+2016-11-09  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0127R2, Declaring non-type parameters with auto.\n+\t* cp-tree.h (enum auto_deduction_context): Add adc_unify.\n+\t* decl.c (grokdeclarator): Allow 'auto' in C++17 template non-type\n+\tparameter types.\n+\t* pt.c (do_auto_deduction): Add outer_targs parameter.\n+\t(convert_template_argument): Call do_auto_deduction.  If adc_unify,\n+\tdon't give up on dependent init.\n+\t(unify): Likewise.  In C++17, walk into the type of a\n+\tTEMPLATE_PARM_INDEX.\n+\t(for_each_template_parm): Add any_fn parameter.\n+\t(struct pair_fn_data): Likewise.\n+\t(for_each_template_parm_r): Call it for any tree.  In C++17, walk\n+\tinto the type of a TEMPLATE_PARM_INDEX.\n+\t(zero_r, array_deduction_r, try_array_deduction): New.\n+\t(type_unification_real): Call try_array_deduction.\n+\t(get_partial_spec_bindings): Likewise.\n+\n 2016-11-07  Jason Merrill  <jason@redhat.com>\n \n \tImplement P0012R1, Make exception specifications part of the type"}, {"sha": "9b5b5bc9bdb8d5c90cac24c878aeea184cf4d0bf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -5163,6 +5163,7 @@ enum auto_deduction_context\n   adc_unspecified,   /* Not given */\n   adc_variable_type, /* Variable initializer deduction */\n   adc_return_type,   /* Return type deduction */\n+  adc_unify,         /* Template argument deduction */\n   adc_requirement    /* Argument dedution constraint */\n };\n \n@@ -6088,7 +6089,8 @@ extern tree make_template_placeholder\t\t(tree);\n extern tree do_auto_deduction                   (tree, tree, tree);\n extern tree do_auto_deduction                   (tree, tree, tree,\n                                                  tsubst_flags_t,\n-                                                 auto_deduction_context);\n+                                                 auto_deduction_context,\n+\t\t\t\t\t\t tree = NULL_TREE);\n extern tree type_uses_auto\t\t\t(tree);\n extern tree type_uses_auto_or_concept\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree,"}, {"sha": "bd37faa8bfd71e8759dc55efd61c96b0e062e189", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -11135,7 +11135,8 @@ grokdeclarator (const cp_declarator *declarator,\n       if (ctype || in_namespace)\n \terror (\"cannot use %<::%> in parameter declaration\");\n \n-      if (type_uses_auto (type))\n+      if (type_uses_auto (type)\n+\t  && !(cxx_dialect >= cxx1z && template_parm_flag))\n \t{\n \t  if (cxx_dialect >= cxx14)\n \t    error (\"%<auto%> parameter not permitted in this context\");"}, {"sha": "64e566e12b083895e9ff04f7757bd69543fe983c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 128, "deletions": 14, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -161,7 +161,7 @@ static tree convert_nontype_argument (tree, tree, tsubst_flags_t);\n static tree convert_template_argument (tree, tree, tree,\n \t\t\t\t       tsubst_flags_t, int, tree);\n static tree for_each_template_parm (tree, tree_fn_t, void*,\n-\t\t\t\t    hash_set<tree> *, bool);\n+\t\t\t\t    hash_set<tree> *, bool, tree_fn_t = NULL);\n static tree expand_template_argument_pack (tree);\n static tree build_template_parm_index (int, int, int, tree, tree);\n static bool inline_needs_template_parms (tree, bool);\n@@ -7299,6 +7299,13 @@ convert_template_argument (tree parm,\n     {\n       tree t = tsubst (TREE_TYPE (parm), args, complain, in_decl);\n \n+      if (tree a = type_uses_auto (t))\n+\t{\n+\t  t = do_auto_deduction (t, arg, a, complain, adc_unspecified);\n+\t  if (t == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+\n       if (invalid_nontype_parm_type_p (t, complain))\n \treturn error_mark_node;\n \n@@ -8789,6 +8796,7 @@ lookup_and_finish_template_variable (tree templ, tree targs,\n struct pair_fn_data\n {\n   tree_fn_t fn;\n+  tree_fn_t any_fn;\n   void *data;\n   /* True when we should also visit template parameters that occur in\n      non-deduced contexts.  */\n@@ -8811,11 +8819,15 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       result = for_each_template_parm (NODE, fn, data, pfd->visited,\t\\\n-\t\t\t\t       pfd->include_nondeduced_p);\t\\\n+\t\t\t\t       pfd->include_nondeduced_p,\t\\\n+\t\t\t\t       pfd->any_fn);\t\t\t\\\n       if (result) goto out;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n+  if (pfd->any_fn && (*pfd->any_fn)(t, data))\n+    return t;\n+\n   if (TYPE_P (t)\n       && (pfd->include_nondeduced_p || TREE_CODE (t) != TYPENAME_TYPE))\n     WALK_SUBTREE (TYPE_CONTEXT (t));\n@@ -8880,7 +8892,8 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n       if (pfd->include_nondeduced_p\n \t  && for_each_template_parm (TYPE_VALUES_RAW (t), fn, data,\n \t\t\t\t     pfd->visited, \n-\t\t\t\t     pfd->include_nondeduced_p))\n+\t\t\t\t     pfd->include_nondeduced_p,\n+\t\t\t\t     pfd->any_fn))\n \treturn error_mark_node;\n       break;\n \n@@ -8911,6 +8924,12 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \treturn t;\n       else if (!fn)\n \treturn t;\n+\n+      /* In C++17 we can deduce a type argument from the type of a non-type\n+\t argument.  */\n+      if (cxx_dialect >= cxx1z\n+\t  && TREE_CODE (t) == TEMPLATE_PARM_INDEX)\n+\tWALK_SUBTREE (TREE_TYPE (t));\n       break;\n \n     case TEMPLATE_DECL:\n@@ -8984,13 +9003,15 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n static tree\n for_each_template_parm (tree t, tree_fn_t fn, void* data,\n \t\t\thash_set<tree> *visited,\n-\t\t\tbool include_nondeduced_p)\n+\t\t\tbool include_nondeduced_p,\n+\t\t\ttree_fn_t any_fn)\n {\n   struct pair_fn_data pfd;\n   tree result;\n \n   /* Set up.  */\n   pfd.fn = fn;\n+  pfd.any_fn = any_fn;\n   pfd.data = data;\n   pfd.include_nondeduced_p = include_nondeduced_p;\n \n@@ -18559,6 +18580,53 @@ unify_one_argument (tree tparms, tree targs, tree parm, tree arg,\n   return unify (tparms, targs, parm, arg, arg_strict, explain_p);\n }\n \n+/* for_each_template_parm callback that always returns 0.  */\n+\n+static int\n+zero_r (tree, void *)\n+{\n+  return 0;\n+}\n+\n+/* for_each_template_parm any_fn callback to handle deduction of a template\n+   type argument from the type of an array bound.  */\n+\n+static int\n+array_deduction_r (tree t, void *data)\n+{\n+  tree_pair_p d = (tree_pair_p)data;\n+  tree &tparms = d->purpose;\n+  tree &targs = d->value;\n+\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    if (tree dom = TYPE_DOMAIN (t))\n+      if (tree max = TYPE_MAX_VALUE (dom))\n+\t{\n+\t  if (TREE_CODE (max) == MINUS_EXPR)\n+\t    max = TREE_OPERAND (max, 0);\n+\t  if (TREE_CODE (max) == TEMPLATE_PARM_INDEX)\n+\t    unify (tparms, targs, TREE_TYPE (max), size_type_node,\n+\t\t   UNIFY_ALLOW_NONE, /*explain*/false);\n+\t}\n+\n+  /* Keep walking.  */\n+  return 0;\n+}\n+\n+/* Try to deduce any not-yet-deduced template type arguments from the type of\n+   an array bound.  This is handled separately from unify because 14.8.2.5 says\n+   \"The type of a type parameter is only deduced from an array bound if it is\n+   not otherwise deduced.\"  */\n+\n+static void\n+try_array_deduction (tree tparms, tree targs, tree parm)\n+{\n+  tree_pair_s data = { tparms, targs };\n+  hash_set<tree> visited;\n+  for_each_template_parm (parm, zero_r, &data, &visited,\n+\t\t\t  /*nondeduced*/false, array_deduction_r);\n+}\n+\n /* Most parms like fn_type_unification.\n \n    If SUBR is 1, we're being called recursively (to unify the\n@@ -18688,6 +18756,7 @@ type_unification_real (tree tparms,\n       tsubst_flags_t complain = (explain_p\n \t\t\t\t ? tf_warning_or_error\n \t\t\t\t : tf_none);\n+      bool tried_array_deduction = (cxx_dialect < cxx1z);\n \n       for (i = 0; i < ntparms; i++)\n \t{\n@@ -18706,6 +18775,15 @@ type_unification_real (tree tparms,\n \t    continue;\n \t  tparm = TREE_VALUE (tparm);\n \n+\t  if (TREE_CODE (tparm) == TYPE_DECL\n+\t      && !tried_array_deduction)\n+\t    {\n+\t      try_array_deduction (tparms, targs, xparms);\n+\t      tried_array_deduction = true;\n+\t      if (TREE_VEC_ELT (targs, i))\n+\t\tcontinue;\n+\t    }\n+\n \t  /* If this is an undeduced nontype parameter that depends on\n \t     a type parameter, try another pass; its type may have been\n \t     deduced from a later argument than the one from which\n@@ -19378,8 +19456,8 @@ template_parm_level_and_index (tree parm, int* level, int* index)\n /* Unifies the remaining arguments in PACKED_ARGS with the pack\n    expansion at the end of PACKED_PARMS. Returns 0 if the type\n    deduction succeeds, 1 otherwise. STRICT is the same as in\n-   unify. CALL_ARGS_P is true iff PACKED_ARGS is actually a function\n-   call argument list. We'll need to adjust the arguments to make them\n+   fn_type_unification. CALL_ARGS_P is true iff PACKED_ARGS is actually a\n+   function call argument list. We'll need to adjust the arguments to make them\n    types. SUBR tells us if this is from a recursive call to\n    type_unification_real, or for comparing two template argument\n    lists. */\n@@ -19680,6 +19758,9 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n   tree targ;\n   tree tparm;\n   int strict_in = strict;\n+  tsubst_flags_t complain = (explain_p\n+\t\t\t     ? tf_warning_or_error\n+\t\t\t     : tf_none);\n \n   /* I don't think this will do the right thing with respect to types.\n      But the only case I've seen it in so far has been array bounds, where\n@@ -19897,9 +19978,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t    if (coerce_template_parms (parm_parms,\n                                        full_argvec,\n \t\t\t\t       TYPE_TI_TEMPLATE (parm),\n-\t\t\t\t       (explain_p\n-\t\t\t\t\t? tf_warning_or_error\n-\t\t\t\t\t: tf_none),\n+\t\t\t\t       complain,\n \t\t\t\t       /*require_all_args=*/true,\n \t\t\t\t       /*use_default_args=*/false)\n \t\t== error_mark_node)\n@@ -20046,6 +20125,18 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t  return x;\n \t}\n \n+      if (cxx_dialect >= cxx1z\n+\t  /* We deduce from array bounds in try_array_deduction.  */\n+\t  && !(strict & UNIFY_ALLOW_INTEGER)\n+\t  && uses_template_parms (TREE_TYPE (parm))\n+\t  && !type_uses_auto (TREE_TYPE (parm)))\n+\t{\n+\t  tree atype = TREE_TYPE (arg);\n+\t  RECUR_AND_CHECK_FAILURE (tparms, targs,\n+\t\t\t\t   TREE_TYPE (parm), atype,\n+\t\t\t\t   UNIFY_ALLOW_NONE, explain_p);\n+\t}\n+\n       /* [temp.deduct.type] If, in the declaration of a function template\n \t with a non-type template-parameter, the non-type\n \t template-parameter is used in an expression in the function\n@@ -20055,6 +20146,13 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t deduced from an array bound may be of any integral type.\n \t The non-type parameter might use already deduced type parameters.  */\n       tparm = tsubst (TREE_TYPE (parm), targs, 0, NULL_TREE);\n+      if (tree a = type_uses_auto (tparm))\n+\t{\n+\t  tparm = do_auto_deduction (tparm, arg, a, complain, adc_unify);\n+\t  if (tparm == error_mark_node)\n+\t    return 1;\n+\t}\n+\n       if (!TREE_TYPE (arg))\n \t/* Template-parameter dependent expression.  Just accept it for now.\n \t   It will later be processed in convert_template_argument.  */\n@@ -21015,6 +21113,8 @@ get_partial_spec_bindings (tree tmpl, tree spec_tmpl, tree args)\n   else\n     deduced_args = innermost_deduced_args;\n \n+  bool tried_array_deduction = (cxx_dialect < cxx1z);\n+ again:\n   if (unify (tparms, deduced_args,\n \t     INNERMOST_TEMPLATE_ARGS (spec_args),\n \t     INNERMOST_TEMPLATE_ARGS (args),\n@@ -21023,7 +21123,17 @@ get_partial_spec_bindings (tree tmpl, tree spec_tmpl, tree args)\n \n   for (i =  0; i < ntparms; ++i)\n     if (! TREE_VEC_ELT (innermost_deduced_args, i))\n-      return NULL_TREE;\n+      {\n+\tif (!tried_array_deduction)\n+\t  {\n+\t    try_array_deduction (tparms, innermost_deduced_args,\n+\t\t\t\t INNERMOST_TEMPLATE_ARGS (spec_args));\n+\t    tried_array_deduction = true;\n+\t    if (TREE_VEC_ELT (innermost_deduced_args, i))\n+\t      goto again;\n+\t  }\n+\treturn NULL_TREE;\n+      }\n \n   tree tinst = build_tree_list (spec_tmpl, deduced_args);\n   if (!push_tinst_level (tinst))\n@@ -24607,14 +24717,16 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \n tree\n do_auto_deduction (tree type, tree init, tree auto_node,\n-                   tsubst_flags_t complain, auto_deduction_context context)\n+                   tsubst_flags_t complain, auto_deduction_context context,\n+\t\t   tree outer_targs)\n {\n   tree targs;\n \n   if (init == error_mark_node)\n     return error_mark_node;\n \n-  if (type_dependent_expression_p (init))\n+  if (type_dependent_expression_p (init)\n+      && context != adc_unify)\n     /* Defining a subset of type-dependent expressions that we can deduce\n        from ahead of time isn't worth the trouble.  */\n     return type;\n@@ -24733,6 +24845,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n                 switch (context)\n                   {\n                   case adc_unspecified:\n+\t\t  case adc_unify:\n                     error(\"placeholder constraints not satisfied\");\n                     break;\n                   case adc_variable_type:\n@@ -24754,8 +24867,9 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n           }\n       }\n \n-  if (processing_template_decl)\n-    targs = add_to_template_args (current_template_args (), targs);\n+  if (processing_template_decl && context != adc_unify)\n+    outer_targs = current_template_args ();\n+  targs = add_to_template_args (outer_targs, targs);\n   return tsubst (type, targs, complain, NULL_TREE);\n }\n "}, {"sha": "771ce0ef9d30d6536342f54b9159ad2dab39b7b4", "filename": "gcc/testsuite/g++.dg/cpp0x/auto9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -111,7 +111,7 @@ badthrow2 () throw (auto &)\t\t\t// { dg-error \"invalid use of|expected\" }\n {\n }\n \n-template <auto V = 4> struct G {};\t\t// { dg-error \"auto\" }\n+template <auto V = 4> struct G {};\t\t// { dg-error \"auto\" \"\" { target { ! c++1z } } }\n \n template <typename T> struct H { H (); ~H (); };\n H<auto> h;\t\t\t\t\t// { dg-error \"invalid|initializer\" }"}, {"sha": "adbc32cf4ce4c10e20a06d2a97330b776c9ce93d", "filename": "gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -368,6 +368,12 @@\n #  error \"__cpp_aligned_new != 201606\"\n #endif\n \n+#ifndef __cpp_template_auto\n+#  error \"__cpp_template_auto\"\n+#elif __cpp_template_auto != 201606\n+#  error \"__cpp_template_auto != 201606\"\n+#endif\n+\n #ifndef __cpp_inline_variables\n #  error \"__cpp_inline_variables\"\n #elif __cpp_inline_variables != 201606"}, {"sha": "9d0507483be47b950ee4c0392eab2361f02761ae", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto1.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -0,0 +1,13 @@\n+// Testcase from P0127R2\n+// { dg-options -std=c++1z }\n+\n+template <long n> struct A { };\n+\n+template <class T> struct C;\n+template <class T, T n> struct C<A<n>>\n+{\n+    using Q = T;\n+};\n+\n+typedef long R;\n+typedef C<A<2>>::Q R;  // OK; T was deduced to long from the template argument value in the type A<2>"}, {"sha": "23dac8a9151010d3402eb2c8997b570991aab478", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto2.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -0,0 +1,10 @@\n+// Testcase from P0127R2\n+// { dg-options -std=c++1z }\n+\n+template <typename T> struct S;\n+template <typename T, T n> struct S<int[n]> {\n+  using Q = T;\n+};\n+\n+typedef S<int[42]>::Q V;\n+typedef decltype(sizeof 0) V;  // OK; T was deduced to std::size_t from the type int[42]"}, {"sha": "00b56b1fe77ca8bda0f8a08143ecb38900716db3", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto3.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -0,0 +1,15 @@\n+// Testcase from P0127R2\n+// { dg-options -std=c++1z }\n+\n+template<auto n> struct B { decltype(n) f = n; };\n+B<5> b1;   // OK: template parameter type is int\n+B<'a'> b2; // OK: template parameter type is char\n+B<2.5> b3; // { dg-error \"\" } template parameter type cannot be double\n+\n+template <auto n> void f(B<n>) { }\n+\n+int main()\n+{\n+  f(B<42>());\n+  f(B<'a'>());\n+}"}, {"sha": "80bbbed9565732c9add8c78d639160cc7b72d555", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto4.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T, T n> void f(T, int (&)[n]);\n+template <class T, T n> void g(int (&)[n], T);\n+template <class T, T n> void h(int (&)[n]);\n+\n+int main()\n+{\n+  const int i = 42;\n+  int ar[i];\n+  h(ar);\n+  f(i, ar);\n+  g(ar, i);\n+}"}, {"sha": "aa5ca7f0d2cdf53893e220280834e6eafd1d127d", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto5.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T> struct A\n+{\n+  template <auto v>    struct Y;\n+  template <auto* p>   struct Y<p> { using type1 = decltype (p); };\n+  template <auto** pp> struct Y<pp> { using type2 = decltype (pp); };\n+};\n+\n+int i;\n+int *p;\n+\n+A<void>::Y<&i>::type1 t1;\n+A<void>::Y<&p>::type2 t2;\n+"}, {"sha": "cbf1b46a73ac21bb2f454be59046b7a1f9374b2e", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto6.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto6.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <int N> struct A;\n+template <typename T, T N> int foo(A<N> *) = delete;\n+void foo(void *);\n+void bar(A<0> *p) {\n+  foo(p);\t\t\t// { dg-error \"\" \"\" { target c++1z } }\n+}"}, {"sha": "2f400f7d44cd15d3ed3604debac1aa87f7235d20", "filename": "gcc/testsuite/g++.dg/template/partial5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a826ca6feb3c7ec3ef6287214a3f2820222c97e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial5.C?ref=4a826ca6feb3c7ec3ef6287214a3f2820222c97e", "patch": "@@ -14,7 +14,7 @@ template<typename T, typename T::foo V>\n struct Y { };\n \n template<typename T, typename U, U v>\n-struct Y<T, v> { }; // { dg-error \"not deducible|U\" }\n+struct Y<T, v> { }; // { dg-error \"not deducible|U\" \"\" { target { ! c++1z } } }\n \n \n template<typename T, T V>"}]}