{"sha": "64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRiODNmMmE0YWUzMDFkOTQxYjE4YmM3N2ZlNmM1ZTJmMWNiMGM2MQ==", "commit": {"author": {"name": "Steven Grady", "email": "grady@digitaldeck.com", "date": "2000-03-17T00:56:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-17T00:56:12Z"}, "message": "rtti.c (build_dynamic_cast_1): Improve diagnostics.\n\n        * rtti.c (build_dynamic_cast_1): Improve diagnostics.\n\nCo-Authored-By: Jason Merrill <jason@casey.cygnus.com>\n\nFrom-SVN: r32599", "tree": {"sha": "b3d4c128983e3967c78e790f753babe1144787f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3d4c128983e3967c78e790f753babe1144787f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61/comments", "author": null, "committer": null, "parents": [{"sha": "d05165c3933de4ce587e8f45c2e31e9c3dcccba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05165c3933de4ce587e8f45c2e31e9c3dcccba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05165c3933de4ce587e8f45c2e31e9c3dcccba7"}], "stats": {"total": 131, "additions": 82, "deletions": 49}, "files": [{"sha": "425bc6308656750c5c1485fd12e7e26e2ba88928", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61", "patch": "@@ -1,3 +1,8 @@\n+2000-03-16  Steven Grady <grady@digitaldeck.com>\n+\t    Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* rtti.c (build_dynamic_cast_1): Improve diagnostics.\n+\n 2000-03-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl2.c (grokfield): Bail out if type is error_mark_node."}, {"sha": "0c1986dbfd18d3cd9bd77e5b7bf0fae5f9d3c814", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 77, "deletions": 49, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=64b83f2a4ae301d941b18bc77fe6c5e2f1cb0c61", "patch": "@@ -548,69 +548,98 @@ build_dynamic_cast_1 (type, expr)\n {\n   enum tree_code tc = TREE_CODE (type);\n   tree exprtype;\n-  enum tree_code ec;\n   tree dcast_fn;\n   tree old_expr = expr;\n+  char* errstr = NULL;\n \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n-  \n-  exprtype = TREE_TYPE (expr);\n-  assert (exprtype != NULL_TREE);\n-  ec = TREE_CODE (exprtype);\n-\n+  /* T shall be a pointer or reference to a complete class type, or\n+     `pointer to cv void''.  */\n   switch (tc)\n     {\n     case POINTER_TYPE:\n-      if (ec == REFERENCE_TYPE)\n-\t{\n-\t  expr = convert_from_reference (expr);\n-\t  exprtype = TREE_TYPE (expr);\n-\t  ec = TREE_CODE (exprtype);\n-\t}\n-      if (ec != POINTER_TYPE)\n-\tgoto fail;\n-      if (TREE_CODE (TREE_TYPE (exprtype)) != RECORD_TYPE)\n-\tgoto fail;\n-      if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n-\tgoto fail;\n-      if (!at_least_as_qualified_p (TREE_TYPE (type),\n-\t\t\t\t    TREE_TYPE (exprtype)))\n-\tgoto fail;\n-      if (TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n+      if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n \tbreak;\n-      /* else fall through */\n     case REFERENCE_TYPE:\n-      if (TREE_CODE (TREE_TYPE (type)) != RECORD_TYPE)\n-\tgoto fail;\n+      if (! IS_AGGR_TYPE (TREE_TYPE (type)))\n+\t{\n+\t  errstr = \"target is not pointer or reference to class\";\n+\t  goto fail;\n+\t}\n       if (TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n-\tgoto fail;\n+\t{\n+\t  errstr = \"target is not pointer or reference to complete type\";\n+\t  goto fail;\n+\t}\n       break;\n-      /* else fall through */\n+\n     default:\n+      errstr = \"target is not pointer or reference\";\n       goto fail;\n     }\n \n-  /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n-  if (ec == RECORD_TYPE)\n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    expr = resolve_offset_ref (expr);\n+\n+  exprtype = TREE_TYPE (expr);\n+  assert (exprtype != NULL_TREE);\n+\n+  if (tc == POINTER_TYPE)\n+    expr = convert_from_reference (expr);\n+  else if (TREE_CODE (exprtype) != REFERENCE_TYPE)\n     {\n+      /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n       exprtype = build_reference_type (exprtype);\n       expr = convert_to_reference (exprtype, expr, CONV_IMPLICIT,\n \t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n-      ec = REFERENCE_TYPE;\n     }\n \n-  if (tc == REFERENCE_TYPE)\n+  exprtype = TREE_TYPE (expr);\n+\n+  if (tc == POINTER_TYPE)\n+    {\n+      /* If T is a pointer type, v shall be an rvalue of a pointer to\n+\t complete class type, and the result is an rvalue of type T.  */\n+\n+      if (TREE_CODE (exprtype) != POINTER_TYPE)\n+\t{\n+\t  errstr = \"source is not a pointer\";\n+\t  goto fail;\n+\t}\n+      if (! IS_AGGR_TYPE (TREE_TYPE (exprtype)))\n+\t{\n+\t  errstr = \"source is not a pointer to class\";\n+\t  goto fail;\n+\t}\n+      if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n+\t{\n+\t  errstr = \"source is a pointer to incomplete type\";\n+\t  goto fail;\n+\t}\n+    }\n+  else\n     {\n-      if (ec != REFERENCE_TYPE)\n-\tgoto fail;\n-      if (TREE_CODE (TREE_TYPE (exprtype)) != RECORD_TYPE)\n-\tgoto fail;\n+      /* T is a reference type, v shall be an lvalue of a complete class\n+\t type, and the result is an lvalue of the type referred to by T.  */\n+\n+      if (! IS_AGGR_TYPE (TREE_TYPE (exprtype)))\n+\t{\n+\t  errstr = \"source is not of class type\";\n+\t  goto fail;\n+\t}\n       if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n-\tgoto fail;\n-      if (!at_least_as_qualified_p (TREE_TYPE (type),\n-\t\t\t\t    TREE_TYPE (exprtype)))\n-\tgoto fail;\n+\t{\n+\t  errstr = \"source is of incomplete class type\";\n+\t  goto fail;\n+\t}\n+      \n+    }\n+\n+  /* The dynamic_cast operator shall not cast away constness.  */\n+  if (!at_least_as_qualified_p (TREE_TYPE (type),\n+\t\t\t\tTREE_TYPE (exprtype)))\n+    {\n+      errstr = \"conversion casts away constness\";\n+      goto fail;\n     }\n \n   /* If *type is an unambiguous accessible base class of *exprtype,\n@@ -669,7 +698,7 @@ build_dynamic_cast_1 (type, expr)\n \n  \t  /* If we got here, we can't convert statically.  Therefore,\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n-\t  if (ec == REFERENCE_TYPE)\n+\t  if (tc == REFERENCE_TYPE)\n \t    {\n \t      if (TREE_CODE (old_expr) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n@@ -717,7 +746,7 @@ build_dynamic_cast_1 (type, expr)\n \t      tree expr2 = build_headof (expr1);\n \t      tree td1 = expr;\n \n-\t      if (ec == POINTER_TYPE)\n+\t      if (tc == POINTER_TYPE)\n \t        td1 = build_indirect_ref (td1, NULL_PTR);\n   \t      td1 = get_tinfo_decl_dynamic (td1);\n \t  \n@@ -802,13 +831,12 @@ build_dynamic_cast_1 (type, expr)\n           return ifnonnull (expr, result);\n \t}\n     }\n-\n-  cp_error (\"dynamic_cast from non-polymorphic type `%#T'\", exprtype);\n-  return error_mark_node;\n+  else\n+    errstr = \"source type is not polymorphic\";\n \n  fail:\n-  cp_error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T'\",\n-\t    expr, exprtype, type);\n+  cp_error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T' (%s)\",\n+\t    expr, exprtype, type, errstr);\n   return error_mark_node;\n }\n \n@@ -1275,7 +1303,7 @@ tinfo_base_init (desc, target)\n   \n   init = tree_cons (NULL_TREE, decay_conversion (name_string), init);\n   \n-  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse(init));\n+  init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse (init));\n   TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n   init = tree_cons (NULL_TREE, init, NULL_TREE);\n   "}]}