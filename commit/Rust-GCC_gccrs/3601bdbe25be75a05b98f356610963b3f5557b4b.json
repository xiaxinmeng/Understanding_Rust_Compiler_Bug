{"sha": "3601bdbe25be75a05b98f356610963b3f5557b4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYwMWJkYmUyNWJlNzVhMDViOThmMzU2NjEwOTYzYjNmNTU1N2I0Yg==", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-05-20T16:56:24Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:14Z"}, "message": "Start compilation of parameters and return type to functions", "tree": {"sha": "ec6bd763b64d744e436157bb3008a9bce1a6211e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec6bd763b64d744e436157bb3008a9bce1a6211e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3601bdbe25be75a05b98f356610963b3f5557b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3601bdbe25be75a05b98f356610963b3f5557b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3601bdbe25be75a05b98f356610963b3f5557b4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3601bdbe25be75a05b98f356610963b3f5557b4b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "484a4c96a291afbc7df2e077d734459c10387891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/484a4c96a291afbc7df2e077d734459c10387891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/484a4c96a291afbc7df2e077d734459c10387891"}], "stats": {"total": 137, "additions": 115, "deletions": 22}, "files": [{"sha": "68a7a23d516463f1668b4e581f1b90c6849a33fd", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 115, "deletions": 22, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601bdbe25be75a05b98f356610963b3f5557b4b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601bdbe25be75a05b98f356610963b3f5557b4b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=3601bdbe25be75a05b98f356610963b3f5557b4b", "patch": "@@ -5,7 +5,7 @@ namespace Rust {\n namespace Compile {\n \n Compilation::Compilation (AST::Crate &crate, ::Backend *backend)\n-  : scope (), crate (crate), backend (backend)\n+  : crate (crate), backend (backend)\n {}\n \n Compilation::~Compilation () {}\n@@ -28,10 +28,11 @@ Compilation::go ()\n   scope.Pop ();\n \n   // Define all globally declared values.\n-  if (!saw_errors ())\n-    backend->write_global_definitions (type_decls, const_decls, func_decls,\n-\t\t\t\t       var_decls);\n+  if (saw_errors ())\n+    return false;\n \n+  backend->write_global_definitions (type_decls, const_decls, func_decls,\n+\t\t\t\t     var_decls);\n   return true;\n }\n \n@@ -76,9 +77,64 @@ Compilation::visit (AST::TypePathSegmentGeneric &segment)\n void\n Compilation::visit (AST::TypePathSegmentFunction &segment)\n {}\n+\n void\n Compilation::visit (AST::TypePath &path)\n-{}\n+{\n+  if (path.segments.size () > 1)\n+    {\n+      rust_error_at (path.locus, \"unable to compile multi segment types yet\");\n+      return;\n+    }\n+\n+  auto typeString = path.as_string ();\n+  if (typeString.compare (\"i64\") == 0)\n+    {\n+      translatedType = backend->integer_type (false, 64);\n+      return;\n+    }\n+  else if (typeString.compare (\"i32\") == 0)\n+    {\n+      translatedType = backend->integer_type (false, 32);\n+      return;\n+    }\n+  else if (typeString.compare (\"i16\") == 0)\n+    {\n+      translatedType = backend->integer_type (false, 16);\n+      return;\n+    }\n+  else if (typeString.compare (\"i8\") == 0)\n+    {\n+      translatedType = backend->integer_type (false, 8);\n+      return;\n+    }\n+  else if (typeString.compare (\"u64\") == 0)\n+    {\n+      translatedType = backend->integer_type (true, 64);\n+      return;\n+    }\n+  else if (typeString.compare (\"u32\") == 0)\n+    {\n+      translatedType = backend->integer_type (true, 32);\n+      return;\n+    }\n+  else if (typeString.compare (\"u16\") == 0)\n+    {\n+      translatedType = backend->integer_type (true, 16);\n+      return;\n+    }\n+  else if (typeString.compare (\"u8\") == 0)\n+    {\n+      translatedType = backend->integer_type (true, 8);\n+      return;\n+    }\n+  else if (typeString.compare (\"bool\") == 0)\n+    {\n+      translatedType = backend->bool_type ();\n+      return;\n+    }\n+}\n+\n void\n Compilation::visit (AST::QualifiedPathInExpression &path)\n {}\n@@ -345,36 +401,72 @@ Compilation::visit (AST::Function &function)\n   std::vector<Backend::Btyped_identifier> parameters;\n   std::vector<Backend::Btyped_identifier> results;\n \n+  for (auto &param : function.function_params)\n+    {\n+      // translate the type\n+      translatedType = NULL;\n+      param.type->accept_vis (*this);\n+      if (translatedType == NULL)\n+\t{\n+\t  rust_error_at (param.locus, \"failed to generate type for parameter\");\n+\t  return;\n+\t}\n+\n+      auto before = letPatternBuffer.size ();\n+      param.param_name->accept_vis (*this);\n+      if (letPatternBuffer.size () <= before)\n+\t{\n+\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n+\t  return;\n+\t}\n+\n+      auto numParamsPerType = letPatternBuffer.size () - before;\n+      for (auto i = 0; i < numParamsPerType; i++)\n+\t{\n+\t  auto paramName = letPatternBuffer.back ();\n+\t  letPatternBuffer.pop_back ();\n+\t  scope.Insert (paramName.variable_ident, param.type.get ());\n+\n+\t  parameters.push_back (\n+\t    Backend::Btyped_identifier (paramName.variable_ident,\n+\t\t\t\t\ttranslatedType, param.locus));\n+\t}\n+    }\n+\n+  Btype *returnType = NULL;\n   if (function.has_function_return_type ())\n     {\n       translatedType = NULL;\n       function.return_type->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n-\t  rust_error_at (function.locus, \"Unable to compile type\");\n+\t  rust_error_at (function.locus,\n+\t\t\t \"failed to generate type for function\");\n \t  return;\n \t}\n     }\n \n-  for (auto &param : function.function_params)\n+  Btype *fntype = backend->function_type (receiver, parameters, results,\n+\t\t\t\t\t  returnType, function.locus);\n+  Bfunction *fndecl\n+    = backend->function (fntype, function.function_name, \"\" /* asm_name */,\n+\t\t\t 0 /* flags */, function.locus);\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  for (auto &param : parameters)\n     {\n-      printf (\"FUNC PARAM: %s\\n\", param.as_string ().c_str ());\n-      // TODO\n+      bool tree_addressable = false;\n+      backend->parameter_variable (fndecl, param.name, param.btype,\n+\t\t\t\t   tree_addressable, param.location);\n     }\n-  if (parameters.size () != function.function_params.size ())\n+\n+  if (!backend->function_set_parameters (fndecl, param_vars))\n     {\n-      rust_error_at (function.locus,\n-\t\t     \"Unable to compile all function parameters\");\n+      rust_error_at (function.locus, \"failed to setup parameter variables\");\n       return;\n     }\n \n-  auto fntype = backend->function_type (receiver, parameters, results, NULL,\n-\t\t\t\t\tfunction.locus);\n-\n-  auto mangled_asm_name = \"\"; // TODO\n-  auto fndecl = backend->function (fntype, function.function_name,\n-\t\t\t\t   mangled_asm_name, 0, function.locus);\n-\n   // walk the expression body\n   std::vector<Bvariable *> vars;\n   auto code_block\n@@ -386,11 +478,12 @@ Compilation::visit (AST::Function &function)\n \n   auto body = backend->block_statement (code_block);\n   if (!backend->function_set_body (fndecl, body))\n-    rust_error_at (function.locus, \"failed to set body to function\");\n+    {\n+      rust_error_at (function.locus, \"failed to set body to function\");\n+      return;\n+    }\n \n   func_decls.push_back (fndecl);\n-  currentFndecl = NULL;\n-\n   scope.Pop ();\n }\n "}]}