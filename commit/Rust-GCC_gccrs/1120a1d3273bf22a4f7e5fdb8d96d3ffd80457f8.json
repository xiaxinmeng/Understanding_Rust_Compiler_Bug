{"sha": "1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEyMGExZDMyNzNiZjIyYTRmN2U1ZmRiOGQ5NmQzZmZkODA0NTdmOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-12-07T03:14:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-12-07T03:14:30Z"}, "message": "* config/h8300/h8300.h: Fix formatting.\n\nFrom-SVN: r38095", "tree": {"sha": "c7d37ac28c9873ba87626a16b2a34ef85315dd0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7d37ac28c9873ba87626a16b2a34ef85315dd0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8/comments", "author": null, "committer": null, "parents": [{"sha": "bc98ef7f6c0cb3ee14b28c3ca7655261138fe0a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc98ef7f6c0cb3ee14b28c3ca7655261138fe0a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc98ef7f6c0cb3ee14b28c3ca7655261138fe0a1"}], "stats": {"total": 221, "additions": 128, "deletions": 93}, "files": [{"sha": "ab59d8ee826d20f76a31538fa291336060d63b50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8", "patch": "@@ -1,3 +1,7 @@\n+2000-12-06  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/h8300/h8300.h: Fix formatting.\n+\n 2000-12-06      Joel Sherrill <joel@OARcorp.com>\n \n         * config.gcc (a29k*-*-rtems*, arm*-*-rtems*, c4x-*-rtems*, "}, {"sha": "0cc180851a63db6dfd28a314b50383007bc985d1", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 124, "deletions": 93, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=1120a1d3273bf22a4f7e5fdb8d96d3ffd80457f8", "patch": "@@ -502,11 +502,11 @@ enum reg_class {\n    dangerous, so we claim that it always pushes a word, then we catch\n    the mov.b rx,@-sp and turn it into a mov.w rx,@-sp on output.\n \n-   On the H8/300h, we simplify TARGET_QUICKCALL by setting this to 4 and doing\n-   a similar thing.  */\n+   On the H8/300H, we simplify TARGET_QUICKCALL by setting this to 4\n+   and doing a similar thing.  */\n \n #define PUSH_ROUNDING(BYTES) \\\n-  (((BYTES) + PARM_BOUNDARY/8 - 1) & -PARM_BOUNDARY/8)\n+  (((BYTES) + PARM_BOUNDARY / 8 - 1) & -PARM_BOUNDARY / 8)\n \n /* Offset of first parameter from the argument pointer register value.  */\n /* Is equal to the size of the saved fp + pc, even if an fp isn't\n@@ -574,7 +574,7 @@ enum reg_class {\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-/* On the h8 the return value is in R0/R1 */\n+/* On the H8 the return value is in R0/R1.  */\n \n #define LIBCALL_VALUE(MODE) \\\n   gen_rtx_REG (MODE, 0)\n@@ -615,9 +615,9 @@ enum reg_class {\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On the H8/300, this is a two item struct, the first is the number of bytes\n-   scanned so far and the second is the rtx of the called library\n-   function if any.  */\n+   On the H8/300, this is a two item struct, the first is the number\n+   of bytes scanned so far and the second is the rtx of the called\n+   library function if any.  */\n \n #define CUMULATIVE_ARGS struct cum_arg\n struct cum_arg\n@@ -989,7 +989,7 @@ struct cum_arg\n #define Pmode (TARGET_H8300H || TARGET_H8300S ? SImode : HImode)\n \n /* ANSI C types.\n-   We use longs for the 300h because ints can be 16 or 32.\n+   We use longs for the 300H because ints can be 16 or 32.\n    GCC requires SIZE_TYPE to be the same size as pointers.  */\n #define NO_BUILTIN_SIZE_TYPE\n #define NO_BUILTIN_PTRDIFF_TYPE\n@@ -1111,45 +1111,53 @@ h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n #define EXTRA_SECTIONS in_ctors, in_dtors, in_readonly_data\n \n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-ctors_section () \t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_ctors)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\\\n-      in_section = in_ctors;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-dtors_section () \t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_dtors)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\\\n-      in_section = in_dtors;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-readonly_data () \t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_readonly_data)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_SECTION_ASM_OP);\\\n-      in_section = in_readonly_data;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+readonly_data ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_readonly_data)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_SECTION_ASM_OP);\t\\\n+      in_section = in_readonly_data;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n-#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n-  do { ctors_section();\t\t\t\t\\\n-       fprintf(FILE, \"%s_%s\\n\", ASM_WORD_OP, NAME); } while (0)\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      ctors_section ();\t\t\t\t\t\\\n+      fprintf (FILE, \"%s_%s\\n\", ASM_WORD_OP, NAME);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n-#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\\\n-  do { dtors_section();\t\t\t\t\\\n-       fprintf(FILE, \"%s_%s\\n\", ASM_WORD_OP, NAME); } while (0)\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      dtors_section ();\t\t\t       \t\t\\\n+      fprintf (FILE, \"%s_%s\\n\", ASM_WORD_OP, NAME);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n #undef DO_GLOBAL_CTORS_BODY\n #define DO_GLOBAL_CTORS_BODY\t\t\t\\\n@@ -1182,29 +1190,31 @@ readonly_data () \t\t\t\t\t\t\\\n /* If we are referencing a function that is supposed to be called\n    through the function vector, the SYMBOL_REF_FLAG in the rtl\n    so the call patterns can generate the correct code.  */\n-#define ENCODE_SECTION_INFO(DECL)  \\\n-  if (TREE_CODE (DECL) == FUNCTION_DECL \\\n-       && h8300_funcvec_function_p (DECL)) \\\n-    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1; \\\n-  else if ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL)) \\\n-      && TREE_CODE (DECL) == VAR_DECL \\\n-      && h8300_eightbit_data_p (DECL)) \\\n-    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1; \\\n-  else if ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL)) \\\n-      && TREE_CODE (DECL) == VAR_DECL \\\n-      && h8300_tiny_data_p (DECL)) \\\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+       && h8300_funcvec_function_p (DECL))\t\t\\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\\\n+  else if ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL))\t\\\n+      && TREE_CODE (DECL) == VAR_DECL\t\t\t\\\n+      && h8300_eightbit_data_p (DECL))\t\t\t\\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\\\n+  else if ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL))\t\\\n+      && TREE_CODE (DECL) == VAR_DECL\t\t\t\\\n+      && h8300_tiny_data_p (DECL))\t\t\t\\\n     h8300_encode_label (DECL);\n \n /* Store the user-specified part of SYMBOL_NAME in VAR.\n    This is sort of inverse to ENCODE_SECTION_INFO.  */\n-#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME) \\\n-  (VAR) = (SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*' || (SYMBOL_NAME)[0] == '@' || (SYMBOL_NAME)[0] == '&') \n+#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\t\\\n+  (VAR) = (SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'\t\\\n+\t\t\t   || (SYMBOL_NAME)[0] == '@'\t\\\n+\t\t\t   || (SYMBOL_NAME)[0] == '&');\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n #define REGISTER_NAMES \\\n-{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"sp\", \"mac\", \"ap\"}\n+{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"sp\", \"mac\", \"ap\" }\n \n #define ADDITIONAL_REGISTER_NAMES \\\n { {\"er0\", 0}, {\"er1\", 1}, {\"er2\", 2}, {\"er3\", 3}, {\"er4\", 4}, \\\n@@ -1243,8 +1253,13 @@ readonly_data () \t\t\t\t\t\t\\\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n \n-#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\\\n+      fputs (\":\\n\", FILE);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #define ASM_OUTPUT_LABELREF(FILE,NAME)  \\\n   asm_fprintf ((FILE), \"%U%s\", (NAME) + (TINY_DATA_NAME_P (NAME) ? 1 : 0))\n@@ -1254,8 +1269,14 @@ readonly_data () \t\t\t\t\t\t\\\n /* This is how to output a command to make the user-level label named NAME\n    defined for reference from other files.  */\n \n-#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\\\n-  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fputs (\"\\t.global \", FILE);\t\t\\\n+      assemble_name (FILE, NAME);\t\t\\\n+      fputs (\"\\n\", FILE);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n    ASM_OUTPUT_LABEL(FILE, NAME)\n@@ -1284,18 +1305,22 @@ readonly_data () \t\t\t\t\t\t\\\n /* This is how to output an assembler line defining a `double' constant.\n    It is .dfloat or .gfloat, depending.  */\n \n-#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n-     fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n-   } while (0)\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\t\\\n+      fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\t\\\n+    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n-#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n-     fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n-   } while (0)\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\t\\\n+      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\t\\\n+    } while (0)\n \n /* This is how to output an assembler line defining an `int' constant.  */\n \n@@ -1354,7 +1379,7 @@ do { char dstr[30];\t\t\t\t\t\\\n    that says to advance the location counter by SIZE bytes.  */\n \n #define ASM_OUTPUT_IDENT(FILE, NAME)\t\t\t\\\n-  fprintf(FILE, \"%s\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME)\n+  fprintf (FILE, \"%s\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME)\n \n #define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n   fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n@@ -1406,25 +1431,29 @@ do { char dstr[30];\t\t\t\t\t\\\n #define TARGET_CR 015\n \n /* Print an instruction operand X on file FILE.\n-   look in h8300.c for details */\n+   Look in h8300.c for details.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '#')\n \n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand(FILE,X,CODE)\n \n /* Print a memory operand whose address is X, on file FILE.\n    This uses a function in h8300.c.  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n /* H8300 specific pragmas.  */\n-#define REGISTER_TARGET_PRAGMAS(PFILE) do {\t\t\t\t\\\n-  cpp_register_pragma (PFILE, 0, \"saveall\", h8300_pr_saveall);\t\t\\\n-  cpp_register_pragma (PFILE, 0, \"interrupt\", h8300_pr_interrupt);\t\\\n-} while (0)\n+#define REGISTER_TARGET_PRAGMAS(PFILE)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      cpp_register_pragma (PFILE, 0, \"saveall\", h8300_pr_saveall);\t\\\n+      cpp_register_pragma (PFILE, 0, \"interrupt\", h8300_pr_interrupt);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n-#define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n+#define FINAL_PRESCAN_INSN(insn, operand, nop)\t\\\n+  final_prescan_insn (insn, operand, nop)\n \n /* Define this macro if GNU CC should generate calls to the System V\n    (and ANSI C) library functions `memcpy' and `memset' rather than\n@@ -1440,19 +1469,21 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* Perform target dependent optabs initialization.  */\n \n-#define INIT_TARGET_OPTABS\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    smul_optab->handlers[(int) HImode].libfunc\t\\\n-      = init_one_libfunc (MULHI3_LIBCALL);\t\\\n-    sdiv_optab->handlers[(int) HImode].libfunc\t\\\n-      = init_one_libfunc (DIVHI3_LIBCALL);\t\\\n-    udiv_optab->handlers[(int) HImode].libfunc\t\\\n-      = init_one_libfunc (UDIVHI3_LIBCALL);\t\\\n-    smod_optab->handlers[(int) HImode].libfunc\t\\\n-      = init_one_libfunc (MODHI3_LIBCALL);\t\\\n-    umod_optab->handlers[(int) HImode].libfunc\t\\\n-      = init_one_libfunc (UMODHI3_LIBCALL);\t\\\n-  } while (0)\n+#define INIT_TARGET_OPTABS\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      smul_optab->handlers[(int) HImode].libfunc\t\t\\\n+\t= init_one_libfunc (MULHI3_LIBCALL);\t\t\t\\\n+      sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n+\t= init_one_libfunc (DIVHI3_LIBCALL);\t\t\t\\\n+      udiv_optab->handlers[(int) HImode].libfunc\t\t\\\n+\t= init_one_libfunc (UDIVHI3_LIBCALL);\t\t\t\\\n+      smod_optab->handlers[(int) HImode].libfunc\t\t\\\n+\t= init_one_libfunc (MODHI3_LIBCALL);\t\t\t\\\n+      umod_optab->handlers[(int) HImode].libfunc\t\t\\\n+\t= init_one_libfunc (UMODHI3_LIBCALL);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define MOVE_RATIO 3\n "}]}