{"sha": "7e6cb0221424399d27a07d3dadd09ad6967e41cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U2Y2IwMjIxNDI0Mzk5ZDI3YTA3ZDNkYWRkMDlhZDY5NjdlNDFjZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-01-25T14:10:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-01-25T14:10:46Z"}, "message": "re PR rtl-optimization/37273 (IRA does not re-materializes addresses (loads from the TOC))\n\n\tPR rtl-optimization/37273\n\t* ira-costs.c (scan_one_insn): Detect constants living in memory and\n\thandle them like argument loads from stack slots.  Do not double\n\tcount memory for memory constants and argument loads from stack slots.\n\nFrom-SVN: r169231", "tree": {"sha": "1f0c96fac3818cfb4a85ccde3cf27fb2245a19db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f0c96fac3818cfb4a85ccde3cf27fb2245a19db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e6cb0221424399d27a07d3dadd09ad6967e41cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6cb0221424399d27a07d3dadd09ad6967e41cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e6cb0221424399d27a07d3dadd09ad6967e41cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6cb0221424399d27a07d3dadd09ad6967e41cd/comments", "author": null, "committer": null, "parents": [{"sha": "315d905fd552d1ace2196310e527407f9b5bdbd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315d905fd552d1ace2196310e527407f9b5bdbd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315d905fd552d1ace2196310e527407f9b5bdbd8"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "6e8a528b43632e1e5b6d0df219268260c3bb1892", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e6cb0221424399d27a07d3dadd09ad6967e41cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e6cb0221424399d27a07d3dadd09ad6967e41cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e6cb0221424399d27a07d3dadd09ad6967e41cd", "patch": "@@ -1,3 +1,10 @@\n+2011-01-25  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/37273\n+\t* ira-costs.c (scan_one_insn): Detect constants living in memory and\n+\thandle them like argument loads from stack slots.  Do not double\n+\tcount memory for memory constants and argument loads from stack slots.\n+\n 2011-01-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/47427"}, {"sha": "6db5bf29b529d1f3713309d79fa9b6d24adf15fa", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e6cb0221424399d27a07d3dadd09ad6967e41cd/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e6cb0221424399d27a07d3dadd09ad6967e41cd/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=7e6cb0221424399d27a07d3dadd09ad6967e41cd", "patch": "@@ -1,5 +1,5 @@\n /* IRA hard register and memory cost calculation for allocnos or pseudos.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n \n@@ -1009,6 +1009,7 @@ scan_one_insn (rtx insn)\n   enum rtx_code pat_code;\n   rtx set, note;\n   int i, k;\n+  bool counted_mem;\n \n   if (!NONDEBUG_INSN_P (insn))\n     return insn;\n@@ -1018,15 +1019,23 @@ scan_one_insn (rtx insn)\n       || pat_code == ADDR_VEC || pat_code == ADDR_DIFF_VEC)\n     return insn;\n \n+  counted_mem = false;\n   set = single_set (insn);\n   extract_insn (insn);\n \n   /* If this insn loads a parameter from its stack slot, then it\n      represents a savings, rather than a cost, if the parameter is\n-     stored in memory.  Record this fact.  */\n+     stored in memory.  Record this fact. \n+\n+     Similarly if we're loading other constants from memory (constant\n+     pool, TOC references, small data areas, etc) and this is the only\n+     assignment to the destination pseudo.  */\n   if (set != 0 && REG_P (SET_DEST (set)) && MEM_P (SET_SRC (set))\n       && (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != NULL_RTX\n-      && MEM_P (XEXP (note, 0)))\n+      && ((MEM_P (XEXP (note, 0)))\n+\t  || (CONSTANT_P (XEXP (note, 0))\n+\t      && LEGITIMATE_CONSTANT_P (XEXP (note, 0))\n+\t      && REG_N_SETS (REGNO (SET_DEST (set))) == 1)))\n     {\n       enum reg_class cl = GENERAL_REGS;\n       rtx reg = SET_DEST (set);\n@@ -1038,6 +1047,7 @@ scan_one_insn (rtx insn)\n \t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n       record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n \t\t\t   0, MEM, SCRATCH, frequency * 2);\n+      counted_mem = true;\n     }\n \n   record_operand_costs (insn, pref);\n@@ -1052,7 +1062,10 @@ scan_one_insn (rtx insn)\n \tstruct costs *p = COSTS (costs, COST_INDEX (regno));\n \tstruct costs *q = op_costs[i];\n \n-\tp->mem_cost += q->mem_cost;\n+\t/* If the already accounted for the memory \"cost\" above, don't\n+\t   do so again.  */\n+\tif (!counted_mem)\n+\t  p->mem_cost += q->mem_cost;\n \tfor (k = 0; k < cost_classes_num; k++)\n \t  p->cost[k] += q->cost[k];\n       }"}]}