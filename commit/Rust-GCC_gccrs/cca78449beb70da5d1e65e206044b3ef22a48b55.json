{"sha": "cca78449beb70da5d1e65e206044b3ef22a48b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NhNzg0NDliZWI3MGRhNWQxZTY1ZTIwNjA0NGIzZWYyMmE0OGI1NQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-11-13T19:13:40Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-11-13T19:13:40Z"}, "message": "Move plain value_range things to value-range.[hc]*.\n\nFrom-SVN: r278153", "tree": {"sha": "7166217f4585418b79d0ba6b4ebe36ed9580288a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7166217f4585418b79d0ba6b4ebe36ed9580288a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cca78449beb70da5d1e65e206044b3ef22a48b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca78449beb70da5d1e65e206044b3ef22a48b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca78449beb70da5d1e65e206044b3ef22a48b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca78449beb70da5d1e65e206044b3ef22a48b55/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "425ea30f79e236c187430749be994309968e1dbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425ea30f79e236c187430749be994309968e1dbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425ea30f79e236c187430749be994309968e1dbd"}], "stats": {"total": 3537, "additions": 1790, "deletions": 1747}, "files": [{"sha": "b51665e28cb6aecb0cca75dd3ef3d99e54762cb8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -1,9 +1,30 @@\n+2019-11-13  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add value-range.o.\n+\t(GTFILES): Add value-range.h.\n+\t* gengtype.c (open_base_files): Add value-range.h to list of\n+\theader files.\n+\t* tree-vrp.c: Move the following value_range related functions:\n+\tranges_from_anti_range, value_range, check, equal_p, symbolic_p,\n+\tconstant_p, set_undefined, set_varying, may_contain_p,\n+\tsingleton_p, type, dump, dump_value_range, debug, vrp_val_max,\n+\tvrp_val_min, vrp_val_is_min, vrp_val_is_max, set, set_nonzero,\n+\tset_zero, vrp_operand_equal_p, range_has_numeric_bounds_p,\n+\tvalue_inside_range, ranges_from_anti_range, union_ranges,\n+\tintersect_ranges, intersect_helper, union_helper, union_,\n+\tnormalize_addresses, normalize_symbolics, num_pairs, lower_bound,\n+\tupper_bound, contains_p, invert, intersect...\n+\t* value-range.cc: ...to here.\n+\t* tree-vrp.h: Move class value_range, enum_value_range_kind, and\n+\tassociated inline methods from here...\n+\t* value-range.h: ...to here.\n+\n 2019-11-13  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>\n \n \t* config/mips/mips.md (rotr<mode>3): Sanitize the constant argument\n \tinstead of asserting its value.\n \n-2019-11-13  Aldy Hernandez  <aldyh@redhat.com>\n+(2019-11-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gimple-fold.c (size_must_be_zero_p): Rewrite use of value_range\n \tconstructors and set methods so value_range_kind is the last"}, {"sha": "7d3c13230e42bae8f6175a1d4bdb91fba0077ec0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -1602,6 +1602,7 @@ OBJS = \\\n \ttyped-splay-tree.o \\\n \tunique-ptr-tests.o \\\n \tvaltrack.o \\\n+\tvalue-range.o \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\\n \tvarasm.o \\\n@@ -2589,6 +2590,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/target-globals.h \\\n   $(srcdir)/ipa-predicate.h \\\n   $(srcdir)/ipa-fnsummary.h \\\n+  $(srcdir)/value-range.h \\\n   $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\\n   $(srcdir)/ubsan.c \\"}, {"sha": "fa95776876da9c96804c01c52526420137e6dec6", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -1717,6 +1717,7 @@ open_base_files (void)\n       \"explow.h\", \"calls.h\", \"memmodel.h\", \"emit-rtl.h\", \"varasm.h\",\n       \"stmt.h\", \"expr.h\", \"alloc-pool.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"internal-fn.h\", \"gimple-fold.h\",\n+      \"value-range.h\",\n       \"tree-eh.h\", \"gimple-iterator.h\", \"gimple-ssa.h\", \"tree-cfg.h\",\n       \"tree-vrp.h\", \"tree-phinodes.h\", \"ssa-iterators.h\", \"stringpool.h\",\n       \"tree-ssanames.h\", \"tree-ssa-loop.h\", \"tree-ssa-loop-ivopts.h\","}, {"sha": "c47c65bd2949c792bd83ba86fd43d0b83642f61a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 7, "deletions": 1543, "changes": 1550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -68,10 +68,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"range-op.h\"\n \n-static bool\n-ranges_from_anti_range (const value_range *ar,\n-\t\t\tvalue_range *vr0, value_range *vr1);\n-\n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n@@ -111,11 +107,6 @@ value_range_equiv::set (tree min, tree max, bitmap equiv,\n     check ();\n }\n \n-value_range::value_range (tree min, tree max, value_range_kind kind)\n-{\n-  set (min, max, kind);\n-}\n-\n value_range_equiv::value_range_equiv (tree min, tree max, bitmap equiv,\n \t\t\t\t      value_range_kind kind)\n {\n@@ -129,21 +120,6 @@ value_range_equiv::value_range_equiv (const value_range &other)\n   set (other.min(), other.max (), NULL, other.kind ());\n }\n \n-value_range::value_range (tree type)\n-{\n-  set_varying (type);\n-}\n-\n-value_range::value_range (tree type,\n-\t\t\t  const wide_int &wmin, const wide_int &wmax,\n-\t\t\t  enum value_range_kind kind)\n-{\n-  tree min = wide_int_to_tree (type, wmin);\n-  tree max = wide_int_to_tree (type, wmax);\n-  gcc_checking_assert (kind == VR_RANGE || kind == VR_ANTI_RANGE);\n-  set (min, max, kind);\n-}\n-\n /* Like set, but keep the equivalences in place.  */\n \n void\n@@ -173,42 +149,6 @@ value_range_equiv::move (value_range_equiv *from)\n   from->m_equiv = NULL;\n }\n \n-/* Check the validity of the range.  */\n-\n-void\n-value_range::check ()\n-{\n-  switch (m_kind)\n-    {\n-    case VR_RANGE:\n-    case VR_ANTI_RANGE:\n-      {\n-\tint cmp;\n-\n-\tgcc_assert (m_min && m_max);\n-\n-\tgcc_assert (!TREE_OVERFLOW_P (m_min) && !TREE_OVERFLOW_P (m_max));\n-\n-\t/* Creating ~[-MIN, +MAX] is stupid because that would be\n-\t   the empty set.  */\n-\tif (INTEGRAL_TYPE_P (TREE_TYPE (m_min)) && m_kind == VR_ANTI_RANGE)\n-\t  gcc_assert (!vrp_val_is_min (m_min) || !vrp_val_is_max (m_max));\n-\n-\tcmp = compare_values (m_min, m_max);\n-\tgcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n-\tbreak;\n-      }\n-    case VR_UNDEFINED:\n-      gcc_assert (!min () && !max ());\n-      break;\n-    case VR_VARYING:\n-      gcc_assert (m_min && m_max);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n void\n value_range_equiv::check ()\n {\n@@ -222,22 +162,6 @@ value_range_equiv::check ()\n     }\n }\n \n-/* Equality operator.  We purposely do not overload ==, to avoid\n-   confusion with the equality bitmap in the derived value_range\n-   class.  */\n-\n-bool\n-value_range::equal_p (const value_range &other) const\n-{\n-  /* Ignore types for undefined.  All undefines are equal.  */\n-  if (undefined_p ())\n-    return m_kind == other.m_kind;\n-\n-  return (m_kind == other.m_kind\n-\t  && vrp_operand_equal_p (m_min, other.m_min)\n-\t  && vrp_operand_equal_p (m_max, other.m_max));\n-}\n-\n /* Return true if the bitmaps B1 and B2 are equal.  */\n \n static bool\n@@ -262,73 +186,19 @@ value_range_equiv::equal_p (const value_range_equiv &other,\n \t      || vrp_bitmap_equal_p (m_equiv, other.m_equiv)));\n }\n \n-/* Return TRUE if this is a symbolic range.  */\n-\n-bool\n-value_range::symbolic_p () const\n-{\n-  return (!varying_p ()\n-\t  && !undefined_p ()\n-\t  && (!is_gimple_min_invariant (m_min)\n-\t      || !is_gimple_min_invariant (m_max)));\n-}\n-\n-/* NOTE: This is not the inverse of symbolic_p because the range\n-   could also be varying or undefined.  Ideally they should be inverse\n-   of each other, with varying only applying to symbolics.  Varying of\n-   constants would be represented as [-MIN, +MAX].  */\n-\n-bool\n-value_range::constant_p () const\n-{\n-  return (!varying_p ()\n-\t  && !undefined_p ()\n-\t  && TREE_CODE (m_min) == INTEGER_CST\n-\t  && TREE_CODE (m_max) == INTEGER_CST);\n-}\n-\n-void\n-value_range::set_undefined ()\n-{\n-  m_kind = VR_UNDEFINED;\n-  m_min = m_max = NULL;\n-}\n-\n void\n value_range_equiv::set_undefined ()\n {\n   set (NULL, NULL, NULL, VR_UNDEFINED);\n }\n \n-void\n-value_range::set_varying (tree type)\n-{\n-  m_kind = VR_VARYING;\n-  if (supports_type_p (type))\n-    {\n-      m_min = vrp_val_min (type);\n-      m_max = vrp_val_max (type);\n-    }\n-  else\n-    /* We can't do anything range-wise with these types.  */\n-    m_min = m_max = error_mark_node;\n-}\n-\n void\n value_range_equiv::set_varying (tree type)\n {\n   value_range::set_varying (type);\n   equiv_clear ();\n }\n \n-/* Return TRUE if it is possible that range contains VAL.  */\n-\n-bool\n-value_range::may_contain_p (tree val) const\n-{\n-  return value_inside_range (val) != 0;\n-}\n-\n void\n value_range_equiv::equiv_clear ()\n {\n@@ -356,98 +226,6 @@ value_range_equiv::equiv_add (const_tree var,\n     bitmap_ior_into (m_equiv, var_vr->m_equiv);\n }\n \n-/* If range is a singleton, place it in RESULT and return TRUE.\n-   Note: A singleton can be any gimple invariant, not just constants.\n-   So, [&x, &x] counts as a singleton.  */\n-\n-bool\n-value_range::singleton_p (tree *result) const\n-{\n-  if (m_kind == VR_ANTI_RANGE)\n-    {\n-      if (nonzero_p ())\n-\t{\n-\t  if (TYPE_PRECISION (type ()) == 1)\n-\t    {\n-\t      if (result)\n-\t\t*result = m_max;\n-\t      return true;\n-\t    }\n-\t  return false;\n-\t}\n-      if (num_pairs () == 1)\n-\t{\n-\t  value_range vr0, vr1;\n-\t  ranges_from_anti_range (this, &vr0, &vr1);\n-\t  return vr0.singleton_p (result);\n-\t}\n-    }\n-  if (m_kind == VR_RANGE\n-      && vrp_operand_equal_p (min (), max ())\n-      && is_gimple_min_invariant (min ()))\n-    {\n-      if (result)\n-        *result = min ();\n-      return true;\n-    }\n-  return false;\n-}\n-\n-tree\n-value_range::type () const\n-{\n-  gcc_checking_assert (m_min);\n-  return TREE_TYPE (min ());\n-}\n-\n-void\n-value_range::dump (FILE *file) const\n-{\n-  if (undefined_p ())\n-    fprintf (file, \"UNDEFINED\");\n-  else if (m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n-    {\n-      tree ttype = type ();\n-\n-      print_generic_expr (file, ttype);\n-      fprintf (file, \" \");\n-\n-      fprintf (file, \"%s[\", (m_kind == VR_ANTI_RANGE) ? \"~\" : \"\");\n-\n-      if (INTEGRAL_TYPE_P (ttype)\n-\t  && !TYPE_UNSIGNED (ttype)\n-\t  && vrp_val_is_min (min ())\n-\t  && TYPE_PRECISION (ttype) != 1)\n-\tfprintf (file, \"-INF\");\n-      else\n-\tprint_generic_expr (file, min ());\n-\n-      fprintf (file, \", \");\n-\n-      if (supports_type_p (ttype)\n-\t  && vrp_val_is_max (max ())\n-\t  && TYPE_PRECISION (ttype) != 1)\n-\tfprintf (file, \"+INF\");\n-      else\n-\tprint_generic_expr (file, max ());\n-\n-      fprintf (file, \"]\");\n-    }\n-  else if (varying_p ())\n-    {\n-      print_generic_expr (file, type ());\n-      fprintf (file, \" VARYING\");\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n-void\n-value_range::dump () const\n-{\n-  dump (stderr);\n-}\n-\n void\n value_range_equiv::dump (FILE *file) const\n {\n@@ -486,27 +264,6 @@ dump_value_range (FILE *file, const value_range_equiv *vr)\n     vr->dump (file);\n }\n \n-void\n-dump_value_range (FILE *file, const value_range *vr)\n-{\n-  if (!vr)\n-    fprintf (file, \"[]\");\n-  else\n-    vr->dump (file);\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const value_range *vr)\n-{\n-  dump_value_range (stderr, vr);\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const value_range &vr)\n-{\n-  dump_value_range (stderr, &vr);\n-}\n-\n DEBUG_FUNCTION void\n debug (const value_range_equiv *vr)\n {\n@@ -567,58 +324,6 @@ static bitmap need_assert_for;\n    ASSERT_EXPRs for SSA name N_I should be inserted.  */\n static assert_locus **asserts_for;\n \n-/* Return the maximum value for TYPE.  */\n-\n-tree\n-vrp_val_max (const_tree type)\n-{\n-  if (INTEGRAL_TYPE_P (type))\n-    return TYPE_MAX_VALUE (type);\n-  if (POINTER_TYPE_P (type))\n-    {\n-      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n-      return wide_int_to_tree (const_cast<tree> (type), max);\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Return the minimum value for TYPE.  */\n-\n-tree\n-vrp_val_min (const_tree type)\n-{\n-  if (INTEGRAL_TYPE_P (type))\n-    return TYPE_MIN_VALUE (type);\n-  if (POINTER_TYPE_P (type))\n-    return build_zero_cst (const_cast<tree> (type));\n-  return NULL_TREE;\n-}\n-\n-/* Return whether VAL is equal to the maximum value of its type.\n-   We can't do a simple equality comparison with TYPE_MAX_VALUE because\n-   C typedefs and Ada subtypes can produce types whose TYPE_MAX_VALUE\n-   is not == to the integer constant with the same value in the type.  */\n-\n-bool\n-vrp_val_is_max (const_tree val)\n-{\n-  tree type_max = vrp_val_max (TREE_TYPE (val));\n-  return (val == type_max\n-\t  || (type_max != NULL_TREE\n-\t      && operand_equal_p (val, type_max, 0)));\n-}\n-\n-/* Return whether VAL is equal to the minimum value of its type.  */\n-\n-bool\n-vrp_val_is_min (const_tree val)\n-{\n-  tree type_min = vrp_val_min (TREE_TYPE (val));\n-  return (val == type_min\n-\t  || (type_min != NULL_TREE\n-\t      && operand_equal_p (val, type_min, 0)));\n-}\n-\n /* VR_TYPE describes a range with mininum value *MIN and maximum\n    value *MAX.  Restrict the range to the set of values that have\n    no bits set outside NONZERO_BITS.  Update *MIN and *MAX and\n@@ -691,184 +396,6 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n   return vr_type;\n }\n \n-\n-/* Set value range to the canonical form of {VRTYPE, MIN, MAX, EQUIV}.\n-   This means adjusting VRTYPE, MIN and MAX representing the case of a\n-   wrapping range with MAX < MIN covering [MIN, type_max] U [type_min, MAX]\n-   as anti-rage ~[MAX+1, MIN-1].  Likewise for wrapping anti-ranges.\n-   In corner cases where MAX+1 or MIN-1 wraps this will fall back\n-   to varying.\n-   This routine exists to ease canonicalization in the case where we\n-   extract ranges from var + CST op limit.  */\n-\n-void\n-value_range::set (tree min, tree max, value_range_kind kind)\n-{\n-  /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n-  if (kind == VR_UNDEFINED)\n-    {\n-      set_undefined ();\n-      return;\n-    }\n-  else if (kind == VR_VARYING)\n-    {\n-      gcc_assert (TREE_TYPE (min) == TREE_TYPE (max));\n-      tree typ = TREE_TYPE (min);\n-      if (supports_type_p (typ))\n-\t{\n-\t  gcc_assert (vrp_val_min (typ));\n-\t  gcc_assert (vrp_val_max (typ));\n-\t}\n-      set_varying (typ);\n-      return;\n-    }\n-\n-  /* Convert POLY_INT_CST bounds into worst-case INTEGER_CST bounds.  */\n-  if (POLY_INT_CST_P (min))\n-    {\n-      tree type_min = vrp_val_min (TREE_TYPE (min));\n-      widest_int lb\n-\t= constant_lower_bound_with_limit (wi::to_poly_widest (min),\n-\t\t\t\t\t   wi::to_widest (type_min));\n-      min = wide_int_to_tree (TREE_TYPE (min), lb);\n-    }\n-  if (POLY_INT_CST_P (max))\n-    {\n-      tree type_max = vrp_val_max (TREE_TYPE (max));\n-      widest_int ub\n-\t= constant_upper_bound_with_limit (wi::to_poly_widest (max),\n-\t\t\t\t\t   wi::to_widest (type_max));\n-      max = wide_int_to_tree (TREE_TYPE (max), ub);\n-    }\n-\n-  /* Nothing to canonicalize for symbolic ranges.  */\n-  if (TREE_CODE (min) != INTEGER_CST\n-      || TREE_CODE (max) != INTEGER_CST)\n-    {\n-      m_kind = kind;\n-      m_min = min;\n-      m_max = max;\n-      return;\n-    }\n-\n-  /* Wrong order for min and max, to swap them and the VR type we need\n-     to adjust them.  */\n-  if (tree_int_cst_lt (max, min))\n-    {\n-      tree one, tmp;\n-\n-      /* For one bit precision if max < min, then the swapped\n-\t range covers all values, so for VR_RANGE it is varying and\n-\t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n-      if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n-\t{\n-\t  set_varying (TREE_TYPE (min));\n-\t  return;\n-\t}\n-\n-      one = build_int_cst (TREE_TYPE (min), 1);\n-      tmp = int_const_binop (PLUS_EXPR, max, one);\n-      max = int_const_binop (MINUS_EXPR, min, one);\n-      min = tmp;\n-\n-      /* There's one corner case, if we had [C+1, C] before we now have\n-\t that again.  But this represents an empty value range, so drop\n-\t to varying in this case.  */\n-      if (tree_int_cst_lt (max, min))\n-\t{\n-\t  set_varying (TREE_TYPE (min));\n-\t  return;\n-\t}\n-\n-      kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n-    }\n-\n-  tree type = TREE_TYPE (min);\n-\n-  /* Anti-ranges that can be represented as ranges should be so.  */\n-  if (kind == VR_ANTI_RANGE)\n-    {\n-      /* For -fstrict-enums we may receive out-of-range ranges so consider\n-         values < -INF and values > INF as -INF/INF as well.  */\n-      bool is_min = vrp_val_is_min (min);\n-      bool is_max = vrp_val_is_max (max);\n-\n-      if (is_min && is_max)\n-\t{\n-\t  /* We cannot deal with empty ranges, drop to varying.\n-\t     ???  This could be VR_UNDEFINED instead.  */\n-\t  set_varying (type);\n-\t  return;\n-\t}\n-      else if (TYPE_PRECISION (TREE_TYPE (min)) == 1\n-\t       && (is_min || is_max))\n-\t{\n-\t  /* Non-empty boolean ranges can always be represented\n-\t     as a singleton range.  */\n-\t  if (is_min)\n-\t    min = max = vrp_val_max (TREE_TYPE (min));\n-\t  else\n-\t    min = max = vrp_val_min (TREE_TYPE (min));\n-\t  kind = VR_RANGE;\n-\t}\n-      else if (is_min)\n-        {\n-\t  tree one = build_int_cst (TREE_TYPE (max), 1);\n-\t  min = int_const_binop (PLUS_EXPR, max, one);\n-\t  max = vrp_val_max (TREE_TYPE (max));\n-\t  kind = VR_RANGE;\n-        }\n-      else if (is_max)\n-        {\n-\t  tree one = build_int_cst (TREE_TYPE (min), 1);\n-\t  max = int_const_binop (MINUS_EXPR, min, one);\n-\t  min = vrp_val_min (TREE_TYPE (min));\n-\t  kind = VR_RANGE;\n-        }\n-    }\n-\n-  /* Normalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n-\n-     Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n-     restrict those to a subset of what actually fits in the type.\n-     Instead use the extremes of the type precision which will allow\n-     compare_range_with_value() to check if a value is inside a range,\n-     whereas if we used TYPE_*_VAL, said function would just punt\n-     upon seeing a VARYING.  */\n-  unsigned prec = TYPE_PRECISION (type);\n-  signop sign = TYPE_SIGN (type);\n-  if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n-      && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n-    {\n-      if (kind == VR_RANGE)\n-\tset_varying (type);\n-      else if (kind == VR_ANTI_RANGE)\n-\tset_undefined ();\n-      else\n-\tgcc_unreachable ();\n-      return;\n-    }\n-\n-  /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n-     to make sure VRP iteration terminates, otherwise we can get into\n-     oscillations.  */\n-\n-  m_kind = kind;\n-  m_min = min;\n-  m_max = max;\n-  if (flag_checking)\n-    check ();\n-}\n-\n-void\n-value_range::set (tree val)\n-{\n-  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n-  if (TREE_OVERFLOW_P (val))\n-    val = drop_tree_overflow (val);\n-  set (val, val);\n-}\n-\n void\n value_range_equiv::set (tree val)\n {\n@@ -878,43 +405,6 @@ value_range_equiv::set (tree val)\n   set (val, val);\n }\n \n-/* Set value range VR to a nonzero range of type TYPE.  */\n-\n-void\n-value_range::set_nonzero (tree type)\n-{\n-  tree zero = build_int_cst (type, 0);\n-  set (zero, zero, VR_ANTI_RANGE);\n-}\n-\n-/* Set value range VR to a ZERO range of type TYPE.  */\n-\n-void\n-value_range::set_zero (tree type)\n-{\n-  set (build_int_cst (type, 0));\n-}\n-\n-/* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */\n-\n-bool\n-vrp_operand_equal_p (const_tree val1, const_tree val2)\n-{\n-  if (val1 == val2)\n-    return true;\n-  if (!val1 || !val2 || !operand_equal_p (val1, val2, 0))\n-    return false;\n-  return true;\n-}\n-\n-static bool\n-range_has_numeric_bounds_p (const value_range *vr)\n-{\n-  return (vr->min ()\n-\t  && TREE_CODE (vr->min ()) == INTEGER_CST\n-\t  && TREE_CODE (vr->max ()) == INTEGER_CST);\n-}\n-\n /* Return true if max and min of VR are INTEGER_CST.  It's not necessary\n    a singleton.  */\n \n@@ -1210,91 +700,17 @@ compare_values (tree val1, tree val2)\n   return compare_values_warnv (val1, val2, &sop);\n }\n \n+/* If BOUND will include a symbolic bound, adjust it accordingly,\n+   otherwise leave it as is.\n \n-/* Return 1 if VAL is inside value range.\n-          0 if VAL is not inside value range.\n-\t -2 if we cannot tell either way.\n-\n-   Benchmark compile/20001226-1.c compilation time after changing this\n-   function.  */\n-\n-int\n-value_range::value_inside_range (tree val) const\n-{\n-  int cmp1, cmp2;\n+   CODE is the original operation that combined the bounds (PLUS_EXPR\n+   or MINUS_EXPR).\n \n-  if (varying_p ())\n-    return 1;\n+   TYPE is the type of the original operation.\n \n-  if (undefined_p ())\n-    return 0;\n+   SYM_OPn is the symbolic for OPn if it has a symbolic.\n \n-  cmp1 = operand_less_p (val, m_min);\n-  if (cmp1 == -2)\n-    return -2;\n-  if (cmp1 == 1)\n-    return m_kind != VR_RANGE;\n-\n-  cmp2 = operand_less_p (m_max, val);\n-  if (cmp2 == -2)\n-    return -2;\n-\n-  if (m_kind == VR_RANGE)\n-    return !cmp2;\n-  else\n-    return !!cmp2;\n-}\n-\n-/* Create two value-ranges in *VR0 and *VR1 from the anti-range *AR\n-   so that *VR0 U *VR1 == *AR.  Returns true if that is possible,\n-   false otherwise.  If *AR can be represented with a single range\n-   *VR1 will be VR_UNDEFINED.  */\n-\n-static bool\n-ranges_from_anti_range (const value_range *ar,\n-\t\t\tvalue_range *vr0, value_range *vr1)\n-{\n-  tree type = ar->type ();\n-\n-  vr0->set_undefined ();\n-  vr1->set_undefined ();\n-\n-  /* As a future improvement, we could handle ~[0, A] as: [-INF, -1] U\n-     [A+1, +INF].  Not sure if this helps in practice, though.  */\n-\n-  if (ar->kind () != VR_ANTI_RANGE\n-      || TREE_CODE (ar->min ()) != INTEGER_CST\n-      || TREE_CODE (ar->max ()) != INTEGER_CST\n-      || !vrp_val_min (type)\n-      || !vrp_val_max (type))\n-    return false;\n-\n-  if (tree_int_cst_lt (vrp_val_min (type), ar->min ()))\n-    vr0->set (vrp_val_min (type),\n-\t      wide_int_to_tree (type, wi::to_wide (ar->min ()) - 1));\n-  if (tree_int_cst_lt (ar->max (), vrp_val_max (type)))\n-    vr1->set (wide_int_to_tree (type, wi::to_wide (ar->max ()) + 1),\n-\t      vrp_val_max (type));\n-  if (vr0->undefined_p ())\n-    {\n-      *vr0 = *vr1;\n-      vr1->set_undefined ();\n-    }\n-\n-  return !vr0->undefined_p ();\n-}\n-\n-/* If BOUND will include a symbolic bound, adjust it accordingly,\n-   otherwise leave it as is.\n-\n-   CODE is the original operation that combined the bounds (PLUS_EXPR\n-   or MINUS_EXPR).\n-\n-   TYPE is the type of the original operation.\n-\n-   SYM_OPn is the symbolic for OPn if it has a symbolic.\n-\n-   NEG_OPn is TRUE if the OPn was negated.  */\n+   NEG_OPn is TRUE if the OPn was negated.  */\n \n static void\n adjust_symbolic_bound (tree &bound, enum tree_code code, tree type,\n@@ -5224,669 +4640,6 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n   return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n }\n \n-/* Union the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n-   { VR1TYPE, VR0MIN, VR0MAX } and store the result\n-   in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest\n-   possible such range.  The resulting range is not canonicalized.  */\n-\n-static void\n-union_ranges (enum value_range_kind *vr0type,\n-\t      tree *vr0min, tree *vr0max,\n-\t      enum value_range_kind vr1type,\n-\t      tree vr1min, tree vr1max)\n-{\n-  int cmpmin = compare_values (*vr0min, vr1min);\n-  int cmpmax = compare_values (*vr0max, vr1max);\n-  bool mineq = cmpmin == 0;\n-  bool maxeq = cmpmax == 0;\n-\n-  /* [] is vr0, () is vr1 in the following classification comments.  */\n-  if (mineq && maxeq)\n-    {\n-      /* [(  )] */\n-      if (*vr0type == vr1type)\n-\t/* Nothing to do for equal ranges.  */\n-\t;\n-      else if ((*vr0type == VR_RANGE\n-\t\t&& vr1type == VR_ANTI_RANGE)\n-\t       || (*vr0type == VR_ANTI_RANGE\n-\t\t   && vr1type == VR_RANGE))\n-\t{\n-\t  /* For anti-range with range union the result is varying.  */\n-\t  goto give_up;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (operand_less_p (*vr0max, vr1min) == 1\n-\t   || operand_less_p (vr1max, *vr0min) == 1)\n-    {\n-      /* [ ] ( ) or ( ) [ ]\n-\t If the ranges have an empty intersection, result of the union\n-\t operation is the anti-range or if both are anti-ranges\n-\t it covers all.  */\n-      if (*vr0type == VR_ANTI_RANGE\n-\t  && vr1type == VR_ANTI_RANGE)\n-\tgoto give_up;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t;\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  *vr0type = vr1type;\n-\t  *vr0min = vr1min;\n-\t  *vr0max = vr1max;\n-\t}\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  /* The result is the convex hull of both ranges.  */\n-\t  if (operand_less_p (*vr0max, vr1min) == 1)\n-\t    {\n-\t      /* If the result can be an anti-range, create one.  */\n-\t      if (TREE_CODE (*vr0max) == INTEGER_CST\n-\t\t  && TREE_CODE (vr1min) == INTEGER_CST\n-\t\t  && vrp_val_is_min (*vr0min)\n-\t\t  && vrp_val_is_max (vr1max))\n-\t\t{\n-\t\t  tree min = int_const_binop (PLUS_EXPR,\n-\t\t\t\t\t      *vr0max,\n-\t\t\t\t\t      build_int_cst (TREE_TYPE (*vr0max), 1));\n-\t\t  tree max = int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t      vr1min,\n-\t\t\t\t\t      build_int_cst (TREE_TYPE (vr1min), 1));\n-\t\t  if (!operand_less_p (max, min))\n-\t\t    {\n-\t\t      *vr0type = VR_ANTI_RANGE;\n-\t\t      *vr0min = min;\n-\t\t      *vr0max = max;\n-\t\t    }\n-\t\t  else\n-\t\t    *vr0max = vr1max;\n-\t\t}\n-\t      else\n-\t\t*vr0max = vr1max;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If the result can be an anti-range, create one.  */\n-\t      if (TREE_CODE (vr1max) == INTEGER_CST\n-\t\t  && TREE_CODE (*vr0min) == INTEGER_CST\n-\t\t  && vrp_val_is_min (vr1min)\n-\t\t  && vrp_val_is_max (*vr0max))\n-\t\t{\n-\t\t  tree min = int_const_binop (PLUS_EXPR,\n-\t\t\t\t\t      vr1max,\n-\t\t\t\t\t      build_int_cst (TREE_TYPE (vr1max), 1));\n-\t\t  tree max = int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t      *vr0min,\n-\t\t\t\t\t      build_int_cst (TREE_TYPE (*vr0min), 1));\n-\t\t  if (!operand_less_p (max, min))\n-\t\t    {\n-\t\t      *vr0type = VR_ANTI_RANGE;\n-\t\t      *vr0min = min;\n-\t\t      *vr0max = max;\n-\t\t    }\n-\t\t  else\n-\t\t    *vr0min = vr1min;\n-\t\t}\n-\t      else\n-\t\t*vr0min = vr1min;\n-\t    }\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if ((maxeq || cmpmax == 1)\n-\t   && (mineq || cmpmin == -1))\n-    {\n-      /* [ (  ) ] or [(  ) ] or [ (  )] */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_RANGE)\n-\t;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  *vr0type = vr1type;\n-\t  *vr0min = vr1min;\n-\t  *vr0max = vr1max;\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  /* Arbitrarily choose the right or left gap.  */\n-\t  if (!mineq && TREE_CODE (vr1min) == INTEGER_CST)\n-\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n-\t\t\t\t       build_int_cst (TREE_TYPE (vr1min), 1));\n-\t  else if (!maxeq && TREE_CODE (vr1max) == INTEGER_CST)\n-\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n-\t\t\t\t       build_int_cst (TREE_TYPE (vr1max), 1));\n-\t  else\n-\t    goto give_up;\n-\t}\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t/* The result covers everything.  */\n-\tgoto give_up;\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if ((maxeq || cmpmax == -1)\n-\t   && (mineq || cmpmin == 1))\n-    {\n-      /* ( [  ] ) or ([  ] ) or ( [  ]) */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_RANGE)\n-\t{\n-\t  *vr0type = vr1type;\n-\t  *vr0min = vr1min;\n-\t  *vr0max = vr1max;\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t;\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  *vr0type = VR_ANTI_RANGE;\n-\t  if (!mineq && TREE_CODE (*vr0min) == INTEGER_CST)\n-\t    {\n-\t      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n-\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0min), 1));\n-\t      *vr0min = vr1min;\n-\t    }\n-\t  else if (!maxeq && TREE_CODE (*vr0max) == INTEGER_CST)\n-\t    {\n-\t      *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n-\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0max), 1));\n-\t      *vr0max = vr1max;\n-\t    }\n-\t  else\n-\t    goto give_up;\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t/* The result covers everything.  */\n-\tgoto give_up;\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (cmpmin == -1\n-\t   && cmpmax == -1\n-\t   && (operand_less_p (vr1min, *vr0max) == 1\n-\t       || operand_equal_p (vr1min, *vr0max, 0)))\n-    {\n-      /* [  (  ]  ) or [   ](   ) */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_RANGE)\n-\t*vr0max = vr1max;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t*vr0min = vr1min;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  if (TREE_CODE (vr1min) == INTEGER_CST)\n-\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n-\t\t\t\t       build_int_cst (TREE_TYPE (vr1min), 1));\n-\t  else\n-\t    goto give_up;\n-\t}\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  if (TREE_CODE (*vr0max) == INTEGER_CST)\n-\t    {\n-\t      *vr0type = vr1type;\n-\t      *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n-\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0max), 1));\n-\t      *vr0max = vr1max;\n-\t    }\n-\t  else\n-\t    goto give_up;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (cmpmin == 1\n-\t   && cmpmax == 1\n-\t   && (operand_less_p (*vr0min, vr1max) == 1\n-\t       || operand_equal_p (*vr0min, vr1max, 0)))\n-    {\n-      /* (  [  )  ] or (   )[   ] */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_RANGE)\n-\t*vr0min = vr1min;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t*vr0max = vr1max;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  if (TREE_CODE (vr1max) == INTEGER_CST)\n-\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n-\t\t\t\t       build_int_cst (TREE_TYPE (vr1max), 1));\n-\t  else\n-\t    goto give_up;\n-\t}\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  if (TREE_CODE (*vr0min) == INTEGER_CST)\n-\t    {\n-\t      *vr0type = vr1type;\n-\t      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n-\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0min), 1));\n-\t      *vr0min = vr1min;\n-\t    }\n-\t  else\n-\t    goto give_up;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else\n-    goto give_up;\n-\n-  return;\n-\n-give_up:\n-  *vr0type = VR_VARYING;\n-  *vr0min = NULL_TREE;\n-  *vr0max = NULL_TREE;\n-}\n-\n-/* Intersect the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n-   { VR1TYPE, VR0MIN, VR0MAX } and store the result\n-   in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest\n-   possible such range.  The resulting range is not canonicalized.  */\n-\n-static void\n-intersect_ranges (enum value_range_kind *vr0type,\n-\t\t  tree *vr0min, tree *vr0max,\n-\t\t  enum value_range_kind vr1type,\n-\t\t  tree vr1min, tree vr1max)\n-{\n-  bool mineq = vrp_operand_equal_p (*vr0min, vr1min);\n-  bool maxeq = vrp_operand_equal_p (*vr0max, vr1max);\n-\n-  /* [] is vr0, () is vr1 in the following classification comments.  */\n-  if (mineq && maxeq)\n-    {\n-      /* [(  )] */\n-      if (*vr0type == vr1type)\n-\t/* Nothing to do for equal ranges.  */\n-\t;\n-      else if ((*vr0type == VR_RANGE\n-\t\t&& vr1type == VR_ANTI_RANGE)\n-\t       || (*vr0type == VR_ANTI_RANGE\n-\t\t   && vr1type == VR_RANGE))\n-\t{\n-\t  /* For anti-range with range intersection the result is empty.  */\n-\t  *vr0type = VR_UNDEFINED;\n-\t  *vr0min = NULL_TREE;\n-\t  *vr0max = NULL_TREE;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (operand_less_p (*vr0max, vr1min) == 1\n-\t   || operand_less_p (vr1max, *vr0min) == 1)\n-    {\n-      /* [ ] ( ) or ( ) [ ]\n-\t If the ranges have an empty intersection, the result of the\n-\t intersect operation is the range for intersecting an\n-\t anti-range with a range or empty when intersecting two ranges.  */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_ANTI_RANGE)\n-\t;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  *vr0type = vr1type;\n-\t  *vr0min = vr1min;\n-\t  *vr0max = vr1max;\n-\t}\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  *vr0type = VR_UNDEFINED;\n-\t  *vr0min = NULL_TREE;\n-\t  *vr0max = NULL_TREE;\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  /* If the anti-ranges are adjacent to each other merge them.  */\n-\t  if (TREE_CODE (*vr0max) == INTEGER_CST\n-\t      && TREE_CODE (vr1min) == INTEGER_CST\n-\t      && operand_less_p (*vr0max, vr1min) == 1\n-\t      && integer_onep (int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t\tvr1min, *vr0max)))\n-\t    *vr0max = vr1max;\n-\t  else if (TREE_CODE (vr1max) == INTEGER_CST\n-\t\t   && TREE_CODE (*vr0min) == INTEGER_CST\n-\t\t   && operand_less_p (vr1max, *vr0min) == 1\n-\t\t   && integer_onep (int_const_binop (MINUS_EXPR,\n-\t\t\t\t\t\t     *vr0min, vr1max)))\n-\t    *vr0min = vr1min;\n-\t  /* Else arbitrarily take VR0.  */\n-\t}\n-    }\n-  else if ((maxeq || operand_less_p (vr1max, *vr0max) == 1)\n-\t   && (mineq || operand_less_p (*vr0min, vr1min) == 1))\n-    {\n-      /* [ (  ) ] or [(  ) ] or [ (  )] */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_RANGE)\n-\t{\n-\t  /* If both are ranges the result is the inner one.  */\n-\t  *vr0type = vr1type;\n-\t  *vr0min = vr1min;\n-\t  *vr0max = vr1max;\n-\t}\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  /* Choose the right gap if the left one is empty.  */\n-\t  if (mineq)\n-\t    {\n-\t      if (TREE_CODE (vr1max) != INTEGER_CST)\n-\t\t*vr0min = vr1max;\n-\t      else if (TYPE_PRECISION (TREE_TYPE (vr1max)) == 1\n-\t\t       && !TYPE_UNSIGNED (TREE_TYPE (vr1max)))\n-\t\t*vr0min\n-\t\t  = int_const_binop (MINUS_EXPR, vr1max,\n-\t\t\t\t     build_int_cst (TREE_TYPE (vr1max), -1));\n-\t      else\n-\t\t*vr0min\n-\t\t  = int_const_binop (PLUS_EXPR, vr1max,\n-\t\t\t\t     build_int_cst (TREE_TYPE (vr1max), 1));\n-\t    }\n-\t  /* Choose the left gap if the right one is empty.  */\n-\t  else if (maxeq)\n-\t    {\n-\t      if (TREE_CODE (vr1min) != INTEGER_CST)\n-\t\t*vr0max = vr1min;\n-\t      else if (TYPE_PRECISION (TREE_TYPE (vr1min)) == 1\n-\t\t       && !TYPE_UNSIGNED (TREE_TYPE (vr1min)))\n-\t\t*vr0max\n-\t\t  = int_const_binop (PLUS_EXPR, vr1min,\n-\t\t\t\t     build_int_cst (TREE_TYPE (vr1min), -1));\n-\t      else\n-\t\t*vr0max\n-\t\t  = int_const_binop (MINUS_EXPR, vr1min,\n-\t\t\t\t     build_int_cst (TREE_TYPE (vr1min), 1));\n-\t    }\n-\t  /* Choose the anti-range if the range is effectively varying.  */\n-\t  else if (vrp_val_is_min (*vr0min)\n-\t\t   && vrp_val_is_max (*vr0max))\n-\t    {\n-\t      *vr0type = vr1type;\n-\t      *vr0min = vr1min;\n-\t      *vr0max = vr1max;\n-\t    }\n-\t  /* Else choose the range.  */\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t/* If both are anti-ranges the result is the outer one.  */\n-\t;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  /* The intersection is empty.  */\n-\t  *vr0type = VR_UNDEFINED;\n-\t  *vr0min = NULL_TREE;\n-\t  *vr0max = NULL_TREE;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if ((maxeq || operand_less_p (*vr0max, vr1max) == 1)\n-\t   && (mineq || operand_less_p (vr1min, *vr0min) == 1))\n-    {\n-      /* ( [  ] ) or ([  ] ) or ( [  ]) */\n-      if (*vr0type == VR_RANGE\n-\t  && vr1type == VR_RANGE)\n-\t/* Choose the inner range.  */\n-\t;\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  /* Choose the right gap if the left is empty.  */\n-\t  if (mineq)\n-\t    {\n-\t      *vr0type = VR_RANGE;\n-\t      if (TREE_CODE (*vr0max) != INTEGER_CST)\n-\t\t*vr0min = *vr0max;\n-\t      else if (TYPE_PRECISION (TREE_TYPE (*vr0max)) == 1\n-\t\t       && !TYPE_UNSIGNED (TREE_TYPE (*vr0max)))\n-\t\t*vr0min\n-\t\t  = int_const_binop (MINUS_EXPR, *vr0max,\n-\t\t\t\t     build_int_cst (TREE_TYPE (*vr0max), -1));\n-\t      else\n-\t\t*vr0min\n-\t\t  = int_const_binop (PLUS_EXPR, *vr0max,\n-\t\t\t\t     build_int_cst (TREE_TYPE (*vr0max), 1));\n-\t      *vr0max = vr1max;\n-\t    }\n-\t  /* Choose the left gap if the right is empty.  */\n-\t  else if (maxeq)\n-\t    {\n-\t      *vr0type = VR_RANGE;\n-\t      if (TREE_CODE (*vr0min) != INTEGER_CST)\n-\t\t*vr0max = *vr0min;\n-\t      else if (TYPE_PRECISION (TREE_TYPE (*vr0min)) == 1\n-\t\t       && !TYPE_UNSIGNED (TREE_TYPE (*vr0min)))\n-\t\t*vr0max\n-\t\t  = int_const_binop (PLUS_EXPR, *vr0min,\n-\t\t\t\t     build_int_cst (TREE_TYPE (*vr0min), -1));\n-\t      else\n-\t\t*vr0max\n-\t\t  = int_const_binop (MINUS_EXPR, *vr0min,\n-\t\t\t\t     build_int_cst (TREE_TYPE (*vr0min), 1));\n-\t      *vr0min = vr1min;\n-\t    }\n-\t  /* Choose the anti-range if the range is effectively varying.  */\n-\t  else if (vrp_val_is_min (vr1min)\n-\t\t   && vrp_val_is_max (vr1max))\n-\t    ;\n-\t  /* Choose the anti-range if it is ~[0,0], that range is special\n-\t     enough to special case when vr1's range is relatively wide.\n-\t     At least for types bigger than int - this covers pointers\n-\t     and arguments to functions like ctz.  */\n-\t  else if (*vr0min == *vr0max\n-\t\t   && integer_zerop (*vr0min)\n-\t\t   && ((TYPE_PRECISION (TREE_TYPE (*vr0min))\n-\t\t\t>= TYPE_PRECISION (integer_type_node))\n-\t\t       || POINTER_TYPE_P (TREE_TYPE (*vr0min)))\n-\t\t   && TREE_CODE (vr1max) == INTEGER_CST\n-\t\t   && TREE_CODE (vr1min) == INTEGER_CST\n-\t\t   && (wi::clz (wi::to_wide (vr1max) - wi::to_wide (vr1min))\n-\t\t       < TYPE_PRECISION (TREE_TYPE (*vr0min)) / 2))\n-\t    ;\n-\t  /* Else choose the range.  */\n-\t  else\n-\t    {\n-\t      *vr0type = vr1type;\n-\t      *vr0min = vr1min;\n-\t      *vr0max = vr1max;\n-\t    }\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  /* If both are anti-ranges the result is the outer one.  */\n-\t  *vr0type = vr1type;\n-\t  *vr0min = vr1min;\n-\t  *vr0max = vr1max;\n-\t}\n-      else if (vr1type == VR_ANTI_RANGE\n-\t       && *vr0type == VR_RANGE)\n-\t{\n-\t  /* The intersection is empty.  */\n-\t  *vr0type = VR_UNDEFINED;\n-\t  *vr0min = NULL_TREE;\n-\t  *vr0max = NULL_TREE;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if ((operand_less_p (vr1min, *vr0max) == 1\n-\t    || operand_equal_p (vr1min, *vr0max, 0))\n-\t   && operand_less_p (*vr0min, vr1min) == 1)\n-    {\n-      /* [  (  ]  ) or [  ](  ) */\n-      if (*vr0type == VR_ANTI_RANGE\n-\t  && vr1type == VR_ANTI_RANGE)\n-\t*vr0max = vr1max;\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t*vr0min = vr1min;\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  if (TREE_CODE (vr1min) == INTEGER_CST)\n-\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n-\t\t\t\t       build_int_cst (TREE_TYPE (vr1min), 1));\n-\t  else\n-\t    *vr0max = vr1min;\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  *vr0type = VR_RANGE;\n-\t  if (TREE_CODE (*vr0max) == INTEGER_CST)\n-\t    *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n-\t\t\t\t       build_int_cst (TREE_TYPE (*vr0max), 1));\n-\t  else\n-\t    *vr0min = *vr0max;\n-\t  *vr0max = vr1max;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if ((operand_less_p (*vr0min, vr1max) == 1\n-\t    || operand_equal_p (*vr0min, vr1max, 0))\n-\t   && operand_less_p (vr1min, *vr0min) == 1)\n-    {\n-      /* (  [  )  ] or (  )[  ] */\n-      if (*vr0type == VR_ANTI_RANGE\n-\t  && vr1type == VR_ANTI_RANGE)\n-\t*vr0min = vr1min;\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t*vr0max = vr1max;\n-      else if (*vr0type == VR_RANGE\n-\t       && vr1type == VR_ANTI_RANGE)\n-\t{\n-\t  if (TREE_CODE (vr1max) == INTEGER_CST)\n-\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n-\t\t\t\t       build_int_cst (TREE_TYPE (vr1max), 1));\n-\t  else\n-\t    *vr0min = vr1max;\n-\t}\n-      else if (*vr0type == VR_ANTI_RANGE\n-\t       && vr1type == VR_RANGE)\n-\t{\n-\t  *vr0type = VR_RANGE;\n-\t  if (TREE_CODE (*vr0min) == INTEGER_CST)\n-\t    *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n-\t\t\t\t       build_int_cst (TREE_TYPE (*vr0min), 1));\n-\t  else\n-\t    *vr0max = *vr0min;\n-\t  *vr0min = vr1min;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-\n-  /* If we know the intersection is empty, there's no need to\n-     conservatively add anything else to the set.  */\n-  if (*vr0type == VR_UNDEFINED)\n-    return;\n-\n-  /* As a fallback simply use { *VRTYPE, *VR0MIN, *VR0MAX } as\n-     result for the intersection.  That's always a conservative\n-     correct estimate unless VR1 is a constant singleton range\n-     in which case we choose that.  */\n-  if (vr1type == VR_RANGE\n-      && is_gimple_min_invariant (vr1min)\n-      && vrp_operand_equal_p (vr1min, vr1max))\n-    {\n-      *vr0type = vr1type;\n-      *vr0min = vr1min;\n-      *vr0max = vr1max;\n-    }\n-}\n-\n-\n-/* Helper for the intersection operation for value ranges.  Given two\n-   value ranges VR0 and VR1, return the intersection of the two\n-   ranges.  This may not be the smallest possible such range.  */\n-\n-value_range\n-value_range::intersect_helper (const value_range *vr0, const value_range *vr1)\n-{\n-  /* If either range is VR_VARYING the other one wins.  */\n-  if (vr1->varying_p ())\n-    return *vr0;\n-  if (vr0->varying_p ())\n-    return *vr1;\n-\n-  /* When either range is VR_UNDEFINED the resulting range is\n-     VR_UNDEFINED, too.  */\n-  if (vr0->undefined_p ())\n-    return *vr0;\n-  if (vr1->undefined_p ())\n-    return *vr1;\n-\n-  value_range_kind vr0kind = vr0->kind ();\n-  tree vr0min = vr0->min ();\n-  tree vr0max = vr0->max ();\n-  intersect_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\t    vr1->kind (), vr1->min (), vr1->max ());\n-  /* Make sure to canonicalize the result though as the inversion of a\n-     VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n-     fall back to vr0 when this turns things to varying.  */\n-  value_range tem;\n-  if (vr0kind == VR_UNDEFINED)\n-    tem.set_undefined ();\n-  else if (vr0kind == VR_VARYING)\n-    tem.set_varying (vr0->type ());\n-  else\n-    tem.set (vr0min, vr0max, vr0kind);\n-  /* If that failed, use the saved original VR0.  */\n-  if (tem.varying_p ())\n-    return *vr0;\n-\n-  return tem;\n-}\n-\n-void\n-value_range::intersect (const value_range *other)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Intersecting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  *this = intersect_helper (this, other);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n void\n value_range_equiv::intersect (const value_range_equiv *other)\n {\n@@ -5936,79 +4689,6 @@ value_range_equiv::intersect (const value_range_equiv *other)\n     }\n }\n \n-/* Helper for meet operation for value ranges.  Given two value ranges VR0 and\n-   VR1, return a range that contains both VR0 and VR1.  This may not be the\n-   smallest possible such range.  */\n-\n-value_range\n-value_range::union_helper (const value_range *vr0, const value_range *vr1)\n-{\n-  /* VR0 has the resulting range if VR1 is undefined or VR0 is varying.  */\n-  if (vr1->undefined_p ()\n-      || vr0->varying_p ())\n-    return *vr0;\n-\n-  /* VR1 has the resulting range if VR0 is undefined or VR1 is varying.  */\n-  if (vr0->undefined_p ()\n-      || vr1->varying_p ())\n-    return *vr1;\n-\n-  value_range_kind vr0kind = vr0->kind ();\n-  tree vr0min = vr0->min ();\n-  tree vr0max = vr0->max ();\n-  union_ranges (&vr0kind, &vr0min, &vr0max,\n-\t\tvr1->kind (), vr1->min (), vr1->max ());\n-\n-  /* Work on a temporary so we can still use vr0 when union returns varying.  */\n-  value_range tem;\n-  if (vr0kind == VR_UNDEFINED)\n-    tem.set_undefined ();\n-  else if (vr0kind == VR_VARYING)\n-    tem.set_varying (vr0->type ());\n-  else\n-    tem.set (vr0min, vr0max, vr0kind);\n-\n-  /* Failed to find an efficient meet.  Before giving up and setting\n-     the result to VARYING, see if we can at least derive a useful\n-     anti-range.  */\n-  if (tem.varying_p ()\n-      && range_includes_zero_p (vr0) == 0\n-      && range_includes_zero_p (vr1) == 0)\n-    {\n-      tem.set_nonzero (vr0->type ());\n-      return tem;\n-    }\n-\n-  return tem;\n-}\n-\n-\n-/* Meet operation for value ranges.  Given two value ranges VR0 and\n-   VR1, store in VR0 a range that contains both VR0 and VR1.  This\n-   may not be the smallest possible such range.  */\n-\n-void\n-value_range::union_ (const value_range *other)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Meeting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  *this = union_helper (this, other);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n void\n value_range_equiv::union_ (const value_range_equiv *other)\n {\n@@ -6046,222 +4726,6 @@ value_range_equiv::union_ (const value_range_equiv *other)\n     }\n }\n \n-/* Normalize addresses into constants.  */\n-\n-value_range\n-value_range::normalize_addresses () const\n-{\n-  if (undefined_p ())\n-    return *this;\n-\n-  if (!POINTER_TYPE_P (type ()) || range_has_numeric_bounds_p (this))\n-    return *this;\n-\n-  if (!range_includes_zero_p (this))\n-    {\n-      gcc_checking_assert (TREE_CODE (m_min) == ADDR_EXPR\n-\t\t\t   || TREE_CODE (m_max) == ADDR_EXPR);\n-      return range_nonzero (type ());\n-    }\n-  return value_range (type ());\n-}\n-\n-/* Normalize symbolics and addresses into constants.  */\n-\n-value_range\n-value_range::normalize_symbolics () const\n-{\n-  if (varying_p () || undefined_p ())\n-    return *this;\n-  tree ttype = type ();\n-  bool min_symbolic = !is_gimple_min_invariant (min ());\n-  bool max_symbolic = !is_gimple_min_invariant (max ());\n-  if (!min_symbolic && !max_symbolic)\n-    return normalize_addresses ();\n-\n-  // [SYM, SYM] -> VARYING\n-  if (min_symbolic && max_symbolic)\n-    {\n-      value_range var;\n-      var.set_varying (ttype);\n-      return var;\n-    }\n-  if (kind () == VR_RANGE)\n-    {\n-      // [SYM, NUM] -> [-MIN, NUM]\n-      if (min_symbolic)\n-\treturn value_range (vrp_val_min (ttype), max ());\n-      // [NUM, SYM] -> [NUM, +MAX]\n-      return value_range (min (), vrp_val_max (ttype));\n-    }\n-  gcc_checking_assert (kind () == VR_ANTI_RANGE);\n-  // ~[SYM, NUM] -> [NUM + 1, +MAX]\n-  if (min_symbolic)\n-    {\n-      if (!vrp_val_is_max (max ()))\n-\t{\n-\t  tree n = wide_int_to_tree (ttype, wi::to_wide (max ()) + 1);\n-\t  return value_range (n, vrp_val_max (ttype));\n-\t}\n-      value_range var;\n-      var.set_varying (ttype);\n-      return var;\n-    }\n-  // ~[NUM, SYM] -> [-MIN, NUM - 1]\n-  if (!vrp_val_is_min (min ()))\n-    {\n-      tree n = wide_int_to_tree (ttype, wi::to_wide (min ()) - 1);\n-      return value_range (vrp_val_min (ttype), n);\n-    }\n-  value_range var;\n-  var.set_varying (ttype);\n-  return var;\n-}\n-\n-/* Return the number of sub-ranges in a range.  */\n-\n-unsigned\n-value_range::num_pairs () const\n-{\n-  if (undefined_p ())\n-    return 0;\n-  if (varying_p ())\n-    return 1;\n-  if (symbolic_p ())\n-    return normalize_symbolics ().num_pairs ();\n-  if (m_kind == VR_ANTI_RANGE)\n-    {\n-      // ~[MIN, X] has one sub-range of [X+1, MAX], and\n-      // ~[X, MAX] has one sub-range of [MIN, X-1].\n-      if (vrp_val_is_min (m_min) || vrp_val_is_max (m_max))\n-\treturn 1;\n-      return 2;\n-    }\n-  return 1;\n-}\n-\n-/* Return the lower bound for a sub-range.  PAIR is the sub-range in\n-   question.  */\n-\n-wide_int\n-value_range::lower_bound (unsigned pair) const\n-{\n-  if (symbolic_p ())\n-    return normalize_symbolics ().lower_bound (pair);\n-\n-  gcc_checking_assert (!undefined_p ());\n-  gcc_checking_assert (pair + 1 <= num_pairs ());\n-  tree t = NULL;\n-  if (m_kind == VR_ANTI_RANGE)\n-    {\n-      tree typ = type ();\n-      if (pair == 1 || vrp_val_is_min (m_min))\n-\tt = wide_int_to_tree (typ, wi::to_wide (m_max) + 1);\n-      else\n-\tt = vrp_val_min (typ);\n-    }\n-  else\n-    t = m_min;\n-  return wi::to_wide (t);\n-}\n-\n-/* Return the upper bound for a sub-range.  PAIR is the sub-range in\n-   question.  */\n-\n-wide_int\n-value_range::upper_bound (unsigned pair) const\n-{\n-  if (symbolic_p ())\n-    return normalize_symbolics ().upper_bound (pair);\n-\n-  gcc_checking_assert (!undefined_p ());\n-  gcc_checking_assert (pair + 1 <= num_pairs ());\n-  tree t = NULL;\n-  if (m_kind == VR_ANTI_RANGE)\n-    {\n-      tree typ = type ();\n-      if (pair == 1 || vrp_val_is_min (m_min))\n-\tt = vrp_val_max (typ);\n-      else\n-\tt = wide_int_to_tree (typ, wi::to_wide (m_min) - 1);\n-    }\n-  else\n-    t = m_max;\n-  return wi::to_wide (t);\n-}\n-\n-/* Return the highest bound in a range.  */\n-\n-wide_int\n-value_range::upper_bound () const\n-{\n-  unsigned pairs = num_pairs ();\n-  gcc_checking_assert (pairs > 0);\n-  return upper_bound (pairs - 1);\n-}\n-\n-/* Return TRUE if range contains INTEGER_CST.  */\n-\n-bool\n-value_range::contains_p (tree cst) const\n-{\n-  gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n-  if (symbolic_p ())\n-    return normalize_symbolics ().contains_p (cst);\n-  return value_inside_range (cst) == 1;\n-}\n-\n-/* Return the inverse of a range.  */\n-\n-void\n-value_range::invert ()\n-{\n-  /* We can't just invert VR_RANGE and VR_ANTI_RANGE because we may\n-     create non-canonical ranges.  Use the constructors instead.  */\n-  if (m_kind == VR_RANGE)\n-    *this = value_range (m_min, m_max, VR_ANTI_RANGE);\n-  else if (m_kind == VR_ANTI_RANGE)\n-    *this = value_range (m_min, m_max);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Range union, but for references.  */\n-\n-void\n-value_range::union_ (const value_range &r)\n-{\n-  /* Disable details for now, because it makes the ranger dump\n-     unnecessarily verbose.  */\n-  bool details = dump_flags & TDF_DETAILS;\n-  if (details)\n-    dump_flags &= ~TDF_DETAILS;\n-  union_ (&r);\n-  if (details)\n-    dump_flags |= TDF_DETAILS;\n-}\n-\n-/* Range intersect, but for references.  */\n-\n-void\n-value_range::intersect (const value_range &r)\n-{\n-  /* Disable details for now, because it makes the ranger dump\n-     unnecessarily verbose.  */\n-  bool details = dump_flags & TDF_DETAILS;\n-  if (details)\n-    dump_flags &= ~TDF_DETAILS;\n-  intersect (&r);\n-  if (details)\n-    dump_flags |= TDF_DETAILS;\n-}\n-\n-bool\n-value_range::operator== (const value_range &r) const\n-{\n-  return equal_p (r);\n-}\n-\n /* Visit all arguments for PHI node PHI that flow through executable\n    edges.  If a valid value range can be derived from all the incoming\n    value ranges, set a new range for the LHS of PHI.  */"}, {"sha": "81f0a7b59216dafc2ee2e0177747bed6ad3d8900", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 1, "deletions": 203, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -20,103 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_VRP_H\n #define GCC_TREE_VRP_H\n \n-/* Types of value ranges.  */\n-enum value_range_kind\n-{\n-  /* Empty range.  */\n-  VR_UNDEFINED,\n-  /* Range spans the entire domain.  */\n-  VR_VARYING,\n-  /* Range is [MIN, MAX].  */\n-  VR_RANGE,\n-  /* Range is ~[MIN, MAX].  */\n-  VR_ANTI_RANGE,\n-  /* Range is a nice guy.  */\n-  VR_LAST\n-};\n-\n-/* Range of values that can be associated with an SSA_NAME after VRP\n-   has executed.  */\n-class GTY((for_user)) value_range\n-{\n-  friend void range_tests ();\n-public:\n-  value_range ();\n-  value_range (tree, tree, value_range_kind = VR_RANGE);\n-  value_range (tree type, const wide_int &, const wide_int &,\n-\t       value_range_kind = VR_RANGE);\n-  value_range (tree type);\n-\n-  void set (tree, tree, value_range_kind = VR_RANGE);\n-  void set (tree);\n-  void set_nonzero (tree);\n-  void set_zero (tree);\n-\n-  enum value_range_kind kind () const;\n-  tree min () const;\n-  tree max () const;\n-\n-  /* Types of value ranges.  */\n-  bool symbolic_p () const;\n-  bool constant_p () const;\n-  bool undefined_p () const;\n-  bool varying_p () const;\n-  void set_varying (tree type);\n-  void set_undefined ();\n-\n-  void union_ (const value_range *);\n-  void intersect (const value_range *);\n-  void union_ (const value_range &);\n-  void intersect (const value_range &);\n-\n-  bool operator== (const value_range &) const;\n-  bool operator!= (const value_range &) const /* = delete */;\n-  bool equal_p (const value_range &) const;\n-\n-  /* Misc methods.  */\n-  tree type () const;\n-  bool may_contain_p (tree) const;\n-  bool zero_p () const;\n-  bool nonzero_p () const;\n-  bool singleton_p (tree *result = NULL) const;\n-  void dump (FILE *) const;\n-  void dump () const;\n-\n-  static bool supports_type_p (tree);\n-  value_range normalize_symbolics () const;\n-  value_range normalize_addresses () const;\n-\n-  static const unsigned int m_max_pairs = 2;\n-  bool contains_p (tree) const;\n-  unsigned num_pairs () const;\n-  wide_int lower_bound (unsigned = 0) const;\n-  wide_int upper_bound (unsigned) const;\n-  wide_int upper_bound () const;\n-  void invert ();\n-\n-protected:\n-  void check ();\n-  static value_range union_helper (const value_range *, const value_range *);\n-  static value_range intersect_helper (const value_range *,\n-\t\t\t\t       const value_range *);\n-\n-  enum value_range_kind m_kind;\n-\n-  tree m_min;\n-  tree m_max;\n-\n-  friend void gt_ggc_mx_value_range (void *);\n-  friend void gt_pch_p_11value_range (void *, void *,\n-\t\t\t\t      gt_pointer_operator, void *);\n-  friend void gt_pch_nx_value_range (void *);\n-  friend void gt_ggc_mx (value_range &);\n-  friend void gt_ggc_mx (value_range *&);\n-  friend void gt_pch_nx (value_range &);\n-  friend void gt_pch_nx (value_range *, gt_pointer_operator, void *);\n-\n-private:\n-  int value_inside_range (tree) const;\n-};\n+#include \"value-range.h\"\n \n /* Note value_range_equiv cannot currently be used with GC memory,\n    only value_range is fully set up for this.  */\n@@ -173,78 +77,20 @@ class GTY((user)) value_range_equiv : public value_range\n   bitmap m_equiv;\n };\n \n-inline\n-value_range::value_range ()\n-{\n-  m_kind = VR_UNDEFINED;\n-  m_min = m_max = NULL;\n-}\n-\n inline\n value_range_equiv::value_range_equiv ()\n   : value_range ()\n {\n   m_equiv = NULL;\n }\n \n-/* Return the kind of this range.  */\n-\n-inline value_range_kind\n-value_range::kind () const\n-{\n-  return m_kind;\n-}\n-\n inline bitmap\n value_range_equiv::equiv () const\n {\n   return m_equiv;\n }\n \n-/* Return the lower bound.  */\n-\n-inline tree\n-value_range::min () const\n-{\n-  return m_min;\n-}\n-\n-/* Return the upper bound.  */\n-\n-inline tree\n-value_range::max () const\n-{\n-  return m_max;\n-}\n-\n-/* Return TRUE if range spans the entire possible domain.  */\n-\n-inline bool\n-value_range::varying_p () const\n-{\n-  return m_kind == VR_VARYING;\n-}\n-\n-/* Return TRUE if range is undefined (essentially the empty set).  */\n-\n-inline bool\n-value_range::undefined_p () const\n-{\n-  return m_kind == VR_UNDEFINED;\n-}\n-\n-/* Return TRUE if range is the constant zero.  */\n-\n-inline bool\n-value_range::zero_p () const\n-{\n-  return (m_kind == VR_RANGE\n-\t  && integer_zerop (m_min)\n-\t  && integer_zerop (m_max));\n-}\n-\n extern void dump_value_range (FILE *, const value_range_equiv *);\n-extern void dump_value_range (FILE *, const value_range *);\n \n struct assert_info\n {\n@@ -261,17 +107,6 @@ struct assert_info\n   tree expr;\n };\n \n-// Return true if TYPE is a valid type for value_range to operate on.\n-// Otherwise return FALSE.\n-\n-inline bool\n-value_range::supports_type_p (tree type)\n-{\n-  if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n-    return type;\n-  return false;\n-}\n-\n extern void register_edge_assert_for (tree, edge, enum tree_code,\n \t\t\t\t      tree, tree, vec<assert_info> &);\n extern bool stmt_interesting_for_vrp (gimple *);\n@@ -282,18 +117,12 @@ extern bool range_int_cst_p (const value_range *);\n extern int compare_values (tree, tree);\n extern int compare_values_warnv (tree, tree, bool *);\n extern int operand_less_p (tree, tree);\n-extern bool vrp_val_is_min (const_tree);\n-extern bool vrp_val_is_max (const_tree);\n-\n-extern tree vrp_val_min (const_tree);\n-extern tree vrp_val_max (const_tree);\n \n void range_fold_unary_expr (value_range *, enum tree_code, tree type,\n \t\t\t    const value_range *, tree op0_type);\n void range_fold_binary_expr (value_range *, enum tree_code, tree type,\n \t\t\t     const value_range *, const value_range *);\n \n-extern bool vrp_operand_equal_p (const_tree, const_tree);\n extern enum value_range_kind intersect_range_with_nonzero_bits\n   (enum value_range_kind, wide_int *, wide_int *, const wide_int &, signop);\n \n@@ -304,35 +133,4 @@ extern tree get_single_symbol (tree, bool *, tree *);\n extern void maybe_set_nonzero_bits (edge, tree);\n extern value_range_kind determine_value_range (tree, wide_int *, wide_int *);\n \n-/* Return TRUE if range is nonzero.  */\n-\n-inline bool\n-value_range::nonzero_p () const\n-{\n-  if (m_kind == VR_ANTI_RANGE\n-      && !TYPE_UNSIGNED (type ())\n-      && integer_zerop (m_min)\n-      && integer_zerop (m_max))\n-    return true;\n-\n-  return (m_kind == VR_RANGE\n-\t  && TYPE_UNSIGNED (type ())\n-\t  && integer_onep (m_min)\n-\t  && vrp_val_is_max (m_max));\n-}\n-\n-/* Return TRUE if *VR includes the value zero.  */\n-\n-inline bool\n-range_includes_zero_p (const value_range *vr)\n-{\n-  if (vr->undefined_p ())\n-    return false;\n-\n-  if (vr->varying_p ())\n-    return true;\n-\n-  return vr->may_contain_p (build_zero_cst (vr->type ()));\n-}\n-\n #endif /* GCC_TREE_VRP_H */"}, {"sha": "3d926005743681e4d1b140a1488073cc31b0dced", "filename": "gcc/value-range.cc", "status": "added", "additions": 1541, "deletions": 0, "changes": 1541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -0,0 +1,1541 @@\n+/* Support routines for value ranges.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"fold-const.h\"\n+\n+value_range::value_range (tree min, tree max, value_range_kind kind)\n+{\n+  set (min, max, kind);\n+}\n+\n+value_range::value_range (tree type)\n+{\n+  set_varying (type);\n+}\n+\n+value_range::value_range (tree type,\n+\t\t\t  const wide_int &wmin, const wide_int &wmax,\n+\t\t\t  enum value_range_kind kind)\n+{\n+  tree min = wide_int_to_tree (type, wmin);\n+  tree max = wide_int_to_tree (type, wmax);\n+  gcc_checking_assert (kind == VR_RANGE || kind == VR_ANTI_RANGE);\n+  set (min, max, kind);\n+}\n+\n+void\n+value_range::set_undefined ()\n+{\n+  m_kind = VR_UNDEFINED;\n+  m_min = m_max = NULL;\n+}\n+\n+void\n+value_range::set_varying (tree type)\n+{\n+  m_kind = VR_VARYING;\n+  if (supports_type_p (type))\n+    {\n+      m_min = vrp_val_min (type);\n+      m_max = vrp_val_max (type);\n+    }\n+  else\n+    /* We can't do anything range-wise with these types.  */\n+    m_min = m_max = error_mark_node;\n+}\n+\n+/* Set value range to the canonical form of {VRTYPE, MIN, MAX, EQUIV}.\n+   This means adjusting VRTYPE, MIN and MAX representing the case of a\n+   wrapping range with MAX < MIN covering [MIN, type_max] U [type_min, MAX]\n+   as anti-rage ~[MAX+1, MIN-1].  Likewise for wrapping anti-ranges.\n+   In corner cases where MAX+1 or MIN-1 wraps this will fall back\n+   to varying.\n+   This routine exists to ease canonicalization in the case where we\n+   extract ranges from var + CST op limit.  */\n+\n+void\n+value_range::set (tree min, tree max, value_range_kind kind)\n+{\n+  /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n+  if (kind == VR_UNDEFINED)\n+    {\n+      set_undefined ();\n+      return;\n+    }\n+  else if (kind == VR_VARYING)\n+    {\n+      gcc_assert (TREE_TYPE (min) == TREE_TYPE (max));\n+      tree typ = TREE_TYPE (min);\n+      if (supports_type_p (typ))\n+\t{\n+\t  gcc_assert (vrp_val_min (typ));\n+\t  gcc_assert (vrp_val_max (typ));\n+\t}\n+      set_varying (typ);\n+      return;\n+    }\n+\n+  /* Convert POLY_INT_CST bounds into worst-case INTEGER_CST bounds.  */\n+  if (POLY_INT_CST_P (min))\n+    {\n+      tree type_min = vrp_val_min (TREE_TYPE (min));\n+      widest_int lb\n+\t= constant_lower_bound_with_limit (wi::to_poly_widest (min),\n+\t\t\t\t\t   wi::to_widest (type_min));\n+      min = wide_int_to_tree (TREE_TYPE (min), lb);\n+    }\n+  if (POLY_INT_CST_P (max))\n+    {\n+      tree type_max = vrp_val_max (TREE_TYPE (max));\n+      widest_int ub\n+\t= constant_upper_bound_with_limit (wi::to_poly_widest (max),\n+\t\t\t\t\t   wi::to_widest (type_max));\n+      max = wide_int_to_tree (TREE_TYPE (max), ub);\n+    }\n+\n+  /* Nothing to canonicalize for symbolic ranges.  */\n+  if (TREE_CODE (min) != INTEGER_CST\n+      || TREE_CODE (max) != INTEGER_CST)\n+    {\n+      m_kind = kind;\n+      m_min = min;\n+      m_max = max;\n+      return;\n+    }\n+\n+  /* Wrong order for min and max, to swap them and the VR type we need\n+     to adjust them.  */\n+  if (tree_int_cst_lt (max, min))\n+    {\n+      tree one, tmp;\n+\n+      /* For one bit precision if max < min, then the swapped\n+\t range covers all values, so for VR_RANGE it is varying and\n+\t for VR_ANTI_RANGE empty range, so drop to varying as well.  */\n+      if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n+\t{\n+\t  set_varying (TREE_TYPE (min));\n+\t  return;\n+\t}\n+\n+      one = build_int_cst (TREE_TYPE (min), 1);\n+      tmp = int_const_binop (PLUS_EXPR, max, one);\n+      max = int_const_binop (MINUS_EXPR, min, one);\n+      min = tmp;\n+\n+      /* There's one corner case, if we had [C+1, C] before we now have\n+\t that again.  But this represents an empty value range, so drop\n+\t to varying in this case.  */\n+      if (tree_int_cst_lt (max, min))\n+\t{\n+\t  set_varying (TREE_TYPE (min));\n+\t  return;\n+\t}\n+\n+      kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n+    }\n+\n+  tree type = TREE_TYPE (min);\n+\n+  /* Anti-ranges that can be represented as ranges should be so.  */\n+  if (kind == VR_ANTI_RANGE)\n+    {\n+      /* For -fstrict-enums we may receive out-of-range ranges so consider\n+         values < -INF and values > INF as -INF/INF as well.  */\n+      bool is_min = vrp_val_is_min (min);\n+      bool is_max = vrp_val_is_max (max);\n+\n+      if (is_min && is_max)\n+\t{\n+\t  /* We cannot deal with empty ranges, drop to varying.\n+\t     ???  This could be VR_UNDEFINED instead.  */\n+\t  set_varying (type);\n+\t  return;\n+\t}\n+      else if (TYPE_PRECISION (TREE_TYPE (min)) == 1\n+\t       && (is_min || is_max))\n+\t{\n+\t  /* Non-empty boolean ranges can always be represented\n+\t     as a singleton range.  */\n+\t  if (is_min)\n+\t    min = max = vrp_val_max (TREE_TYPE (min));\n+\t  else\n+\t    min = max = vrp_val_min (TREE_TYPE (min));\n+\t  kind = VR_RANGE;\n+\t}\n+      else if (is_min)\n+        {\n+\t  tree one = build_int_cst (TREE_TYPE (max), 1);\n+\t  min = int_const_binop (PLUS_EXPR, max, one);\n+\t  max = vrp_val_max (TREE_TYPE (max));\n+\t  kind = VR_RANGE;\n+        }\n+      else if (is_max)\n+        {\n+\t  tree one = build_int_cst (TREE_TYPE (min), 1);\n+\t  max = int_const_binop (MINUS_EXPR, min, one);\n+\t  min = vrp_val_min (TREE_TYPE (min));\n+\t  kind = VR_RANGE;\n+        }\n+    }\n+\n+  /* Normalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n+\n+     Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n+     restrict those to a subset of what actually fits in the type.\n+     Instead use the extremes of the type precision which will allow\n+     compare_range_with_value() to check if a value is inside a range,\n+     whereas if we used TYPE_*_VAL, said function would just punt\n+     upon seeing a VARYING.  */\n+  unsigned prec = TYPE_PRECISION (type);\n+  signop sign = TYPE_SIGN (type);\n+  if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n+      && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n+    {\n+      if (kind == VR_RANGE)\n+\tset_varying (type);\n+      else if (kind == VR_ANTI_RANGE)\n+\tset_undefined ();\n+      else\n+\tgcc_unreachable ();\n+      return;\n+    }\n+\n+  /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n+     to make sure VRP iteration terminates, otherwise we can get into\n+     oscillations.  */\n+\n+  m_kind = kind;\n+  m_min = min;\n+  m_max = max;\n+  if (flag_checking)\n+    check ();\n+}\n+\n+void\n+value_range::set (tree val)\n+{\n+  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n+  if (TREE_OVERFLOW_P (val))\n+    val = drop_tree_overflow (val);\n+  set (val, val);\n+}\n+\n+/* Set value range VR to a nonzero range of type TYPE.  */\n+\n+void\n+value_range::set_nonzero (tree type)\n+{\n+  tree zero = build_int_cst (type, 0);\n+  set (zero, zero, VR_ANTI_RANGE);\n+}\n+\n+/* Set value range VR to a ZERO range of type TYPE.  */\n+\n+void\n+value_range::set_zero (tree type)\n+{\n+  set (build_int_cst (type, 0));\n+}\n+\n+/* Check the validity of the range.  */\n+\n+void\n+value_range::check ()\n+{\n+  switch (m_kind)\n+    {\n+    case VR_RANGE:\n+    case VR_ANTI_RANGE:\n+      {\n+\tgcc_assert (m_min && m_max);\n+\tgcc_assert (!TREE_OVERFLOW_P (m_min) && !TREE_OVERFLOW_P (m_max));\n+\n+\t/* Creating ~[-MIN, +MAX] is stupid because that would be\n+\t   the empty set.  */\n+\tif (INTEGRAL_TYPE_P (TREE_TYPE (m_min)) && m_kind == VR_ANTI_RANGE)\n+\t  gcc_assert (!vrp_val_is_min (m_min) || !vrp_val_is_max (m_max));\n+\n+\tint cmp = compare_values (m_min, m_max);\n+\tgcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n+\tbreak;\n+      }\n+    case VR_UNDEFINED:\n+      gcc_assert (!min () && !max ());\n+      break;\n+    case VR_VARYING:\n+      gcc_assert (m_min && m_max);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return the number of sub-ranges in a range.  */\n+\n+unsigned\n+value_range::num_pairs () const\n+{\n+  if (undefined_p ())\n+    return 0;\n+  if (varying_p ())\n+    return 1;\n+  if (symbolic_p ())\n+    return normalize_symbolics ().num_pairs ();\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      // ~[MIN, X] has one sub-range of [X+1, MAX], and\n+      // ~[X, MAX] has one sub-range of [MIN, X-1].\n+      if (vrp_val_is_min (m_min) || vrp_val_is_max (m_max))\n+\treturn 1;\n+      return 2;\n+    }\n+  return 1;\n+}\n+\n+/* Return the lower bound for a sub-range.  PAIR is the sub-range in\n+   question.  */\n+\n+wide_int\n+value_range::lower_bound (unsigned pair) const\n+{\n+  if (symbolic_p ())\n+    return normalize_symbolics ().lower_bound (pair);\n+\n+  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (pair + 1 <= num_pairs ());\n+  tree t = NULL;\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      tree typ = type ();\n+      if (pair == 1 || vrp_val_is_min (m_min))\n+\tt = wide_int_to_tree (typ, wi::to_wide (m_max) + 1);\n+      else\n+\tt = vrp_val_min (typ);\n+    }\n+  else\n+    t = m_min;\n+  return wi::to_wide (t);\n+}\n+\n+/* Return the upper bound for a sub-range.  PAIR is the sub-range in\n+   question.  */\n+\n+wide_int\n+value_range::upper_bound (unsigned pair) const\n+{\n+  if (symbolic_p ())\n+    return normalize_symbolics ().upper_bound (pair);\n+\n+  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (pair + 1 <= num_pairs ());\n+  tree t = NULL;\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      tree typ = type ();\n+      if (pair == 1 || vrp_val_is_min (m_min))\n+\tt = vrp_val_max (typ);\n+      else\n+\tt = wide_int_to_tree (typ, wi::to_wide (m_min) - 1);\n+    }\n+  else\n+    t = m_max;\n+  return wi::to_wide (t);\n+}\n+\n+/* Return the highest bound in a range.  */\n+\n+wide_int\n+value_range::upper_bound () const\n+{\n+  unsigned pairs = num_pairs ();\n+  gcc_checking_assert (pairs > 0);\n+  return upper_bound (pairs - 1);\n+}\n+\n+bool\n+value_range::equal_p (const value_range &other) const\n+{\n+  /* Ignore types for undefined.  All undefines are equal.  */\n+  if (undefined_p ())\n+    return m_kind == other.m_kind;\n+\n+  return (m_kind == other.m_kind\n+\t  && vrp_operand_equal_p (m_min, other.m_min)\n+\t  && vrp_operand_equal_p (m_max, other.m_max));\n+}\n+\n+bool\n+value_range::operator== (const value_range &r) const\n+{\n+  return equal_p (r);\n+}\n+\n+/* If range is a singleton, place it in RESULT and return TRUE.\n+   Note: A singleton can be any gimple invariant, not just constants.\n+   So, [&x, &x] counts as a singleton.  */\n+/* Return TRUE if this is a symbolic range.  */\n+\n+bool\n+value_range::symbolic_p () const\n+{\n+  return (!varying_p ()\n+\t  && !undefined_p ()\n+\t  && (!is_gimple_min_invariant (m_min)\n+\t      || !is_gimple_min_invariant (m_max)));\n+}\n+\n+/* NOTE: This is not the inverse of symbolic_p because the range\n+   could also be varying or undefined.  Ideally they should be inverse\n+   of each other, with varying only applying to symbolics.  Varying of\n+   constants would be represented as [-MIN, +MAX].  */\n+\n+bool\n+value_range::constant_p () const\n+{\n+  return (!varying_p ()\n+\t  && !undefined_p ()\n+\t  && TREE_CODE (m_min) == INTEGER_CST\n+\t  && TREE_CODE (m_max) == INTEGER_CST);\n+}\n+\n+bool\n+value_range::singleton_p (tree *result) const\n+{\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      if (nonzero_p ())\n+\t{\n+\t  if (TYPE_PRECISION (type ()) == 1)\n+\t    {\n+\t      if (result)\n+\t\t*result = m_max;\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n+      if (num_pairs () == 1)\n+\t{\n+\t  value_range vr0, vr1;\n+\t  ranges_from_anti_range (this, &vr0, &vr1);\n+\t  return vr0.singleton_p (result);\n+\t}\n+    }\n+  if (m_kind == VR_RANGE\n+      && vrp_operand_equal_p (min (), max ())\n+      && is_gimple_min_invariant (min ()))\n+    {\n+      if (result)\n+        *result = min ();\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return 1 if VAL is inside value range.\n+          0 if VAL is not inside value range.\n+\t -2 if we cannot tell either way.\n+\n+   Benchmark compile/20001226-1.c compilation time after changing this\n+   function.  */\n+\n+int\n+value_range::value_inside_range (tree val) const\n+{\n+  int cmp1, cmp2;\n+\n+  if (varying_p ())\n+    return 1;\n+\n+  if (undefined_p ())\n+    return 0;\n+\n+  cmp1 = operand_less_p (val, m_min);\n+  if (cmp1 == -2)\n+    return -2;\n+  if (cmp1 == 1)\n+    return m_kind != VR_RANGE;\n+\n+  cmp2 = operand_less_p (m_max, val);\n+  if (cmp2 == -2)\n+    return -2;\n+\n+  if (m_kind == VR_RANGE)\n+    return !cmp2;\n+  else\n+    return !!cmp2;\n+}\n+\n+/* Return TRUE if it is possible that range contains VAL.  */\n+\n+bool\n+value_range::may_contain_p (tree val) const\n+{\n+  return value_inside_range (val) != 0;\n+}\n+\n+/* Return TRUE if range contains INTEGER_CST.  */\n+\n+bool\n+value_range::contains_p (tree cst) const\n+{\n+  gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n+  if (symbolic_p ())\n+    return normalize_symbolics ().contains_p (cst);\n+  return value_inside_range (cst) == 1;\n+}\n+\n+/* Normalize addresses into constants.  */\n+\n+value_range\n+value_range::normalize_addresses () const\n+{\n+  if (undefined_p ())\n+    return *this;\n+\n+  if (!POINTER_TYPE_P (type ()) || range_has_numeric_bounds_p (this))\n+    return *this;\n+\n+  if (!range_includes_zero_p (this))\n+    {\n+      gcc_checking_assert (TREE_CODE (m_min) == ADDR_EXPR\n+\t\t\t   || TREE_CODE (m_max) == ADDR_EXPR);\n+      return range_nonzero (type ());\n+    }\n+  return value_range (type ());\n+}\n+\n+/* Normalize symbolics and addresses into constants.  */\n+\n+value_range\n+value_range::normalize_symbolics () const\n+{\n+  if (varying_p () || undefined_p ())\n+    return *this;\n+  tree ttype = type ();\n+  bool min_symbolic = !is_gimple_min_invariant (min ());\n+  bool max_symbolic = !is_gimple_min_invariant (max ());\n+  if (!min_symbolic && !max_symbolic)\n+    return normalize_addresses ();\n+\n+  // [SYM, SYM] -> VARYING\n+  if (min_symbolic && max_symbolic)\n+    {\n+      value_range var;\n+      var.set_varying (ttype);\n+      return var;\n+    }\n+  if (kind () == VR_RANGE)\n+    {\n+      // [SYM, NUM] -> [-MIN, NUM]\n+      if (min_symbolic)\n+\treturn value_range (vrp_val_min (ttype), max ());\n+      // [NUM, SYM] -> [NUM, +MAX]\n+      return value_range (min (), vrp_val_max (ttype));\n+    }\n+  gcc_checking_assert (kind () == VR_ANTI_RANGE);\n+  // ~[SYM, NUM] -> [NUM + 1, +MAX]\n+  if (min_symbolic)\n+    {\n+      if (!vrp_val_is_max (max ()))\n+\t{\n+\t  tree n = wide_int_to_tree (ttype, wi::to_wide (max ()) + 1);\n+\t  return value_range (n, vrp_val_max (ttype));\n+\t}\n+      value_range var;\n+      var.set_varying (ttype);\n+      return var;\n+    }\n+  // ~[NUM, SYM] -> [-MIN, NUM - 1]\n+  if (!vrp_val_is_min (min ()))\n+    {\n+      tree n = wide_int_to_tree (ttype, wi::to_wide (min ()) - 1);\n+      return value_range (vrp_val_min (ttype), n);\n+    }\n+  value_range var;\n+  var.set_varying (ttype);\n+  return var;\n+}\n+\n+/* Intersect the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n+   { VR1TYPE, VR0MIN, VR0MAX } and store the result\n+   in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest\n+   possible such range.  The resulting range is not canonicalized.  */\n+\n+static void\n+intersect_ranges (enum value_range_kind *vr0type,\n+\t\t  tree *vr0min, tree *vr0max,\n+\t\t  enum value_range_kind vr1type,\n+\t\t  tree vr1min, tree vr1max)\n+{\n+  bool mineq = vrp_operand_equal_p (*vr0min, vr1min);\n+  bool maxeq = vrp_operand_equal_p (*vr0max, vr1max);\n+\n+  /* [] is vr0, () is vr1 in the following classification comments.  */\n+  if (mineq && maxeq)\n+    {\n+      /* [(  )] */\n+      if (*vr0type == vr1type)\n+\t/* Nothing to do for equal ranges.  */\n+\t;\n+      else if ((*vr0type == VR_RANGE\n+\t\t&& vr1type == VR_ANTI_RANGE)\n+\t       || (*vr0type == VR_ANTI_RANGE\n+\t\t   && vr1type == VR_RANGE))\n+\t{\n+\t  /* For anti-range with range intersection the result is empty.  */\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (operand_less_p (*vr0max, vr1min) == 1\n+\t   || operand_less_p (vr1max, *vr0min) == 1)\n+    {\n+      /* [ ] ( ) or ( ) [ ]\n+\t If the ranges have an empty intersection, the result of the\n+\t intersect operation is the range for intersecting an\n+\t anti-range with a range or empty when intersecting two ranges.  */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  /* If the anti-ranges are adjacent to each other merge them.  */\n+\t  if (TREE_CODE (*vr0max) == INTEGER_CST\n+\t      && TREE_CODE (vr1min) == INTEGER_CST\n+\t      && operand_less_p (*vr0max, vr1min) == 1\n+\t      && integer_onep (int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t\tvr1min, *vr0max)))\n+\t    *vr0max = vr1max;\n+\t  else if (TREE_CODE (vr1max) == INTEGER_CST\n+\t\t   && TREE_CODE (*vr0min) == INTEGER_CST\n+\t\t   && operand_less_p (vr1max, *vr0min) == 1\n+\t\t   && integer_onep (int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t\t     *vr0min, vr1max)))\n+\t    *vr0min = vr1min;\n+\t  /* Else arbitrarily take VR0.  */\n+\t}\n+    }\n+  else if ((maxeq || operand_less_p (vr1max, *vr0max) == 1)\n+\t   && (mineq || operand_less_p (*vr0min, vr1min) == 1))\n+    {\n+      /* [ (  ) ] or [(  ) ] or [ (  )] */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_RANGE)\n+\t{\n+\t  /* If both are ranges the result is the inner one.  */\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  /* Choose the right gap if the left one is empty.  */\n+\t  if (mineq)\n+\t    {\n+\t      if (TREE_CODE (vr1max) != INTEGER_CST)\n+\t\t*vr0min = vr1max;\n+\t      else if (TYPE_PRECISION (TREE_TYPE (vr1max)) == 1\n+\t\t       && !TYPE_UNSIGNED (TREE_TYPE (vr1max)))\n+\t\t*vr0min\n+\t\t  = int_const_binop (MINUS_EXPR, vr1max,\n+\t\t\t\t     build_int_cst (TREE_TYPE (vr1max), -1));\n+\t      else\n+\t\t*vr0min\n+\t\t  = int_const_binop (PLUS_EXPR, vr1max,\n+\t\t\t\t     build_int_cst (TREE_TYPE (vr1max), 1));\n+\t    }\n+\t  /* Choose the left gap if the right one is empty.  */\n+\t  else if (maxeq)\n+\t    {\n+\t      if (TREE_CODE (vr1min) != INTEGER_CST)\n+\t\t*vr0max = vr1min;\n+\t      else if (TYPE_PRECISION (TREE_TYPE (vr1min)) == 1\n+\t\t       && !TYPE_UNSIGNED (TREE_TYPE (vr1min)))\n+\t\t*vr0max\n+\t\t  = int_const_binop (PLUS_EXPR, vr1min,\n+\t\t\t\t     build_int_cst (TREE_TYPE (vr1min), -1));\n+\t      else\n+\t\t*vr0max\n+\t\t  = int_const_binop (MINUS_EXPR, vr1min,\n+\t\t\t\t     build_int_cst (TREE_TYPE (vr1min), 1));\n+\t    }\n+\t  /* Choose the anti-range if the range is effectively varying.  */\n+\t  else if (vrp_val_is_min (*vr0min)\n+\t\t   && vrp_val_is_max (*vr0max))\n+\t    {\n+\t      *vr0type = vr1type;\n+\t      *vr0min = vr1min;\n+\t      *vr0max = vr1max;\n+\t    }\n+\t  /* Else choose the range.  */\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t/* If both are anti-ranges the result is the outer one.  */\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  /* The intersection is empty.  */\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((maxeq || operand_less_p (*vr0max, vr1max) == 1)\n+\t   && (mineq || operand_less_p (vr1min, *vr0min) == 1))\n+    {\n+      /* ( [  ] ) or ([  ] ) or ( [  ]) */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_RANGE)\n+\t/* Choose the inner range.  */\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  /* Choose the right gap if the left is empty.  */\n+\t  if (mineq)\n+\t    {\n+\t      *vr0type = VR_RANGE;\n+\t      if (TREE_CODE (*vr0max) != INTEGER_CST)\n+\t\t*vr0min = *vr0max;\n+\t      else if (TYPE_PRECISION (TREE_TYPE (*vr0max)) == 1\n+\t\t       && !TYPE_UNSIGNED (TREE_TYPE (*vr0max)))\n+\t\t*vr0min\n+\t\t  = int_const_binop (MINUS_EXPR, *vr0max,\n+\t\t\t\t     build_int_cst (TREE_TYPE (*vr0max), -1));\n+\t      else\n+\t\t*vr0min\n+\t\t  = int_const_binop (PLUS_EXPR, *vr0max,\n+\t\t\t\t     build_int_cst (TREE_TYPE (*vr0max), 1));\n+\t      *vr0max = vr1max;\n+\t    }\n+\t  /* Choose the left gap if the right is empty.  */\n+\t  else if (maxeq)\n+\t    {\n+\t      *vr0type = VR_RANGE;\n+\t      if (TREE_CODE (*vr0min) != INTEGER_CST)\n+\t\t*vr0max = *vr0min;\n+\t      else if (TYPE_PRECISION (TREE_TYPE (*vr0min)) == 1\n+\t\t       && !TYPE_UNSIGNED (TREE_TYPE (*vr0min)))\n+\t\t*vr0max\n+\t\t  = int_const_binop (PLUS_EXPR, *vr0min,\n+\t\t\t\t     build_int_cst (TREE_TYPE (*vr0min), -1));\n+\t      else\n+\t\t*vr0max\n+\t\t  = int_const_binop (MINUS_EXPR, *vr0min,\n+\t\t\t\t     build_int_cst (TREE_TYPE (*vr0min), 1));\n+\t      *vr0min = vr1min;\n+\t    }\n+\t  /* Choose the anti-range if the range is effectively varying.  */\n+\t  else if (vrp_val_is_min (vr1min)\n+\t\t   && vrp_val_is_max (vr1max))\n+\t    ;\n+\t  /* Choose the anti-range if it is ~[0,0], that range is special\n+\t     enough to special case when vr1's range is relatively wide.\n+\t     At least for types bigger than int - this covers pointers\n+\t     and arguments to functions like ctz.  */\n+\t  else if (*vr0min == *vr0max\n+\t\t   && integer_zerop (*vr0min)\n+\t\t   && ((TYPE_PRECISION (TREE_TYPE (*vr0min))\n+\t\t\t>= TYPE_PRECISION (integer_type_node))\n+\t\t       || POINTER_TYPE_P (TREE_TYPE (*vr0min)))\n+\t\t   && TREE_CODE (vr1max) == INTEGER_CST\n+\t\t   && TREE_CODE (vr1min) == INTEGER_CST\n+\t\t   && (wi::clz (wi::to_wide (vr1max) - wi::to_wide (vr1min))\n+\t\t       < TYPE_PRECISION (TREE_TYPE (*vr0min)) / 2))\n+\t    ;\n+\t  /* Else choose the range.  */\n+\t  else\n+\t    {\n+\t      *vr0type = vr1type;\n+\t      *vr0min = vr1min;\n+\t      *vr0max = vr1max;\n+\t    }\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  /* If both are anti-ranges the result is the outer one.  */\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (vr1type == VR_ANTI_RANGE\n+\t       && *vr0type == VR_RANGE)\n+\t{\n+\t  /* The intersection is empty.  */\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((operand_less_p (vr1min, *vr0max) == 1\n+\t    || operand_equal_p (vr1min, *vr0max, 0))\n+\t   && operand_less_p (*vr0min, vr1min) == 1)\n+    {\n+      /* [  (  ]  ) or [  ](  ) */\n+      if (*vr0type == VR_ANTI_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\t*vr0max = vr1max;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t*vr0min = vr1min;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  if (TREE_CODE (vr1min) == INTEGER_CST)\n+\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n+\t\t\t\t       build_int_cst (TREE_TYPE (vr1min), 1));\n+\t  else\n+\t    *vr0max = vr1min;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = VR_RANGE;\n+\t  if (TREE_CODE (*vr0max) == INTEGER_CST)\n+\t    *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n+\t\t\t\t       build_int_cst (TREE_TYPE (*vr0max), 1));\n+\t  else\n+\t    *vr0min = *vr0max;\n+\t  *vr0max = vr1max;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((operand_less_p (*vr0min, vr1max) == 1\n+\t    || operand_equal_p (*vr0min, vr1max, 0))\n+\t   && operand_less_p (vr1min, *vr0min) == 1)\n+    {\n+      /* (  [  )  ] or (  )[  ] */\n+      if (*vr0type == VR_ANTI_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\t*vr0min = vr1min;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t*vr0max = vr1max;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  if (TREE_CODE (vr1max) == INTEGER_CST)\n+\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n+\t\t\t\t       build_int_cst (TREE_TYPE (vr1max), 1));\n+\t  else\n+\t    *vr0min = vr1max;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = VR_RANGE;\n+\t  if (TREE_CODE (*vr0min) == INTEGER_CST)\n+\t    *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n+\t\t\t\t       build_int_cst (TREE_TYPE (*vr0min), 1));\n+\t  else\n+\t    *vr0max = *vr0min;\n+\t  *vr0min = vr1min;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  /* If we know the intersection is empty, there's no need to\n+     conservatively add anything else to the set.  */\n+  if (*vr0type == VR_UNDEFINED)\n+    return;\n+\n+  /* As a fallback simply use { *VRTYPE, *VR0MIN, *VR0MAX } as\n+     result for the intersection.  That's always a conservative\n+     correct estimate unless VR1 is a constant singleton range\n+     in which case we choose that.  */\n+  if (vr1type == VR_RANGE\n+      && is_gimple_min_invariant (vr1min)\n+      && vrp_operand_equal_p (vr1min, vr1max))\n+    {\n+      *vr0type = vr1type;\n+      *vr0min = vr1min;\n+      *vr0max = vr1max;\n+    }\n+}\n+\n+/* Helper for the intersection operation for value ranges.  Given two\n+   value ranges VR0 and VR1, return the intersection of the two\n+   ranges.  This may not be the smallest possible such range.  */\n+\n+value_range\n+value_range::intersect_helper (const value_range *vr0, const value_range *vr1)\n+{\n+  /* If either range is VR_VARYING the other one wins.  */\n+  if (vr1->varying_p ())\n+    return *vr0;\n+  if (vr0->varying_p ())\n+    return *vr1;\n+\n+  /* When either range is VR_UNDEFINED the resulting range is\n+     VR_UNDEFINED, too.  */\n+  if (vr0->undefined_p ())\n+    return *vr0;\n+  if (vr1->undefined_p ())\n+    return *vr1;\n+\n+  value_range_kind vr0kind = vr0->kind ();\n+  tree vr0min = vr0->min ();\n+  tree vr0max = vr0->max ();\n+  intersect_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\t    vr1->kind (), vr1->min (), vr1->max ());\n+  /* Make sure to canonicalize the result though as the inversion of a\n+     VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n+     fall back to vr0 when this turns things to varying.  */\n+  value_range tem;\n+  if (vr0kind == VR_UNDEFINED)\n+    tem.set_undefined ();\n+  else if (vr0kind == VR_VARYING)\n+    tem.set_varying (vr0->type ());\n+  else\n+    tem.set (vr0min, vr0max, vr0kind);\n+  /* If that failed, use the saved original VR0.  */\n+  if (tem.varying_p ())\n+    return *vr0;\n+\n+  return tem;\n+}\n+\n+/* Union the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n+   { VR1TYPE, VR0MIN, VR0MAX } and store the result\n+   in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest\n+   possible such range.  The resulting range is not canonicalized.  */\n+\n+static void\n+union_ranges (enum value_range_kind *vr0type,\n+\t      tree *vr0min, tree *vr0max,\n+\t      enum value_range_kind vr1type,\n+\t      tree vr1min, tree vr1max)\n+{\n+  int cmpmin = compare_values (*vr0min, vr1min);\n+  int cmpmax = compare_values (*vr0max, vr1max);\n+  bool mineq = cmpmin == 0;\n+  bool maxeq = cmpmax == 0;\n+\n+  /* [] is vr0, () is vr1 in the following classification comments.  */\n+  if (mineq && maxeq)\n+    {\n+      /* [(  )] */\n+      if (*vr0type == vr1type)\n+\t/* Nothing to do for equal ranges.  */\n+\t;\n+      else if ((*vr0type == VR_RANGE\n+\t\t&& vr1type == VR_ANTI_RANGE)\n+\t       || (*vr0type == VR_ANTI_RANGE\n+\t\t   && vr1type == VR_RANGE))\n+\t{\n+\t  /* For anti-range with range union the result is varying.  */\n+\t  goto give_up;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (operand_less_p (*vr0max, vr1min) == 1\n+\t   || operand_less_p (vr1max, *vr0min) == 1)\n+    {\n+      /* [ ] ( ) or ( ) [ ]\n+\t If the ranges have an empty intersection, result of the union\n+\t operation is the anti-range or if both are anti-ranges\n+\t it covers all.  */\n+      if (*vr0type == VR_ANTI_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\tgoto give_up;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  /* The result is the convex hull of both ranges.  */\n+\t  if (operand_less_p (*vr0max, vr1min) == 1)\n+\t    {\n+\t      /* If the result can be an anti-range, create one.  */\n+\t      if (TREE_CODE (*vr0max) == INTEGER_CST\n+\t\t  && TREE_CODE (vr1min) == INTEGER_CST\n+\t\t  && vrp_val_is_min (*vr0min)\n+\t\t  && vrp_val_is_max (vr1max))\n+\t\t{\n+\t\t  tree min = int_const_binop (PLUS_EXPR,\n+\t\t\t\t\t      *vr0max,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (*vr0max), 1));\n+\t\t  tree max = int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t      vr1min,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (vr1min), 1));\n+\t\t  if (!operand_less_p (max, min))\n+\t\t    {\n+\t\t      *vr0type = VR_ANTI_RANGE;\n+\t\t      *vr0min = min;\n+\t\t      *vr0max = max;\n+\t\t    }\n+\t\t  else\n+\t\t    *vr0max = vr1max;\n+\t\t}\n+\t      else\n+\t\t*vr0max = vr1max;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If the result can be an anti-range, create one.  */\n+\t      if (TREE_CODE (vr1max) == INTEGER_CST\n+\t\t  && TREE_CODE (*vr0min) == INTEGER_CST\n+\t\t  && vrp_val_is_min (vr1min)\n+\t\t  && vrp_val_is_max (*vr0max))\n+\t\t{\n+\t\t  tree min = int_const_binop (PLUS_EXPR,\n+\t\t\t\t\t      vr1max,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (vr1max), 1));\n+\t\t  tree max = int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t      *vr0min,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (*vr0min), 1));\n+\t\t  if (!operand_less_p (max, min))\n+\t\t    {\n+\t\t      *vr0type = VR_ANTI_RANGE;\n+\t\t      *vr0min = min;\n+\t\t      *vr0max = max;\n+\t\t    }\n+\t\t  else\n+\t\t    *vr0min = vr1min;\n+\t\t}\n+\t      else\n+\t\t*vr0min = vr1min;\n+\t    }\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((maxeq || cmpmax == 1)\n+\t   && (mineq || cmpmin == -1))\n+    {\n+      /* [ (  ) ] or [(  ) ] or [ (  )] */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_RANGE)\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  /* Arbitrarily choose the right or left gap.  */\n+\t  if (!mineq && TREE_CODE (vr1min) == INTEGER_CST)\n+\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n+\t\t\t\t       build_int_cst (TREE_TYPE (vr1min), 1));\n+\t  else if (!maxeq && TREE_CODE (vr1max) == INTEGER_CST)\n+\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n+\t\t\t\t       build_int_cst (TREE_TYPE (vr1max), 1));\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t/* The result covers everything.  */\n+\tgoto give_up;\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((maxeq || cmpmax == -1)\n+\t   && (mineq || cmpmin == 1))\n+    {\n+      /* ( [  ] ) or ([  ] ) or ( [  ]) */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  *vr0type = VR_ANTI_RANGE;\n+\t  if (!mineq && TREE_CODE (*vr0min) == INTEGER_CST)\n+\t    {\n+\t      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n+\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0min), 1));\n+\t      *vr0min = vr1min;\n+\t    }\n+\t  else if (!maxeq && TREE_CODE (*vr0max) == INTEGER_CST)\n+\t    {\n+\t      *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n+\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0max), 1));\n+\t      *vr0max = vr1max;\n+\t    }\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t/* The result covers everything.  */\n+\tgoto give_up;\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (cmpmin == -1\n+\t   && cmpmax == -1\n+\t   && (operand_less_p (vr1min, *vr0max) == 1\n+\t       || operand_equal_p (vr1min, *vr0max, 0)))\n+    {\n+      /* [  (  ]  ) or [   ](   ) */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_RANGE)\n+\t*vr0max = vr1max;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t*vr0min = vr1min;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  if (TREE_CODE (vr1min) == INTEGER_CST)\n+\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n+\t\t\t\t       build_int_cst (TREE_TYPE (vr1min), 1));\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  if (TREE_CODE (*vr0max) == INTEGER_CST)\n+\t    {\n+\t      *vr0type = vr1type;\n+\t      *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n+\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0max), 1));\n+\t      *vr0max = vr1max;\n+\t    }\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (cmpmin == 1\n+\t   && cmpmax == 1\n+\t   && (operand_less_p (*vr0min, vr1max) == 1\n+\t       || operand_equal_p (*vr0min, vr1max, 0)))\n+    {\n+      /* (  [  )  ] or (   )[   ] */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_RANGE)\n+\t*vr0min = vr1min;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t*vr0max = vr1max;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  if (TREE_CODE (vr1max) == INTEGER_CST)\n+\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n+\t\t\t\t       build_int_cst (TREE_TYPE (vr1max), 1));\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  if (TREE_CODE (*vr0min) == INTEGER_CST)\n+\t    {\n+\t      *vr0type = vr1type;\n+\t      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n+\t\t\t\t\t build_int_cst (TREE_TYPE (*vr0min), 1));\n+\t      *vr0min = vr1min;\n+\t    }\n+\t  else\n+\t    goto give_up;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else\n+    goto give_up;\n+\n+  return;\n+\n+give_up:\n+  *vr0type = VR_VARYING;\n+  *vr0min = NULL_TREE;\n+  *vr0max = NULL_TREE;\n+}\n+\n+/* Helper for meet operation for value ranges.  Given two value ranges VR0 and\n+   VR1, return a range that contains both VR0 and VR1.  This may not be the\n+   smallest possible such range.  */\n+\n+value_range\n+value_range::union_helper (const value_range *vr0, const value_range *vr1)\n+{\n+  /* VR0 has the resulting range if VR1 is undefined or VR0 is varying.  */\n+  if (vr1->undefined_p ()\n+      || vr0->varying_p ())\n+    return *vr0;\n+\n+  /* VR1 has the resulting range if VR0 is undefined or VR1 is varying.  */\n+  if (vr0->undefined_p ()\n+      || vr1->varying_p ())\n+    return *vr1;\n+\n+  value_range_kind vr0kind = vr0->kind ();\n+  tree vr0min = vr0->min ();\n+  tree vr0max = vr0->max ();\n+  union_ranges (&vr0kind, &vr0min, &vr0max,\n+\t\tvr1->kind (), vr1->min (), vr1->max ());\n+\n+  /* Work on a temporary so we can still use vr0 when union returns varying.  */\n+  value_range tem;\n+  if (vr0kind == VR_UNDEFINED)\n+    tem.set_undefined ();\n+  else if (vr0kind == VR_VARYING)\n+    tem.set_varying (vr0->type ());\n+  else\n+    tem.set (vr0min, vr0max, vr0kind);\n+\n+  /* Failed to find an efficient meet.  Before giving up and setting\n+     the result to VARYING, see if we can at least derive a useful\n+     anti-range.  */\n+  if (tem.varying_p ()\n+      && range_includes_zero_p (vr0) == 0\n+      && range_includes_zero_p (vr1) == 0)\n+    {\n+      tem.set_nonzero (vr0->type ());\n+      return tem;\n+    }\n+\n+  return tem;\n+}\n+\n+/* Meet operation for value ranges.  Given two value ranges VR0 and\n+   VR1, store in VR0 a range that contains both VR0 and VR1.  This\n+   may not be the smallest possible such range.  */\n+\n+void\n+value_range::union_ (const value_range *other)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Meeting\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\nand\\n  \");\n+      dump_value_range (dump_file, other);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  *this = union_helper (this, other);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"to\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Range union, but for references.  */\n+\n+void\n+value_range::union_ (const value_range &r)\n+{\n+  /* Disable details for now, because it makes the ranger dump\n+     unnecessarily verbose.  */\n+  bool details = dump_flags & TDF_DETAILS;\n+  if (details)\n+    dump_flags &= ~TDF_DETAILS;\n+  union_ (&r);\n+  if (details)\n+    dump_flags |= TDF_DETAILS;\n+}\n+\n+void\n+value_range::intersect (const value_range *other)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Intersecting\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\nand\\n  \");\n+      dump_value_range (dump_file, other);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  *this = intersect_helper (this, other);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"to\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Range intersect, but for references.  */\n+\n+void\n+value_range::intersect (const value_range &r)\n+{\n+  /* Disable details for now, because it makes the ranger dump\n+     unnecessarily verbose.  */\n+  bool details = dump_flags & TDF_DETAILS;\n+  if (details)\n+    dump_flags &= ~TDF_DETAILS;\n+  intersect (&r);\n+  if (details)\n+    dump_flags |= TDF_DETAILS;\n+}\n+\n+/* Return the inverse of a range.  */\n+\n+void\n+value_range::invert ()\n+{\n+  /* We can't just invert VR_RANGE and VR_ANTI_RANGE because we may\n+     create non-canonical ranges.  Use the constructors instead.  */\n+  if (m_kind == VR_RANGE)\n+    *this = value_range (m_min, m_max, VR_ANTI_RANGE);\n+  else if (m_kind == VR_ANTI_RANGE)\n+    *this = value_range (m_min, m_max);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+void\n+value_range::dump (FILE *file) const\n+{\n+  if (undefined_p ())\n+    fprintf (file, \"UNDEFINED\");\n+  else if (m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n+    {\n+      tree ttype = type ();\n+\n+      print_generic_expr (file, ttype);\n+      fprintf (file, \" \");\n+\n+      fprintf (file, \"%s[\", (m_kind == VR_ANTI_RANGE) ? \"~\" : \"\");\n+\n+      if (INTEGRAL_TYPE_P (ttype)\n+\t  && !TYPE_UNSIGNED (ttype)\n+\t  && vrp_val_is_min (min ())\n+\t  && TYPE_PRECISION (ttype) != 1)\n+\tfprintf (file, \"-INF\");\n+      else\n+\tprint_generic_expr (file, min ());\n+\n+      fprintf (file, \", \");\n+\n+      if (supports_type_p (ttype)\n+\t  && vrp_val_is_max (max ())\n+\t  && TYPE_PRECISION (ttype) != 1)\n+\tfprintf (file, \"+INF\");\n+      else\n+\tprint_generic_expr (file, max ());\n+\n+      fprintf (file, \"]\");\n+    }\n+  else if (varying_p ())\n+    {\n+      print_generic_expr (file, type ());\n+      fprintf (file, \" VARYING\");\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+void\n+value_range::dump () const\n+{\n+  dump (stderr);\n+}\n+\n+void\n+dump_value_range (FILE *file, const value_range *vr)\n+{\n+  if (!vr)\n+    fprintf (file, \"[]\");\n+  else\n+    vr->dump (file);\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const value_range *vr)\n+{\n+  dump_value_range (stderr, vr);\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const value_range &vr)\n+{\n+  dump_value_range (stderr, &vr);\n+}\n+\n+/* Create two value-ranges in *VR0 and *VR1 from the anti-range *AR\n+   so that *VR0 U *VR1 == *AR.  Returns true if that is possible,\n+   false otherwise.  If *AR can be represented with a single range\n+   *VR1 will be VR_UNDEFINED.  */\n+\n+bool\n+ranges_from_anti_range (const value_range *ar,\n+\t\t\tvalue_range *vr0, value_range *vr1)\n+{\n+  tree type = ar->type ();\n+\n+  vr0->set_undefined ();\n+  vr1->set_undefined ();\n+\n+  /* As a future improvement, we could handle ~[0, A] as: [-INF, -1] U\n+     [A+1, +INF].  Not sure if this helps in practice, though.  */\n+\n+  if (ar->kind () != VR_ANTI_RANGE\n+      || TREE_CODE (ar->min ()) != INTEGER_CST\n+      || TREE_CODE (ar->max ()) != INTEGER_CST\n+      || !vrp_val_min (type)\n+      || !vrp_val_max (type))\n+    return false;\n+\n+  if (tree_int_cst_lt (vrp_val_min (type), ar->min ()))\n+    vr0->set (vrp_val_min (type),\n+\t      wide_int_to_tree (type, wi::to_wide (ar->min ()) - 1));\n+  if (tree_int_cst_lt (ar->max (), vrp_val_max (type)))\n+    vr1->set (wide_int_to_tree (type, wi::to_wide (ar->max ()) + 1),\n+\t      vrp_val_max (type));\n+  if (vr0->undefined_p ())\n+    {\n+      *vr0 = *vr1;\n+      vr1->set_undefined ();\n+    }\n+\n+  return !vr0->undefined_p ();\n+}\n+\n+bool\n+range_has_numeric_bounds_p (const value_range *vr)\n+{\n+  return (vr->min ()\n+\t  && TREE_CODE (vr->min ()) == INTEGER_CST\n+\t  && TREE_CODE (vr->max ()) == INTEGER_CST);\n+}\n+\n+/* Return the maximum value for TYPE.  */\n+\n+tree\n+vrp_val_max (const_tree type)\n+{\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MAX_VALUE (type);\n+  if (POINTER_TYPE_P (type))\n+    {\n+      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      return wide_int_to_tree (const_cast<tree> (type), max);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Return the minimum value for TYPE.  */\n+\n+tree\n+vrp_val_min (const_tree type)\n+{\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MIN_VALUE (type);\n+  if (POINTER_TYPE_P (type))\n+    return build_zero_cst (const_cast<tree> (type));\n+  return NULL_TREE;\n+}\n+\n+/* Return whether VAL is equal to the maximum value of its type.\n+   We can't do a simple equality comparison with TYPE_MAX_VALUE because\n+   C typedefs and Ada subtypes can produce types whose TYPE_MAX_VALUE\n+   is not == to the integer constant with the same value in the type.  */\n+\n+bool\n+vrp_val_is_max (const_tree val)\n+{\n+  tree type_max = vrp_val_max (TREE_TYPE (val));\n+  return (val == type_max\n+\t  || (type_max != NULL_TREE\n+\t      && operand_equal_p (val, type_max, 0)));\n+}\n+\n+/* Return whether VAL is equal to the minimum value of its type.  */\n+\n+bool\n+vrp_val_is_min (const_tree val)\n+{\n+  tree type_min = vrp_val_min (TREE_TYPE (val));\n+  return (val == type_min\n+\t  || (type_min != NULL_TREE\n+\t      && operand_equal_p (val, type_min, 0)));\n+}\n+\n+/* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */\n+\n+bool\n+vrp_operand_equal_p (const_tree val1, const_tree val2)\n+{\n+  if (val1 == val2)\n+    return true;\n+  if (!val1 || !val2 || !operand_equal_p (val1, val2, 0))\n+    return false;\n+  return true;\n+}"}, {"sha": "8a88e9a6e8cf6ca11eca491310735e90b4c3037b", "filename": "gcc/value-range.h", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cca78449beb70da5d1e65e206044b3ef22a48b55/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=cca78449beb70da5d1e65e206044b3ef22a48b55", "patch": "@@ -0,0 +1,216 @@\n+/* Support routines for value ranges.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VALUE_RANGE_H\n+#define GCC_VALUE_RANGE_H\n+\n+/* Types of value ranges.  */\n+enum value_range_kind\n+{\n+  /* Empty range.  */\n+  VR_UNDEFINED,\n+  /* Range spans the entire domain.  */\n+  VR_VARYING,\n+  /* Range is [MIN, MAX].  */\n+  VR_RANGE,\n+  /* Range is ~[MIN, MAX].  */\n+  VR_ANTI_RANGE,\n+  /* Range is a nice guy.  */\n+  VR_LAST\n+};\n+\n+// Range of values that can be associated with an SSA_NAME.\n+\n+class GTY((for_user)) value_range\n+{\n+  friend void range_tests ();\n+public:\n+  value_range ();\n+  value_range (tree, tree, value_range_kind = VR_RANGE);\n+  value_range (tree type, const wide_int &, const wide_int &,\n+\t       value_range_kind = VR_RANGE);\n+  value_range (tree type);\n+\n+  void set (tree, tree, value_range_kind = VR_RANGE);\n+  void set (tree);\n+  void set_nonzero (tree);\n+  void set_zero (tree);\n+\n+  enum value_range_kind kind () const;\n+  tree min () const;\n+  tree max () const;\n+\n+  /* Types of value ranges.  */\n+  bool symbolic_p () const;\n+  bool constant_p () const;\n+  bool undefined_p () const;\n+  bool varying_p () const;\n+  void set_varying (tree type);\n+  void set_undefined ();\n+\n+  void union_ (const value_range *);\n+  void intersect (const value_range *);\n+  void union_ (const value_range &);\n+  void intersect (const value_range &);\n+\n+  bool operator== (const value_range &) const;\n+  bool operator!= (const value_range &) const /* = delete */;\n+  bool equal_p (const value_range &) const;\n+\n+  /* Misc methods.  */\n+  tree type () const;\n+  bool may_contain_p (tree) const;\n+  bool zero_p () const;\n+  bool nonzero_p () const;\n+  bool singleton_p (tree *result = NULL) const;\n+  void dump (FILE *) const;\n+  void dump () const;\n+\n+  static bool supports_type_p (tree);\n+  value_range normalize_symbolics () const;\n+  value_range normalize_addresses () const;\n+\n+  static const unsigned int m_max_pairs = 2;\n+  bool contains_p (tree) const;\n+  unsigned num_pairs () const;\n+  wide_int lower_bound (unsigned = 0) const;\n+  wide_int upper_bound (unsigned) const;\n+  wide_int upper_bound () const;\n+  void invert ();\n+\n+protected:\n+  void check ();\n+  static value_range union_helper (const value_range *, const value_range *);\n+  static value_range intersect_helper (const value_range *,\n+\t\t\t\t       const value_range *);\n+\n+  friend void gt_ggc_mx_value_range (void *);\n+  friend void gt_pch_p_11value_range (void *, void *,\n+\t\t\t\t      gt_pointer_operator, void *);\n+  friend void gt_pch_nx_value_range (void *);\n+  friend void gt_ggc_mx (value_range &);\n+  friend void gt_ggc_mx (value_range *&);\n+  friend void gt_pch_nx (value_range &);\n+  friend void gt_pch_nx (value_range *, gt_pointer_operator, void *);\n+\n+  enum value_range_kind m_kind;\n+  tree m_min;\n+  tree m_max;\n+\n+private:\n+  int value_inside_range (tree) const;\n+};\n+\n+extern bool range_has_numeric_bounds_p (const value_range *);\n+extern bool ranges_from_anti_range (const value_range *,\n+\t\t\t\t    value_range *, value_range *);\n+extern void dump_value_range (FILE *, const value_range *);\n+extern bool vrp_val_is_min (const_tree);\n+extern bool vrp_val_is_max (const_tree);\n+extern tree vrp_val_min (const_tree);\n+extern tree vrp_val_max (const_tree);\n+extern bool vrp_operand_equal_p (const_tree, const_tree);\n+\n+inline\n+value_range::value_range ()\n+{\n+  m_kind = VR_UNDEFINED;\n+  m_min = m_max = NULL;\n+}\n+\n+inline value_range_kind\n+value_range::kind () const\n+{\n+  return m_kind;\n+}\n+\n+inline tree\n+value_range::type () const\n+{\n+  return TREE_TYPE (min ());\n+}\n+\n+inline tree\n+value_range::min () const\n+{\n+  return m_min;\n+}\n+\n+inline tree\n+value_range::max () const\n+{\n+  return m_max;\n+}\n+\n+inline bool\n+value_range::varying_p () const\n+{\n+  return m_kind == VR_VARYING;\n+}\n+\n+inline bool\n+value_range::undefined_p () const\n+{\n+  return m_kind == VR_UNDEFINED;\n+}\n+\n+inline bool\n+value_range::zero_p () const\n+{\n+  return (m_kind == VR_RANGE\n+\t  && integer_zerop (m_min)\n+\t  && integer_zerop (m_max));\n+}\n+\n+inline bool\n+value_range::nonzero_p () const\n+{\n+  if (m_kind == VR_ANTI_RANGE\n+      && !TYPE_UNSIGNED (type ())\n+      && integer_zerop (m_min)\n+      && integer_zerop (m_max))\n+    return true;\n+\n+  return (m_kind == VR_RANGE\n+\t  && TYPE_UNSIGNED (type ())\n+\t  && integer_onep (m_min)\n+\t  && vrp_val_is_max (m_max));\n+}\n+\n+inline bool\n+value_range::supports_type_p (tree type)\n+{\n+  if (type && (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)))\n+    return type;\n+  return false;\n+}\n+\n+inline bool\n+range_includes_zero_p (const value_range *vr)\n+{\n+  if (vr->undefined_p ())\n+    return false;\n+\n+  if (vr->varying_p ())\n+    return true;\n+\n+  return vr->may_contain_p (build_zero_cst (vr->type ()));\n+}\n+\n+#endif // GCC_VALUE_RANGE_H"}]}