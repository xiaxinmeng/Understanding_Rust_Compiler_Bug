{"sha": "9b195552ab86ef09b69ddcd3c2243c166c4a8558", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxOTU1NTJhYjg2ZWYwOWI2OWRkY2QzYzIyNDNjMTY2YzRhODU1OA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2017-04-10T14:58:33Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2017-04-10T14:58:33Z"}, "message": "re PR rtl-optimization/70478 ([LRA] S/390: Performance regression - superfluous stack frame)\n\n2017-04-10  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/70478\n\t* lra-constraints.c (curr_small_class_check): New.\n\t(update_and_check_small_class_inputs): New.\n\t(process_alt_operands): Update curr_small_class_check.  Disfavor\n\talternative insn memory operands.  Check available regs for small\n\tclass operands.\n\nFrom-SVN: r246808", "tree": {"sha": "64ff01c322fd901eb7a2fc42fbdd4783ffd41f58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64ff01c322fd901eb7a2fc42fbdd4783ffd41f58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b195552ab86ef09b69ddcd3c2243c166c4a8558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b195552ab86ef09b69ddcd3c2243c166c4a8558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b195552ab86ef09b69ddcd3c2243c166c4a8558", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b195552ab86ef09b69ddcd3c2243c166c4a8558/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1246dc40673aa025027039fbcad61f6100e523ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1246dc40673aa025027039fbcad61f6100e523ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1246dc40673aa025027039fbcad61f6100e523ac"}], "stats": {"total": 69, "additions": 69, "deletions": 0}, "files": [{"sha": "00b994b5245d13756111b58f891ec18cd70f193a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b195552ab86ef09b69ddcd3c2243c166c4a8558/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b195552ab86ef09b69ddcd3c2243c166c4a8558/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b195552ab86ef09b69ddcd3c2243c166c4a8558", "patch": "@@ -1,3 +1,12 @@\n+2017-04-10  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/70478\n+\t* lra-constraints.c (curr_small_class_check): New.\n+\t(update_and_check_small_class_inputs): New.\n+\t(process_alt_operands): Update curr_small_class_check.  Disfavor\n+\talternative insn memory operands.  Check available regs for small\n+\tclass operands.\n+\n 2017-03-31  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \tPR target/80057"}, {"sha": "82b1ed0d403122dc58898d0e6ac678ff9ea4b725", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b195552ab86ef09b69ddcd3c2243c166c4a8558/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b195552ab86ef09b69ddcd3c2243c166c4a8558/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=9b195552ab86ef09b69ddcd3c2243c166c4a8558", "patch": "@@ -1852,6 +1852,42 @@ prohibited_class_reg_set_mode_p (enum reg_class rclass,\n \t  (temp, ira_prohibited_class_mode_regs[rclass][mode]));\n }\n \n+\n+/* Used to check validity info about small class input operands.  It\n+   should be incremented at start of processing an insn\n+   alternative.  */\n+static unsigned int curr_small_class_check = 0;\n+\n+/* Update number of used inputs of class OP_CLASS for operand NOP.\n+   Return true if we have more such class operands than the number of\n+   available regs.  */\n+static bool\n+update_and_check_small_class_inputs (int nop, enum reg_class op_class)\n+{\n+  static unsigned int small_class_check[LIM_REG_CLASSES];\n+  static int small_class_input_nums[LIM_REG_CLASSES];\n+  \n+  if (SMALL_REGISTER_CLASS_P (op_class)\n+      /* We are interesting in classes became small because of fixing\n+\t some hard regs, e.g. by an user through GCC options.  */\n+      && hard_reg_set_intersect_p (reg_class_contents[op_class],\n+\t\t\t\t   ira_no_alloc_regs)\n+      && (curr_static_id->operand[nop].type != OP_OUT\n+\t  || curr_static_id->operand[nop].early_clobber))\n+    {\n+      if (small_class_check[op_class] == curr_small_class_check)\n+\tsmall_class_input_nums[op_class]++;\n+      else\n+\t{\n+\t  small_class_check[op_class] = curr_small_class_check;\n+\t  small_class_input_nums[op_class] = 1;\n+\t}\n+      if (small_class_input_nums[op_class] > ira_class_hard_regs_num[op_class])\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Major function to choose the current insn alternative and what\n    operands should be reloaded and how.\t If ONLY_ALTERNATIVE is not\n    negative we should consider only this alternative.  Return false if\n@@ -1952,6 +1988,7 @@ process_alt_operands (int only_alternative)\n       if (!TEST_BIT (preferred, nalt))\n \tcontinue;\n \n+      curr_small_class_check++;\n       overall = losers = addr_losers = 0;\n       static_reject = reject = reload_nregs = reload_sum = 0;\n       for (nop = 0; nop < n_operands; nop++)\n@@ -2685,6 +2722,21 @@ process_alt_operands (int only_alternative)\n \t\t    }\n \t\t}\n \n+\t      /* When we use memory operand, the insn should read the\n+\t\t value from memory and even if we just wrote a value\n+\t\t into the memory it is costly in comparison with an\n+\t\t insn alternative which does not use memory\n+\t\t (e.g. register or immediate operand).  */\n+\t      if (no_regs_p && offmemok)\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    fprintf\n+\t\t      (lra_dump_file,\n+\t\t       \"            Using memory insn operand %d: reject+=3\\n\",\n+\t\t       nop);\n+\t\t  reject += 3;\n+\t\t}\n+\t      \n #ifdef SECONDARY_MEMORY_NEEDED\n \t      /* If reload requires moving value through secondary\n \t\t memory, it will need one more insn at least.  */\n@@ -2747,6 +2799,14 @@ process_alt_operands (int only_alternative)\n               goto fail;\n             }\n \n+\t  if (update_and_check_small_class_inputs (nop, this_alternative))\n+\t    {\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf (lra_dump_file,\n+\t\t\t \"            alt=%d, not enough small class regs -- refuse\\n\",\n+\t\t\t nalt);\n+\t      goto fail;\n+\t    }\n \t  curr_alt[nop] = this_alternative;\n \t  COPY_HARD_REG_SET (curr_alt_set[nop], this_alternative_set);\n \t  curr_alt_win[nop] = this_alternative_win;"}]}