{"sha": "7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxMDI1N2ZkZGRiNzdlMTg1NGYyMjNmYzM4YzdkNjk1ZmI4ZWJiNA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-01-05T21:21:16Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-01-05T21:21:16Z"}, "message": "re PR middle-end/38492 ([graphite] segfaulting code when compiled with -fgraphite -fgraphite-identity)\n\n2009-01-05  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/38492\n\t* graphite.c (rename_map_elt, debug_rename_elt,\n        debug_rename_map_1, debug_rename_map, new_rename_map_elt,\n        rename_map_elt_info, eq_rename_map_elts,\n        get_new_name_from_old_name, bb_in_sese_p): Moved around.\n\t(sese_find_uses_to_rename_use): Renamed sese_build_livein_liveouts_use.\n\t(sese_find_uses_to_rename_bb): Renamed sese_build_livein_liveouts_bb.\n\t(sese_build_livein_liveouts): New.\n\t(new_sese, free_sese): New.\n\t(new_scop): Call new_sese.\n\t(free_scop): Call free_sese.\n\t(rename_variables_from_edge, rename_phis_end_scop): Removed.\n\t(register_old_new_names): Renamed register_old_and_new_names.\n\t(register_scop_liveout_renames, add_loop_exit_phis,\n\tinsert_loop_close_phis, struct igp,\n\tdefault_liveout_before_guard, add_guard_exit_phis,\n\tinsert_guard_phis, copy_renames): New.\n\t(translate_clast): Call insert_loop_close_phis and insert_guard_phis.\n\t(sese_add_exit_phis_edge): Renamed scop_add_exit_phis_edge.\n\t(rewrite_into_sese_closed_ssa): Renamed scop_insert_phis_for_liveouts.\n\t(scop_adjust_phis_for_liveouts): New.\n\t(gloog): Call scop_adjust_phis_for_liveouts.\n\n\t* graphite.h (struct sese): Documented.  Added fields liveout,\n        num_ver and livein.\n\t(SESE_LIVEOUT, SESE_LIVEIN, SESE_LIVEIN_VER, SESE_NUM_VER): New.\n\t(new_sese, free_sese, sese_build_livein_liveouts): Declared.\n\t(struct scop): Added field liveout_renames.\n\t(SCOP_LIVEOUT_RENAMES): New.\n\nFrom-SVN: r143097", "tree": {"sha": "7103675e82bd26353d156d348a7f09c39210cc96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7103675e82bd26353d156d348a7f09c39210cc96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eefe5da052814d1ba1b047abbd016ce6de6f73c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eefe5da052814d1ba1b047abbd016ce6de6f73c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eefe5da052814d1ba1b047abbd016ce6de6f73c8"}], "stats": {"total": 760, "additions": 533, "deletions": 227}, "files": [{"sha": "0cccf3b545c5ba45bf8668a277893c4e33dcc985", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "patch": "@@ -1,3 +1,35 @@\n+2009-01-05  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/38492\n+\t* graphite.c (rename_map_elt, debug_rename_elt,\n+        debug_rename_map_1, debug_rename_map, new_rename_map_elt,\n+        rename_map_elt_info, eq_rename_map_elts,\n+        get_new_name_from_old_name, bb_in_sese_p): Moved around.\n+\t(sese_find_uses_to_rename_use): Renamed sese_build_livein_liveouts_use.\n+\t(sese_find_uses_to_rename_bb): Renamed sese_build_livein_liveouts_bb.\n+\t(sese_build_livein_liveouts): New.\n+\t(new_sese, free_sese): New.\n+\t(new_scop): Call new_sese.\n+\t(free_scop): Call free_sese.\n+\t(rename_variables_from_edge, rename_phis_end_scop): Removed.\n+\t(register_old_new_names): Renamed register_old_and_new_names.\n+\t(register_scop_liveout_renames, add_loop_exit_phis,\n+\tinsert_loop_close_phis, struct igp,\n+\tdefault_liveout_before_guard, add_guard_exit_phis,\n+\tinsert_guard_phis, copy_renames): New.\n+\t(translate_clast): Call insert_loop_close_phis and insert_guard_phis.\n+\t(sese_add_exit_phis_edge): Renamed scop_add_exit_phis_edge.\n+\t(rewrite_into_sese_closed_ssa): Renamed scop_insert_phis_for_liveouts.\n+\t(scop_adjust_phis_for_liveouts): New.\n+\t(gloog): Call scop_adjust_phis_for_liveouts.\n+\n+\t* graphite.h (struct sese): Documented.  Added fields liveout,\n+        num_ver and livein.\n+\t(SESE_LIVEOUT, SESE_LIVEIN, SESE_LIVEIN_VER, SESE_NUM_VER): New.\n+\t(new_sese, free_sese, sese_build_livein_liveouts): Declared.\n+\t(struct scop): Added field liveout_renames.\n+\t(SCOP_LIVEOUT_RENAMES): New.\n+\n 2009-01-05  Harsha Jagasia  <harsha.jagasia@amd.com>\n \n \tPR tree-optimization/38510"}, {"sha": "b03e0619c5b7fd128006449f671ddcd7db7da401", "filename": "gcc/graphite.c", "status": "modified", "additions": 473, "deletions": 227, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "patch": "@@ -1183,6 +1183,169 @@ free_graphite_bb (struct graphite_bb *gbb)\n   XDELETE (gbb);\n }\n \n+\f\n+\n+/* Structure containing the mapping between the old names and the new\n+   names used after block copy in the new loop context.  */\n+typedef struct rename_map_elt\n+{\n+  tree old_name, new_name;\n+} *rename_map_elt;\n+\n+\n+/* Print to stderr the element ELT.  */\n+\n+static void\n+debug_rename_elt (rename_map_elt elt)\n+{\n+  fprintf (stderr, \"(\");\n+  print_generic_expr (stderr, elt->old_name, 0);\n+  fprintf (stderr, \", \");\n+  print_generic_expr (stderr, elt->new_name, 0);\n+  fprintf (stderr, \")\\n\");\n+}\n+\n+/* Helper function for debug_rename_map.  */\n+\n+static int\n+debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+{\n+  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  debug_rename_elt (entry);\n+  return 1;\n+}\n+\n+/* Print to stderr all the elements of MAP.  */\n+\n+void\n+debug_rename_map (htab_t map)\n+{\n+  htab_traverse (map, debug_rename_map_1, NULL);\n+}\n+\n+/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n+\n+static inline rename_map_elt\n+new_rename_map_elt (tree old_name, tree new_name)\n+{\n+  rename_map_elt res;\n+  \n+  res = XNEW (struct rename_map_elt);\n+  res->old_name = old_name;\n+  res->new_name = new_name;\n+\n+  return res;\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+static hashval_t\n+rename_map_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct rename_map_elt *) elt)->old_name);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+static int\n+eq_rename_map_elts (const void *e1, const void *e2)\n+{\n+  const struct rename_map_elt *elt1 = (const struct rename_map_elt *) e1;\n+  const struct rename_map_elt *elt2 = (const struct rename_map_elt *) e2;\n+\n+  return (elt1->old_name == elt2->old_name);\n+}\n+\n+/* Returns the new name associated to OLD_NAME in MAP.  */\n+\n+static tree\n+get_new_name_from_old_name (htab_t map, tree old_name)\n+{\n+  struct rename_map_elt tmp;\n+  PTR *slot;\n+\n+  tmp.old_name = old_name;\n+  slot = htab_find_slot (map, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((rename_map_elt) *slot)->new_name;\n+\n+  return old_name;\n+}\n+\n+\f\n+\n+/* Returns true when BB is in REGION.  */\n+\n+static bool\n+bb_in_sese_p (basic_block bb, sese region)\n+{\n+  return pointer_set_contains (SESE_REGION_BBS (region), bb);\n+}\n+\n+/* For a USE in BB, if BB is outside REGION, mark the USE in the\n+   SESE_LIVEIN and SESE_LIVEOUT sets.  */\n+\n+static void\n+sese_build_livein_liveouts_use (sese region, basic_block bb, tree use)\n+{\n+  unsigned ver;\n+  basic_block def_bb;\n+\n+  if (TREE_CODE (use) != SSA_NAME)\n+    return;\n+\n+  ver = SSA_NAME_VERSION (use);\n+  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n+  if (!def_bb\n+      || !bb_in_sese_p (def_bb, region)\n+      || bb_in_sese_p (bb, region))\n+    return;\n+\n+  if (!SESE_LIVEIN_VER (region, ver))\n+    SESE_LIVEIN_VER (region, ver) = BITMAP_ALLOC (NULL);\n+\n+  bitmap_set_bit (SESE_LIVEIN_VER (region, ver), bb->index);\n+  bitmap_set_bit (SESE_LIVEOUT (region), ver);\n+}\n+\n+/* Marks for rewrite all the SSA_NAMES defined in REGION and that are\n+   used in BB that is outside of the REGION.  */\n+\n+static void\n+sese_build_livein_liveouts_bb (sese region, basic_block bb)\n+{\n+  gimple_stmt_iterator bsi;\n+  edge e;\n+  edge_iterator ei;\n+  ssa_op_iter iter;\n+  tree var;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n+      sese_build_livein_liveouts_use (region, bb,\n+\t\t\t\t      PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e));\n+\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    FOR_EACH_SSA_TREE_OPERAND (var, gsi_stmt (bsi), iter, SSA_OP_ALL_USES)\n+      sese_build_livein_liveouts_use (region, bb, var);\n+}\n+\n+/* Build the SESE_LIVEIN and SESE_LIVEOUT for REGION.  */\n+\n+void\n+sese_build_livein_liveouts (sese region)\n+{\n+  basic_block bb;\n+\n+  SESE_LIVEOUT (region) = BITMAP_ALLOC (NULL);\n+  SESE_NUM_VER (region) = num_ssa_names;\n+  SESE_LIVEIN (region) = XCNEWVEC (bitmap, SESE_NUM_VER (region));\n+\n+  FOR_EACH_BB (bb)\n+    sese_build_livein_liveouts_bb (region, bb);\n+}\n+\n /* Register basic blocks belonging to a region in a pointer set.  */\n \n static void\n@@ -1203,6 +1366,47 @@ register_bb_in_sese (basic_block entry_bb, basic_block exit_bb, sese region)\n     }\n }\n \n+/* Builds a new SESE region from edges ENTRY and EXIT.  */\n+\n+sese\n+new_sese (edge entry, edge exit)\n+{\n+  sese res = XNEW (struct sese);\n+\n+  SESE_ENTRY (res) = entry;\n+  SESE_EXIT (res) = exit;\n+  SESE_REGION_BBS (res) = pointer_set_create ();\n+  register_bb_in_sese (entry->dest, exit->dest, res);\n+\n+  SESE_LIVEOUT (res) = NULL;\n+  SESE_NUM_VER (res) = 0;\n+  SESE_LIVEIN (res) = NULL;\n+\n+  return res;\n+}\n+\n+/* Deletes REGION.  */\n+\n+void\n+free_sese (sese region)\n+{\n+  int i;\n+\n+  for (i = 0; i < SESE_NUM_VER (region); i++)\n+    BITMAP_FREE (SESE_LIVEIN_VER (region, i));\n+\n+  if (SESE_LIVEIN (region))\n+    free (SESE_LIVEIN (region));\n+\n+  if (SESE_LIVEOUT (region))\n+    BITMAP_FREE (SESE_LIVEOUT (region));\n+\n+  pointer_set_destroy (SESE_REGION_BBS (region));\n+  XDELETE (region);\n+}\n+\n+\f\n+\n /* Creates a new scop starting with ENTRY.  */\n \n static scop_p\n@@ -1212,12 +1416,7 @@ new_scop (edge entry, edge exit)\n \n   gcc_assert (entry && exit);\n \n-  SCOP_REGION (scop) = XNEW (struct sese);\n-  SESE_ENTRY (SCOP_REGION (scop)) = entry;\n-  SESE_EXIT (SCOP_REGION (scop)) = exit;\n-  SESE_REGION_BBS (SCOP_REGION (scop)) = pointer_set_create ();\n-  register_bb_in_sese (SCOP_ENTRY (scop), SCOP_EXIT (scop),\n-\t\t       SCOP_REGION (scop));\n+  SCOP_REGION (scop) = new_sese (entry, exit);\n   SCOP_BBS (scop) = VEC_alloc (graphite_bb_p, heap, 3);\n   SCOP_OLDIVS (scop) = VEC_alloc (name_tree, heap, 3);\n   SCOP_BBS_B (scop) = BITMAP_ALLOC (NULL);\n@@ -1230,6 +1429,8 @@ new_scop (edge entry, edge exit)\n   SCOP_LOOP2CLOOG_LOOP (scop) = htab_create (10, hash_loop_to_cloog_loop,\n \t\t\t\t\t     eq_loop_to_cloog_loop,\n \t\t\t\t\t     free);\n+  SCOP_LIVEOUT_RENAMES (scop) = htab_create (10, rename_map_elt_info,\n+\t\t\t\t\t     eq_rename_map_elts, free);\n   return scop;\n }\n \n@@ -1261,7 +1462,8 @@ free_scop (scop_p scop)\n   VEC_free (name_tree, heap, SCOP_PARAMS (scop));\n   cloog_program_free (SCOP_PROG (scop));\n   htab_delete (SCOP_LOOP2CLOOG_LOOP (scop)); \n-  XDELETE (SCOP_REGION (scop));\n+  htab_delete (SCOP_LIVEOUT_RENAMES (scop));\n+  free_sese (SCOP_REGION (scop));\n   XDELETE (scop);\n }\n \n@@ -3754,94 +3956,6 @@ graphite_create_new_loop (scop_p scop, edge entry_edge,\n   return loop;\n }\n \n-/* Structure containing the mapping between the old names and the new\n-   names used after block copy in the new loop context.  */\n-typedef struct rename_map_elt\n-{\n-  tree old_name, new_name;\n-} *rename_map_elt;\n-\n-\n-/* Print to stderr the element ELT.  */\n-\n-static void\n-debug_rename_elt (rename_map_elt elt)\n-{\n-  fprintf (stderr, \"(\");\n-  print_generic_expr (stderr, elt->old_name, 0);\n-  fprintf (stderr, \", \");\n-  print_generic_expr (stderr, elt->new_name, 0);\n-  fprintf (stderr, \")\\n\");\n-}\n-\n-/* Helper function for debug_rename_map.  */\n-\n-static int\n-debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n-{\n-  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n-  debug_rename_elt (entry);\n-  return 1;\n-}\n-\n-/* Print to stderr all the elements of MAP.  */\n-\n-void\n-debug_rename_map (htab_t map)\n-{\n-  htab_traverse (map, debug_rename_map_1, NULL);\n-}\n-\n-/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n-\n-static inline rename_map_elt\n-new_rename_map_elt (tree old_name, tree new_name)\n-{\n-  rename_map_elt res;\n-  \n-  res = XNEW (struct rename_map_elt);\n-  res->old_name = old_name;\n-  res->new_name = new_name;\n-\n-  return res;\n-}\n-\n-/* Computes a hash function for database element ELT.  */\n-\n-static hashval_t\n-rename_map_elt_info (const void *elt)\n-{\n-  return htab_hash_pointer (((const struct rename_map_elt *) elt)->old_name);\n-}\n-\n-/* Compares database elements E1 and E2.  */\n-\n-static int\n-eq_rename_map_elts (const void *e1, const void *e2)\n-{\n-  const struct rename_map_elt *elt1 = (const struct rename_map_elt *) e1;\n-  const struct rename_map_elt *elt2 = (const struct rename_map_elt *) e2;\n-\n-  return (elt1->old_name == elt2->old_name);\n-}\n-\n-/* Returns the new name associated to OLD_NAME in MAP.  */\n-\n-static tree\n-get_new_name_from_old_name (htab_t map, tree old_name)\n-{\n-  struct rename_map_elt tmp;\n-  PTR *slot;\n-\n-  tmp.old_name = old_name;\n-  slot = htab_find_slot (map, &tmp, NO_INSERT);\n-\n-  if (slot && *slot)\n-    return ((rename_map_elt) *slot)->new_name;\n-\n-  return old_name;\n-}\n-\n /* Rename the SSA_NAMEs used in STMT and that appear in IVSTACK.  */\n \n static void \n@@ -4032,38 +4146,6 @@ rename_variables (basic_block bb, htab_t map)\n     rename_variables_in_stmt (gsi_stmt (gsi), map);\n }\n \n-/* Rename following the information from MAP the PHI node argument\n-   corresponding to the edge E.  In order to allow several renames of\n-   that argument, we match the original SSA_NAME on the argument\n-   coming from the edge different than E.  */\n-\n-static void\n-rename_variables_from_edge (edge e, gimple phi, htab_t map)\n-{\n-  int n = e->dest_idx == 0 ? 1 : 0;\n-  tree old_name = gimple_phi_arg_def (phi, n);\n-  tree new_name = get_new_name_from_old_name (map, old_name);\n-\n-  gcc_assert (gimple_phi_num_args (phi) == 2\n-\t      && gimple_phi_arg_edge (phi, e->dest_idx) == e);\n-\n-  SET_PHI_ARG_DEF (phi, n, new_name);\n-}\n-\n-/* Rename all the phi arguments for the edges comming from the scop\n-   according to the MAP.  */\n-\n-static void\n-rename_phis_end_scop (scop_p scop, htab_t map)\n-{\n-  basic_block after_scop = SCOP_EXIT (scop);\n-  edge e = SESE_EXIT (SCOP_REGION (scop));\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_phis (after_scop); !gsi_end_p (gsi); gsi_next (&gsi))\n-    rename_variables_from_edge (e, gsi_stmt (gsi), map);\n-}\n-\n /* Remove condition from BB.  */\n \n static void\n@@ -4144,7 +4226,7 @@ build_iv_mapping (loop_iv_stack ivstack, htab_t map, gbb_p gbb, scop_p scop)\n /* Register in MAP the tuple (old_name, new_name).  */\n \n static void\n-register_old_new_names (htab_t map, tree old_name, tree new_name)\n+register_old_and_new_names (htab_t map, tree old_name, tree new_name)\n {\n   struct rename_map_elt tmp;\n   PTR *slot;\n@@ -4193,11 +4275,32 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n \t{\n \t  tree old_name = DEF_FROM_PTR (def_p);\n \t  tree new_name = create_new_def_for (old_name, copy, def_p);\n-\t  register_old_new_names (map, old_name, new_name);\n+\t  register_old_and_new_names (map, old_name, new_name);\n \t}\n     }\n }\n \n+/* Records in SCOP_LIVEOUT_RENAMES the names that are live out of\n+   the SCOP and that appear in the RENAME_MAP.  */\n+\n+static void\n+register_scop_liveout_renames (scop_p scop, htab_t rename_map)\n+{\n+  int i;\n+  sese region = SCOP_REGION (scop);\n+\n+  for (i = 0; i < SESE_NUM_VER (region); i++)\n+    if (bitmap_bit_p (SESE_LIVEOUT (region), i)\n+\t&& is_gimple_reg (ssa_name (i)))\n+      {\n+\ttree old_name = ssa_name (i);\n+\ttree new_name = get_new_name_from_old_name (rename_map, old_name);\n+\n+\tregister_old_and_new_names (SCOP_LIVEOUT_RENAMES (scop),\n+\t\t\t\t    old_name, new_name);\n+      }\n+}\n+\n /* Copies BB and includes in the copied BB all the statements that can\n    be reached following the use-def chains from the memory accesses,\n    and returns the next edge following this new block.  */\n@@ -4215,15 +4318,153 @@ copy_bb_and_scalar_dependences (basic_block bb, scop_p scop,\n   rename_variables (new_bb, map);\n   remove_phi_nodes (new_bb);\n   expand_scalar_variables (new_bb, scop, context_loop, map);\n-  rename_phis_end_scop (scop, map);\n+  register_scop_liveout_renames (scop, map);\n \n   return next_e;\n }\n \n-/* Translates a CLAST statement STMT to GCC representation.  NEXT_E is\n-   the edge where new generated code should be attached.  BB_EXIT is the last\n-   basic block that defines the scope of code generation.  CONTEXT_LOOP is the\n-   loop in which the generated code will be placed (might be NULL).  */\n+/* Helper function for htab_traverse in insert_loop_close_phis.  */\n+\n+static int\n+add_loop_exit_phis (void **slot, void *s)\n+{\n+  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  tree new_name = entry->new_name;\n+  basic_block bb = (basic_block) s;\n+  gimple phi = create_phi_node (new_name, bb);\n+  tree res = create_new_def_for (gimple_phi_result (phi), phi,\n+\t\t\t\t gimple_phi_result_ptr (phi));\n+\n+  add_phi_arg (phi, new_name, single_pred_edge (bb));\n+\n+  entry->new_name = res;\n+  *slot = entry;\n+  return 1;\n+}\n+\n+/* Iterate over the SCOP_LIVEOUT_RENAMES (SCOP) and get tuples of the\n+   form (OLD_NAME, NEW_NAME).  Insert in BB \"RES = phi (NEW_NAME)\",\n+   and finally register in SCOP_LIVEOUT_RENAMES (scop) the tuple\n+   (OLD_NAME, RES).  */\n+\n+static void\n+insert_loop_close_phis (scop_p scop, basic_block bb)\n+{\n+  update_ssa (TODO_update_ssa);\n+  htab_traverse (SCOP_LIVEOUT_RENAMES (scop), add_loop_exit_phis, bb);\n+  update_ssa (TODO_update_ssa);\n+}\n+\n+/* Helper structure for htab_traverse in insert_guard_phis.  */\n+\n+struct igp {\n+  basic_block bb;\n+  edge true_edge, false_edge;\n+  htab_t liveout_before_guard;\n+};\n+\n+/* Return the default name that is before the guard.  */\n+\n+static tree\n+default_liveout_before_guard (htab_t liveout_before_guard, tree old_name)\n+{\n+  tree res = get_new_name_from_old_name (liveout_before_guard, old_name);\n+\n+  if (res == old_name)\n+    {\n+      if (is_gimple_reg (res))\n+\treturn fold_convert (TREE_TYPE (res), integer_zero_node);\n+      return gimple_default_def (cfun, res);\n+    }\n+\n+  return res;\n+}\n+\n+/* Helper function for htab_traverse in insert_guard_phis.  */\n+\n+static int\n+add_guard_exit_phis (void **slot, void *s)\n+{\n+  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  struct igp *i = (struct igp *) s;\n+  basic_block bb = i->bb;\n+  edge true_edge = i->true_edge;\n+  edge false_edge = i->false_edge;\n+  tree name1 = entry->new_name;\n+  tree name2 = default_liveout_before_guard (i->liveout_before_guard,\n+\t\t\t\t\t     entry->old_name);\n+  gimple phi = create_phi_node (name1, bb);\n+  tree res = create_new_def_for (gimple_phi_result (phi), phi,\n+\t\t\t\t gimple_phi_result_ptr (phi));\n+\n+  add_phi_arg (phi, name1, true_edge);\n+  add_phi_arg (phi, name2, false_edge);\n+\n+  entry->new_name = res;\n+  *slot = entry;\n+  return 1;\n+}\n+\n+/* Iterate over the SCOP_LIVEOUT_RENAMES (SCOP) and get tuples of the\n+   form (OLD_NAME, NAME1).  If there is a correspondent tuple of\n+   OLD_NAME in LIVEOUT_BEFORE_GUARD, i.e. (OLD_NAME, NAME2) then\n+   insert in BB\n+   \n+   | RES = phi (NAME1 (on TRUE_EDGE), NAME2 (on FALSE_EDGE))\"\n+\n+   if there is no tuple for OLD_NAME in LIVEOUT_BEFORE_GUARD, insert\n+\n+   | RES = phi (NAME1 (on TRUE_EDGE),\n+   |            DEFAULT_DEFINITION of NAME1 (on FALSE_EDGE))\".\n+\n+   Finally register in SCOP_LIVEOUT_RENAMES (scop) the tuple\n+   (OLD_NAME, RES).  */\n+\n+static void\n+insert_guard_phis (scop_p scop, basic_block bb, edge true_edge,\n+\t\t   edge false_edge, htab_t liveout_before_guard)\n+{\n+  struct igp i;\n+  i.bb = bb;\n+  i.true_edge = true_edge;\n+  i.false_edge = false_edge;\n+  i.liveout_before_guard = liveout_before_guard;\n+\n+  update_ssa (TODO_update_ssa);\n+  htab_traverse (SCOP_LIVEOUT_RENAMES (scop), add_guard_exit_phis, &i);\n+  update_ssa (TODO_update_ssa);\n+}\n+\n+/* Helper function for htab_traverse.  */\n+\n+static int\n+copy_renames (void **slot, void *s)\n+{\n+  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  htab_t res = (htab_t) s;\n+  tree old_name = entry->old_name;\n+  tree new_name = entry->new_name;\n+  struct rename_map_elt tmp;\n+  PTR *x;\n+\n+  tmp.old_name = old_name;\n+  x = htab_find_slot (res, &tmp, INSERT);\n+\n+  if (!*x)\n+    *x = new_rename_map_elt (old_name, new_name);\n+\n+  return 1;\n+}\n+\n+/* Translates a CLAST statement STMT to GCC representation in the\n+   context of a SCOP.\n+\n+   - NEXT_E is the edge where new generated code should be attached.\n+   - CONTEXT_LOOP is the loop in which the generated code will be placed\n+     (might be NULL).  \n+   - IVSTACK contains the surrounding loops around the statement to be\n+     translated.\n+*/\n \n static edge\n translate_clast (scop_p scop, struct loop *context_loop,\n@@ -4264,30 +4505,45 @@ translate_clast (scop_p scop, struct loop *context_loop,\n \t\t\t\t    ivstack, context_loop ? context_loop\n \t\t\t\t    : get_loop (0));\n       edge last_e = single_exit (loop);\n-\t\n+\n       next_e = translate_clast (scop, loop, ((struct clast_for *) stmt)->body,\n \t\t\t\tsingle_pred_edge (loop->latch), ivstack);\n       redirect_edge_succ_nodup (next_e, loop->latch);\n-\t\n+\n       set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n       loop_iv_stack_pop (ivstack);\n       last_e = single_succ_edge (split_edge (last_e));\n+      insert_loop_close_phis (scop, last_e->src);\n+\n       recompute_all_dominators ();\n       graphite_verify ();\n       return translate_clast (scop, context_loop, stmt->next, last_e, ivstack);\n     }\n \n   if (CLAST_STMT_IS_A (stmt, stmt_guard))\n     {\n+      htab_t liveout_before_guard = htab_create (10, rename_map_elt_info,\n+\t\t\t\t\t\t eq_rename_map_elts, free);\n       edge last_e = graphite_create_new_guard (scop, next_e,\n \t\t\t\t\t       ((struct clast_guard *) stmt),\n \t\t\t\t\t       ivstack);\n       edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n+      edge false_e = get_false_edge_from_guard_bb (next_e->dest);\n+      edge exit_true_e = single_succ_edge (true_e->dest);\n+      edge exit_false_e = single_succ_edge (false_e->dest);\n+\n+      htab_traverse (SCOP_LIVEOUT_RENAMES (scop), copy_renames,\n+\t\t     liveout_before_guard);\n+\n       next_e = translate_clast (scop, context_loop, \n \t\t\t\t((struct clast_guard *) stmt)->then,\n \t\t\t\ttrue_e, ivstack);\n+      insert_guard_phis (scop, last_e->src, exit_true_e, exit_false_e,\n+\t\t\t liveout_before_guard);\n+      htab_delete (liveout_before_guard);\n       recompute_all_dominators ();\n       graphite_verify ();\n+\n       return translate_clast (scop, context_loop, stmt->next, last_e, ivstack);\n     }\n \n@@ -4710,72 +4966,10 @@ move_sese_in_condition (sese region)\n   return if_region;\n }\n \n-/* Returns true when BB is in REGION.  */\n-\n-static bool\n-bb_in_sese_p (basic_block bb, sese region)\n-{\n-  return pointer_set_contains (SESE_REGION_BBS (region), bb);\n-}\n-\n-/* For USE in BB, if it is used outside of the REGION it is defined in,\n-   mark it for rewrite.  Record basic block BB where it is used\n-   to USE_BLOCKS.  Record the ssa name index to NEED_PHIS bitmap.  */\n-\n-static void\n-sese_find_uses_to_rename_use (sese region, basic_block bb, tree use,\n-\t\t\t      bitmap *use_blocks, bitmap need_phis)\n-{\n-  unsigned ver;\n-  basic_block def_bb;\n-\n-  if (TREE_CODE (use) != SSA_NAME)\n-    return;\n-\n-  ver = SSA_NAME_VERSION (use);\n-  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n-  if (!def_bb\n-      || !bb_in_sese_p (def_bb, region)\n-      || bb_in_sese_p (bb, region))\n-    return;\n-\n-  if (!use_blocks[ver])\n-    use_blocks[ver] = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (use_blocks[ver], bb->index);\n-\n-  bitmap_set_bit (need_phis, ver);\n-}\n-\n-/* Marks names that are used in BB and outside of the loop they are\n-   defined in for rewrite.  Records the set of blocks in that the ssa\n-   names are defined to USE_BLOCKS.  Record the SSA names that will\n-   need exit PHIs in NEED_PHIS.  */\n-\n-static void\n-sese_find_uses_to_rename_bb (sese region, basic_block bb,\n-\t\t\t     bitmap *use_blocks, bitmap need_phis)\n-{\n-  gimple_stmt_iterator bsi;\n-  edge e;\n-  edge_iterator ei;\n-  ssa_op_iter iter;\n-  tree var;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n-      sese_find_uses_to_rename_use (region, bb,\n-\t\t\t\t    PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e),\n-\t\t\t\t    use_blocks, need_phis);\n-\n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-    FOR_EACH_SSA_TREE_OPERAND (var, gsi_stmt (bsi), iter, SSA_OP_ALL_USES)\n-      sese_find_uses_to_rename_use (region, bb, var, use_blocks, need_phis);\n-}\n-\n /* Add exit phis for USE on EXIT.  */\n \n static void\n-sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n+scop_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n {\n   gimple phi = create_phi_node (use, exit);\n \n@@ -4786,10 +4980,10 @@ sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n }\n \n /* Add phi nodes for VAR that is used in LIVEIN.  Phi nodes are\n-   inserted in block WHERE.  */\n+   inserted in block BB.  */\n \n static void\n-sese_add_exit_phis_var (basic_block where, tree var, bitmap livein,\n+scop_add_exit_phis_var (basic_block bb, tree var, bitmap livein,\n \t\t\tedge false_e, edge true_e)\n {\n   bitmap def;\n@@ -4805,39 +4999,82 @@ sese_add_exit_phis_var (basic_block where, tree var, bitmap livein,\n   compute_global_livein (livein, def);\n   BITMAP_FREE (def);\n \n-  sese_add_exit_phis_edge (where, var, false_e, true_e);\n+  scop_add_exit_phis_edge (bb, var, false_e, true_e);\n }\n \n-/* Insert in the block WHERE phi nodes for variables defined in REGION\n-   and used outside the REGION.  */\n+/* Insert in the block BB phi nodes for variables defined in REGION\n+   and used outside the REGION.  The code generation moves REGION in\n+   the else clause of an \"if (1)\" and generates code in the then\n+   clause that is at this point empty:\n+\n+   | if (1)\n+   |   empty;\n+   | else\n+   |   REGION;\n+*/\n \n static void\n-rewrite_into_sese_closed_ssa (sese region, basic_block where,\n-\t\t\t      edge false_e, edge true_e)\n+scop_insert_phis_for_liveouts (sese region, basic_block bb,\n+\t\t\t       edge false_e, edge true_e)\n {\n   unsigned i;\n-  basic_block bb;\n   bitmap_iterator bi;\n-  bitmap names_to_rename = BITMAP_ALLOC (NULL);\n-  unsigned old_num_ssa_names = num_ssa_names;\n-  bitmap *use_blocks = XCNEWVEC (bitmap, old_num_ssa_names);\n \n   update_ssa (TODO_update_ssa);\n \n-  FOR_EACH_BB (bb)\n-    sese_find_uses_to_rename_bb (region, bb, use_blocks, names_to_rename);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n-    sese_add_exit_phis_var (where, ssa_name (i), use_blocks[i],\n+  EXECUTE_IF_SET_IN_BITMAP (SESE_LIVEOUT (region), 0, i, bi)\n+    scop_add_exit_phis_var (bb, ssa_name (i), SESE_LIVEIN_VER (region, i),\n \t\t\t    false_e, true_e);\n \n   update_ssa (TODO_update_ssa);\n+}\n \n-  for (i = 0; i < old_num_ssa_names; i++)\n-    BITMAP_FREE (use_blocks[i]);\n+/* Adjusts the phi nodes in the block BB for variables defined in\n+   SCOP_REGION and used outside the SCOP_REGION.  The code generation\n+   moves SCOP_REGION in the else clause of an \"if (1)\" and generates\n+   code in the then clause:\n \n-  free (use_blocks);\n-  BITMAP_FREE (names_to_rename);\n+   | if (1)\n+   |   generated code from REGION;\n+   | else\n+   |   REGION;\n+\n+   To adjust the phi nodes after the condition, SCOP_LIVEOUT_RENAMES\n+   hash table is used: this stores for a name that is part of the\n+   LIVEOUT of SCOP_REGION its new name in the generated code.  */\n+\n+static void\n+scop_adjust_phis_for_liveouts (scop_p scop, basic_block bb, edge false_e,\n+\t\t\t       edge true_e)\n+{\n+  gimple_stmt_iterator si;\n+\n+  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      unsigned i, false_i;\n+      gimple phi = gsi_stmt (si);\n+\n+      if (!is_gimple_reg (PHI_RESULT (phi)))\n+\tcontinue;\n+\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\tif (gimple_phi_arg_edge (phi, i) == false_e)\n+\t  {\n+\t    false_i = i;\n+\t    break;\n+\t  }\n+\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\tif (gimple_phi_arg_edge (phi, i) == true_e)\n+\t  {\n+\t    tree old_name = gimple_phi_arg_def (phi, false_i);\n+\t    tree new_name = get_new_name_from_old_name\n+\t      (SCOP_LIVEOUT_RENAMES (scop), old_name);\n+\n+\t    gcc_assert (old_name != new_name);\n+\t    SET_PHI_ARG_DEF (phi, i, new_name);\n+\t  }\n+    }\n }\n \n /* Returns the first cloog name used in EXPR.  */\n@@ -4976,24 +5213,33 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n     }\n \n   if_region = move_sese_in_condition (SCOP_REGION (scop));\n-  rewrite_into_sese_closed_ssa (SCOP_REGION (scop),\n-\t\t\t\tif_region->region->exit->src,\n-\t\t\t\tif_region->false_region->exit,\n-\t\t\t\tif_region->true_region->exit);\n+  sese_build_livein_liveouts (SCOP_REGION (scop));\n+  scop_insert_phis_for_liveouts (SCOP_REGION (scop),\n+\t\t\t\t if_region->region->exit->src,\n+\t\t\t\t if_region->false_region->exit,\n+\t\t\t\t if_region->true_region->exit);\n   recompute_all_dominators ();\n   graphite_verify ();\n   context_loop = SESE_ENTRY (SCOP_REGION (scop))->src->loop_father;\n   compute_cloog_iv_types (stmt);\n-  new_scop_exit_edge = translate_clast (scop, context_loop,\n-\t\t\t\t\tstmt, if_region->true_region->entry,\n+\n+  new_scop_exit_edge = translate_clast (scop, context_loop, stmt,\n+\t\t\t\t\tif_region->true_region->entry,\n \t\t\t\t\t&ivstack);\n+  free_loop_iv_stack (&ivstack);\n+  cloog_clast_free (stmt);\n+\n+  graphite_verify ();\n+  scop_adjust_phis_for_liveouts (scop,\n+\t\t\t\t if_region->region->exit->src,\n+\t\t\t\t if_region->false_region->exit,\n+\t\t\t\t if_region->true_region->exit);\n+\n   recompute_all_dominators ();\n   graphite_verify ();\n   cleanup_tree_cfg ();\n   recompute_all_dominators ();\n   graphite_verify ();\n-  free_loop_iv_stack (&ivstack);\n-  cloog_clast_free (stmt);\n }\n \n /* Returns the number of data references in SCOP.  */"}, {"sha": "76f26c8728a1b1f9f85ef1a4f9e895f3e4f69111", "filename": "gcc/graphite.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b10257fdddb77e1854f223fc38c7d695fb8ebb4/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=7b10257fdddb77e1854f223fc38c7d695fb8ebb4", "patch": "@@ -275,13 +275,36 @@ DEF_VEC_ALLOC_P (name_tree, heap);\n    by two edges.  */\n typedef struct sese\n {\n+  /* Single ENTRY and single EXIT from the SESE region.  */\n   edge entry, exit;\n+\n+  /* REGION_BASIC_BLOCKS contains the set of all the basic blocks\n+     belonging to the SESE region.  */\n   struct pointer_set_t *region_basic_blocks;\n+\n+  /* An SSA_NAME version is flagged in the LIVEOUT bitmap if the\n+     SSA_NAME is defined inside and used outside the SESE region.  */\n+  bitmap liveout;\n+\n+  /* The overall number of SSA_NAME versions used to index LIVEIN.  */\n+  int num_ver;\n+\n+  /* For each SSA_NAME version VER in LIVEOUT, LIVEIN[VER] contains\n+     the set of basic blocks indices that contain a use of VER.  */\n+  bitmap *livein;\n } *sese;\n \n #define SESE_ENTRY(S) (S->entry)\n #define SESE_EXIT(S) (S->exit)\n #define SESE_REGION_BBS(S) (S->region_basic_blocks)\n+#define SESE_LIVEOUT(S) (S->liveout)\n+#define SESE_LIVEIN(S) (S->livein)\n+#define SESE_LIVEIN_VER(S, I) (S->livein[I])\n+#define SESE_NUM_VER(S) (S->num_ver)\n+\n+extern sese new_sese (edge, edge);\n+extern void free_sese (sese);\n+extern void sese_build_livein_liveouts (sese);\n \n /* A SCOP is a Static Control Part of the program, simple enough to be\n    represented in polyhedral form.  */\n@@ -319,6 +342,10 @@ struct scop\n      can only add new params before generating the bb domains, otherwise they\n      become invalid.  */\n   bool add_params;\n+\n+  /* LIVEOUT_RENAMES registers the rename mapping that has to be\n+     applied after code generation.  */\n+  htab_t liveout_renames;\n };\n \n #define SCOP_BBS(S) S->bbs\n@@ -341,6 +368,7 @@ struct scop\n #define SCOP_PROG(S) S->program\n #define SCOP_LOOP2CLOOG_LOOP(S) S->loop2cloog_loop\n #define SCOP_LOOPS_MAPPING(S) S->loops_mapping\n+#define SCOP_LIVEOUT_RENAMES(S) S->liveout_renames\n \n extern void debug_scop (scop_p, int);\n extern void debug_scops (int);"}]}