{"sha": "29de0a5c2f01ef2036a4b47ccecb26189748a606", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkZTBhNWMyZjAxZWYyMDM2YTRiNDdjY2VjYjI2MTg5NzQ4YTYwNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-05-19T16:22:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-05-19T16:22:07Z"}, "message": "Add prototypes for all static functions.\n\n(adspath): Delete; never used and has numerous parse errors.\n\nFrom-SVN: r12042", "tree": {"sha": "8f3f5901cb443ee68636cc5cbbe4dda8a522f4a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f3f5901cb443ee68636cc5cbbe4dda8a522f4a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29de0a5c2f01ef2036a4b47ccecb26189748a606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29de0a5c2f01ef2036a4b47ccecb26189748a606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29de0a5c2f01ef2036a4b47ccecb26189748a606", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29de0a5c2f01ef2036a4b47ccecb26189748a606/comments", "author": null, "committer": null, "parents": [{"sha": "b423779d2d40eb0603d8b0b09cf8a5f068efaf49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b423779d2d40eb0603d8b0b09cf8a5f068efaf49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b423779d2d40eb0603d8b0b09cf8a5f068efaf49"}], "stats": {"total": 135, "additions": 20, "deletions": 115}, "files": [{"sha": "caee999b57ae9ab38f537f40f21c1f6470f7b499", "filename": "gcc/dbxout.c", "status": "modified", "additions": 20, "deletions": 115, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29de0a5c2f01ef2036a4b47ccecb26189748a606/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29de0a5c2f01ef2036a4b47ccecb26189748a606/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=29de0a5c2f01ef2036a4b47ccecb26189748a606", "patch": "@@ -154,6 +154,8 @@ static int have_used_extensions = 0;\n \n static int source_label_number = 1;\n \n+static int scope_labelno = 0;\n+\n char *getpwd ();\n \n /* Typical USG systems don't have stab.h, and they also have\n@@ -322,123 +324,26 @@ static int current_sym_nchars;\n void dbxout_types ();\n void dbxout_args ();\n void dbxout_symbol ();\n-static void dbxout_type_name ();\n-static void dbxout_type ();\n-static void dbxout_typedefs ();\n-static void dbxout_symbol_name ();\n-static void dbxout_symbol_location ();\n-static void dbxout_prepare_symbol ();\n-static void dbxout_finish_symbol ();\n-static void dbxout_type_index ();\n-static void dbxout_continue ();\n-static void print_int_cst_octal ();\n-static void print_octal ();\n-\f\n-#if 0 /* Not clear we will actually need this.  */\n-\n-/* Return the absolutized filename for the given relative\n-   filename.  Note that if that filename is already absolute, it may\n-   still be returned in a modified form because this routine also\n-   eliminates redundant slashes and single dots and eliminates double\n-   dots to get a shortest possible filename from the given input\n-   filename.  The absolutization of relative filenames is made by\n-   assuming that the given filename is to be taken as relative to\n-   the first argument (cwd) or to the current directory if cwd is\n-   NULL.  */\n-\n-static char *\n-abspath (rel_filename)\n-     char *rel_filename;\n-{\n-  /* Setup the current working directory as needed.  */\n-  char *abs_buffer\n-    = (char *) alloca (strlen (cwd) + strlen (rel_filename) + 1);\n-  char *endp = abs_buffer;\n-  char *outp, *inp;\n-  char *value;\n-\n-  /* Copy the filename (possibly preceded by the current working\n-     directory name) into the absolutization buffer.  */\n \n-  {\n-    char *src_p;\n-\n-    if (rel_filename[0] != '/')\n-      {\n-        src_p = cwd;\n-        while (*endp++ = *src_p++)\n-          continue;\n-        *(endp-1) = '/';        \t\t/* overwrite null */\n-      }\n-    src_p = rel_filename;\n-    while (*endp++ = *src_p++)\n-      continue;\n-    if (endp[-1] == '/')\n-      *endp = '\\0';\n-\n-  /* Now make a copy of abs_buffer into abs_buffer, shortening the\n-     filename (by taking out slashes and dots) as we go.  */\n-\n-  outp = inp = abs_buffer;\n-  *outp++ = *inp++;        \t/* copy first slash */\n-  for (;;)\n-    {\n-      if (!inp[0])\n-        break;\n-      else if (inp[0] == '/' && outp[-1] == '/')\n-        {\n-          inp++;\n-          continue;\n-        }\n-      else if (inp[0] == '.' && outp[-1] == '/')\n-        {\n-          if (!inp[1])\n-                  break;\n-          else if (inp[1] == '/')\n-            {\n-                    inp += 2;\n-                    continue;\n-            }\n-          else if ((inp[1] == '.') && (inp[2] == 0 || inp[2] == '/'))\n-            {\n-                    inp += (inp[2] == '/') ? 3 : 2;\n-                    outp -= 2;\n-                    while (outp >= abs_buffer && *outp != '/')\n-              \toutp--;\n-                    if (outp < abs_buffer)\n-                {\n-                  /* Catch cases like /.. where we try to backup to a\n-                     point above the absolute root of the logical file\n-                     system.  */\n-\n-              \t  fprintf (stderr, \"%s: invalid file name: %s\\n\",\n-\t\t\t   pname, rel_filename);\n-              \t  exit (1);\n-              \t}\n-                    *++outp = '\\0';\n-                    continue;\n-            }\n-        }\n-      *outp++ = *inp++;\n-    }\n-\n-  /* On exit, make sure that there is a trailing null, and make sure that\n-     the last character of the returned string is *not* a slash.  */\n-\n-  *outp = '\\0';\n-  if (outp[-1] == '/')\n-    *--outp  = '\\0';\n-\n-  /* Make a copy (in the heap) of the stuff left in the absolutization\n-     buffer and return a pointer to the copy.  */\n-\n-  value = (char *) oballoc (strlen (abs_buffer) + 1);\n-  strcpy (value, abs_buffer);\n-  return value;\n-}\n-#endif /* 0 */\n+static void dbxout_function_end\t\tPROTO((void));\n+static void dbxout_typedefs\t\tPROTO((tree));\n+static void dbxout_type_index\t\tPROTO((tree));\n+static void dbxout_continue\t\tPROTO((void));\n+static void dbxout_type_fields\t\tPROTO((tree));\n+static void dbxout_type_method_1\tPROTO((tree, char *));\n+static void dbxout_type_methods\t\tPROTO((tree));\n+static void dbxout_range_type\t\tPROTO((tree));\n+static void dbxout_type\t\t\tPROTO((tree, int, int));\n+static void print_int_cst_octal\t\tPROTO((tree));\n+static void print_octal\t\t\tPROTO((unsigned HOST_WIDE_INT, int));\n+static void dbxout_type_name\t\tPROTO((tree));\n+static void dbxout_symbol_location\tPROTO((tree, tree, char *, rtx));\n+static void dbxout_symbol_name\t\tPROTO((tree, char *, int));\n+static void dbxout_prepare_symbol\tPROTO((tree));\n+static void dbxout_finish_symbol\tPROTO((tree));\n+static void dbxout_block\t\tPROTO((tree, int, tree));\n+static void dbxout_really_begin_function PROTO((tree));\n \f\n-static int scope_labelno = 0;\n static void\n dbxout_function_end ()\n {"}]}