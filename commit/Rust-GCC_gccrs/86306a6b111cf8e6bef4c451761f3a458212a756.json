{"sha": "86306a6b111cf8e6bef4c451761f3a458212a756", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYzMDZhNmIxMTFjZjhlNmJlZjRjNDUxNzYxZjNhNDU4MjEyYTc1Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-08-10T14:54:22Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-08-10T14:54:22Z"}, "message": "re PR c++/10530 (Cannot access non-dependent type within nested template)\n\ncp:\n\tPR c++/10530\n\t* pt.c (dependent_type_p_r): A dependent template-id is a class\n\ttype with dependent template arguments, or a bound template\n\ttemplate parameter.\n\t(type_dependent_expression_p): A template function decl cannot\n\thave a dependent context.\ntestsuite:\n\tPR c++/10530\n\t* g++.dg/template/dependent-name2.C: New test.\n\nFrom-SVN: r70293", "tree": {"sha": "ebbe19ab3f32b618c056e966ef2359cd6a508112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebbe19ab3f32b618c056e966ef2359cd6a508112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86306a6b111cf8e6bef4c451761f3a458212a756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86306a6b111cf8e6bef4c451761f3a458212a756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86306a6b111cf8e6bef4c451761f3a458212a756", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86306a6b111cf8e6bef4c451761f3a458212a756/comments", "author": null, "committer": null, "parents": [{"sha": "3372178cc3d73aeedb6afbd02871ce6cd6aea0af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3372178cc3d73aeedb6afbd02871ce6cd6aea0af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3372178cc3d73aeedb6afbd02871ce6cd6aea0af"}], "stats": {"total": 63, "additions": 49, "deletions": 14}, "files": [{"sha": "4db8e19ede84e357c1309e297f01685757849136", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=86306a6b111cf8e6bef4c451761f3a458212a756", "patch": "@@ -1,3 +1,12 @@\n+2003-08-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/10530\n+\t* pt.c (dependent_type_p_r): A dependent template-id is a class\n+\ttype with dependent template arguments, or a bound template\n+\ttemplate parameter.\n+\t(type_dependent_expression_p): A template function decl cannot\n+\thave a dependent context.\n+\n 2003-08-07  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/5767"}, {"sha": "a4e55c0330da7c3968a163a81a8bfb1d93d344fb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=86306a6b111cf8e6bef4c451761f3a458212a756", "patch": "@@ -11348,25 +11348,23 @@ dependent_type_p_r (tree type)\n \treturn true;\n       return dependent_type_p (TREE_TYPE (type));\n     }\n+  \n   /* -- a template-id in which either the template name is a template\n-        parameter or any of the template arguments is a dependent type or\n-\tan expression that is type-dependent or value-dependent.  \n-\n-     This language seems somewhat confused; for example, it does not\n-     discuss template template arguments.  Therefore, we use the\n-     definition for dependent template arguments in [temp.dep.temp].  */\n-  if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n-      && (dependent_template_id_p\n-\t  (CLASSTYPE_TI_TEMPLATE (type),\n-\t   CLASSTYPE_TI_ARGS (type))))\n+     parameter ...  */\n+  if (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     return true;\n-  else if (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+  /* ... or any of the template arguments is a dependent type or\n+\tan expression that is type-dependent or value-dependent.   */\n+  else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n+      && any_dependent_template_arguments_p (CLASSTYPE_TI_ARGS (type)))\n     return true;\n+  \n   /* All TYPEOF_TYPEs are dependent; if the argument of the `typeof'\n      expression is not type-dependent, then it should already been\n      have resolved.  */\n   if (TREE_CODE (type) == TYPEOF_TYPE)\n     return true;\n+  \n   /* The standard does not specifically mention types that are local\n      to template functions or local classes, but they should be\n      considered dependent too.  For example:\n@@ -11616,9 +11614,8 @@ type_dependent_expression_p (tree expression)\n   if (TREE_CODE (expression) == FUNCTION_DECL\n       && DECL_LANG_SPECIFIC (expression)\n       && DECL_TEMPLATE_INFO (expression)\n-      && (dependent_template_id_p\n-\t  (DECL_TI_TEMPLATE (expression),\n-\t   INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n+      && (any_dependent_template_arguments_p\n+\t  (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n     return true;\n \n   if (TREE_TYPE (expression) == unknown_type_node)"}, {"sha": "34e5185272b7831ed97b0d246373f10b4636b151", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86306a6b111cf8e6bef4c451761f3a458212a756", "patch": "@@ -1,3 +1,8 @@\n+2003-08-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/10530\n+\t* g++.dg/template/dependent-name2.C: New test.\n+\n 2003-08-08  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* g++.dg/parse/crash11.C: Put the dg options in comments."}, {"sha": "611d5f9c8d95dc0a34b4b48e32bd96664dcb83af", "filename": "gcc/testsuite/g++.dg/template/dependent-name2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86306a6b111cf8e6bef4c451761f3a458212a756/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name2.C?ref=86306a6b111cf8e6bef4c451761f3a458212a756", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 1 Aug 2003 <nathan@codesourcery.com>\n+\n+// PR 10530. Thought a type was dependent.\n+\n+template <typename T>\n+struct Foo {\n+  struct Inner {\n+    typedef int type;\n+  };\n+};\n+\n+template <typename A> struct Bar {\n+  typedef typename Foo<int>::Inner::type type;\n+};\n+\n+template <template <typename T> class TPL> void Foo ()\n+{\n+  TPL<int> x;\n+\n+  f (x);\n+}"}]}