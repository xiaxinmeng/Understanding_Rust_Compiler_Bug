{"sha": "436d9f924cf07f4901d701999f4f19138bd5e917", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM2ZDlmOTI0Y2YwN2Y0OTAxZDcwMTk5OWY0ZjE5MTM4YmQ1ZTkxNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T10:11:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T10:11:20Z"}, "message": "[multiple changes]\n\n2012-11-06  Tristan Gingold  <gingold@adacore.com>\n\n\t* fe.h (Get_Vax_Real_Literal_As_Signed): Declare.\n\t* eval_fat.adb, eval_fat.ads (Decompose_Int): Move spec in package spec.\n\t* exp_vfpt.adb, exp_vfpt.ads (Vax_Real_Literal_As_Signed): New function.\n\t(Expand_Vax_Real_Literal): Remove.\n\t* exp_ch2.adb (Expand_N_Real_Literal): Do nothing.\n\t* sem_eval.adb (Expr_Value_R): Remove special Vax float case,\n\tas this is not anymore a special case.\n\n2012-11-06  Yannick Moy  <moy@adacore.com>\n\n\t* uintp.ads: Minor correction of typo in comment.\n\n2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragnma, case Unchecked_Union): remove\n\trequirement that discriminants of an unchecked_union must have\n\tdefaults.\n\n2012-11-06  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* projects.texi: Minor wordsmithing.\n\nFrom-SVN: r193224", "tree": {"sha": "cb0cadf761ed3e11307dea97c80ddd8c0bda71e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb0cadf761ed3e11307dea97c80ddd8c0bda71e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/436d9f924cf07f4901d701999f4f19138bd5e917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436d9f924cf07f4901d701999f4f19138bd5e917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/436d9f924cf07f4901d701999f4f19138bd5e917", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/436d9f924cf07f4901d701999f4f19138bd5e917/comments", "author": null, "committer": null, "parents": [{"sha": "a9b9fbf664de2ab613586fa8795e4decb774393a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b9fbf664de2ab613586fa8795e4decb774393a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9b9fbf664de2ab613586fa8795e4decb774393a"}], "stats": {"total": 270, "additions": 141, "deletions": 129}, "files": [{"sha": "a08aa1464c148b3ddeb97711946e1c9f0e046cf6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -1,3 +1,27 @@\n+2012-11-06  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* fe.h (Get_Vax_Real_Literal_As_Signed): Declare.\n+\t* eval_fat.adb, eval_fat.ads (Decompose_Int): Move spec in package spec.\n+\t* exp_vfpt.adb, exp_vfpt.ads (Vax_Real_Literal_As_Signed): New function.\n+\t(Expand_Vax_Real_Literal): Remove.\n+\t* exp_ch2.adb (Expand_N_Real_Literal): Do nothing.\n+\t* sem_eval.adb (Expr_Value_R): Remove special Vax float case,\n+\tas this is not anymore a special case.\n+\n+2012-11-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* uintp.ads: Minor correction of typo in comment.\n+\n+2012-11-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragnma, case Unchecked_Union): remove\n+\trequirement that discriminants of an unchecked_union must have\n+\tdefaults.\n+\n+2012-11-06  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* projects.texi: Minor wordsmithing.\n+\n 2012-11-06  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch9.adb, exp_vfpt.adb, xoscons.adb: Minor reformatting."}, {"sha": "5ff748dfbe71bda67525c6eb4c6086541b40c300", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -57,20 +57,6 @@ package body Eval_Fat is\n    --  parts. The fraction is in the interval 1.0 / Radix .. T'Pred (1.0) and\n    --  uses Rbase = Radix. The result is rounded to a nearest machine number.\n \n-   procedure Decompose_Int\n-     (RT       : R;\n-      X        : T;\n-      Fraction : out UI;\n-      Exponent : out UI;\n-      Mode     : Rounding_Mode);\n-   --  This is similar to Decompose, except that the Fraction value returned\n-   --  is an integer representing the value Fraction * Scale, where Scale is\n-   --  the value (Machine_Radix_Value (RT) ** Machine_Mantissa_Value (RT)). The\n-   --  value is obtained by using biased rounding (halfway cases round away\n-   --  from zero), round to even, a floor operation or a ceiling operation\n-   --  depending on the setting of Mode (see corresponding descriptions in\n-   --  Urealp).\n-\n    --------------\n    -- Adjacent --\n    --------------"}, {"sha": "4ef153ced77db0b31c9a1a3f32b95a01dc8fad5e", "filename": "gcc/ada/eval_fat.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Feval_fat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Feval_fat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.ads?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -99,4 +99,18 @@ package Eval_Fat is\n       Mode  : Rounding_Mode;\n       Enode : Node_Id) return T;\n \n+   procedure Decompose_Int\n+     (RT       : R;\n+      X        : T;\n+      Fraction : out UI;\n+      Exponent : out UI;\n+      Mode     : Rounding_Mode);\n+   --  Decomposes a floating-point number into fraction and exponent parts.\n+   --  The Fraction value returned is an integer representing the value\n+   --  Fraction * Scale, where Scale is the value (Machine_Radix_Value (RT) **\n+   --  Machine_Mantissa_Value (RT)). The value is obtained by using biased\n+   --  rounding (halfway cases round away from zero), round to even, a floor\n+   --  operation or a ceiling operation depending on the setting of Mode (see\n+   --  corresponding descriptions in Urealp).\n+\n end Eval_Fat;"}, {"sha": "bbd23ba0fdc8bf630aa7b0314db890919a136281", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -32,7 +32,6 @@ with Errout;   use Errout;\n with Exp_Smem; use Exp_Smem;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Exp_VFpt; use Exp_VFpt;\n with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -637,9 +636,8 @@ package body Exp_Ch2 is\n \n    procedure Expand_N_Real_Literal (N : Node_Id) is\n    begin\n-      if Vax_Float (Etype (N)) then\n-         Expand_Vax_Real_Literal (N);\n-      end if;\n+      --  Vax real literal are now allowed by gigi\n+      null;\n    end Expand_N_Real_Literal;\n \n    --------------------------------"}, {"sha": "af4c3ef4d823d63602029e2b3b7d399180ae57bc", "filename": "gcc/ada/exp_vfpt.adb", "status": "modified", "additions": 79, "deletions": 67, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fexp_vfpt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fexp_vfpt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_vfpt.adb?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -32,8 +32,8 @@ with Sem_Res;  use Sem_Res;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n-with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n+with Eval_Fat; use Eval_Fat;\n \n package body Exp_VFpt is\n \n@@ -76,9 +76,13 @@ package body Exp_VFpt is\n    --  +--------------------------------+\n    --  |             fraction           |  A + 4\n    --  +--------------------------------+\n-   --  |             fraction           |  A + 6\n+   --  |             fraction (low)     |  A + 6\n    --  +--------------------------------+\n \n+   --  Note that the fraction bits are not continuous in memory. Bytes in a\n+   --  words are stored using little endianness, but words are stored using\n+   --  big endianness (PDP endian)\n+\n    --  Like Float F but with 55 bits for the fraction.\n \n    --  Float G:\n@@ -93,10 +97,10 @@ package body Exp_VFpt is\n    --  +--------------------------------+\n    --  |             fraction           |  A + 4\n    --  +--------------------------------+\n-   --  |             fraction           |  A + 6\n+   --  |             fraction (low)     |  A + 6\n    --  +--------------------------------+\n \n-   --  Exponent values of 1 through 2047 indicate trye binary exponents of\n+   --  Exponent values of 1 through 2047 indicate true binary exponents of\n    --  -1023 to +1023.\n \n    --  Main differences compared to IEEE 754:\n@@ -553,93 +557,101 @@ package body Exp_VFpt is\n       Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n    end Expand_Vax_Foreign_Return;\n \n-   -----------------------------\n-   -- Expand_Vax_Real_Literal --\n-   -----------------------------\n+   --------------------------------\n+   -- Vax_Real_Literal_As_Signed --\n+   --------------------------------\n \n-   procedure Expand_Vax_Real_Literal (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Typ  : constant Entity_Id  := Etype (N);\n-      Btyp : constant Entity_Id  := Base_Type (Typ);\n-      Stat : constant Boolean    := Is_Static_Expression (N);\n-      Nod  : Node_Id;\n+   function Get_Vax_Real_Literal_As_Signed (N : Node_Id) return Uint is\n+      Btyp     : constant Entity_Id :=\n+                   Base_Type (Underlying_Type (Etype (N)));\n+\n+      Value    : constant Ureal := Realval (N);\n+      Negative : Boolean;\n+      Fraction : UI;\n+      Exponent : UI;\n+      Res      : UI;\n+\n+      Exponent_Size : Uint;\n+      --  Number of bits for the exponent\n \n-      RE_Source : RE_Id;\n-      RE_Target : RE_Id;\n-      RE_Fncall : RE_Id;\n-      --  Entities for source, target and function call in conversion\n+      Fraction_Size : Uint;\n+      --  Number of bits for the fraction\n \n+      Uintp_Mark : constant Uintp.Save_Mark := Mark;\n+      --  Use the mark & release feature to delete temporaries\n    begin\n-      --  We do not know how to convert Vax format real literals, so what\n-      --  we do is to convert these to be IEEE literals, and introduce the\n-      --  necessary conversion operation.\n+      --  Extract the sign now\n \n-      if Vax_Float (Btyp) then\n-         --  What we want to construct here is\n+      Negative := UR_Is_Negative (Value);\n \n-         --    x!(y_to_z (1.0E0))\n+      --  Decompose the number\n \n-         --  where\n+      Decompose_Int (Btyp, abs Value, Fraction, Exponent, Round_Even);\n \n-         --    x is the base type of the literal (Btyp)\n+      --  Number of bits for the fraction, leading fraction bit is implicit\n \n-         --    y_to_z is\n+      Fraction_Size := Machine_Mantissa_Value (Btyp) - Int'(1);\n \n-         --      s_to_f for F_Float\n-         --      t_to_g for G_Float\n-         --      t_to_d for D_Float\n+      --  Number of bits for the exponent (one bit for the sign)\n \n-         --  The literal is typed as S (for F_Float) or T otherwise\n+      Exponent_Size := RM_Size (Btyp) - Fraction_Size - Int'(1);\n \n-         --  We do all our own construction, analysis, and expansion here,\n-         --  since things are at too low a level to use Analyze or Expand\n-         --  to get this built (we get circularities and other strange\n-         --  problems if we try!)\n+      if Fraction = Uint_0 then\n+         --  Handle zero\n \n-         if Digits_Value (Btyp) = VAXFF_Digits then\n-            RE_Source := RE_S;\n-            RE_Target := RE_F;\n-            RE_Fncall := RE_S_To_F;\n+         Res := Uint_0;\n \n-         elsif Digits_Value (Btyp) = VAXDF_Digits then\n-            RE_Source := RE_T;\n-            RE_Target := RE_D;\n-            RE_Fncall := RE_T_To_D;\n+      elsif Exponent <= -(Uint_2 ** (Exponent_Size - 1)) then\n+         --  Underflow\n \n-         else pragma Assert (Digits_Value (Btyp) = VAXGF_Digits);\n-            RE_Source := RE_T;\n-            RE_Target := RE_G;\n-            RE_Fncall := RE_T_To_G;\n-         end if;\n+         Res := Uint_0;\n+      else\n+         --  Check for overflow\n \n-         Nod := Relocate_Node (N);\n+         pragma Assert (Exponent < Uint_2 ** (Exponent_Size - 1));\n \n-         Set_Etype (Nod, RTE (RE_Source));\n-         Set_Analyzed (Nod, True);\n+         --  MSB of the fraction must be 1\n \n-         Nod :=\n-           Make_Function_Call (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Fncall), Loc),\n-             Parameter_Associations => New_List (Nod));\n+         pragma Assert (Fraction / Uint_2 ** Fraction_Size = Uint_1);\n \n-         Set_Etype (Nod, RTE (RE_Target));\n-         Set_Analyzed (Nod, True);\n+         --  Remove the redudant most significant fraction bit\n \n-         Nod :=\n-           Make_Unchecked_Type_Conversion (Loc,\n-             Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n-             Expression   => Nod);\n+         Fraction := Fraction - Uint_2 ** Fraction_Size;\n \n-         Set_Etype (Nod, Typ);\n-         Set_Analyzed (Nod, True);\n-         Rewrite (N, Nod);\n+         --  Build the fraction part. Note that this field is in mixed\n+         --  endianness: words are stored using little endianness, while bytes\n+         --  in words are stored using big endianness.\n \n-         --  This odd expression is still a static expression. Note that\n-         --  the routine Sem_Eval.Expr_Value_R understands this.\n+         Res := Uint_0;\n+         for I in 1 .. UI_To_Int (RM_Size (Btyp)) / 16 loop\n+            Res := (Res * (Uint_2 ** 16)) + (Fraction mod (Uint_2 ** 16));\n+            Fraction := Fraction / (Uint_2 ** 16);\n+         end loop;\n \n-         Set_Is_Static_Expression (N, Stat);\n+         --  The sign bit\n+\n+         if Negative then\n+            Res := Res + Int (2**15);\n+         end if;\n+\n+         --  The exponent\n+\n+         Res := Res + (Exponent + Uint_2 ** (Exponent_Size - 1))\n+           * Uint_2 ** (15 - Exponent_Size);\n+\n+         --  Until now, we have created an unsigned number, but an underlying\n+         --  type is a signed type. Convert to a signed number to avoid\n+         --  overflow in gigi.\n+\n+         if Res >= Uint_2 ** (Exponent_Size + Fraction_Size) then\n+            Res := Res - Uint_2 ** (Exponent_Size + Fraction_Size + 1);\n+         end if;\n       end if;\n-   end Expand_Vax_Real_Literal;\n+\n+      Release_And_Save (Uintp_Mark, Res);\n+\n+      return Res;\n+   end Get_Vax_Real_Literal_As_Signed;\n \n    ----------------------\n    -- Expand_Vax_Valid --"}, {"sha": "52aaf7dd3f341257cdca24cc5c9bd3ced0625b9c", "filename": "gcc/ada/exp_vfpt.ads", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fexp_vfpt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fexp_vfpt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_vfpt.ads?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,7 @@\n --  point formats as used on the Vax and the Alpha and the ia64.\n \n with Types; use Types;\n+with Uintp; use Uintp;\n \n package Exp_VFpt is\n \n@@ -51,10 +52,12 @@ package Exp_VFpt is\n    --  that moves the return value to an integer location on Alpha/VMS,\n    --  noop everywhere else.\n \n-   procedure Expand_Vax_Real_Literal (N : Node_Id);\n-   --  The node N is a real literal node where the type is a Vax floating-point\n-   --  type. This procedure rewrites the node to eliminate the occurrence of\n-   --  such constants.\n+   function Get_Vax_Real_Literal_As_Signed (N : Node_Id) return Uint;\n+   --  Get the Vax binary representation of a real literal whose type is a Vax\n+   --  floating-point type. This is used by gigi. Previously we expanded\n+   --  real literal to a call to a LIB$OTS routine that performed the\n+   --  conversion. This worked well, but was not efficient and generated huge\n+   --  functions for aggregate initialization.\n \n    procedure Expand_Vax_Valid (N : Node_Id);\n    --  The node N is an attribute reference node for the Valid attribute where"}, {"sha": "f8d399c965cfbe84d3180061017fbd2d5927f308", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -156,6 +156,11 @@ extern void Get_External_Name_With_Suffix\t(Entity_Id, Fat_Pointer);\n \n extern Boolean Is_Fully_Repped_Tagged_Type      (Entity_Id);\n \n+/* exp_vfpt: */\n+\n+#define Get_Vax_Real_Literal_As_Signed exp_vfpt__get_vax_real_literal_as_signed\n+extern Ureal Get_Vax_Real_Literal_As_Signed (Node_Id);\n+\n /* lib: */\n \n #define Cunit \t\t\t\tlib__cunit"}, {"sha": "79ac6620ad7af78aadb53e7a112f7646017c2431", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -1036,10 +1036,10 @@ names in lower case)\n \n @noindent\n After building an application or a library it is often required to\n-install it into the development environment. This installation is\n-required if the library is to be used by another application for\n-example. The @command{gprinstall} tool provide an easy way to install\n-libraries, executable or object code generated durting the build. The\n+install it into the development environment. For instance this step is\n+required if the library is to be used by another application.\n+The @command{gprinstall} tool provides an easy way to install\n+libraries, executable or object code generated during the build. The\n @b{Install} package can be used to change the default locations.\n \n The following attributes can be defined in package @code{Install}:\n@@ -1073,7 +1073,7 @@ installed. Default is @b{include}.\n \n @item @b{Project_Subdir}\n \n-Subdirectory of @b{Prefix} where the installed project is to be\n+Subdirectory of @b{Prefix} where the generated project file is to be\n installed. Default is @b{share/gpr}.\n @end table\n "}, {"sha": "343485436c55294c19f94315173758068e522312", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -3862,7 +3862,6 @@ package body Sem_Eval is\n    function Expr_Value_R (N : Node_Id) return Ureal is\n       Kind : constant Node_Kind := Nkind (N);\n       Ent  : Entity_Id;\n-      Expr : Node_Id;\n \n    begin\n       if Kind = N_Real_Literal then\n@@ -3876,25 +3875,6 @@ package body Sem_Eval is\n       elsif Kind = N_Integer_Literal then\n          return UR_From_Uint (Expr_Value (N));\n \n-      --  Strange case of VAX literals, which are at this stage transformed\n-      --  into Vax_Type!x_To_y(IEEE_Literal). See Expand_N_Real_Literal in\n-      --  Exp_Vfpt for further details.\n-\n-      elsif Vax_Float (Etype (N))\n-        and then Nkind (N) = N_Unchecked_Type_Conversion\n-      then\n-         Expr := Expression (N);\n-\n-         if Nkind (Expr) = N_Function_Call\n-           and then Present (Parameter_Associations (Expr))\n-         then\n-            Expr := First (Parameter_Associations (Expr));\n-\n-            if Nkind (Expr) = N_Real_Literal then\n-               return Realval (Expr);\n-            end if;\n-         end if;\n-\n       --  Peculiar VMS case, if we have xxx'Null_Parameter, return 0.0\n \n       elsif Kind = N_Attribute_Reference"}, {"sha": "f7f56f01e0ab236d2cbf9f1478a5ff9611753248", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -14495,7 +14495,6 @@ package body Sem_Prag is\n             Assoc   : constant Node_Id := Arg1;\n             Type_Id : constant Node_Id := Get_Pragma_Arg (Assoc);\n             Typ     : Entity_Id;\n-            Discr   : Entity_Id;\n             Tdef    : Node_Id;\n             Clist   : Node_Id;\n             Vpart   : Node_Id;\n@@ -14546,21 +14545,12 @@ package body Sem_Prag is\n             --  Note: in previous versions of GNAT we used to check for limited\n             --  types and give an error, but in fact the standard does allow\n             --  Unchecked_Union on limited types, so this check was removed.\n+            --  Similarly, GNAT used to require that all discriminants have\n+            --  default values, but this is not mandated by the RM.\n \n             --  Proceed with basic error checks completed\n \n             else\n-               Discr := First_Discriminant (Typ);\n-               while Present (Discr) loop\n-                  if No (Discriminant_Default_Value (Discr)) then\n-                     Error_Msg_N\n-                       (\"unchecked union discriminant must have default value\",\n-                        Discr);\n-                  end if;\n-\n-                  Next_Discriminant (Discr);\n-               end loop;\n-\n                Tdef  := Type_Definition (Declaration_Node (Typ));\n                Clist := Component_List (Tdef);\n "}, {"sha": "dcf85a07f375f7ef80d7c56e3dddc2036b53f931", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/436d9f924cf07f4901d701999f4f19138bd5e917/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=436d9f924cf07f4901d701999f4f19138bd5e917", "patch": "@@ -407,7 +407,7 @@ private\n \n    Base : constant Int := 2 ** Base_Bits;\n \n-   --  Values in the range -(Base+1) .. Max_Direct are encoded directly as\n+   --  Values in the range -(Base-1) .. Max_Direct are encoded directly as\n    --  Uint values by adding a bias value. The value of Max_Direct is chosen\n    --  so that a directly represented number always fits in two digits when\n    --  represented in base format."}]}