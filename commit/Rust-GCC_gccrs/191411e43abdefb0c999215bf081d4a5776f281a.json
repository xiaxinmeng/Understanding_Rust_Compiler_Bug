{"sha": "191411e43abdefb0c999215bf081d4a5776f281a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkxNDExZTQzYWJkZWZiMGM5OTkyMTViZjA4MWQ0YTU3NzZmMjgxYQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-10-09T09:41:44Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-10-09T09:41:44Z"}, "message": "[PR 82416] Do not extend operands to at least 32 bits\n\n2017-10-09  Martin Jambor  <mjambor@suse.cz>\n\n\tPR hsa/82416\ngcc/\n\t* hsa-common.h (hsa_op_with_type): New method extend_int_to_32bit.\n\t* hsa-gen.c (hsa_extend_inttype_to_32bit): New function.\n\t(hsa_type_for_scalar_tree_type): Use it.  Always force min32int for\n\tCOMPLEX types.\n\t(hsa_fixup_mov_insn_type): New function.\n\t(hsa_op_with_type::get_in_type): Use it.\n\t(hsa_build_append_simple_mov): Likewise.  Allow sub-32bit\n\timmediates in an assert.\n\t(hsa_op_with_type::extend_int_to_32bit): New method.\n\t(gen_hsa_insns_for_bitfield): Fixup instruction and intermediary\n\ttypes.  Convert to dest type if necessary.\n\t(gen_hsa_insns_for_bitfield_load): Fixup load type if necessary.\n\t(reg_for_gimple_ssa): Pass false as min32int to\n\thsa_type_for_scalar_tree_type.\n\t(gen_hsa_addr): Fixup type when creating addresable temporary.\n\t(gen_hsa_cmp_insn_from_gimple): Extend operands if necessary.\n\t(gen_hsa_unary_operation): Extend operands and convert to dest type if\n\tnecessary.  Call hsa_fixup_mov_insn_type.\n\t(gen_hsa_binary_operation): Changed operand types to hsa_op_with_type,\n\textend operands and convert to dest type if necessary.\n\t(gen_hsa_insns_for_operation_assignment): Extend operands and convert\n\tto dest type if necessary.\n\t(set_output_in_type): Call hsa_fixup_mov_insn_type.  Just ude dest\n\tif conversion nt necessary and size matches.\n\t(gen_hsa_insns_for_load): Call hsa_fixup_mov_insn_type, convert\n\tto dest type if necessary.\n\t(gen_hsa_insns_for_store): Call hsa_fixup_mov_insn_type.\n\t(gen_hsa_insns_for_switch_stmt): Likewise. Also extend operands if\n\tnecessary.\n\t(gen_hsa_clrsb): Likewise.\n\t(gen_hsa_ffs): Likewise.\n\t(gen_hsa_divmod): Extend operands and convert to dest type if\n\tnecessary.\n\t(gen_hsa_atomic_for_builtin): Change type of op to hsa_op_with_type.\n\nlibgomp/\n\t* testsuite/libgomp.hsa.c/pr82416.c: New test.\n\nFrom-SVN: r253538", "tree": {"sha": "a2cd293263fb95faee3d20a30527eacb24426513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2cd293263fb95faee3d20a30527eacb24426513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/191411e43abdefb0c999215bf081d4a5776f281a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191411e43abdefb0c999215bf081d4a5776f281a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/191411e43abdefb0c999215bf081d4a5776f281a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191411e43abdefb0c999215bf081d4a5776f281a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7807e11c4d56ffc299a15e727ab3bf670d0fb8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7807e11c4d56ffc299a15e727ab3bf670d0fb8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7807e11c4d56ffc299a15e727ab3bf670d0fb8e"}], "stats": {"total": 301, "additions": 240, "deletions": 61}, "files": [{"sha": "5718175a321d742b66cf2c3f51cc226b21bf47cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/191411e43abdefb0c999215bf081d4a5776f281a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/191411e43abdefb0c999215bf081d4a5776f281a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=191411e43abdefb0c999215bf081d4a5776f281a", "patch": "@@ -1,3 +1,41 @@\n+2017-10-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR hsa/82416\n+\t* hsa-common.h (hsa_op_with_type): New method extend_int_to_32bit.\n+\t* hsa-gen.c (hsa_extend_inttype_to_32bit): New function.\n+\t(hsa_type_for_scalar_tree_type): Use it.  Always force min32int for\n+\tCOMPLEX types.\n+\t(hsa_fixup_mov_insn_type): New function.\n+\t(hsa_op_with_type::get_in_type): Use it.\n+\t(hsa_build_append_simple_mov): Likewise.  Allow sub-32bit\n+\timmediates in an assert.\n+\t(hsa_op_with_type::extend_int_to_32bit): New method.\n+\t(gen_hsa_insns_for_bitfield): Fixup instruction and intermediary\n+\ttypes.  Convert to dest type if necessary.\n+\t(gen_hsa_insns_for_bitfield_load): Fixup load type if necessary.\n+\t(reg_for_gimple_ssa): Pass false as min32int to\n+\thsa_type_for_scalar_tree_type.\n+\t(gen_hsa_addr): Fixup type when creating addresable temporary.\n+\t(gen_hsa_cmp_insn_from_gimple): Extend operands if necessary.\n+\t(gen_hsa_unary_operation): Extend operands and convert to dest type if\n+\tnecessary.  Call hsa_fixup_mov_insn_type.\n+\t(gen_hsa_binary_operation): Changed operand types to hsa_op_with_type,\n+\textend operands and convert to dest type if necessary.\n+\t(gen_hsa_insns_for_operation_assignment): Extend operands and convert\n+\tto dest type if necessary.\n+\t(set_output_in_type): Call hsa_fixup_mov_insn_type.  Just ude dest\n+\tif conversion nt necessary and size matches.\n+\t(gen_hsa_insns_for_load): Call hsa_fixup_mov_insn_type, convert\n+\tto dest type if necessary.\n+\t(gen_hsa_insns_for_store): Call hsa_fixup_mov_insn_type.\n+\t(gen_hsa_insns_for_switch_stmt): Likewise. Also extend operands if\n+\tnecessary.\n+\t(gen_hsa_clrsb): Likewise.\n+\t(gen_hsa_ffs): Likewise.\n+\t(gen_hsa_divmod): Extend operands and convert to dest type if\n+\tnecessary.\n+\t(gen_hsa_atomic_for_builtin): Change type of op to hsa_op_with_type.\n+\n 2017-10-08  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (conditional branch): Clean up formatting."}, {"sha": "3075163a02032f8ad72e9e9639081f87c37f6ec7", "filename": "gcc/hsa-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/191411e43abdefb0c999215bf081d4a5776f281a/gcc%2Fhsa-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/191411e43abdefb0c999215bf081d4a5776f281a/gcc%2Fhsa-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.h?ref=191411e43abdefb0c999215bf081d4a5776f281a", "patch": "@@ -157,6 +157,9 @@ class hsa_op_with_type : public hsa_op_base\n   /* Convert an operand to a destination type DTYPE and attach insns\n      to HBB if needed.  */\n   hsa_op_with_type *get_in_type (BrigType16_t dtype, hsa_bb *hbb);\n+  /* If this operand has integer type smaller than 32 bits, extend it to 32\n+     bits, adding instructions to HBB if needed.  */\n+  hsa_op_with_type *extend_int_to_32bit (hsa_bb *hbb);\n \n protected:\n   hsa_op_with_type (BrigKind16_t k, BrigType16_t t);"}, {"sha": "b5a8c73731af4dfad2a8edf596513001ab937a1d", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 157, "deletions": 61, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/191411e43abdefb0c999215bf081d4a5776f281a/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/191411e43abdefb0c999215bf081d4a5776f281a/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=191411e43abdefb0c999215bf081d4a5776f281a", "patch": "@@ -564,6 +564,19 @@ get_integer_type_by_bytes (unsigned size, bool sign)\n   return 0;\n }\n \n+/* If T points to an integral type smaller than 32 bits, change it to a 32bit\n+   equivalent and return the result.  Otherwise just return the result.   */\n+\n+static BrigType16_t\n+hsa_extend_inttype_to_32bit (BrigType16_t t)\n+{\n+  if (t == BRIG_TYPE_U8 || t == BRIG_TYPE_U16)\n+    return BRIG_TYPE_U32;\n+  else if (t == BRIG_TYPE_S8 || t == BRIG_TYPE_S16)\n+    return BRIG_TYPE_S32;\n+  return t;\n+}\n+\n /* Return HSA type for tree TYPE, which has to fit into BrigType16_t.  Pointers\n    are assumed to use flat addressing.  If min32int is true, always expand\n    integer types to one that has at least 32 bits.  */\n@@ -580,8 +593,13 @@ hsa_type_for_scalar_tree_type (const_tree type, bool min32int)\n   if (POINTER_TYPE_P (type))\n     return hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT);\n \n-  if (TREE_CODE (type) == VECTOR_TYPE || TREE_CODE (type) == COMPLEX_TYPE)\n+  if (TREE_CODE (type) == VECTOR_TYPE)\n     base = TREE_TYPE (type);\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      base = TREE_TYPE (type);\n+      min32int = true;\n+    }\n   else\n     base = type;\n \n@@ -652,14 +670,9 @@ hsa_type_for_scalar_tree_type (const_tree type, bool min32int)\n     }\n \n   if (min32int)\n-    {\n-      /* Registers/immediate operands can only be 32bit or more except for\n-\t f16.  */\n-      if (res == BRIG_TYPE_U8 || res == BRIG_TYPE_U16)\n-\tres = BRIG_TYPE_U32;\n-      else if (res == BRIG_TYPE_S8 || res == BRIG_TYPE_S16)\n-\tres = BRIG_TYPE_S32;\n-    }\n+    /* Registers/immediate operands can only be 32bit or more except for\n+       f16.  */\n+    res = hsa_extend_inttype_to_32bit (res);\n \n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n@@ -1009,6 +1022,16 @@ hsa_get_string_cst_symbol (tree string_cst)\n   return sym;\n }\n \n+/* Make the type of a MOV instruction larger if mandated by HSAIL rules.  */\n+\n+static void\n+hsa_fixup_mov_insn_type (hsa_insn_basic *insn)\n+{\n+  insn->m_type = hsa_extend_inttype_to_32bit (insn->m_type);\n+  if (insn->m_type == BRIG_TYPE_B8 || insn->m_type == BRIG_TYPE_B16)\n+    insn->m_type = BRIG_TYPE_B32;\n+}\n+\n /* Constructor of the ancestor of all operands.  K is BRIG kind that identified\n    what the operator is.  */\n \n@@ -1050,9 +1073,11 @@ hsa_op_with_type::get_in_type (BrigType16_t dtype, hsa_bb *hbb)\n   else\n     {\n       dest = new hsa_op_reg (m_type);\n-      hbb->append_insn (new hsa_insn_basic (2, BRIG_OPCODE_MOV,\n-\t\t\t\t\t    dest->m_type, dest, this));\n \n+      hsa_insn_basic *mov = new hsa_insn_basic (2, BRIG_OPCODE_MOV,\n+\t\t\t\t\t\tdest->m_type, dest, this);\n+      hsa_fixup_mov_insn_type (mov);\n+      hbb->append_insn (mov);\n       /* We cannot simply for instance: 'mov_u32 $_3, 48 (s32)' because\n \t type of the operand must be same as type of the instruction.  */\n       dest->m_type = dtype;\n@@ -1061,6 +1086,20 @@ hsa_op_with_type::get_in_type (BrigType16_t dtype, hsa_bb *hbb)\n   return dest;\n }\n \n+/* If this operand has integer type smaller than 32 bits, extend it to 32 bits,\n+   adding instructions to HBB if needed.  */\n+\n+hsa_op_with_type *\n+hsa_op_with_type::extend_int_to_32bit (hsa_bb *hbb)\n+{\n+  if (m_type == BRIG_TYPE_U8 || m_type == BRIG_TYPE_U16)\n+    return get_in_type (BRIG_TYPE_U32, hbb);\n+  else if (m_type == BRIG_TYPE_S8 || m_type == BRIG_TYPE_S16)\n+    return get_in_type (BRIG_TYPE_S32, hbb);\n+  else\n+    return this;\n+}\n+\n /* Constructor of class representing HSA immediate values.  TREE_VAL is the\n    tree representation of the immediate value.  If min32int is true,\n    always expand integer types to one that has at least 32 bits.  */\n@@ -1292,7 +1331,7 @@ hsa_function_representation::reg_for_gimple_ssa (tree ssa)\n     return m_ssa_map[SSA_NAME_VERSION (ssa)];\n \n   hreg = new hsa_op_reg (hsa_type_for_scalar_tree_type (TREE_TYPE (ssa),\n-\t\t\t\t\t\t\t true));\n+\t\t\t\t\t\t\tfalse));\n   hreg->m_gimple_ssa = ssa;\n   m_ssa_map[SSA_NAME_VERSION (ssa)] = hreg;\n \n@@ -1799,7 +1838,7 @@ gen_address_calculation (tree exp, hsa_bb *hbb, BrigType16_t addrtype)\n \n     case INTEGER_CST:\n       {\n-       hsa_op_immed *imm = new hsa_op_immed (exp);\n+\thsa_op_immed *imm = new hsa_op_immed (exp);\n        if (addrtype != imm->m_type)\n \t imm->m_type = addrtype;\n        return imm;\n@@ -1957,8 +1996,10 @@ gen_hsa_addr (tree ref, hsa_bb *hbb, HOST_WIDE_INT *output_bitsize = NULL,\n     case SSA_NAME:\n       {\n \taddrtype = hsa_get_segment_addr_type (BRIG_SEGMENT_PRIVATE);\n-\tsymbol = hsa_cfun->create_hsa_temporary (flat_addrtype);\n-\thsa_op_reg *r = hsa_cfun->reg_for_gimple_ssa (ref);\n+\thsa_op_with_type *r = hsa_cfun->reg_for_gimple_ssa (ref);\n+\tif (r->m_type == BRIG_TYPE_B1)\n+\t  r = r->get_in_type (BRIG_TYPE_U32, hbb);\n+\tsymbol = hsa_cfun->create_hsa_temporary (r->m_type);\n \n \thbb->append_insn (new hsa_insn_mem (BRIG_OPCODE_ST, r->m_type,\n \t\t\t\t\t    r, new hsa_op_address (symbol)));\n@@ -2247,13 +2288,18 @@ hsa_build_append_simple_mov (hsa_op_reg *dest, hsa_op_base *src, hsa_bb *hbb)\n      rules like when dealing with memory.  */\n   BrigType16_t tp = mem_type_for_type (dest->m_type);\n   hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV, tp, dest, src);\n+  hsa_fixup_mov_insn_type (insn);\n+  unsigned dest_size = hsa_type_bit_size (dest->m_type);\n   if (hsa_op_reg *sreg = dyn_cast <hsa_op_reg *> (src))\n-    gcc_assert (hsa_type_bit_size (dest->m_type)\n-\t\t== hsa_type_bit_size (sreg->m_type));\n+    gcc_assert (dest_size == hsa_type_bit_size (sreg->m_type));\n   else\n-    gcc_assert (hsa_type_bit_size (dest->m_type)\n-\t\t== hsa_type_bit_size (as_a <hsa_op_immed *> (src)->m_type));\n-\n+    {\n+      unsigned imm_size\n+\t=  hsa_type_bit_size (as_a <hsa_op_immed *> (src)->m_type);\n+      gcc_assert ((dest_size == imm_size)\n+\t\t  /* Eventually < 32bit registers will be promoted to 32bit. */\n+\t\t  || (dest_size < 32 && imm_size == 32));\n+    }\n   hbb->append_insn (insn);\n }\n \n@@ -2268,13 +2314,15 @@ gen_hsa_insns_for_bitfield (hsa_op_reg *dest, hsa_op_reg *value_reg,\n \t\t\t    HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t\t\t    hsa_bb *hbb)\n {\n-  unsigned type_bitsize = hsa_type_bit_size (dest->m_type);\n+  unsigned type_bitsize\n+    = hsa_type_bit_size (hsa_extend_inttype_to_32bit (dest->m_type));\n   unsigned left_shift = type_bitsize - (bitsize + bitpos);\n   unsigned right_shift = left_shift + bitpos;\n \n   if (left_shift)\n     {\n-      hsa_op_reg *value_reg_2 = new hsa_op_reg (dest->m_type);\n+      hsa_op_reg *value_reg_2\n+\t= new hsa_op_reg (hsa_extend_inttype_to_32bit (dest->m_type));\n       hsa_op_immed *c = new hsa_op_immed (left_shift, BRIG_TYPE_U32);\n \n       hsa_insn_basic *lshift\n@@ -2288,7 +2336,8 @@ gen_hsa_insns_for_bitfield (hsa_op_reg *dest, hsa_op_reg *value_reg,\n \n   if (right_shift)\n     {\n-      hsa_op_reg *value_reg_2 = new hsa_op_reg (dest->m_type);\n+      hsa_op_reg *value_reg_2\n+\t= new hsa_op_reg (hsa_extend_inttype_to_32bit (dest->m_type));\n       hsa_op_immed *c = new hsa_op_immed (right_shift, BRIG_TYPE_U32);\n \n       hsa_insn_basic *rshift\n@@ -2301,8 +2350,10 @@ gen_hsa_insns_for_bitfield (hsa_op_reg *dest, hsa_op_reg *value_reg,\n     }\n \n     hsa_insn_basic *assignment\n-      = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type, dest, value_reg);\n+      = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type, NULL, value_reg);\n+    hsa_fixup_mov_insn_type (assignment);\n     hbb->append_insn (assignment);\n+    assignment->set_output_in_type (dest, 0, hbb);\n }\n \n \n@@ -2318,8 +2369,10 @@ gen_hsa_insns_for_bitfield_load (hsa_op_reg *dest, hsa_op_address *addr,\n \t\t\t\t hsa_bb *hbb, BrigAlignment8_t align)\n {\n   hsa_op_reg *value_reg = new hsa_op_reg (dest->m_type);\n-  hsa_insn_mem *mem = new hsa_insn_mem (BRIG_OPCODE_LD, dest->m_type, value_reg,\n-\t\t\t\t\taddr);\n+  hsa_insn_mem *mem\n+  = new hsa_insn_mem (BRIG_OPCODE_LD,\n+\t\t      hsa_extend_inttype_to_32bit (dest->m_type),\n+\t\t      value_reg, addr);\n   mem->set_align (align);\n   hbb->append_insn (mem);\n   gen_hsa_insns_for_bitfield (dest, value_reg, bitsize, bitpos, hbb);\n@@ -2446,9 +2499,10 @@ gen_hsa_insns_for_load (hsa_op_reg *dest, tree rhs, tree type, hsa_bb *hbb)\n \treal_reg : imag_reg;\n \n       hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV,\n-\t\t\t\t\t\t dest->m_type, dest, source);\n-\n+\t\t\t\t\t\t dest->m_type, NULL, source);\n+      hsa_fixup_mov_insn_type (insn);\n       hbb->append_insn (insn);\n+      insn->set_output_in_type (dest, 0, hbb);\n     }\n   else if (TREE_CODE (rhs) == BIT_FIELD_REF\n \t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n@@ -2584,6 +2638,7 @@ gen_hsa_insns_for_store (tree lhs, hsa_op_base *src, hsa_bb *hbb)\n \n       hsa_insn_basic *basic = new hsa_insn_basic (2, BRIG_OPCODE_MOV, mem_type,\n \t\t\t\t\t\t  new_value_reg, src);\n+      hsa_fixup_mov_insn_type (basic);\n       hbb->append_insn (basic);\n \n       if (bitpos)\n@@ -2954,8 +3009,10 @@ gen_hsa_cmp_insn_from_gimple (enum tree_code code, tree lhs, tree rhs,\n     ? (BrigType16_t) BRIG_TYPE_B1 : dest->m_type;\n \n   hsa_insn_cmp *cmp = new hsa_insn_cmp (compare, dest_type);\n-  cmp->set_op (1, hsa_reg_or_immed_for_gimple_op (lhs, hbb));\n-  cmp->set_op (2, hsa_reg_or_immed_for_gimple_op (rhs, hbb));\n+  hsa_op_with_type *op1 = hsa_reg_or_immed_for_gimple_op (lhs, hbb);\n+  cmp->set_op (1, op1->extend_int_to_32bit (hbb));\n+  hsa_op_with_type *op2 = hsa_reg_or_immed_for_gimple_op (rhs, hbb);\n+  cmp->set_op (2, op2->extend_int_to_32bit (hbb));\n \n   hbb->append_insn (cmp);\n   cmp->set_output_in_type (dest, 0, hbb);\n@@ -2973,8 +3030,14 @@ gen_hsa_unary_operation (BrigOpcode opcode, hsa_op_reg *dest,\n   hsa_insn_basic *insn;\n \n   if (opcode == BRIG_OPCODE_MOV && hsa_needs_cvt (dest->m_type, op1->m_type))\n-    insn = new hsa_insn_cvt (dest, op1);\n-  else if (opcode == BRIG_OPCODE_FIRSTBIT || opcode == BRIG_OPCODE_LASTBIT)\n+    {\n+      insn = new hsa_insn_cvt (dest, op1);\n+      hbb->append_insn (insn);\n+      return;\n+    }\n+\n+  op1 = op1->extend_int_to_32bit (hbb);\n+  if (opcode == BRIG_OPCODE_FIRSTBIT || opcode == BRIG_OPCODE_LASTBIT)\n     {\n       BrigType16_t srctype = hsa_type_integer_p (op1->m_type) ? op1->m_type\n \t: hsa_unsigned_type_for_type (op1->m_type);\n@@ -2983,9 +3046,12 @@ gen_hsa_unary_operation (BrigOpcode opcode, hsa_op_reg *dest,\n     }\n   else\n     {\n-      insn = new hsa_insn_basic (2, opcode, dest->m_type, dest, op1);\n+      BrigType16_t optype = hsa_extend_inttype_to_32bit (dest->m_type);\n+      insn = new hsa_insn_basic (2, opcode, optype, NULL, op1);\n \n-      if (opcode == BRIG_OPCODE_ABS || opcode == BRIG_OPCODE_NEG)\n+      if (opcode == BRIG_OPCODE_MOV)\n+\thsa_fixup_mov_insn_type (insn);\n+      else if (opcode == BRIG_OPCODE_ABS || opcode == BRIG_OPCODE_NEG)\n \t{\n \t  /* ABS and NEG only exist in _s form :-/  */\n \t  if (insn->m_type == BRIG_TYPE_U32)\n@@ -2996,9 +3062,7 @@ gen_hsa_unary_operation (BrigOpcode opcode, hsa_op_reg *dest,\n     }\n \n   hbb->append_insn (insn);\n-\n-  if (opcode == BRIG_OPCODE_FIRSTBIT || opcode == BRIG_OPCODE_LASTBIT)\n-    insn->set_output_in_type (dest, 0, hbb);\n+  insn->set_output_in_type (dest, 0, hbb);\n }\n \n /* Generate a binary instruction with OPCODE and append it to a basic block\n@@ -3007,10 +3071,15 @@ gen_hsa_unary_operation (BrigOpcode opcode, hsa_op_reg *dest,\n \n static void\n gen_hsa_binary_operation (int opcode, hsa_op_reg *dest,\n-\t\t\t  hsa_op_base *op1, hsa_op_base *op2, hsa_bb *hbb)\n+\t\t\t  hsa_op_with_type *op1, hsa_op_with_type *op2,\n+\t\t\t  hsa_bb *hbb)\n {\n   gcc_checking_assert (dest);\n \n+  BrigType16_t optype = hsa_extend_inttype_to_32bit (dest->m_type);\n+  op1 = op1->extend_int_to_32bit (hbb);\n+  op2 = op2->extend_int_to_32bit (hbb);\n+\n   if ((opcode == BRIG_OPCODE_SHL || opcode == BRIG_OPCODE_SHR)\n       && is_a <hsa_op_immed *> (op2))\n     {\n@@ -3026,9 +3095,10 @@ gen_hsa_binary_operation (int opcode, hsa_op_reg *dest,\n       i->set_type (hsa_unsigned_type_for_type (i->m_type));\n     }\n \n-  hsa_insn_basic *insn = new hsa_insn_basic (3, opcode, dest->m_type, dest,\n+  hsa_insn_basic *insn = new hsa_insn_basic (3, opcode, optype, NULL,\n \t\t\t\t\t     op1, op2);\n   hbb->append_insn (insn);\n+  insn->set_output_in_type (dest, 0, hbb);\n }\n \n /* Generate HSA instructions for a single assignment.  HBB is the basic block\n@@ -3150,6 +3220,7 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n \telse if (TREE_CODE (rhs2) == SSA_NAME)\n \t  {\n \t    hsa_op_reg *s = hsa_cfun->reg_for_gimple_ssa (rhs2);\n+\t    s = as_a <hsa_op_reg *> (s->extend_int_to_32bit (hbb));\n \t    hsa_op_reg *d = new hsa_op_reg (s->m_type);\n \t    hsa_op_immed *size_imm = new hsa_op_immed (bitsize, BRIG_TYPE_U32);\n \n@@ -3253,27 +3324,33 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n \n \thsa_op_with_type *op2 = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n \thsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n+\top2 = op2->extend_int_to_32bit (hbb);\n+\top3 = op3->extend_int_to_32bit (hbb);\n \n-\tBrigType16_t utype = hsa_unsigned_type_for_type (dest->m_type);\n+\tBrigType16_t type = hsa_extend_inttype_to_32bit (dest->m_type);\n+\tBrigType16_t utype = hsa_unsigned_type_for_type (type);\n \tif (is_a <hsa_op_immed *> (op2))\n \t  op2->m_type = utype;\n \tif (is_a <hsa_op_immed *> (op3))\n \t  op3->m_type = utype;\n \n \thsa_insn_basic *insn\n \t  = new hsa_insn_basic (4, BRIG_OPCODE_CMOV,\n-\t\t\t\thsa_bittype_for_type (dest->m_type),\n-\t\t\t\tdest, ctrl, op2, op3);\n+\t\t\t\thsa_bittype_for_type (type),\n+\t\t\t\tNULL, ctrl, op2, op3);\n \n \thbb->append_insn (insn);\n+\tinsn->set_output_in_type (dest, 0, hbb);\n \treturn;\n       }\n     case COMPLEX_EXPR:\n       {\n \thsa_op_reg *dest\n \t  = hsa_cfun->reg_for_gimple_ssa (gimple_assign_lhs (assign));\n \thsa_op_with_type *rhs1_reg = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n+\trhs1_reg = rhs1_reg->extend_int_to_32bit (hbb);\n \thsa_op_with_type *rhs2_reg = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n+\trhs2_reg = rhs2_reg->extend_int_to_32bit (hbb);\n \n \tif (hsa_seen_error ())\n \t  return;\n@@ -3298,11 +3375,10 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n     }\n \n \n-  hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (gimple_assign_lhs (assign));\n-\n+  hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n   hsa_op_with_type *op1 = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n-  hsa_op_with_type *op2 = rhs2 != NULL_TREE ?\n-    hsa_reg_or_immed_for_gimple_op (rhs2, hbb) : NULL;\n+  hsa_op_with_type *op2\n+    = rhs2 ? hsa_reg_or_immed_for_gimple_op (rhs2, hbb) : NULL;\n \n   if (hsa_seen_error ())\n     return;\n@@ -3312,6 +3388,7 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n     case GIMPLE_TERNARY_RHS:\n       {\n \thsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n+\top3 = op3->extend_int_to_32bit (hbb);\n \thsa_insn_basic *insn = new hsa_insn_basic (4, opcode, dest->m_type, dest,\n \t\t\t\t\t\t   op1, op2, op3);\n \thbb->append_insn (insn);\n@@ -3407,14 +3484,15 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n   tree highest = get_switch_high (s);\n \n   hsa_op_reg *index = hsa_cfun->reg_for_gimple_ssa (index_tree);\n+  index = as_a <hsa_op_reg *> (index->extend_int_to_32bit (hbb));\n \n   hsa_op_reg *cmp1_reg = new hsa_op_reg (BRIG_TYPE_B1);\n-  hsa_op_immed *cmp1_immed = new hsa_op_immed (lowest);\n+  hsa_op_immed *cmp1_immed = new hsa_op_immed (lowest, true);\n   hbb->append_insn (new hsa_insn_cmp (BRIG_COMPARE_GE, cmp1_reg->m_type,\n \t\t\t\t      cmp1_reg, index, cmp1_immed));\n \n   hsa_op_reg *cmp2_reg = new hsa_op_reg (BRIG_TYPE_B1);\n-  hsa_op_immed *cmp2_immed = new hsa_op_immed (highest);\n+  hsa_op_immed *cmp2_immed = new hsa_op_immed (highest, true);\n   hbb->append_insn (new hsa_insn_cmp (BRIG_COMPARE_LE, cmp2_reg->m_type,\n \t\t\t\t      cmp2_reg, index, cmp2_immed));\n \n@@ -3444,7 +3522,7 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n   hsa_op_reg *sub_index = new hsa_op_reg (index->m_type);\n   hbb->append_insn (new hsa_insn_basic (3, BRIG_OPCODE_SUB, sub_index->m_type,\n \t\t\t\t\tsub_index, index,\n-\t\t\t\t\tnew hsa_op_immed (lowest)));\n+\t\t\t\t\tnew hsa_op_immed (lowest, true)));\n \n   hsa_op_base *tmp = sub_index->get_in_type (BRIG_TYPE_U64, hbb);\n   sub_index = as_a <hsa_op_reg *> (tmp);\n@@ -3760,7 +3838,6 @@ void\n hsa_insn_basic::set_output_in_type (hsa_op_reg *dest, unsigned op_index,\n \t\t\t\t    hsa_bb *hbb)\n {\n-  hsa_insn_basic *insn;\n   gcc_checking_assert (op_output_p (op_index));\n \n   if (dest->m_type == m_type)\n@@ -3769,15 +3846,28 @@ hsa_insn_basic::set_output_in_type (hsa_op_reg *dest, unsigned op_index,\n       return;\n     }\n \n-  hsa_op_reg *tmp = new hsa_op_reg (m_type);\n-  set_op (op_index, tmp);\n-\n+  hsa_insn_basic *insn;\n+  hsa_op_reg *tmp;\n   if (hsa_needs_cvt (dest->m_type, m_type))\n-    insn = new hsa_insn_cvt (dest, tmp);\n+    {\n+      tmp = new hsa_op_reg (m_type);\n+      insn = new hsa_insn_cvt (dest, tmp);\n+    }\n+  else if (hsa_type_bit_size (dest->m_type) == hsa_type_bit_size (m_type))\n+    {\n+      /* When output, HSA registers do not really have types, only sizes, so if\n+\t the sizes match, we can use the register directly.  */\n+      set_op (op_index, dest);\n+      return;\n+    }\n   else\n-    insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type,\n-\t\t\t       dest, tmp->get_in_type (dest->m_type, hbb));\n-\n+    {\n+      tmp = new hsa_op_reg (m_type);\n+      insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type,\n+\t\t\t\t dest, tmp->get_in_type (dest->m_type, hbb));\n+      hsa_fixup_mov_insn_type (insn);\n+    }\n+  set_op (op_index, tmp);\n   hbb->append_insn (insn);\n }\n \n@@ -4200,6 +4290,7 @@ gen_hsa_clrsb (gcall *call, hsa_bb *hbb)\n   hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n   tree rhs1 = gimple_call_arg (call, 0);\n   hsa_op_with_type *arg = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n+  arg->extend_int_to_32bit (hbb);\n   BrigType16_t bittype = hsa_bittype_for_type (arg->m_type);\n   unsigned bitsize = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (rhs1)));\n \n@@ -4272,6 +4363,7 @@ gen_hsa_ffs (gcall *call, hsa_bb *hbb)\n \n   tree rhs1 = gimple_call_arg (call, 0);\n   hsa_op_with_type *arg = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n+  arg = arg->extend_int_to_32bit (hbb);\n \n   hsa_op_reg *tmp = new hsa_op_reg (BRIG_TYPE_U32);\n   hsa_insn_srctype *insn = new hsa_insn_srctype (2, BRIG_OPCODE_LASTBIT,\n@@ -4361,7 +4453,9 @@ gen_hsa_divmod (gcall *call, hsa_bb *hbb)\n   tree rhs1 = gimple_call_arg (call, 1);\n \n   hsa_op_with_type *arg0 = hsa_reg_or_immed_for_gimple_op (rhs0, hbb);\n+  arg0 = arg0->extend_int_to_32bit (hbb);\n   hsa_op_with_type *arg1 = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n+  arg1 = arg1->extend_int_to_32bit (hbb);\n \n   hsa_op_reg *dest0 = new hsa_op_reg (arg0->m_type);\n   hsa_op_reg *dest1 = new hsa_op_reg (arg1->m_type);\n@@ -4374,11 +4468,13 @@ gen_hsa_divmod (gcall *call, hsa_bb *hbb)\n   hbb->append_insn (insn);\n \n   hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n+  BrigType16_t dst_type = hsa_extend_inttype_to_32bit (dest->m_type);\n   BrigType16_t src_type = hsa_bittype_for_type (dest0->m_type);\n \n-  insn = new hsa_insn_packed (3, BRIG_OPCODE_COMBINE, dest->m_type,\n-\t\t\t      src_type, dest, dest0, dest1);\n+  insn = new hsa_insn_packed (3, BRIG_OPCODE_COMBINE, dst_type,\n+\t\t\t      src_type, NULL, dest0, dest1);\n   hbb->append_insn (insn);\n+  insn->set_output_in_type (dest, 0, hbb);\n }\n \n /* Set VALUE to a shadow kernel debug argument and append a new instruction\n@@ -4936,8 +5032,8 @@ gen_hsa_atomic_for_builtin (bool ret_orig, enum BrigAtomicOperation acode,\n       tgt = addr;\n     }\n \n-  hsa_op_base *op = hsa_reg_or_immed_for_gimple_op (gimple_call_arg (stmt, 1),\n-\t\t\t\t\t\t    hbb);\n+  hsa_op_with_type *op\n+    = hsa_reg_or_immed_for_gimple_op (gimple_call_arg (stmt, 1), hbb);\n   if (lhs)\n     {\n       atominsn->set_op (0, dest);"}, {"sha": "1c5c5a9a912c1ab6b2b8a29fad22bddd9074a2fa", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/191411e43abdefb0c999215bf081d4a5776f281a/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/191411e43abdefb0c999215bf081d4a5776f281a/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=191411e43abdefb0c999215bf081d4a5776f281a", "patch": "@@ -1,3 +1,8 @@\n+2017-10-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR hsa/82416\n+\t* testsuite/libgomp.hsa.c/pr82416.c: New test.\n+\n 2017-10-07  Tom de Vries  <tom@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-fortran/firstprivate-1.f90 (firstprivate):"}, {"sha": "b89d421e8f3a647ee987cc9a0402e47874eb55a0", "filename": "libgomp/testsuite/libgomp.hsa.c/pr82416.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/191411e43abdefb0c999215bf081d4a5776f281a/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr82416.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/191411e43abdefb0c999215bf081d4a5776f281a/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr82416.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fpr82416.c?ref=191411e43abdefb0c999215bf081d4a5776f281a", "patch": "@@ -0,0 +1,37 @@\n+char __attribute__ ((noipa))\n+toup (char X)\n+{\n+  if (X >= 97 && X <= 122)\n+    return X - 32;\n+  else\n+    return X;\n+}\n+\n+char __attribute__ ((noipa))\n+target_toup (char X)\n+{\n+  char r;\n+#pragma omp target map(to:X) map(from:r)\n+  {\n+    if (X >= 97 && X <= 122)\n+      r = X - 32;\n+    else\n+      r = X;\n+  }\n+  return r;\n+}\n+\n+int main (int argc, char **argv)\n+{\n+  char a = 'a';\n+  if (toup (a) != target_toup (a))\n+    __builtin_abort ();\n+  a = 'Z';\n+  if (toup (a) != target_toup (a))\n+    __builtin_abort ();\n+  a = 5;\n+  if (toup (a) != target_toup (a))\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}