{"sha": "bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "node_id": "C_kwDOANBUbNoAKGJjOGQ2YzYwMTM3ZjhiYmYxNzNiODZkZGYzMWIxNWQ3YmEyYTMzZGQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-11-30T09:17:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-11-30T09:18:55Z"}, "message": "Fix -freorder-blocks-and-partition glitch with Windows SEH (continued)\n\nThis fixes a thinko in the fix for the -freorder-blocks-and-partition\nglitch with SEH on 64-bit Windows:\n  https://gcc.gnu.org/pipermail/gcc-patches/2021-February/565208.html\n\nEven if no exceptions are active, e.g. in C, we need to consider calls.\n\ngcc/\n\tPR target/103274\n\t* config/i386/i386.c (ix86_output_call_insn): Beef up comment about\n\tnops emitted with SEH.\n\t* config/i386/winnt.c (i386_pe_seh_unwind_emit): When switching to\n\tthe cold section, emit a nop before the directive if the previous\n\tactive instruction is a call.", "tree": {"sha": "dedfe7471450fe0bd1adb6a941627b4fd5c3eeb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dedfe7471450fe0bd1adb6a941627b4fd5c3eeb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd/comments", "author": null, "committer": null, "parents": [{"sha": "7abcc9ca20d4e17deabb308b5f483aaccc3dc02c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7abcc9ca20d4e17deabb308b5f483aaccc3dc02c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7abcc9ca20d4e17deabb308b5f483aaccc3dc02c"}], "stats": {"total": 10, "additions": 6, "deletions": 4}, "files": [{"sha": "0e6bf3e0fefcdd79d78771c283e7e5e57a4aa40d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "patch": "@@ -16438,8 +16438,10 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)\n \t    break;\n \n \t  /* If we get to the epilogue note, prevent a catch region from\n-\t     being adjacent to the standard epilogue sequence.  If non-\n-\t     call-exceptions, we'll have done this during epilogue emission. */\n+\t     being adjacent to the standard epilogue sequence.  Note that,\n+\t     if non-call exceptions are enabled, we already did it during\n+\t     epilogue expansion, or else, if the insn can throw internally,\n+\t     we already did it during the reorg pass.  */\n \t  if (NOTE_P (i) && NOTE_KIND (i) == NOTE_INSN_EPILOGUE_BEG\n \t      && !flag_non_call_exceptions\n \t      && !can_throw_internal (insn))"}, {"sha": "0aaf46f050a5734980003ac6197fff1e704e0d0a", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=bc8d6c60137f8bbf173b86ddf31b15d7ba2a33dd", "patch": "@@ -1243,9 +1243,9 @@ i386_pe_seh_unwind_emit (FILE *out_file, rtx_insn *insn)\n   seh = cfun->machine->seh;\n   if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n     {\n-      /* See ix86_seh_fixup_eh_fallthru for the rationale.  */\n+      /* See ix86_output_call_insn/seh_fixup_eh_fallthru for the rationale.  */\n       rtx_insn *prev = prev_active_insn (insn);\n-      if (prev && !insn_nothrow_p (prev))\n+      if (prev && (CALL_P (prev) || !insn_nothrow_p (prev)))\n \tfputs (\"\\tnop\\n\", out_file);\n       fputs (\"\\t.seh_endproc\\n\", out_file);\n       seh->in_cold_section = true;"}]}