{"sha": "ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0N2QzOGQ0YzVkMjI5YzY4NmU0NzlmY2ViOWVlOWViMjM0NDJmZg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2008-09-23T14:55:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2008-09-23T14:55:14Z"}, "message": "c-tree.h: Add argument to c_objc_common_truthvalue_conversion, parser_build_binary_op.\n\n        * c-tree.h: Add argument to c_objc_common_truthvalue_conversion,\n        parser_build_binary_op.\n        * c-decl.c (build_enumerator): Pass location to build_binary_op.\n        * c-typeck.c (build_array_ref): Same.\n        (parser_build_unary_op): New location argument.\n        (pointer_diff): Pass location to build_binary_op,\n        c_objc_common_truthvalue_conversion.\n        (build_modify_expr): Same.\n        (build_unary_op): New location argument.\n        (build_binary_op): New location argument.\n        (c_objc_common_truthvalue_conversion): Pass location to\n        c_*common_truthvalue_conversion.\n        * c-convert.c (convert): Same.\n        * c-common.c (binary_op_error): New location argument.\n        (pointer_int_sum): Pass location to build_binary_op.\n        (c_common_truthvalue_conversion): New location argument.\n        (warn_for_sign_compare): Same.\n        * c-common.h: Add location argument to c_common_truthvalue_conversion,\n        binary_op_error, build_binary_op, warn_for_sign_compare.\n        * c-parser.c (c_parser_condition): Pass location to\n        c_*common_truthvalue_conversion.\n        (c_parser_conditional_expression): Save condition's location and pass\n        it on down.\n        (c_parser_binary_expression): Same, but for the binary operator's\n        location.\n        (c_parser_omp_for_loop): Pass location to\n        c_objc_common_truthvalue_conversion.\nobjc/\n        * objc-act.c (next_sjlj_build_enter_and_setjmp): Call\n        c_common_truthvalue_conversion with location.\n        (next_sjlj_build_catch_list): Same.\n        (next_sjlj_build_try_catch_finally): Same.\ntestsuite/\n        * gcc.dg/Walways-true-1.c: Test column numbers.\n        * gcc.dg/c90-const-expr-5.c: Same.\n        * gcc.dg/compare4.c: Same.\n        * gcc.dg/Werror-1.c: Same.\ncp/\n        * typeck.c (build_array_ref): Pass location to cp_build_binary_op.\n        (get_member_function_from_ptrfunc): Same.\n        (build_x_binary_op): Same.\n        (build_binary_op): Same.\n        (cp_build_binary_op): New location argument.\n        (pointer_diff): Pass location to cp_build_binary_op.\n        (cp_truthvalue_conversion): Pass location to build_binary_op.\n        (convert_ptrmem): Pass location to cp_build_binary_op.\n        (cp_build_modify_expr): Same.\n        (build_ptrmemfunc): Same.\n        * init.c (expand_cleanup_for_base): Pass location to\n        c_common_truthvalue_conversion.\n        (build_new_1): Pass location to cp_build_binary_op.\n        (build_vec_delete_1): Pass location to *build_binary_op,\n        c_common_truthvalue_conversion.\n        (build_vec_init): Same.\n        (build_delete): Same.\n        * decl.c (compute_array_index_type): Same.\n        * call.c (build_new_op): Same.\n        * rtti.c (build_dynamic_cast_1): Same.\n        * cp-tree.h: Add argument to cp_build_binary_op.\n        * semantics.c (handle_omp_for_class_iterator): Pass location to\n        *build_binary_op, c_common_truthvalue_conversion.\n        * decl2.c (get_guard_cond): Same.\n\nFrom-SVN: r140598", "tree": {"sha": "21c7a88d82936ace208bcdd02d4ba68c691c6cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21c7a88d82936ace208bcdd02d4ba68c691c6cf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/comments", "author": null, "committer": null, "parents": [{"sha": "f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ac18b79931a074b5bc88e0b64ea8ef84e40941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ac18b79931a074b5bc88e0b64ea8ef84e40941"}], "stats": {"total": 583, "additions": 395, "deletions": 188}, "files": [{"sha": "45c2c3c11dc78022dd588c82f8448b20cf301483", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -1,3 +1,33 @@\n+2008-09-23  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-tree.h: Add argument to c_objc_common_truthvalue_conversion,\n+\tparser_build_binary_op.\n+\t* c-decl.c (build_enumerator): Pass location to build_binary_op.\n+\t* c-typeck.c (build_array_ref): Same.\n+\t(parser_build_unary_op): New location argument.\n+\t(pointer_diff): Pass location to build_binary_op,\n+\tc_objc_common_truthvalue_conversion.\n+\t(build_modify_expr): Same.\n+\t(build_unary_op): New location argument.\n+\t(build_binary_op): New location argument.\n+\t(c_objc_common_truthvalue_conversion): Pass location to\n+\tc_*common_truthvalue_conversion.\n+\t* c-convert.c (convert): Same.\n+\t* c-common.c (binary_op_error): New location argument.\n+\t(pointer_int_sum): Pass location to build_binary_op.\n+\t(c_common_truthvalue_conversion): New location argument.\n+\t(warn_for_sign_compare): Same.\n+\t* c-common.h: Add location argument to c_common_truthvalue_conversion,\n+\tbinary_op_error, build_binary_op, warn_for_sign_compare.\n+\t* c-parser.c (c_parser_condition): Pass location to\n+\tc_*common_truthvalue_conversion.\n+\t(c_parser_conditional_expression): Save condition's location and pass\n+\tit on down.\n+\t(c_parser_binary_expression): Same, but for the binary operator's\n+\tlocation.\n+\t(c_parser_omp_for_loop): Pass location to\n+\tc_objc_common_truthvalue_conversion.\n+\n 2008-09-23  Martin Jambor  <mjambor@suse.cz>\n \n \t* cgraph.c (cgraph_free_edge): Use sizeof(*e)."}, {"sha": "09027bab795d2e69f579f9339518ab6b986eb5c9", "filename": "gcc/c-common.c", "status": "modified", "additions": 65, "deletions": 36, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2849,10 +2849,12 @@ min_precision (tree value, int unsignedp)\n }\n \f\n /* Print an error message for invalid operands to arith operation\n-   CODE with TYPE0 for operand 0, and TYPE1 for operand 1.  */\n+   CODE with TYPE0 for operand 0, and TYPE1 for operand 1.\n+   LOCATION is the location of the message.  */\n \n void\n-binary_op_error (enum tree_code code, tree type0, tree type1)\n+binary_op_error (location_t location, enum tree_code code,\n+\t\t tree type0, tree type1)\n {\n   const char *opname;\n \n@@ -2903,8 +2905,9 @@ binary_op_error (enum tree_code code, tree type0, tree type1)\n     default:\n       gcc_unreachable ();\n     }\n-  error (\"invalid operands to binary %s (have %qT and %qT)\", opname,\n-\t type0, type1);\n+  error_at (location,\n+\t    \"invalid operands to binary %s (have %qT and %qT)\", opname,\n+\t    type0, type1);\n }\n \f\n /* Subroutine of build_binary_op, used for comparison operations.\n@@ -3320,7 +3323,8 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n       /* Convert both subexpression types to the type of intop,\n \t because weird cases involving pointer arithmetic\n \t can result in a sum or difference with different type args.  */\n-      ptrop = build_binary_op (subcode, ptrop,\n+      ptrop = build_binary_op (EXPR_LOCATION (TREE_OPERAND (intop, 1)),\n+\t\t\t       subcode, ptrop,\n \t\t\t       convert (int_type, TREE_OPERAND (intop, 1)), 1);\n       intop = convert (int_type, TREE_OPERAND (intop, 0));\n     }\n@@ -3336,7 +3340,8 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      Do this multiplication as signed, then convert to the appropriate\n      type for the pointer operation.  */\n   intop = convert (sizetype,\n-\t\t   build_binary_op (MULT_EXPR, intop,\n+\t\t   build_binary_op (EXPR_LOCATION (intop),\n+\t\t\t\t    MULT_EXPR, intop,\n \t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n@@ -3367,6 +3372,8 @@ decl_with_nonnull_addr_p (const_tree expr)\n    have been validated to be of suitable type; otherwise, a bad\n    diagnostic may result.\n \n+   The EXPR is located at LOCATION.\n+\n    This preparation consists of taking the ordinary\n    representation of an expression expr and producing a valid tree\n    boolean expression describing whether expr is nonzero.  We could\n@@ -3376,7 +3383,7 @@ decl_with_nonnull_addr_p (const_tree expr)\n    The resulting type should always be `truthvalue_type_node'.  */\n \n tree\n-c_common_truthvalue_conversion (tree expr)\n+c_common_truthvalue_conversion (location_t location, tree expr)\n {\n   switch (TREE_CODE (expr))\n     {\n@@ -3397,14 +3404,17 @@ c_common_truthvalue_conversion (tree expr)\n       if (TREE_TYPE (expr) == truthvalue_type_node)\n \treturn expr;\n       return build2 (TREE_CODE (expr), truthvalue_type_node,\n-\t\t c_common_truthvalue_conversion (TREE_OPERAND (expr, 0)),\n-\t\t c_common_truthvalue_conversion (TREE_OPERAND (expr, 1)));\n+\t\t c_common_truthvalue_conversion (location, \n+\t\t\t\t\t\t TREE_OPERAND (expr, 0)),\n+\t\t c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t TREE_OPERAND (expr, 1)));\n \n     case TRUTH_NOT_EXPR:\n       if (TREE_TYPE (expr) == truthvalue_type_node)\n \treturn expr;\n       return build1 (TREE_CODE (expr), truthvalue_type_node,\n-\t\t c_common_truthvalue_conversion (TREE_OPERAND (expr, 0)));\n+\t\t c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t TREE_OPERAND (expr, 0)));\n \n     case ERROR_MARK:\n       return expr;\n@@ -3434,9 +3444,10 @@ c_common_truthvalue_conversion (tree expr)\n \tif (decl_with_nonnull_addr_p (inner))\n \t  {\n \t    /* Common Ada/Pascal programmer's mistake.  */\n-\t    warning (OPT_Waddress,\n-\t\t     \"the address of %qD will always evaluate as %<true%>\",\n-\t\t     inner);\n+\t    warning_at (location,\n+\t\t\tOPT_Waddress,\n+\t\t\t\"the address of %qD will always evaluate as %<true%>\",\n+\t\t\tinner);\n \t    return truthvalue_true_node;\n \t  }\n \n@@ -3456,17 +3467,20 @@ c_common_truthvalue_conversion (tree expr)\n       }\n \n     case COMPLEX_EXPR:\n-      return build_binary_op ((TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1))\n+      return build_binary_op (EXPR_LOCATION (expr),\n+\t\t\t      (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1))\n \t\t\t       ? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n-\t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 0)),\n-\t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\tc_common_truthvalue_conversion (location,\n+\t\t\t\t\t\tTREE_OPERAND (expr, 0)),\n+\t\tc_common_truthvalue_conversion (location,\n+\t\t\t\t\t\tTREE_OPERAND (expr, 1)),\n \t\t\t      0);\n \n     case NEGATE_EXPR:\n     case ABS_EXPR:\n     case FLOAT_EXPR:\n       /* These don't change whether an object is nonzero or zero.  */\n-      return c_common_truthvalue_conversion (TREE_OPERAND (expr, 0));\n+      return c_common_truthvalue_conversion (location, TREE_OPERAND (expr, 0));\n \n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n@@ -3475,16 +3489,20 @@ c_common_truthvalue_conversion (tree expr)\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n \treturn build2 (COMPOUND_EXPR, truthvalue_type_node,\n \t\t       TREE_OPERAND (expr, 1),\n-\t\t       c_common_truthvalue_conversion (TREE_OPERAND (expr, 0)));\n+\t\t       c_common_truthvalue_conversion \n+\t\t        (location, TREE_OPERAND (expr, 0)));\n       else\n-\treturn c_common_truthvalue_conversion (TREE_OPERAND (expr, 0));\n+\treturn c_common_truthvalue_conversion (location,\n+\t\t\t\t\t       TREE_OPERAND (expr, 0));\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n       return fold_build3 (COND_EXPR, truthvalue_type_node,\n \t\tTREE_OPERAND (expr, 0),\n-\t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n-\t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 2)));\n+\t\tc_common_truthvalue_conversion (location,\n+\t\t\t\t\t\tTREE_OPERAND (expr, 1)),\n+\t\tc_common_truthvalue_conversion (location,\n+\t\t\t\t\t\tTREE_OPERAND (expr, 2)));\n \n     CASE_CONVERT:\n       /* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE,\n@@ -3495,7 +3513,8 @@ c_common_truthvalue_conversion (tree expr)\n       /* If this is widening the argument, we can ignore it.  */\n       if (TYPE_PRECISION (TREE_TYPE (expr))\n \t  >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (expr, 0))))\n-\treturn c_common_truthvalue_conversion (TREE_OPERAND (expr, 0));\n+\treturn c_common_truthvalue_conversion (location,\n+\t\t\t\t\t       TREE_OPERAND (expr, 0));\n       break;\n \n     case MODIFY_EXPR:\n@@ -3516,10 +3535,13 @@ c_common_truthvalue_conversion (tree expr)\n     {\n       tree t = save_expr (expr);\n       return (build_binary_op\n-\t      ((TREE_SIDE_EFFECTS (expr)\n+\t      (EXPR_LOCATION (expr),\n+\t       (TREE_SIDE_EFFECTS (expr)\n \t\t? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n-\tc_common_truthvalue_conversion (build_unary_op (REALPART_EXPR, t, 0)),\n-\tc_common_truthvalue_conversion (build_unary_op (IMAGPART_EXPR, t, 0)),\n+\tc_common_truthvalue_conversion (location,\n+\t\t\t\t\tbuild_unary_op (REALPART_EXPR, t, 0)),\n+\tc_common_truthvalue_conversion (location,\n+\t\t\t\t\tbuild_unary_op (IMAGPART_EXPR, t, 0)),\n \t       0));\n     }\n \n@@ -3528,10 +3550,12 @@ c_common_truthvalue_conversion (tree expr)\n       tree fixed_zero_node = build_fixed (TREE_TYPE (expr),\n \t\t\t\t\t  FCONST0 (TYPE_MODE\n \t\t\t\t\t\t   (TREE_TYPE (expr))));\n-      return build_binary_op (NE_EXPR, expr, fixed_zero_node, 1);\n+      return build_binary_op (EXPR_LOCATION (expr),\n+\t\t\t      NE_EXPR, expr, fixed_zero_node, 1);\n     }\n \n-  return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n+  return build_binary_op (EXPR_LOCATION (expr),\n+\t\t\t  NE_EXPR, expr, integer_zero_node, 1);\n }\n \f\n static void def_builtin_1  (enum built_in_function fncode,\n@@ -8198,13 +8222,16 @@ warn_for_div_by_zero (tree divisor)\n    between signed and unsigned quantities that may fail. Do the\n    checking based on the original operand trees ORIG_OP0 and ORIG_OP1,\n    so that casts will be considered, but default promotions won't\n-   be. \n+   be.\n+\n+   LOCATION is the location of the comparison operator.\n \n    The arguments of this function map directly to local variables\n    of build_binary_op.  */\n \n void \n-warn_for_sign_compare (tree orig_op0, tree orig_op1, \n+warn_for_sign_compare (location_t location,\n+\t\t       tree orig_op0, tree orig_op1, \n \t\t       tree op0, tree op1, \n \t\t       tree result_type, enum tree_code resultcode)\n {\n@@ -8219,8 +8246,9 @@ warn_for_sign_compare (tree orig_op0, tree orig_op1,\n       && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n       != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n     {\n-      warning (OPT_Wsign_compare, \"comparison between types %qT and %qT\",\n-               TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n+      warning_at (location,\n+\t\t  OPT_Wsign_compare, \"comparison between types %qT and %qT\",\n+\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n     }\n \n   /* Do not warn if the comparison is being done in a signed type,\n@@ -8266,8 +8294,9 @@ warn_for_sign_compare (tree orig_op0, tree orig_op1,\n                                    c_common_signed_type (result_type)))\n         /* OK */;\n       else \n-        warning (OPT_Wsign_compare, \n-                 \"comparison between signed and unsigned integer expressions\");\n+        warning_at (location,\n+\t\t    OPT_Wsign_compare, \n+\t\t    \"comparison between signed and unsigned integer expressions\");\n     }\n   \n   /* Warn if two unsigned values are being compared in a size larger\n@@ -8320,8 +8349,8 @@ warn_for_sign_compare (tree orig_op0, tree orig_op1,\n \t\t    warning (OPT_Wsign_compare, \n \t\t\t     \"promoted ~unsigned is always non-zero\");\n \t\t  else\n-\t\t    warning (OPT_Wsign_compare, \n-\t\t\t     \"comparison of promoted ~unsigned with constant\");\n+\t\t    warning_at (location, OPT_Wsign_compare, \n+\t\t\t\t\"comparison of promoted ~unsigned with constant\");\n \t\t}\n             }\n         }\n@@ -8330,7 +8359,7 @@ warn_for_sign_compare (tree orig_op0, tree orig_op1,\n                    < TYPE_PRECISION (result_type))\n                && (TYPE_PRECISION (TREE_TYPE (op1))\n                    < TYPE_PRECISION (result_type)))\n-        warning (OPT_Wsign_compare, \n+        warning_at (location, OPT_Wsign_compare,\n                  \"comparison of promoted ~unsigned with unsigned\");\n     }\n }"}, {"sha": "9621b05ba469be06a7531a996f4732a83c265284", "filename": "gcc/c-common.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -714,13 +714,13 @@ extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);\n extern tree c_build_bitfield_integer_type (unsigned HOST_WIDE_INT, int);\n extern bool decl_with_nonnull_addr_p (const_tree);\n-extern tree c_common_truthvalue_conversion (tree);\n+extern tree c_common_truthvalue_conversion (location_t, tree);\n extern void c_apply_type_quals_to_decl (int, tree);\n extern tree c_sizeof_or_alignof_type (tree, bool, int);\n extern tree c_alignof_expr (tree);\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n-extern void binary_op_error (enum tree_code, tree, tree);\n+extern void binary_op_error (location_t, enum tree_code, tree, tree);\n extern tree fix_string_type (tree);\n struct varray_head_tag;\n extern void constant_expression_warning (tree);\n@@ -817,7 +817,7 @@ extern tree build_case_label (tree, tree, tree);\n    a variant of the C language.  They are used in c-common.c.  */\n \n extern tree build_unary_op (enum tree_code, tree, int);\n-extern tree build_binary_op (enum tree_code, tree, tree, int);\n+extern tree build_binary_op (location_t, enum tree_code, tree, tree, int);\n extern tree perform_integral_promotions (tree);\n \n /* These functions must be defined by each front-end which implements\n@@ -917,7 +917,8 @@ extern void warn_about_parentheses (enum tree_code, enum tree_code,\n \t\t\t\t    enum tree_code);\n extern void warn_for_unused_label (tree label);\n extern void warn_for_div_by_zero (tree divisor);\n-extern void warn_for_sign_compare (tree orig_op0, tree orig_op1, \n+extern void warn_for_sign_compare (location_t,\n+\t\t\t\t   tree orig_op0, tree orig_op1, \n \t\t\t\t   tree op0, tree op1, \n \t\t\t\t   tree result_type, \n \t\t\t\t   enum tree_code resultcode);"}, {"sha": "a5dc1fb39ffadd786770c4ea271ac1d73c8a4a5a", "filename": "gcc/c-convert.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -100,7 +100,8 @@ convert (tree type, tree expr)\n   if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n     return fold (convert_to_integer (type, e));\n   if (code == BOOLEAN_TYPE)\n-    return fold_convert (type, c_objc_common_truthvalue_conversion (expr));\n+    return fold_convert \n+      (type, c_objc_common_truthvalue_conversion (input_location, expr));\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (convert_to_pointer (type, e));\n   if (code == REAL_TYPE)"}, {"sha": "70265557269dbb4d7ab20c34587098efc8481093", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -6027,8 +6027,10 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n \t     \"ISO C restricts enumerator values to range of %<int%>\");\n \n   /* Set basis for default for next value.  */\n-  the_enum->enum_next_value = build_binary_op (PLUS_EXPR, value,\n-\t\t\t\t\t       integer_one_node, 0);\n+  the_enum->enum_next_value\n+    = build_binary_op\n+         (EXPR_HAS_LOCATION (value) ? EXPR_LOCATION (value) : input_location,\n+\t PLUS_EXPR, value, integer_one_node, 0);\n   the_enum->enum_overflow = tree_int_cst_lt (the_enum->enum_next_value, value);\n \n   /* Now create a declaration for the enum value name.  */"}, {"sha": "4222f41e19f59a4dea28f328d551ec9c542755fd", "filename": "gcc/c-parser.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -3805,7 +3805,7 @@ c_parser_condition (c_parser *parser)\n   tree cond;\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_objc_common_truthvalue_conversion \n-    (c_parser_expression_conv (parser).value);\n+    (loc, c_parser_expression_conv (parser).value);\n   if (CAN_HAVE_LOCATION_P (cond))\n     SET_EXPR_LOCATION (cond, loc);\n   if (warn_sequence_point)\n@@ -4426,8 +4426,13 @@ static struct c_expr\n c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n {\n   struct c_expr cond, exp1, exp2, ret;\n+  location_t cond_loc;\n+\n   gcc_assert (!after || c_dialect_objc ());\n+\n+  cond_loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_binary_expression (parser, after);\n+\n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n   cond = default_function_array_conversion (cond);\n@@ -4438,14 +4443,14 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \t       \"ISO C forbids omitting the middle term of a ?: expression\");\n       /* Make sure first operand is calculated only once.  */\n       exp1.value = save_expr (default_conversion (cond.value));\n-      cond.value = c_objc_common_truthvalue_conversion (exp1.value);\n+      cond.value = c_objc_common_truthvalue_conversion (cond_loc, exp1.value);\n       skip_evaluation += cond.value == truthvalue_true_node;\n     }\n   else\n     {\n       cond.value\n \t= c_objc_common_truthvalue_conversion\n-\t(default_conversion (cond.value));\n+\t(cond_loc, default_conversion (cond.value));\n       skip_evaluation += cond.value == truthvalue_false_node;\n       exp1 = c_parser_expression_conv (parser);\n       skip_evaluation += ((cond.value == truthvalue_true_node)\n@@ -4570,6 +4575,8 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n     enum tree_code op;\n   } stack[NUM_PRECS];\n   int sp;\n+  /* Location of the binary operator.  */\n+  location_t binary_loc;\n #define POP\t\t\t\t\t\t\t\t      \\\n   do {\t\t\t\t\t\t\t\t\t      \\\n     switch (stack[sp].op)\t\t\t\t\t\t      \\\n@@ -4587,7 +4594,8 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       = default_function_array_conversion (stack[sp - 1].expr);\t\t      \\\n     stack[sp].expr\t\t\t\t\t\t\t      \\\n       = default_function_array_conversion (stack[sp].expr);\t\t      \\\n-    stack[sp - 1].expr = parser_build_binary_op (stack[sp].op,\t\t      \\\n+    stack[sp - 1].expr = parser_build_binary_op (binary_loc,\t\t      \\\n+\t\t\t\t\t\t stack[sp].op,\t\t      \\\n \t\t\t\t\t\t stack[sp - 1].expr,\t      \\\n \t\t\t\t\t\t stack[sp].expr);\t      \\\n     sp--;\t\t\t\t\t\t\t\t      \\\n@@ -4681,6 +4689,7 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \t     expression.  */\n \t  goto out;\n \t}\n+      binary_loc = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n       while (oprec <= stack[sp].prec)\n \tPOP;\n@@ -4690,14 +4699,14 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \t  stack[sp].expr\n \t    = default_function_array_conversion (stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n-\t    (default_conversion (stack[sp].expr.value));\n+\t    (binary_loc, default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_false_node;\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n \t  stack[sp].expr\n \t    = default_function_array_conversion (stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n-\t    (default_conversion (stack[sp].expr.value));\n+\t    (binary_loc, default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_true_node;\n \t  break;\n \tdefault:\n@@ -7602,7 +7611,7 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n       if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n \t{\n \t  cond = c_parser_expression_conv (parser).value;\n-\t  cond = c_objc_common_truthvalue_conversion (cond);\n+\t  cond = c_objc_common_truthvalue_conversion (input_location, cond);\n \t  if (CAN_HAVE_LOCATION_P (cond))\n \t    SET_EXPR_LOCATION (cond, input_location);\n \t}"}, {"sha": "26ef664092a9c6abbc250e83ae8a5ef378313b55", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -521,7 +521,6 @@ extern struct c_declspecs *finish_declspecs (struct c_declspecs *);\n /* in c-objc-common.c */\n extern bool c_objc_common_init (void);\n extern bool c_missing_noreturn_ok_p (tree);\n-extern tree c_objc_common_truthvalue_conversion (tree expr);\n extern bool c_warn_unused_global_decl (const_tree);\n extern void c_initialize_diagnostics (diagnostic_context *);\n extern bool c_vla_unspec_p (tree x, tree fn);\n@@ -540,6 +539,7 @@ extern struct c_switch *c_switch_stack;\n extern struct c_label_context_se *label_context_stack_se;\n extern struct c_label_context_vm *label_context_stack_vm;\n \n+extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (tree);\n extern int same_translation_unit_p (const_tree, const_tree);\n extern int comptypes (tree, tree);\n@@ -557,7 +557,8 @@ extern struct c_expr c_expr_sizeof_expr (struct c_expr);\n extern struct c_expr c_expr_sizeof_type (struct c_type_name *);\n extern struct c_expr parser_build_unary_op (enum tree_code, struct c_expr,\n     \t\t\t\t\t    location_t);\n-extern struct c_expr parser_build_binary_op (enum tree_code, struct c_expr,\n+extern struct c_expr parser_build_binary_op (location_t, \n+    \t\t\t\t\t     enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n extern tree build_conditional_expr (tree, tree, tree);\n extern tree build_compound_expr (tree, tree);"}, {"sha": "14244051f17ddf168377a0231ea83976ef7b18f0", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 59, "deletions": 43, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2163,8 +2163,9 @@ build_array_ref (tree array, tree index, location_t loc)\n       gcc_assert (TREE_CODE (TREE_TYPE (ar)) == POINTER_TYPE);\n       gcc_assert (TREE_CODE (TREE_TYPE (TREE_TYPE (ar))) != FUNCTION_TYPE);\n \n-      return build_indirect_ref (build_binary_op (PLUS_EXPR, ar, index, 0),\n-\t\t\t\t \"array indexing\", loc);\n+      return build_indirect_ref\n+\t(build_binary_op (loc, PLUS_EXPR, ar, index, 0),\n+\t \"array indexing\", loc);\n     }\n }\n \f\n@@ -2760,23 +2761,29 @@ parser_build_unary_op (enum tree_code code, struct c_expr arg, location_t loc)\n    in the input.  CODE, a tree_code, specifies the binary operator, and\n    ARG1 and ARG2 are the operands.  In addition to constructing the\n    expression, we check for operands that were written with other binary\n-   operators in a way that is likely to confuse the user.  */\n+   operators in a way that is likely to confuse the user.\n+\n+   LOCATION is the location of the binary operator.  */\n \n struct c_expr\n-parser_build_binary_op (enum tree_code code, struct c_expr arg1,\n-\t\t\tstruct c_expr arg2)\n+parser_build_binary_op (location_t location, enum tree_code code,\n+\t\t\tstruct c_expr arg1, struct c_expr arg2)\n {\n   struct c_expr result;\n \n   enum tree_code code1 = arg1.original_code;\n   enum tree_code code2 = arg2.original_code;\n \n-  result.value = build_binary_op (code, arg1.value, arg2.value, 1);\n+  result.value = build_binary_op (location, code,\n+\t\t\t\t  arg1.value, arg2.value, 1);\n   result.original_code = code;\n \n   if (TREE_CODE (result.value) == ERROR_MARK)\n     return result;\n \n+  if (location != UNKNOWN_LOCATION)\n+    protected_set_expr_location (result.value, location);\n+\n   /* Check for cases such as x+y<<z which users are likely\n      to misinterpret.  */\n   if (warn_parentheses)\n@@ -2873,7 +2880,8 @@ pointer_diff (tree op0, tree op1)\n      Do not do default conversions on the minus operator\n      in case restype is a short type.  */\n \n-  op0 = build_binary_op (MINUS_EXPR, convert (restype, op0),\n+  op0 = build_binary_op (input_location,\n+\t\t\t MINUS_EXPR, convert (restype, op0),\n \t\t\t convert (restype, op1), 0);\n   /* This generates an error if op1 is pointer to incomplete type.  */\n   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (orig_op1))))\n@@ -3006,7 +3014,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  error (\"wrong type argument to unary exclamation mark\");\n \t  return error_mark_node;\n \t}\n-      arg = c_objc_common_truthvalue_conversion (arg);\n+      arg = c_objc_common_truthvalue_conversion (input_location, arg);\n       return invert_truthvalue (arg);\n \n     case REALPART_EXPR:\n@@ -3167,7 +3175,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  tree op0 = TREE_OPERAND (arg, 0);\n \t  if (!c_mark_addressable (op0))\n \t    return error_mark_node;\n-\t  return build_binary_op (PLUS_EXPR,\n+\t  return build_binary_op (EXPR_LOCATION (xarg), PLUS_EXPR,\n \t\t\t\t  (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE\n \t\t\t\t   ? array_to_pointer_conversion (op0)\n \t\t\t\t   : op0),\n@@ -3859,7 +3867,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   if (modifycode != NOP_EXPR)\n     {\n       lhs = stabilize_reference (lhs);\n-      newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n+      newrhs = build_binary_op (EXPR_LOCATION (lhs),\n+\t\t\t\tmodifycode, lhs, rhs, 1);\n     }\n \n   /* Give an error for storing in something that is 'const'.  */\n@@ -7914,6 +7923,7 @@ push_cleanup (tree ARG_UNUSED (decl), tree cleanup, bool eh_only)\n \f\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n+   LOCATION is the operator's location.\n    This function differs from `build' in several ways:\n    the data type of the result is computed and recorded in it,\n    warnings are generated if arg data types are invalid,\n@@ -7928,8 +7938,8 @@ push_cleanup (tree ARG_UNUSED (decl), tree cleanup, bool eh_only)\n    the arithmetic is to be done.  */\n \n tree\n-build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n-\t\t int convert_p)\n+build_binary_op (location_t location, enum tree_code code,\n+\t\t tree orig_op0, tree orig_op1, int convert_p)\n {\n   tree type0, type1;\n   enum tree_code code0, code1;\n@@ -7981,6 +7991,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* True means types are compatible as far as ObjC is concerned.  */\n   bool objc_ok;\n \n+  if (location == UNKNOWN_LOCATION)\n+    location = input_location;\n+\n   if (convert_p)\n     {\n       op0 = default_conversion (orig_op0);\n@@ -8013,7 +8026,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   if ((invalid_op_diag\n        = targetm.invalid_binary_op (code, type0, type1)))\n     {\n-      error (invalid_op_diag);\n+      error_at (location, invalid_op_diag);\n       return error_mark_node;\n     }\n \n@@ -8131,8 +8144,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     but that does not mean the operands should be\n \t     converted to ints!  */\n \t  result_type = integer_type_node;\n-\t  op0 = c_common_truthvalue_conversion (op0);\n-\t  op1 = c_common_truthvalue_conversion (op1);\n+\t  op0 = c_common_truthvalue_conversion (location, op0);\n+\t  op1 = c_common_truthvalue_conversion (location, op1);\n \t  converted = 1;\n \t}\n       break;\n@@ -8197,8 +8210,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case EQ_EXPR:\n     case NE_EXPR:\n       if (FLOAT_TYPE_P (type0) || FLOAT_TYPE_P (type1))\n-\twarning (OPT_Wfloat_equal,\n-\t\t \"comparing floating point with == or != is unsafe\");\n+\twarning_at (location,\n+\t\t    OPT_Wfloat_equal,\n+\t\t    \"comparing floating point with == or != is unsafe\");\n       /* Result of comparison is always int,\n \t but don't convert the args to int!  */\n       build_type = integer_type_node;\n@@ -8222,20 +8236,20 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t whose value is 0 but which isn't a valid null ptr const.  */\n \t      if (pedantic && !null_pointer_constant_p (orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n-\t\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n+\t\tpedwarn (location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n \t      if (pedantic && !null_pointer_constant_p (orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n-\t\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n+\t\tpedwarn (location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else\n \t    /* Avoid warning about the volatile ObjC EH puts on decls.  */\n \t    if (!objc_ok)\n-\t      pedwarn (input_location, 0,\n+\t      pedwarn (location, 0,\n \t\t       \"comparison of distinct pointer types lacks a cast\");\n \n \t  if (result_type == NULL_TREE)\n@@ -8245,27 +8259,29 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  if (TREE_CODE (op0) == ADDR_EXPR\n \t      && decl_with_nonnull_addr_p (TREE_OPERAND (op0, 0)))\n-\t    warning (OPT_Waddress, \"the address of %qD will never be NULL\",\n-\t\t     TREE_OPERAND (op0, 0));\n+\t    warning_at (location,\n+\t\t\tOPT_Waddress, \"the address of %qD will never be NULL\",\n+\t\t\tTREE_OPERAND (op0, 0));\n \t  result_type = type0;\n \t}\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  if (TREE_CODE (op1) == ADDR_EXPR\n \t      && decl_with_nonnull_addr_p (TREE_OPERAND (op1, 0)))\n-\t    warning (OPT_Waddress, \"the address of %qD will never be NULL\",\n-\t\t     TREE_OPERAND (op1, 0));\n+\t    warning_at (location,\n+\t\t\tOPT_Waddress, \"the address of %qD will never be NULL\",\n+\t\t\tTREE_OPERAND (op1, 0));\n \t  result_type = type1;\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n+\t  pedwarn (location, 0, \"comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n+\t  pedwarn (location, 0, \"comparison between pointer and integer\");\n \t}\n       break;\n \n@@ -8286,44 +8302,44 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n \t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n-\t\tpedwarn (input_location, 0,\n+\t\tpedwarn (location, 0,\n \t\t\t \"comparison of complete and incomplete pointers\");\n \t      else if (TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n+\t\tpedwarn (location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"ordered comparisons of pointers to functions\");\n \t    }\n \t  else\n \t    {\n \t      result_type = ptr_type_node;\n-\t      pedwarn (input_location, 0,\n+\t      pedwarn (location, 0,\n \t\t       \"comparison of distinct pointer types lacks a cast\");\n \t    }\n \t}\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n \t  result_type = type0;\n \t  if (pedantic)\n-\t    pedwarn (input_location, OPT_pedantic, \n+\t    pedwarn (location, OPT_pedantic, \n \t\t     \"ordered comparison of pointer with integer zero\");\n \t  else if (extra_warnings)\n-\t    warning (OPT_Wextra,\n+\t    warning_at (location, OPT_Wextra,\n \t\t     \"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  result_type = type1;\n-\t  pedwarn (input_location, OPT_pedantic, \n+\t  pedwarn (location, OPT_pedantic, \n \t\t   \"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n+\t  pedwarn (location, 0, \"comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (input_location, 0, \"comparison between pointer and integer\");\n+\t  pedwarn (location, 0, \"comparison between pointer and integer\");\n \t}\n       break;\n \n@@ -8339,7 +8355,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  || !same_scalar_type_ignoring_signedness (TREE_TYPE (type0),\n \t\t\t\t\t\t    TREE_TYPE (type1))))\n     {\n-      binary_op_error (code, type0, type1);\n+      binary_op_error (location, code, type0, type1);\n       return error_mark_node;\n     }\n \n@@ -8429,7 +8445,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \t  if (warn_sign_compare && !skip_evaluation)\n             {\n-              warn_for_sign_compare (orig_op0, orig_op1, op0, op1, \n+              warn_for_sign_compare (location, orig_op0, orig_op1, op0, op1, \n                                      result_type, resultcode);\n \t    }\n \t}\n@@ -8443,7 +8459,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n   if (!result_type)\n     {\n-      binary_op_error (code, TREE_TYPE (op0), TREE_TYPE (op1));\n+      binary_op_error (location, code, TREE_TYPE (op0), TREE_TYPE (op1));\n       return error_mark_node;\n     }\n \n@@ -8479,23 +8495,23 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \n /* Convert EXPR to be a truth-value, validating its type for this\n-   purpose.  */\n+   purpose.  LOCATION is the source location for the expression.  */\n \n tree\n-c_objc_common_truthvalue_conversion (tree expr)\n+c_objc_common_truthvalue_conversion (location_t location, tree expr)\n {\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n     case ARRAY_TYPE:\n-      error (\"used array that cannot be converted to pointer where scalar is required\");\n+      error_at (location, \"used array that cannot be converted to pointer where scalar is required\");\n       return error_mark_node;\n \n     case RECORD_TYPE:\n-      error (\"used struct type value where scalar is required\");\n+      error_at (location, \"used struct type value where scalar is required\");\n       return error_mark_node;\n \n     case UNION_TYPE:\n-      error (\"used union type value where scalar is required\");\n+      error_at (location, \"used union type value where scalar is required\");\n       return error_mark_node;\n \n     case FUNCTION_TYPE:\n@@ -8507,7 +8523,7 @@ c_objc_common_truthvalue_conversion (tree expr)\n \n   /* ??? Should we also give an error for void and vectors rather than\n      leaving those to give errors later?  */\n-  return c_common_truthvalue_conversion (expr);\n+  return c_common_truthvalue_conversion (location, expr);\n }\n \f\n "}, {"sha": "4b5105e04e85672b37b045b30cd73c597adbf25b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -1,3 +1,30 @@\n+2008-09-23  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* typeck.c (build_array_ref): Pass location to cp_build_binary_op.\n+\t(get_member_function_from_ptrfunc): Same.\n+\t(build_x_binary_op): Same.\n+\t(build_binary_op): Same.\n+\t(cp_build_binary_op): New location argument.\n+\t(pointer_diff): Pass location to cp_build_binary_op.\n+\t(cp_truthvalue_conversion): Pass location to build_binary_op.\n+\t(convert_ptrmem): Pass location to cp_build_binary_op.\n+\t(cp_build_modify_expr): Same.\n+\t(build_ptrmemfunc): Same.\n+\t* init.c (expand_cleanup_for_base): Pass location to\n+\tc_common_truthvalue_conversion.\n+\t(build_new_1): Pass location to cp_build_binary_op.\n+\t(build_vec_delete_1): Pass location to *build_binary_op,\n+\tc_common_truthvalue_conversion.\n+\t(build_vec_init): Same.\n+\t(build_delete): Same.\n+\t* decl.c (compute_array_index_type): Same.\n+\t* call.c (build_new_op): Same.\n+\t* rtti.c (build_dynamic_cast_1): Same.\n+\t* cp-tree.h: Add argument to cp_build_binary_op.\n+\t* semantics.c (handle_omp_for_class_iterator): Pass location to\n+\t*build_binary_op, c_common_truthvalue_conversion.\n+\t* decl2.c (get_guard_cond): Same.\n+\n 2008-09-17  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/22374"}, {"sha": "bdaf7fdcc92a0507acdb979fdb996ae838818c2b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -4199,7 +4199,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      return cp_build_binary_op (code, arg1, arg2, complain);\n+      return cp_build_binary_op (input_location, code, arg1, arg2, complain);\n \n     case UNARY_PLUS_EXPR:\n     case NEGATE_EXPR:"}, {"sha": "c32fff6b7b407c9cefac4899a0d28efece2ed8b9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -4963,7 +4963,8 @@ extern tree composite_pointer_type\t\t(tree, tree, tree, tree,\n \t\t\t\t\t\t const char*, tsubst_flags_t);\n extern tree merge_types\t\t\t\t(tree, tree);\n extern tree check_return_expr\t\t\t(tree, bool *);\n-extern tree cp_build_binary_op                  (enum tree_code, tree, tree,\n+extern tree cp_build_binary_op                  (location_t,\n+\t\t\t\t\t\t enum tree_code, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n #define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n extern tree build_ptrmemfunc_access_expr\t(tree, tree);"}, {"sha": "82e0bba649fe277cffd14da51d0f6f2d4ee103f4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -7223,7 +7223,8 @@ compute_array_index_type (tree name, tree size)\n \t cp_build_binary_op will be appropriately folded.  */\n       saved_processing_template_decl = processing_template_decl;\n       processing_template_decl = 0;\n-      itype = cp_build_binary_op (MINUS_EXPR,\n+      itype = cp_build_binary_op (input_location,\n+\t\t\t\t  MINUS_EXPR,\n \t\t\t\t  cp_convert (ssizetype, size),\n \t\t\t\t  cp_convert (ssizetype, integer_one_node),\n \t\t\t\t  tf_warning_or_error);"}, {"sha": "b326752746f1d41b05fd39267d6b59a29874c7f7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2530,14 +2530,16 @@ get_guard_cond (tree guard)\n       guard_value = integer_one_node;\n       if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n \tguard_value = convert (TREE_TYPE (guard), guard_value);\n-      guard = cp_build_binary_op (BIT_AND_EXPR, guard, guard_value,\n+      guard = cp_build_binary_op (input_location,\n+\t\t\t\t  BIT_AND_EXPR, guard, guard_value,\n \t\t\t\t  tf_warning_or_error);\n     }\n \n   guard_value = integer_zero_node;\n   if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n     guard_value = convert (TREE_TYPE (guard), guard_value);\n-  return cp_build_binary_op (EQ_EXPR, guard, guard_value,\n+  return cp_build_binary_op (input_location,\n+\t\t\t     EQ_EXPR, guard, guard_value,\n \t\t\t     tf_warning_or_error);\n }\n \n@@ -2927,20 +2929,22 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n \t last to destroy the variable.  */\n       else if (initp)\n \tguard_cond\n-\t  = cp_build_binary_op (EQ_EXPR,\n+\t  = cp_build_binary_op (input_location,\n+\t\t\t\tEQ_EXPR,\n \t\t\t\tcp_build_unary_op (PREINCREMENT_EXPR,\n-\t\t\t\t\t\tguard,\n-\t\t\t\t\t\t/*noconvert=*/1,\n-                                                tf_warning_or_error),\n+\t\t\t\t\t\t   guard,\n+\t\t\t\t\t\t   /*noconvert=*/1,\n+\t\t\t\t\t\t   tf_warning_or_error),\n \t\t\t\tinteger_one_node,\n \t\t\t\ttf_warning_or_error);\n       else\n \tguard_cond\n-\t  = cp_build_binary_op (EQ_EXPR,\n+\t  = cp_build_binary_op (input_location,\n+\t\t\t\tEQ_EXPR,\n \t\t\t\tcp_build_unary_op (PREDECREMENT_EXPR,\n-\t\t\t\t\t\tguard,\n-\t\t\t\t\t\t/*noconvert=*/1,\n-                                                tf_warning_or_error),\n+\t\t\t\t\t\t   guard,\n+\t\t\t\t\t\t   /*noconvert=*/1,\n+\t\t\t\t\t\t   tf_warning_or_error),\n \t\t\t\tinteger_zero_node,\n \t\t\t\ttf_warning_or_error);\n \n@@ -2993,7 +2997,8 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n   /* Build the outer if-stmt to check for initialization or destruction.  */\n   init_if_stmt = begin_if_stmt ();\n   cond = initp ? integer_one_node : integer_zero_node;\n-  cond = cp_build_binary_op (EQ_EXPR,\n+  cond = cp_build_binary_op (input_location,\n+\t\t\t     EQ_EXPR,\n \t\t\t     initialize_p_decl,\n \t\t\t     cond,\n \t\t\t     tf_warning_or_error);\n@@ -3026,7 +3031,8 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n     /* Conditionalize this initialization on being in the right priority\n        and being initializing/finalizing appropriately.  */\n     priority_if_stmt = begin_if_stmt ();\n-    cond = cp_build_binary_op (EQ_EXPR,\n+    cond = cp_build_binary_op (input_location,\n+\t\t\t       EQ_EXPR,\n \t\t\t       priority_decl,\n \t\t\t       build_int_cst (NULL_TREE, priority),\n \t\t\t       tf_warning_or_error);"}, {"sha": "d68dd2d536278c3c15cfac493b32ed8cbb97e351", "filename": "gcc/cp/init.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -1001,7 +1001,7 @@ expand_cleanup_for_base (tree binfo, tree flag)\n                                     tf_warning_or_error);\n   if (flag)\n     expr = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\tc_common_truthvalue_conversion (flag),\n+\t\t\tc_common_truthvalue_conversion (input_location, flag),\n \t\t\texpr, integer_zero_node);\n \n   finish_eh_cleanup (expr);\n@@ -1877,7 +1877,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   for (elt_type = type;\n        TREE_CODE (elt_type) == ARRAY_TYPE;\n        elt_type = TREE_TYPE (elt_type))\n-    nelts = cp_build_binary_op (MULT_EXPR, nelts,\n+    nelts = cp_build_binary_op (input_location,\n+\t\t\t\tMULT_EXPR, nelts,\n \t\t\t\tarray_type_nelts_top (elt_type),\n \t\t\t\tcomplain);\n \n@@ -2177,7 +2178,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n             }\n \t  init_expr\n \t    = build_vec_init (init_expr,\n-\t\t\t      cp_build_binary_op (MINUS_EXPR, outer_nelts,\n+\t\t\t      cp_build_binary_op (input_location,\n+\t\t\t\t\t\t  MINUS_EXPR, outer_nelts,\n \t\t\t\t\t\t  integer_one_node,\n \t\t\t\t\t\t  complain),\n \t\t\t      init,\n@@ -2312,7 +2314,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n     {\n       if (check_new)\n \t{\n-\t  tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n+\t  tree ifexp = cp_build_binary_op (input_location,\n+\t\t\t\t\t   NE_EXPR, alloc_node,\n \t\t\t\t\t   integer_zero_node,\n \t\t\t\t\t   complain);\n \t  rval = build_conditional_expr (ifexp, rval, alloc_node, \n@@ -2579,7 +2582,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t  cookie_size = targetm.cxx.get_cookie_size (type);\n \t  base_tbd\n \t    = cp_convert (ptype,\n-\t\t\t  cp_build_binary_op (MINUS_EXPR,\n+\t\t\t  cp_build_binary_op (input_location,\n+\t\t\t\t\t      MINUS_EXPR,\n \t\t\t\t\t      cp_convert (string_type_node,\n \t\t\t\t\t\t\t  base),\n \t\t\t\t\t      cookie_size,\n@@ -2933,13 +2937,15 @@ build_vec_init (tree base, tree maxindex, tree init,\n       && from_array != 2)\n     {\n       tree e;\n-      tree m = cp_build_binary_op (MINUS_EXPR, maxindex, iterator,\n+      tree m = cp_build_binary_op (input_location,\n+\t\t\t\t   MINUS_EXPR, maxindex, iterator,\n \t\t\t\t   complain);\n \n       /* Flatten multi-dimensional array since build_vec_delete only\n \t expects one-dimensional array.  */\n       if (TREE_CODE (type) == ARRAY_TYPE)\n-\tm = cp_build_binary_op (MULT_EXPR, m,\n+\tm = cp_build_binary_op (input_location,\n+\t\t\t\tMULT_EXPR, m,\n \t\t\t\tarray_type_nelts_total (type),\n \t\t\t\tcomplain);\n \n@@ -3167,7 +3173,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \tifexp = integer_one_node;\n       else\n \t/* Handle deleting a null pointer.  */\n-\tifexp = fold (cp_build_binary_op (NE_EXPR, addr, integer_zero_node,\n+\tifexp = fold (cp_build_binary_op (input_location,\n+\t\t\t\t\t  NE_EXPR, addr, integer_zero_node,\n \t\t\t\t\t  tf_warning_or_error));\n \n       if (ifexp != integer_one_node)"}, {"sha": "1d5da6714376ca95a34546e284e1998c37f98211", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -721,7 +721,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t      tree neq;\n \n \t      result = save_expr (result);\n-\t      neq = c_common_truthvalue_conversion (result);\n+\t      neq = c_common_truthvalue_conversion (input_location, result);\n \t      return cp_convert (type,\n \t\t\t\t build3 (COND_EXPR, TREE_TYPE (result),\n \t\t\t\t\t neq, result, bad));"}, {"sha": "82a0495ef43671d7b8d154b0b19a8f601fc607d4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -4107,7 +4107,8 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t\t\t\t\t tf_warning_or_error));\n   *pre_body = pop_stmt_list (*pre_body);\n \n-  cond = cp_build_binary_op (TREE_CODE (cond), decl, diff,\n+  cond = cp_build_binary_op (elocus,\n+\t\t\t     TREE_CODE (cond), decl, diff,\n \t\t\t     tf_warning_or_error);\n   incr = build_modify_expr (decl, PLUS_EXPR, incr);\n "}, {"sha": "75bcf9c6913294917d894662ec256a138448c3bb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2655,7 +2655,8 @@ build_array_ref (tree array, tree idx, location_t loc)\n \n     warn_array_subscript_with_type_char (idx);\n \n-    ret = cp_build_indirect_ref (cp_build_binary_op (PLUS_EXPR, ar, ind,\n+    ret = cp_build_indirect_ref (cp_build_binary_op (input_location,\n+\t\t\t\t\t\t     PLUS_EXPR, ar, ind,\n \t\t\t\t\t\t     tf_warning_or_error),\n                                  \"array indexing\",\n                                  tf_warning_or_error);\n@@ -2718,16 +2719,20 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR, idx, integer_one_node,\n+\t  e1 = cp_build_binary_op (input_location,\n+\t\t\t\t   BIT_AND_EXPR, idx, integer_one_node,\n \t\t\t\t   tf_warning_or_error);\n-\t  idx = cp_build_binary_op (MINUS_EXPR, idx, integer_one_node,\n+\t  idx = cp_build_binary_op (input_location,\n+\t\t\t\t    MINUS_EXPR, idx, integer_one_node,\n \t\t\t\t    tf_warning_or_error);\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR, delta, integer_one_node,\n+\t  e1 = cp_build_binary_op (input_location,\n+\t\t\t\t   BIT_AND_EXPR, delta, integer_one_node,\n \t\t\t\t   tf_warning_or_error);\n-\t  delta = cp_build_binary_op (RSHIFT_EXPR, delta, integer_one_node,\n+\t  delta = cp_build_binary_op (input_location,\n+\t\t\t\t      RSHIFT_EXPR, delta, integer_one_node,\n \t\t\t\t      tf_warning_or_error);\n \t  break;\n \n@@ -3141,15 +3146,16 @@ build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n \n /* For the c-common bits.  */\n tree\n-build_binary_op (enum tree_code code, tree op0, tree op1,\n+build_binary_op (location_t location, enum tree_code code, tree op0, tree op1,\n \t\t int convert_p ATTRIBUTE_UNUSED)\n {\n-  return cp_build_binary_op(code, op0, op1, tf_warning_or_error);\n+  return cp_build_binary_op (location, code, op0, op1, tf_warning_or_error);\n }\n \n \n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n+   LOCATION is the location_t of the operator in the source code.\n    This function differs from `build' in several ways:\n    the data type of the result is computed and recorded in it,\n    warnings are generated if arg data types are invalid,\n@@ -3167,7 +3173,8 @@ build_binary_op (enum tree_code code, tree op0, tree op1,\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n+cp_build_binary_op (location_t location,\n+\t\t    enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t    tsubst_flags_t complain)\n {\n   tree op0, op1;\n@@ -3555,18 +3562,22 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t    {\n \t      tree pfn0 = pfn_from_ptrmemfunc (op0);\n \t      tree delta0 = delta_from_ptrmemfunc (op0);\n-\t      tree e1 = cp_build_binary_op (EQ_EXPR,\n+\t      tree e1 = cp_build_binary_op (location,\n+\t\t\t\t\t    EQ_EXPR,\n \t  \t\t\t            pfn0,\t\n \t\t\t\t      \t    fold_convert (TREE_TYPE (pfn0),\n \t\t\t\t\t\t\t  integer_zero_node),\n \t\t\t\t\t    complain);\n-\t      tree e2 = cp_build_binary_op (BIT_AND_EXPR, \n+\t      tree e2 = cp_build_binary_op (location,\n+\t\t\t\t\t    BIT_AND_EXPR, \n \t\t\t\t\t    delta0,\n \t\t\t\t            integer_one_node,\n \t\t\t\t\t    complain);\n-\t      e2 = cp_build_binary_op (EQ_EXPR, e2, integer_zero_node,\n+\t      e2 = cp_build_binary_op (location,\n+\t\t\t\t       EQ_EXPR, e2, integer_zero_node,\n \t\t\t\t       complain);\n-\t      op0 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e2,\n+\t      op0 = cp_build_binary_op (location,\n+\t\t\t\t\tTRUTH_ANDIF_EXPR, e1, e2,\n \t\t\t\t\tcomplain);\n \t      op1 = cp_convert (TREE_TYPE (op0), integer_one_node); \n \t    }\n@@ -3578,7 +3589,7 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (op0))\n-\treturn cp_build_binary_op (code, op1, op0, complain);\n+\treturn cp_build_binary_op (location, code, op1, op0, complain);\n       else if (TYPE_PTRMEMFUNC_P (type0) && TYPE_PTRMEMFUNC_P (type1))\n \t{\n \t  tree type;\n@@ -3626,28 +3637,34 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t         pointer-to-member is any member with a zero PFN and\n \t         LSB of the DELTA field is 0.  */\n \n-\t      e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t      e1 = cp_build_binary_op (location, BIT_AND_EXPR,\n \t\t\t\t       delta0, \n \t\t\t\t       integer_one_node,\n \t\t\t\t       complain);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, e1, integer_zero_node,\n+\t      e1 = cp_build_binary_op (location,\n+\t\t\t\t       EQ_EXPR, e1, integer_zero_node,\n \t\t\t\t       complain);\n-\t      e2 = cp_build_binary_op (BIT_AND_EXPR,\n+\t      e2 = cp_build_binary_op (location, BIT_AND_EXPR,\n \t\t\t\t       delta1,\n \t\t\t\t       integer_one_node,\n \t\t\t\t       complain);\n-\t      e2 = cp_build_binary_op (EQ_EXPR, e2, integer_zero_node,\n+\t      e2 = cp_build_binary_op (location,\n+\t\t\t\t       EQ_EXPR, e2, integer_zero_node,\n \t\t\t\t       complain);\n-\t      e1 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1,\n+\t      e1 = cp_build_binary_op (location,\n+\t\t\t\t       TRUTH_ANDIF_EXPR, e2, e1,\n \t\t\t\t       complain);\n-\t      e2 = cp_build_binary_op (EQ_EXPR,\n+\t      e2 = cp_build_binary_op (location, EQ_EXPR,\n \t\t\t\t       pfn0,\n \t\t\t\t       fold_convert (TREE_TYPE (pfn0),\n \t\t\t\t\t\t     integer_zero_node),\n \t\t\t\t       complain);\n-\t      e2 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1, complain);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1, complain);\n-\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2, complain);\n+\t      e2 = cp_build_binary_op (location,\n+\t\t\t\t       TRUTH_ANDIF_EXPR, e2, e1, complain);\n+\t      e1 = cp_build_binary_op (location,\n+\t\t\t\t       EQ_EXPR, delta0, delta1, complain);\n+\t      e1 = cp_build_binary_op (location,\n+\t\t\t\t       TRUTH_ORIF_EXPR, e1, e2, complain);\n \t    }\n \t  else\n \t    {\n@@ -3660,19 +3677,24 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t         pointer-to-member is any member with a zero PFN; the\n \t         DELTA field is unspecified.  */\n  \n-    \t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1, complain);\n-\t      e2 = cp_build_binary_op (EQ_EXPR,\n+    \t      e1 = cp_build_binary_op (location,\n+\t\t\t\t       EQ_EXPR, delta0, delta1, complain);\n+\t      e2 = cp_build_binary_op (location,\n+\t\t\t\t       EQ_EXPR,\n \t\t      \t\t       pfn0,\n \t\t\t   \t       fold_convert (TREE_TYPE (pfn0),\n \t\t\t\t\t\t     integer_zero_node),\n \t\t\t\t       complain);\n-\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2, complain);\n+\t      e1 = cp_build_binary_op (location,\n+\t\t\t\t       TRUTH_ORIF_EXPR, e1, e2, complain);\n \t    }\n \t  e2 = build2 (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t  e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1, complain);\n+\t  e = cp_build_binary_op (location,\n+\t\t\t\t  TRUTH_ANDIF_EXPR, e2, e1, complain);\n \t  if (code == EQ_EXPR)\n \t    return e;\n-\t  return cp_build_binary_op (EQ_EXPR, e, integer_zero_node, complain);\n+\t  return cp_build_binary_op (location,\n+\t\t\t\t     EQ_EXPR, e, integer_zero_node, complain);\n \t}\n       else\n \t{\n@@ -3773,7 +3795,7 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      || !same_scalar_type_ignoring_signedness (TREE_TYPE (type0),\n \t\t\t\t\t\t\tTREE_TYPE (type1)))\n \t    {\n-\t      binary_op_error (code, type0, type1);\n+\t      binary_op_error (location, code, type0, type1);\n \t      return error_mark_node;\n \t    }\n \t  arithmetic_types_p = 1;\n@@ -3857,8 +3879,8 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  && !processing_template_decl\n           && (complain & tf_warning))\n \t{\n-            warn_for_sign_compare (orig_op0, orig_op1, op0, op1, \n-                                   result_type, resultcode);\n+\t  warn_for_sign_compare (location, orig_op0, orig_op1, op0, op1, \n+\t\t\t\t result_type, resultcode);\n \t}\n     }\n \n@@ -3954,7 +3976,8 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n \n-  op0 = cp_build_binary_op (MINUS_EXPR,\n+  op0 = cp_build_binary_op (input_location,\n+\t\t\t    MINUS_EXPR,\n \t\t\t    cp_convert (restype, op0),\n \t\t\t    cp_convert (restype, op1),\n \t\t\t    tf_warning_or_error);\n@@ -4073,9 +4096,10 @@ cp_truthvalue_conversion (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n   if (TYPE_PTRMEM_P (type))\n-    return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n+    return build_binary_op (EXPR_LOCATION (expr),\n+\t\t\t    NE_EXPR, expr, integer_zero_node, 1);\n   else\n-    return c_common_truthvalue_conversion (expr);\n+    return c_common_truthvalue_conversion (input_location, expr);\n }\n \n /* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */\n@@ -4968,12 +4992,14 @@ convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \t{\n \t  tree cond, op1, op2;\n \n-\t  cond = cp_build_binary_op (EQ_EXPR,\n+\t  cond = cp_build_binary_op (input_location,\n+\t\t\t\t     EQ_EXPR,\n \t\t\t\t     expr,\n \t\t\t\t     build_int_cst (TREE_TYPE (expr), -1),\n \t\t\t\t     tf_warning_or_error);\n \t  op1 = build_nop (ptrdiff_type_node, expr);\n-\t  op2 = cp_build_binary_op (PLUS_EXPR, op1, delta,\n+\t  op2 = cp_build_binary_op (input_location,\n+\t\t\t\t    PLUS_EXPR, op1, delta,\n \t\t\t\t    tf_warning_or_error);\n \n \t  expr = fold_build3 (COND_EXPR, ptrdiff_type_node, cond, op1, op2);\n@@ -5914,7 +5940,8 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t\t\t|| MAYBE_CLASS_TYPE_P (lhstype)));\n \n \t  lhs = stabilize_reference (lhs);\n-\t  newrhs = cp_build_binary_op (modifycode, lhs, rhs,\n+\t  newrhs = cp_build_binary_op (EXPR_LOCATION (lhs),\n+\t\t\t\t       modifycode, lhs, rhs,\n \t\t\t\t       complain);\n \t  if (newrhs == error_mark_node)\n \t    {\n@@ -6303,9 +6330,11 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n       gcc_assert  (same_type_ignoring_top_level_qualifiers_p\n \t\t   (TREE_TYPE (delta), ptrdiff_type_node));\n       if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_delta)\n-\tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node,\n+\tn = cp_build_binary_op (input_location,\n+\t\t\t\tLSHIFT_EXPR, n, integer_one_node,\n \t\t\t\ttf_warning_or_error);\n-      delta = cp_build_binary_op (PLUS_EXPR, delta, n, tf_warning_or_error);\n+      delta = cp_build_binary_op (input_location,\n+\t\t\t\t  PLUS_EXPR, delta, n, tf_warning_or_error);\n       return build_ptrmemfunc1 (to_type, delta, npfn);\n     }\n "}, {"sha": "fb9b664d2b8178d45a61b1e5a914c0c79478307b", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -1,3 +1,10 @@\n+2008-09-23  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* objc-act.c (next_sjlj_build_enter_and_setjmp): Call\n+\tc_common_truthvalue_conversion with location.\n+\t(next_sjlj_build_catch_list): Same.\n+\t(next_sjlj_build_try_catch_finally): Same.\n+\n 2008-09-17  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR objc/37460"}, {"sha": "9ea40eafbec39ad81517c0b1bf224d17293bf75b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -3538,7 +3538,7 @@ next_sjlj_build_enter_and_setjmp (void)\n   sj = build_function_call (objc_setjmp_decl, t);\n \n   cond = build2 (COMPOUND_EXPR, TREE_TYPE (sj), enter, sj);\n-  cond = c_common_truthvalue_conversion (cond);\n+  cond = c_common_truthvalue_conversion (input_location, cond);\n \n   return build3 (COND_EXPR, void_type_node, cond, NULL, NULL);\n }\n@@ -3605,7 +3605,7 @@ next_sjlj_build_catch_list (void)\n \t      t = objc_get_class_reference (OBJC_TYPE_NAME (TREE_TYPE (type)));\n \t      args = tree_cons (NULL, t, args);\n \t      t = build_function_call (objc_exception_match_decl, args);\n-\t      cond = c_common_truthvalue_conversion (t);\n+\t      cond = c_common_truthvalue_conversion (input_location, t);\n \t    }\n \t  t = build3 (COND_EXPR, void_type_node, cond, body, NULL);\n \t  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n@@ -3727,7 +3727,8 @@ next_sjlj_build_try_catch_finally (void)\n   /* Build the complete FINALLY statement list.  */\n   t = next_sjlj_build_try_exit ();\n   t = build_stmt (COND_EXPR,\n-\t\t  c_common_truthvalue_conversion (rethrow_decl),\n+\t\t  c_common_truthvalue_conversion \n+\t\t    (input_location, rethrow_decl),\n \t\t  NULL, t);\n   SET_EXPR_LOCATION (t, cur_try_context->finally_locus);\n   append_to_statement_list (t, &TREE_OPERAND (try_fin, 1));\n@@ -3738,7 +3739,8 @@ next_sjlj_build_try_catch_finally (void)\n   t = tree_cons (NULL, rethrow_decl, NULL);\n   t = build_function_call (objc_exception_throw_decl, t);\n   t = build_stmt (COND_EXPR,\n-\t\t  c_common_truthvalue_conversion (rethrow_decl),\n+\t\t  c_common_truthvalue_conversion (input_location, \n+\t\t\t\t\t\t  rethrow_decl),\n \t\t  t, NULL);\n   SET_EXPR_LOCATION (t, cur_try_context->end_finally_locus);\n   append_to_statement_list (t, &TREE_OPERAND (try_fin, 1));"}, {"sha": "4ec69d5889c280a1d27fe580d2e7fdbbbe37a513", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -1,3 +1,10 @@\n+2008-09-23  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gcc.dg/Walways-true-1.c: Test column numbers.\n+\t* gcc.dg/c90-const-expr-5.c: Same.\n+\t* gcc.dg/compare4.c: Same.\n+\t* gcc.dg/Werror-1.c: Same.\n+\n 2008-09-23  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37588\n@@ -619,6 +626,7 @@\n \tPR tree-optimization/37508\n \t* gcc.dg/tree-ssa/pr37508.c: New testcase.\n \n+>>>>>>> .r140590\n 2008-09-15  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* g++.old-deja/g++.brendan/crash16.C: Function name is the correct "}, {"sha": "32b921c3fa7330ada7e046966d209bd953de4954", "filename": "gcc/testsuite/gcc.dg/Walways-true-1.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-1.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2,7 +2,7 @@\n    Origin: Ian Lance Taylor <iant@google.com>.  */\n \n /* { dg-do compile} */\n-/* { dg-options \"-Waddress\" } */\n+/* { dg-options \"-Waddress -fshow-column\" } */\n \n extern int foo (int);\n \n@@ -12,46 +12,46 @@ void\n bar (int a)\n {\n  lab:\n-  if (foo)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+  if (foo)\t/* { dg-warning \"7:always evaluate as\" \"correct warning\" } */\n     foo (0);\n   if (foo (1))\n     ;\n-  if (&i)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+  if (&i)\t/* { dg-warning \"7:always evaluate as\" \"correct warning\" } */\n     foo (2);\n   if (i)\n     foo (3);\n-  if (&a)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+  if (&a)\t/* { dg-warning \"7:always evaluate as\" \"correct warning\" } */\n     foo (4);\n   if (a)\n     foo (5);\n-  if (&&lab)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+  if (&&lab)\t/* { dg-warning \"7:always evaluate as\" \"correct warning\" } */\n     foo (6);\n-  if (foo == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (foo == 0)\t/* { dg-warning \"11:never be NULL\" \"correct warning\" } */\n     foo (7);\n   if (foo (1) == 0)\n     foo (8);\n-  if (&i == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (&i == 0)\t/* { dg-warning \"10:never be NULL\" \"correct warning\" } */\n     foo (9);\n   if (i == 0)\n     foo (10);\n-  if (&a == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (&a == 0)\t/* { dg-warning \"10:never be NULL\" \"correct warning\" } */\n     foo (11);\n   if (a == 0)\n     foo (12);\n-  if (&&lab == 0) /* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (&&lab == 0) /* { dg-warning \"13:never be NULL\" \"correct warning\" } */\n     foo (13);\n-  if (0 == foo)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (0 == foo)\t/* { dg-warning \"9:never be NULL\" \"correct warning\" } */\n     foo (14);\n   if (0 == foo (1))\n     foo (15);\n-  if (0 == &i)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (0 == &i)\t/* { dg-warning \"9:never be NULL\" \"correct warning\" } */\n     foo (16);\n   if (0 == i)\n     foo (17);\n-  if (0 == &a)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (0 == &a)\t/* { dg-warning \"9:never be NULL\" \"correct warning\" } */\n     foo (18);\n   if (0 == a)\n     foo (19);\n-  if (0 == &&lab) /* { dg-warning \"never be NULL\" \"correct warning\" } */\n+  if (0 == &&lab) /* { dg-warning \"9:never be NULL\" \"correct warning\" } */\n     foo (20);\n }"}, {"sha": "001af24525c388f90e887fd34732c41b918b851c", "filename": "gcc/testsuite/gcc.dg/Werror-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2FWerror-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2FWerror-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWerror-1.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Waddress -Wattributes -Werror\" } */\n+/* { dg-options \"-Waddress -Wattributes -Werror -fshow-column\" } */\n /* { dg-message \"warnings being treated as errors\" \"\" {target \"*-*-*\"} 0 } */\n \n /* This is the first in a series of test cases that test the\n@@ -16,6 +16,6 @@ int i;\n void\n foo ()\n {\n-  if (&i)\t/* { dg-error \".* will always evaluate as 'true'\" } */\n+  if (&i)\t/* { dg-error \"7:.* will always evaluate as 'true'\" } */\n     grill ();\n }"}, {"sha": "0a5af8124cd3a9b626d5f6c6bba38238e79f0c07", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-5.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2,7 +2,7 @@\n    qualified void.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n /* { dg-do compile } */\n-/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors -fshow-column\" } */\n \n typedef void V;\n int *p;\n@@ -15,14 +15,14 @@ f (void)\n {\n   /* (V *)0 is a null pointer constant, so the assignment should be\n      diagnosed.  */\n-  q = (j ? p : (V *)0); /* { dg-error \"assignment from incompatible pointer type\" } */\n-  q = (j ? p : (void *)0); /* { dg-error \"assignment from incompatible pointer type\" } */\n+  q = (j ? p : (V *)0); /* { dg-error \"3:assignment from incompatible pointer type\" } */\n+  q = (j ? p : (void *)0); /* { dg-error \"3:assignment from incompatible pointer type\" } */\n   /* And this conversion should be valid.  */\n   (void (*)(void))(V *)0;\n   (void (*)(void))(void *)0;\n   /* Pointers to qualified void are not valid null pointer\n      constants.  */\n-  fp = (const void *)0; /* { dg-error \"ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+  fp = (const void *)0; /* { dg-error \"3:ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n   fp = (void *)0;\n   fp = (V *)0;\n   fp = 0;\n@@ -32,8 +32,8 @@ f (void)\n   (void *)0 == fp;\n   fp == (V *)0;\n   (V *)0 == fp;\n-  fp == (V *)1; /* { dg-error \"ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n-  (V *)1 == fp; /* { dg-error \"ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n-  fp == (const void *)0; /* { dg-error \"ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n-  (const void *)0 == fp; /* { dg-error \"ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  fp == (V *)1; /* { dg-error \"6:ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  (V *)1 == fp; /* { dg-error \"10:ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  fp == (const void *)0; /* { dg-error \"6:ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n+  (const void *)0 == fp; /* { dg-error \"19:ISO C forbids comparison of 'void \\\\*' with function pointer\" } */\n }"}, {"sha": "e5dad4d1e456d68f98f5c7c1e11c43ee470c94e0", "filename": "gcc/testsuite/gcc.dg/compare4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare4.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -2,15 +2,15 @@\n    Origin: Kaveh R. Ghazi <ghazi@caip.rutgers.edu> 5/13/2001.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-Wsign-compare -fstrict-overflow\" } */\n+/* { dg-options \"-fshow-column -Wsign-compare -fstrict-overflow\" } */\n \n extern void bar(void);\n \n int foo(int x, int y, unsigned u)\n {\n   /* A COMPOUND_EXPR is non-negative if the last element is known to\n      be non-negative.  */\n-  if (u < (bar(), -1)) /*{ dg-warning \"signed and unsigned\" \"COMPOUND_EXPR\" }*/\n+  if (u < (bar(), -1)) /*{ dg-warning \"9:signed and unsigned\" \"COMPOUND_EXPR\" }*/\n     return x;\n   if (u < (bar(), 10))\n     return x;\n@@ -34,7 +34,7 @@ int foo(int x, int y, unsigned u)\n \n   /* A MODIFY_EXPR is non-negative if the new value is known to be\n      non-negative.  */\n-  if (u < (x = -1)) /* { dg-warning \"signed and unsigned\" \"MODIFY_EXPR\" } */\n+  if (u < (x = -1)) /* { dg-warning \"9:signed and unsigned\" \"MODIFY_EXPR\" } */\n     return x;\n   if (u < (x = 10))\n     return x;"}, {"sha": "f84a553959d71073465ed06e235d4eb7b19405dc", "filename": "gcc/testsuite/gcc.dg/misc-column.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2Fmisc-column.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba47d38d4c5d229c686e479fceb9ee9eb23442ff/gcc%2Ftestsuite%2Fgcc.dg%2Fmisc-column.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmisc-column.c?ref=ba47d38d4c5d229c686e479fceb9ee9eb23442ff", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-options \"-fshow-column -Wall -Wfloat-equal -pedantic\" } */\n+\n+float a, b;\n+\n+int *p;\n+struct {\n+\tint a;\n+\tchar b;\n+} *q;\n+\n+extern void bar();\n+\n+void foo (void)\n+{\n+  if (a == b) /* { dg-warning \"9:comparing floating point with\" } */\n+    bar ();\n+\n+  if (p < q) /* { dg-warning \"9:comparison of distinct pointer types\" } */\n+    bar ();\n+\n+  if (&p == 0) /* { dg-warning \"10:will never be NULL\" } */\n+    bar();\n+\n+  if (p == 4) /* { dg-warning \"9:comparison between pointer and integer\" } */\n+    bar();\n+\n+  if (p < 0) /* { dg-warning \"9:ordered comparison of pointer with\" } */\n+    bar();\n+}"}]}