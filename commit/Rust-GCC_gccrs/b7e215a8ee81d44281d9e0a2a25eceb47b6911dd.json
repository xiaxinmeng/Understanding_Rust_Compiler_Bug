{"sha": "b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdlMjE1YThlZTgxZDQ0MjgxZDllMGEyYTI1ZWNlYjQ3YjY5MTFkZA==", "commit": {"author": {"name": "Indu Bhagat", "email": "indu.bhagat@oracle.com", "date": "2021-05-20T18:15:52Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2021-06-28T16:47:20Z"}, "message": "CTF/BTF debug formats\n\nThis commit introduces support for generating CTF debugging\ninformation and BTF debugging information from GCC.\n\n2021-06-28  Indu Bhagat  <indu.bhagat@oracle.com>\n\t    David Faust  <david.faust@oracle.com>\n\t    Jose E. Marchesi  <jose.marchesi@oracle.com>\n\t    Weimin Pan  <weimin.pan@oracle.com>\n\ngcc/\n\n\t* Makefile.in: Add ctfc.*, ctfout.c and btfout.c files to\n\tGTFILES.  Add new object files.\n\t* common.opt: Add CTF and BTF debug info options.\n\t* btfout.c: New file.\n\t* ctfc.c: Likewise.\n\t* ctfc.h: Likewise.\n\t* ctfout.c: Likewise.\n\t* dwarf2ctf.c: Likewise.\n\t* dwarf2ctf.h: Likewise.\n\t* dwarf2cfi.c (dwarf2out_do_frame): Acknowledge CTF_DEBUG and\n\tBTF_DEBUG.\n\t* dwarf2out.c (dwarf2out_source_line): Likewise.\n\t(dwarf2out_finish): Skip emitting DWARF if CTF or BTF are to\n\tbe generated.\n\t(debug_format_do_cu): New function.\n\t(dwarf2out_early_finish): Traverse DIEs and emit CTF/BTF for\n\tthem if\trequested.\n\tInclude dwarf2ctf.c.\n\t* final.c (dwarf2_debug_info_emitted_p): Acknowledge DWARF-based debug\n\tformats.\n\t* flag-types.h (enum debug_info_type): Add CTF_DEBUG and BTF_DEBUG.\n\t(CTF_DEBUG): New bitmask.\n\t(BTF_DEBUG): Likewise.\n\t(enum ctf_debug_info_levels): New enum.\n\t* gengtype.c (open_base_files): Handle ctfc.h.\n\t(main): Handle uint32_t type.\n\t* flags.h (btf_debuginfo_p): New definition.\n\t(dwarf_based_debuginfo_p): Likewise.\n\t* opts.c (debug_type_names): Add entries for CTF and BTF.\n\t(btf_debuginfo_p): New function.\n\t(dwarf_based_debuginfo_p): Likewise.\n\t(common_handle_option): Handle -gctfN and -gbtf options.\n\t(set_debug_level): Set CTF_DEBUG, BTF_DEBUG whenever appropriate.\n\t* toplev.c (process_options): Inform the user and ignore -gctfLEVEL if\n\tfrontend is not C.\n\ninclude/\n\n\t* ctf.h: New file.\n\t* btf.h: Likewise.\n\nlibiberty/\n\n\t* simple-object.c (handle_lto_debug_sections): Copy over .ctf\n\tsections.", "tree": {"sha": "121afbbec2428c85a68b6119ac8c0f25f6cd9fab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/121afbbec2428c85a68b6119ac8c0f25f6cd9fab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/comments", "author": {"login": "ibhagatgnu", "id": 51812649, "node_id": "MDQ6VXNlcjUxODEyNjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/51812649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibhagatgnu", "html_url": "https://github.com/ibhagatgnu", "followers_url": "https://api.github.com/users/ibhagatgnu/followers", "following_url": "https://api.github.com/users/ibhagatgnu/following{/other_user}", "gists_url": "https://api.github.com/users/ibhagatgnu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibhagatgnu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibhagatgnu/subscriptions", "organizations_url": "https://api.github.com/users/ibhagatgnu/orgs", "repos_url": "https://api.github.com/users/ibhagatgnu/repos", "events_url": "https://api.github.com/users/ibhagatgnu/events{/privacy}", "received_events_url": "https://api.github.com/users/ibhagatgnu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "532617d6367c29803d5909f2432b1ebfb9ee1886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/532617d6367c29803d5909f2432b1ebfb9ee1886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/532617d6367c29803d5909f2432b1ebfb9ee1886"}], "stats": {"total": 5379, "additions": 5343, "deletions": 36}, "files": [{"sha": "934b2a05327cc8de3ae7a911e0e0938e8f3a04be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -1319,6 +1319,9 @@ OBJS = \\\n \tcfgloopanal.o \\\n \tcfgloopmanip.o \\\n \tcfgrtl.o \\\n+\tctfc.o \\\n+\tctfout.o \\\n+\tbtfout.o \\\n \tsymtab.o \\\n \tsymtab-thunks.o \\\n \tsymtab-clones.o \\\n@@ -1359,6 +1362,7 @@ OBJS = \\\n \tdumpfile.o \\\n \tdwarf2asm.o \\\n \tdwarf2cfi.o \\\n+\tdwarf2ctf.o \\\n \tdwarf2out.o \\\n \tearly-remat.o \\\n \temit-rtl.o \\\n@@ -2655,7 +2659,11 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/dwarf2out.h \\\n   $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/dwarf2cfi.c \\\n+  $(srcdir)/dwarf2ctf.c \\\n   $(srcdir)/dwarf2out.c \\\n+  $(srcdir)/ctfc.h \\\n+  $(srcdir)/ctfout.c \\\n+  $(srcdir)/btfout.c \\\n   $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/gimple-isel.cc \\\n   $(srcdir)/dojump.c $(srcdir)/emit-rtl.h \\"}, {"sha": "45954b4b7b96669625ca08caad4c0d6ebf52df03", "filename": "gcc/btfout.c", "status": "added", "additions": 1129, "deletions": 0, "changes": 1129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fbtfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fbtfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbtfout.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,1129 @@\n+/* Output BTF format from GCC.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains routines to output the BPF Type Format (BTF). The BTF\n+   debug format is very similar to CTF; as a result, the structure of this file\n+   closely resembles that of ctfout.c, and the same CTF container objects are\n+   used.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"output.h\"\n+#include \"dwarf2asm.h\"\n+#include \"debug.h\"\n+#include \"ctfc.h\"\n+#include \"diagnostic-core.h\"\n+#include \"cgraph.h\"\n+#include \"varasm.h\"\n+#include \"dwarf2out.h\" /* For lookup_decl_die.  */\n+\n+static int btf_label_num;\n+\n+static GTY (()) section * btf_info_section;\n+\n+/* BTF debug info section.  */\n+\n+#ifndef BTF_INFO_SECTION_NAME\n+#define BTF_INFO_SECTION_NAME  \".BTF\"\n+#endif\n+\n+#define BTF_INFO_SECTION_FLAGS (SECTION_DEBUG)\n+\n+/* Maximum size (in bytes) for an artifically generated BTF label.  */\n+\n+#define MAX_BTF_LABEL_BYTES 40\n+\n+static char btf_info_section_label[MAX_BTF_LABEL_BYTES];\n+\n+#ifndef BTF_INFO_SECTION_LABEL\n+#define BTF_INFO_SECTION_LABEL  \"Lbtf\"\n+#endif\n+\n+/* BTF encodes void as type id 0.  */\n+\n+#define BTF_VOID_TYPEID 0\n+#define BTF_INIT_TYPEID 1\n+\n+#define BTF_INVALID_TYPEID 0xFFFFFFFF\n+\n+/* Mapping of CTF variables to the IDs they will be assigned when they are\n+   converted to BTF_KIND_VAR type records. Strictly accounts for the index\n+   from the start of the variable type entries, does not include the number\n+   of types emitted prior to the variable records.  */\n+static hash_map <ctf_dvdef_ref, unsigned int> *btf_var_ids;\n+\n+/* Mapping of type IDs from original CTF ID to BTF ID. Types do not map\n+   1-to-1 from CTF to BTF. To avoid polluting the CTF container when updating\n+   type references-by-ID, we use this map instead.  */\n+static ctf_id_t * btf_id_map = NULL;\n+\n+/* Information for creating the BTF_KIND_DATASEC records.  */\n+typedef struct btf_datasec\n+{\n+  const char *name;                    /* Section name, e.g. \".bss\".  */\n+  uint32_t name_offset;                /* Offset to name in string table.  */\n+  vec<struct btf_var_secinfo> entries; /* Variable entries in this section.  */\n+} btf_datasec_t;\n+\n+/* One BTF_KIND_DATASEC record is created for each output data section which\n+   will hold at least one variable.  */\n+static vec<btf_datasec_t> datasecs;\n+\n+/* Holes occur for types which are present in the CTF container, but are either\n+   non-representable or redundant in BTF.  */\n+static vec<ctf_id_t> holes;\n+\n+/* CTF definition(s) of void. Only one definition of void should be generated.\n+   We should not encounter more than one definition of void, but use a vector\n+   to be safe.  */\n+static vec<ctf_id_t> voids;\n+\n+/* Functions in BTF have two separate type records - one for the prototype\n+   (BTF_KIND_FUNC_PROTO), as well as a BTF_KIND_FUNC. CTF_K_FUNCTION types\n+   map closely to BTF_KIND_FUNC_PROTO, but the BTF_KIND_FUNC records must be\n+   created. This vector holds them.  */\n+static GTY (()) vec<ctf_dtdef_ref, va_gc> *funcs;\n+\n+/* The number of BTF variables added to the TU CTF container.  */\n+static unsigned int num_vars_added = 0;\n+\n+/* The number of BTF types added to the TU CTF container.  */\n+static unsigned int num_types_added = 0;\n+\n+/* The number of types synthesized for BTF that do not correspond to\n+   CTF types.  */\n+static unsigned int num_types_created = 0;\n+\n+/* Map a CTF type kind to the corresponding BTF type kind.  */\n+\n+static uint32_t\n+get_btf_kind (uint32_t ctf_kind)\n+{\n+  /* N.B. the values encoding kinds are not in general the same for the\n+     same kind between CTF and BTF. e.g. CTF_K_CONST != BTF_KIND_CONST.  */\n+  switch (ctf_kind)\n+    {\n+    case CTF_K_INTEGER:  return BTF_KIND_INT;\n+    case CTF_K_POINTER:  return BTF_KIND_PTR;\n+    case CTF_K_ARRAY:    return BTF_KIND_ARRAY;\n+    case CTF_K_FUNCTION: return BTF_KIND_FUNC_PROTO;\n+    case CTF_K_STRUCT:   return BTF_KIND_STRUCT;\n+    case CTF_K_UNION:    return BTF_KIND_UNION;\n+    case CTF_K_ENUM:     return BTF_KIND_ENUM;\n+    case CTF_K_FORWARD:  return BTF_KIND_FWD;\n+    case CTF_K_TYPEDEF:  return BTF_KIND_TYPEDEF;\n+    case CTF_K_VOLATILE: return BTF_KIND_VOLATILE;\n+    case CTF_K_CONST:    return BTF_KIND_CONST;\n+    case CTF_K_RESTRICT: return BTF_KIND_RESTRICT;\n+    default:;\n+    }\n+  return BTF_KIND_UNKN;\n+}\n+\n+/* Allocate the btf_id_map, and initialize elements to BTF_INVALID_TYPEID.  */\n+\n+static void\n+init_btf_id_map (size_t len)\n+{\n+  btf_id_map = XNEWVEC (ctf_id_t, len);\n+\n+  btf_id_map[0] = BTF_VOID_TYPEID;\n+  for (size_t i = 1; i < len; i++)\n+    btf_id_map[i] = BTF_INVALID_TYPEID;\n+}\n+\n+/* Return the BTF type ID of CTF type ID KEY, or BTF_INVALID_TYPEID if the CTF\n+   type with ID KEY does not map to a BTF type.  */\n+\n+static inline ctf_id_t\n+get_btf_id (ctf_id_t key)\n+{\n+  return btf_id_map[key];\n+}\n+\n+/* Set the CTF type ID KEY to map to BTF type ID VAL.  */\n+\n+static inline void\n+set_btf_id (ctf_id_t key, ctf_id_t val)\n+{\n+  btf_id_map[key] = val;\n+}\n+\n+/* Return TRUE iff the given CTF type ID maps to a BTF type which will\n+   be emitted.  */\n+static inline bool\n+btf_emit_id_p (ctf_id_t id)\n+{\n+  return ((btf_id_map[id] != BTF_VOID_TYPEID)\n+\t  && (btf_id_map[id] <= BTF_MAX_TYPE));\n+}\n+\n+/* Each BTF type can be followed additional, variable-length information\n+   completing the description of the type. Calculate the number of bytes\n+   of variable information required to encode a given type.  */\n+\n+static uint64_t\n+btf_calc_num_vbytes (ctf_dtdef_ref dtd)\n+{\n+  uint64_t vlen_bytes = 0;\n+\n+  uint32_t kind = get_btf_kind (CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info));\n+  uint32_t vlen = CTF_V2_INFO_VLEN (dtd->dtd_data.ctti_info);\n+\n+  switch (kind)\n+    {\n+    case BTF_KIND_UNKN:\n+    case BTF_KIND_PTR:\n+    case BTF_KIND_FWD:\n+    case BTF_KIND_TYPEDEF:\n+    case BTF_KIND_VOLATILE:\n+    case BTF_KIND_CONST:\n+    case BTF_KIND_RESTRICT:\n+    case BTF_KIND_FUNC:\n+    /* These kinds have no vlen data.  */\n+      break;\n+\n+    case BTF_KIND_INT:\n+      /* Size 0 integers represent redundant definitions of void that will\n+\t not be emitted. Don't allocate space for them.  */\n+      if (dtd->dtd_data.ctti_size == 0)\n+\tbreak;\n+\n+      vlen_bytes += sizeof (uint32_t);\n+      break;\n+\n+    case BTF_KIND_ARRAY:\n+      vlen_bytes += sizeof (struct btf_array);\n+      break;\n+\n+    case BTF_KIND_STRUCT:\n+    case BTF_KIND_UNION:\n+      vlen_bytes += vlen * sizeof (struct btf_member);\n+      break;\n+\n+    case BTF_KIND_ENUM:\n+      vlen_bytes += vlen * sizeof (struct btf_enum);\n+      break;\n+\n+    case BTF_KIND_FUNC_PROTO:\n+      vlen_bytes += vlen * sizeof (struct btf_param);\n+      break;\n+\n+    case BTF_KIND_VAR:\n+      vlen_bytes += sizeof (struct btf_var);\n+      break;\n+\n+    case BTF_KIND_DATASEC:\n+      vlen_bytes += vlen * sizeof (struct btf_var_secinfo);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return vlen_bytes;\n+}\n+\n+/* Initialize BTF section (.BTF) for output.  */\n+\n+void\n+init_btf_sections (void)\n+{\n+  btf_info_section = get_section (BTF_INFO_SECTION_NAME, BTF_INFO_SECTION_FLAGS,\n+\t\t\t\t  NULL);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (btf_info_section_label,\n+\t\t\t       BTF_INFO_SECTION_LABEL, btf_label_num++);\n+}\n+\n+/* Push a BTF datasec variable entry INFO into the datasec named SECNAME,\n+   creating the datasec if it does not already exist.  */\n+\n+static void\n+btf_datasec_push_entry (ctf_container_ref ctfc, const char *secname,\n+\t\t\tstruct btf_var_secinfo info)\n+{\n+  if (secname == NULL)\n+    return;\n+\n+  for (size_t i = 0; i < datasecs.length (); i++)\n+    if (strcmp (datasecs[i].name, secname) == 0)\n+      {\n+\tdatasecs[i].entries.safe_push (info);\n+\treturn;\n+      }\n+\n+  /* If we don't already have a datasec record for secname, make one.  */\n+\n+  uint32_t str_off;\n+  ctf_add_string (ctfc, secname, &str_off, CTF_AUX_STRTAB);\n+  if (strcmp (secname, \"\"))\n+    ctfc->ctfc_aux_strlen += strlen (secname) + 1;\n+\n+  btf_datasec_t ds;\n+  ds.name = secname;\n+  ds.name_offset = str_off;\n+\n+  ds.entries.create (0);\n+  ds.entries.safe_push (info);\n+\n+  datasecs.safe_push (ds);\n+  num_types_created++;\n+}\n+\n+/* Construct all BTF_KIND_DATASEC records for CTFC. One such record is created\n+   for each non-empty data-containing section in the output. Each record is\n+   followed by a variable number of entries describing the variables stored\n+   in that section.  */\n+\n+static void\n+btf_collect_datasec (ctf_container_ref ctfc)\n+{\n+  /* See cgraph.h struct symtab_node, which varpool_node extends.  */\n+  varpool_node *node;\n+  FOR_EACH_VARIABLE (node)\n+    {\n+      dw_die_ref die = lookup_decl_die (node->decl);\n+      if (die == NULL)\n+\tcontinue;\n+\n+      ctf_dvdef_ref dvd = ctf_dvd_lookup (ctfc, die);\n+      if (dvd == NULL)\n+\tcontinue;\n+\n+      const char *section_name = node->get_section ();\n+\n+      if (section_name == NULL)\n+\t{\n+\t  switch (categorize_decl_for_section (node->decl, 0))\n+\t    {\n+\t    case SECCAT_BSS:\n+\t      section_name = \".bss\";\n+\t      break;\n+\t    case SECCAT_DATA:\n+\t      section_name = \".data\";\n+\t      break;\n+\t    case SECCAT_RODATA:\n+\t      section_name = \".rodata\";\n+\t      break;\n+\t    default:\n+\t      continue;\n+\t    }\n+\t}\n+\n+      struct btf_var_secinfo info;\n+\n+      info.type = 0;\n+      unsigned int *var_id = btf_var_ids->get (dvd);\n+      if (var_id)\n+\t/* +1 for the sentinel type not in the types map.  */\n+\tinfo.type = *var_id + num_types_added + 1;\n+      else\n+\tcontinue;\n+\n+      info.size = 0;\n+      tree size = DECL_SIZE_UNIT (node->decl);\n+      if (tree_fits_uhwi_p (size))\n+\tinfo.size = tree_to_uhwi (size);\n+\n+      /* Offset is left as 0 at compile time, to be filled in by loaders such\n+\t as libbpf.  */\n+      info.offset = 0;\n+\n+      btf_datasec_push_entry (ctfc, section_name, info);\n+    }\n+}\n+\n+/* Return true if the type ID is that of a type which will not be emitted (for\n+   example, if it is not representable in BTF).  */\n+\n+static bool\n+btf_removed_type_p (ctf_id_t id)\n+{\n+  return holes.contains (id);\n+}\n+\n+/* Adjust the given type ID to account for holes and duplicate definitions of\n+   void.  */\n+\n+static ctf_id_t\n+btf_adjust_type_id (ctf_id_t id)\n+{\n+  size_t n;\n+  ctf_id_t i = 0;\n+\n+  /* Do not adjust invalid type markers.  */\n+  if (id == BTF_INVALID_TYPEID)\n+    return id;\n+\n+  for (n = 0; n < voids.length (); n++)\n+    if (id == voids[n])\n+      return BTF_VOID_TYPEID;\n+\n+  for (n = 0; n < holes.length (); n++)\n+    {\n+      if (holes[n] < id)\n+\ti++;\n+      else if (holes[n] == id)\n+\treturn BTF_VOID_TYPEID;\n+    }\n+\n+  return id - i;\n+}\n+\n+/* Postprocessing callback routine for types.  */\n+\n+int\n+btf_dtd_postprocess_cb (ctf_dtdef_ref *slot, ctf_container_ref arg_ctfc)\n+{\n+  ctf_dtdef_ref ctftype = (ctf_dtdef_ref) * slot;\n+\n+  size_t index = ctftype->dtd_type;\n+  gcc_assert (index <= arg_ctfc->ctfc_types->elements ());\n+\n+  uint32_t ctf_kind, btf_kind;\n+\n+  ctf_kind = CTF_V2_INFO_KIND (ctftype->dtd_data.ctti_info);\n+  btf_kind = get_btf_kind (ctf_kind);\n+\n+  if (btf_kind == BTF_KIND_UNKN)\n+    /* This type is not representable in BTF. Create a hole.  */\n+    holes.safe_push (ctftype->dtd_type);\n+\n+  else if (btf_kind == BTF_KIND_INT && ctftype->dtd_data.ctti_size == 0)\n+    {\n+      /* This is a (redundant) definition of void.  */\n+      voids.safe_push (ctftype->dtd_type);\n+      holes.safe_push (ctftype->dtd_type);\n+    }\n+\n+  arg_ctfc->ctfc_types_list[index] = ctftype;\n+\n+  return 1;\n+}\n+\n+/* Preprocessing callback routine for variables.  */\n+\n+int\n+btf_dvd_emit_preprocess_cb (ctf_dvdef_ref *slot, ctf_container_ref arg_ctfc)\n+{\n+  ctf_dvdef_ref var = (ctf_dvdef_ref) * slot;\n+\n+  /* Do not add variables which refer to unsupported types.  */\n+  if (btf_removed_type_p (var->dvd_type))\n+    return 1;\n+\n+  arg_ctfc->ctfc_vars_list[num_vars_added] = var;\n+  btf_var_ids->put (var, num_vars_added);\n+\n+  num_vars_added++;\n+  num_types_created++;\n+\n+  return 1;\n+}\n+\n+/* Preprocessing callback routine for types.  */\n+\n+static void\n+btf_dtd_emit_preprocess_cb (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n+{\n+  if (!btf_emit_id_p (dtd->dtd_type))\n+    return;\n+\n+  uint32_t btf_kind\n+    = get_btf_kind (CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info));\n+\n+  if (btf_kind == BTF_KIND_FUNC_PROTO)\n+    {\n+      /* Functions actually get two types: a BTF_KIND_FUNC_PROTO, and\n+\t also a BTF_KIND_FUNC. But the CTF container only allocates one\n+\t type per function, which matches closely with BTF_KIND_FUNC_PROTO.\n+\t For each such function, also allocate a BTF_KIND_FUNC entry.\n+\t These will be output later.  */\n+      ctf_dtdef_ref func_dtd = ggc_cleared_alloc<ctf_dtdef_t> ();\n+      func_dtd->dtd_data = dtd->dtd_data;\n+      func_dtd->dtd_data.ctti_type = dtd->dtd_type;\n+\n+      vec_safe_push (funcs, func_dtd);\n+      num_types_created++;\n+\n+      /* Only the BTF_KIND_FUNC type actually references the name. The\n+\t BTF_KIND_FUNC_PROTO is always anonymous.  */\n+      dtd->dtd_data.ctti_name = 0;\n+    }\n+\n+  ctfc->ctfc_num_vlen_bytes += btf_calc_num_vbytes (dtd);\n+}\n+\n+/* Preprocess the CTF information to prepare for BTF output.  BTF is almost a\n+   subset of CTF, with many small differences in encoding, and lacking support\n+   for some types (notably floating point formats).\n+\n+   During the preprocessing pass:\n+   - Ascertain that the sorted list of types has been prepared.  For the BTF\n+     generation process, this is taken care of by the btf_init_postprocess ().\n+\n+   - BTF_KIND_FUNC and BTF_KIND_DATASEC records are constructed. These types do\n+     not have analogues in CTF (the analogous type to CTF_K_FUNCTION is\n+     BTF_KIND_FUNC_PROTO), but can be relatively easily deduced from CTF\n+     information.\n+\n+   - Construct BTF_KIND_VAR records, representing variables.\n+\n+   - Calculate the total size in bytes of variable-length information following\n+     BTF type records. This is used for outputting the BTF header.\n+\n+   After preprocessing, all BTF information is ready to be output:\n+   - ctfc->ctfc_types_list holdstypes converted from CTF types. This does not\n+     include KIND_VAR, KIND_FUNC, nor KIND_DATASEC types. These types have been\n+     re-encoded to the appropriate representation in BTF.\n+   - ctfc->ctfc_vars_list holds all variables which should be output.\n+     Variables of unsupported types are not present in this list.\n+   - Vector 'funcs' holds all BTF_KIND_FUNC types, one to match each\n+     BTF_KIND_FUNC_PROTO.\n+   - Vector 'datasecs' holds all BTF_KIND_DATASEC types.  */\n+\n+static void\n+btf_emit_preprocess (ctf_container_ref ctfc)\n+{\n+  size_t num_ctf_types = ctfc->ctfc_types->elements ();\n+  size_t num_ctf_vars = ctfc->ctfc_vars->elements ();\n+  size_t i;\n+\n+  if (num_ctf_types)\n+    {\n+      gcc_assert (ctfc->ctfc_types_list);\n+      /* Preprocess the types.  */\n+      for (i = 1; i <= num_ctf_types; i++)\n+\tbtf_dtd_emit_preprocess_cb (ctfc, ctfc->ctfc_types_list[i]);\n+    }\n+\n+  btf_var_ids = hash_map<ctf_dvdef_ref, unsigned int>::create_ggc (100);\n+\n+  if (num_ctf_vars)\n+    {\n+      /* Allocate and construct the list of variables. While BTF variables are\n+\t not distinct from types (in that variables are simply types with\n+\t BTF_KIND_VAR), it is simpler to maintain a separate list of variables\n+\t and append them to the types list during output.  */\n+      ctfc->ctfc_vars_list = ggc_vec_alloc<ctf_dvdef_ref>(num_ctf_vars);\n+      ctfc->ctfc_vars->traverse<ctf_container_ref, btf_dvd_emit_preprocess_cb>\n+\t(ctfc);\n+\n+      ctfc->ctfc_num_vlen_bytes += (num_vars_added * sizeof (struct btf_var));\n+    }\n+\n+  btf_collect_datasec (ctfc);\n+}\n+\n+/* Return true iff DMD is a member description of a bit-field which can be\n+   validly represented in BTF.  */\n+\n+static bool\n+btf_dmd_representable_bitfield_p (ctf_container_ref ctfc, ctf_dmdef_t *dmd)\n+{\n+  ctf_dtdef_ref ref_type = ctfc->ctfc_types_list[dmd->dmd_type];\n+\n+  if (CTF_V2_INFO_KIND (ref_type->dtd_data.ctti_info) == CTF_K_SLICE)\n+    {\n+      unsigned short word_offset = ref_type->dtd_u.dtu_slice.cts_offset;\n+      unsigned short bits = ref_type->dtd_u.dtu_slice.cts_bits;\n+      uint64_t sou_offset = dmd->dmd_offset;\n+\n+      if ((bits > 0xff) || ((sou_offset + word_offset) > 0xffffff))\n+\treturn false;\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* BTF asm helper routines.  */\n+\n+/* Asm'out a BTF type. This routine is responsible for the bulk of the task\n+   of converting CTF types to their BTF representation.  */\n+\n+static void\n+btf_asm_type (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n+{\n+  uint32_t btf_kind, btf_kflag, btf_vlen, btf_size_type;\n+  uint32_t ctf_info = dtd->dtd_data.ctti_info;\n+\n+  btf_kind = get_btf_kind (CTF_V2_INFO_KIND (ctf_info));\n+  btf_size_type = dtd->dtd_data.ctti_type;\n+  btf_vlen = CTF_V2_INFO_VLEN (ctf_info);\n+\n+  /* By now any unrepresentable types have been removed.  */\n+  gcc_assert (btf_kind != BTF_KIND_UNKN);\n+\n+  /* Size 0 integers are redundant definitions of void. None should remain\n+     in the types list by this point.  */\n+  gcc_assert (btf_kind != BTF_KIND_INT || btf_size_type >= 1);\n+\n+  /* Re-encode the ctti_info to BTF.  */\n+  /* kflag is 1 for structs/unions with a bitfield member.\n+     kflag is 1 for forwards to unions.\n+     kflag is 0 in all other cases.  */\n+  btf_kflag = 0;\n+\n+  if (btf_kind == BTF_KIND_STRUCT || btf_kind == BTF_KIND_UNION)\n+    {\n+      /* If a struct/union has ANY bitfield members, set kflag=1.\n+\t Note that we must also change the encoding of every member to encode\n+\t both member bitfield size (stealing most-significant 8 bits) and bit\n+\t offset (LS 24 bits). This is done during preprocessing.  */\n+      ctf_dmdef_t *dmd;\n+      for (dmd = dtd->dtd_u.dtu_members;\n+\t   dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+\t{\n+\t  /* Set kflag if this member is a representable bitfield.  */\n+\t  if (btf_dmd_representable_bitfield_p (ctfc, dmd))\n+\t    btf_kflag = 1;\n+\n+\t  /* Struct members that refer to unsupported types or bitfield formats\n+\t     shall be skipped. These are marked during preprocessing.  */\n+\t  else if (!btf_emit_id_p (dmd->dmd_type))\n+\t    btf_vlen -= 1;\n+\t}\n+    }\n+\n+  /* BTF forwards make use of KIND_FLAG to distinguish between forwards to\n+     structs and forwards to unions. The dwarf2ctf conversion process stores\n+     the kind of the forward in ctti_type, but for BTF this must be 0 for\n+     forwards, with only the KIND_FLAG to distinguish.\n+     At time of writing, BTF forwards to enums are unspecified.  */\n+  if (btf_kind == BTF_KIND_FWD)\n+    {\n+      if (dtd->dtd_data.ctti_type == CTF_K_UNION)\n+\tbtf_kflag = 1;\n+\n+      btf_size_type = 0;\n+    }\n+\n+  dw2_asm_output_data (4, dtd->dtd_data.ctti_name, \"btt_name\");\n+  dw2_asm_output_data (4, BTF_TYPE_INFO (btf_kind, btf_kflag, btf_vlen),\n+\t\t       \"btt_info: kind=%u, kflag=%u, vlen=%u\",\n+\t\t       btf_kind, btf_kflag, btf_vlen);\n+  switch (btf_kind)\n+    {\n+    case BTF_KIND_INT:\n+    case BTF_KIND_STRUCT:\n+    case BTF_KIND_UNION:\n+    case BTF_KIND_ENUM:\n+    case BTF_KIND_DATASEC:\n+      dw2_asm_output_data (4, dtd->dtd_data.ctti_size, \"btt_size: %uB\",\n+\t\t\t   dtd->dtd_data.ctti_size);\n+      return;\n+    default:\n+      break;\n+    }\n+\n+  dw2_asm_output_data (4, get_btf_id (dtd->dtd_data.ctti_type), \"btt_type\");\n+}\n+\n+/* Asm'out the variable information following a BTF_KIND_ARRAY.  */\n+\n+static void\n+btf_asm_array (ctf_dtdef_ref dtd)\n+{\n+  dw2_asm_output_data (4, get_btf_id (dtd->dtd_u.dtu_arr.ctr_contents),\n+\t\t       \"bta_contents\");\n+  dw2_asm_output_data (4, get_btf_id (dtd->dtd_u.dtu_arr.ctr_index),\n+\t\t       \"bta_index\");\n+  dw2_asm_output_data (4, dtd->dtd_u.dtu_arr.ctr_nelems, \"bta_nelems\");\n+}\n+\n+/* Asm'out a BTF_KIND_VAR.  */\n+\n+static void\n+btf_asm_varent (ctf_dvdef_ref var)\n+{\n+  dw2_asm_output_data (4, var->dvd_name_offset, \"btv_name\");\n+  dw2_asm_output_data (4, BTF_TYPE_INFO (BTF_KIND_VAR, 0, 0), \"btv_info\");\n+  dw2_asm_output_data (4, get_btf_id (var->dvd_type), \"btv_type\");\n+  dw2_asm_output_data (4, (var->dvd_visibility ? 1 : 0), \"btv_linkage\");\n+}\n+\n+/* Asm'out a member description following a BTF_KIND_STRUCT or\n+   BTF_KIND_UNION.  */\n+\n+static void\n+btf_asm_sou_member (ctf_container_ref ctfc, ctf_dmdef_t * dmd)\n+{\n+  ctf_dtdef_ref ref_type = ctfc->ctfc_types_list[dmd->dmd_type];\n+\n+  /* Re-encode bitfields to BTF representation.  */\n+  if (CTF_V2_INFO_KIND (ref_type->dtd_data.ctti_info) == CTF_K_SLICE)\n+    {\n+      ctf_id_t base_type = ref_type->dtd_u.dtu_slice.cts_type;\n+      unsigned short word_offset = ref_type->dtd_u.dtu_slice.cts_offset;\n+      unsigned short bits = ref_type->dtd_u.dtu_slice.cts_bits;\n+      uint64_t sou_offset = dmd->dmd_offset;\n+\n+      /* Pack the bit offset and bitfield size together.  */\n+      sou_offset += word_offset;\n+\n+      /* If this bitfield cannot be represented, do not output anything.\n+\t The parent struct/union 'vlen' field has already been updated.  */\n+      if ((bits > 0xff) || (sou_offset > 0xffffff))\n+\treturn;\n+\n+      sou_offset &= 0x00ffffff;\n+      sou_offset |= ((bits & 0xff) << 24);\n+\n+      /* Refer to the base type of the slice.  */\n+      dw2_asm_output_data (4, dmd->dmd_name_offset, \"btm_name_off\");\n+      dw2_asm_output_data (4, get_btf_id (base_type), \"btm_type\");\n+      dw2_asm_output_data (4, sou_offset, \"btm_offset\");\n+    }\n+  else\n+    {\n+      dw2_asm_output_data (4, dmd->dmd_name_offset, \"btm_name_off\");\n+      dw2_asm_output_data (4, get_btf_id (dmd->dmd_type), \"btm_type\");\n+      dw2_asm_output_data (4, dmd->dmd_offset, \"btm_offset\");\n+    }\n+}\n+\n+/* Asm'out an enum constant following a BTF_KIND_ENUM.  */\n+\n+static void\n+btf_asm_enum_const (ctf_dmdef_t * dmd)\n+{\n+  dw2_asm_output_data (4, dmd->dmd_name_offset, \"bte_name\");\n+  dw2_asm_output_data (4, dmd->dmd_value, \"bte_value\");\n+}\n+\n+/* Asm'out a function parameter description following a BTF_KIND_FUNC_PROTO.  */\n+\n+static void\n+btf_asm_func_arg (ctf_func_arg_t * farg, size_t stroffset)\n+{\n+  /* If the function arg does not have a name, refer to the null string at\n+     the start of the string table. This ensures correct encoding for varargs\n+     '...' arguments.  */\n+  if ((farg->farg_name != NULL) && strcmp (farg->farg_name, \"\"))\n+    dw2_asm_output_data (4, farg->farg_name_offset + stroffset, \"farg_name\");\n+  else\n+    dw2_asm_output_data (4, 0, \"farg_name\");\n+\n+  dw2_asm_output_data (4, (btf_removed_type_p (farg->farg_type)\n+\t\t\t   ? BTF_VOID_TYPEID\n+\t\t\t   : get_btf_id (farg->farg_type)),\n+\t\t       \"farg_type\");\n+}\n+\n+/* Asm'out a BTF_KIND_FUNC type.  */\n+\n+static void\n+btf_asm_func_type (ctf_dtdef_ref dtd)\n+{\n+  dw2_asm_output_data (4, dtd->dtd_data.ctti_name, \"btt_name\");\n+  dw2_asm_output_data (4, BTF_TYPE_INFO (BTF_KIND_FUNC, 0, 0), \"btt_info\");\n+  dw2_asm_output_data (4, get_btf_id (dtd->dtd_data.ctti_type), \"btt_type\");\n+}\n+\n+/* Asm'out a variable entry following a BTF_KIND_DATASEC.  */\n+\n+static void\n+btf_asm_datasec_entry (struct btf_var_secinfo info)\n+{\n+  dw2_asm_output_data (4, info.type, \"bts_type\");\n+  dw2_asm_output_data (4, info.offset, \"bts_offset\");\n+  dw2_asm_output_data (4, info.size, \"bts_size\");\n+}\n+\n+/* Asm'out a whole BTF_KIND_DATASEC, including its variable entries.  */\n+\n+static void\n+btf_asm_datasec_type (btf_datasec_t ds, size_t stroffset)\n+{\n+  dw2_asm_output_data (4, ds.name_offset + stroffset, \"btt_name\");\n+  dw2_asm_output_data (4, BTF_TYPE_INFO (BTF_KIND_DATASEC, 0,\n+\t\t\t\t\t ds.entries.length ()),\n+\t\t       \"btt_info\");\n+  /* Note: the \"total section size in bytes\" is emitted as 0 and patched by\n+     loaders such as libbpf.  */\n+  dw2_asm_output_data (4, 0, \"btt_size\");\n+  for (size_t i = 0; i < ds.entries.length (); i++)\n+    btf_asm_datasec_entry (ds.entries[i]);\n+}\n+\n+/* Compute and output the header information for a .BTF section.  */\n+\n+static void\n+output_btf_header (ctf_container_ref ctfc)\n+{\n+   switch_to_section (btf_info_section);\n+   ASM_OUTPUT_LABEL (asm_out_file, btf_info_section_label);\n+\n+   /* BTF magic number, version, flags, and header length.  */\n+   dw2_asm_output_data (2, BTF_MAGIC, \"btf_magic\");\n+   dw2_asm_output_data (1, BTF_VERSION, \"btf_version\");\n+   dw2_asm_output_data (1, 0, \"btf_flags\");\n+   dw2_asm_output_data (4, sizeof (struct btf_header), \"btf_hdr_len\");\n+\n+   uint32_t type_off = 0, type_len = 0;\n+   uint32_t str_off = 0, str_len = 0;\n+   uint32_t datasec_vlen_bytes = 0;\n+\n+   if (!ctfc_is_empty_container (ctfc))\n+     {\n+       for (size_t i = 0; i < datasecs.length (); i++)\n+\t {\n+\t   datasec_vlen_bytes += ((datasecs[i].entries.length ())\n+\t\t\t\t  * sizeof (struct btf_var_secinfo));\n+\t }\n+\n+       /* Total length (bytes) of the types section.  */\n+       type_len = (num_types_added * sizeof (struct btf_type))\n+\t + (num_types_created * sizeof (struct btf_type))\n+\t + datasec_vlen_bytes\n+\t + ctfc->ctfc_num_vlen_bytes;\n+\n+       str_off = type_off + type_len;\n+\n+       str_len = ctfc->ctfc_strtable.ctstab_len\n+\t + ctfc->ctfc_aux_strtable.ctstab_len;\n+     }\n+\n+   /* Offset of type section.  */\n+   dw2_asm_output_data (4, type_off, \"type_off\");\n+   /* Length of type section in bytes.  */\n+   dw2_asm_output_data (4, type_len, \"type_len\");\n+    /* Offset of string section.  */\n+   dw2_asm_output_data (4, str_off, \"str_off\");\n+    /* Length of string section in bytes.  */\n+   dw2_asm_output_data (4, str_len, \"str_len\");\n+}\n+\n+/* Output all BTF_KIND_VARs in CTFC.  */\n+\n+static void\n+output_btf_vars (ctf_container_ref ctfc)\n+{\n+  size_t i;\n+  size_t num_ctf_vars = num_vars_added;\n+  if (num_ctf_vars)\n+    {\n+      for (i = 0; i < num_ctf_vars; i++)\n+\tbtf_asm_varent (ctfc->ctfc_vars_list[i]);\n+    }\n+}\n+\n+/* Output BTF string records. The BTF strings section is a concatenation\n+   of the standard and auxilliary string tables in the ctf container.  */\n+\n+static void\n+output_btf_strs (ctf_container_ref ctfc)\n+{\n+  ctf_string_t * ctf_string = ctfc->ctfc_strtable.ctstab_head;\n+\n+  while (ctf_string)\n+    {\n+      dw2_asm_output_nstring (ctf_string->cts_str, -1, \"btf_string\");\n+      ctf_string = ctf_string->cts_next;\n+    }\n+\n+  ctf_string = ctfc->ctfc_aux_strtable.ctstab_head;\n+  while (ctf_string)\n+    {\n+      dw2_asm_output_nstring (ctf_string->cts_str, -1, \"btf_aux_string\");\n+      ctf_string = ctf_string->cts_next;\n+    }\n+}\n+\n+/* Output all (representable) members of a BTF_KIND_STRUCT or\n+   BTF_KIND_UNION type.  */\n+\n+static void\n+output_asm_btf_sou_fields (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n+{\n+  ctf_dmdef_t * dmd;\n+\n+  for (dmd = dtd->dtd_u.dtu_members;\n+       dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+      btf_asm_sou_member (ctfc, dmd);\n+}\n+\n+/* Output all enumerator constants following a BTF_KIND_ENUM.  */\n+\n+static void\n+output_asm_btf_enum_list (ctf_container_ref ARG_UNUSED (ctfc),\n+\t\t\t  ctf_dtdef_ref dtd)\n+{\n+  ctf_dmdef_t * dmd;\n+\n+  for (dmd = dtd->dtd_u.dtu_members;\n+       dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+    btf_asm_enum_const (dmd);\n+}\n+\n+/* Output all function arguments following a BTF_KIND_FUNC_PROTO.  */\n+\n+static void\n+output_asm_btf_func_args_list (ctf_container_ref ctfc,\n+\t\t\t       ctf_dtdef_ref dtd)\n+{\n+  size_t farg_name_offset = ctfc_get_strtab_len (ctfc, CTF_STRTAB);\n+  ctf_func_arg_t * farg;\n+  for (farg = dtd->dtd_u.dtu_argv;\n+       farg != NULL; farg = (ctf_func_arg_t *) ctf_farg_list_next (farg))\n+    btf_asm_func_arg (farg, farg_name_offset);\n+}\n+\n+/* Output the variable portion of a BTF type record. The information depends\n+   on the kind of the type.  */\n+\n+static void\n+output_asm_btf_vlen_bytes (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n+{\n+  uint32_t btf_kind, encoding;\n+\n+  btf_kind = get_btf_kind (CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info));\n+\n+  if (btf_kind == BTF_KIND_UNKN)\n+    return;\n+\n+  switch (btf_kind)\n+    {\n+    case BTF_KIND_INT:\n+      /* Redundant definitions of void may still be hanging around in the type\n+\t list as size 0 integers. Skip emitting them.  */\n+      if (dtd->dtd_data.ctti_size < 1)\n+\tbreak;\n+\n+      encoding = BTF_INT_DATA (dtd->dtd_u.dtu_enc.cte_format,\n+\t\t\t       dtd->dtd_u.dtu_enc.cte_offset,\n+\t\t\t       dtd->dtd_u.dtu_enc.cte_bits);\n+\n+      dw2_asm_output_data (4, encoding, \"bti_encoding\");\n+      break;\n+\n+    case BTF_KIND_ARRAY:\n+      btf_asm_array (dtd);\n+      break;\n+\n+    case BTF_KIND_STRUCT:\n+    case BTF_KIND_UNION:\n+      output_asm_btf_sou_fields (ctfc, dtd);\n+      break;\n+\n+    case BTF_KIND_ENUM:\n+      output_asm_btf_enum_list (ctfc, dtd);\n+      break;\n+\n+    case BTF_KIND_FUNC_PROTO:\n+      output_asm_btf_func_args_list (ctfc, dtd);\n+      break;\n+\n+    case BTF_KIND_VAR:\n+      /* BTF Variables are handled by output_btf_vars and btf_asm_varent.\n+\t There should be no BTF_KIND_VAR types at this point.  */\n+      gcc_unreachable ();\n+\n+    case BTF_KIND_DATASEC:\n+      /* The BTF_KIND_DATASEC records are handled by output_btf_datasec_types\n+\t and btf_asm_datasec_type. There should be no BTF_KIND_DATASEC types\n+\t at this point.  */\n+      gcc_unreachable ();\n+\n+    default:\n+      /* All other BTF type kinds have no variable length data.  */\n+      break;\n+    }\n+}\n+\n+/* Output a whole BTF type record for TYPE, including the fixed and variable\n+   data portions.  */\n+\n+static void\n+output_asm_btf_type (ctf_container_ref ctfc, ctf_dtdef_ref type)\n+{\n+  if (btf_emit_id_p (type->dtd_type))\n+    {\n+      btf_asm_type (ctfc, type);\n+      output_asm_btf_vlen_bytes (ctfc, type);\n+    }\n+}\n+\n+/* Output all BTF types in the container. This does not include synthesized\n+   types: BTF_KIND_VAR, BTF_KIND_FUNC, nor BTF_KIND_DATASEC.  */\n+\n+static void\n+output_btf_types (ctf_container_ref ctfc)\n+{\n+  size_t i;\n+  size_t num_types = ctfc->ctfc_types->elements ();\n+  if (num_types)\n+    {\n+      for (i = 1; i <= num_types; i++)\n+\toutput_asm_btf_type (ctfc, ctfc->ctfc_types_list[i]);\n+    }\n+}\n+\n+/* Output all BTF_KIND_FUNC type records.  */\n+\n+static void\n+output_btf_func_types (void)\n+{\n+  for (size_t i = 0; i < vec_safe_length (funcs); i++)\n+    btf_asm_func_type ((*funcs)[i]);\n+}\n+\n+/* Output all BTF_KIND_DATASEC records.  */\n+\n+static void\n+output_btf_datasec_types (ctf_container_ref ctfc)\n+{\n+  size_t name_offset = ctfc_get_strtab_len (ctfc, CTF_STRTAB);\n+\n+  for (size_t i = 0; i < datasecs.length(); i++)\n+    btf_asm_datasec_type (datasecs[i], name_offset);\n+}\n+\n+/* Postprocess the CTF debug data post initialization.\n+\n+   During the postprocess pass:\n+\n+   - Prepare the sorted list of BTF types.\n+\n+     The sorted list of BTF types is, firstly, used for lookup (during the BTF\n+     generation process) of CTF/BTF types given a typeID.\n+\n+     Secondly, in the emitted BTF section, BTF Types need to be in the sorted\n+     order of their type IDs.  The BTF types section is viewed as an array,\n+     with type IDs used to index into that array.  It is essential that every\n+     type be placed at the exact index corresponding to its ID, or else\n+     references to that type from other types will no longer be correct.\n+\n+   - References to void types are converted to reference BTF_VOID_TYPEID. In\n+     CTF, a distinct type is used to encode void.\n+\n+   - Bitfield struct/union members are converted to BTF encoding. CTF uses\n+     slices to encode bitfields, but BTF does not have slices and encodes\n+     bitfield information directly in the variable-length btf_member\n+     descriptions following the struct or union type.\n+\n+   - Unrepresentable types are removed. We cannot have any invalid BTF types\n+     appearing in the output so they must be removed, and type ids of other\n+     types and references adjust accordingly. This also involves ensuring that\n+     BTF descriptions of struct members referring to unrepresentable types are\n+     not emitted, as they would be nonsensical.\n+\n+   - Adjust inner- and inter-type references-by-ID to account for removed\n+     types, and construct the types list.  */\n+\n+void\n+btf_init_postprocess (void)\n+{\n+  ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n+\n+  size_t i;\n+  size_t num_ctf_types = tu_ctfc->ctfc_types->elements ();\n+\n+  holes.create (0);\n+  voids.create (0);\n+\n+  num_types_added = 0;\n+  num_types_created = 0;\n+\n+  if (num_ctf_types)\n+    {\n+      init_btf_id_map (num_ctf_types + 1);\n+\n+      /* Allocate the types list and traverse all types, placing each type\n+\t at the index according to its ID.  Add 1 because type ID 0 always\n+\t represents VOID.  */\n+      tu_ctfc->ctfc_types_list\n+\t= ggc_vec_alloc<ctf_dtdef_ref>(num_ctf_types + 1);\n+      tu_ctfc->ctfc_types->traverse<ctf_container_ref, btf_dtd_postprocess_cb>\n+\t(tu_ctfc);\n+\n+      /* Build mapping of CTF type ID -> BTF type ID, and count total number\n+\t of valid BTF types added.  */\n+      for (i = 1; i <= num_ctf_types; i++)\n+\t{\n+\t  ctf_dtdef_ref dtd = tu_ctfc->ctfc_types_list[i];\n+\t  ctf_id_t btfid = btf_adjust_type_id (dtd->dtd_type);\n+\t  set_btf_id (dtd->dtd_type, btfid);\n+\t  if (btfid < BTF_MAX_TYPE && (btfid != BTF_VOID_TYPEID))\n+\t    num_types_added ++;\n+\t}\n+    }\n+}\n+\n+/* Process and output all BTF data. Entry point of btfout.  */\n+\n+void\n+btf_output (const char * filename)\n+{\n+  ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n+\n+  init_btf_sections ();\n+\n+  datasecs.create (0);\n+  vec_alloc (funcs, 16);\n+\n+  ctf_add_cuname (tu_ctfc, filename);\n+\n+  btf_emit_preprocess (tu_ctfc);\n+\n+  output_btf_header (tu_ctfc);\n+  output_btf_types (tu_ctfc);\n+  output_btf_vars (tu_ctfc);\n+  output_btf_func_types ();\n+  output_btf_datasec_types (tu_ctfc);\n+  output_btf_strs (tu_ctfc);\n+}\n+\n+/* Reset all state for BTF generation so that we can rerun the compiler within\n+   the same process.  */\n+\n+void\n+btf_finalize (void)\n+{\n+  btf_info_section = NULL;\n+\n+  /* Clear preprocessing state.  */\n+  num_vars_added = 0;\n+  num_types_added = 0;\n+  num_types_created = 0;\n+\n+  holes.release ();\n+  voids.release ();\n+  for (size_t i = 0; i < datasecs.length (); i++)\n+    datasecs[i].entries.release ();\n+  datasecs.release ();\n+\n+  funcs = NULL;\n+\n+  free (btf_id_map);\n+  btf_id_map = NULL;\n+\n+  ggc_free (btf_var_ids);\n+  btf_var_ids = NULL;\n+\n+  ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n+  ctfc_delete_container (tu_ctfc);\n+  tu_ctfc = NULL;\n+}\n+\n+#include \"gt-btfout.h\""}, {"sha": "1dd4456e5770bc8afd8c12e3e6d0533b03d68580", "filename": "gcc/common.opt", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -122,6 +122,11 @@ enum debug_info_levels debug_info_level = DINFO_LEVEL_NONE\n Variable\n bool use_gnu_debug_info_extensions\n \n+; Level of CTF debugging information we are producing.  See flag-types.h\n+; for the definitions of the different possible levels.\n+Variable\n+enum ctf_debug_info_levels ctf_debug_info_level = CTFINFO_LEVEL_NONE\n+\n ; Original value of maximum field alignment in bytes, specified via\n ; -fpack-struct=<value>.\n Variable\n@@ -3183,6 +3188,16 @@ gcolumn-info\n Common Driver Var(debug_column_info,1) Init(1)\n Record DW_AT_decl_column and DW_AT_call_column in DWARF.\n \n+; The CTF generation process feeds off DWARF dies.  This option implicitly\n+; updates the debug_info_level to DINFO_LEVEL_NORMAL.\n+gctf\n+Common Driver RejectNegative JoinedOrMissing\n+Generate CTF debug information at default level.\n+\n+gbtf\n+Common Driver RejectNegative JoinedOrMissing\n+Generate BTF debug information at default level.\n+\n gdwarf\n Common Driver JoinedOrMissing Negative(gdwarf-)\n Generate debug information in default version of DWARF format."}, {"sha": "1a6ddb808299654753aeba234d0455ffc881476f", "filename": "gcc/ctfc.c", "status": "added", "additions": 969, "deletions": 0, "changes": 969, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fctfc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fctfc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fctfc.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,969 @@\n+/* Generate CTF.\n+   Copyright (C) 2019,2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"toplev.h\"\n+#include \"ctfc.h\"\n+#include \"diagnostic-core.h\"\n+\n+/* A CTF container object - one per translation unit.  */\n+\n+ctf_container_ref tu_ctfc;\n+\n+ctf_container_ref\n+ctf_get_tu_ctfc (void)\n+{\n+  return tu_ctfc;\n+}\n+\n+/* If the next ctf type id is still set to the init value, no ctf records to\n+   report.  */\n+bool\n+ctfc_is_empty_container (ctf_container_ref ctfc)\n+{\n+  return ((ctfc)->ctfc_nextid == CTF_INIT_TYPEID);\n+}\n+\n+/* Get the total number of CTF types in the container.  */\n+\n+unsigned int\n+ctfc_get_num_ctf_types (ctf_container_ref ctfc)\n+{\n+  return ctfc->ctfc_types->elements ();\n+}\n+\n+/* Get the total number of CTF variables in the container.  */\n+\n+unsigned int ctfc_get_num_ctf_vars (ctf_container_ref ctfc)\n+{\n+  return ctfc->ctfc_vars->elements ();\n+}\n+\n+/* Get reference to the CTF string table or the CTF auxilliary\n+   string table.  */\n+\n+ctf_strtable_t *\n+ctfc_get_strtab (ctf_container_ref ctfc, int aux)\n+{\n+  return aux ? &(ctfc)->ctfc_aux_strtable : &(ctfc->ctfc_strtable);\n+}\n+\n+/* Get the length of the specified string table of the CTF container.  */\n+\n+size_t\n+ctfc_get_strtab_len (ctf_container_ref ctfc, int aux)\n+{\n+  ctf_strtable_t * strtab = ctfc_get_strtab (ctfc, aux);\n+  return strtab->ctstab_len;\n+}\n+\n+/* Get the number of bytes to represent the variable length portion of all CTF\n+   types in the CTF container.  */\n+\n+size_t ctfc_get_num_vlen_bytes (ctf_container_ref ctfc)\n+{\n+  return ctfc->ctfc_num_vlen_bytes;\n+}\n+\n+/* Return which member of the union is used in CTFTYPE.  Used for garbage\n+   collection.  */\n+\n+enum ctf_dtu_d_union_enum\n+ctf_dtu_d_union_selector (ctf_dtdef_ref ctftype)\n+{\n+  uint32_t kind = CTF_V2_INFO_KIND (ctftype->dtd_data.ctti_info);\n+  switch (kind)\n+    {\n+    case CTF_K_UNKNOWN:\n+    case CTF_K_INTEGER:\n+    case CTF_K_FLOAT:\n+      return CTF_DTU_D_ENCODING;\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+    case CTF_K_ENUM:\n+      return CTF_DTU_D_MEMBERS;\n+    case CTF_K_ARRAY:\n+      return CTF_DTU_D_ARRAY;\n+    case CTF_K_FUNCTION:\n+      return CTF_DTU_D_ARGUMENTS;\n+    case CTF_K_SLICE:\n+      return CTF_DTU_D_SLICE;\n+    default:\n+      /* The largest member as default.  */\n+      return CTF_DTU_D_ARRAY;\n+    }\n+}\n+\n+/* Insert CTF type into the CTF container.  */\n+\n+static void\n+ctf_dtd_insert (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n+{\n+  bool existed = false;\n+  ctf_dtdef_ref entry = dtd;\n+\n+  ctf_dtdef_ref * item = ctfc->ctfc_types->find_slot (entry, INSERT);\n+  if (*item == NULL)\n+     *item = dtd;\n+  else\n+    existed = true;\n+  /* Duplicate CTF type records not expected to be inserted.  */\n+  gcc_assert (!existed);\n+}\n+\n+/* Lookup CTF type given a DWARF die for the type.  */\n+\n+static ctf_dtdef_ref\n+ctf_dtd_lookup (const ctf_container_ref ctfc, const dw_die_ref type)\n+{\n+  ctf_dtdef_t entry;\n+  entry.dtd_key = type;\n+\n+  ctf_dtdef_ref * slot = ctfc->ctfc_types->find_slot (&entry, NO_INSERT);\n+\n+  if (slot)\n+    return (ctf_dtdef_ref)*slot;\n+\n+  return NULL;\n+}\n+\n+/* Insert CTF variable into the CTF container.  */\n+\n+static void\n+ctf_dvd_insert (ctf_container_ref ctfc, ctf_dvdef_ref dvd)\n+{\n+  bool existed = false;\n+  ctf_dvdef_ref entry = dvd;\n+\n+  ctf_dvdef_ref * item = ctfc->ctfc_vars->find_slot (entry, INSERT);\n+  if (*item == NULL)\n+     *item = dvd;\n+  else\n+    existed = true;\n+  /* Duplicate variable records not expected to be inserted.  */\n+  gcc_assert (!existed);\n+}\n+\n+/* Lookup CTF variable given a DWARF die for the decl.  */\n+\n+ctf_dvdef_ref\n+ctf_dvd_lookup (const ctf_container_ref ctfc, dw_die_ref die)\n+{\n+  ctf_dvdef_t entry;\n+  entry.dvd_key = die;\n+\n+  ctf_dvdef_ref * slot = ctfc->ctfc_vars->find_slot (&entry, NO_INSERT);\n+\n+  if (slot)\n+    return (ctf_dvdef_ref)*slot;\n+\n+  return NULL;\n+}\n+\n+/* Append member definition to the list.  Member list is a singly-linked list\n+   with list start pointing to the head.  */\n+\n+static void\n+ctf_dmd_list_append (ctf_dmdef_t ** dmd, ctf_dmdef_t * elem)\n+{\n+  ctf_dmdef_t * tail = (dmd && *dmd) ? *dmd : NULL;\n+  if (tail)\n+    {\n+      while (tail->dmd_next)\n+\ttail = tail->dmd_next;\n+\n+      tail->dmd_next = elem;\n+    }\n+  else\n+    *dmd = elem;\n+\n+  elem->dmd_next = NULL;\n+}\n+\n+/* Append function argument to the list.  Member list is a singly-linked list\n+   with list start pointing to the head.  */\n+\n+static void\n+ctf_farg_list_append (ctf_func_arg_t ** farg, ctf_func_arg_t * elem)\n+{\n+  ctf_func_arg_t * tail = (farg && *farg) ? *farg : NULL;\n+  if (tail)\n+    {\n+      while (tail->farg_next)\n+\ttail = tail->farg_next;\n+\n+      tail->farg_next = elem;\n+    }\n+  else\n+    *farg = elem;\n+\n+  elem->farg_next = NULL;\n+}\n+\n+/* Append str to the CTF string table.  */\n+\n+static void\n+ctfc_strtable_append_str (ctf_strtable_t * str_table, const char * str)\n+{\n+  ctf_string_t * ctf_string = ggc_cleared_alloc<ctf_string_t> ();\n+  /* Keep a reference to the input STR.  */\n+  ctf_string->cts_str = str;\n+  ctf_string->cts_next = NULL;\n+\n+  if (!str_table->ctstab_head)\n+    str_table->ctstab_head = ctf_string;\n+\n+  /* Append to the end of the list.  */\n+  if (str_table->ctstab_tail)\n+    str_table->ctstab_tail->cts_next = ctf_string;\n+\n+  str_table->ctstab_tail = ctf_string;\n+}\n+\n+/* Wrapper function to add str to the CTF string table.  No de-duplication of\n+   CTF strings is done by the compiler.  */\n+\n+static const char *\n+ctfc_strtable_add_str (ctf_strtable_t * str_table, const char * name,\n+\t\t      uint32_t * name_offset)\n+{\n+  size_t len;\n+  char * ctf_string;\n+  /* Return value is the offset to the string in the string table.  */\n+  uint32_t str_offset = str_table->ctstab_len;\n+\n+  /* Add empty string only once at the beginning of the string table.  Also, do\n+     not add null strings, return the offset to the empty string for them.  */\n+  if ((!name || (name != NULL && !strcmp (name, \"\"))) && str_offset)\n+    {\n+      ctf_string = CONST_CAST (char *, str_table->ctstab_estr);\n+      str_offset = 0;\n+    }\n+  else\n+    {\n+      gcc_assert (name);\n+      /* Add null-terminated strings to the string table.  */\n+      len = strlen (name) + 1;\n+      ctf_string = CONST_CAST (char *, ggc_strdup (name));\n+\n+      ctfc_strtable_append_str (str_table, ctf_string);\n+      /* Add string to the string table.  Keep number of strings updated.  */\n+      str_table->ctstab_num++;\n+      /* Keep the number of bytes contained in the string table updated.  */\n+      str_table->ctstab_len += len;\n+    }\n+\n+  *name_offset = str_offset;\n+\n+  return (const char *) ctf_string;\n+\n+}\n+\n+/* Add string to the appropriate string table in the CTF container.  */\n+\n+const char *\n+ctf_add_string (ctf_container_ref ctfc, const char * name,\n+\t\tuint32_t * name_offset, int aux_str = CTF_STRTAB)\n+{\n+  /* Get the CTF string table or the CTF auxilliary string table,\n+     as applicable.  */\n+  ctf_strtable_t *str_table = ctfc_get_strtab (ctfc, aux_str);\n+  return ctfc_strtable_add_str (str_table, name, name_offset);\n+}\n+\n+/* Add the compilation unit (CU) name string to the the CTF string table.  The\n+   CU name has a prepended pwd string if it is a relative path.  Also set the\n+   CU name offset in the CTF container.  */\n+\n+void\n+ctf_add_cuname (ctf_container_ref ctfc, const char * filename)\n+{\n+  char * cuname = NULL;\n+\n+  /* (filename at this point of compilation cannot be null).  */\n+\n+  if (!IS_DIR_SEPARATOR (filename[0]))\n+    {\n+      /* Filename is a relative path.  */\n+      const char * cu_pwd = get_src_pwd ();\n+      const int cu_pwd_len = strlen (cu_pwd);\n+\n+      /* Add a DIR_SEPARATOR char before the filename.  */\n+      const int len = cu_pwd_len + 2 + strlen (filename);\n+\n+      cuname = (char *) ggc_alloc_atomic (len);\n+      memset (cuname, 0, len);\n+\n+      strcpy (cuname, cu_pwd);\n+      cuname[cu_pwd_len] = DIR_SEPARATOR;\n+      cuname[cu_pwd_len+1] = 0;\n+      strcat (cuname, filename);\n+    }\n+  else\n+    /* Filename is an absolute path.  */\n+    cuname = CONST_CAST (char *, ggc_strdup (filename));\n+\n+  ctf_add_string (ctfc, cuname, &(ctfc->ctfc_cuname_offset));\n+  /* Add 1 as CTF strings in the CTF string table are null-terminated\n+     strings.  */\n+  ctfc->ctfc_strlen += strlen (cuname) + 1;\n+\n+  /* Mark cuname for garbage collection.  */\n+  cuname = NULL;\n+}\n+\n+/* Functions to create CTF types.\n+\n+   These functions perform the task of adding CTF types to the CTF container.\n+   No de-duplication is done by them; the onus is on the calling function to do\n+   so.  The caller must first do a lookup via ctf_dtd_lookup or\n+   ctf_dvd_lookup, as applicable, to ascertain that the CTF type or the CTF\n+   variable respectively does not already exist, and then add it.  */\n+\n+static ctf_id_t\n+ctf_add_generic (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t\t ctf_dtdef_ref * rp, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+\n+  gcc_assert (flag == CTF_ADD_NONROOT || flag == CTF_ADD_ROOT);\n+\n+  dtd = ggc_cleared_alloc<ctf_dtdef_t> ();\n+\n+  type = ctfc->ctfc_nextid++;\n+  gcc_assert (type < CTF_MAX_TYPE); /* CTF type ID overflow.  */\n+\n+  /* Buffer the strings in the CTF string table.  */\n+  dtd->dtd_name = ctf_add_string (ctfc, name, &(dtd->dtd_data.ctti_name));\n+  dtd->dtd_type = type;\n+  dtd->dtd_key = die;\n+\n+  if ((name != NULL) && strcmp (name, \"\"))\n+    ctfc->ctfc_strlen += strlen (name) + 1;\n+\n+  ctf_dtd_insert (ctfc, dtd);\n+\n+  *rp = dtd;\n+  return type;\n+}\n+\n+static ctf_id_t\n+ctf_add_encoded (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t\t const ctf_encoding_t * ep, uint32_t kind, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+\n+  type = ctf_add_generic (ctfc, flag, name, &dtd, die);\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (kind, flag, 0);\n+\n+  uint32_t roundup_nbytes = (ROUND_UP (ep->cte_bits, BITS_PER_UNIT)\n+\t\t\t\t    / BITS_PER_UNIT);\n+\n+  /* FIXME, stay close to what libctf does.  But by getting next power of two,\n+     aren't we conveying less precise information.  E.g. floating point mode\n+     XF has a size of 12 bytes.  */\n+  dtd->dtd_data.ctti_size = roundup_nbytes ? (1 << ceil_log2 (roundup_nbytes))\n+\t\t\t   : roundup_nbytes;\n+  dtd->dtd_u.dtu_enc = *ep;\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_reftype (ctf_container_ref ctfc, uint32_t flag, ctf_id_t ref,\n+\t\t uint32_t kind, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+\n+  gcc_assert (ref <= CTF_MAX_TYPE);\n+\n+  type = ctf_add_generic (ctfc, flag, NULL, &dtd, die);\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (kind, flag, 0);\n+  /* Caller of this API must guarantee that a CTF type with id = ref already\n+     exists.  This will also be validated for us at link-time.  */\n+  dtd->dtd_data.ctti_type = (uint32_t) ref;\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_forward (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t\t uint32_t kind, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type = 0;\n+\n+  type = ctf_add_generic (ctfc, flag, name, &dtd, die);\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (CTF_K_FORWARD, flag, 0);\n+  dtd->dtd_data.ctti_type = kind;\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_typedef (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t\t ctf_id_t ref, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+\n+  gcc_assert (ref <= CTF_MAX_TYPE);\n+  /* Nameless Typedefs are not expected.  */\n+  gcc_assert ((name != NULL) && strcmp (name, \"\"));\n+\n+  type = ctf_add_generic (ctfc, flag, name, &dtd, die);\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (CTF_K_TYPEDEF, flag, 0);\n+  /* Caller of this API must guarantee that a CTF type with id = ref already\n+     exists.  This will also be validated for us at link-time.  */\n+  dtd->dtd_data.ctti_type = (uint32_t) ref;\n+\n+  gcc_assert (dtd->dtd_type != dtd->dtd_data.ctti_type);\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_slice (ctf_container_ref ctfc, uint32_t flag, ctf_id_t ref,\n+\t       uint32_t bit_offset, uint32_t bit_size, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+  uint32_t roundup_nbytes;\n+\n+  gcc_assert ((bit_size <= 255) && (bit_offset <= 255));\n+\n+  gcc_assert (ref <= CTF_MAX_TYPE);\n+\n+  type = ctf_add_generic (ctfc, flag, NULL, &dtd, die);\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (CTF_K_SLICE, flag, 0);\n+\n+  roundup_nbytes = (ROUND_UP (bit_size, BITS_PER_UNIT) / BITS_PER_UNIT);\n+  /* FIXME, stay close to what libctf does.  But by getting next power of two,\n+     aren't we conveying less precise information, especially for bitfields.\n+     For example, cte_bits = 33, roundup_nbytes = 5, ctti_size = 8 in the\n+     implementation below.  */\n+  dtd->dtd_data.ctti_size = roundup_nbytes ? (1 << ceil_log2 (roundup_nbytes))\n+\t\t\t\t\t   : 0;\n+\n+  /* Caller of this API must guarantee that a CTF type with id = ref already\n+     exists.  This will also be validated for us at link-time.  */\n+  dtd->dtd_u.dtu_slice.cts_type = (uint32_t) ref;\n+  dtd->dtd_u.dtu_slice.cts_bits = bit_size;\n+  dtd->dtd_u.dtu_slice.cts_offset = bit_offset;\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_float (ctf_container_ref ctfc, uint32_t flag,\n+\t       const char * name, const ctf_encoding_t * ep, dw_die_ref die)\n+{\n+  return (ctf_add_encoded (ctfc, flag, name, ep, CTF_K_FLOAT, die));\n+}\n+\n+ctf_id_t\n+ctf_add_integer (ctf_container_ref ctfc, uint32_t flag,\n+\t\t const char * name, const ctf_encoding_t * ep, dw_die_ref die)\n+{\n+  return (ctf_add_encoded (ctfc, flag, name, ep, CTF_K_INTEGER, die));\n+}\n+\n+ctf_id_t\n+ctf_add_unknown (ctf_container_ref ctfc, uint32_t flag,\n+\t\t const char * name, const ctf_encoding_t * ep, dw_die_ref die)\n+{\n+  return (ctf_add_encoded (ctfc, flag, name, ep, CTF_K_UNKNOWN, die));\n+}\n+\n+ctf_id_t\n+ctf_add_pointer (ctf_container_ref ctfc, uint32_t flag, ctf_id_t ref,\n+\t\t dw_die_ref die)\n+{\n+  return (ctf_add_reftype (ctfc, flag, ref, CTF_K_POINTER, die));\n+}\n+\n+ctf_id_t\n+ctf_add_array (ctf_container_ref ctfc, uint32_t flag, const ctf_arinfo_t * arp,\n+\t       dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+\n+  gcc_assert (arp);\n+\n+  /* Caller of this API must make sure CTF type for arp->ctr_contents and\n+     arp->ctr_index are already added.  This will also be validated for us at\n+     link-time.  */\n+\n+  type = ctf_add_generic (ctfc, flag, NULL, &dtd, die);\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (CTF_K_ARRAY, flag, 0);\n+  dtd->dtd_data.ctti_size = 0;\n+  dtd->dtd_u.dtu_arr = *arp;\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_enum (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t      HOST_WIDE_INT size, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+\n+  /* In the compiler, no need to handle the case of promoting forwards to\n+     enums.  This comment is simply to note a divergence from libctf.  */\n+\n+  /* The compiler does, however, update any previously existing forward types\n+     to non-root.  CTF does not allow existence of two root types with the same\n+     name.  */\n+  ctf_dtdef_ref enum_fwd_type = ctf_dtd_lookup (ctfc, die);\n+  if (enum_fwd_type)\n+    {\n+      enum_fwd_type->dtd_data.ctti_info\n+\t= CTF_TYPE_INFO (CTF_K_FORWARD, CTF_ADD_NONROOT, 0);\n+    }\n+\n+  type = ctf_add_generic (ctfc, flag, name, &dtd, die);\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (CTF_K_ENUM, flag, 0);\n+\n+  /* Size in bytes should always fit, of course.\n+     TBD WARN - warn instead?  */\n+  gcc_assert (size <= CTF_MAX_SIZE);\n+\n+  dtd->dtd_data.ctti_size = size;\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+int\n+ctf_add_enumerator (ctf_container_ref ctfc, ctf_id_t enid, const char * name,\n+\t\t    HOST_WIDE_INT value, dw_die_ref die)\n+{\n+  ctf_dmdef_t * dmd;\n+  uint32_t kind, vlen, root;\n+\n+  /* Callers of this API must make sure that CTF_K_ENUM with enid has been\n+     addded.  This will also be validated for us at link-time.  */\n+  ctf_dtdef_ref dtd = ctf_dtd_lookup (ctfc, die);\n+  gcc_assert (dtd);\n+  gcc_assert (dtd->dtd_type == enid);\n+  gcc_assert (name);\n+\n+  kind = CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info);\n+  root = CTF_V2_INFO_ISROOT (dtd->dtd_data.ctti_info);\n+  vlen = CTF_V2_INFO_VLEN (dtd->dtd_data.ctti_info);\n+\n+  gcc_assert (kind == CTF_K_ENUM && vlen < CTF_MAX_VLEN);\n+\n+  /* Enum value is of type HOST_WIDE_INT in the compiler, dmd_value is int32_t\n+     on the other hand.  Check bounds and skip adding this enum value if out of\n+     bounds.  */\n+  if ((value > INT_MAX) || (value < INT_MIN))\n+    {\n+      /* FIXME - Note this TBD_CTF_REPRESENTATION_LIMIT.  */\n+      return (1);\n+    }\n+\n+  dmd = ggc_cleared_alloc<ctf_dmdef_t> ();\n+\n+  /* Buffer the strings in the CTF string table.  */\n+  dmd->dmd_name = ctf_add_string (ctfc, name, &(dmd->dmd_name_offset));\n+  dmd->dmd_type = CTF_NULL_TYPEID;\n+  dmd->dmd_offset = 0;\n+\n+  dmd->dmd_value = value;\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n+  ctf_dmd_list_append (&dtd->dtd_u.dtu_members, dmd);\n+\n+  if ((name != NULL) && strcmp (name, \"\"))\n+    ctfc->ctfc_strlen += strlen (name) + 1;\n+\n+  return (0);\n+}\n+\n+int\n+ctf_add_member_offset (ctf_container_ref ctfc, dw_die_ref sou,\n+\t\t       const char * name, ctf_id_t type,\n+\t\t       uint64_t bit_offset)\n+{\n+  ctf_dtdef_ref dtd = ctf_dtd_lookup (ctfc, sou);\n+  ctf_dmdef_t * dmd;\n+\n+  uint32_t kind, vlen, root;\n+\n+  /* The type of the member being added must already exist.  */\n+  gcc_assert (dtd);\n+\n+  kind = CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info);\n+  root = CTF_V2_INFO_ISROOT (dtd->dtd_data.ctti_info);\n+  vlen = CTF_V2_INFO_VLEN (dtd->dtd_data.ctti_info);\n+\n+  gcc_assert (kind == CTF_K_STRUCT || kind == CTF_K_UNION);\n+  gcc_assert (vlen < CTF_MAX_VLEN);\n+\n+  dmd = ggc_cleared_alloc<ctf_dmdef_t> ();\n+\n+  /* Buffer the strings in the CTF string table.  */\n+  dmd->dmd_name = ctf_add_string (ctfc, name, &(dmd->dmd_name_offset));\n+  dmd->dmd_type = type;\n+  dmd->dmd_value = -1;\n+\n+  if (kind == CTF_K_STRUCT && vlen != 0)\n+    dmd->dmd_offset = bit_offset;\n+  else\n+    dmd->dmd_offset = 0;\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n+  ctf_dmd_list_append (&dtd->dtd_u.dtu_members, dmd);\n+\n+  if ((name != NULL) && strcmp (name, \"\"))\n+    ctfc->ctfc_strlen += strlen (name) + 1;\n+\n+  return 0;\n+}\n+\n+int\n+ctf_add_variable (ctf_container_ref ctfc, const char * name, ctf_id_t ref,\n+\t\t  dw_die_ref die, unsigned int external_vis)\n+{\n+  ctf_dvdef_ref dvd;\n+\n+  gcc_assert (name);\n+\n+  if (name != NULL)\n+    {\n+      dvd = ggc_cleared_alloc<ctf_dvdef_t> ();\n+      dvd->dvd_key = die;\n+      /* Buffer the strings in the CTF string table.  */\n+      dvd->dvd_name = ctf_add_string (ctfc, name, &(dvd->dvd_name_offset));\n+      dvd->dvd_visibility = external_vis;\n+      dvd->dvd_type = ref;\n+      ctf_dvd_insert (ctfc, dvd);\n+\n+      if (strcmp (name, \"\"))\n+\tctfc->ctfc_strlen += strlen (name) + 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+ctf_add_function_arg (ctf_container_ref ctfc, dw_die_ref func,\n+\t\t      const char * name, ctf_id_t type)\n+{\n+  ctf_dtdef_ref dtd = ctf_dtd_lookup (ctfc, func);\n+  ctf_func_arg_t * farg;\n+  uint32_t vlen;\n+\n+  /* The function to which argument is being added must already exist.  */\n+  gcc_assert (dtd);\n+  /* The number of args must have been non-zero.  */\n+  vlen = CTF_V2_INFO_VLEN (dtd->dtd_data.ctti_info);\n+  gcc_assert (vlen);\n+\n+  farg = ggc_cleared_alloc<ctf_func_arg_t> ();\n+\n+  /* Buffer the strings in the auxilliary string table.  CTF V3 format does not\n+     require function argument names.  Use auxilliary string table to keep\n+     these strings to avoid unnecessary bloat in CTF section in CTF V3.  */\n+  farg->farg_name = ctf_add_string (ctfc, name, &(farg->farg_name_offset),\n+\t\t\t\t    CTF_AUX_STRTAB);\n+  farg->farg_type = type;\n+\n+  ctf_farg_list_append (&dtd->dtd_u.dtu_argv, farg);\n+\n+  /* For aux_str, keep ctfc_aux_strlen updated for debugging.  */\n+  if ((name != NULL) && strcmp (name, \"\"))\n+    ctfc->ctfc_aux_strlen += strlen (name) + 1;\n+\n+  return 0;\n+}\n+\n+ctf_id_t\n+ctf_add_function (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t\t  const ctf_funcinfo_t * ctc, dw_die_ref die,\n+\t\t  bool from_global_func)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type;\n+  uint32_t vlen;\n+\n+  gcc_assert (ctc);\n+\n+  vlen = ctc->ctc_argc;\n+  gcc_assert (vlen <= CTF_MAX_VLEN);\n+\n+  type = ctf_add_generic (ctfc, flag, name, &dtd, die);\n+\n+  dtd->from_global_func = from_global_func;\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (CTF_K_FUNCTION, flag, vlen);\n+  /* Caller must make sure CTF types for ctc->ctc_return are already added.  */\n+  dtd->dtd_data.ctti_type = (uint32_t) ctc->ctc_return;\n+  /* Caller must make sure CTF types for function arguments are already added\n+     via ctf_add_function_arg () API.  */\n+\n+  ctfc->ctfc_num_stypes++;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_sou (ctf_container_ref ctfc, uint32_t flag, const char * name,\n+\t     uint32_t kind, size_t size, dw_die_ref die)\n+{\n+  ctf_dtdef_ref dtd;\n+  ctf_id_t type = 0;\n+\n+  gcc_assert ((kind == CTF_K_STRUCT) || (kind == CTF_K_UNION));\n+\n+  /* In the compiler, no need to handle the case of promoting forwards to\n+     structs.  This comment is simply to note a divergence from libctf.  */\n+\n+  /* The compiler does, however, update any previously existing forward types\n+     to non-root.  CTF does not allow existence of two root types with the same\n+     name.  */\n+  ctf_dtdef_ref sou_fwd_type = ctf_dtd_lookup (ctfc, die);\n+  if (sou_fwd_type)\n+    {\n+      sou_fwd_type->dtd_data.ctti_info\n+\t= CTF_TYPE_INFO (CTF_K_FORWARD, CTF_ADD_NONROOT, 0);\n+    }\n+\n+  type = ctf_add_generic (ctfc, flag, name, &dtd, die);\n+\n+  dtd->dtd_data.ctti_info = CTF_TYPE_INFO (kind, flag, 0);\n+\n+  if (size > CTF_MAX_SIZE)\n+    {\n+      dtd->dtd_data.ctti_size = CTF_LSIZE_SENT;\n+      dtd->dtd_data.ctti_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+      dtd->dtd_data.ctti_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+      ctfc->ctfc_num_types++;\n+    }\n+  else\n+    {\n+      dtd->dtd_data.ctti_size = (uint32_t) size;\n+      ctfc->ctfc_num_stypes++;\n+    }\n+\n+  return type;\n+}\n+\n+/* Check if CTF for TYPE has already been generated.  Mainstay for\n+   de-duplication.  If CTF type already exists, returns TRUE and updates\n+   the TYPE_ID for the caller.  */\n+\n+bool\n+ctf_type_exists (ctf_container_ref ctfc, dw_die_ref type,\n+\t\t ctf_id_t * type_id)\n+{\n+  bool exists = false;\n+  ctf_dtdef_ref ctf_type_seen = ctf_dtd_lookup (ctfc, type);\n+\n+  if (ctf_type_seen)\n+    {\n+      exists = true;\n+      /* CTF type for this type exists.  */\n+      *type_id = ctf_type_seen->dtd_type;\n+    }\n+\n+  return exists;\n+}\n+\n+/* Location information for CTF Types and CTF Variables.  CTF section does not\n+   emit location information; at this time, location information is needed for\n+   BTF CO-RE use-cases.  */\n+\n+int\n+ctfc_get_dtd_srcloc (ctf_dtdef_ref dtd, ctf_srcloc_ref loc)\n+{\n+  loc->ctsloc_file = ctf_get_die_loc_file (dtd->dtd_key);\n+  loc->ctsloc_line = ctf_get_die_loc_line (dtd->dtd_key);\n+  loc->ctsloc_col = ctf_get_die_loc_col (dtd->dtd_key);\n+\n+  if (loc->ctsloc_file == NULL)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int\n+ctfc_get_dvd_srcloc (ctf_dvdef_ref dvd, ctf_srcloc_ref loc)\n+{\n+  loc->ctsloc_file = ctf_get_die_loc_file (dvd->dvd_key);\n+  loc->ctsloc_line = ctf_get_die_loc_line (dvd->dvd_key);\n+  loc->ctsloc_col = ctf_get_die_loc_col (dvd->dvd_key);\n+\n+  if (loc->ctsloc_file == NULL)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* CTF container setup and teardown routines.  */\n+\n+/* Initialize the CTF string table.\n+   The first entry in the CTF string table (empty string) is added.  */\n+\n+static void\n+init_ctf_strtable (ctf_strtable_t * strtab)\n+{\n+  strtab->ctstab_head = NULL;\n+  strtab->ctstab_tail = NULL;\n+  strtab->ctstab_num = 0;\n+  strtab->ctstab_len = 0;\n+\n+  /* The first entry in the CTF string table is an empty string.  E.g., CTF\n+     type records with no name (like CTF_K_CONST, CTF_K_VOLATILE etc) point to\n+     this string.  */\n+  uint32_t estr_offset = 0;\n+  strtab->ctstab_estr = ctfc_strtable_add_str (strtab, \"\", &estr_offset);\n+}\n+\n+/* Initialize the string tables in the CTF container.  */\n+\n+static void\n+init_ctf_string_table (ctf_container_ref ctfc)\n+{\n+  init_ctf_strtable (&ctfc->ctfc_strtable);\n+  ctfc->ctfc_strlen++;\n+\n+  init_ctf_strtable (&ctfc->ctfc_aux_strtable);\n+  ctfc->ctfc_aux_strlen++;\n+}\n+\n+/* Allocate a new CTF container with the desired flags.  */\n+\n+static inline ctf_container_ref\n+new_ctf_container (void)\n+{\n+  tu_ctfc = ggc_cleared_alloc<ctf_container_t> ();\n+  tu_ctfc->ctfc_types\n+    = hash_table<ctfc_dtd_hasher>::create_ggc (100);\n+  tu_ctfc->ctfc_vars\n+    = hash_table<ctfc_dvd_hasher>::create_ggc (100);\n+\n+  return tu_ctfc;\n+}\n+\n+/* Initialize a CTF container per translation unit.  */\n+\n+static void\n+init_ctf_container (void)\n+{\n+  tu_ctfc = new_ctf_container ();\n+\n+  tu_ctfc->ctfc_magic = CTF_MAGIC;\n+  tu_ctfc->ctfc_version = CTF_VERSION;\n+  tu_ctfc->ctfc_flags = CTF_F_NEWFUNCINFO;\n+  tu_ctfc->ctfc_nextid = CTF_INIT_TYPEID;\n+\n+  init_ctf_string_table (tu_ctfc);\n+}\n+\n+void\n+ctfc_delete_strtab (ctf_strtable_t * strtab)\n+{\n+  ctf_string_t * str = NULL;\n+  ctf_string_t * next_str = NULL;\n+\n+  str = strtab->ctstab_head;\n+  next_str = str;\n+  while (next_str != NULL)\n+    {\n+      next_str = str->cts_next;\n+      ggc_free (str);\n+      str = next_str;\n+    }\n+\n+  strtab->ctstab_head = NULL;\n+  strtab->ctstab_tail = NULL;\n+  strtab->ctstab_estr = NULL;\n+}\n+\n+/* Delete the CTF container's resources.  */\n+\n+void\n+ctfc_delete_container (ctf_container_ref ctfc)\n+{\n+  /* FIXME - CTF container can be cleaned up now.\n+     Will the ggc machinery take care of cleaning up the container structure\n+     including the hash_map members etc. ?  */\n+  if (ctfc)\n+    {\n+      ctfc_delete_strtab (&ctfc->ctfc_strtable);\n+      ctfc_delete_strtab (&ctfc->ctfc_aux_strtable);\n+      if (ctfc->ctfc_vars_list)\n+\t{\n+\t  ggc_free (ctfc->ctfc_vars_list);\n+\t  ctfc->ctfc_vars_list = NULL;\n+\t}\n+      if (ctfc->ctfc_types_list)\n+\t{\n+\t  ggc_free (ctfc->ctfc_types_list);\n+\t  ctfc->ctfc_types_list = NULL;\n+\t}\n+      if (ctfc->ctfc_gfuncs_list)\n+\t{\n+\t  ggc_free (ctfc->ctfc_gfuncs_list);\n+\t  ctfc->ctfc_gfuncs_list = NULL;\n+\t}\n+      if (ctfc->ctfc_gobjts_list)\n+\t{\n+\t  ggc_free (ctfc->ctfc_gobjts_list);\n+\t  ctfc->ctfc_gobjts_list = NULL;\n+\t}\n+\n+      ctfc= NULL;\n+    }\n+}\n+\n+/* CTF routines interfacing to the compiler.  */\n+\n+void\n+ctf_init (void)\n+{\n+  init_ctf_container ();\n+}"}, {"sha": "39c527074b549143d4f4c25d02e7168ac31fb148", "filename": "gcc/ctfc.h", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fctfc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fctfc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fctfc.h?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,436 @@\n+/* ctfc.h - Declarations and definitions related to the CTF container.\n+   Copyright (C) 2019,2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file defines the data structures and functions used by the compiler\n+   to generate the CTF debug info.  The definitions below are compiler internal\n+   representations and closely reflect the CTF format requirements in <ctf.h>.\n+\n+   The contents of the CTF container are used eventually for emission of both\n+   CTF (ctfout.c) and BTF debug info (btfout.c), as the two type debug formats\n+   are close cousins.  */\n+\n+#ifndef GCC_CTFC_H\n+#define GCC_CTFC_H 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"dwarf2ctf.h\"\n+#include \"ctf.h\"\n+#include \"btf.h\"\n+\n+/* Invalid CTF type ID definition.  */\n+\n+#define CTF_NULL_TYPEID 0\n+\n+/* Value to start generating the CTF type ID from.  */\n+\n+#define CTF_INIT_TYPEID 1\n+\n+/* CTF type ID.  */\n+\n+typedef uint64_t ctf_id_t;\n+\n+/* CTF string table element (list node).  */\n+\n+typedef struct GTY ((chain_next (\"%h.cts_next\"))) ctf_string\n+{\n+  const char * cts_str;\t\t  /* CTF string.  */\n+  struct ctf_string * cts_next;   /* A list node.  */\n+} ctf_string_t;\n+\n+/* Internal representation of CTF string table.  */\n+\n+typedef struct GTY (()) ctf_strtable\n+{\n+  ctf_string_t * ctstab_head;\t    /* Head str ptr.  */\n+  ctf_string_t * ctstab_tail;\t    /* Tail.  new str appended to tail.  */\n+  int ctstab_num;\t\t    /* Number of strings in the table.  */\n+  size_t ctstab_len;\t\t    /* Size of string table in bytes.  */\n+  const char * ctstab_estr;\t    /* Empty string \"\".  */\n+} ctf_strtable_t;\n+\n+/* Encoding information for integers, floating-point values etc.  The flags\n+   field will contain values appropriate for the type defined in <ctf.h>.  */\n+\n+typedef struct GTY (()) ctf_encoding\n+{\n+  unsigned int cte_format;  /* Data format (CTF_INT_* or CTF_FP_* flags).  */\n+  unsigned int cte_offset;  /* Offset of value in bits.  */\n+  unsigned int cte_bits;    /* Size of storage in bits.  */\n+} ctf_encoding_t;\n+\n+/* Array information for CTF generation.  */\n+\n+typedef struct GTY (()) ctf_arinfo\n+{\n+  ctf_id_t ctr_contents;\t/* Type of array contents.  */\n+  ctf_id_t ctr_index;\t\t/* Type of array index.  */\n+  unsigned int ctr_nelems;\t/* Number of elements.  */\n+} ctf_arinfo_t;\n+\n+/* Function information for CTF generation.  */\n+\n+typedef struct GTY (()) ctf_funcinfo\n+{\n+  ctf_id_t ctc_return;\t\t/* Function return type.  */\n+  unsigned int ctc_argc;\t/* Number of typed arguments to function.  */\n+  unsigned int ctc_flags;\t/* Function attributes (see below).  */\n+} ctf_funcinfo_t;\n+\n+typedef struct GTY (()) ctf_sliceinfo\n+{\n+  unsigned int cts_type;\t/* Reference CTF type.  */\n+  unsigned short cts_offset;\t/* Offset in bits of the first bit.  */\n+  unsigned short cts_bits;\t/* Size in bits.  */\n+} ctf_sliceinfo_t;\n+\n+/* CTF type representation internal to the compiler.  It closely reflects the\n+   ctf_type_t type node in <ctf.h> except the GTY (()) tags.  */\n+\n+typedef struct GTY (()) ctf_itype\n+{\n+  uint32_t ctti_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctti_info;\t\t/* Encoded kind, variant length (see below).  */\n+  union GTY ((desc (\"0\")))\n+  {\n+    uint32_t GTY ((tag (\"0\"))) _size;/* Size of entire type in bytes.  */\n+    uint32_t GTY ((tag (\"1\"))) _type;/* Reference to another type.  */\n+  } _u;\n+  uint32_t ctti_lsizehi;\t/* High 32 bits of type size in bytes.  */\n+  uint32_t ctti_lsizelo;\t/* Low 32 bits of type size in bytes.  */\n+} ctf_itype_t;\n+\n+#define ctti_size _u._size\n+#define ctti_type _u._type\n+\n+/* Function arguments end with varargs.  */\n+\n+#define CTF_FUNC_VARARG 0x1\n+\n+/* Struct/union/enum member definition for CTF generation.  */\n+\n+typedef struct GTY ((chain_next (\"%h.dmd_next\"))) ctf_dmdef\n+{\n+  const char * dmd_name;\t/* Name of this member.  */\n+  ctf_id_t dmd_type;\t\t/* Type of this member (for sou).  */\n+  uint32_t dmd_name_offset;\t/* Offset of the name in str table.  */\n+  uint64_t dmd_offset;\t\t/* Offset of this member in bits (for sou).  */\n+  int dmd_value;\t\t/* Value of this member (for enum).  */\n+  struct ctf_dmdef * dmd_next;\t/* A list node.  */\n+} ctf_dmdef_t;\n+\n+#define ctf_dmd_list_next(elem) ((ctf_dmdef_t *)((elem)->dmd_next))\n+\n+/* Function Argument.  */\n+\n+typedef struct GTY (()) ctf_func_arg\n+{\n+  ctf_id_t farg_type;\t\t  /* Type identifier of the argument.  */\n+  const char * farg_name;\t  /* Name of the the argument.  */\n+  uint32_t farg_name_offset;\t  /* Offset of the name in str table.  */\n+  struct ctf_func_arg * farg_next;/* A list node.  */\n+} ctf_func_arg_t;\n+\n+#define ctf_farg_list_next(elem) ((ctf_func_arg_t *)((elem)->farg_next))\n+\n+/* Type definition for CTF generation.  */\n+\n+struct GTY ((for_user)) ctf_dtdef\n+{\n+  dw_die_ref dtd_key;\t      /* Type key for hashing.  */\n+  const char * dtd_name;      /* Name associated with definition (if any).  */\n+  ctf_id_t dtd_type;\t      /* Type identifier for this definition.  */\n+  ctf_itype_t dtd_data;\t      /* Type node.  */\n+  bool from_global_func; /* Whether this type was added from a global\n+\t\t\t    function.  */\n+  union GTY ((desc (\"ctf_dtu_d_union_selector (&%1)\")))\n+  {\n+    /* struct, union, or enum.  */\n+    ctf_dmdef_t * GTY ((tag (\"CTF_DTU_D_MEMBERS\"))) dtu_members;\n+    /* array.  */\n+    ctf_arinfo_t GTY ((tag (\"CTF_DTU_D_ARRAY\"))) dtu_arr;\n+    /* integer or float.  */\n+    ctf_encoding_t GTY ((tag (\"CTF_DTU_D_ENCODING\"))) dtu_enc;\n+    /* function.  */\n+    ctf_func_arg_t * GTY ((tag (\"CTF_DTU_D_ARGUMENTS\"))) dtu_argv;\n+    /* slice.  */\n+    ctf_sliceinfo_t GTY ((tag (\"CTF_DTU_D_SLICE\"))) dtu_slice;\n+  } dtd_u;\n+};\n+\n+typedef struct ctf_dtdef ctf_dtdef_t;\n+\n+/* Variable definition for CTF generation.  */\n+\n+struct GTY ((for_user)) ctf_dvdef\n+{\n+  dw_die_ref dvd_key;\t\t/* DWARF DIE corresponding to the variable.  */\n+  const char * dvd_name;\t/* Name associated with variable.  */\n+  uint32_t dvd_name_offset;\t/* Offset of the name in str table.  */\n+  unsigned int dvd_visibility;\t/* External visibility.  0=static,1=global.  */\n+  ctf_id_t dvd_type;\t\t/* Type of variable.  */\n+};\n+\n+typedef struct ctf_dvdef ctf_dvdef_t;\n+\n+typedef ctf_dvdef_t * ctf_dvdef_ref;\n+typedef ctf_dtdef_t * ctf_dtdef_ref;\n+\n+/* Location information for CTF Types and CTF Variables.  */\n+\n+typedef struct GTY (()) ctf_srcloc\n+{\n+  const char * ctsloc_file;\n+  unsigned int ctsloc_line;\n+  unsigned int ctsloc_col;\n+} ctf_srcloc_t;\n+\n+typedef ctf_srcloc_t * ctf_srcloc_ref;\n+\n+/* Helper enum and api for the GTY machinery to work on union dtu_d.  */\n+\n+enum ctf_dtu_d_union_enum {\n+  CTF_DTU_D_MEMBERS,\n+  CTF_DTU_D_ARRAY,\n+  CTF_DTU_D_ENCODING,\n+  CTF_DTU_D_ARGUMENTS,\n+  CTF_DTU_D_SLICE,\n+};\n+\n+enum ctf_dtu_d_union_enum\n+ctf_dtu_d_union_selector (ctf_dtdef_ref);\n+\n+struct ctfc_dtd_hasher : ggc_ptr_hash <ctf_dtdef_t>\n+{\n+  typedef ctf_dtdef_ref compare_type;\n+\n+  static hashval_t hash (ctf_dtdef_ref);\n+  static bool equal (ctf_dtdef_ref, ctf_dtdef_ref);\n+};\n+\n+inline hashval_t\n+ctfc_dtd_hasher::hash (ctf_dtdef_ref dtd)\n+{\n+  return htab_hash_pointer (dtd->dtd_key);\n+}\n+\n+inline bool\n+ctfc_dtd_hasher::equal (ctf_dtdef_ref dtd, ctf_dtdef_ref dtd2)\n+{\n+  return (dtd->dtd_key == dtd2->dtd_key);\n+}\n+\n+struct ctfc_dvd_hasher : ggc_ptr_hash <ctf_dvdef_t>\n+{\n+  typedef ctf_dvdef_ref compare_type;\n+\n+  static hashval_t hash (ctf_dvdef_ref);\n+  static bool equal (ctf_dvdef_ref, ctf_dvdef_ref);\n+};\n+\n+inline hashval_t\n+ctfc_dvd_hasher::hash (ctf_dvdef_ref dvd)\n+{\n+  return htab_hash_pointer (dvd->dvd_key);\n+}\n+\n+inline bool\n+ctfc_dvd_hasher::equal (ctf_dvdef_ref dvd, ctf_dvdef_ref dvd2)\n+{\n+  return (dvd->dvd_key == dvd2->dvd_key);\n+}\n+\n+/* CTF container structure.\n+   It is the context passed around when generating ctf debug info.  There is\n+   one container per translation unit.  */\n+\n+typedef struct GTY (()) ctf_container\n+{\n+  /* CTF Preamble.  */\n+  unsigned short ctfc_magic;\n+  unsigned char ctfc_version;\n+  unsigned char ctfc_flags;\n+  uint32_t ctfc_cuname_offset;\n+\n+  /* CTF types.  */\n+  hash_table <ctfc_dtd_hasher> * GTY (()) ctfc_types;\n+  /* CTF variables.  */\n+  hash_table <ctfc_dvd_hasher> * GTY (()) ctfc_vars;\n+\n+  /* CTF string table.  */\n+  ctf_strtable_t ctfc_strtable;\n+  /* Auxilliary string table.  At this time, used for keeping func arg names\n+     for BTF.  */\n+  ctf_strtable_t ctfc_aux_strtable;\n+\n+  uint64_t ctfc_num_types;\n+  uint64_t ctfc_num_stypes;\n+  uint64_t ctfc_num_global_funcs;\n+  uint64_t ctfc_num_global_objts;\n+\n+  /* Number of vlen bytes - the variable length portion after ctf_type_t and\n+     ctf_stype_t in the CTF section.  This is used to calculate the offsets in\n+     the CTF header.  */\n+  uint64_t ctfc_num_vlen_bytes;\n+\n+  /* Next CTF type id to assign.  */\n+  ctf_id_t ctfc_nextid;\n+\n+  /* Specify an explicit length of 0 so that the GC marking routines steer\n+     clear of marking the CTF vars and CTF types twice. These lists below do\n+     not own the pointed to objects, they simply hold references to them.  */\n+\n+  /* List of pre-processed CTF Variables.  CTF requires that the variables\n+     appear in the sorted order of their names.  */\n+  ctf_dvdef_t ** GTY ((length (\"0\"))) ctfc_vars_list;\n+  /* List of pre-processed CTF types.  CTF requires that a shared type must\n+     appear before the type that uses it.  For the compiler, this means types\n+     are emitted in sorted order of their type IDs.  */\n+  ctf_dtdef_t ** GTY ((length (\"0\"))) ctfc_types_list;\n+  /* List of CTF function types for global functions.  The order of global\n+     function entries in the CTF funcinfo section is undefined by the\n+     compiler.  */\n+  ctf_dtdef_t ** GTY ((length (\"0\"))) ctfc_gfuncs_list;\n+  /* List of CTF variables at global scope.  The order of global object entries\n+     in the CTF objinfo section is undefined by the  compiler.  */\n+  ctf_dvdef_t ** GTY ((length (\"0\"))) ctfc_gobjts_list;\n+\n+  /* Following members are for debugging only.  They do not add functional\n+     value to the task of CTF creation.  These can be cleaned up once CTF\n+     generation stabilizes.  */\n+\n+  /* Keep a count of the number of bytes dumped in asm for debugging\n+     purposes.  */\n+  uint64_t ctfc_numbytes_asm;\n+   /* Total length of all strings in CTF.  */\n+  size_t ctfc_strlen;\n+  /* Total length of all strings in aux string table.  */\n+  size_t ctfc_aux_strlen;\n+\n+} ctf_container_t;\n+\n+/* Markers for which string table from the CTF container to use.  */\n+\n+#define CTF_STRTAB 0\t    /* CTF string table.  */\n+#define CTF_AUX_STRTAB 1    /* CTF auxilliary string table.  */\n+\n+typedef ctf_container_t * ctf_container_ref;\n+\n+extern GTY (()) ctf_container_ref tu_ctfc;\n+\n+extern void ctfc_delete_container (ctf_container_ref);\n+\n+/* If the next ctf type id is still set to the init value, no ctf records to\n+   report.  */\n+extern bool ctfc_is_empty_container (ctf_container_ref);\n+\n+/* Get the total number of CTF types in the container.  */\n+\n+extern unsigned int ctfc_get_num_ctf_types (ctf_container_ref);\n+\n+/* Get the total number of CTF variables in the container.  */\n+\n+extern unsigned int ctfc_get_num_ctf_vars (ctf_container_ref);\n+\n+/* Get reference to the CTF string table or the CTF auxilliary\n+   string table.  */\n+\n+extern ctf_strtable_t * ctfc_get_strtab (ctf_container_ref, int);\n+\n+/* Get the length of the specified string table in the CTF container.  */\n+\n+extern size_t ctfc_get_strtab_len (ctf_container_ref, int);\n+\n+/* Get the number of bytes to represent the variable length portion of all CTF\n+   types in the CTF container.  */\n+\n+extern size_t ctfc_get_num_vlen_bytes (ctf_container_ref);\n+\n+/* The compiler demarcates whether types are visible at top-level scope or not.\n+   The only example so far of a type not visible at top-level scope is slices.\n+   CTF_ADD_NONROOT is used to indicate the latter.  */\n+#define\tCTF_ADD_NONROOT\t0\t/* CTF type only visible in nested scope.  */\n+#define\tCTF_ADD_ROOT\t1\t/* CTF type visible at top-level scope.  */\n+\n+/* These APIs allow to initialize and finalize the CTF machinery and\n+   to add types to the CTF container associated to the current\n+   translation unit.  Used in dwarf2ctf.c.  */\n+\n+extern void ctf_init (void);\n+extern void ctf_output (const char * filename);\n+extern void ctf_finalize (void);\n+\n+extern void btf_output (const char * filename);\n+extern void btf_init_postprocess (void);\n+extern void btf_finalize (void);\n+\n+extern ctf_container_ref ctf_get_tu_ctfc (void);\n+\n+extern bool ctf_type_exists (ctf_container_ref, dw_die_ref, ctf_id_t *);\n+\n+extern void ctf_add_cuname (ctf_container_ref, const char *);\n+\n+extern ctf_dvdef_ref ctf_dvd_lookup (const ctf_container_ref, dw_die_ref);\n+\n+extern const char * ctf_add_string (ctf_container_ref, const char *,\n+\t\t\t\t    uint32_t *, int);\n+\n+extern ctf_id_t ctf_add_reftype (ctf_container_ref, uint32_t, ctf_id_t,\n+\t\t\t\t uint32_t, dw_die_ref);\n+extern ctf_id_t ctf_add_enum (ctf_container_ref, uint32_t, const char *,\n+\t\t\t      HOST_WIDE_INT, dw_die_ref);\n+extern ctf_id_t ctf_add_slice (ctf_container_ref, uint32_t, ctf_id_t,\n+\t\t\t       uint32_t, uint32_t, dw_die_ref);\n+extern ctf_id_t ctf_add_float (ctf_container_ref, uint32_t, const char *,\n+\t\t\t       const ctf_encoding_t *, dw_die_ref);\n+extern ctf_id_t ctf_add_integer (ctf_container_ref, uint32_t, const char *,\n+\t\t\t\t const ctf_encoding_t *, dw_die_ref);\n+extern ctf_id_t ctf_add_unknown (ctf_container_ref, uint32_t, const char *,\n+\t\t\t\t const ctf_encoding_t *, dw_die_ref);\n+extern ctf_id_t ctf_add_pointer (ctf_container_ref, uint32_t, ctf_id_t,\n+\t\t\t\t dw_die_ref);\n+extern ctf_id_t ctf_add_array (ctf_container_ref, uint32_t,\n+\t\t\t       const ctf_arinfo_t *, dw_die_ref);\n+extern ctf_id_t ctf_add_forward (ctf_container_ref, uint32_t, const char *,\n+\t\t\t\t uint32_t, dw_die_ref);\n+extern ctf_id_t ctf_add_typedef (ctf_container_ref, uint32_t, const char *,\n+\t\t\t\t ctf_id_t, dw_die_ref);\n+extern ctf_id_t ctf_add_function (ctf_container_ref, uint32_t, const char *,\n+\t\t\t\t  const ctf_funcinfo_t *, dw_die_ref, bool);\n+extern ctf_id_t ctf_add_sou (ctf_container_ref, uint32_t, const char *,\n+\t\t\t     uint32_t, size_t, dw_die_ref);\n+\n+extern int ctf_add_enumerator (ctf_container_ref, ctf_id_t, const char *,\n+\t\t\t       HOST_WIDE_INT, dw_die_ref);\n+extern int ctf_add_member_offset (ctf_container_ref, dw_die_ref, const char *,\n+\t\t\t\t  ctf_id_t, uint64_t);\n+extern int ctf_add_function_arg (ctf_container_ref, dw_die_ref,\n+\t\t\t\t const char *, ctf_id_t);\n+extern int ctf_add_variable (ctf_container_ref, const char *, ctf_id_t,\n+\t\t\t     dw_die_ref, unsigned int);\n+\n+/* CTF section does not emit location information; at this time, location\n+   information is needed for BTF CO-RE use-cases.  */\n+\n+extern int ctfc_get_dtd_srcloc (ctf_dtdef_ref, ctf_srcloc_ref);\n+extern int ctfc_get_dvd_srcloc (ctf_dvdef_ref, ctf_srcloc_ref);\n+\n+#endif /* GCC_CTFC_H */"}, {"sha": "c264fd6661a357e009527f5cc0daf00e9d23091d", "filename": "gcc/ctfout.c", "status": "added", "additions": 830, "deletions": 0, "changes": 830, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fctfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fctfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fctfout.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,830 @@\n+/* Output CTF format from GCC.\n+   Copyright (C) 2019,2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"output.h\"\n+#include \"dwarf2asm.h\"\n+#include \"debug.h\"\n+#include \"ctfc.h\"\n+#include \"diagnostic-core.h\"\n+\n+static int ctf_label_num;\n+\n+/* Pointers to various CTF sections.  */\n+\n+static GTY (()) section * ctf_info_section;\n+\n+/* Section names used to hold CTF debugging information.  */\n+\n+/* CTF debug info section.  */\n+\n+#ifndef CTF_INFO_SECTION_NAME\n+#define CTF_INFO_SECTION_NAME  \".ctf\"\n+#endif\n+\n+/* Section flags for the CTF debug info section.  */\n+\n+#define CTF_INFO_SECTION_FLAGS (SECTION_DEBUG)\n+\n+/* Maximum size (in bytes) of an artificially generated CTF label.  */\n+\n+#define MAX_CTF_LABEL_BYTES 40\n+\n+static char ctf_info_section_label[MAX_CTF_LABEL_BYTES];\n+\n+#ifndef CTF_INFO_SECTION_LABEL\n+#define CTF_INFO_SECTION_LABEL\t\t\t\"Lctf\"\n+#endif\n+\n+/* CTF preprocess callback arguments.  */\n+\n+typedef struct ctf_dtd_preprocess_arg\n+{\n+  uint64_t dtd_global_func_idx;\n+  ctf_container_ref dtd_arg_ctfc;\n+} ctf_dtd_preprocess_arg_t;\n+\n+typedef struct ctf_dvd_preprocess_arg\n+{\n+  uint64_t dvd_global_obj_idx;\n+  ctf_container_ref dvd_arg_ctfc;\n+} ctf_dvd_preprocess_arg_t;\n+\n+/* Compare two CTF variable definition entries.  Currently used for sorting\n+   by name.  */\n+\n+static int\n+ctf_varent_compare (const void * entry1, const void * entry2)\n+{\n+  int result;\n+  const ctf_dvdef_t * e1 = *(const ctf_dvdef_t * const*) entry1;\n+  const ctf_dvdef_t * e2 = *(const ctf_dvdef_t * const*) entry2;\n+\n+  result = strcmp (e1->dvd_name, e2->dvd_name);\n+\n+  return result;\n+}\n+\n+/* A CTF type record may be followed by variable-length of bytes to encode the\n+   CTF type completely.  This routine calculates the number of bytes, in the\n+   final binary CTF format, which are used to encode information about the type\n+   completely.\n+\n+   This function must always be in sync with the CTF header.  */\n+\n+static uint64_t\n+ctf_calc_num_vbytes (ctf_dtdef_ref ctftype)\n+{\n+  uint32_t size;\n+  uint64_t vlen_bytes = 0;\n+\n+  uint32_t kind = CTF_V2_INFO_KIND (ctftype->dtd_data.ctti_info);\n+  uint32_t vlen = CTF_V2_INFO_VLEN (ctftype->dtd_data.ctti_info);\n+\n+  ctf_dmdef_t * dmd;\n+  ctf_func_arg_t * farg;\n+  uint32_t size_per_member = 0;\n+  unsigned int num_members = 0;\n+  unsigned int num_fargs = 0;\n+\n+  switch (kind)\n+    {\n+      case CTF_K_FORWARD:\n+      case CTF_K_UNKNOWN:\n+      case CTF_K_POINTER:\n+      case CTF_K_TYPEDEF:\n+      case CTF_K_VOLATILE:\n+      case CTF_K_CONST:\n+      case CTF_K_RESTRICT:\n+\t/* These types have no vlen data.  */\n+\tbreak;\n+\n+      case CTF_K_INTEGER:\n+      case CTF_K_FLOAT:\n+\t/* 4 bytes to represent encoding CTF_INT_DATA, CTF_FP_DATA.  */\n+\tvlen_bytes += sizeof (uint32_t);\n+\tbreak;\n+      case CTF_K_FUNCTION:\n+\t/* Sanity check - number of function args must be the same as\n+\t   vlen.  */\n+\tfor (farg = ctftype->dtd_u.dtu_argv;\n+\t     farg != NULL; farg = (ctf_func_arg_t *) ctf_farg_list_next (farg))\n+\t  num_fargs++;\n+\tgcc_assert (vlen == num_fargs);\n+\n+\t/* FIXME - CTF_PADDING_FOR_ALIGNMENT.  */\n+\tvlen_bytes += (vlen + (vlen & 1)) * sizeof (uint32_t);\n+\tbreak;\n+      case CTF_K_ARRAY:\n+\t/* This has a single ctf_array_t.  */\n+\tvlen_bytes += sizeof (ctf_array_t);\n+\tbreak;\n+      case CTF_K_SLICE:\n+\tvlen_bytes += sizeof (ctf_slice_t);\n+\tbreak;\n+      case CTF_K_STRUCT:\n+      case CTF_K_UNION:\n+\t/* Count the number and type of members.  */\n+\tsize = ctftype->dtd_data.ctti_size;\n+\tsize_per_member = size >= CTF_LSTRUCT_THRESH\n+\t\t\t  ? sizeof (ctf_lmember_t) : sizeof (ctf_member_t);\n+\n+\t/* Sanity check - number of members of struct must be the same as\n+\t   vlen.  */\n+\tfor (dmd = ctftype->dtd_u.dtu_members;\n+\t     dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+\t  num_members++;\n+\tgcc_assert (vlen == num_members);\n+\n+\tvlen_bytes += (num_members * size_per_member);\n+\tbreak;\n+      case CTF_K_ENUM:\n+\tvlen_bytes += vlen * sizeof (ctf_enum_t);\n+\tbreak;\n+      default :\n+\tbreak;\n+    }\n+  return vlen_bytes;\n+}\n+\n+/* Add a CTF variable to the end of the list.  */\n+\n+static void\n+ctf_list_add_ctf_vars (ctf_container_ref ctfc, ctf_dvdef_ref var)\n+{\n+  /* FIXME - static may not fly with multiple CUs.  */\n+  static int num_vars_added = 0;\n+  ctfc->ctfc_vars_list[num_vars_added++] = var;\n+}\n+\n+/* Initialize the various sections and labels for CTF output.  */\n+\n+void\n+init_ctf_sections (void)\n+{\n+  /* Note : Even in case of LTO, the compiler continues to generate a single\n+     CTF section for each compilation unit \"early\".  Unlike other debug\n+     sections, CTF sections are non-LTO sections, and do not take the\n+     .gnu.debuglto_ prefix.  The linker will de-duplicate the types in the CTF\n+     sections, in case of LTO or  otherwise.  */\n+  ctf_info_section = get_section (CTF_INFO_SECTION_NAME, CTF_INFO_SECTION_FLAGS,\n+\t\t\t\t  NULL);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (ctf_info_section_label,\n+\t\t\t       CTF_INFO_SECTION_LABEL, ctf_label_num++);\n+}\n+\n+/* Routines for CTF pre-processing.  */\n+\n+static void\n+ctf_preprocess_var (ctf_container_ref ctfc, ctf_dvdef_ref var)\n+{\n+  /* Add it to the list of types.  This array of types will be sorted before\n+     assembling into output.  */\n+  ctf_list_add_ctf_vars (ctfc, var);\n+}\n+\n+/* CTF preprocess callback routine for CTF variables.  */\n+\n+int\n+ctf_dvd_preprocess_cb (ctf_dvdef_ref * slot, void * arg)\n+{\n+  ctf_dvd_preprocess_arg_t * dvd_arg =  (ctf_dvd_preprocess_arg_t *)arg;\n+  ctf_dvdef_ref var = (ctf_dvdef_ref) *slot;\n+  ctf_container_ref arg_ctfc = dvd_arg->dvd_arg_ctfc;\n+\n+  ctf_preprocess_var (arg_ctfc, var);\n+\n+  /* Keep track of global objts.  */\n+  arg_ctfc->ctfc_gobjts_list[dvd_arg->dvd_global_obj_idx] = var;\n+  dvd_arg->dvd_global_obj_idx++;\n+\n+  return 1;\n+}\n+\n+/* CTF preprocess callback routine for CTF types.  */\n+\n+int\n+ctf_dtd_preprocess_cb (ctf_dtdef_ref * slot, void * arg)\n+{\n+  uint32_t kind;\n+\n+  ctf_dtdef_ref ctftype = (ctf_dtdef_ref) *slot;\n+  ctf_dtd_preprocess_arg_t * dtd_arg = (ctf_dtd_preprocess_arg_t *)arg;\n+  ctf_container_ref arg_ctfc = dtd_arg->dtd_arg_ctfc;\n+\n+  size_t index = ctftype->dtd_type;\n+  gcc_assert (index <= arg_ctfc->ctfc_types->elements ());\n+\n+  /* CTF types need to be output in the order of their type IDs.  In other\n+     words, if type A is used to define type B, type ID of type A must\n+     appear before type ID of type B.  */\n+  arg_ctfc->ctfc_types_list[index] = ctftype;\n+\n+  /* Keep track of the CTF type if it's a function type and the type\n+     was generated from a function object.  */\n+  kind = CTF_V2_INFO_KIND (ctftype->dtd_data.ctti_info);\n+  if (kind == CTF_K_FUNCTION && ctftype->from_global_func)\n+    {\n+      arg_ctfc->ctfc_gfuncs_list[dtd_arg->dtd_global_func_idx] = ctftype;\n+      dtd_arg->dtd_global_func_idx++;\n+    }\n+\n+  /* Calculate the vlen bytes.  */\n+  arg_ctfc->ctfc_num_vlen_bytes += ctf_calc_num_vbytes (ctftype);\n+\n+  return 1;\n+}\n+\n+/* CTF preprocessing.\n+   After the CTF types for the compilation unit have been generated fully, the\n+   compiler writes out the asm for the CTF types.\n+\n+   CTF writeout in the compiler requires two passes over the CTF types.  In the\n+   first pass, the CTF preprocess pass:\n+     1.  CTF types are sorted in the order of their type IDs.\n+     2.  The variable number of bytes after each CTF type record are calculated.\n+\t This is used to calculate the offsets in the ctf_header_t.\n+     3.  If the CTF type is of CTF_K_FUNCTION, the number of bytes in the\n+\t funcinfo sub-section are calculated.  This is used to calculate the\n+\t offsets in the ctf_header_t.\n+     4.  Keep the list of CTF variables in ASCIIbetical order of their names.\n+\n+   In the second pass, the CTF writeout pass, asm tags are written out using\n+   the compiler's afore-generated internal pre-processed CTF types.  */\n+\n+static void\n+ctf_preprocess (ctf_container_ref ctfc)\n+{\n+  size_t num_ctf_types = ctfc->ctfc_types->elements ();\n+\n+  /* Initialize an array to keep track of the CTF variables at global\n+     scope.  */\n+  size_t num_global_objts = ctfc->ctfc_num_global_objts;\n+  if (num_global_objts)\n+    {\n+      ctfc->ctfc_gobjts_list = ggc_vec_alloc<ctf_dvdef_t*>(num_global_objts);\n+    }\n+\n+  size_t num_ctf_vars = ctfc->ctfc_vars->elements ();\n+  if (num_ctf_vars)\n+    {\n+      ctf_dvd_preprocess_arg_t dvd_arg;\n+      dvd_arg.dvd_global_obj_idx = 0;\n+      dvd_arg.dvd_arg_ctfc = ctfc;\n+\n+      /* Allocate CTF var list.  */\n+      ctfc->ctfc_vars_list = ggc_vec_alloc<ctf_dvdef_ref>(num_ctf_vars);\n+      /* Variables appear in the sort ASCIIbetical order of their names.  This\n+\t permits binary searching in the CTF reader.  Add the variables to a\n+\t list for sorting.  */\n+      ctfc->ctfc_vars->traverse<void *, ctf_dvd_preprocess_cb> (&dvd_arg);\n+      /* Sort the list.  */\n+      qsort (ctfc->ctfc_vars_list, num_ctf_vars, sizeof (ctf_dvdef_ref),\n+\t     ctf_varent_compare);\n+    }\n+\n+  /* Initialize an array to keep track of the CTF functions types for global\n+     functions in the CTF data section.  */\n+  size_t num_global_funcs = ctfc->ctfc_num_global_funcs;\n+  if (num_global_funcs)\n+    {\n+      ctfc->ctfc_gfuncs_list = ggc_vec_alloc<ctf_dtdef_t*>(num_global_funcs);\n+      gcc_assert (num_ctf_types);\n+    }\n+\n+  if (num_ctf_types)\n+    {\n+      ctf_dtd_preprocess_arg_t dtd_arg;\n+      dtd_arg.dtd_global_func_idx = 0;\n+      dtd_arg.dtd_arg_ctfc = ctfc;\n+      /* Allocate the CTF types list.  Add 1 because type ID 0 is never a valid\n+\t CTF type ID.  No CTF type record should appear at that offset, this\n+\t eases debugging and readability.  */\n+      ctfc->ctfc_types_list = ggc_vec_alloc<ctf_dtdef_ref>(num_ctf_types + 1);\n+      /* Pre-process CTF types.  */\n+      ctfc->ctfc_types->traverse<void *, ctf_dtd_preprocess_cb> (&dtd_arg);\n+\n+      gcc_assert (dtd_arg.dtd_global_func_idx == num_global_funcs);\n+    }\n+}\n+\n+/* CTF asm helper routines.  */\n+\n+/* Asm'out the CTF preamble.  */\n+\n+static void\n+ctf_asm_preamble (ctf_container_ref ctfc)\n+{\n+  dw2_asm_output_data (2, ctfc->ctfc_magic,\n+\t\t       \"CTF preamble magic number\");\n+  dw2_asm_output_data (1, ctfc->ctfc_version, \"CTF preamble version\");\n+  dw2_asm_output_data (1, ctfc->ctfc_flags, \"CTF preamble flags\");\n+}\n+\n+/* Asm'out a CTF type which is represented by ctf_stype_t.  */\n+\n+static void\n+ctf_asm_stype (ctf_dtdef_ref type)\n+{\n+  dw2_asm_output_data (4, type->dtd_data.ctti_name, \"ctt_name\");\n+  dw2_asm_output_data (4, type->dtd_data.ctti_info, \"ctt_info\");\n+  /* union.  */\n+  dw2_asm_output_data (4, type->dtd_data.ctti_size, \"ctt_size or ctt_type\");\n+}\n+\n+/* Asm'out a CTF type which is represented by ctf_type_t.  */\n+\n+static void\n+ctf_asm_type (ctf_dtdef_ref type)\n+{\n+  dw2_asm_output_data (4, type->dtd_data.ctti_name, \"ctt_name\");\n+  dw2_asm_output_data (4, type->dtd_data.ctti_info, \"ctt_info\");\n+  /* union.  */\n+  dw2_asm_output_data (4, type->dtd_data.ctti_size, \"ctt_size\");\n+  dw2_asm_output_data (4, type->dtd_data.ctti_lsizehi, \"ctt_lsizehi\");\n+  dw2_asm_output_data (4, type->dtd_data.ctti_lsizelo, \"ctt_lsizelo\");\n+}\n+\n+/* Asm'out a CTF type of kind CTF_K_SLICE.  */\n+\n+static void\n+ctf_asm_slice (ctf_dtdef_ref type)\n+{\n+  dw2_asm_output_data (4, type->dtd_u.dtu_slice.cts_type, \"cts_type\");\n+  dw2_asm_output_data (2, type->dtd_u.dtu_slice.cts_offset, \"cts_offset\");\n+  dw2_asm_output_data (2, type->dtd_u.dtu_slice.cts_bits, \"cts_bits\");\n+}\n+\n+/* Asm'out a CTF type of kind CTF_K_ARRAY.  */\n+\n+static void\n+ctf_asm_array (ctf_dtdef_ref dtd)\n+{\n+  dw2_asm_output_data (4, dtd->dtd_u.dtu_arr.ctr_contents, \"cta_contents\");\n+  dw2_asm_output_data (4, dtd->dtd_u.dtu_arr.ctr_index, \"cta_index\");\n+  dw2_asm_output_data (4, dtd->dtd_u.dtu_arr.ctr_nelems, \"cta_nelems\");\n+}\n+\n+/* Asm'out a CTF variable.  */\n+\n+static void\n+ctf_asm_varent (ctf_dvdef_ref var)\n+{\n+  /* Output the reference to the name in the string table.  */\n+  dw2_asm_output_data (4, var->dvd_name_offset, \"ctv_name\");\n+  /* Output the type index.  */\n+  dw2_asm_output_data (4, var->dvd_type, \"ctv_typeidx\");\n+}\n+\n+/* Asm'out a member of CTF struct or union, represented by ctf_lmember_t.  */\n+\n+static void\n+ctf_asm_sou_lmember (ctf_dmdef_t * dmd)\n+{\n+  dw2_asm_output_data (4, dmd->dmd_name_offset, \"ctlm_name\");\n+  dw2_asm_output_data (4, CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset),\n+\t\t       \"ctlm_offsethi\");\n+  dw2_asm_output_data (4, dmd->dmd_type, \"ctlm_type\");\n+  dw2_asm_output_data (4, CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset),\n+\t\t       \"ctlm_offsetlo\");\n+}\n+\n+/* Asm'out a member of a CTF sruct or union, represented by ctf_member_t.  */\n+\n+static void\n+ctf_asm_sou_member (ctf_dmdef_t * dmd)\n+{\n+  dw2_asm_output_data (4, dmd->dmd_name_offset, \"ctm_name\");\n+  dw2_asm_output_data (4, dmd->dmd_offset, \"ctm_offset\");\n+  dw2_asm_output_data (4, dmd->dmd_type, \"ctm_type\");\n+}\n+\n+/* Asm'out an enumerator constant.  */\n+\n+static void\n+ctf_asm_enum_const (ctf_dmdef_t * dmd)\n+{\n+  dw2_asm_output_data (4, dmd->dmd_name_offset, \"cte_name\");\n+  dw2_asm_output_data (4, dmd->dmd_value, \"cte_value\");\n+}\n+\n+/* Asm'out a function argument.  */\n+\n+static void\n+ctf_asm_func_arg (ctf_func_arg_t * farg)\n+{\n+  dw2_asm_output_data (4, farg->farg_type, \"dtu_argv\");\n+}\n+\n+/* CTF writeout to asm file.  */\n+\n+static void\n+output_ctf_header (ctf_container_ref ctfc)\n+{\n+  switch_to_section (ctf_info_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, ctf_info_section_label);\n+\n+  ctf_asm_preamble (ctfc);\n+\n+  /* For a single compilation unit, the parent container's name and label are\n+     NULL.  */\n+  dw2_asm_output_data (4, 0, \"cth_parlabel\");\n+  dw2_asm_output_data (4, 0, \"cth_parname\");\n+  dw2_asm_output_data (4, ctfc->ctfc_cuname_offset, \"cth_cuname\");\n+\n+  int typeslen = 0;\n+  /* Initialize the offsets.  The offsets are from after the CTF header.  */\n+  uint32_t lbloff = 0;\n+  uint32_t objtoff = 0;\n+  uint32_t funcoff = 0;\n+  uint32_t objtidxoff = 0;\n+  uint32_t funcidxoff = 0;\n+  uint32_t varoff = 0;\n+  uint32_t typeoff = 0;\n+  uint32_t stroff = 0;\n+\n+  if (!ctfc_is_empty_container (ctfc))\n+    {\n+      gcc_assert (ctfc_get_num_ctf_types (ctfc)\n+\t\t  == (ctfc->ctfc_num_types + ctfc->ctfc_num_stypes));\n+\n+      funcoff = objtoff + ctfc->ctfc_num_global_objts * sizeof (uint32_t);\n+      /* Object index appears after function info.  */\n+      objtidxoff = funcoff + ctfc->ctfc_num_global_funcs * sizeof (uint32_t);\n+      /* Funxtion index goes next.  */\n+      funcidxoff = objtidxoff + ctfc->ctfc_num_global_objts * sizeof (uint32_t);\n+      /* Vars appear after function index.  */\n+      varoff = funcidxoff + ctfc->ctfc_num_global_funcs * sizeof (uint32_t);\n+      /* CTF types appear after vars.  */\n+      typeoff = varoff + ctfc_get_num_ctf_vars (ctfc) * sizeof (ctf_varent_t);\n+      /* The total number of bytes for CTF types is the sum of the number of\n+\t times struct ctf_type_t, struct ctf_stype_t are written, plus the\n+\t amount of variable length data after each one of these.  */\n+      typeslen = ctfc->ctfc_num_types * sizeof (ctf_type_t)\n+\t\t+ ctfc->ctfc_num_stypes * (sizeof (ctf_stype_t))\n+\t\t+ ctfc_get_num_vlen_bytes (ctfc);\n+\n+      /* Strings appear after types.  */\n+      stroff = typeoff + typeslen;\n+    }\n+\n+    /* Offset of label section.  */\n+    dw2_asm_output_data (4, lbloff, \"cth_lbloff\");\n+    /* Offset of object section.  */\n+    dw2_asm_output_data (4, objtoff, \"cth_objtoff\");\n+    /* Offset of function section.  */\n+    dw2_asm_output_data (4, funcoff, \"cth_funcoff\");\n+    /* Offset of object index section.  */\n+    dw2_asm_output_data (4, objtidxoff, \"cth_objtidxoff\");\n+    /* Offset of function index section.  */\n+    dw2_asm_output_data (4, funcidxoff, \"cth_funcidxoff\");\n+\n+    /* Offset of variable section.  */\n+    dw2_asm_output_data (4, varoff, \"cth_varoff\");\n+    /* Offset of type section.  */\n+    dw2_asm_output_data (4, typeoff, \"cth_typeoff\");\n+    /* Offset of string section.  */\n+    dw2_asm_output_data (4, stroff, \"cth_stroff\");\n+    /* Length of string section in bytes.  */\n+    dw2_asm_output_data (4, ctfc->ctfc_strlen, \"cth_strlen\");\n+}\n+\n+/* Output the CTF object info section.  */\n+\n+static void\n+output_ctf_obj_info (ctf_container_ref ctfc)\n+{\n+  uint64_t i;\n+  ctf_dvdef_ref var;\n+\n+  if (!ctfc->ctfc_num_global_objts) return;\n+\n+  /* Compiler spits out the objts (at global scope) in the CTF obj info section.\n+     In no specific order.  In an object file, the CTF object index section is\n+     used to associate the objts to their corresponding names.  */\n+  for (i = 0; i < ctfc->ctfc_num_global_objts; i++)\n+    {\n+      var = ctfc->ctfc_gobjts_list[i];\n+\n+      /* CTF type ID corresponding to the type of the variable.  */\n+      dw2_asm_output_data (4, var->dvd_type, \"objtinfo_var_type\");\n+    }\n+\n+}\n+\n+/* Output the CTF function info section.  */\n+\n+static void\n+output_ctf_func_info (ctf_container_ref ctfc)\n+{\n+  uint64_t i;\n+  ctf_dtdef_ref ctftype;\n+\n+  if (!ctfc->ctfc_num_global_funcs) return;\n+\n+  /* The CTF funcinfo section is simply an array of CTF_K_FUNCTION type IDs in\n+     the type section.  In an object file, the CTF function index section is\n+     used to associate functions to their corresponding names.  */\n+  for (i = 0; i < ctfc->ctfc_num_global_funcs; i++)\n+    {\n+      ctftype = ctfc->ctfc_gfuncs_list[i];\n+      dw2_asm_output_data (4, ctftype->dtd_type, \"funcinfo_func_type\");\n+    }\n+}\n+\n+/* Output the CTF object index section.  */\n+\n+static void\n+output_ctf_objtidx (ctf_container_ref ctfc)\n+{\n+  uint64_t i;\n+  ctf_dvdef_ref var;\n+\n+  if (!ctfc->ctfc_num_global_objts) return;\n+\n+  for (i = 0; i < ctfc->ctfc_num_global_objts; i++)\n+    {\n+      var = ctfc->ctfc_gobjts_list[i];\n+      /* Offset to the name in CTF string table.  */\n+      dw2_asm_output_data (4, var->dvd_name_offset, \"objtinfo_name\");\n+    }\n+}\n+\n+/* Output the CTF function index section.  */\n+\n+static void\n+output_ctf_funcidx (ctf_container_ref ctfc)\n+{\n+  uint64_t i;\n+  ctf_dtdef_ref ctftype;\n+\n+  if (!ctfc->ctfc_num_global_funcs) return;\n+\n+  for (i = 0; i < ctfc->ctfc_num_global_funcs; i++)\n+    {\n+      ctftype = ctfc->ctfc_gfuncs_list[i];\n+      /* Offset to the name in CTF string table.  */\n+      dw2_asm_output_data (4, ctftype->dtd_data.ctti_name, \"funcinfo_name\");\n+    }\n+}\n+\n+/* Output the CTF variables.  Variables appear in the sorted ASCIIbetical\n+   order of their names.  This permits binary searching in the CTF reader.  */\n+\n+static void\n+output_ctf_vars (ctf_container_ref ctfc)\n+{\n+  size_t i;\n+  size_t num_ctf_vars = ctfc->ctfc_vars->elements ();\n+  if (num_ctf_vars)\n+    {\n+      /* Iterate over the list of sorted vars and output the asm.  */\n+      for (i = 0; i < num_ctf_vars; i++)\n+\t{\n+\t  ctf_asm_varent (ctfc->ctfc_vars_list[i]);\n+\t  /* The type of variable must be a valid one.  */\n+\t  gcc_assert (ctfc->ctfc_vars_list[i]->dvd_type != CTF_NULL_TYPEID);\n+\t}\n+    }\n+}\n+\n+/* Output the CTF string records.  */\n+\n+static void\n+output_ctf_strs (ctf_container_ref ctfc)\n+{\n+  ctf_string_t * ctf_string = ctfc->ctfc_strtable.ctstab_head;\n+\n+  while (ctf_string)\n+    {\n+      dw2_asm_output_nstring (ctf_string->cts_str, -1, \"ctf_string\");\n+      ctf_string = ctf_string->cts_next;\n+    }\n+}\n+\n+/* Output the members of the CTF struct or union.  */\n+\n+static void\n+output_asm_ctf_sou_fields (ctf_container_ref ARG_UNUSED (ctfc),\n+\t\t\t   ctf_dtdef_ref dtd)\n+{\n+  ctf_dmdef_t * dmd;\n+\n+  /* Function pointer to dump struct/union members.  */\n+  void (*ctf_asm_sou_field_func) (ctf_dmdef_t *);\n+\n+  uint32_t size = dtd->dtd_data.ctti_size;\n+\n+  /* The variable length data struct/union CTF types is an array of\n+     ctf_member or ctf_lmember, depending on size of the member.  */\n+  if (size >= CTF_LSTRUCT_THRESH)\n+    ctf_asm_sou_field_func = ctf_asm_sou_lmember;\n+  else\n+    ctf_asm_sou_field_func = ctf_asm_sou_member;\n+\n+  for (dmd = dtd->dtd_u.dtu_members;\n+       dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+    {\n+      ctf_asm_sou_field_func (dmd);\n+      /* Sanity Check - Unrepresented types appear as explicit types.  */\n+      gcc_assert (dmd->dmd_type != CTF_NULL_TYPEID);\n+    }\n+}\n+\n+/* Output the list of enumerator constants of the CTF enum type.  */\n+\n+static void\n+output_asm_ctf_enum_list (ctf_container_ref ARG_UNUSED (ctfc),\n+\t\t\t  ctf_dtdef_ref dtd)\n+{\n+  ctf_dmdef_t * dmd;\n+\n+  for (dmd = dtd->dtd_u.dtu_members;\n+       dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+    ctf_asm_enum_const (dmd);\n+}\n+\n+/* Output the list of function arguments of the CTF function type.  */\n+\n+static void\n+output_asm_func_args_list (ctf_container_ref ARG_UNUSED (ctfc),\n+\t\t\t  ctf_dtdef_ref dtd)\n+{\n+  ctf_func_arg_t * farg;\n+\n+  for (farg = dtd->dtd_u.dtu_argv;\n+       farg != NULL; farg = (ctf_func_arg_t *) ctf_farg_list_next (farg))\n+    ctf_asm_func_arg (farg);\n+}\n+\n+/* Output the variable length portion of the CTF type record.  */\n+\n+static void\n+output_asm_ctf_vlen_bytes (ctf_container_ref ctfc, ctf_dtdef_ref ctftype)\n+{\n+  uint32_t encoding;\n+  uint32_t kind = CTF_V2_INFO_KIND (ctftype->dtd_data.ctti_info);\n+  uint32_t vlen = CTF_V2_INFO_VLEN (ctftype->dtd_data.ctti_info);\n+\n+  switch (kind)\n+    {\n+      case CTF_K_INTEGER:\n+      case CTF_K_FLOAT:\n+\tif (kind == CTF_K_INTEGER)\n+\t  {\n+\t    encoding = CTF_INT_DATA (ctftype->dtd_u.dtu_enc.cte_format,\n+\t\t\t\t     ctftype->dtd_u.dtu_enc.cte_offset,\n+\t\t\t\t     ctftype->dtd_u.dtu_enc.cte_bits);\n+\t  }\n+\telse\n+\t  {\n+\t    encoding = CTF_FP_DATA (ctftype->dtd_u.dtu_enc.cte_format,\n+\t\t\t\t    ctftype->dtd_u.dtu_enc.cte_offset,\n+\t\t\t\t    ctftype->dtd_u.dtu_enc.cte_bits);\n+\t  }\n+\tdw2_asm_output_data (4, encoding, \"ctf_encoding_data\");\n+\tbreak;\n+      case CTF_K_FUNCTION:\n+\t  {\n+\t    output_asm_func_args_list (ctfc, ctftype);\n+\t    /* FIXME - CTF_PADDING_FOR_ALIGNMENT.\n+\t       libctf expects this padding for alignment reasons.  Expected to\n+\t       be redundant in CTF_VERSION_4.  */\n+\t    if (vlen & 1)\n+\t      dw2_asm_output_data (4, 0, \"dtu_argv_padding\");\n+\n+\t    break;\n+\t  }\n+      case CTF_K_ARRAY:\n+\tctf_asm_array (ctftype);\n+\tbreak;\n+      case CTF_K_SLICE:\n+\t  {\n+\t    ctf_asm_slice (ctftype);\n+\t    /* Type of the slice must be a valid CTF type.  */\n+\t    gcc_assert (ctftype->dtd_u.dtu_slice.cts_type != CTF_NULL_TYPEID);\n+\t    break;\n+\t  }\n+      case CTF_K_STRUCT:\n+      case CTF_K_UNION:\n+\toutput_asm_ctf_sou_fields (ctfc, ctftype);\n+\tbreak;\n+      case CTF_K_ENUM:\n+\toutput_asm_ctf_enum_list (ctfc, ctftype);\n+\tbreak;\n+\n+      default:\n+\t/* CTF types of kind CTF_K_VOLATILE, CTF_K_CONST, CTF_K_RESTRICT,\n+\t   etc have no vlen data to write.  */\n+\tbreak;\n+    }\n+}\n+\n+/* Output a CTF Type.  */\n+\n+static void\n+output_asm_ctf_type (ctf_container_ref ctfc, ctf_dtdef_ref type)\n+{\n+  if (type->dtd_data.ctti_size <= CTF_MAX_SIZE)\n+    ctf_asm_stype (type);\n+  else\n+    ctf_asm_type (type);\n+  /* Now comes the variable-length portion for defining types completely.\n+     E.g., encoding follows CTF_INT_DATA, CTF_FP_DATA types,\n+     struct ctf_array_t follows CTF_K_ARRAY types, or a bunch of\n+     struct ctf_member / ctf_lmember ctf_enum sit in there for CTF_K_STRUCT or\n+     CTF_K_UNION.  */\n+  output_asm_ctf_vlen_bytes (ctfc, type);\n+\n+  uint32_t kind = CTF_V2_INFO_KIND (type->dtd_data.ctti_info);\n+  /* The underlying type must be a valid CTF type.  */\n+  if (kind == CTF_K_POINTER || kind == CTF_K_TYPEDEF\n+      || kind == CTF_K_VOLATILE || kind == CTF_K_CONST\n+      || kind == CTF_K_RESTRICT)\n+    gcc_assert (type->dtd_data.ctti_type != CTF_NULL_TYPEID);\n+}\n+\n+/* Output all CTF type records.  */\n+\n+static void\n+output_ctf_types (ctf_container_ref ctfc)\n+{\n+  size_t i;\n+  size_t num_ctf_types = ctfc->ctfc_types->elements ();\n+  if (num_ctf_types)\n+    {\n+      /* Type ID = 0 is used as sentinel value; not a valid type.  */\n+      for (i = 1; i <= num_ctf_types; i++)\n+\toutput_asm_ctf_type (ctfc, ctfc->ctfc_types_list[i]);\n+    }\n+}\n+\n+/* CTF routines interfacing to the compiler.  */\n+\n+/* Prepare and output the CTF section.  */\n+\n+void\n+ctf_output (const char * filename)\n+{\n+  if (ctf_debug_info_level == CTFINFO_LEVEL_NONE)\n+    return;\n+\n+  /* Get the CTF container for the current translation unit.  */\n+  ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n+\n+  init_ctf_sections ();\n+\n+  ctf_add_cuname (tu_ctfc, filename);\n+\n+  /* Pre-process CTF before generating assembly.  */\n+  ctf_preprocess (tu_ctfc);\n+  output_ctf_header (tu_ctfc);\n+  output_ctf_obj_info (tu_ctfc);\n+  output_ctf_func_info (tu_ctfc);\n+  output_ctf_objtidx (tu_ctfc);\n+  output_ctf_funcidx (tu_ctfc);\n+  output_ctf_vars (tu_ctfc);\n+  output_ctf_types (tu_ctfc);\n+  output_ctf_strs (tu_ctfc);\n+\n+  /* The total number of string bytes must be equal to those processed out to\n+     the str subsection.  */\n+  gcc_assert (tu_ctfc->ctfc_strlen\n+\t      == ctfc_get_strtab_len (tu_ctfc, CTF_STRTAB));\n+\n+}\n+\n+/* Reset all state for CTF generation so that we can rerun the compiler within\n+   the same process.  */\n+\n+void\n+ctf_finalize (void)\n+{\n+  ctf_info_section = NULL;\n+\n+  ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n+  ctfc_delete_container (tu_ctfc);\n+  tu_ctfc = NULL;\n+}\n+\n+#include \"gt-ctfout.h\""}, {"sha": "df9b625f5bcc255404066dada43f8606776553db", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -3558,7 +3558,7 @@ dwarf2out_do_frame (void)\n   /* We want to emit correct CFA location expressions or lists, so we\n      have to return true if we're going to generate debug info, even if\n      we're not going to output frame or unwind info.  */\n-  if (dwarf_debuginfo_p ())\n+  if (dwarf_debuginfo_p () || dwarf_based_debuginfo_p ())\n     return true;\n \n   if (saved_do_cfi_asm > 0)"}, {"sha": "08e12520daaf8e38c51db63f62afa535619c28bf", "filename": "gcc/dwarf2ctf.c", "status": "added", "additions": 990, "deletions": 0, "changes": 990, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2ctf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2ctf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2ctf.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,990 @@\n+/* Generate CTF types and objects from the GCC DWARF.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"dwarf2out.h\"\n+#include \"dwarf2out.h\"\n+\n+#include \"dwarf2ctf.h\"\n+#include \"ctfc.h\"\n+\n+/* Forward declarations for some routines defined in this file.  */\n+\n+static ctf_id_t\n+gen_ctf_type (ctf_container_ref, dw_die_ref);\n+\n+/* All the DIE structures we handle come from the DWARF information\n+   generated by GCC.  However, there are two situations where we need\n+   to create our own created DIE structures because GCC doesn't\n+   provide them.\n+\n+   The DWARF spec suggests using a DIE with DW_TAG_unspecified_type\n+   and name \"void\" in order to denote the void type.  But GCC doesn't\n+   follow this advice.  Still we need a DIE to act as a key for void\n+   types, we use ctf_void_die.\n+\n+   Also, if a subrange type corresponding to an array index does not\n+   specify a type then we assume it is `int'.\n+\n+   Finally, for types unrepresentable in CTF, we need a DIE to anchor\n+   them to a CTF type of kind unknown.\n+\n+   The variables below are initialized in ctf_debug_init and hold\n+   references to the proper DIEs.  */\n+\n+static GTY (()) dw_die_ref ctf_void_die;\n+static GTY (()) dw_die_ref ctf_array_index_die;\n+static GTY (()) dw_die_ref ctf_unknown_die;\n+\n+/* Some DIEs have a type description attribute, stored in a DW_AT_type\n+   attribute.  However, GCC generates no attribute to signify a `void'\n+   type.\n+\n+   This can happen in many contexts (return type of a function,\n+   pointed or qualified type, etc) so we use the `ctf_get_AT_type'\n+   function below abstracts this.  */\n+\n+static dw_die_ref\n+ctf_get_AT_type (dw_die_ref die)\n+{\n+  dw_die_ref type_die = get_AT_ref (die, DW_AT_type);\n+  return (type_die ? type_die : ctf_void_die);\n+}\n+\n+/* Some data member DIEs have location specified as a DWARF expression\n+   (specifically in DWARF2).  Luckily, the expression is a simple\n+   DW_OP_plus_uconst with one operand set to zero.\n+\n+   Sometimes the data member location may also be negative.  In yet some other\n+   cases (specifically union data members), the data member location is\n+   non-existent.  Handle all these scenarios here to abstract this.  */\n+\n+static HOST_WIDE_INT\n+ctf_get_AT_data_member_location (dw_die_ref die)\n+{\n+  HOST_WIDE_INT field_location = 0;\n+  dw_attr_node * attr;\n+\n+  /* The field location (in bits) can be determined from\n+     either a DW_AT_data_member_location attribute or a\n+     DW_AT_data_bit_offset attribute.  */\n+  if (get_AT (die, DW_AT_data_bit_offset))\n+    field_location = get_AT_unsigned (die, DW_AT_data_bit_offset);\n+  else\n+    {\n+      attr = get_AT (die, DW_AT_data_member_location);\n+      if (attr && AT_class (attr) == dw_val_class_loc)\n+\t{\n+\t  dw_loc_descr_ref descr = AT_loc (attr);\n+\t  /* Operand 2 must be zero; the structure is assumed to be on the\n+\t     stack in DWARF2.  */\n+\t  gcc_assert (!descr->dw_loc_oprnd2.v.val_unsigned);\n+\t  gcc_assert (descr->dw_loc_oprnd2.val_class\n+\t\t      == dw_val_class_unsigned_const);\n+\t  field_location = descr->dw_loc_oprnd1.v.val_unsigned;\n+\t}\n+      else\n+\t{\n+\t  attr = get_AT (die, DW_AT_data_member_location);\n+\t  if (attr && AT_class (attr) == dw_val_class_const)\n+\t    field_location = AT_int (attr);\n+\t  else\n+\t    field_location = (get_AT_unsigned (die,\n+\t\t\t\t\t   DW_AT_data_member_location)\n+\t\t\t      * 8);\n+\t}\n+    }\n+\n+  return field_location;\n+}\n+\n+/* CTF Types' and CTF Variables' Location Information.  CTF section does not\n+   emit location information, this is provided for BTF CO-RE use-cases.  These\n+   functions fetch information from DWARF Die directly, as such the location\n+   information is not buffered in the CTF container.  */\n+\n+const char *\n+ctf_get_die_loc_file (dw_die_ref die)\n+{\n+  if (!die)\n+    return NULL;\n+\n+  struct dwarf_file_data * file;\n+  file = get_AT_file (die, DW_AT_decl_file);\n+  if (!file)\n+    return NULL;\n+\n+  return file->filename;\n+}\n+\n+unsigned int\n+ctf_get_die_loc_line (dw_die_ref die)\n+{\n+  if (!die)\n+    return 0;\n+\n+  return get_AT_unsigned (die, DW_AT_decl_line);\n+}\n+\n+unsigned int\n+ctf_get_die_loc_col (dw_die_ref die)\n+{\n+  if (!die)\n+    return 0;\n+\n+  return get_AT_unsigned (die, DW_AT_decl_column);\n+}\n+\n+/* Generate CTF for the void type.  */\n+\n+static ctf_id_t\n+gen_ctf_void_type (ctf_container_ref ctfc)\n+{\n+  ctf_encoding_t ctf_encoding = {0, 0, 0};\n+\n+  /* In CTF the void type is encoded as a 0-byte signed integer\n+     type.  */\n+\n+  ctf_encoding.cte_bits = 0;\n+  ctf_encoding.cte_format = CTF_INT_SIGNED;\n+\n+  gcc_assert (ctf_void_die != NULL);\n+  return ctf_add_integer (ctfc, CTF_ADD_ROOT, \"void\",\n+\t\t\t  &ctf_encoding, ctf_void_die);\n+}\n+\n+/* Generate CTF type of unknown kind.  */\n+\n+static ctf_id_t\n+gen_ctf_unknown_type (ctf_container_ref ctfc)\n+{\n+  ctf_id_t unknown_type_id;\n+\n+  /* In CTF, the unknown type is encoded as a 0 byte sized type with kind\n+     CTF_K_UNKNOWN.  Create an encoding object merely to reuse the underlying\n+     ctf_add_encoded interface; the CTF encoding object is not 'used' any more\n+     than just the generation of size from.  */\n+  ctf_encoding_t ctf_encoding = {0, 0, 0};\n+\n+  gcc_assert (ctf_unknown_die != NULL);\n+  /* Type de-duplication.  */\n+  if (!ctf_type_exists (ctfc, ctf_unknown_die, &unknown_type_id))\n+    unknown_type_id = ctf_add_unknown (ctfc, CTF_ADD_ROOT, \"unknown\",\n+\t\t\t\t       &ctf_encoding, ctf_unknown_die);\n+\n+  return unknown_type_id;\n+}\n+\n+/* Sizes of entities can be given in bytes or bits.  This function\n+   abstracts this by returning the size in bits of the given entity.\n+   If no DW_AT_byte_size nor DW_AT_bit_size are defined, this function\n+   returns 0.  */\n+\n+static uint32_t\n+ctf_die_bitsize (dw_die_ref die)\n+{\n+  dw_attr_node *attr_byte_size = get_AT (die, DW_AT_byte_size);\n+  dw_attr_node *attr_bit_size = get_AT (die, DW_AT_bit_size);\n+\n+  if (attr_bit_size)\n+    return AT_unsigned (attr_bit_size);\n+  else if (attr_byte_size)\n+    return (AT_unsigned (attr_byte_size) * 8);\n+  else\n+    return 0;\n+}\n+\n+/* Generate CTF for base type (integer, boolean, real, fixed point and complex).\n+   Important: the caller of this API must make sure that duplicate types are\n+   not added.  */\n+\n+static ctf_id_t\n+gen_ctf_base_type (ctf_container_ref ctfc, dw_die_ref type)\n+{\n+  ctf_id_t type_id = CTF_NULL_TYPEID;\n+\n+  ctf_encoding_t ctf_encoding = {0, 0, 0};\n+\n+  unsigned int encoding = get_AT_unsigned (type, DW_AT_encoding);\n+  unsigned int bit_size = ctf_die_bitsize (type);\n+  const char * name_string = get_AT_string (type, DW_AT_name);\n+\n+  switch (encoding)\n+    {\n+    case DW_ATE_void:\n+\n+      ctf_encoding.cte_format = CTF_INT_SIGNED;\n+      ctf_encoding.cte_bits = 0;\n+\n+      gcc_assert (name_string);\n+      type_id = ctf_add_integer (ctfc, CTF_ADD_ROOT, name_string,\n+\t\t\t\t &ctf_encoding, type);\n+\n+      break;\n+    case DW_ATE_boolean:\n+\n+      ctf_encoding.cte_format = CTF_INT_BOOL;\n+      ctf_encoding.cte_bits = bit_size;\n+\n+      gcc_assert (name_string);\n+      type_id = ctf_add_integer (ctfc, CTF_ADD_ROOT, name_string,\n+\t\t\t\t &ctf_encoding, type);\n+      break;\n+    case DW_ATE_float:\n+      {\n+\tunsigned int float_bit_size\n+\t  = tree_to_uhwi (TYPE_SIZE (float_type_node));\n+\tunsigned int double_bit_size\n+\t  = tree_to_uhwi (TYPE_SIZE (double_type_node));\n+\tunsigned int long_double_bit_size\n+\t  = tree_to_uhwi (TYPE_SIZE (long_double_type_node));\n+\n+\tif (bit_size == float_bit_size)\n+\t  ctf_encoding.cte_format = CTF_FP_SINGLE;\n+\telse if (bit_size == double_bit_size)\n+\t  ctf_encoding.cte_format = CTF_FP_DOUBLE;\n+\telse if (bit_size == long_double_bit_size)\n+\t  ctf_encoding.cte_format = CTF_FP_LDOUBLE;\n+\telse\n+\t  /* CTF does not have representation for other types.  Skip them.  */\n+\t  break;\n+\n+\tctf_encoding.cte_bits = bit_size;\n+\ttype_id = ctf_add_float (ctfc, CTF_ADD_ROOT, name_string,\n+\t\t\t\t &ctf_encoding, type);\n+\n+\tbreak;\n+      }\n+    case DW_ATE_signed_char:\n+      /* FALLTHROUGH */\n+    case DW_ATE_unsigned_char:\n+      /* FALLTHROUGH */\n+    case DW_ATE_signed:\n+      /* FALLTHROUGH */\n+    case DW_ATE_unsigned:\n+\n+      if (encoding == DW_ATE_signed_char\n+\t  || encoding == DW_ATE_unsigned_char)\n+\tctf_encoding.cte_format |= CTF_INT_CHAR;\n+\n+      if (encoding == DW_ATE_signed\n+\t  || encoding == DW_ATE_signed_char)\n+\tctf_encoding.cte_format |= CTF_INT_SIGNED;\n+\n+      ctf_encoding.cte_bits = bit_size;\n+      type_id = ctf_add_integer (ctfc, CTF_ADD_ROOT, name_string,\n+\t\t\t\t &ctf_encoding, type);\n+      break;\n+\n+    case DW_ATE_complex_float:\n+      {\n+\tunsigned int float_bit_size\n+\t  = tree_to_uhwi (TYPE_SIZE (float_type_node));\n+\tunsigned int double_bit_size\n+\t  = tree_to_uhwi (TYPE_SIZE (double_type_node));\n+\tunsigned int long_double_bit_size\n+\t  = tree_to_uhwi (TYPE_SIZE (long_double_type_node));\n+\n+\tif (bit_size == float_bit_size * 2)\n+\t  ctf_encoding.cte_format = CTF_FP_CPLX;\n+\telse if (bit_size == double_bit_size * 2)\n+\t  ctf_encoding.cte_format = CTF_FP_DCPLX;\n+\telse if (bit_size == long_double_bit_size * 2)\n+\t    ctf_encoding.cte_format = CTF_FP_LDCPLX;\n+\telse\n+\t  /* CTF does not have representation for other types.  Skip them.  */\n+\t  break;\n+\n+\tctf_encoding.cte_bits = bit_size;\n+\ttype_id = ctf_add_float (ctfc, CTF_ADD_ROOT, name_string,\n+\t\t\t\t &ctf_encoding, type);\n+\tbreak;\n+      }\n+    default:\n+      /* Ignore.  */\n+      break;\n+    }\n+\n+  return type_id;\n+}\n+\n+/* Generate CTF for a pointer type.  */\n+\n+static ctf_id_t\n+gen_ctf_pointer_type (ctf_container_ref ctfc, dw_die_ref ptr_type)\n+{\n+  ctf_id_t type_id = CTF_NULL_TYPEID;\n+  ctf_id_t ptr_type_id = CTF_NULL_TYPEID;\n+  dw_die_ref pointed_type_die = ctf_get_AT_type (ptr_type);\n+\n+  type_id = gen_ctf_type (ctfc, pointed_type_die);\n+\n+  /* Type de-duplication.\n+     Consult the ctfc_types hash again before adding the CTF pointer type\n+     because there can be cases where a pointer type may have been added by\n+     the gen_ctf_type call above.  */\n+  if (ctf_type_exists (ctfc, ptr_type, &ptr_type_id))\n+    return ptr_type_id;\n+\n+  ptr_type_id = ctf_add_pointer (ctfc, CTF_ADD_ROOT, type_id, ptr_type);\n+  return ptr_type_id;\n+}\n+\n+/* Generate CTF for an array type.  */\n+\n+static ctf_id_t\n+gen_ctf_array_type (ctf_container_ref ctfc, dw_die_ref array_type)\n+{\n+  dw_die_ref c;\n+  ctf_id_t array_elems_type_id = CTF_NULL_TYPEID;\n+\n+  int vector_type_p = get_AT_flag (array_type, DW_AT_GNU_vector);\n+  if (vector_type_p)\n+    return array_elems_type_id;\n+\n+  dw_die_ref array_elems_type = ctf_get_AT_type (array_type);\n+\n+  /* First, register the type of the array elements if needed.  */\n+  array_elems_type_id = gen_ctf_type (ctfc, array_elems_type);\n+\n+  /* DWARF array types pretend C supports multi-dimensional arrays.\n+     So for the type int[N][M], the array type DIE contains two\n+     subrange_type children, the first iwth upper bound N-1 and the\n+     second with upper bound M-1.\n+\n+     CTF, on the other hand, just encodes each array type in its own\n+     array type CTF struct.  Therefore we have to iterate on the\n+     children and create all the needed types.  */\n+\n+  c = dw_get_die_child (array_type);\n+  gcc_assert (c);\n+  do\n+    {\n+      ctf_arinfo_t arinfo;\n+      dw_die_ref array_index_type;\n+      uint32_t array_num_elements;\n+\n+      c = dw_get_die_sib (c);\n+\n+      if (dw_get_die_tag (c) == DW_TAG_subrange_type)\n+\t{\n+\t  dw_attr_node *upper_bound_at;\n+\n+\t  array_index_type = ctf_get_AT_type (c);\n+\n+\t  /* When DW_AT_upper_bound is used to specify the size of an\n+\t     array in DWARF, it is usually an unsigned constant\n+\t     specifying the upper bound index of the array.  However,\n+\t     for unsized arrays, such as foo[] or bar[0],\n+\t     DW_AT_upper_bound is a signed integer constant\n+\t     instead.  */\n+\n+\t  upper_bound_at = get_AT (c, DW_AT_upper_bound);\n+\t  if (upper_bound_at\n+\t      && AT_class (upper_bound_at) == dw_val_class_unsigned_const)\n+\t    /* This is the upper bound index.  */\n+\t    array_num_elements = get_AT_unsigned (c, DW_AT_upper_bound) + 1;\n+\t  else if (get_AT (c, DW_AT_count))\n+\t    array_num_elements = get_AT_unsigned (c, DW_AT_count);\n+\t  else\n+\t    {\n+\t      /* This is a VLA of some kind.  */\n+\t      array_num_elements = 0;\n+\t    }\n+\t}\n+      else if (dw_get_die_tag (c) == DW_TAG_enumeration_type)\n+\t{\n+\t  array_index_type = 0;\n+\t  array_num_elements = 0;\n+\t  /* XXX writeme. */\n+\t  gcc_assert (1);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+      /* Ok, mount and register the array type.  Note how the array\n+\t type we register here is the type of the elements in\n+\t subsequent \"dimensions\", if there are any.  */\n+\n+      arinfo.ctr_nelems = array_num_elements;\n+      if (array_index_type)\n+\tarinfo.ctr_index = gen_ctf_type (ctfc, array_index_type);\n+      else\n+\tarinfo.ctr_index = gen_ctf_type (ctfc, ctf_array_index_die);\n+\n+      arinfo.ctr_contents = array_elems_type_id;\n+      if (!ctf_type_exists (ctfc, c, &array_elems_type_id))\n+\tarray_elems_type_id = ctf_add_array (ctfc, CTF_ADD_ROOT, &arinfo,\n+\t\t\t\t\t     c);\n+    }\n+  while (c != dw_get_die_child (array_type));\n+\n+#if 0\n+  /* Type de-duplication.\n+     Consult the ctfc_types hash again before adding the CTF array type because\n+     there can be cases where an array_type type may have been added by the\n+     gen_ctf_type call above.  */\n+  if (!ctf_type_exists (ctfc, array_type, &type_id))\n+    type_id = ctf_add_array (ctfc, CTF_ADD_ROOT, &arinfo, array_type);\n+#endif\n+\n+  return array_elems_type_id;\n+}\n+\n+/* Generate CTF for a typedef.  */\n+\n+static ctf_id_t\n+gen_ctf_typedef (ctf_container_ref ctfc, dw_die_ref tdef)\n+{\n+  ctf_id_t tdef_type_id, tid;\n+  const char *tdef_name = get_AT_string (tdef, DW_AT_name);\n+  dw_die_ref tdef_type = ctf_get_AT_type (tdef);\n+\n+  tid = gen_ctf_type (ctfc, tdef_type);\n+\n+  /* Type de-duplication.\n+     This is necessary because the ctf for the typedef may have been already\n+     added due to the gen_ctf_type call above.  */\n+  if (!ctf_type_exists (ctfc, tdef, &tdef_type_id))\n+  {\n+    tdef_type_id = ctf_add_typedef (ctfc, CTF_ADD_ROOT,\n+\t\t\t\t    tdef_name,\n+\t\t\t\t    tid,\n+\t\t\t\t    tdef);\n+  }\n+  return tdef_type_id;\n+}\n+\n+/* Generate CTF for a type modifier.\n+\n+   If the given DIE contains a valid C modifier (like _Atomic), which is not\n+   supported by CTF, then this function skips the modifier die and continues\n+   with the underlying type.\n+\n+   For all other cases, this function returns a CTF_NULL_TYPEID;\n+*/\n+\n+static ctf_id_t\n+gen_ctf_modifier_type (ctf_container_ref ctfc, dw_die_ref modifier)\n+{\n+  uint32_t kind = CTF_K_MAX;\n+  ctf_id_t modifier_type_id, qual_type_id;\n+  dw_die_ref qual_type = ctf_get_AT_type (modifier);\n+\n+  switch (dw_get_die_tag (modifier))\n+    {\n+    case DW_TAG_const_type: kind = CTF_K_CONST; break;\n+    case DW_TAG_volatile_type: kind = CTF_K_VOLATILE; break;\n+    case DW_TAG_restrict_type: kind = CTF_K_RESTRICT; break;\n+    case DW_TAG_atomic_type: break;\n+    default:\n+      return CTF_NULL_TYPEID;\n+    }\n+\n+  /* Register the type for which this modifier applies.  */\n+  qual_type_id = gen_ctf_type (ctfc, qual_type);\n+\n+  /* Skip generating a CTF modifier record for _Atomic as there is no\n+     representation for it.  */\n+  if (dw_get_die_tag (modifier) == DW_TAG_atomic_type)\n+    return qual_type_id;\n+\n+  gcc_assert (kind != CTF_K_MAX);\n+  /* Now register the modifier itself.  */\n+  if (!ctf_type_exists (ctfc, modifier, &modifier_type_id))\n+    modifier_type_id = ctf_add_reftype (ctfc, CTF_ADD_ROOT,\n+\t\t\t\t\tqual_type_id, kind,\n+\t\t\t\t\tmodifier);\n+\n+  return modifier_type_id;\n+}\n+\n+/* Generate CTF for a struct type.  */\n+\n+static ctf_id_t\n+gen_ctf_sou_type (ctf_container_ref ctfc, dw_die_ref sou, uint32_t kind)\n+{\n+  uint32_t bit_size = ctf_die_bitsize (sou);\n+  int declaration_p = get_AT_flag (sou, DW_AT_declaration);\n+  const char *sou_name = get_AT_string (sou, DW_AT_name);\n+\n+  ctf_id_t sou_type_id;\n+\n+  /* An incomplete structure or union type is represented in DWARF by\n+     a structure or union DIE that does not have a size attribute and\n+     that has a DW_AT_declaration attribute.  This corresponds to a\n+     CTF forward type with kind CTF_K_STRUCT.  */\n+  if (bit_size == 0 && declaration_p)\n+    return ctf_add_forward (ctfc, CTF_ADD_ROOT,\n+\t\t\t    sou_name, kind, sou);\n+\n+  /* This is a complete struct or union type.  Generate a CTF type for\n+     it if it doesn't exist already.  */\n+  if (!ctf_type_exists (ctfc, sou, &sou_type_id))\n+    sou_type_id = ctf_add_sou (ctfc, CTF_ADD_ROOT,\n+\t\t\t       sou_name, kind, bit_size / 8,\n+\t\t\t       sou);\n+\n+  /* Now process the struct members.  */\n+  {\n+    dw_die_ref c;\n+\n+    c = dw_get_die_child (sou);\n+    if (c)\n+      do\n+\t{\n+\t  const char *field_name;\n+\t  dw_die_ref field_type;\n+\t  HOST_WIDE_INT field_location;\n+\t  ctf_id_t field_type_id;\n+\n+\t  c = dw_get_die_sib (c);\n+\n+\t  field_name = get_AT_string (c, DW_AT_name);\n+\t  field_type = ctf_get_AT_type (c);\n+\t  field_location = ctf_get_AT_data_member_location (c);\n+\n+\t  /* Generate the field type.  */\n+\t  field_type_id = gen_ctf_type (ctfc, field_type);\n+\n+\t  /* If this is a bit-field, then wrap the field type\n+\t     generated above with a CTF slice.  */\n+\t  if (get_AT (c, DW_AT_bit_offset)\n+\t      || get_AT (c, DW_AT_data_bit_offset))\n+\t    {\n+\t      dw_attr_node *attr;\n+\t      HOST_WIDE_INT bitpos = 0;\n+\t      HOST_WIDE_INT bitsize = ctf_die_bitsize (c);\n+\t      HOST_WIDE_INT bit_offset;\n+\n+\t      /* The bit offset is given in bits and it may be\n+\t\t negative.  */\n+\t      attr = get_AT (c, DW_AT_bit_offset);\n+\t      if (attr)\n+\t\t{\n+\t\t  if (AT_class (attr) == dw_val_class_unsigned_const)\n+\t\t    bit_offset = AT_unsigned (attr);\n+\t\t  else\n+\t\t    bit_offset = AT_int (attr);\n+\n+\t\t  if (BYTES_BIG_ENDIAN)\n+\t\t    bitpos = field_location + bit_offset;\n+\t\t  else\n+\t\t    {\n+\t\t      HOST_WIDE_INT bit_size;\n+\n+\t\t      attr = get_AT (c, DW_AT_byte_size);\n+\t\t      if (attr)\n+\t\t\t/* Explicit size given in bytes.  */\n+\t\t\tbit_size = AT_unsigned (attr) * 8;\n+\t\t      else\n+\t\t\t/* Infer the size from the member type.  */\n+\t\t\tbit_size = ctf_die_bitsize (field_type);\n+\n+\t\t      bitpos = (field_location\n+\t\t\t\t+ bit_size\n+\t\t\t\t- bit_offset\n+\t\t\t\t- bitsize);\n+\t\t    }\n+\t\t}\n+\n+\t      /* In DWARF5 a data_bit_offset attribute is given with\n+\t\t the offset of the data from the beginning of the\n+\t\t struct.  Acknowledge it if present.  */\n+\t      attr = get_AT (c, DW_AT_data_bit_offset);\n+\t      if (attr)\n+\t\tbitpos += AT_unsigned (attr);\n+\n+\t      field_type_id = ctf_add_slice (ctfc, CTF_ADD_NONROOT,\n+\t\t\t\t\t     field_type_id,\n+\t\t\t\t\t     bitpos - field_location,\n+\t\t\t\t\t     bitsize,\n+\t\t\t\t\t     c);\n+\t    }\n+\n+\t  /* Add the field type to the struct or union type.  */\n+\t  ctf_add_member_offset (ctfc, sou,\n+\t\t\t\t field_name,\n+\t\t\t\t field_type_id,\n+\t\t\t\t field_location);\n+\t}\n+      while (c != dw_get_die_child (sou));\n+  }\n+\n+  return sou_type_id;\n+}\n+\n+/* Generate CTF for a function type.  */\n+\n+static ctf_id_t\n+gen_ctf_function_type (ctf_container_ref ctfc, dw_die_ref function,\n+\t\t       bool from_global_func)\n+{\n+  const char *function_name = get_AT_string (function, DW_AT_name);\n+  dw_die_ref return_type = ctf_get_AT_type (function);\n+\n+  ctf_funcinfo_t func_info;\n+  uint32_t num_args = 0;\n+\n+  ctf_id_t return_type_id;\n+  ctf_id_t function_type_id;\n+\n+  /* First, add the return type.  */\n+  return_type_id = gen_ctf_type (ctfc, return_type);\n+  func_info.ctc_return = return_type_id;\n+\n+  /* Type de-duplication.\n+     Consult the ctfc_types hash before adding the CTF function type.  */\n+  if (ctf_type_exists (ctfc, function, &function_type_id))\n+    return function_type_id;\n+\n+  /* Do a first pass on the formals to determine the number of\n+     arguments, and whether the function type gets a varargs.  */\n+  {\n+    dw_die_ref c;\n+\n+    c = dw_get_die_child (function);\n+    if (c)\n+      do\n+\t{\n+\t  c = dw_get_die_sib (c);\n+\n+\t  if (dw_get_die_tag (c) == DW_TAG_formal_parameter)\n+\t    num_args += 1;\n+\t  else if (dw_get_die_tag (c) == DW_TAG_unspecified_parameters)\n+\t    {\n+\t      func_info.ctc_flags |= CTF_FUNC_VARARG;\n+\t      num_args += 1;\n+\t    }\n+\t}\n+      while (c != dw_get_die_child (function));\n+  }\n+\n+  /* Note the number of typed arguments _includes_ the vararg.  */\n+  func_info.ctc_argc = num_args;\n+\n+  /* Type de-duplication has already been performed by now.  */\n+  function_type_id = ctf_add_function (ctfc, CTF_ADD_ROOT,\n+\t\t\t\t       function_name,\n+\t\t\t\t       (const ctf_funcinfo_t *)&func_info,\n+\t\t\t\t       function,\n+\t\t\t\t       from_global_func);\n+\n+  /* Second pass on formals: generate the CTF types corresponding to\n+     them and add them as CTF function args.  */\n+  {\n+    dw_die_ref c;\n+    unsigned int i = 0;\n+    const char *arg_name;\n+    ctf_id_t arg_type;\n+\n+    c = dw_get_die_child (function);\n+    if (c)\n+      do\n+\t{\n+\t  c = dw_get_die_sib (c);\n+\n+\t  if (dw_get_die_tag (c) == DW_TAG_unspecified_parameters)\n+\t    {\n+\t      gcc_assert (i == num_args - 1);\n+\t      /* Add an argument with type 0 and no name.  */\n+\t      ctf_add_function_arg (ctfc, function, \"\", 0);\n+\t    }\n+\t  else if (dw_get_die_tag (c) == DW_TAG_formal_parameter)\n+\t    {\n+\t      i++;\n+\t      arg_name = get_AT_string (c, DW_AT_name);\n+\t      arg_type = gen_ctf_type (ctfc, ctf_get_AT_type (c));\n+\t      /* Add the argument to the existing CTF function type.  */\n+\t      ctf_add_function_arg (ctfc, function, arg_name, arg_type);\n+\t    }\n+\t  else\n+\t    /* This is a local variable.  Ignore.  */\n+\t    continue;\n+\t}\n+      while (c != dw_get_die_child (function));\n+  }\n+\n+  return function_type_id;\n+}\n+\n+/* Generate CTF for an enumeration type.  */\n+\n+static ctf_id_t\n+gen_ctf_enumeration_type (ctf_container_ref ctfc, dw_die_ref enumeration)\n+{\n+  const char *enum_name = get_AT_string (enumeration, DW_AT_name);\n+  unsigned int bit_size = ctf_die_bitsize (enumeration);\n+  int declaration_p = get_AT_flag (enumeration, DW_AT_declaration);\n+\n+  ctf_id_t enumeration_type_id;\n+\n+  /* If this is an incomplete enum, generate a CTF forward for it and\n+     be done.  */\n+  if (declaration_p)\n+    {\n+      gcc_assert (enum_name);\n+      return ctf_add_forward (ctfc, CTF_ADD_ROOT, enum_name,\n+\t\t\t      CTF_K_ENUM, enumeration);\n+    }\n+\n+  /* If the size the enumerators is not specified then use the size of\n+     the underlying type, which must be a base type.  */\n+  if (bit_size == 0)\n+    {\n+      dw_die_ref type = ctf_get_AT_type (enumeration);\n+      bit_size = ctf_die_bitsize (type);\n+    }\n+\n+  /* Generate a CTF type for the enumeration.  */\n+  enumeration_type_id = ctf_add_enum (ctfc, CTF_ADD_ROOT,\n+\t\t\t\t      enum_name, bit_size / 8, enumeration);\n+\n+  /* Process the enumerators.  */\n+  {\n+    dw_die_ref c;\n+\n+    c = dw_get_die_child (enumeration);\n+    if (c)\n+      do\n+\t{\n+\t  const char *enumerator_name;\n+\t  dw_attr_node *enumerator_value;\n+\t  HOST_WIDE_INT value_wide_int;\n+\n+\t  c = dw_get_die_sib (c);\n+\n+\t  enumerator_name = get_AT_string (c, DW_AT_name);\n+\t  enumerator_value = get_AT (c, DW_AT_const_value);\n+\n+\t  /* enumerator_value can be either a signed or an unsigned\n+\t     constant value.  */\n+\t  if (AT_class (enumerator_value) == dw_val_class_unsigned_const\n+\t      || (AT_class (enumerator_value)\n+\t\t  == dw_val_class_unsigned_const_implicit))\n+\t    value_wide_int = AT_unsigned (enumerator_value);\n+\t  else\n+\t    value_wide_int = AT_int (enumerator_value);\n+\n+\t  ctf_add_enumerator (ctfc, enumeration_type_id,\n+\t\t\t      enumerator_name, value_wide_int, enumeration);\n+\t}\n+      while (c != dw_get_die_child (enumeration));\n+  }\n+\n+  return enumeration_type_id;\n+}\n+\n+/* Add a CTF variable record for the given input DWARF DIE.  */\n+\n+static void\n+gen_ctf_variable (ctf_container_ref ctfc, dw_die_ref die)\n+{\n+  const char *var_name = get_AT_string (die, DW_AT_name);\n+  dw_die_ref var_type = ctf_get_AT_type (die);\n+  unsigned int external_vis = get_AT_flag (die, DW_AT_external);\n+  ctf_id_t var_type_id;\n+\n+  /* Avoid duplicates.  */\n+  if (ctf_dvd_lookup (ctfc, die))\n+    return;\n+\n+  /* Add the type of the variable.  */\n+  var_type_id = gen_ctf_type (ctfc, var_type);\n+\n+  /* Generate the new CTF variable and update global counter.  */\n+  (void) ctf_add_variable (ctfc, var_name, var_type_id, die, external_vis);\n+  ctfc->ctfc_num_global_objts += 1;\n+}\n+\n+/* Add a CTF function record for the given input DWARF DIE.  */\n+\n+static void\n+gen_ctf_function (ctf_container_ref ctfc, dw_die_ref die)\n+{\n+  ctf_id_t function_type_id;\n+  /* Type de-duplication.\n+     Consult the ctfc_types hash before adding the CTF function type.  */\n+  if (ctf_type_exists (ctfc, die, &function_type_id))\n+    return;\n+\n+  /* Add the type of the function and update the global functions\n+     counter.  Note that DWARF encodes function types in both\n+     DW_TAG_subroutine_type and DW_TAG_subprogram in exactly the same\n+     way.  */\n+  (void) gen_ctf_function_type (ctfc, die, true /* from_global_func */);\n+  ctfc->ctfc_num_global_funcs += 1;\n+}\n+\n+/* Add CTF type record(s) for the given input DWARF DIE and return its type id.\n+\n+   If there is already a CTF type corresponding to the given DIE, then\n+   this function returns the type id of the existing type.\n+\n+   If the given DIE is not recognized as a type, then this function\n+   returns CTF_NULL_TYPEID.  */\n+\n+static ctf_id_t\n+gen_ctf_type (ctf_container_ref ctfc, dw_die_ref die)\n+{\n+  ctf_id_t type_id;\n+  int unrecog_die = false;\n+\n+  if (ctf_type_exists (ctfc, die, &type_id))\n+    return type_id;\n+\n+  switch (dw_get_die_tag (die))\n+    {\n+    case DW_TAG_base_type:\n+      type_id = gen_ctf_base_type (ctfc, die);\n+      break;\n+    case DW_TAG_pointer_type:\n+      type_id = gen_ctf_pointer_type (ctfc, die);\n+      break;\n+    case DW_TAG_typedef:\n+      type_id = gen_ctf_typedef (ctfc, die);\n+      break;\n+    case DW_TAG_array_type:\n+      type_id = gen_ctf_array_type (ctfc, die);\n+      break;\n+    case DW_TAG_structure_type:\n+      type_id = gen_ctf_sou_type (ctfc, die, CTF_K_STRUCT);\n+      break;\n+    case DW_TAG_union_type:\n+      type_id = gen_ctf_sou_type (ctfc, die, CTF_K_UNION);\n+      break;\n+    case DW_TAG_subroutine_type:\n+      type_id = gen_ctf_function_type (ctfc, die,\n+\t\t\t\t       false /* from_global_func */);\n+      break;\n+    case DW_TAG_enumeration_type:\n+      type_id = gen_ctf_enumeration_type (ctfc, die);\n+      break;\n+    case DW_TAG_atomic_type:\n+      /* FALLTHROUGH */\n+    case DW_TAG_const_type:\n+      /* FALLTHROUGH */\n+    case DW_TAG_restrict_type:\n+      /* FALLTHROUGH */\n+    case DW_TAG_volatile_type:\n+      type_id = gen_ctf_modifier_type (ctfc, die);\n+      break;\n+    case DW_TAG_unspecified_type:\n+      {\n+\tconst char *name = get_AT_string (die, DW_AT_name);\n+\n+\tif (name && strcmp (name, \"void\") == 0)\n+\t  type_id = gen_ctf_void_type (ctfc);\n+\telse\n+\t  type_id = CTF_NULL_TYPEID;\n+\n+\tbreak;\n+      }\n+    case DW_TAG_reference_type:\n+      type_id = CTF_NULL_TYPEID;\n+      break;\n+    default:\n+      /* Unrecognized DIE.  */\n+      unrecog_die = true;\n+      type_id = CTF_NULL_TYPEID;\n+      break;\n+    }\n+\n+  /* For all types unrepresented in CTF, use an explicit CTF type of kind\n+     CTF_K_UNKNOWN.  */\n+  if ((type_id == CTF_NULL_TYPEID) && (!unrecog_die))\n+    type_id = gen_ctf_unknown_type (ctfc);\n+\n+  return type_id;\n+}\n+\n+bool\n+ctf_do_die (dw_die_ref die)\n+{\n+  ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n+\n+  /* Note how we tell the caller to continue traversing children DIEs\n+     if this DIE didn't result in CTF records being added.  */\n+  if (dw_get_die_tag (die) == DW_TAG_variable)\n+    {\n+      gen_ctf_variable (tu_ctfc, die);\n+      return false;\n+    }\n+  else if (dw_get_die_tag (die) == DW_TAG_subprogram)\n+    {\n+      gen_ctf_function (tu_ctfc, die);\n+      return false;\n+    }\n+  else\n+    return gen_ctf_type (tu_ctfc, die) == CTF_NULL_TYPEID;\n+}\n+\n+/* Initialize CTF subsystem for CTF debug info generation.  */\n+\n+void\n+ctf_debug_init (void)\n+{\n+  /* First, initialize the CTF subsystem.  */\n+  ctf_init ();\n+\n+  /* Create a couple of DIE structures that we may need.  */\n+  ctf_void_die = new_die_raw (DW_TAG_unspecified_type);\n+  add_name_attribute (ctf_void_die, \"void\");\n+  ctf_array_index_die\n+    = base_type_die (integer_type_node, 0 /* reverse */);\n+  add_name_attribute (ctf_array_index_die, \"int\");\n+  ctf_unknown_die = new_die_raw (DW_TAG_unspecified_type);\n+  add_name_attribute (ctf_unknown_die, \"unknown\");\n+}\n+\n+/* Preprocess the CTF debug information after initialization.  */\n+\n+void\n+ctf_debug_init_postprocess (bool btf)\n+{\n+  /* Only BTF requires postprocessing right after init.  */\n+  if (btf)\n+    btf_init_postprocess ();\n+}\n+\n+/* Prepare for output and write out the CTF debug information.  */\n+\n+void\n+ctf_debug_finalize (const char *filename, bool btf)\n+{\n+  if (btf)\n+    {\n+      btf_output (filename);\n+      btf_finalize ();\n+    }\n+\n+  else\n+    {\n+      /* Emit the collected CTF information.  */\n+      ctf_output (filename);\n+\n+      /* Reset the CTF state.  */\n+      ctf_finalize ();\n+    }\n+}\n+\n+#include \"gt-dwarf2ctf.h\""}, {"sha": "a3cf5672e253ad4b61efb6e28ca77e2857ddc4a8", "filename": "gcc/dwarf2ctf.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2ctf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2ctf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2ctf.h?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,53 @@\n+/* dwarf2ctf.h - DWARF interface for CTF/BTF generation.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains declarations and prototypes to define an interface\n+   between DWARF and CTF/BTF generation.  */\n+\n+#ifndef GCC_DWARF2CTF_H\n+#define GCC_DWARF2CTF_H 1\n+\n+#include \"dwarf2out.h\"\n+\n+/* Debug Format Interface.  Used in dwarf2out.c.  */\n+\n+extern void ctf_debug_init (void);\n+extern void ctf_debug_init_postprocess (bool);\n+extern bool ctf_do_die (dw_die_ref);\n+extern void ctf_debug_finalize (const char *, bool);\n+\n+/* Wrappers for CTF/BTF to fetch information from GCC DWARF DIE.  Used in\n+   ctfc.c.\n+\n+   A CTF container does not store all debug information internally.  Some of\n+   the info is fetched indirectly via the DIE reference available in each CTF\n+   container entry.\n+\n+   These functions will be used by the CTF container to give access to its\n+   consumers (CTF/BTF) to various debug information available in DWARF DIE.\n+   Direct access to debug information in GCC dwarf structures by the consumers\n+   of CTF/BTF information is not ideal.  */\n+\n+/* Source location information.  */\n+\n+extern const char * ctf_get_die_loc_file (dw_die_ref);\n+extern unsigned int ctf_get_die_loc_line (dw_die_ref);\n+extern unsigned int ctf_get_die_loc_col (dw_die_ref);\n+\n+#endif /* GCC_DWARF2CTF_H */"}, {"sha": "13998b2672fa47e06cf97ce7dd395920f4951d4b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"expr.h\"\n #include \"dwarf2out.h\"\n+#include \"dwarf2ctf.h\"\n #include \"dwarf2asm.h\"\n #include \"toplev.h\"\n #include \"md5.h\"\n@@ -28332,7 +28333,10 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n   dw_line_info_table *table;\n   static var_loc_view lvugid;\n \n-  if (debug_info_level < DINFO_LEVEL_TERSE)\n+  /* 'line_info_table' information gathering is not needed when the debug\n+     info level is set to the lowest value.  Also, the current DWARF-based\n+     debug formats do not use this info.  */\n+  if (debug_info_level < DINFO_LEVEL_TERSE || !dwarf_debuginfo_p ())\n     return;\n \n   table = cur_line_info_table;\n@@ -31876,6 +31880,10 @@ dwarf2out_finish (const char *filename)\n   unsigned char checksum[16];\n   char dl_section_ref[MAX_ARTIFICIAL_LABEL_BYTES];\n \n+  /* Skip emitting DWARF if not required.  */\n+  if (!dwarf_debuginfo_p ())\n+    return;\n+\n   /* Flush out any latecomers to the limbo party.  */\n   flush_limbo_die_list ();\n \n@@ -32631,6 +32639,19 @@ note_variable_value (dw_die_ref die)\n   FOR_EACH_CHILD (die, c, note_variable_value (c));\n }\n \n+/* Process DWARF dies for CTF generation.  */\n+\n+static void\n+ctf_debug_do_cu (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+\n+  if (!ctf_do_die (die))\n+    return;\n+\n+  FOR_EACH_CHILD (die, c, ctf_do_die (c));\n+}\n+\n /* Perform any cleanups needed after the early debug generation pass\n    has run.  */\n \n@@ -32753,6 +32774,20 @@ dwarf2out_early_finish (const char *filename)\n       print_die (comp_unit_die (), dump_file);\n     }\n \n+  /* Generate CTF/BTF debug info.  */\n+  if ((ctf_debug_info_level > CTFINFO_LEVEL_NONE\n+       || btf_debuginfo_p ()) && lang_GNU_C ())\n+    {\n+      ctf_debug_init ();\n+      ctf_debug_do_cu (comp_unit_die ());\n+      for (limbo_die_node *node = limbo_die_list; node; node = node->next)\n+\tctf_debug_do_cu (node->die);\n+      /* Post process the debug data in the CTF container if necessary.  */\n+      ctf_debug_init_postprocess (btf_debuginfo_p ());\n+      /* Emit CTF/BTF debug info.  */\n+      ctf_debug_finalize (filename, btf_debuginfo_p ());\n+    }\n+\n   /* Do not generate DWARF assembler now when not producing LTO bytecode.  */\n   if ((!flag_generate_lto && !flag_generate_offload)\n       /* FIXME: Disable debug info generation for (PE-)COFF targets since the"}, {"sha": "ac6892d041ca3bf3d656589e2e7ee3c4a00f2b5f", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -1429,7 +1429,7 @@ static bool\n dwarf2_debug_info_emitted_p (tree decl)\n {\n   /* When DWARF2 debug info is not generated internally.  */\n-  if (!dwarf_debuginfo_p ())\n+  if (!dwarf_debuginfo_p () && !dwarf_based_debuginfo_p ())\n     return false;\n \n   if (DECL_IGNORED_P (decl))"}, {"sha": "e43d1de490df7a2142dbbdb16fd348a4841a5dbb", "filename": "gcc/flag-types.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -29,7 +29,9 @@ enum debug_info_type\n   DINFO_TYPE_DWARF2 = 2,\t  /* Dwarf v2 debug info.  */\n   DINFO_TYPE_XCOFF = 3,\t\t  /* IBM/Xcoff debug info.  */\n   DINFO_TYPE_VMS = 4,\t\t  /* VMS debug info.  */\n-  DINFO_TYPE_MAX = DINFO_TYPE_VMS /* Marker only.  */\n+  DINFO_TYPE_CTF = 5,\t\t  /* CTF debug info.  */\n+  DINFO_TYPE_BTF = 6,\t\t  /* BTF debug info.  */\n+  DINFO_TYPE_MAX = DINFO_TYPE_BTF /* Marker only.  */\n };\n \n #define NO_DEBUG      (0U)\n@@ -41,6 +43,10 @@ enum debug_info_type\n #define XCOFF_DEBUG   (1U << DINFO_TYPE_XCOFF)\n /* Write VMS debug info (using vmsdbgout.c).  */\n #define VMS_DEBUG     (1U << DINFO_TYPE_VMS)\n+/* Write CTF debug info (using ctfout.c).  */\n+#define CTF_DEBUG     (1U << DINFO_TYPE_CTF)\n+/* Write BTF debug info (using btfout.c).  */\n+#define BTF_DEBUG     (1U << DINFO_TYPE_BTF)\n /* Note: Adding new definitions to handle -combination- of debug formats,\n    like VMS_AND_DWARF2_DEBUG is not recommended.  This definition remains\n    here for historical reasons.  */\n@@ -56,6 +62,19 @@ enum debug_info_levels\n   DINFO_LEVEL_VERBOSE\t/* Write normal info plus #define/#undef info.  */\n };\n \n+/* CTF debug info levels.\n+   CTF debug info levels are untied with DWARF debug info levels because CTF\n+   may co-exist with DWARF.  */\n+enum ctf_debug_info_levels\n+{\n+  CTFINFO_LEVEL_NONE = 0,     /* Write no CTF debug info.  */\n+  CTFINFO_LEVEL_TERSE = 1,    /* Write CTF information to support tracebacks\n+\t\t\t\t only.  Not Implemented.  */\n+  CTFINFO_LEVEL_NORMAL = 2    /* Write CTF type information for all entities\n+\t\t\t\t (functions, data objects, variables etc.)\n+\t\t\t\t at file-scope or global-scope only.  */\n+};\n+\n /* A major contribution to object and executable size is debug\n    information size.  A major contribution to debug information\n    size is struct descriptions replicated in several object files."}, {"sha": "85fd228a20ca89fdc57474e318757eccb2be5630", "filename": "gcc/flags.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -40,10 +40,19 @@ unsigned int debug_set_count (uint32_t w_symbols);\n \n const char * debug_set_names (uint32_t w_symbols);\n \n+/* Return true iff BTF debug info is enabled.  */\n+\n+extern bool btf_debuginfo_p ();\n+\n /* Return true iff DWARF2 debug info is enabled.  */\n \n extern bool dwarf_debuginfo_p ();\n \n+/* Return true iff the debug info format is to be generated based on DWARF\n+   DIEs (like CTF and BTF debug info formats).  */\n+\n+extern bool dwarf_based_debuginfo_p ();\n+\n extern void strip_off_ending (char *, int);\n extern int base_of_path (const char *path, const char **base_out);\n "}, {"sha": "d105c9bd41b1e85372a026057d02469e354a708f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -1727,7 +1727,7 @@ open_base_files (void)\n       \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"symbol-summary.h\",\n       \"ipa-prop.h\", \"ipa-fnsummary.h\", \"dwarf2out.h\", \"omp-general.h\",\n       \"omp-offload.h\", \"ipa-modref-tree.h\", \"ipa-modref.h\", \"symtab-thunks.h\",\n-      \"symtab-clones.h\", \"diagnostic-spec.h\",\n+      \"symtab-clones.h\", \"diagnostic-spec.h\", \"ctfc.h\",\n       NULL\n     };\n     const char *const *ifp;\n@@ -5202,6 +5202,7 @@ main (int argc, char **argv)\n       POS_HERE (do_scalar_typedef (\"poly_int64\", &pos));\n       POS_HERE (do_scalar_typedef (\"poly_uint64\", &pos));\n       POS_HERE (do_scalar_typedef (\"uint64_t\", &pos));\n+      POS_HERE (do_scalar_typedef (\"uint32_t\", &pos));\n       POS_HERE (do_scalar_typedef (\"uint8\", &pos));\n       POS_HERE (do_scalar_typedef (\"uintptr_t\", &pos));\n       POS_HERE (do_scalar_typedef (\"jword\", &pos));"}, {"sha": "66262c5b7076179525a1aa1b2698f301d53f959c", "filename": "gcc/opts.c", "status": "modified", "additions": 108, "deletions": 29, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -42,21 +42,22 @@ static void set_Wstrict_aliasing (struct gcc_options *opts, int onoff);\n \n const char *const debug_type_names[] =\n {\n-  \"none\", \"stabs\", \"dwarf-2\", \"xcoff\", \"vms\"\n+  \"none\", \"stabs\", \"dwarf-2\", \"xcoff\", \"vms\", \"ctf\", \"btf\"\n };\n \n /* Bitmasks of fundamental debug info formats indexed by enum\n    debug_info_type.  */\n \n static uint32_t debug_type_masks[] =\n {\n-  NO_DEBUG, DBX_DEBUG, DWARF2_DEBUG, XCOFF_DEBUG, VMS_DEBUG\n+  NO_DEBUG, DBX_DEBUG, DWARF2_DEBUG, XCOFF_DEBUG, VMS_DEBUG,\n+  CTF_DEBUG, BTF_DEBUG\n };\n \n /* Names of the set of debug formats requested by user.  Updated and accessed\n    via debug_set_names.  */\n \n-static char df_set_names[sizeof \"none stabs dwarf-2 xcoff vms\"];\n+static char df_set_names[sizeof \"none stabs dwarf-2 xcoff vms ctf btf\"];\n \n /* Get enum debug_info_type of the specified debug format, for error messages.\n    Can be used only for individual debug format types.  */\n@@ -126,6 +127,14 @@ debug_set_names (uint32_t w_symbols)\n   return df_set_names;\n }\n \n+/* Return TRUE iff BTF debug info is enabled.  */\n+\n+bool\n+btf_debuginfo_p ()\n+{\n+  return (write_symbols & BTF_DEBUG);\n+}\n+\n /* Return TRUE iff dwarf2 debug info is enabled.  */\n \n bool\n@@ -134,6 +143,15 @@ dwarf_debuginfo_p ()\n   return (write_symbols & DWARF2_DEBUG);\n }\n \n+/* Return true iff the debug info format is to be generated based on DWARF\n+   DIEs (like CTF and BTF debug info formats).  */\n+\n+bool dwarf_based_debuginfo_p ()\n+{\n+  return ((write_symbols & CTF_DEBUG)\n+\t  || (write_symbols & BTF_DEBUG));\n+}\n+\n /* Parse the -femit-struct-debug-detailed option value\n    and set the flag variables. */\n \n@@ -2868,6 +2886,24 @@ common_handle_option (struct gcc_options *opts,\n                        loc);\n       break;\n \n+    case OPT_gbtf:\n+      set_debug_level (BTF_DEBUG, false, arg, opts, opts_set, loc);\n+      /* set the debug level to level 2, but if already at level 3,\n+\t don't lower it.  */\n+      if (opts->x_debug_info_level < DINFO_LEVEL_NORMAL)\n+\topts->x_debug_info_level = DINFO_LEVEL_NORMAL;\n+      break;\n+\n+    case OPT_gctf:\n+      set_debug_level (CTF_DEBUG, false, arg, opts, opts_set, loc);\n+      /* CTF generation feeds off DWARF dies.  For optimal CTF, switch debug\n+\t info level to 2.  If off or at level 1, set it to level 2, but if\n+\t already at level 3, don't lower it.  */\n+      if (opts->x_debug_info_level < DINFO_LEVEL_NORMAL\n+\t  && opts->x_ctf_debug_info_level > CTFINFO_LEVEL_NONE)\n+\topts->x_debug_info_level = DINFO_LEVEL_NORMAL;\n+      break;\n+\n     case OPT_gdwarf:\n       if (arg && strlen (arg) != 0)\n         {\n@@ -3116,7 +3152,10 @@ set_debug_level (uint32_t dinfo, int extended, const char *arg,\n \t  if (extended == 2)\n \t    {\n #if defined DWARF2_DEBUGGING_INFO || defined DWARF2_LINENO_DEBUGGING_INFO\n-\t      opts->x_write_symbols = DWARF2_DEBUG;\n+\t      if (opts->x_write_symbols & CTF_DEBUG)\n+\t\topts->x_write_symbols |= DWARF2_DEBUG;\n+\t      else\n+\t\topts->x_write_symbols = DWARF2_DEBUG;\n #elif defined DBX_DEBUGGING_INFO\n \t      opts->x_write_symbols = DBX_DEBUG;\n #endif\n@@ -3125,41 +3164,81 @@ set_debug_level (uint32_t dinfo, int extended, const char *arg,\n \t  if (opts->x_write_symbols == NO_DEBUG)\n \t    warning_at (loc, 0, \"target system does not support debug output\");\n \t}\n+      else if ((opts->x_write_symbols & CTF_DEBUG)\n+\t       || (opts->x_write_symbols & BTF_DEBUG))\n+\t{\n+\t  opts->x_write_symbols |= DWARF2_DEBUG;\n+\t  opts_set->x_write_symbols |= DWARF2_DEBUG;\n+\t}\n     }\n   else\n     {\n-      /* Does it conflict with an already selected debug format?  */\n-      if (opts_set->x_write_symbols != NO_DEBUG\n-\t  && opts->x_write_symbols != NO_DEBUG\n-\t  && dinfo != opts->x_write_symbols)\n+      /* Make and retain the choice if both CTF and DWARF debug info are to\n+\t be generated.  */\n+      if (((dinfo == DWARF2_DEBUG) || (dinfo == CTF_DEBUG))\n+\t  && ((opts->x_write_symbols == (DWARF2_DEBUG|CTF_DEBUG))\n+\t      || (opts->x_write_symbols == DWARF2_DEBUG)\n+\t      || (opts->x_write_symbols == CTF_DEBUG)))\n \t{\n-\t  gcc_assert (debug_set_count (dinfo) <= 1);\n-\t  error_at (loc, \"debug format %qs conflicts with prior selection\",\n-\t\t    debug_type_names[debug_set_to_format (dinfo)]);\n+\t  opts->x_write_symbols |= dinfo;\n+\t  opts_set->x_write_symbols |= dinfo;\n+\t}\n+      /* However, CTF and BTF are not allowed together at this time.  */\n+      else if (((dinfo == DWARF2_DEBUG) || (dinfo == BTF_DEBUG))\n+\t       && ((opts->x_write_symbols == (DWARF2_DEBUG|BTF_DEBUG))\n+\t\t   || (opts->x_write_symbols == DWARF2_DEBUG)\n+\t\t   || (opts->x_write_symbols == BTF_DEBUG)))\n+\t{\n+\t  opts->x_write_symbols |= dinfo;\n+\t  opts_set->x_write_symbols |= dinfo;\n+\t}\n+      else\n+\t{\n+\t  /* Does it conflict with an already selected debug format?  */\n+\t  if (opts_set->x_write_symbols != NO_DEBUG\n+\t      && opts->x_write_symbols != NO_DEBUG\n+\t      && dinfo != opts->x_write_symbols)\n+\t    {\n+\t      gcc_assert (debug_set_count (dinfo) <= 1);\n+\t      error_at (loc, \"debug format %qs conflicts with prior selection\",\n+\t\t\tdebug_type_names[debug_set_to_format (dinfo)]);\n+\t    }\n+\t  opts->x_write_symbols = dinfo;\n+\t  opts_set->x_write_symbols = dinfo;\n \t}\n-\n-      opts->x_write_symbols = dinfo;\n-      opts_set->x_write_symbols = dinfo;\n     }\n \n-  /* A debug flag without a level defaults to level 2.\n-     If off or at level 1, set it to level 2, but if already\n-     at level 3, don't lower it.  */ \n-  if (*arg == '\\0')\n-    {\n-      if (opts->x_debug_info_level < DINFO_LEVEL_NORMAL)\n-\topts->x_debug_info_level = DINFO_LEVEL_NORMAL;\n-    }\n-  else\n+  if (dinfo != BTF_DEBUG)\n     {\n-      int argval = integral_argument (arg);\n-      if (argval == -1)\n-\terror_at (loc, \"unrecognized debug output level %qs\", arg);\n-      else if (argval > 3)\n-\terror_at (loc, \"debug output level %qs is too high\", arg);\n+      /* A debug flag without a level defaults to level 2.\n+\t If off or at level 1, set it to level 2, but if already\n+\t at level 3, don't lower it.  */\n+      if (*arg == '\\0')\n+\t{\n+\t  if (dinfo == CTF_DEBUG)\n+\t    opts->x_ctf_debug_info_level = CTFINFO_LEVEL_NORMAL;\n+\t  else if (opts->x_debug_info_level < DINFO_LEVEL_NORMAL)\n+\t    opts->x_debug_info_level = DINFO_LEVEL_NORMAL;\n+\t}\n       else\n-\topts->x_debug_info_level = (enum debug_info_levels) argval;\n+\t{\n+\t  int argval = integral_argument (arg);\n+\t  if (argval == -1)\n+\t    error_at (loc, \"unrecognized debug output level %qs\", arg);\n+\t  else if (argval > 3)\n+\t    error_at (loc, \"debug output level %qs is too high\", arg);\n+\t  else\n+\t    {\n+\t      if (dinfo == CTF_DEBUG)\n+\t\topts->x_ctf_debug_info_level\n+\t\t  = (enum ctf_debug_info_levels) argval;\n+\t      else\n+\t\topts->x_debug_info_level = (enum debug_info_levels) argval;\n+\t    }\n+\t}\n     }\n+  else if (*arg != '\\0')\n+    error_at (loc, \"unrecognized btf debug output level %qs\", arg);\n }\n \n /* Arrange to dump core on error for diagnostic context DC.  (The"}, {"sha": "43f1f7d345e7bb8cbf560c919ece41624c1fc2d7", "filename": "gcc/toplev.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -1232,6 +1232,7 @@ parse_alignment_opts (void)\n static void\n process_options (void)\n {\n+  const char *language_string = lang_hooks.name;\n   /* Just in case lang_hooks.post_options ends up calling a debug_hook.\n      This can happen with incorrect pre-processed input. */\n   debug_hooks = &do_nothing_debug_hooks;\n@@ -1415,6 +1416,17 @@ process_options (void)\n \tdebug_info_level = DINFO_LEVEL_NONE;\n     }\n \n+  /* CTF is supported for only C at this time.\n+     Compiling with -flto results in frontend language of GNU GIMPLE.  */\n+  if (!lang_GNU_C ()\n+      && ctf_debug_info_level > CTFINFO_LEVEL_NONE)\n+    {\n+      inform (UNKNOWN_LOCATION,\n+\t      \"CTF debug info requested, but not supported for %qs frontend\",\n+\t      language_string);\n+      ctf_debug_info_level = CTFINFO_LEVEL_NONE;\n+    }\n+\n   if (flag_dump_final_insns && !flag_syntax_only && !no_backend)\n     {\n       FILE *final_output = fopen (flag_dump_final_insns, \"w\");\n@@ -1436,7 +1448,8 @@ process_options (void)\n \n   /* A lot of code assumes write_symbols == NO_DEBUG if the debugging\n      level is 0.  */\n-  if (debug_info_level == DINFO_LEVEL_NONE)\n+  if (debug_info_level == DINFO_LEVEL_NONE\n+      && ctf_debug_info_level == CTFINFO_LEVEL_NONE)\n     write_symbols = NO_DEBUG;\n \n   if (write_symbols == NO_DEBUG)\n@@ -1450,7 +1463,8 @@ process_options (void)\n     debug_hooks = &xcoff_debug_hooks;\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-  else if (write_symbols == DWARF2_DEBUG)\n+  else if (dwarf_debuginfo_p ()\n+\t   || dwarf_based_debuginfo_p ())\n     debug_hooks = &dwarf2_debug_hooks;\n #endif\n #ifdef VMS_DEBUGGING_INFO\n@@ -1472,6 +1486,7 @@ process_options (void)\n   /* We know which debug output will be used so we can set flag_var_tracking\n      and flag_var_tracking_uninit if the user has not specified them.  */\n   if (debug_info_level < DINFO_LEVEL_NORMAL\n+      || !dwarf_debuginfo_p ()\n       || debug_hooks->var_location == do_nothing_debug_hooks.var_location)\n     {\n       if (flag_var_tracking == 1"}, {"sha": "3b1a4c3093f2530c5613c4a3bfb962dd29ceffaa", "filename": "include/btf.h", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/include%2Fbtf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/include%2Fbtf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fbtf.h?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,196 @@\n+/* Declarations and definitions relating to the BPF Type Format (BTF).\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is derived from the BTF specification described in the\n+   Linux kernel source tree (linux/Documentation/bpf/btf.rst).  */\n+\n+#ifndef _BTF_H_\n+#define _BTF_H_\n+\n+#include <stdint.h>\n+\n+#ifdef\t__cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+/* BTF magic number to identify header, endianness.  */\n+#define BTF_MAGIC\t0xeb9f\n+/* Data format version number.  */\n+#define BTF_VERSION \t1\n+\n+struct btf_header\n+{\n+  uint16_t magic;\t/* Magic number (BTF_MAGIC).  */\n+  uint8_t  version;\t/* Data format version (BTF_VERSION).  */\n+  uint8_t  flags;\t/* Flags. Currently unused.  */\n+  uint32_t hdr_len;\t/* Length of this header (sizeof (struct btf_header)).  */\n+\n+  /* Following offsets are relative to the end of this header.  */\n+  uint32_t type_off;\t/* Offset of type section, in bytes.  */\n+  uint32_t type_len;\t/* Length of type section, in bytes.  */\n+  uint32_t str_off;\t/* Offset of string section, in bytes.  */\n+  uint32_t str_len;\t/* Length of string section, in bytes.  */\n+};\n+\n+/* Maximum type identifier.  */\n+#define BTF_MAX_TYPE\t0x000fffff\n+/* Maximum offset into the string section.  */\n+#define BTF_MAX_NAME_OFFSET\t0x00ffffff\n+/* Maximum number of struct, union, enum members or func args.  */\n+#define BTF_MAX_VLEN\t0xffff\n+\n+struct btf_type\n+{\n+  uint32_t name_off; \t/* Offset in string section of type name.  */\n+  uint32_t info;\t/* Encoded kind, variant length, kind flag:\n+\t\t\t   - bits  0-15: vlen\n+\t\t\t   - bits 16-23: unused\n+\t\t\t   - bits 24-27: kind\n+\t\t\t   - bits 28-30: unused\n+\t\t\t   - bit     31: kind_flag\n+\t\t\t   See accessor macros below.  */\n+\n+  /* SIZE is used by INT, ENUM, STRUCT, UNION, DATASEC kinds.\n+     TYPE is used by PTR, TYPEDEF, VOLATILE, CONST, RESTRICT, FUNC,\n+     FUNC_PROTO and VAR kinds.  */\n+  union\n+  {\n+    uint32_t size;\t/* Size of the entire type, in bytes.  */\n+    uint32_t type;\t/* A type_id referring to another type.  */\n+  };\n+};\n+\n+/* The folloing macros access the information encoded in btf_type.info.  */\n+/* Type kind. See below.  */\n+#define BTF_INFO_KIND(info)\t(((info) >> 24) & 0x0f)\n+/* Number of entries of variable length data following certain type kinds.\n+   For example, number of structure members, number of function parameters.  */\n+#define BTF_INFO_VLEN(info)\t((info) & 0xffff)\n+/* For BTF_KIND_FWD, 1 if forward to union, 0 if forward to struct.\n+   For BTF_KIND_STRUCT and BTF_KIND_UNION, 1 if the struct/union contains\n+   a bitfield.  */\n+#define BTF_INFO_KFLAG(info)\t((info) >> 31)\n+\n+/* Encoding for struct btf_type.info.  */\n+#define BTF_TYPE_INFO(kind, kflag, vlen) \\\n+  ((((kflag) ? 1 : 0 ) << 31) | ((kind) << 24) | ((vlen) & 0xffff))\n+\n+#define BTF_KIND_UNKN\t\t0\t/* Unknown or invalid.  */\n+#define BTF_KIND_INT\t\t1\t/* Integer.  */\n+#define BTF_KIND_PTR\t\t2\t/* Pointer.  */\n+#define BTF_KIND_ARRAY\t\t3\t/* Array.  */\n+#define BTF_KIND_STRUCT\t\t4\t/* Struct.  */\n+#define BTF_KIND_UNION\t\t5\t/* Union.  */\n+#define BTF_KIND_ENUM\t\t6\t/* Enumeration.  */\n+#define BTF_KIND_FWD\t\t7\t/* Forward.  */\n+#define BTF_KIND_TYPEDEF\t8\t/* Typedef.  */\n+#define BTF_KIND_VOLATILE\t9\t/* Referenced type is volatile.  */\n+#define BTF_KIND_CONST\t\t10\t/* Referenced type is const.  */\n+#define BTF_KIND_RESTRICT\t11\t/* Restrict.  */\n+#define BTF_KIND_FUNC\t\t12\t/* Subprogram.  */\n+#define BTF_KIND_FUNC_PROTO\t13\t/* Function Prototype.  */\n+#define BTF_KIND_VAR\t\t14\t/* Variable.  */\n+#define BTF_KIND_DATASEC\t15\t/* Section such as .bss or .data.  */\n+#define BTF_KIND_MAX\t\tBTF_KIND_DATASEC\n+#define NR_BTF_KINDS\t\t(BTF_KIND_MAX + 1)\n+\n+/* For some BTF_KINDs, struct btf_type is immediately followed by\n+   additional data describing the type.  */\n+\n+/* BTF_KIND_INT is followed by a 32-bit word, with the following\n+   bit arrangement.  */\n+#define BTF_INT_ENCODING(VAL)\t(((VAL) & 0x0f000000) >> 24)\n+#define BTF_INT_OFFSET(VAL)\t(((VAL) & 0x00ff0000) >> 16)\n+#define BTF_INT_BITS(VAL)\t((VAL)  & 0x000000ff)\n+\n+#define BTF_INT_DATA(encoding, offset, bits) \\\n+  ((((encoding) & 0x0f) << 24) | (((offset) & 0xff) << 16) | ((bits) & 0xff))\n+\n+/* BTF_INT_ENCODING holds the following attribute flags.  */\n+#define BTF_INT_SIGNED \t(1 << 0)\n+#define BTF_INT_CHAR \t(1 << 1)\n+#define BTF_INT_BOOL\t(1 << 2)\n+\n+/* BTF_KIND_ENUM is followed by VLEN struct btf_enum entries,\n+   which describe the enumerators. Note that BTF currently only\n+   supports signed 32-bit enumerator values.  */\n+struct btf_enum\n+{\n+  uint32_t name_off;\t/* Offset in string section of enumerator name.  */\n+  int32_t  val;\t\t/* Enumerator value.  */\n+};\n+\n+/* BTF_KIND_ARRAY is followed by a single struct btf_array.  */\n+struct btf_array\n+{\n+  uint32_t type;\t/* Type of array elements.  */\n+  uint32_t index_type;\t/* Type of array index.  */\n+  uint32_t nelems;\t/* Number of elements. 0 for unsized/variable length.  */\n+};\n+\n+/* BTF_KIND_STRUCT and BTF_KIND_UNION are followed by VLEN\n+   struct btf_member.  */\n+struct btf_member\n+{\n+  uint32_t name_off;\t/* Offset in string section of member name.  */\n+  uint32_t type;\t/* Type of member.  */\n+  uint32_t offset;\t/* If the type info kind_flag is set, this contains\n+\t\t\t   both the member bitfield size and bit offset,\n+\t\t\t   according to the macros below. If kind_flag is not\n+\t\t\t   set, offset contains only the bit offset (from the\n+\t\t\t   beginning of the struct).  */\n+};\n+\n+/* If struct or union type info kind_flag is set, used to access member\n+   bitfield size from btf_member.offset.  */\n+#define BTF_MEMBER_BITFIELD_SIZE (val) \t((val) >> 24)\n+/* If struct or union type info kind_flag is set, used to access member\n+   bit offset from btf_member.offset.  */\n+#define BTF_MEMBER_BIT_OFFSET (val)\t((val) & 0x00ffffff)\n+\n+/* BTF_KIND_FUNC_PROTO is followed by VLEN struct btf_param entries, which\n+   describe the types of the function parameters.  */\n+struct btf_param\n+{\n+  uint32_t name_off;\t/* Offset in string section of parameter name.  */\n+  uint32_t type;\t/* Type of parameter.  */\n+};\n+\n+/* BTF_KIND_VAR is followed by a single struct btf_var, which describes\n+   information about the variable.  */\n+struct btf_var\n+{\n+  uint32_t linkage;\t/* Currently only 0=static or 1=global.  */\n+};\n+\n+/* BTF_KIND_DATASEC is followed by VLEN struct btf_var_secinfo entries,\n+   which describe all BTF_KIND_VAR types contained in the section.  */\n+struct btf_var_secinfo\n+{\n+  uint32_t type;\t/* Type of variable.  */\n+  uint32_t offset;\t/* In-section offset of variable (in bytes).  */\n+  uint32_t size;\t/* Size (in bytes) of variable.  */\n+};\n+\n+#ifdef\t__cplusplus\n+}\n+#endif\n+\n+#endif /* _BTF_H_ */"}, {"sha": "91b03f718235e5a409b87799f03c07ac0c41b07b", "filename": "include/ctf.h", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/include%2Fctf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/include%2Fctf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fctf.h?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -0,0 +1,520 @@\n+/* CTF format description.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef\t_CTF_H\n+#define\t_CTF_H\n+\n+#include <sys/types.h>\n+#include <limits.h>\n+#include <stdint.h>\n+\n+\n+#ifdef\t__cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+/* CTF - Compact ANSI-C Type Format\n+\n+   This file format can be used to compactly represent the information needed\n+   by a debugger to interpret the ANSI-C types used by a given program.\n+   Traditionally, this kind of information is generated by the compiler when\n+   invoked with the -g flag and is stored in \"stabs\" strings or in the more\n+   modern DWARF format.  CTF provides a representation of only the information\n+   that is relevant to debugging a complex, optimized C program such as the\n+   operating system kernel in a form that is significantly more compact than\n+   the equivalent stabs or DWARF representation.  The format is data-model\n+   independent, so consumers do not need different code depending on whether\n+   they are 32-bit or 64-bit programs; libctf automatically compensates for\n+   endianness variations.  CTF assumes that a standard ELF symbol table is\n+   available for use in the debugger, and uses the structure and data of the\n+   symbol table to avoid storing redundant information.  The CTF data may be\n+   compressed on disk or in memory, indicated by a bit in the header.  CTF may\n+   be interpreted in a raw disk file, or it may be stored in an ELF section,\n+   typically named .ctf.  Data structures are aligned so that a raw CTF file or\n+   CTF ELF section may be manipulated using mmap(2).\n+\n+   The CTF file or section itself has the following structure:\n+\n+   +--------+--------+---------+----------+--------+----------+...\n+   |  file  |  type  |  data   | function | object | function |...\n+   | header | labels | objects |   info   | index  |  index   |...\n+   +--------+--------+---------+----------+--------+----------+...\n+\n+   ...+----------+-------+--------+\n+   ...| variable | data  | string |\n+   ...|   info   | types | table  |\n+      +----------+-------+--------+\n+\n+   The file header stores a magic number and version information, encoding\n+   flags, and the byte offset of each of the sections relative to the end of the\n+   header itself.  If the CTF data has been uniquified against another set of\n+   CTF data, a reference to that data also appears in the the header.  This\n+   reference is the name of the label corresponding to the types uniquified\n+   against.\n+\n+   Following the header is a list of labels, used to group the types included in\n+   the data types section.  Each label is accompanied by a type ID i.  A given\n+   label refers to the group of types whose IDs are in the range [0, i].\n+\n+   Data object and function records (collectively, \"symtypetabs\") are stored in\n+   the same order as they appear in the corresponding symbol table, except that\n+   symbols marked SHN_UNDEF are not stored and symbols that have no type data\n+   are padded out with zeroes.  For each entry in these tables, the type ID (a\n+   small integer) is recorded.  (Functions get CTF_K_FUNCTION types, just like\n+   data objects that are function pointers.)\n+\n+   For situations in which the order of the symbols in the symtab is not known,\n+   or most symbols have no type in this dict and most entries would be\n+   zero-pads, a pair of optional indexes follow the data object and function\n+   info sections: each of these is an array of strtab indexes, mapped 1:1 to the\n+   corresponding data object / function info section, giving each entry in those\n+   sections a name so that the linker can correlate them with final symtab\n+   entries and reorder them accordingly (dropping the indexes in the process).\n+\n+   Variable records (as distinct from data objects) provide a modicum of support\n+   for non-ELF systems, mapping a variable name to a CTF type ID.  The variable\n+   names are sorted into ASCIIbetical order, permitting binary searching.  We do\n+   not define how the consumer maps these variable names to addresses or\n+   anything else, or indeed what these names represent: they might be names\n+   looked up at runtime via dlsym() or names extracted at runtime by a debugger\n+   or anything else the consumer likes.  Variable records with identically-\n+   named entries in the data object section are removed.\n+\n+   The data types section is a list of variable size records that represent each\n+   type, in order by their ID.  The types themselves form a directed graph,\n+   where each node may contain one or more outgoing edges to other type nodes,\n+   denoted by their ID.  Most type nodes are standalone or point backwards to\n+   earlier nodes, but this is not required: nodes can point to later nodes,\n+   particularly structure and union members.\n+\n+   Strings are recorded as a string table ID (0 or 1) and a byte offset into the\n+   string table.  String table 0 is the internal CTF string table.  String table\n+   1 is the external string table, which is the string table associated with the\n+   ELF dynamic symbol table for this object.  CTF does not record any strings\n+   that are already in the symbol table, and the CTF string table does not\n+   contain any duplicated strings.\n+\n+   If the CTF data has been merged with another parent CTF object, some outgoing\n+   edges may refer to type nodes that exist in another CTF object.  The debugger\n+   and libctf library are responsible for connecting the appropriate objects\n+   together so that the full set of types can be explored and manipulated.\n+\n+   This connection is done purely using the ctf_import() function.  The\n+   ctf_archive machinery (and thus ctf_open et al) automatically imports archive\n+   members named \".ctf\" into child dicts if available in the same archive, to\n+   match the relationship set up by the linker, but callers can call ctf_import\n+   themselves as well if need be, if they know a different relationship is in\n+   force.  */\n+\n+#define CTF_MAX_TYPE\t0xfffffffe\t/* Max type identifier value.  */\n+#define CTF_MAX_PTYPE\t0x7fffffff\t/* Max parent type identifier value.  */\n+#define CTF_MAX_NAME 0x7fffffff\t\t/* Max offset into a string table.  */\n+#define CTF_MAX_VLEN\t0xffffff /* Max struct, union, enum members or args.  */\n+\n+/* See ctf_type_t */\n+#define CTF_MAX_SIZE\t0xfffffffe\t/* Max size of a v2 type in bytes. */\n+#define CTF_LSIZE_SENT\t0xffffffff\t/* Sentinel for v2 ctt_size.  */\n+\n+  /* Start of actual data structure definitions.\n+\n+     Every field in these structures must have corresponding code in the\n+     endianness-swapping machinery in libctf/ctf-open.c.  */\n+\n+typedef struct ctf_preamble\n+{\n+  unsigned short ctp_magic;\t/* Magic number (CTF_MAGIC).  */\n+  unsigned char ctp_version;\t/* Data format version number (CTF_VERSION).  */\n+  unsigned char ctp_flags;\t/* Flags (see below).  */\n+} ctf_preamble_t;\n+\n+typedef struct ctf_header\n+{\n+  ctf_preamble_t cth_preamble;\n+  uint32_t cth_parlabel;\t/* Ref to name of parent lbl uniq'd against.  */\n+  uint32_t cth_parname;\t\t/* Ref to basename of parent.  */\n+  uint32_t cth_cuname;\t\t/* Ref to CU name (may be 0).  */\n+  uint32_t cth_lbloff;\t\t/* Offset of label section.  */\n+  uint32_t cth_objtoff;\t\t/* Offset of object section.  */\n+  uint32_t cth_funcoff;\t\t/* Offset of function section.  */\n+  uint32_t cth_objtidxoff;\t/* Offset of object index section.  */\n+  uint32_t cth_funcidxoff;\t/* Offset of function index section.  */\n+  uint32_t cth_varoff;\t\t/* Offset of variable section.  */\n+  uint32_t cth_typeoff;\t\t/* Offset of type section.  */\n+  uint32_t cth_stroff;\t\t/* Offset of string section.  */\n+  uint32_t cth_strlen;\t\t/* Length of string section in bytes.  */\n+} ctf_header_t;\n+\n+#define cth_magic   cth_preamble.ctp_magic\n+#define cth_version cth_preamble.ctp_version\n+#define cth_flags   cth_preamble.ctp_flags\n+\n+#define CTF_MAGIC\t0xdff2\t/* Magic number identifying header.  */\n+\n+/* Data format version number.  */\n+\n+/* v1 upgraded to a later version is not quite the same as the native form,\n+   because the boundary between parent and child types is different but not\n+   recorded anywhere, and you can write it out again via ctf_compress_write(),\n+   so we must track whether the thing was originally v1 or not.  If we were\n+   writing the header from scratch, we would add a *pair* of version number\n+   fields to allow for this, but this will do for now.  (A flag will not do,\n+   because we need to encode both the version we came from and the version we\n+   went to, not just \"we were upgraded\".) */\n+\n+# define CTF_VERSION_1 1\n+# define CTF_VERSION_1_UPGRADED_3 2\n+# define CTF_VERSION_2 3\n+\n+/* Note: some flags may be valid only in particular format versions.  */\n+\n+#define CTF_VERSION_3 4\n+#define CTF_VERSION CTF_VERSION_3 /* Current version.  */\n+\n+#define CTF_F_COMPRESS\t0x1\t/* Data buffer is compressed by libctf.  */\n+#define CTF_F_NEWFUNCINFO 0x2\t/* New v3 func info section format.  */\n+\n+typedef struct ctf_lblent\n+{\n+  uint32_t ctl_label;\t\t/* Ref to name of label.  */\n+  uint32_t ctl_type;\t\t/* Last type associated with this label.  */\n+} ctf_lblent_t;\n+\n+typedef struct ctf_varent\n+{\n+  uint32_t ctv_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctv_type;\t\t/* Index of type of this variable.  */\n+} ctf_varent_t;\n+\n+/* In format v2, type sizes, measured in bytes, come in two flavours.  Nearly\n+   all of them fit into a (UINT_MAX - 1), and thus can be stored in the ctt_size\n+   member of a ctf_stype_t.  The maximum value for these sizes is CTF_MAX_SIZE.\n+   Types larger than this must be stored in the ctf_lsize member of a\n+   ctf_type_t.  Use of this member is indicated by the presence of\n+   CTF_LSIZE_SENT in ctt_size.  */\n+\n+typedef struct ctf_stype\n+{\n+  uint32_t ctt_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctt_info;\t\t/* Encoded kind, variant length (see below).  */\n+#ifndef __GNUC__\n+  union\n+  {\n+    uint32_t _size;\t\t/* Size of entire type in bytes.  */\n+    uint32_t _type;\t\t/* Reference to another type.  */\n+  } _u;\n+#else\n+  __extension__\n+  union\n+  {\n+    uint32_t ctt_size;\t\t/* Size of entire type in bytes.  */\n+    uint32_t ctt_type;\t\t/* Reference to another type.  */\n+  };\n+#endif\n+} ctf_stype_t;\n+\n+typedef struct ctf_type\n+{\n+  uint32_t ctt_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctt_info;\t\t/* Encoded kind, variant length (see below).  */\n+#ifndef __GNUC__\n+union\n+  {\n+    uint32_t _size;\t\t/* Always CTF_LSIZE_SENT.  */\n+    uint32_t _type;\t\t/* Do not use.  */\n+  } _u;\n+#else\n+  __extension__\n+  union\n+  {\n+    uint32_t ctt_size;\t\t/* Always CTF_LSIZE_SENT.  */\n+    uint32_t ctt_type;\t\t/* Do not use.  */\n+  };\n+#endif\n+  uint32_t ctt_lsizehi;\t\t/* High 32 bits of type size in bytes.  */\n+  uint32_t ctt_lsizelo;\t\t/* Low 32 bits of type size in bytes.  */\n+} ctf_type_t;\n+\n+#ifndef __GNUC__\n+#define ctt_size _u._size\t/* For fundamental types that have a size.  */\n+#define ctt_type _u._type\t/* For types that reference another type.  */\n+#endif\n+\n+/* The following macros and inline functions compose and decompose values for\n+   ctt_info and ctt_name, as well as other structures that contain name\n+   references.  Use outside libdtrace-ctf itself is explicitly for access to CTF\n+   files directly: types returned from the library will always appear to be\n+   CTF_V2.\n+\n+   v1: (transparently upgraded to v2 at open time: may be compiled out of the\n+   library)\n+               ------------------------\n+   ctt_info:   | kind | isroot | vlen |\n+               ------------------------\n+               15   11    10    9     0\n+\n+   v2:\n+               ------------------------\n+   ctt_info:   | kind | isroot | vlen |\n+               ------------------------\n+               31    26    25  24     0\n+\n+   CTF_V1 and V2 _INFO_VLEN have the same interface:\n+\n+   kind = CTF_*_INFO_KIND(c.ctt_info);     <-- CTF_K_* value (see below)\n+   vlen = CTF_*_INFO_VLEN(fp, c.ctt_info); <-- length of variable data list\n+\n+   stid = CTF_NAME_STID(c.ctt_name);     <-- string table id number (0 or 1)\n+   offset = CTF_NAME_OFFSET(c.ctt_name); <-- string table byte offset\n+\n+   c.ctt_info = CTF_TYPE_INFO(kind, vlen);\n+   c.ctt_name = CTF_TYPE_NAME(stid, offset);  */\n+\n+#define CTF_V1_INFO_KIND(info)\t\t(((info) & 0xf800) >> 11)\n+#define CTF_V1_INFO_ISROOT(info)\t(((info) & 0x0400) >> 10)\n+#define CTF_V1_INFO_VLEN(info)\t\t(((info) & CTF_MAX_VLEN_V1))\n+\n+#define CTF_V2_INFO_KIND(info)\t\t(((info) & 0xfc000000) >> 26)\n+#define CTF_V2_INFO_ISROOT(info)\t(((info) & 0x2000000) >> 25)\n+#define CTF_V2_INFO_VLEN(info)\t\t(((info) & CTF_MAX_VLEN))\n+\n+#define CTF_NAME_STID(name)\t\t((name) >> 31)\n+#define CTF_NAME_OFFSET(name)\t\t((name) & CTF_MAX_NAME)\n+#define CTF_SET_STID(name, stid)\t((name) | ((unsigned int) stid) << 31)\n+\n+/* V2 only. */\n+#define CTF_TYPE_INFO(kind, isroot, vlen) \\\n+\t(((kind) << 26) | (((isroot) ? 1 : 0) << 25) | ((vlen) & CTF_MAX_VLEN))\n+\n+#define CTF_TYPE_NAME(stid, offset) \\\n+\t(((stid) << 31) | ((offset) & CTF_MAX_NAME))\n+\n+/* The next set of macros are for public consumption only.  Not used internally,\n+   since the relevant type boundary is dependent upon the version of the file at\n+   *opening* time, not the version after transparent upgrade.  Use\n+   ctf_type_isparent() / ctf_type_ischild() for that.  */\n+\n+#define CTF_V2_TYPE_ISPARENT(fp, id)\t((id) <= CTF_MAX_PTYPE)\n+#define CTF_V2_TYPE_ISCHILD(fp, id)\t((id) > CTF_MAX_PTYPE)\n+#define CTF_V2_TYPE_TO_INDEX(id)\t((id) & CTF_MAX_PTYPE)\n+#define CTF_V2_INDEX_TO_TYPE(id, child) ((child) ? ((id) | (CTF_MAX_PTYPE+1)) : (id))\n+\n+#define CTF_V1_TYPE_ISPARENT(fp, id)\t((id) <= CTF_MAX_PTYPE_V1)\n+#define CTF_V1_TYPE_ISCHILD(fp, id)\t((id) > CTF_MAX_PTYPE_V1)\n+#define CTF_V1_TYPE_TO_INDEX(id)\t((id) & CTF_MAX_PTYPE_V1)\n+#define CTF_V1_INDEX_TO_TYPE(id, child) ((child) ? ((id) | (CTF_MAX_PTYPE_V1+1)) : (id))\n+\n+/* Valid for both V1 and V2. */\n+#define CTF_TYPE_LSIZE(cttp) \\\n+\t(((uint64_t)(cttp)->ctt_lsizehi) << 32 | (cttp)->ctt_lsizelo)\n+#define CTF_SIZE_TO_LSIZE_HI(size)\t((uint32_t)((uint64_t)(size) >> 32))\n+#define CTF_SIZE_TO_LSIZE_LO(size)\t((uint32_t)(size))\n+\n+#define CTF_STRTAB_0\t0\t/* String table id 0 (in-CTF).  */\n+#define CTF_STRTAB_1\t1\t/* String table id 1 (ELF strtab).  */\n+\n+/* Values for CTF_TYPE_KIND().  If the kind has an associated data list,\n+   CTF_INFO_VLEN() will extract the number of elements in the list, and\n+   the type of each element is shown in the comments below. */\n+\n+#define CTF_K_UNKNOWN\t0\t/* Unknown type (used for padding and\n+\t\t\t\t   unrepresentable types).  */\n+#define CTF_K_INTEGER\t1\t/* Variant data is CTF_INT_DATA (see below).  */\n+#define CTF_K_FLOAT\t2\t/* Variant data is CTF_FP_DATA (see below).  */\n+#define CTF_K_POINTER\t3\t/* ctt_type is referenced type.  */\n+#define CTF_K_ARRAY\t4\t/* Variant data is single ctf_array_t.  */\n+#define CTF_K_FUNCTION\t5\t/* ctt_type is return type, variant data is\n+\t\t\t\t   list of argument types (unsigned short's for v1,\n+\t\t\t\t   uint32_t's for v2).  */\n+#define CTF_K_STRUCT\t6\t/* Variant data is list of ctf_member_t's.  */\n+#define CTF_K_UNION\t7\t/* Variant data is list of ctf_member_t's.  */\n+#define CTF_K_ENUM\t8\t/* Variant data is list of ctf_enum_t's.  */\n+#define CTF_K_FORWARD\t9\t/* No additional data; ctt_name is tag.  */\n+#define CTF_K_TYPEDEF\t10\t/* ctt_type is referenced type.  */\n+#define CTF_K_VOLATILE\t11\t/* ctt_type is base type.  */\n+#define CTF_K_CONST\t12\t/* ctt_type is base type.  */\n+#define CTF_K_RESTRICT\t13\t/* ctt_type is base type.  */\n+#define CTF_K_SLICE\t14\t/* Variant data is a ctf_slice_t.  */\n+\n+#define CTF_K_MAX\t63\t/* Maximum possible (V2) CTF_K_* value.  */\n+\n+/* Values for ctt_type when kind is CTF_K_INTEGER.  The flags, offset in bits,\n+   and size in bits are encoded as a single word using the following macros.\n+   (However, you can also encode the offset and bitness in a slice.)  */\n+\n+#define CTF_INT_ENCODING(data) (((data) & 0xff000000) >> 24)\n+#define CTF_INT_OFFSET(data)   (((data) & 0x00ff0000) >> 16)\n+#define CTF_INT_BITS(data)     (((data) & 0x0000ffff))\n+\n+#define CTF_INT_DATA(encoding, offset, bits) \\\n+       (((encoding) << 24) | ((offset) << 16) | (bits))\n+\n+#define CTF_INT_SIGNED\t0x01\t/* Integer is signed (otherwise unsigned).  */\n+#define CTF_INT_CHAR\t0x02\t/* Character display format.  */\n+#define CTF_INT_BOOL\t0x04\t/* Boolean display format.  */\n+#define CTF_INT_VARARGS\t0x08\t/* Varargs display format.  */\n+\n+/* Use CTF_CHAR to produce a char that agrees with the system's native\n+   char signedness.  */\n+#if CHAR_MIN == 0\n+# define CTF_CHAR (CTF_INT_CHAR)\n+#else\n+# define CTF_CHAR (CTF_INT_CHAR | CTF_INT_SIGNED)\n+#endif\n+\n+/* Values for ctt_type when kind is CTF_K_FLOAT.  The encoding, offset in bits,\n+   and size in bits are encoded as a single word using the following macros.\n+   (However, you can also encode the offset and bitness in a slice.)  */\n+\n+#define CTF_FP_ENCODING(data)  (((data) & 0xff000000) >> 24)\n+#define CTF_FP_OFFSET(data)    (((data) & 0x00ff0000) >> 16)\n+#define CTF_FP_BITS(data)      (((data) & 0x0000ffff))\n+\n+#define CTF_FP_DATA(encoding, offset, bits) \\\n+       (((encoding) << 24) | ((offset) << 16) | (bits))\n+\n+/* Variant data when kind is CTF_K_FLOAT is an encoding in the top eight bits.  */\n+#define CTF_FP_ENCODING(data)\t(((data) & 0xff000000) >> 24)\n+\n+#define CTF_FP_SINGLE\t1\t/* IEEE 32-bit float encoding.  */\n+#define CTF_FP_DOUBLE\t2\t/* IEEE 64-bit float encoding.  */\n+#define CTF_FP_CPLX\t3\t/* Complex encoding.  */\n+#define CTF_FP_DCPLX\t4\t/* Double complex encoding.  */\n+#define CTF_FP_LDCPLX\t5\t/* Long double complex encoding.  */\n+#define CTF_FP_LDOUBLE\t6\t/* Long double encoding.  */\n+#define CTF_FP_INTRVL\t7\t/* Interval (2x32-bit) encoding.  */\n+#define CTF_FP_DINTRVL\t8\t/* Double interval (2x64-bit) encoding.  */\n+#define CTF_FP_LDINTRVL\t9\t/* Long double interval (2x128-bit) encoding.  */\n+#define CTF_FP_IMAGRY\t10\t/* Imaginary (32-bit) encoding.  */\n+#define CTF_FP_DIMAGRY\t11\t/* Long imaginary (64-bit) encoding.  */\n+#define CTF_FP_LDIMAGRY\t12\t/* Long double imaginary (128-bit) encoding.  */\n+\n+#define CTF_FP_MAX\t12\t/* Maximum possible CTF_FP_* value */\n+\n+/* A slice increases the offset and reduces the bitness of the referenced\n+   ctt_type, which must be a type which has an encoding (fp, int, or enum).  We\n+   also store the referenced type in here, because it is easier to keep the\n+   ctt_size correct for the slice than to shuffle the size into here and keep\n+   the ctt_type where it is for other types.\n+\n+   In a future version, where we loosen requirements on alignment in the CTF\n+   file, the cts_offset and cts_bits will be chars: but for now they must be\n+   shorts or everything after a slice will become unaligned.  */\n+\n+typedef struct ctf_slice\n+{\n+  uint32_t cts_type;\n+  unsigned short cts_offset;\n+  unsigned short cts_bits;\n+} ctf_slice_t;\n+\n+typedef struct ctf_array\n+{\n+  uint32_t cta_contents;\t/* Reference to type of array contents.  */\n+  uint32_t cta_index;\t\t/* Reference to type of array index.  */\n+  uint32_t cta_nelems;\t\t/* Number of elements.  */\n+} ctf_array_t;\n+\n+/* Most structure members have bit offsets that can be expressed using a short.\n+   Some don't.  ctf_member_t is used for structs which cannot contain any of\n+   these large offsets, whereas ctf_lmember_t is used in the latter case.  If\n+   any member of a given struct has an offset that cannot be expressed using a\n+   uint32_t, all members will be stored as type ctf_lmember_t.  This is expected\n+   to be very rare (but nonetheless possible).  */\n+\n+#define CTF_LSTRUCT_THRESH\t536870912\n+\n+typedef struct ctf_member_v2\n+{\n+  uint32_t ctm_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctm_offset;\t\t/* Offset of this member in bits.  */\n+  uint32_t ctm_type;\t\t/* Reference to type of member.  */\n+} ctf_member_t;\n+\n+typedef struct ctf_lmember_v2\n+{\n+  uint32_t ctlm_name;\t\t/* Reference to name in string table.  */\n+  uint32_t ctlm_offsethi;\t/* High 32 bits of member offset in bits.  */\n+  uint32_t ctlm_type;\t\t/* Reference to type of member.  */\n+  uint32_t ctlm_offsetlo;\t/* Low 32 bits of member offset in bits.  */\n+} ctf_lmember_t;\n+\n+#define\tCTF_LMEM_OFFSET(ctlmp) \\\n+\t(((uint64_t)(ctlmp)->ctlm_offsethi) << 32 | (ctlmp)->ctlm_offsetlo)\n+#define\tCTF_OFFSET_TO_LMEMHI(offset)\t((uint32_t)((uint64_t)(offset) >> 32))\n+#define\tCTF_OFFSET_TO_LMEMLO(offset)\t((uint32_t)(offset))\n+\n+typedef struct ctf_enum\n+{\n+  uint32_t cte_name;\t\t/* Reference to name in string table.  */\n+  int32_t cte_value;\t\t/* Value associated with this name.  */\n+} ctf_enum_t;\n+\n+/* The ctf_archive is a collection of ctf_dict_t's stored together. The format\n+   is suitable for mmap()ing: this control structure merely describes the\n+   mmap()ed archive (and overlaps the first few bytes of it), hence the\n+   greater care taken with integral types.  All CTF files in an archive\n+   must have the same data model.  (This is not validated.)\n+\n+   All integers in this structure are stored in little-endian byte order.\n+\n+   The code relies on the fact that everything in this header is a uint64_t\n+   and thus the header needs no padding (in particular, that no padding is\n+   needed between ctfa_ctfs and the unnamed ctfa_archive_modent array\n+   that follows it).\n+\n+   This is *not* the same as the data structure returned by the ctf_arc_*()\n+   functions:  this is the low-level on-disk representation.  */\n+\n+#define CTFA_MAGIC 0x8b47f2a4d7623eeb\t/* Random.  */\n+struct ctf_archive\n+{\n+  /* Magic number.  (In loaded files, overwritten with the file size\n+     so ctf_arc_close() knows how much to munmap()).  */\n+  uint64_t ctfa_magic;\n+\n+  /* CTF data model.  */\n+  uint64_t ctfa_model;\n+\n+  /* Number of CTF dicts in the archive.  */\n+  uint64_t ctfa_ndicts;\n+\n+  /* Offset of the name table.  */\n+  uint64_t ctfa_names;\n+\n+  /* Offset of the CTF table.  Each element starts with a size (a uint64_t\n+     in network byte order) then a ctf_dict_t of that size.  */\n+  uint64_t ctfa_ctfs;\n+};\n+\n+/* An array of ctfa_nnamed of this structure lies at\n+   ctf_archive[ctf_archive->ctfa_modents] and gives the ctfa_ctfs or\n+   ctfa_names-relative offsets of each name or ctf_dict_t.  */\n+\n+typedef struct ctf_archive_modent\n+{\n+  uint64_t name_offset;\n+  uint64_t ctf_offset;\n+} ctf_archive_modent_t;\n+\n+#ifdef\t__cplusplus\n+}\n+#endif\n+\n+#endif\t\t\t\t/* _CTF_H */"}, {"sha": "909995dd1661545365c5cd725acf0b4ef8c17663", "filename": "libiberty/simple-object.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/libiberty%2Fsimple-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd/libiberty%2Fsimple-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object.c?ref=b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "patch": "@@ -304,6 +304,9 @@ handle_lto_debug_sections (const char *name, int rename)\n   /* Copy over .GCC.command.line section under the same name if present.  */\n   else if (strcmp (name, \".GCC.command.line\") == 0)\n     return strcpy (newname, name);\n+  /* Copy over .ctf section under the same name if present.  */\n+  else if (strcmp (name, \".ctf\") == 0)\n+    return strcpy (newname, name);\n   free (newname);\n   return NULL;\n }"}]}