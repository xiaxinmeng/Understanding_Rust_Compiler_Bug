{"sha": "f1e93d3f1ad9091e0c986e6e014738a53f10a50e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlOTNkM2YxYWQ5MDkxZTBjOTg2ZTZlMDE0NzM4YTUzZjEwYTUwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2021-01-30T16:52:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-15T10:19:20Z"}, "message": "[Ada] Add support for folding more and/or expressions\n\ngcc/ada/\n\n\t* sem_eval.adb (Eval_Logical_Op, Test_Expression_Is_Foldable):\n\tAdd support for folding more \"and\"/\"or\" expressions.\n\t* exp_util.adb (Side_Effect_Free): Fix handling of membership\n\ttests.", "tree": {"sha": "7f5755c4070fca4be7b22fc1091efb731e5ab95e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f5755c4070fca4be7b22fc1091efb731e5ab95e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1e93d3f1ad9091e0c986e6e014738a53f10a50e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e93d3f1ad9091e0c986e6e014738a53f10a50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1e93d3f1ad9091e0c986e6e014738a53f10a50e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e93d3f1ad9091e0c986e6e014738a53f10a50e/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69558e562c0605e1e13d069c3bdbadedf7d72016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69558e562c0605e1e13d069c3bdbadedf7d72016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69558e562c0605e1e13d069c3bdbadedf7d72016"}], "stats": {"total": 160, "additions": 114, "deletions": 46}, "files": [{"sha": "c6c8d6c62531705be7af579df7a207e8486e29de", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e93d3f1ad9091e0c986e6e014738a53f10a50e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e93d3f1ad9091e0c986e6e014738a53f10a50e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f1e93d3f1ad9091e0c986e6e014738a53f10a50e", "patch": "@@ -13460,16 +13460,26 @@ package body Exp_Util is\n \n          --  A binary operator is side effect free if and both operands are\n          --  side effect free. For this purpose binary operators include\n-         --  membership tests and short circuit forms.\n+         --  short circuit forms.\n \n          when N_Binary_Op\n-            | N_Membership_Test\n             | N_Short_Circuit\n          =>\n             return Side_Effect_Free (Left_Opnd  (N), Name_Req, Variable_Ref)\n                      and then\n                    Side_Effect_Free (Right_Opnd (N), Name_Req, Variable_Ref);\n \n+         --  Membership tests may have either Right_Opnd or Alternatives set\n+\n+         when N_Membership_Test =>\n+            return Side_Effect_Free (Left_Opnd (N), Name_Req, Variable_Ref)\n+                     and then\n+                   (if Present (Right_Opnd (N))\n+                    then Side_Effect_Free\n+                           (Right_Opnd (N), Name_Req, Variable_Ref)\n+                    else Side_Effect_Free\n+                           (Alternatives (N), Name_Req, Variable_Ref));\n+\n          --  An explicit dereference is side effect free only if it is\n          --  a side effect free prefixed reference.\n "}, {"sha": "307045a2124f34c1e65356d3397926a546b2bcfb", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 102, "deletions": 44, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e93d3f1ad9091e0c986e6e014738a53f10a50e/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e93d3f1ad9091e0c986e6e014738a53f10a50e/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=f1e93d3f1ad9091e0c986e6e014738a53f10a50e", "patch": "@@ -2995,10 +2995,12 @@ package body Sem_Eval is\n    --  static if both operands are potentially static (RM 4.9(7), 4.9(20)).\n \n    procedure Eval_Logical_Op (N : Node_Id) is\n-      Left  : constant Node_Id := Left_Opnd (N);\n-      Right : constant Node_Id := Right_Opnd (N);\n-      Stat  : Boolean;\n-      Fold  : Boolean;\n+      Left      : constant Node_Id := Left_Opnd (N);\n+      Right     : constant Node_Id := Right_Opnd (N);\n+      Left_Int  : Uint := No_Uint;\n+      Right_Int : Uint := No_Uint;\n+      Stat      : Boolean;\n+      Fold      : Boolean;\n \n    begin\n       --  If not foldable we are done\n@@ -3011,64 +3013,88 @@ package body Sem_Eval is\n \n       --  Compile time evaluation of logical operation\n \n-      declare\n-         Left_Int  : constant Uint := Expr_Value (Left);\n-         Right_Int : constant Uint := Expr_Value (Right);\n+      if Is_Modular_Integer_Type (Etype (N)) then\n+         Left_Int  := Expr_Value (Left);\n+         Right_Int := Expr_Value (Right);\n \n-      begin\n-         if Is_Modular_Integer_Type (Etype (N)) then\n-            declare\n-               Left_Bits  : Bits (0 .. UI_To_Int (Esize (Etype (N))) - 1);\n-               Right_Bits : Bits (0 .. UI_To_Int (Esize (Etype (N))) - 1);\n+         declare\n+            Left_Bits  : Bits (0 .. UI_To_Int (Esize (Etype (N))) - 1);\n+            Right_Bits : Bits (0 .. UI_To_Int (Esize (Etype (N))) - 1);\n \n-            begin\n-               To_Bits (Left_Int, Left_Bits);\n-               To_Bits (Right_Int, Right_Bits);\n+         begin\n+            To_Bits (Left_Int, Left_Bits);\n+            To_Bits (Right_Int, Right_Bits);\n \n-               --  Note: should really be able to use array ops instead of\n-               --  these loops, but they break the build with a cryptic error\n-               --  during the bind of gnat1 likely due to a wrong computation\n-               --  of a date or checksum.\n+            --  Note: should really be able to use array ops instead of\n+            --  these loops, but they break the build with a cryptic error\n+            --  during the bind of gnat1 likely due to a wrong computation\n+            --  of a date or checksum.\n \n-               if Nkind (N) = N_Op_And then\n-                  for J in Left_Bits'Range loop\n-                     Left_Bits (J) := Left_Bits (J) and Right_Bits (J);\n-                  end loop;\n+            if Nkind (N) = N_Op_And then\n+               for J in Left_Bits'Range loop\n+                  Left_Bits (J) := Left_Bits (J) and Right_Bits (J);\n+               end loop;\n \n-               elsif Nkind (N) = N_Op_Or then\n-                  for J in Left_Bits'Range loop\n-                     Left_Bits (J) := Left_Bits (J) or Right_Bits (J);\n-                  end loop;\n+            elsif Nkind (N) = N_Op_Or then\n+               for J in Left_Bits'Range loop\n+                  Left_Bits (J) := Left_Bits (J) or Right_Bits (J);\n+               end loop;\n \n-               else\n-                  pragma Assert (Nkind (N) = N_Op_Xor);\n+            else\n+               pragma Assert (Nkind (N) = N_Op_Xor);\n \n-                  for J in Left_Bits'Range loop\n-                     Left_Bits (J) := Left_Bits (J) xor Right_Bits (J);\n-                  end loop;\n-               end if;\n+               for J in Left_Bits'Range loop\n+                  Left_Bits (J) := Left_Bits (J) xor Right_Bits (J);\n+               end loop;\n+            end if;\n \n-               Fold_Uint (N, From_Bits (Left_Bits, Etype (N)), Stat);\n-            end;\n+            Fold_Uint (N, From_Bits (Left_Bits, Etype (N)), Stat);\n+         end;\n \n-         else\n-            pragma Assert (Is_Boolean_Type (Etype (N)));\n+      else\n+         pragma Assert (Is_Boolean_Type (Etype (N)));\n \n-            if Nkind (N) = N_Op_And then\n+         if Compile_Time_Known_Value (Left)\n+           and then Compile_Time_Known_Value (Right)\n+         then\n+            Right_Int := Expr_Value (Right);\n+            Left_Int  := Expr_Value (Left);\n+         end if;\n+\n+         if Nkind (N) = N_Op_And then\n+\n+            --  If Left or Right are not compile time known values it means\n+            --  that the result is always False as per\n+            --  Test_Expression_Is_Foldable.\n+            --  Note that in this case, both Right_Int and Left_Int are set\n+            --  to No_Uint, so need to test for both.\n+\n+            if Right_Int = No_Uint then\n+               Fold_Uint (N, Uint_0, Stat);\n+            else\n                Fold_Uint (N,\n                  Test (Is_True (Left_Int) and then Is_True (Right_Int)), Stat);\n+            end if;\n+         elsif Nkind (N) = N_Op_Or then\n \n-            elsif Nkind (N) = N_Op_Or then\n-               Fold_Uint (N,\n-                 Test (Is_True (Left_Int) or else Is_True (Right_Int)), Stat);\n+            --  If Left or Right are not compile time known values it means\n+            --  that the result is always True. as per\n+            --  Test_Expression_Is_Foldable.\n+            --  Note that in this case, both Right_Int and Left_Int are set\n+            --  to No_Uint, so need to test for both.\n \n+            if Right_Int = No_Uint then\n+               Fold_Uint (N, Uint_1, Stat);\n             else\n-               pragma Assert (Nkind (N) = N_Op_Xor);\n                Fold_Uint (N,\n-                 Test (Is_True (Left_Int) xor Is_True (Right_Int)), Stat);\n+                 Test (Is_True (Left_Int) or else Is_True (Right_Int)), Stat);\n             end if;\n+         else\n+            pragma Assert (Nkind (N) = N_Op_Xor);\n+            Fold_Uint (N,\n+              Test (Is_True (Left_Int) xor Is_True (Right_Int)), Stat);\n          end if;\n-      end;\n+      end if;\n    end Eval_Logical_Op;\n \n    ------------------------\n@@ -7193,6 +7219,38 @@ package body Sem_Eval is\n                       and then Compile_Time_Known_Value (Op2);\n          end if;\n \n+         if not Fold\n+           and then not Is_Modular_Integer_Type (Etype (N))\n+         then\n+            case Nkind (N) is\n+               when N_Op_And =>\n+\n+                  --  (False and XXX) = (XXX and False) = False\n+\n+                  Fold :=\n+                    (Compile_Time_Known_Value (Op1)\n+                       and then Is_False (Expr_Value (Op1))\n+                       and then Side_Effect_Free (Op2))\n+                      or else (Compile_Time_Known_Value (Op2)\n+                                and then Is_False (Expr_Value (Op2))\n+                                and then Side_Effect_Free (Op1));\n+\n+               when N_Op_Or =>\n+\n+                  --  (True and XXX) = (XXX and True) = True\n+\n+                  Fold :=\n+                    (Compile_Time_Known_Value (Op1)\n+                       and then Is_True (Expr_Value (Op1))\n+                       and then Side_Effect_Free (Op2))\n+                      or else (Compile_Time_Known_Value (Op2)\n+                                and then Is_True (Expr_Value (Op2))\n+                                and then Side_Effect_Free (Op1));\n+\n+               when others => null;\n+            end case;\n+         end if;\n+\n          return;\n \n       --  Else result is static and foldable. Both operands are static, and"}]}