{"sha": "9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYwOWIxZjI3Mjg1YmI4YjcyZWUzZmEwMjYxOWZjMmZhYzg0NWIzYg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "2000-02-15T22:34:33Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-02-15T22:34:33Z"}, "message": "Makefile.in (lcm.o): Depend on insn-attr.h.\n\n\t* Makefile.in (lcm.o): Depend on insn-attr.h.\n\t* basic-block.h (optimize_mode_switching): Declare.\n\t* lcm.c (tm_p.h, insn-attr.h): #include.\n\t(seginfo, bb_info): New structs.\n\t(antic, transp, comp, delete, insert) : New file-scope static variables.\n\t(new_seginfo, add_seginfo, make_preds_opaque, reg_dies): New functions.\n\t(reg_becomes_live, optimize_mode_switching): Likewise.\n\t* tm.texi: Add description of mode switching macros.\n\t* toplev.c (rest_of_compilation): Call optimize_mode_switching.\n\n\t* sh-protos.h (remove_dead_before_cse): Remove prototype.\n\t(fldi_ok, fpscr_set_from_mem): New prototypes.\n\t* sh.h (OPTIMIZATION_OPTION): Remove sh_flag_remove_dead_before_cse set.\n\t(CONST_DOUBLE_OK_FOR_LETTER_P, SECONDARY_INPUT_RELOAD_CLASS):\n\tDisable fldi for (TARGET_SH4 && ! TARGET_FMOVD).\n\t(sh_flag_remove_dead_before_cse): Remove declaration.\n\t(NUM_MODES_FOR_MODE_SWITCHING, OPTIMIZE_MODE_SWITCHING): New macros.\n\t(MODE_USES_IN_EXIT_BLOCK, MODE_NEEDED, MODE_AT_ENTRY): Likewise.\n\t(MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n\t* sh.c (broken_move): Disable fldi for (TARGET_SH4 && ! TARGET_FMOVD).\n\t(barrier_align): Allow for JUMP_INSNS containing a parallel.\n\t(machine_dependent_reorg): Remove sh_flag_remove_dead_before_cse set.\n\t(fldi_ok): New function.\n\t(get_fpscr_rtx): Add fpscr_rtx as GC root.\n\t(emit_sf_insn): Only generate fpu switches when optimize < 1.\n\t(emit_df_insn): Likewise.\n\t(expand_fp_branch, emit_fpscr_use, remove_dead_before_cse): Delete.\n\t(sh_flag_remove_dead_before_cse): Delete.\n\t(get_free_reg, fpscr_set_from_mem): New functions.\n\t* sh.md (movdf, movsf): Remove no_new_pseudos code.\n\t(return): Remove emit_fpscr_use / remove_dead_before_cse calls.\n\nCo-Authored-By: Andrew MacLeod <amacleod@cygnus.com>\n\nFrom-SVN: r31990", "tree": {"sha": "e647915f74630ab20a46bfbbd0f14b62bd524134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e647915f74630ab20a46bfbbd0f14b62bd524134"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/comments", "author": null, "committer": null, "parents": [{"sha": "78de74bea93ed92acb7c78ebb9293eb6f1d08b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78de74bea93ed92acb7c78ebb9293eb6f1d08b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78de74bea93ed92acb7c78ebb9293eb6f1d08b15"}], "stats": {"total": 870, "additions": 704, "deletions": 166}, "files": [{"sha": "e315302d13604e49d71781312e6b971925143b87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -1,3 +1,38 @@\n+Tue Feb 15 22:30:36 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+                          Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* Makefile.in (lcm.o): Depend on insn-attr.h.\n+\t* basic-block.h (optimize_mode_switching): Declare.\n+\t* lcm.c (tm_p.h, insn-attr.h): #include.\n+\t(seginfo, bb_info): New structs.\n+\t(antic, transp, comp, delete, insert) : New file-scope static variables.\n+\t(new_seginfo, add_seginfo, make_preds_opaque, reg_dies): New functions.\n+\t(reg_becomes_live, optimize_mode_switching): Likewise.\n+\t* tm.texi: Add description of mode switching macros.\n+\t* toplev.c (rest_of_compilation): Call optimize_mode_switching.\n+\n+\t* sh-protos.h (remove_dead_before_cse): Remove prototype.\n+\t(fldi_ok, fpscr_set_from_mem): New prototypes.\n+\t* sh.h (OPTIMIZATION_OPTION): Remove sh_flag_remove_dead_before_cse set.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P, SECONDARY_INPUT_RELOAD_CLASS):\n+\tDisable fldi for (TARGET_SH4 && ! TARGET_FMOVD).\n+\t(sh_flag_remove_dead_before_cse): Remove declaration.\n+\t(NUM_MODES_FOR_MODE_SWITCHING, OPTIMIZE_MODE_SWITCHING): New macros.\n+\t(MODE_USES_IN_EXIT_BLOCK, MODE_NEEDED, MODE_AT_ENTRY): Likewise.\n+\t(MODE_PRIORITY_TO_MODE, EMIT_MODE_SET): Likewise.\n+\t* sh.c (broken_move): Disable fldi for (TARGET_SH4 && ! TARGET_FMOVD).\n+\t(barrier_align): Allow for JUMP_INSNS containing a parallel.\n+\t(machine_dependent_reorg): Remove sh_flag_remove_dead_before_cse set.\n+\t(fldi_ok): New function.\n+\t(get_fpscr_rtx): Add fpscr_rtx as GC root.\n+\t(emit_sf_insn): Only generate fpu switches when optimize < 1.\n+\t(emit_df_insn): Likewise.\n+\t(expand_fp_branch, emit_fpscr_use, remove_dead_before_cse): Delete.\n+\t(sh_flag_remove_dead_before_cse): Delete.\n+\t(get_free_reg, fpscr_set_from_mem): New functions.\n+\t* sh.md (movdf, movsf): Remove no_new_pseudos code.\n+\t(return): Remove emit_fpscr_use / remove_dead_before_cse calls.\n+\n 2000-02-15  Loren Rittle  <ljrittle@acm.org>\n \n \t* ginclude/stddef.h: Correct usage of _BSD_RUNE_T_ for FreeBSD."}, {"sha": "b773bc3580c0e791f4c5f3fb743df59849ae9e0d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -1567,7 +1567,7 @@ resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) flags.h output.h resource.h function.h toplev.h \\\n    insn-attr.h\n lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n-   real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n+   real.h insn-config.h insn-attr.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h function.h insn-config.h \\\n    ggc.h"}, {"sha": "b83e0f4c458fb922dabb18fc85cb67e3dd8cdf8c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -435,6 +435,7 @@ extern struct edge_list *pre_edge_rev_lcm PARAMS ((FILE *, int, sbitmap *,\n \t\t\t\t\t\t   sbitmap **));\n extern void compute_available\t\tPARAMS ((sbitmap *, sbitmap *,\n \t\t\t\t\t\t sbitmap *, sbitmap *));\n+extern void optimize_mode_switching\tPARAMS ((FILE *));\n \n /* In emit-rtl.c.  */\n extern rtx emit_block_insn_after\tPARAMS ((rtx, rtx, basic_block));"}, {"sha": "bb962255dd0e0abce359ac90caa7dc99b1168f74", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for Hitachi Super-H.\n-   Copyright (C) 1993-1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1999, 2000 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -109,4 +109,8 @@ extern void sh_expand_epilogue PARAMS ((void));\n extern void function_epilogue PARAMS ((FILE *, int));\n extern int initial_elimination_offset PARAMS ((int, int));\n extern void emit_fpscr_use PARAMS ((void));\n-extern void remove_dead_before_cse PARAMS ((void));\n+extern int fldi_ok PARAMS ((void));\n+\n+#ifdef HARD_CONST\n+extern void fpscr_set_from_mem PARAMS ((int, HARD_REG_SET));\n+#endif"}, {"sha": "549f453a1ff9fac18bf949a40d7dde9e5a6d2d76", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 86, "deletions": 130, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for Hitachi Super-H.\n-   Copyright (C) 1993-1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1999, 2000 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com). \n \n@@ -2025,6 +2025,9 @@ broken_move (insn)\n \t\t&& GET_CODE (SET_SRC (pat)) == CONST_DOUBLE\n \t\t&& (fp_zero_operand (SET_SRC (pat))\n \t\t    || fp_one_operand (SET_SRC (pat)))\n+\t\t/* ??? If this is a -m4 or -m4-single compilation, we don't\n+\t\t   know the current setting of fpscr, so disable fldi.  */\n+\t\t&& (! TARGET_SH4 || TARGET_FMOVD)\n \t\t&& GET_CODE (SET_DEST (pat)) == REG\n \t\t&& REGNO (SET_DEST (pat)) >= FIRST_FP_REG\n \t\t&& REGNO (SET_DEST (pat)) <= LAST_FP_REG)\n@@ -2772,9 +2775,14 @@ barrier_align (barrier_or_label)\n       if (prev\n \t  && GET_CODE (prev) == JUMP_INSN\n \t  && JUMP_LABEL (prev)\n-\t  && next_real_insn (JUMP_LABEL (prev)) == next_real_insn (barrier_or_label)\n-\t  && (credit - slot >= (GET_CODE (SET_SRC (PATTERN (prev))) == PC ? 2 : 0)))\n-\treturn 0;\n+\t  && next_real_insn (JUMP_LABEL (prev)) == next_real_insn (barrier_or_label))\n+\t{\n+\t  rtx pat = PATTERN (prev);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    pat = XVECEXP (pat, 0, 0);\n+\t  if (credit - slot >= (GET_CODE (SET_SRC (pat)) == PC ? 2 : 0))\n+\t    return 0;\n+\t}\n     }\n \n   return CACHE_LOG;\n@@ -3203,13 +3211,11 @@ machine_dependent_reorg (first)\n #if 0\n   /* fpscr is not actually a user variable, but we pretend it is for the\n      sake of the previous optimization passes, since we want it handled like\n-     one.  However, we don't have eny debugging information for it, so turn\n+     one.  However, we don't have any debugging information for it, so turn\n      it into a non-user variable now.  */\n   if (TARGET_SH4)\n     REG_USERVAR_P (get_fpscr_rtx ()) = 0;\n #endif\n-  if (optimize)\n-    sh_flag_remove_dead_before_cse = 1;\n   mdep_reorg_phase = SH_AFTER_MDEP_REORG;\n }\n \n@@ -4617,6 +4623,19 @@ fp_one_operand (op)\n   return REAL_VALUES_EQUAL (r, dconst1);\n }\n \n+/* For -m4 and -m4-single-only, mode switching is used.  If we are\n+   compiling without -mfmovd, movsf_ie isn't taken into account for\n+   mode switching.  We could check in machine_dependent_reorg for\n+   cases where we know we are in single precision mode, but there is\n+   interface to find that out during reload, so we must avoid\n+   choosing an fldi alternative during reload and thus failing to\n+   allocate a scratch register for the constant loading.  */\n+int\n+fldi_ok ()\n+{\n+  return ! TARGET_SH4 || TARGET_FMOVD || reload_completed;\n+}\n+\n int\n tertiary_reload_operand (op, mode)\n      rtx op;\n@@ -4815,6 +4834,7 @@ get_fpscr_rtx ()\n       fpscr_rtx = gen_rtx (REG, PSImode, 48);\n       REG_USERVAR_P (fpscr_rtx) = 1;\n       pop_obstacks ();\n+      ggc_add_rtx_root (&fpscr_rtx, 1);\n       mark_user_reg (fpscr_rtx);\n     }\n   if (! reload_completed || mdep_reorg_phase != SH_AFTER_MDEP_REORG)\n@@ -4829,13 +4849,13 @@ emit_sf_insn (pat)\n   rtx addr;\n   /* When generating reload insns,  we must not create new registers.  FPSCR\n      should already have the correct value, so do nothing to change it.  */\n-  if (! TARGET_FPU_SINGLE && ! reload_in_progress)\n+  if (! TARGET_FPU_SINGLE && ! reload_in_progress && optimize < 1)\n     {\n       addr = gen_reg_rtx (SImode);\n       emit_insn (gen_fpu_switch0 (addr));\n     }\n   emit_insn (pat);\n-  if (! TARGET_FPU_SINGLE && ! reload_in_progress)\n+  if (! TARGET_FPU_SINGLE && ! reload_in_progress && optimize < 1)\n     {\n       addr = gen_reg_rtx (SImode);\n       emit_insn (gen_fpu_switch1 (addr));\n@@ -4847,13 +4867,13 @@ emit_df_insn (pat)\n      rtx pat;\n {\n   rtx addr;\n-  if (TARGET_FPU_SINGLE && ! reload_in_progress)\n+  if (TARGET_FPU_SINGLE && ! reload_in_progress && optimize < 1)\n     {\n       addr = gen_reg_rtx (SImode);\n       emit_insn (gen_fpu_switch0 (addr));\n     }\n   emit_insn (pat);\n-  if (TARGET_FPU_SINGLE && ! reload_in_progress)\n+  if (TARGET_FPU_SINGLE && ! reload_in_progress && optimize < 1)\n     {\n       addr = gen_reg_rtx (SImode);\n       emit_insn (gen_fpu_switch1 (addr));\n@@ -4893,65 +4913,6 @@ expand_df_binop (fun, operands)\n   emit_df_insn ((*fun) (operands[0], operands[1], operands[2],\n \t\t\t get_fpscr_rtx ()));\n }\n-\n-void\n-expand_fp_branch (compare, branch)\n-     rtx (*compare) PARAMS ((void)), (*branch) PARAMS ((void));\n-{\n-  (GET_MODE (sh_compare_op0)  == SFmode ? emit_sf_insn : emit_df_insn)\n-    ((*compare) ());\n-  emit_jump_insn ((*branch) ());\n-}\n-\f\n-/* We don't want to make fpscr call-saved, because that would prevent\n-   channging it, and it would also cost an exstra instruction to save it.\n-   We don't want it to be known as a global register either, because\n-   that disables all flow analysis.  But it has to be live at the function\n-   return.  Thus, we need to insert a USE at the end of the function.  */\n-/* This should best be called at about the time FINALIZE_PIC is called,\n-   but not dependent on flag_pic.  Alas, there is no suitable hook there,\n-   so this gets called from HAVE_RETURN.  */\n-void\n-emit_fpscr_use ()\n-{\n-  static int fpscr_uses = 0;\n-\n-  if (rtx_equal_function_value_matters)\n-    {\n-      emit_insn (gen_rtx (USE, VOIDmode, get_fpscr_rtx ()));\n-      fpscr_uses++;\n-    }\n-  else\n-    {\n-      if (fpscr_uses > 1)\n-\t{\n-\t  /* Due to he crude way we emit the USEs, we might end up with\n-\t     some extra ones.  Delete all but the last one.  */\n-\t  rtx insn;\n-\n-\t  for (insn = get_last_insn(); insn; insn = PREV_INSN (insn))\n-\t    if (GET_CODE (insn) == INSN\n-\t\t&& GET_CODE (PATTERN (insn)) == USE\n-\t\t&& GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n-\t\t&& REGNO (XEXP (PATTERN (insn), 0)) == FPSCR_REG)\n-\t      {\n-\t\tinsn = PREV_INSN (insn);\n-\t\tbreak;\n-\t      }\n-\t  for (; insn; insn = PREV_INSN (insn))\n-\t    if (GET_CODE (insn) == INSN\n-\t\t&& GET_CODE (PATTERN (insn)) == USE\n-\t\t&& GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n-\t\t&& REGNO (XEXP (PATTERN (insn), 0)) == FPSCR_REG)\n-\t      {\n-\t\tPUT_CODE (insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n-\t      }\n-\t}\n-      fpscr_uses = 0;\n-    }\n-}\n \f\n /* ??? gcc does flow analysis strictly after common subexpression\n    elimination.  As a result, common subespression elimination fails\n@@ -4980,8 +4941,6 @@ f(double a)\n    remove assignments that are dead due to a following assignment in the\n    same basic block.  */\n \n-int sh_flag_remove_dead_before_cse;\n-\n static void \n mark_use (x, reg_set_block)\n      rtx x, *reg_set_block;\n@@ -5035,70 +4994,67 @@ mark_use (x, reg_set_block)\n       }\n     }\n }\n+\f\n+static rtx get_free_reg PARAMS ((HARD_REG_SET));\n+\n+/* This function returns a register to use to load the address to load\n+   the fpscr from.  Currently it always returns r1 or r7, but when we are\n+   able to use pseudo registers after combine, or have a better mechanism\n+   for choosing a register, it should be done here.  */\n+/* REGS_LIVE is the liveness information for the point for which we\n+   need this allocation.  In some bare-bones exit blocks, r1 is live at the\n+   start.  We can even have all of r0..r3 being live:\n+__complex__ long long f (double d) { if (d == 0) return 2; else return 3; }\n+   INSN before which new insns are placed with will clobber the register\n+   we return.  If a basic block consists only of setting the return value\n+   register to a pseudo and using that register, the return value is not\n+   live before or after this block, yet we we'll insert our insns right in\n+   the middle.  */\n \n-void\n-remove_dead_before_cse ()\n+static rtx\n+get_free_reg (regs_live)\n+     HARD_REG_SET regs_live;\n {\n-  rtx *reg_set_block, last, last_call, insn, set;\n-  int in_libcall = 0;\n+  rtx reg;\n \n-  /* This pass should run just once, after rtl generation.  */\n+  if (! TEST_HARD_REG_BIT (regs_live, 1))\n+    return gen_rtx_REG (Pmode, 1);\n \n-  if (! sh_flag_remove_dead_before_cse\n-      || rtx_equal_function_value_matters\n-      || reload_completed)\n-    return;\n+  /* Hard reg 1 is live; since this is a SMALL_REGISTER_CLASSES target,\n+     there shouldn't be anything but a jump before the function end.  */\n+  if (! TEST_HARD_REG_BIT (regs_live, 7))\n+    return gen_rtx_REG (Pmode, 7);\n \n-  sh_flag_remove_dead_before_cse = 0;\n+  abort ();\n+}\n \n-  reg_set_block = (rtx *)alloca (max_reg_num () * sizeof (rtx));\n-  bzero ((char *)reg_set_block, max_reg_num () * sizeof (rtx));\n-  last_call = last = get_last_insn ();\n-  for (insn = last; insn; insn = PREV_INSN (insn))\n+/* This function will set the fpscr from memory. \n+   MODE is the mode we are setting it to.  */\n+void\n+fpscr_set_from_mem (mode, regs_live)\n+     int mode;\n+     HARD_REG_SET regs_live;\n+{\n+  enum attr_fp_mode fp_mode = mode;\n+  rtx i;\n+  rtx addr_reg = get_free_reg (regs_live);\n+\n+  i = gen_rtx_SET (VOIDmode, addr_reg,\n+\t\t   gen_rtx_SYMBOL_REF (SImode, \"__fpscr_values\"));\n+  emit_insn (i);\n+  if (fp_mode == (TARGET_FPU_SINGLE ? FP_MODE_SINGLE : FP_MODE_DOUBLE))\n     {\n-      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\tcontinue;\n-      if (GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  last_call = last = insn;\n-\t  continue;\n-\t}\n-      set = single_set (insn);\n-\n-      /* Don't delete parts of libcalls, since that would confuse cse, loop\n-\t and flow.  */\n-      if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\tin_libcall = 1;\n-      else if (in_libcall)\n-\t{\n-\t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t    in_libcall = 0;\n-\t}\n-      else if (set && GET_CODE (SET_DEST (set)) == REG)\n-\t{\n-\t  int regno = REGNO (SET_DEST (set));\n-\t  rtx ref_insn = (regno < FIRST_PSEUDO_REGISTER && call_used_regs[regno]\n-\t\t\t  ? last_call\n-\t\t\t  : last);\n-\t  if (reg_set_block[regno] == ref_insn\n-\t      && (regno >= FIRST_PSEUDO_REGISTER\n-\t\t  || HARD_REGNO_NREGS (regno, GET_MODE (SET_DEST (set))) == 1)\n-\t      && (GET_CODE (insn) != CALL_INSN || CONST_CALL_P (insn)))\n-\t    {\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    reg_set_block[REGNO (SET_DEST (set))] = ref_insn;\n-\t}\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  last_call = insn;\n-\t  mark_use (CALL_INSN_FUNCTION_USAGE (insn), reg_set_block);\n-\t}\n-      mark_use (PATTERN (insn), reg_set_block);\n+      rtx r = addr_reg;\n+      addr_reg = get_free_reg (regs_live);\n+      i = gen_rtx_SET (VOIDmode, addr_reg,\n+\t\t       gen_rtx_PLUS (Pmode, r, GEN_INT (4)));\n+      emit_insn (i);\n     }\n-  return;\n+  \n+  i = gen_rtx_SET (VOIDmode, \n+ \t\t   get_fpscr_rtx (), \n+  \t\t   gen_rtx_MEM (PSImode, gen_rtx_POST_INC (Pmode, addr_reg)));\n+  i = emit_insn (i);\n+  REG_NOTES (i) = gen_rtx_EXPR_LIST (REG_DEAD, addr_reg, REG_NOTES (i));\n+  REG_NOTES (i) = gen_rtx_EXPR_LIST (REG_INC, addr_reg, REG_NOTES (i));\n }"}, {"sha": "a3870df4832542eccaa9a953c75e7a1737f14e8c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for Hitachi Super-H.\n-   Copyright (C) 1993-1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1999, 2000 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -204,8 +204,6 @@ extern int target_flags;\n do {\t\t\t\t\t\t\t\t\t\\\n   if (LEVEL)\t\t\t\t\t\t\t\t\\\n     flag_omit_frame_pointer = -1;\t\t\t\t\t\\\n-  if (LEVEL)\t\t\t\t\t\t\t\t\\\n-    sh_flag_remove_dead_before_cse = 1;\t\t\t\t\t\\\n   if (SIZE)\t\t\t\t\t\t\t\t\\\n     target_flags |= SPACE_BIT;\t\t\t\t\t\t\\\n } while (0)\n@@ -756,9 +754,9 @@ extern enum reg_class reg_class_from_letter[];\n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n-((C) == 'G' ? fp_zero_operand (VALUE)\t\t\\\n- : (C) == 'H' ? fp_one_operand (VALUE)\t\t\\\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n+((C) == 'G' ? (fp_zero_operand (VALUE) && fldi_ok ())\t\\\n+ : (C) == 'H' ? (fp_one_operand (VALUE) && fldi_ok ())\t\\\n  : (C) == 'F')\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -791,7 +789,8 @@ extern enum reg_class reg_class_from_letter[];\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)  \\\n   ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS || (CLASS) == DF_REGS)\t\\\n     && immediate_operand ((X), (MODE))\t\t\t\t\t\\\n-    && ! ((fp_zero_operand (X) || fp_one_operand (X)) && (MODE) == SFmode))\\\n+    && ! ((fp_zero_operand (X) || fp_one_operand (X))\t\t\t\\\n+\t  && (MODE) == SFmode && fldi_ok ()))\t\t\t\t\\\n    ? R0_REGS\t\t\t\t\t\t\t\t\\\n    : CLASS == FPUL_REGS && immediate_operand ((X), (MODE))\t\t\\\n    ? (GET_CODE (X) == CONST_INT && CONST_OK_FOR_I (INTVAL (X))\t\t\\\n@@ -2122,7 +2121,6 @@ sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n #define PRAGMA_INSERT_ATTRIBUTES(node, pattr, prefix_attr) \\\n   sh_pragma_insert_attributes (node, pattr, prefix_attr)\n \n-extern int sh_flag_remove_dead_before_cse;\n extern int rtx_equal_function_value_matters;\n extern struct rtx_def *fpscr_rtx;\n \n@@ -2239,3 +2237,27 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define SH_DYNAMIC_SHIFT_COST \\\n   (TARGET_HARD_SH4 ? 1 : TARGET_SH3 ? (TARGET_SMALLCODE ? 1 : 2) : 20)\n+\n+\n+#define NUM_MODES_FOR_MODE_SWITCHING { FP_MODE_NONE }\n+\n+#define OPTIMIZE_MODE_SWITCHING(ENTITY) TARGET_SH4\n+\n+#define MODE_USES_IN_EXIT_BLOCK gen_rtx_USE (VOIDmode, get_fpscr_rtx ())\n+\n+#define MODE_NEEDED(ENTITY, INSN)\t\t\t\t\t\\\n+  (recog_memoized (INSN) >= 0\t\t\t\t\t\t\\\n+   ? get_attr_fp_mode (INSN)\t\t\t\t\t\t\\\n+   : (GET_CODE (PATTERN (INSN)) == USE\t\t\t\t\\\n+      && rtx_equal_p (XEXP (PATTERN (INSN), 0), get_fpscr_rtx ()))\t\\\n+   ? (TARGET_FPU_SINGLE ? FP_MODE_SINGLE : FP_MODE_DOUBLE)\t\t\\\n+   : FP_MODE_NONE)\n+\n+#define MODE_AT_ENTRY(ENTITY) \\\n+  (TARGET_FPU_SINGLE ? FP_MODE_SINGLE : FP_MODE_DOUBLE)\n+\n+#define MODE_PRIORITY_TO_MODE(ENTITY, N) \\\n+  ((TARGET_FPU_SINGLE != 0) ^ (N) ? FP_MODE_SINGLE : FP_MODE_DOUBLE)\n+\n+#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \\\n+  fpscr_set_from_mem ((MODE), (HARD_REGS_LIVE))"}, {"sha": "237f774298d3e153237944f08bdc17acf2f37b7d", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -2812,18 +2812,7 @@\n   if (prepare_move_operands (operands, DFmode)) DONE;\n   if (TARGET_SH4)\n     {\n-      if (no_new_pseudos)\n-\t{\n-\t  /* ??? FIXME: This is only a stopgap fix.  There is no guarantee\n-\t     that fpscr is in the right state. */\n-\t  emit_insn (gen_movdf_i4 (operands[0], operands[1], get_fpscr_rtx ()));\n-\t  DONE;\n-\t}\n       emit_df_insn (gen_movdf_i4 (operands[0], operands[1], get_fpscr_rtx ()));\n-      /* We need something to tag possible REG_LIBCALL notes on to.  */\n-      if (TARGET_FPU_SINGLE && rtx_equal_function_value_matters\n-\t  && GET_CODE (operands[0]) == REG)\n-\temit_insn (gen_mov_nop (operands[0]));\n       DONE;\n     }\n }\")\n@@ -2910,18 +2899,7 @@\n     DONE;\n   if (TARGET_SH3E)\n     {\n-      if (no_new_pseudos)\n-\t{\n-\t  /* ??? FIXME: This is only a stopgap fix.  There is no guarantee\n-\t     that fpscr is in the right state. */\n-\t  emit_insn (gen_movsf_ie (operands[0], operands[1], get_fpscr_rtx ()));\n-\t  DONE;\n-\t}\n       emit_sf_insn (gen_movsf_ie (operands[0], operands[1], get_fpscr_rtx ()));\n-      /* We need something to tag possible REG_LIBCALL notes on to.  */\n-      if (! TARGET_FPU_SINGLE && rtx_equal_function_value_matters\n-\t  && GET_CODE (operands[0]) == REG)\n-\temit_insn (gen_mov_nop (operands[0]));\n       DONE;\n     }\n }\")\n@@ -3415,9 +3393,7 @@\n ;; that doesn't mix with emitting a prologue.\n (define_insn \"return\"\n   [(return)]\n-  \"emit_fpscr_use (),\n-   remove_dead_before_cse (),\n-   reload_completed\"\n+  \"reload_completed\"\n   \"%@\t%#\"\n   [(set_attr \"type\" \"return\")\n    (set_attr \"needs_delay_slot\" \"yes\")])"}, {"sha": "7598b34d126de78c1fab6a537ebf6d7449e19002", "filename": "gcc/lcm.c", "status": "modified", "additions": 459, "deletions": 0, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -61,6 +61,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"basic-block.h\"\n+#include \"tm_p.h\"\n+/* We want target macros for the mode switching code to be able to refer\n+   to instruction attribute values.  */\n+#include \"insn-attr.h\"\n \n /* Edge based LCM routines.  */\n static void compute_antinout_edge  PARAMS ((sbitmap *, sbitmap *,\n@@ -794,3 +798,458 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n \n   return edge_list;\n }\n+\n+/* MODE SWITCHING */\n+/* The algorithm for setting the modes consists of scanning the insn list\n+   and finding all the insns which require a specific mode.  Each insn gets\n+   a unique struct seginfo element.  These structures are inserted into a list\n+   for each basic block.  For each entity, there is an array of bb_info over\n+   the flow graph basic blocks (local var 'bb_info'), and contains a list\n+   of all insns within that basic block, in the order they are encountered.\n+\n+   For each entity, any basic block WITHOUT any insns requiring a specific\n+   mode are given a single entry, without a mode.  (Each basic block\n+   in the flow graph must have at least one entry in the segment table.)\n+\n+   The LCM algorithm is then run over the flow graph to determine where to\n+   place the sets to the highest-priority value in respect of first the first\n+   insn in any one block.  Any adjustments required to the transparancy\n+   vectors are made, then the next iteration starts for the next-lower\n+   priority mode, till for each entity all modes are exhasted.\n+\n+   More details are located in the code for optimize_mode_switching().  */\n+\n+/* This structure contains the information for each insn which requires\n+   either single or double mode to be set.  \n+   MODE is the mode this insn must be executed in.\n+   INSN_PTR is the insn to be executed.\n+   BBNUM is the flow graph basic block this insn occurs in.\n+   NEXT is the next insn in the same basic block.  */\n+struct seginfo \n+{\n+  int mode;\n+  rtx insn_ptr;\n+  int bbnum;\n+  struct seginfo *next;\n+  HARD_REG_SET regs_live;\n+};\n+\n+struct bb_info\n+{\n+  struct seginfo *seginfo;\n+  int computing;\n+};\n+\n+/* These bitmaps are used for the LCM algorithm.  */\n+\n+static sbitmap *antic;\n+static sbitmap *transp;\n+static sbitmap *comp;\n+static sbitmap *delete;\n+static sbitmap *insert;\n+\n+static struct seginfo * new_seginfo PARAMS ((int, rtx, int, HARD_REG_SET));;\n+static void add_seginfo PARAMS ((struct bb_info *, struct seginfo *));\n+static void make_preds_opaque PARAMS ((basic_block, int));\n+static void reg_dies PARAMS ((rtx, HARD_REG_SET));\n+static void reg_becomes_live PARAMS ((rtx, rtx, void *));\n+\n+/* This function will allocate a new BBINFO structure, initialized\n+   with the FP_MODE, INSN, and basic block BB parameters.  */\n+static struct seginfo *\n+new_seginfo (mode, insn, bb, regs_live)\n+     int mode;\n+     rtx insn;\n+     int bb;\n+     HARD_REG_SET regs_live;\n+{\n+  struct seginfo *ptr;\n+  ptr = xmalloc (sizeof (struct seginfo));\n+  ptr->mode = mode;\n+  ptr->insn_ptr = insn;\n+  ptr->bbnum = bb;\n+  ptr->next = NULL;\n+  COPY_HARD_REG_SET (ptr->regs_live, regs_live);\n+  return ptr;\n+}\n+\n+/* Add a seginfo element to the end of a list.  \n+   HEAD is a pointer to the list beginning.\n+   INFO is the structure to be linked in.  */\n+static void\n+add_seginfo (head, info)\n+     struct bb_info *head;\n+     struct seginfo *info;\n+{\n+  struct seginfo *ptr;\n+\n+  if (head->seginfo == NULL)\n+    head->seginfo = info;\n+  else\n+    {\n+      ptr = head->seginfo;\n+      while (ptr->next != NULL)\n+        ptr = ptr->next;\n+      ptr->next = info;\n+    }\n+}\n+\n+/* Make all predecessors of basic block B opaque, recursively, till we hit\n+   some that are already non-transparent, or an edge where aux is set; that\n+   denotes that a mode set is to be done on that edge.\n+   J is the bit number in the bitmaps that corresponds to the entity that\n+   we are currently handling mode-switching for.  */\n+static void\n+make_preds_opaque (b, j)\n+     basic_block b;\n+     int j;\n+{\n+  edge e;\n+\n+  for (e = b->pred; e; e = e->pred_next)\n+    {\n+      basic_block pb = e->src;\n+      if (e->aux || ! TEST_BIT (transp[pb->index], j))\n+\tcontinue;\n+      RESET_BIT (transp[pb->index], j);\n+      make_preds_opaque (pb, j);\n+    }\n+}\n+\n+/* Record in LIVE that register REG died.  */\n+static void\n+reg_dies (reg, live)\n+     rtx reg;\n+     HARD_REG_SET live;\n+{\n+  int regno;\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+  regno = REGNO (reg);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+      for (; --nregs >=0; nregs--, regno++)\n+\tCLEAR_HARD_REG_BIT (live, regno);\n+    }\n+}\n+\n+/* Record in LIVE that register REG became live.\n+   This is called via note_stores.  */\n+static void\n+reg_becomes_live (reg, setter, live)\n+     rtx reg;\n+     rtx setter ATTRIBUTE_UNUSED;\n+     void *live;\n+{\n+  int regno;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+\n+  regno = REGNO (reg);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+      for (; nregs-- > 0; regno++)\n+\tSET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno);\n+    }\n+}\n+\n+/* Find all insns that need a particular mode\n+   setting, and insert the necessary mode switches.  */\n+void\n+optimize_mode_switching (file)\n+     FILE *file ATTRIBUTE_UNUSED;\n+{\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+  rtx insn;\n+  int bb, e;\n+  edge eg;\n+  int need_commit = 0;\n+  sbitmap *kill;\n+  struct edge_list *edge_list;\n+  static int num_modes[] = NUM_MODES_FOR_MODE_SWITCHING;\n+#define N_ENTITIES (sizeof num_modes / sizeof (int))\n+  int entity_map[N_ENTITIES];\n+  struct bb_info *bb_info[N_ENTITIES];\n+  int i, j;\n+  int n_entities;\n+  int max_num_modes = 0;\n+\n+  for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n+    {\n+      if (OPTIMIZE_MODE_SWITCHING (e))\n+\t{\n+\t  /* Create the list of segments within each basic block.  */\n+\t  bb_info[n_entities]\n+\t    = (struct bb_info *) xcalloc (n_basic_blocks, sizeof **bb_info);\n+\t  entity_map[n_entities++] = e;\n+\t  if (num_modes[e] > max_num_modes)\n+\t    max_num_modes = num_modes[e];\n+\t}\n+    }\n+  if (! n_entities)\n+    return;\n+\n+#ifdef MODE_USES_IN_EXIT_BLOCK\n+  /* For some ABIs a particular mode setting is required at function exit.  */\n+\n+  for (eg = EXIT_BLOCK_PTR->pred; eg; eg = eg->pred_next)\n+    {\n+      int bb = eg->src->index;\n+\n+      rtx insn = BLOCK_END (bb);\n+      rtx use = MODE_USES_IN_EXIT_BLOCK;\n+\n+      /* If the block ends with the use of the return value\n+\t and / or a return, insert the new use(s) in front of them.  */\n+      while ((GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE)\n+\t     || GET_CODE (insn) == JUMP_INSN)\n+\tinsn = PREV_INSN (insn);\n+      use = emit_insn_after (use, insn);\n+      if (insn == BLOCK_END (bb))\n+\tBLOCK_END (bb) = use;\n+      else if (NEXT_INSN (use) == BLOCK_HEAD (bb))\n+\tBLOCK_HEAD (bb) = NEXT_INSN (insn);\n+    }\n+#endif\n+\n+  /* Create the bitmap vectors.  */\n+\n+  antic = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n+  transp = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n+  comp = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n+\n+  sbitmap_vector_ones (transp, n_basic_blocks);\n+\n+  for (j = n_entities - 1; j >= 0; j--)\n+    {\n+      int e = entity_map[j];\n+      int no_mode = num_modes[e];\n+      struct bb_info *info = bb_info[j];\n+\n+      /* Determine what the first use (if any) need for a mode of entity E is.\n+\t This will be th mode that is anticipatable for this block.\n+\t Also compute the initial transparency settings.  */\n+      for (bb = 0 ; bb < n_basic_blocks; bb++)\n+\t{\n+\t  struct seginfo *ptr;\n+\t  int last_mode = no_mode;\n+\t  HARD_REG_SET live_now;\n+\n+\t  REG_SET_TO_HARD_REG_SET (live_now,\n+\t\t\t\t   BASIC_BLOCK (bb)->global_live_at_start);\n+\t  for (insn = BLOCK_HEAD (bb); \n+\t       insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n+\t       insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t\t{\n+\t\t  int mode = MODE_NEEDED (e, insn);\n+\t\t  rtx link;\n+\n+\t\t  if (mode != no_mode && mode != last_mode)\n+\t\t    {\n+\t\t      last_mode = mode;\n+\t\t      ptr = new_seginfo (mode, insn, bb, live_now);\n+\t\t      add_seginfo (info + bb, ptr);\n+\t\t      RESET_BIT (transp[bb], j);\n+\t\t    }\n+\n+\t\t  /* Update LIVE_NOW.  */\n+\t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n+\t\t      reg_dies (XEXP (link, 0), live_now);\n+\t\t  note_stores (PATTERN (insn), reg_becomes_live, &live_now);\n+\t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\t    if (REG_NOTE_KIND (link) == REG_UNUSED)\n+\t\t      reg_dies (XEXP (link, 0), live_now);\n+\t\t}\n+\t    }\n+\t  info[bb].computing = last_mode;\n+\t  /* Check for blocks without ANY mode requirements.  */\n+\t  if (last_mode == no_mode)\n+\t    {\n+\t      ptr = new_seginfo (no_mode, insn, bb, live_now);\n+\t      add_seginfo (info + bb, ptr);\n+\t    }\n+\t}\n+#ifdef MODE_AT_ENTRY\n+      {\n+\tint mode = MODE_AT_ENTRY (e);\n+\tif (mode != no_mode)\n+\t  {\n+\t    for (eg = ENTRY_BLOCK_PTR->succ; eg; eg = eg->succ_next)\n+\t      {\n+\t\tbb = eg->dest->index;\n+\n+\t        /* By always making this nontransparent, we save\n+\t\t   an extra check in make_preds_opaque.  We also\n+\t\t   need this to avoid confusing pre_edge_lcm when\n+\t\t   antic is cleared but transp and comp are set.  */\n+\t\tRESET_BIT (transp[bb], j);\n+\n+\t\t/* If the block already has MODE, pretend it\n+\t\t   has none (because we don't need to set it),\n+\t\t   but retain whatever mode it computes.  */\n+\t\tif (info[bb].seginfo->mode == mode)\n+\t\t  {\n+\t\t    info[bb].seginfo->mode = no_mode;\n+\t\t  }\n+\t\t/* Insert a fake computing definition of MODE into entry blocks\n+\t\t   which compute no mode. This represents the mode on entry.  */\n+\t\telse if (info[bb].computing == no_mode)\n+\t\t  {\n+\t\t    info[bb].computing = mode;\n+\t\t    info[bb].seginfo->mode = no_mode;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+#endif /* MODE_AT_ENTRY */\n+    }\n+\n+  kill = sbitmap_vector_alloc (n_basic_blocks, n_entities);\n+  for (i = 0; i < max_num_modes; i++)\n+    {\n+      int current_mode[N_ENTITIES];\n+\n+      /* Set the anticipatable and computing arrays.  */\n+      sbitmap_vector_zero (antic, n_basic_blocks);\n+      sbitmap_vector_zero (comp, n_basic_blocks);\n+      for (j = n_entities - 1; j >= 0; j--)\n+\t{\n+\t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n+\t  struct bb_info *info = bb_info[j];\n+\t  \n+\t  for (bb = 0 ; bb < n_basic_blocks; bb++)\n+\t    {\n+\n+\t      if (info[bb].seginfo->mode == m)\n+\t\tSET_BIT (antic[bb], j);\n+\n+\t      if (info[bb].computing == m)\n+\t\tSET_BIT (comp[bb], j);\n+\t    }\n+\t}\n+\n+      /* Calculate the optimal locations for the\n+\t placement mode switches to modes with priority I.  */\n+\n+      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+\tsbitmap_not (kill[bb], transp[bb]);\n+      edge_list = pre_edge_lcm (file, 1, transp, comp, antic,\n+\t\t\t\tkill, &insert, &delete);\n+\n+      for (j = n_entities - 1; j >=0; j--)\n+\t{\n+\t  /* Insert all mode sets that have been inserted by lcm.  */\n+\t  int no_mode = num_modes[entity_map[j]];\n+\t  /* Wherever we have moved a mode setting upwards in the flow graph,\n+\t     the blocks between the new setting site and the now redundant\n+\t     computation ceases to be transparent for any lower-priority\n+\t     mode of the same entity.  First set the aux field of each\n+\t     insertion site edge non-transparent, then propagate the new\n+\t     non-transparency from the redundant computation upwards till\n+\t     we hit an insertion site or an already non-transparent block.  */\n+\t  for (e = NUM_EDGES (edge_list) - 1; e >= 0; e--)\n+\t    {\n+\t      edge eg = INDEX_EDGE (edge_list, e);\n+\t      int mode;\n+\t      basic_block src_bb;\n+\t      HARD_REG_SET live_at_edge;\n+\t      rtx mode_set;\n+\n+\t      eg->aux = 0;\n+\n+\t      if (! TEST_BIT (insert[e], j))\n+\t\tcontinue;\n+\n+\t      eg->aux = (void *)1;\n+\n+\t      mode = current_mode[j];\n+\t      src_bb = eg->src;\n+\n+\t      REG_SET_TO_HARD_REG_SET (live_at_edge, src_bb->global_live_at_end);\n+\t      start_sequence ();\n+\t      EMIT_MODE_SET (entity_map[j], mode, live_at_edge);\n+\t      mode_set = gen_sequence ();\n+\t      end_sequence ();\n+\n+\t      /* If this is an abnormal edge, we'll insert at the end of the\n+\t\t previous block.  */\n+\t      if (eg->flags & EDGE_ABNORMAL)\n+\t\t{\n+\n+\t\t  src_bb->end = emit_insn_after (mode_set, src_bb->end);\n+\t\t  bb_info[j][src_bb->index].computing = mode;\n+\t\t  RESET_BIT (transp[src_bb->index], j);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  need_commit = 1;\n+\t\t  insert_insn_on_edge (mode_set, eg);\n+\t\t}\n+\n+\t    }\n+\n+\t  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+\t    {\n+\t      if (TEST_BIT (delete[bb], j))\n+\t\t{\n+\t\t  make_preds_opaque (BASIC_BLOCK (bb), j);\n+\t\t  /* Cancel the 'deleted' mode set.  */\n+\t\t  bb_info[j][bb].seginfo->mode = no_mode;\n+\t\t}\n+\t    }\n+\t}\n+      free_edge_list (edge_list);\n+    }\n+\n+  /* Now output the remaining mode sets in all the segments.  */\n+  for (j = n_entities - 1; j >= 0; j--)\n+    {\n+      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+\t{\n+\t  struct seginfo *ptr, *next;\n+\t  for (ptr = bb_info[j][bb].seginfo; ptr; ptr = next)\n+\t    {\n+\t      next = ptr->next;\n+\t      if (ptr->mode != FP_MODE_NONE)\n+\t\t{\n+\t\t  rtx mode_set;\n+\n+\t\t  start_sequence ();\n+\t\t  EMIT_MODE_SET (entity_map[j], ptr->mode, ptr->regs_live);\n+\t\t  mode_set = gen_sequence ();\n+\t\t  end_sequence ();\n+\n+\t\t  emit_block_insn_before (mode_set, ptr->insn_ptr,\n+\t\t\t\t\t  BASIC_BLOCK (ptr->bbnum));\n+\t\t}\n+\t      free (ptr);\n+\t    }\n+\t}\n+      free (bb_info[j]);\n+    }\n+\n+  /* Finished. Free up all the things we've allocated.  */\n+  \n+  sbitmap_vector_free (kill);\n+  sbitmap_vector_free (antic);\n+  sbitmap_vector_free (transp);\n+  sbitmap_vector_free (comp);\n+  sbitmap_vector_free (delete);\n+  sbitmap_vector_free (insert);\n+\n+  if (need_commit)\n+    commit_edge_insertions ();\n+#endif /* OPTIMIZE_MODE_SWITCHING */\n+}"}, {"sha": "fe89ee080d24af4df383f51ed4aa0ba32be2cc12", "filename": "gcc/tm.texi", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -37,6 +37,7 @@ includes @file{tm.h} and most compiler source files include\n * Assembler Format::    Defining how to write insns and pseudo-ops to output.\n * Debugging Info::      Defining the format of debugging output.\n * Cross-compilation::   Handling floating point for cross-compilers.\n+* Mode Switching::      Insertion of mode-switching instructions.\n * Misc::                Everything else.\n @end menu\n \n@@ -7194,6 +7195,85 @@ The value is in the target machine's representation for mode @var{mode}\n and has the type @code{REAL_VALUE_TYPE}.\n @end table\n \n+@node Mode Switching\n+@section Mode Switching Instructions\n+@cindex mode switching\n+The following macros control mode switching optimizations:\n+\n+@table @code\n+@findex OPTIMIZE_MODE_SWITCHING\n+@item OPTIMIZE_MODE_SWITCHING (@var{entity})\n+Define this macro if the port needs extra instructions inserted for mode\n+switching in an optimizing compilation.\n+\n+For an example, the SH4 can perform both single and double precision\n+floating point operations, but to perform a single precision operation,\n+the FPSCR PR bit has to be cleared, while for a double precision\n+operation, this bit has to be set.  Changing the PR bit requires a general\n+purpose register as a scratch register, hence these FPSCR sets have to\n+be inserted before reload, i.e. you can't put this into instruction emitting\n+or MACHINE_DEPENDENT_REORG.\n+\n+You can have multiple entities that are mode-switched, and select at run time\n+which entities actually need it.  @code{OPTIMIZE_MODE_SWITCHING} should\n+return non-zero for any @var{entity} that that needs mode-switching.\n+If you define this macro, you also have to define\n+@code{NUM_MODES_FOR_MODE_SWITCHING}, @code{MODE_NEEDED},\n+@code{MODE_PRIORITY_TO_MODE} and @code{EMIT_MODE_SET}.\n+@code{MODE_AT_ENTRY} and @code{MODE_USES_IN_EXIT_BLOCK} are optional.\n+\n+@findex NUM_MODES_FOR_MODE_SWITCHING\n+@item NUM_MODES_FOR_MODE_SWITCHING\n+If you define @code{OPTIMIZE_MODE_SWITCHING}, you have to define this as\n+initializer for an array of integers.  Each initializer element\n+N refers to an entity that needs mode switching, and specifies the number\n+of different modes that might need to be set for this entity.\n+The position of the initializer in the initializer - starting counting at\n+zero - determines the integer that is used to refer to the mode-switched\n+entity in question.\n+In macros that take mode arguments / yield a mode result, modes are\n+represented as numbers 0 .. N - 1.  N is used to specify that no mode\n+switch is needed / supplied.\n+\n+@findex MODE_USES_IN_EXIT_BLOCK\n+@item MODE_USES_IN_EXIT_BLOCK\n+If this macro is defined, it is called for each exit block when mode switching\n+optimization is performed.  Its return value should be the pattern of an insn,\n+or a sequence of insns.  It is emitted before the return insn / use insns at\n+the end of the exit block.\n+\n+This is done before insns are examined for their need of any mode switching.\n+\n+@findex MODE_NEEDED\n+@item MODE_NEEDED (@var{entity}, @var{insn})\n+@var{entity} is an integer specifying a mode-switched entity.  If\n+@code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to\n+return an integer value not larger than the corresponding element in\n+NUM_MODES_FOR_MODE_SWITCHING, to denote the mode that @var{entity} must\n+be switched into prior to the execution of INSN.\n+\n+@findex MODE_AT_ENTRY\n+@item MODE_AT_ENTRY (@var{entity})\n+If this macro is defined, it is evaluated for every @var{entity} that needs\n+mode switching.  It should evaluate to an integer, which is a mode that\n+@var{entity} is assumed to be switched to at function entry.\n+\n+@findex MODE_PRIORITY_TO_MODE\n+@item MODE_PRIORITY_TO_MODE (@var{entity}, @var{n})\n+This macro specifies the order in which modes for ENTITY are processed.\n+0 is the highest priority, NUM_MODES_FOR_MODE_SWITCHING[ENTITY] - 1 the\n+lowest.  The value of the macro should be an integer designating a mode\n+for ENTITY.  For any fixed @var{entity}, @code{mode_priority_to_mode}\n+(@var{entity}, @var{n}) shall be a bijection in 0 ..\n+@code{num_modes_for_mode_switching}[@var{entity}] - 1 .\n+\n+@findex EMIT_MODE_SET\n+@item EMIT_MODE_SET (@var{entity}, @var{mode}, @var{hard_regs_live})\n+Generate one or more insns to set @var{entity} to @var{mode}.\n+@var{hard_reg_live} is the set of hard registers live at the point where\n+the insn(s) are to be inserted.\n+@end table\n+\n @node Misc\n @section Miscellaneous Parameters\n @cindex parameters, miscellaneous"}, {"sha": "42e47a4d2f126b1205da01b2b5923456936cd088", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f09b1f27285bb8b72ee3fa02619fc2fac845b3b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9f09b1f27285bb8b72ee3fa02619fc2fac845b3b", "patch": "@@ -3305,6 +3305,11 @@ rest_of_compilation (decl)\n   /* Print function header into sched dump now\n      because doing the sched analysis makes some of the dump.  */\n \n+  if (optimize && n_basic_blocks)\n+    {\n+      optimize_mode_switching (NULL_PTR);\n+    }\n+\n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns)\n     {"}]}