{"sha": "b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc2YjA4ZWY5NDU5OGU3ZmU2ZWYyZWMzNTUwZjAzYzdiYjFlMWU3Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-02-22T21:18:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-02-22T21:18:25Z"}, "message": "expr.c (store_expr): When converting expression to promoted equivalent type...\n\n\t* expr.c (store_expr): When converting expression to promoted\n\tequivalent type, allow using SUBREG_REG of TARGET as the target\n\tof the expansion of EXP.\n\t* loop.c (basic_induction_var, case SUBREG): Always look inside.\n\t* config/alpha/alpha.c (rtx_equiv_function_matters): Delete decl.\n\t(alpha_emit_set_const): Handle SImode when can't make new pseudos.\n\t(alpha_emit_set_const_1, alpha_sa_mask): Use no_new_pseudos.\n\t* config/alpha/alpha.md (addsi3, subsi3): Don't use if optimizing.\n\nFrom-SVN: r49972", "tree": {"sha": "4650717d3b5700502979ec67e579bd50629ce350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4650717d3b5700502979ec67e579bd50629ce350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/comments", "author": null, "committer": null, "parents": [{"sha": "3256b817fc4df76420ab88b8f83dabeb66939360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3256b817fc4df76420ab88b8f83dabeb66939360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3256b817fc4df76420ab88b8f83dabeb66939360"}], "stats": {"total": 100, "additions": 40, "deletions": 60}, "files": [{"sha": "7710be58b60e1526ffe837f72d35a45ceac55028", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "patch": "@@ -48,9 +48,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"debug.h\"\n \n-/* External data.  */\n-extern int rtx_equal_function_value_matters;\n-\n /* Specify which cpu to schedule for.  */\n \n enum processor_type alpha_cpu;\n@@ -2231,15 +2228,29 @@ alpha_emit_set_const (target, mode, c, n)\n      HOST_WIDE_INT c;\n      int n;\n {\n-  rtx pat;\n+  rtx result = 0;\n+  rtx orig_target = target;\n   int i;\n \n+  /* If we can't make any pseudos, TARGET is an SImode hard register, we\n+     can't load this constant in one insn, do this in DImode.  */\n+  if (no_new_pseudos && mode == SImode\n+      && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER\n+      && (result = alpha_emit_set_const_1 (target, mode, c, 1)) == 0)\n+    {\n+      target = gen_lowpart (DImode, target);\n+      mode = DImode;\n+    }\n+\n   /* Try 1 insn, then 2, then up to N.  */\n-  for (i = 1; i <= n; i++)\n-    if ((pat = alpha_emit_set_const_1 (target, mode, c, i)) != 0)\n-      return pat;\n+  for (i = 1; i <= n && result == 0; i++)\n+    result = alpha_emit_set_const_1 (target, mode, c, i);\n \n-  return 0;\n+  /* Allow for the case where we changed the mode of TARGET.  */\n+  if (result == target)\n+    result = orig_target;\n+\n+  return result;\n }\n \n /* Internal routine for the above to check for N or below insns.  */\n@@ -2255,8 +2266,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n   int i, bits;\n   /* Use a pseudo if highly optimizing and still generating RTL.  */\n   rtx subtarget\n-    = (flag_expensive_optimizations && rtx_equal_function_value_matters\n-       ? 0 : target);\n+    = (flag_expensive_optimizations && !no_new_pseudos ? 0 : target);\n   rtx temp;\n \n #if HOST_BITS_PER_WIDE_INT == 64\n@@ -2321,8 +2331,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n      we can't make pseudos, we can't do anything since the expand_binop\n      and expand_unop calls will widen and try to make pseudos.  */\n \n-  if (n == 1\n-      || (mode == SImode && ! rtx_equal_function_value_matters))\n+  if (n == 1 || (mode == SImode && no_new_pseudos))\n     return 0;\n \n   /* Next, see if we can load a related constant and then shift and possibly\n@@ -5857,7 +5866,7 @@ alpha_sa_mask (imaskP, fmaskP)\n      the regular part of the compiler.  In the ASM_OUTPUT_MI_THUNK case\n      we don't have valid register life info, but assemble_start_function\n      wants to output .frame and .mask directives.  */\n-  if (current_function_is_thunk && rtx_equal_function_value_matters)\n+  if (current_function_is_thunk && !no_new_pseudos)\n     {\n       *imaskP = 0;\n       *fmaskP = 0;"}, {"sha": "06c272b6890e607af4e8972a93a2416cb4d2279b", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "patch": "@@ -518,31 +518,14 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(sign_extend:DI (match_dup 1)))]\n   \"\")\n \n-;; Do addsi3 the way expand_binop would do if we didn't have one.  This\n-;; generates better code.  We have the anonymous addsi3 pattern below in\n-;; case combine wants to make it.\n+;; Don't say we have addsi3 if optimizing.  This generates better code.  We\n+;; have the anonymous addsi3 pattern below in case combine wants to make it.\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n \t\t (match_operand:SI 2 \"add_operand\" \"\")))]\n-  \"\"\n-{\n-  if (optimize)\n-    {\n-      rtx op1 = gen_lowpart (DImode, operands[1]);\n-      rtx op2 = gen_lowpart (DImode, operands[2]);\n-\n-      if (! cse_not_expected)\n-        {\n-          rtx tmp = gen_reg_rtx (DImode);\n-          emit_insn (gen_adddi3 (tmp, op1, op2));\n-          emit_move_insn (gen_lowpart (DImode, operands[0]), tmp);\n-        }\n-      else\n-        emit_insn (gen_adddi3 (gen_lowpart (DImode, operands[0]), op1, op2));\n-      DONE;\n-    }\n-})\n+  \"! optimize\"\n+  \"\")\n \n (define_insn \"*addsi_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n@@ -844,24 +827,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n \t\t  (match_operand:SI 2 \"reg_or_8bit_operand\" \"\")))]\n-  \"\"\n-{\n-  if (optimize)\n-    {\n-      rtx op1 = gen_lowpart (DImode, operands[1]);\n-      rtx op2 = gen_lowpart (DImode, operands[2]);\n-\n-      if (! cse_not_expected)\n-        {\n-          rtx tmp = gen_reg_rtx (DImode);\n-          emit_insn (gen_subdi3 (tmp, op1, op2));\n-          emit_move_insn (gen_lowpart (DImode, operands[0]), tmp);\n-        }\n-      else\n-        emit_insn (gen_subdi3 (gen_lowpart (DImode, operands[0]), op1, op2));\n-      DONE;\n-    }\n-})\n+  \"! optimize\"\n+  \"\")\n \n (define_insn \"*subsi_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}, {"sha": "bcc76bc26049dbc3ffcb4c0d15014ebe2a0ab623", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "patch": "@@ -3989,6 +3989,8 @@ store_expr (exp, target, want_value)\n        and then convert to the wider mode.  Our value is the computed\n        expression.  */\n     {\n+      rtx inner_target = 0;\n+\n       /* If we don't want a value, we can do the conversion inside EXP,\n \t which will often result in some optimizations.  Do the conversion\n \t in two steps: first change the signedness, if needed, then\n@@ -4009,9 +4011,11 @@ store_expr (exp, target, want_value)\n \t  exp = convert (type_for_mode (GET_MODE (SUBREG_REG (target)),\n \t\t\t\t\tSUBREG_PROMOTED_UNSIGNED_P (target)),\n \t\t\t exp);\n+\n+\t  inner_target = SUBREG_REG (target);\n \t}\n \n-      temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n+      temp = expand_expr (exp, inner_target, VOIDmode, 0);\n \n       /* If TEMP is a volatile MEM and we want a result value, make\n \t the access now so it gets done only once.  Likewise if"}, {"sha": "68ef43906cb964b9006d5cf986f228864f5c33ca", "filename": "gcc/loop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b76b08ef94598e7fe6ef2ec3550f03c7bb1e1e7f", "patch": "@@ -6127,13 +6127,13 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n       return 1;\n \n     case SUBREG:\n-      /* If this is a SUBREG for a promoted variable, check the inner\n-\t value.  */\n-      if (SUBREG_PROMOTED_VAR_P (x))\n-\treturn basic_induction_var (loop, SUBREG_REG (x),\n-\t\t\t\t    GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t    dest_reg, p, inc_val, mult_val, location);\n-      return 0;\n+      /* If what's inside the SUBREG is a BIV, then the SUBREG.  This will\n+\t handle addition of promoted variables.\n+\t ??? The comment at the start of this function is wrong: promoted\n+\t variable increments don't look like it says they do.  */\n+      return basic_induction_var (loop, SUBREG_REG (x),\n+\t\t\t\t  GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t  dest_reg, p, inc_val, mult_val, location);\n \n     case REG:\n       /* If this register is assigned in a previous insn, look at its"}]}