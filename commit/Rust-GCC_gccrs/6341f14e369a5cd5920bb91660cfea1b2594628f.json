{"sha": "6341f14e369a5cd5920bb91660cfea1b2594628f", "node_id": "C_kwDOANBUbNoAKDYzNDFmMTRlMzY5YTVjZDU5MjBiYjkxNjYwY2ZlYTFiMjU5NDYyOGY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-03T17:47:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-03T17:47:01Z"}, "message": "analyzer: use std::unique_ptr for pending_diagnostic/note\n\ngcc/analyzer/ChangeLog:\n\t* call-info.cc: Add define of INCLUDE_MEMORY.\n\t* call-summary.cc: Likewise.\n\t* checker-path.cc: Likewise.\n\t* constraint-manager.cc: Likewise.\n\t* diagnostic-manager.cc: Likewise.\n\t(saved_diagnostic::saved_diagnostic): Use std::unique_ptr for\n\tparam d and field m_d.\n\t(saved_diagnostic::~saved_diagnostic): Remove explicit delete of m_d.\n\t(saved_diagnostic::add_note): Use std::unique_ptr for\n\tparam pn.\n\t(saved_diagnostic::get_pending_diagnostic): Update for conversion\n\tof m_sd.m_d to unique_ptr.\n\t(diagnostic_manager::add_diagnostic): Use std::unique_ptr for\n\tparam d.  Remove explicit deletion.\n\t(diagnostic_manager::add_note): Use std::unique_ptr for param pn.\n\t(diagnostic_manager::emit_saved_diagnostic): Update for conversion\n\tof m_sd.m_d to unique_ptr.\n\t(null_assignment_sm_context::warn): Use std::unique_ptr for\n\tparam d.  Remove explicit deletion.\n\t* diagnostic-manager.h (saved_diagnostic::saved_diagnostic): Use\n\tstd::unique_ptr for param d.\n\t(saved_diagnostic::add_note): Likewise for param pn.\n\t(saved_diagnostic::m_d): Likewise.\n\t(diagnostic_manager::add_diagnostic): Use std::unique_ptr for\n\tparam d.\n\t(diagnostic_manager::add_note): Use std::unique_ptr for param pn.\n\t* engine.cc: Include \"make-unique.h\".\n\t(impl_region_model_context::warn): Update to use std::unique_ptr\n\tfor param, removing explicit deletion.\n\t(impl_region_model_context::add_note): Likewise.\n\t(impl_sm_context::warn): Update to use std::unique_ptr\n\tfor param.\n\t(impl_region_model_context::on_state_leak): Likewise for result of\n\ton_leak.\n\t(exploded_node::on_longjmp): Use make_unique when creating\n\tpending_diagnostic.\n\t(exploded_graph::process_node): Likewise.\n\t* exploded-graph.h (impl_region_model_context::warn): Update to\n\tuse std::unique_ptr for param.\n\t(impl_region_model_context::add_note): Likewise.\n\t* feasible-graph.cc: Add define of INCLUDE_MEMORY.\n\t* pending-diagnostic.cc: Likewise.\n\t* pending-diagnostic.h: Include analyzer.sm.h\"\n\t* program-point.cc: Add define of INCLUDE_MEMORY.\n\t* program-state.cc: Likewise.\n\t* region-model-asm.cc: Likewise.\n\t* region-model-impl-calls.cc: Likewise.  Include \"make-unique.h\".\n\t(region_model::impl_call_putenv): Use make_unique when creating\n\tpending_diagnostic.\n\t* region-model-manager.cc: Add define of INCLUDE_MEMORY.\n\t* region-model-reachability.cc: Likewise.\n\t* region-model.cc: Likewise.  Include \"make-unique.h\".\n\t(region_model::get_gassign_result): Use make_unique when creating\n\tpending_diagnostic.\n\t(region_model::check_for_poison): Likewise.\n\t(region_model::on_stmt_pre): Likewise.\n\t(region_model::check_symbolic_bounds): Likewise.\n\t(region_model::check_region_bounds): Likewise.\n\t(annotating_ctxt: make_note): Use std::unique_ptr for result.\n\t(region_model::deref_rvalue): Use make_unique when creating\n\tpending_diagnostic.\n\t(region_model::check_for_writable_region): Likewise.\n\t(region_model::check_region_size): Likewise.\n\t(region_model::check_dynamic_size_for_floats): Likewise.\n\t(region_model::maybe_complain_about_infoleak): Likewise.\n\t(noop_region_model_context::add_note): Use std::unique_ptr for\n\tparam.  Remove explicit deletion.\n\t* region-model.h: Include \"analyzer/pending-diagnostic.h\".\n\t(region_model_context::warn): Convert param to std::unique_ptr.\n\t(region_model_context::add_note): Likewise.\n\t(noop_region_model_context::warn): Likewise.\n\t(noop_region_model_context::add_note): Likewise.\n\t(region_model_context_decorator::warn): Likewise.\n\t(region_model_context_decorator::add_note): Likewise.\n\t(note_adding_context::warn): Likewise.\n\t(note_adding_context::make_note): Likewise for return type.\n\t(test_region_model_context::warn): Convert param to\n\tstd::unique_ptr.\n\t* region.cc: Add define of INCLUDE_MEMORY.\n\t* sm-fd.cc: Likewise.  Include \"make-unique.h\".\n\t(fd_state_machine::check_for_fd_attrs): Use make_unique when\n\tcreating pending_diagnostics.\n\t(fd_state_machine::on_open): Likewise.\n\t(fd_state_machine::on_creat): Likewise.\n\t(fd_state_machine::check_for_dup): Likewise.\n\t(fd_state_machine::on_close): Likewise.\n\t(fd_state_machine::check_for_open_fd): Likewise.\n\t(fd_state_machine::on_leak): Likewise, converting return type to\n\tstd::unique_ptr.\n\t* sm-file.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"make-unique.h\".\n\t(fileptr_state_machine::on_stmt): Use make_unique when creating\n\tpending_diagnostic.\n\t(fileptr_state_machine::on_leak): Likewise, converting return type\n\tto std::unique_ptr.\n\t* sm-malloc.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"make-unique.h\".\n\t(malloc_state_machine::on_stmt): Use make_unique when creating\n\tpending_diagnostic.\n\t(malloc_state_machine::handle_free_of_non_heap): Likewise.\n\t(malloc_state_machine::on_deallocator_call): Likewise.\n\t(malloc_state_machine::on_realloc_call): Likewise.\n\t(malloc_state_machine::on_leak): Likewise, converting return type\n\tto std::unique_ptr.\n\t* sm-pattern-test.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"make-unique.h\".\n\t(pattern_test_state_machine::on_condition): Use make_unique when\n\tcreating pending_diagnostic.\n\t* sm-sensitive.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"make-unique.h\".\n\t(sensitive_state_machine::warn_for_any_exposure): Use make_unique\n\twhen creating pending_diagnostic.\n\t* sm-signal.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"make-unique.h\".\n\t(signal_state_machine::on_stmt): Use make_unique when creating\n\tpending_diagnostic.\n\t* sm-taint.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"make-unique.h\".\n\t(taint_state_machine::check_for_tainted_size_arg): Use make_unique\n\twhen creating pending_diagnostic.\n\t(taint_state_machine::check_for_tainted_divisor): Likewise.\n\t(region_model::check_region_for_taint): Likewise.\n\t(region_model::check_dynamic_size_for_taint): Likewise.\n\t* sm.cc: Add define of INCLUDE_MEMORY.  Include\n\t\"analyzer/pending-diagnostic.h\".\n\t(state_machine::on_leak): Move here from sm.h, changing return\n\ttype to std::unique_ptr.\n\t* sm.h (state_machine::on_leak): Change return type to\n\tstd::unique_ptr.  Move defn of base impl to sm.cc\n\t(sm_context::warn): Convert param d to std_unique_ptr.\n\t* state-purge.cc: Add define of INCLUDE_MEMORY.\n\t* store.cc: Likewise.\n\t* svalue.cc: Likewise.\n\t* trimmed-graph.cc: Likewise.\n\t* varargs.cc: Likewise.  Include \"make-unique.h\".\n\t(va_list_state_machine::check_for_ended_va_list): Use make_unique\n\twhen creating pending_diagnostic.\n\t(va_list_state_machine::on_leak): Likewise, converting return type\n\tto std::unique_ptr.\n\t(region_model::impl_call_va_arg): Use make_unique when creating\n\tpending_diagnostic.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/analyzer_gil_plugin.c: Add define of\n\tINCLUDE_MEMORY.  Include \"make-unique.h\".\n\t(gil_state_machine::check_for_pyobject_in_call): Use make_unique\n\twhen creating pending_diagnostic.\n\t(gil_state_machine::on_stmt): Likewise.\n\t(gil_state_machine::check_for_pyobject_usage_without_gil): Likewise.\n\t* gcc.dg/plugin/analyzer_kernel_plugin.c: : Add define of\n\tINCLUDE_MEMORY.\n\t* gcc.dg/plugin/analyzer_known_fns_plugin.c: Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "ccd0c74837e9feb99ba9baade5d1a2bb7cd167fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccd0c74837e9feb99ba9baade5d1a2bb7cd167fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6341f14e369a5cd5920bb91660cfea1b2594628f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6341f14e369a5cd5920bb91660cfea1b2594628f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6341f14e369a5cd5920bb91660cfea1b2594628f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6341f14e369a5cd5920bb91660cfea1b2594628f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fd485d15c1a2c427c39bcd45e03bed8cde689e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd485d15c1a2c427c39bcd45e03bed8cde689e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd485d15c1a2c427c39bcd45e03bed8cde689e6"}], "stats": {"total": 456, "additions": 266, "deletions": 190}, "files": [{"sha": "3572e06d14bf0d6a0493555fe146317159d3c841", "filename": "gcc/analyzer/call-info.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fcall-info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fcall-info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-info.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "ebc7b5028ec6d13d76d1460e8a2af7cb8809313e", "filename": "gcc/analyzer/call-summary.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fcall-summary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fcall-summary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -18,6 +18,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "4cf28c2af86325c2c58e1a34804dd9d0a1c238af", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "b4e51b089432fc1f5c9b060d9375524101c4caf5", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "0444e52258c367583bea0d4bc157f408124aa1c0", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n@@ -638,14 +639,14 @@ saved_diagnostic::saved_diagnostic (const state_machine *sm,\n \t\t\t\t    tree var,\n \t\t\t\t    const svalue *sval,\n \t\t\t\t    state_machine::state_t state,\n-\t\t\t\t    pending_diagnostic *d,\n+\t\t\t\t    std::unique_ptr<pending_diagnostic> d,\n \t\t\t\t    unsigned idx)\n : m_sm (sm), m_enode (enode), m_snode (snode), m_stmt (stmt),\n  /* stmt_finder could be on-stack; we want our own copy that can\n     outlive that.  */\n   m_stmt_finder (stmt_finder ? stmt_finder->clone () : NULL),\n   m_var (var), m_sval (sval), m_state (state),\n-  m_d (d), m_trailing_eedge (NULL),\n+  m_d (std::move (d)), m_trailing_eedge (NULL),\n   m_idx (idx),\n   m_best_epath (NULL), m_problem (NULL),\n   m_notes ()\n@@ -662,7 +663,6 @@ saved_diagnostic::saved_diagnostic (const state_machine *sm,\n saved_diagnostic::~saved_diagnostic ()\n {\n   delete m_stmt_finder;\n-  delete m_d;\n   delete m_best_epath;\n   delete m_problem;\n }\n@@ -689,10 +689,10 @@ saved_diagnostic::operator== (const saved_diagnostic &other) const\n /* Add PN to this diagnostic, taking ownership of it.  */\n \n void\n-saved_diagnostic::add_note (pending_note *pn)\n+saved_diagnostic::add_note (std::unique_ptr<pending_note> pn)\n {\n   gcc_assert (pn);\n-  m_notes.safe_push (pn);\n+  m_notes.safe_push (pn.release ());\n }\n \n /* Return a new json::object of the form\n@@ -896,7 +896,7 @@ class path_builder\n \n   pending_diagnostic *get_pending_diagnostic () const\n   {\n-    return m_sd.m_d;\n+    return m_sd.m_d.get ();\n   }\n \n   bool reachable_from_p (const exploded_node *src_enode) const\n@@ -955,8 +955,7 @@ diagnostic_manager::diagnostic_manager (logger *logger, engine *eng,\n }\n \n /* Queue pending_diagnostic D at ENODE for later emission.\n-   Return true/false signifying if the diagnostic was actually added.\n-   Take ownership of D (or delete it).  */\n+   Return true/false signifying if the diagnostic was actually added.  */\n \n bool\n diagnostic_manager::add_diagnostic (const state_machine *sm,\n@@ -966,7 +965,7 @@ diagnostic_manager::add_diagnostic (const state_machine *sm,\n \t\t\t\t    tree var,\n \t\t\t\t    const svalue *sval,\n \t\t\t\t    state_machine::state_t state,\n-\t\t\t\t    pending_diagnostic *d)\n+\t\t\t\t    std::unique_ptr<pending_diagnostic> d)\n {\n   LOG_FUNC (get_logger ());\n \n@@ -987,21 +986,20 @@ diagnostic_manager::add_diagnostic (const state_machine *sm,\n \t  if (get_logger ())\n \t    get_logger ()->log (\"rejecting disabled warning %qs\",\n \t\t\t\td->get_kind ());\n-\t  delete d;\n \t  m_num_disabled_diagnostics++;\n \t  return false;\n \t}\n     }\n \n   saved_diagnostic *sd\n     = new saved_diagnostic (sm, enode, snode, stmt, finder, var, sval,\n-\t\t\t    state, d, m_saved_diagnostics.length ());\n+\t\t\t    state, std::move (d), m_saved_diagnostics.length ());\n   m_saved_diagnostics.safe_push (sd);\n   enode->add_diagnostic (sd);\n   if (get_logger ())\n     log (\"adding saved diagnostic %i at SN %i to EN %i: %qs\",\n \t sd->get_index (),\n-\t snode->m_index, enode->m_index, d->get_kind ());\n+\t snode->m_index, enode->m_index, sd->m_d->get_kind ());\n   return true;\n }\n \n@@ -1013,25 +1011,25 @@ bool\n diagnostic_manager::add_diagnostic (exploded_node *enode,\n \t\t\t\t    const supernode *snode, const gimple *stmt,\n \t\t\t\t    stmt_finder *finder,\n-\t\t\t\t    pending_diagnostic *d)\n+\t\t\t\t    std::unique_ptr<pending_diagnostic> d)\n {\n   gcc_assert (enode);\n   return add_diagnostic (NULL, enode, snode, stmt, finder, NULL_TREE,\n-\t\t\t NULL, 0, d);\n+\t\t\t NULL, 0, std::move (d));\n }\n \n /* Add PN to the most recent saved_diagnostic.  */\n \n void\n-diagnostic_manager::add_note (pending_note *pn)\n+diagnostic_manager::add_note (std::unique_ptr<pending_note> pn)\n {\n   LOG_FUNC (get_logger ());\n   gcc_assert (pn);\n \n   /* Get most recent saved_diagnostic.  */\n   gcc_assert (m_saved_diagnostics.length () > 0);\n   saved_diagnostic *sd = m_saved_diagnostics[m_saved_diagnostics.length () - 1];\n-  sd->add_note (pn);\n+  sd->add_note (std::move (pn));\n }\n \n /* Return a new json::object of the form\n@@ -1386,13 +1384,13 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n \n   emission_path.inject_any_inlined_call_events (get_logger ());\n \n-  emission_path.prepare_for_emission (sd.m_d);\n+  emission_path.prepare_for_emission (sd.m_d.get ());\n \n   location_t loc\n     = get_emission_location (sd.m_stmt, sd.m_snode->m_fun, *sd.m_d);\n \n   /* Allow the pending_diagnostic to fix up the locations of events.  */\n-  emission_path.fixup_locations (sd.m_d);\n+  emission_path.fixup_locations (sd.m_d.get ());\n \n   gcc_rich_location rich_loc (loc);\n   rich_loc.set_path (&emission_path);\n@@ -1783,14 +1781,12 @@ struct null_assignment_sm_context : public sm_context\n   }\n \n   void warn (const supernode *, const gimple *,\n-\t     tree, pending_diagnostic *d) final override\n+\t     tree, std::unique_ptr<pending_diagnostic>) final override\n   {\n-    delete d;\n   }\n   void warn (const supernode *, const gimple *,\n-\t     const svalue *, pending_diagnostic *d) final override\n+\t     const svalue *, std::unique_ptr<pending_diagnostic>) final override\n   {\n-    delete d;\n   }\n \n   tree get_diagnostic_tree (tree expr) final override"}, {"sha": "fdab038d7a1aa78c28b75d88271199c557015257", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -36,13 +36,13 @@ class saved_diagnostic\n \t\t    stmt_finder *stmt_finder,\n \t\t    tree var, const svalue *sval,\n \t\t    state_machine::state_t state,\n-\t\t    pending_diagnostic *d,\n+\t\t    std::unique_ptr<pending_diagnostic> d,\n \t\t    unsigned idx);\n   ~saved_diagnostic ();\n \n   bool operator== (const saved_diagnostic &other) const;\n \n-  void add_note (pending_note *pn);\n+  void add_note (std::unique_ptr<pending_note> pn);\n \n   json::object *to_json () const;\n \n@@ -76,7 +76,7 @@ class saved_diagnostic\n   tree m_var;\n   const svalue *m_sval;\n   state_machine::state_t m_state;\n-  pending_diagnostic *m_d; // owned\n+  std::unique_ptr<pending_diagnostic> m_d;\n   const exploded_edge *m_trailing_eedge;\n \n private:\n@@ -117,14 +117,14 @@ class diagnostic_manager : public log_user\n \t\t       tree var,\n \t\t       const svalue *sval,\n \t\t       state_machine::state_t state,\n-\t\t       pending_diagnostic *d);\n+\t\t       std::unique_ptr<pending_diagnostic> d);\n \n   bool add_diagnostic (exploded_node *enode,\n \t\t       const supernode *snode, const gimple *stmt,\n \t\t       stmt_finder *finder,\n-\t\t       pending_diagnostic *d);\n+\t\t       std::unique_ptr<pending_diagnostic> d);\n \n-  void add_note (pending_note *pn);\n+  void add_note (std::unique_ptr<pending_note> pn);\n \n   void emit_saved_diagnostics (const exploded_graph &eg);\n "}, {"sha": "fd532b1384dff1f3317219da0d63988805030887", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"fold-const.h\"\n #include \"gcc-rich-location.h\"\n@@ -114,35 +115,29 @@ impl_region_model_context (program_state *state,\n }\n \n bool\n-impl_region_model_context::warn (pending_diagnostic *d)\n+impl_region_model_context::warn (std::unique_ptr<pending_diagnostic> d)\n {\n   LOG_FUNC (get_logger ());\n   if (m_stmt == NULL && m_stmt_finder == NULL)\n     {\n       if (get_logger ())\n \tget_logger ()->log (\"rejecting diagnostic: no stmt\");\n-      delete d;\n       return false;\n     }\n   if (m_eg)\n     return m_eg->get_diagnostic_manager ().add_diagnostic\n       (m_enode_for_diag, m_enode_for_diag->get_supernode (),\n-       m_stmt, m_stmt_finder, d);\n+       m_stmt, m_stmt_finder, std::move (d));\n   else\n-    {\n-      delete d;\n-      return false;\n-    }\n+    return false;\n }\n \n void\n-impl_region_model_context::add_note (pending_note *pn)\n+impl_region_model_context::add_note (std::unique_ptr<pending_note> pn)\n {\n   LOG_FUNC (get_logger ());\n   if (m_eg)\n-    m_eg->get_diagnostic_manager ().add_note (pn);\n-  else\n-    delete pn;\n+    m_eg->get_diagnostic_manager ().add_note (std::move (pn));\n }\n \n void\n@@ -401,10 +396,11 @@ class impl_sm_context : public sm_context\n   }\n \n   void warn (const supernode *snode, const gimple *stmt,\n-\t     tree var, pending_diagnostic *d) final override\n+\t     tree var,\n+\t     std::unique_ptr<pending_diagnostic> d) final override\n   {\n     LOG_FUNC (get_logger ());\n-    gcc_assert (d); // take ownership\n+    gcc_assert (d);\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL, NULL);\n \n@@ -416,14 +412,15 @@ class impl_sm_context : public sm_context\n \t : m_old_smap->get_global_state ());\n     m_eg.get_diagnostic_manager ().add_diagnostic\n       (&m_sm, m_enode_for_diag, snode, stmt, m_stmt_finder,\n-       var, var_old_sval, current, d);\n+       var, var_old_sval, current, std::move (d));\n   }\n \n   void warn (const supernode *snode, const gimple *stmt,\n-\t     const svalue *sval, pending_diagnostic *d) final override\n+\t     const svalue *sval,\n+\t     std::unique_ptr<pending_diagnostic> d) final override\n   {\n     LOG_FUNC (get_logger ());\n-    gcc_assert (d); // take ownership\n+    gcc_assert (d);\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL, NULL, NULL);\n \n@@ -433,7 +430,7 @@ class impl_sm_context : public sm_context\n \t : m_old_smap->get_global_state ());\n     m_eg.get_diagnostic_manager ().add_diagnostic\n       (&m_sm, m_enode_for_diag, snode, stmt, m_stmt_finder,\n-       NULL_TREE, sval, current, d);\n+       NULL_TREE, sval, current, std::move (d));\n   }\n \n   /* Hook for picking more readable trees for SSA names of temporaries,\n@@ -864,12 +861,12 @@ impl_region_model_context::on_state_leak (const state_machine &sm,\n     }\n \n   tree leaked_tree_for_diag = fixup_tree_for_diagnostic (leaked_tree);\n-  pending_diagnostic *pd = sm.on_leak (leaked_tree_for_diag);\n+  std::unique_ptr<pending_diagnostic> pd = sm.on_leak (leaked_tree_for_diag);\n   if (pd)\n     m_eg->get_diagnostic_manager ().add_diagnostic\n       (&sm, m_enode_for_diag, m_enode_for_diag->get_supernode (),\n        m_stmt, &stmt_finder,\n-       leaked_tree_for_diag, sval, state, pd);\n+       leaked_tree_for_diag, sval, state, std::move (pd));\n }\n \n /* Implementation of region_model_context::on_condition vfunc.\n@@ -1845,7 +1842,9 @@ exploded_node::on_longjmp (exploded_graph &eg,\n   /* Verify that the setjmp's call_stack hasn't been popped.  */\n   if (!valid_longjmp_stack_p (longjmp_point, setjmp_point))\n     {\n-      ctxt->warn (new stale_jmp_buf (setjmp_call, longjmp_call, setjmp_point));\n+      ctxt->warn (make_unique<stale_jmp_buf> (setjmp_call,\n+\t\t\t\t\t      longjmp_call,\n+\t\t\t\t\t      setjmp_point));\n       return;\n     }\n \n@@ -4243,7 +4242,7 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\tconst svalue *fn_ptr_sval\n \t\t\t  = model->get_rvalue (fn_ptr, &ctxt);\n \t\t\tif (fn_ptr_sval->all_zeroes_p ())\n-\t\t\t  ctxt.warn (new jump_through_null (call));\n+\t\t\t  ctxt.warn (make_unique<jump_through_null> (call));\n \t\t      }\n \n \t\t    /* An unknown function or a special function was called"}, {"sha": "dae73daf54a83428f8322e949e8ae83695a49ce3", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -56,8 +56,8 @@ class impl_region_model_context : public region_model_context\n \t\t\t     uncertainty_t *uncertainty,\n \t\t\t     logger *logger = NULL);\n \n-  bool warn (pending_diagnostic *d) final override;\n-  void add_note (pending_note *pn) final override;\n+  bool warn (std::unique_ptr<pending_diagnostic> d) final override;\n+  void add_note (std::unique_ptr<pending_note> pn) final override;\n   void on_svalue_leak (const svalue *) override;\n   void on_liveness_change (const svalue_set &live_svalues,\n \t\t\t   const region_model *model) final override;"}, {"sha": "c5b0d6202434a361f7a963239f989289aab928bc", "filename": "gcc/analyzer/feasible-graph.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Ffeasible-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Ffeasible-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "a21c86f37b57e15cedb045f59b9621ad86aaefe9", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "6ca8ab9f4aad73b2759bfc5b654a113bfd716fe5", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_ANALYZER_PENDING_DIAGNOSTIC_H\n \n #include \"diagnostic-path.h\"\n+#include \"analyzer/sm.h\"\n \n namespace ana {\n "}, {"sha": "23635a18de1ea4a41e07dde46724e27cfd1a3067", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "d00fd5ebe0b932a51e3c11e5a878665d5776a6bf", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "171b2496f588f08b17e14d987d5c75c19ecaf218", "filename": "gcc/analyzer/region-model-asm.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-asm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-asm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-asm.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "790dc64945edf72d4d5e59b5ea8ad05c225b94da", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n@@ -54,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-path.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"make-unique.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -745,7 +747,7 @@ region_model::impl_call_putenv (const call_details &cd)\n       break;\n     case MEMSPACE_STACK:\n       if (ctxt)\n-\tctxt->warn (new putenv_of_auto_var (fndecl, reg));\n+\tctxt->warn (make_unique<putenv_of_auto_var> (fndecl, reg));\n       break;\n     }\n }"}, {"sha": "de01627bdb6c6750d00081c04f537ad4c0a3dff3", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "6d2711a01812a10abd3ec4508fe0128002470aa5", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "37b113fc978eb868708b356b580df202923a08ed", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -813,14 +814,17 @@ region_model::get_gassign_result (const gassign *assign,\n \t      if (TREE_CODE (rhs2_cst) == INTEGER_CST)\n \t\t{\n \t\t  if (tree_int_cst_sgn (rhs2_cst) < 0)\n-\t\t    ctxt->warn (new shift_count_negative_diagnostic\n-\t\t\t\t  (assign, rhs2_cst));\n+\t\t    ctxt->warn\n+\t\t      (make_unique<shift_count_negative_diagnostic>\n+\t\t\t (assign, rhs2_cst));\n \t\t  else if (compare_tree_int (rhs2_cst,\n \t\t\t\t\t     TYPE_PRECISION (TREE_TYPE (rhs1)))\n \t\t\t   >= 0)\n-\t\t    ctxt->warn (new shift_count_overflow_diagnostic\n-\t\t\t\t  (assign, TYPE_PRECISION (TREE_TYPE (rhs1)),\n-\t\t\t\t   rhs2_cst));\n+\t\t    ctxt->warn\n+\t\t      (make_unique<shift_count_overflow_diagnostic>\n+\t\t\t (assign,\n+\t\t\t  int (TYPE_PRECISION (TREE_TYPE (rhs1))),\n+\t\t\t  rhs2_cst));\n \t\t}\n \t  }\n \n@@ -1038,8 +1042,9 @@ region_model::check_for_poison (const svalue *sval,\n       const region *src_region = NULL;\n       if (pkind == POISON_KIND_UNINIT)\n \tsrc_region = get_region_for_poisoned_expr (expr);\n-      if (ctxt->warn (new poisoned_value_diagnostic (diag_arg, pkind,\n-\t\t\t\t\t\t     src_region)))\n+      if (ctxt->warn (make_unique<poisoned_value_diagnostic> (diag_arg,\n+\t\t\t\t\t\t\t      pkind,\n+\t\t\t\t\t\t\t      src_region)))\n \t{\n \t  /* We only want to report use of a poisoned value at the first\n \t     place it gets used; return an unknown value to avoid generating\n@@ -1228,7 +1233,7 @@ region_model::on_stmt_pre (const gimple *stmt,\n \t  {\n \t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n \t       diagnostic at this exploded_node.  */\n-\t    ctxt->warn (new dump_path_diagnostic ());\n+\t    ctxt->warn (make_unique<dump_path_diagnostic> ());\n \t  }\n \telse if (is_special_named_call_p (call, \"__analyzer_dump_region_model\",\n \t\t\t\t\t  0))\n@@ -1784,16 +1789,18 @@ void region_model::check_symbolic_bounds (const region *base_reg,\n \t  gcc_unreachable ();\n \t  break;\n \tcase DIR_READ:\n-\t  ctxt->warn (new symbolic_buffer_overread (base_reg, diag_arg,\n-\t\t\t\t\t\t    offset_tree,\n-\t\t\t\t\t\t    num_bytes_tree,\n-\t\t\t\t\t\t    capacity_tree));\n+\t  ctxt->warn (make_unique<symbolic_buffer_overread> (base_reg,\n+\t\t\t\t\t\t\t     diag_arg,\n+\t\t\t\t\t\t\t     offset_tree,\n+\t\t\t\t\t\t\t     num_bytes_tree,\n+\t\t\t\t\t\t\t     capacity_tree));\n \t  break;\n \tcase DIR_WRITE:\n-\t  ctxt->warn (new symbolic_buffer_overflow (base_reg, diag_arg,\n-\t\t\t\t\t\t    offset_tree,\n-\t\t\t\t\t\t    num_bytes_tree,\n-\t\t\t\t\t\t    capacity_tree));\n+\t  ctxt->warn (make_unique<symbolic_buffer_overflow> (base_reg,\n+\t\t\t\t\t\t\t     diag_arg,\n+\t\t\t\t\t\t\t     offset_tree,\n+\t\t\t\t\t\t\t     num_bytes_tree,\n+\t\t\t\t\t\t\t     capacity_tree));\n \t  break;\n \t}\n     }\n@@ -1884,10 +1891,10 @@ region_model::check_region_bounds (const region *reg,\n \t  gcc_unreachable ();\n \t  break;\n \tcase DIR_READ:\n-\t  ctxt->warn (new buffer_underread (reg, diag_arg, out));\n+\t  ctxt->warn (make_unique<buffer_underread> (reg, diag_arg, out));\n \t  break;\n \tcase DIR_WRITE:\n-\t  ctxt->warn (new buffer_underflow (reg, diag_arg, out));\n+\t  ctxt->warn (make_unique<buffer_underflow> (reg, diag_arg, out));\n \t  break;\n \t}\n     }\n@@ -1912,10 +1919,12 @@ region_model::check_region_bounds (const region *reg,\n \t  gcc_unreachable ();\n \t  break;\n \tcase DIR_READ:\n-\t  ctxt->warn (new buffer_overread (reg, diag_arg, out, byte_bound));\n+\t  ctxt->warn (make_unique<buffer_overread> (reg, diag_arg,\n+\t\t\t\t\t\t    out, byte_bound));\n \t  break;\n \tcase DIR_WRITE:\n-\t  ctxt->warn (new buffer_overflow (reg, diag_arg, out, byte_bound));\n+\t  ctxt->warn (make_unique<buffer_overflow> (reg, diag_arg,\n+\t\t\t\t\t\t    out, byte_bound));\n \t  break;\n \t}\n     }\n@@ -2564,9 +2573,10 @@ check_external_function_for_access_attr (const gcall *call,\n \t      m_access (access)\n \t    {\n \t    }\n-\t    pending_note *make_note () final override\n+\t    std::unique_ptr<pending_note> make_note () final override\n \t    {\n-\t      return new reason_attr_access (m_callee_fndecl, m_access);\n+\t      return make_unique<reason_attr_access>\n+\t\t(m_callee_fndecl, m_access);\n \t    }\n \t  private:\n \t    tree m_callee_fndecl;\n@@ -3374,7 +3384,8 @@ region_model::deref_rvalue (const svalue *ptr_sval, tree ptr_tree,\n \t\tconst poisoned_svalue *poisoned_sval\n \t\t  = as_a <const poisoned_svalue *> (ptr_sval);\n \t\tenum poison_kind pkind = poisoned_sval->get_poison_kind ();\n-\t\tctxt->warn (new poisoned_value_diagnostic (ptr, pkind, NULL));\n+\t\tctxt->warn (make_unique<poisoned_value_diagnostic>\n+\t\t\t      (ptr, pkind, NULL));\n \t      }\n \t  }\n       }\n@@ -3531,14 +3542,16 @@ region_model::check_for_writable_region (const region* dest_reg,\n       {\n \tconst function_region *func_reg = as_a <const function_region *> (base_reg);\n \ttree fndecl = func_reg->get_fndecl ();\n-\tctxt->warn (new write_to_const_diagnostic (func_reg, fndecl));\n+\tctxt->warn (make_unique<write_to_const_diagnostic>\n+\t\t      (func_reg, fndecl));\n       }\n       break;\n     case RK_LABEL:\n       {\n \tconst label_region *label_reg = as_a <const label_region *> (base_reg);\n \ttree label = label_reg->get_label ();\n-\tctxt->warn (new write_to_const_diagnostic (label_reg, label));\n+\tctxt->warn (make_unique<write_to_const_diagnostic>\n+\t\t      (label_reg, label));\n       }\n       break;\n     case RK_DECL:\n@@ -3551,11 +3564,11 @@ region_model::check_for_writable_region (const region* dest_reg,\n \t   \"this\" param is \"T* const\").  */\n \tif (TREE_READONLY (decl)\n \t    && is_global_var (decl))\n-\t  ctxt->warn (new write_to_const_diagnostic (dest_reg, decl));\n+\t  ctxt->warn (make_unique<write_to_const_diagnostic> (dest_reg, decl));\n       }\n       break;\n     case RK_STRING:\n-      ctxt->warn (new write_to_string_literal_diagnostic (dest_reg));\n+      ctxt->warn (make_unique<write_to_string_literal_diagnostic> (dest_reg));\n       break;\n     }\n }\n@@ -4031,8 +4044,8 @@ region_model::check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n \tif (TREE_CODE (cst_cap) == INTEGER_CST\n \t    && !capacity_compatible_with_type (cst_cap, pointee_size_tree,\n \t\t\t\t\t       is_struct))\n-\t  ctxt->warn (new dubious_allocation_size (lhs_reg, rhs_reg,\n-\t\t\t\t\t\t   cst_cap));\n+\t  ctxt->warn (make_unique <dubious_allocation_size> (lhs_reg, rhs_reg,\n+\t\t\t\t\t\t\t     cst_cap));\n       }\n       break;\n     default:\n@@ -4043,8 +4056,9 @@ region_model::check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n \t    if (!v.get_result ())\n \t      {\n \t\ttree expr = get_representative_tree (capacity);\n-\t\tctxt->warn (new dubious_allocation_size (lhs_reg, rhs_reg,\n-\t\t\t    expr));\n+\t\tctxt->warn (make_unique <dubious_allocation_size> (lhs_reg,\n+\t\t\t\t\t\t\t\t   rhs_reg,\n+\t\t\t\t\t\t\t\t   expr));\n \t      }\n \t  }\n       break;\n@@ -5766,7 +5780,7 @@ region_model::check_dynamic_size_for_floats (const svalue *size_in_bytes,\n   if (const svalue *float_sval = v.get_svalue_to_report ())\n \t{\n \t  tree diag_arg = get_representative_tree (float_sval);\n-\t  ctxt->warn (new float_as_size_arg (diag_arg));\n+\t  ctxt->warn (make_unique<float_as_size_arg> (diag_arg));\n \t}\n }\n \n@@ -6389,17 +6403,16 @@ region_model::maybe_complain_about_infoleak (const region *dst_reg,\n {\n   /* Check for exposure.  */\n   if (contains_uninit_p (copied_sval))\n-    ctxt->warn (new exposure_through_uninit_copy (src_reg,\n-\t\t\t\t\t\t  dst_reg,\n-\t\t\t\t\t\t  copied_sval));\n+    ctxt->warn (make_unique<exposure_through_uninit_copy> (src_reg,\n+\t\t\t\t\t\t\t   dst_reg,\n+\t\t\t\t\t\t\t   copied_sval));\n }\n \n /* class noop_region_model_context : public region_model_context.  */\n \n void\n-noop_region_model_context::add_note (pending_note *pn)\n+noop_region_model_context::add_note (std::unique_ptr<pending_note>)\n {\n-  delete pn;\n }\n \n void"}, {"sha": "91b17ce2ad9543f8857a558662f201e4f2d1a1d1", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region.h\"\n #include \"analyzer/known-function-manager.h\"\n #include \"analyzer/region-model-manager.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n \n using namespace ana;\n \n@@ -671,11 +672,11 @@ class region_model_context\n  public:\n   /* Hook for clients to store pending diagnostics.\n      Return true if the diagnostic was stored, or false if it was deleted.  */\n-  virtual bool warn (pending_diagnostic *d) = 0;\n+  virtual bool warn (std::unique_ptr<pending_diagnostic> d) = 0;\n \n-  /* Hook for clients to add a note to the last previously stored pending diagnostic.\n-     Takes ownership of the pending_node (or deletes it).  */\n-  virtual void add_note (pending_note *pn) = 0;\n+  /* Hook for clients to add a note to the last previously stored\n+     pending diagnostic.  */\n+  virtual void add_note (std::unique_ptr<pending_note> pn) = 0;\n \n   /* Hook for clients to be notified when an SVAL that was reachable\n      in a previous state is no longer live, so that clients can emit warnings\n@@ -774,8 +775,8 @@ class region_model_context\n class noop_region_model_context : public region_model_context\n {\n public:\n-  bool warn (pending_diagnostic *) override { return false; }\n-  void add_note (pending_note *pn) override;\n+  bool warn (std::unique_ptr<pending_diagnostic>) override { return false; }\n+  void add_note (std::unique_ptr<pending_note>) override;\n   void on_svalue_leak (const svalue *) override {}\n   void on_liveness_change (const svalue_set &,\n \t\t\t   const region_model *) override {}\n@@ -847,14 +848,14 @@ class tentative_region_model_context : public noop_region_model_context\n class region_model_context_decorator : public region_model_context\n {\n  public:\n-  bool warn (pending_diagnostic *d) override\n+  bool warn (std::unique_ptr<pending_diagnostic> d) override\n   {\n-    return m_inner->warn (d);\n+    return m_inner->warn (std::move (d));\n   }\n \n-  void add_note (pending_note *pn) override\n+  void add_note (std::unique_ptr<pending_note> pn) override\n   {\n-    m_inner->add_note (pn);\n+    m_inner->add_note (std::move (pn));\n   }\n \n   void on_svalue_leak (const svalue *sval) override\n@@ -961,9 +962,9 @@ class region_model_context_decorator : public region_model_context\n class note_adding_context : public region_model_context_decorator\n {\n public:\n-  bool warn (pending_diagnostic *d) override\n+  bool warn (std::unique_ptr<pending_diagnostic> d) override\n   {\n-    if (m_inner->warn (d))\n+    if (m_inner->warn (std::move (d)))\n       {\n \tadd_note (make_note ());\n \treturn true;\n@@ -973,7 +974,7 @@ class note_adding_context : public region_model_context_decorator\n   }\n \n   /* Hook to make the new note.  */\n-  virtual pending_note *make_note () = 0;\n+  virtual std::unique_ptr<pending_note> make_note () = 0;\n \n protected:\n   note_adding_context (region_model_context *inner)\n@@ -1116,9 +1117,9 @@ using namespace ::selftest;\n class test_region_model_context : public noop_region_model_context\n {\n public:\n-  bool warn (pending_diagnostic *d) final override\n+  bool warn (std::unique_ptr<pending_diagnostic> d) final override\n   {\n-    m_diagnostics.safe_push (d);\n+    m_diagnostics.safe_push (d.release ());\n     return true;\n   }\n "}, {"sha": "4bc191848a41737b6030c74923c4004bcda7cfe1", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "da0e92b511379da38f59d0446c7c49974e7f45dd", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,8 +19,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -110,7 +112,7 @@ class fd_state_machine : public state_machine\n \t\t     const svalue *rhs) const final override;\n \n   bool can_purge_p (state_t s) const final override;\n-  pending_diagnostic *on_leak (tree var) const final override;\n+  std::unique_ptr<pending_diagnostic> on_leak (tree var) const final override;\n \n   bool is_unchecked_fd_p (state_t s) const;\n   bool is_valid_fd_p (state_t s) const;\n@@ -885,19 +887,21 @@ fd_state_machine::check_for_fd_attrs (\n \t    {\n \n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new fd_use_after_close (*this, diag_arg,\n-\t\t\t\t\t\t     callee_fndecl, attr_name,\n-\t\t\t\t\t\t     arg_idx));\n+\t\t\t     make_unique<fd_use_after_close>\n+\t\t\t       (*this, diag_arg,\n+\t\t\t\tcallee_fndecl, attr_name,\n+\t\t\t\targ_idx));\n \t      continue;\n \t    }\n \n \t  if (!(is_valid_fd_p (state) || (state == m_stop)))\n \t    {\n \t      if (!is_constant_fd_p (state))\n \t\tsm_ctxt->warn (node, stmt, arg,\n-\t\t\t       new fd_use_without_check (*this, diag_arg,\n-\t\t\t\t\t\t\tcallee_fndecl, attr_name,\n-\t\t\t\t\t\t\targ_idx));\n+\t\t\t       make_unique<fd_use_without_check>\n+\t\t\t\t (*this, diag_arg,\n+\t\t\t\t  callee_fndecl, attr_name,\n+\t\t\t\t  arg_idx));\n \t    }\n \n \t  switch (fd_attr_access_dir)\n@@ -910,8 +914,11 @@ fd_state_machine::check_for_fd_attrs (\n \t\t{\n \t\t  sm_ctxt->warn (\n \t\t      node, stmt, arg,\n-\t\t      new fd_access_mode_mismatch (*this, diag_arg, DIRS_WRITE,\n-\t\t\t\t\t\t   callee_fndecl, attr_name, arg_idx));\n+\t\t      make_unique<fd_access_mode_mismatch> (*this, diag_arg,\n+\t\t\t\t\t\t\t    DIRS_WRITE,\n+\t\t\t\t\t\t\t    callee_fndecl,\n+\t\t\t\t\t\t\t    attr_name,\n+\t\t\t\t\t\t\t    arg_idx));\n \t\t}\n \n \t      break;\n@@ -921,8 +928,11 @@ fd_state_machine::check_for_fd_attrs (\n \t\t{\n \t\t  sm_ctxt->warn (\n \t\t      node, stmt, arg,\n-\t\t      new fd_access_mode_mismatch (*this, diag_arg, DIRS_READ,\n-\t\t\t\t\t\t   callee_fndecl, attr_name, arg_idx));\n+\t\t      make_unique<fd_access_mode_mismatch> (*this, diag_arg,\n+\t\t\t\t\t\t\t    DIRS_READ,\n+\t\t\t\t\t\t\t    callee_fndecl,\n+\t\t\t\t\t\t\t    attr_name,\n+\t\t\t\t\t\t\t    arg_idx));\n \t\t}\n \n \t      break;\n@@ -963,7 +973,8 @@ fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\n     }\n   else\n     {\n-      sm_ctxt->warn (node, stmt, NULL_TREE, new fd_leak (*this, NULL_TREE));\n+      sm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t     make_unique<fd_leak> (*this, NULL_TREE));\n     }\n }\n \n@@ -975,7 +986,8 @@ fd_state_machine::on_creat (sm_context *sm_ctxt, const supernode *node,\n   if (lhs)\n     sm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked_write_only);\n   else\n-    sm_ctxt->warn (node, stmt, NULL_TREE, new fd_leak (*this, NULL_TREE));\n+    sm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t   make_unique<fd_leak> (*this, NULL_TREE));\n }\n \n void\n@@ -1021,7 +1033,8 @@ fd_state_machine::check_for_dup (sm_context *sm_ctxt, const supernode *node,\n \t{\n \t  sm_ctxt->warn (\n \t      node, stmt, arg_2,\n-\t      new fd_use_without_check (*this, diag_arg_2, callee_fndecl));\n+\t      make_unique<fd_use_without_check> (*this, diag_arg_2,\n+\t\t\t\t\t\t callee_fndecl));\n \t  return;\n \t}\n       /* dup2 returns value of its second argument on success.But, the\n@@ -1059,7 +1072,8 @@ fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\n \n   if (is_closed_fd_p (state))\n     {\n-      sm_ctxt->warn (node, stmt, arg, new fd_double_close (*this, diag_arg));\n+      sm_ctxt->warn (node, stmt, arg,\n+\t\t     make_unique<fd_double_close> (*this, diag_arg));\n       sm_ctxt->set_next_state (stmt, arg, m_stop);\n     }\n }\n@@ -1091,7 +1105,8 @@ fd_state_machine::check_for_open_fd (\n   if (is_closed_fd_p (state))\n     {\n       sm_ctxt->warn (node, stmt, arg,\n-\t\t     new fd_use_after_close (*this, diag_arg, callee_fndecl));\n+\t\t     make_unique<fd_use_after_close> (*this, diag_arg,\n+\t\t\t\t\t\t      callee_fndecl));\n     }\n \n   else\n@@ -1101,7 +1116,8 @@ fd_state_machine::check_for_open_fd (\n \t  if (!is_constant_fd_p (state))\n \t    sm_ctxt->warn (\n \t\tnode, stmt, arg,\n-\t\tnew fd_use_without_check (*this, diag_arg, callee_fndecl));\n+\t\tmake_unique<fd_use_without_check> (*this, diag_arg,\n+\t\t\t\t\t\t   callee_fndecl));\n \t}\n       switch (callee_fndecl_dir)\n \t{\n@@ -1112,7 +1128,7 @@ fd_state_machine::check_for_open_fd (\n \t    {\n \t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new fd_access_mode_mismatch (\n+\t\t\t     make_unique<fd_access_mode_mismatch> (\n \t\t\t\t *this, diag_arg, DIRS_WRITE, callee_fndecl));\n \t    }\n \n@@ -1123,7 +1139,7 @@ fd_state_machine::check_for_open_fd (\n \t    {\n \t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new fd_access_mode_mismatch (\n+\t\t\t     make_unique<fd_access_mode_mismatch> (\n \t\t\t\t *this, diag_arg, DIRS_READ, callee_fndecl));\n \t    }\n \t  break;\n@@ -1195,10 +1211,10 @@ fd_state_machine::can_purge_p (state_t s) const\n     return true;\n }\n \n-pending_diagnostic *\n+std::unique_ptr<pending_diagnostic>\n fd_state_machine::on_leak (tree var) const\n {\n-  return new fd_leak (*this, var);\n+  return make_unique<fd_leak> (*this, var);\n }\n } // namespace\n "}, {"sha": "cbd17887e93f89f0b751f7d9cccfc009c1457541", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,8 +19,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -79,7 +81,7 @@ class fileptr_state_machine : public state_machine\n \t\t     const svalue *rhs) const final override;\n \n   bool can_purge_p (state_t s) const final override;\n-  pending_diagnostic *on_leak (tree var) const final override;\n+  std::unique_ptr<pending_diagnostic> on_leak (tree var) const final override;\n \n   /* State for a FILE * returned from fopen that hasn't been checked for\n      NULL.\n@@ -404,7 +406,7 @@ fileptr_state_machine::on_stmt (sm_context *sm_ctxt,\n \t      {\n \t\ttree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t\tsm_ctxt->warn (node, stmt, arg,\n-\t\t\t       new double_fclose (*this, diag_arg));\n+\t\t\t       make_unique<double_fclose> (*this, diag_arg));\n \t\tsm_ctxt->set_next_state (stmt, arg, m_stop);\n \t      }\n \t    return true;\n@@ -471,10 +473,10 @@ fileptr_state_machine::can_purge_p (state_t s) const\n    fileptr_state_machine, for complaining about leaks of FILE * in\n    state 'unchecked' and 'nonnull'.  */\n \n-pending_diagnostic *\n+std::unique_ptr<pending_diagnostic>\n fileptr_state_machine::on_leak (tree var) const\n {\n-  return new file_leak (*this, var);\n+  return make_unique<file_leak> (*this, var);\n }\n \n } // anonymous namespace"}, {"sha": "d050ef83eeb0c6742cc14fa04c80db78c7689241", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,8 +19,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -383,7 +385,7 @@ class malloc_state_machine : public state_machine\n \t\t     const svalue *rhs) const final override;\n \n   bool can_purge_p (state_t s) const final override;\n-  pending_diagnostic *on_leak (tree var) const final override;\n+  std::unique_ptr<pending_diagnostic> on_leak (tree var) const final override;\n \n   bool reset_when_passed_to_unknown_fn_p (state_t s,\n \t\t\t\t\t  bool is_mutable) const final override;\n@@ -1726,9 +1728,8 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t\t{\n \t\t\t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t\t\t  sm_ctxt->warn (node, stmt, arg,\n-\t\t\t\t\t new possible_null_arg (*this, diag_arg,\n-\t\t\t\t\t\t\t\tcallee_fndecl,\n-\t\t\t\t\t\t\t\ti));\n+\t\t\t\t\t make_unique<possible_null_arg>\n+\t\t\t\t\t   (*this, diag_arg, callee_fndecl, i));\n \t\t\t  const allocation_state *astate\n \t\t\t    = as_a_allocation_state (state);\n \t\t\t  sm_ctxt->set_next_state (stmt, arg,\n@@ -1738,8 +1739,8 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t\t{\n \t\t\t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t\t\t  sm_ctxt->warn (node, stmt, arg,\n-\t\t\t\t\t new null_arg (*this, diag_arg,\n-\t\t\t\t\t\t       callee_fndecl, i));\n+\t\t\t\t\t make_unique<null_arg>\n+\t\t\t\t\t   (*this, diag_arg, callee_fndecl, i));\n \t\t\t  sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t\t\t}\n \t\t    }\n@@ -1781,24 +1782,25 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    {\n \t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new possible_null_deref (*this, diag_arg));\n+\t\t\t     make_unique<possible_null_deref> (*this,\n+\t\t\t\t\t\t\t       diag_arg));\n \t      const allocation_state *astate = as_a_allocation_state (state);\n \t      sm_ctxt->set_next_state (stmt, arg, astate->get_nonnull ());\n \t    }\n \t  else if (state == m_null)\n \t    {\n \t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new null_deref (*this, diag_arg));\n+\t\t\t     make_unique<null_deref> (*this, diag_arg));\n \t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t    }\n \t  else if (freed_p (state))\n \t    {\n \t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t      const allocation_state *astate = as_a_allocation_state (state);\n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new use_after_free (*this, diag_arg,\n-\t\t\t\t\t\t astate->m_deallocator));\n+\t\t\t     make_unique<use_after_free>\n+\t\t\t       (*this, diag_arg, astate->m_deallocator));\n \t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t    }\n \t}\n@@ -1850,8 +1852,8 @@ malloc_state_machine::handle_free_of_non_heap (sm_context *sm_ctxt,\n       freed_reg = old_model->deref_rvalue (ptr_sval, arg, NULL);\n     }\n   sm_ctxt->warn (node, call, arg,\n-\t\t new free_of_non_heap (*this, diag_arg, freed_reg,\n-\t\t\t\t       d->m_name));\n+\t\t make_unique<free_of_non_heap>\n+\t\t   (*this, diag_arg, freed_reg, d->m_name));\n   sm_ctxt->set_next_state (call, arg, m_stop);\n }\n \n@@ -1879,11 +1881,11 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n \t{\n \t  /* Wrong allocator.  */\n \t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\t  pending_diagnostic *pd\n-\t    = new mismatching_deallocation (*this, diag_arg,\n-\t\t\t\t\t    astate->m_deallocators,\n-\t\t\t\t\t    d);\n-\t  sm_ctxt->warn (node, call, arg, pd);\n+\t  sm_ctxt->warn (node, call, arg,\n+\t\t\t make_unique<mismatching_deallocation>\n+\t\t\t   (*this, diag_arg,\n+\t\t\t    astate->m_deallocators,\n+\t\t\t    d));\n \t}\n       sm_ctxt->set_next_state (call, arg, d->m_freed);\n     }\n@@ -1895,7 +1897,7 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n       /* freed -> stop, with warning.  */\n       tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n       sm_ctxt->warn (node, call, arg,\n-\t\t     new double_free (*this, diag_arg, d->m_name));\n+\t\t     make_unique<double_free> (*this, diag_arg, d->m_name));\n       sm_ctxt->set_next_state (call, arg, m_stop);\n     }\n   else if (state == m_non_heap)\n@@ -1933,11 +1935,10 @@ malloc_state_machine::on_realloc_call (sm_context *sm_ctxt,\n \t{\n \t  /* Wrong allocator.  */\n \t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\t  pending_diagnostic *pd\n-\t    = new mismatching_deallocation (*this, diag_arg,\n-\t\t\t\t\t    astate->m_deallocators,\n-\t\t\t\t\t    d);\n-\t  sm_ctxt->warn (node, call, arg, pd);\n+\t  sm_ctxt->warn (node, call, arg,\n+\t\t\t make_unique<mismatching_deallocation>\n+\t\t\t   (*this, diag_arg,\n+\t\t\t    astate->m_deallocators, d));\n \t  sm_ctxt->set_next_state (call, arg, m_stop);\n \t  if (path_context *path_ctxt = sm_ctxt->get_path_context ())\n \t    path_ctxt->terminate_path ();\n@@ -1948,7 +1949,7 @@ malloc_state_machine::on_realloc_call (sm_context *sm_ctxt,\n       /* freed -> stop, with warning.  */\n       tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n       sm_ctxt->warn (node, call, arg,\n-\t\t     new double_free (*this, diag_arg, \"free\"));\n+\t\t     make_unique<double_free> (*this, diag_arg, \"free\"));\n       sm_ctxt->set_next_state (call, arg, m_stop);\n       if (path_context *path_ctxt = sm_ctxt->get_path_context ())\n \tpath_ctxt->terminate_path ();\n@@ -2030,10 +2031,10 @@ malloc_state_machine::can_purge_p (state_t s) const\n    (for complaining about leaks of pointers in state 'unchecked' and\n    'nonnull').  */\n \n-pending_diagnostic *\n+std::unique_ptr<pending_diagnostic>\n malloc_state_machine::on_leak (tree var) const\n {\n-  return new malloc_leak (*this, var);\n+  return make_unique<malloc_leak> (*this, var);\n }\n \n /* Implementation of state_machine::reset_when_passed_to_unknown_fn_p vfunc"}, {"sha": "704f628f5b7511b544476d22aaa12b08a5b0d543", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -21,8 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -139,8 +141,8 @@ pattern_test_state_machine::on_condition (sm_context *sm_ctxt,\n \n   if (tree lhs_expr = sm_ctxt->get_diagnostic_tree (lhs))\n     {\n-      pending_diagnostic *diag = new pattern_match (lhs_expr, op, rhs_cst);\n-      sm_ctxt->warn (node, stmt, lhs_expr, diag);\n+      sm_ctxt->warn (node, stmt, lhs_expr,\n+\t\t     make_unique<pattern_match> (lhs_expr, op, rhs_cst));\n     }\n }\n "}, {"sha": "d19765fc4a9890d1d82fac7cc5830963beb1829e", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -20,8 +20,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -181,7 +183,8 @@ sensitive_state_machine::warn_for_any_exposure (sm_context *sm_ctxt,\n     {\n       tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n       sm_ctxt->warn (node, stmt, arg,\n-\t\t     new exposure_through_output_file (*this, diag_arg));\n+\t\t     make_unique<exposure_through_output_file> (*this,\n+\t\t\t\t\t\t\t\tdiag_arg));\n     }\n }\n "}, {"sha": "737ec4a8ad53bb81a8349492f475af8b3e5bef88", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -21,8 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -351,8 +353,8 @@ signal_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  if (signal_unsafe_p (callee_fndecl))\n \t    if (sm_ctxt->get_global_state () == m_in_signal_handler)\n \t      sm_ctxt->warn (node, stmt, NULL_TREE,\n-\t\t\t     new signal_unsafe_call (*this, call,\n-\t\t\t\t\t\t     callee_fndecl));\n+\t\t\t     make_unique<signal_unsafe_call>\n+\t\t\t       (*this, call, callee_fndecl));\n     }\n \n   return false;"}, {"sha": "d4ee6c435b8f54a214be78258c55a9564fdc584b", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -21,8 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -1163,10 +1165,11 @@ taint_state_machine::check_for_tainted_size_arg (sm_context *sm_ctxt,\n \t    TREE_STRING_POINTER (access->to_external_string ());\n \t  tree diag_size = sm_ctxt->get_diagnostic_tree (size_arg);\n \t  sm_ctxt->warn (node, call, size_arg,\n-\t\t\t new tainted_access_attrib_size (*this, diag_size, b,\n-\t\t\t\t\t\t\t callee_fndecl,\n-\t\t\t\t\t\t\t access->sizarg,\n-\t\t\t\t\t\t\t access_str));\n+\t\t\t make_unique<tainted_access_attrib_size>\n+\t\t\t   (*this, diag_size, b,\n+\t\t\t    callee_fndecl,\n+\t\t\t    access->sizarg,\n+\t\t\t    access_str));\n \t}\n     }\n }\n@@ -1201,7 +1204,7 @@ taint_state_machine::check_for_tainted_divisor (sm_context *sm_ctxt,\n \n       tree diag_divisor = sm_ctxt->get_diagnostic_tree (divisor_expr);\n       sm_ctxt->warn (node, assign, divisor_expr,\n-\t\t     new tainted_divisor (*this, diag_divisor, b));\n+\t\t     make_unique <tainted_divisor> (*this, diag_divisor, b));\n       sm_ctxt->set_next_state (assign, divisor_sval, m_stop);\n     }\n }\n@@ -1264,7 +1267,7 @@ region_model::check_region_for_taint (const region *reg,\n \t    if (taint_sm.get_taint (state, index->get_type (), &b))\n \t    {\n \t      tree arg = get_representative_tree (index);\n-\t      ctxt->warn (new tainted_array_index (taint_sm, arg, b));\n+\t      ctxt->warn (make_unique<tainted_array_index> (taint_sm, arg, b));\n \t    }\n \t  }\n \t  break;\n@@ -1286,7 +1289,7 @@ region_model::check_region_for_taint (const region *reg,\n \t    if (taint_sm.get_taint (state, effective_type, &b))\n \t      {\n \t\ttree arg = get_representative_tree (offset);\n-\t\tctxt->warn (new tainted_offset (taint_sm, arg, b));\n+\t\tctxt->warn (make_unique<tainted_offset> (taint_sm, arg, b));\n \t      }\n \t  }\n \t  break;\n@@ -1311,7 +1314,7 @@ region_model::check_region_for_taint (const region *reg,\n \t    if (taint_sm.get_taint (state, size_sval->get_type (), &b))\n \t      {\n \t\ttree arg = get_representative_tree (size_sval);\n-\t\tctxt->warn (new tainted_size (taint_sm, arg, b));\n+\t\tctxt->warn (make_unique<tainted_size> (taint_sm, arg, b));\n \t      }\n \t  }\n \t  break;\n@@ -1357,7 +1360,8 @@ region_model::check_dynamic_size_for_taint (enum memory_space mem_space,\n   if (taint_sm.get_taint (state, size_in_bytes->get_type (), &b))\n     {\n       tree arg = get_representative_tree (size_in_bytes);\n-      ctxt->warn (new tainted_allocation_size (taint_sm, arg, b, mem_space));\n+      ctxt->warn (make_unique<tainted_allocation_size>\n+\t\t    (taint_sm, arg, b, mem_space));\n     }\n }\n "}, {"sha": "1f329cb11d07fe6b802e4504559a47f861d6ae92", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n@@ -39,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/store.h\"\n #include \"analyzer/svalue.h\"\n #include \"analyzer/program-state.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -121,6 +123,14 @@ state_machine::get_state_by_name (const char *name) const\n   gcc_unreachable ();\n }\n \n+/* Base implementation of state_machine::on_leak.  */\n+\n+std::unique_ptr<pending_diagnostic>\n+state_machine::on_leak (tree var ATTRIBUTE_UNUSED) const\n+{\n+  return NULL;\n+}\n+\n /* Dump a multiline representation of this state machine to PP.  */\n \n void"}, {"sha": "0171474e4b92161894b7609eaa1f2b4b29986fd4", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -123,10 +123,8 @@ class state_machine : public log_user\n   virtual bool can_purge_p (state_t s) const = 0;\n \n   /* Called when VAR leaks (and !can_purge_p).  */\n-  virtual pending_diagnostic *on_leak (tree var ATTRIBUTE_UNUSED) const\n-  {\n-    return NULL;\n-  }\n+  virtual std::unique_ptr<pending_diagnostic>\n+  on_leak (tree var ATTRIBUTE_UNUSED) const;\n \n   /* Return true if S should be reset to \"start\" for values passed (or reachable\n      from) calls to unknown functions.  IS_MUTABLE is true for pointers as\n@@ -250,9 +248,11 @@ class sm_context\n   /* Called by state_machine in response to pattern matches:\n      issue a diagnostic D using NODE and STMT for location information.  */\n   virtual void warn (const supernode *node, const gimple *stmt,\n-\t\t     tree var, pending_diagnostic *d) = 0;\n+\t\t     tree var,\n+\t\t     std::unique_ptr<pending_diagnostic> d) = 0;\n   virtual void warn (const supernode *node, const gimple *stmt,\n-\t\t     const svalue *var, pending_diagnostic *d) = 0;\n+\t\t     const svalue *var,\n+\t\t     std::unique_ptr<pending_diagnostic> d) = 0;\n \n   /* For use when generating trees when creating pending_diagnostics, so that\n      rather than e.g."}, {"sha": "6fac18a2bbc0ff229e3b7e2686529b32f7544030", "filename": "gcc/analyzer/state-purge.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "c0f5ed104e1eba44c3ca80903da55d5ad8952b74", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "aa03b049724da8ff17797e1991a21a015229840b", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "9a42248e6fa05c6f780eead0434fe347a0e4fc5a", "filename": "gcc/analyzer/trimmed-graph.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Ftrimmed-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Ftrimmed-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ftrimmed-graph.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "8b1d8091e17ebb54a5ce1f92be706506f2b4f4fb", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -19,8 +19,10 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"tree.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n@@ -212,7 +214,7 @@ class va_list_state_machine : public state_machine\n   {\n     return s != m_started;\n   }\n-  pending_diagnostic *on_leak (tree var) const final override;\n+  std::unique_ptr<pending_diagnostic> on_leak (tree var) const final override;\n \n   /* State for a va_list that the result of a va_start or va_copy.  */\n   state_t m_started;\n@@ -553,8 +555,8 @@ va_list_state_machine::check_for_ended_va_list (sm_context *sm_ctxt,\n {\n   if (sm_ctxt->get_state (call, arg) == m_ended)\n     sm_ctxt->warn (node, call, arg,\n-\t\t   new va_list_use_after_va_end (*this, arg, NULL_TREE,\n-\t\t\t\t\t\t usage_fnname));\n+\t\t   make_unique<va_list_use_after_va_end>\n+\t\t     (*this, arg, NULL_TREE, usage_fnname));\n }\n \n /* Get the svalue with associated va_list_state_machine state for\n@@ -629,10 +631,10 @@ va_list_state_machine::on_va_end (sm_context *sm_ctxt,\n /* Implementation of state_machine::on_leak vfunc for va_list_state_machine\n    (for complaining about leaks of values in state 'started').  */\n \n-pending_diagnostic *\n+std::unique_ptr<pending_diagnostic>\n va_list_state_machine::on_leak (tree var) const\n {\n-  return new va_list_leak (*this, NULL, var);\n+  return make_unique<va_list_leak> (*this, NULL, var);\n }\n \n } // anonymous namespace\n@@ -1000,17 +1002,19 @@ region_model::impl_call_va_arg (const call_details &cd)\n \t\t  else\n \t\t    {\n \t\t      if (ctxt)\n-\t\t\tctxt->warn (new va_arg_type_mismatch (va_list_tree,\n-\t\t\t\t\t\t\t      arg_reg,\n-\t\t\t\t\t\t\t      lhs_type,\n-\t\t\t\t\t\t\t      arg_type));\n+\t\t\tctxt->warn (make_unique <va_arg_type_mismatch>\n+\t\t\t\t      (va_list_tree,\n+\t\t\t\t       arg_reg,\n+\t\t\t\t       lhs_type,\n+\t\t\t\t       arg_type));\n \t\t      saw_problem = true;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (ctxt)\n-\t\t    ctxt->warn (new va_list_exhausted (va_list_tree, arg_reg));\n+\t\t    ctxt->warn (make_unique <va_list_exhausted> (va_list_tree,\n+\t\t\t\t\t\t\t\t arg_reg));\n \t\t  saw_problem = true;\n \t\t}\n \t    }"}, {"sha": "cf0baa5670d1e35ca93897de5cf5a97fb4087c61", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_gil_plugin.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -4,10 +4,12 @@\n */\n /* { dg-options \"-g\" } */\n \n+#define INCLUDE_MEMORY\n #include \"gcc-plugin.h\"\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"make-unique.h\"\n #include \"diagnostic.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n@@ -309,9 +311,9 @@ gil_state_machine::check_for_pyobject_in_call (sm_context *sm_ctxt,\n       if (type_based_on_pyobject_p (type))\n \t{\n \t  sm_ctxt->warn (node, call, NULL_TREE,\n-\t\t\t new fncall_without_gil (*this, call,\n-\t\t\t\t\t\t callee_fndecl,\n-\t\t\t\t\t\t i));\n+\t\t\t make_unique<fncall_without_gil> (*this, call,\n+\t\t\t\t\t\t\t  callee_fndecl,\n+\t\t\t\t\t\t\t  i));\n \t  sm_ctxt->set_global_state (m_stop);\n \t}\n     }\n@@ -337,7 +339,7 @@ gil_state_machine::on_stmt (sm_context *sm_ctxt,\n \t      if (global_state == m_released_gil)\n \t\t{\n \t\t  sm_ctxt->warn (node, stmt, NULL_TREE,\n-\t\t\t\t new double_save_thread (*this, call));\n+\t\t\t\t make_unique<double_save_thread> (*this, call));\n \t\t  sm_ctxt->set_global_state (m_stop);\n \t\t}\n \t      else\n@@ -393,7 +395,7 @@ gil_state_machine::check_for_pyobject_usage_without_gil (sm_context *sm_ctxt,\n   if (type_based_on_pyobject_p (type))\n     {\n       sm_ctxt->warn (node, stmt, NULL_TREE,\n-\t\t     new pyobject_usage_without_gil (*this, op));\n+\t\t     make_unique<pyobject_usage_without_gil> (*this, op));\n       sm_ctxt->set_global_state (m_stop);\n     }\n }"}, {"sha": "d1c29132e6765bc85ea3372663fb2511e899b231", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_kernel_plugin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -1,6 +1,7 @@\n /* Proof-of-concept of a -fanalyzer plugin for the Linux kernel.  */\n /* { dg-options \"-g\" } */\n \n+#define INCLUDE_MEMORY\n #include \"gcc-plugin.h\"\n #include \"config.h\"\n #include \"system.h\""}, {"sha": "ccf69ed83389c7d3c1264dfdc5107d826cd1fc81", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_known_fns_plugin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6341f14e369a5cd5920bb91660cfea1b2594628f/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c?ref=6341f14e369a5cd5920bb91660cfea1b2594628f", "patch": "@@ -1,6 +1,7 @@\n /* Proof-of-concept of a -fanalyzer plugin to handle known functions.  */\n /* { dg-options \"-g\" } */\n \n+#define INCLUDE_MEMORY\n #include \"gcc-plugin.h\"\n #include \"config.h\"\n #include \"system.h\""}]}