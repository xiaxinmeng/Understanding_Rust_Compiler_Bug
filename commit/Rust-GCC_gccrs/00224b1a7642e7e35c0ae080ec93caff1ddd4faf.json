{"sha": "00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyMjRiMWE3NjQyZTdlMzVjMGFlMDgwZWM5M2NhZmYxZGRkNGZhZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:18:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:18:38Z"}, "message": "poly_int: process_alt_operands\n\nThis patch makes process_alt_operands check that the mode sizes\nare ordered, so that match_reload can validly treat them as subregs\nof one another.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* lra-constraints.c (process_alt_operands): Reject matched\n\toperands whose sizes aren't ordered.\n\t(match_reload): Refer to this check here.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256158", "tree": {"sha": "89b96524133cfefe0f1a3fd01d2aab484841fc3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89b96524133cfefe0f1a3fd01d2aab484841fc3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00224b1a7642e7e35c0ae080ec93caff1ddd4faf/comments", "author": null, "committer": null, "parents": [{"sha": "4871e1ed1728da22d48cfad1cb25a0a37f65d1bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4871e1ed1728da22d48cfad1cb25a0a37f65d1bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4871e1ed1728da22d48cfad1cb25a0a37f65d1bc"}], "stats": {"total": 17, "additions": 17, "deletions": 0}, "files": [{"sha": "799be1c22efc674db278e3d621c962b8a1854902", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00224b1a7642e7e35c0ae080ec93caff1ddd4faf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00224b1a7642e7e35c0ae080ec93caff1ddd4faf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lra-constraints.c (process_alt_operands): Reject matched\n+\toperands whose sizes aren't ordered.\n+\t(match_reload): Refer to this check here.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "59daf11062a8e8a5d4ccd8bd4e5b779ae538b97b", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00224b1a7642e7e35c0ae080ec93caff1ddd4faf/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00224b1a7642e7e35c0ae080ec93caff1ddd4faf/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "patch": "@@ -933,6 +933,8 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n   push_to_sequence (*before);\n   if (inmode != outmode)\n     {\n+      /* process_alt_operands has already checked that the mode sizes\n+\t are ordered.  */\n       if (partial_subreg_p (outmode, inmode))\n \t{\n \t  reg = new_in_reg\n@@ -2112,6 +2114,13 @@ process_alt_operands (int only_alternative)\n \t\t    len = 0;\n \t\t    lra_assert (nop > m);\n \n+\t\t    /* Reject matches if we don't know which operand is\n+\t\t       bigger.  This situation would arguably be a bug in\n+\t\t       an .md pattern, but could also occur in a user asm.  */\n+\t\t    if (!ordered_p (GET_MODE_SIZE (biggest_mode[m]),\n+\t\t\t\t    GET_MODE_SIZE (biggest_mode[nop])))\n+\t\t      break;\n+\n \t\t    this_alternative_matches = m;\n \t\t    m_hregno = get_hard_regno (*curr_id->operand_loc[m], false);\n \t\t    /* We are supposed to match a previous operand."}]}