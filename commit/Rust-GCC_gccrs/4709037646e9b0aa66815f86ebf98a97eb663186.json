{"sha": "4709037646e9b0aa66815f86ebf98a97eb663186", "node_id": "C_kwDOANBUbNoAKDQ3MDkwMzc2NDZlOWIwYWE2NjgxNWY4NmViZjk4YTk3ZWI2NjMxODY", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-07-07T09:38:42Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-13T10:01:16Z"}, "message": "[Ada] Fix proof of runtime unit System.Arith_64\n\nAfter changes in provers and Why3, changes are needed to recover\nautomatic proof of System.Arith_64. This is the first part of it.\n\ngcc/ada/\n\n\t* libgnat/s-aridou.adb (Lemma_Mult_Div, Lemma_Powers): New\n\tlemmas.\n\t(Prove_Sign_Quotient): New local lemma.\n\t(Prove_Signs): Expand definition of Big_R and Big_Q in the\n\tpostcondition. Add intermediate assertions.\n\t(Double_Divide): Call new lemma.\n\t(Lemma_Div_Eq): Provide body for proving lemma.\n\t(Lemma_Powers_Of_2, Lemma_Shift_Without_Drop,\n\tProve_Dividend_Scaling, Prove_Multiplication, Prove_Z_Low): Call\n\tlemmas, add intermediate assertions.", "tree": {"sha": "aa5b3e1e87aec40d1510c396f8da617a77a30ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa5b3e1e87aec40d1510c396f8da617a77a30ac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4709037646e9b0aa66815f86ebf98a97eb663186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4709037646e9b0aa66815f86ebf98a97eb663186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4709037646e9b0aa66815f86ebf98a97eb663186", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4709037646e9b0aa66815f86ebf98a97eb663186/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d03a7f8c247d73258b80891c79358b745c379992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d03a7f8c247d73258b80891c79358b745c379992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d03a7f8c247d73258b80891c79358b745c379992"}], "stats": {"total": 96, "additions": 92, "deletions": 4}, "files": [{"sha": "b40e4c3869a6c608a26289a2fb983db489b7c201", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 92, "deletions": 4, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4709037646e9b0aa66815f86ebf98a97eb663186/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4709037646e9b0aa66815f86ebf98a97eb663186/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=4709037646e9b0aa66815f86ebf98a97eb663186", "patch": "@@ -438,6 +438,12 @@ is\n      Ghost,\n      Post => X * (Y + Z) = X * Y + X * Z;\n \n+   procedure Lemma_Mult_Div (A, B : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => B /= 0,\n+     Post => A * B / B = A;\n+\n    procedure Lemma_Mult_Non_Negative (X, Y : Big_Integer)\n    with\n      Ghost,\n@@ -469,6 +475,12 @@ is\n      Post => not In_Double_Int_Range (Big_2xxDouble)\n        and then not In_Double_Int_Range (-Big_2xxDouble);\n \n+   procedure Lemma_Powers (A : Big_Natural; B, C : Natural)\n+   with\n+     Ghost,\n+     Pre  => B <= Natural'Last - C,\n+     Post => A**B * A**C = A**(B + C);\n+\n    procedure Lemma_Powers_Of_2 (M, N : Natural)\n    with\n      Ghost,\n@@ -606,7 +618,6 @@ is\n    is null;\n    procedure Lemma_Div_Ge (X, Y, Z : Big_Integer) is null;\n    procedure Lemma_Div_Lt (X, Y, Z : Big_Natural) is null;\n-   procedure Lemma_Div_Eq (A, B, S, R : Big_Integer) is null;\n    procedure Lemma_Double_Big_2xxSingle is null;\n    procedure Lemma_Double_Shift (X : Double_Uns; S, S1 : Double_Uns) is null;\n    procedure Lemma_Double_Shift (X : Single_Uns; S, S1 : Natural) is null;\n@@ -629,6 +640,7 @@ is\n    procedure Lemma_Mult_Non_Positive (X, Y : Big_Integer) is null;\n    procedure Lemma_Neg_Rem (X, Y : Big_Integer) is null;\n    procedure Lemma_Not_In_Range_Big2xx64 is null;\n+   procedure Lemma_Powers (A : Big_Natural; B, C : Natural) is null;\n    procedure Lemma_Rem_Commutation (X, Y : Double_Uns) is null;\n    procedure Lemma_Rem_Is_Ident (X, Y : Big_Integer) is null;\n    procedure Lemma_Rem_Sign (X, Y : Big_Integer) is null;\n@@ -864,6 +876,23 @@ is\n         Post => abs Big_Q = Big (Qu);\n       --  Proves correctness of the rounding of the unsigned quotient\n \n+      procedure Prove_Sign_Quotient\n+      with\n+        Ghost,\n+        Pre  => Mult /= 0\n+          and then Quot = Big (X) / (Big (Y) * Big (Z))\n+          and then Big_R = Big (X) rem (Big (Y) * Big (Z))\n+          and then Big_Q =\n+            (if Round then\n+               Round_Quotient (Big (X), Big (Y) * Big (Z), Quot, Big_R)\n+             else Quot),\n+        Post =>\n+          (if X >= 0 then\n+             (if Den_Pos then Big_Q >= 0 else Big_Q <= 0)\n+           else\n+             (if Den_Pos then Big_Q <= 0 else Big_Q >= 0));\n+      --  Proves the correct sign of the signed quotient Big_Q\n+\n       procedure Prove_Signs\n       with\n         Ghost,\n@@ -880,7 +909,13 @@ is\n           and then\n             Q = (if (X >= 0) = Den_Pos then To_Int (Qu) else To_Int (-Qu))\n           and then not (X = Double_Int'First and then Big (Y) * Big (Z) = -1),\n-        Post => Big (R) = Big_R and then Big (Q) = Big_Q;\n+        Post => Big (R) = Big (X) rem (Big (Y) * Big (Z))\n+          and then\n+            (if Round then\n+               Big (Q) = Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                         Big (X) / (Big (Y) * Big (Z)),\n+                                         Big (R))\n+             else Big (Q) = Big (X) / (Big (Y) * Big (Z)));\n       --  Proves final signs match the intended result after the unsigned\n       --  division is done.\n \n@@ -891,6 +926,7 @@ is\n       procedure Prove_Overflow_Case is null;\n       procedure Prove_Quotient_Zero is null;\n       procedure Prove_Round_To_One is null;\n+      procedure Prove_Sign_Quotient is null;\n \n       -------------------------\n       -- Prove_Rounding_Case --\n@@ -1056,6 +1092,8 @@ is\n             pragma Assert (Big (Double_Uns (Hi (T2))) >= 1);\n             pragma Assert (Big (Double_Uns (Lo (T2))) >= 0);\n             pragma Assert (Big (Double_Uns (Lo (T1))) >= 0);\n+            pragma Assert (Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n+                                         + Big (Double_Uns (Lo (T1))) >= 0);\n             pragma Assert (Mult >= Big_2xxDouble * Big (Double_Uns (Hi (T2))));\n             pragma Assert (Mult >= Big_2xxDouble);\n             if Hi (T2) > 1 then\n@@ -1064,6 +1102,10 @@ is\n                                  Mult > Big_2xxDouble);\n             elsif Lo (T2) > 0 then\n                pragma Assert (Big (Double_Uns (Lo (T2))) > 0);\n+               pragma Assert (Big_2xxSingle > 0);\n+               pragma Assert (Big_2xxSingle * Big (Double_Uns (Lo (T2))) > 0);\n+               pragma Assert (Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n+                                            + Big (Double_Uns (Lo (T1))) > 0);\n                pragma Assert (if X = Double_Int'First and then Round then\n                                  Mult > Big_2xxDouble);\n             elsif Lo (T1) > 0 then\n@@ -1138,6 +1180,7 @@ is\n       end if;\n \n       pragma Assert (abs Big_Q = Big (Qu));\n+      Prove_Sign_Quotient;\n \n       --  Set final signs (RM 4.5.5(27-30))\n \n@@ -1225,6 +1268,18 @@ is\n       pragma Assert ((Hi or Lo) = Hi + Lo);\n    end Lemma_Concat_Definition;\n \n+   ------------------\n+   -- Lemma_Div_Eq --\n+   ------------------\n+\n+   procedure Lemma_Div_Eq (A, B, S, R : Big_Integer) is\n+   begin\n+      pragma Assert ((A - B) * S = R);\n+      pragma Assert ((A - B) * S / S = R / S);\n+      Lemma_Mult_Div (A - B, S);\n+      pragma Assert (A - B = R / S);\n+   end Lemma_Div_Eq;\n+\n    ------------------------\n    -- Lemma_Double_Shift --\n    ------------------------\n@@ -1317,6 +1372,19 @@ is\n                                       + Big (Double_Uns'(Xlo * Ylo)));\n    end Lemma_Mult_Decomposition;\n \n+   --------------------\n+   -- Lemma_Mult_Div --\n+   --------------------\n+\n+   procedure Lemma_Mult_Div (A, B : Big_Integer) is\n+   begin\n+      if B > 0 then\n+         pragma Assert (A * B / B = A);\n+      else\n+         pragma Assert (A * (-B) / (-B) = A);\n+      end if;\n+   end Lemma_Mult_Div;\n+\n    -------------------\n    -- Lemma_Neg_Div --\n    -------------------\n@@ -1341,6 +1409,7 @@ is\n       Lemma_Powers_Of_2_Commutation (M);\n       Lemma_Powers_Of_2_Commutation (N);\n       Lemma_Powers_Of_2_Commutation (M + N);\n+      Lemma_Powers (Big (Double_Uns'(2)), M, N);\n \n       if M + N < Double_Size then\n          pragma Assert (Big (Double_Uns'(2))**M * Big (Double_Uns'(2))**N\n@@ -1516,6 +1585,8 @@ is\n       pragma Assert (X < 2**(Double_Size - Shift));\n       pragma Assert (Big (X) < Big_2xx (Double_Size - Shift));\n       pragma Assert (Y = 2**Shift * X);\n+      Lemma_Lt_Mult (Big (X), Big_2xx (Double_Size - Shift), Big_2xx (Shift),\n+                     Big_2xx (Shift) * Big_2xx (Double_Size - Shift));\n       pragma Assert (Big_2xx (Shift) * Big (X)\n                      < Big_2xx (Shift) * Big_2xx (Double_Size - Shift));\n       Lemma_Powers_Of_2 (Shift, Double_Size - Shift);\n@@ -2063,8 +2134,8 @@ is\n \n       begin\n          Lemma_Shift_Left (D (1) & D (2), Scale);\n-         pragma Assert (By (Big_2xxSingle * Big_2xx (Scale) <= Big_2xxDouble,\n-                            Big_2xx (Scale) <= Big_2xxSingle));\n+         Lemma_Ge_Mult (Big_2xxSingle, Big_2xx (Scale), Big_2xxSingle,\n+                        Big_2xxSingle * Big_2xx (Scale));\n          Lemma_Lt_Mult (Big (Double_Uns (D (3))), Big_2xxSingle,\n                         Big_2xx (Scale), Big_2xxDouble);\n          Lemma_Shift_Left (Double_Uns (D (3)), Scale);\n@@ -2225,10 +2296,23 @@ is\n          pragma Assert\n            (Big (Double_Uns (Hi (T3))) + Big (Double_Uns (Hi (T2))) =\n               Big (Double_Uns (S1)));\n+         Lemma_Mult_Distribution (Big_2xxSingle * Big_2xxSingle,\n+                                  Big (Double_Uns (Hi (T3))),\n+                                  Big (Double_Uns (Hi (T2))));\n          pragma Assert\n            (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n             + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T3)))\n             = Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (S1)));\n+         pragma Assert (Big (Double_Uns (Q)) * Big (Zu) =\n+           Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (S1))\n+                         + Big_2xxSingle * Big (Double_Uns (S2))\n+                                         + Big (Double_Uns (S3)));\n+         pragma Assert\n+           (By (Big (Double_Uns (Q)) * Big (Zu) = Big3 (S1, S2, S3),\n+              Big3 (S1, S2, S3) =\n+                Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (S1))\n+                              + Big_2xxSingle * Big (Double_Uns (S2))\n+                                              + Big (Double_Uns (S3))));\n       end Prove_Multiplication;\n \n       -----------------------------\n@@ -2357,6 +2441,7 @@ is\n          Lemma_Div_Definition (T1, Zlo, T1 / Zlo, T1 rem Zlo);\n          pragma Assert (Double_Uns (Lo (T1 rem Zlo)) = T1 rem Zlo);\n          Lemma_Hi_Lo (T2, Lo (T1 rem Zlo), D (4));\n+         pragma Assert (T1 rem Zlo < Double_Uns (Zlo));\n          pragma Assert (T1 rem Zlo + Double_Uns'(1) <= Double_Uns (Zlo));\n          Lemma_Ge_Commutation (Double_Uns (Zlo), T1 rem Zlo + Double_Uns'(1));\n          Lemma_Add_Commutation (T1 rem Zlo, 1);\n@@ -2365,6 +2450,9 @@ is\n          pragma Assert\n            (Mult = Big (Double_Uns (Zlo)) *\n               (Big_2xxSingle * Big (T1 / Zlo) + Big (T2 / Zlo)) + Big (Ru));\n+         pragma Assert (Big_2xxSingle * Big (Double_Uns (D (2)))\n+                                      + Big (Double_Uns (D (3)))\n+                        < Big_2xxSingle * (Big (Double_Uns (D (2))) + 1));\n          Lemma_Div_Lt (Big (T1), Big_2xxSingle, Big (Double_Uns (Zlo)));\n          Lemma_Div_Commutation (T1, Double_Uns (Zlo));\n          Lemma_Lo_Is_Ident (T1 / Zlo);"}]}