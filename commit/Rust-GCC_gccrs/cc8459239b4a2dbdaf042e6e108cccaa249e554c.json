{"sha": "cc8459239b4a2dbdaf042e6e108cccaa249e554c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M4NDU5MjM5YjRhMmRiZGFmMDQyZTZlMTA4Y2NjYWEyNDllNTU0Yw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2012-03-09T04:17:02Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2012-03-09T04:17:02Z"}, "message": "Use word_mode to push/pop register for x86\n\n2012-03-08  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (setup_incoming_varargs_64): Use word_mode\n\twith integer parameters in registers.\n\t(gen_push): Push register in word_mode instead of Pmode.\n\t(ix86_emit_save_regs): Likewise.\n\t(ix86_emit_save_regs_using_mov): Save integer registers in\n\tword_mode.\n\t(gen_pop): Pop register in word_mode instead of Pmode.\n\t(ix86_emit_restore_regs_using_pop): Likewise.\n\t(ix86_expand_prologue): Replace Pmode with word_mode for push\n\timmediate.  Use ix86_gen_pro_epilogue_adjust_stack.  Save and\n\trestore RAX and R10 in word_mode.\n\t(ix86_emit_restore_regs_using_mov): Restore integer registers\n\tin word_mode.\n\t(ix86_expand_split_stack_prologue): Save R10_REG and restore in\n\tword_mode.\n\t(ix86_split_to_parts): Use word_mode with PUT_MODE for push.\n\t(ix86_split_long_move): Likewise.\n\n\t* config/i386/i386.md (W): New.\n\t(*push<mode>2_prologue): Replace :P with :W.\n\t(*pop<mode>1): Likewise.\n\t(*pop<mode>1_epilogue): Likewise.\n\t(push/pop peephole2): Use word_mode scratch registers.\n\nFrom-SVN: r185123", "tree": {"sha": "072d25a57e83bf59543cb61401b4ddeba4649ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/072d25a57e83bf59543cb61401b4ddeba4649ff5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc8459239b4a2dbdaf042e6e108cccaa249e554c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8459239b4a2dbdaf042e6e108cccaa249e554c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8459239b4a2dbdaf042e6e108cccaa249e554c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8459239b4a2dbdaf042e6e108cccaa249e554c/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78d162367846e7cf9f0588bfb3be960caf3ed614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d162367846e7cf9f0588bfb3be960caf3ed614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d162367846e7cf9f0588bfb3be960caf3ed614"}], "stats": {"total": 184, "additions": 113, "deletions": 71}, "files": [{"sha": "c36c61cb761f139f906cec22c4c653947af5309d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8459239b4a2dbdaf042e6e108cccaa249e554c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8459239b4a2dbdaf042e6e108cccaa249e554c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc8459239b4a2dbdaf042e6e108cccaa249e554c", "patch": "@@ -1,3 +1,29 @@\n+2012-03-08  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (setup_incoming_varargs_64): Use word_mode\n+\twith integer parameters in registers.\n+\t(gen_push): Push register in word_mode instead of Pmode.\n+\t(ix86_emit_save_regs): Likewise.\n+\t(ix86_emit_save_regs_using_mov): Save integer registers in\n+\tword_mode.\n+\t(gen_pop): Pop register in word_mode instead of Pmode.\n+\t(ix86_emit_restore_regs_using_pop): Likewise.\n+\t(ix86_expand_prologue): Replace Pmode with word_mode for push\n+\timmediate.  Use ix86_gen_pro_epilogue_adjust_stack.  Save and\n+\trestore RAX and R10 in word_mode.\n+\t(ix86_emit_restore_regs_using_mov): Restore integer registers\n+\tin word_mode.\n+\t(ix86_expand_split_stack_prologue): Save R10_REG and restore in\n+\tword_mode.\n+\t(ix86_split_to_parts): Use word_mode with PUT_MODE for push.\n+\t(ix86_split_long_move): Likewise.\n+\n+\t* config/i386/i386.md (W): New.\n+\t(*push<mode>2_prologue): Replace :P with :W.\n+\t(*pop<mode>1): Likewise.\n+\t(*pop<mode>1_epilogue): Likewise.\n+\t(push/pop peephole2): Use word_mode scratch registers.\n+\n 2012-03-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/predicates.md (indirect_branch_operand): Simplify."}, {"sha": "15465c2efadf8e1d17ebec73f63dff4566f35405", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8459239b4a2dbdaf042e6e108cccaa249e554c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8459239b4a2dbdaf042e6e108cccaa249e554c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cc8459239b4a2dbdaf042e6e108cccaa249e554c", "patch": "@@ -7601,12 +7601,13 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n \n   for (i = cum->regno; i < max; i++)\n     {\n-      mem = gen_rtx_MEM (Pmode,\n+      mem = gen_rtx_MEM (word_mode,\n \t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n       MEM_NOTRAP_P (mem) = 1;\n       set_mem_alias_set (mem, set);\n-      emit_move_insn (mem, gen_rtx_REG (Pmode,\n-\t\t\t\t\tx86_64_int_parameter_registers[i]));\n+      emit_move_insn (mem,\n+\t\t      gen_rtx_REG (word_mode,\n+\t\t\t\t   x86_64_int_parameter_registers[i]));\n     }\n \n   if (ix86_varargs_fpr_size)\n@@ -8661,8 +8662,11 @@ gen_push (rtx arg)\n     m->fs.cfa_offset += UNITS_PER_WORD;\n   m->fs.sp_offset += UNITS_PER_WORD;\n \n+  if (REG_P (arg) && GET_MODE (arg) != word_mode)\n+    arg = gen_rtx_REG (word_mode, REGNO (arg));\n+\n   return gen_rtx_SET (VOIDmode,\n-\t\t      gen_rtx_MEM (Pmode,\n+\t\t      gen_rtx_MEM (word_mode,\n \t\t\t\t   gen_rtx_PRE_DEC (Pmode,\n \t\t\t\t\t\t    stack_pointer_rtx)),\n \t\t      arg);\n@@ -8673,9 +8677,12 @@ gen_push (rtx arg)\n static rtx\n gen_pop (rtx arg)\n {\n+  if (REG_P (arg) && GET_MODE (arg) != word_mode)\n+    arg = gen_rtx_REG (word_mode, REGNO (arg));\n+\n   return gen_rtx_SET (VOIDmode,\n \t\t      arg,\n-\t\t      gen_rtx_MEM (Pmode,\n+\t\t      gen_rtx_MEM (word_mode,\n \t\t\t\t   gen_rtx_POST_INC (Pmode,\n \t\t\t\t\t\t     stack_pointer_rtx)));\n }\n@@ -9142,7 +9149,7 @@ ix86_emit_save_regs (void)\n   for (regno = FIRST_PSEUDO_REGISTER - 1; regno-- > 0; )\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n       {\n-\tinsn = emit_insn (gen_push (gen_rtx_REG (Pmode, regno)));\n+\tinsn = emit_insn (gen_push (gen_rtx_REG (word_mode, regno)));\n \tRTX_FRAME_RELATED_P (insn) = 1;\n       }\n }\n@@ -9222,7 +9229,7 @@ ix86_emit_save_regs_using_mov (HOST_WIDE_INT cfa_offset)\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, true))\n       {\n-        ix86_emit_save_reg_using_mov (Pmode, regno, cfa_offset);\n+        ix86_emit_save_reg_using_mov (word_mode, regno, cfa_offset);\n \tcfa_offset -= UNITS_PER_WORD;\n       }\n }\n@@ -10159,7 +10166,7 @@ ix86_expand_prologue (void)\n \t to implement macro RETURN_ADDR_RTX and intrinsic function\n \t expand_builtin_return_addr etc.  */\n       t = plus_constant (crtl->drap_reg, -UNITS_PER_WORD);\n-      t = gen_frame_mem (Pmode, t);\n+      t = gen_frame_mem (word_mode, t);\n       insn = emit_insn (gen_push (t));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n@@ -10356,14 +10363,18 @@ ix86_expand_prologue (void)\n       if (r10_live && eax_live)\n         {\n \t  t = choose_baseaddr (m->fs.sp_offset - allocate);\n-\t  emit_move_insn (r10, gen_frame_mem (Pmode, t));\n+\t  emit_move_insn (gen_rtx_REG (word_mode, R10_REG),\n+\t\t\t  gen_frame_mem (word_mode, t));\n \t  t = choose_baseaddr (m->fs.sp_offset - allocate - UNITS_PER_WORD);\n-\t  emit_move_insn (eax, gen_frame_mem (Pmode, t));\n+\t  emit_move_insn (gen_rtx_REG (word_mode, AX_REG),\n+\t\t\t  gen_frame_mem (word_mode, t));\n \t}\n       else if (eax_live || r10_live)\n \t{\n \t  t = choose_baseaddr (m->fs.sp_offset - allocate);\n-\t  emit_move_insn ((eax_live ? eax : r10), gen_frame_mem (Pmode, t));\n+\t  emit_move_insn (gen_rtx_REG (word_mode,\n+\t\t\t\t       (eax_live ? AX_REG : R10_REG)),\n+\t\t\t  gen_frame_mem (word_mode, t));\n \t}\n     }\n   gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);\n@@ -10533,7 +10544,7 @@ ix86_emit_restore_regs_using_pop (void)\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, false))\n-      ix86_emit_restore_reg_using_pop (gen_rtx_REG (Pmode, regno));\n+      ix86_emit_restore_reg_using_pop (gen_rtx_REG (word_mode, regno));\n }\n \n /* Emit code and notes for the LEAVE instruction.  */\n@@ -10576,11 +10587,11 @@ ix86_emit_restore_regs_using_mov (HOST_WIDE_INT cfa_offset,\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n       {\n-\trtx reg = gen_rtx_REG (Pmode, regno);\n+\trtx reg = gen_rtx_REG (word_mode, regno);\n \trtx insn, mem;\n \n \tmem = choose_baseaddr (cfa_offset);\n-\tmem = gen_frame_mem (Pmode, mem);\n+\tmem = gen_frame_mem (word_mode, mem);\n \tinsn = emit_move_insn (reg, mem);\n \n         if (m->fs.cfa_reg == crtl->drap_reg && regno == REGNO (crtl->drap_reg))\n@@ -11185,8 +11196,8 @@ ix86_expand_split_stack_prologue (void)\n \t{\n \t  rtx rax;\n \n-\t  rax = gen_rtx_REG (Pmode, AX_REG);\n-\t  emit_move_insn (rax, reg10);\n+\t  rax = gen_rtx_REG (word_mode, AX_REG);\n+\t  emit_move_insn (rax, gen_rtx_REG (word_mode, R10_REG));\n \t  use_reg (&call_fusage, rax);\n \t}\n \n@@ -11265,8 +11276,8 @@ ix86_expand_split_stack_prologue (void)\n   /* If we are in 64-bit mode and this function uses a static chain,\n      we saved %r10 in %rax before calling _morestack.  */\n   if (TARGET_64BIT && DECL_STATIC_CHAIN (cfun->decl))\n-    emit_move_insn (gen_rtx_REG (Pmode, R10_REG),\n-\t\t    gen_rtx_REG (Pmode, AX_REG));\n+    emit_move_insn (gen_rtx_REG (word_mode, R10_REG),\n+\t\t    gen_rtx_REG (word_mode, AX_REG));\n \n   /* If this function calls va_start, we need to store a pointer to\n      the arguments on the old stack, because they may not have been\n@@ -20275,7 +20286,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n       gcc_assert (ok);\n \n       operand = copy_rtx (operand);\n-      PUT_MODE (operand, Pmode);\n+      PUT_MODE (operand, word_mode);\n       parts[0] = parts[1] = parts[2] = parts[3] = operand;\n       return size;\n     }\n@@ -20428,7 +20439,7 @@ ix86_split_long_move (rtx operands[])\n       if (push_operand (operands[0], VOIDmode))\n \t{\n \t  operands[0] = copy_rtx (operands[0]);\n-\t  PUT_MODE (operands[0], Pmode);\n+\t  PUT_MODE (operands[0], word_mode);\n \t}\n       else\n         operands[0] = gen_lowpart (DImode, operands[0]);"}, {"sha": "188c9828038df50904c739bc854ba70f8f302fa6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 56, "deletions": 51, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8459239b4a2dbdaf042e6e108cccaa249e554c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8459239b4a2dbdaf042e6e108cccaa249e554c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cc8459239b4a2dbdaf042e6e108cccaa249e554c", "patch": "@@ -894,6 +894,11 @@\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n \n+;; This mode iterator allows :W to be used for patterns that operate on\n+;; word_mode sized quantities.\n+(define_mode_iterator W\n+  [(SI \"word_mode == SImode\") (DI \"word_mode == DImode\")])\n+\n ;; This mode iterator allows :PTR to be used for patterns that operate on\n ;; ptr_mode sized quantities.\n (define_mode_iterator PTR\n@@ -1702,25 +1707,25 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*push<mode>2_prologue\"\n-  [(set (match_operand:P 0 \"push_operand\" \"=<\")\n-\t(match_operand:P 1 \"general_no_elim_operand\" \"r<i>*m\"))\n+  [(set (match_operand:W 0 \"push_operand\" \"=<\")\n+\t(match_operand:W 1 \"general_no_elim_operand\" \"r<i>*m\"))\n    (clobber (mem:BLK (scratch)))]\n   \"\"\n   \"push{<imodesuffix>}\\t%1\"\n   [(set_attr \"type\" \"push\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*pop<mode>1\"\n-  [(set (match_operand:P 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(match_operand:P 1 \"pop_operand\" \">\"))]\n+  [(set (match_operand:W 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(match_operand:W 1 \"pop_operand\" \">\"))]\n   \"\"\n   \"pop{<imodesuffix>}\\t%0\"\n   [(set_attr \"type\" \"pop\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*pop<mode>1_epilogue\"\n-  [(set (match_operand:P 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(match_operand:P 1 \"pop_operand\" \">\"))\n+  [(set (match_operand:W 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(match_operand:W 1 \"pop_operand\" \">\"))\n    (clobber (mem:BLK (scratch)))]\n   \"\"\n   \"pop{<imodesuffix>}\\t%0\"\n@@ -17334,131 +17339,131 @@\n ;; alternative when no register is available later.\n \n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"(TARGET_SINGLE_PUSH || optimize_insn_for_size_p ())\n-   && INTVAL (operands[0]) == -GET_MODE_SIZE (Pmode)\"\n+   && INTVAL (operands[0]) == -GET_MODE_SIZE (word_mode)\"\n   [(clobber (match_dup 1))\n-   (parallel [(set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n+   (parallel [(set (mem:W (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n \t      (clobber (mem:BLK (scratch)))])])\n \n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"(TARGET_DOUBLE_PUSH || optimize_insn_for_size_p ())\n-   && INTVAL (operands[0]) == -2*GET_MODE_SIZE (Pmode)\"\n+   && INTVAL (operands[0]) == -2*GET_MODE_SIZE (word_mode)\"\n   [(clobber (match_dup 1))\n-   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n-   (parallel [(set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n+   (set (mem:W (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n+   (parallel [(set (mem:W (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n \t      (clobber (mem:BLK (scratch)))])])\n \n ;; Convert esp subtractions to push.\n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"(TARGET_SINGLE_PUSH || optimize_insn_for_size_p ())\n-   && INTVAL (operands[0]) == -GET_MODE_SIZE (Pmode)\"\n+   && INTVAL (operands[0]) == -GET_MODE_SIZE (word_mode)\"\n   [(clobber (match_dup 1))\n-   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))])\n+   (set (mem:W (pre_dec:P (reg:P SP_REG))) (match_dup 1))])\n \n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"(TARGET_DOUBLE_PUSH || optimize_insn_for_size_p ())\n-   && INTVAL (operands[0]) == -2*GET_MODE_SIZE (Pmode)\"\n+   && INTVAL (operands[0]) == -2*GET_MODE_SIZE (word_mode)\"\n   [(clobber (match_dup 1))\n-   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n-   (set (mem:P (pre_dec:P (reg:P SP_REG))) (match_dup 1))])\n+   (set (mem:W (pre_dec:P (reg:P SP_REG))) (match_dup 1))\n+   (set (mem:W (pre_dec:P (reg:P SP_REG))) (match_dup 1))])\n \n ;; Convert epilogue deallocator to pop.\n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"(TARGET_SINGLE_POP || optimize_insn_for_size_p ())\n-   && INTVAL (operands[0]) == GET_MODE_SIZE (Pmode)\"\n-  [(parallel [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n+   && INTVAL (operands[0]) == GET_MODE_SIZE (word_mode)\"\n+  [(parallel [(set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])])\n \n ;; Two pops case is tricky, since pop causes dependency\n ;; on destination register.  We use two registers if available.\n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n-   (match_scratch:P 2 \"r\")\n+  [(match_scratch:W 1 \"r\")\n+   (match_scratch:W 2 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"(TARGET_DOUBLE_POP || optimize_insn_for_size_p ())\n-   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n-  [(parallel [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n+   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (word_mode)\"\n+  [(parallel [(set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (set (match_dup 2) (mem:P (post_inc:P (reg:P SP_REG))))])\n+   (set (match_dup 2) (mem:W (post_inc:P (reg:P SP_REG))))])\n \n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))\n \t      (clobber (mem:BLK (scratch)))])]\n   \"optimize_insn_for_size_p ()\n-   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n-  [(parallel [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n+   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (word_mode)\"\n+  [(parallel [(set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))\n \t      (clobber (mem:BLK (scratch)))])\n-   (set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))])\n+   (set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))])\n \n ;; Convert esp additions to pop.\n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"INTVAL (operands[0]) == GET_MODE_SIZE (Pmode)\"\n-  [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))])\n+  \"INTVAL (operands[0]) == GET_MODE_SIZE (word_mode)\"\n+  [(set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))])\n \n ;; Two pops case is tricky, since pop causes dependency\n ;; on destination register.  We use two registers if available.\n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n-   (match_scratch:P 2 \"r\")\n+  [(match_scratch:W 1 \"r\")\n+   (match_scratch:W 2 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n-  [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n-   (set (match_dup 2) (mem:P (post_inc:P (reg:P SP_REG))))])\n+  \"INTVAL (operands[0]) == 2*GET_MODE_SIZE (word_mode)\"\n+  [(set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))\n+   (set (match_dup 2) (mem:W (post_inc:P (reg:P SP_REG))))])\n \n (define_peephole2\n-  [(match_scratch:P 1 \"r\")\n+  [(match_scratch:W 1 \"r\")\n    (parallel [(set (reg:P SP_REG)\n \t\t   (plus:P (reg:P SP_REG)\n \t\t\t   (match_operand:P 0 \"const_int_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"optimize_insn_for_size_p ()\n-   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (Pmode)\"\n-  [(set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))\n-   (set (match_dup 1) (mem:P (post_inc:P (reg:P SP_REG))))])\n+   && INTVAL (operands[0]) == 2*GET_MODE_SIZE (word_mode)\"\n+  [(set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))\n+   (set (match_dup 1) (mem:W (post_inc:P (reg:P SP_REG))))])\n \f\n ;; Convert compares with 1 to shorter inc/dec operations when CF is not\n ;; required and register dies.  Similarly for 128 to -128.\n@@ -17569,7 +17574,7 @@\n ;;  leal    (%edx,%eax,4), %eax\n \n (define_peephole2\n-  [(match_scratch:P 5 \"r\")\n+  [(match_scratch:W 5 \"r\")\n    (parallel [(set (match_operand 0 \"register_operand\" \"\")\n \t\t   (ashift (match_operand 1 \"register_operand\" \"\")\n \t\t\t   (match_operand 2 \"const_int_operand\" \"\")))\n@@ -17595,16 +17600,16 @@\n   enum machine_mode op1mode = GET_MODE (operands[1]);\n   enum machine_mode mode = op1mode == DImode ? DImode : SImode;\n   int scale = 1 << INTVAL (operands[2]);\n-  rtx index = gen_lowpart (Pmode, operands[1]);\n-  rtx base = gen_lowpart (Pmode, operands[5]);\n+  rtx index = gen_lowpart (word_mode, operands[1]);\n+  rtx base = gen_lowpart (word_mode, operands[5]);\n   rtx dest = gen_lowpart (mode, operands[3]);\n \n-  operands[1] = gen_rtx_PLUS (Pmode, base,\n-  \t\t\t      gen_rtx_MULT (Pmode, index, GEN_INT (scale)));\n+  operands[1] = gen_rtx_PLUS (word_mode, base,\n+\t\t\t      gen_rtx_MULT (word_mode, index, GEN_INT (scale)));\n   operands[5] = base;\n-  if (mode != Pmode)\n+  if (mode != word_mode)\n     operands[1] = gen_rtx_SUBREG (mode, operands[1], 0);\n-  if (op1mode != Pmode)\n+  if (op1mode != word_mode)\n     operands[5] = gen_rtx_SUBREG (op1mode, operands[5], 0);\n   operands[0] = dest;\n })"}]}