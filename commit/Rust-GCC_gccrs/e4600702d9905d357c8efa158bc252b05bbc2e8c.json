{"sha": "e4600702d9905d357c8efa158bc252b05bbc2e8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ2MDA3MDJkOTkwNWQzNTdjOGVmYTE1OGJjMjUyYjA1YmJjMmU4Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-27T17:49:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-27T17:49:28Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1313", "tree": {"sha": "47f30223d8f5aa9bad41515f2fbebb978d2bc5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f30223d8f5aa9bad41515f2fbebb978d2bc5da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4600702d9905d357c8efa158bc252b05bbc2e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4600702d9905d357c8efa158bc252b05bbc2e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4600702d9905d357c8efa158bc252b05bbc2e8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4600702d9905d357c8efa158bc252b05bbc2e8c/comments", "author": null, "committer": null, "parents": [{"sha": "b0dda4b14d7b40d00e1bada840d2bb48ab0d8fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0dda4b14d7b40d00e1bada840d2bb48ab0d8fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0dda4b14d7b40d00e1bada840d2bb48ab0d8fd9"}], "stats": {"total": 1305, "additions": 874, "deletions": 431}, "files": [{"sha": "8fe7ffc32d0421178290284d1339701584c96562", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -817,7 +817,7 @@ combine.o : combine.c $(CONFIG_H) $(RTL_H) gvarargs.h flags.h  \\\n    insn-config.h insn-flags.h insn-codes.h insn-attr.h regs.h expr.h \\\n    basic-block.h recog.h real.h\n regclass.o : regclass.c $(CONFIG_H) $(RTL_H) hard-reg-set.h flags.h \\\n-   basic-block.h regs.h insn-config.h recog.h \n+   basic-block.h regs.h insn-config.h recog.h reload.h real.h\n local-alloc.o : local-alloc.c $(CONFIG_H) $(RTL_H) flags.h basic-block.h \\\n    regs.h hard-reg-set.h insn-config.h recog.h output.h\n global-alloc.o : global-alloc.c $(CONFIG_H) $(RTL_H) flags.h  \\"}, {"sha": "6476549f1a6d4c04ad39fd572f507e8bb5b5f5ab", "filename": "gcc/cse.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -5836,6 +5836,37 @@ cse_insn (insn, in_libcall_block)\n \t    }\n         }\n \n+      /* See if we have a CONST_INT that is already in a register in a\n+\t wider mode.  */\n+\n+      if (src_const && src_related == 0 && GET_CODE (src_const) == CONST_INT\n+\t  && GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n+\t{\n+\t  enum machine_mode wider_mode;\n+\n+\t  for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t       GET_MODE_BITSIZE (wider_mode) <= BITS_PER_WORD\n+\t       && src_related == 0;\n+\t       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+\t    {\n+\t      struct table_elt *const_elt\n+\t\t= lookup (src_const, HASH (src_const, wider_mode), wider_mode);\n+\n+\t      if (const_elt == 0)\n+\t\tcontinue;\n+\n+\t      for (const_elt = const_elt->first_same_value;\n+\t\t   const_elt; const_elt = const_elt->next_same_value)\n+\t\tif (GET_CODE (const_elt->exp) == REG)\n+\t\t  {\n+\t\t    src_related = gen_lowpart_if_possible (mode,\n+\t\t\t\t\t\t\t   const_elt->exp);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n+\n       /* Another possibility is that we have an AND with a constant in\n \t a mode narrower than a word.  If so, it might have been generated\n \t as part of an \"if\" which would narrow the AND.  If we already"}, {"sha": "bc19c92dfe1ed4491f7d5d1cd423f70a8d2d4848", "filename": "gcc/flow.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -2554,7 +2554,7 @@ dump_flow_info (file)\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_n_refs[i])\n       {\n-\tenum reg_class class;\n+\tenum reg_class class, altclass;\n \tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n \t\t i, reg_n_refs[i], reg_live_length[i]);\n \tif (reg_basic_block[i] >= 0)\n@@ -2568,12 +2568,17 @@ dump_flow_info (file)\n \tif (PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n \t  fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n \tclass = reg_preferred_class (i);\n-\tif (class != GENERAL_REGS)\n+\taltclass = reg_alternate_class (i);\n+\tif (class != GENERAL_REGS || altclass != ALL_REGS)\n \t  {\n-\t    if (reg_preferred_or_nothing (i))\n+\t    if (altclass == ALL_REGS || class == ALL_REGS)\n+\t      fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t    else if (altclass == NO_REGS)\n \t      fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n \t    else\n-\t      fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t      fprintf (file, \"; pref %s, else %s\",\n+\t\t       reg_class_names[(int) class],\n+\t\t       reg_class_names[(int) altclass]);\n \t  }\n \tif (REGNO_POINTER_FLAG (i))\n \t  fprintf (file, \"; pointer\");"}, {"sha": "6a8ab038ea8e032fdf24ec55ff2458405b59c812", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -145,9 +145,10 @@ static enum machine_mode *qty_mode;\n \n static int *qty_n_calls_crossed;\n \n-/* Nonzero means don't allocate qty Q if we can't get its preferred class.  */\n+/* Register class within which we allocate qty Q if we can't get\n+   its preferred class.  */\n \n-static char *qty_preferred_or_nothing;\n+static enum reg_class *qty_alternate_class;\n \n /* Element Q is the SCRATCH expression for which this quantity is being\n    allocated or 0 if this quantity is allocating registers.  */\n@@ -258,7 +259,7 @@ alloc_qty (regno, mode, size, birth)\n   qty_birth[qty] = birth;\n   qty_n_calls_crossed[qty] = reg_n_calls_crossed[regno];\n   qty_min_class[qty] = reg_preferred_class (regno);\n-  qty_preferred_or_nothing[qty] = reg_preferred_or_nothing (regno);\n+  qty_alternate_class[qty] = reg_alternate_class (regno);\n   qty_n_refs[qty] = reg_n_refs[regno];\n }\n \f\n@@ -344,7 +345,7 @@ alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n   qty_death[qty] = 2 * insn_number + 1;\n   qty_n_calls_crossed[qty] = 0;\n   qty_min_class[qty] = class;\n-  qty_preferred_or_nothing[qty] = 1;\n+  qty_alternate_class[qty] = NO_REGS;\n   qty_n_refs[qty] = 1;\n }\n \f\n@@ -389,7 +390,7 @@ local_alloc ()\n   qty_mode = (enum machine_mode *) alloca (max_qty * sizeof (enum machine_mode));\n   qty_n_calls_crossed = (int *) alloca (max_qty * sizeof (int));\n   qty_min_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n-  qty_preferred_or_nothing = (char *) alloca (max_qty);\n+  qty_alternate_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n   qty_n_refs = (short *) alloca (max_qty * sizeof (short));\n \n   reg_qty = (int *) alloca (max_regno * sizeof (int));\n@@ -413,7 +414,7 @@ local_alloc ()\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n       if (reg_basic_block[i] >= 0 && reg_n_deaths[i] == 1\n-\t  && (reg_preferred_or_nothing (i)\n+\t  && (reg_alternate_class (i) == NO_REGS\n \t      || reg_class_size[(int) reg_preferred_class (i)] > 1))\n \treg_qty[i] = -2;\n       else\n@@ -1336,8 +1337,8 @@ block_alloc (b)\n \t\tcontinue;\n \t    }\n \n-\t  if (!qty_preferred_or_nothing[q])\n-\t    qty_phys_reg[q] = find_free_reg (ALL_REGS, \n+\t  if (qty_alternate_class[q] != NO_REGS)\n+\t    qty_phys_reg[q] = find_free_reg (qty_alternate_class[q],\n \t\t\t\t\t     qty_mode[q], q, 0, 0,\n \t\t\t\t\t     qty_birth[q], qty_death[q]);\n \t}\n@@ -1596,8 +1597,6 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       /* Update info about quantity SQTY.  */\n       qty_n_calls_crossed[sqty] += reg_n_calls_crossed[sreg];\n       qty_n_refs[sqty] += reg_n_refs[sreg];\n-      if (! reg_preferred_or_nothing (sreg))\n-\tqty_preferred_or_nothing[sqty] = 0;\n       if (usize < ssize)\n \t{\n \t  register int i;\n@@ -1662,6 +1661,10 @@ update_qty_class (qty, reg)\n   enum reg_class rclass = reg_preferred_class (reg);\n   if (reg_class_subset_p (rclass, qty_min_class[qty]))\n     qty_min_class[qty] = rclass;\n+\n+  rclass = reg_alternate_class (reg);\n+  if (reg_class_subset_p (rclass, qty_alternate_class[qty]))\n+    qty_alternate_class[qty] = rclass;\n }\n \f\n /* Handle something which alters the value of an rtx REG."}, {"sha": "1c573b5cb1df4e60d25eaa7f6cf53792471eb9ad", "filename": "gcc/regclass.c", "status": "modified", "additions": 817, "deletions": 414, "changes": 1231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -1,5 +1,5 @@\n /* Compute register class preferences for pseudo-registers.\n-   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -30,13 +30,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"regs.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"reload.h\"\n+#include \"real.h\"\n \n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n \n #ifndef MEMORY_MOVE_COST\n-#define MEMORY_MOVE_COST(x) 2\n+#define MEMORY_MOVE_COST(x) 4\n #endif\n \f\n /* Register tables used by many passes.  */\n@@ -129,7 +131,6 @@ enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n char *reg_names[] = REGISTER_NAMES;\n \n-\n /* Indexed by n, gives number of times (REG n) is set or clobbered.\n    This information remains valid for the rest of the compilation\n    of the current function; it is used to control register allocation.\n@@ -139,6 +140,16 @@ char *reg_names[] = REGISTER_NAMES;\n \n short *reg_n_sets;\n \n+/* Maximum cost of moving from a register in one class to a register in\n+   another class.  Based on REGISTER_MOVE_COST.  */\n+\n+static int move_cost[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* Similar, but here we don't have to move if the first index is a subset\n+   of the second so in that case the cost is zero.  */\n+\n+static int may_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n+\n /* Function called only once to initialize the above data on reg usage.\n    Once this is done, various switches may override.  */\n \n@@ -253,6 +264,38 @@ init_reg_sets ()\n \t  *p = (enum reg_class) i;\n \t}\n     }\n+\n+  /* Initialize the move cost table.  Find every subset of each class\n+     and take the maximum cost of moving any subset to any other.  */\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    for (j = 0; j < N_REG_CLASSES; j++)\n+      {\n+\tint cost = i == j ? 2 : REGISTER_MOVE_COST (i, j);\n+\tenum reg_class *p1, *p2;\n+\n+\tfor (p2 = &reg_class_subclasses[j][0]; *p2 != LIM_REG_CLASSES; p2++)\n+\t  if (*p2 != i)\n+\t    cost = MAX (cost, REGISTER_MOVE_COST (i, *p2));\n+\n+\tfor (p1 = &reg_class_subclasses[i][0]; *p1 != LIM_REG_CLASSES; p1++)\n+\t  {\n+\t    if (*p1 != j)\n+\t      cost = MAX (cost, REGISTER_MOVE_COST (*p1, j));\n+\n+\t    for (p2 = &reg_class_subclasses[j][0];\n+\t\t *p2 != LIM_REG_CLASSES; p2++)\n+\t      if (*p1 != *p2)\n+\t\tcost = MAX (cost, REGISTER_MOVE_COST (*p1, *p2));\n+\t  }\n+\n+\tmove_cost[i][j] = cost;\n+\n+\tif (reg_class_subset_p (i, j))\n+\t  cost = 0;\n+\n+\tmay_move_cost[i][j] = cost;\n+      }\n }\n \n /* After switches have been processed, which perhaps alter\n@@ -340,18 +383,25 @@ fix_register (name, fixed, call_used)\n /* Now the data and code for the `regclass' pass, which happens\n    just before local-alloc.  */\n \n-/* savings[R].savings[CL] is twice the amount saved by putting register R\n-   in class CL.  This data is used within `regclass' and freed\n-   when it is finished.  */\n+/* The `costs' struct records the cost of using a hard register of each class\n+   and of using memory for each pseudo.  We use this data to set up\n+   register class preferences.  */\n \n-struct savings\n+struct costs\n {\n-  short savings[N_REG_CLASSES];\n-  short memcost;\n-  short nrefs;\n+  int cost[N_REG_CLASSES];\n+  int mem_cost;\n };\n \n-static struct savings *savings;\n+/* Record the cost of each class for each pseudo.  */\n+\n+static struct costs *costs;\n+\n+/* Record the same data by operand number, accumulated for each alternative\n+   in an insn.  The contribution to a pseudo is that of the minimum-cost\n+   alternative.  */\n+\n+static struct costs op_costs[MAX_RECOG_OPERANDS];\n \n /* (enum reg_class) prefclass[R] is the preferred class for pseudo number R.\n    This is available after `regclass' is run.  */\n@@ -385,12 +435,13 @@ reg_preferred_class (regno)\n   return (enum reg_class) prefclass[regno];\n }\n \n-int\n-reg_preferred_or_nothing (regno)\n+enum reg_class\n+reg_alternate_class (regno)\n {\n   if (prefclass == 0)\n-    return 0;\n-  return preferred_or_nothing[regno];\n+    return ALL_REGS;\n+\n+  return (enum reg_class) altclass[regno];\n }\n \n /* This prevents dump_flow_info from losing if called\n@@ -414,394 +465,756 @@ regclass (f, nregs)\n {\n #ifdef REGISTER_CONSTRAINTS\n   register rtx insn;\n-  register int i;\n+  register int i, j;\n+  struct costs init_cost;\n+  rtx set;\n+  int pass;\n \n   init_recog ();\n \n-  /* Zero out our accumulation of the cost of each class for each reg.  */\n+  init_cost.mem_cost = 10000;\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    init_cost.cost[i] = 10000;\n \n-  savings = (struct savings *) alloca (nregs * sizeof (struct savings));\n-  bzero (savings, nregs * sizeof (struct savings));\n+  /* Normally we scan the insns once and determine the best class to use for\n+     each register.  However, if -fexpensive_optimizations are on, we do so\n+     twice, the second time using the tentative best classes to guide the\n+     selection.  */\n \n-  loop_depth = 1;\n+  for (pass = 0; pass <= flag_expensive_optimizations; pass++)\n+    {\n+      /* Zero out our accumulation of the cost of each class for each reg.  */\n \n-  /* Scan the instructions and record each time it would\n-     save code to put a certain register in a certain class.  */\n+      costs = (struct costs *) alloca (nregs * sizeof (struct costs));\n+      bzero (costs, nregs * sizeof (struct costs));\n \n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\tloop_depth++;\n-      else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\tloop_depth--;\n-      else if ((GET_CODE (insn) == INSN\n-\t\t&& GET_CODE (PATTERN (insn)) != USE\n-\t\t&& GET_CODE (PATTERN (insn)) != CLOBBER\n-\t\t&& GET_CODE (PATTERN (insn)) != ASM_INPUT)\n-\t       || (GET_CODE (insn) == JUMP_INSN\n-\t\t   && GET_CODE (PATTERN (insn)) != ADDR_VEC\n-\t\t   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n-\t       || GET_CODE (insn) == CALL_INSN)\n+      loop_depth = 0, loop_cost = 1;\n+\n+      /* Scan the instructions and record each time it would\n+\t save code to put a certain register in a certain class.  */\n+\n+      for (insn = f; insn; insn = NEXT_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == INSN && asm_noperands (PATTERN (insn)) >= 0)\n+\t  char *constraints[MAX_RECOG_OPERANDS];\n+\t  enum machine_mode modes[MAX_RECOG_OPERANDS];\n+\t  int nalternatives;\n+\t  int noperands;\n+\n+\t  /* Show that an insn inside a loop is likely to be executed three\n+\t     times more than insns outside a loop.  This is much more agressive\n+\t     than the assumptions made elsewhere and is being tried as an\n+\t     experiment.  */\n+\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t    loop_depth++, loop_cost = 1 << (2 * MIN (loop_depth, 5));\n+\t  else if (GET_CODE (insn) == NOTE\n+\t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t    loop_depth--, loop_cost = 1 << (2 * MIN (loop_depth, 5));\n+\n+\t  else if ((GET_CODE (insn) == INSN\n+\t\t    && GET_CODE (PATTERN (insn)) != USE\n+\t\t    && GET_CODE (PATTERN (insn)) != CLOBBER\n+\t\t    && GET_CODE (PATTERN (insn)) != ASM_INPUT)\n+\t\t   || (GET_CODE (insn) == JUMP_INSN\n+\t\t       && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t\t       && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n+\t\t   || GET_CODE (insn) == CALL_INSN)\n \t    {\n-\t      int noperands = asm_noperands (PATTERN (insn));\n-\t      /* We don't use alloca because alloca would not free\n-\t\t any of the space until this function returns.  */\n-\t      rtx *operands = (rtx *) oballoc (noperands * sizeof (rtx));\n-\t      char **constraints\n-\t\t= (char **) oballoc (noperands * sizeof (char *));\n+\t      if (GET_CODE (insn) == INSN\n+\t\t  && (noperands = asm_noperands (PATTERN (insn))) >= 0)\n+\t\t{\n+\t\t  decode_asm_operands (PATTERN (insn), recog_operand, 0,\n+\t\t\t\t       constraints, modes);\n+\t\t  nalternatives = n_occurrences (',', constraints[0]) + 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int insn_code_number = recog_memoized (insn);\n+\t\t  rtx note;\n \n-\t      decode_asm_operands (PATTERN (insn), operands, 0, constraints, 0);\n+\t\t  set = single_set (insn);\n+\t\t  insn_extract (insn);\n \n-\t      for (i = noperands - 1; i >= 0; i--)\n-\t\treg_class_record (operands[i], i, constraints);\n+\t\t  nalternatives = insn_n_alternatives[insn_code_number];\n+\t\t  noperands = insn_n_operands[insn_code_number];\n \n-\t      obfree (operands);\n-\t    }\n-\t  else\n-\t    {\n-\t      int insn_code_number = recog_memoized (insn);\n-\t      rtx set = single_set (insn);\n+\t\t  /* If this insn loads a parameter from its stack slot, then\n+\t\t     it represents a savings, rather than a cost, if the\n+\t\t     parameter is stored in memory.  Record this fact.  */\n \n-\t      insn_extract (insn);\n+\t\t  if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n+\t\t      && GET_CODE (SET_SRC (set)) == MEM\n+\t\t      && (note = find_reg_note (insn, REG_EQUIV, 0)) != 0\n+\t\t      && GET_CODE (XEXP (note, 0)) == MEM)\n+\t\t    {\n+\t\t      costs[REGNO (SET_DEST (set))].mem_cost\n+\t\t\t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)))\n+\t\t\t    * loop_cost);\n+\t\t      record_address_regs (XEXP (SET_SRC (set), 0),\n+\t\t\t\t\t   BASE_REG_CLASS, loop_cost * 2);\n+\t\t      continue;\n+\t\t    }\n+\t      \n+\t\t  /* Improve handling of two-address insns such as\n+\t\t     (set X (ashift CONST Y)) where CONST must be made to\n+\t\t     match X. Change it into two insns: (set X CONST)\n+\t\t     (set X (ashift X Y)).  If we left this for reloading, it\n+\t\t     would probably get three insns because X and Y might go\n+\t\t     in the same place. This prevents X and Y from receiving\n+\t\t     the same hard reg.\n+\n+\t\t     We can only do this if the modes of operands 0 and 1\n+\t\t     (which might not be the same) are tieable and we only need\n+\t\t     do this during our first pass.  */\n+\n+\t\t  if (pass == 0 && optimize\n+\t\t      && noperands >= 3\n+\t\t      && insn_operand_constraint[insn_code_number][1][0] == '0'\n+\t\t      && insn_operand_constraint[insn_code_number][1][1] == 0\n+\t\t      && CONSTANT_P (recog_operand[1])\n+\t\t      && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n+\t\t      && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n+\t\t      && GET_CODE (recog_operand[0]) == REG\n+\t\t      && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n+\t\t\t\t\t  insn_operand_mode[insn_code_number][1]))\n+\t\t    {\n+\t\t      rtx previnsn = prev_real_insn (insn);\n+\t\t      rtx dest\n+\t\t\t= gen_lowpart (insn_operand_mode[insn_code_number][1],\n+\t\t\t\t       recog_operand[0]);\n+\t\t      rtx newinsn\n+\t\t\t= emit_insn_before (gen_move_insn (dest,\n+\t\t\t\t\t\t\t   recog_operand[1]),\n+\t\t\t\t\t    insn);\n+\n+\t\t      /* If this insn was the start of a basic block,\n+\t\t\t include the new insn in that block.  */\n+\t\t      if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n+\t\t\t{\n+\t\t\t  int b;\n+\t\t\t  for (b = 0; b < n_basic_blocks; b++)\n+\t\t\t    if (insn == basic_block_head[b])\n+\t\t\t      basic_block_head[b] = newinsn;\n+\t\t\t}\n+\n+\t\t      /* This makes one more setting of new insns's dest. */\n+\t\t      reg_n_sets[REGNO (recog_operand[0])]++;\n+\n+\t\t      insn = PREV_INSN (newinsn);\n+\t\t      continue;\n+\t\t    }\n \n-\t      for (i = insn_n_operands[insn_code_number] - 1; i >= 0; i--)\n-\t\treg_class_record (recog_operand[i], i,\n-\t\t\t\t  insn_operand_constraint[insn_code_number]);\n+\t\t  /* If this is setting a pseudo from another pseudo or the\n+\t\t     sum of a pseudo and a constant integer and the other\n+\t\t     pseudo is known to be a pointer, set the destination to\n+\t\t     be a pointer as well.\n+\n+\t\t     Likewise if it is setting the destination from an address\n+\t\t     or from a value equivalent to an address or to the sum of\n+\t\t     an address and something else.\n+\t\t     \n+\t\t     But don't do any of this if the pseudo corresponds to\n+\t\t     a user variable since it should have already been set\n+\t\t     as a pointer based on the type.\n+\n+\t\t     There is no point in doing this during our second\n+\t\t     pass since not enough should have changed.  */\n+\n+\t\t  if (pass == 0 && set != 0 && GET_CODE (SET_DEST (set)) == REG\n+\t\t      && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t\t      && ! REG_USERVAR_P (SET_DEST (set))\n+\t\t      && ! REGNO_POINTER_FLAG (REGNO (SET_DEST (set)))\n+\t\t      && ((GET_CODE (SET_SRC (set)) == REG\n+\t\t\t   && REGNO_POINTER_FLAG (REGNO (SET_SRC (set))))\n+\t\t\t  || ((GET_CODE (SET_SRC (set)) == PLUS\n+\t\t\t       || GET_CODE (SET_SRC (set)) == LO_SUM)\n+\t\t\t      && (GET_CODE (XEXP (SET_SRC (set), 1))\n+\t\t\t\t  == CONST_INT)\n+\t\t\t      && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n+\t\t\t      && REGNO_POINTER_FLAG (REGNO (XEXP (SET_SRC (set), 0))))\n+\t\t\t  || GET_CODE (SET_SRC (set)) == CONST\n+\t\t\t  || GET_CODE (SET_SRC (set)) == SYMBOL_REF\n+\t\t\t  || GET_CODE (SET_SRC (set)) == LABEL_REF\n+\t\t\t  || (GET_CODE (SET_SRC (set)) == HIGH\n+\t\t\t      && (GET_CODE (XEXP (SET_SRC (set), 0)) == CONST\n+\t\t\t\t  || (GET_CODE (XEXP (SET_SRC (set), 0))\n+\t\t\t\t      == SYMBOL_REF)\n+\t\t\t\t  || (GET_CODE (XEXP (SET_SRC (set), 0))\n+\t\t\t\t      == LABEL_REF)))\n+\t\t\t  || ((GET_CODE (SET_SRC (set)) == PLUS\n+\t\t\t       || GET_CODE (SET_SRC (set)) == LO_SUM)\n+\t\t\t      && (GET_CODE (XEXP (SET_SRC (set), 1)) == CONST\n+\t\t\t\t  || (GET_CODE (XEXP (SET_SRC (set), 1))\n+\t\t\t\t      == SYMBOL_REF)\n+\t\t\t\t  || (GET_CODE (XEXP (SET_SRC (set), 1))\n+\t\t\t\t      == LABEL_REF)))\n+\t\t\t  || ((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n+\t\t\t      && (GET_CODE (XEXP (note, 0)) == CONST\n+\t\t\t\t  || GET_CODE (XEXP (note, 0)) == SYMBOL_REF\n+\t\t\t\t  || GET_CODE (XEXP (note, 0)) == LABEL_REF))))\n+\t\t    REGNO_POINTER_FLAG (REGNO (SET_DEST (set))) = 1;\n+\n+\t\t  for (i = 0; i < noperands; i++)\n+\t\t    {\n+\t\t      constraints[i]\n+\t\t\t= insn_operand_constraint[insn_code_number][i];\n+\t\t      modes[i] = insn_operand_mode[insn_code_number][i];\n+\t\t    }\n+\t\t}\n \n-\t      /* If this insn loads a parameter from its stack slot,\n-\t\t then it represents a savings, rather than a cost,\n-\t\t if the parameter is stored in memory.  Record this fact.  */\n-\t      if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n-\t\t  && GET_CODE (SET_SRC (set)) == MEM)\n+\t      /* If we get here, we are set up to record the costs of all the\n+\t\t operands for this insn.  Start by initializing the costs.\n+\t\t Then handle any address registers.  Finally record the desired\n+\t\t classes for any pseudos, doing it twice if some pair of\n+\t\t operands are commutative.  */\n+\t     \n+\t      for (i = 0; i < noperands; i++)\n \t\t{\n-\t\t  rtx note = find_reg_note (insn, REG_EQUIV, 0);\n-\t\t  if (note != 0 && GET_CODE (XEXP (note, 0)) == MEM)\n-\t\t    savings[REGNO (SET_DEST (set))].memcost\n-\t\t      -= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)))\n-\t\t\t  * loop_depth);\n+\t\t  op_costs[i] = init_cost;\n+\n+\t\t  if (GET_CODE (recog_operand[i]) == SUBREG)\n+\t\t    recog_operand[i] = SUBREG_REG (recog_operand[i]);\n+\n+\t\t  if (GET_CODE (recog_operand[i]) == MEM)\n+\t\t    record_address_regs (XEXP (recog_operand[i], 0),\n+\t\t\t\t\t BASE_REG_CLASS, loop_cost * 2);\n+\t\t  else if (constraints[i][0] == 'p')\n+\t\t    record_address_regs (recog_operand[i],\n+\t\t\t\t\t BASE_REG_CLASS, loop_cost * 2);\n \t\t}\n+\n+\t      /* Check for commutative in a separate loop so everything will\n+\t\t have been initialized.  Don't bother doing anything if the\n+\t\t second operand is a constant since that is the case\n+\t\t for which the constraints should have been written.  */\n \t      \n-\t      /* Improve handling of two-address insns such as\n-\t\t (set X (ashift CONST Y)) where CONST must be made to match X.\n-\t\t Change it into two insns: (set X CONST)  (set X (ashift X Y)).\n-\t\t If we left this for reloading, it would probably get three\n-\t\t insns because X and Y might go in the same place.\n-\t\t This prevents X and Y from receiving the same hard reg.\n-\n-\t\t We can only do this if the modes of operands 0 and 1 (which\n-\t\t might not be the same) are tieable.  */\n-\n-\t      if (optimize\n-\t\t  && insn_n_operands[insn_code_number] >= 3\n-\t\t  && insn_operand_constraint[insn_code_number][1][0] == '0'\n-\t\t  && insn_operand_constraint[insn_code_number][1][1] == 0\n-\t\t  && CONSTANT_P (recog_operand[1])\n-\t\t  && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n-\t\t  && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n-\t\t  && GET_CODE (recog_operand[0]) == REG\n-\t\t  && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n-\t\t\t\t      insn_operand_mode[insn_code_number][1]))\n-\t\t{\n-\t\t  rtx previnsn = prev_real_insn (insn);\n-\t\t  rtx dest\n-\t\t    = gen_lowpart (insn_operand_mode[insn_code_number][1],\n-\t\t\t\t   recog_operand[0]);\n-\t\t  rtx newinsn\n-\t\t    = emit_insn_before (gen_move_insn (dest, recog_operand[1]),\n+\t      for (i = 0; i < noperands; i++)\n+\t\tif (constraints[i][0] == '%'\n+\t\t    && ! CONSTANT_P (recog_operand[i+1]))\n+\t\t  {\n+\t\t    char *xconstraints[MAX_RECOG_OPERANDS];\n+\t\t    int j;\n+\n+\t\t    /* Handle commutative operands by swapping the constraints.\n+\t\t       We assume the modes are the same.  */\n+\n+\t\t    for (j = 0; j < noperands; j++)\n+\t\t      xconstraints[j] = constraints[j];\n+\n+\t\t    xconstraints[i] = constraints[i+1];\n+\t\t    xconstraints[i+1] = constraints[i];\n+\t\t    record_reg_classes (nalternatives, noperands,\n+\t\t\t\t\trecog_operand, modes, xconstraints,\n \t\t\t\t\tinsn);\n+\t\t  }\n \n-\t\t  /* If this insn was the start of a basic block,\n-\t\t     include the new insn in that block.  */\n-\t\t  if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n-\t\t    {\n-\t\t      int b;\n-\t\t      for (b = 0; b < n_basic_blocks; b++)\n-\t\t\tif (insn == basic_block_head[b])\n-\t\t\t  basic_block_head[b] = newinsn;\n-\t\t    }\n+\t      record_reg_classes (nalternatives, noperands, recog_operand,\n+\t\t\t\t  modes, constraints, insn);\n \n-\t\t  /* This makes one more setting of new insns's destination. */\n-\t\t  reg_n_sets[REGNO (recog_operand[0])]++;\n+\t      /* Now add the cost for each operand to the total costs for\n+\t\t its register.  */\n \n-\t\t  *recog_operand_loc[1] = recog_operand[0];\n-\t\t  for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n-\t\t    if (recog_dup_num[i] == 1)\n-\t\t      *recog_dup_loc[i] = recog_operand[0];\n-\t\t}\n+\t      for (i = 0; i < noperands; i++)\n+\t\tif (GET_CODE (recog_operand[i]) == REG\n+\t\t    && REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER)\n+\t\t  {\n+\t\t    int regno = REGNO (recog_operand[i]);\n+\t\t    struct costs *p = &costs[regno], *q = &op_costs[i];\n+\n+\t\t    p->mem_cost += q->mem_cost * loop_cost;\n+\t\t    for (j = 0; j < N_REG_CLASSES; j++)\n+\t\t      p->cost[j] += q->cost[j] * loop_cost;\n+\t\t  }\n \t    }\n \t}\n-    }\n \n-  /* Now for each register look at how desirable each class is\n-     and find which class is preferred.  Store that in `prefclass[REGNO]'.  */\n-    \n-  prefclass = (char *) oballoc (nregs);\n+      /* Now for each register look at how desirable each class is\n+\t and find which class is preferred.  Store that in\n+\t `prefclass[REGNO]'.  Record in `altclass[REGNO]' the largest register\n+\t class any of whose registers is better than memory.  */\n     \n-  preferred_or_nothing = (char *) oballoc (nregs);\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n-    {\n-      register int best_savings = 0;\n-      enum reg_class best = ALL_REGS;\n-\n-      /* This is an enum reg_class, but we call it an int\n-\t to save lots of casts.  */\n-      register int class;\n-      register struct savings *p = &savings[i];\n+      if (pass == 0)\n+\t{\n+\t  prefclass = (char *) oballoc (nregs);\n+\t  altclass = (char *) oballoc (nregs);\n+\t}\n \n-      for (class = (int) ALL_REGS - 1; class > 0; class--)\n+      for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n \t{\n-\t  if (p->savings[class] > best_savings)\n+\t  register int best_cost = (1 << (HOST_BITS_PER_INT - 1)) - 1;\n+\t  enum reg_class best = ALL_REGS, alt = NO_REGS;\n+\t  /* This is an enum reg_class, but we call it an int\n+\t     to save lots of casts.  */\n+\t  register int class;\n+\t  register struct costs *p = &costs[i];\n+\n+\t  for (class = (int) ALL_REGS - 1; class > 0; class--)\n \t    {\n-\t      best_savings = p->savings[class];\n-\t      best = (enum reg_class) class;\n-\t    }\n-\t  else if (p->savings[class] == best_savings)\n-\t    {\n-\t      best = reg_class_subunion[(int)best][class];\n+\t      /* Ignore classes that are too small for this operand.  */\n+\t      if (CLASS_MAX_NREGS (class, PSEUDO_REGNO_MODE (i))\n+\t\t  > reg_class_size[class])\n+\t\t;\n+\t      else if (p->cost[class] < best_cost)\n+\t\t{\n+\t\t  best_cost = p->cost[class];\n+\t\t  best = (enum reg_class) class;\n+\t\t}\n+\t      else if (p->cost[class] == best_cost)\n+\t\tbest = reg_class_subunion[(int)best][class];\n \t    }\n-\t}\n-\n-#if 0\n-      /* Note that best_savings is twice number of places something\n-\t is saved.  */\n-      if ((best_savings - p->savings[(int) GENERAL_REGS]) * 5 < reg_n_refs[i])\n-\tprefclass[i] = (int) GENERAL_REGS;\n-      else\n-\tprefclass[i] = (int) best;\n-#else\n-      /* We cast to (int) because (char) hits bugs in some compilers.  */\n-      prefclass[i] = (int) best;\n-#endif\n \n-      /* reg_n_refs + p->memcost measures the cost of putting in memory.\n-\t If a GENERAL_REG is no better, don't even try for one.\n-\t Since savings and memcost are 2 * number of refs,\n-\t this effectively counts each memory operand not needing reloading\n-\t as costing 1/2 of a reload insn.  */\n-      if (reg_n_refs != 0)\n-\tpreferred_or_nothing[i]\n-\t  = ((best_savings - p->savings[(int) GENERAL_REGS])\n-\t     >= p->nrefs + p->memcost);\n+\t  /* Record the alternate register class; i.e., a class for which\n+\t     every register in it is better than using memory.  If adding a\n+\t     class would make a smaller class (i.e., no union of just those\n+\t     classes exists), skip that class.  The major unions of classes\n+\t     should be provided as a register class.  Don't do this if we\n+\t     will be doing it again later.  */\n+\n+\t  if (pass == 1 || ! flag_expensive_optimizations)\n+\t    for (class = 0; class < N_REG_CLASSES; class++)\n+\t      if (p->cost[class] < p->mem_cost\n+\t\t  && (reg_class_size[reg_class_subunion[(int) alt][class]]\n+\t\t      > reg_class_size[(int) alt]))\n+\t\talt = reg_class_subunion[(int) alt][class];\n+\t  \n+\t  /* If we don't add any classes, nothing to try.  */\n+\t  if (alt == best)\n+\t    alt = (int) NO_REGS;\n+\n+\t  /* We cast to (int) because (char) hits bugs in some compilers.  */\n+\t  prefclass[i] = (int) best;\n+\t  altclass[i] = (int) alt;\n+\t}\n     }\n #endif /* REGISTER_CONSTRAINTS */\n }\n \f\n #ifdef REGISTER_CONSTRAINTS\n \n-/* Scan an operand OP for register class preferences.\n-   OPNO is the operand number, and CONSTRAINTS is the constraint\n-   vector for the insn.\n+/* Record the cost of using memory or registers of various classes for\n+   the operands in INSN.\n \n-   Record the preferred register classes from the constraint for OP\n-   if OP is a register.  If OP is a memory reference, record suitable\n-   preferences for registers used in the address.  */\n+   N_ALTS is the number of alternatives.\n \n-void\n-reg_class_record (op, opno, constraints)\n-     rtx op;\n-     int opno;\n+   N_OPS is the number of operands.\n+\n+   OPS is an array of the operands.\n+\n+   MODES are the modes of the operands, in case any are VOIDmode.\n+\n+   CONSTRAINTS are the constraints to use for the operands.  This array\n+   is modified by this procedure.\n+\n+   This procedure works alternative by alternative.  For each alternative\n+   we assume that we will be able to allocate all pseudos to their ideal\n+   register class and calculate the cost of using that alternative.  Then\n+   we compute for each operand that is a pseudo-register, the cost of \n+   having the pseudo allocated to each register class and using it in that\n+   alternative.  To this cost is added the cost of the alternative.\n+\n+   The cost of each class for this insn is its lowest cost among all the\n+   alternatives.  */\n+\n+static void\n+record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n+     int n_alts;\n+     int n_ops;\n+     rtx *ops;\n+     enum machine_mode *modes;\n      char **constraints;\n+     rtx insn;\n {\n-  char *constraint = constraints[opno];\n-  register char *p;\n-  register enum reg_class class = NO_REGS;\n-  char *next = 0;\n-  int memok = 0;\n-  int double_cost = 0;\n+  int alt;\n+  enum op_type {OP_READ, OP_WRITE, OP_READ_WRITE} op_types[MAX_RECOG_OPERANDS];\n+  int i, j;\n+\n+  /* By default, each operand is an input operand.  */\n \n-  if (op == 0)\n-    return;\n+  for (i = 0; i < n_ops; i++)\n+    op_types[i] = OP_READ;\n \n-  while (1)\n+  /* Process each alternative, each time minimizing an operand's cost with\n+     the cost for each operand in that alternative.  */\n+\n+  for (alt = 0; alt < n_alts; alt++)\n     {\n-      if (GET_CODE (op) == SUBREG)\n-\top = SUBREG_REG (op);\n-      else break;\n-    }\n+      struct costs this_op_costs[MAX_RECOG_OPERANDS];\n+      int alt_fail = 0;\n+      int alt_cost = 0;\n+      enum reg_class classes[MAX_RECOG_OPERANDS];\n+      int class;\n \n-  /* Memory reference: scan the address.  */\n+      for (i = 0; i < n_ops; i++)\n+\t{\n+\t  char *p = constraints[i];\n+\t  rtx op = ops[i];\n+\t  enum machine_mode mode = modes[i];\n+\t  int allows_mem = 0;\n+\t  int win = 0;\n+\t  char c;\n \n-  if (GET_CODE (op) == MEM)\n-    record_address_regs (XEXP (op, 0), 2, 0);\n+\t  /* If this operand has no constraints at all, we can conclude \n+\t     nothing about it since anything is valid.  */\n \n-  if (GET_CODE (op) != REG)\n-    {\n-      /* If the constraint says the operand is supposed to BE an address,\n-\t scan it as one.  */\n+\t  if (*p == 0)\n+\t    {\n+\t      if (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t\tbzero ((char *) &this_op_costs[i], sizeof this_op_costs[i]);\n \n-      if (constraint != 0 && constraint[0] == 'p')\n-\trecord_address_regs (op, 2, 0);\n-      return;\n-    }\n+\t      continue;\n+\t    }\n \n-  /* Operand is a register: examine the constraint for specified classes.  */\n+\t  /* If this alternative is only relevant when this operand\n+\t     matches a previous operand, we do different things depending\n+\t     on whether this operand is a pseudo-reg or not.  */\n \n-  for (p = constraint; *p || next; p++)\n-    {\n-      enum reg_class new_class = NO_REGS;\n+\t  if (p[0] >= '0' && p[0] <= '0' + i && (p[1] == ',' || p[1] == 0))\n+\t    {\n+\t      j = p[0] - '0';\n+\t      classes[i] = classes[j];\n+\n+\t      if (GET_CODE (op) != REG || REGNO (op) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  /* If this matches the other operand, we have no added\n+\t\t     cost.  */\n+\t\t  if (rtx_equal_p (ops[j], op))\n+\t\t    ;\n+\n+\t\t  /* If we can't put the other operand into a register, this\n+\t\t     alternative can't be used.  */\n+\n+\t\t  else if (classes[j] == NO_REGS)\n+\t\t    alt_fail = 1;\n+\n+\t\t  /* Otherwise, add to the cost of this alternative the cost\n+\t\t     to copy this operand to the register used for the other\n+\t\t     operand.  */\n+\n+\t\t  else\n+\t\t    alt_cost += copy_cost (op, mode, classes[j], 1);\n+\t\t}\n+\n+\t      else\n+\t\t{\n+\t\t  /* The costs of this operand are the same as that of the\n+\t\t     other operand.  However, if we cannot tie them, this\n+\t\t     alternative needs to do a copy, which is one\n+\t\t     instruction.  */\n+\n+\t\t  this_op_costs[i] = this_op_costs[j];\n+\t\t  if (! find_reg_note (insn, REG_DEAD, op))\n+\t\t    alt_cost += 2;\n+\t\t}\n+\n+\t      continue;\n+\t    }\n+\n+\t  /* Scan all the constraint letters.  See if the operand matches\n+\t     any of the constraints.  Collect the valid register classes\n+\t     and see if this operand accepts memory.  */\n+\n+\t  classes[i] = NO_REGS;\n+\t  while (*p && (c = *p++) != ',')\n+\t    switch (c)\n+\t      {\n+\t      case '=':\n+\t\top_types[i] = OP_WRITE;\n+\t\tbreak;\n+\n+\t      case '+':\n+\t\top_types[i] = OP_READ_WRITE;\n+\t\tbreak;\n+\n+\t      case '*':\n+\t\t/* Ignore the next letter for this pass.  */\n+\t\tp++;\n+\t\tbreak;\n+\n+\t      case '%':\n+\t      case '?':  case '!':  case '#':\n+\t      case '&':\n+\t      case '0':  case '1':  case '2':  case '3':  case '4':\n+\t      case 'p':\n+\t\tbreak;\n+\n+\t      case 'm':  case 'o':  case 'V':\n+\t\t/* It doesn't seem worth distingishing between offsettable\n+\t\t   and non-offsettable addresses here.  */\n+\t\tallows_mem = 1;\n+\t\tif (GET_CODE (op) == MEM)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case '<':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case '>':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'E':\n+\t\t/* Match any floating double constant, but only if\n+\t\t   we can examine the bits of it reliably.  */\n+\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t    && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n+\t\t  break;\n+\t\tif (GET_CODE (op) == CONST_DOUBLE)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'F':\n+\t\tif (GET_CODE (op) == CONST_DOUBLE)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'G':\n+\t      case 'H':\n+\t\tif (GET_CODE (op) == CONST_DOUBLE\n+\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (op, c))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 's':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\t  break;\n+\t      case 'i':\n+\t\tif (CONSTANT_P (op)\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t\t    && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+#endif\n+\t\t    )\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'n':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'I':\n+\t      case 'J':\n+\t      case 'K':\n+\t      case 'L':\n+\t      case 'M':\n+\t      case 'N':\n+\t      case 'O':\n+\t      case 'P':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (op), c))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'X':\n+\t\twin = 1;\n+\t\tbreak;\n \n-      if (*p == 0)\n-\t{\n-\t  p = next;\n-\t  next = 0;\n-\t}\n-      switch (*p)\n-\t{\n-\tcase '=':\n-\tcase '?':\n-\tcase '#':\n-\tcase '&':\n-\tcase '!':\n-\tcase '%':\n-\tcase 'E':\n-\tcase 'F':\n-\tcase 'G':\n-\tcase 'H':\n-\tcase 'i':\n-\tcase 'n':\n-\tcase 's':\n-\tcase 'p':\n-\tcase ',':\n-\tcase 'I':\n-\tcase 'J':\n-\tcase 'K':\n-\tcase 'L':\n-\tcase 'M':\n-\tcase 'N':\n-\tcase 'O':\n-\tcase 'P':\n #ifdef EXTRA_CONSTRAINT\n-\tcase 'Q':\n-\tcase 'R':\n-\tcase 'S':\n-\tcase 'T':\n-\tcase 'U':\n+              case 'Q':\n+              case 'R':\n+              case 'S':\n+              case 'T':\n+              case 'U':\n+\t\tif (EXTRA_CONSTRAINT (op, c))\n+\t\t  win = 1;\n+\t\tbreak;\n #endif\n-\tcase 'V':\n-\tcase 'X':\n-\t  break;\n-\n-\tcase '+':\n-\t  /* An input-output operand is twice as costly if it loses.  */\n-\t  double_cost = 1;\n-\t  break;\n-\n-\tcase 'm':\n-\tcase 'o':\n-\t  memok = 1;\n-\t  break;\n-\n-\t  /* * means ignore following letter\n-\t     when choosing register preferences.  */\n-\tcase '*':\n-\t  p++;\n-\t  break;\n-\n-\tcase 'g':\n-\tcase 'r':\n-\t  new_class = GENERAL_REGS;\n-\t  break;\n-\n-\tcase '0':\n-\tcase '1':\n-\tcase '2':\n-\tcase '3':\n-\tcase '4':\n-\t  /* If constraint says \"match another operand\",\n-\t     use that operand's constraint to choose preferences.  */\n-\t  if (*p - '0' < opno)\n+\n+\t      case 'g':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    || (CONSTANT_P (op)\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t\t\t&& (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n+#endif\n+\t\t\t))\n+\t\t  win = 1;\n+\t\tallows_mem = 1;\n+\t      case 'r':\n+\t\tclasses[i]\n+\t\t  = reg_class_subunion[(int) classes[i]][(int) GENERAL_REGS];\n+\t\tbreak;\n+\n+\t      default:\n+\t\tclasses[i]\n+\t\t  = reg_class_subunion[(int) classes[i]]\n+\t\t    [(int) REG_CLASS_FROM_LETTER (c)];\n+\t      }\n+\n+\t  constraints[i] = p;\n+\n+\t  /* How we account for this operand now depends on whether it is  a\n+\t     pseudo register or not.  If it is, we first check if any\n+\t     register classes are valid.  If not, we ignore this alternative,\n+\t     since we want to assume that all pseudos get allocated for\n+\t     register preferencing.  If some register class is valid, compute\n+\t     the costs of moving the pseudo into that class.  */\n+\n+\t  if (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      opno = *p - '0';\n-\t      next = constraints[opno];\n+\t      if (classes[i] == NO_REGS)\n+\t\talt_fail = 1;\n+\t      else\n+\t\t{\n+\t\t  struct costs *pp = &this_op_costs[i];\n+\n+\t\t  for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t    pp->cost[class] = may_move_cost[class][(int) classes[i]];\n+\n+\t\t  /* If the alternative actually allows memory, make things\n+\t\t     a bit cheaper since we won't need an extra insn to\n+\t\t     load it.  */\n+\n+\t\t  pp->mem_cost = MEMORY_MOVE_COST (mode) - allows_mem;\n+\n+\t\t  /* If we have assigned a class to this register in our\n+\t\t     first pass, add a cost to this alternative corresponding\n+\t\t     to what we would add if this register were not in the\n+\t\t     appropriate class.  */\n+\n+\t\t  if (prefclass)\n+\t\t    alt_cost\n+\t\t      += may_move_cost[prefclass[REGNO (op)]][(int) classes[i]];\n+\t\t}\n \t    }\n-\t  break;\n \n-\tdefault:\n-\t  new_class = REG_CLASS_FROM_LETTER (*p);\n-\t  break;\n-\t}\n+\t  /* Otherwise, if this alternative wins, either because we\n+\t     have already determined that or if we have a hard register of\n+\t     the proper class, there is no cost for this alternative.  */\n \n-      /* If this object can fit into the class requested, compute the subunion\n-\t of the requested class and classes found so far.  */\n-      if (CLASS_MAX_NREGS (new_class, GET_MODE (op))\n-\t  <= reg_class_size[(int) new_class])\n-\tclass = reg_class_subunion[(int) class][(int) new_class];\n-    }\n+\t  else if (win\n+\t\t   || (GET_CODE (op) == REG\n+\t\t       && reg_fits_class_p (op, classes[i], 0, mode)))\n+\t    ;\n \n-  {\n-    register int i;\n-    register struct savings *pp;\n-    register enum reg_class class1;\n-    int cost = 2 * (1 + double_cost) * loop_depth;\n-    pp = &savings[REGNO (op)];\n+\t  /* If registers are valid, the cost of this alternative includes\n+\t     copying the object to and/or from a register.  */\n \n-    /* Increment the savings for this reg\n-       for each class contained in the one the constraint asks for.  */\n+\t  else if (classes[i] != NO_REGS)\n+\t    {\n+\t      if (op_types[i] != OP_WRITE)\n+\t\talt_cost += copy_cost (op, mode, classes[i], 1);\n \n-    if (class != NO_REGS && class != ALL_REGS)\n-      {\n-\tint extracost;\n+\t      if (op_types[i] != OP_READ)\n+\t\talt_cost += copy_cost (op, mode, classes[i], 0);\n+\t    }\n \n-\tpp->savings[(int) class] += cost;\n-\tfor (i = 0; ; i++)\n-\t  {\n-\t    class1 = reg_class_subclasses[(int)class][i];\n-\t    if (class1 == LIM_REG_CLASSES)\n-\t      break;\n-\t    pp->savings[(int) class1] += cost;\n-\t  }\n-\t/* If it's slow to move data between this class and GENERAL_REGS,\n-\t   record that fact.  */\n-\textracost = (REGISTER_MOVE_COST (class, GENERAL_REGS) - 2) * loop_depth;\n-\tif (extracost > 0)\n+\t  /* The only other way this alternative can be used is if this is a\n+\t     constant that could be placed into memory.  */\n+\n+\t  else if (CONSTANT_P (op) && allows_mem)\n+\t    alt_cost += MEMORY_MOVE_COST (mode);\n+\t  else\n+\t    alt_fail = 1;\n+\t}\n+\n+      if (alt_fail)\n+\tcontinue;\n+\n+      /* Finally, update the costs with the information we've calculated\n+\t about this alternative.  */\n+\n+      for (i = 0; i < n_ops; i++)\n+\tif (GET_CODE (ops[i]) == REG\n+\t    && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n-\t    /* Check that this class and GENERAL_REGS don't overlap.\n-\t       REGISTER_MOVE_COST is meaningless if there is overlap.  */\n-\t    HARD_REG_SET temp;\n-\t    COMPL_HARD_REG_SET (temp, reg_class_contents[(int) class]);\n-\t    GO_IF_HARD_REG_SUBSET (reg_class_contents[(int) GENERAL_REGS],\n-\t\t\t\t   temp, label1);\n-\t    /* Overlap.  */\n-\t    goto label2;\n-\n-\t  label1: /* No overlap.  */\n-\t    /* Charge this extra cost to GENERAL_REGS\n-\t       and all its subclasses (none of which overlap this class).  */\n-\t    extracost = extracost * cost / (2 * loop_depth);\n-\t    pp->savings[(int) GENERAL_REGS] -= extracost;\n-\t    for (i = 0; ; i++)\n-\t      {\n-\t\tclass1 = reg_class_subclasses[(int)GENERAL_REGS][i];\n-\t\tif (class1 == LIM_REG_CLASSES)\n-\t\t  break;\n-\t\tpp->savings[(int) class1] -= extracost;\n-\t      }\n+\t    struct costs *pp = &op_costs[i], *qq = &this_op_costs[i];\n+\t    int scale = 1 + (op_types[i] == OP_READ_WRITE);\n \n-\t  label2: ;\n-\t  }\n-      }\n+\t    pp->mem_cost = MIN (pp->mem_cost,\n+\t\t\t\t(qq->mem_cost + alt_cost) * scale);\n \n-    if (! memok)\n-      pp->memcost += (MEMORY_MOVE_COST (GET_MODE (op)) * (1 + double_cost)\n-\t\t      - 1) * loop_depth;\n-    pp->nrefs += loop_depth;\n-  }\n+\t    for (class = 0; class < N_REG_CLASSES; class++)\n+\t      pp->cost[class] = MIN (pp->cost[class],\n+\t\t\t\t     (qq->cost[class] + alt_cost) * scale);\n+\t  }\n+    }\n }\n+\f\n+/* Compute the cost of loading X into (if TO_P is non-zero) or from (if\n+   TO_P is zero) a register of class CLASS in mode MODE.\n \n+   X must not be a pseudo.  */\n+\n+static int\n+copy_cost (x, mode, class, to_p)\n+     rtx x;\n+     enum machine_mode mode;\n+     enum reg_class class;\n+     int to_p;\n+{\n+  enum reg_class secondary_class = NO_REGS;\n+\n+  /* If X is a SCRATCH, there is actually nothing to move since we are\n+     assuming optimal allocation.  */\n+\n+  if (GET_CODE (x) == SCRATCH)\n+    return 0;\n+\n+  /* Get the class we will actually use for a reload.  */\n+  class = PREFERRED_RELOAD_CLASS (x, class);\n+\n+#ifdef HAVE_SECONDARY_RELOADS\n+  /* If we need a secondary reload (we assume here that we are using \n+     the secondary reload as an intermediate, not a scratch register), the\n+     cost is that to load the input into the intermediate register, then\n+     to copy them.  We use a special value of TO_P to avoid recursion.  */\n+\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+  if (to_p == 1)\n+    secondary_class = SECONDARY_INPUT_RELOAD_CLASS (class, mode, x);\n+#endif\n+\n+#ifdef SECONARY_OUTPUT_RELOAD_CLASS\n+  if (! to_p)\n+    secondary_class = SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, x);\n+#endif\n+\n+  if (secondary_class != NO_REGS)\n+    return (move_cost[(int) secondary_class][(int) class]\n+\t    + copy_cost (x, mode, secondary_class, 2));\n+#endif  /* HAVE_SECONARY_RELOADS */\n+\n+  /* For memory, use the memory move cost, for (hard) registers, use the\n+     cost to move between the register classes, and use 2 for everything\n+     else (constants).  */\n+\n+  if (GET_CODE (x) == MEM || class == NO_REGS)\n+    return MEMORY_MOVE_COST (mode);\n+\n+  else if (GET_CODE (x) == REG)\n+    return move_cost[(int) REGNO_REG_CLASS (REGNO (x))][(int) class];\n+\n+  else\n+    /* If this is a constant, we may eventually want to call rtx_cost here.  */\n+    return 2;\n+}\n+\f\n /* Record the pseudo registers we must reload into hard registers\n    in a subexpression of a memory address, X.\n-   BCOST is the cost if X is a register and it fails to be in BASE_REG_CLASS.\n-   ICOST is the cost if it fails to be in INDEX_REG_CLASS. */\n+\n+   CLASS is the class that the register needs to be in and is either\n+   BASE_REG_CLASS or INDEX_REG_CLASS.\n+\n+   SCALE is twice the amount to multiply the cost by (it is twice so we\n+   can represent half-cost adjustments).  */\n \n void\n-record_address_regs (x, bcost, icost)\n+record_address_regs (x, class, scale)\n      rtx x;\n-     int bcost, icost;\n+     enum reg_class class;\n+     int scale;\n {\n   register enum rtx_code code = GET_CODE (x);\n \n@@ -820,66 +1233,88 @@ record_address_regs (x, bcost, icost)\n \t we must determine whether registers are \"base\" or \"index\" regs.\n \t If there is a sum of two registers, we must choose one to be\n \t the \"base\".  Luckily, we can use the REGNO_POINTER_FLAG\n-\t to make a good choice most of the time.  */\n+\t to make a good choice most of the time.  We only need to do this\n+\t on machines that can have two registers in an address and where\n+\t the base and index register classes are different.\n+\n+\t ??? This code used to set REGNO_POINTER_FLAG in some cases, but\n+\t that seems bogus since it should only be set when we are sure\n+\t the register is being used as a pointer.  */\n+\n       {\n \trtx arg0 = XEXP (x, 0);\n \trtx arg1 = XEXP (x, 1);\n \tregister enum rtx_code code0 = GET_CODE (arg0);\n \tregister enum rtx_code code1 = GET_CODE (arg1);\n-\tint icost0 = 0;\n-\tint icost1 = 0;\n-\tint suppress1 = 0;\n-\tint suppress0 = 0;\n \n \t/* Look inside subregs.  */\n-\twhile (code0 == SUBREG)\n+\tif (code0 == SUBREG)\n \t  arg0 = SUBREG_REG (arg0), code0 = GET_CODE (arg0);\n-\twhile (code1 == SUBREG)\n+\tif (code1 == SUBREG)\n \t  arg1 = SUBREG_REG (arg1), code1 = GET_CODE (arg1);\n \n-\tif (code0 == MULT || code1 == MEM)\n-\t  icost0 = 2;\n-\telse if (code1 == MULT || code0 == MEM)\n-\t  icost1 = 2;\n-\telse if (code0 == CONST_INT)\n-\t  suppress0 = 1;\n-\telse if (code1 == CONST_INT)\n-\t  suppress1 = 1;\n-\telse if (code0 == REG && code1 == REG)\n+\t/* If this machine only allows one register per address, it must\n+\t   be in the first operand.  */\n+\n+\tif (MAX_REGS_PER_ADDRESS == 1)\n+\t  record_address_regs (arg0, class, scale);\n+\n+\t/* If index and base registers are the same on this machine, just\n+\t   record registers in any non-constant operands.  We assume here,\n+\t   as well as in the tests below, that all addresses are in \n+\t   canonical form.  */\n+\n+\telse if (INDEX_REG_CLASS == BASE_REG_CLASS)\n \t  {\n-\t    if (REGNO_POINTER_FLAG (REGNO (arg0)))\n-\t      icost1 = 2;\n-\t    else if (REGNO_POINTER_FLAG (REGNO (arg1)))\n-\t      icost0 = 2;\n-\t    else\n-\t      icost0 = icost1 = 1;\n+\t    record_address_regs (arg0, class, scale);\n+\t    if (! CONSTANT_P (arg1))\n+\t      record_address_regs (arg1, class, scale);\n \t  }\n-\telse if (code0 == REG)\n+\n+\t/* If the second operand is a constant integer, it doesn't change\n+\t   what class the first operand must be.  */\n+\n+\telse if (code1 == CONST_INT || code1 == CONST_DOUBLE)\n+\t  record_address_regs (arg0, class, scale);\n+\n+\t/* If the second operand is a symbolic constant, the first operand\n+\t   must be an index register.  */\n+\n+\telse if (code1 == SYMBOL_REF || code1 == CONST || code1 == LABEL_REF)\n+\t  record_address_regs (arg0, INDEX_REG_CLASS, scale);\n+\n+\t/* If this the sum of two registers where the first is known to be a \n+\t   pointer, it must be a base register with the second an index.  */\n+\n+\telse if (code0 == REG && code1 == REG\n+\t\t && REGNO_POINTER_FLAG (REGNO (arg0)))\n \t  {\n-\t    if (code1 == PLUS\n-\t\t&& ! REGNO_POINTER_FLAG (REGNO (arg0)))\n-\t      icost0 = 2;\n-\t    else\n-\t      REGNO_POINTER_FLAG (REGNO (arg0)) = 1;\n+\t    record_address_regs (arg0, BASE_REG_CLASS, scale);\n+\t    record_address_regs (arg1, INDEX_REG_CLASS, scale);\n \t  }\n-\telse if (code1 == REG)\n+\n+\t/* If this is the sum of two registers and neither is known to\n+\t   be a pointer, count equal chances that each might be a base\n+\t   or index register.  This case should be rare.  */\n+\n+\telse if (code0 == REG && code1 == REG\n+\t\t && ! REGNO_POINTER_FLAG (REGNO (arg0))\n+\t\t && ! REGNO_POINTER_FLAG (REGNO (arg1)))\n \t  {\n-\t    if (code0 == PLUS\n-\t\t&& ! REGNO_POINTER_FLAG (REGNO (arg1)))\n-\t      icost1 = 2;\n-\t    else\n-\t      REGNO_POINTER_FLAG (REGNO (arg1)) = 1;\n+\t    record_address_regs (arg0, BASE_REG_CLASS, scale / 2);\n+\t    record_address_regs (arg0, INDEX_REG_CLASS, scale / 2);\n+\t    record_address_regs (arg1, BASE_REG_CLASS, scale / 2);\n+\t    record_address_regs (arg1, INDEX_REG_CLASS, scale / 2);\n \t  }\n \n-\t/* ICOST0 determines whether we are treating operand 0\n-\t   as a base register or as an index register.\n-\t   SUPPRESS0 nonzero means it isn't a register at all.\n-\t   ICOST1 and SUPPRESS1 are likewise for operand 1.  */\n+\t/* In all other cases, the first operand is an index and the\n+\t   second is the base.  */\n \n-\tif (! suppress0)\n-\t  record_address_regs (arg0, 2 - icost0, icost0);\n-\tif (! suppress1)\n-\t  record_address_regs (arg1, 2 - icost1, icost1);\n+\telse\n+\t  {\n+\t    record_address_regs (arg0, INDEX_REG_CLASS, scale);\n+\t    record_address_regs (arg1, BASE_REG_CLASS, scale);\n+\t  }\n       }\n       break;\n \n@@ -890,51 +1325,19 @@ record_address_regs (x, bcost, icost)\n       /* Double the importance of a pseudo register that is incremented\n \t or decremented, since it would take two extra insns\n \t if it ends up in the wrong place.  */\n-      record_address_regs (XEXP (x, 0), 2 * bcost, 2 * icost);\n+\n+      record_address_regs (XEXP (x, 0), class, 2 * scale);\n       break;\n \n     case REG:\n       {\n-\tregister struct savings *pp;\n-\tregister enum reg_class class, class1;\n-\tpp = &savings[REGNO (x)];\n-\tpp->nrefs += loop_depth;\n-\n-\t/* We have an address (or part of one) that is just one register.  */\n-\n-\t/* Record BCOST worth of savings for classes contained\n-\t   in BASE_REG_CLASS.  */\n-\n-\tclass = BASE_REG_CLASS;\n-\tif (class != NO_REGS && class != ALL_REGS)\n-\t  {\n-\t    register int i;\n-\t    pp->savings[(int) class] += bcost * loop_depth;\n-\t    for (i = 0; ; i++)\n-\t      {\n-\t\tclass1 = reg_class_subclasses[(int)class][i];\n-\t\tif (class1 == LIM_REG_CLASSES)\n-\t\t  break;\n-\t\tpp->savings[(int) class1] += bcost * loop_depth;\n-\t      }\n-\t  }\n+\tregister struct costs *pp = &costs[REGNO (x)];\n+\tregister int i;\n \n-\t/* Record ICOST worth of savings for classes contained\n-\t   in INDEX_REG_CLASS.  */\n+\tpp->mem_cost += (MEMORY_MOVE_COST (Pmode) * scale) / 2;\n \n-\tclass = INDEX_REG_CLASS;\n-\tif (icost != 0 && class != NO_REGS && class != ALL_REGS)\n-\t  {\n-\t    register int i;\n-\t    pp->savings[(int) class] += icost * loop_depth;\n-\t    for (i = 0; ; i++)\n-\t      {\n-\t\tclass1 = reg_class_subclasses[(int)class][i];\n-\t\tif (class1 == LIM_REG_CLASSES)\n-\t\t  break;\n-\t\tpp->savings[(int) class1] += icost * loop_depth;\n-\t      }\n-\t  }\n+\tfor (i = 0; i < N_REG_CLASSES; i++)\n+\t  pp->cost[i] += (may_move_cost[i][(int) class] * scale) / 2;\n       }\n       break;\n \n@@ -944,7 +1347,7 @@ record_address_regs (x, bcost, icost)\n \tregister int i;\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  if (fmt[i] == 'e')\n-\t    record_address_regs (XEXP (x, i), bcost, icost);\n+\t    record_address_regs (XEXP (x, i), class, scale);\n       }\n     }\n }"}, {"sha": "db65eba0b67cdecb5bd71b61974b11c5b3f9bf7d", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -1502,7 +1502,7 @@ operands_match_p (x, y)\n \f\n /* Return the number of times character C occurs in string S.  */\n \n-static int\n+int\n n_occurrences (c, s)\n      char c;\n      char *s;\n@@ -2045,7 +2045,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   ? reg_preferred_class (REGNO (recog_operand[i])) : NO_REGS);\n       pref_or_nothing[i]\n \t= (code == REG && REGNO (recog_operand[i]) > FIRST_PSEUDO_REGISTER\n-\t   && reg_preferred_or_nothing (REGNO (recog_operand[i])));\n+\t   && reg_alternate_class (REGNO (recog_operand[i])) == NO_REGS);\n     }\n \n   /* If this is simply a copy from operand 1 to operand 0, merge the"}, {"sha": "a49029ed14a53cd57474adda0562a814bde2f3ad", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4600702d9905d357c8efa158bc252b05bbc2e8c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e4600702d9905d357c8efa158bc252b05bbc2e8c", "patch": "@@ -642,6 +642,7 @@ extern char *decode_asm_operands ();\n #ifdef BITS_PER_WORD\n /* Conditional is to detect when config.h has been included.  */\n extern enum reg_class reg_preferred_class ();\n+extern enum reg_class reg_alternate_class ();\n #endif\n \n extern rtx get_first_nonparm_insn ();"}]}