{"sha": "9c04723a04fc5bbedd779431fede2571561e276f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMwNDcyM2EwNGZjNWJiZWRkNzc5NDMxZmVkZTI1NzE1NjFlMjc2Zg==", "commit": {"author": {"name": "Dehao Chen", "email": "dehao@google.com", "date": "2012-05-08T10:01:44Z"}, "committer": {"name": "Dehao Chen", "email": "dehao@gcc.gnu.org", "date": "2012-05-08T10:01:44Z"}, "message": "predict.c (find_qualified_ssa_name): New\n\n2012-05-08  Dehao Chen  <dehao@google.com>\ngcc/\n\t* predict.c (find_qualified_ssa_name): New\n\t(find_ssa_name_in_expr): New\n\t(find_ssa_name_in_assign_stmt): New\n\t(is_comparison_with_loop_invariant_p): New\n\t(is_bound_expr_similar): New\n\t(predict_iv_comparison): New\n\t(predict_loops): Add heuristic for loop-nested branches that compare an\n\tinduction variable to a loop bound variable.\n\t* predict.def (PRED_LOOP_IV_COMPARE): New macro\ntestsuite/\n\t* gcc.dg/predict-1.c: Check if LOOP_IV_COMPARE static predict\n\theuristic is working properly.\n\t* gcc.dg/predict-2.c: Likewise.\n\t* gcc/dg/predict-3.c: Likewise.\n\t* gcc/dg/predict-4.c: Likewise.\n\t* gcc/dg/predict-5.c: Likewise.\n\t* gcc/dg/predict-6.c: Likewise.\n\nFrom-SVN: r187277", "tree": {"sha": "732faa7f65751352d1a617a0eb9ad11d9033c84f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/732faa7f65751352d1a617a0eb9ad11d9033c84f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c04723a04fc5bbedd779431fede2571561e276f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c04723a04fc5bbedd779431fede2571561e276f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c04723a04fc5bbedd779431fede2571561e276f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c04723a04fc5bbedd779431fede2571561e276f/comments", "author": {"login": "danielcdh", "id": 694263, "node_id": "MDQ6VXNlcjY5NDI2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/694263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielcdh", "html_url": "https://github.com/danielcdh", "followers_url": "https://api.github.com/users/danielcdh/followers", "following_url": "https://api.github.com/users/danielcdh/following{/other_user}", "gists_url": "https://api.github.com/users/danielcdh/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielcdh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielcdh/subscriptions", "organizations_url": "https://api.github.com/users/danielcdh/orgs", "repos_url": "https://api.github.com/users/danielcdh/repos", "events_url": "https://api.github.com/users/danielcdh/events{/privacy}", "received_events_url": "https://api.github.com/users/danielcdh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "536b0cb7af779dc7e417b2f91d9ca32382d3d203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/536b0cb7af779dc7e417b2f91d9ca32382d3d203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/536b0cb7af779dc7e417b2f91d9ca32382d3d203"}], "stats": {"total": 706, "additions": 706, "deletions": 0}, "files": [{"sha": "733e8548cecaa45c820d00b5451afe7cf35d8156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -1,3 +1,15 @@\n+2012-05-08  Dehao Chen  <dehao@google.com>\n+\n+\t* predict.c (find_qualified_ssa_name): New\n+\t(find_ssa_name_in_expr): New\n+\t(find_ssa_name_in_assign_stmt): New\n+\t(is_comparison_with_loop_invariant_p): New\n+\t(is_bound_expr_similar): New\n+\t(predict_iv_comparison): New\n+\t(predict_loops): Add heuristic for loop-nested branches that compare an\n+\tinduction variable to a loop bound variable.\n+\t* predict.def (PRED_LOOP_IV_COMPARE): New macro\n+\n 2012-05-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (has_dispatch): Use TARGET_BDVER1 and"}, {"sha": "c93586bd50272ec0d8a0efdaa451118dcb8259eb", "filename": "gcc/predict.c", "status": "modified", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -946,6 +946,355 @@ combine_predictions_for_bb (basic_block bb)\n     }\n }\n \n+/* Check if T1 and T2 satisfy the IV_COMPARE condition.\n+   Return the SSA_NAME if the condition satisfies, NULL otherwise.\n+\n+   T1 and T2 should be one of the following cases:\n+     1. T1 is SSA_NAME, T2 is NULL\n+     2. T1 is SSA_NAME, T2 is INTEGER_CST between [-4, 4]\n+     3. T2 is SSA_NAME, T1 is INTEGER_CST between [-4, 4]  */\n+\n+static tree\n+strips_small_constant (tree t1, tree t2)\n+{\n+  tree ret = NULL;\n+  int value = 0;\n+\n+  if (!t1)\n+    return NULL;\n+  else if (TREE_CODE (t1) == SSA_NAME)\n+    ret = t1;\n+  else if (host_integerp (t1, 0))\n+    value = tree_low_cst (t1, 0);\n+  else\n+    return NULL;\n+\n+  if (!t2)\n+    return ret;\n+  else if (host_integerp (t2, 0))\n+    value = tree_low_cst (t2, 0);\n+  else if (TREE_CODE (t2) == SSA_NAME)\n+    {\n+      if (ret)\n+        return NULL;\n+      else\n+        ret = t2;\n+    }\n+\n+  if (value <= 4 && value >= -4)\n+    return ret;\n+  else\n+    return NULL;\n+}\n+\n+/* Return the SSA_NAME in T or T's operands.\n+   Return NULL if SSA_NAME cannot be found.  */\n+\n+static tree\n+get_base_value (tree t)\n+{\n+  if (TREE_CODE (t) == SSA_NAME)\n+    return t;\n+\n+  if (!BINARY_CLASS_P (t))\n+    return NULL;\n+\n+  switch (TREE_OPERAND_LENGTH (t))\n+    {\n+    case 1:\n+      return strips_small_constant (TREE_OPERAND (t, 0), NULL);\n+    case 2:\n+      return strips_small_constant (TREE_OPERAND (t, 0),\n+\t\t\t\t    TREE_OPERAND (t, 1));\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+/* Check the compare STMT in LOOP. If it compares an induction\n+   variable to a loop invariant, return true, and save\n+   LOOP_INVARIANT, COMPARE_CODE and LOOP_STEP.\n+   Otherwise return false and set LOOP_INVAIANT to NULL.  */\n+\n+static bool\n+is_comparison_with_loop_invariant_p (gimple stmt, struct loop *loop,\n+\t\t\t\t     tree *loop_invariant,\n+\t\t\t\t     enum tree_code *compare_code,\n+\t\t\t\t     int *loop_step,\n+\t\t\t\t     tree *loop_iv_base)\n+{\n+  tree op0, op1, bound, base;\n+  affine_iv iv0, iv1;\n+  enum tree_code code;\n+  int step;\n+\n+  code = gimple_cond_code (stmt);\n+  *loop_invariant = NULL;\n+\n+  switch (code)\n+    {\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case NE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case EQ_EXPR:\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  op0 = gimple_cond_lhs (stmt);\n+  op1 = gimple_cond_rhs (stmt);\n+\n+  if ((TREE_CODE (op0) != SSA_NAME && TREE_CODE (op0) != INTEGER_CST) \n+       || (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op1) != INTEGER_CST))\n+    return false;\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), op0, &iv0, true))\n+    return false;\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), op1, &iv1, true))\n+    return false;\n+  if (TREE_CODE (iv0.step) != INTEGER_CST\n+      || TREE_CODE (iv1.step) != INTEGER_CST)\n+    return false;\n+  if ((integer_zerop (iv0.step) && integer_zerop (iv1.step))\n+      || (!integer_zerop (iv0.step) && !integer_zerop (iv1.step)))\n+    return false;\n+\n+  if (integer_zerop (iv0.step))\n+    {\n+      if (code != NE_EXPR && code != EQ_EXPR)\n+\tcode = invert_tree_comparison (code, false);\n+      bound = iv0.base;\n+      base = iv1.base;\n+      if (host_integerp (iv1.step, 0))\n+\tstep = tree_low_cst (iv1.step, 0);\n+      else\n+\treturn false;\n+    }\n+  else\n+    {\n+      bound = iv1.base;\n+      base = iv0.base;\n+      if (host_integerp (iv0.step, 0))\n+\tstep = tree_low_cst (iv0.step, 0);  \n+      else\n+\treturn false;\n+    }\n+\n+  if (TREE_CODE (bound) != INTEGER_CST)\n+    bound = get_base_value (bound);\n+  if (!bound)\n+    return false;\n+  if (TREE_CODE (base) != INTEGER_CST)\n+    base = get_base_value (base);\n+  if (!base)\n+    return false;\n+\n+  *loop_invariant = bound;\n+  *compare_code = code;\n+  *loop_step = step;\n+  *loop_iv_base = base;\n+  return true;\n+}\n+\n+/* Compare two SSA_NAMEs: returns TRUE if T1 and T2 are value coherent.  */\n+\n+static bool\n+expr_coherent_p (tree t1, tree t2)\n+{\n+  gimple stmt;\n+  tree ssa_name_1 = NULL;\n+  tree ssa_name_2 = NULL;\n+\n+  gcc_assert (TREE_CODE (t1) == SSA_NAME || TREE_CODE (t1) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (t2) == SSA_NAME || TREE_CODE (t2) == INTEGER_CST);\n+\n+  if (t1 == t2)\n+    return true;\n+\n+  if (TREE_CODE (t1) == INTEGER_CST && TREE_CODE (t2) == INTEGER_CST)\n+    return true;\n+  if (TREE_CODE (t1) == INTEGER_CST || TREE_CODE (t2) == INTEGER_CST)\n+    return false;\n+\n+  /* Check to see if t1 is expressed/defined with t2.  */\n+  stmt = SSA_NAME_DEF_STMT (t1);\n+  gcc_assert (stmt != NULL);\n+  if (is_gimple_assign (stmt))\n+    {\n+      ssa_name_1 = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_USE);\n+      if (ssa_name_1 && ssa_name_1 == t2)\n+\treturn true;\n+    }\n+\n+  /* Check to see if t2 is expressed/defined with t1.  */\n+  stmt = SSA_NAME_DEF_STMT (t2);\n+  gcc_assert (stmt != NULL);\n+  if (is_gimple_assign (stmt))\n+    {\n+      ssa_name_2 = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_USE);\n+      if (ssa_name_2 && ssa_name_2 == t1)\n+\treturn true;\n+    }\n+\n+  /* Compare if t1 and t2's def_stmts are identical.  */\n+  if (ssa_name_2 != NULL && ssa_name_1 == ssa_name_2)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Predict branch probability of BB when BB contains a branch that compares\n+   an induction variable in LOOP with LOOP_IV_BASE_VAR to LOOP_BOUND_VAR. The\n+   loop exit is compared using LOOP_BOUND_CODE, with step of LOOP_BOUND_STEP.\n+\n+   E.g.\n+     for (int i = 0; i < bound; i++) {\n+       if (i < bound - 2)\n+\t computation_1();\n+       else\n+\t computation_2();\n+     }\n+\n+  In this loop, we will predict the branch inside the loop to be taken.  */\n+\n+static void\n+predict_iv_comparison (struct loop *loop, basic_block bb,\n+\t\t       tree loop_bound_var,\n+\t\t       tree loop_iv_base_var,\n+\t\t       enum tree_code loop_bound_code,\n+\t\t       int loop_bound_step)\n+{\n+  gimple stmt;\n+  tree compare_var, compare_base;\n+  enum tree_code compare_code;\n+  int compare_step;\n+  edge then_edge;\n+  edge_iterator ei;\n+\n+  if (predicted_by_p (bb, PRED_LOOP_ITERATIONS_GUESSED)\n+      || predicted_by_p (bb, PRED_LOOP_ITERATIONS)\n+      || predicted_by_p (bb, PRED_LOOP_EXIT))\n+    return;\n+\n+  stmt = last_stmt (bb);\n+  if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n+    return;\n+  if (!is_comparison_with_loop_invariant_p (stmt, loop, &compare_var,\n+\t\t\t\t\t    &compare_code,\n+\t\t\t\t\t    &compare_step,\n+\t\t\t\t\t    &compare_base))\n+    return;\n+\n+  /* Find the taken edge.  */\n+  FOR_EACH_EDGE (then_edge, ei, bb->succs)\n+    if (then_edge->flags & EDGE_TRUE_VALUE)\n+      break;\n+\n+  /* When comparing an IV to a loop invariant, NE is more likely to be\n+     taken while EQ is more likely to be not-taken.  */\n+  if (compare_code == NE_EXPR)\n+    {\n+      predict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+      return;\n+    }\n+  else if (compare_code == EQ_EXPR)\n+    {\n+      predict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, NOT_TAKEN);\n+      return;\n+    }\n+\n+  if (!expr_coherent_p (loop_iv_base_var, compare_base))\n+    return;\n+\n+  /* If loop bound, base and compare bound are all constants, we can\n+     calculate the probability directly.  */\n+  if (host_integerp (loop_bound_var, 0)\n+      && host_integerp (compare_var, 0)\n+      && host_integerp (compare_base, 0))\n+    {\n+      int probability;\n+      HOST_WIDE_INT compare_count;\n+      HOST_WIDE_INT loop_bound = tree_low_cst (loop_bound_var, 0);\n+      HOST_WIDE_INT compare_bound = tree_low_cst (compare_var, 0);\n+      HOST_WIDE_INT base = tree_low_cst (compare_base, 0);\n+      HOST_WIDE_INT loop_count = (loop_bound - base) / compare_step;\n+\n+      if ((compare_step > 0)\n+          ^ (compare_code == LT_EXPR || compare_code == LE_EXPR))\n+\tcompare_count = (loop_bound - compare_bound) / compare_step;\n+      else\n+\tcompare_count = (compare_bound - base) / compare_step;\n+\n+      if (compare_code == LE_EXPR || compare_code == GE_EXPR)\n+\tcompare_count ++;\n+      if (loop_bound_code == LE_EXPR || loop_bound_code == GE_EXPR)\n+\tloop_count ++;\n+      if (compare_count < 0)\n+\tcompare_count = 0;\n+      if (loop_count < 0)\n+\tloop_count = 0;\n+\n+      if (loop_count == 0)\n+\tprobability = 0;\n+      else if (compare_count > loop_count)\n+\tprobability = REG_BR_PROB_BASE;\n+      else\n+\tprobability = (double) REG_BR_PROB_BASE * compare_count / loop_count;\n+      predict_edge (then_edge, PRED_LOOP_IV_COMPARE, probability);\n+      return;\n+    }\n+\n+  if (expr_coherent_p (loop_bound_var, compare_var))\n+    {\n+      if ((loop_bound_code == LT_EXPR || loop_bound_code == LE_EXPR)\n+\t  && (compare_code == LT_EXPR || compare_code == LE_EXPR))\n+\tpredict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+      else if ((loop_bound_code == GT_EXPR || loop_bound_code == GE_EXPR)\n+\t       && (compare_code == GT_EXPR || compare_code == GE_EXPR))\n+\tpredict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+      else if (loop_bound_code == NE_EXPR)\n+\t{\n+\t  /* If the loop backedge condition is \"(i != bound)\", we do\n+\t     the comparison based on the step of IV:\n+\t     * step < 0 : backedge condition is like (i > bound)\n+\t     * step > 0 : backedge condition is like (i < bound)  */\n+\t  gcc_assert (loop_bound_step != 0);\n+\t  if (loop_bound_step > 0\n+\t      && (compare_code == LT_EXPR\n+\t\t  || compare_code == LE_EXPR))\n+\t    predict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+\t  else if (loop_bound_step < 0\n+\t\t   && (compare_code == GT_EXPR\n+\t\t       || compare_code == GE_EXPR))\n+\t    predict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+\t  else\n+\t    predict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, NOT_TAKEN);\n+\t}\n+      else\n+\t/* The branch is predicted not-taken if loop_bound_code is\n+\t   opposite with compare_code.  */\n+\tpredict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, NOT_TAKEN);\n+    }\n+  else if (expr_coherent_p (loop_iv_base_var, compare_var))\n+    {\n+      /* For cases like:\n+\t   for (i = s; i < h; i++)\n+\t     if (i > s + 2) ....\n+\t The branch should be predicted taken.  */\n+      if (loop_bound_step > 0\n+\t  && (compare_code == GT_EXPR || compare_code == GE_EXPR))\n+\tpredict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+      else if (loop_bound_step < 0\n+\t       && (compare_code == LT_EXPR || compare_code == LE_EXPR))\n+\tpredict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, TAKEN);\n+      else\n+\tpredict_edge_def (then_edge, PRED_LOOP_IV_COMPARE_GUESS, NOT_TAKEN);\n+    }\n+}\n+ \n /* Predict edge probabilities by exploiting loop structure.  */\n \n static void\n@@ -963,6 +1312,12 @@ predict_loops (void)\n       VEC (edge, heap) *exits;\n       struct tree_niter_desc niter_desc;\n       edge ex;\n+      struct nb_iter_bound *nb_iter;\n+      enum tree_code loop_bound_code = ERROR_MARK;\n+      int loop_bound_step = 0;\n+      tree loop_bound_var = NULL;\n+      tree loop_iv_base = NULL;\n+      gimple stmt = NULL;\n \n       exits = get_loop_exit_edges (loop);\n       n_exits = VEC_length (edge, exits);\n@@ -1010,6 +1365,25 @@ predict_loops (void)\n \t}\n       VEC_free (edge, heap, exits);\n \n+      /* Find information about loop bound variables.  */\n+      for (nb_iter = loop->bounds; nb_iter;\n+\t   nb_iter = nb_iter->next)\n+\tif (nb_iter->stmt\n+\t    && gimple_code (nb_iter->stmt) == GIMPLE_COND)\n+\t  {\n+\t    stmt = nb_iter->stmt;\n+\t    break;\n+\t  }\n+      if (!stmt && last_stmt (loop->header)\n+\t  && gimple_code (last_stmt (loop->header)) == GIMPLE_COND)\n+\tstmt = last_stmt (loop->header);\n+      if (stmt)\n+\tis_comparison_with_loop_invariant_p (stmt, loop,\n+\t\t\t\t\t     &loop_bound_var,\n+\t\t\t\t\t     &loop_bound_code,\n+\t\t\t\t\t     &loop_bound_step,\n+\t\t\t\t\t     &loop_iv_base);\n+\n       bbs = get_loop_body (loop);\n \n       for (j = 0; j < loop->num_nodes; j++)\n@@ -1071,6 +1445,10 @@ predict_loops (void)\n \t\t    || !flow_bb_inside_loop_p (loop, e->dest))\n \t\t  predict_edge (e, PRED_LOOP_EXIT, probability);\n \t    }\n+\t  if (loop_bound_var)\n+\t    predict_iv_comparison (loop, bb, loop_bound_var, loop_iv_base,\n+\t\t\t\t   loop_bound_code,\n+\t\t\t\t   loop_bound_step);\n \t}\n \n       /* Free basic blocks from get_loop_body.  */"}, {"sha": "591bb1caf58f3c01421116c4322ebb90934e7d79", "filename": "gcc/predict.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -116,3 +116,13 @@ DEF_PREDICTOR (PRED_NULL_RETURN, \"null return\", HITRATE (90), 0)\n \n /* Branches to a mudflap bounds check are extremely unlikely.  */\n DEF_PREDICTOR (PRED_MUDFLAP, \"mudflap check\", PROB_VERY_LIKELY, 0)\n+\n+/* Branches to compare induction variable to a loop bound is\n+   extremely likely.  */\n+DEF_PREDICTOR (PRED_LOOP_IV_COMPARE_GUESS, \"guess loop iv compare\",\n+\t       PROB_VERY_LIKELY, 0)\n+\n+/* Use number of loop iterations determined by # of iterations analysis\n+   to set probability of branches that compares IV to loop bound variable.  */\n+DEF_PREDICTOR (PRED_LOOP_IV_COMPARE, \"loop iv compare\", PROB_VERY_LIKELY,\n+\t       PRED_FLAG_FIRST_MATCH)"}, {"sha": "f9ef02a8278f045bf013c40a12c7b7da00962078", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -1,3 +1,13 @@\n+2012-05-08  Dehao Chen  <dehao@google.com>\n+\n+\t* gcc.dg/predict-1.c: Check if LOOP_IV_COMPARE static predict\n+\theuristic is working properly.\n+\t* gcc.dg/predict-2.c: Likewise.\n+\t* gcc/dg/predict-3.c: Likewise.\n+\t* gcc/dg/predict-4.c: Likewise.\n+\t* gcc/dg/predict-5.c: Likewise.\n+\t* gcc/dg/predict-6.c: Likewise.\n+\n 2012-05-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/53239"}, {"sha": "e7f4618a0f7beb1213dcd0c779b47bd1caac2cd3", "filename": "gcc/testsuite/gcc.dg/predict-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-1.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int bound)\n+{\n+  int i, ret = 0;\n+  for (i = 0; i < bound; i++)\n+    {\n+      if (i > bound)\n+\tglobal += bar (i);\n+      if (i >= bound + 2)\n+\tglobal += bar (i);\n+      if (i > bound - 2)\n+\tglobal += bar (i);\n+      if (i + 2 > bound)\n+\tglobal += bar (i);\n+      if (i == 10)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 0.0%\" 5 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int bound)\n+{\n+  int i, ret = 0;\n+  for (i = 0; i < bound; i++)\n+    {\n+      if (i > bound)\n+\tglobal += bar (i);\n+      if (i >= bound + 2)\n+\tglobal += bar (i);\n+      if (i > bound - 2)\n+\tglobal += bar (i);\n+      if (i + 2 > bound)\n+\tglobal += bar (i);\n+      if (i == 10)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 0.0%\" 5 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */"}, {"sha": "44895b7cf642969c51a104e1228629001e8a4b78", "filename": "gcc/testsuite/gcc.dg/predict-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-2.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int base, int bound)\n+{\n+  int i, ret = 0;\n+  for (i = base; i < bound; i++)\n+    {\n+      if (i > bound * bound)\n+\tglobal += bar (i);\n+      if (i > bound + 10)\n+\tglobal += bar (i);\n+      if (i <= bound + 10)\n+\tglobal += bar (i);\n+      if (i > base + 10)\n+\tglobal += bar (i);\n+      if (i < base - 10)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"loop iv compare heuristics\" \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int base, int bound)\n+{\n+  int i, ret = 0;\n+  for (i = base; i < bound; i++)\n+    {\n+      if (i > bound * bound)\n+\tglobal += bar (i);\n+      if (i > bound + 10)\n+\tglobal += bar (i);\n+      if (i <= bound + 10)\n+\tglobal += bar (i);\n+      if (i > base + 10)\n+\tglobal += bar (i);\n+      if (i < base - 10)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"loop iv compare heuristics\" \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */"}, {"sha": "afaf5400ffe53f66d2b569a4825a62ecee7718fc", "filename": "gcc/testsuite/gcc.dg/predict-3.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-3.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int bound)\n+{\n+  int i, ret = 0;\n+  for (i = 0; i <= bound; i++)\n+    {\n+      if (i < bound - 2)\n+\tglobal += bar (i);\n+      if (i <= bound)\n+\tglobal += bar (i);\n+      if (i + 1 < bound)\n+\tglobal += bar (i);\n+      if (i != bound)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 100.0%\" 4 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int bound)\n+{\n+  int i, ret = 0;\n+  for (i = 0; i <= bound; i++)\n+    {\n+      if (i < bound - 2)\n+\tglobal += bar (i);\n+      if (i <= bound)\n+\tglobal += bar (i);\n+      if (i + 1 < bound)\n+\tglobal += bar (i);\n+      if (i != bound)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 100.0%\" 4 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */"}, {"sha": "f575b98de5f9952486f86ae0e0d332591b517098", "filename": "gcc/testsuite/gcc.dg/predict-4.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-4.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int bound)\n+{\n+  int i, ret = 0;\n+  for (i = 0; i < 10; i++)\n+    {\n+      if (i < 5)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"loop iv compare heuristics: 50.0%\" \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar(int);\n+\n+void foo (int bound)\n+{\n+  int i, ret = 0;\n+  for (i = 0; i < 10; i++)\n+    {\n+      if (i < 5)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"loop iv compare heuristics: 50.0%\" \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */"}, {"sha": "f6e70d3254008814832fa8f15619458830e9aced", "filename": "gcc/testsuite/gcc.dg/predict-5.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-5.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar (int);\n+\n+void foo (int base, int bound)\n+{\n+  int i, ret = 0;\n+  for (i = base; i <= bound; i++)\n+    {\n+      if (i > base)\n+\tglobal += bar (i);\n+      if (i > base + 1)\n+\tglobal += bar (i);\n+      if (i >= base + 3)\n+\tglobal += bar (i);\n+      if (i - 2 >= base)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 100.0%\" 4 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar (int);\n+\n+void foo (int base, int bound)\n+{\n+  int i, ret = 0;\n+  for (i = base; i <= bound; i++)\n+    {\n+      if (i > base)\n+\tglobal += bar (i);\n+      if (i > base + 1)\n+\tglobal += bar (i);\n+      if (i >= base + 3)\n+\tglobal += bar (i);\n+      if (i - 2 >= base)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 100.0%\" 4 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */"}, {"sha": "552fd0743f3b0c1a7846063f40328261faf74982", "filename": "gcc/testsuite/gcc.dg/predict-6.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c04723a04fc5bbedd779431fede2571561e276f/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-6.c?ref=9c04723a04fc5bbedd779431fede2571561e276f", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar (int);\n+\n+void foo (int base, int bound)\n+{\n+  int i, ret = 0;\n+  for (i = base; i <= bound; i++)\n+    {\n+      if (i < base)\n+\tglobal += bar (i);\n+      if (i < base + 1)\n+\tglobal += bar (i);\n+      if (i <= base + 3)\n+\tglobal += bar (i);\n+      if (i - 1 < base)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 0.0%\" 4 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+\n+extern int global;\n+\n+int bar (int);\n+\n+void foo (int base, int bound)\n+{\n+  int i, ret = 0;\n+  for (i = base; i <= bound; i++)\n+    {\n+      if (i < base)\n+\tglobal += bar (i);\n+      if (i < base + 1)\n+\tglobal += bar (i);\n+      if (i <= base + 3)\n+\tglobal += bar (i);\n+      if (i - 1 < base)\n+\tglobal += bar (i);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop iv compare heuristics: 0.0%\" 4 \"profile_estimate\"} } */\n+/* { dg-final { cleanup-tree-dump \"profile_estimate\" } } */"}]}