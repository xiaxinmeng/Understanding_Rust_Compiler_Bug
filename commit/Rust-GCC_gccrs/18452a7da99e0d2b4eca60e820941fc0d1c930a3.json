{"sha": "18452a7da99e0d2b4eca60e820941fc0d1c930a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg0NTJhN2RhOTllMGQyYjRlY2E2MGU4MjA5NDFmYzBkMWM5MzBhMw==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2007-04-30T19:17:59Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-04-30T19:17:59Z"}, "message": "trans-const.c (gfc_conv_mpz_to_tree): Use mpz_get_double_int.\n\n* trans-const.c (gfc_conv_mpz_to_tree): Use mpz_get_double_int.\n(gfc_conv_tree_to_mpz): New function.\n(gfc_conv_mpfr_to_tree): Use real_from_mpfr.\n(gfc_conv_tree_to_mpfr): New function.\n* trans-const.h: (gfc_conv_tree_to_mpz): New prototype.\n(gfc_conv_tree_to_mpfr): New prototype.\n\nFrom-SVN: r124305", "tree": {"sha": "e3bf3bf016695d90ad6f4c85478f7148d7488dbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3bf3bf016695d90ad6f4c85478f7148d7488dbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18452a7da99e0d2b4eca60e820941fc0d1c930a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18452a7da99e0d2b4eca60e820941fc0d1c930a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18452a7da99e0d2b4eca60e820941fc0d1c930a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18452a7da99e0d2b4eca60e820941fc0d1c930a3/comments", "author": null, "committer": null, "parents": [{"sha": "e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4fd22c6d5a014ae055d1ed7499c87f9dbb9a3cd"}], "stats": {"total": 134, "additions": 33, "deletions": 101}, "files": [{"sha": "e0f8ca3afb6566361418d69cf9300e7ffefe16b6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18452a7da99e0d2b4eca60e820941fc0d1c930a3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18452a7da99e0d2b4eca60e820941fc0d1c930a3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=18452a7da99e0d2b4eca60e820941fc0d1c930a3", "patch": "@@ -1,3 +1,12 @@\n+2007-04-30  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\t* trans-const.c (gfc_conv_mpz_to_tree): Use mpz_get_double_int.\n+\t(gfc_conv_tree_to_mpz): New function.\n+\t(gfc_conv_mpfr_to_tree): Use real_from_mpfr.\n+\t(gfc_conv_tree_to_mpfr): New function.\n+\t* trans-const.h: (gfc_conv_tree_to_mpz): New prototype.\n+\t(gfc_conv_tree_to_mpfr): New prototype.\n+\n 2007-04-30  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* intrinsic.texi (IERRNO): Changed class to non-elemental function."}, {"sha": "435d5ec9092722dabdc88097aca121be8f2634d2", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 20, "deletions": 99, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18452a7da99e0d2b4eca60e820941fc0d1c930a3/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18452a7da99e0d2b4eca60e820941fc0d1c930a3/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=18452a7da99e0d2b4eca60e820941fc0d1c930a3", "patch": "@@ -29,6 +29,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"real.h\"\n+#include \"double-int.h\"\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-const.h\"\n@@ -152,128 +153,48 @@ gfc_init_constants (void)\n }\n \n /* Converts a GMP integer into a backend tree node.  */\n+\n tree\n gfc_conv_mpz_to_tree (mpz_t i, int kind)\n {\n-  HOST_WIDE_INT high;\n-  unsigned HOST_WIDE_INT low;\n+  double_int val = mpz_get_double_int (gfc_get_int_type (kind), i, true);\n+  return double_int_to_tree (gfc_get_int_type (kind), val);\n+}\n \n-  if (mpz_fits_slong_p (i))\n-    {\n-      /* Note that HOST_WIDE_INT is never smaller than long.  */\n-      low = mpz_get_si (i);\n-      high = mpz_sgn (i) < 0 ? -1 : 0;\n-    }\n-  else\n-    {\n-      unsigned HOST_WIDE_INT *words;\n-      size_t count, numb;\n-\n-      /* Determine the number of unsigned HOST_WIDE_INT that are required\n-         for represent the value.  The code to calculate count is\n-\t extracted from the GMP manual, section \"Integer Import and Export\":\n-         http://gmplib.org/manual/Integer-Import-and-Export.html  */\n-      numb = 8*sizeof(HOST_WIDE_INT);\n-      count = (mpz_sizeinbase (i, 2) + numb-1) / numb;\n-      if (count < 2)\n-\tcount = 2;\n-      words = (unsigned HOST_WIDE_INT *) alloca (count * sizeof(HOST_WIDE_INT));\n-\n-      /* Since we know that the value is not zero (mpz_fits_slong_p),\n-\t we know that at least one word will be written, but we don't know\n-\t about the second.  It's quicker to zero the second word before\n-\t than conditionally clear it later.  */\n-      words[1] = 0;\n-      \n-      /* Extract the absolute value into words.  */\n-      mpz_export (words, &count, -1, sizeof(HOST_WIDE_INT), 0, 0, i);\n-\n-      /* We don't assume that all numbers are in range for its type.\n-         However, we never create a type larger than 2*HWI, which is the\n-\t largest that the middle-end can handle. So, we only take the\n-\t first two elements of words, which is equivalent to wrapping the\n-\t value if it's larger than the type range.  */\n-      low = words[0];\n-      high = words[1];\n-\n-      /* Negate if necessary.  */\n-      if (mpz_sgn (i) < 0)\n-\t{\n-\t  if (low == 0)\n-\t    high = -high;\n-\t  else\n-\t    low = -low, high = ~high;\n-\t}\n-    }\n+/* Converts a backend tree into a GMP integer.  */\n \n-  return build_int_cst_wide (gfc_get_int_type (kind), low, high);\n+void\n+gfc_conv_tree_to_mpz (mpz_t i, tree source)\n+{\n+  double_int val = tree_to_double_int (source);\n+  mpz_set_double_int (i, val, TYPE_UNSIGNED (TREE_TYPE (source)));\n }\n \n-/* Converts a real constant into backend form.  Uses an intermediate string\n-   representation.  */\n+/* Converts a real constant into backend form.  */\n \n tree\n gfc_conv_mpfr_to_tree (mpfr_t f, int kind)\n {\n-  tree res;\n   tree type;\n-  mp_exp_t exp;\n-  char *p, *q;\n   int n;\n   REAL_VALUE_TYPE real;\n \n   n = gfc_validate_kind (BT_REAL, kind, false);\n-\n   gcc_assert (gfc_real_kinds[n].radix == 2);\n \n   type = gfc_get_real_type (kind);\n+  real_from_mpfr (&real, f, type, GFC_RND_MODE);\n+  return build_real (type, real);\n+}\n \n-  /* Take care of Infinity and NaN.  */\n-  if (mpfr_inf_p (f))\n-    {\n-      real_inf (&real);\n-      if (mpfr_sgn (f) < 0)\n-\treal = REAL_VALUE_NEGATE(real);\n-      res = build_real (type , real);\n-      return res;\n-    }\n-\n-  if (mpfr_nan_p (f))\n-    {\n-      real_nan (&real, \"\", 0, TYPE_MODE (type));\n-      res = build_real (type , real);\n-      return res;\n-    }\n-\n-  /* mpfr chooses too small a number of hexadecimal digits if the\n-     number of binary digits is not divisible by four, therefore we\n-     have to explicitly request a sufficient number of digits here.  */\n-  p = mpfr_get_str (NULL, &exp, 16, gfc_real_kinds[n].digits / 4 + 1,\n-\t\t    f, GFC_RND_MODE);\n-\n-  /* REAL_VALUE_ATOF expects the exponent for mantissa * 2**exp,\n-     mpfr_get_str returns the exponent for mantissa * 16**exp, adjust\n-     for that.  */\n-  exp *= 4;\n-\n-  /* The additional 12 characters add space for the sprintf below.\n-     This leaves 6 digits for the exponent which is certainly enough.  */\n-  q = (char *) gfc_getmem (strlen (p) + 12);\n-\n-  if (p[0] == '-')\n-    sprintf (q, \"-0x.%sp%d\", &p[1], (int) exp);\n-  else\n-    sprintf (q, \"0x.%sp%d\", p, (int) exp);\n-\n-  res = build_real (type, REAL_VALUE_ATOF (q, TYPE_MODE (type)));\n-\n-  gfc_free (q);\n-  gfc_free (p);\n+/* Converts a backend tree into a real constant.  */\n \n-  return res;\n+void\n+gfc_conv_tree_to_mpfr (mpfr_ptr f, tree source)\n+{\n+  mpfr_from_real (f, TREE_REAL_CST_PTR (source), GFC_RND_MODE);\n }\n \n-\n /* Translate any literal constant to a tree.  Constants never have\n    pre or post chains.  Character literal constants are special\n    special because they have a value and a length, so they cannot be"}, {"sha": "1f4157ee46e885ca9ef6579119f486124cc77d35", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18452a7da99e0d2b4eca60e820941fc0d1c930a3/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18452a7da99e0d2b4eca60e820941fc0d1c930a3/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=18452a7da99e0d2b4eca60e820941fc0d1c930a3", "patch": "@@ -20,11 +20,13 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-/* Returns an INT_CST.  */\n+/* Converts between INT_CST and GMP integer representations.  */\n tree gfc_conv_mpz_to_tree (mpz_t, int);\n+void gfc_conv_tree_to_mpz (mpz_t, tree);\n \n-/* Returns a REAL_CST.  */\n+/* Converts between REAL_CST and MPFR floating-point representations.  */\n tree gfc_conv_mpfr_to_tree (mpfr_t, int);\n+void gfc_conv_tree_to_mpfr (mpfr_ptr, tree);\n \n /* Build a tree for a constant.  Must be an EXPR_CONSTANT gfc_expr.\n    For CHARACTER literal constants, the caller still has to set the"}]}