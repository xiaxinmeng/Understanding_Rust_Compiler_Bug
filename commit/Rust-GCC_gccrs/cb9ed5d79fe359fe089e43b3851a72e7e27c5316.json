{"sha": "cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I5ZWQ1ZDc5ZmUzNTlmZTA4OWU0M2IzODUxYTcyZTdlMjdjNTMxNg==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-05-03T12:54:45Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-05-03T12:54:45Z"}, "message": "re PR middle-end/31699 (-march=opteron -ftree-vectorize generates wrong code)\n\n        PR tree-optimization/31699\n        * tree-vect-analyze.c (vect_update_misalignment_for_peel): Remove wrong\n        code.\n        (vect_enhance_data_refs_alignment): Compute peel amount using\n        TYPE_VECTOR_SUBPARTS instead of vf.\n        * tree-vect-transform.c (vect_gen_niters_for_prolog_loop): Likewise.\n\nFrom-SVN: r124375", "tree": {"sha": "c155e715aab82e74ee4d9c068a74667321236329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c155e715aab82e74ee4d9c068a74667321236329"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/comments", "author": null, "committer": null, "parents": [{"sha": "7b50cdeffbd3fcb4029eee0c0d85f4ea19fcc47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b50cdeffbd3fcb4029eee0c0d85f4ea19fcc47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b50cdeffbd3fcb4029eee0c0d85f4ea19fcc47f"}], "stats": {"total": 241, "additions": 196, "deletions": 45}, "files": [{"sha": "e39d94e7423933e30b85e8121277c887065e7320", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -1,3 +1,12 @@\n+2007-05-03  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\tPR tree-optimization/31699\n+\t* tree-vect-analyze.c (vect_update_misalignment_for_peel): Remove wrong\n+\tcode.\n+\t(vect_enhance_data_refs_alignment): Compute peel amount using \n+\tTYPE_VECTOR_SUBPARTS instead of vf.\t\n+\t* tree-vect-transform.c (vect_gen_niters_for_prolog_loop): Likewise.\n+\n 2007-05-02  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \tPR bootstrap/31776"}, {"sha": "0d00f9ba7d556787920086ff9fa2c4fc279e5ed7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -1,3 +1,18 @@\n+2007-05-03  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\tPR tree-optimization/31699\n+\t* lib/target-supports.exp (check_effective_target_vect_intfloat_cvt): \n+\tNew.\n+\t(check_effective_target_vect_floatint_cvt): New.\n+\t* gcc.dg/vect/vect-floatint-conversion-1.c: Use new keyword instead\n+\tof specific targets.\n+\t* gcc.dg/vect/vect-intfloat-conversion-1.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-1.c: One less loop gets vectorized.\n+\t* gcc.dg/vect/vect-multitypes-4.c: Likewise.\n+\t* gcc.dg/vect/vect-iv-4.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-11.c: New.\n+\t* gcc.dg/vect/pr31699.c: New.\n+\n 2007-05-02  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gcc.c-torture/compile-limits-stringlit.c: Reduce size of string.\n@@ -2399,7 +2414,7 @@\n \t    Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect/vect-intfloat-conversion-1.c:  New test.\n-\t* gcc.dg/vect/vect-intfloat-conversion-1.c:  New test.\n+\t* gcc.dg/vect/vect-floatint-conversion-1.c:  New test.\n \t* gcc.dg/vect/vect-93.c: Another loop gets vectorized on powerpc.\n \t* gcc.dg/vect/vect-113.c: Likewise.\n "}, {"sha": "860999243877c3c5ed0977a90f46933ce0b8233a", "filename": "gcc/testsuite/gcc.dg/vect/pr31699.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+float x[256];\n+\n+void foo(void)\n+{\n+ double *z = malloc (sizeof(double) * 256);\n+\n+ int i;\n+ for (i=0; i<256; ++i)\n+   z[i] = x[i] + 1.0f;\n+}\n+\n+\n+int main()\n+{\n+ int i;\n+\n+ check_vect ();\n+\n+ for (i = 0; i < 256; i++)\n+   x[i] = (float) i;\n+\n+ foo();\n+\n+ return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_intfloat_cvt } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "dd845bf057dbb9cc61b33040e19d00adff31c1f2", "filename": "gcc/testsuite/gcc.dg/vect/vect-floatint-conversion-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-floatint-conversion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-floatint-conversion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-floatint-conversion-1.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -36,5 +36,5 @@ main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_floatint_cvt } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "85a993a34c889778c218c93e96a4de135b98521d", "filename": "gcc/testsuite/gcc.dg/vect/vect-intfloat-conversion-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-intfloat-conversion-1.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -34,5 +34,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_intfloat_cvt } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0a3c44579ed91679f09192f27d1eb4f9fafa2f32", "filename": "gcc/testsuite/gcc.dg/vect/vect-iv-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-iv-4.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -40,5 +40,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_pack_trunc } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e1cbafa56a1dfd358aaca672d8a3376286fed614", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -14,10 +14,9 @@ int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n \n /* Current peeling-for-alignment scheme will consider the 'sa[i+7]'\n    access for peeling, and therefore will examine the option of\n-   using a peeling factor = VF-7%VF. This will result in a peeling factor 1,\n+   using a peeling factor = V-7%V = 1,3 for V=8,4 respectively, \n    which will also align the access to 'ia[i+3]', and the loop could be \n-   vectorized on all targets that support unaligned loads.\n- */\n+   vectorized on all targets that support unaligned loads.  */\n \n int main1 (int n)\n {\n@@ -43,17 +42,16 @@ int main1 (int n)\n \n /* Current peeling-for-alignment scheme will consider the 'ia[i+3]'\n    access for peeling, and therefore will examine the option of\n-   using a peeling factor = VF-3%VF. This will result in a peeling factor\n-   5 if VF=8, or 1 if VF=4,2. In either case, this will also align the access \n-   to 'sa[i+3]', and the loop could be vectorized on targets that support \n-   unaligned loads.  */\n+   using a peeling factor = (V-3)%V = 1 for V=2,4. \n+   This will not align the access 'sa[i+3]' (for which we need to\n+   peel 5 iterations), so the loop can not be vectorized.  */\n \n int main2 (int n)\n {\n   int i;\n \n   /* Multiple types with different sizes, used in independent\n-     copmutations. Vectorizable.  */\n+     copmutations.  */\n   for (i = 0; i < n; i++)\n     {\n       ia[i+3] = ib[i];\n@@ -80,8 +78,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "26bba0b1f24e8bdd5dcb0317a47448c0e25122e4", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-11.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-11.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+short x[N] __attribute__ ((__aligned__(16)));\n+\n+int\n+foo (int len, int *z) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    z[i] = x[i];\n+  }\n+}\n+\n+\n+int main (void)\n+{\n+  short i;\n+  int z[N+4];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    x[i] = i;\n+  }\n+\n+  foo (N,z+2);\n+\n+  for (i=0; i<N; i++) {\n+    if (z[i+2] != x[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_no_align && vect_unpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "b5a55cba762d8907afd0f58766b29c8824c1a24a", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -20,8 +20,7 @@ unsigned int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n    access for peeling, and therefore will examine the option of\n    using a peeling factor = VF-7%VF. This will result in a peeling factor 1,\n    which will also align the access to 'ia[i+3]', and the loop could be\n-   vectorized on all targets that support unaligned loads.\n- */\n+   vectorized on all targets that support unaligned loads.  */\n \n int main1 (int n)\n {\n@@ -48,9 +47,9 @@ int main1 (int n)\n /* Current peeling-for-alignment scheme will consider the 'ia[i+3]'\n    access for peeling, and therefore will examine the option of\n    using a peeling factor = VF-3%VF. This will result in a peeling factor\n-   5 if VF=8, or 1 if VF=4,2. In either case, this will also align the access \n-   to 'sa[i+3]', and the loop could be vectorized on targets that support \n-   unaligned loads.  */\n+   1 if VF=4,2. This will not align the access to 'sa[i+3]', for which we \n+   need to peel 5,1 iterations for VF=4,2 respectively, so the loop can not \n+   be vectorized.  */\n \n int main2 (int n)\n {\n@@ -84,8 +83,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "9ada7f18706cad945f5b5451423f487f59fca6b3", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -1368,6 +1368,49 @@ proc check_effective_target_vect_int { } {\n     return $et_vect_int_saved\n }\n \n+# Return 1 if the target supports int->float conversion \n+#\n+\n+proc check_effective_target_vect_intfloat_cvt { } {\n+    global et_vect_intfloat_cvt_saved\n+\n+    if [info exists et_vect_intfloat_cvt_saved] {\n+        verbose \"check_effective_target_vect_intfloat_cvt: using cached result\" 2\n+    } else {\n+        set et_vect_intfloat_cvt_saved 0\n+        if { [istarget i?86-*-*]\n+              || [istarget powerpc*-*-*]\n+              || [istarget x86_64-*-*] } {\n+           set et_vect_intfloat_cvt_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect_intfloat_cvt: returning $et_vect_intfloat_cvt_saved\" 2\n+    return $et_vect_intfloat_cvt_saved\n+}\n+\n+\n+# Return 1 if the target supports float->int conversion\n+#\n+\n+proc check_effective_target_vect_floatint_cvt { } {\n+    global et_vect_floatint_cvt_saved\n+\n+    if [info exists et_vect_floatint_cvt_saved] {\n+        verbose \"check_effective_target_vect_floatint_cvt: using cached result\" 2\n+    } else {\n+        set et_vect_floatint_cvt_saved 0\n+        if { [istarget i?86-*-*]\n+              || [istarget x86_64-*-*] } {\n+           set et_vect_floatint_cvt_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect_floatint_cvt: returning $et_vect_floatint_cvt_saved\" 2\n+    return $et_vect_floatint_cvt_saved\n+}\n+\n+\n # Return 1 is this is an arm target using 32-bit instructions\n proc check_effective_target_arm32 { } {\n     global et_arm32_saved"}, {"sha": "3a4841d2c050d8d5dc3886710991ec93718ae06f", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -1258,15 +1258,6 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n   if (DR_GROUP_FIRST_DR (peel_stmt_info))\n     dr_peel_size *= DR_GROUP_SIZE (peel_stmt_info);\n \n-  if (known_alignment_for_access_p (dr)\n-      && known_alignment_for_access_p (dr_peel)\n-      && (DR_MISALIGNMENT (dr) / dr_size ==\n-          DR_MISALIGNMENT (dr_peel) / dr_peel_size))\n-    {\n-      DR_MISALIGNMENT (dr) = 0;\n-      return;\n-    }\n-\n   /* It can be assumed that the data refs with the same alignment as dr_peel\n      are aligned in the vector loop.  */\n   same_align_drs\n@@ -1507,7 +1498,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t the prolog loop ({VF - misalignment}), is a multiple of the\n \t\t number of the interleaved accesses.  */\n \t      int elem_size, mis_in_elements;\n-\t      int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\t      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t      int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n \t      /* FORNOW: handle only known alignment.  */\n \t      if (!known_alignment_for_access_p (dr))\n@@ -1516,10 +1508,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t  break;\n \t\t}\n \n-\t      elem_size = UNITS_PER_SIMD_WORD / vf;\n+\t      elem_size = UNITS_PER_SIMD_WORD / nelements;\n \t      mis_in_elements = DR_MISALIGNMENT (dr) / elem_size;\n \n-\t      if ((vf - mis_in_elements) % DR_GROUP_SIZE (stmt_info))\n+\t      if ((nelements - mis_in_elements) % DR_GROUP_SIZE (stmt_info))\n \t\t{\n \t\t  do_peeling = false;\n \t\t  break;\n@@ -1541,6 +1533,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n     {\n       int mis;\n       int npeel = 0;\n+      tree stmt = DR_STMT (dr0);\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n       if (known_alignment_for_access_p (dr0))\n         {\n@@ -1550,7 +1546,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n              factor minus the misalignment as an element count.  */\n           mis = DR_MISALIGNMENT (dr0);\n           mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n-          npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n+          npeel = nelements - mis;\n \n \t  /* For interleaved data access every iteration accesses all the \n \t     members of the group, therefore we divide the number of iterations"}, {"sha": "4775e2cd58282db48b992ea500b1dc9ea8398612", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9ed5d79fe359fe089e43b3851a72e7e27c5316/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=cb9ed5d79fe359fe089e43b3851a72e7e27c5316", "patch": "@@ -4786,13 +4786,17 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n    prolog_niters = min ( LOOP_NITERS , \n                         (VF/group_size - addr_mis/elem_size)&(VF/group_size-1) )\n \t where group_size is the size of the interleaved group.\n-*/\n+\n+   The above formulas assume that VF == number of elements in the vector. This\n+   may not hold when there are multiple-types in the loop.\n+   In this case, for some data-references in the loop the VF does not represent\n+   the number of elements that fit in the vector.  Therefore, instead of VF we\n+   use TYPE_VECTOR_SUBPARTS.  */\n \n static tree \n vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree var, stmt;\n   tree iters, iters_name;\n@@ -4805,6 +4809,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   tree niters_type = TREE_TYPE (loop_niters);\n   int group_size = 1;\n   int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+  int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n   if (DR_GROUP_FIRST_DR (stmt_info))\n     {\n@@ -4825,7 +4830,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"known alignment = %d.\", byte_misalign);\n       iters = build_int_cst (niters_type, \n-\t\t\t     (vf - elem_misalign)&(vf/group_size-1));\n+\t\t\t     (nelements - elem_misalign)&(nelements/group_size-1));\n     }\n   else\n     {\n@@ -4837,9 +4842,9 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n       tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);\n       tree elem_size_log =\n-        build_int_cst (type, exact_log2 (vectype_align/vf));\n-      tree vf_minus_1 = build_int_cst (type, vf - 1);\n-      tree vf_tree = build_int_cst (type, vf);\n+        build_int_cst (type, exact_log2 (vectype_align/nelements));\n+      tree nelements_minus_1 = build_int_cst (type, nelements - 1);\n+      tree nelements_tree = build_int_cst (type, nelements);\n       tree byte_misalign;\n       tree elem_misalign;\n \n@@ -4854,9 +4859,9 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       elem_misalign =\n         fold_build2 (RSHIFT_EXPR, type, byte_misalign, elem_size_log);\n \n-      /* Create:  (niters_type) (VF - elem_misalign)&(VF - 1)  */\n-      iters = fold_build2 (MINUS_EXPR, type, vf_tree, elem_misalign);\n-      iters = fold_build2 (BIT_AND_EXPR, type, iters, vf_minus_1);\n+      /* Create:  (niters_type) (nelements - elem_misalign)&(nelements - 1)  */\n+      iters = fold_build2 (MINUS_EXPR, type, nelements_tree, elem_misalign);\n+      iters = fold_build2 (BIT_AND_EXPR, type, iters, nelements_minus_1);\n       iters = fold_convert (niters_type, iters);\n     }\n "}]}