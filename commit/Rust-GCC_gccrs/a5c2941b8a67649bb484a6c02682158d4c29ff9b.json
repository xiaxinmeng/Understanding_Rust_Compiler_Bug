{"sha": "a5c2941b8a67649bb484a6c02682158d4c29ff9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVjMjk0MWI4YTY3NjQ5YmI0ODRhNmMwMjY4MjE1OGQ0YzI5ZmY5Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1994-10-15T00:32:58Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1994-10-15T00:32:58Z"}, "message": "(build_method_call): Disable code that tries to do tricky stuff with a default parameter that is a constructor call...\n\n(build_method_call): Disable code that tries to do tricky\n        stuff with a default parameter that is a constructor call, but\n        actually does other tricky stuff that breaks things.\n(build_scoped_method_call): Don't lose side effects in the\n        object expression when calling a non-existent destructor.\n(build_scoped_method_call): Remove erroneous error message\n        when destructor call is written as a scoped call.\n\nFrom-SVN: r8274", "tree": {"sha": "513788d8f3d1545c05d0e9c0c08589222b73dc38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/513788d8f3d1545c05d0e9c0c08589222b73dc38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5c2941b8a67649bb484a6c02682158d4c29ff9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c2941b8a67649bb484a6c02682158d4c29ff9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c2941b8a67649bb484a6c02682158d4c29ff9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c2941b8a67649bb484a6c02682158d4c29ff9b/comments", "author": null, "committer": null, "parents": [{"sha": "f37f4651e1bcb4d14b8540f8e317a975f897498d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37f4651e1bcb4d14b8540f8e317a975f897498d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37f4651e1bcb4d14b8540f8e317a975f897498d"}], "stats": {"total": 20, "additions": 12, "deletions": 8}, "files": [{"sha": "41580a6199fbeb0a884bf13ae80eec302efd93a1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2941b8a67649bb484a6c02682158d4c29ff9b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2941b8a67649bb484a6c02682158d4c29ff9b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a5c2941b8a67649bb484a6c02682158d4c29ff9b", "patch": "@@ -1439,12 +1439,10 @@ build_scoped_method_call (exp, scopes, name, parms)\n \tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t  exp, basetype, type);\n       name = TREE_OPERAND (name, 0);\n-      if (IDENTIFIER_HAS_TYPE_VALUE (name))\n-\tname = IDENTIFIER_TYPE_VALUE (name);\n-      if (basetype != name)\n-\tcp_error (\"qualified type `%T' does not match destructor type `%T'\",\n+      if (basetype != get_type_value (name))\n+\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  basetype, name);\n-      return void_zero_node;\n+      return convert (void_type_node, exp);\n     }\n \n   if (! is_aggr_typedef (basename, 1))\n@@ -1472,15 +1470,16 @@ build_scoped_method_call (exp, scopes, name, parms)\n \t{\n \t  /* Explicit call to destructor.  */\n \t  name = TREE_OPERAND (name, 0);\n-\t  if (name != constructor_name (TREE_TYPE (decl)))\n+\t  if (! (name == constructor_name (TREE_TYPE (decl))\n+\t\t || TREE_TYPE (decl) == get_type_value (name)))\n \t    {\n \t      cp_error\n-\t\t(\"qualified type `%T' does not match destructor type `%T'\",\n+\t\t(\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t TREE_TYPE (decl), name);\n \t      return error_mark_node;\n \t    }\n \t  if (! TYPE_HAS_DESTRUCTOR (TREE_TYPE (decl)))\n-\t    return void_zero_node;\n+\t    return convert (void_type_node, exp);\n \t  \n \t  return build_delete (TREE_TYPE (decl), decl, integer_two_node,\n \t\t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR,\n@@ -1962,6 +1961,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  TREE_CALLS_NEW (instance_ptr) = 1;\n \t  instance = build_indirect_ref (instance_ptr, NULL_PTR);\n \n+#if 0\n+\t  /* This breaks initialization of a reference from a new\n+             expression of a different type.  And it doesn't appear to\n+             serve its original purpose any more, either.  jason 10/12/94 */\n \t  /* If it's a default argument initialized from a ctor, what we get\n \t     from instance_ptr will match the arglist for the FUNCTION_DECL\n \t     of the constructor.  */\n@@ -1970,6 +1973,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      && TREE_CALLS_NEW (TREE_VALUE (TREE_OPERAND (TREE_VALUE (parms), 1))))\n \t    parms = build_tree_list (NULL_TREE, instance_ptr);\n \t  else\n+#endif\n \t    parms = tree_cons (NULL_TREE, instance_ptr, parms);\n \t}\n     }"}]}