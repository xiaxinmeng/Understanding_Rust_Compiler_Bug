{"sha": "787732cdd12218f31dced23a9c427b29c721a9d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg3NzMyY2RkMTIyMThmMzFkY2VkMjNhOWM0MjdiMjljNzIxYTlkNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-25T22:23:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-25T22:23:49Z"}, "message": "compiler: improve escape analysis\n    \n    This CL ports recent enhancements of the escape analysis in the\n    gc compiler to gofrontend.\n    \n    - CL 99335: unnamed receiver should not escape.\n    \n    - CL 105257: propagate loop depth to field. This prevents it\n      from escaping when a field's address is taken inside a loop\n      (but not otherwise escape).\n    \n    - CL 107597: use element type for \"indirection\" of slice/string.\n      This prevents the slice/string from escaping when only the\n      element, in case that it is pointerless, flows to outer scope.\n    \n    Reviewed-on: https://go-review.googlesource.com/120760\n\nFrom-SVN: r262120", "tree": {"sha": "ba26ce38ad8bff564c5420b549f769a10d715f43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba26ce38ad8bff564c5420b549f769a10d715f43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/787732cdd12218f31dced23a9c427b29c721a9d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787732cdd12218f31dced23a9c427b29c721a9d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/787732cdd12218f31dced23a9c427b29c721a9d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/787732cdd12218f31dced23a9c427b29c721a9d6/comments", "author": null, "committer": null, "parents": [{"sha": "4fdb6fb6aebfba933ee8b07ff395d236180b5d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fdb6fb6aebfba933ee8b07ff395d236180b5d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fdb6fb6aebfba933ee8b07ff395d236180b5d67"}], "stats": {"total": 134, "additions": 81, "deletions": 53}, "files": [{"sha": "3d825803ae819b854c1c225c10f32eb236a0aa36", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787732cdd12218f31dced23a9c427b29c721a9d6/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787732cdd12218f31dced23a9c427b29c721a9d6/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=787732cdd12218f31dced23a9c427b29c721a9d6", "patch": "@@ -1,4 +1,4 @@\n-7008302f1f0eaa9508b2857185505d4dc7baac1e\n+baaaf1e0f1e9a54ea2dfe475154c85c83ec03740\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e32ae5b475ced723bd438e1360d9aeaed5054dca", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 80, "deletions": 52, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/787732cdd12218f31dced23a9c427b29c721a9d6/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/787732cdd12218f31dced23a9c427b29c721a9d6/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=787732cdd12218f31dced23a9c427b29c721a9d6", "patch": "@@ -43,6 +43,12 @@ Node::type() const\n         // which may also be pointer. We model it as another void*, so\n         // we don't lose pointer-ness.\n         return this->child()->type();\n+      else if (this->child()->type()->is_slice_type())\n+        // We model \"indirect\" of a slice as dereferencing its pointer\n+        // field (to get element). Use element type here.\n+        return this->child()->type()->array_type()->element_type();\n+      else if (this->child()->type()->is_string_type())\n+        return Type::lookup_integer_type(\"uint8\");\n       else\n         return this->child()->type()->deref();\n     }\n@@ -1811,60 +1817,77 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \n     case Expression::EXPRESSION_UNARY:\n       {\n-\tif ((*pexpr)->unary_expression()->op() != OPERATOR_AND)\n-\t  break;\n+\tExpression* operand = (*pexpr)->unary_expression()->operand();\n \n-\tNode* addr_node = Node::make_node(*pexpr);\n-\tthis->context_->track(addr_node);\n+        if ((*pexpr)->unary_expression()->op() == OPERATOR_AND)\n+          {\n+            this->context_->track(n);\n \n-\tExpression* operand = (*pexpr)->unary_expression()->operand();\n-\tNamed_object* var = NULL;\n-\tif (operand->var_expression() != NULL)\n-\t  var = operand->var_expression()->named_object();\n-\telse if (operand->enclosed_var_expression() != NULL)\n-\t  var = operand->enclosed_var_expression()->variable();\n+            Named_object* var = NULL;\n+            if (operand->var_expression() != NULL)\n+              var = operand->var_expression()->named_object();\n+            else if (operand->enclosed_var_expression() != NULL)\n+              var = operand->enclosed_var_expression()->variable();\n \n-\tif (var == NULL)\n-\t  break;\n+            if (var != NULL\n+                && ((var->is_variable() && var->var_value()->is_parameter())\n+                    || var->is_result_variable()))\n+              {\n+                Node::Escape_state* addr_state = n->state(this->context_, NULL);\n+                addr_state->loop_depth = 1;\n+                break;\n+              }\n+          }\n \n-\tif (var->is_variable()\n-\t    && !var->var_value()->is_parameter())\n-\t  {\n-\t    // For &x, use the loop depth of x if known.\n-\t    Node::Escape_state* addr_state =\n-\t      addr_node->state(this->context_, NULL);\n-\t    Node* operand_node = Node::make_node(operand);\n-\t    Node::Escape_state* operand_state =\n-\t      operand_node->state(this->context_, NULL);\n-\t    if (operand_state->loop_depth != 0)\n-\t      addr_state->loop_depth = operand_state->loop_depth;\n-\t  }\n-\telse if ((var->is_variable()\n-\t\t  && var->var_value()->is_parameter())\n-\t\t || var->is_result_variable())\n-\t  {\n-\t    Node::Escape_state* addr_state =\n-\t      addr_node->state(this->context_, NULL);\n-\t    addr_state->loop_depth = 1;\n-\t  }\n+        if ((*pexpr)->unary_expression()->op() != OPERATOR_AND\n+            && (*pexpr)->unary_expression()->op() != OPERATOR_MULT)\n+          break;\n+\n+        // For &x and *x, use the loop depth of x if known.\n+        Node::Escape_state* expr_state = n->state(this->context_, NULL);\n+        Node* operand_node = Node::make_node(operand);\n+        Node::Escape_state* operand_state = operand_node->state(this->context_, NULL);\n+        if (operand_state->loop_depth != 0)\n+          expr_state->loop_depth = operand_state->loop_depth;\n       }\n       break;\n \n     case Expression::EXPRESSION_ARRAY_INDEX:\n       {\n         Array_index_expression* aie = (*pexpr)->array_index_expression();\n+\n+        // Propagate the loopdepth to element.\n+        Node* array_node = Node::make_node(aie->array());\n+        Node::Escape_state* elem_state = n->state(this->context_, NULL);\n+        Node::Escape_state* array_state = array_node->state(this->context_, NULL);\n+        elem_state->loop_depth = array_state->loop_depth;\n+\n         if (aie->end() != NULL && !aie->array()->type()->is_slice_type())\n           {\n-            // Slicing an array.\n+            // Slicing an array. This effectively takes the address of the array.\n             Expression* addr = Expression::make_unary(OPERATOR_AND, aie->array(),\n                                                       aie->location());\n             Node* addr_node = Node::make_node(addr);\n             n->set_child(addr_node);\n             this->context_->track(addr_node);\n+\n+            Node::Escape_state* addr_state = addr_node->state(this->context_, NULL);\n+            addr_state->loop_depth = array_state->loop_depth;\n           }\n       }\n       break;\n \n+    case Expression::EXPRESSION_FIELD_REFERENCE:\n+      {\n+        // Propagate the loopdepth to field.\n+        Node* struct_node =\n+          Node::make_node((*pexpr)->field_reference_expression()->expr());\n+        Node::Escape_state* field_state = n->state(this->context_, NULL);\n+        Node::Escape_state* struct_state = struct_node->state(this->context_, NULL);\n+        field_state->loop_depth = struct_state->loop_depth;\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -3288,28 +3311,33 @@ Escape_analysis_tag::tag(Named_object* fn)\n   Function_type* fntype = fn->func_value()->type();\n   Bindings* bindings = fn->func_value()->block()->bindings();\n \n-  if (fntype->is_method()\n-      && !fntype->receiver()->name().empty()\n-      && !Gogo::is_sink_name(fntype->receiver()->name()))\n+  if (fntype->is_method())\n     {\n-      Named_object* rcvr_no = bindings->lookup(fntype->receiver()->name());\n-      go_assert(rcvr_no != NULL);\n-      Node* rcvr_node = Node::make_node(rcvr_no);\n-      switch ((rcvr_node->encoding() & ESCAPE_MASK))\n-\t{\n-\tcase Node::ESCAPE_NONE: // not touched by flood\n-\tcase Node::ESCAPE_RETURN:\n-\t  if (fntype->receiver()->type()->has_pointer())\n-\t    // Don't bother tagging for scalars.\n-\t    fntype->add_receiver_note(rcvr_node->encoding());\n-\t  break;\n+      if (fntype->receiver()->name().empty()\n+          || Gogo::is_sink_name(fntype->receiver()->name()))\n+        // Unnamed receiver is not used in the function body, does not escape.\n+        fntype->add_receiver_note(Node::ESCAPE_NONE);\n+      else\n+        {\n+          Named_object* rcvr_no = bindings->lookup(fntype->receiver()->name());\n+          go_assert(rcvr_no != NULL);\n+          Node* rcvr_node = Node::make_node(rcvr_no);\n+          switch ((rcvr_node->encoding() & ESCAPE_MASK))\n+            {\n+            case Node::ESCAPE_NONE: // not touched by flood\n+            case Node::ESCAPE_RETURN:\n+              if (fntype->receiver()->type()->has_pointer())\n+                // Don't bother tagging for scalars.\n+                fntype->add_receiver_note(rcvr_node->encoding());\n+              break;\n \n-\tcase Node::ESCAPE_HEAP: // flooded, moved to heap.\n-\t  break;\n+            case Node::ESCAPE_HEAP: // flooded, moved to heap.\n+              break;\n \n-\tdefault:\n-\t  break;\n-\t}\n+            default:\n+              break;\n+            }\n+        }\n     }\n \n   int i = 0;"}]}