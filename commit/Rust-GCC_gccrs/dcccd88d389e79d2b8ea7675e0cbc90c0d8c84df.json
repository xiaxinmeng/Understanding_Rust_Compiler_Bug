{"sha": "dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNjY2Q4OGQzODllNzlkMmI4ZWE3Njc1ZTBjYmM5MGMwZDhjODRkZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-05-01T20:05:57Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-05-01T20:05:57Z"}, "message": "re PR tree-optimization/27283 (ICE: SSA corruption - Conflict across an abnormal edge)\n\n\tPR tree-optimization/27283\n\t* tree-ssa-loop-ivopts.c (struct nfe_cache_elt): Store just trees,\n\tnot whole # of iteration descriptions.\n\t(niter_for_exit): Return just # of iterations.  Fail if # of iterations\n\tuses abnormal ssa name.\n\t(niter_for_single_dom_exit): Ditto.\n\t(find_induction_variables, may_eliminate_iv): Expect niter_for_exit to\n\treturn just the number of iterations.\n\n\t* g++.dg/tree-ssa/pr27283.C: New test.\n\nFrom-SVN: r113427", "tree": {"sha": "c23066a00dcce02ea7bc2323eb29f97eb1070b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23066a00dcce02ea7bc2323eb29f97eb1070b42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/comments", "author": null, "committer": null, "parents": [{"sha": "a5dfac10a2ec09de7b9763226161dfc90a2a259d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5dfac10a2ec09de7b9763226161dfc90a2a259d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5dfac10a2ec09de7b9763226161dfc90a2a259d"}], "stats": {"total": 292, "additions": 180, "deletions": 112}, "files": [{"sha": "2fd3b028be8a6dabc50b84029ef2a36625b39224", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "patch": "@@ -1,3 +1,14 @@\n+2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27283\n+\t* tree-ssa-loop-ivopts.c (struct nfe_cache_elt): Store just trees,\n+\tnot whole # of iteration descriptions.\n+\t(niter_for_exit): Return just # of iterations.  Fail if # of iterations\n+\tuses abnormal ssa name.\n+\t(niter_for_single_dom_exit): Ditto.\n+\t(find_induction_variables, may_eliminate_iv): Expect niter_for_exit to\n+\treturn just the number of iterations.\n+\n 2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/27144"}, {"sha": "732fb0a931d291eec014ceadb9d0112858c7e1e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "patch": "@@ -1,3 +1,8 @@\n+2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27283\n+\t* g++.dg/tree-ssa/pr27283.C: New test.\n+\n 2006-05-01  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/loop-16.c: New test."}, {"sha": "224ea6a9bf96a857fa719c64192366d3d599a3ae", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr27283.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27283.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27283.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr27283.C?ref=dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+namespace Gambit\n+{\n+  template < class T > class Array\n+  {\n+  protected:int mindex, maxdex;\n+    T *data;\n+    int InsertAt (const T & t, int n)\n+    {\n+      T *new_data = new T[++this->maxdex - this->mindex + 1] - this->mindex;\n+      int i;\n+      for (i = this->mindex; i <= n - 1; i++)\n+          new_data[i] = this->data[i];\n+    }\n+  public:   Array (unsigned int len = 0):mindex (1), maxdex (len),\n+      data ((len) ? new T[len] -\n+            1 : 0)\n+    {\n+    }\n+    virtual ~ Array ()\n+    {\n+      if (maxdex >= mindex)\n+        delete[](data + mindex);\n+    }\n+    const T & operator[] (int index) const\n+    {\n+    }\n+    int Append (const T & t)\n+    {\n+      return InsertAt (t, this->maxdex + 1);\n+    }\n+  };\n+}\n+class gIndexOdometer\n+{\n+private:Gambit::Array < int >MinIndices;\n+    Gambit::Array < int >CurIndices;\n+    gIndexOdometer (const Gambit::Array < int >, const Gambit::Array < int >);\n+  void SetIndex (const int &, const int &);\n+  int NoIndices () const;\n+  gIndexOdometer AfterExcisionOf (int &) const;\n+};\n+gIndexOdometer\n+gIndexOdometer::AfterExcisionOf (int &to_be_zapped) const\n+{\n+  Gambit::Array < int >NewMins, NewMaxs;\n+  int i;\n+  for (i = 1; i <= NoIndices (); i++)\n+    {\n+      NewMins.Append (MinIndices[i]);\n+    }\n+  gIndexOdometer NewOdo (NewMins, NewMaxs);\n+    NewOdo.SetIndex (i, CurIndices[i]);\n+}\n+"}, {"sha": "02f045b43c6a0f384c5a7b75951f2d5073a92bf3", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 107, "deletions": 112, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=dcccd88d389e79d2b8ea7675e0cbc90c0d8c84df", "patch": "@@ -643,6 +643,86 @@ stmt_after_increment (struct loop *loop, struct iv_cand *cand, tree stmt)\n     }\n }\n \n+/* Returns true if EXP is a ssa name that occurs in an abnormal phi node.  */\n+\n+static bool\n+abnormal_ssa_name_p (tree exp)\n+{\n+  if (!exp)\n+    return false;\n+\n+  if (TREE_CODE (exp) != SSA_NAME)\n+    return false;\n+\n+  return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp) != 0;\n+}\n+\n+/* Returns false if BASE or INDEX contains a ssa name that occurs in an\n+   abnormal phi node.  Callback for for_each_index.  */\n+\n+static bool\n+idx_contains_abnormal_ssa_name_p (tree base, tree *index,\n+\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))\n+\treturn false;\n+      if (abnormal_ssa_name_p (TREE_OPERAND (base, 3)))\n+\treturn false;\n+    }\n+\n+  return !abnormal_ssa_name_p (*index);\n+}\n+\n+/* Returns true if EXPR contains a ssa name that occurs in an\n+   abnormal phi node.  */\n+\n+static bool\n+contains_abnormal_ssa_name_p (tree expr)\n+{\n+  enum tree_code code;\n+  enum tree_code_class class;\n+\n+  if (!expr)\n+    return false;\n+\n+  code = TREE_CODE (expr);\n+  class = TREE_CODE_CLASS (code);\n+\n+  if (code == SSA_NAME)\n+    return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (expr) != 0;\n+\n+  if (code == INTEGER_CST\n+      || is_gimple_min_invariant (expr))\n+    return false;\n+\n+  if (code == ADDR_EXPR)\n+    return !for_each_index (&TREE_OPERAND (expr, 0),\n+\t\t\t    idx_contains_abnormal_ssa_name_p,\n+\t\t\t    NULL);\n+\n+  switch (class)\n+    {\n+    case tcc_binary:\n+    case tcc_comparison:\n+      if (contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 1)))\n+\treturn true;\n+\n+      /* Fallthru.  */\n+    case tcc_unary:\n+      if (contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 0)))\n+\treturn true;\n+\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n /* Element of the table in that we cache the numbers of iterations obtained\n    from exits of the loop.  */\n \n@@ -651,11 +731,9 @@ struct nfe_cache_elt\n   /* The edge for that the number of iterations is cached.  */\n   edge exit;\n \n-  /* True if the # of iterations was successfully determined.  */\n-  bool valid_p;\n-\n-  /* Description of # of iterations.  */\n-  struct tree_niter_desc niter;\n+  /* Number of iterations corresponding to this exit, or NULL if it cannot be\n+     determined.  */\n+  tree niter;\n };\n \n /* Hash function for nfe_cache_elt E.  */\n@@ -678,13 +756,14 @@ nfe_eq (const void *e1, const void *e2)\n   return elt1->exit == e2;\n }\n \n-/*  Returns structure describing number of iterations determined from\n+/*  Returns tree describing number of iterations determined from\n     EXIT of DATA->current_loop, or NULL if something goes wrong.  */\n \n-static struct tree_niter_desc *\n+static tree\n niter_for_exit (struct ivopts_data *data, edge exit)\n {\n   struct nfe_cache_elt *nfe_desc;\n+  struct tree_niter_desc desc;\n   PTR *slot;\n \n   slot = htab_find_slot_with_hash (data->niters, exit,\n@@ -695,25 +774,31 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n     {\n       nfe_desc = xmalloc (sizeof (struct nfe_cache_elt));\n       nfe_desc->exit = exit;\n-      nfe_desc->valid_p = number_of_iterations_exit (data->current_loop,\n-\t\t\t\t\t\t     exit, &nfe_desc->niter,\n-\t\t\t\t\t\t     true);\n-      *slot = nfe_desc;\n+\n+      /* Try to determine number of iterations.  We must know it\n+\t unconditionally (i.e., without possibility of # of iterations\n+\t being zero).  Also, we cannot safely work with ssa names that\n+\t appear in phi nodes on abnormal edges, so that we do not create\n+\t overlapping life ranges for them (PR 27283).  */\n+      if (number_of_iterations_exit (data->current_loop,\n+\t\t\t\t     exit, &desc, true)\n+\t  && zero_p (desc.may_be_zero)\n+     \t  && !contains_abnormal_ssa_name_p (desc.niter))\n+\tnfe_desc->niter = desc.niter;\n+      else\n+\tnfe_desc->niter = NULL_TREE;\n     }\n   else\n     nfe_desc = *slot;\n \n-  if (!nfe_desc->valid_p)\n-    return NULL;\n-\n-  return &nfe_desc->niter;\n+  return nfe_desc->niter;\n }\n \n-/* Returns structure describing number of iterations determined from\n+/* Returns tree describing number of iterations determined from\n    single dominating exit of DATA->current_loop, or NULL if something\n    goes wrong.  */\n \n-static struct tree_niter_desc *\n+static tree\n niter_for_single_dom_exit (struct ivopts_data *data)\n {\n   edge exit = single_dom_exit (data->current_loop);\n@@ -869,86 +954,6 @@ determine_biv_step (tree phi)\n   return (zero_p (iv.step) ? NULL_TREE : iv.step);\n }\n \n-/* Returns true if EXP is a ssa name that occurs in an abnormal phi node.  */\n-\n-static bool\n-abnormal_ssa_name_p (tree exp)\n-{\n-  if (!exp)\n-    return false;\n-\n-  if (TREE_CODE (exp) != SSA_NAME)\n-    return false;\n-\n-  return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp) != 0;\n-}\n-\n-/* Returns false if BASE or INDEX contains a ssa name that occurs in an\n-   abnormal phi node.  Callback for for_each_index.  */\n-\n-static bool\n-idx_contains_abnormal_ssa_name_p (tree base, tree *index,\n-\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n-{\n-  if (TREE_CODE (base) == ARRAY_REF)\n-    {\n-      if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))\n-\treturn false;\n-      if (abnormal_ssa_name_p (TREE_OPERAND (base, 3)))\n-\treturn false;\n-    }\n-\n-  return !abnormal_ssa_name_p (*index);\n-}\n-\n-/* Returns true if EXPR contains a ssa name that occurs in an\n-   abnormal phi node.  */\n-\n-static bool\n-contains_abnormal_ssa_name_p (tree expr)\n-{\n-  enum tree_code code;\n-  enum tree_code_class class;\n-\n-  if (!expr)\n-    return false;\n-\n-  code = TREE_CODE (expr);\n-  class = TREE_CODE_CLASS (code);\n-\n-  if (code == SSA_NAME)\n-    return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (expr) != 0;\n-\n-  if (code == INTEGER_CST\n-      || is_gimple_min_invariant (expr))\n-    return false;\n-\n-  if (code == ADDR_EXPR)\n-    return !for_each_index (&TREE_OPERAND (expr, 0),\n-\t\t\t    idx_contains_abnormal_ssa_name_p,\n-\t\t\t    NULL);\n-\n-  switch (class)\n-    {\n-    case tcc_binary:\n-    case tcc_comparison:\n-      if (contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 1)))\n-\treturn true;\n-\n-      /* Fallthru.  */\n-    case tcc_unary:\n-      if (contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 0)))\n-\treturn true;\n-\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return false;\n-}\n-\n /* Finds basic ivs.  */\n \n static bool\n@@ -1102,20 +1107,13 @@ find_induction_variables (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      struct tree_niter_desc *niter;\n-\n-      niter = niter_for_single_dom_exit (data);\n+      tree niter = niter_for_single_dom_exit (data);\n \n       if (niter)\n \t{\n \t  fprintf (dump_file, \"  number of iterations \");\n-\t  print_generic_expr (dump_file, niter->niter, TDF_SLIM);\n-\t  fprintf (dump_file, \"\\n\");\n-\n-    \t  fprintf (dump_file, \"  may be zero if \");\n-    \t  print_generic_expr (dump_file, niter->may_be_zero, TDF_SLIM);\n-    \t  fprintf (dump_file, \"\\n\");\n-    \t  fprintf (dump_file, \"\\n\");\n+\t  print_generic_expr (dump_file, niter, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\\n\");\n     \t};\n  \n       fprintf (dump_file, \"Induction variables:\\n\\n\");\n@@ -3954,7 +3952,6 @@ may_eliminate_iv (struct ivopts_data *data,\n {\n   basic_block ex_bb;\n   edge exit;\n-  struct tree_niter_desc *niter;\n   tree nit, nit_type;\n   tree wider_type, period, per_type;\n   struct loop *loop = data->current_loop;\n@@ -3977,12 +3974,10 @@ may_eliminate_iv (struct ivopts_data *data,\n   if (flow_bb_inside_loop_p (loop, exit->dest))\n     return false;\n \n-  niter = niter_for_exit (data, exit);\n-  if (!niter\n-      || !zero_p (niter->may_be_zero))\n+  nit = niter_for_exit (data, exit);\n+  if (!nit)\n     return false;\n \n-  nit = niter->niter;\n   nit_type = TREE_TYPE (nit);\n \n   /* Determine whether we may use the variable to test whether niter iterations"}]}