{"sha": "5a73491b0f4872a9574c324531de37d75de10d5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE3MzQ5MWIwZjQ4NzJhOTU3NGMzMjQ1MzFkZTM3ZDc1ZGUxMGQ1Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-19T12:48:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-19T12:48:39Z"}, "message": "(instantiate_decl): New function.\n\n(instantiate_decls{,_1}): Call it.\n\nFrom-SVN: r1896", "tree": {"sha": "56a17c34aed187c8221760ae9ea3f5985dcb08ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56a17c34aed187c8221760ae9ea3f5985dcb08ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a73491b0f4872a9574c324531de37d75de10d5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a73491b0f4872a9574c324531de37d75de10d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a73491b0f4872a9574c324531de37d75de10d5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a73491b0f4872a9574c324531de37d75de10d5b/comments", "author": null, "committer": null, "parents": [{"sha": "fe0cf571ecf5a92898cb5d55985c896e1eef4cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0cf571ecf5a92898cb5d55985c896e1eef4cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe0cf571ecf5a92898cb5d55985c896e1eef4cc3"}], "stats": {"total": 90, "additions": 71, "deletions": 19}, "files": [{"sha": "753931d67d91f9c446ad0d1d999ef5b9ee2f96bc", "filename": "gcc/function.c", "status": "modified", "additions": 71, "deletions": 19, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a73491b0f4872a9574c324531de37d75de10d5b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a73491b0f4872a9574c324531de37d75de10d5b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5a73491b0f4872a9574c324531de37d75de10d5b", "patch": "@@ -307,6 +307,7 @@ static void fixup_var_refs_1 ();\n static void optimize_bit_field ();\n static void instantiate_decls ();\n static void instantiate_decls_1 ();\n+static void instantiate_decl ();\n static int instantiate_virtual_regs_1 ();\n static rtx fixup_memory_subreg ();\n static rtx walk_fixup_memory_subreg ();\n@@ -1902,20 +1903,10 @@ instantiate_decls (fndecl, valid_only)\n   /* Process all parameters of the function.  */\n   for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n     {\n-      if (DECL_RTL (decl) && GET_CODE (DECL_RTL (decl)) == MEM\n-\t  && (! valid_only\n-\t      || ! mode_dependent_address_p (XEXP (DECL_RTL (decl), 0))))\n-\tinstantiate_virtual_regs_1 (&XEXP (DECL_RTL (decl), 0),\n-\t\t\t\t    (valid_only ? DECL_RTL (decl) : NULL_RTX),\n-\t\t\t\t    0);\n-      if (DECL_INCOMING_RTL (decl)\n-\t  && GET_CODE (DECL_INCOMING_RTL (decl)) == MEM\n-\t  && (! valid_only\n-\t      || ! mode_dependent_address_p (XEXP (DECL_INCOMING_RTL (decl), 0))))\n-\tinstantiate_virtual_regs_1 (&XEXP (DECL_INCOMING_RTL (decl), 0),\n-\t\t\t\t    (valid_only ? DECL_INCOMING_RTL (decl)\n-\t\t\t\t     : NULL_RTX),\n-\t\t\t\t    0);\n+      instantiate_decl (DECL_RTL (decl), int_size_in_bytes (TREE_TYPE (decl)),\n+\t\t\tvalid_only);\t\n+      instantiate_decl (DECL_INCOMING_RTL (decl),\n+\t\t\tint_size_in_bytes (TREE_TYPE (decl)), valid_only);\n     }\n \n   /* Now process all variables defined in the function or its subblocks. */\n@@ -1942,16 +1933,77 @@ instantiate_decls_1 (let, valid_only)\n   tree t;\n \n   for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n-    if (DECL_RTL (t) && GET_CODE (DECL_RTL (t)) == MEM\n-\t&& (! valid_only\n-\t    || ! mode_dependent_address_p (XEXP (DECL_RTL (t), 0))))\n-      instantiate_virtual_regs_1 (& XEXP (DECL_RTL (t), 0),\n-\t\t\t\t  valid_only ? DECL_RTL (t) : NULL_RTX, 0);\n+    instantiate_decl (DECL_RTL (t), int_size_in_bytes (TREE_TYPE (t)),\n+\t\t      valid_only);\n \n   /* Process all subblocks.  */\n   for (t = BLOCK_SUBBLOCKS (let); t; t = TREE_CHAIN (t))\n     instantiate_decls_1 (t, valid_only);\n }\n+\n+/* Subroutine of the preceeding procedures: Given RTL representing a\n+   decl and the size of the object, do any instantiation required.\n+\n+   If VALID_ONLY is non-zero, it means that the RTL should only be\n+   changed if the new address is valid.  */\n+\n+static void\n+instantiate_decl (x, size, valid_only)\n+     rtx x;\n+     int size;\n+     int valid_only;\n+{\n+  enum machine_mode mode;\n+  rtx addr;\n+\n+  /* If this is not a MEM, no need to do anything.  Similarly if the\n+     address is a constant or a register that is not a virtual register.  */\n+\n+  if (x == 0 || GET_CODE (x) != MEM)\n+    return;\n+\n+  addr = XEXP (x, 0);\n+  if (CONSTANT_P (addr)\n+      || (GET_CODE (addr) == REG\n+\t  && (REGNO (addr) < FIRST_VIRTUAL_REGISTER\n+\t      || REGNO (addr) > LAST_VIRTUAL_REGISTER)))\n+    return;\n+\n+  /* If we should only do this if the address is valid, copy the address.\n+     We need to do this so we can undo any changes that might make the\n+     address invalid.  This copy is unfortunate, but probably can't be\n+     avoided.  */\n+\n+  if (valid_only)\n+    addr = copy_rtx (addr);\n+\n+  instantiate_virtual_regs_1 (&addr, NULL_RTX, 0);\n+\n+  if (! valid_only)\n+    return;\n+\n+  /* Now verify that the resulting address is valid for every integer or\n+     floating-point mode up to and including SIZE bytes long.  We do this\n+     since the object might be accessed in any mode and frame addresses\n+     are shared.  */\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+       mode != VOIDmode && GET_MODE_SIZE (mode) <= size;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (! memory_address_p (mode, addr))\n+      return;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+       mode != VOIDmode && GET_MODE_SIZE (mode) <= size;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (! memory_address_p (mode, addr))\n+      return;\n+\n+  /* Otherwise, put back the address, now that we have updated it and we\n+     know it is valid.  */\n+\n+  XEXP (x, 0) = addr;\n+}\n \f\n /* Given a pointer to a piece of rtx and an optional pointer to the\n    containing object, instantiate any virtual registers present in it."}]}