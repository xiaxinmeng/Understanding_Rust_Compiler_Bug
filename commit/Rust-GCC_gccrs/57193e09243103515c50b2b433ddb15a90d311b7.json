{"sha": "57193e09243103515c50b2b433ddb15a90d311b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcxOTNlMDkyNDMxMDM1MTVjNTBiMmI0MzNkZGIxNWE5MGQzMTFiNw==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2006-02-15T09:44:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:44:24Z"}, "message": "sem_ch12.adb (Inline_Instance_Body): Remove erroneous assumption that Scope_Stack.First = 1.\n\n2006-02-13  Thomas Quinot  <quinot@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch12.adb (Inline_Instance_Body): Remove erroneous assumption\n\tthat Scope_Stack.First = 1.\n\tProperly handle Ada_Version_Explicit and Ada_Version_Config, which\n\twere not always properly handled previously.\n\t(Formal_Entity): Complete rewrite, to handle properly some complex case\n\twith multiple levels of parametrization by formal packages.\n\t(Analyze_Formal_Derived_Type): Propagate Ada 2005 \"limited\" indicator\n\tto the corresponding derived type declaration for proper semantics.\n\n\t* sem_prag.adb (Analyze_Pragma): Remove '!' in warning message.\n\t(Check_Component): Enforce restriction on components of\n\tunchecked_unions: a component in a variant cannot contain tasks or\n\tcontrolled types.\n\t(Unchecked_Union): Allow nested variants and multiple discriminants, to\n\tconform to AI-216.\n\tAdd pragma Ada_2005 (synonym for Ada_05)\n\tProperly handle Ada_Version_Explicit and Ada_Version_Config, which\n\twere not always properly handled previously.\n\tDocument that pragma Propagate_Exceptions has no effect\n\t(Analyze_Pragma, case Pure): Set new flag Has_Pragma_Pure\n\t(Set_Convention_From_Pragma): Check that if a convention is\n\tspecified for a dispatching operation, then it must be\n\tconsistent with the existing convention for the operation.\n\t(CPP_Class): Because of the C++ ABI compatibility, the programmer is no\n\tlonger required to specify an vtable-ptr component in the record. For\n\tcompatibility reasons we leave the support for the previous definition.\n\t(Analyze_Pragma, case No_Return): Allow multiple arguments\n\n\t* sem_ch3.ads, sem_ch3.adb (Check_Abstract_Overriding): Flag a\n\tnon-overrideen inherited operation with a controlling result as\n\tillegal only its implicit declaration comes from the derived type\n\tdeclaration of its result's type.\n\t(Check_Possible_Deferred_Completion): Relocate the object definition\n\tnode of the subtype indication of a deferred constant completion rather\n\tthan directly analyzing it. The analysis of the generated subtype will\n\tcorrectly decorate the GNAT tree.\n\t(Record_Type_Declaration): Check whether this is a declaration for a\n\tlimited derived record before analyzing components.\n\t(Analyze_Component_Declaration): Diagnose record types  not explicitly\n\tdeclared limited when a component has a limited type.\n\t(Build_Derived_Record_Type): Code reorganization to check if some of\n\tthe inherited subprograms of a tagged type cover interface primitives.\n\tThis check was missing in case of a full-type associated with a private\n\ttype declaration.\n\t(Constant_Redeclaration): Check that the subtypes of the partial and the\n\tfull view of a constrained deferred constant statically match.\n\t(Mentions_T): A reference to the current type in an anonymous access\n\tcomponent declaration  must be an entity name.\n\t(Make_Incomplete_Type_Declaration): If type is tagged, set type of\n\tclass_wide type to refer to full type, not to the incomplete one.\n\t(Add_Interface_Tag_Components): Do nothing if RE_Interface_Tag is not\n\tavailable. Required to give support to the certified run-time.\n\t(Analyze_Component_Declaration): In case of anonymous access components\n\tperform missing checks for AARM 3.9.2(9) and 3.10.2 (12.2).\n\t(Process_Discriminants): For an access discriminant, use the\n\tdiscriminant specification as the associated_node_for_itype, to\n\tsimplify accessibility checks.\n\nFrom-SVN: r111091", "tree": {"sha": "3ecf2b18b07d04d5c8637ab49fd55ce77b652b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ecf2b18b07d04d5c8637ab49fd55ce77b652b8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57193e09243103515c50b2b433ddb15a90d311b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57193e09243103515c50b2b433ddb15a90d311b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57193e09243103515c50b2b433ddb15a90d311b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57193e09243103515c50b2b433ddb15a90d311b7/comments", "author": null, "committer": null, "parents": [{"sha": "561d9139e3ba1195a41f7fa0c55352dec96a0991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561d9139e3ba1195a41f7fa0c55352dec96a0991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561d9139e3ba1195a41f7fa0c55352dec96a0991"}], "stats": {"total": 1031, "additions": 670, "deletions": 361}, "files": [{"sha": "ba3cc95d9c49864b6136abc376fcf7e043170caf", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 106, "deletions": 101, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=57193e09243103515c50b2b433ddb15a90d311b7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1351,6 +1351,7 @@ package body Sem_Ch12 is\n              Subtype_Indication            => Subtype_Mark (Def));\n \n          Set_Abstract_Present (New_N, Abstract_Present (Def));\n+         Set_Limited_Present  (New_N, Limited_Present  (Def));\n \n       else\n          New_N :=\n@@ -1364,6 +1365,8 @@ package body Sem_Ch12 is\n \n          Set_Abstract_Present\n            (Type_Definition (New_N), Abstract_Present (Def));\n+         Set_Limited_Present\n+           (Type_Definition (New_N), Limited_Present (Def));\n       end if;\n \n       Rewrite (N, New_N);\n@@ -1894,7 +1897,7 @@ package body Sem_Ch12 is\n             Ctrl_Type : constant Entity_Id := Find_Dispatching_Type (Nam);\n \n          begin\n-            if not Present (Ctrl_Type) then\n+            if No (Ctrl_Type) then\n                Error_Msg_N\n                  (\"abstract formal subprogram must have a controlling type\",\n                   N);\n@@ -3030,9 +3033,13 @@ package body Sem_Ch12 is\n                        Cunit_Entity (Current_Sem_Unit);\n       Removed      : Boolean := False;\n       Num_Scopes   : Int := 0;\n-      Use_Clauses  : array (1 .. Scope_Stack.Last) of Node_Id;\n-      Instances    : array (1 .. Scope_Stack.Last) of Entity_Id;\n-      Inner_Scopes : array (1 .. Scope_Stack.Last) of Entity_Id;\n+\n+      Scope_Stack_Depth : constant Int :=\n+                            Scope_Stack.Last - Scope_Stack.First + 1;\n+\n+      Use_Clauses  : array (1 .. Scope_Stack_Depth) of Node_Id;\n+      Instances    : array (1 .. Scope_Stack_Depth) of Entity_Id;\n+      Inner_Scopes : array (1 .. Scope_Stack_Depth) of Entity_Id;\n       Num_Inner    : Int := 0;\n       N_Instances  : Int := 0;\n       S            : Entity_Id;\n@@ -6568,16 +6575,23 @@ package body Sem_Ch12 is\n       --  because each actual has the same name as the formal, and they do\n       --  appear in the same order.\n \n-      function Formal_Entity\n-        (F       : Node_Id;\n-         Act_Ent : Entity_Id) return Entity_Id;\n-      --  Returns the entity associated with the given formal F. In the\n-      --  case where F is a formal package, this function will iterate\n-      --  through all of F's formals and enter map associations from the\n+      function Get_Formal_Entity (N : Node_Id) return Entity_Id;\n+      --  Retrieve entity of defining entity of  generic formal parameter.\n+      --  Only the declarations of formals need to be considered when\n+      --  linking them to actuals, but the declarative list may include\n+      --  internal entities generated during analysis, and those are ignored.\n+\n+      procedure Match_Formal_Entity\n+        (Formal_Node : Node_Id;\n+         Formal_Ent  : Entity_Id;\n+         Actual_Ent  : Entity_Id);\n+      --  Associates the formal entity with the actual. In the case\n+      --  where Formal_Ent is a formal package, this procedure iterates\n+      --  through all of its formals and enters associations betwen the\n       --  actuals occurring in the formal package's corresponding actual\n-      --  package (obtained via Act_Ent) to the formal package's formal\n-      --  parameters. This function is called recursively for arbitrary\n-      --  levels of formal packages.\n+      --  package (given by Actual_Ent) and the formal package's formal\n+      --  parameters. This procedure recurses if any of the parameters is\n+      --  itself a package.\n \n       function Is_Instance_Of\n         (Act_Spec : Entity_Id;\n@@ -6641,118 +6655,109 @@ package body Sem_Ch12 is\n          end case;\n       end Find_Matching_Actual;\n \n-      -------------------\n-      -- Formal_Entity --\n-      -------------------\n+      -------------------------\n+      -- Match_Formal_Entity --\n+      -------------------------\n \n-      function Formal_Entity\n-        (F       : Node_Id;\n-         Act_Ent : Entity_Id) return Entity_Id\n+      procedure Match_Formal_Entity\n+        (Formal_Node : Node_Id;\n+         Formal_Ent  : Entity_Id;\n+         Actual_Ent  : Entity_Id)\n       is\n-         Orig_Node : Node_Id := F;\n          Act_Pkg   : Entity_Id;\n \n       begin\n-         case Nkind (Original_Node (F)) is\n-            when N_Formal_Object_Declaration     =>\n-               return Defining_Identifier (F);\n+         Set_Instance_Of (Formal_Ent, Actual_Ent);\n \n-            when N_Formal_Type_Declaration       =>\n-               return Defining_Identifier (F);\n+         if Ekind (Actual_Ent) = E_Package then\n+            --  Record associations for each parameter\n \n-            when N_Formal_Subprogram_Declaration =>\n-               return Defining_Unit_Name (Specification (F));\n+            Act_Pkg := Actual_Ent;\n \n-            when N_Package_Declaration           =>\n-               return Defining_Unit_Name (Specification (F));\n+            declare\n+               A_Ent  : Entity_Id := First_Entity (Act_Pkg);\n+               F_Ent  : Entity_Id;\n+               F_Node : Node_Id;\n \n-            when N_Formal_Package_Declaration |\n-                 N_Generic_Package_Declaration   =>\n+               Gen_Decl : Node_Id;\n+               Formals  : List_Id;\n+               Actual   : Entity_Id;\n \n-               if Nkind (F) = N_Generic_Package_Declaration then\n-                  Orig_Node := Original_Node (F);\n-               end if;\n+            begin\n+               --  Retrieve the actual given in the formal package declaration\n \n-               Act_Pkg := Act_Ent;\n+               Actual := Entity (Name (Original_Node (Formal_Node)));\n \n-               --  Find matching actual package, skipping over itypes and\n-               --  other entities generated when analyzing the formal. We\n-               --  know that if the instantiation is legal then there is\n-               --  a matching package for the formal.\n+               --  The actual in the formal package declaration  may be a\n+               --  renamed generic package, in which case we want to retrieve\n+               --  the original generic in order to traverse its formal part.\n \n-               while Ekind (Act_Pkg) /= E_Package loop\n-                  Act_Pkg := Next_Entity (Act_Pkg);\n-               end loop;\n+               if Present (Renamed_Entity (Actual)) then\n+                  Gen_Decl := Unit_Declaration_Node (Renamed_Entity (Actual));\n+               else\n+                  Gen_Decl := Unit_Declaration_Node (Actual);\n+               end if;\n \n-               declare\n-                  Actual_Ent  : Entity_Id := First_Entity (Act_Pkg);\n-                  Formal_Node : Node_Id;\n-                  Formal_Ent  : Entity_Id;\n+               Formals := Generic_Formal_Declarations (Gen_Decl);\n \n-                  Gen_Decl : Node_Id;\n-                  Formals  : List_Id;\n+               if Present (Formals) then\n+                  F_Node := First_Non_Pragma (Formals);\n+               else\n+                  F_Node := Empty;\n+               end if;\n \n-               begin\n-                  --  The actual may be a renamed generic package, in which\n-                  --  case we want to retrieve the original generic in order\n-                  --  to traverse its formal part.\n-\n-                  if Present (Renamed_Entity (Entity (Name (Orig_Node)))) then\n-                     Gen_Decl :=\n-                       Unit_Declaration_Node (\n-                         Renamed_Entity (Entity (Name (Orig_Node))));\n-                  else\n-                     Gen_Decl :=\n-                        Unit_Declaration_Node (Entity (Name (Orig_Node)));\n-                  end if;\n+               while Present (A_Ent)\n+                 and then Present (F_Node)\n+                 and then A_Ent /= First_Private_Entity (Act_Pkg)\n+               loop\n+                  F_Ent := Get_Formal_Entity (F_Node);\n \n-                  Formals := Generic_Formal_Declarations (Gen_Decl);\n+                  if Present (F_Ent) then\n \n-                  if Present (Formals) then\n-                     Formal_Node := First_Non_Pragma (Formals);\n-                  else\n-                     Formal_Node := Empty;\n+                     --  This is a formal of the original package. Record\n+                     --  association and recurse.\n+\n+                     Find_Matching_Actual (F_Node, A_Ent);\n+                     Match_Formal_Entity (F_Node, F_Ent, A_Ent);\n+                     Next_Entity (A_Ent);\n                   end if;\n \n-                  while Present (Actual_Ent)\n-                    and then Present (Formal_Node)\n-                    and then Actual_Ent /= First_Private_Entity (Act_Pkg)\n-                  loop\n-                     --  ???  Are the following calls also needed here:\n-                     --\n-                     --  Set_Is_Hidden (Actual_Ent, False);\n-                     --  Set_Is_Potentially_Use_Visible\n-                     --    (Actual_Ent, In_Use (Act_Ent));\n+                  Next_Non_Pragma (F_Node);\n+               end loop;\n+            end;\n+         end if;\n+      end Match_Formal_Entity;\n \n-                     Formal_Ent := Formal_Entity (Formal_Node, Actual_Ent);\n-                     if Present (Formal_Ent) then\n-                        Set_Instance_Of (Formal_Ent, Actual_Ent);\n-                     end if;\n-                     Next_Non_Pragma (Formal_Node);\n+      -----------------------\n+      -- Get_Formal_Entity --\n+      -----------------------\n \n-                     Next_Entity (Actual_Ent);\n-                  end loop;\n-               end;\n+      function Get_Formal_Entity (N : Node_Id) return Entity_Id is\n+         Kind : constant Node_Kind := Nkind (Original_Node (N));\n+      begin\n+         case Kind is\n+            when N_Formal_Object_Declaration     =>\n+               return Defining_Identifier (N);\n+\n+            when N_Formal_Type_Declaration       =>\n+               return Defining_Identifier (N);\n \n-               return Defining_Identifier (Orig_Node);\n+            when N_Formal_Subprogram_Declaration =>\n+               return Defining_Unit_Name (Specification (N));\n \n-            when N_Use_Package_Clause =>\n-               return Empty;\n+            when N_Formal_Package_Declaration    =>\n+               return Defining_Identifier (Original_Node (N));\n \n-            when N_Use_Type_Clause =>\n-               return Empty;\n+            when N_Generic_Package_Declaration   =>\n+               return Defining_Identifier (Original_Node (N));\n \n-            --  We return Empty for all other encountered forms of\n-            --  declarations because there are some cases of nonformal\n-            --  sorts of declaration that can show up (e.g., when array\n-            --  formals are present). Since it's not clear what kinds\n-            --  can appear among the formals, we won't raise failure here.\n+            --  All other declarations are introduced by semantic analysis\n+            --  and have no match in the actual.\n \n-            when others =>\n+            when others                          =>\n                return Empty;\n-\n          end case;\n-      end Formal_Entity;\n+      end Get_Formal_Entity;\n \n       --------------------\n       -- Is_Instance_Of --\n@@ -6987,11 +6992,12 @@ package body Sem_Ch12 is\n                   end if;\n \n                   if Present (Formal_Node) then\n-                     Formal_Ent := Formal_Entity (Formal_Node, Actual_Ent);\n+                     Formal_Ent := Get_Formal_Entity (Formal_Node);\n \n                      if Present (Formal_Ent) then\n                         Find_Matching_Actual (Formal_Node, Actual_Ent);\n-                        Set_Instance_Of (Formal_Ent, Actual_Ent);\n+                        Match_Formal_Entity\n+                          (Formal_Node, Formal_Ent, Actual_Ent);\n                      end if;\n \n                      Next_Non_Pragma (Formal_Node);\n@@ -8529,7 +8535,7 @@ package body Sem_Ch12 is\n                  and then Present (Ancestor_Discr)\n                loop\n                   if Base_Type (Act_T) /= Base_Type (Ancestor) and then\n-                    not Present (Corresponding_Discriminant (Actual_Discr))\n+                    No (Corresponding_Discriminant (Actual_Discr))\n                   then\n                      Error_Msg_NE\n                        (\"discriminant & does not correspond \" &\n@@ -10444,7 +10450,6 @@ package body Sem_Ch12 is\n           (Fname => Unit_File_Name (Get_Source_Unit (Gen_Unit)),\n            Renamings_Included => True) then\n          Ada_Version := Ada_Version_Type'Last;\n-         Ada_Version_Explicit := Ada_Version_Explicit_Config;\n       end if;\n \n       Current_Instantiated_Parent := (Gen_Unit, Act_Unit, Assoc_Null);"}, {"sha": "7d706ce71f89c17de79a0d4ee34fdbacdbd8a454", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 455, "deletions": 190, "changes": 645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=57193e09243103515c50b2b433ddb15a90d311b7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -658,10 +658,10 @@ package body Sem_Ch3 is\n      (Def_Id : Entity_Id;\n       R      : Node_Id;\n       Subt   : Entity_Id);\n-   --  This routine is used to set the scalar range field for a subtype\n-   --  given Def_Id, the entity for the subtype, and R, the range expression\n-   --  for the scalar range. Subt provides the parent subtype to be used\n-   --  to analyze, resolve, and check the given range.\n+   --  This routine is used to set the scalar range field for a subtype given\n+   --  Def_Id, the entity for the subtype, and R, the range expression for the\n+   --  scalar range. Subt provides the parent subtype to be used to analyze,\n+   --  resolve, and check the given range.\n \n    procedure Signed_Integer_Type_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Create a new signed integer entity, and apply the constraint to obtain\n@@ -680,9 +680,7 @@ package body Sem_Ch3 is\n      (Related_Nod : Node_Id;\n       N           : Node_Id) return Entity_Id\n    is\n-      Anon_Type : constant Entity_Id :=\n-                    Create_Itype (E_Anonymous_Access_Type, Related_Nod,\n-                                  Scope_Id => Scope (Current_Scope));\n+      Anon_Type  : Entity_Id;\n       Desig_Type : Entity_Id;\n \n    begin\n@@ -692,16 +690,14 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"task entries cannot have access parameters\", N);\n       end if;\n \n-      --  Ada 2005: for an object declaration or function with an anonymous\n-      --  access result, the corresponding anonymous type is declared in the\n-      --  current scope. For access formals, access components, and access\n-      --  discriminants, the scope is that of the enclosing declaration,\n-      --  as set above. This special-case handling of resetting the scope\n-      --  is awkward, and it might be better to pass in the required scope\n-      --  as a parameter. ???\n+      --  Ada 2005: for an object declaration the corresponding anonymous\n+      --  type is declared in the current scope.\n \n       if Nkind (Related_Nod) = N_Object_Declaration then\n-         Set_Scope (Anon_Type, Current_Scope);\n+         Anon_Type :=\n+           Create_Itype\n+            (E_Anonymous_Access_Type, Related_Nod,\n+               Scope_Id => Current_Scope);\n \n       --  For the anonymous function result case, retrieve the scope of\n       --  the function specification's associated entity rather than using\n@@ -713,7 +709,19 @@ package body Sem_Ch3 is\n       elsif Nkind (Related_Nod) = N_Function_Specification\n          and then Nkind (Parent (N)) /= N_Parameter_Specification\n       then\n-         Set_Scope (Anon_Type, Scope (Defining_Unit_Name (Related_Nod)));\n+         Anon_Type :=\n+           Create_Itype\n+            (E_Anonymous_Access_Type, Related_Nod,\n+               Scope_Id => Scope (Defining_Unit_Name (Related_Nod)));\n+\n+      else\n+         --  For access formals, access components, and access\n+         --  discriminants, the scope is that of the enclosing declaration,\n+\n+         Anon_Type :=\n+           Create_Itype\n+            (E_Anonymous_Access_Type, Related_Nod,\n+               Scope_Id => Scope (Current_Scope));\n       end if;\n \n       if All_Present (N)\n@@ -1081,9 +1089,10 @@ package body Sem_Ch3 is\n       -------------\n \n       procedure Add_Tag (Iface : Entity_Id) is\n-         Def      : Node_Id;\n-         Tag      : Entity_Id;\n-         Decl     : Node_Id;\n+         Decl   : Node_Id;\n+         Def    : Node_Id;\n+         Tag    : Entity_Id;\n+         Offset : Entity_Id;\n \n       begin\n          pragma Assert (Is_Tagged_Type (Iface)\n@@ -1115,21 +1124,52 @@ package body Sem_Ch3 is\n          Set_DT_Entry_Count    (Tag,\n            DT_Entry_Count (First_Entity (Iface)));\n \n-         if not Present (Last_Tag) then\n+         if No (Last_Tag) then\n             Prepend (Decl, L);\n          else\n             Insert_After (Last_Tag, Decl);\n          end if;\n \n          Last_Tag := Decl;\n+\n+         --  If the ancestor has discriminants we need to give special support\n+         --  to store the offset_to_top value of the secondary dispatch tables.\n+         --  For this purpose we add a supplementary component just after the\n+         --  field that contains the tag associated with each secondary DT.\n+\n+         if Typ /= Etype (Typ)\n+           and then Has_Discriminants (Etype (Typ))\n+         then\n+            Def :=\n+              Make_Component_Definition (Loc,\n+                Subtype_Indication =>\n+                  New_Occurrence_Of (RTE (RE_Storage_Offset), Loc));\n+\n+            Offset :=\n+              Make_Defining_Identifier (Loc, New_Internal_Name ('V'));\n+\n+            Decl :=\n+              Make_Component_Declaration (Loc,\n+                Defining_Identifier  => Offset,\n+                Component_Definition => Def);\n+\n+            Analyze_Component_Declaration (Decl);\n+\n+            Set_Analyzed (Decl);\n+            Set_Ekind               (Offset, E_Component);\n+            Init_Component_Location (Offset);\n+            Insert_After (Last_Tag, Decl);\n+            Last_Tag := Decl;\n+         end if;\n       end Add_Tag;\n \n    --  Start of processing for Add_Interface_Tag_Components\n \n    begin\n       if Ekind (Typ) /= E_Record_Type\n-        or else not Present (Abstract_Interfaces (Typ))\n+        or else No (Abstract_Interfaces (Typ))\n         or else Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+        or else not RTE_Available (RE_Interface_Tag)\n       then\n          return;\n       end if;\n@@ -1207,6 +1247,13 @@ package body Sem_Ch3 is\n       --  Determines whether a constraint uses the discriminant of a record\n       --  type thus becoming a per-object constraint (POC).\n \n+      function Is_Known_Limited (Typ : Entity_Id) return Boolean;\n+      --  Check whether enclosing record is limited, to validate declaration\n+      --  of components with limited types.\n+      --  This seems a wrong description to me???\n+      --  What is Typ? For sure it can return a result without checking\n+      --  the enclosing record (enclosing what???)\n+\n       ------------------\n       -- Contains_POC --\n       ------------------\n@@ -1259,6 +1306,41 @@ package body Sem_Ch3 is\n          end case;\n       end Contains_POC;\n \n+      ----------------------\n+      -- Is_Known_Limited --\n+      ----------------------\n+\n+      function Is_Known_Limited (Typ : Entity_Id) return Boolean is\n+         P : constant Entity_Id := Etype (Typ);\n+         R : constant Entity_Id := Root_Type (Typ);\n+\n+      begin\n+         if Is_Limited_Record (Typ) then\n+            return True;\n+\n+         --  If the root type is limited (and not a limited interface)\n+         --  so is the current type\n+\n+         elsif Is_Limited_Record (R)\n+           and then\n+             (not Is_Interface (R)\n+               or else not Is_Limited_Interface (R))\n+         then\n+            return True;\n+\n+         --  Else the type may have a limited interface progenitor, but a\n+         --  limited record parent.\n+\n+         elsif R /= P\n+           and then Is_Limited_Record (P)\n+         then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_Known_Limited;\n+\n    --  Start of processing for Analyze_Component_Declaration\n \n    begin\n@@ -1321,6 +1403,40 @@ package body Sem_Ch3 is\n       if Present (Expression (N)) then\n          Analyze_Per_Use_Expression (Expression (N), T);\n          Check_Initialization (T, Expression (N));\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Access_Type (T)\n+           and then Ekind (T) = E_Anonymous_Access_Type\n+         then\n+            --  Check RM 3.9.2(9): \"if the expected type for an expression is\n+            --  an anonymous access-to-specific tagged type, then the object\n+            --  designated by the expression shall not be dynamically tagged\n+            --  unless it is a controlling operand in a call on a dispatching\n+            --  operation\"\n+\n+            if Is_Tagged_Type (Directly_Designated_Type (T))\n+              and then\n+                Ekind (Directly_Designated_Type (T)) /= E_Class_Wide_Type\n+              and then\n+                Ekind (Directly_Designated_Type (Etype (Expression (N)))) =\n+                                                        E_Class_Wide_Type\n+            then\n+               Error_Msg_N\n+                 (\"access to specific tagged type required ('R'M 3.9.2(9))\",\n+                  Expression (N));\n+            end if;\n+\n+            --  (Ada 2005: AI-230): Accessibility check for anonymous\n+            --  components\n+\n+            if Type_Access_Level (Etype (Expression (N))) >\n+               Type_Access_Level (T)\n+            then\n+               Error_Msg_N\n+                 (\"expression has deeper access level than component \" &\n+                  \"('R'M 3.10.2 (12.2))\", Expression (N));\n+            end if;\n+         end if;\n       end if;\n \n       --  The parent type may be a private view with unknown discriminants,\n@@ -1406,11 +1522,19 @@ package body Sem_Ch3 is\n         and then Is_Tagged_Type (Current_Scope)\n       then\n          if Is_Derived_Type (Current_Scope)\n-           and then not Is_Limited_Record (Root_Type (Current_Scope))\n+           and then not Is_Known_Limited (Current_Scope)\n          then\n             Error_Msg_N\n               (\"extension of nonlimited type cannot have limited components\",\n                N);\n+\n+            if Is_Interface (Root_Type (Current_Scope)) then\n+               Error_Msg_N\n+                 (\"\\limitedness is not inherited from limited interface\", N);\n+               Error_Msg_N\n+                 (\"\\add LIMITED to type indication\", N);\n+            end if;\n+\n             Explain_Limited_Type (T, N);\n             Set_Etype (Id, Any_Type);\n             Set_Is_Limited_Composite (Current_Scope, False);\n@@ -2067,7 +2191,7 @@ package body Sem_Ch3 is\n          --  In case of errors detected in the analysis of the expression,\n          --  decorate it with the expected type to avoid cascade errors\n \n-         if not Present (Etype (E)) then\n+         if No (Etype (E)) then\n             Set_Etype (E, T);\n          end if;\n \n@@ -2660,7 +2784,11 @@ package body Sem_Ch3 is\n       if Limited_Present (N) then\n          Set_Is_Limited_Record (T);\n \n-         if not Is_Limited_Type (Parent_Type) then\n+         if not Is_Limited_Type (Parent_Type)\n+           and then\n+             (not Is_Interface (Parent_Type)\n+               or else  not Is_Limited_Interface (Parent_Type))\n+         then\n             Error_Msg_NE (\"parent type& of limited extension must be limited\",\n               N, Parent_Type);\n          end if;\n@@ -5332,7 +5460,6 @@ package body Sem_Ch3 is\n       Constraint_Present     : Boolean;\n       Has_Interfaces         : Boolean := False;\n       Inherit_Discrims       : Boolean := False;\n-      Last_Inherited_Prim_Op : Elmt_Id;\n       Tagged_Partial_View    : Entity_Id;\n       Save_Etype             : Entity_Id;\n       Save_Discr_Constr      : Elist_Id;\n@@ -5768,7 +5895,7 @@ package body Sem_Ch3 is\n             Discrim := First_Discriminant (Derived_Type);\n             while Present (Discrim) loop\n                if not Is_Tagged\n-                 and then not Present (Corresponding_Discriminant (Discrim))\n+                 and then No (Corresponding_Discriminant (Discrim))\n                then\n                   Error_Msg_N\n                     (\"new discriminants must constrain old ones\", Discrim);\n@@ -6006,40 +6133,6 @@ package body Sem_Ch3 is\n             else\n                Collect_Interfaces (Type_Definition (N), Derived_Type);\n             end if;\n-\n-            --  Ada 2005 (AI-251): The progenitor types specified in a private\n-            --  extension declaration and the progenitor types specified in the\n-            --  corresponding declaration of a record extension given in the\n-            --  private part need not be the same; the only requirement is that\n-            --  the private extension must be descended from each interface\n-            --  from which the record extension is descended (AARM 7.3, 20.1/2)\n-\n-            if Has_Private_Declaration (Derived_Type) then\n-               declare\n-                  N_Partial : constant Node_Id := Parent (Tagged_Partial_View);\n-                  Iface_Partial : Entity_Id;\n-\n-               begin\n-                  if Nkind (N_Partial) = N_Private_Extension_Declaration\n-                    and then not Is_Empty_List (Interface_List (N_Partial))\n-                  then\n-                     Iface_Partial := First (Interface_List (N_Partial));\n-\n-                     while Present (Iface_Partial) loop\n-                        if not Interface_Present_In_Ancestor\n-                                 (Derived_Type, Etype (Iface_Partial))\n-                        then\n-                           Error_Msg_N\n-                             (\"(Ada 2005) full type and private extension must\"\n-                              & \" have the same progenitors\", Derived_Type);\n-                           exit;\n-                        end if;\n-\n-                        Next (Iface_Partial);\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n          end if;\n \n       else\n@@ -6060,8 +6153,9 @@ package body Sem_Ch3 is\n          Constrs := Discriminant_Constraint (Parent_Type);\n       end if;\n \n-      Assoc_List := Inherit_Components (N,\n-        Parent_Base, Derived_Type, Is_Tagged, Inherit_Discrims, Constrs);\n+      Assoc_List :=\n+        Inherit_Components\n+          (N, Parent_Base, Derived_Type, Is_Tagged, Inherit_Discrims, Constrs);\n \n       --  STEP 5a: Copy the parent record declaration for untagged types\n \n@@ -6208,116 +6302,103 @@ package body Sem_Ch3 is\n             end;\n          end if;\n \n-         --  Ada 2005 (AI-251): Keep separate the management of tagged types\n-         --  implementing interfaces\n+         Derive_Subprograms (Parent_Type, Derived_Type);\n+\n+         --  Ada 2005 (AI-251): Handle tagged types implementing interfaces\n \n-         if not Is_Tagged_Type (Derived_Type)\n-           or else not Has_Interfaces\n+         if Is_Tagged_Type (Derived_Type)\n+           and then Has_Interfaces\n          then\n-            Derive_Subprograms (Parent_Type, Derived_Type);\n+            --  Ada 2005 (AI-251): If we are analyzing a full view that has\n+            --  no partial view we derive the abstract interface Subprograms\n \n-         else\n-            --  Ada 2005 (AI-251): Complete the decoration of tagged private\n-            --  types that implement interfaces\n+            if No (Tagged_Partial_View) then\n+               Derive_Interface_Subprograms (Derived_Type);\n \n-            if Present (Tagged_Partial_View) then\n-               Derive_Subprograms\n-                 (Parent_Type, Derived_Type);\n+            --  Ada 2005 (AI-251): if we are analyzing a full view that has\n+            --  a partial view we complete the derivation of the subprograms\n \n+            else\n                Complete_Subprograms_Derivation\n                  (Partial_View => Tagged_Partial_View,\n                   Derived_Type => Derived_Type);\n+            end if;\n \n-            --  Ada 2005 (AI-251): Derive the interface subprograms of all the\n-            --  implemented interfaces and check if some of the subprograms\n-            --  inherited from the ancestor cover some interface subprogram.\n+            --  Ada 2005 (AI-251): In both cases we check if some of the\n+            --  inherited subprograms cover interface primitives.\n \n-            else\n-               Derive_Subprograms (Parent_Type, Derived_Type);\n+            declare\n+               Iface_Subp      : Entity_Id;\n+               Iface_Subp_Elmt : Elmt_Id;\n+               Prev_Alias      : Entity_Id;\n+               Subp            : Entity_Id;\n+               Subp_Elmt       : Elmt_Id;\n \n-               declare\n-                  Subp_Elmt         : Elmt_Id;\n-                  First_Iface_Elmt  : Elmt_Id;\n-                  Iface_Subp_Elmt   : Elmt_Id;\n-                  Subp              : Entity_Id;\n-                  Iface_Subp        : Entity_Id;\n-                  Is_Interface_Subp : Boolean;\n+            begin\n+               Iface_Subp_Elmt :=\n+                 First_Elmt (Primitive_Operations (Derived_Type));\n+               while Present (Iface_Subp_Elmt) loop\n+                  Iface_Subp := Node (Iface_Subp_Elmt);\n+\n+                  --  Look for an abstract interface subprogram\n+\n+                  if Is_Abstract (Iface_Subp)\n+                    and then Present (Alias (Iface_Subp))\n+                    and then Present (DTC_Entity (Alias (Iface_Subp)))\n+                    and then Is_Interface\n+                               (Scope (DTC_Entity (Alias (Iface_Subp))))\n+                  then\n+                     --  Look for candidate primitive subprograms of the tagged\n+                     --  type that can cover this interface subprogram.\n \n-               begin\n-                  --  Ada 2005 (AI-251): Remember the entity corresponding to\n-                  --  the last inherited primitive operation. This is required\n-                  --  to check if some of the inherited subprograms covers some\n-                  --  of the new interfaces.\n-\n-                  Last_Inherited_Prim_Op := No_Elmt;\n-\n-                  Subp_Elmt :=\n-                    First_Elmt (Primitive_Operations (Derived_Type));\n-                  while Present (Subp_Elmt) loop\n-                     Last_Inherited_Prim_Op := Subp_Elmt;\n-                     Next_Elmt (Subp_Elmt);\n-                  end loop;\n+                     Subp_Elmt :=\n+                       First_Elmt (Primitive_Operations (Derived_Type));\n+                     while Present (Subp_Elmt) loop\n+                        Subp := Node (Subp_Elmt);\n \n-                  --  Ada 2005 (AI-251): Derive subprograms in abstract\n-                  --  interfaces.\n+                        if not Is_Abstract (Subp)\n+                          and then Chars (Subp) = Chars (Iface_Subp)\n+                          and then Type_Conformant (Iface_Subp, Subp)\n+                        then\n+                           Prev_Alias := Alias (Iface_Subp);\n \n-                  Derive_Interface_Subprograms (Derived_Type);\n-\n-                  --  Ada 2005 (AI-251): Check if some of the inherited\n-                  --  subprograms cover some of the new interfaces.\n-\n-                  if Present (Last_Inherited_Prim_Op) then\n-                     First_Iface_Elmt := Next_Elmt (Last_Inherited_Prim_Op);\n-                     Iface_Subp_Elmt  := First_Iface_Elmt;\n-                     while Present (Iface_Subp_Elmt) loop\n-                        Subp_Elmt := First_Elmt (Primitive_Operations\n-                                                  (Derived_Type));\n-                        while Subp_Elmt /= First_Iface_Elmt loop\n-                           Subp       := Node (Subp_Elmt);\n-                           Iface_Subp := Node (Iface_Subp_Elmt);\n-\n-                           Is_Interface_Subp :=\n-                             Present (Alias (Subp))\n-                               and then Present (DTC_Entity (Alias (Subp)))\n-                               and then Is_Interface (Scope\n-                                                      (DTC_Entity\n-                                                       (Alias (Subp))));\n-\n-                           if Chars (Subp) = Chars (Iface_Subp)\n-                             and then not Is_Interface_Subp\n-                             and then not Is_Abstract (Subp)\n-                             and then Type_Conformant (Iface_Subp, Subp)\n-                           then\n-                              Check_Dispatching_Operation\n-                                (Subp     => Subp,\n-                                 Old_Subp => Iface_Subp);\n-\n-                              --  Traverse the list of aliased subprograms\n-\n-                              declare\n-                                 E : Entity_Id;\n-\n-                              begin\n-                                 E := Alias (Subp);\n-                                 while Present (Alias (E)) loop\n-                                    E := Alias (E);\n-                                 end loop;\n-\n-                                 Set_Alias (Subp, E);\n-                              end;\n-\n-                              Set_Has_Delayed_Freeze (Subp);\n-                              exit;\n-                           end if;\n-\n-                           Next_Elmt (Subp_Elmt);\n-                        end loop;\n+                           Check_Dispatching_Operation\n+                             (Subp     => Subp,\n+                              Old_Subp => Iface_Subp);\n+\n+                           pragma Assert\n+                             (Alias (Iface_Subp) = Subp);\n+                           pragma Assert\n+                             (Abstract_Interface_Alias (Iface_Subp)\n+                               = Prev_Alias);\n+\n+                           --  Traverse the list of aliased subprograms to link\n+                           --  subp with its ultimate aliased subprogram. This\n+                           --  avoids problems with the backend.\n+\n+                           declare\n+                              E : Entity_Id;\n+\n+                           begin\n+                              E := Alias (Subp);\n+                              while Present (Alias (E)) loop\n+                                 E := Alias (E);\n+                              end loop;\n+\n+                              Set_Alias (Subp, E);\n+                           end;\n \n-                        Next_Elmt (Iface_Subp_Elmt);\n+                           Set_Has_Delayed_Freeze (Subp);\n+                           exit;\n+                        end if;\n+\n+                        Next_Elmt (Subp_Elmt);\n                      end loop;\n                   end if;\n-               end;\n-            end if;\n+\n+                  Next_Elmt (Iface_Subp_Elmt);\n+               end loop;\n+            end;\n          end if;\n       end if;\n \n@@ -7092,10 +7173,11 @@ package body Sem_Ch3 is\n    -------------------------------\n \n    procedure Check_Abstract_Overriding (T : Entity_Id) is\n-      Op_List  : Elist_Id;\n-      Elmt     : Elmt_Id;\n-      Subp     : Entity_Id;\n-      Type_Def : Node_Id;\n+      Op_List    : Elist_Id;\n+      Elmt       : Elmt_Id;\n+      Subp       : Entity_Id;\n+      Alias_Subp : Entity_Id;\n+      Type_Def   : Node_Id;\n \n    begin\n       Op_List := Primitive_Operations (T);\n@@ -7105,13 +7187,22 @@ package body Sem_Ch3 is\n       Elmt := First_Elmt (Op_List);\n       while Present (Elmt) loop\n          Subp := Node (Elmt);\n+         Alias_Subp := Alias (Subp);\n+\n+         --  Inherited subprograms are identified by the fact that they do not\n+         --  come from source, and the associated source location is the\n+         --  location of the first subtype of the derived type.\n \n          --  Special exception, do not complain about failure to override the\n          --  stream routines _Input and _Output, as well as the primitive\n          --  operations used in dispatching selects since we always provide\n          --  automatic overridings for these subprograms.\n \n-         if Is_Abstract (Subp)\n+         if (Is_Abstract (Subp)\n+               or else (Has_Controlling_Result (Subp)\n+                         and then Present (Alias_Subp)\n+                         and then not Comes_From_Source (Subp)\n+                         and then Sloc (Subp) = Sloc (First_Subtype (T))))\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract (T)\n@@ -7120,31 +7211,44 @@ package body Sem_Ch3 is\n            and then Chars (Subp) /= Name_uDisp_Get_Prim_Op_Kind\n            and then Chars (Subp) /= Name_uDisp_Timed_Select\n          then\n-            if Present (Alias (Subp)) then\n-\n-               --  Only perform the check for a derived subprogram when\n-               --  the type has an explicit record extension. This avoids\n-               --  incorrectly flagging abstract subprograms for the case\n-               --  of a type without an extension derived from a formal type\n-               --  with a tagged actual (can occur within a private part).\n+            if Present (Alias_Subp) then\n+\n+               --  Only perform the check for a derived subprogram when the\n+               --  type has an explicit record extension. This avoids\n+               --  incorrectly flagging abstract subprograms for the case of a\n+               --  type without an extension derived from a formal type with a\n+               --  tagged actual (can occur within a private part).\n+\n+               --  Ada 2005 (AI-391): In the case of an inherited function with\n+               --  a controlling result of the type, the rule does not apply if\n+               --  the type is a null extension (unless the parent function\n+               --  itself is abstract, in which case the function must still be\n+               --  be overridden). The expander will generate an overriding\n+               --  wrapper function calling the parent subprogram (see\n+               --  Exp_Ch3.Make_Controlling_Wrapper_Functions).\n \n                Type_Def := Type_Definition (Parent (T));\n                if Nkind (Type_Def) = N_Derived_Type_Definition\n                  and then Present (Record_Extension_Part (Type_Def))\n+                 and then\n+                   (Ada_Version < Ada_05\n+                      or else not Is_Null_Extension (T)\n+                      or else Ekind (Subp) = E_Procedure\n+                      or else not Has_Controlling_Result (Subp)\n+                      or else Is_Abstract (Alias_Subp)\n+                      or else Is_Access_Type (Etype (Subp)))\n                then\n                   Error_Msg_NE\n                     (\"type must be declared abstract or & overridden\",\n                      T, Subp);\n \n                   --  Traverse the whole chain of aliased subprograms to\n-                  --  complete the error notification. This is useful for\n-                  --  traceability of the chain of entities when the subprogram\n-                  --  corresponds with interface subprogram (that may be\n-                  --  defined in another package)\n+                  --  complete the error notification. This is especially\n+                  --  useful for traceability of the chain of entities when the\n+                  --  subprogram corresponds with an interface subprogram\n+                  --  (which might be defined in another package)\n \n-                  if Ada_Version >= Ada_05\n-                    and then Present (Alias (Subp))\n-                  then\n+                  if Present (Alias_Subp) then\n                      declare\n                         E : Entity_Id;\n \n@@ -7657,7 +7761,7 @@ package body Sem_Ch3 is\n             Next_Elmt (Elmt);\n          end loop;\n \n-         if not Present (Elmt) then\n+         if No (Elmt) then\n             Append_Elmt (Node => Iface,\n                          To   => Abstract_Interfaces (Derived_Type));\n          end if;\n@@ -8018,13 +8122,62 @@ package body Sem_Ch3 is\n       Obj_Def : constant Node_Id := Object_Definition (N);\n       New_T   : Entity_Id;\n \n+      procedure Check_Possible_Deferred_Completion\n+        (Prev_Id      : Entity_Id;\n+         Prev_Obj_Def : Node_Id;\n+         Curr_Obj_Def : Node_Id);\n+      --  Determine whether the two object definitions describe the partial\n+      --  and the full view of a constrained deferred constant. Generate\n+      --  a subtype for the full view and verify that it statically matches\n+      --  the subtype of the partial view.\n+\n       procedure Check_Recursive_Declaration (Typ : Entity_Id);\n       --  If deferred constant is an access type initialized with an allocator,\n       --  check whether there is an illegal recursion in the definition,\n       --  through a default value of some record subcomponent. This is normally\n       --  detected when generating init procs, but requires this additional\n       --  mechanism when expansion is disabled.\n \n+      ----------------------------------------\n+      -- Check_Possible_Deferred_Completion --\n+      ----------------------------------------\n+\n+      procedure Check_Possible_Deferred_Completion\n+        (Prev_Id      : Entity_Id;\n+         Prev_Obj_Def : Node_Id;\n+         Curr_Obj_Def : Node_Id)\n+      is\n+      begin\n+         if Nkind (Prev_Obj_Def) = N_Subtype_Indication\n+           and then Present (Constraint (Prev_Obj_Def))\n+           and then Nkind (Curr_Obj_Def) = N_Subtype_Indication\n+           and then Present (Constraint (Curr_Obj_Def))\n+         then\n+            declare\n+               Loc    : constant Source_Ptr := Sloc (N);\n+               Def_Id : constant Entity_Id :=\n+                          Make_Defining_Identifier (Loc,\n+                            New_Internal_Name ('S'));\n+               Decl   : constant Node_Id :=\n+                          Make_Subtype_Declaration (Loc,\n+                            Defining_Identifier =>\n+                              Def_Id,\n+                            Subtype_Indication =>\n+                              Relocate_Node (Curr_Obj_Def));\n+\n+            begin\n+               Insert_Before_And_Analyze (N, Decl);\n+               Set_Etype (Id, Def_Id);\n+\n+               if not Subtypes_Statically_Match (Etype (Prev_Id), Def_Id) then\n+                  Error_Msg_Sloc := Sloc (Prev_Id);\n+                  Error_Msg_N (\"subtype does not statically match deferred \" &\n+                               \"declaration#\", N);\n+               end if;\n+            end;\n+         end if;\n+      end Check_Possible_Deferred_Completion;\n+\n       ---------------------------------\n       -- Check_Recursive_Declaration --\n       ---------------------------------\n@@ -8124,6 +8277,16 @@ package body Sem_Ch3 is\n       --  If so, process the full constant declaration\n \n       else\n+         --  RM 7.4 (6): If the subtype defined by the subtype_indication in\n+         --  the deferred declaration is constrained, then the subtype defined\n+         --  by the subtype_indication in the full declaration shall match it\n+         --  statically.\n+\n+         Check_Possible_Deferred_Completion\n+           (Prev_Id      => Prev,\n+            Prev_Obj_Def => Object_Definition (Parent (Prev)),\n+            Curr_Obj_Def => Obj_Def);\n+\n          Set_Full_View (Prev, Id);\n          Set_Is_Public (Id, Is_Public (Prev));\n          Set_Is_Internal (Id);\n@@ -10413,6 +10576,13 @@ package body Sem_Ch3 is\n            (New_Subp, Is_Valued_Procedure (Parent_Subp));\n       end if;\n \n+      --  No_Return must be inherited properly. If this is overridden in the\n+      --  case of a dispatching operation, then a check is made in Sem_Disp\n+      --  that the overriding operation is also No_Return (no such check is\n+      --  required for the case of non-dispatching operation.\n+\n+      Set_No_Return (New_Subp, No_Return (Parent_Subp));\n+\n       --  A derived function with a controlling result is abstract. If the\n       --  Derived_Type is a nonabstract formal generic derived type, then\n       --  inherited operations are not abstract: the required check is done at\n@@ -10845,7 +11015,7 @@ package body Sem_Ch3 is\n \n             Partial_View := First_Entity (Current_Scope);\n             loop\n-               exit when not Present (Partial_View)\n+               exit when No (Partial_View)\n                  or else (Has_Private_Declaration (Partial_View)\n                            and then Full_View (Partial_View) = T);\n \n@@ -11020,13 +11190,15 @@ package body Sem_Ch3 is\n       Build_Derived_Type (N, Parent_Type, T, Is_Completion);\n \n       --  AI-419:  the parent type of an explicitly limited derived type must\n-      --  be limited. Interface progenitors were checked earlier.\n+      --  be a limited type or a limited interface.\n \n       if Limited_Present (Def) then\n          Set_Is_Limited_Record (T);\n \n          if not Is_Limited_Type (Parent_Type)\n-           and then not Is_Interface (Parent_Type)\n+           and then\n+             (not Is_Interface (Parent_Type)\n+               or else not Is_Limited_Interface (Parent_Type))\n          then\n             Error_Msg_NE (\"parent type& of limited type must be limited\",\n               N, Parent_Type);\n@@ -11273,6 +11445,21 @@ package body Sem_Ch3 is\n                then\n                   Error_Msg_N\n                    (\"completion of nonlimited type cannot be limited\", N);\n+\n+               elsif Ekind (Prev) = E_Record_Type_With_Private\n+                 and then\n+                   (Nkind (N) = N_Task_Type_Declaration\n+                     or else Nkind (N) = N_Protected_Type_Declaration)\n+               then\n+                  if not Is_Limited_Record (Prev) then\n+                     Error_Msg_N\n+                        (\"completion of nonlimited type cannot be limited\", N);\n+\n+                  elsif No (Interface_List (N)) then\n+                     Error_Msg_N\n+                        (\"completion of tagged private type must be tagged\",\n+                           N);\n+                  end if;\n                end if;\n \n             --  Ada 2005 (AI-251): Private extension declaration of a\n@@ -12144,6 +12331,7 @@ package body Sem_Ch3 is\n \n          if Ekind (Component) = E_Component\n            and then Is_Tag (Component)\n+           and then RTE_Available (RE_Interface_Tag)\n            and then Etype  (Component) = RTE (RE_Interface_Tag)\n          then\n             null;\n@@ -12191,6 +12379,41 @@ package body Sem_Ch3 is\n       return Assoc_List;\n    end Inherit_Components;\n \n+   -----------------------\n+   -- Is_Null_Extension --\n+   -----------------------\n+\n+   function Is_Null_Extension (T : Entity_Id) return Boolean is\n+      Full_Type_Decl : constant Node_Id := Parent (T);\n+      Full_Type_Defn : constant Node_Id := Type_Definition (Full_Type_Decl);\n+      Comp_List      : Node_Id;\n+      First_Comp     : Node_Id;\n+\n+   begin\n+      if not Is_Tagged_Type (T)\n+        or else Nkind (Full_Type_Defn) /= N_Derived_Type_Definition\n+      then\n+         return False;\n+      end if;\n+\n+      Comp_List := Component_List (Record_Extension_Part (Full_Type_Defn));\n+\n+      if Present (Discriminant_Specifications (Full_Type_Decl)) then\n+         return False;\n+\n+      elsif Present (Comp_List)\n+        and then Is_Non_Empty_List (Component_Items (Comp_List))\n+      then\n+         First_Comp := First (Component_Items (Comp_List));\n+\n+         return Chars (Defining_Identifier (First_Comp)) = Name_uParent\n+           and then No (Next (First_Comp));\n+\n+      else\n+         return True;\n+      end if;\n+   end Is_Null_Extension;\n+\n    ------------------------------\n    -- Is_Valid_Constraint_Kind --\n    ------------------------------\n@@ -13111,7 +13334,7 @@ package body Sem_Ch3 is\n          end if;\n \n          if Nkind (Discriminant_Type (Discr)) = N_Access_Definition then\n-            Discr_Type := Access_Definition (N, Discriminant_Type (Discr));\n+            Discr_Type := Access_Definition (Discr, Discriminant_Type (Discr));\n \n             --  Ada 2005 (AI-230): Access discriminants are now allowed for\n             --  nonlimited types, and are treated like other components of\n@@ -13344,6 +13567,14 @@ package body Sem_Ch3 is\n          Iface_Elmt : Elmt_Id;\n \n       begin\n+         --  Abstract interfaces are only associated with tagged record types\n+\n+         if not Is_Tagged_Type (Typ)\n+           or else not Is_Record_Type (Typ)\n+         then\n+            return;\n+         end if;\n+\n          --  Implementations of the form:\n          --    type Typ is new Iface ...\n \n@@ -13361,10 +13592,11 @@ package body Sem_Ch3 is\n             while Present (Iface_Elmt) loop\n                Iface := Node (Iface_Elmt);\n \n-               if Is_Interface (Iface)\n-                 and then not Contain_Interface (Iface, Ifaces)\n-               then\n+               pragma Assert (Is_Interface (Iface));\n+\n+               if not Contain_Interface (Iface, Ifaces) then\n                   Append_Elmt (Iface, Ifaces);\n+                  Collect_Implemented_Interfaces (Iface, Ifaces);\n                end if;\n \n                Next_Elmt (Iface_Elmt);\n@@ -13495,15 +13727,22 @@ package body Sem_Ch3 is\n             Collect_Implemented_Interfaces (Priv_T, Priv_T_Ifaces);\n             Collect_Implemented_Interfaces (Full_T, Full_T_Ifaces);\n \n-            --  Ada 2005 (AI-396): The partial view shall be a descendant of\n-            --  an interface type if and only if the full view is a descendant\n-            --  of the interface type.\n+            --  Ada 2005 (AI-251): The partial view shall be a descendant of\n+            --  an interface type if and only if the full type is descendant\n+            --  of the interface type (AARM 7.3 (7.3/2).\n+\n+            Iface := Find_Hidden_Interface (Priv_T_Ifaces, Full_T_Ifaces);\n+\n+            if Present (Iface) then\n+               Error_Msg_NE (\"interface & not implemented by full type \" &\n+                             \"('R'M'-2005 7.3 (7.3/2))\", Priv_T, Iface);\n+            end if;\n \n             Iface := Find_Hidden_Interface (Full_T_Ifaces, Priv_T_Ifaces);\n \n             if Present (Iface) then\n                Error_Msg_NE (\"interface & not implemented by partial view \" &\n-                             \"('R'M'-2005 7.3(9))\", Full_T, Iface);\n+                             \"('R'M'-2005 7.3 (7.3/2))\", Full_T, Iface);\n             end if;\n          end;\n       end if;\n@@ -13543,7 +13782,14 @@ package body Sem_Ch3 is\n          then\n             null;\n \n-         elsif not Is_Ancestor (Base_Type (Priv_Parent), Full_Parent) then\n+         --  Ada 2005 (AI-251): If the parent of the private type declaration\n+         --  is an interface there is no need to check that it is an ancestor\n+         --  of the associated full type declaration. The required tests for\n+         --  this case case are performed by Build_Derived_Record_Type.\n+\n+         elsif not Is_Interface (Base_Type (Priv_Parent))\n+           and then not Is_Ancestor (Base_Type (Priv_Parent), Full_Parent)\n+         then\n             Error_Msg_N\n               (\"parent of full type must descend from parent\"\n                   & \" of private extension\", Full_Indic);\n@@ -13554,7 +13800,7 @@ package body Sem_Ch3 is\n          --  subtype of the full type must be constrained if and only if\n          --  the ancestor subtype of the private extension is constrained.\n \n-         elsif not Present (Discriminant_Specifications (Parent (Priv_T)))\n+         elsif No (Discriminant_Specifications (Parent (Priv_T)))\n            and then not Has_Unknown_Discriminants (Priv_T)\n            and then Has_Discriminants (Base_Type (Priv_Parent))\n          then\n@@ -14512,8 +14758,13 @@ package body Sem_Ch3 is\n \n                if Nkind (Subt) = N_Identifier then\n                   return Chars (Subt) = Chars (T);\n+\n+               --  A reference to the current type may appear as the prefix\n+               --  of a 'Class attribute.\n+\n                elsif Nkind (Subt) = N_Attribute_Reference\n                   and then Attribute_Name (Subt) = Name_Class\n+                  and then Is_Entity_Name (Prefix (Subt))\n                then\n                   return (Chars (Prefix (Subt))) = Chars (T);\n                else\n@@ -14638,8 +14889,12 @@ package body Sem_Ch3 is\n \n       begin\n          --  If there is a previous partial view, no need to create a new one\n+         --  If the partial view is incomplete, it is given by Prev. If it is\n+         --  a private declaration, full declaration is flagged accordingly.\n \n-         if Prev /= T then\n+         if Prev /= T\n+           or else Has_Private_Declaration (T)\n+         then\n             return;\n \n          elsif No (Inc_T) then\n@@ -14671,6 +14926,7 @@ package body Sem_Ch3 is\n             if Tagged_Present (Def) then\n                Make_Class_Wide_Type (Inc_T);\n                Set_Class_Wide_Type (T, Class_Wide_Type (Inc_T));\n+               Set_Etype (Class_Wide_Type (T), T);\n             end if;\n          end if;\n       end Make_Incomplete_Type_Declaration;\n@@ -14915,6 +15171,15 @@ package body Sem_Ch3 is\n \n       Final_Storage_Only := not Is_Controlled (T);\n \n+      --  Ada 2005: check whether an explicit Limited is present in a derived\n+      --  type declaration.\n+\n+      if Nkind (Parent (Def)) = N_Derived_Type_Definition\n+        and then Limited_Present (Parent (Def))\n+      then\n+         Set_Is_Limited_Record (T);\n+      end if;\n+\n       --  If the component list of a record type is defined by the reserved\n       --  word null and there is no discriminant part, then the record type has\n       --  no components and all records of the type are null records (RM 3.7)"}, {"sha": "d4d3799396e9429a867a5781192506b606ce857c", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=57193e09243103515c50b2b433ddb15a90d311b7", "patch": "@@ -157,6 +157,11 @@ package Sem_Ch3  is\n    --  Given a discriminant somewhere in the Typ_For_Constraint tree\n    --  and a Constraint, return the value of that discriminant.\n \n+   function Is_Null_Extension (T : Entity_Id) return Boolean;\n+   --  Returns True if the tagged type T has an N_Full_Type_Declaration that\n+   --  is a null extension, meaning that it has an extension part without any\n+   --  components and does not have a known discriminant part.\n+\n    function Is_Visible_Component (C : Entity_Id) return Boolean;\n    --  Determines if a record component C is visible in the present context.\n    --  Note that even though component C could appear in the entity chain"}, {"sha": "bec0eb5e8c0cbc83be6e32940d17aba0a8a84dba", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 104, "deletions": 70, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57193e09243103515c50b2b433ddb15a90d311b7/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=57193e09243103515c50b2b433ddb15a90d311b7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -341,7 +341,7 @@ package body Sem_Prag is\n \n       procedure Check_Component (Comp : Node_Id);\n       --  Examine Unchecked_Union component for correct use of per-object\n-      --  constrained subtypes.\n+      --  constrained subtypes, and for restrictions on finalizable components.\n \n       procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n       --  Nam is an N_String_Literal node containing the external name set\n@@ -988,7 +988,8 @@ package body Sem_Prag is\n             declare\n                Sindic : constant Node_Id :=\n                           Subtype_Indication (Component_Definition (Comp));\n-\n+               Typ    : constant Entity_Id :=\n+                          Etype (Defining_Identifier (Comp));\n             begin\n                if Nkind (Sindic) = N_Subtype_Indication then\n \n@@ -1004,6 +1005,15 @@ package body Sem_Prag is\n                        \" constraint must be an Unchecked_Union\", Comp);\n                   end if;\n                end if;\n+\n+               if Is_Controlled (Typ) then\n+                  Error_Msg_N\n+                   (\"component of unchecked union cannot be controlled\", Comp);\n+\n+               elsif Has_Task (Typ) then\n+                  Error_Msg_N\n+                   (\"component of unchecked union cannot have tasks\", Comp);\n+               end if;\n             end;\n          end if;\n       end Check_Component;\n@@ -1440,12 +1450,6 @@ package body Sem_Prag is\n          Comp  : Node_Id;\n \n       begin\n-         if Present (Variant_Part (Clist)) then\n-            Error_Msg_N\n-              (\"Unchecked_Union may not have nested variants\",\n-               Variant_Part (Clist));\n-         end if;\n-\n          if not Is_Non_Empty_List (Component_Items (Clist)) then\n             Error_Msg_N\n               (\"Unchecked_Union may not have empty component list\",\n@@ -1957,6 +1961,24 @@ package body Sem_Prag is\n \n          procedure Set_Convention_From_Pragma (E : Entity_Id) is\n          begin\n+            --  Check invalid attempt to change convention for an overridden\n+            --  dispatching operation. This is Ada 2005 AI 430. Technically\n+            --  this is an amendment and should only be done in Ada 2005 mode.\n+            --  However, this is clearly a mistake, since the problem that is\n+            --  addressed by this AI is that there is a clear gap in the RM!\n+\n+            if Is_Dispatching_Operation (E)\n+              and then Present (Overridden_Operation (E))\n+              and then C /= Convention (Overridden_Operation (E))\n+            then\n+               Error_Pragma_Arg\n+                 (\"cannot change convention for \" &\n+                  \"overridden dispatching operation\",\n+                  Arg1);\n+            end if;\n+\n+            --  Set the convention\n+\n             Set_Convention (E, C);\n             Set_Has_Convention_Pragma (E);\n \n@@ -2862,7 +2884,7 @@ package body Sem_Prag is\n                else\n                   Dval := Default_Value (Formal);\n \n-                  if not Present (Dval) then\n+                  if No (Dval) then\n                      Error_Msg_NE\n                        (\"optional formal& does not have default value!\",\n                         Arg_First_Optional_Parameter, Formal);\n@@ -4222,9 +4244,9 @@ package body Sem_Prag is\n             Error_Msg_Sloc := Task_Dispatching_Policy_Sloc;\n             Error_Pragma (\"Profile (Ravenscar) incompatible with policy#\");\n \n-         --  Set the FIFO_Within_Priorities policy, but always\n-         --  preserve System_Location since we like the error\n-         --  message with the run time name.\n+         --  Set the FIFO_Within_Priorities policy, but always preserve\n+         --  System_Location since we like the error message with the run time\n+         --  name.\n \n          else\n             Task_Dispatching_Policy := 'F';\n@@ -4242,9 +4264,8 @@ package body Sem_Prag is\n             Error_Msg_Sloc := Locking_Policy_Sloc;\n             Error_Pragma (\"Profile (Ravenscar) incompatible with policy#\");\n \n-         --  Set the Ceiling_Locking policy, but always preserve\n-         --  System_Location since we like the error message with the\n-         --  run time name.\n+         --  Set the Ceiling_Locking policy, but preserve System_Location since\n+         --  we like the error message with the run time name.\n \n          else\n             Locking_Policy := 'C';\n@@ -4268,7 +4289,7 @@ package body Sem_Prag is\n    begin\n       if not Is_Pragma_Name (Chars (N)) then\n          if Warn_On_Unrecognized_Pragma then\n-            Error_Pragma (\"unrecognized pragma%!?\");\n+            Error_Pragma (\"unrecognized pragma%?\");\n          else\n             return;\n          end if;\n@@ -4368,17 +4389,20 @@ package body Sem_Prag is\n             Ada_Version_Explicit := Ada_Version;\n             Check_Arg_Count (0);\n \n-         ------------\n-         -- Ada_05 --\n-         ------------\n+         ---------------------\n+         -- Ada_05/Ada_2005 --\n+         ---------------------\n \n          --  pragma Ada_05;\n          --  pragma Ada_05 (LOCAL_NAME);\n \n-         --  Note: this pragma also has some specific processing in Par.Prag\n+         --  pragma Ada_2005;\n+         --  pragma Ada_2005 (LOCAL_NAME):\n+\n+         --  Note: these pragma also have some specific processing in Par.Prag\n          --  because we want to set the Ada 2005 version mode during parsing.\n \n-         when Pragma_Ada_05 => declare\n+         when Pragma_Ada_05 | Pragma_Ada_2005 => declare\n             E_Id : Node_Id;\n \n          begin\n@@ -4397,7 +4421,7 @@ package body Sem_Prag is\n             else\n                Check_Arg_Count (0);\n                Ada_Version := Ada_05;\n-               Ada_Version_Explicit := Ada_Version;\n+               Ada_Version_Explicit := Ada_05;\n             end if;\n          end;\n \n@@ -4618,7 +4642,7 @@ package body Sem_Prag is\n \n             procedure Process_Async_Pragma is\n             begin\n-               if not Present (L) then\n+               if No (L) then\n                   Set_Is_Asynchronous (Nm);\n                   return;\n                end if;\n@@ -5255,16 +5279,15 @@ package body Sem_Prag is\n                     (\"only tagged records can contain vtable pointers\", Arg1);\n                end if;\n \n-            --  Case of tagged type with no vtable ptr\n-\n-            --  What is test for Typ = Root_Typ (Typ) about here ???\n+            --  Case of tagged type with no user-defined vtable ptr. In this\n+            --  case, because of our C++ ABI compatibility, the programmer\n+            --  does not need to specify the tag component.\n \n             elsif Is_Tagged_Type (Typ)\n-              and then Typ = Root_Type (Typ)\n               and then No (Default_DTC)\n             then\n-               Error_Pragma_Arg\n-                 (\"a cpp_class must contain a vtable pointer\", Arg1);\n+               Set_Is_CPP_Class (Typ);\n+               Set_Is_Limited_Record (Typ);\n \n             --  Tagged type that has a vtable ptr\n \n@@ -5438,6 +5461,8 @@ package body Sem_Prag is\n                Next_Component (DTC);\n             end loop;\n \n+            --  Case of tagged type with no user-defined vtable ptr\n+\n             if No (DTC) then\n                Error_Msg_NE (\"must be a& component name\", Arg, Typ);\n                raise Pragma_Exit;\n@@ -8101,48 +8126,57 @@ package body Sem_Prag is\n          -- No_Return --\n          ---------------\n \n-         --  pragma No_Return (procedure_LOCAL_NAME);\n+         --  pragma No_Return (procedure_LOCAL_NAME {, procedure_Local_Name});\n \n          when Pragma_No_Return => No_Return : declare\n             Id    : Node_Id;\n             E     : Entity_Id;\n             Found : Boolean;\n+            Arg   : Node_Id;\n \n          begin\n             GNAT_Pragma;\n-            Check_Arg_Count (1);\n-            Check_No_Identifiers;\n-            Check_Arg_Is_Local_Name (Arg1);\n-            Id := Expression (Arg1);\n-            Analyze (Id);\n+            Check_At_Least_N_Arguments (1);\n \n-            if not Is_Entity_Name (Id) then\n-               Error_Pragma_Arg (\"entity name required\", Arg1);\n-            end if;\n+            --  Loop through arguments of pragma\n \n-            if Etype (Id) = Any_Type then\n-               raise Pragma_Exit;\n-            end if;\n+            Arg := Arg1;\n+            while Present (Arg) loop\n+               Check_Arg_Is_Local_Name (Arg);\n+               Id := Expression (Arg);\n+               Analyze (Id);\n \n-            E := Entity (Id);\n+               if not Is_Entity_Name (Id) then\n+                  Error_Pragma_Arg (\"entity name required\", Arg);\n+               end if;\n \n-            Found := False;\n-            while Present (E)\n-              and then Scope (E) = Current_Scope\n-            loop\n-               if Ekind (E) = E_Procedure\n-                 or else Ekind (E) = E_Generic_Procedure\n-               then\n-                  Set_No_Return (E);\n-                  Found := True;\n+               if Etype (Id) = Any_Type then\n+                  raise Pragma_Exit;\n                end if;\n \n-               E := Homonym (E);\n-            end loop;\n+               --  Loop to find matching procedures\n \n-            if not Found then\n-               Error_Pragma (\"no procedures found for pragma%\");\n-            end if;\n+               E := Entity (Id);\n+               Found := False;\n+               while Present (E)\n+                 and then Scope (E) = Current_Scope\n+               loop\n+                  if Ekind (E) = E_Procedure\n+                    or else Ekind (E) = E_Generic_Procedure\n+                  then\n+                     Set_No_Return (E);\n+                     Found := True;\n+                  end if;\n+\n+                  E := Homonym (E);\n+               end loop;\n+\n+               if not Found then\n+                  Error_Pragma_Arg (\"no procedure & found for pragma%\", Arg);\n+               end if;\n+\n+               Next (Arg);\n+            end loop;\n          end No_Return;\n \n          ------------------------\n@@ -8181,7 +8215,7 @@ package body Sem_Prag is\n          -- Obsolescent --\n          -----------------\n \n-            --  pragma Obsolescent [(static_string_EXPRESSION [, Ada_05])];\n+         --  pragma Obsolescent [(static_string_EXPRESSION [, Ada_05])];\n \n          when Pragma_Obsolescent => Obsolescent : declare\n             Subp   : Node_Or_Entity_Id;\n@@ -8789,6 +8823,8 @@ package body Sem_Prag is\n \n          --  pragma Propagate_Exceptions;\n \n+         --  Note: this pragma is obsolete and has no effect\n+\n          when Pragma_Propagate_Exceptions =>\n             GNAT_Pragma;\n             Check_Arg_Count (0);\n@@ -8956,6 +8992,7 @@ package body Sem_Prag is\n \n             Ent := Find_Lib_Unit_Name;\n             Set_Is_Pure (Ent);\n+            Set_Has_Pragma_Pure (Ent);\n             Set_Suppress_Elaboration_Warnings (Ent);\n          end Pure;\n \n@@ -10146,18 +10183,14 @@ package body Sem_Prag is\n \n                Discr := First_Discriminant (Typ);\n \n-               if Present (Next_Discriminant (Discr)) then\n-                  Error_Msg_N\n-                    (\"Unchecked_Union must have exactly one discriminant\",\n-                     Next_Discriminant (Discr));\n-                  return;\n-               end if;\n-\n-               if No (Discriminant_Default_Value (Discr)) then\n-                  Error_Msg_N\n-                    (\"Unchecked_Union discriminant must have default value\",\n-                     Discr);\n-               end if;\n+               while Present (Discr) loop\n+                  if No (Discriminant_Default_Value (Discr)) then\n+                     Error_Msg_N\n+                       (\"Unchecked_Union discriminant must have default value\",\n+                        Discr);\n+                  end if;\n+                  Next_Discriminant (Discr);\n+               end loop;\n \n                Tdef  := Type_Definition (Declaration_Node (Typ));\n                Clist := Component_List (Tdef);\n@@ -10686,6 +10719,7 @@ package body Sem_Prag is\n       Pragma_Ada_83                       => -1,\n       Pragma_Ada_95                       => -1,\n       Pragma_Ada_05                       => -1,\n+      Pragma_Ada_2005                     => -1,\n       Pragma_All_Calls_Remote             => -1,\n       Pragma_Annotate                     => -1,\n       Pragma_Assert                       => -1,"}]}