{"sha": "74509b963ef64101ce601a497913c13021994f51", "node_id": "C_kwDOANBUbNoAKDc0NTA5Yjk2M2VmNjQxMDFjZTYwMWE0OTc5MTNjMTMwMjE5OTRmNTE", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-17T19:40:44Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-17T19:40:44Z"}, "message": "Add very basic IPA part of modref-kill analysis\n\ngcc/ChangeLog:\n\n2021-11-17  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref-tree.c: Include cgraph.h and tree-streamer.h.\n\t(modref_access_node::stream_out): New member function.\n\t(modref_access_node::stream_in): New member function.\n\t* ipa-modref-tree.h (modref_access_node::stream_out,\n\tmodref_access_node::stream_in): Declare.\n\t* ipa-modref.c (modref_summary_lto::useful_p): Free useless kills.\n\t(modref_summary_lto::dump): Dump kills.\n\t(analyze_store): Record kills for LTO\n\t(analyze_stmt): Likewise.\n\t(modref_summaries_lto::duplicate): Duplicate kills.\n\t(write_modref_records): Use new stream_out member function.\n\t(read_modref_records): Likewise.\n\t(modref_write): Stream out kills.\n\t(read_section): Stream in kills\n\t(remap_kills): New function.\n\t(update_signature): Use it.", "tree": {"sha": "11a9e8c4d19a6e7b31959b1b5ce8fd1ed58056fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11a9e8c4d19a6e7b31959b1b5ce8fd1ed58056fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74509b963ef64101ce601a497913c13021994f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74509b963ef64101ce601a497913c13021994f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74509b963ef64101ce601a497913c13021994f51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74509b963ef64101ce601a497913c13021994f51/comments", "author": null, "committer": null, "parents": [{"sha": "ef342b2d99e7947a15e72ed02173d235feaf35f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef342b2d99e7947a15e72ed02173d235feaf35f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef342b2d99e7947a15e72ed02173d235feaf35f0"}], "stats": {"total": 171, "additions": 118, "deletions": 53}, "files": [{"sha": "e23d88d7fc05845dac1eadd47e7c256f1a553071", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74509b963ef64101ce601a497913c13021994f51/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74509b963ef64101ce601a497913c13021994f51/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=74509b963ef64101ce601a497913c13021994f51", "patch": "@@ -27,6 +27,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"tree-ssa-alias.h\"\n #include \"gimple.h\"\n+#include \"cgraph.h\"\n+#include \"tree-streamer.h\"\n \n /* Return true if both accesses are the same.  */\n bool\n@@ -458,6 +460,50 @@ modref_access_node::try_merge_with (vec <modref_access_node, va_gc> *&accesses,\n       i++;\n }\n \n+/* Stream out to OB.  */\n+\n+void\n+modref_access_node::stream_out (struct output_block *ob) const\n+{\n+  streamer_write_hwi (ob, parm_index);\n+  if (parm_index != MODREF_UNKNOWN_PARM)\n+    {\n+      streamer_write_uhwi (ob, parm_offset_known);\n+      if (parm_offset_known)\n+\t{\n+\t  streamer_write_poly_int64 (ob, parm_offset);\n+\t  streamer_write_poly_int64 (ob, offset);\n+\t  streamer_write_poly_int64 (ob, size);\n+\t  streamer_write_poly_int64 (ob, max_size);\n+\t}\n+    }\n+}\n+\n+modref_access_node\n+modref_access_node::stream_in (struct lto_input_block *ib)\n+{\n+  int parm_index = streamer_read_hwi (ib);\n+  bool parm_offset_known = false;\n+  poly_int64 parm_offset = 0;\n+  poly_int64 offset = 0;\n+  poly_int64 size = -1;\n+  poly_int64 max_size = -1;\n+\n+  if (parm_index != MODREF_UNKNOWN_PARM)\n+    {\n+      parm_offset_known = streamer_read_uhwi (ib);\n+      if (parm_offset_known)\n+\t{\n+\t  parm_offset = streamer_read_poly_int64 (ib);\n+\t  offset = streamer_read_poly_int64 (ib);\n+\t  size = streamer_read_poly_int64 (ib);\n+\t  max_size = streamer_read_poly_int64 (ib);\n+\t}\n+    }\n+  return {offset, size, max_size, parm_offset, parm_index,\n+\t  parm_offset_known, false};\n+}\n+\n /* Insert access with OFFSET and SIZE.\n    Collapse tree if it has more than MAX_ACCESSES entries.\n    If RECORD_ADJUSTMENTs is true avoid too many interval extensions."}, {"sha": "0a097349ebd4cf71897f447ab5f5b885ffcee23f", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74509b963ef64101ce601a497913c13021994f51/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74509b963ef64101ce601a497913c13021994f51/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=74509b963ef64101ce601a497913c13021994f51", "patch": "@@ -99,6 +99,10 @@ struct GTY(()) modref_access_node\n   tree get_call_arg (const gcall *stmt) const;\n   /* Build ao_ref corresponding to the access and return true if succesful.  */\n   bool get_ao_ref (const gcall *stmt, class ao_ref *ref) const;\n+  /* Stream access to OB.  */\n+  void stream_out (struct output_block *ob) const;\n+  /* Stream access in from IB.  */\n+  static modref_access_node stream_in (struct lto_input_block *ib);\n   /* Insert A into vector ACCESSES.  Limit size of vector to MAX_ACCESSES and\n      if RECORD_ADJUSTMENT is true keep track of adjustment counts.\n      Return 0 if nothing changed, 1 is insertion suceeded and -1 if failed.  */"}, {"sha": "9ceecdd479f1236acf795576962ed2ebe96f92ce", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 68, "deletions": 53, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74509b963ef64101ce601a497913c13021994f51/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74509b963ef64101ce601a497913c13021994f51/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=74509b963ef64101ce601a497913c13021994f51", "patch": "@@ -410,6 +410,8 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n \t    && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   if (loads && !loads->every_base)\n     return true;\n+  else\n+    kills.release ();\n   if (ecf_flags & ECF_PURE)\n     return ((!side_effects || !nondeterministic)\n \t    && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n@@ -634,6 +636,15 @@ modref_summary_lto::dump (FILE *out)\n   dump_lto_records (loads, out);\n   fprintf (out, \"  stores:\\n\");\n   dump_lto_records (stores, out);\n+  if (kills.length ())\n+    {\n+      fprintf (out, \"  kills:\\n\");\n+      for (auto kill : kills)\n+\t{\n+\t  fprintf (out, \"    \");\n+\t  kill.dump (out);\n+\t}\n+    }\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n   if (side_effects)\n@@ -1527,15 +1538,17 @@ analyze_store (gimple *stmt, tree, tree op, void *data)\n     record_access (summary->stores, &r, a);\n   if (summary_lto)\n     record_access_lto (summary_lto->stores, &r, a);\n-  if (summary\n-      && ((summary_ptrs *)data)->always_executed\n+  if (((summary_ptrs *)data)->always_executed\n       && a.useful_for_kill_p ()\n       && (!cfun->can_throw_non_call_exceptions\n \t  || !stmt_could_throw_p (cfun, stmt)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"   - Recording kill\\n\");\n-      modref_access_node::insert_kill (summary->kills, a, false);\n+      if (summary)\n+\tmodref_access_node::insert_kill (summary->kills, a, false);\n+      if (summary_lto)\n+\tmodref_access_node::insert_kill (summary_lto->kills, a, false);\n     }\n   return false;\n }\n@@ -1554,8 +1567,7 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n      Similar logic is in ipa-pure-const.c.  */\n   if ((ipa || cfun->after_inlining) && gimple_clobber_p (stmt))\n     {\n-      if (summary\n-\t  && always_executed && record_access_p (gimple_assign_lhs (stmt)))\n+      if (always_executed && record_access_p (gimple_assign_lhs (stmt)))\n \t{\n \t  ao_ref r;\n \t  ao_ref_init (&r, gimple_assign_lhs (stmt));\n@@ -1564,7 +1576,10 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"   - Recording kill\\n\");\n-\t      modref_access_node::insert_kill (summary->kills, a, false);\n+\t      if (summary)\n+\t\tmodref_access_node::insert_kill (summary->kills, a, false);\n+\t      if (summary_lto)\n+\t\tmodref_access_node::insert_kill (summary_lto->kills, a, false);\n \t    }\n \t}\n       return true;\n@@ -3270,6 +3285,8 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t src_data->loads->max_refs,\n \t\t\t src_data->loads->max_accesses);\n   dst_data->loads->copy_from (src_data->loads);\n+  dst_data->kills.reserve_exact (src_data->kills.length ());\n+  dst_data->kills.splice (src_data->kills);\n   dst_data->writes_errno = src_data->writes_errno;\n   dst_data->side_effects = src_data->side_effects;\n   dst_data->nondeterministic = src_data->nondeterministic;\n@@ -3324,40 +3341,21 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n \n   streamer_write_uhwi (ob, tt->every_base);\n   streamer_write_uhwi (ob, vec_safe_length (tt->bases));\n-  size_t i;\n-  modref_base_node <tree> *base_node;\n-  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n+  for (auto base_node : tt->bases)\n     {\n       stream_write_tree (ob, base_node->base, true);\n \n       streamer_write_uhwi (ob, base_node->every_ref);\n       streamer_write_uhwi (ob, vec_safe_length (base_node->refs));\n \n-      size_t j;\n-      modref_ref_node <tree> *ref_node;\n-      FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+      for (auto ref_node : base_node->refs)\n \t{\n \t  stream_write_tree (ob, ref_node->ref, true);\n \t  streamer_write_uhwi (ob, ref_node->every_access);\n \t  streamer_write_uhwi (ob, vec_safe_length (ref_node->accesses));\n \n-\t  size_t k;\n-\t  modref_access_node *access_node;\n-\t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n-\t    {\n-\t      streamer_write_hwi (ob, access_node->parm_index);\n-\t      if (access_node->parm_index != -1)\n-\t\t{\n-\t\t  streamer_write_uhwi (ob, access_node->parm_offset_known);\n-\t\t  if (access_node->parm_offset_known)\n-\t\t    {\n-\t\t      streamer_write_poly_int64 (ob, access_node->parm_offset);\n-\t\t      streamer_write_poly_int64 (ob, access_node->offset);\n-\t\t      streamer_write_poly_int64 (ob, access_node->size);\n-\t\t      streamer_write_poly_int64 (ob, access_node->max_size);\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  for (auto access_node : ref_node->accesses)\n+\t    access_node.stream_out (ob);\n \t}\n     }\n }\n@@ -3469,26 +3467,7 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \n \t  for (size_t k = 0; k < naccesses; k++)\n \t    {\n-\t      int parm_index = streamer_read_hwi (ib);\n-\t      bool parm_offset_known = false;\n-\t      poly_int64 parm_offset = 0;\n-\t      poly_int64 offset = 0;\n-\t      poly_int64 size = -1;\n-\t      poly_int64 max_size = -1;\n-\n-\t      if (parm_index != -1)\n-\t\t{\n-\t\t  parm_offset_known = streamer_read_uhwi (ib);\n-\t\t  if (parm_offset_known)\n-\t\t    {\n-\t\t      parm_offset = streamer_read_poly_int64 (ib);\n-\t\t      offset = streamer_read_poly_int64 (ib);\n-\t\t      size = streamer_read_poly_int64 (ib);\n-\t\t      max_size = streamer_read_poly_int64 (ib);\n-\t\t    }\n-\t\t}\n-\t      modref_access_node a = {offset, size, max_size, parm_offset,\n-\t\t\t\t      parm_index, parm_offset_known, false};\n+\t      modref_access_node a = modref_access_node::stream_in (ib);\n \t      if (nolto_ref_node)\n \t\tnolto_ref_node->insert_access (a, max_accesses, false);\n \t      if (lto_ref_node)\n@@ -3599,6 +3578,9 @@ modref_write ()\n \n \t  write_modref_records (r->loads, ob);\n \t  write_modref_records (r->stores, ob);\n+\t  streamer_write_uhwi (ob, r->kills.length ());\n+\t  for (auto kill : r->kills)\n+\t    kill.stream_out (ob);\n \n \t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, r->writes_errno, 1);\n@@ -3723,6 +3705,20 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n       read_modref_records (&ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->stores : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->stores : NULL);\n+      int j = streamer_read_uhwi (&ib);\n+      if (j && modref_sum)\n+\tmodref_sum->kills.reserve_exact (j);\n+      if (j && modref_sum_lto)\n+\tmodref_sum_lto->kills.reserve_exact (j);\n+      for (int k = 0; k < j; k++)\n+\t{\n+\t  modref_access_node a = modref_access_node::stream_in (&ib);\n+\n+\t  if (modref_sum)\n+\t    modref_sum->kills.quick_push (a);\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->kills.quick_push (a);\n+\t}\n       struct bitpack_d bp = streamer_read_bitpack (&ib);\n       if (bp_unpack_value (&bp, 1))\n \t{\n@@ -3863,6 +3859,27 @@ remap_arg_flags (auto_vec <eaf_flags_t> &arg_flags, clone_info *info)\n     }\n }\n \n+/* Update kills accrdoing to the parm map MAP.  */\n+\n+static void\n+remap_kills (vec <modref_access_node> &kills, const vec <int> &map)\n+{\n+  for (size_t i = 0; i < kills.length ();)\n+    if (kills[i].parm_index >= 0)\n+      {\n+\tif (kills[i].parm_index < (int)map.length ()\n+\t    && map[kills[i].parm_index] != MODREF_UNKNOWN_PARM)\n+\t  {\n+\t    kills[i].parm_index = map[kills[i].parm_index];\n+\t    i++;\n+\t  }\n+\telse\n+\t  kills.unordered_remove (i);\n+      }\n+    else\n+      i++;\n+}\n+\n /* If signature changed, update the summary.  */\n \n static void\n@@ -3913,17 +3930,15 @@ update_signature (struct cgraph_node *node)\n     {\n       r->loads->remap_params (&map);\n       r->stores->remap_params (&map);\n-      /* TODO: One we do IPA kills analysis, update the table here.  */\n-      r->kills.release ();\n+      remap_kills (r->kills, map);\n       if (r->arg_flags.length ())\n \tremap_arg_flags (r->arg_flags, info);\n     }\n   if (r_lto)\n     {\n       r_lto->loads->remap_params (&map);\n       r_lto->stores->remap_params (&map);\n-      /* TODO: One we do IPA kills analysis, update the table here.  */\n-      r_lto->kills.release ();\n+      remap_kills (r_lto->kills, map);\n       if (r_lto->arg_flags.length ())\n \tremap_arg_flags (r_lto->arg_flags, info);\n     }"}]}