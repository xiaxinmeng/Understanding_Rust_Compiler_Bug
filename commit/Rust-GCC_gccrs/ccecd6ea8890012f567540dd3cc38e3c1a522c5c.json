{"sha": "ccecd6ea8890012f567540dd3cc38e3c1a522c5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlY2Q2ZWE4ODkwMDEyZjU2NzU0MGRkM2NjMzhlM2MxYTUyMmM1Yw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2011-03-24T16:50:31Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2011-03-24T16:50:31Z"}, "message": "reload.c (find_reloads_subreg_address): Add address_reloaded parameter and return true there if...\n\n2011-03-24  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* reload.c (find_reloads_subreg_address): Add address_reloaded\n\tparameter and return true there if the full address has been\n\treloaded.\n\t(find_reloads_toplev): Pass address_reloaded flag.\n\t(find_reloads_address_1): Don't use address_reloaded parameter.\n\nFrom-SVN: r171413", "tree": {"sha": "b0ddf7d0049d6270abcb59efbdcd34cdfd58170e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ddf7d0049d6270abcb59efbdcd34cdfd58170e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccecd6ea8890012f567540dd3cc38e3c1a522c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccecd6ea8890012f567540dd3cc38e3c1a522c5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccecd6ea8890012f567540dd3cc38e3c1a522c5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccecd6ea8890012f567540dd3cc38e3c1a522c5c/comments", "author": null, "committer": null, "parents": [{"sha": "111eeb6ee5705d40454c91b8baea3c1d798421d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111eeb6ee5705d40454c91b8baea3c1d798421d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111eeb6ee5705d40454c91b8baea3c1d798421d4"}], "stats": {"total": 34, "additions": 24, "deletions": 10}, "files": [{"sha": "a8af16000d778582ff86f26c084c8c8a0f7149ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccecd6ea8890012f567540dd3cc38e3c1a522c5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccecd6ea8890012f567540dd3cc38e3c1a522c5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccecd6ea8890012f567540dd3cc38e3c1a522c5c", "patch": "@@ -1,3 +1,11 @@\n+2011-03-24  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* reload.c (find_reloads_subreg_address): Add address_reloaded\n+\tparameter and return true there if the full address has been\n+\treloaded.\n+\t(find_reloads_toplev): Pass address_reloaded flag.\n+\t(find_reloads_address_1): Don't use address_reloaded parameter.\n+\n 2011-03-24  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-live.c (remove_unused_scope_block_p): Remove set but"}, {"sha": "e4dda401868d4380667d9cb875cdeaf68762a048", "filename": "gcc/reload.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccecd6ea8890012f567540dd3cc38e3c1a522c5c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccecd6ea8890012f567540dd3cc38e3c1a522c5c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ccecd6ea8890012f567540dd3cc38e3c1a522c5c", "patch": "@@ -285,7 +285,7 @@ static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, int,\n \t\t\t\t       enum reload_type, int);\n static rtx find_reloads_subreg_address (rtx, int, int, enum reload_type,\n-\t\t\t\t\tint, rtx);\n+\t\t\t\t\tint, rtx, int *);\n static void copy_replacements_1 (rtx *, rtx *, int);\n static int find_inc_amount (rtx, rtx);\n static int refers_to_mem_for_reload_p (rtx);\n@@ -4759,7 +4759,7 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])\n \t\t\t   || num_not_at_initial_offset))))\n \tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n-\t\t\t\t\t insn);\n+\t\t\t\t\t   insn, address_reloaded);\n     }\n \n   for (copied = 0, i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -5995,7 +5995,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t{\n \t\t  x = find_reloads_subreg_address (x, 0, opnum,\n \t\t\t\t\t\t   ADDR_TYPE (type),\n-\t\t\t\t\t\t   ind_levels, insn);\n+\t\t\t\t\t\t   ind_levels, insn, NULL);\n \t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0, rclass,\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n@@ -6097,9 +6097,11 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n \n static rtx\n find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n-\t\t\t     enum reload_type type, int ind_levels, rtx insn)\n+\t\t\t     enum reload_type type, int ind_levels, rtx insn,\n+\t\t\t     int *address_reloaded)\n {\n   int regno = REGNO (SUBREG_REG (x));\n+  int reloaded = 0;\n \n   if (reg_equiv_memory_loc[regno])\n     {\n@@ -6123,7 +6125,6 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t      unsigned inner_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n \t      int offset;\n \t      rtx orig = tem;\n-\t      int reloaded;\n \n \t      /* For big-endian paradoxical subregs, SUBREG_BYTE does not\n \t\t hold the correct (negative) byte offset.  */\n@@ -6192,11 +6193,13 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t  && !strict_memory_address_addr_space_p\n \t\t\t(GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),\n \t\t\t MEM_ADDR_SPACE (reg_equiv_mem[regno])))\n-\t\tpush_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n-\t\t\t     base_reg_class (GET_MODE (tem), MEM, SCRATCH),\n-\t\t\t     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,\n-\t\t\t     opnum, type);\n-\n+\t\t{\n+\t\t  push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n+\t\t\t       base_reg_class (GET_MODE (tem), MEM, SCRATCH),\n+\t\t\t       GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,\n+\t\t\t       opnum, type);\n+\t\t  reloaded = 1;\n+\t\t}\n \t      /* If this is not a toplevel operand, find_reloads doesn't see\n \t\t this substitution.  We have to emit a USE of the pseudo so\n \t\t that delete_output_reload can see it.  */\n@@ -6211,6 +6214,9 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t    }\n \t}\n     }\n+  if (reloaded && address_reloaded)\n+    *address_reloaded = 1;\n+\n   return x;\n }\n \f"}]}