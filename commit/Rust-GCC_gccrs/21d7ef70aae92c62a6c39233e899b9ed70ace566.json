{"sha": "21d7ef70aae92c62a6c39233e899b9ed70ace566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFkN2VmNzBhYWU5MmM2MmE2YzM5MjMzZTg5OWI5ZWQ3MGFjZTU2Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:17:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:17:42Z"}, "message": "[multiple changes]\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Case_Expression): In the scope of a\n\tpredicate function, delay the expansion of the expression only\n\tif the target type has a specified Static_ Predicate aspect,\n\tbecause the expression is processed later. A dynamic predicate\n\tmust be expanded in standard fashion.\n\n2015-10-26  Claire Dross  <dross@adacore.com>\n\n\t* a-nudira.ads: Remove SPARK_Mode as it currently causes an error.\n\n2015-10-26  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_aggr.adb, sem_type.adb, sem_ch12.adb, sem_res.adb, sem_ch4.adb,\n\tsem_ch8.adb, exp_aggr.adb, sem_eval.adb, s-fatgen.adb, a-tienio.adb:\n\tFix typos.\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): The processing\n\tfor aspects Abstract_State, Ghost, Initial_Condition, Initializes\n\tand Refined_State no longer have to take SPARK_Mode into account.\n\t(Insert_After_SPARK_Mode): Removed.\n\t(Insert_Pragma): Update profile and comment on usage. The routine can\n\tnow insert a pragma after the \"header\" of an instance.\n\t* sem_prag.adb (Analyze_If_Available): New routine.\n\t(Analyze_Pragma): Do not reset the Analyzed flag of various\n\tSPARK pragmas as they use the Is_Analyzed_Pragma attribute to\n\tavoid reanalysis. Various pragmas now trigger the analysis\n\tof related pragmas that depend on or are dependent on the\n\tcurrent pragma. Remove the declaration order checks related\n\tto pragmas Abstract_State, Initial_Condition and Initializes.\n\t(Analyze_Pre_Post_Condition): Analyze pragmas SPARK_Mode and\n\tVolatile_Function prior to analyzing the pre/postcondition.\n\t(Check_Declaration_Order): Removed.\n\t(Check_Distinct_Name): Ensure that a potentially duplicated pragma\n\tTest_Case is not the pragma being analyzed.\n\t(Is_Followed_By_Pragma): Removed.\n\nFrom-SVN: r229331", "tree": {"sha": "582d1c2afaba5d035f73c43da9e2c038b6dcae62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/582d1c2afaba5d035f73c43da9e2c038b6dcae62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21d7ef70aae92c62a6c39233e899b9ed70ace566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d7ef70aae92c62a6c39233e899b9ed70ace566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21d7ef70aae92c62a6c39233e899b9ed70ace566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d7ef70aae92c62a6c39233e899b9ed70ace566/comments", "author": null, "committer": null, "parents": [{"sha": "2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba4f1fb6ecf07b7779910035d0ff75982d383fb"}], "stats": {"total": 1037, "additions": 402, "deletions": 635}, "files": [{"sha": "fff8b879093c9a8fcbc9188b26e463434573dfa8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -1,3 +1,43 @@\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Case_Expression): In the scope of a\n+\tpredicate function, delay the expansion of the expression only\n+\tif the target type has a specified Static_ Predicate aspect,\n+\tbecause the expression is processed later. A dynamic predicate\n+\tmust be expanded in standard fashion.\n+\n+2015-10-26  Claire Dross  <dross@adacore.com>\n+\n+\t* a-nudira.ads: Remove SPARK_Mode as it currently causes an error.\n+\n+2015-10-26  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_aggr.adb, sem_type.adb, sem_ch12.adb, sem_res.adb, sem_ch4.adb,\n+\tsem_ch8.adb, exp_aggr.adb, sem_eval.adb, s-fatgen.adb, a-tienio.adb:\n+\tFix typos.\n+\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): The processing\n+\tfor aspects Abstract_State, Ghost, Initial_Condition, Initializes\n+\tand Refined_State no longer have to take SPARK_Mode into account.\n+\t(Insert_After_SPARK_Mode): Removed.\n+\t(Insert_Pragma): Update profile and comment on usage. The routine can\n+\tnow insert a pragma after the \"header\" of an instance.\n+\t* sem_prag.adb (Analyze_If_Available): New routine.\n+\t(Analyze_Pragma): Do not reset the Analyzed flag of various\n+\tSPARK pragmas as they use the Is_Analyzed_Pragma attribute to\n+\tavoid reanalysis. Various pragmas now trigger the analysis\n+\tof related pragmas that depend on or are dependent on the\n+\tcurrent pragma. Remove the declaration order checks related\n+\tto pragmas Abstract_State, Initial_Condition and Initializes.\n+\t(Analyze_Pre_Post_Condition): Analyze pragmas SPARK_Mode and\n+\tVolatile_Function prior to analyzing the pre/postcondition.\n+\t(Check_Declaration_Order): Removed.\n+\t(Check_Distinct_Name): Ensure that a potentially duplicated pragma\n+\tTest_Case is not the pragma being analyzed.\n+\t(Is_Followed_By_Pragma): Removed.\n+\n 2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb: Handle subprogram bodies without previous specs."}, {"sha": "251f852579ceb3986ad53850a01cdf25cb7f8fe5", "filename": "gcc/ada/a-nudira.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -29,7 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body Ada.Numerics.Discrete_Random with SPARK_Mode => Off is\n+package body Ada.Numerics.Discrete_Random is\n \n    package SRN renames System.Random_Numbers;\n    use SRN;"}, {"sha": "77501ec63ae7d4c9f13b041444d9f0abd4b40c7f", "filename": "gcc/ada/a-nudira.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fa-nudira.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fa-nudira.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.ads?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -41,7 +41,7 @@ with System.Random_Numbers;\n generic\n    type Result_Subtype is (<>);\n \n-package Ada.Numerics.Discrete_Random with SPARK_Mode is\n+package Ada.Numerics.Discrete_Random is\n \n    --  Basic facilities\n \n@@ -65,7 +65,6 @@ package Ada.Numerics.Discrete_Random with SPARK_Mode is\n    function Value (Coded_State : String) return State;\n \n private\n-   pragma SPARK_Mode (Off);\n \n    type Generator is new System.Random_Numbers.Generator;\n "}, {"sha": "e98f410eee9120d05262fa7d4e78b323456fde30", "filename": "gcc/ada/a-tienio.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fa-tienio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fa-tienio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienio.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -97,7 +97,7 @@ package body Ada.Text_IO.Enumeration_IO is\n    begin\n       --  Ensure that Item is valid before attempting to retrieve the Image, to\n       --  prevent the possibility of out-of-bounds addressing of index or image\n-      --  tables. Units in  the run-time library are normally compiled with\n+      --  tables. Units in the run-time library are normally compiled with\n       --  checks suppressed, which includes instantiated generics.\n \n       if not Item'Valid then"}, {"sha": "5266bca6cd54eb40eda85ebb418debbf8cf7477b", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -2477,7 +2477,7 @@ package body Exp_Aggr is\n             then\n                Ancestor_Is_Expression := True;\n \n-               --  Set up  finalization data for enclosing record, because\n+               --  Set up finalization data for enclosing record, because\n                --  controlled subcomponents of the ancestor part will be\n                --  attached to it.\n \n@@ -3559,7 +3559,7 @@ package body Exp_Aggr is\n          end if;\n \n          if Nkind (N) = N_Aggregate\n-           and then  Present (Component_Associations (N))\n+           and then Present (Component_Associations (N))\n          then\n             Expr := First (Component_Associations (N));\n             while Present (Expr) loop\n@@ -3936,7 +3936,7 @@ package body Exp_Aggr is\n       --  If the size is known, or all the components are static, try to\n       --  build a fully positional aggregate.\n \n-      --  The size of the type  may not be known for an aggregate with\n+      --  The size of the type may not be known for an aggregate with\n       --  discriminated array components, but if the components are static\n       --  it is still possible to verify statically that the length is\n       --  compatible with the upper bound of the type, and therefore it is\n@@ -3980,7 +3980,7 @@ package body Exp_Aggr is\n \n                   else\n                      Error_Msg_N\n-                       (\"non-static object  requires elaboration code??\", N);\n+                       (\"non-static object requires elaboration code??\", N);\n                      exit;\n                   end if;\n "}, {"sha": "6714894f637797cf8d424f9b5fbeaa4315891f59", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -4864,12 +4864,14 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  If the case expression is a predicate specification, do not\n-      --  expand, because it will be converted to the proper predicate\n-      --  form when building the predicate function.\n+      --  If the case expression is a predicate specification, and the type\n+      --  to which it applies has a static predicate aspect, do not expand,\n+      --  because it will be converted to the proper predicate form later.\n \n       if Ekind_In (Current_Scope, E_Function, E_Procedure)\n         and then Is_Predicate_Function (Current_Scope)\n+        and then\n+          Has_Static_Predicate_Aspect (Etype (First_Entity (Current_Scope)))\n       then\n          return;\n       end if;"}, {"sha": "35d037ac388013c1fb53dc39f34dd4950ce90be7", "filename": "gcc/ada/s-fatgen.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -744,7 +744,7 @@ package body System.Fat_Gen is\n       else\n          Result := Machine (Radix_To_M_Minus_1 + Result) - Radix_To_M_Minus_1;\n \n-         if Result > abs X  then\n+         if Result > abs X then\n             Result := Result - 1.0;\n          end if;\n "}, {"sha": "44d89f5edf87237d4f5ec19a290838c21130ee63", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -401,7 +401,7 @@ package body Sem_Aggr is\n    --  is set in Resolve_Array_Aggregate but the aggregate is not\n    --  immediately replaced with a raise CE. In fact, Array_Aggr_Subtype must\n    --  first construct the proper itype for the aggregate (Gigi needs\n-   --  this). After constructing the proper itype we will eventually  replace\n+   --  this). After constructing the proper itype we will eventually replace\n    --  the top-level aggregate with a raise CE (done in Resolve_Aggregate).\n    --  Of course in cases such as:\n    --\n@@ -412,7 +412,7 @@ package body Sem_Aggr is\n    --  (in this particular case the bounds will be 1 .. 2).\n \n    procedure Make_String_Into_Aggregate (N : Node_Id);\n-   --  A string literal can appear in  a context in  which a one dimensional\n+   --  A string literal can appear in a context in which a one dimensional\n    --  array of characters is expected. This procedure simply rewrites the\n    --  string as an aggregate, prior to resolution.\n \n@@ -2718,7 +2718,7 @@ package body Sem_Aggr is\n             if Etype (Imm_Type) = Base_Type (A_Type) then\n                return True;\n \n-            --  The base type of the parent type may appear as  a private\n+            --  The base type of the parent type may appear as a private\n             --  extension if it is declared as such in a parent unit of the\n             --  current one. For consistency of the subsequent analysis use\n             --  the partial view for the ancestor part."}, {"sha": "bb4095b0df4a393300c8a5d41d317ecd6936f898", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -149,7 +149,7 @@ package body Sem_Ch12 is\n    --  However, for private types, this by itself does not insure that the\n    --  proper VIEW of the entity is used (the full type may be visible at the\n    --  point of generic definition, but not at instantiation, or vice-versa).\n-   --  In  order to reference the proper view, we special-case any reference\n+   --  In order to reference the proper view, we special-case any reference\n    --  to private types in the generic object, by saving both views, one in\n    --  the generic and one in the semantic copy. At time of instantiation, we\n    --  check whether the two views are consistent, and exchange declarations if\n@@ -708,7 +708,7 @@ package body Sem_Ch12 is\n    --  If the instantiation happens textually before the body of the generic,\n    --  the instantiation of the body must be analyzed after the generic body,\n    --  and not at the point of instantiation. Such early instantiations can\n-   --  happen if the generic and the instance appear in  a package declaration\n+   --  happen if the generic and the instance appear in a package declaration\n    --  because the generic body can only appear in the corresponding package\n    --  body. Early instantiations can also appear if generic, instance and\n    --  body are all in the declarative part of a subprogram or entry. Entities\n@@ -807,7 +807,7 @@ package body Sem_Ch12 is\n    --  Within the generic part, entities in the formal package are\n    --  visible. To validate subsequent type declarations, indicate\n    --  the correspondence between the entities in the analyzed formal,\n-   --  and the entities in  the actual package. There are three packages\n+   --  and the entities in the actual package. There are three packages\n    --  involved in the instantiation of a formal package: the parent\n    --  generic P1 which appears in the generic declaration, the fake\n    --  instantiation P2 which appears in the analyzed generic, and whose\n@@ -1101,8 +1101,8 @@ package body Sem_Ch12 is\n       --  include an Others clause.\n \n       procedure Process_Default (F : Entity_Id);\n-      --  Add a copy of the declaration of generic formal  F to the list of\n-      --  associations, and add an explicit box association for F  if there\n+      --  Add a copy of the declaration of generic formal F to the list of\n+      --  associations, and add an explicit box association for F if there\n       --  is none yet, and the default comes from an Others_Choice.\n \n       function Renames_Standard_Subprogram (Subp : Entity_Id) return Boolean;\n@@ -1268,7 +1268,7 @@ package body Sem_Ch12 is\n             --  insert actuals for those defaults, and cannot rely on their\n             --  names to disambiguate them.\n \n-            if Actual = First_Named  then\n+            if Actual = First_Named then\n                Next (First_Named);\n \n             elsif Present (Actual) then\n@@ -2883,7 +2883,7 @@ package body Sem_Ch12 is\n          end if;\n \n          --  Default name may be overloaded, in which case the interpretation\n-         --  with the correct profile must be  selected, as for a renaming.\n+         --  with the correct profile must be selected, as for a renaming.\n          --  If the definition is an indexed component, it must denote a\n          --  member of an entry family. If it is a selected component, it\n          --  can be a protected operation.\n@@ -4600,14 +4600,14 @@ package body Sem_Ch12 is\n                Scope_Stack.Table (Scope_Stack.Last - J + 1).First_Use_Clause :=\n                  Use_Clauses (J);\n                Install_Use_Clauses (Use_Clauses (J));\n-            end  loop;\n+            end loop;\n \n          else\n             for J in reverse 1 .. Num_Scopes loop\n                Scope_Stack.Table (Scope_Stack.Last - J + 1).First_Use_Clause :=\n                  Use_Clauses (J);\n                Install_Use_Clauses (Use_Clauses (J));\n-            end  loop;\n+            end loop;\n          end if;\n \n          --  Restore status of instances. If one of them is a body, make its\n@@ -5897,7 +5897,7 @@ package body Sem_Ch12 is\n            and then not Comes_From_Source (E1)\n            and then Chars (E1) /= Chars (E2)\n          then\n-            while Present (E1) and then  Chars (E1) /= Chars (E2) loop\n+            while Present (E1) and then Chars (E1) /= Chars (E2) loop\n                Next_Entity (E1);\n             end loop;\n          end if;\n@@ -7695,14 +7695,14 @@ package body Sem_Ch12 is\n \n       begin\n          E1 := First_Entity (P);\n-         while Present (E1) and then  E1 /= Instance loop\n+         while Present (E1) and then E1 /= Instance loop\n             if Ekind (E1) = E_Package\n               and then Nkind (Parent (E1)) = N_Package_Renaming_Declaration\n             then\n                if Renamed_Object (E1) = Pack then\n                   return True;\n \n-               elsif E1 = P or else  Renamed_Object (E1) = P then\n+               elsif E1 = P or else Renamed_Object (E1) = P then\n                   return False;\n \n                elsif Is_Actual_Of_Previous_Formal (E1) then\n@@ -8724,7 +8724,7 @@ package body Sem_Ch12 is\n                   if Scop = Par_I then\n                      null;\n \n-                  --  If the next node is a source  body we must freeze in\n+                  --  If the next node is a source body we must freeze in\n                   --  the current scope as well.\n \n                   elsif Present (Next (N))\n@@ -9472,7 +9472,7 @@ package body Sem_Ch12 is\n       --  same order.\n \n       function Get_Formal_Entity (N : Node_Id) return Entity_Id;\n-      --  Retrieve entity of defining entity of  generic formal parameter.\n+      --  Retrieve entity of defining entity of generic formal parameter.\n       --  Only the declarations of formals need to be considered when\n       --  linking them to actuals, but the declarative list may include\n       --  internal entities generated during analysis, and those are ignored.\n@@ -9571,7 +9571,7 @@ package body Sem_Ch12 is\n \n                Actual := Entity (Name (Original_Node (Formal_Node)));\n \n-               --  The actual in the formal package declaration  may be a\n+               --  The actual in the formal package declaration may be a\n                --  renamed generic package, in which case we want to retrieve\n                --  the original generic in order to traverse its formal part.\n \n@@ -9710,7 +9710,7 @@ package body Sem_Ch12 is\n       Analyze (Actual);\n \n       if not Is_Entity_Name (Actual)\n-        or else  Ekind (Entity (Actual)) /= E_Package\n+        or else Ekind (Entity (Actual)) /= E_Package\n       then\n          Error_Msg_N\n            (\"expect package instance to instantiate formal\", Actual);\n@@ -12259,7 +12259,7 @@ package body Sem_Ch12 is\n          end if;\n \n          --  Verify that limitedness matches. If parent is a limited\n-         --  interface then  the generic formal is not unless declared\n+         --  interface then the generic formal is not unless declared\n          --  explicitly so. If not declared limited, the actual cannot be\n          --  limited (see AI05-0087).\n "}, {"sha": "2797c6309e53394cde146e9c51e7ebb4dfb542c6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 69, "deletions": 193, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -1208,39 +1208,28 @@ package body Sem_Ch13 is\n       procedure Decorate (Asp : Node_Id; Prag : Node_Id);\n       --  Establish linkages between an aspect and its corresponding pragma\n \n-      procedure Insert_After_SPARK_Mode\n-        (Prag    : Node_Id;\n-         Ins_Nod : Node_Id;\n-         Decls   : List_Id);\n+      procedure Insert_Pragma\n+        (Prag        : Node_Id;\n+         Is_Instance : Boolean := False);\n       --  Subsidiary to the analysis of aspects\n       --    Abstract_State\n-      --    Ghost\n-      --    Initializes\n-      --    Initial_Condition\n-      --    Refined_State\n-      --  Insert node Prag before node Ins_Nod. If Ins_Nod is for pragma\n-      --  SPARK_Mode, then skip SPARK_Mode. Decls is the associated declarative\n-      --  list where Prag is to reside.\n-\n-      procedure Insert_Pragma (Prag : Node_Id);\n-      --  Subsidiary to the analysis of aspects\n       --    Attach_Handler\n       --    Contract_Cases\n       --    Depends\n+      --    Ghost\n       --    Global\n+      --    Initial_Condition\n+      --    Initializes\n       --    Post\n       --    Pre\n       --    Refined_Depends\n       --    Refined_Global\n+      --    Refined_State\n       --    SPARK_Mode\n       --    Warnings\n       --  Insert pragma Prag such that it mimics the placement of a source\n-      --  pragma of the same kind.\n-      --\n-      --    procedure Proc (Formal : ...) with Global => ...;\n-      --\n-      --    procedure Proc (Formal : ...);\n-      --    pragma Global (...);\n+      --  pragma of the same kind. Flag Is_Generic should be set when the\n+      --  context denotes a generic instance.\n \n       --------------\n       -- Decorate --\n@@ -1254,42 +1243,14 @@ package body Sem_Ch13 is\n          Set_Parent                    (Prag, Asp);\n       end Decorate;\n \n-      -----------------------------\n-      -- Insert_After_SPARK_Mode --\n-      -----------------------------\n-\n-      procedure Insert_After_SPARK_Mode\n-        (Prag    : Node_Id;\n-         Ins_Nod : Node_Id;\n-         Decls   : List_Id)\n-      is\n-         Decl : Node_Id := Ins_Nod;\n-\n-      begin\n-         --  Skip SPARK_Mode\n-\n-         if Present (Decl)\n-           and then Nkind (Decl) = N_Pragma\n-           and then Pragma_Name (Decl) = Name_SPARK_Mode\n-         then\n-            Decl := Next (Decl);\n-         end if;\n-\n-         if Present (Decl) then\n-            Insert_Before (Decl, Prag);\n-\n-         --  Aitem acts as the last declaration\n-\n-         else\n-            Append_To (Decls, Prag);\n-         end if;\n-      end Insert_After_SPARK_Mode;\n-\n       -------------------\n       -- Insert_Pragma --\n       -------------------\n \n-      procedure Insert_Pragma (Prag : Node_Id) is\n+      procedure Insert_Pragma\n+        (Prag        : Node_Id;\n+         Is_Instance : Boolean := False)\n+      is\n          Aux   : Node_Id;\n          Decl  : Node_Id;\n          Decls : List_Id;\n@@ -1365,7 +1326,39 @@ package body Sem_Ch13 is\n                Set_Visible_Declarations (Specification (N), Decls);\n             end if;\n \n-            Prepend_To (Decls, Prag);\n+            --  The visible declarations of a generic instance have the\n+            --  following structure:\n+\n+            --    <renamings of generic formals>\n+            --    <renamings of internally-generated spec and body>\n+            --    <first source declaration>\n+\n+            --  Insert the pragma before the first source declaration by\n+            --  skipping the instance \"header\".\n+\n+            if Is_Instance then\n+               Decl := First (Decls);\n+               while Present (Decl) and then not Comes_From_Source (Decl) loop\n+                  Decl := Next (Decl);\n+               end loop;\n+\n+               --  The instance \"header\" is followed by at least one source\n+               --  declaration.\n+\n+               if Present (Decl) then\n+                  Insert_Before (Decl, Prag);\n+\n+               --  Otherwise the pragma is placed after the instance \"header\"\n+\n+               else\n+                  Append_To (Decls, Prag);\n+               end if;\n+\n+            --  Otherwise this is not a generic instance\n+\n+            else\n+               Prepend_To (Decls, Prag);\n+            end if;\n \n          --  When the aspect is associated with a protected unit declaration,\n          --  insert the generated pragma at the top of the visible declarations\n@@ -2298,8 +2291,6 @@ package body Sem_Ch13 is\n \n                when Aspect_Abstract_State => Abstract_State : declare\n                   Context : Node_Id := N;\n-                  Decl    : Node_Id;\n-                  Decls   : List_Id;\n \n                begin\n                   --  When aspect Abstract_State appears on a generic package,\n@@ -2318,54 +2309,12 @@ package body Sem_Ch13 is\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Abstract_State);\n-                     Decorate (Aspect, Aitem);\n-\n-                     Decls := Visible_Declarations (Specification (Context));\n \n-                     --  In general pragma Abstract_State must be at the top\n-                     --  of the existing visible declarations to emulate its\n-                     --  source counterpart. The only exception to this is a\n-                     --  generic instance in which case the pragma must be\n-                     --  inserted after the association renamings.\n-\n-                     if Present (Decls) then\n-                        Decl := First (Decls);\n-\n-                        --  The visible declarations of a generic instance have\n-                        --  the following structure:\n-\n-                        --    <renamings of generic formals>\n-                        --    <renamings of internally-generated spec and body>\n-                        --    <first source declaration>\n-\n-                        --  The pragma must be inserted before the first source\n-                        --  declaration, skip the instance \"header\".\n-\n-                        if Is_Generic_Instance (Defining_Entity (Context)) then\n-                           while Present (Decl)\n-                             and then not Comes_From_Source (Decl)\n-                           loop\n-                              Decl := Next (Decl);\n-                           end loop;\n-                        end if;\n-\n-                        --  When aspects Abstract_State, Ghost,\n-                        --  Initial_Condition and Initializes are out of order,\n-                        --  ensure that pragma SPARK_Mode is always at the top\n-                        --  of the declarations to properly enabled/suppress\n-                        --  errors.\n-\n-                        Insert_After_SPARK_Mode\n-                          (Prag    => Aitem,\n-                           Ins_Nod => Decl,\n-                           Decls   => Decls);\n-\n-                     --  Otherwise the pragma forms a new declarative list\n-\n-                     else\n-                        Set_Visible_Declarations\n-                          (Specification (Context), New_List (Aitem));\n-                     end if;\n+                     Decorate (Aspect, Aitem);\n+                     Insert_Pragma\n+                       (Prag        => Aitem,\n+                        Is_Instance =>\n+                          Is_Generic_Instance (Defining_Entity (Context)));\n \n                   else\n                      Error_Msg_NE\n@@ -2526,51 +2475,16 @@ package body Sem_Ch13 is\n                --  declarations or after an object, a [generic] subprogram, or\n                --  a type declaration.\n \n-               when Aspect_Ghost => Ghost : declare\n-                  Decls : List_Id;\n-\n-               begin\n+               when Aspect_Ghost =>\n                   Make_Aitem_Pragma\n                     (Pragma_Argument_Associations => New_List (\n                        Make_Pragma_Argument_Association (Loc,\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Ghost);\n \n                   Decorate (Aspect, Aitem);\n-\n-                  --  When the aspect applies to a [generic] package, insert\n-                  --  the pragma at the top of the visible declarations. This\n-                  --  emulates the placement of a source pragma.\n-\n-                  if Nkind_In (N, N_Generic_Package_Declaration,\n-                                  N_Package_Declaration)\n-                  then\n-                     Decls := Visible_Declarations (Specification (N));\n-\n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Visible_Declarations (N, Decls);\n-                     end if;\n-\n-                     --  When aspects Abstract_State, Ghost, Initial_Condition\n-                     --  and Initializes are out of order, ensure that pragma\n-                     --  SPARK_Mode is always at the top of the declarations to\n-                     --  properly enabled/suppress errors.\n-\n-                     Insert_After_SPARK_Mode\n-                       (Prag    => Aitem,\n-                        Ins_Nod => First (Decls),\n-                        Decls   => Decls);\n-\n-                  --  Otherwise the context is an object, [generic] subprogram\n-                  --  or type declaration.\n-\n-                  else\n-                     Insert_Pragma (Aitem);\n-                  end if;\n-\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n-               end Ghost;\n \n                --  Global\n \n@@ -2604,7 +2518,6 @@ package body Sem_Ch13 is\n \n                when Aspect_Initial_Condition => Initial_Condition : declare\n                   Context : Node_Id := N;\n-                  Decls   : List_Id;\n \n                begin\n                   --  When aspect Initial_Condition appears on a generic\n@@ -2618,30 +2531,20 @@ package body Sem_Ch13 is\n                   if Nkind_In (Context, N_Generic_Package_Declaration,\n                                         N_Package_Declaration)\n                   then\n-                     Decls := Visible_Declarations (Specification (Context));\n-\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  =>\n                           Name_Initial_Condition);\n-                     Decorate (Aspect, Aitem);\n-\n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Visible_Declarations (Context, Decls);\n-                     end if;\n \n-                     --  When aspects Abstract_State, Ghost, Initial_Condition\n-                     --  and Initializes are out of order, ensure that pragma\n-                     --  SPARK_Mode is always at the top of the declarations to\n-                     --  properly enabled/suppress errors.\n+                     Decorate (Aspect, Aitem);\n+                     Insert_Pragma\n+                       (Prag        => Aitem,\n+                        Is_Instance =>\n+                          Is_Generic_Instance (Defining_Entity (Context)));\n \n-                     Insert_After_SPARK_Mode\n-                       (Prag    => Aitem,\n-                        Ins_Nod => First (Decls),\n-                        Decls   => Decls);\n+                  --  Otherwise the context is illegal\n \n                   else\n                      Error_Msg_NE\n@@ -2663,7 +2566,6 @@ package body Sem_Ch13 is\n \n                when Aspect_Initializes => Initializes : declare\n                   Context : Node_Id := N;\n-                  Decls   : List_Id;\n \n                begin\n                   --  When aspect Initializes appears on a generic package,\n@@ -2677,29 +2579,19 @@ package body Sem_Ch13 is\n                   if Nkind_In (Context, N_Generic_Package_Declaration,\n                                         N_Package_Declaration)\n                   then\n-                     Decls := Visible_Declarations (Specification (Context));\n-\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Initializes);\n-                     Decorate (Aspect, Aitem);\n-\n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Visible_Declarations (Context, Decls);\n-                     end if;\n \n-                     --  When aspects Abstract_State, Ghost, Initial_Condition\n-                     --  and Initializes are out of order, ensure that pragma\n-                     --  SPARK_Mode is always at the top of the declarations to\n-                     --  properly enabled/suppress errors.\n+                     Decorate (Aspect, Aitem);\n+                     Insert_Pragma\n+                       (Prag        => Aitem,\n+                        Is_Instance =>\n+                          Is_Generic_Instance (Defining_Entity (Context)));\n \n-                     Insert_After_SPARK_Mode\n-                       (Prag    => Aitem,\n-                        Ins_Nod => First (Decls),\n-                        Decls   => Decls);\n+                  --  Otherwise the context is illegal\n \n                   else\n                      Error_Msg_NE\n@@ -2813,47 +2705,31 @@ package body Sem_Ch13 is\n \n                --  Refined_State\n \n-               when Aspect_Refined_State => Refined_State : declare\n-                  Decls : List_Id;\n+               when Aspect_Refined_State =>\n \n-               begin\n                   --  The corresponding pragma for Refined_State is inserted in\n                   --  the declarations of the related package body. This action\n                   --  synchronizes both the source and from-aspect versions of\n                   --  the pragma.\n \n                   if Nkind (N) = N_Package_Body then\n-                     Decls := Declarations (N);\n-\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Refined_State);\n-                     Decorate (Aspect, Aitem);\n-\n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Declarations (N, Decls);\n-                     end if;\n \n-                     --  Pragma Refined_State must be inserted after pragma\n-                     --  SPARK_Mode in the tree. This ensures that any error\n-                     --  messages dependent on SPARK_Mode will be properly\n-                     --  enabled/suppressed.\n+                     Decorate (Aspect, Aitem);\n+                     Insert_Pragma (Aitem);\n \n-                     Insert_After_SPARK_Mode\n-                       (Prag    => Aitem,\n-                        Ins_Nod => First (Decls),\n-                        Decls   => Decls);\n+                  --  Otherwise the context is illegal\n \n                   else\n                      Error_Msg_NE\n                        (\"aspect & must apply to a package body\", Aspect, Id);\n                   end if;\n \n                   goto Continue;\n-               end Refined_State;\n \n                --  Relative_Deadline\n "}, {"sha": "9928c3b0cfb11521a710892e46f3c5ae9d776f57", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -1802,7 +1802,7 @@ package body Sem_Ch4 is\n       --  call to a user-defined equality operator.\n \n       --  For the predefined case, the result is Boolean, regardless of the\n-      --  type of the  operands. The operands may even be limited, if they are\n+      --  type of the operands. The operands may even be limited, if they are\n       --  generic actuals. If they are overloaded, label the left argument with\n       --  the common type that must be present, or with the type of the formal\n       --  of the user-defined function.\n@@ -3196,7 +3196,7 @@ package body Sem_Ch4 is\n       --  Try_Indexed_Call and there is nothing else to do.\n \n       if Is_Indexed\n-        and then  Nkind (N) = N_Slice\n+        and then Nkind (N) = N_Slice\n       then\n          return;\n       end if;\n@@ -5422,7 +5422,7 @@ package body Sem_Ch4 is\n             --  and no further processing is required (this is the case of an\n             --  operator constructed by Exp_Fixd for a fixed point operation)\n             --  Otherwise add one interpretation with universal fixed result\n-            --  If the operator is given in  functional notation, it comes\n+            --  If the operator is given in functional notation, it comes\n             --  from source and Fixed_As_Integer cannot apply.\n \n             if (Nkind (N) not in N_Op"}, {"sha": "bf39088d6e147aaf3ab9dc0d1a71352bd7118f69", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -107,7 +107,7 @@ package body Sem_Ch8 is\n    --  Open scopes, that is to say scopes currently being compiled, have their\n    --  corresponding rows of entities in order, innermost scope first.\n \n-   --  The scopes of packages that are mentioned in  context clauses appear in\n+   --  The scopes of packages that are mentioned in context clauses appear in\n    --  no particular order, interspersed among open scopes. This is because\n    --  in the course of analyzing the context of a compilation, a package\n    --  declaration is first an open scope, and subsequently an element of the\n@@ -191,7 +191,7 @@ package body Sem_Ch8 is\n    --  removed from visibility chains on exit from the corresponding scope.\n    --  From the outside, these entities are always accessed by selected\n    --  notation, and the entity chain for the record type, protected type,\n-   --  etc. is traversed sequentially in  order to find the designated entity.\n+   --  etc. is traversed sequentially in order to find the designated entity.\n \n    --  The discriminants of a type and the operations of a protected type or\n    --  task are unchained on  exit from the first view of the type, (such as\n@@ -224,7 +224,7 @@ package body Sem_Ch8 is\n \n    --  The Rtsfind mechanism can force a call to Semantics while another\n    --  compilation is in progress. The unit retrieved by Rtsfind must be\n-   --  compiled in  its own context, and has no access to the visibility of\n+   --  compiled in its own context, and has no access to the visibility of\n    --  the unit currently being compiled. The procedures Save_Scope_Stack and\n    --  Restore_Scope_Stack make entities in current open scopes invisible\n    --  before compiling the retrieved unit, and restore the compilation"}, {"sha": "c4fe76876268a4d82b16867ce296d51f23927cf6", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -814,7 +814,7 @@ package body Sem_Eval is\n             V := UI_Negate (Intval (Right_Opnd (N)));\n             return;\n \n-         elsif Nkind (N) = N_Attribute_Reference  then\n+         elsif Nkind (N) = N_Attribute_Reference then\n             if Attribute_Name (N) = Name_Succ then\n                R := First (Expressions (N));\n                V := Uint_1;\n@@ -2909,7 +2909,7 @@ package body Sem_Eval is\n    -- Eval_Op_Not --\n    -----------------\n \n-   --  The not operation is a  static functions, so the result is potentially\n+   --  The not operation is a static functions, so the result is potentially\n    --  static if the operand is potentially static (RM 4.9(7), 4.9(20)).\n \n    procedure Eval_Op_Not (N : Node_Id) is"}, {"sha": "b3e90b592e761e6141e11524d723d094b7719da1", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 247, "deletions": 397, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -2760,6 +2760,10 @@ package body Sem_Prag is\n       --  is the entity of the related subprogram. Subp_Decl is the declaration\n       --  of the related subprogram. Sets flag Legal when the pragma is legal.\n \n+      procedure Analyze_If_Present (Id : Pragma_Id);\n+      --  Inspect the remainder of the list containing pragma N and look for\n+      --  a pragma that matches Id. If found, analyze the pragma.\n+\n       procedure Analyze_Part_Of\n         (Item_Id : Entity_Id;\n          State   : Node_Id;\n@@ -2888,11 +2892,6 @@ package body Sem_Prag is\n       --  UU_Typ is the related Unchecked_Union type. Flag In_Variant_Part\n       --  should be set when Comp comes from a record variant.\n \n-      procedure Check_Declaration_Order (First : Node_Id; Second : Node_Id);\n-      --  Subsidiary routine to the analysis of pragmas Abstract_State,\n-      --  Initial_Condition and Initializes. Determine whether pragma First\n-      --  appears before pragma Second. If this is not the case, emit an error.\n-\n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n       --  Check if a rep item of the same name as the current pragma is already\n       --  chained as a rep pragma to the given entity. If so give a message\n@@ -3125,10 +3124,6 @@ package body Sem_Prag is\n       --  Determines if the placement of the current pragma is appropriate\n       --  for a configuration pragma.\n \n-      function Is_Followed_By_Pragma (Prag_Nam : Name_Id) return Boolean;\n-      --  Determine whether pragma N is followed by another pragma denoted by\n-      --  its name Prag_Nam. It is assumed that N is a list member.\n-\n       function Is_In_Context_Clause return Boolean;\n       --  Returns True if pragma appears within the context clause of a unit,\n       --  and False for any other placement (does not generate any messages).\n@@ -3349,11 +3344,6 @@ package body Sem_Prag is\n          Subp_Decl := Empty;\n          Legal     := False;\n \n-         --  Reset the Analyzed flag because the pragma requires further\n-         --  analysis.\n-\n-         Set_Analyzed (N, False);\n-\n          GNAT_Pragma;\n          Check_Arg_Count (1);\n \n@@ -3404,6 +3394,37 @@ package body Sem_Prag is\n          Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n       end Analyze_Depends_Global;\n \n+      ------------------------\n+      -- Analyze_If_Present --\n+      ------------------------\n+\n+      procedure Analyze_If_Present (Id : Pragma_Id) is\n+         Stmt : Node_Id;\n+\n+      begin\n+         pragma Assert (Is_List_Member (N));\n+\n+         --  Inspect the declarations or statements following pragma N looking\n+         --  for another pragma whose Id matches the caller's request. If it is\n+         --  available, analyze it.\n+\n+         Stmt := Next (N);\n+         while Present (Stmt) loop\n+            if Nkind (Stmt) = N_Pragma and then Get_Pragma_Id (Stmt) = Id then\n+               Analyze_Pragma (Stmt);\n+               exit;\n+\n+            --  The first source declaration or statement immediately following\n+            --  N ends the region where a pragma may appear.\n+\n+            elsif Comes_From_Source (Stmt) then\n+               exit;\n+            end if;\n+\n+            Next (Stmt);\n+         end loop;\n+      end Analyze_If_Present;\n+\n       ---------------------\n       -- Analyze_Part_Of --\n       ---------------------\n@@ -3603,11 +3624,6 @@ package body Sem_Prag is\n          --  Post_Class.\n \n       begin\n-         --  Reset the Analyzed flag because the pragma requires further\n-         --  analysis.\n-\n-         Set_Analyzed (N, False);\n-\n          --  Change the name of pragmas Pre, Pre_Class, Post and Post_Class to\n          --  offer uniformity among the various kinds of pre/postconditions by\n          --  rewriting the pragma identifier. This allows the retrieval of the\n@@ -3733,6 +3749,11 @@ package body Sem_Prag is\n \n          Subp_Id := Defining_Entity (Subp_Decl);\n \n+         --  Chain the pragma on the contract for further processing by\n+         --  Analyze_Pre_Post_Condition_In_Decl_Part.\n+\n+         Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n+\n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -3744,13 +3765,14 @@ package body Sem_Prag is\n          if Nkind_In (Subp_Decl, N_Subprogram_Body,\n                                  N_Subprogram_Body_Stub)\n          then\n+            --  The legality checks of pragmas Precondition and Postcondition\n+            --  are affected by the SPARK mode in effect and the volatility of\n+            --  the context. Analyze all pragmas in a specific order.\n+\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n+            Analyze_If_Present (Pragma_Volatile_Function);\n             Analyze_Pre_Post_Condition_In_Decl_Part (N);\n          end if;\n-\n-         --  Chain the pragma on the contract for further processing by\n-         --  Analyze_Pre_Post_Condition_In_Decl_Part.\n-\n-         Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n       end Analyze_Pre_Post_Condition;\n \n       -----------------------------------------\n@@ -3772,11 +3794,6 @@ package body Sem_Prag is\n          Body_Id := Empty;\n          Legal   := False;\n \n-         --  Reset the Analyzed flag because the pragma requires further\n-         --  analysis.\n-\n-         Set_Analyzed (N, False);\n-\n          GNAT_Pragma;\n          Check_Arg_Count (1);\n          Check_No_Identifiers;\n@@ -4331,107 +4348,6 @@ package body Sem_Prag is\n          end if;\n       end Check_Component;\n \n-      -----------------------------\n-      -- Check_Declaration_Order --\n-      -----------------------------\n-\n-      procedure Check_Declaration_Order (First : Node_Id; Second : Node_Id) is\n-         procedure Check_Aspect_Specification_Order;\n-         --  Inspect the aspect specifications of the context to determine the\n-         --  proper order.\n-\n-         --------------------------------------\n-         -- Check_Aspect_Specification_Order --\n-         --------------------------------------\n-\n-         procedure Check_Aspect_Specification_Order is\n-            Asp_First  : constant Node_Id := Corresponding_Aspect (First);\n-            Asp_Second : constant Node_Id := Corresponding_Aspect (Second);\n-            Asp        : Node_Id;\n-\n-         begin\n-            --  Both aspects must be part of the same aspect specification list\n-\n-            pragma Assert\n-              (List_Containing (Asp_First) = List_Containing (Asp_Second));\n-\n-            --  Try to reach Second starting from First in a left to right\n-            --  traversal of the aspect specifications.\n-\n-            Asp := Next (Asp_First);\n-            while Present (Asp) loop\n-\n-               --  The order is ok, First is followed by Second\n-\n-               if Asp = Asp_Second then\n-                  return;\n-               end if;\n-\n-               Next (Asp);\n-            end loop;\n-\n-            --  If we get here, then the aspects are out of order\n-\n-            SPARK_Msg_N (\"aspect % cannot come after aspect %\", First);\n-         end Check_Aspect_Specification_Order;\n-\n-         --  Local variables\n-\n-         Stmt : Node_Id;\n-\n-      --  Start of processing for Check_Declaration_Order\n-\n-      begin\n-         --  Cannot check the order if one of the pragmas is missing\n-\n-         if No (First) or else No (Second) then\n-            return;\n-         end if;\n-\n-         --  Set up the error names in case the order is incorrect\n-\n-         Error_Msg_Name_1 := Pragma_Name (First);\n-         Error_Msg_Name_2 := Pragma_Name (Second);\n-\n-         if From_Aspect_Specification (First) then\n-\n-            --  Both pragmas are actually aspects, check their declaration\n-            --  order in the associated aspect specification list. Otherwise\n-            --  First is an aspect and Second a source pragma.\n-\n-            if From_Aspect_Specification (Second) then\n-               Check_Aspect_Specification_Order;\n-            end if;\n-\n-         --  Abstract_States is a source pragma\n-\n-         else\n-            if From_Aspect_Specification (Second) then\n-               SPARK_Msg_N (\"pragma % cannot come after aspect %\", First);\n-\n-            --  Both pragmas are source constructs. Try to reach First from\n-            --  Second by traversing the declarations backwards.\n-\n-            else\n-               Stmt := Prev (Second);\n-               while Present (Stmt) loop\n-\n-                  --  The order is ok, First is followed by Second\n-\n-                  if Stmt = First then\n-                     return;\n-                  end if;\n-\n-                  Prev (Stmt);\n-               end loop;\n-\n-               --  If we get here, then the pragmas are out of order\n-\n-               SPARK_Msg_N (\"pragma % cannot come after pragma %\", First);\n-            end if;\n-         end if;\n-      end Check_Declaration_Order;\n-\n       ----------------------------\n       -- Check_Duplicate_Pragma --\n       ----------------------------\n@@ -5890,39 +5806,6 @@ package body Sem_Prag is\n          end if;\n       end Is_Configuration_Pragma;\n \n-      ---------------------------\n-      -- Is_Followed_By_Pragma --\n-      ---------------------------\n-\n-      function Is_Followed_By_Pragma (Prag_Nam : Name_Id) return Boolean is\n-         Stmt : Node_Id;\n-\n-      begin\n-         pragma Assert (Is_List_Member (N));\n-\n-         --  Inspect the declarations or statements following pragma N looking\n-         --  for another pragma whose name matches the caller's request.\n-\n-         Stmt := Next (N);\n-         while Present (Stmt) loop\n-            if Nkind (Stmt) = N_Pragma\n-              and then Pragma_Name (Stmt) = Prag_Nam\n-            then\n-               return True;\n-\n-            --  The first source declaration or statement immediately following\n-            --  N ends the region where a pragma may appear.\n-\n-            elsif Comes_From_Source (Stmt) then\n-               exit;\n-            end if;\n-\n-            Next (Stmt);\n-         end loop;\n-\n-         return False;\n-      end Is_Followed_By_Pragma;\n-\n       --------------------------\n       -- Is_In_Context_Clause --\n       --------------------------\n@@ -10416,6 +10299,22 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  Chain the pragma on the contract for completeness\n+\n+            Add_Contract_Item (N, Pack_Id);\n+\n+            --  The legality checks of pragmas Abstract_State, Initializes, and\n+            --  Initial_Condition are affected by the SPARK mode in effect. In\n+            --  addition, these three pragmas are subject to an inherent order:\n+\n+            --    1) Abstract_State\n+            --    2) Initializes\n+            --    3) Initial_Condition\n+\n+            --  Analyze all these pragmas in the order outlined above\n+\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -10452,16 +10351,8 @@ package body Sem_Prag is\n                Analyze_Abstract_State (States, Pack_Id);\n             end if;\n \n-            --  Verify the declaration order of pragmas Abstract_State and\n-            --  Initializes.\n-\n-            Check_Declaration_Order\n-              (First  => N,\n-               Second => Get_Pragma (Pack_Id, Pragma_Initializes));\n-\n-            --  Chain the pragma on the contract for completeness\n-\n-            Add_Contract_Item (N, Pack_Id);\n+            Analyze_If_Present (Pragma_Initializes);\n+            Analyze_If_Present (Pragma_Initial_Condition);\n          end Abstract_State;\n \n          ------------\n@@ -11001,7 +10892,7 @@ package body Sem_Prag is\n          --  POLICY_IDENTIFIER ::= Check | Disable | Ignore\n \n          --  Note: Check and Ignore are language-defined. Disable is a GNAT\n-         --  implementation defined addition that results in totally ignoring\n+         --  implementation-defined addition that results in totally ignoring\n          --  the corresponding assertion. If Disable is specified, then the\n          --  argument of the assertion is not even analyzed. This is useful\n          --  when the aspect/pragma argument references entities in a with'ed\n@@ -11213,11 +11104,6 @@ package body Sem_Prag is\n             Obj_Id   : Entity_Id;\n \n          begin\n-            --  Reset the Analyzed flag because the pragma requires further\n-            --  analysis.\n-\n-            Set_Analyzed (N, False);\n-\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_At_Most_N_Arguments  (1);\n@@ -11244,6 +11130,11 @@ package body Sem_Prag is\n \n             if Ekind (Obj_Id) = E_Variable then\n \n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_External_Property_In_Decl_Part.\n+\n+               Add_Contract_Item (N, Obj_Id);\n+\n                --  A pragma that applies to a Ghost entity becomes Ghost for\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n@@ -11256,11 +11147,6 @@ package body Sem_Prag is\n                   Check_Static_Boolean_Expression (Get_Pragma_Arg (Arg1));\n                end if;\n \n-               --  Chain the pragma on the contract for further processing by\n-               --  Analyze_External_Property_In_Decl_Part.\n-\n-               Add_Contract_Item (N, Obj_Id);\n-\n             --  Otherwise the external property applies to a constant\n \n             else\n@@ -12290,11 +12176,6 @@ package body Sem_Prag is\n \n             Obj_Id := Defining_Entity (Obj_Decl);\n \n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Obj_Id);\n-\n             --  The object declaration must be a library-level variable with\n             --  an initialization expression. The expression must depend on\n             --  a variable, parameter, or another constant_after_elaboration,\n@@ -12320,15 +12201,20 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  Chain the pragma on the contract for completeness\n+\n+            Add_Contract_Item (N, Obj_Id);\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Obj_Id);\n+\n             --  Analyze the Boolean expression (if any)\n \n             if Present (Arg1) then\n                Check_Static_Boolean_Expression (Get_Pragma_Arg (Arg1));\n             end if;\n-\n-            --  Chain the pragma on the contract for completeness\n-\n-            Add_Contract_Item (N, Obj_Id);\n          end Constant_After_Elaboration;\n \n          --------------------\n@@ -12384,11 +12270,6 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n-            --  The pragma is analyzed at the end of the declarative part which\n-            --  contains the related subprogram. Reset the analyzed flag.\n-\n-            Set_Analyzed (N, False);\n-\n             --  Ensure the proper placement of the pragma. Contract_Cases must\n             --  be associated with a subprogram declaration or a body that acts\n             --  as a spec.\n@@ -12427,6 +12308,11 @@ package body Sem_Prag is\n \n             Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Contract_Cases_In_Decl_Part.\n+\n+            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -12439,13 +12325,14 @@ package body Sem_Prag is\n             if Nkind_In (Subp_Decl, N_Subprogram_Body,\n                                     N_Subprogram_Body_Stub)\n             then\n+               --  The legality checks of pragma Contract_Cases are affected by\n+               --  the SPARK mode in effect and the volatility of the context.\n+               --  Analyze all pragmas in a specific order.\n+\n+               Analyze_If_Present (Pragma_SPARK_Mode);\n+               Analyze_If_Present (Pragma_Volatile_Function);\n                Analyze_Contract_Cases_In_Decl_Part (N);\n             end if;\n-\n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Contract_Cases_In_Decl_Part.\n-\n-            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n          end Contract_Cases;\n \n          ----------------\n@@ -13145,7 +13032,6 @@ package body Sem_Prag is\n          --    the annotation must instantiate itself.\n \n          when Pragma_Depends => Depends : declare\n-            Global    : Node_Id;\n             Legal     : Boolean;\n             Spec_Id   : Entity_Id;\n             Subp_Decl : Node_Id;\n@@ -13166,34 +13052,20 @@ package body Sem_Prag is\n                if Nkind_In (Subp_Decl, N_Subprogram_Body,\n                                        N_Subprogram_Body_Stub)\n                then\n-                  --  Pragmas Global and Depends must be analyzed in a specific\n-                  --  order, as the latter depends on the former. When the two\n-                  --  pragmas appear out of order, their analyis is triggered\n-                  --  by pragma Global.\n-\n-                  --    pragma Depends ...;\n-                  --    pragma Global  ...;  <analyze both pragmas here>\n-\n-                  --  Wait until pragma Global is encountered\n-\n-                  if Is_Followed_By_Pragma (Name_Global) then\n-                     null;\n+                  --  The legality checks of pragmas Depends and Global are\n+                  --  affected by the SPARK mode in effect and the volatility\n+                  --  of the context. In addition these two pragmas are subject\n+                  --  to an inherent order:\n \n-                  --  Otherwise pragma Depends is the last of the pair. Analyze\n-                  --  both pragmas when they appear in order.\n+                  --    1) Global\n+                  --    2) Depends\n \n-                  --    pragma Global  ...;\n-                  --    pragma Depends ...;  <analyze both pragmas here>\n+                  --  Analyze all these pragmas in the order outlined above\n \n-                  else\n-                     Global := Get_Pragma (Spec_Id, Pragma_Global);\n-\n-                     if Present (Global) then\n-                        Analyze_Global_In_Decl_Part (Global);\n-                     end if;\n-\n-                     Analyze_Depends_In_Decl_Part (N);\n-                  end if;\n+                  Analyze_If_Present (Pragma_SPARK_Mode);\n+                  Analyze_If_Present (Pragma_Volatile_Function);\n+                  Analyze_If_Present (Pragma_Global);\n+                  Analyze_Depends_In_Decl_Part (N);\n                end if;\n             end if;\n          end Depends;\n@@ -14154,12 +14026,21 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n+            --  Chain the pragma on the contract for completeness\n+\n+            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n+\n+            --  The legality checks of pragma Extension_Visible are affected\n+            --  by the SPARK mode in effect. Analyze all pragmas in specific\n+            --  order.\n+\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n \n             --  Mark the pragma as Ghost if the related subprogram is also\n             --  Ghost. This also ensures that any expansion performed further\n             --  below will produce Ghost nodes.\n \n+            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n             Mark_Pragma_As_Ghost (N, Spec_Id);\n \n             --  Examine the formals of the related subprogram\n@@ -14205,10 +14086,6 @@ package body Sem_Prag is\n                Check_Static_Boolean_Expression\n                  (Expression (Get_Argument (N, Spec_Id)));\n             end if;\n-\n-            --  Chain the pragma on the contract for completeness\n-\n-            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n          end Extensions_Visible;\n \n          --------------\n@@ -14673,7 +14550,6 @@ package body Sem_Prag is\n          --    the annotation must instantiate itself.\n \n          when Pragma_Global => Global : declare\n-            Depends   : Node_Id;\n             Legal     : Boolean;\n             Spec_Id   : Entity_Id;\n             Subp_Decl : Node_Id;\n@@ -14694,34 +14570,20 @@ package body Sem_Prag is\n                if Nkind_In (Subp_Decl, N_Subprogram_Body,\n                                        N_Subprogram_Body_Stub)\n                then\n-                  --  Pragmas Global and Depends must be analyzed in a specific\n-                  --  order, as the latter depends on the former. When the two\n-                  --  pragmas appear in order, their analysis is triggered by\n-                  --  pragma Depends.\n+                  --  The legality checks of pragmas Depends and Global are\n+                  --  affected by the SPARK mode in effect and the volatility\n+                  --  of the context. In addition these two pragmas are subject\n+                  --  to an inherent order:\n \n-                  --    pragma Global  ...;\n-                  --    pragma Depends ...;  <analyze both pragmas here>\n+                  --    1) Global\n+                  --    2) Depends\n \n-                  --  Wait until pragma Global is encountered\n+                  --  Analyze all these pragmas in the order outlined above\n \n-                  if Is_Followed_By_Pragma (Name_Depends) then\n-                     null;\n-\n-                  --  Otherwise pragma Global is the last of the pair. Analyze\n-                  --  both pragmas when they are out of order.\n-\n-                  --    pragma Depends ...;\n-                  --    pragma Global  ...;  <analyze both pragmas here>\n-\n-                  else\n-                     Analyze_Global_In_Decl_Part (N);\n-\n-                     Depends := Get_Pragma (Spec_Id, Pragma_Depends);\n-\n-                     if Present (Depends) then\n-                        Analyze_Depends_In_Decl_Part (Depends);\n-                     end if;\n-                  end if;\n+                  Analyze_If_Present (Pragma_SPARK_Mode);\n+                  Analyze_If_Present (Pragma_Volatile_Function);\n+                  Analyze_Global_In_Decl_Part (N);\n+                  Analyze_If_Present (Pragma_Depends);\n                end if;\n             end if;\n          end Global;\n@@ -15315,11 +15177,6 @@ package body Sem_Prag is\n             Pack_Id   : Entity_Id;\n \n          begin\n-            --  Reset the Analyzed flag because the pragma requires further\n-            --  analysis.\n-\n-            Set_Analyzed (N, False);\n-\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n@@ -15341,36 +15198,31 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            --  The pragma must be analyzed at the end of the visible\n-            --  declarations of the related package. Save the pragma for later\n-            --  (see Analyze_Initial_Condition_In_Decl_Part) by adding it to\n-            --  the contract of the package.\n-\n             Pack_Id := Defining_Entity (Pack_Decl);\n \n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Initial_Condition_In_Decl_Part.\n \n-            Mark_Pragma_As_Ghost (N, Pack_Id);\n+            Add_Contract_Item (N, Pack_Id);\n \n-            --  Verify the declaration order of pragma Initial_Condition with\n-            --  respect to pragmas Abstract_State and Initializes when SPARK\n-            --  checks are enabled.\n+            --  The legality checks of pragmas Abstract_State, Initializes, and\n+            --  Initial_Condition are affected by the SPARK mode in effect. In\n+            --  addition, these three pragmas are subject to an inherent order:\n \n-            if SPARK_Mode /= Off then\n-               Check_Declaration_Order\n-                 (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n-                  Second => N);\n+            --    1) Abstract_State\n+            --    2) Initializes\n+            --    3) Initial_Condition\n \n-               Check_Declaration_Order\n-                 (First  => Get_Pragma (Pack_Id, Pragma_Initializes),\n-                  Second => N);\n-            end if;\n+            --  Analyze all these pragmas in the order outlined above\n \n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Initial_Condition_In_Decl_Part.\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n+            Analyze_If_Present (Pragma_Abstract_State);\n+            Analyze_If_Present (Pragma_Initializes);\n \n-            Add_Contract_Item (N, Pack_Id);\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Pack_Id);\n          end Initial_Condition;\n \n          ------------------------\n@@ -15441,11 +15293,6 @@ package body Sem_Prag is\n             Pack_Id   : Entity_Id;\n \n          begin\n-            --  Reset the Analyzed flag because the pragma requires further\n-            --  analysis.\n-\n-            Set_Analyzed (N, False);\n-\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n@@ -15469,25 +15316,31 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Initializes_In_Decl_Part.\n+\n+            Add_Contract_Item (N, Pack_Id);\n+\n+            --  The legality checks of pragmas Abstract_State, Initializes, and\n+            --  Initial_Condition are affected by the SPARK mode in effect. In\n+            --  addition, these three pragmas are subject to an inherent order:\n+\n+            --    1) Abstract_State\n+            --    2) Initializes\n+            --    3) Initial_Condition\n+\n+            --  Analyze all these pragmas in the order outlined above\n+\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n+            Analyze_If_Present (Pragma_Abstract_State);\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n             Mark_Pragma_As_Ghost (N, Pack_Id);\n             Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n \n-            --  Verify the declaration order of pragmas Abstract_State and\n-            --  Initializes when SPARK checks are enabled.\n-\n-            if SPARK_Mode /= Off then\n-               Check_Declaration_Order\n-                 (First  => Get_Pragma (Pack_Id, Pragma_Abstract_State),\n-                  Second => N);\n-            end if;\n-\n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Initializes_In_Decl_Part.\n-\n-            Add_Contract_Item (N, Pack_Id);\n+            Analyze_If_Present (Pragma_Initial_Condition);\n          end Initializes;\n \n          ------------\n@@ -17760,11 +17613,17 @@ package body Sem_Prag is\n                Legal   => Legal);\n \n             if Legal then\n-               State_Id := Entity (State);\n+\n+               --  Add the pragma to the contract of the item. This aids with\n+               --  the detection of a missing but required Part_Of indicator.\n+\n+               Add_Contract_Item (N, Item_Id);\n \n                --  The Part_Of indicator turns an object into a constituent of\n                --  the encapsulating state.\n \n+               State_Id := Entity (State);\n+\n                if Ekind_In (Item_Id, E_Constant, E_Variable) then\n                   Append_Elmt (Item_Id, Part_Of_Constituents (State_Id));\n                   Set_Encapsulating_State (Item_Id, State_Id);\n@@ -17778,11 +17637,6 @@ package body Sem_Prag is\n                      State_Id => State_Id,\n                      Instance => Stmt);\n                end if;\n-\n-               --  Add the pragma to the contract of the item. This aids with\n-               --  the detection of a missing but required Part_Of indicator.\n-\n-               Add_Contract_Item (N, Item_Id);\n             end if;\n          end Part_Of;\n \n@@ -18974,10 +18828,9 @@ package body Sem_Prag is\n          --    the related generic subprogram body is instantiated.\n \n          when Pragma_Refined_Depends => Refined_Depends : declare\n-            Body_Id    : Entity_Id;\n-            Legal      : Boolean;\n-            Ref_Global : Node_Id;\n-            Spec_Id    : Entity_Id;\n+            Body_Id : Entity_Id;\n+            Legal   : Boolean;\n+            Spec_Id : Entity_Id;\n \n          begin\n             Analyze_Refined_Depends_Global_Post (Spec_Id, Body_Id, Legal);\n@@ -18989,34 +18842,20 @@ package body Sem_Prag is\n \n                Add_Contract_Item (N, Body_Id);\n \n-               --  Pragmas Refined_Global and Refined_Depends must be analyzed\n-               --  in a specific order, as the latter depends on the former.\n-               --  When the two pragmas appear out of order, their analysis is\n-               --  triggered by pragma Refined_Global.\n+               --  The legality checks of pragmas Refined_Depends and\n+               --  Refined_Global are affected by the SPARK mode in effect and\n+               --  the volatility of the context. In addition these two pragmas\n+               --  are subject to an inherent order:\n \n-               --    pragma Refined_Depends ...;\n-               --    pragma Refined_Global  ...;  <analyze both pragmas here>\n+               --    1) Refined_Global\n+               --    2) Refined_Depends\n \n-               --  Wait until pragma Refined_Global is enountered\n+               --  Analyze all these pragmas in the order outlined above\n \n-               if Is_Followed_By_Pragma (Name_Refined_Global) then\n-                  null;\n-\n-               --  Otherwise pragma Refined_Depends is the last of the pair.\n-               --  Analyze both pragmas when they appear in order.\n-\n-               --    pragma Refined_Global  ...;\n-               --    pragma Refined_Depends ...;  <analyze both pragmas here>\n-\n-               else\n-                  Ref_Global := Get_Pragma (Body_Id, Pragma_Refined_Global);\n-\n-                  if Present (Ref_Global) then\n-                     Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n-                  end if;\n-\n-                  Analyze_Refined_Depends_In_Decl_Part (N);\n-               end if;\n+               Analyze_If_Present (Pragma_SPARK_Mode);\n+               Analyze_If_Present (Pragma_Volatile_Function);\n+               Analyze_If_Present (Pragma_Refined_Global);\n+               Analyze_Refined_Depends_In_Decl_Part (N);\n             end if;\n          end Refined_Depends;\n \n@@ -19057,10 +18896,9 @@ package body Sem_Prag is\n          --    the related generic subprogram body is instantiated.\n \n          when Pragma_Refined_Global => Refined_Global : declare\n-            Body_Id     : Entity_Id;\n-            Legal       : Boolean;\n-            Ref_Depends : Node_Id;\n-            Spec_Id     : Entity_Id;\n+            Body_Id : Entity_Id;\n+            Legal   : Boolean;\n+            Spec_Id : Entity_Id;\n \n          begin\n             Analyze_Refined_Depends_Global_Post (Spec_Id, Body_Id, Legal);\n@@ -19072,34 +18910,20 @@ package body Sem_Prag is\n \n                Add_Contract_Item (N, Body_Id);\n \n-               --  Pragmas Refined_Global and Refined_Depends must be analyzed\n-               --  in a specific order, as the latter depends on the former.\n-               --  When the two pragmas are in order, their analysis must be\n-               --  triggered by pragma Refined_Depends.\n-\n-               --    pragma Refined_Global  ...;\n-               --    pragma Refined_Depends ...;  <analyze both pragmas here>\n-\n-               --  Wait until pragma Refined_Depends is encountered\n+               --  The legality checks of pragmas Refined_Depends and\n+               --  Refined_Global are affected by the SPARK mode in effect and\n+               --  the volatility of the context. In addition these two pragmas\n+               --  are subject to an inherent order:\n \n-               if Is_Followed_By_Pragma (Name_Refined_Depends) then\n-                  null;\n-\n-               --  Otherwise pragma Refined_Global is the last of the pair.\n-               --  Analyze both pragmas when they are out of order.\n+               --    1) Refined_Global\n+               --    2) Refined_Depends\n \n-               --    pragma Refined_Depends ...;\n-               --    pragma Refined_Global  ...;  <analyze both pragmas here>\n+               --  Analyze all these pragmas in the order outlined above\n \n-               else\n-                  Analyze_Refined_Global_In_Decl_Part (N);\n-\n-                  Ref_Depends := Get_Pragma (Body_Id, Pragma_Refined_Depends);\n-\n-                  if Present (Ref_Depends) then\n-                     Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n-                  end if;\n-               end if;\n+               Analyze_If_Present (Pragma_SPARK_Mode);\n+               Analyze_If_Present (Pragma_Volatile_Function);\n+               Analyze_Refined_Global_In_Decl_Part (N);\n+               Analyze_If_Present (Pragma_Refined_Depends);\n             end if;\n          end Refined_Global;\n \n@@ -19140,16 +18964,23 @@ package body Sem_Prag is\n             --  body because it cannot benefit from forward references.\n \n             if Legal then\n+\n+               --  Chain the pragma on the contract for completeness\n+\n+               Add_Contract_Item (N, Body_Id);\n+\n+               --  The legality checks of pragma Refined_Post are affected by\n+               --  the SPARK mode in effect and the volatility of the context.\n+               --  Analyze all pragmas in a specific order.\n+\n+               Analyze_If_Present (Pragma_SPARK_Mode);\n+               Analyze_If_Present (Pragma_Volatile_Function);\n                Analyze_Pre_Post_Condition_In_Decl_Part (N);\n \n                --  Currently it is not possible to inline pre/postconditions on\n                --  a subprogram subject to pragma Inline_Always.\n \n                Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n-\n-               --  Chain the pragma on the contract for completeness\n-\n-               Add_Contract_Item (N, Body_Id);\n             end if;\n          end Refined_Post;\n \n@@ -19196,11 +19027,6 @@ package body Sem_Prag is\n             Spec_Id   : Entity_Id;\n \n          begin\n-            --  Reset the Analyzed flag because the pragma requires further\n-            --  analysis.\n-\n-            Set_Analyzed (N, False);\n-\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n@@ -19222,6 +19048,16 @@ package body Sem_Prag is\n \n             Spec_Id := Corresponding_Spec (Pack_Decl);\n \n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Refined_State_In_Decl_Part.\n+\n+            Add_Contract_Item (N, Defining_Entity (Pack_Decl));\n+\n+            --  The legality checks of pragma Refined_State are affected by the\n+            --  SPARK mode in effect. Analyze all pragmas in a specific order.\n+\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -19241,11 +19077,6 @@ package body Sem_Prag is\n                   & \"states\", N, Spec_Id);\n                return;\n             end if;\n-\n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Refined_State_In_Decl_Part.\n-\n-            Add_Contract_Item (N, Defining_Entity (Pack_Decl));\n          end Refined_State;\n \n          -----------------------\n@@ -21092,6 +20923,7 @@ package body Sem_Prag is\n                   Prag := Contract_Test_Cases (Items);\n                   while Present (Prag) loop\n                      if Pragma_Name (Prag) = Name_Test_Case\n+                       and then Prag /= N\n                        and then String_Equal\n                                   (Name, Get_Name_From_CTC_Pragma (Prag))\n                      then\n@@ -21115,11 +20947,6 @@ package body Sem_Prag is\n          --  Start of processing for Test_Case\n \n          begin\n-            --  Reset the Analyzed flag because the pragma requires further\n-            --  analysis.\n-\n-            Set_Analyzed (N, False);\n-\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments (4);\n@@ -21194,7 +21021,7 @@ package body Sem_Prag is\n               and then Nkind_In (Context, N_Generic_Package_Declaration,\n                                           N_Package_Declaration)\n             then\n-               Subp_Id := Defining_Entity (Subp_Decl);\n+               null;\n \n             --  Otherwise the placement is illegal\n \n@@ -21203,6 +21030,13 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            Subp_Id := Defining_Entity (Subp_Decl);\n+\n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Test_Case_In_Decl_Part.\n+\n+            Add_Contract_Item (N, Subp_Id);\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -21239,13 +21073,14 @@ package body Sem_Prag is\n             if Nkind_In (Subp_Decl, N_Subprogram_Body,\n                                     N_Subprogram_Body_Stub)\n             then\n+               --  The legality checks of pragma Test_Case are affected by the\n+               --  SPARK mode in effect and the volatility of the context.\n+               --  Analyze all pragmas in a specific order.\n+\n+               Analyze_If_Present (Pragma_SPARK_Mode);\n+               Analyze_If_Present (Pragma_Volatile_Function);\n                Analyze_Test_Case_In_Decl_Part (N);\n             end if;\n-\n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Test_Case_In_Decl_Part.\n-\n-            Add_Contract_Item (N, Subp_Id);\n          end Test_Case;\n \n          --------------------------\n@@ -22113,6 +21948,16 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  Chain the pragma on the contract for completeness\n+\n+            Add_Contract_Item (N, Spec_Id);\n+\n+            --  The legality checks of pragma Volatile_Function are affected by\n+            --  the SPARK mode in effect. Analyze all pragmas in a specific\n+            --  order.\n+\n+            Analyze_If_Present (Pragma_SPARK_Mode);\n+\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -22147,8 +21992,6 @@ package body Sem_Prag is\n             if Present (Arg1) then\n                Check_Static_Boolean_Expression (Get_Pragma_Arg (Arg1));\n             end if;\n-\n-            Add_Contract_Item (N, Spec_Id);\n          end Volatile_Function;\n \n          ----------------------\n@@ -25221,11 +25064,18 @@ package body Sem_Prag is\n          if Is_Entity_Name (State) then\n             State_Id := Entity_Of (State);\n \n+            --  When the abstract state is undefined, it appears as Any_Id. Do\n+            --  not continue with the analysis of the clause.\n+\n+            if State_Id = Any_Id then\n+               return;\n+\n             --  Catch any attempts to re-refine a state or refine a state that\n             --  is not defined in the package declaration.\n \n-            if Ekind (State_Id) = E_Abstract_State then\n+            elsif Ekind (State_Id) = E_Abstract_State then\n                Check_Matching_State;\n+\n             else\n                SPARK_Msg_NE\n                  (\"& must denote an abstract state\", State, State_Id);"}, {"sha": "57067f49428ec18bd2d189ddaae1d1e1c8ec189f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -251,7 +251,7 @@ package body Sem_Res is\n      (N   : Node_Id;\n       Op  : Entity_Id;\n       Typ : Entity_Id);\n-   --  An operator can rename another, e.g. in  an instantiation. In that\n+   --  An operator can rename another, e.g. in an instantiation. In that\n    --  case, the proper operator node must be constructed and resolved.\n \n    procedure Set_String_Literal_Subtype (N : Node_Id; Typ : Entity_Id);\n@@ -2285,7 +2285,7 @@ package body Sem_Res is\n                      then\n                         exit Interp_Loop;\n \n-                     elsif Nkind (N) in  N_Unary_Op\n+                     elsif Nkind (N) in N_Unary_Op\n                        and then Etype (Right_Opnd (N)) = Any_Type\n                      then\n                         exit Interp_Loop;\n@@ -11234,7 +11234,7 @@ package body Sem_Res is\n       New_N   : Node_Id;\n \n    begin\n-      if Nkind (N) in  N_Binary_Op then\n+      if Nkind (N) in N_Binary_Op then\n          Append (Left_Opnd (N), Actuals);\n       end if;\n "}, {"sha": "d5be94ec90ecd81209eb62871ec3c1b879fbab8a", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d7ef70aae92c62a6c39233e899b9ed70ace566/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=21d7ef70aae92c62a6c39233e899b9ed70ace566", "patch": "@@ -1977,7 +1977,7 @@ package body Sem_Type is\n                   return It2;\n                end if;\n \n-            elsif Nkind (N) in  N_Unary_Op then\n+            elsif Nkind (N) in N_Unary_Op then\n                if Etype (Right_Opnd (N)) = Etype (First_Formal (Nam1)) then\n                   return It1;\n                else"}]}