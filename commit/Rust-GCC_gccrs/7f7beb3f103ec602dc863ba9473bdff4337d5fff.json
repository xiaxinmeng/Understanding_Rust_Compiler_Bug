{"sha": "7f7beb3f103ec602dc863ba9473bdff4337d5fff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y3YmViM2YxMDNlYzYwMmRjODYzYmE5NDczYmRmZjQzMzdkNWZmZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-25T01:33:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-25T01:33:28Z"}, "message": "ipa.c (cgraph_non_local_node_p_1, [...]): Move to ipa-visibility.c\n\n\n\t* ipa.c (cgraph_non_local_node_p_1, cgraph_local_node_p, address_taken_from_non_vtable_p,\n\tcomdat_can_be_unshared_p_1, comdat_can_be_unshared_p, cgraph_externally_visible_p,\n\tvarpool_externally_visible_p, can_replace_by_local_alias,\n\tupdate_visibility_by_resolution_info, function_and_variable_visibility,\n\tpass_data_ipa_function_and_variable_visibility,\n\tmake_pass_ipa_function_and_variable_visibility,\n\twhole_program_function_and_variable_visibility,\n\tpass_data_ipa_whole_program_visibility,\n\tmake_pass_ipa_whole_program_visibility): Move to ipa-visibility.c\n\t* cgraph.h (cgraph_local_node_p): Declare.\n\t* ipa-visibility.c: New file.\n\t* Makefile.in (OBJS): Add ipa-visiblity.o\n\nFrom-SVN: r210907", "tree": {"sha": "de602b53be64b261cf9867d72fbeff7b24e4f6a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de602b53be64b261cf9867d72fbeff7b24e4f6a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f7beb3f103ec602dc863ba9473bdff4337d5fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7beb3f103ec602dc863ba9473bdff4337d5fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7beb3f103ec602dc863ba9473bdff4337d5fff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7beb3f103ec602dc863ba9473bdff4337d5fff/comments", "author": null, "committer": null, "parents": [{"sha": "876814dba3103ceafc6a3366f9160ab879a901f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876814dba3103ceafc6a3366f9160ab879a901f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876814dba3103ceafc6a3366f9160ab879a901f9"}], "stats": {"total": 1460, "additions": 778, "deletions": 682}, "files": [{"sha": "05f5e3efb1e2e587ee280261816fdcd1a4843a0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f7beb3f103ec602dc863ba9473bdff4337d5fff", "patch": "@@ -1,3 +1,18 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa.c (cgraph_non_local_node_p_1, cgraph_local_node_p, address_taken_from_non_vtable_p,\n+\tcomdat_can_be_unshared_p_1, comdat_can_be_unshared_p, cgraph_externally_visible_p,\n+\tvarpool_externally_visible_p, can_replace_by_local_alias,\n+\tupdate_visibility_by_resolution_info, function_and_variable_visibility,\n+\tpass_data_ipa_function_and_variable_visibility,\n+\tmake_pass_ipa_function_and_variable_visibility,\n+\twhole_program_function_and_variable_visibility,\n+\tpass_data_ipa_whole_program_visibility,\n+\tmake_pass_ipa_whole_program_visibility): Move to ipa-visibility.c\n+\t* cgraph.h (cgraph_local_node_p): Declare.\n+\t* ipa-visibility.c: New file.\n+\t* Makefile.in (OBJS): Add ipa-visiblity.o\n+\n 2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gimple-fold.c (can_refer_decl_in_current_unit_p): Be sure"}, {"sha": "335018606e5f78118fd9df52f1263f9094f2c2ba", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7f7beb3f103ec602dc863ba9473bdff4337d5fff", "patch": "@@ -1270,6 +1270,7 @@ OBJS = \\\n \tipa-split.o \\\n \tipa-inline.o \\\n \tipa-comdats.o \\\n+\tipa-visibility.o \\\n \tipa-inline-analysis.o \\\n \tipa-inline-transform.o \\\n \tipa-profile.o \\"}, {"sha": "91bcc000369ae56c7a7aad1dd1ab5ec298d59ef3", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7f7beb3f103ec602dc863ba9473bdff4337d5fff", "patch": "@@ -963,6 +963,10 @@ void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n bool varpool_externally_visible_p (varpool_node *);\n \n+/* In ipa-visibility.c */\n+bool cgraph_local_node_p (struct cgraph_node *);\n+\n+\n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n bool cgraph_optimize_for_size_p (struct cgraph_node *);"}, {"sha": "b091071d448e20b824fc3c90d7be2a2c67525499", "filename": "gcc/ipa-visibility.c", "status": "added", "additions": 758, "deletions": 0, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=7f7beb3f103ec602dc863ba9473bdff4337d5fff", "patch": "@@ -0,0 +1,758 @@\n+/* IPA visibility pass\n+   Copyright (C) 2003-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements two related passes: \n+\n+     - pass_data_ipa_function_and_variable_visibility run just after\n+       symbol table, references and callgraph are built\n+\n+     - pass_data_ipa_function_and_variable_visibility run as first\n+       proper IPA pass (that is after early optimization, or, (with LTO)\n+       as a first pass done at link-time.\n+\n+   Purpose of both passes is to set correctly visibility properties\n+   of all symbols.  This includes:\n+\n+    - Symbol privatization:\n+\n+      Some symbols that are declared public by frontend may be\n+      turned local (either by -fwhole-program flag, by linker plugin feedback\n+      or by other reasons)\n+\n+    - Discovery of local functions:\n+\n+      A local function is one whose calls can occur only in the current\n+      compilation unit and all its calls are explicit, so we can change\n+      its calling convention.  We simply mark all static functions whose\n+      address is not taken as local.\n+\n+      externally_visible flag is set for symbols that can not be privatized.\n+      For privatized symbols we clear TREE_PUBLIC flag and dismantle comdat\n+      group.\n+\n+    - Dismantling of comdat groups:\n+\n+      Comdat group represent a section that may be replaced by linker by\n+      a different copy of the same section from other unit.\n+      If we have resolution information (from linker plugin) and we know that\n+      a given comdat gorup is prevailing, we can dismantle it and turn symbols\n+      into normal symbols.  If the resolution information says that the\n+      section was previaled by copy from non-LTO code, we can also dismantle\n+      it and turn all symbols into external.\n+\n+    - Local aliases:\n+\n+      Some symbols can be interposed by dynamic linker. Refering to these\n+      symbols is expensive, since it needs to be overwritable by the dynamic\n+      linker.  In some cases we know that the interposition does not change\n+      semantic and we can always refer to a local copy (as in the case of\n+      inline function).  In this case we produce a local alias and redirect\n+      calls to it.\n+\n+      TODO: This should be done for references, too.\n+\n+    - Removal of static ocnstructors and destructors that have no side effects.\n+\n+    - Regularization of several oddities introduced by frontends that may\n+      be impractical later in the optimization queue.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"cgraph.h\"\n+#include \"tree-pass.h\"\n+#include \"pointer-set.h\"\n+#include \"calls.h\"\n+#include \"gimple-expr.h\"\n+\n+/* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n+\n+static bool\n+cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+   /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n+   return !(cgraph_only_called_directly_or_aliased_p (node)\n+\t    && !ipa_ref_has_aliases_p (&node->ref_list)\n+\t    && node->definition\n+\t    && !DECL_EXTERNAL (node->decl)\n+\t    && !node->externally_visible\n+\t    && !node->used_from_other_partition\n+\t    && !node->in_other_partition);\n+}\n+\n+/* Return true when function can be marked local.  */\n+\n+bool\n+cgraph_local_node_p (struct cgraph_node *node)\n+{\n+   struct cgraph_node *n = cgraph_function_or_thunk_node (node, NULL);\n+\n+   /* FIXME: thunks can be considered local, but we need prevent i386\n+      from attempting to change calling convention of them.  */\n+   if (n->thunk.thunk_p)\n+     return false;\n+   return !cgraph_for_node_and_aliases (n,\n+\t\t\t\t\tcgraph_non_local_node_p_1, NULL, true);\n+\t\t\t\t\t\n+}\n+\n+/* Return true when there is a reference to node and it is not vtable.  */\n+static bool\n+address_taken_from_non_vtable_p (symtab_node *node)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n+\t\t\t\t\t     i, ref); i++)\n+    if (ref->use == IPA_REF_ADDR)\n+      {\n+\tvarpool_node *node;\n+\tif (is_a <cgraph_node *> (ref->referring))\n+\t  return true;\n+\tnode = ipa_ref_referring_varpool_node (ref);\n+\tif (!DECL_VIRTUAL_P (node->decl))\n+\t  return true;\n+      }\n+  return false;\n+}\n+\n+/* A helper for comdat_can_be_unshared_p.  */\n+\n+static bool\n+comdat_can_be_unshared_p_1 (symtab_node *node)\n+{\n+  if (!node->externally_visible)\n+    return true;\n+  /* When address is taken, we don't know if equality comparison won't\n+     break eventually. Exception are virutal functions, C++\n+     constructors/destructors and vtables, where this is not possible by\n+     language standard.  */\n+  if (!DECL_VIRTUAL_P (node->decl)\n+      && (TREE_CODE (node->decl) != FUNCTION_DECL\n+\t  || (!DECL_CXX_CONSTRUCTOR_P (node->decl)\n+\t      && !DECL_CXX_DESTRUCTOR_P (node->decl)))\n+      && address_taken_from_non_vtable_p (node))\n+    return false;\n+\n+  /* If the symbol is used in some weird way, better to not touch it.  */\n+  if (node->force_output)\n+    return false;\n+\n+  /* Explicit instantiations needs to be output when possibly\n+     used externally.  */\n+  if (node->forced_by_abi\n+      && TREE_PUBLIC (node->decl)\n+      && (node->resolution != LDPR_PREVAILING_DEF_IRONLY\n+          && !flag_whole_program))\n+    return false;\n+\n+  /* Non-readonly and volatile variables can not be duplicated.  */\n+  if (is_a <varpool_node *> (node)\n+      && (!TREE_READONLY (node->decl)\n+\t  || TREE_THIS_VOLATILE (node->decl)))\n+    return false;\n+  return true;\n+}\n+\n+/* COMDAT functions must be shared only if they have address taken,\n+   otherwise we can produce our own private implementation with\n+   -fwhole-program.  \n+   Return true when turning COMDAT functoin static can not lead to wrong\n+   code when the resulting object links with a library defining same COMDAT.\n+\n+   Virtual functions do have their addresses taken from the vtables,\n+   but in C++ there is no way to compare their addresses for equality.  */\n+\n+static bool\n+comdat_can_be_unshared_p (symtab_node *node)\n+{\n+  if (!comdat_can_be_unshared_p_1 (node))\n+    return false;\n+  if (node->same_comdat_group)\n+    {\n+      symtab_node *next;\n+\n+      /* If more than one function is in the same COMDAT group, it must\n+         be shared even if just one function in the comdat group has\n+         address taken.  */\n+      for (next = node->same_comdat_group;\n+\t   next != node; next = next->same_comdat_group)\n+        if (!comdat_can_be_unshared_p_1 (next))\n+          return false;\n+    }\n+  return true;\n+}\n+\n+/* Return true when function NODE should be considered externally visible.  */\n+\n+static bool\n+cgraph_externally_visible_p (struct cgraph_node *node,\n+\t\t\t     bool whole_program)\n+{\n+  if (!node->definition)\n+    return false;\n+  if (!TREE_PUBLIC (node->decl)\n+      || DECL_EXTERNAL (node->decl))\n+    return false;\n+\n+  /* Do not try to localize built-in functions yet.  One of problems is that we\n+     end up mangling their asm for WHOPR that makes it impossible to call them\n+     using the implicit built-in declarations anymore.  Similarly this enables\n+     us to remove them as unreachable before actual calls may appear during\n+     expansion or folding.  */\n+  if (DECL_BUILT_IN (node->decl))\n+    return true;\n+\n+  /* If linker counts on us, we must preserve the function.  */\n+  if (symtab_used_from_object_file_p (node))\n+    return true;\n+  if (DECL_PRESERVE_P (node->decl))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\",\n+\t\t\tDECL_ATTRIBUTES (node->decl)))\n+    return true;\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+      && lookup_attribute (\"dllexport\",\n+\t\t\t   DECL_ATTRIBUTES (node->decl)))\n+    return true;\n+  if (node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    return false;\n+  /* When doing LTO or whole program, we can bring COMDAT functoins static.\n+     This improves code quality and we know we will duplicate them at most twice\n+     (in the case that we are not using plugin and link with object file\n+      implementing same COMDAT)  */\n+  if ((in_lto_p || whole_program)\n+      && DECL_COMDAT (node->decl)\n+      && comdat_can_be_unshared_p (node))\n+    return false;\n+\n+  /* When doing link time optimizations, hidden symbols become local.  */\n+  if (in_lto_p\n+      && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (node->decl) == VISIBILITY_INTERNAL)\n+      /* Be sure that node is defined in IR file, not in other object\n+\t file.  In that case we don't set used_from_other_object_file.  */\n+      && node->definition)\n+    ;\n+  else if (!whole_program)\n+    return true;\n+\n+  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true when variable VNODE should be considered externally visible.  */\n+\n+bool\n+varpool_externally_visible_p (varpool_node *vnode)\n+{\n+  if (DECL_EXTERNAL (vnode->decl))\n+    return true;\n+\n+  if (!TREE_PUBLIC (vnode->decl))\n+    return false;\n+\n+  /* If linker counts on us, we must preserve the function.  */\n+  if (symtab_used_from_object_file_p (vnode))\n+    return true;\n+\n+  if (DECL_HARD_REGISTER (vnode->decl))\n+    return true;\n+  if (DECL_PRESERVE_P (vnode->decl))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\",\n+\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n+    return true;\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+      && lookup_attribute (\"dllexport\",\n+\t\t\t   DECL_ATTRIBUTES (vnode->decl)))\n+    return true;\n+\n+  /* See if we have linker information about symbol not being used or\n+     if we need to make guess based on the declaration.\n+\n+     Even if the linker clams the symbol is unused, never bring internal\n+     symbols that are declared by user as used or externally visible.\n+     This is needed for i.e. references from asm statements.   */\n+  if (symtab_used_from_object_file_p (vnode))\n+    return true;\n+  if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    return false;\n+\n+  /* As a special case, the COMDAT virtual tables can be unshared.\n+     In LTO mode turn vtables into static variables.  The variable is readonly,\n+     so this does not enable more optimization, but referring static var\n+     is faster for dynamic linking.  Also this match logic hidding vtables\n+     from LTO symbol tables.  */\n+  if ((in_lto_p || flag_whole_program)\n+      && DECL_COMDAT (vnode->decl)\n+      && comdat_can_be_unshared_p (vnode))\n+    return false;\n+\n+  /* When doing link time optimizations, hidden symbols become local.  */\n+  if (in_lto_p\n+      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n+      /* Be sure that node is defined in IR file, not in other object\n+\t file.  In that case we don't set used_from_other_object_file.  */\n+      && vnode->definition)\n+    ;\n+  else if (!flag_whole_program)\n+    return true;\n+\n+  /* Do not attempt to privatize COMDATS by default.\n+     This would break linking with C++ libraries sharing\n+     inline definitions.\n+\n+     FIXME: We can do so for readonly vars with no address taken and\n+     possibly also for vtables since no direct pointer comparsion is done.\n+     It might be interesting to do so to reduce linking overhead.  */\n+  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n+    return true;\n+  return false;\n+}\n+\n+/* Return true if reference to NODE can be replaced by a local alias.\n+   Local aliases save dynamic linking overhead and enable more optimizations.\n+ */\n+\n+bool\n+can_replace_by_local_alias (symtab_node *node)\n+{\n+  return (symtab_node_availability (node) > AVAIL_OVERWRITABLE\n+\t  && !symtab_can_be_discarded (node));\n+}\n+\n+/* In LTO we can remove COMDAT groups and weak symbols.\n+   Either turn them into normal symbols or external symbol depending on \n+   resolution info.  */\n+\n+static void\n+update_visibility_by_resolution_info (symtab_node * node)\n+{\n+  bool define;\n+\n+  if (!node->externally_visible\n+      || (!DECL_WEAK (node->decl) && !DECL_ONE_ONLY (node->decl))\n+      || node->resolution == LDPR_UNKNOWN)\n+    return;\n+\n+  define = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t    || node->resolution == LDPR_PREVAILING_DEF\n+\t    || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n+\n+  /* The linker decisions ought to agree in the whole group.  */\n+  if (node->same_comdat_group)\n+    for (symtab_node *next = node->same_comdat_group;\n+\t next != node; next = next->same_comdat_group)\n+      gcc_assert (!node->externally_visible\n+\t\t  || define == (next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t        || next->resolution == LDPR_PREVAILING_DEF\n+\t\t\t        || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP));\n+\n+  if (node->same_comdat_group)\n+    for (symtab_node *next = node->same_comdat_group;\n+\t next != node; next = next->same_comdat_group)\n+      {\n+\tnext->set_comdat_group (NULL);\n+\tDECL_WEAK (next->decl) = false;\n+\tif (next->externally_visible\n+\t    && !define)\n+\t  DECL_EXTERNAL (next->decl) = true;\n+      }\n+  node->set_comdat_group (NULL);\n+  DECL_WEAK (node->decl) = false;\n+  if (!define)\n+    DECL_EXTERNAL (node->decl) = true;\n+  symtab_dissolve_same_comdat_group_list (node);\n+}\n+\n+/* Decide on visibility of all symbols.  */\n+\n+static unsigned int\n+function_and_variable_visibility (bool whole_program)\n+{\n+  struct cgraph_node *node;\n+  varpool_node *vnode;\n+\n+  /* All aliases should be procssed at this point.  */\n+  gcc_checking_assert (!alias_pairs || !alias_pairs->length ());\n+\n+  FOR_EACH_FUNCTION (node)\n+    {\n+      int flags = flags_from_decl_or_type (node->decl);\n+\n+      /* Optimize away PURE and CONST constructors and destructors.  */\n+      if (optimize\n+\t  && (flags & (ECF_CONST | ECF_PURE))\n+\t  && !(flags & ECF_LOOPING_CONST_OR_PURE))\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t}\n+\n+      /* Frontends and alias code marks nodes as needed before parsing is finished.\n+\t We may end up marking as node external nodes where this flag is meaningless\n+\t strip it.  */\n+      if (DECL_EXTERNAL (node->decl) || !node->definition)\n+\t{\n+\t  node->force_output = 0;\n+\t  node->forced_by_abi = 0;\n+\t}\n+\n+      /* C++ FE on lack of COMDAT support create local COMDAT functions\n+\t (that ought to be shared but can not due to object format\n+\t limitations).  It is necessary to keep the flag to make rest of C++ FE\n+\t happy.  Clear the flag here to avoid confusion in middle-end.  */\n+      if (DECL_COMDAT (node->decl) && !TREE_PUBLIC (node->decl))\n+        DECL_COMDAT (node->decl) = 0;\n+\n+      /* For external decls stop tracking same_comdat_group. It doesn't matter\n+\t what comdat group they are in when they won't be emitted in this TU.  */\n+      if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  symtab_node *n;\n+\n+\t  for (n = node->same_comdat_group;\n+\t       n != node;\n+\t       n = n->same_comdat_group)\n+\t      /* If at least one of same comdat group functions is external,\n+\t\t all of them have to be, otherwise it is a front-end bug.  */\n+\t      gcc_assert (DECL_EXTERNAL (n->decl));\n+#endif\n+\t  symtab_dissolve_same_comdat_group_list (node);\n+\t}\n+      gcc_assert ((!DECL_WEAK (node->decl)\n+\t\t  && !DECL_COMDAT (node->decl))\n+      \t          || TREE_PUBLIC (node->decl)\n+\t\t  || node->weakref\n+\t\t  || DECL_EXTERNAL (node->decl));\n+      if (cgraph_externally_visible_p (node, whole_program))\n+        {\n+\t  gcc_assert (!node->global.inlined_to);\n+\t  node->externally_visible = true;\n+\t}\n+      else\n+\t{\n+\t  node->externally_visible = false;\n+\t  node->forced_by_abi = false;\n+\t}\n+      if (!node->externally_visible\n+\t  && node->definition && !node->weakref\n+\t  && !DECL_EXTERNAL (node->decl))\n+\t{\n+\t  gcc_assert (whole_program || in_lto_p\n+\t\t      || !TREE_PUBLIC (node->decl));\n+\t  node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t|| node->unique_name\n+\t\t\t\t|| node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t&& TREE_PUBLIC (node->decl));\n+\t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n+\t    {\n+\t      symtab_node *next = node;\n+\n+\t      /* Set all members of comdat group local.  */\n+\t      if (node->same_comdat_group)\n+\t\tfor (next = node->same_comdat_group;\n+\t\t     next != node;\n+\t\t     next = next->same_comdat_group)\n+\t\t{\n+\t\t  next->set_comdat_group (NULL);\n+\t\t  symtab_make_decl_local (next->decl);\n+\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t\t|| next->unique_name\n+\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t       && TREE_PUBLIC (next->decl));\n+\t\t}\n+\t      /* cgraph_externally_visible_p has already checked all other nodes\n+\t         in the group and they will all be made local.  We need to\n+\t         dissolve the group at once so that the predicate does not\n+\t         segfault though. */\n+\t      symtab_dissolve_same_comdat_group_list (node);\n+\t    }\n+\t  if (TREE_PUBLIC (node->decl))\n+\t    node->set_comdat_group (NULL);\n+\t  symtab_make_decl_local (node->decl);\n+\t}\n+\n+      if (node->thunk.thunk_p\n+\t  && TREE_PUBLIC (node->decl))\n+\t{\n+\t  struct cgraph_node *decl_node = node;\n+\n+\t  decl_node = cgraph_function_node (decl_node->callees->callee, NULL);\n+\n+\t  /* Thunks have the same visibility as function they are attached to.\n+\t     Make sure the C++ front end set this up properly.  */\n+\t  if (DECL_ONE_ONLY (decl_node->decl))\n+\t    {\n+\t      gcc_checking_assert (DECL_COMDAT (node->decl)\n+\t\t\t\t   == DECL_COMDAT (decl_node->decl));\n+\t      gcc_checking_assert (symtab_in_same_comdat_p (node, decl_node));\n+\t      gcc_checking_assert (node->same_comdat_group);\n+\t    }\n+\t  node->forced_by_abi = decl_node->forced_by_abi;\n+\t  if (DECL_EXTERNAL (decl_node->decl))\n+\t    DECL_EXTERNAL (node->decl) = 1;\n+\t}\n+\n+      update_visibility_by_resolution_info (node);\n+    }\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      node->local.local |= cgraph_local_node_p (node);\n+\n+      /* If we know that function can not be overwritten by a different semantics\n+\t and moreover its section can not be discarded, replace all direct calls\n+\t by calls to an nonoverwritable alias.  This make dynamic linking\n+\t cheaper and enable more optimization.\n+\n+\t TODO: We can also update virtual tables.  */\n+      if (node->callers && can_replace_by_local_alias (node))\n+\t{\n+\t  struct cgraph_node *alias = cgraph (symtab_nonoverwritable_alias (node));\n+\n+\t  if (alias && alias != node)\n+\t    {\n+\t      while (node->callers)\n+\t\t{\n+\t\t  struct cgraph_edge *e = node->callers;\n+\n+\t\t  cgraph_redirect_edge_callee (e, alias);\n+\t\t  if (gimple_has_body_p (e->caller->decl))\n+\t\t    {\n+\t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n+\t\t      cgraph_redirect_edge_call_stmt_to_callee (e);\n+\t\t      pop_cfun ();\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  FOR_EACH_VARIABLE (vnode)\n+    {\n+      /* weak flag makes no sense on local variables.  */\n+      gcc_assert (!DECL_WEAK (vnode->decl)\n+\t\t  || vnode->weakref\n+      \t\t  || TREE_PUBLIC (vnode->decl)\n+\t\t  || DECL_EXTERNAL (vnode->decl));\n+      /* In several cases declarations can not be common:\n+\n+\t - when declaration has initializer\n+\t - when it is in weak\n+\t - when it has specific section\n+\t - when it resides in non-generic address space.\n+\t - if declaration is local, it will get into .local common section\n+\t   so common flag is not needed.  Frontends still produce these in\n+\t   certain cases, such as for:\n+\n+\t     static int a __attribute__ ((common))\n+\n+\t Canonicalize things here and clear the redundant flag.  */\n+      if (DECL_COMMON (vnode->decl)\n+\t  && (!(TREE_PUBLIC (vnode->decl)\n+\t      || DECL_EXTERNAL (vnode->decl))\n+\t      || (DECL_INITIAL (vnode->decl)\n+\t\t  && DECL_INITIAL (vnode->decl) != error_mark_node)\n+\t      || DECL_WEAK (vnode->decl)\n+\t      || DECL_SECTION_NAME (vnode->decl) != NULL\n+\t      || ! (ADDR_SPACE_GENERIC_P\n+\t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->decl))))))\n+\tDECL_COMMON (vnode->decl) = 0;\n+    }\n+  FOR_EACH_DEFINED_VARIABLE (vnode)\n+    {\n+      if (!vnode->definition)\n+        continue;\n+      if (varpool_externally_visible_p (vnode))\n+\tvnode->externally_visible = true;\n+      else\n+\t{\n+          vnode->externally_visible = false;\n+\t  vnode->forced_by_abi = false;\n+\t}\n+      if (!vnode->externally_visible\n+\t  && !vnode->weakref)\n+\t{\n+\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n+\t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t       || vnode->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t       && TREE_PUBLIC (vnode->decl));\n+\t  if (vnode->same_comdat_group && TREE_PUBLIC (vnode->decl))\n+\t    {\n+\t      symtab_node *next = vnode;\n+\n+\t      /* Set all members of comdat group local.  */\n+\t      if (vnode->same_comdat_group)\n+\t\tfor (next = vnode->same_comdat_group;\n+\t\t     next != vnode;\n+\t\t     next = next->same_comdat_group)\n+\t\t{\n+\t\t  next->set_comdat_group (NULL);\n+\t\t  symtab_make_decl_local (next->decl);\n+\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t\t|| next->unique_name\n+\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t       && TREE_PUBLIC (next->decl));\n+\t\t}\n+\t      symtab_dissolve_same_comdat_group_list (vnode);\n+\t    }\n+\t  if (TREE_PUBLIC (vnode->decl))\n+\t    vnode->set_comdat_group (NULL);\n+\t  symtab_make_decl_local (vnode->decl);\n+\t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t}\n+      update_visibility_by_resolution_info (vnode);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nMarking local functions:\");\n+      FOR_EACH_DEFINED_FUNCTION (node)\n+\tif (node->local.local)\n+\t  fprintf (dump_file, \" %s\", node->name ());\n+      fprintf (dump_file, \"\\n\\n\");\n+      fprintf (dump_file, \"\\nMarking externally visible functions:\");\n+      FOR_EACH_DEFINED_FUNCTION (node)\n+\tif (node->externally_visible)\n+\t  fprintf (dump_file, \" %s\", node->name ());\n+      fprintf (dump_file, \"\\n\\n\");\n+      fprintf (dump_file, \"\\nMarking externally visible variables:\");\n+      FOR_EACH_DEFINED_VARIABLE (vnode)\n+\tif (vnode->externally_visible)\n+\t  fprintf (dump_file, \" %s\", vnode->name ());\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+  cgraph_function_flags_ready = true;\n+  return 0;\n+}\n+\n+/* Local function pass handling visibilities.  This happens before LTO streaming\n+   so in particular -fwhole-program should be ignored at this level.  */\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_function_and_variable_visibility =\n+{\n+  SIMPLE_IPA_PASS, /* type */\n+  \"visibility\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n+};\n+\n+/* Bring functions local at LTO time with -fwhole-program.  */\n+\n+static unsigned int\n+whole_program_function_and_variable_visibility (void)\n+{\n+  function_and_variable_visibility (flag_whole_program);\n+  if (optimize)\n+    ipa_discover_readonly_nonaddressable_vars ();\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_whole_program_visibility =\n+{\n+  IPA_PASS, /* type */\n+  \"whole-program\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_execute */\n+  TV_CGRAPHOPT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n+};\n+\n+class pass_ipa_whole_program_visibility : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_whole_program_visibility (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_whole_program_visibility, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+\n+  virtual bool gate (function *)\n+    {\n+      /* Do not re-run on ltrans stage.  */\n+      return !flag_ltrans;\n+    }\n+  virtual unsigned int execute (function *)\n+    {\n+      return whole_program_function_and_variable_visibility ();\n+    }\n+\n+}; // class pass_ipa_whole_program_visibility\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_whole_program_visibility (gcc::context *ctxt)\n+{\n+  return new pass_ipa_whole_program_visibility (ctxt);\n+}\n+\n+class pass_ipa_function_and_variable_visibility : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_function_and_variable_visibility,\n+\t\t\t   ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *)\n+    {\n+      return function_and_variable_visibility (flag_whole_program && !flag_lto);\n+    }\n+\n+}; // class pass_ipa_function_and_variable_visibility\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n+{\n+  return new pass_ipa_function_and_variable_visibility (ctxt);\n+}"}, {"sha": "5850d2818295aaea7043a80e8e946a01cdf65f0c", "filename": "gcc/ipa.c", "status": "modified", "additions": 0, "deletions": 682, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f7beb3f103ec602dc863ba9473bdff4337d5fff/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=7f7beb3f103ec602dc863ba9473bdff4337d5fff", "patch": "@@ -42,36 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"dbgcnt.h\"\n \n-/* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n-\n-static bool\n-cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n-{\n-   /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n-   return !(cgraph_only_called_directly_or_aliased_p (node)\n-\t    && !ipa_ref_has_aliases_p (&node->ref_list)\n-\t    && node->definition\n-\t    && !DECL_EXTERNAL (node->decl)\n-\t    && !node->externally_visible\n-\t    && !node->used_from_other_partition\n-\t    && !node->in_other_partition);\n-}\n-\n-/* Return true when function can be marked local.  */\n-\n-static bool\n-cgraph_local_node_p (struct cgraph_node *node)\n-{\n-   struct cgraph_node *n = cgraph_function_or_thunk_node (node, NULL);\n-\n-   /* FIXME: thunks can be considered local, but we need prevent i386\n-      from attempting to change calling convention of them.  */\n-   if (n->thunk.thunk_p)\n-     return false;\n-   return !cgraph_for_node_and_aliases (n,\n-\t\t\t\t\tcgraph_non_local_node_p_1, NULL, true);\n-\t\t\t\t\t\n-}\n \n /* Return true when NODE has ADDR reference.  */\n \n@@ -761,593 +731,6 @@ ipa_discover_readonly_nonaddressable_vars (void)\n     fprintf (dump_file, \"\\n\");\n }\n \n-/* Return true when there is a reference to node and it is not vtable.  */\n-static bool\n-address_taken_from_non_vtable_p (symtab_node *node)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t     i, ref); i++)\n-    if (ref->use == IPA_REF_ADDR)\n-      {\n-\tvarpool_node *node;\n-\tif (is_a <cgraph_node *> (ref->referring))\n-\t  return true;\n-\tnode = ipa_ref_referring_varpool_node (ref);\n-\tif (!DECL_VIRTUAL_P (node->decl))\n-\t  return true;\n-      }\n-  return false;\n-}\n-\n-/* A helper for comdat_can_be_unshared_p.  */\n-\n-static bool\n-comdat_can_be_unshared_p_1 (symtab_node *node)\n-{\n-  if (!node->externally_visible)\n-    return true;\n-  /* When address is taken, we don't know if equality comparison won't\n-     break eventually. Exception are virutal functions, C++\n-     constructors/destructors and vtables, where this is not possible by\n-     language standard.  */\n-  if (!DECL_VIRTUAL_P (node->decl)\n-      && (TREE_CODE (node->decl) != FUNCTION_DECL\n-\t  || (!DECL_CXX_CONSTRUCTOR_P (node->decl)\n-\t      && !DECL_CXX_DESTRUCTOR_P (node->decl)))\n-      && address_taken_from_non_vtable_p (node))\n-    return false;\n-\n-  /* If the symbol is used in some weird way, better to not touch it.  */\n-  if (node->force_output)\n-    return false;\n-\n-  /* Explicit instantiations needs to be output when possibly\n-     used externally.  */\n-  if (node->forced_by_abi\n-      && TREE_PUBLIC (node->decl)\n-      && (node->resolution != LDPR_PREVAILING_DEF_IRONLY\n-          && !flag_whole_program))\n-    return false;\n-\n-  /* Non-readonly and volatile variables can not be duplicated.  */\n-  if (is_a <varpool_node *> (node)\n-      && (!TREE_READONLY (node->decl)\n-\t  || TREE_THIS_VOLATILE (node->decl)))\n-    return false;\n-  return true;\n-}\n-\n-/* COMDAT functions must be shared only if they have address taken,\n-   otherwise we can produce our own private implementation with\n-   -fwhole-program.  \n-   Return true when turning COMDAT functoin static can not lead to wrong\n-   code when the resulting object links with a library defining same COMDAT.\n-\n-   Virtual functions do have their addresses taken from the vtables,\n-   but in C++ there is no way to compare their addresses for equality.  */\n-\n-static bool\n-comdat_can_be_unshared_p (symtab_node *node)\n-{\n-  if (!comdat_can_be_unshared_p_1 (node))\n-    return false;\n-  if (node->same_comdat_group)\n-    {\n-      symtab_node *next;\n-\n-      /* If more than one function is in the same COMDAT group, it must\n-         be shared even if just one function in the comdat group has\n-         address taken.  */\n-      for (next = node->same_comdat_group;\n-\t   next != node; next = next->same_comdat_group)\n-        if (!comdat_can_be_unshared_p_1 (next))\n-          return false;\n-    }\n-  return true;\n-}\n-\n-/* Return true when function NODE should be considered externally visible.  */\n-\n-static bool\n-cgraph_externally_visible_p (struct cgraph_node *node,\n-\t\t\t     bool whole_program)\n-{\n-  if (!node->definition)\n-    return false;\n-  if (!TREE_PUBLIC (node->decl)\n-      || DECL_EXTERNAL (node->decl))\n-    return false;\n-\n-  /* Do not try to localize built-in functions yet.  One of problems is that we\n-     end up mangling their asm for WHOPR that makes it impossible to call them\n-     using the implicit built-in declarations anymore.  Similarly this enables\n-     us to remove them as unreachable before actual calls may appear during\n-     expansion or folding.  */\n-  if (DECL_BUILT_IN (node->decl))\n-    return true;\n-\n-  /* If linker counts on us, we must preserve the function.  */\n-  if (symtab_used_from_object_file_p (node))\n-    return true;\n-  if (DECL_PRESERVE_P (node->decl))\n-    return true;\n-  if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (node->decl)))\n-    return true;\n-  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-      && lookup_attribute (\"dllexport\",\n-\t\t\t   DECL_ATTRIBUTES (node->decl)))\n-    return true;\n-  if (node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n-    return false;\n-  /* When doing LTO or whole program, we can bring COMDAT functoins static.\n-     This improves code quality and we know we will duplicate them at most twice\n-     (in the case that we are not using plugin and link with object file\n-      implementing same COMDAT)  */\n-  if ((in_lto_p || whole_program)\n-      && DECL_COMDAT (node->decl)\n-      && comdat_can_be_unshared_p (node))\n-    return false;\n-\n-  /* When doing link time optimizations, hidden symbols become local.  */\n-  if (in_lto_p\n-      && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (node->decl) == VISIBILITY_INTERNAL)\n-      /* Be sure that node is defined in IR file, not in other object\n-\t file.  In that case we don't set used_from_other_object_file.  */\n-      && node->definition)\n-    ;\n-  else if (!whole_program)\n-    return true;\n-\n-  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Return true when variable VNODE should be considered externally visible.  */\n-\n-bool\n-varpool_externally_visible_p (varpool_node *vnode)\n-{\n-  if (DECL_EXTERNAL (vnode->decl))\n-    return true;\n-\n-  if (!TREE_PUBLIC (vnode->decl))\n-    return false;\n-\n-  /* If linker counts on us, we must preserve the function.  */\n-  if (symtab_used_from_object_file_p (vnode))\n-    return true;\n-\n-  if (DECL_HARD_REGISTER (vnode->decl))\n-    return true;\n-  if (DECL_PRESERVE_P (vnode->decl))\n-    return true;\n-  if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n-    return true;\n-  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-      && lookup_attribute (\"dllexport\",\n-\t\t\t   DECL_ATTRIBUTES (vnode->decl)))\n-    return true;\n-\n-  /* See if we have linker information about symbol not being used or\n-     if we need to make guess based on the declaration.\n-\n-     Even if the linker clams the symbol is unused, never bring internal\n-     symbols that are declared by user as used or externally visible.\n-     This is needed for i.e. references from asm statements.   */\n-  if (symtab_used_from_object_file_p (vnode))\n-    return true;\n-  if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n-    return false;\n-\n-  /* As a special case, the COMDAT virtual tables can be unshared.\n-     In LTO mode turn vtables into static variables.  The variable is readonly,\n-     so this does not enable more optimization, but referring static var\n-     is faster for dynamic linking.  Also this match logic hidding vtables\n-     from LTO symbol tables.  */\n-  if ((in_lto_p || flag_whole_program)\n-      && DECL_COMDAT (vnode->decl)\n-      && comdat_can_be_unshared_p (vnode))\n-    return false;\n-\n-  /* When doing link time optimizations, hidden symbols become local.  */\n-  if (in_lto_p\n-      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n-      /* Be sure that node is defined in IR file, not in other object\n-\t file.  In that case we don't set used_from_other_object_file.  */\n-      && vnode->definition)\n-    ;\n-  else if (!flag_whole_program)\n-    return true;\n-\n-  /* Do not attempt to privatize COMDATS by default.\n-     This would break linking with C++ libraries sharing\n-     inline definitions.\n-\n-     FIXME: We can do so for readonly vars with no address taken and\n-     possibly also for vtables since no direct pointer comparsion is done.\n-     It might be interesting to do so to reduce linking overhead.  */\n-  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n-    return true;\n-  return false;\n-}\n-\n-/* Return true if reference to NODE can be replaced by a local alias.\n-   Local aliases save dynamic linking overhead and enable more optimizations.\n- */\n-\n-bool\n-can_replace_by_local_alias (symtab_node *node)\n-{\n-  return (symtab_node_availability (node) > AVAIL_OVERWRITABLE\n-\t  && !symtab_can_be_discarded (node));\n-}\n-\n-/* In LTO we can remove COMDAT groups and weak symbols.\n-   Either turn them into normal symbols or external symbol depending on \n-   resolution info.  */\n-\n-static void\n-update_visibility_by_resolution_info (symtab_node * node)\n-{\n-  bool define;\n-\n-  if (!node->externally_visible\n-      || (!DECL_WEAK (node->decl) && !DECL_ONE_ONLY (node->decl))\n-      || node->resolution == LDPR_UNKNOWN)\n-    return;\n-\n-  define = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t    || node->resolution == LDPR_PREVAILING_DEF\n-\t    || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n-\n-  /* The linker decisions ought to agree in the whole group.  */\n-  if (node->same_comdat_group)\n-    for (symtab_node *next = node->same_comdat_group;\n-\t next != node; next = next->same_comdat_group)\n-      gcc_assert (!node->externally_visible\n-\t\t  || define == (next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t        || next->resolution == LDPR_PREVAILING_DEF\n-\t\t\t        || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP));\n-\n-  if (node->same_comdat_group)\n-    for (symtab_node *next = node->same_comdat_group;\n-\t next != node; next = next->same_comdat_group)\n-      {\n-\tnext->set_comdat_group (NULL);\n-\tDECL_WEAK (next->decl) = false;\n-\tif (next->externally_visible\n-\t    && !define)\n-\t  DECL_EXTERNAL (next->decl) = true;\n-      }\n-  node->set_comdat_group (NULL);\n-  DECL_WEAK (node->decl) = false;\n-  if (!define)\n-    DECL_EXTERNAL (node->decl) = true;\n-  symtab_dissolve_same_comdat_group_list (node);\n-}\n-\n-/* Mark visibility of all functions.\n-\n-   A local function is one whose calls can occur only in the current\n-   compilation unit and all its calls are explicit, so we can change\n-   its calling convention.  We simply mark all static functions whose\n-   address is not taken as local.\n-\n-   We also change the TREE_PUBLIC flag of all declarations that are public\n-   in language point of view but we want to overwrite this default\n-   via visibilities for the backend point of view.  */\n-\n-static unsigned int\n-function_and_variable_visibility (bool whole_program)\n-{\n-  struct cgraph_node *node;\n-  varpool_node *vnode;\n-\n-  /* All aliases should be procssed at this point.  */\n-  gcc_checking_assert (!alias_pairs || !alias_pairs->length ());\n-\n-  FOR_EACH_FUNCTION (node)\n-    {\n-      int flags = flags_from_decl_or_type (node->decl);\n-\n-      /* Optimize away PURE and CONST constructors and destructors.  */\n-      if (optimize\n-\t  && (flags & (ECF_CONST | ECF_PURE))\n-\t  && !(flags & ECF_LOOPING_CONST_OR_PURE))\n-\t{\n-\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n-\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n-\t}\n-\n-      /* Frontends and alias code marks nodes as needed before parsing is finished.\n-\t We may end up marking as node external nodes where this flag is meaningless\n-\t strip it.  */\n-      if (DECL_EXTERNAL (node->decl) || !node->definition)\n-\t{\n-\t  node->force_output = 0;\n-\t  node->forced_by_abi = 0;\n-\t}\n-\n-      /* C++ FE on lack of COMDAT support create local COMDAT functions\n-\t (that ought to be shared but can not due to object format\n-\t limitations).  It is necessary to keep the flag to make rest of C++ FE\n-\t happy.  Clear the flag here to avoid confusion in middle-end.  */\n-      if (DECL_COMDAT (node->decl) && !TREE_PUBLIC (node->decl))\n-        DECL_COMDAT (node->decl) = 0;\n-\n-      /* For external decls stop tracking same_comdat_group. It doesn't matter\n-\t what comdat group they are in when they won't be emitted in this TU.  */\n-      if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n-\t{\n-#ifdef ENABLE_CHECKING\n-\t  symtab_node *n;\n-\n-\t  for (n = node->same_comdat_group;\n-\t       n != node;\n-\t       n = n->same_comdat_group)\n-\t      /* If at least one of same comdat group functions is external,\n-\t\t all of them have to be, otherwise it is a front-end bug.  */\n-\t      gcc_assert (DECL_EXTERNAL (n->decl));\n-#endif\n-\t  symtab_dissolve_same_comdat_group_list (node);\n-\t}\n-      gcc_assert ((!DECL_WEAK (node->decl)\n-\t\t  && !DECL_COMDAT (node->decl))\n-      \t          || TREE_PUBLIC (node->decl)\n-\t\t  || node->weakref\n-\t\t  || DECL_EXTERNAL (node->decl));\n-      if (cgraph_externally_visible_p (node, whole_program))\n-        {\n-\t  gcc_assert (!node->global.inlined_to);\n-\t  node->externally_visible = true;\n-\t}\n-      else\n-\t{\n-\t  node->externally_visible = false;\n-\t  node->forced_by_abi = false;\n-\t}\n-      if (!node->externally_visible\n-\t  && node->definition && !node->weakref\n-\t  && !DECL_EXTERNAL (node->decl))\n-\t{\n-\t  gcc_assert (whole_program || in_lto_p\n-\t\t      || !TREE_PUBLIC (node->decl));\n-\t  node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t|| node->unique_name\n-\t\t\t\t|| node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t&& TREE_PUBLIC (node->decl));\n-\t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n-\t    {\n-\t      symtab_node *next = node;\n-\n-\t      /* Set all members of comdat group local.  */\n-\t      if (node->same_comdat_group)\n-\t\tfor (next = node->same_comdat_group;\n-\t\t     next != node;\n-\t\t     next = next->same_comdat_group)\n-\t\t{\n-\t\t  next->set_comdat_group (NULL);\n-\t\t  symtab_make_decl_local (next->decl);\n-\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t\t|| next->unique_name\n-\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (next->decl));\n-\t\t}\n-\t      /* cgraph_externally_visible_p has already checked all other nodes\n-\t         in the group and they will all be made local.  We need to\n-\t         dissolve the group at once so that the predicate does not\n-\t         segfault though. */\n-\t      symtab_dissolve_same_comdat_group_list (node);\n-\t    }\n-\t  if (TREE_PUBLIC (node->decl))\n-\t    node->set_comdat_group (NULL);\n-\t  symtab_make_decl_local (node->decl);\n-\t}\n-\n-      if (node->thunk.thunk_p\n-\t  && TREE_PUBLIC (node->decl))\n-\t{\n-\t  struct cgraph_node *decl_node = node;\n-\n-\t  decl_node = cgraph_function_node (decl_node->callees->callee, NULL);\n-\n-\t  /* Thunks have the same visibility as function they are attached to.\n-\t     Make sure the C++ front end set this up properly.  */\n-\t  if (DECL_ONE_ONLY (decl_node->decl))\n-\t    {\n-\t      gcc_checking_assert (DECL_COMDAT (node->decl)\n-\t\t\t\t   == DECL_COMDAT (decl_node->decl));\n-\t      gcc_checking_assert (symtab_in_same_comdat_p (node, decl_node));\n-\t      gcc_checking_assert (node->same_comdat_group);\n-\t    }\n-\t  node->forced_by_abi = decl_node->forced_by_abi;\n-\t  if (DECL_EXTERNAL (decl_node->decl))\n-\t    DECL_EXTERNAL (node->decl) = 1;\n-\t}\n-\n-      update_visibility_by_resolution_info (node);\n-    }\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    {\n-      node->local.local |= cgraph_local_node_p (node);\n-\n-      /* If we know that function can not be overwritten by a different semantics\n-\t and moreover its section can not be discarded, replace all direct calls\n-\t by calls to an nonoverwritable alias.  This make dynamic linking\n-\t cheaper and enable more optimization.\n-\n-\t TODO: We can also update virtual tables.  */\n-      if (node->callers && can_replace_by_local_alias (node))\n-\t{\n-\t  struct cgraph_node *alias = cgraph (symtab_nonoverwritable_alias (node));\n-\n-\t  if (alias && alias != node)\n-\t    {\n-\t      while (node->callers)\n-\t\t{\n-\t\t  struct cgraph_edge *e = node->callers;\n-\n-\t\t  cgraph_redirect_edge_callee (e, alias);\n-\t\t  if (gimple_has_body_p (e->caller->decl))\n-\t\t    {\n-\t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n-\t\t      cgraph_redirect_edge_call_stmt_to_callee (e);\n-\t\t      pop_cfun ();\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  FOR_EACH_VARIABLE (vnode)\n-    {\n-      /* weak flag makes no sense on local variables.  */\n-      gcc_assert (!DECL_WEAK (vnode->decl)\n-\t\t  || vnode->weakref\n-      \t\t  || TREE_PUBLIC (vnode->decl)\n-\t\t  || DECL_EXTERNAL (vnode->decl));\n-      /* In several cases declarations can not be common:\n-\n-\t - when declaration has initializer\n-\t - when it is in weak\n-\t - when it has specific section\n-\t - when it resides in non-generic address space.\n-\t - if declaration is local, it will get into .local common section\n-\t   so common flag is not needed.  Frontends still produce these in\n-\t   certain cases, such as for:\n-\n-\t     static int a __attribute__ ((common))\n-\n-\t Canonicalize things here and clear the redundant flag.  */\n-      if (DECL_COMMON (vnode->decl)\n-\t  && (!(TREE_PUBLIC (vnode->decl)\n-\t      || DECL_EXTERNAL (vnode->decl))\n-\t      || (DECL_INITIAL (vnode->decl)\n-\t\t  && DECL_INITIAL (vnode->decl) != error_mark_node)\n-\t      || DECL_WEAK (vnode->decl)\n-\t      || DECL_SECTION_NAME (vnode->decl) != NULL\n-\t      || ! (ADDR_SPACE_GENERIC_P\n-\t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->decl))))))\n-\tDECL_COMMON (vnode->decl) = 0;\n-    }\n-  FOR_EACH_DEFINED_VARIABLE (vnode)\n-    {\n-      if (!vnode->definition)\n-        continue;\n-      if (varpool_externally_visible_p (vnode))\n-\tvnode->externally_visible = true;\n-      else\n-\t{\n-          vnode->externally_visible = false;\n-\t  vnode->forced_by_abi = false;\n-\t}\n-      if (!vnode->externally_visible\n-\t  && !vnode->weakref)\n-\t{\n-\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n-\t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t       || vnode->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (vnode->decl));\n-\t  if (vnode->same_comdat_group && TREE_PUBLIC (vnode->decl))\n-\t    {\n-\t      symtab_node *next = vnode;\n-\n-\t      /* Set all members of comdat group local.  */\n-\t      if (vnode->same_comdat_group)\n-\t\tfor (next = vnode->same_comdat_group;\n-\t\t     next != vnode;\n-\t\t     next = next->same_comdat_group)\n-\t\t{\n-\t\t  next->set_comdat_group (NULL);\n-\t\t  symtab_make_decl_local (next->decl);\n-\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t\t|| next->unique_name\n-\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (next->decl));\n-\t\t}\n-\t      symtab_dissolve_same_comdat_group_list (vnode);\n-\t    }\n-\t  if (TREE_PUBLIC (vnode->decl))\n-\t    vnode->set_comdat_group (NULL);\n-\t  symtab_make_decl_local (vnode->decl);\n-\t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t}\n-      update_visibility_by_resolution_info (vnode);\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nMarking local functions:\");\n-      FOR_EACH_DEFINED_FUNCTION (node)\n-\tif (node->local.local)\n-\t  fprintf (dump_file, \" %s\", node->name ());\n-      fprintf (dump_file, \"\\n\\n\");\n-      fprintf (dump_file, \"\\nMarking externally visible functions:\");\n-      FOR_EACH_DEFINED_FUNCTION (node)\n-\tif (node->externally_visible)\n-\t  fprintf (dump_file, \" %s\", node->name ());\n-      fprintf (dump_file, \"\\n\\n\");\n-      fprintf (dump_file, \"\\nMarking externally visible variables:\");\n-      FOR_EACH_DEFINED_VARIABLE (vnode)\n-\tif (vnode->externally_visible)\n-\t  fprintf (dump_file, \" %s\", vnode->name ());\n-      fprintf (dump_file, \"\\n\\n\");\n-    }\n-  cgraph_function_flags_ready = true;\n-  return 0;\n-}\n-\n-/* Local function pass handling visibilities.  This happens before LTO streaming\n-   so in particular -fwhole-program should be ignored at this level.  */\n-\n-namespace {\n-\n-const pass_data pass_data_ipa_function_and_variable_visibility =\n-{\n-  SIMPLE_IPA_PASS, /* type */\n-  \"visibility\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_CGRAPHOPT, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n-};\n-\n-class pass_ipa_function_and_variable_visibility : public simple_ipa_opt_pass\n-{\n-public:\n-  pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n-    : simple_ipa_opt_pass (pass_data_ipa_function_and_variable_visibility,\n-\t\t\t   ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual unsigned int execute (function *)\n-    {\n-      return function_and_variable_visibility (flag_whole_program && !flag_lto);\n-    }\n-\n-}; // class pass_ipa_function_and_variable_visibility\n-\n-} // anon namespace\n-\n-simple_ipa_opt_pass *\n-make_pass_ipa_function_and_variable_visibility (gcc::context *ctxt)\n-{\n-  return new pass_ipa_function_and_variable_visibility (ctxt);\n-}\n-\n /* Free inline summary.  */\n \n namespace {\n@@ -1390,71 +773,6 @@ make_pass_ipa_free_inline_summary (gcc::context *ctxt)\n   return new pass_ipa_free_inline_summary (ctxt);\n }\n \n-/* Bring functionss local at LTO time with -fwhole-program.  */\n-\n-static unsigned int\n-whole_program_function_and_variable_visibility (void)\n-{\n-  function_and_variable_visibility (flag_whole_program);\n-  if (optimize)\n-    ipa_discover_readonly_nonaddressable_vars ();\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_ipa_whole_program_visibility =\n-{\n-  IPA_PASS, /* type */\n-  \"whole-program\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_execute */\n-  TV_CGRAPHOPT, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n-};\n-\n-class pass_ipa_whole_program_visibility : public ipa_opt_pass_d\n-{\n-public:\n-  pass_ipa_whole_program_visibility (gcc::context *ctxt)\n-    : ipa_opt_pass_d (pass_data_ipa_whole_program_visibility, ctxt,\n-\t\t      NULL, /* generate_summary */\n-\t\t      NULL, /* write_summary */\n-\t\t      NULL, /* read_summary */\n-\t\t      NULL, /* write_optimization_summary */\n-\t\t      NULL, /* read_optimization_summary */\n-\t\t      NULL, /* stmt_fixup */\n-\t\t      0, /* function_transform_todo_flags_start */\n-\t\t      NULL, /* function_transform */\n-\t\t      NULL) /* variable_transform */\n-  {}\n-\n-  /* opt_pass methods: */\n-\n-  virtual bool gate (function *)\n-    {\n-      /* Do not re-run on ltrans stage.  */\n-      return !flag_ltrans;\n-    }\n-  virtual unsigned int execute (function *)\n-    {\n-      return whole_program_function_and_variable_visibility ();\n-    }\n-\n-}; // class pass_ipa_whole_program_visibility\n-\n-} // anon namespace\n-\n-ipa_opt_pass_d *\n-make_pass_ipa_whole_program_visibility (gcc::context *ctxt)\n-{\n-  return new pass_ipa_whole_program_visibility (ctxt);\n-}\n-\n /* Generate and emit a static constructor or destructor.  WHICH must\n    be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n    is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the"}]}