{"sha": "783bfe5ee838afc44f8f2125be624788ebe0723b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgzYmZlNWVlODM4YWZjNDRmOGYyMTI1YmU2MjQ3ODhlYmUwNzIzYg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2019-10-15T00:12:49Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2019-10-15T00:12:49Z"}, "message": "Rename attribute-related functions and productions in C parser.\n\nThe C2x attribute syntax, [[ ]], appears in different places in the\nsyntax from GNU __attribute__, and, where they can appear in the same\nplace in the syntax, they do not always appertain to the same entity.\n(For example, in \"int func(void) ATTRS;\", GNU attributes appertain to\nthe declaration but C2x attributes appertain to the function type.)\n\nThus, the C parser needs to handle the two kinds of attributes\nseparately, with each place in the syntax accepting whatever kinds of\nattributes are appropriate there and applying them to the relevant\nentities.  This patch prepares for this by renaming parser functions\nrelating to attributes to make clear they are specifically about GNU\nattributes and renaming syntax productions likewise to avoid confusing\nwith the C2x attributes syntax productions.\n\nWhere comments refer to attributes, this has only be changed where it\nis clear that in the context they are referring specifically to the\ngnu-attributes syntax.  There may be other places that also end up\nchanging to refer to gnu-attributes as part of the C2x attributes\nimplementation, if more detailed examination of those places shows\nthey are also specific to gnu-attributes.  (I do not expect code\ndealing with semantics of attributes outside of the parser to need to\nchange; as for C++, it will be possible to use existing attributes\ninside [[]] with the gnu:: form of the attribute name.)\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.\n\n\t* c-parser.c (c_parser_attribute_any_word): Rename to\n\tc_parser_gnu_attribute_any_word.  All callers changed.\n\t(c_parser_attribute): Rename to c_parser_gnu_attribute.  All\n\tcallers changed.\n\t(c_parser_attributes): Rename to c_parser_gnu_attributes.  All\n\tcallers changed.\n\t(c_parser_declaration_or_fndef, c_parser_declspecs)\n\t(c_parser_enum_specifier, c_parser_struct_or_union_specifier)\n\t(c_parser_struct_declaration, c_parser_declarator)\n\t(c_parser_gnu_attribute, c_parser_compound_statement)\n\t(c_parser_label, c_parser_statement, c_parser_objc_method_decl)\n\t(c_parser_transaction_attributes): Add \"gnu-\" prefix to names of\n\tattribute-related syntax productions.\n\nFrom-SVN: r276978", "tree": {"sha": "77e549c2cb36410ab587209edb830ed0563e3536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77e549c2cb36410ab587209edb830ed0563e3536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/783bfe5ee838afc44f8f2125be624788ebe0723b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783bfe5ee838afc44f8f2125be624788ebe0723b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/783bfe5ee838afc44f8f2125be624788ebe0723b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783bfe5ee838afc44f8f2125be624788ebe0723b/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "490d1b4a834897e927d58d1a8fba93c2a33172df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/490d1b4a834897e927d58d1a8fba93c2a33172df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/490d1b4a834897e927d58d1a8fba93c2a33172df"}], "stats": {"total": 172, "additions": 95, "deletions": 77}, "files": [{"sha": "0cf32f6e638e06c3f518da22a75b99a574761e4b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783bfe5ee838afc44f8f2125be624788ebe0723b/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783bfe5ee838afc44f8f2125be624788ebe0723b/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=783bfe5ee838afc44f8f2125be624788ebe0723b", "patch": "@@ -1,3 +1,19 @@\n+2019-10-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-parser.c (c_parser_attribute_any_word): Rename to\n+\tc_parser_gnu_attribute_any_word.  All callers changed.\n+\t(c_parser_attribute): Rename to c_parser_gnu_attribute.  All\n+\tcallers changed.\n+\t(c_parser_attributes): Rename to c_parser_gnu_attributes.  All\n+\tcallers changed.\n+\t(c_parser_declaration_or_fndef, c_parser_declspecs)\n+\t(c_parser_enum_specifier, c_parser_struct_or_union_specifier)\n+\t(c_parser_struct_declaration, c_parser_declarator)\n+\t(c_parser_gnu_attribute, c_parser_compound_statement)\n+\t(c_parser_label, c_parser_statement, c_parser_objc_method_decl)\n+\t(c_parser_transaction_attributes): Add \"gnu-\" prefix to names of\n+\tattribute-related syntax productions.\n+\n 2019-10-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* c-objc-common.c (useful_aka_type_p): Replace with..."}, {"sha": "7618a46c8bcb18245fe92e8e97d53ee2a97ef25d", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783bfe5ee838afc44f8f2125be624788ebe0723b/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783bfe5ee838afc44f8f2125be624788ebe0723b/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=783bfe5ee838afc44f8f2125be624788ebe0723b", "patch": "@@ -1400,7 +1400,7 @@ static struct c_arg_info *c_parser_parms_list_declarator (c_parser *, tree,\n \t\t\t\t\t\t\t  tree);\n static struct c_parm *c_parser_parameter_declaration (c_parser *, tree);\n static tree c_parser_simple_asm_expr (c_parser *);\n-static tree c_parser_attributes (c_parser *);\n+static tree c_parser_gnu_attributes (c_parser *);\n static struct c_expr c_parser_initializer (c_parser *);\n static struct c_expr c_parser_braced_init (c_parser *, tree, bool,\n \t\t\t\t\t   struct obstack *);\n@@ -1714,8 +1714,8 @@ add_debug_begin_stmt (location_t loc)\n      init-declarator-list , init-declarator\n \n    init-declarator:\n-     declarator simple-asm-expr[opt] attributes[opt]\n-     declarator simple-asm-expr[opt] attributes[opt] = initializer\n+     declarator simple-asm-expr[opt] gnu-attributes[opt]\n+     declarator simple-asm-expr[opt] gnu-attributes[opt] = initializer\n \n    GNU extensions:\n \n@@ -1726,11 +1726,11 @@ add_debug_begin_stmt (location_t loc)\n    attribute ;\n \n    Objective-C:\n-     attributes objc-class-definition\n-     attributes objc-category-definition\n-     attributes objc-protocol-definition\n+     gnu-attributes objc-class-definition\n+     gnu-attributes objc-category-definition\n+     gnu-attributes objc-protocol-definition\n \n-   The simple-asm-expr and attributes are GNU extensions.\n+   The simple-asm-expr and gnu-attributes are GNU extensions.\n \n    This function does not handle __extension__; that is handled in its\n    callers.  ??? Following the old parser, __extension__ may start\n@@ -2043,7 +2043,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    asm_name = c_parser_simple_asm_expr (parser);\n \t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n \t    {\n-\t      postfix_attrs = c_parser_attributes (parser);\n+\t      postfix_attrs = c_parser_gnu_attributes (parser);\n \t      if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \t\t{\n \t\t  /* This means there is an attribute specifier after\n@@ -2244,7 +2244,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t}\n \t      c_parser_consume_token (parser);\n \t      if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-\t\tall_prefix_attrs = chainon (c_parser_attributes (parser),\n+\t\tall_prefix_attrs = chainon (c_parser_gnu_attributes (parser),\n \t\t\t\t\t    prefix_attrs);\n \t      else\n \t\tall_prefix_attrs = prefix_attrs;\n@@ -2544,7 +2544,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n    6.7, C11 6.7), adding them to SPECS (which may already include some).\n    Storage class specifiers are accepted iff SCSPEC_OK; type\n    specifiers are accepted iff TYPESPEC_OK; alignment specifiers are\n-   accepted iff ALIGNSPEC_OK; attributes are accepted at the start\n+   accepted iff ALIGNSPEC_OK; gnu-attributes are accepted at the start\n    iff START_ATTR_OK; __auto_type is accepted iff AUTO_TYPE_OK.\n \n    declaration-specifiers:\n@@ -2613,7 +2613,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n    GNU extensions:\n \n    declaration-specifiers:\n-     attributes declaration-specifiers[opt]\n+     gnu-attributes declaration-specifiers[opt]\n \n    type-qualifier:\n      address-space\n@@ -2906,7 +2906,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_ATTRIBUTE:\n \t  if (!attrs_ok)\n \t    goto out;\n-\t  attrs = c_parser_attributes (parser);\n+\t  attrs = c_parser_gnu_attributes (parser);\n \t  declspecs_add_attrs (loc, specs, attrs);\n \t  break;\n \tcase RID_ALIGNAS:\n@@ -2939,12 +2939,14 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n /* Parse an enum specifier (C90 6.5.2.2, C99 6.7.2.2, C11 6.7.2.2).\n \n    enum-specifier:\n-     enum attributes[opt] identifier[opt] { enumerator-list } attributes[opt]\n-     enum attributes[opt] identifier[opt] { enumerator-list , } attributes[opt]\n-     enum attributes[opt] identifier\n+     enum gnu-attributes[opt] identifier[opt] { enumerator-list }\n+       gnu-attributes[opt]\n+     enum gnu-attributes[opt] identifier[opt] { enumerator-list , }\n+       gnu-attributes[opt]\n+     enum gnu-attributes[opt] identifier\n \n    The form with trailing comma is new in C99.  The forms with\n-   attributes are GNU extensions.  In GNU C, we accept any expression\n+   gnu-attributes are GNU extensions.  In GNU C, we accept any expression\n    without commas in the syntax (assignment expressions, not just\n    conditional expressions); assignment expressions will be diagnosed\n    as non-constant.\n@@ -2960,8 +2962,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n    GNU Extensions:\n \n    enumerator:\n-     enumeration-constant attributes[opt]\n-     enumeration-constant attributes[opt] = constant-expression\n+     enumeration-constant gnu-attributes[opt]\n+     enumeration-constant gnu-attributes[opt] = constant-expression\n \n */\n \n@@ -2975,7 +2977,7 @@ c_parser_enum_specifier (c_parser *parser)\n   location_t ident_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));\n   c_parser_consume_token (parser);\n-  attrs = c_parser_attributes (parser);\n+  attrs = c_parser_gnu_attributes (parser);\n   enum_loc = c_parser_peek_token (parser)->location;\n   /* Set the location in case we create a decl now.  */\n   c_parser_set_source_position_from_token (c_parser_peek_token (parser));\n@@ -3031,7 +3033,7 @@ c_parser_enum_specifier (c_parser *parser)\n \t  decl_loc = value_loc = token->location;\n \t  c_parser_consume_token (parser);\n \t  /* Parse any specified attributes.  */\n-\t  tree enum_attrs = c_parser_attributes (parser);\n+\t  tree enum_attrs = c_parser_gnu_attributes (parser);\n \t  if (c_parser_next_token_is (parser, CPP_EQ))\n \t    {\n \t      c_parser_consume_token (parser);\n@@ -3069,7 +3071,7 @@ c_parser_enum_specifier (c_parser *parser)\n \t      break;\n \t    }\n \t}\n-      postfix_attrs = c_parser_attributes (parser);\n+      postfix_attrs = c_parser_gnu_attributes (parser);\n       ret.spec = finish_enum (type, nreverse (values),\n \t\t\t      chainon (attrs, postfix_attrs));\n       ret.kind = ctsk_tagdef;\n@@ -3102,9 +3104,9 @@ c_parser_enum_specifier (c_parser *parser)\n /* Parse a struct or union specifier (C90 6.5.2.1, C99 6.7.2.1, C11 6.7.2.1).\n \n    struct-or-union-specifier:\n-     struct-or-union attributes[opt] identifier[opt]\n-       { struct-contents } attributes[opt]\n-     struct-or-union attributes[opt] identifier\n+     struct-or-union gnu-attributes[opt] identifier[opt]\n+       { struct-contents } gnu-attributes[opt]\n+     struct-or-union gnu-attributes[opt] identifier\n \n    struct-contents:\n      struct-declaration-list\n@@ -3160,7 +3162,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     }\n   struct_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n-  attrs = c_parser_attributes (parser);\n+  attrs = c_parser_gnu_attributes (parser);\n \n   /* Set the location in case we create a decl now.  */\n   c_parser_set_source_position_from_token (c_parser_peek_token (parser));\n@@ -3276,7 +3278,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t         recovered already.  Go on with the next field. */\n \t    }\n \t}\n-      postfix_attrs = c_parser_attributes (parser);\n+      postfix_attrs = c_parser_gnu_attributes (parser);\n       ret.spec = finish_struct (struct_loc, type, nreverse (contents),\n \t\t\t\tchainon (attrs, postfix_attrs), struct_info);\n       ret.kind = ctsk_tagdef;\n@@ -3309,15 +3311,15 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n      type-specifier specifier-qualifier-list[opt]\n      type-qualifier specifier-qualifier-list[opt]\n      alignment-specifier specifier-qualifier-list[opt]\n-     attributes specifier-qualifier-list[opt]\n+     gnu-attributes specifier-qualifier-list[opt]\n \n    struct-declarator-list:\n      struct-declarator\n-     struct-declarator-list , attributes[opt] struct-declarator\n+     struct-declarator-list , gnu-attributes[opt] struct-declarator\n \n    struct-declarator:\n-     declarator attributes[opt]\n-     declarator[opt] : constant-expression attributes[opt]\n+     declarator gnu-attributes[opt]\n+     declarator[opt] : constant-expression gnu-attributes[opt]\n \n    GNU extensions:\n \n@@ -3326,7 +3328,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n      specifier-qualifier-list\n \n    Unlike the ISO C syntax, semicolons are handled elsewhere.  The use\n-   of attributes where shown is a GNU extension.  In GNU C, we accept\n+   of gnu-attributes where shown is a GNU extension.  In GNU C, we accept\n    any expression without commas in the syntax (assignment\n    expressions, not just conditional expressions); assignment\n    expressions will be diagnosed as non-constant.  */\n@@ -3446,15 +3448,15 @@ c_parser_struct_declaration (c_parser *parser)\n \t      width = c_parser_expr_no_commas (parser, NULL).value;\n \t    }\n \t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-\t    postfix_attrs = c_parser_attributes (parser);\n+\t    postfix_attrs = c_parser_gnu_attributes (parser);\n \t  d = grokfield (c_parser_peek_token (parser)->location,\n \t\t\t declarator, specs, width, &all_prefix_attrs);\n \t  decl_attributes (&d, chainon (postfix_attrs,\n \t\t\t\t\tall_prefix_attrs), 0);\n \t  DECL_CHAIN (d) = decls;\n \t  decls = d;\n \t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-\t    all_prefix_attrs = chainon (c_parser_attributes (parser),\n+\t    all_prefix_attrs = chainon (c_parser_gnu_attributes (parser),\n \t\t\t\t\tprefix_attrs);\n \t  else\n \t    all_prefix_attrs = prefix_attrs;\n@@ -3600,7 +3602,7 @@ c_parser_alignas_specifier (c_parser * parser)\n \n    direct-declarator:\n      identifier\n-     ( attributes[opt] declarator )\n+     ( gnu-attributes[opt] declarator )\n      direct-declarator array-declarator\n      direct-declarator ( parameter-type-list )\n      direct-declarator ( identifier-list[opt] )\n@@ -3611,9 +3613,9 @@ c_parser_alignas_specifier (c_parser * parser)\n \n    type-qualifier-list:\n      type-qualifier\n-     attributes\n+     gnu-attributes\n      type-qualifier-list type-qualifier\n-     type-qualifier-list attributes\n+     type-qualifier-list gnu-attributes\n \n    array-declarator:\n      [ type-qualifier-list[opt] assignment-expression[opt] ]\n@@ -3630,8 +3632,8 @@ c_parser_alignas_specifier (c_parser * parser)\n      parameter-list , parameter-declaration\n \n    parameter-declaration:\n-     declaration-specifiers declarator attributes[opt]\n-     declaration-specifiers abstract-declarator[opt] attributes[opt]\n+     declaration-specifiers declarator gnu-attributes[opt]\n+     declaration-specifiers abstract-declarator[opt] gnu-attributes[opt]\n \n    identifier-list:\n      identifier\n@@ -3642,7 +3644,7 @@ c_parser_alignas_specifier (c_parser * parser)\n      pointer[opt] direct-abstract-declarator\n \n    direct-abstract-declarator:\n-     ( attributes[opt] abstract-declarator )\n+     ( gnu-attributes[opt] abstract-declarator )\n      direct-abstract-declarator[opt] array-declarator\n      direct-abstract-declarator[opt] ( parameter-type-list[opt] )\n \n@@ -3660,7 +3662,7 @@ c_parser_alignas_specifier (c_parser * parser)\n      parameter-list ;\n      parameter-forward-declarations parameter-list ;\n \n-   The uses of attributes shown above are GNU extensions.\n+   The uses of gnu-attributes shown above are GNU extensions.\n \n    Some forms of array declarator are not included in C99 in the\n    syntax for abstract declarators; these are disallowed elsewhere.\n@@ -3705,7 +3707,7 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n      parenthesized declarator.  In an abstract declarator or parameter\n      declarator, they could start a parenthesized declarator or a\n      parameter list.  To tell which, the open parenthesis and any\n-     following attributes must be read.  If a declaration specifier\n+     following gnu-attributes must be read.  If a declaration specifier\n      follows, then it is a parameter list; if the specifier is a\n      typedef name, there might be an ambiguity about redeclaring it,\n      which is resolved in the direction of treating it as a typedef\n@@ -3720,12 +3722,12 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n      parentheses.  The proper resolution of this ambiguity needs\n      documenting.  At present we follow an accident of the old\n      parser's implementation, whereby the first parameter must have\n-     some declaration specifiers other than just attributes.  Thus as\n+     some declaration specifiers other than just gnu-attributes.  Thus as\n      a parameter declaration it is treated as a parenthesized\n      parameter named x, and as an abstract declarator it is\n      rejected.\n \n-     ??? Also following the old parser, attributes inside an empty\n+     ??? Also following the old parser, gnu-attributes inside an empty\n      parameter list are ignored, making it a list not yielding a\n      prototype, rather than giving an error or making it have one\n      parameter with implicit type int.\n@@ -3764,7 +3766,7 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       tree attrs;\n       struct c_declarator *inner;\n       c_parser_consume_token (parser);\n-      attrs = c_parser_attributes (parser);\n+      attrs = c_parser_gnu_attributes (parser);\n       if (kind != C_DTR_NORMAL\n \t  && (c_parser_next_token_starts_declspecs (parser)\n \t      || c_parser_next_token_is (parser, CPP_CLOSE_PAREN)))\n@@ -3903,7 +3905,7 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       tree attrs;\n       struct c_arg_info *args;\n       c_parser_consume_token (parser);\n-      attrs = c_parser_attributes (parser);\n+      attrs = c_parser_gnu_attributes (parser);\n       args = c_parser_parms_declarator (parser, id_present, attrs);\n       if (args == NULL)\n \treturn NULL;\n@@ -4051,7 +4053,7 @@ c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr)\n \t  tree new_attrs;\n \t  c_parser_consume_token (parser);\n \t  mark_forward_parm_decls ();\n-\t  new_attrs = c_parser_attributes (parser);\n+\t  new_attrs = c_parser_gnu_attributes (parser);\n \t  return c_parser_parms_list_declarator (parser, new_attrs, expr);\n \t}\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -4162,7 +4164,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       return NULL;\n     }\n   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-    postfix_attrs = c_parser_attributes (parser);\n+    postfix_attrs = c_parser_gnu_attributes (parser);\n \n   /* Generate a location for the parameter, ranging from the start of the\n      initial token to the end of the final token.\n@@ -4264,7 +4266,7 @@ c_parser_simple_asm_expr (c_parser *parser)\n }\n \n static tree\n-c_parser_attribute_any_word (c_parser *parser)\n+c_parser_gnu_attribute_any_word (c_parser *parser)\n {\n   tree attr_name = NULL_TREE;\n \n@@ -4329,20 +4331,20 @@ c_parser_attribute_any_word (c_parser *parser)\n   return attr_name;\n }\n \n-/* Parse (possibly empty) attributes.  This is a GNU extension.\n+/* Parse (possibly empty) gnu-attributes.  This is a GNU extension.\n \n-   attributes:\n+   gnu-attributes:\n      empty\n-     attributes attribute\n+     gnu-attributes gnu-attribute\n \n-   attribute:\n-     __attribute__ ( ( attribute-list ) )\n+   gnu-attribute:\n+     __attribute__ ( ( gnu-attribute-list ) )\n \n-   attribute-list:\n-     attrib\n-     attribute_list , attrib\n+   gnu-attribute-list:\n+     gnu-attrib\n+     gnu-attribute_list , gnu-attrib\n \n-   attrib:\n+   gnu-attrib:\n      empty\n      any-word\n      any-word ( identifier )\n@@ -4361,8 +4363,8 @@ c_parser_attribute_any_word (c_parser *parser)\n    commas with no attributes in between.  */\n \n static tree\n-c_parser_attribute (c_parser *parser, tree attrs,\n-\t\t    bool expect_comma = false, bool empty_ok = true)\n+c_parser_gnu_attribute (c_parser *parser, tree attrs,\n+\t\t\tbool expect_comma = false, bool empty_ok = true)\n {\n   bool comma_first = c_parser_next_token_is (parser, CPP_COMMA);\n   if (!comma_first\n@@ -4377,7 +4379,7 @@ c_parser_attribute (c_parser *parser, tree attrs,\n \treturn attrs;\n     }\n \n-  tree attr_name = c_parser_attribute_any_word (parser);\n+  tree attr_name = c_parser_gnu_attribute_any_word (parser);\n   if (attr_name == NULL_TREE)\n     return NULL_TREE;\n \n@@ -4476,7 +4478,7 @@ c_parser_attribute (c_parser *parser, tree attrs,\n }\n \n static tree\n-c_parser_attributes (c_parser *parser)\n+c_parser_gnu_attributes (c_parser *parser)\n {\n   tree attrs = NULL_TREE;\n   while (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n@@ -4503,7 +4505,7 @@ c_parser_attributes (c_parser *parser)\n       for (bool expect_comma = false; ; expect_comma = true)\n \t{\n \t  /* Parse a single attribute.  */\n-\t  tree attr = c_parser_attribute (parser, attrs, expect_comma);\n+\t  tree attr = c_parser_gnu_attribute (parser, attrs, expect_comma);\n \t  if (attr == error_mark_node)\n \t    return attrs;\n \t  if (!attr)\n@@ -4974,8 +4976,8 @@ c_parser_initval (c_parser *parser, struct c_expr *after,\n    GNU syntax also permits (not shown above) labels at the end of\n    compound statements, which yield an error.  We don't allow labels\n    on declarations; this might seem like a natural extension, but\n-   there would be a conflict between attributes on the label and\n-   prefix attributes on the declaration.  ??? The syntax follows the\n+   there would be a conflict between gnu-attributes on the label and\n+   prefix gnu-attributes on the declaration.  ??? The syntax follows the\n    old parser in requiring something after label declarations.\n    Although they are erroneous if the labels declared aren't defined,\n    is it useful for the syntax to be this way?\n@@ -5209,7 +5211,7 @@ c_parser_all_labels (c_parser *parser)\n /* Parse a label (C90 6.6.1, C99 6.8.1, C11 6.8.1).\n \n    label:\n-     identifier : attributes[opt]\n+     identifier : gnu-attributes[opt]\n      case constant-expression :\n      default :\n \n@@ -5218,7 +5220,7 @@ c_parser_all_labels (c_parser *parser)\n    label:\n      case constant-expression ... constant-expression :\n \n-   The use of attributes on labels is a GNU extension.  The syntax in\n+   The use of gnu-attributes on labels is a GNU extension.  The syntax in\n    GNU C accepts any expressions without commas, non-constant\n    expressions being rejected later.  */\n \n@@ -5268,7 +5270,7 @@ c_parser_label (c_parser *parser)\n       c_parser_consume_token (parser);\n       gcc_assert (c_parser_next_token_is (parser, CPP_COLON));\n       c_parser_consume_token (parser);\n-      attrs = c_parser_attributes (parser);\n+      attrs = c_parser_gnu_attributes (parser);\n       tlab = define_label (loc2, name);\n       if (tlab)\n \t{\n@@ -5287,7 +5289,7 @@ c_parser_label (c_parser *parser)\n       if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n \t{\n \t  location_t loc = c_parser_peek_token (parser)->location;\n-\t  tree attrs = c_parser_attributes (parser);\n+\t  tree attrs = c_parser_gnu_attributes (parser);\n \t  if (attribute_fallthrough_p (attrs))\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -5359,7 +5361,7 @@ c_parser_label (c_parser *parser)\n      goto * expression ;\n \n    expression-statement:\n-     attributes ;\n+     gnu-attributes ;\n \n    Objective-C:\n \n@@ -5601,7 +5603,7 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \tcase RID_ATTRIBUTE:\n \t  {\n \t    /* Allow '__attribute__((fallthrough));'.  */\n-\t    tree attrs = c_parser_attributes (parser);\n+\t    tree attrs = c_parser_gnu_attributes (parser);\n \t    if (attribute_fallthrough_p (attrs))\n \t      {\n \t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -7703,7 +7705,7 @@ c_parser_has_attribute_expression (c_parser *parser)\n   location_t atloc = c_parser_peek_token (parser)->location;\n   /* Parse a single attribute.  Require no leading comma and do not\n      allow empty attributes.  */\n-  tree attr = c_parser_attribute (parser, NULL_TREE, false, false);\n+  tree attr = c_parser_gnu_attribute (parser, NULL_TREE, false, false);\n \n   parser->lex_untranslated_string = false;\n \n@@ -10495,7 +10497,7 @@ c_parser_objc_maybe_method_attributes (c_parser* parser, tree* attributes)\n     }\n \n   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-    *attributes = c_parser_attributes (parser);\n+    *attributes = c_parser_gnu_attributes (parser);\n \n   /* If there were no attributes here, just report any earlier error.  */\n   if (*attributes == NULL_TREE || bad)\n@@ -10520,7 +10522,7 @@ c_parser_objc_maybe_method_attributes (c_parser* parser, tree* attributes)\n      objc-selector\n      ( objc-type-name ) objc-keyword-selector objc-optparmlist\n      objc-keyword-selector objc-optparmlist\n-     attributes\n+     gnu-attributes\n \n    objc-keyword-selector:\n      objc-keyword-decl\n@@ -10585,7 +10587,7 @@ c_parser_objc_method_decl (c_parser *parser, bool is_class_method,\n \t    }\n \t  /* New ObjC allows attributes on method parameters.  */\n \t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-\t    param_attr = c_parser_attributes (parser);\n+\t    param_attr = c_parser_gnu_attributes (parser);\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME))\n \t    {\n \t      c_parser_error (parser, \"expected identifier\");\n@@ -20559,7 +20561,7 @@ c_parser_omp_threadprivate (c_parser *parser)\n /* Parse a transaction attribute (GCC Extension).\n \n    transaction-attribute:\n-     attributes\n+     gnu-attributes\n      [ [ any-word ] ]\n \n    The transactional memory language description is written for C++,\n@@ -20572,15 +20574,15 @@ c_parser_transaction_attributes (c_parser *parser)\n   tree attr_name, attr = NULL;\n \n   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n-    return c_parser_attributes (parser);\n+    return c_parser_gnu_attributes (parser);\n \n   if (!c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n     return NULL_TREE;\n   c_parser_consume_token (parser);\n   if (!c_parser_require (parser, CPP_OPEN_SQUARE, \"expected %<[%>\"))\n     goto error1;\n \n-  attr_name = c_parser_attribute_any_word (parser);\n+  attr_name = c_parser_gnu_attribute_any_word (parser);\n   if (attr_name)\n     {\n       c_parser_consume_token (parser);"}]}