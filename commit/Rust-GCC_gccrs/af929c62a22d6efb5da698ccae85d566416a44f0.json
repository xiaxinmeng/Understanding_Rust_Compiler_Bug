{"sha": "af929c62a22d6efb5da698ccae85d566416a44f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY5MjljNjJhMjJkNmVmYjVkYTY5OGNjYWU4NWQ1NjY0MTZhNDRmMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-11T18:17:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-11T18:17:54Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r726", "tree": {"sha": "a2b21f9fbc38a011d29e6f6777b5910a02017faa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2b21f9fbc38a011d29e6f6777b5910a02017faa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af929c62a22d6efb5da698ccae85d566416a44f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af929c62a22d6efb5da698ccae85d566416a44f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af929c62a22d6efb5da698ccae85d566416a44f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af929c62a22d6efb5da698ccae85d566416a44f0/comments", "author": null, "committer": null, "parents": [{"sha": "d79022179595b58010836e23f6016306f27caad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79022179595b58010836e23f6016306f27caad3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79022179595b58010836e23f6016306f27caad3"}], "stats": {"total": 98, "additions": 76, "deletions": 22}, "files": [{"sha": "121fa302f42bd4124c279ea38f7cd93424c41d26", "filename": "gcc/genextract.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=af929c62a22d6efb5da698ccae85d566416a44f0", "patch": "@@ -110,8 +110,8 @@ gen_insn (insn)\n   for (; i >= 0; i--)\n     if (!operand_seen[i])\n       {\n-\tprintf (\"      recog_operand[%d] = const0_rtx;\\n\", i);\n-\tprintf (\"      recog_operand_loc[%d] = &junk;\\n\", i);\n+\tprintf (\"      ro[%d] = const0_rtx;\\n\", i);\n+\tprintf (\"      ro_loc[%d] = &junk;\\n\", i);\n       }\n   printf (\"      break;\\n\");\n }\n@@ -158,7 +158,7 @@ walk_rtx (x, path)\n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n       mark_operand_seen (XINT (x, 0));\n-      printf (\"      recog_operand[%d] = *(recog_operand_loc[%d]\\n        = &\",\n+      printf (\"      ro[%d] = *(ro_loc[%d] = &\",\n \t      XINT (x, 0), XINT (x, 0));\n       print_path (path);\n       printf (\");\\n\");\n@@ -175,7 +175,7 @@ walk_rtx (x, path)\n \n     case MATCH_OPERATOR:\n       mark_operand_seen (XINT (x, 0));\n-      printf (\"      recog_operand[%d] = *(recog_operand_loc[%d]\\n        = &\",\n+      printf (\"      ro[%d] = *(ro_loc[%d]\\n        = &\",\n \t      XINT (x, 0), XINT (x, 0));\n       print_path (path);\n       printf (\");\\n\");\n@@ -190,7 +190,7 @@ walk_rtx (x, path)\n \n     case MATCH_PARALLEL:\n       mark_operand_seen (XINT (x, 0));\n-      printf (\"      recog_operand[%d] = *(recog_operand_loc[%d]\\n        = &\",\n+      printf (\"      ro[%d] = *(ro_loc[%d]\\n        = &\",\n \t      XINT (x, 0), XINT (x, 0));\n       print_path (path);\n       printf (\");\\n\");\n@@ -350,11 +350,14 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"extern rtx *recog_operand_loc[];\\n\");\n   printf (\"extern rtx *recog_dup_loc[];\\n\");\n   printf (\"extern char recog_dup_num[];\\n\");\n-  printf (\"extern void fatal_insn_not_found ();\\n\\n\");\n+  printf (\"extern\\n#ifdef __GNUC__\\nvolatile\\n#endif\\n\");\n+  printf (\"void fatal_insn_not_found ();\\n\\n\");\n \n   printf (\"void\\ninsn_extract (insn)\\n\");\n   printf (\"     rtx insn;\\n\");\n   printf (\"{\\n\");\n+  printf (\"  register rtx *ro = recog_operand;\\n\");\n+  printf (\"  register rtx **ro_loc = recog_operand_loc;\\n\");\n   printf (\"  int insn_code = INSN_CODE (insn);\\n\");\n   printf (\"  if (insn_code == -1) fatal_insn_not_found (insn);\\n\");\n   printf (\"  insn = PATTERN (insn);\\n\");\n@@ -401,7 +404,7 @@ from the machine description file `md'.  */\\n\\n\");\n       printf (\"#if __GNUC__ > 1 && !defined (bcopy)\\n\");\n       printf (\"#define bcopy(FROM,TO,COUNT) __builtin_memcpy(TO,FROM,COUNT)\\n\");\n       printf (\"#endif\\n\");\n-      printf (\"      bcopy (&XVECEXP (insn, 0, 0), recog_operand,\\n\");\n+      printf (\"      bcopy (&XVECEXP (insn, 0, 0), ro,\\n\");\n       printf (\"             sizeof (rtx) * XVECLEN (insn, 0));\\n\");\n       printf (\"      break;\\n\");\n     }"}, {"sha": "05c1a2737dcfd724e123a711aa2261eb1249a781", "filename": "gcc/reload.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=af929c62a22d6efb5da698ccae85d566416a44f0", "patch": "@@ -4179,6 +4179,46 @@ copy_replacements (x, y)\n \t}\n }\n \f\n+/* If LOC was scheduled to be replaced by something, return the replacement.\n+   Otherwise, return *LOC.  */\n+\n+rtx\n+find_replacement (loc)\n+     rtx *loc;\n+{\n+  struct replacement *r;\n+\n+  for (r = &replacements[0]; r < &replacements[n_replacements]; r++)\n+    {\n+      rtx reloadreg = reload_reg_rtx[r->what];\n+\n+      if (reloadreg && r->where == loc)\n+\t{\n+\t  if (r->mode != VOIDmode && GET_MODE (reloadreg) != r->mode)\n+\t    reloadreg = gen_rtx (REG, r->mode, REGNO (reloadreg));\n+\n+\t  return reloadreg;\n+\t}\n+      else if (reloadreg && r->subreg_loc == loc)\n+\t{\n+\t  /* RELOADREG must be either a REG or a SUBREG.\n+\n+\t     ??? Is it actually still ever a SUBREG?  If so, why?  */\n+\n+\t  if (GET_CODE (reloadreg) == REG)\n+\t    return gen_rtx (REG, GET_MODE (*loc),\n+\t\t\t    REGNO (reloadreg) + SUBREG_WORD (*loc));\n+\t  else if (GET_MODE (reloadreg) == GET_MODE (*loc))\n+\t    return reloadreg;\n+\t  else\n+\t    return gen_rtx (SUBREG, GET_MODE (*loc), SUBREG_REG (reloadreg),\n+\t\t\t    SUBREG_WORD (reloadreg) + SUBREG_WORD (*loc));\n+\t}\n+    }\n+\n+  return *loc;\n+}\n+\f\n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X\n    other than being stored into."}, {"sha": "e7b21446c4680204b2bf119ff1ebb9d35bcf9a5b", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=af929c62a22d6efb5da698ccae85d566416a44f0", "patch": "@@ -110,3 +110,4 @@ extern void find_reloads ();\n extern void subst_reloads ();\n extern rtx eliminate_regs ();\n extern rtx gen_input_reload ();\n+extern rtx find_replacement ();"}, {"sha": "bac9c2f29e121865bfd20280cc74ef4e583d6ada", "filename": "gcc/reload1.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=af929c62a22d6efb5da698ccae85d566416a44f0", "patch": "@@ -5428,9 +5428,12 @@ gen_input_reload (reloadreg, in, before_insn)\n \t `insn_extract'and it is simpler to emit and then delete the insn if\n \t not valid than to dummy things up.  */\n \n-      rtx move_operand, other_operand, insn;\n+      rtx op0, op1, tem, insn;\n       int code;\n \n+      op0 = find_replacement (&XEXP (in, 0));\n+      op1 = find_replacement (&XEXP (in, 1));\n+\n       /* Since constraint checking is strict, commutativity won't be\n \t checked, so we need to do that here to avoid spurious failure\n \t if the add instruction is two-address and the second operand\n@@ -5440,7 +5443,10 @@ gen_input_reload (reloadreg, in, before_insn)\n \n       if (GET_CODE (XEXP (in, 1)) == REG\n \t  && REGNO (reloadreg) == REGNO (XEXP (in, 1)))\n-\tin = gen_rtx (PLUS, GET_MODE (in), XEXP (in, 1), XEXP (in, 0));\n+\ttem = op0, op0 = op1, op1 = tem;\n+\n+      if (op0 != XEXP (in, 0) || op1 != XEXP (in, 1))\n+\tin = gen_rtx (PLUS, GET_MODE (in), op0, op1);\n \n       insn = emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in),\n \t\t\t\t   before_insn);\n@@ -5463,23 +5469,20 @@ gen_input_reload (reloadreg, in, before_insn)\n \n       /* If that failed, we must use a conservative two-insn sequence.\n \t use move to copy constant, MEM, or pseudo register to the reload\n-\t register since \"move\" will be able to handle arbitrary operand, unlike\n-\t add which can't, in general.  Then add the registers.\n+\t register since \"move\" will be able to handle an arbitrary operand,\n+\t unlike add which can't, in general.  Then add the registers.\n \n \t If there is another way to do this for a specific machine, a\n \t DEFINE_PEEPHOLE should be specified that recognizes the sequence\n \t we emit below.  */\n \n-      if (CONSTANT_P (XEXP (in, 1))\n-\t  || GET_CODE (XEXP (in, 1)) == MEM\n-\t  || (GET_CODE (XEXP (in, 1)) == REG\n-\t      && REGNO (XEXP (in, 1)) >= FIRST_PSEUDO_REGISTER))\n-\tmove_operand = XEXP (in, 1), other_operand = XEXP (in, 0);\n-      else\n-\tmove_operand = XEXP (in, 0), other_operand = XEXP (in, 1);\n+      if (CONSTANT_P (op1) || GET_CODE (op1) == MEM\n+\t  || (GET_CODE (op1) == REG\n+\t      && REGNO (op1) >= FIRST_PSEUDO_REGISTER))\n+\ttem = op0, op0 = op1, op1 = tem;\n \n-      emit_insn_before (gen_move_insn (reloadreg, move_operand), before_insn);\n-      emit_insn_before (gen_add2_insn (reloadreg, other_operand), before_insn);\n+      emit_insn_before (gen_move_insn (reloadreg, op0), before_insn);\n+      emit_insn_before (gen_add2_insn (reloadreg, op1), before_insn);\n     }\n \n   /* If IN is a simple operand, use gen_move_insn.  */"}, {"sha": "2b914a66d731c9e60f8460e4b0a82f93ebab7467", "filename": "gcc/tree.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af929c62a22d6efb5da698ccae85d566416a44f0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=af929c62a22d6efb5da698ccae85d566416a44f0", "patch": "@@ -1742,10 +1742,12 @@ save_expr (expr)\n \n   /* If the tree evaluates to a constant, then we don't want to hide that\n      fact (i.e. this allows further folding, and direct checks for constants).\n+     However, a read-only object that has side effects cannot be bypassed.\n      Since it is no problem to reevaluate literals, we just return the \n      literal node. */\n \n-  if (TREE_CONSTANT (t) || TREE_READONLY (t) || TREE_CODE (t) == SAVE_EXPR)\n+  if (TREE_CONSTANT (t) || (TREE_READONLY (t) && ! TREE_SIDE_EFFECTS (t))\n+      || TREE_CODE (t) == SAVE_EXPR)\n     return t;\n \n   t = build (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl, NULL);\n@@ -1852,7 +1854,12 @@ stabilize_reference_1 (e)\n   register int length;\n   register enum tree_code code = TREE_CODE (e);\n \n-  if (TREE_CONSTANT (e) || TREE_READONLY (e) || code == SAVE_EXPR)\n+  /* We cannot ignore const expressions because it might be a reference\n+     to a const array but whose index contains side-effects.  But we can\n+     ignore things that are actual constant or that already have been\n+     handled by this function.  */\n+\n+  if (TREE_CONSTANT (e) || code == SAVE_EXPR)\n     return e;\n \n   switch (TREE_CODE_CLASS (code))"}]}