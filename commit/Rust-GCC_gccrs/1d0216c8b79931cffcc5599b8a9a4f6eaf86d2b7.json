{"sha": "1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQwMjE2YzhiNzk5MzFjZmZjYzU1OTliOGE5YTRmNmVhZjg2ZDJiNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-11-09T11:42:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-11-09T11:42:16Z"}, "message": "target.def (can_use_doloop_p): New hook.\n\ngcc/\n\t* target.def (can_use_doloop_p): New hook.\n\t* doc/tm.texi.in (TARGET_CAN_USE_DOLOOP_P): Add.\n\t* doc/tm.texi: Regenerate.\n\t* doc/md.texi (doloop_begin, doloop_end): Update documentation.\n\t* hooks.h (hook_bool_dint_dint_uint_true): Declare.\n\t* hooks.c (hook_bool_dint_dint_uint_true): New function.\n\t* targhooks.h (can_use_doloop_if_innermost): Declare.\n\t* targhooks.c (can_use_doloop_if_innermost): New function.\n\t* target.h: Include double-int.h.\n\t* loop-doloop.c (doloop_optimize): Call targetm.can_use_doloop_p.\n\tRemove iteration count, maximum iteration count, loop depth and\n\tenter-at-top inputs from doloop_begin and doloop_end.\n\t* config/arc/arc.md (doloop_begin, doloop_end): Update for new\n\tinterface.\n\t* config/arc/arc.c (arc_can_use_doloop_p): New function.\n\t(TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/arm/thumb2.md (doloop_end): Update for new interface.\n\t* config/arm/arm.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/bfin/bfin.md (doloop_end): Update for new interface.\n\t* config/bfin/bfin.c (bfin_can_use_doloop_p): New function.\n\t(TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/c6x/c6x.md (doloop_end): Update for new interface.\n\t* config/ia64/ia64.md (doloop_end): Update for new interface.\n\t* config/ia64/ia64.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/mep/mep.md (doloop_begin, doloop_end): Update for new\n\tinterface.\n\t* config/mep/mep.c (mep_emit_doloop): Likewise.\n\t(TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/rs6000/rs6000.md (doloop_end): Update for new interface.\n\t* config/rs6000/rs6000.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/s390/s390.md (doloop_end): Update for new interface.\n\t* config/sh/sh.md (doloop_end): Likewise.\n\t* config/spu/spu.md (doloop_end): Likewise.\n\t* config/spu/spu.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/tilegx/tilegx.md (doloop_end): Update for new interface.\n\t* config/tilegx/tilegx.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/tilepro/tilepro.md (doloop_end): Update for new interface.\n\t* config/tilepro/tilepro.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\t* config/v850/v850.md (doloop_begin, doloop_end): Update for new\n\tinterface.\n\t* config/v850/v850.c (TARGET_CAN_USE_DOLOOP_P): Define.\n\nFrom-SVN: r204614", "tree": {"sha": "5b96e2c7a588193d1b4019f9316a1ca13b8376ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b96e2c7a588193d1b4019f9316a1ca13b8376ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12929715b124071e523316c28897c8a05083cf12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12929715b124071e523316c28897c8a05083cf12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12929715b124071e523316c28897c8a05083cf12"}], "stats": {"total": 463, "additions": 239, "deletions": 224}, "files": [{"sha": "f91e443e88b18e4edb3d45bb794433109be31320", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1,3 +1,47 @@\n+2013-11-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* target.def (can_use_doloop_p): New hook.\n+\t* doc/tm.texi.in (TARGET_CAN_USE_DOLOOP_P): Add.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/md.texi (doloop_begin, doloop_end): Update documentation.\n+\t* hooks.h (hook_bool_dint_dint_uint_true): Declare.\n+\t* hooks.c (hook_bool_dint_dint_uint_true): New function.\n+\t* targhooks.h (can_use_doloop_if_innermost): Declare.\n+\t* targhooks.c (can_use_doloop_if_innermost): New function.\n+\t* target.h: Include double-int.h.\n+\t* loop-doloop.c (doloop_optimize): Call targetm.can_use_doloop_p.\n+\tRemove iteration count, maximum iteration count, loop depth and\n+\tenter-at-top inputs from doloop_begin and doloop_end.\n+\t* config/arc/arc.md (doloop_begin, doloop_end): Update for new\n+\tinterface.\n+\t* config/arc/arc.c (arc_can_use_doloop_p): New function.\n+\t(TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/arm/thumb2.md (doloop_end): Update for new interface.\n+\t* config/arm/arm.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/bfin/bfin.md (doloop_end): Update for new interface.\n+\t* config/bfin/bfin.c (bfin_can_use_doloop_p): New function.\n+\t(TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/c6x/c6x.md (doloop_end): Update for new interface.\n+\t* config/ia64/ia64.md (doloop_end): Update for new interface.\n+\t* config/ia64/ia64.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/mep/mep.md (doloop_begin, doloop_end): Update for new\n+\tinterface.\n+\t* config/mep/mep.c (mep_emit_doloop): Likewise.\n+\t(TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/rs6000/rs6000.md (doloop_end): Update for new interface.\n+\t* config/rs6000/rs6000.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/s390/s390.md (doloop_end): Update for new interface.\n+\t* config/sh/sh.md (doloop_end): Likewise.\n+\t* config/spu/spu.md (doloop_end): Likewise.\n+\t* config/spu/spu.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/tilegx/tilegx.md (doloop_end): Update for new interface.\n+\t* config/tilegx/tilegx.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/tilepro/tilepro.md (doloop_end): Update for new interface.\n+\t* config/tilepro/tilepro.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\t* config/v850/v850.md (doloop_begin, doloop_end): Update for new\n+\tinterface.\n+\t* config/v850/v850.c (TARGET_CAN_USE_DOLOOP_P): Define.\n+\n 2013-11-08  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR other/59055"}, {"sha": "7b1853b7f9bf0564d4e77c0b9dcc29e80263b353", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -388,6 +388,7 @@ static bool arc_return_in_memory (const_tree, const_tree);\n static void arc_init_simd_builtins (void);\n static bool arc_vector_mode_supported_p (enum machine_mode);\n \n+static bool arc_can_use_doloop_p (double_int, double_int, unsigned int, bool);\n static const char *arc_invalid_within_doloop (const_rtx);\n \n static void output_short_suffix (FILE *file);\n@@ -493,6 +494,9 @@ static void arc_finalize_pic (void);\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P arc_vector_mode_supported_p\n \n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P arc_can_use_doloop_p\n+\n #undef TARGET_INVALID_WITHIN_DOLOOP\n #define TARGET_INVALID_WITHIN_DOLOOP arc_invalid_within_doloop\n \n@@ -5638,6 +5642,23 @@ arc_pass_by_reference (cumulative_args_t ca_v ATTRIBUTE_UNUSED,\n \t      || TREE_ADDRESSABLE (type)));\n }\n \n+/* Implement TARGET_CAN_USE_DOLOOP_P.  */\n+\n+static bool\n+arc_can_use_doloop_p (double_int iterations, double_int,\n+\t\t      unsigned int loop_depth, bool entered_at_top)\n+{\n+  if (loop_depth > 1)\n+    return false;\n+  /* Setting up the loop with two sr instructions costs 6 cycles.  */\n+  if (TARGET_ARC700\n+      && !entered_at_top\n+      && iterations.high == 0\n+      && iterations.low > 0\n+      && iterations.low <= (flag_pic ? 6 : 3))\n+    return false;\n+  return true;\n+}\n \n /* NULL if INSN insn is valid within a low-overhead loop.\n    Otherwise return why doloop cannot be applied.  */"}, {"sha": "baf347876beecc0e8fe828bd889e12cad82144d3", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -4706,16 +4706,10 @@\n })\n \n ; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the loop end pattern\n+; operand 1 is the loop end pattern\n (define_expand \"doloop_begin\"\n   [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand:QI 1 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 3 \"const_int_operand\" \"\"))\n-   (use (match_operand 4 \"\" \"\"))]\n+   (use (match_operand 1 \"\" \"\"))]\n   \"\"\n {\n   /* Using the INSN_UID of the loop end pattern to identify it causes\n@@ -4725,10 +4719,8 @@\n      still be able to tell what kind of number this is.  */\n   static HOST_WIDE_INT loop_end_id = 0;\n \n-  if (INTVAL (operands[3]) > 1)\n-    FAIL;\n   rtx id = GEN_INT (--loop_end_id);\n-  XEXP (XVECEXP (PATTERN (operands[4]), 0, 4), 0) = id;\n+  XEXP (XVECEXP (PATTERN (operands[1]), 0, 4), 0) = id;\n   emit_insn (gen_doloop_begin_i (operands[0], const0_rtx, id,\n \t\t\t\t const0_rtx, const0_rtx));\n   DONE;\n@@ -4907,36 +4899,22 @@\n )\n \n ; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the label to jump to at the top of the loop\n-; operand 5 is nonzero if the loop is entered at its top.\n+; operand 1 is the label to jump to at the top of the loop\n ; Use this for the ARC600 and ARC700.  For ARCtangent-A5, this is unsafe\n ; without further checking for nearby branches etc., and without proper\n ; annotation of shift patterns that clobber lp_count\n ; ??? ARC600 might want to check if the loop has few iteration and only a\n ; single insn - loop setup is expensive then.\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand:QI 1 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 3 \"const_int_operand\" \"\"))\n-   (use (label_ref (match_operand 4 \"\" \"\")))\n-   (use (match_operand:QI 5 \"const_int_operand\" \"\"))]\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"TARGET_ARC600 || TARGET_ARC700\"\n {\n-  if (INTVAL (operands[3]) > 1)\n-    FAIL;\n-  /* Setting up the loop with two sr isntructions costs 6 cycles.  */\n-  if (TARGET_ARC700 && !INTVAL (operands[5])\n-      && INTVAL (operands[1]) && INTVAL (operands[1]) <= (flag_pic ? 6 : 3))\n-    FAIL;\n   /* We could do smaller bivs with biv widening, and wider bivs by having\n      a high-word counter in an outer loop - but punt on this for now.  */\n   if (GET_MODE (operands[0]) != SImode)\n     FAIL;\n-  emit_jump_insn (gen_doloop_end_i (operands[0], operands[4], const0_rtx));\n+  emit_jump_insn (gen_doloop_end_i (operands[0], operands[1], const0_rtx));\n   DONE;\n })\n "}, {"sha": "acb1c166e77dfce2bf75f2135ab6f6adef13f2c0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -667,6 +667,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef MAX_INSN_PER_IT_BLOCK\n #define MAX_INSN_PER_IT_BLOCK (arm_restrict_it ? 1 : 4)\n \n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f"}, {"sha": "b8b49fe7aee0ccd6a2f82cf322ad25d39daa7431", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1449,11 +1449,7 @@\n ;; knows what to generate.\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))      ; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))      ; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))      ; max iterations\n-   (use (match_operand 3 \"\" \"\"))      ; loop level\n-   (use (match_operand 4 \"\" \"\"))      ; label\n-   (use (match_operand 5 \"\" \"\"))]     ; flag: 1 if loop entered at top, else 0\n+   (use (match_operand 1 \"\" \"\"))]     ; label\n   \"TARGET_32BIT\"\n   \"\n  {\n@@ -1472,10 +1468,6 @@\n      rtx insn;\n      rtx cmp;\n \n-     /* Only use this on innermost loops.  */\n-     if (INTVAL (operands[3]) > 1)\n-       FAIL;\n-\n      if (GET_MODE (operands[0]) != SImode)\n        FAIL;\n \n@@ -1488,7 +1480,7 @@\n      cmp = XVECEXP (PATTERN (insn), 0, 0);\n      cc_reg = SET_DEST (cmp);\n      bcomp = gen_rtx_NE (VOIDmode, cc_reg, const0_rtx);\n-     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [4]);\n+     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [1]);\n      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n                                   gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n                                                         loc_ref, pc_rtx)));"}, {"sha": "bd677f88bab76529b0e5267bd5c98e896db49765", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -3366,6 +3366,22 @@ find_prev_insn_start (rtx insn)\n   return insn;\n }\n \f\n+/* Implement TARGET_CAN_USE_DOLOOP_P.  */\n+\n+static bool\n+bfin_can_use_doloop_p (double_int, double_int iterations_max,\n+\t\t       unsigned int, bool)\n+{\n+  /* Due to limitations in the hardware (an initial loop count of 0\n+     does not loop 2^32 times) we must avoid to generate a hardware\n+     loops when we cannot rule out this case.  */\n+  if (!flag_unsafe_loop_optimizations\n+      && (iterations_max.high != 0\n+\t  || iterations_max.low >= 0xFFFFFFFF))\n+    return false;\n+  return true;\n+}\n+\n /* Increment the counter for the number of loop instructions in the\n    current function.  */\n \n@@ -5810,4 +5826,7 @@ bfin_conditional_register_usage (void)\n #undef TARGET_DELAY_VARTRACK\n #define TARGET_DELAY_VARTRACK true\n \n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P bfin_can_use_doloop_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "e3bc6363f4aa31c4551a440d9e25803f82936597", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1929,35 +1929,25 @@\n ;;  Hardware loop\n \n ; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the label to jump to at the top of the loop\n-; operand 5 indicates if the loop is entered at the top\n+; operand 1 is the label to jump to at the top of the loop\n (define_expand \"doloop_end\"\n   [(parallel [(set (pc) (if_then_else\n \t\t\t  (ne (match_operand:SI 0 \"\" \"\")\n \t\t\t      (const_int 1))\n-\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t  (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t  (pc)))\n \t      (set (match_dup 0)\n \t\t   (plus:SI (match_dup 0)\n \t\t\t    (const_int -1)))\n \t      (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n-\t      (clobber (match_operand 5 \"\"))])] ; match_scratch\n+\t      (clobber (match_dup 2))])] ; match_scratch\n   \"\"\n {\n   /* The loop optimizer doesn't check the predicates... */\n   if (GET_MODE (operands[0]) != SImode)\n     FAIL;\n-  /* Due to limitations in the hardware (an initial loop count of 0\n-     does not loop 2^32 times) we must avoid to generate a hardware\n-     loops when we cannot rule out this case.  */\n-  if (!flag_unsafe_loop_optimizations\n-      && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) >= 0xFFFFFFFF)\n-    FAIL;\n   bfin_hardware_loop ();\n-  operands[5] = gen_rtx_SCRATCH (SImode);\n+  operands[2] = gen_rtx_SCRATCH (SImode);\n })\n \n (define_insn \"loop_end\""}, {"sha": "d7606965cde63c8f205bca04f7a595e9fc014e78", "filename": "gcc/config/c6x/c6x.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fc6x%2Fc6x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fc6x%2Fc6x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1421,27 +1421,23 @@\n ;; -------------------------------------------------------------------------\n \n ; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the label to jump to at the top of the loop\n-; operand 5 indicates if the loop is entered at the top\n+; operand 1 is the label to jump to at the top of the loop\n (define_expand \"doloop_end\"\n   [(parallel [(set (pc) (if_then_else\n \t\t\t  (ne (match_operand:SI 0 \"\" \"\")\n \t\t\t      (const_int 1))\n-\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t  (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t  (pc)))\n \t      (set (match_dup 0)\n \t\t   (plus:SI (match_dup 0)\n \t\t\t    (const_int -1)))\n-\t      (clobber (match_operand 5 \"\"))])] ; match_scratch\n+\t      (clobber (match_dup 2))])] ; match_scratch\n   \"TARGET_INSNS_64PLUS && optimize\"\n {\n   /* The loop optimizer doesn't check the predicates... */\n   if (GET_MODE (operands[0]) != SImode)\n     FAIL;\n-  operands[5] = gen_rtx_SCRATCH (SImode);\n+  operands[2] = gen_rtx_SCRATCH (SImode);\n })\n \n (define_insn \"mvilc\""}, {"sha": "1bf3e2fe928c993dde2e756067aa2b18a55e8a23", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -620,6 +620,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT ia64_trampoline_init\n \n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n #undef TARGET_INVALID_WITHIN_DOLOOP\n #define TARGET_INVALID_WITHIN_DOLOOP hook_constcharptr_const_rtx_null\n "}, {"sha": "4d9d4e0129f55514329eabcd9364052505002107", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -3956,18 +3956,11 @@\n \n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))\t; max iterations\n-   (use (match_operand 3 \"\" \"\"))\t; loop level\n-   (use (match_operand 4 \"\" \"\"))\t; label\n-   (use (match_operand 5 \"\" \"\"))]\t; flag: 1 if loop entered at top, else 0\n+   (use (match_operand 1 \"\" \"\"))]\t; label\n   \"\"\n {\n-  /* Only use cloop on innermost loops.  */\n-  if (INTVAL (operands[3]) > 1)\n-    FAIL;\n   emit_jump_insn (gen_doloop_end_internal (gen_rtx_REG (DImode, AR_LC_REGNUM),\n-\t\t\t\t\t   operands[4]));\n+\t\t\t\t\t   operands[1]));\n   DONE;\n })\n "}, {"sha": "e67540a56113eca54ee6a8c059a4778e474eac4f", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -5103,7 +5103,7 @@ mep_emit_doloop (rtx *operands, int is_end)\n \n   tag = GEN_INT (cfun->machine->doloop_tags - 1);\n   if (is_end)\n-    emit_jump_insn (gen_doloop_end_internal (operands[0], operands[4], tag));\n+    emit_jump_insn (gen_doloop_end_internal (operands[0], operands[1], tag));\n   else\n     emit_insn (gen_doloop_begin_internal (operands[0], operands[0], tag));\n }\n@@ -7280,6 +7280,8 @@ mep_asm_init_sections (void)\n #define TARGET_TRAMPOLINE_INIT\t\tmep_trampoline_init\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P\tmep_legitimate_constant_p\n+#undef  TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P\t\tcan_use_doloop_if_innermost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "42542eab8bd7ae4934c28990b9590902e1486558", "filename": "gcc/config/mep/mep.md", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fmep%2Fmep.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fmep%2Fmep.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -2076,14 +2076,9 @@\n \n (define_expand \"doloop_begin\"\n   [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand:QI 1 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 3 \"const_int_operand\" \"\"))\n-   (use (match_operand 4 \"\" \"\"))]\n+   (use (match_operand 1 \"\" \"\"))]\n   \"!profile_arc_flag && TARGET_OPT_REPEAT\"\n-  \"if (INTVAL (operands[3]) > 1)\n-     FAIL;\n-   mep_emit_doloop (operands, 0);\n+  \"mep_emit_doloop (operands, 0);\n    DONE;\n   \")\n \n@@ -2112,15 +2107,9 @@\n \n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"nonimmediate_operand\" \"\"))\n-   (use (match_operand:QI 1 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n-   (use (match_operand:QI 3 \"const_int_operand\" \"\"))\n-   (use (label_ref (match_operand 4 \"\" \"\")))\n-   (use (match_operand 5 \"\" \"\"))]\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"!profile_arc_flag && TARGET_OPT_REPEAT\"\n-  \"if (INTVAL (operands[3]) > 1)\n-     FAIL;\n-   if (GET_CODE (operands[0]) == REG && GET_MODE (operands[0]) != SImode)\n+  \"if (GET_CODE (operands[0]) == REG && GET_MODE (operands[0]) != SImode)\n      FAIL;\n    mep_emit_doloop (operands, 1);\n    DONE;"}, {"sha": "8c8ee9fae0e753480a53512ede3c475e20ee61cd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1593,6 +1593,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n #define TARGET_VECTORIZE_VEC_PERM_CONST_OK rs6000_vectorize_vec_perm_const_ok\n+\n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \f\n \n /* Processor table.  */"}, {"sha": "3f13c4603f7535b7be829b772ff7f5929860e799", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -14791,28 +14791,21 @@\n \n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))\t; max iterations\n-   (use (match_operand 3 \"\" \"\"))\t; loop level\n-   (use (match_operand 4 \"\" \"\"))\t; label\n-   (use (match_operand 5 \"\" \"\"))]\t; flag: 1 if loop entered at top, else 0\n+   (use (match_operand 1 \"\" \"\"))]\t; label\n   \"\"\n   \"\n {\n-  /* Only use this on innermost loops.  */\n-  if (INTVAL (operands[3]) > 1)\n-    FAIL;\n   if (TARGET_64BIT)\n     {\n       if (GET_MODE (operands[0]) != DImode)\n \tFAIL;\n-      emit_jump_insn (gen_ctrdi (operands[0], operands[4]));\n+      emit_jump_insn (gen_ctrdi (operands[0], operands[1]));\n     }\n   else\n     {\n       if (GET_MODE (operands[0]) != SImode)\n \tFAIL;\n-      emit_jump_insn (gen_ctrsi (operands[0], operands[4]));\n+      emit_jump_insn (gen_ctrsi (operands[0], operands[1]));\n     }\n   DONE;\n }\")"}, {"sha": "8354e26389296f23bfd49a80235e2c547b05d867", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -8412,19 +8412,15 @@\n \n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))        ; max iterations\n-   (use (match_operand 3 \"\" \"\"))        ; loop level\n-   (use (match_operand 4 \"\" \"\"))        ; label\n-   (use (match_operand 5 \"\" \"\"))]       ; flag: 1 if loop entered at top, else 0\n+   (use (match_operand 1 \"\" \"\"))]       ; label\n   \"\"\n {\n   if (GET_MODE (operands[0]) == SImode && !TARGET_CPU_ZARCH)\n-    emit_jump_insn (gen_doloop_si31 (operands[4], operands[0], operands[0]));\n+    emit_jump_insn (gen_doloop_si31 (operands[1], operands[0], operands[0]));\n   else if (GET_MODE (operands[0]) == SImode && TARGET_CPU_ZARCH)\n-    emit_jump_insn (gen_doloop_si64 (operands[4], operands[0], operands[0]));\n+    emit_jump_insn (gen_doloop_si64 (operands[1], operands[0], operands[0]));\n   else if (GET_MODE (operands[0]) == DImode && TARGET_ZARCH)\n-    emit_jump_insn (gen_doloop_di (operands[4], operands[0], operands[0]));\n+    emit_jump_insn (gen_doloop_di (operands[1], operands[0], operands[0]));\n   else\n     FAIL;\n "}, {"sha": "8cc9195c9887de6ad89c32345e28b31836ad1f92", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -8776,25 +8776,21 @@ label:\n })\n \n ; operand 0 is the loop count pseudo register\n-; operand 1 is the number of loop iterations or 0 if it is unknown\n-; operand 2 is the maximum number of loop iterations\n-; operand 3 is the number of levels of enclosed loops\n-; operand 4 is the label to jump to at the top of the loop\n+; operand 1 is the label to jump to at the top of the loop\n (define_expand \"doloop_end\"\n   [(parallel [(set (pc)\n \t\t   (if_then_else (ne:SI (match_operand:SI 0 \"\" \"\")\n \t\t\t\t        (const_int 1))\n-\t\t\t\t (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t\t (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t\t (pc)))\n \t      (set (match_dup 0)\n \t\t   (plus:SI (match_dup 0) (const_int -1)))\n-\t      (clobber (reg:SI T_REG))])\n-   (match_operand 5 \"\" \"\")]\n+\t      (clobber (reg:SI T_REG))])]\n   \"TARGET_SH2\"\n {\n   if (GET_MODE (operands[0]) != SImode)\n     FAIL;\n-  emit_jump_insn (gen_doloop_end_split (operands[0], operands[4], operands[0]));\n+  emit_jump_insn (gen_doloop_end_split (operands[0], operands[1], operands[0]));\n   DONE;\n })\n "}, {"sha": "38c441d9a030c1bfc5651292b2ec5bd695b2322c", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -7328,6 +7328,9 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_CANONICALIZE_COMPARISON\n #define TARGET_CANONICALIZE_COMPARISON spu_canonicalize_comparison\n \n+#undef TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-spu.h\""}, {"sha": "3ca53481128db6bbcbc8bbb8f4352ec61d9db807", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -4487,11 +4487,7 @@ selb\\t%0,%4,%0,%3\"\n  ;; knows what to generate.\n  (define_expand \"doloop_end\"\n    [(use (match_operand 0 \"\" \"\"))      ; loop pseudo\n-    (use (match_operand 1 \"\" \"\"))      ; iterations; zero if unknown\n-    (use (match_operand 2 \"\" \"\"))      ; max iterations\n-    (use (match_operand 3 \"\" \"\"))      ; loop level\n-    (use (match_operand 4 \"\" \"\"))      ; label\n-    (match_operand 5 \"\" \"\")]\n+    (use (match_operand 1 \"\" \"\"))]     ; label\n    \"\"\n    \"\n  {\n@@ -4507,16 +4503,13 @@ selb\\t%0,%4,%0,%3\"\n      rtx bcomp;\n      rtx loc_ref;\n \n-     /* Only use this on innermost loops.  */\n-     if (INTVAL (operands[3]) > 1)\n-       FAIL;\n      if (GET_MODE (operands[0]) != SImode)\n        FAIL;\n \n      s0 = operands [0];\n      emit_move_insn (s0, gen_rtx_PLUS (SImode, s0, GEN_INT (-1)));\n      bcomp = gen_rtx_NE(SImode, s0, const0_rtx);\n-     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [4]);\n+     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [1]);\n      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n                                   gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n                                                         loc_ref, pc_rtx)));"}, {"sha": "dafa44c0674226be4c020c2f5ae2648c6b04c7a0", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -5578,6 +5578,8 @@ tilegx_file_end (void)\n #undef  TARGET_ASM_ALIGNED_DI_OP\n #define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n \n+#undef  TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "30dc8e628ba8a8410ae5fa43d5022bbe4f7224bb", "filename": "gcc/config/tilegx/tilegx.md", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -2414,11 +2414,7 @@\n ;; generate.\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))    ;; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))    ;; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))    ;; max iterations\n-   (use (match_operand 3 \"\" \"\"))    ;; loop level\n-   (use (match_operand 4 \"\" \"\"))    ;; label\n-   (use (match_operand 5 \"\" \"\"))]   ;; flag: 1 if loop entered at top, else 0\n+   (use (match_operand 1 \"\" \"\"))]   ;; label\n    \"\"\n {\n   if (optimize > 0 && flag_modulo_sched)\n@@ -2428,17 +2424,14 @@\n      rtx loc_ref;\n      enum machine_mode mode = GET_MODE (operands[0]);\n \n-     /* only do inner loop  */\n-     if (INTVAL (operands[3]) > 1)\n-       FAIL;\n      /* only deal with loop counters in SImode or DImode  */\n      if (mode != SImode && mode != DImode)\n        FAIL;\n \n      s0 = operands [0];\n      emit_move_insn (s0, gen_rtx_PLUS (mode, s0, GEN_INT (-1)));\n      bcomp = gen_rtx_NE(mode, s0, const0_rtx);\n-     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [4]);\n+     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [1]);\n      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n                                   gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n                                                         loc_ref, pc_rtx)));"}, {"sha": "5e3be831fb1b6e705afb35dbfea7288db5fa6ff7", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -5067,6 +5067,8 @@ tilepro_file_end (void)\n #undef  TARGET_ASM_FILE_END\n #define TARGET_ASM_FILE_END tilepro_file_end\n \n+#undef  TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "f090f9e038bd61258212c666b5a3f48bf4b31b4b", "filename": "gcc/config/tilepro/tilepro.md", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilepro%2Ftilepro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Ftilepro%2Ftilepro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1318,11 +1318,7 @@\n ;; generate.\n (define_expand \"doloop_end\"\n   [(use (match_operand 0 \"\" \"\"))    ;; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))    ;; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))    ;; max iterations\n-   (use (match_operand 3 \"\" \"\"))    ;; loop level\n-   (use (match_operand 4 \"\" \"\"))    ;; label\n-   (use (match_operand 5 \"\" \"\"))]   ;; flag: 1 if loop entered at top, else 0\n+   (use (match_operand 1 \"\" \"\"))]   ;; label\n    \"\"\n {\n   if (optimize > 0)\n@@ -1331,9 +1327,6 @@\n      rtx bcomp;\n      rtx loc_ref;\n \n-     /* only do inner loop  */\n-     if (INTVAL (operands[3]) > 1)\n-       FAIL;\n      /* only deal with loop counters in SImode  */\n      if (GET_MODE (operands[0]) != SImode)\n        FAIL;\n@@ -1342,7 +1335,7 @@\n \n      emit_move_insn (s0, gen_rtx_PLUS (SImode, s0, GEN_INT (-1)));\n      bcomp = gen_rtx_NE(SImode, s0, const0_rtx);\n-     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [4]);\n+     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [1]);\n      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n                                   gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n                                                         loc_ref, pc_rtx)));"}, {"sha": "006cff4bcdfbd776b875eff524b80512c691e1c7", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -3269,6 +3269,9 @@ v850_gen_movdi (rtx * operands)\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P v850_legitimate_constant_p\n \n+#undef  TARGET_CAN_USE_DOLOOP_P\n+#define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-v850.h\""}, {"sha": "f56d54a91a0c8207d78495ba9205b17398a3c0c2", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1357,20 +1357,11 @@\n \n (define_expand \"doloop_begin\"\n  [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n-  (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n-  (use (match_operand 2 \"\" \"\"))        ; max iterations\n-  (use (match_operand 3 \"\" \"\"))        ; loop level\n-  (use (match_operand 4 \"\" \"\"))]       ; condition\n+  (use (match_operand 1 \"\" \"\"))]       ; doloop_end pattern\n   \"TARGET_V850E3V5_UP && TARGET_LOOP\"\n   {\n-    rtx loop_cnt   = operands[0];\n-    rtx loop_level = operands[3];\n-\n-    if (INTVAL (loop_level) > 1)\n-      FAIL;\n-    if (GET_MODE (loop_cnt) != SImode)\n-      FAIL;\n-\n+    rtx loop_cnt = operands[0];\n+    gcc_assert (GET_MODE (loop_cnt) == SImode);\n     emit_insn (gen_fix_loop_counter (loop_cnt));\n     DONE;\n   }\n@@ -1394,19 +1385,12 @@\n \n (define_expand \"doloop_end\"\n  [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n-  (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n-  (use (match_operand 2 \"\" \"\"))        ; max iterations\n-  (use (match_operand 3 \"\" \"\"))        ; loop level\n-  (use (match_operand 4 \"\" \"\"))        ; label\n-  (use (match_operand 5 \"\" \"\"))]       ; entered at top\n+  (use (match_operand 1 \"\" \"\"))]       ; label\n   \"TARGET_V850E3V5_UP && TARGET_LOOP\"\n   {\n-    rtx loop_cnt   = operands[0];\n-    rtx loop_level = operands[3];\n-    rtx label      = operands[4];\n+    rtx loop_cnt = operands[0];\n+    rtx label    = operands[1];\n \n-    if (INTVAL (loop_level) > 1)\n-      FAIL;\n     if (GET_MODE (loop_cnt) != SImode)\n       FAIL;\n "}, {"sha": "1a06e3d6e74037f00d1fc92d4a33571762cbddbc", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -5857,34 +5857,27 @@ reduction is enabled.\n \n @cindex @code{doloop_end} instruction pattern\n @item @samp{doloop_end}\n-Conditional branch instruction that decrements a register and jumps if\n-the register is nonzero.  This instruction takes five operands: Operand\n-0 is the register to decrement and test; operand 1 is the number of loop\n-iterations as a @code{const_int} or @code{const0_rtx} if this cannot be\n-determined until run-time; operand 2 is the actual or estimated maximum\n-number of iterations as a @code{const_int}; operand 3 is the number of\n-enclosed loops as a @code{const_int} (an innermost loop has a value of\n-1); operand 4 is the label to jump to if the register is nonzero;\n-operand 5 is const1_rtx if the loop in entered at its top, const0_rtx\n-otherwise.\n+Conditional branch instruction that decrements a register and\n+jumps if the register is nonzero.  Operand 0 is the register to\n+decrement and test; operand 1 is the label to jump to if the\n+register is nonzero.\n @xref{Looping Patterns}.\n \n This optional instruction pattern should be defined for machines with\n low-overhead looping instructions as the loop optimizer will try to\n-modify suitable loops to utilize it.  If nested low-overhead looping is\n-not supported, use a @code{define_expand} (@pxref{Expander Definitions})\n-and make the pattern fail if operand 3 is not @code{const1_rtx}.\n-Similarly, if the actual or estimated maximum number of iterations is\n-too large for this instruction, make it fail.\n+modify suitable loops to utilize it.  The target hook\n+@code{TARGET_CAN_USE_DOLOOP_P} controls the conditions under which\n+low-overhead loops can be used.\n \n @cindex @code{doloop_begin} instruction pattern\n @item @samp{doloop_begin}\n Companion instruction to @code{doloop_end} required for machines that\n-need to perform some initialization, such as loading special registers\n-used by a low-overhead looping instruction.  If initialization insns do\n-not always need to be emitted, use a @code{define_expand}\n-(@pxref{Expander Definitions}) and make it fail.\n+need to perform some initialization, such as loading a special counter\n+register.  Operand 1 is the associated @code{doloop_end} pattern and\n+operand 0 is the register that it decrements.\n \n+If initialization insns do not always need to be emitted, use a\n+@code{define_expand} (@pxref{Expander Definitions}) and make it fail.\n \n @cindex @code{canonicalize_funcptr_for_compare} instruction pattern\n @item @samp{canonicalize_funcptr_for_compare}"}, {"sha": "35cfa995583ddb89fff77973b1f5229f1d025367", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -11091,6 +11091,20 @@ function version at run-time for a given set of function versions.\n body must be generated.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_CAN_USE_DOLOOP_P (double_int @var{iterations}, double_int @var{iterations_max}, unsigned int @var{loop_depth}, bool @var{entered_at_top})\n+Return true if it is possible to use low-overhead loops (@code{doloop_end}\n+and @code{doloop_begin}) for a particular loop.  @var{iterations} gives the\n+exact number of iterations, or 0 if not known.  @var{iterations_max} gives\n+the maximum number of iterations, or 0 if not known.  @var{loop_depth} is\n+the nesting depth of the loop, with 1 for innermost loops, 2 for loops that\n+contain innermost loops, and so on.  @var{entered_at_top} is true if the\n+loop is only entered from the top.\n+\n+This hook is only used if @code{doloop_end} is available.  The default\n+implementation returns true.  You can use @code{can_use_doloop_if_innermost}\n+if the loop must be the innermost, and if there are no other restrictions.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {const char *} TARGET_INVALID_WITHIN_DOLOOP (const_rtx @var{insn})\n \n Take an instruction in @var{insn} and return NULL if it is valid within a"}, {"sha": "b10ecd7dda8d84849f5b4347a4cb390e90db6087", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -8212,6 +8212,8 @@ to by @var{ce_info}.\n \n @hook TARGET_GENERATE_VERSION_DISPATCHER_BODY\n \n+@hook TARGET_CAN_USE_DOLOOP_P\n+\n @hook TARGET_INVALID_WITHIN_DOLOOP\n \n @hook TARGET_LEGITIMATE_COMBINED_INSN"}, {"sha": "9f53007337d5897e7f945ffeadff2e99f85bcf51", "filename": "gcc/hooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -331,6 +331,12 @@ hook_bool_rtx_int_int_int_intp_bool_false (rtx a ATTRIBUTE_UNUSED,\n   return false;\n }\n \n+bool\n+hook_bool_dint_dint_uint_bool_true (double_int, double_int, unsigned int, bool)\n+{\n+  return true;\n+}\n+\n /* Generic hook that takes an rtx and returns it.  */\n rtx\n hook_rtx_rtx_identity (rtx x)"}, {"sha": "38454fbe10a5480bc8487329b3627ac395c22873", "filename": "gcc/hooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -23,6 +23,7 @@\n #define GCC_HOOKS_H\n \n #include \"machmode.h\"\n+#include \"double-int.h\"\n \n extern bool hook_bool_void_false (void);\n extern bool hook_bool_void_true (void);\n@@ -60,6 +61,8 @@ extern bool hook_bool_rtx_int_int_int_intp_bool_false (rtx, int, int, int,\n extern bool hook_bool_tree_tree_false (tree, tree);\n extern bool hook_bool_tree_tree_true (tree, tree);\n extern bool hook_bool_tree_bool_false (tree, bool);\n+extern bool hook_bool_dint_dint_uint_bool_true (double_int, double_int,\n+\t\t\t\t\t\tunsigned int, bool);\n \n extern void hook_void_void (void);\n extern void hook_void_constcharptr (const char *);"}, {"sha": "82c01a54b9d4cce01c5b77913d53e99cdce47482", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 24, "deletions": 45, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -548,20 +548,8 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n #ifdef HAVE_doloop_begin\n   {\n     rtx init;\n-    unsigned level = get_loop_level (loop) + 1;\n-    double_int iter;\n-    rtx iter_rtx;\n-\n-    if (!get_max_loop_iterations (loop, &iter)\n-\t|| !iter.fits_shwi ())\n-      iter_rtx = const0_rtx;\n-    else\n-      iter_rtx = GEN_INT (iter.to_shwi ());\n-    init = gen_doloop_begin (counter_reg,\n-\t\t\t     desc->const_iter ? desc->niter_expr : const0_rtx,\n-\t\t\t     iter_rtx,\n-\t\t\t     GEN_INT (level),\n-\t\t\t     doloop_seq);\n+\n+    init = gen_doloop_begin (counter_reg, doloop_seq);\n     if (init)\n       {\n \tstart_sequence ();\n@@ -608,16 +596,15 @@ doloop_optimize (struct loop *loop)\n {\n   enum machine_mode mode;\n   rtx doloop_seq, doloop_pat, doloop_reg;\n-  rtx iterations, count;\n-  rtx iterations_max;\n+  rtx count;\n+  double_int iterations, iterations_max;\n   rtx start_label;\n   rtx condition;\n   unsigned level, est_niter;\n   int max_cost;\n   struct niter_desc *desc;\n   unsigned word_mode_size;\n   unsigned HOST_WIDE_INT word_mode_max;\n-  double_int iter;\n   int entered_at_top;\n \n   if (dump_file)\n@@ -667,25 +654,30 @@ doloop_optimize (struct loop *loop)\n       return false;\n     }\n \n-  count = copy_rtx (desc->niter_expr);\n-  iterations = desc->const_iter ? desc->niter_expr : const0_rtx;\n-  if (!get_max_loop_iterations (loop, &iter)\n-      || !iter.fits_shwi ())\n-    iterations_max = const0_rtx;\n+  if (desc->const_iter)\n+    iterations = rtx_to_double_int (desc->niter_expr);\n   else\n-    iterations_max = GEN_INT (iter.to_shwi ());\n+    iterations = double_int_zero;\n+  if (!get_max_loop_iterations (loop, &iterations_max))\n+    iterations_max = double_int_zero;\n   level = get_loop_level (loop) + 1;\n+  entered_at_top = (loop->latch == desc->in_edge->dest\n+\t\t    && contains_no_active_insn_p (loop->latch));\n+  if (!targetm.can_use_doloop_p (iterations, iterations_max, level,\n+\t\t\t\t entered_at_top))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Loop rejected by can_use_doloop_p.\\n\");\n+      return false;\n+    }\n \n   /* Generate looping insn.  If the pattern FAILs then give up trying\n      to modify the loop since there is some aspect the back-end does\n      not like.  */\n+  count = copy_rtx (desc->niter_expr);\n   start_label = block_label (desc->in_edge->dest);\n   doloop_reg = gen_reg_rtx (mode);\n-  entered_at_top = (loop->latch == desc->in_edge->dest\n-\t\t    && contains_no_active_insn_p (loop->latch));\n-  doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n-\t\t\t       GEN_INT (level), start_label,\n-\t\t\t       GEN_INT (entered_at_top));\n+  doloop_seq = gen_doloop_end (doloop_reg, start_label);\n \n   word_mode_size = GET_MODE_PRECISION (word_mode);\n   word_mode_max\n@@ -696,27 +688,14 @@ doloop_optimize (struct loop *loop)\n \t computed, we must be sure that the number of iterations fits into\n \t the new mode.  */\n       && (word_mode_size >= GET_MODE_PRECISION (mode)\n-\t  || iter.ule (double_int::from_shwi (word_mode_max))))\n+\t  || iterations_max.ule (double_int::from_shwi (word_mode_max))))\n     {\n       if (word_mode_size > GET_MODE_PRECISION (mode))\n-\t{\n-\t  count = simplify_gen_unary (ZERO_EXTEND, word_mode,\n-\t\t\t\t      count, mode);\n-\t  iterations = simplify_gen_unary (ZERO_EXTEND, word_mode,\n-\t\t\t\t\t   iterations, mode);\n-\t  iterations_max = simplify_gen_unary (ZERO_EXTEND, word_mode,\n-\t\t\t\t\t       iterations_max, mode);\n-\t}\n+\tcount = simplify_gen_unary (ZERO_EXTEND, word_mode, count, mode);\n       else\n-\t{\n-\t  count = lowpart_subreg (word_mode, count, mode);\n-\t  iterations = lowpart_subreg (word_mode, iterations, mode);\n-\t  iterations_max = lowpart_subreg (word_mode, iterations_max, mode);\n-\t}\n+\tcount = lowpart_subreg (word_mode, count, mode);\n       PUT_MODE (doloop_reg, word_mode);\n-      doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n-\t\t\t\t   GEN_INT (level), start_label,\n-\t\t\t\t   GEN_INT (entered_at_top));\n+      doloop_seq = gen_doloop_end (doloop_reg, start_label);\n     }\n   if (! doloop_seq)\n     {"}, {"sha": "f6e42a17b0e5274cab5c281dd1e74c16958dd3ea", "filename": "gcc/target.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -3597,6 +3597,23 @@ normally defined in @file{libgcc2.c}.\",\n  tree, (void),\n  default_external_stack_protect_fail)\n \n+DEFHOOK\n+(can_use_doloop_p,\n+ \"Return true if it is possible to use low-overhead loops (@code{doloop_end}\\n\\\n+and @code{doloop_begin}) for a particular loop.  @var{iterations} gives the\\n\\\n+exact number of iterations, or 0 if not known.  @var{iterations_max} gives\\n\\\n+the maximum number of iterations, or 0 if not known.  @var{loop_depth} is\\n\\\n+the nesting depth of the loop, with 1 for innermost loops, 2 for loops that\\n\\\n+contain innermost loops, and so on.  @var{entered_at_top} is true if the\\n\\\n+loop is only entered from the top.\\n\\\n+\\n\\\n+This hook is only used if @code{doloop_end} is available.  The default\\n\\\n+implementation returns true.  You can use @code{can_use_doloop_if_innermost}\\n\\\n+if the loop must be the innermost, and if there are no other restrictions.\",\n+ bool, (double_int iterations, double_int iterations_max,\n+\tunsigned int loop_depth, bool entered_at_top),\n+ hook_bool_dint_dint_uint_bool_true)\n+\n /* Returns NULL if target supports the insn within a doloop block,\n    otherwise it returns an error message.  */\n DEFHOOK"}, {"sha": "12249ecfd5ca7c4fa3e65ba8b0170acbfa623227", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -50,6 +50,7 @@\n \n #include \"insn-modes.h\"\n #include \"insn-codes.h\"\n+#include \"double-int.h\"\n \n #ifdef ENABLE_CHECKING\n "}, {"sha": "a671486453a4f80283ab946ad0b6fe0389f4dcfa", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -1738,5 +1738,14 @@ default_builtin_chkp_function (unsigned int fcode ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n+/* An implementation of TARGET_CAN_USE_DOLOOP_P for targets that do\n+   not support nested low-overhead loops.  */\n+\n+bool\n+can_use_doloop_if_innermost (double_int, double_int,\n+\t\t\t     unsigned int loop_depth, bool)\n+{\n+  return loop_depth == 1;\n+}\n \n #include \"gt-targhooks.h\""}, {"sha": "1ba0c1d4e7d01bb53c892c35f5f6c1f13a1311ca", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=1d0216c8b79931cffcc5599b8a9a4f6eaf86d2b7", "patch": "@@ -213,3 +213,5 @@ extern tree default_fn_abi_va_list_bounds_size (tree);\n extern tree default_chkp_bound_type (void);\n extern enum machine_mode default_chkp_bound_mode (void);\n extern tree default_builtin_chkp_function (unsigned int);\n+extern bool can_use_doloop_if_innermost (double_int, double_int,\n+\t\t\t\t\t unsigned int, bool);"}]}