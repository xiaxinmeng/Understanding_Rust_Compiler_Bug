{"sha": "196b199369f3e1f24c391891fcf9ab90de2a2739", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk2YjE5OTM2OWYzZTFmMjRjMzkxODkxZmNmOWFiOTBkZTJhMjczOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-11-30T10:45:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-11-30T10:45:39Z"}, "message": "[multiple changes]\n\n2009-11-30  Robert Dewar  <dewar@adacore.com>\n\n\t* osint.ads, prj.adb, prj.ads: Minor reformatting\n\t* s-stchop.adb, s-taprop-vxworks.adb, s-taprop-tru64.adb,\n\ts-taprop-vms.adb, s-taprop-linux.adb, s-taprop-solaris.adb,\n\ts-strxdr.adb, s-taprop-irix.adb,\n\ts-osinte-hpux-dce.adb, s-osinte-tru64.adb, s-taenca.adb,\n\ts-taprop-hpux-dce.adb, s-stausa.adb, s-taprop-posix.adb: Minor code\n\treorganization (use conditional expressions).\n\n2009-11-30  Bob Duff  <duff@adacore.com>\n\n\t* g-sttsne-locking.adb (Copy_Service_Entry): Complete previous change.\n\nFrom-SVN: r154779", "tree": {"sha": "3b261d5a5445f547021de9cc6066149576f1ce31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b261d5a5445f547021de9cc6066149576f1ce31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/196b199369f3e1f24c391891fcf9ab90de2a2739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196b199369f3e1f24c391891fcf9ab90de2a2739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/196b199369f3e1f24c391891fcf9ab90de2a2739", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196b199369f3e1f24c391891fcf9ab90de2a2739/comments", "author": null, "committer": null, "parents": [{"sha": "ffab1d071ca78b02490bb39ae784d1ad45f4eb04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffab1d071ca78b02490bb39ae784d1ad45f4eb04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffab1d071ca78b02490bb39ae784d1ad45f4eb04"}], "stats": {"total": 651, "additions": 270, "deletions": 381}, "files": [{"sha": "e07b4fa0b45aa887bd52542a3f094d963c9b694f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -1,3 +1,17 @@\n+2009-11-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* osint.ads, prj.adb, prj.ads: Minor reformatting\n+\t* s-stchop.adb, s-taprop-vxworks.adb, s-taprop-tru64.adb,\n+\ts-taprop-vms.adb, s-taprop-linux.adb, s-taprop-solaris.adb,\n+\ts-strxdr.adb, s-taprop-irix.adb, s-osinte-hpux-dce.adb,\n+\ts-osinte-tru64.adb, s-taenca.adb, s-taprop-hpux-dce.adb, s-stausa.adb,\n+\ts-taprop-posix.adb: Minor code reorganization (use conditional\n+\texpressions).\n+\n+2009-11-30  Bob Duff  <duff@adacore.com>\n+\n+\t* g-sttsne-locking.adb (Copy_Service_Entry): Complete previous change.\n+\n 2009-11-30  Bob Duff  <duff@adacore.com>\n \n \t* socket.c: Add more accessor functions for struct servent (need"}, {"sha": "c5e39b734b90609d1bf3793b93c60fe504a4c526", "filename": "gcc/ada/g-sttsne-locking.adb", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fg-sttsne-locking.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fg-sttsne-locking.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sttsne-locking.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -57,8 +57,8 @@ package body GNAT.Sockets.Thin.Task_Safe_NetDB is\n    --  is too small for the associated data).\n \n    procedure Copy_Service_Entry\n-     (Source_Servent       : Servent;\n-      Target_Servent       : out Servent;\n+     (Source_Servent       : Servent_Access;\n+      Target_Servent       : Servent_Access;\n       Target_Buffer        : System.Address;\n       Target_Buffer_Length : C.int;\n       Result               : out C.int);\n@@ -194,8 +194,8 @@ package body GNAT.Sockets.Thin.Task_Safe_NetDB is\n    ------------------------\n \n    procedure Copy_Service_Entry\n-     (Source_Servent       : Servent;\n-      Target_Servent       : out Servent;\n+     (Source_Servent       : Servent_Access;\n+      Target_Servent       : Servent_Access;\n       Target_Buffer        : System.Address;\n       Target_Buffer_Length : C.int;\n       Result               : out C.int)\n@@ -383,11 +383,14 @@ package body GNAT.Sockets.Thin.Task_Safe_NetDB is\n          goto Unlock_Return;\n       end if;\n \n-      --  Now copy the data to the user-provided buffer\n+      --  Now copy the data to the user-provided buffer. We convert Ret to\n+      --  type Servent_Access using the .all'Unchecked_Access trick to avoid\n+      --  an accessibility check. Ret could be pointing to a nested variable,\n+      --  and we don't want to raise an exception in that case.\n \n       Copy_Service_Entry\n-        (Source_Servent       => SE.all,\n-         Target_Servent       => Ret.all,\n+        (Source_Servent       => SE,\n+         Target_Servent       => Ret.all'Unchecked_Access,\n          Target_Buffer        => Buf,\n          Target_Buffer_Length => Buflen,\n          Result               => Result);\n@@ -420,11 +423,12 @@ package body GNAT.Sockets.Thin.Task_Safe_NetDB is\n          goto Unlock_Return;\n       end if;\n \n-      --  Now copy the data to the user-provided buffer\n+      --  Now copy the data to the user-provided buffer. See Safe_Getservbyname\n+      --  for comment regarding .all'Unchecked_Access.\n \n       Copy_Service_Entry\n-        (Source_Servent       => SE.all,\n-         Target_Servent       => Ret.all,\n+        (Source_Servent       => SE,\n+         Target_Servent       => Ret.all'Unchecked_Access,\n          Target_Buffer        => Buf,\n          Target_Buffer_Length => Buflen,\n          Result               => Result);"}, {"sha": "38ae79598e73e7d23c7ee6f180a288c9fc4d5459", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -207,10 +207,9 @@ package Osint is\n    function To_Host_Dir_Spec\n      (Canonical_Dir : String;\n       Prefix_Style  : Boolean) return String_Access;\n-   --  Convert a canonical syntax directory specification to host syntax.\n-   --  The Prefix_Style flag is currently ignored but should be set to\n-   --  False.\n-   --  Caller must free result\n+   --  Convert a canonical syntax directory specification to host syntax. The\n+   --  Prefix_Style flag is currently ignored but should be set to False.\n+   --  Note that the caller must free result.\n \n    function To_Host_File_Spec\n      (Canonical_File : String) return String_Access;"}, {"sha": "70a5737df2f64fd60a5732a0a554f93255043a46", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -1215,15 +1215,19 @@ package body Prj is\n    ------------\n \n    function Length\n-     (Table : Name_List_Table.Instance; List : Name_List_Index) return Natural\n+     (Table : Name_List_Table.Instance;\n+      List  : Name_List_Index) return Natural\n    is\n       Count : Natural := 0;\n-      Tmp   : Name_List_Index := List;\n+      Tmp   : Name_List_Index;\n+\n    begin\n+      Tmp := List;\n       while Tmp /= No_Name_List loop\n          Count := Count + 1;\n          Tmp := Table.Table (Tmp).Next;\n       end loop;\n+\n       return Count;\n    end Length;\n "}, {"sha": "605c5bd12af7e56291755a1190ceae177afd7d7b", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -317,8 +317,9 @@ package Prj is\n    --  The table for lists of names\n \n    function Length\n-     (Table : Name_List_Table.Instance; List : Name_List_Index) return Natural;\n-   --  Return the number of elements in that list\n+     (Table : Name_List_Table.Instance;\n+      List  : Name_List_Index) return Natural;\n+   --  Return the number of elements in specified list\n \n    type Number_List_Index is new Nat;\n    No_Number_List : constant Number_List_Index := 0;"}, {"sha": "8844d17e0b221ee88e026705dfd4de6ea4b3a51a", "filename": "gcc/ada/s-osinte-hpux-dce.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-osinte-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-osinte-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-hpux-dce.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2007, AdaCore                     --\n+--                     Copyright (C) 1995-2009, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -314,11 +314,7 @@ package body System.OS_Interface is\n \n    begin\n       if pthread_cond_timedwait_base (cond, mutex, abstime) /= 0 then\n-         if errno = EAGAIN then\n-            return ETIMEDOUT;\n-         else\n-            return errno;\n-         end if;\n+         return (if errno = EAGAIN then ETIMEDOUT else errno);\n       else\n          return 0;\n       end if;"}, {"sha": "6229ba0caecd82b9d707dcd8aabb1a0fee6f5ea1", "filename": "gcc/ada/s-osinte-tru64.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-osinte-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-osinte-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-tru64.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -99,11 +99,10 @@ package body System.OS_Interface is\n       --  Stick a guard page right above the Yellow Zone if it exists\n \n       if Teb.all.stack_yellow /= Teb.all.stack_guard then\n-         if Hide then\n-            Res := mprotect (Teb.all.stack_yellow, Get_Page_Size, PROT_ON);\n-         else\n-            Res := mprotect (Teb.all.stack_yellow, Get_Page_Size, PROT_OFF);\n-         end if;\n+         Res :=\n+           mprotect\n+             (Teb.all.stack_yellow, Get_Page_Size,\n+              prot => (if Res then PROT_ON else PROT_OFF));\n       end if;\n    end Hide_Unhide_Yellow_Zone;\n "}, {"sha": "37dda6fad3c9c73c51bd4a90a2d1cbffba2d55aa", "filename": "gcc/ada/s-stausa.adb", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -609,20 +609,18 @@ package body System.Stack_Usage is\n             --  Take either the label size or the number image size for the\n             --  size of the column \"Stack Size\".\n \n-            if Size_Str_Len > Stack_Size_Str'Length then\n-               Max_Stack_Size_Len := Size_Str_Len;\n-            else\n-               Max_Stack_Size_Len := Stack_Size_Str'Length;\n-            end if;\n+            Max_Stack_Size_Len :=\n+              (if Size_Str_Len > Stack_Size_Str'Length\n+               then Size_Str_Len\n+               else Stack_Size_Str'Length);\n \n             --  Take either the label size or the number image size for the\n-            --  size of the column \"Stack Usage\"\n+            --  size of the column \"Stack Usage\".\n \n-            if Result_Str_Len > Actual_Size_Str'Length then\n-               Max_Actual_Use_Len := Result_Str_Len;\n-            else\n-               Max_Actual_Use_Len := Actual_Size_Str'Length;\n-            end if;\n+            Max_Actual_Use_Len :=\n+              (if Result_Str_Len > Actual_Size_Str'Length\n+               then Result_Str_Len\n+               else Actual_Size_Str'Length);\n \n             Output_Result\n               (Analyzer.Result_Id,"}, {"sha": "d4aa675a857721a039ca414707ba6c0611ab2f3e", "filename": "gcc/ada/s-stchop.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-stchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-stchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -149,11 +149,9 @@ package body System.Stack_Checking.Operations is\n          --  If a stack base address has been registered, honor it. Fallback to\n          --  the address of a local object otherwise.\n \n-         if My_Stack.Limit /= System.Null_Address then\n-            My_Stack.Base := My_Stack.Limit;\n-         else\n-            My_Stack.Base := Frame_Address;\n-         end if;\n+         My_Stack.Base :=\n+           (if My_Stack.Limit /= System.Null_Address\n+            then My_Stack.Limit else Frame_Address);\n \n          if Stack_Grows_Down then\n "}, {"sha": "4fca719e25d41776377c3b7f2d5abaefa9217edb", "filename": "gcc/ada/s-strxdr.adb", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-strxdr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-strxdr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-strxdr.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -1263,11 +1263,9 @@ package body System.Stream_Attributes is\n       else\n          --  Test sign and apply two complement notation\n \n-         if Item < 0 then\n-            U := XDR_U'Last xor XDR_U (-(Item + 1));\n-         else\n-            U := XDR_U (Item);\n-         end if;\n+         U := (if Item < 0\n+               then XDR_U'Last xor XDR_U (-(Item + 1))\n+               else XDR_U (Item));\n \n          for N in reverse S'Range loop\n             S (N) := SE (U mod BB);\n@@ -1386,8 +1384,7 @@ package body System.Stream_Attributes is\n             X := Long_Unsigned (Item);\n          end if;\n \n-         --  Compute using machine unsigned\n-         --  rather than long_unsigned.\n+         --  Compute using machine unsigned rather than long_unsigned\n \n          for N in reverse S'Range loop\n \n@@ -1530,8 +1527,7 @@ package body System.Stream_Attributes is\n             X := Long_Long_Unsigned (Item);\n          end if;\n \n-         --  Compute using machine unsigned\n-         --  rather than long_long_unsigned.\n+         --  Compute using machine unsigned rather than long_long_unsigned\n \n          for N in reverse S'Range loop\n \n@@ -1571,8 +1567,7 @@ package body System.Stream_Attributes is\n          S := Long_Long_Unsigned_To_XDR_S_LLU (Item);\n \n       else\n-         --  Compute using machine unsigned\n-         --  rather than long_long_unsigned.\n+         --  Compute using machine unsigned rather than long_long_unsigned\n \n          for N in reverse S'Range loop\n \n@@ -1609,8 +1604,7 @@ package body System.Stream_Attributes is\n          S := Long_Long_Unsigned_To_XDR_S_LU (Long_Long_Unsigned (Item));\n \n       else\n-         --  Compute using machine unsigned\n-         --  rather than long_unsigned.\n+         --  Compute using machine unsigned rather than long_unsigned\n \n          for N in reverse S'Range loop\n \n@@ -1729,11 +1723,9 @@ package body System.Stream_Attributes is\n       else\n          --  Test sign and apply two complement's notation\n \n-         if Item < 0 then\n-            U := XDR_SU'Last xor XDR_SU (-(Item + 1));\n-         else\n-            U := XDR_SU (Item);\n-         end if;\n+         U := (if Item < 0\n+               then XDR_SU'Last xor XDR_SU (-(Item + 1))\n+               else XDR_SU (Item));\n \n          for N in reverse S'Range loop\n             S (N) := SE (U mod BB);\n@@ -1766,11 +1758,9 @@ package body System.Stream_Attributes is\n       else\n          --  Test sign and apply two complement's notation\n \n-         if Item < 0 then\n-            U := XDR_SSU'Last xor XDR_SSU (-(Item + 1));\n-         else\n-            U := XDR_SSU (Item);\n-         end if;\n+         U := (if Item < 0\n+               then XDR_SSU'Last xor XDR_SSU (-(Item + 1))\n+               else XDR_SSU (Item));\n \n          S (1) := SE (U);\n       end if;"}, {"sha": "fba7691e3a2950a723848afd0eb0852f4ddb9867", "filename": "gcc/ada/s-taenca.adb", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taenca.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taenca.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taenca.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -165,13 +165,8 @@ package body System.Tasking.Entry_Calls is\n            and then Entry_Call.State = Now_Abortable\n          then\n             Queuing.Dequeue_Call (Entry_Call);\n-\n-            if Entry_Call.Cancellation_Attempted then\n-               Entry_Call.State := Cancelled;\n-            else\n-               Entry_Call.State := Done;\n-            end if;\n-\n+            Entry_Call.State :=\n+              (if Entry_Call.Cancellation_Attempted then Cancelled else Done);\n             Unlock_And_Update_Server (Self_ID, Entry_Call);\n \n          else"}, {"sha": "ebc2f9ddc0c94dfb3e3fa2bc31beb4d6be2630cb", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 29, "deletions": 46, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -411,16 +411,14 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Reason);\n \n       Result : Interfaces.C.int;\n+\n    begin\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n \n       --  EINTR is not considered a failure\n \n@@ -450,32 +448,24 @@ package body System.Task_Primitives.Operations is\n       Timedout := True;\n       Yielded := False;\n \n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n \n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock'Access,\n-                    Request'Access);\n-\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -515,11 +505,10 @@ package body System.Task_Primitives.Operations is\n \n       Write_Lock (Self_ID);\n \n-      if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Time + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n@@ -528,19 +517,13 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock'Access,\n-                    Request'Access);\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             exit when Abs_Time <= Monotonic_Clock;\n "}, {"sha": "e73555fb30426618394d96857044ec1a1884fc36", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -430,15 +430,12 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n \n       --  EINTR is not considered a failure\n \n@@ -469,30 +466,24 @@ package body System.Task_Primitives.Operations is\n       Timedout := True;\n       Yielded  := False;\n \n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n \n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                    Request'Access);\n-\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n@@ -530,11 +521,10 @@ package body System.Task_Primitives.Operations is\n \n       Write_Lock (Self_ID);\n \n-      if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Time + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n@@ -543,17 +533,13 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n-            else\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Self_ID.Common.LL.L'Access,\n-                            Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;"}, {"sha": "5680fa22c76104150dc7694835acff1f86ab64d4", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -426,15 +426,12 @@ package body System.Task_Primitives.Operations is\n    begin\n       pragma Assert (Self_ID = Self);\n \n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n \n       --  EINTR is not considered a failure\n \n@@ -469,32 +466,24 @@ package body System.Task_Primitives.Operations is\n       Timedout := True;\n       Yielded := False;\n \n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n \n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock'Access,\n-                    Request'Access);\n-\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n@@ -539,11 +528,10 @@ package body System.Task_Primitives.Operations is\n \n       Write_Lock (Self_ID);\n \n-      if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Time + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n@@ -552,17 +540,13 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n-            else\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Self_ID.Common.LL.L'Access,\n-                            Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n@@ -1104,6 +1088,7 @@ package body System.Task_Primitives.Operations is\n          SSL.Abort_Undefer.all;\n \n          raise Program_Error;\n+\n       else\n          --  Suspend the task if the state is False. Otherwise, the task\n          --  continues its execution, and the state of the suspension object\n@@ -1118,8 +1103,7 @@ package body System.Task_Primitives.Operations is\n                --  Loop in case pthread_cond_wait returns earlier than expected\n                --  (e.g. in case of EINTR caused by a signal). This should not\n                --  happen with the current Linux implementation of pthread, but\n-               --  POSIX does not guarantee it, so this may change in the\n-               --  future.\n+               --  POSIX does not guarantee it so this may change in future.\n \n                Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n                pragma Assert (Result = 0 or else Result = EINTR);"}, {"sha": "84c0eee4ffeeb7083eea6cac5e4ac384a0fbfe2c", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -244,12 +244,9 @@ package body System.Task_Primitives.Operations is\n          Guard_Page_Address :=\n            Stack_Base - (Stack_Base mod Get_Page_Size) + Get_Page_Size;\n \n-         if On then\n-            Res := mprotect (Guard_Page_Address, Get_Page_Size, PROT_ON);\n-         else\n-            Res := mprotect (Guard_Page_Address, Get_Page_Size, PROT_OFF);\n-         end if;\n-\n+         Res :=\n+           mprotect (Guard_Page_Address, Get_Page_Size,\n+                     prot => (if ON then PROT_ON else PROT_OFF));\n          pragma Assert (Res = 0);\n       end if;\n    end Stack_Guard;\n@@ -491,15 +488,12 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n \n       --  EINTR is not considered a failure\n \n@@ -551,27 +545,19 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Abs_Time > Check_Time then\n-         if Relative_Timed_Wait then\n-            Request := To_Timespec (Rel_Time);\n-         else\n-            Request := To_Timespec (Abs_Time);\n-         end if;\n+         Request :=\n+           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n \n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                    Request'Access);\n-\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n@@ -633,28 +619,20 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Abs_Time > Check_Time then\n-         if Relative_Timed_Wait then\n-            Request := To_Timespec (Rel_Time);\n-         else\n-            Request := To_Timespec (Abs_Time);\n-         end if;\n-\n+         Request :=\n+           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Single_RTS_Lock'Access,\n-                            Request'Access);\n-            else\n-               Result := pthread_cond_timedwait\n-                           (Self_ID.Common.LL.CV'Access,\n-                            Self_ID.Common.LL.L'Access,\n-                            Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;"}, {"sha": "5250e0e2c1568d2cb2f87787c8efba0866b8d3b9", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -1226,15 +1226,13 @@ package body System.Task_Primitives.Operations is\n       Timedout := True;\n       Yielded := False;\n \n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n-\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n@@ -1294,11 +1292,10 @@ package body System.Task_Primitives.Operations is\n \n       Write_Lock (Self_ID);\n \n-      if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Time + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);"}, {"sha": "cd23f16d9caf71ce6b84b9f9e76396e172736029", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -440,15 +440,12 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n \n       --  EINTR is not considered a failure\n \n@@ -482,32 +479,24 @@ package body System.Task_Primitives.Operations is\n       Timedout := True;\n       Yielded := False;\n \n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n \n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock'Access,\n-                    Request'Access);\n-\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n@@ -550,11 +539,10 @@ package body System.Task_Primitives.Operations is\n \n       Write_Lock (Self_ID);\n \n-      if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-      end if;\n+      Abs_Time :=\n+        (if Mode = Relative\n+         then Time + Check_Time\n+         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n@@ -563,19 +551,13 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock'Access,\n-                    Request'Access);\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;"}, {"sha": "582f88bcbdea7a67ed159c7d20fb0f666701176d", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -408,15 +408,12 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Result :=\n+        pthread_cond_wait\n+          (cond  => Self_ID.Common.LL.CV'Access,\n+           mutex => (if Single_Lock\n+                     then Single_RTS_Lock'Access\n+                     else Self_ID.Common.LL.L'Access));\n \n       --  EINTR is not considered a failure\n \n@@ -540,19 +537,13 @@ package body System.Task_Primitives.Operations is\n                   exit;\n                end if;\n \n-               if Single_Lock then\n-                  Result :=\n-                    pthread_cond_wait\n-                      (Self_ID.Common.LL.CV'Access,\n-                       Single_RTS_Lock'Access);\n-                  pragma Assert (Result = 0);\n-               else\n-                  Result :=\n-                    pthread_cond_wait\n-                      (Self_ID.Common.LL.CV'Access,\n-                       Self_ID.Common.LL.L'Access);\n-                  pragma Assert (Result = 0);\n-               end if;\n+               Result :=\n+                 pthread_cond_wait\n+                   (cond  => Self_ID.Common.LL.CV'Access,\n+                    mutex => (if Single_Lock\n+                              then Single_RTS_Lock'Access\n+                              else Self_ID.Common.LL.L'Access));\n+               pragma Assert (Result = 0);\n \n                Yielded := True;\n "}, {"sha": "4cde338bfd3c85649e124d310d99e0906cd1e501", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 34, "deletions": 44, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/196b199369f3e1f24c391891fcf9ab90de2a2739/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=196b199369f3e1f24c391891fcf9ab90de2a2739", "patch": "@@ -430,12 +430,10 @@ package body System.Task_Primitives.Operations is\n \n       --  Release the mutex before sleeping\n \n-      if Single_Lock then\n-         Result := semGive (Single_RTS_Lock.Mutex);\n-      else\n-         Result := semGive (Self_ID.Common.LL.L.Mutex);\n-      end if;\n-\n+      Result :=\n+        semGive (if Single_Lock\n+                 then Single_RTS_Lock.Mutex\n+                 else Self_ID.Common.LL.L.Mutex);\n       pragma Assert (Result = 0);\n \n       --  Perform a blocking operation to take the CV semaphore. Note that a\n@@ -448,12 +446,10 @@ package body System.Task_Primitives.Operations is\n \n       --  Take the mutex back\n \n-      if Single_Lock then\n-         Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n-      else\n-         Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n-      end if;\n-\n+      Result :=\n+        semTake ((if Single_Lock\n+                  then Single_RTS_Lock.Mutex\n+                  else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n       pragma Assert (Result = 0);\n    end Sleep;\n \n@@ -506,12 +502,10 @@ package body System.Task_Primitives.Operations is\n          loop\n             --  Release the mutex before sleeping\n \n-            if Single_Lock then\n-               Result := semGive (Single_RTS_Lock.Mutex);\n-            else\n-               Result := semGive (Self_ID.Common.LL.L.Mutex);\n-            end if;\n-\n+            Result :=\n+              semGive (if Single_Lock\n+                       then Single_RTS_Lock.Mutex\n+                       else Self_ID.Common.LL.L.Mutex);\n             pragma Assert (Result = 0);\n \n             --  Perform a blocking operation to take the CV semaphore. Note\n@@ -551,12 +545,10 @@ package body System.Task_Primitives.Operations is\n \n             --  Take the mutex back\n \n-            if Single_Lock then\n-               Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n-            else\n-               Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n-            end if;\n-\n+            Result :=\n+              semTake ((if Single_Lock\n+                        then Single_RTS_Lock.Mutex\n+                        else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n             pragma Assert (Result = 0);\n \n             exit when Timedout or Wakeup;\n@@ -623,11 +615,10 @@ package body System.Task_Primitives.Operations is\n \n          --  Modifying State, locking the TCB\n \n-         if Single_Lock then\n-            Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n-         else\n-            Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n-         end if;\n+         Result :=\n+           semTake ((if Single_Lock\n+                     then Single_RTS_Lock.Mutex\n+                     else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n \n          pragma Assert (Result = 0);\n \n@@ -639,11 +630,10 @@ package body System.Task_Primitives.Operations is\n \n             --  Release the TCB before sleeping\n \n-            if Single_Lock then\n-               Result := semGive (Single_RTS_Lock.Mutex);\n-            else\n-               Result := semGive (Self_ID.Common.LL.L.Mutex);\n-            end if;\n+            Result :=\n+              semGive (if Single_Lock\n+                       then Single_RTS_Lock.Mutex\n+                       else Self_ID.Common.LL.L.Mutex);\n             pragma Assert (Result = 0);\n \n             exit when Aborted;\n@@ -670,11 +660,11 @@ package body System.Task_Primitives.Operations is\n             --  Take back the lock after having slept, to protect further\n             --  access to Self_ID.\n \n-            if Single_Lock then\n-               Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n-            else\n-               Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n-            end if;\n+            Result :=\n+              semTake\n+                ((if Single_Lock\n+                  then Single_RTS_Lock.Mutex\n+                  else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n \n             pragma Assert (Result = 0);\n \n@@ -683,11 +673,11 @@ package body System.Task_Primitives.Operations is\n \n          Self_ID.Common.State := Runnable;\n \n-         if Single_Lock then\n-            Result := semGive (Single_RTS_Lock.Mutex);\n-         else\n-            Result := semGive (Self_ID.Common.LL.L.Mutex);\n-         end if;\n+         Result :=\n+           semGive\n+             (if Single_Lock\n+              then Single_RTS_Lock.Mutex\n+              else Self_ID.Common.LL.L.Mutex);\n \n       else\n          taskDelay (0);"}]}