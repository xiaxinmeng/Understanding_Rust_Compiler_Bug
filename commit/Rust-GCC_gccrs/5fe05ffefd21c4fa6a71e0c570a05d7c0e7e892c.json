{"sha": "5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "node_id": "C_kwDOANBUbNoAKDVmZTA1ZmZlZmQyMWM0ZmE2YTcxZTBjNTcwYTA1ZDdjMGU3ZTg5MmM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-01T07:30:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-04-01T07:30:31Z"}, "message": "range-op-float: Further comparison fixes\n\nOn Fri, Mar 31, 2023 at 09:57:54AM +0200, Jakub Jelinek via Gcc-patches wrote:\n> and so if maybe_isnan, they always return [0, 1].  Now, thinking about it,\n> this is unnecessary pessimization, for the case where the ... block\n> returns range_false (type) we actually could do it also if maybe_isnan (op1,\n> op2), because if one or both operands are NAN, the comparison will be false,\n> and if neither is NAN, the comparison will be also false.  Will fix\n> incrementally today.\n\nHere it is.\n1) the foperator_{,not_}equal::fold_range cases\n   - we have correctly first a case handling known_isnan on either operand,\n     return there range_false (type) - EQ, resp. range_true (type) - NE\n   - next we handle the singleton cases, maybe_isnan + singleton isn't\n     singleton, so these are ok\n   - there is a missing case (not handled in this patch) where both operands\n     are known to be zeros, but not singleton zeros\n   - there is some !maybe_isnan (op1, op2) handling which tries to prove\n     when the operands are certainly not equal and results in\n     range_false (type) - EQ, resp. range_true (type) - NE\n   - otherwise range_true_and_false (type)\n   Now, I think (and this patch implements it) that the !maybe_isnan (op1, op2)\n   check is unnecessary.  If we prove that when ignoring maybe NANs, the\n   ranges don't intersect and so the comparison is always false for EQ or\n   always true for NE, if NANs can appear, it doesn't change anything on\n   that either, for EQ if NAN appears, the result is false like what we\n   proved for the finite ranges, for NE if NAN appears, the result is true\n   like what we proved for the finite ranges\n2) foperator_{lt,le,gt,ge}::fold_range cases\n   - these have correctly known_isnan on either operand first and return\n     there range_false (type)\n   - then !maybe_isnan (op1, op2) condition guarded checks\n   - finally range_true_and_false (type) - so do that for\n     maybe_isnan (op1, op2)\n   Here in the !maybe_isnan (op1, op2) guarded code we have some condition\n   which results in range_true (type), another condition which results in\n   range_false (type) and otherwise range_true_and_false (type).\n   Now, the condition which results in range_false (type) can be IMHO done\n   also for the maybe_isnan (op1, op2) cases, because it is [0, 0]\n   if both operands are finite or [0, 0] if either operand is NAN.\n3) finally, LTGT_EXPR wasn't handled at all.  LTGT_EXPR is the inverse\n   comparision to UNEQ_EXPR, I believe both raise exceptions only if\n   either operand is sNaN, UNEQ_EXPR is true if both operands are\n   either equal or either of the operands is NAN, while LTGT_EXPR is\n   true if the operands compare either smaller or larger and is false if\n   either of the operands is NAN.\n\n2023-04-01  Jakub Jelinek  <jakub@redhat.com>\n\n\t* range-op-float.cc (foperator_equal::fold_range): Perform the\n\tnon-singleton handling regardless of maybe_isnan (op1, op2).\n\t(foperator_not_equal::fold_range): Likewise.\n\t(foperator_lt::fold_range, foperator_le::fold_range,\n\tfoperator_gt::fold_range, foperator_ge::fold_range): Perform the\n\treal_* comparison check which results in range_false (type)\n\teven if maybe_isnan (op1, op2).  Simplify.\n\t(foperator_ltgt): New class.\n\t(fop_ltgt): New variable.\n\t(floating_op_table::floating_op_table): Handle LTGT_EXPR using\n\tfop_ltgt.\n\n\t* gcc.dg/torture/inf-compare-1.c: Add dg-additional-options\n\t-fno-tree-dominator-opts -fno-tree-vrp.\n\t* gcc.dg/torture/inf-compare-1-float.c: Likewise.\n\t* gcc.dg/torture/inf-compare-2.c: Likewise.\n\t* gcc.dg/torture/inf-compare-2-float.c: Likewise.", "tree": {"sha": "2d1ce5d52b2d2ecf734add0f66faad733b0f0e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d1ce5d52b2d2ecf734add0f66faad733b0f0e40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d3bc53b177037699f7f8dda3a3d17e647c459d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d3bc53b177037699f7f8dda3a3d17e647c459d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d3bc53b177037699f7f8dda3a3d17e647c459d"}], "stats": {"total": 158, "additions": 112, "deletions": 46}, "files": [{"sha": "0e0fd92ff2e94079ad275c9b1bd8d98a8e20e9fe", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 108, "deletions": 46, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "patch": "@@ -616,7 +616,7 @@ foperator_equal::fold_range (irange &r, tree type,\n       else\n \tr = range_false (type);\n     }\n-  else if (!maybe_isnan (op1, op2))\n+  else\n     {\n       // If ranges do not intersect, we know the range is not equal,\n       // otherwise we don't know anything for sure.\n@@ -638,8 +638,6 @@ foperator_equal::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else\n-    r = range_true_and_false (type);\n   return true;\n }\n \n@@ -734,7 +732,7 @@ foperator_not_equal::fold_range (irange &r, tree type,\n       else\n \tr = range_true (type);\n     }\n-  else if (!maybe_isnan (op1, op2))\n+  else\n     {\n       // If ranges do not intersect, we know the range is not equal,\n       // otherwise we don't know anything for sure.\n@@ -756,8 +754,6 @@ foperator_not_equal::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else\n-    r = range_true_and_false (type);\n   return true;\n }\n \n@@ -839,17 +835,13 @@ foperator_lt::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LT))\n     return true;\n \n-  if (op1.known_isnan () || op2.known_isnan ())\n+  if (op1.known_isnan ()\n+      || op2.known_isnan ()\n+      || !real_less (&op1.lower_bound (), &op2.upper_bound ()))\n     r = range_false (type);\n-  else if (!maybe_isnan (op1, op2))\n-    {\n-      if (real_less (&op1.upper_bound (), &op2.lower_bound ()))\n-\tr = range_true (type);\n-      else if (!real_less (&op1.lower_bound (), &op2.upper_bound ()))\n-\tr = range_false (type);\n-      else\n-\tr = range_true_and_false (type);\n-    }\n+  else if (!maybe_isnan (op1, op2)\n+\t   && real_less (&op1.upper_bound (), &op2.lower_bound ()))\n+    r = range_true (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -959,17 +951,13 @@ foperator_le::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_LE))\n     return true;\n \n-  if (op1.known_isnan () || op2.known_isnan ())\n+  if (op1.known_isnan ()\n+      || op2.known_isnan ()\n+      || !real_compare (LE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n     r = range_false (type);\n-  else if (!maybe_isnan (op1, op2))\n-    {\n-      if (real_compare (LE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n-\tr = range_true (type);\n-      else if (!real_compare (LE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n-\tr = range_false (type);\n-      else\n-\tr = range_true_and_false (type);\n-    }\n+  else if (!maybe_isnan (op1, op2)\n+\t   && real_compare (LE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n+    r = range_true (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -1073,17 +1061,13 @@ foperator_gt::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GT))\n     return true;\n \n-  if (op1.known_isnan () || op2.known_isnan ())\n+  if (op1.known_isnan ()\n+      || op2.known_isnan ()\n+      || !real_compare (GT_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n     r = range_false (type);\n-  else if (!maybe_isnan (op1, op2))\n-    {\n-      if (real_compare (GT_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n-\tr = range_true (type);\n-      else if (!real_compare (GT_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n-\tr = range_false (type);\n-      else\n-\tr = range_true_and_false (type);\n-    }\n+  else if (!maybe_isnan (op1, op2)\n+\t   && real_compare (GT_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n+    r = range_true (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -1197,17 +1181,13 @@ foperator_ge::fold_range (irange &r, tree type,\n   if (frelop_early_resolve (r, type, op1, op2, rel, VREL_GE))\n     return true;\n \n-  if (op1.known_isnan () || op2.known_isnan ())\n+  if (op1.known_isnan ()\n+      || op2.known_isnan ()\n+      || !real_compare (GE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n     r = range_false (type);\n-  else if (!maybe_isnan (op1, op2))\n-    {\n-      if (real_compare (GE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n-\tr = range_true (type);\n-      else if (!real_compare (GE_EXPR, &op1.upper_bound (), &op2.lower_bound ()))\n-\tr = range_false (type);\n-      else\n-\tr = range_true_and_false (type);\n-    }\n+  else if (!maybe_isnan (op1, op2)\n+\t   && real_compare (GE_EXPR, &op1.lower_bound (), &op2.upper_bound ()))\n+    r = range_true (type);\n   else\n     r = range_true_and_false (type);\n   return true;\n@@ -2092,6 +2072,87 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n   return true;\n }\n \n+class foperator_ltgt : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+  using range_operator_float::op1_range;\n+  using range_operator_float::op2_range;\n+public:\n+  bool fold_range (irange &r, tree type,\n+\t\t   const frange &op1, const frange &op2,\n+\t\t   relation_trio rel = TRIO_VARYING) const final override\n+  {\n+    if (op1.known_isnan () || op2.known_isnan ())\n+      {\n+\tr = range_false (type);\n+\treturn true;\n+      }\n+    frange op1_no_nan = op1;\n+    frange op2_no_nan = op2;\n+    if (op1.maybe_isnan ())\n+      op1_no_nan.clear_nan ();\n+    if (op2.maybe_isnan ())\n+      op2_no_nan.clear_nan ();\n+    if (!fop_not_equal.fold_range (r, type, op1_no_nan, op2_no_nan, rel))\n+      return false;\n+    // The result is the same as the ordered version when the\n+    // comparison is true or when the operands cannot be NANs.\n+    if (!maybe_isnan (op1, op2) || r == range_false (type))\n+      return true;\n+    else\n+      {\n+\tr = range_true_and_false (type);\n+\treturn true;\n+      }\n+  }\n+  bool op1_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op2,\n+\t\t  relation_trio = TRIO_VARYING) const final override;\n+  bool op2_range (frange &r, tree type,\n+\t\t  const irange &lhs, const frange &op1,\n+\t\t  relation_trio rel = TRIO_VARYING) const final override\n+  {\n+    return op1_range (r, type, lhs, op1, rel.swap_op1_op2 ());\n+  }\n+} fop_ltgt;\n+\n+bool\n+foperator_ltgt::op1_range (frange &r, tree type,\n+\t\t\t   const irange &lhs,\n+\t\t\t   const frange &op2,\n+\t\t\t   relation_trio) const\n+{\n+  switch (get_bool_state (r, lhs, type))\n+    {\n+    case BRS_TRUE:\n+      // A true LTGT means both operands are !NAN, so it's\n+      // impossible for op2 to be a NAN.\n+      if (op2.known_isnan ())\n+\tr.set_undefined ();\n+      else\n+\t{\n+\t  // The true side indicates !NAN and not equal.  We can at least\n+\t  // represent !NAN.\n+\t  r.set_varying (type);\n+\t  r.clear_nan ();\n+\t}\n+      break;\n+\n+    case BRS_FALSE:\n+      // If it's false, the result is the same as OP2 plus a NAN.\n+      r = op2;\n+      // Add both zeros if there's the possibility of zero equality.\n+      frange_add_zeros (r, type);\n+      // Add the possibility of a NAN.\n+      r.update_nan ();\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return true;\n+}\n+\n // Final tweaks for float binary op op1_range/op2_range.\n // Return TRUE if the operation is performed and a valid range is available.\n \n@@ -2767,6 +2828,7 @@ floating_op_table::floating_op_table ()\n   set (UNEQ_EXPR, fop_unordered_equal);\n   set (ORDERED_EXPR, fop_ordered);\n   set (UNORDERED_EXPR, fop_unordered);\n+  set (LTGT_EXPR, fop_ltgt);\n \n   set (ABS_EXPR, fop_abs);\n   set (NEGATE_EXPR, fop_negate);"}, {"sha": "c53dcfe672c7a80902f37bfb09e2f9141cf45f8a", "filename": "gcc/testsuite/gcc.dg/torture/inf-compare-1-float.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-1-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-1-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-1-float.c?ref=5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "patch": "@@ -3,6 +3,7 @@\n /* { dg-add-options ieee } */\n /* { dg-require-effective-target fenv_exceptions } */\n /* { dg-skip-if \"fenv\" { powerpc-ibm-aix* } } */\n+/* { dg-additional-options \"-fno-tree-dominator-opts -fno-tree-vrp\" } */\n \n #include <fenv.h>\n "}, {"sha": "40bbac46f7ee4249324dba3c8aaf1743580cf439", "filename": "gcc/testsuite/gcc.dg/torture/inf-compare-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-1.c?ref=5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "patch": "@@ -3,6 +3,7 @@\n /* { dg-add-options ieee } */\n /* { dg-require-effective-target fenv_exceptions_double } */\n /* { dg-skip-if \"fenv\" { powerpc-ibm-aix* } } */\n+/* { dg-additional-options \"-fno-tree-dominator-opts -fno-tree-vrp\" } */\n \n #include <fenv.h>\n "}, {"sha": "f932cc919110233d29aa05c93493569958f3d74a", "filename": "gcc/testsuite/gcc.dg/torture/inf-compare-2-float.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-2-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-2-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-2-float.c?ref=5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "patch": "@@ -3,6 +3,7 @@\n /* { dg-add-options ieee } */\n /* { dg-require-effective-target fenv_exceptions } */\n /* { dg-skip-if \"fenv\" { powerpc-ibm-aix* } } */\n+/* { dg-additional-options \"-fno-tree-dominator-opts -fno-tree-vrp\" } */\n \n #include <fenv.h>\n "}, {"sha": "f6a1c00b6239164bb2ad23858ae2c5a81fe1784c", "filename": "gcc/testsuite/gcc.dg/torture/inf-compare-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Finf-compare-2.c?ref=5fe05ffefd21c4fa6a71e0c570a05d7c0e7e892c", "patch": "@@ -3,6 +3,7 @@\n /* { dg-add-options ieee } */\n /* { dg-require-effective-target fenv_exceptions_double } */\n /* { dg-skip-if \"fenv\" { powerpc-ibm-aix* } } */\n+/* { dg-additional-options \"-fno-tree-dominator-opts -fno-tree-vrp\" } */\n \n #include <fenv.h>\n "}]}