{"sha": "d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmNDhjN2M2MmQzZDhjZjg5ODJjYjI5YTgxMjhlM2I4MTMzNWQyNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-03-27T12:51:43Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-03-27T12:51:43Z"}, "message": "re PR fortran/88247 (ICE in get_array_ctor_var_strlen, at fortran/trans-array.c:2068)\n\n2019-03-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/88247\n\t* expr.c (is_subref_array): Permit substrings to be detected\n\tas subref arrays.\n\t* trans-array.c (get_array_ctor_var_strlen): Obtain the length\n\tof deferred length strings. Handle substrings with a NULL end\n\texpression.\n\t(trans_array_constructor): Remove an unnecessary blank line.\n\t(gfc_conv_scalarized_array_ref): Skip to label 'done' if 'decl'\n\tis a pointer array.\n\t(get_array_charlen): If the expression is an array, convert the\n\tfirst element of the constructor and use its string length. Get\n\ta new charlen if necessary.\n\t(gfc_conv_expr_descriptor): Call 'get_array_charlen' for array\n\tconstructor expressions. If the ss_info string length is\n\tavailable, use that to set the span of character arrays.\n\t* trans-expr.c (gfc_get_expr_charlen): Handle substrings\n\t* trans-stmt.c (trans_associate_var): Set the pointer array\n\tflag for variable targets and constant array constructors. Take\n\tcare not to reset the string length or the span in the case of\n\texpressions that are not converted as direct by reference.\n\n2019-03-27  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/88247\n\t* gfortran.dg/associate_47.f90: New test.\n\nFrom-SVN: r269962", "tree": {"sha": "76bbc93eb20c9c454b06f631c411d2415a8c5992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76bbc93eb20c9c454b06f631c411d2415a8c5992"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/comments", "author": null, "committer": null, "parents": [{"sha": "6461f211e09415edd95315f4f9ff843f4f1d8eff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6461f211e09415edd95315f4f9ff843f4f1d8eff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6461f211e09415edd95315f4f9ff843f4f1d8eff"}], "stats": {"total": 184, "additions": 173, "deletions": 11}, "files": [{"sha": "e1fdb93f3d061baa56045915aa0408771e36cde1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -1,3 +1,26 @@\n+2019-03-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/88247\n+\t* expr.c (is_subref_array): Permit substrings to be detected\n+\tas subref arrays.\n+\t* trans-array.c (get_array_ctor_var_strlen): Obtain the length\n+\tof deferred length strings. Handle substrings with a NULL end\n+\texpression.\n+\t(trans_array_constructor): Remove an unnecessary blank line.\n+\t(gfc_conv_scalarized_array_ref): Skip to label 'done' if 'decl'\n+\tis a pointer array.\n+\t(get_array_charlen): If the expression is an array, convert the\n+\tfirst element of the constructor and use its string length. Get\n+\ta new charlen if necessary.\n+\t(gfc_conv_expr_descriptor): Call 'get_array_charlen' for array\n+\tconstructor expressions. If the ss_info string length is\n+\tavailable, use that to set the span of character arrays.\n+\t* trans-expr.c (gfc_get_expr_charlen): Handle substrings\n+\t* trans-stmt.c (trans_associate_var): Set the pointer array\n+\tflag for variable targets and constant array constructors. Take\n+\tcare not to reset the string length or the span in the case of\n+\texpressions that are not converted as direct by reference.\n+\n 2019-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* intrinsic.texi (MINLOC): Fix typo in BACK argument documentation."}, {"sha": "f54affae18dc67d5b20b1a6dfb2b026a1a7c5b03", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -1080,8 +1080,10 @@ is_subref_array (gfc_expr * e)\n   for (ref = e->ref; ref; ref = ref->next)\n     {\n       /* If we haven't seen the array reference and this is an intrinsic,\n-\t what follows cannot be a subreference array.  */\n+\t what follows cannot be a subreference array, unless there is a\n+\t substring reference.  */\n       if (!seen_array && ref->type == REF_COMPONENT\n+\t  && ref->u.c.component->ts.type != BT_CHARACTER\n \t  && ref->u.c.component->ts.type != BT_CLASS\n \t  && !gfc_bt_struct (ref->u.c.component->ts.type))\n \treturn false;"}, {"sha": "2bc24d957755bc0a006658440c35776f41be2cda", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -2099,6 +2099,8 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n \t{\n \tcase REF_ARRAY:\n \t  /* Array references don't change the string length.  */\n+\t  if (ts->deferred)\n+\t    get_array_ctor_all_strlen (block, expr, len);\n \t  break;\n \n \tcase REF_COMPONENT:\n@@ -2107,7 +2109,8 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n \t  break;\n \n \tcase REF_SUBSTRING:\n-\t  if (ref->u.ss.start->expr_type != EXPR_CONSTANT\n+\t  if (ref->u.ss.end == NULL\n+\t      || ref->u.ss.start->expr_type != EXPR_CONSTANT\n \t      || ref->u.ss.end->expr_type != EXPR_CONSTANT)\n \t    {\n \t      /* Note that this might evaluate expr.  */\n@@ -2507,7 +2510,6 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t\t\t       ss_info->string_length);\n \t  ss_info->string_length = gfc_evaluate_now (ss_info->string_length,\n \t\t\t\t\t\t     &length_se.pre);\n-\n \t  gfc_add_block_to_block (&outer_loop->pre, &length_se.pre);\n \t  gfc_add_block_to_block (&outer_loop->post, &length_se.post);\n \t}\n@@ -3470,6 +3472,9 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t\t\t\t\t || expr->expr_type == EXPR_FUNCTION))))\n     decl = expr->symtree->n.sym->backend_decl;\n \n+  if (decl && GFC_DECL_PTR_ARRAY_P (decl))\n+    goto done;\n+\n   /* A pointer array component can be detected from its field decl. Fix\n      the descriptor, mark the resulting variable decl and pass it to\n      gfc_build_array_ref.  */\n@@ -3486,6 +3491,7 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \tdecl = info->descriptor;\n     }\n \n+done:\n   se->expr = gfc_build_array_ref (base, index, decl);\n }\n \n@@ -6929,6 +6935,7 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n   gfc_formal_arglist *formal;\n   gfc_actual_arglist *arg;\n   gfc_se tse;\n+  gfc_expr *e;\n \n   if (expr->ts.u.cl->length\n \t&& gfc_is_constant_expr (expr->ts.u.cl->length))\n@@ -6940,14 +6947,42 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n \n   switch (expr->expr_type)\n     {\n+    case EXPR_ARRAY:\n+\n+      /* This is somewhat brutal. The expression for the first\n+\t element of the array is evaluated and assigned to a\n+\t new string length for the original expression.  */\n+      e = gfc_constructor_first (expr->value.constructor)->expr;\n+\n+      gfc_init_se (&tse, NULL);\n+      if (e->rank)\n+\tgfc_conv_expr_descriptor (&tse, e);\n+      else\n+\tgfc_conv_expr (&tse, e);\n+\n+      gfc_add_block_to_block (&se->pre, &tse.pre);\n+      gfc_add_block_to_block (&se->post, &tse.post);\n+\n+      if (!expr->ts.u.cl->backend_decl || !VAR_P (expr->ts.u.cl->backend_decl))\n+\t{\n+\t  expr->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n+\t  expr->ts.u.cl->backend_decl =\n+\t\t\tgfc_create_var (gfc_charlen_type_node, \"sln\");\n+\t}\n+\n+      gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n+\t\t      tse.string_length);\n+\n+      return;\n+\n     case EXPR_OP:\n       get_array_charlen (expr->value.op.op1, se);\n \n       /* For parentheses the expression ts.u.cl is identical.  */\n       if (expr->value.op.op == INTRINSIC_PARENTHESES)\n \treturn;\n \n-     expr->ts.u.cl->backend_decl =\n+      expr->ts.u.cl->backend_decl =\n \t\tgfc_create_var (gfc_charlen_type_node, \"sln\");\n \n       if (expr->value.op.op2)\n@@ -7325,7 +7360,8 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n   if (need_tmp)\n     {\n-      if (expr->ts.type == BT_CHARACTER && !expr->ts.u.cl->backend_decl)\n+      if (expr->ts.type == BT_CHARACTER\n+\t  && (!expr->ts.u.cl->backend_decl || expr->expr_type == EXPR_ARRAY))\n \tget_array_charlen (expr, se);\n \n       /* Tell the scalarizer to make a temporary.  */\n@@ -7447,7 +7483,17 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n       /* Set the string_length for a character array.  */\n       if (expr->ts.type == BT_CHARACTER)\n-\tse->string_length =  gfc_get_expr_charlen (expr);\n+\t{\n+\t  se->string_length =  gfc_get_expr_charlen (expr);\n+\t  if (VAR_P (se->string_length)\n+\t      && expr->ts.u.cl->backend_decl == se->string_length)\n+\t    tmp = ss_info->string_length;\n+\t  else\n+\t    tmp = se->string_length;\n+\n+\t  if (expr->ts.deferred)\n+\t    gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl, tmp);\n+\t}\n \n       /* If we have an array section or are assigning make sure that\n \t the lower bound is 1.  References to the full\n@@ -7509,7 +7555,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t}\n \n       /* Set the span field.  */\n-      tmp = gfc_get_array_span (desc, expr);\n+      if (expr->ts.type == BT_CHARACTER && ss_info->string_length)\n+\ttmp = ss_info->string_length;\n+      else\n+\ttmp = gfc_get_array_span (desc, expr);\n       if (tmp != NULL_TREE)\n \tgfc_conv_descriptor_span_set (&loop.pre, parm, tmp);\n "}, {"sha": "19fb16feebe8d9bba6ed8e5781e1c733c52d4f81", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -1824,6 +1824,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n {\n   gfc_ref *r;\n   tree length;\n+  gfc_se se;\n \n   gcc_assert (e->expr_type == EXPR_VARIABLE\n \t      && e->ts.type == BT_CHARACTER);\n@@ -1859,9 +1860,20 @@ gfc_get_expr_charlen (gfc_expr *e)\n \t  /* Do nothing.  */\n \t  break;\n \n+\tcase REF_SUBSTRING:\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, r->u.ss.start, gfc_charlen_type_node);\n+\t  length = se.expr;\n+\t  gfc_conv_expr_type (&se, r->u.ss.end, gfc_charlen_type_node);\n+\t  length = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t    gfc_charlen_type_node,\n+\t\t\t\t    se.expr, length);\n+\t  length = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t    gfc_charlen_type_node, length,\n+\t\t\t\t    gfc_index_one_node);\n+\t  break;\n+\n \tdefault:\n-\t  /* We should never got substring references here.  These will be\n-\t     broken down by the scalarizer.  */\n \t  gcc_unreachable ();\n \t  break;\n \t}"}, {"sha": "b9966ed93184f41828203ae813b2901641b4b436", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -1707,17 +1707,19 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       /* If association is to an expression, evaluate it and create temporary.\n \t Otherwise, get descriptor of target for pointer assignment.  */\n       gfc_init_se (&se, NULL);\n+\n       if (sym->assoc->variable || cst_array_ctor)\n \t{\n \t  se.direct_byref = 1;\n \t  se.use_offset = 1;\n \t  se.expr = desc;\n+\t  GFC_DECL_PTR_ARRAY_P (sym->backend_decl) = 1;\n \t}\n \n       gfc_conv_expr_descriptor (&se, e);\n \n       if (sym->ts.type == BT_CHARACTER\n-\t  && sym->ts.deferred\n+\t  && !se.direct_byref && sym->ts.deferred\n \t  && !sym->attr.select_type_temporary\n \t  && VAR_P (sym->ts.u.cl->backend_decl)\n \t  && se.string_length != sym->ts.u.cl->backend_decl)\n@@ -1746,7 +1748,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \n       /* If this is a subreference array pointer associate name use the\n \t associate variable element size for the value of 'span'.  */\n-      if (sym->attr.subref_array_pointer)\n+      if (sym->attr.subref_array_pointer && !se.direct_byref)\n \t{\n \t  gcc_assert (e->expr_type == EXPR_VARIABLE);\n \t  tmp = gfc_get_array_span (se.expr, e);"}, {"sha": "00eac8cde770e9e35e83cd07989a3737934ae577", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -1,3 +1,8 @@\n+2019-03-27  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/88247\n+\t* gfortran.dg/associate_47.f90: New test.\n+\n 2019-03-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/89463"}, {"sha": "085c6f38338d8083d20475b402f78431a833366b", "filename": "gcc/testsuite/gfortran.dg/associate_47.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_47.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f48c7c62d3d8cf8982cb29a8128e3b81335d24/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_47.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_47.f90?ref=d5f48c7c62d3d8cf8982cb29a8128e3b81335d24", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR88247 and more besides :-)\n+!\n+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>\n+!\n+program p\n+   type t\n+      character(:), allocatable :: c\n+      character(:), dimension(:), allocatable :: d\n+   end type\n+   type(t), allocatable :: x\n+\n+   call foo ('abcdef','ghijkl')\n+   associate (y => [x%c(:)])\n+      if (y(1) .ne. 'abcdef') stop 1\n+   end associate\n+\n+   call foo ('ghi','ghi')\n+   associate (y => [x%c(2:)])\n+      if (y(1) .ne. 'hi') stop 2\n+   end associate\n+\n+   call foo ('lmnopq','ghijkl')\n+   associate (y => [x%c(:3)])\n+      if (y(1) .ne. 'lmn') stop 3\n+   end associate\n+\n+   call foo ('abcdef','ghijkl')\n+   associate (y => [x%c(2:4)])\n+      if (y(1) .ne. 'bcd') stop 4\n+   end associate\n+\n+   call foo ('lmnopqrst','ghijklmno')\n+   associate (y => x%d(:))\n+      if (len(y) .ne. 9) stop 5\n+      if (any (y .ne. ['lmnopqrst','ghijklmno'])) stop 5\n+      y(1) = 'zqrtyd'\n+   end associate\n+   if (x%d(1) .ne. 'zqrtyd') stop 5\n+\n+! Substrings of arrays still do not work correctly.\n+   call foo ('lmnopqrst','ghijklmno')\n+   associate (y => x%d(:)(2:4))\n+!      if (any (y .ne. ['mno','hij'])) stop 6\n+   end associate\n+\n+   call foo ('abcdef','ghijkl')\n+   associate (y => [x%d(:)])\n+      if (len(y) .ne. 6) stop 7\n+      if (any (y .ne. ['abcdef','ghijkl'])) stop 7\n+   end associate\n+\n+   call foo ('lmnopqrst','ghijklmno')\n+   associate (y => [x%d(2:1:-1)])\n+      if (len(y) .ne. 9) stop 8\n+      if (any (y .ne. ['ghijklmno','lmnopqrst'])) stop 8\n+   end associate\n+\n+   deallocate (x)\n+contains\n+   subroutine foo (c1, c2)\n+     character(*) :: c1, c2\n+     if (allocated (x)) deallocate (x)\n+     allocate (x)\n+     x%c = c1\n+     x%d = [c1, c2]\n+   end subroutine foo\n+end"}]}