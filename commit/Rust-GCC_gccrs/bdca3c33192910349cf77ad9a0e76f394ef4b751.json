{"sha": "bdca3c33192910349cf77ad9a0e76f394ef4b751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRjYTNjMzMxOTI5MTAzNDljZjc3YWQ5YTBlNzZmMzk0ZWY0Yjc1MQ==", "commit": {"author": {"name": "Herman A.J. ten Brugge", "email": "Haj.Ten.Brugge@net.HCC.nl", "date": "2002-01-09T20:48:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-09T20:48:48Z"}, "message": "real.c (c4xtoe, toc4x): Do some special conversion on long doubles for the c4x target.\n\n        * real.c (c4xtoe, toc4x): Do some special conversion on long doubles\n        for the c4x target. Also improve layout.\n\nFrom-SVN: r48688", "tree": {"sha": "18785be70698dd564c40af21be3514d809998b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18785be70698dd564c40af21be3514d809998b20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdca3c33192910349cf77ad9a0e76f394ef4b751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdca3c33192910349cf77ad9a0e76f394ef4b751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdca3c33192910349cf77ad9a0e76f394ef4b751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdca3c33192910349cf77ad9a0e76f394ef4b751/comments", "author": null, "committer": null, "parents": [{"sha": "d66ae36a8b9a73f2ba22368e8e2ffa1bbdccf5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d66ae36a8b9a73f2ba22368e8e2ffa1bbdccf5ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d66ae36a8b9a73f2ba22368e8e2ffa1bbdccf5ec"}], "stats": {"total": 150, "additions": 78, "deletions": 72}, "files": [{"sha": "4623baa7b07a9dbf596492b223747aa457cdafb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdca3c33192910349cf77ad9a0e76f394ef4b751/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdca3c33192910349cf77ad9a0e76f394ef4b751/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdca3c33192910349cf77ad9a0e76f394ef4b751", "patch": "@@ -1,3 +1,8 @@\n+2002-01-09  Herman A.J. ten Brugge  <Haj.Ten.Brugge@net.HCC.nl>\n+\n+        * real.c (c4xtoe, toc4x): Do some special conversion on long doubles\n+        for the c4x target. Also improve layout.\n+\n 2002-01-09  Richard Henderson  <rth@redhat.com>\n \n \t* config/m32r/m32r.c (move_src_operand): Fix 32-bit int test."}, {"sha": "1986cad3dae6816c5b5fe95c101d722afa940fe9", "filename": "gcc/real.c", "status": "modified", "additions": 73, "deletions": 72, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdca3c33192910349cf77ad9a0e76f394ef4b751/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdca3c33192910349cf77ad9a0e76f394ef4b751/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=bdca3c33192910349cf77ad9a0e76f394ef4b751", "patch": "@@ -6064,16 +6064,25 @@ c4xtoe (d, e, mode)\n      enum machine_mode mode;\n {\n   UEMUSHORT y[NI];\n+  UEMUSHORT dn[4];\n   int r;\n   int isnegative;\n   int size;\n   int i;\n   int carry;\n \n+  dn[0] = d[0];\n+  dn[1] = d[1];\n+  if (mode != QFmode)\n+    {\n+      dn[2] = d[3] << 8;\n+      dn[3] = 0;\n+    }\n+\n   /* Short-circuit the zero case.  */\n-  if ((d[0] == 0x8000)\n-      && (d[1] == 0x0000)\n-      && ((mode == QFmode) || ((d[2] == 0x0000) && (d[3] == 0x0000))))\n+  if ((dn[0] == 0x8000)\n+      && (dn[1] == 0x0000)\n+      && ((mode == QFmode) || ((dn[2] == 0x0000) && (dn[3] == 0x0000))))\n     {\n       e[0] = 0;\n       e[1] = 0;\n@@ -6085,87 +6094,79 @@ c4xtoe (d, e, mode)\n     }\n \n   ecleaz (y);\t\t\t/* start with a zero */\n-  r = d[0];\t\t\t/* get sign/exponent part */\n+  r = dn[0];\t\t\t/* get sign/exponent part */\n   if (r & (unsigned int) 0x0080)\n-  {\n-     y[0] = 0xffff;\t\t/* fill in our sign */\n-     isnegative = TRUE;\n-  }\n+    {\n+      y[0] = 0xffff;\t\t/* fill in our sign */\n+      isnegative = TRUE;\n+    }\n   else\n-  {\n-     isnegative = FALSE;\n-  }\n+    isnegative = FALSE;\n \n   r >>= 8;\t\t\t/* Shift exponent word down 8 bits.  */\n   if (r & 0x80)\t\t\t/* Make the exponent negative if it is.  */\n-  {\n-     r = r | (~0 & ~0xff);\n-  }\n+    r = r | (~0 & ~0xff);\n \n   if (isnegative)\n-  {\n-     /* Now do the high order mantissa.  We don't \"or\" on the high bit\n-\tbecause it is 2 (not 1) and is handled a little differently\n-\tbelow.  */\n-     y[M] = d[0] & 0x7f;\n+    {\n+      /* Now do the high order mantissa.  We don't \"or\" on the high bit\n+\t because it is 2 (not 1) and is handled a little differently\n+\t below.  */\n+      y[M] = dn[0] & 0x7f;\n \n-     y[M+1] = d[1];\n-     if (mode != QFmode)\t/* There are only 2 words in QFmode.  */\n-     {\n-\ty[M+2] = d[2];\t\t/* Fill in the rest of our mantissa.  */\n-\ty[M+3] = d[3];\n-\tsize = 4;\n-     }\n-     else\n-     {\n+      y[M+1] = dn[1];\n+      if (mode != QFmode)\t/* There are only 2 words in QFmode.  */\n+        {\n+\t  y[M+2] = dn[2];\t/* Fill in the rest of our mantissa.  */\n+\t  y[M+3] = dn[3];\n+\t  size = 4;\n+        }\n+      else\n \tsize = 2;\n-     }\n-     eshift(y, -8);\n+      eshift(y, -8);\n \n-     /* Now do the two's complement on the data.  */\n+      /* Now do the two's complement on the data.  */\n \n-     carry = 1;\t/* Initially add 1 for the two's complement.  */\n-     for (i=size + M; i > M; i--)\n-     {\n-\tif (carry && (y[i] == 0x0000))\n-\t{\n-\t   /* We overflowed into the next word, carry is the same.  */\n-\t   y[i] = carry ? 0x0000 : 0xffff;\n-\t}\n-\telse\n-\t{\n-\t   /* No overflow, just invert and add carry.  */\n-\t   y[i] = ((~y[i]) + carry) & 0xffff;\n-\t   carry = 0;\n-\t}\n-     }\n-\n-     if (carry)\n-     {\n-\teshift(y, -1);\n-\ty[M+1] |= 0x8000;\n-\tr++;\n-     }\n-     y[1] = r + EXONE;\n-  }\n+      carry = 1;\t/* Initially add 1 for the two's complement.  */\n+      for (i=size + M; i > M; i--)\n+        {\n+\t  if (carry && (y[i] == 0x0000))\n+\t    /* We overflowed into the next word, carry is the same.  */\n+\t    y[i] = carry ? 0x0000 : 0xffff;\n+\t  else\n+\t    {\n+\t      /* No overflow, just invert and add carry.  */\n+\t      y[i] = ((~y[i]) + carry) & 0xffff;\n+\t      carry = 0;\n+\t    }\n+        }\n+\n+      if (carry)\n+        {\n+\t  eshift(y, -1);\n+\t  y[M+1] |= 0x8000;\n+\t  r++;\n+         }\n+       y[1] = r + EXONE;\n+    }\n   else\n-  {\n-    /* Add our e type exponent offset to form our exponent.  */\n-     r += EXONE;\n-     y[1] = r;\n+    {\n+      /* Add our e type exponent offset to form our exponent.  */\n+      r += EXONE;\n+      y[1] = r;\n \n      /* Now do the high order mantissa strip off the exponent and sign\n \tbits and add the high 1 bit.  */\n-     y[M] = (d[0] & 0x7f) | 0x80;\n+     y[M] = (dn[0] & 0x7f) | 0x80;\n \n-     y[M+1] = d[1];\n+     y[M+1] = dn[1];\n      if (mode != QFmode)\t/* There are only 2 words in QFmode.  */\n-     {\n-\ty[M+2] = d[2];\t\t/* Fill in the rest of our mantissa.  */\n-\ty[M+3] = d[3];\n-     }\n+       {\n+\t y[M+2] = dn[2];\t/* Fill in the rest of our mantissa.  */\n+\t y[M+3] = dn[3];\n+       }\n      eshift(y, -8);\n-  }\n+    }\n \n   emovo (y, e);\n }\n@@ -6243,9 +6244,7 @@ toc4x (x, y, mode)\n       while (v > M)\n \t{\n \t  if (x[v] == 0x0000)\n-\t    {\n-\t      x[v] = carry ? 0x0000 : 0xffff;\n-\t    }\n+\t    x[v] = carry ? 0x0000 : 0xffff;\n \t  else\n \t    {\n \t      x[v] = ((~x[v]) + carry) & 0xffff;\n@@ -6267,9 +6266,7 @@ toc4x (x, y, mode)\n \t}\n     }\n   else\n-    {\n-      i = ((int) x[1]) - 0x7f;\n-    }\n+    i = ((int) x[1]) - 0x7f;\n \n   if ((i < -128) || (i > 127))\n     {\n@@ -6279,6 +6276,8 @@ toc4x (x, y, mode)\n \t{\n \t  y[2] = 0xffff;\n \t  y[3] = 0xffff;\n+\t  y[3] = (y[1] << 8) | ((y[2] >> 8) & 0xff);\n+\t  y[2] = (y[0] << 8) | ((y[1] >> 8) & 0xff);\n \t}\n #ifdef ERANGE\n       errno = ERANGE;\n@@ -6296,6 +6295,8 @@ toc4x (x, y, mode)\n     {\n       y[2] = x[M + 2];\n       y[3] = x[M + 3];\n+      y[3] = (y[1] << 8) | ((y[2] >> 8) & 0xff);\n+      y[2] = (y[0] << 8) | ((y[1] >> 8) & 0xff);\n     }\n }\n #endif /* C4X */"}]}