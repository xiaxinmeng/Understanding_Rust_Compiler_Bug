{"sha": "fbffc70af694dc340bb390071e1cf7b80486a249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJmZmM3MGFmNjk0ZGMzNDBiYjM5MDA3MWUxY2Y3YjgwNDg2YTI0OQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-04-26T20:54:51Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-04-26T20:54:51Z"}, "message": "function.c (expand_function_end): Always clobber the return registers, even if there is no return label.\n\n\t* function.c (expand_function_end): Always clobber the\n\treturn registers, even if there is no return label.\n\nFrom-SVN: r41612", "tree": {"sha": "ffccfbfbd8a06c00a5e393e6d7df7510847830ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffccfbfbd8a06c00a5e393e6d7df7510847830ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbffc70af694dc340bb390071e1cf7b80486a249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbffc70af694dc340bb390071e1cf7b80486a249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbffc70af694dc340bb390071e1cf7b80486a249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbffc70af694dc340bb390071e1cf7b80486a249/comments", "author": null, "committer": null, "parents": [{"sha": "9cc03fabc2fae764f2d2ca0bff25b1d34b8e96b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc03fabc2fae764f2d2ca0bff25b1d34b8e96b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc03fabc2fae764f2d2ca0bff25b1d34b8e96b6"}], "stats": {"total": 43, "additions": 24, "deletions": 19}, "files": [{"sha": "957f0471d5276f9cfb9b15514e5cd0f19ca43d76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbffc70af694dc340bb390071e1cf7b80486a249/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbffc70af694dc340bb390071e1cf7b80486a249/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbffc70af694dc340bb390071e1cf7b80486a249", "patch": "@@ -1,3 +1,8 @@\n+2001-04-26  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* function.c (expand_function_end): Always clobber the\n+\treturn registers, even if there is no return label.\n+\n Thu Apr 26 20:28:21 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* (ix86_expand_fp_movcc): Re-enable SSE conditional move generation.\n@@ -77,6 +82,7 @@ Thu Apr 26 19:20:28 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* config/i386/i386.h (CC1_CPU_SPEC): Fix deprecation warnings for\n \t-m386 and -m486.\n \n+>>>>>>> 1.9867\n 2001-04-26  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* configure.in (configargs.h): Define thread_model.\n@@ -161,6 +167,7 @@ Wed Apr 25 17:09:50 2001  J\"orn Rennecke <amylaar@redhat.com>\n \t(get_exception_filter): New fn.\n \t(finish_eh_generation): Use it.\n \n+>>>>>>> 1.9859\n 2001-04-24  Nathan Sidwell <nathan@codesourcery.com>\n \n \t* c-semantics.c (add_scope_stmt): Don't call"}, {"sha": "482e3ef089da51f6b2d7cd8cdec4eba1de6f14f4", "filename": "gcc/function.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbffc70af694dc340bb390071e1cf7b80486a249/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbffc70af694dc340bb390071e1cf7b80486a249/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fbffc70af694dc340bb390071e1cf7b80486a249", "patch": "@@ -6777,31 +6777,29 @@ expand_function_end (filename, line, end_bindings)\n      SDB depends on this.  */\n   emit_line_note_force (filename, line);\n \n+  /* Before the return label (if any), clobber the return\n+     registers so that they are not propogated live to the rest of\n+     the function.  This can only happen with functions that drop\n+     through; if there had been a return statement, there would\n+     have either been a return rtx, or a jump to the return label.  */\n+  {\n+    rtx before, after;\n+    \n+    before = get_last_insn ();\n+    clobber_return_register ();\n+    after = get_last_insn ();\n+    \n+    if (before != after)\n+      cfun->x_clobber_return_insn = after;\n+  }\n+\n   /* Output the label for the actual return from the function,\n      if one is expected.  This happens either because a function epilogue\n      is used instead of a return instruction, or because a return was done\n      with a goto in order to run local cleanups, or because of pcc-style\n      structure returning.  */\n-\n   if (return_label)\n-    {\n-      rtx before, after;\n-\n-      /* Before the return label, clobber the return registers so that\n-         they are not propogated live to the rest of the function.  This\n-\t can only happen with functions that drop through; if there had\n-\t been a return statement, there would have either been a return\n-\t rtx, or a jump to the return label.  */\n-\n-      before = get_last_insn ();\n-      clobber_return_register ();\n-      after = get_last_insn ();\n-\n-      if (before != after)\n-\tcfun->x_clobber_return_insn = after;\n-\n-      emit_label (return_label);\n-    }\n+    emit_label (return_label);\n \n   /* C++ uses this.  */\n   if (end_bindings)"}]}