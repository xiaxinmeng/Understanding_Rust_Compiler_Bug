{"sha": "013cfc648405a8a118d07436f103e4d70224fe00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzY2ZjNjQ4NDA1YThhMTE4ZDA3NDM2ZjEwM2U0ZDcwMjI0ZmUwMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-09T09:50:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-09T09:50:20Z"}, "message": "Improve LIM fill_always_executed_in computation\n\nCurrently the DOM walk over a loop body does not walk into not\nalways executed subloops to avoid scalability issues since doing\nso makes the walk quadratic in the loop depth.  It turns out this\nis not an issue in practice and even with a loop depth of 1800\nthis function is way off the radar.\n\nSo the following patch removes the limitation, replacing it with\na comment.\n\n2021-09-09  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (fill_always_executed_in_1): Walk\n\tinto all subloops.\n\n\t* gcc.dg/tree-ssa/ssa-lim-17.c: New testcase.", "tree": {"sha": "ca468ff6558e0211fbeda33517a6f71a7933d5b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca468ff6558e0211fbeda33517a6f71a7933d5b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/013cfc648405a8a118d07436f103e4d70224fe00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013cfc648405a8a118d07436f103e4d70224fe00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013cfc648405a8a118d07436f103e4d70224fe00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013cfc648405a8a118d07436f103e4d70224fe00/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e27bc2b885207d51500b2c42f949ca5073dbe72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e27bc2b885207d51500b2c42f949ca5073dbe72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e27bc2b885207d51500b2c42f949ca5073dbe72"}], "stats": {"total": 36, "additions": 27, "deletions": 9}, "files": [{"sha": "1c840e554b7ea8ea98bc30ae5bf6715e437da34a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-17.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cfc648405a8a118d07436f103e4d70224fe00/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cfc648405a8a118d07436f103e4d70224fe00/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-17.c?ref=013cfc648405a8a118d07436f103e4d70224fe00", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+volatile int flag, bar;\n+double foo (double *valp)\n+{\n+  double sum = 0;\n+  for (int i = 0; i < 256; ++i)\n+    {\n+      if (flag)\n+\tfor (int j = 0; j < 256; ++j)\n+\t  bar = flag;\n+      if (flag)\n+        sum += 1.;\n+      sum += *valp; // we should move the load of *valp out of the loop\n+    }\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Moving statement\" 1 \"lim2\" } } */"}, {"sha": "4b187c2cdafe586fe159343c1f5b22abfde7446a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013cfc648405a8a118d07436f103e4d70224fe00/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013cfc648405a8a118d07436f103e4d70224fe00/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=013cfc648405a8a118d07436f103e4d70224fe00", "patch": "@@ -3074,15 +3074,13 @@ fill_always_executed_in_1 (class loop *loop, sbitmap contains_call)\n \t    break;\n \n \t  if (bb->loop_father->header == bb)\n-\t    {\n-\t      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n-\t\tbreak;\n-\n-\t      /* In a loop that is always entered we may proceed anyway.\n-\t\t But record that we entered it and stop once we leave it\n-\t\t since it might not be finite.  */\n-\t      inn_loop = bb->loop_father;\n-\t    }\n+\t    /* Record that we enter into a subloop since it might not\n+\t       be finite.  */\n+\t    /* ???  Entering into a not always executed subloop makes\n+\t       fill_always_executed_in quadratic in loop depth since\n+\t       we walk those loops N times.  This is not a problem\n+\t       in practice though, see PR102253 for a worst-case testcase.  */\n+\t    inn_loop = bb->loop_father;\n \n \t  /* Walk the body of LOOP sorted by dominance relation.  Additionally,\n \t     if a basic block S dominates the latch, then only blocks dominated"}]}