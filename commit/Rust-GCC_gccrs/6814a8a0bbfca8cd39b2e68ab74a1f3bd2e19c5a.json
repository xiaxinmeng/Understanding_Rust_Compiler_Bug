{"sha": "6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgxNGE4YTBiYmZjYThjZDM5YjJlNjhhYjc0YTFmM2JkMmUxOWM1YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-08T21:30:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-08T21:30:17Z"}, "message": "flow.c (count_basic_blocks, [...]): A rethrow can occur outside of an EH region.\n\n        * flow.c (count_basic_blocks, find_basic_blocks_1): A rethrow\n        can occur outside of an EH region.\n        * except.c: Correct comments about rethrow behavior.\n        (rethrow_symbol_map): Do nothing if !flag_new_exceptions.\n\n        * flow.c (make_edges): Always call make_eh_edge for calls.\n\nFrom-SVN: r32432", "tree": {"sha": "5ebf91de1a0adafc35062b23a2450bd867d352f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ebf91de1a0adafc35062b23a2450bd867d352f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/comments", "author": null, "committer": null, "parents": [{"sha": "2b01d2d999a4fa1e0ce9b7b9d85ebaedfc726043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b01d2d999a4fa1e0ce9b7b9d85ebaedfc726043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b01d2d999a4fa1e0ce9b7b9d85ebaedfc726043"}], "stats": {"total": 83, "additions": 54, "deletions": 29}, "files": [{"sha": "17ab03e7a19abb4a96dbc32f65613e67a521293a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "patch": "@@ -1,3 +1,14 @@\n+2000-03-08  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* flow.c (count_basic_blocks, find_basic_blocks_1): A rethrow\n+\tcan occur outside of an EH region.\n+\t* except.c: Correct comments about rethrow behavior.\n+\t(rethrow_symbol_map): Do nothing if !flag_new_exceptions.\n+\n+2000-03-08  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* flow.c (make_edges): Always call make_eh_edge for calls.\n+\n 2000-03-08  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplib.h (parse_underflow_t, CPP_NULL_BUFFER): Delete."}, {"sha": "7ecfaf85c21304105016d7ce31cbd8bd74a2d3a0", "filename": "gcc/except.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "patch": "@@ -495,6 +495,7 @@ static int eh_region_from_symbol PARAMS ((rtx));\n extern struct obstack permanent_obstack;\n \n /* Generate a SYMBOL_REF for rethrow to use */\n+\n static rtx\n create_rethrow_ref (region_num)\n      int region_num;\n@@ -566,7 +567,7 @@ top_label_entry (stack)\n   return (*stack)->u.tlabel;\n }\n \n-/* get an exception label. These must be on the permanent obstack */\n+/* Get an exception label.  */\n \n rtx\n gen_exception_label ()\n@@ -602,7 +603,8 @@ push_eh_entry (stack)\n   stack->top = node;\n }\n \n-/* push an existing entry onto a stack. */\n+/* Push an existing entry onto a stack.  */\n+\n static void\n push_entry (stack, entry)\n      struct eh_stack *stack;\n@@ -695,7 +697,7 @@ struct func_eh_entry\n {\n   int range_number;   /* EH region number from EH NOTE insn's.  */\n   rtx rethrow_label;  /* Label for rethrow.  */\n-  int rethrow_ref;    /* Is rethrow referenced?  */\n+  int rethrow_ref;    /* Is rethrow_label referenced?  */\n   struct handler_info *handlers;\n };\n \n@@ -969,6 +971,7 @@ duplicate_eh_handlers (old_note_eh_region, new_note_eh_region, map)\n \n \n /* Given a rethrow symbol, find the EH region number this is for. */\n+\n static int \n eh_region_from_symbol (sym)\n      rtx sym;\n@@ -984,6 +987,7 @@ eh_region_from_symbol (sym)\n \n /* Like find_func_region, but using the rethrow symbol for the region\n    rather than the region number itself.  */\n+\n static int\n find_func_region_from_symbol (sym)\n      rtx sym;\n@@ -995,12 +999,17 @@ find_func_region_from_symbol (sym)\n    __rethrow as well. This performs the remap. If a symbol isn't foiund,\n    the original one is returned. This is not an efficient routine,\n    so don't call it on everything!! */\n+\n rtx \n rethrow_symbol_map (sym, map)\n      rtx sym;\n      rtx (*map) PARAMS ((rtx));\n {\n   int x, y;\n+\n+  if (! flag_new_exceptions)\n+    return sym;\n+\n   for (x = 0; x < current_func_eh_entry; x++)\n     if (function_eh_regions[x].rethrow_label == sym)\n       {\n@@ -1021,6 +1030,10 @@ rethrow_symbol_map (sym, map)\n   return sym;\n }\n \n+/* Returns nonzero if the rethrow label for REGION is referenced\n+   somewhere (i.e. we rethrow out of REGION or some other region\n+   masquerading as REGION).  */\n+\n int \n rethrow_used (region)\n      int region;\n@@ -2011,7 +2024,7 @@ expand_rethrow (label)\n \t  label = last_rethrow_symbol;\n \temit_library_call (rethrow_libfunc, 0, VOIDmode, 1, label, Pmode);\n \tregion = find_func_region (eh_region_from_symbol (label));\n-\t/* If the region is -1, it doesn't exist yet.  We should be\n+\t/* If the region is -1, it doesn't exist yet.  We shouldn't be\n \t   trying to rethrow there yet.  */\n \tif (region == -1)\n \t  abort ();\n@@ -2194,14 +2207,12 @@ output_exception_table_entry (file, n)\n   int index = find_func_region (n);\n   rtx rethrow;\n   \n- /* form and emit the rethrow label, if needed  */\n-  rethrow = function_eh_regions[index].rethrow_label;\n-  if (rethrow != NULL_RTX && !flag_new_exceptions)\n-      rethrow = NULL_RTX;\n-  if (rethrow != NULL_RTX && handler == NULL)\n-    if (! function_eh_regions[index].rethrow_ref)\n-      rethrow = NULL_RTX;\n-\n+  /* Form and emit the rethrow label, if needed  */\n+  if (flag_new_exceptions\n+      && (handler || function_eh_regions[index].rethrow_ref))\n+    rethrow = function_eh_regions[index].rethrow_label;\n+  else\n+    rethrow = NULL_RTX;\n \n   for ( ; handler != NULL || rethrow != NULL_RTX; handler = handler->next)\n     {\n@@ -2301,7 +2312,7 @@ output_exception_table ()\n       if (i != 0)\n         assemble_integer (const0_rtx, i , 1);\n \n-      /* Generate the label for offset calculations on rethrows */\n+      /* Generate the label for offset calculations on rethrows.  */\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LRTH\", 0);\n       assemble_label(buf);\n     }\n@@ -2318,7 +2329,7 @@ output_exception_table ()\n   assemble_label(buf);\n   assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n-  /* for binary compatability, the old __throw checked the second\n+  /* For binary compatibility, the old __throw checked the second\n      position for a -1, so we should output at least 2 -1's */\n   if (! flag_new_exceptions)\n     assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n@@ -2666,7 +2677,7 @@ scan_region (insn, n, delete_outer)\n   /* Assume we can delete the region.  */\n   int delete = 1;\n \n-  /* Can't delete something which is rethrown to. */\n+  /* Can't delete something which is rethrown from. */\n   if (rethrow_used (n))\n     delete = 0;\n \n@@ -2783,9 +2794,10 @@ exception_optimize ()\n     }\n }\n \n-/* This function determines whether any of the exception regions in the\n-   current function are targets of a rethrow or not, and set the \n-   reference flag according.  */\n+/* This function determines whether the rethrow labels for any of the\n+   exception regions in the current function are used or not, and set\n+   the reference flag according.  */\n+\n void\n update_rethrow_references ()\n {\n@@ -2800,7 +2812,7 @@ update_rethrow_references ()\n   saw_rethrow = (int *) xcalloc (current_func_eh_entry, sizeof (int));\n \n   /* Determine what regions exist, and whether there are any rethrows\n-     to those regions or not.  */\n+     from those regions or not.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == CALL_INSN)\n       {\n@@ -3336,7 +3348,7 @@ reachable_handlers (block, info, insn, handlers)\n   if (insn && GET_CODE (insn) == CALL_INSN)\n     {\n       /* RETHROWs specify a region number from which we are going to rethrow.\n-\t This means we wont pass control to handlers in the specified\n+\t This means we won't pass control to handlers in the specified\n \t region, but rather any region OUTSIDE the specified region.\n \t We accomplish this by setting block to the outer_index of the\n \t specified region.  */"}, {"sha": "570483567a3f620d242f4ebda87ce5d9ff03ee8e", "filename": "gcc/flow.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6814a8a0bbfca8cd39b2e68ab74a1f3bd2e19c5a", "patch": "@@ -469,8 +469,9 @@ count_basic_blocks (f)\n \t  prev_call = insn;\n \t  call_had_abnormal_edge = 0;\n \n-\t  /* If there is a specified EH region, we have an edge.  */\n-\t  if (eh_region && region > 0)\n+\t  /* If there is an EH region or rethrow, we have an edge.  */\n+\t  if ((eh_region && region > 0)\n+\t      || find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n \t    call_had_abnormal_edge = 1;\n \t  else\n \t    {\n@@ -541,8 +542,9 @@ find_basic_blocks_1 (f)\n \t  int region = (note ? XWINT (XEXP (note, 0), 0) : 1);\n \t  call_has_abnormal_edge = 0;\n \n-\t  /* If there is an EH region, we have an edge.  */\n-\t  if (eh_list && region > 0)\n+\t  /* If there is an EH region or rethrow, we have an edge.  */\n+\t  if ((eh_list && region > 0)\n+\t      || find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n \t    call_has_abnormal_edge = 1;\n \t  else\n \t    {\n@@ -983,10 +985,10 @@ make_edges (label_value_list)\n \n       if (code == CALL_INSN || asynchronous_exceptions)\n \t{\n-\t  /* If there's an EH region active at the end of a block,\n-\t     add the appropriate edges.  */\n-\t  if (bb->eh_end >= 0)\n-\t    make_eh_edge (edge_cache, eh_nest_info, bb, insn, bb->eh_end);\n+\t  /* Add any appropriate EH edges.  We do this unconditionally\n+\t     since there may be a REG_EH_REGION or REG_EH_RETHROW note\n+\t     on the call, and this needn't be within an EH region.  */\n+\t  make_eh_edge (edge_cache, eh_nest_info, bb, insn, bb->eh_end);\n \n \t  /* If we have asynchronous exceptions, do the same for *all*\n \t     exception regions active in the block.  */\n@@ -1778,7 +1780,7 @@ delete_eh_regions ()\n \t  {\n \t    int num = NOTE_EH_HANDLER (insn);\n \t    /* A NULL handler indicates a region is no longer needed,\n-\t       as long as it isn't the target of a rethrow.  */\n+\t       as long as its rethrow label isn't used.  */\n \t    if (get_first_handler (num) == NULL && ! rethrow_used (num))\n \t      {\n \t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;"}]}