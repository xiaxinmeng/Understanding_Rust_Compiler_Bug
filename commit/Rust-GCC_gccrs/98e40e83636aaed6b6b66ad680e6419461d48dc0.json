{"sha": "98e40e83636aaed6b6b66ad680e6419461d48dc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThlNDBlODM2MzZhYWVkNmI2YjY2YWQ2ODBlNjQxOTQ2MWQ0OGRjMA==", "commit": {"author": {"name": "Graham Stott", "email": "grahams@redhat.com", "date": "2002-01-06T05:24:03Z"}, "committer": {"name": "Graham Stott", "email": "grahams@gcc.gnu.org", "date": "2002-01-06T05:24:03Z"}, "message": "cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): Add parenthesis.\n\n\n        * cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): Add parenthesis.\n        (VAR_FUNCTION_OR_PARM_DECL_CHECK): Likewise.\n        (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK) Likewise.\n        (RECORD_OR_UNION_TYPE_CHECK): Likewise.\n        (BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK): Likewise.\n        (C_IS_RESERVED_WORD): Uppercase macro parameter.\n        (C_RID_YYCODE) Likewise.\n        (ptrmem_cst): Use rtx.\n        (LOCAL_BINDING_P): Add whitespace.\n        (INHERITED_VALUE_BINDING_P): Likewise.\n        (BINDING_SCOPE): Wrap long line.\n        (BINDING_HAS_LEVEL_P): Remove parenthesis.\n        (BINDING_VALUE): Wrap long line.\n        (BINDING_TYPE): Whitespace.\n        (IDENTIFIER_GLOBAL_VALUE): Add parenthesis.\n        (SET_IDENTIFIER_GLOBAL_VALUE): Likewise.\n        (IDENTIFIER_NAMESPACE_VALUE): Likewise.\n        (SET_IDENTIFIER_NAMESPACE_VALUE: Likewise.\n        (same_type_p): Uppercase macro parameters.\n        (same_type_ignoring_top_level_qualifiers_p): Likewise.\n        (OVL_FUNCTION): Wrap long line.\n        (OVL_CHAIN): Whitespace.\n        (OVL_CURRENT): Add paranthesis and whitespace.\n        (OVL_NEXT): Whitespace.\n        (OVL_USED): Likewise.\n        (IDENTIFIER_TYPE_VALUE): Likewise.\n        (REAL_IDENTIFIER_TYPE_VALUE): Remove parenthesis.\n        (SET_IDENTIFIER_TYPE_VALUE): Add parenthesis and whitespace.\n        (LANG_ID_FIELD): Whitespace.\n        (SET_LANG_ID(NODE,VALUE,NAME): Likewise.\n        (IDENTIFIER_LABEL_VALUE): Whitespace and wrap.\n        (SET_IDENTIFIER_LABEL_VALUE): Whitespace.\n        (IDENTIFIER_IMPLICIT_DECL): Whitespace and wrap.\n        (SET_IDENTIFIER_IMPLICIT_DECL); Whitespace.\n        (IDENTIFIER_ERROR_LOCUS): Whitespace and wrap.\n        (SET_IDENTIFIER_ERROR_LOCUS); Whitespace.\n        (IDENTIFIER_VIRTUAL_P): Likewise.\n        (IDENTIFIER_OPNAME_P): Likewise.\n        (IDENTIFIER_TYPENAME_P): Remove parenthesis.\n        (C_TYPE_FIELDS_READONLY): Uppercase macro parameters.\n        (C_SET_EXP_ORIGINAL_CODE): Likewise.\n        (TYPE_ASSEMBLER_NAME_STRING): Wrap long line.\n        (TYPE_ASSEMBLER_NAME_LENGTH): Likewise.\n        (IS_AGGR_TYPE): Uppercase macro parameter.\n        (CLASS_TYPE_P): Likewise.\n        (IS_AGGR_TYPE_CODE): Uppercase macro parameter and parenthesis.\n        (IS_AGGR_TYPE_2): Whitespace.\n        (TAGGED_TYPE_P): Uppercase macro parameter.\n        (TYPE_BUILT_IN): Whitespace.\n        (TYPE_FOR_JAVA): Likewise.\n        (FUNCTION_ARG_CHAIN): Remove parenthesis.\n        (FUNCTION_FIRST_USER_PARMTYPE): Add parenthesis.\n        (FUNCTION_FIRST_USER_PARAM): Likewise.\n        (PROMOTES_TO_AGGR_TYPE): Whitespace.\n        (DERIVED_FROM_P): Add parenthesis and wrap.\n        (UNIQUELY_DERIVED_FROM_P): Likewise.\n        (ACCESSIBLY_UNIQUELY_DERIVED_P): Likewise.\n        (PUBLICLY_UNIQUELY_DERIVED_P): Likewise.\n        (CLASSTYPE_USE_TEMPLATE): Whitespace.\n        (CLASSTYPE_INLINE_FRIENDS): Remove parenthesis.\n        (TYPE_GETS_DELETE): Add parenthesis.\n        (TYPE_HAS_CONVERSION): Add parenthesis and wrap.\n        (TYPE_HAS_ASSIGN_REF): Likewise,\n        (TYPE_HAS_CONST_ASSIGN_REF): Likewise.\n        (TYPE_HAS_INIT_REF): Likewise.\n        (TYPE_HAS_CONST_INIT_REF): Likewise.\n        (TYPE_BEING_DEFINED): Likewise.\n        (TYPE_LANG_SPECIFIC): Likewise.\n        (CLASSTYPE_RTTI): Likewise.\n        (TYPE_OVERLOADS_CALL_EXPR): Likewise.\n        (TYPE_OVERLOADS_ARRAY_REF): Likewise.\n        (TYPE_OVERLOADS_ARROW): Likewise.\n        (TYPE_USES_MULTIPLE_INHERITANCE): Likewise.\n        (TYPE_USES_VIRTUAL_BASECLASSES): Add parenthesis.\n        (CLASSTYPE_METHOD_VEC): Likewise.\n        (CLASSTYPE_MARKED_N): Likewise.\n        (CLASSTYPE_MARKED): Likewise.\n        (CLASSTYPE_MARKED2): Likewise.\n        (CLASSTYPE_MARKED3): Likewise.\n        (CLASSTYPE_MARKED4): Likewise.\n        (CLASSTYPE_MARKED5): Likewise.\n        (CLASSTYPE_MARKED6): Likewise.\n        (SET_CLASSTYPE_MARKED): Whitespace.\n        (CLEAR_CLASSTYPE_MARKED): Likewise.\n        (SET_CLASSTYPE_MARKED2): Likewise.\n        (CLEAR_CLASSTYPE_MARKED2): Likewise.\n        (SET_CLASSTYPE_MARKED3): Likewise.\n        (CLEAR_CLASSTYPE_MARKED3): Likewise.\n        (SET_CLASSTYPE_MARKED4): Likewise.\n        (CLEAR_CLASSTYPE_MARKED4): Likewise.\n        (SET_CLASSTYPE_MARKED5): Likewise.\n        (CLEAR_CLASSTYPE_MARKED5): Likewise.\n        (SET_CLASSTYPE_MARKED6): Likewise.\n        (CLEAR_CLASSTYPE_MARKED6): Likewise.\n        (CLASSTYPE_TAGS): Likewise.\n        (CLASSTYPE_VSIZE): Likewise.\n        (CLASSTYPE_VBASECLASSES): Likewise.\n        (CANONICAL_BINFO): Add parenthesis.\n        (CLASSTYPE_SIZE(NODE): Likewise.\n        (CLASSTYPE_SIZE_UNIT): Likewise.\n        (CLASSTYPE_ALIGN(NODE): Likewise.\n        (CLASSTYPE_USER_ALIGN): Likewise.\n        (TYPE_JAVA_INTERFACE): Likewise.\n        (CLASSTYPE_PURE_VIRTUALS): Likewise.\n        (CLASSTYPE_NEEDS_VIRTUAL_REINIT): Whitespace and wrap.\n        (TYPE_HAS_DEFAULT_CONSTRUCTOR): Likewise.\n        (CLASSTYPE_HAS_MUTABLE): Likewise.\n        (CLASSTYPE_FRIEND_CLASSES): Likewise. Likewise.\n        (CLASSTYPE_DECLARED_CLASS): Whitespace and wrap.\n        (CLASSTYPE_READONLY_FIELDS_NEED_INIT): Likewise.\n        (CLASSTYPE_REF_FIELDS_NEED_INIT): Likewise.\n        (CLASSTYPE_INTERFACE_ONLY): Likewise.\n        (CLASSTYPE_INTERFACE_KNOWN): Likewise.\n        (CLASSTYPE_INTERFACE_UNKNOWN): Likewise.\n        (SET_CLASSTYPE_INTERFACE_UNKNOWN_X): Likewise.\n        (SET_CLASSTYPE_INTERFACE_UNKNOWN): Likewise.\n        (SET_CLASSTYPE_INTERFACE_KNOWN): Likewise.\n        (CLASSTYPE_DEBUG_REQUESTED): Whitespace and wrap.\n        (BINFO_UNSHARED_MARKED): Whitespace.\n        (BINFO_MARKED): Whitespace and wrap.\n        (SET_BINFO_MARKED): Likewise.\n        (CLEAR_BINFO_MARKED): Likewise.\n        (BINFO_VTABLE_PATH_MARKED): Likewise.\n        (SET_BINFO_VTABLE_PATH_MARKED): Likewise.\n        (CLEAR_BINFO_VTABLE_PATH_MARKED): Likewise.\n        (BINFO_SUBVTT_INDEX): Remove parenthesis.\n        (BINFO_VPTR_INDEX): Likewise.\n        (BINFO_PRIMARY_BASE_OF): Likewise,\n        (CLASSTYPE_VFIELDS): Whitespace.\n        (VF_DERIVED_VALUE): Wrap long line.\n        (NAMESPACE_LEVEL): Whitespace.\n        (CAN_HAVE_FULL_LANG_DECL_P): Remove parenthesis.\n        (DEFARG_POINTER): Whitespace.\n        (DECL_NEEDED_P): Remove parenthesis.\n        (DECL_LANGUAGE): Whitespace.\n        (SET_DECL_LANGUAGE): Add parenthesis.\n        (DECL_CONSTRUCTOR_P): Whitespace and wrap.\n        (DECL_OVERLOADED_OPERATOR_P): Remove parenthesis.\n        (DECL_IN_AGGR_P): Whitespace.\n        (DECL_FRIEND_P): Likewise.\n        (DECL_BEFRIENDING_CLASSES): Likewise.\n        (DECL_STATIC_FUNCTION_P): Whitespace and wrap.\n        (DECL_NONCONVERTING_P): Whitespace.\n        (DECL_PURE_VIRTUAL_P): Likewise.\n        (DECL_NEEDS_FINAL_OVERRIDER_P): Likewise.\n        (DECL_PENDING_INLINE_INFO): Whitespace.\n        (DECL_SORTED_FIELDS): Likewise.\n        (DECL_DEFERRED_FN): Likewise.\n        (DECL_TEMPLATE_INFO): Likewise.\n        (CLASSTYPE_TEMPLATE_INFO): Whitespace and wrap.\n        (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO); Likewise.\n        (SET_TYPE_TEMPLATE_INFO): Add parenthesis.\n        (TMPL_ARGS_LEVEL): Likewise.\n        (SET_TMPL_ARGS_LEVEL): Likewise.\n        (INNERMOST_TEMPLATE_PARMS): Whitespace.\n        (C_TYPEDEF_EXPLICITLY_SIGNED): Uppercase macro parameter.\n        (INTEGRAL_CODE_P(CODE): Add parenthesis.\n        (CP_INTEGRAL_TYPE_P): Remove parenthesis.\n        (TYPE_HAS_CONSTRUCTOR): Whitespace.\n        (TREE_HAS_CONSTRUCTOR): Likewise.\n        (TYPE_HAS_DESTRUCTOR): Likewise.\n        (TYPE_HAS_REAL_ASSIGN_REF): Likewise.\n        (TYPE_HAS_COMPLEX_ASSIGN_REF): Likewise.\n        (TYPE_HAS_ABSTRACT_ASSIGN_REF): Likewise.\n        (TYPE_HAS_COMPLEX_INIT_REF): Likewise.\n        (TYPE_HAS_NONTRIVIAL_DESTRUCTOR): Likewise.\n        (TYPE_PTRMEMFUNC_P): Likewise.\n        (TYPE_PTRMEMFUNC_FLAG): Likewise.\n        (TYPE_GET_PTRMEMFUNC_TYPE): Likewise.\n        (TYPE_SET_PTRMEMFUNC_TYPE): Likewise.\n        (TYPE_PTRMEM_CLASS_TYPE): Remove paranthesis.\n        (TYPE_PTRMEM_POINTED_TO_TYPE): Likewise.\n        (DECL_ACCESS): Whitespace.\n        (DECL_GLOBAL_CTOR_P): Remove paranthesis.\n        (DECL_GLOBAL_DTOR_P): Likewise.\n        (GLOBAL_INIT_PRIORITY): Likewise.\n        (DECL_TEMPLATE_PARMS): Likewise.\n        (DECL_TEMPLATE_RESULT): Likewise.\n        (DECL_TEMPLATE_INSTANTIATIONS): Likewise.\n        (DECL_TEMPLATE_SPECIALIZATIONS): Likewise.\n        (DECL_IMPLICIT_TYPEDEF_P): Remove parenthesis.\n        (SET_DECL_IMPLICIT_TYPEDEF_P): Likewise.\n        (PRIMARY_TEMPLATE_P): Add parenthesis.\n        (DECL_USE_TEMPLATE): Whitespace.\n        (CLASSTYPE_IMPLICIT_INSTANTIATION): Likewise.\n        (SET_CLASSTYPE_IMPLICIT_INSTANTIATION): Likewise.\n        (CLASSTYPE_EXPLICIT_INSTANTIATION): Likewise.\n        (SET_CLASSTYPE_EXPLICIT_INSTANTIATION): Likewise.\n        (CALL_DECLARATOR_PARMS): Remove parenthesis.\n        (CALL_DECLARATOR_QUALS): Likewise.\n        (CALL_DECLARATOR_EXCEPTION_SPEC): Likewise.\n        (TEMP_NAME_P): Wrap.\n        (VFIELD_NAME_P): Likewise.\n        (B_SET): Uppercase macro parameters and add parenthesis.\n        (B_CLR): Likewise.\n        (B_TST): Likewise.\n        (LOOKUP_NAMESPACES_ONLY): Uppercase macro parameters.\n        (LOOKUP_TYPES_ONLY): Uppercase macro parameters.\n        (LOOKUP_QUALIFIERS_ONLY): Uppercase macro parameters.\n        (same_or_base_type_p): Likewise.\n        (cp_deprecated): Likewise.\n\nFrom-SVN: r48573", "tree": {"sha": "b4e282342f77df227b3c13461d439d6c8a6396f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4e282342f77df227b3c13461d439d6c8a6396f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98e40e83636aaed6b6b66ad680e6419461d48dc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e40e83636aaed6b6b66ad680e6419461d48dc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e40e83636aaed6b6b66ad680e6419461d48dc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e40e83636aaed6b6b66ad680e6419461d48dc0/comments", "author": null, "committer": null, "parents": [{"sha": "c28abdf00d60460c4f7e27edc7deb099ae91e8c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c28abdf00d60460c4f7e27edc7deb099ae91e8c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c28abdf00d60460c4f7e27edc7deb099ae91e8c1"}], "stats": {"total": 765, "additions": 513, "deletions": 252}, "files": [{"sha": "c3bfb4d69a3eba5cbebedbd4c0b976a63d23684c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e40e83636aaed6b6b66ad680e6419461d48dc0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e40e83636aaed6b6b66ad680e6419461d48dc0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=98e40e83636aaed6b6b66ad680e6419461d48dc0", "patch": "@@ -1,3 +1,207 @@\n+2002-01-06  Graham Stott  <grahams@redhat.com>\n+\n+\t* cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK): Add parenthesis.\n+\t(VAR_FUNCTION_OR_PARM_DECL_CHECK): Likewise.\n+\t(VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK) Likewise.\n+\t(RECORD_OR_UNION_TYPE_CHECK): Likewise.\n+\t(BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK): Likewise.\n+\t(C_IS_RESERVED_WORD): Uppercase macro parameter.\n+\t(C_RID_YYCODE) Likewise.\n+\t(ptrmem_cst): Use rtx.\n+\t(LOCAL_BINDING_P): Add whitespace.\n+\t(INHERITED_VALUE_BINDING_P): Likewise.\n+\t(BINDING_SCOPE): Wrap long line.\n+\t(BINDING_HAS_LEVEL_P): Remove parenthesis.\n+\t(BINDING_VALUE): Wrap long line.\n+\t(BINDING_TYPE): Whitespace.\n+\t(IDENTIFIER_GLOBAL_VALUE): Add parenthesis.\n+\t(SET_IDENTIFIER_GLOBAL_VALUE): Likewise.\n+\t(IDENTIFIER_NAMESPACE_VALUE): Likewise. \n+\t(SET_IDENTIFIER_NAMESPACE_VALUE: Likewise.\n+\t(same_type_p): Uppercase macro parameters.\n+\t(same_type_ignoring_top_level_qualifiers_p): Likewise.\n+\t(OVL_FUNCTION): Wrap long line.\n+\t(OVL_CHAIN): Whitespace.\n+\t(OVL_CURRENT): Add paranthesis and whitespace.\n+\t(OVL_NEXT): Whitespace.\n+\t(OVL_USED): Likewise.\n+\t(IDENTIFIER_TYPE_VALUE): Likewise.\n+\t(REAL_IDENTIFIER_TYPE_VALUE): Remove parenthesis.\n+\t(SET_IDENTIFIER_TYPE_VALUE): Add parenthesis and whitespace.\n+\t(LANG_ID_FIELD): Whitespace.\n+\t(SET_LANG_ID(NODE,VALUE,NAME): Likewise.\n+\t(IDENTIFIER_LABEL_VALUE): Whitespace and wrap.\n+\t(SET_IDENTIFIER_LABEL_VALUE): Whitespace.\n+\t(IDENTIFIER_IMPLICIT_DECL): Whitespace and wrap.\n+\t(SET_IDENTIFIER_IMPLICIT_DECL); Whitespace.\n+\t(IDENTIFIER_ERROR_LOCUS): Whitespace and wrap.\n+\t(SET_IDENTIFIER_ERROR_LOCUS); Whitespace.\n+\t(IDENTIFIER_VIRTUAL_P): Likewise.\n+\t(IDENTIFIER_OPNAME_P): Likewise.\n+\t(IDENTIFIER_TYPENAME_P): Remove parenthesis.\n+\t(C_TYPE_FIELDS_READONLY): Uppercase macro parameters.\n+\t(C_SET_EXP_ORIGINAL_CODE): Likewise.\n+\t(TYPE_ASSEMBLER_NAME_STRING): Wrap long line.\n+\t(TYPE_ASSEMBLER_NAME_LENGTH): Likewise.\n+\t(IS_AGGR_TYPE): Uppercase macro parameter.\n+\t(CLASS_TYPE_P): Likewise.\n+\t(IS_AGGR_TYPE_CODE): Uppercase macro parameter and parenthesis.\n+\t(IS_AGGR_TYPE_2): Whitespace.\n+\t(TAGGED_TYPE_P): Uppercase macro parameter.\n+\t(TYPE_BUILT_IN): Whitespace.\n+\t(TYPE_FOR_JAVA): Likewise.\n+\t(FUNCTION_ARG_CHAIN): Remove parenthesis.\n+\t(FUNCTION_FIRST_USER_PARMTYPE): Add parenthesis.\n+\t(FUNCTION_FIRST_USER_PARAM): Likewise.\n+\t(PROMOTES_TO_AGGR_TYPE): Whitespace.\n+\t(DERIVED_FROM_P): Add parenthesis and wrap.\n+\t(UNIQUELY_DERIVED_FROM_P): Likewise.\n+\t(ACCESSIBLY_UNIQUELY_DERIVED_P): Likewise.\n+\t(PUBLICLY_UNIQUELY_DERIVED_P): Likewise.\n+\t(CLASSTYPE_USE_TEMPLATE): Whitespace.\n+\t(CLASSTYPE_INLINE_FRIENDS): Remove parenthesis.\n+\t(TYPE_GETS_DELETE): Add parenthesis.\n+\t(TYPE_HAS_CONVERSION): Add parenthesis and wrap.\n+\t(TYPE_HAS_ASSIGN_REF): Likewise,\n+\t(TYPE_HAS_CONST_ASSIGN_REF): Likewise.\n+\t(TYPE_HAS_INIT_REF): Likewise.\n+\t(TYPE_HAS_CONST_INIT_REF): Likewise.\n+\t(TYPE_BEING_DEFINED): Likewise.\n+\t(TYPE_LANG_SPECIFIC): Likewise.\n+\t(CLASSTYPE_RTTI): Likewise.\n+\t(TYPE_OVERLOADS_CALL_EXPR): Likewise.\n+\t(TYPE_OVERLOADS_ARRAY_REF): Likewise.\n+\t(TYPE_OVERLOADS_ARROW): Likewise.\n+\t(TYPE_USES_MULTIPLE_INHERITANCE): Likewise.\n+\t(TYPE_USES_VIRTUAL_BASECLASSES): Add parenthesis.\n+\t(CLASSTYPE_METHOD_VEC): Likewise.\n+\t(CLASSTYPE_MARKED_N): Likewise.\n+\t(CLASSTYPE_MARKED): Likewise.\n+\t(CLASSTYPE_MARKED2): Likewise.\n+\t(CLASSTYPE_MARKED3): Likewise.\n+\t(CLASSTYPE_MARKED4): Likewise.\n+\t(CLASSTYPE_MARKED5): Likewise.\n+\t(CLASSTYPE_MARKED6): Likewise.\n+\t(SET_CLASSTYPE_MARKED): Whitespace.\n+\t(CLEAR_CLASSTYPE_MARKED): Likewise.\n+\t(SET_CLASSTYPE_MARKED2): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED2): Likewise.\n+\t(SET_CLASSTYPE_MARKED3): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED3): Likewise.\n+\t(SET_CLASSTYPE_MARKED4): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED4): Likewise.\n+\t(SET_CLASSTYPE_MARKED5): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED5): Likewise.\n+\t(SET_CLASSTYPE_MARKED6): Likewise.\n+\t(CLEAR_CLASSTYPE_MARKED6): Likewise.\n+\t(CLASSTYPE_TAGS): Likewise.\n+\t(CLASSTYPE_VSIZE): Likewise.\n+\t(CLASSTYPE_VBASECLASSES): Likewise.\n+\t(CANONICAL_BINFO): Add parenthesis.\n+\t(CLASSTYPE_SIZE(NODE): Likewise.\n+\t(CLASSTYPE_SIZE_UNIT): Likewise.\n+\t(CLASSTYPE_ALIGN(NODE): Likewise.\n+\t(CLASSTYPE_USER_ALIGN): Likewise.\n+\t(TYPE_JAVA_INTERFACE): Likewise.\n+\t(CLASSTYPE_PURE_VIRTUALS): Likewise.\n+\t(CLASSTYPE_NEEDS_VIRTUAL_REINIT): Whitespace and wrap.\n+\t(TYPE_HAS_DEFAULT_CONSTRUCTOR): Likewise.\n+\t(CLASSTYPE_HAS_MUTABLE): Likewise.\n+\t(CLASSTYPE_FRIEND_CLASSES): Likewise. Likewise.\n+\t(CLASSTYPE_DECLARED_CLASS): Whitespace and wrap.\n+\t(CLASSTYPE_READONLY_FIELDS_NEED_INIT): Likewise.\n+\t(CLASSTYPE_REF_FIELDS_NEED_INIT): Likewise.\n+\t(CLASSTYPE_INTERFACE_ONLY): Likewise.\n+\t(CLASSTYPE_INTERFACE_KNOWN): Likewise.\n+\t(CLASSTYPE_INTERFACE_UNKNOWN): Likewise.\n+\t(SET_CLASSTYPE_INTERFACE_UNKNOWN_X): Likewise.\n+\t(SET_CLASSTYPE_INTERFACE_UNKNOWN): Likewise.\n+\t(SET_CLASSTYPE_INTERFACE_KNOWN): Likewise.\n+\t(CLASSTYPE_DEBUG_REQUESTED): Whitespace and wrap.\n+\t(BINFO_UNSHARED_MARKED): Whitespace.\n+\t(BINFO_MARKED): Whitespace and wrap.\n+\t(SET_BINFO_MARKED): Likewise.\n+\t(CLEAR_BINFO_MARKED): Likewise.\n+\t(BINFO_VTABLE_PATH_MARKED): Likewise.\n+\t(SET_BINFO_VTABLE_PATH_MARKED): Likewise.\n+\t(CLEAR_BINFO_VTABLE_PATH_MARKED): Likewise.\n+\t(BINFO_SUBVTT_INDEX): Remove parenthesis.\n+\t(BINFO_VPTR_INDEX): Likewise.\n+\t(BINFO_PRIMARY_BASE_OF): Likewise,\n+\t(CLASSTYPE_VFIELDS): Whitespace.\n+\t(VF_DERIVED_VALUE): Wrap long line.\n+\t(NAMESPACE_LEVEL): Whitespace.\n+        (CAN_HAVE_FULL_LANG_DECL_P): Remove parenthesis.\n+        (DEFARG_POINTER): Whitespace.\n+        (DECL_NEEDED_P): Remove parenthesis.\n+        (DECL_LANGUAGE): Whitespace.\n+        (SET_DECL_LANGUAGE): Add parenthesis.\n+        (DECL_CONSTRUCTOR_P): Whitespace and wrap.\n+        (DECL_OVERLOADED_OPERATOR_P): Remove parenthesis.\n+        (DECL_IN_AGGR_P): Whitespace.\n+        (DECL_FRIEND_P): Likewise.\n+        (DECL_BEFRIENDING_CLASSES): Likewise.\n+        (DECL_STATIC_FUNCTION_P): Whitespace and wrap.\n+        (DECL_NONCONVERTING_P): Whitespace.\n+        (DECL_PURE_VIRTUAL_P): Likewise.\n+        (DECL_NEEDS_FINAL_OVERRIDER_P): Likewise.\n+        (DECL_PENDING_INLINE_INFO): Whitespace.\n+        (DECL_SORTED_FIELDS): Likewise.\n+        (DECL_DEFERRED_FN): Likewise.\n+        (DECL_TEMPLATE_INFO): Likewise.\n+        (CLASSTYPE_TEMPLATE_INFO): Whitespace and wrap.\n+        (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO); Likewise.\n+        (SET_TYPE_TEMPLATE_INFO): Add parenthesis.\n+        (TMPL_ARGS_LEVEL): Likewise.\n+        (SET_TMPL_ARGS_LEVEL): Likewise.\n+        (INNERMOST_TEMPLATE_PARMS): Whitespace.\n+        (C_TYPEDEF_EXPLICITLY_SIGNED): Uppercase macro parameter.\n+        (INTEGRAL_CODE_P(CODE): Add parenthesis.\n+        (CP_INTEGRAL_TYPE_P): Remove parenthesis.\n+        (TYPE_HAS_CONSTRUCTOR): Whitespace.\n+        (TREE_HAS_CONSTRUCTOR): Likewise.\n+        (TYPE_HAS_DESTRUCTOR): Likewise.\n+        (TYPE_HAS_REAL_ASSIGN_REF): Likewise.\n+        (TYPE_HAS_COMPLEX_ASSIGN_REF): Likewise.\n+        (TYPE_HAS_ABSTRACT_ASSIGN_REF): Likewise.\n+        (TYPE_HAS_COMPLEX_INIT_REF): Likewise.\n+        (TYPE_HAS_NONTRIVIAL_DESTRUCTOR): Likewise.\n+        (TYPE_PTRMEMFUNC_P): Likewise.\n+        (TYPE_PTRMEMFUNC_FLAG): Likewise.\n+        (TYPE_GET_PTRMEMFUNC_TYPE): Likewise.\n+        (TYPE_SET_PTRMEMFUNC_TYPE): Likewise.\n+        (TYPE_PTRMEM_CLASS_TYPE): Remove paranthesis.\n+        (TYPE_PTRMEM_POINTED_TO_TYPE): Likewise.\n+        (DECL_ACCESS): Whitespace.\n+        (DECL_GLOBAL_CTOR_P): Remove paranthesis.\n+        (DECL_GLOBAL_DTOR_P): Likewise.\n+        (GLOBAL_INIT_PRIORITY): Likewise.\n+\t(DECL_TEMPLATE_PARMS): Likewise.\n+        (DECL_TEMPLATE_RESULT): Likewise.\n+        (DECL_TEMPLATE_INSTANTIATIONS): Likewise.\n+        (DECL_TEMPLATE_SPECIALIZATIONS): Likewise.\n+        (DECL_IMPLICIT_TYPEDEF_P): Remove parenthesis.\n+        (SET_DECL_IMPLICIT_TYPEDEF_P): Likewise.\n+        (PRIMARY_TEMPLATE_P): Add parenthesis.\n+        (DECL_USE_TEMPLATE): Whitespace.\n+        (CLASSTYPE_IMPLICIT_INSTANTIATION): Likewise.\n+        (SET_CLASSTYPE_IMPLICIT_INSTANTIATION): Likewise.\n+        (CLASSTYPE_EXPLICIT_INSTANTIATION): Likewise.\n+        (SET_CLASSTYPE_EXPLICIT_INSTANTIATION): Likewise.\n+        (CALL_DECLARATOR_PARMS): Remove parenthesis.\n+        (CALL_DECLARATOR_QUALS): Likewise.\n+        (CALL_DECLARATOR_EXCEPTION_SPEC): Likewise.\n+        (TEMP_NAME_P): Wrap.\n+        (VFIELD_NAME_P): Likewise.\n+        (B_SET): Uppercase macro parameters and add parenthesis.\n+        (B_CLR): Likewise.\n+        (B_TST): Likewise.\n+        (LOOKUP_NAMESPACES_ONLY): Uppercase macro parameters.\n+        (LOOKUP_TYPES_ONLY): Uppercase macro parameters.\n+        (LOOKUP_QUALIFIERS_ONLY): Uppercase macro parameters.\n+        (same_or_base_type_p): Likewise.\n+        (cp_deprecated): Likewise.\n+\n 2002-01-05  Richard Henderson  <rth@redhat.com>\n \n         * semantics.c (expand_body): Revert last change."}, {"sha": "9538921a2eb9d399cdec4d031d9a8df33214ee50", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 309, "deletions": 252, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98e40e83636aaed6b6b66ad680e6419461d48dc0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98e40e83636aaed6b6b66ad680e6419461d48dc0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=98e40e83636aaed6b6b66ad680e6419461d48dc0", "patch": "@@ -154,27 +154,27 @@ Boston, MA 02111-1307, USA.  */\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n #define VAR_OR_FUNCTION_DECL_CHECK(NODE)\t\t\t\\\n-({  const tree __t = NODE;\t\t\t\t\t\\\n-    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+({  const tree __t = (NODE);\t\t\t\t\t\\\n+    enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != VAR_DECL && __c != FUNCTION_DECL)\t\t\\\n       tree_check_failed (__t, VAR_DECL, __FILE__, __LINE__,\t\\\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n #define VAR_FUNCTION_OR_PARM_DECL_CHECK(NODE)\t\t\t\\\n-({  const tree __t = NODE;\t\t\t\t\t\\\n-    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n-    if (__c != VAR_DECL\t\t\t\t\t\\\n-\t&& __c != FUNCTION_DECL\t\t\t\t\\\n+({  const tree __t = (NODE);\t\t\t\t\t\\\n+    enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n+    if (__c != VAR_DECL\t\t\t\t\t\t\\\n+\t&& __c != FUNCTION_DECL\t\t\t\t\t\\\n         && __c != PARM_DECL)\t\t\t\t\t\\\n       tree_check_failed (__t, VAR_DECL, __FILE__, __LINE__,\t\\\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n #define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\t\t\\\n-({  const tree __t = NODE;\t\t\t\t\t\\\n-    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n-    if (__c != VAR_DECL\t\t\t\t\t\\\n+({  const tree __t = (NODE);\t\t\t\t\t\\\n+    enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n+    if (__c != VAR_DECL\t\t\t\t\t\t\\\n \t&& __c != FUNCTION_DECL\t\t\t\t\t\\\n \t&& __c != TYPE_DECL\t\t\t\t\t\\\n \t&& __c != TEMPLATE_DECL)\t\t\t\t\\\n@@ -183,28 +183,28 @@ Boston, MA 02111-1307, USA.  */\n     __t; })\n \n #define RECORD_OR_UNION_TYPE_CHECK(NODE)\t\t\t\\\n-({  const tree __t = NODE;\t\t\t\t\t\\\n-    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+({  const tree __t = (NODE);\t\t\t\t\t\\\n+    enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != RECORD_TYPE && __c != UNION_TYPE)\t\t\\\n       tree_check_failed (__t, RECORD_TYPE, __FILE__, __LINE__,\t\\\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n #define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE)\t\t\\\n-({  const tree __t = NODE;\t\t\t\t\t\\\n-    enum tree_code __c = TREE_CODE(__t);\t\t\t\\\n+({  const tree __t = (NODE);\t\t\t\t\t\\\n+    enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != BOUND_TEMPLATE_TEMPLATE_PARM)\t\t\t\\\n       tree_check_failed (__t, BOUND_TEMPLATE_TEMPLATE_PARM,\t\\\n \t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     __t; })\n \n #else /* not ENABLE_TREE_CHECKING, or not gcc */\n \n-#define VAR_OR_FUNCTION_DECL_CHECK(NODE)\tNODE\n-#define VAR_FUNCTION_OR_PARM_DECL_CHECK(NODE)   NODE\n-#define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\tNODE\n-#define RECORD_OR_UNION_TYPE_CHECK(NODE)\tNODE\n-#define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE)\tNODE\n+#define VAR_OR_FUNCTION_DECL_CHECK(NODE)\t\t(NODE)\n+#define VAR_FUNCTION_OR_PARM_DECL_CHECK(NODE)   \t(NODE)\n+#define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\t(NODE)\n+#define RECORD_OR_UNION_TYPE_CHECK(NODE)\t\t(NODE)\n+#define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE)\t(NODE)\n \n #endif\n \n@@ -242,10 +242,10 @@ struct lang_identifier\n    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n    and C_RID_YYCODE is the token number wanted by Yacc.  */\n \n-#define C_IS_RESERVED_WORD(id) TREE_LANG_FLAG_5 (id)\n+#define C_IS_RESERVED_WORD(ID) TREE_LANG_FLAG_5 (ID)\n \n extern const short rid_to_yy[RID_MAX];\n-#define C_RID_YYCODE(id) rid_to_yy[C_RID_CODE (id)]\n+#define C_RID_YYCODE(ID) rid_to_yy[C_RID_CODE (ID)]\n \n #define LANG_IDENTIFIER_CAST(NODE) \\\n \t((struct lang_identifier*)IDENTIFIER_NODE_CHECK (NODE))\n@@ -277,57 +277,59 @@ typedef struct ptrmem_cst\n   struct tree_common common;\n   /* This isn't used, but the middle-end expects all constants to have\n      this field.  */\n-  struct rtx_def *rtl;\n+  rtx rtl;\n   tree member;\n }* ptrmem_cst_t;\n \n /* Nonzero if this binding is for a local scope, as opposed to a class\n    or namespace scope.  */\n-#define LOCAL_BINDING_P(NODE) TREE_LANG_FLAG_0(NODE)\n+#define LOCAL_BINDING_P(NODE) TREE_LANG_FLAG_0 (NODE)\n \n /* Nonzero if BINDING_VALUE is from a base class of the class which is\n    currently being defined.  */\n-#define INHERITED_VALUE_BINDING_P(NODE) TREE_LANG_FLAG_1(NODE)\n+#define INHERITED_VALUE_BINDING_P(NODE) TREE_LANG_FLAG_1 (NODE)\n \n /* For a binding between a name and an entity at a non-local scope,\n    defines the scope where the binding is declared.  (Either a class\n    _TYPE node, or a NAMESPACE_DECL.)  This macro should be used only\n    for namespace-level bindings; on the IDENTIFIER_BINDING list\n    BINDING_LEVEL is used instead.  */\n-#define BINDING_SCOPE(NODE) (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->scope.scope)\n+#define BINDING_SCOPE(NODE) \\\n+  (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->scope.scope)\n \n /* Nonzero if NODE has BINDING_LEVEL, rather than BINDING_SCOPE.  */\n-#define BINDING_HAS_LEVEL_P(NODE) TREE_LANG_FLAG_2 ((NODE))\n+#define BINDING_HAS_LEVEL_P(NODE) TREE_LANG_FLAG_2 (NODE)\n \n /* This is the declaration bound to the name. Possible values:\n    variable, overloaded function, namespace, template, enumerator.  */\n-#define BINDING_VALUE(NODE)    (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->value)\n+#define BINDING_VALUE(NODE) \\\n+  (((struct tree_binding*)CPLUS_BINDING_CHECK (NODE))->value)\n \n /* If name is bound to a type, this is the type (struct, union, enum).  */\n-#define BINDING_TYPE(NODE)     TREE_TYPE(NODE)\n+#define BINDING_TYPE(NODE)     TREE_TYPE (NODE)\n \n #define IDENTIFIER_GLOBAL_VALUE(NODE) \\\n-  namespace_binding (NODE, global_namespace)\n+  namespace_binding ((NODE), global_namespace)\n #define SET_IDENTIFIER_GLOBAL_VALUE(NODE, VAL) \\\n-  set_namespace_binding (NODE, global_namespace, VAL)\n+  set_namespace_binding ((NODE), global_namespace, (VAL))\n #define IDENTIFIER_NAMESPACE_VALUE(NODE) \\\n-  namespace_binding (NODE, current_namespace)\n+  namespace_binding ((NODE), current_namespace)\n #define SET_IDENTIFIER_NAMESPACE_VALUE(NODE, VAL) \\\n-  set_namespace_binding (NODE, current_namespace, VAL)\n+  set_namespace_binding ((NODE), current_namespace, (VAL))\n \n #define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (TRY_BLOCK_CHECK (NODE))\n #define CLEANUP_DECL(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n #define CLEANUP_EXPR(NODE)      TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n \n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n    sense of `same'.  */\n-#define same_type_p(type1, type2) \\\n-  comptypes ((type1), (type2), COMPARE_STRICT)\n+#define same_type_p(TYPE1, TYPE2) \\\n+  comptypes ((TYPE1), (TYPE2), COMPARE_STRICT)\n \n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n    top-level qualifiers.  */\n-#define same_type_ignoring_top_level_qualifiers_p(type1, type2) \\\n-  same_type_p (TYPE_MAIN_VARIANT (type1), TYPE_MAIN_VARIANT (type2))\n+#define same_type_ignoring_top_level_qualifiers_p(TYPE1, TYPE2) \\\n+  same_type_p (TYPE_MAIN_VARIANT (TYPE1), TYPE_MAIN_VARIANT (TYPE2))\n \n /* Non-zero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n@@ -352,17 +354,18 @@ struct tree_binding\n };\n \n /* The overloaded FUNCTION_DECL. */\n-#define OVL_FUNCTION(NODE)   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n-#define OVL_CHAIN(NODE)      TREE_CHAIN(NODE)\n+#define OVL_FUNCTION(NODE) \\\n+  (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n+#define OVL_CHAIN(NODE)      TREE_CHAIN (NODE)\n /* Polymorphic access to FUNCTION and CHAIN. */\n #define OVL_CURRENT(NODE)     \\\n-  ((TREE_CODE(NODE)==OVERLOAD) ? OVL_FUNCTION(NODE) : NODE)\n+  ((TREE_CODE (NODE) == OVERLOAD) ? OVL_FUNCTION (NODE) : (NODE))\n #define OVL_NEXT(NODE)        \\\n-  ((TREE_CODE(NODE)==OVERLOAD) ? TREE_CHAIN(NODE) : NULL_TREE)\n+  ((TREE_CODE (NODE) == OVERLOAD) ? TREE_CHAIN (NODE) : NULL_TREE)\n /* If set, this was imported in a using declaration.\n    This is not to confuse with being used somewhere, which\n    is not important for this node. */\n-#define OVL_USED(NODE)        TREE_USED(NODE)\n+#define OVL_USED(NODE)        TREE_USED (NODE)\n \n struct tree_overload\n {\n@@ -435,57 +438,60 @@ struct tree_srcloc\n    type. For namespace scope, the presence of a type in any namespace\n    is indicated with global_type_node, and the real type behind must\n    be found through lookup. */\n-#define IDENTIFIER_TYPE_VALUE(NODE) (identifier_type_value(NODE))\n-#define REAL_IDENTIFIER_TYPE_VALUE(NODE) (TREE_TYPE (NODE))\n-#define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = TYPE)\n+#define IDENTIFIER_TYPE_VALUE(NODE) identifier_type_value (NODE)\n+#define REAL_IDENTIFIER_TYPE_VALUE(NODE) TREE_TYPE (NODE)\n+#define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = (TYPE))\n #define IDENTIFIER_HAS_TYPE_VALUE(NODE) (IDENTIFIER_TYPE_VALUE (NODE) ? 1 : 0)\n \n-#define LANG_ID_FIELD(NAME,NODE)\t\t\t\\\n+#define LANG_ID_FIELD(NAME, NODE)\t\t\t\\\n   (LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\\\n    ? LANG_IDENTIFIER_CAST (NODE)->x->NAME : 0)\n \n-#define SET_LANG_ID(NODE,VALUE,NAME)\t\t\t\t\t  \\\n-  (LANG_IDENTIFIER_CAST (NODE)->x == 0\t\t\t\t  \\\n+#define SET_LANG_ID(NODE, VALUE, NAME)\t\t\t\t\t  \\\n+  (LANG_IDENTIFIER_CAST (NODE)->x == 0\t\t\t\t  \t  \\\n    ? LANG_IDENTIFIER_CAST (NODE)->x\t\t\t\t\t  \\\n       = (struct lang_id2 *)perm_calloc (1, sizeof (struct lang_id2)) : 0, \\\n    LANG_IDENTIFIER_CAST (NODE)->x->NAME = (VALUE))\n \n-#define IDENTIFIER_LABEL_VALUE(NODE)\t    LANG_ID_FIELD(label_value, NODE)\n-#define SET_IDENTIFIER_LABEL_VALUE(NODE,VALUE)   \\\n-\tSET_LANG_ID(NODE, VALUE, label_value)\n+#define IDENTIFIER_LABEL_VALUE(NODE) \\\n+  LANG_ID_FIELD (label_value, NODE)\n+#define SET_IDENTIFIER_LABEL_VALUE(NODE, VALUE)   \\\n+  SET_LANG_ID (NODE, VALUE, label_value)\n \n-#define IDENTIFIER_IMPLICIT_DECL(NODE)\t    LANG_ID_FIELD(implicit_decl, NODE)\n-#define SET_IDENTIFIER_IMPLICIT_DECL(NODE,VALUE) \\\n-\tSET_LANG_ID(NODE, VALUE, implicit_decl)\n+#define IDENTIFIER_IMPLICIT_DECL(NODE) \\\n+  LANG_ID_FIELD (implicit_decl, NODE)\n+#define SET_IDENTIFIER_IMPLICIT_DECL(NODE, VALUE) \\\n+  SET_LANG_ID (NODE, VALUE, implicit_decl)\n \n-#define IDENTIFIER_ERROR_LOCUS(NODE)\t    LANG_ID_FIELD(error_locus, NODE)\n-#define SET_IDENTIFIER_ERROR_LOCUS(NODE,VALUE)\t\\\n-\tSET_LANG_ID(NODE, VALUE, error_locus)\n+#define IDENTIFIER_ERROR_LOCUS(NODE) \\\n+  LANG_ID_FIELD (error_locus, NODE)\n+#define SET_IDENTIFIER_ERROR_LOCUS(NODE, VALUE)\t\\\n+  SET_LANG_ID (NODE, VALUE, error_locus)\n \n /* Nonzero if this identifier is used as a virtual function name somewhere\n    (optimizes searches).  */\n-#define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1(NODE)\n+#define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1 (NODE)\n \n /* Nonzero if this identifier is the prefix for a mangled C++ operator\n    name.  */\n-#define IDENTIFIER_OPNAME_P(NODE) TREE_LANG_FLAG_2(NODE)\n+#define IDENTIFIER_OPNAME_P(NODE) TREE_LANG_FLAG_2 (NODE)\n \n /* Nonzero if this identifier is the name of a type-conversion\n    operator.  */\n #define IDENTIFIER_TYPENAME_P(NODE) \\\n-  (TREE_LANG_FLAG_4 (NODE))\n+  TREE_LANG_FLAG_4 (NODE)\n \n /* Nonzero if this identifier is the name of a constructor or\n    destructor.  */\n #define IDENTIFIER_CTOR_OR_DTOR_P(NODE) \\\n   TREE_LANG_FLAG_3 (NODE)\n \n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n-#define C_TYPE_FIELDS_READONLY(type) TYPE_LANG_FLAG_0 (type)\n+#define C_TYPE_FIELDS_READONLY(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n \n /* Store a value in that field.  */\n-#define C_SET_EXP_ORIGINAL_CODE(exp, code) \\\n-  (TREE_COMPLEXITY (exp) = (int)(code))\n+#define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n+  (TREE_COMPLEXITY (EXP) = (int)(CODE))\n \f\n /* If non-zero, a VAR_DECL whose cleanup will cause a throw to the\n    next exception handler.  */\n@@ -1076,8 +1082,10 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define TYPE_NAME_STRING(NODE) (IDENTIFIER_POINTER (TYPE_IDENTIFIER (NODE)))\n #define TYPE_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (TYPE_IDENTIFIER (NODE)))\n \n-#define TYPE_ASSEMBLER_NAME_STRING(NODE) (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME  (NODE))))\n-#define TYPE_ASSEMBLER_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n+#define TYPE_ASSEMBLER_NAME_STRING(NODE) \\\n+  (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME  (NODE))))\n+#define TYPE_ASSEMBLER_NAME_LENGTH(NODE) \\\n+  (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n \n /* Nonzero if NODE has no name for linkage purposes.  */\n #define TYPE_ANONYMOUS_P(NODE) \\\n@@ -1091,12 +1099,12 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    template template parameters.  Despite its name,\n    this macro has nothing to do with the definition of aggregate given\n    in the standard.  Think of this macro as MAYBE_CLASS_TYPE_P.  */\n-#define IS_AGGR_TYPE(t)\t\t\t\t\\\n-  (TREE_CODE (t) == TEMPLATE_TYPE_PARM\t\t\\\n-   || TREE_CODE (t) == TYPENAME_TYPE\t\t\\\n-   || TREE_CODE (t) == TYPEOF_TYPE\t\t\\\n-   || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n-   || TYPE_LANG_FLAG_5 (t))\n+#define IS_AGGR_TYPE(T)\t\t\t\t\t\\\n+  (TREE_CODE (T) == TEMPLATE_TYPE_PARM\t\t\t\\\n+   || TREE_CODE (T) == TYPENAME_TYPE\t\t\t\\\n+   || TREE_CODE (T) == TYPEOF_TYPE\t\t\t\\\n+   || TREE_CODE (T) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n+   || TYPE_LANG_FLAG_5 (T))\n \n /* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or\n    union type.  */\n@@ -1105,22 +1113,22 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n \n /* Nonzero if T is a class type.  Zero for template type parameters,\n    typename types, and so forth.  */\n-#define CLASS_TYPE_P(t) \\\n-  (IS_AGGR_TYPE_CODE (TREE_CODE (t)) && IS_AGGR_TYPE (t))\n+#define CLASS_TYPE_P(T) \\\n+  (IS_AGGR_TYPE_CODE (TREE_CODE (T)) && IS_AGGR_TYPE (T))\n \n-#define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE)\n-#define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n+#define IS_AGGR_TYPE_CODE(T)\t((T) == RECORD_TYPE || (T) == UNION_TYPE)\n+#define IS_AGGR_TYPE_2(TYPE1, TYPE2) \\\n   (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n    && IS_AGGR_TYPE (TYPE1) && IS_AGGR_TYPE (TYPE2))\n-#define TAGGED_TYPE_P(t) \\\n-  (CLASS_TYPE_P (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n+#define TAGGED_TYPE_P(T) \\\n+  (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n #define IS_OVERLOAD_TYPE(T) TAGGED_TYPE_P (T)\n \n /* In a *_TYPE, nonzero means a built-in type.  */\n-#define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)\n+#define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6 (NODE)\n \n /* True if this a \"Java\" type, defined in 'extern \"Java\"'. */\n-#define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3(NODE)\n+#define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3 (NODE)\n \n /* Nonzero if this type is const-qualified.  */\n #define CP_TYPE_CONST_P(NODE)\t\t\t\t\\\n@@ -1143,33 +1151,37 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    == TYPE_QUAL_CONST)\n \n #define FUNCTION_ARG_CHAIN(NODE) \\\n-  (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n+  TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE)))\n \n /* Given a FUNCTION_DECL, returns the first TREE_LIST out of TYPE_ARG_TYPES\n    which refers to a user-written parameter.  */\n #define FUNCTION_FIRST_USER_PARMTYPE(NODE) \\\n-  (skip_artificial_parms_for (NODE, TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n+  skip_artificial_parms_for ((NODE), TYPE_ARG_TYPES (TREE_TYPE (NODE)))\n \n /* Similarly, but for DECL_ARGUMENTS.  */\n #define FUNCTION_FIRST_USER_PARM(NODE) \\\n-  (skip_artificial_parms_for (NODE, DECL_ARGUMENTS (NODE)))\n+  skip_artificial_parms_for ((NODE), DECL_ARGUMENTS (NODE))\n \n-#define PROMOTES_TO_AGGR_TYPE(NODE,CODE)\t\\\n+#define PROMOTES_TO_AGGR_TYPE(NODE, CODE)\t\\\n   (((CODE) == TREE_CODE (NODE)\t\t\t\\\n-       && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\\\n+    && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\t\\\n    || IS_AGGR_TYPE (NODE))\n \n /* Nonzero iff TYPE is derived from PARENT. Ignores accessibility and\n    ambiguity issues.  */\n-#define DERIVED_FROM_P(PARENT, TYPE) (lookup_base (TYPE, PARENT, ba_any, NULL))\n+#define DERIVED_FROM_P(PARENT, TYPE) \\\n+  lookup_base ((TYPE), PARENT, ba_any, NULL)\n /* Nonzero iff TYPE is uniquely derived from PARENT. Ignores\n    accessibility.  */\n-#define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (lookup_base (TYPE, PARENT, ba_ignore | ba_quiet, NULL))\n+#define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) \\\n+  lookup_base ((TYPE), (PARENT), ba_ignore | ba_quiet, NULL)\n /* Nonzero iff TYPE is accessible in the current scope and uniquely\n    derived from PARENT.  */\n-#define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (lookup_base (TYPE, PARENT, ba_check | ba_quiet, NULL))\n+#define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n+  lookup_base ((TYPE), (PARENT), ba_check | ba_quiet, NULL)\n /* Nonzero iff TYPE is publicly & uniquely derived from PARENT.  */\n-#define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (lookup_base (TYPE, PARENT,  ba_not_special | ba_quiet, NULL))\n+#define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n+  lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL)\n \f\n /* This structure provides additional information above and beyond\n    what is provide in the ordinary tree_type.  In the past, we used it\n@@ -1265,16 +1277,16 @@ struct lang_type\n      1=implicit template instantiation\n      2=explicit template specialization\n      3=explicit template instantiation  */\n-#define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC(NODE)->use_template)\n+#define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC (NODE)->use_template)\n \n /* Fields used for storing information before the class is defined.\n    After the class is defined, these fields hold other information.  */\n \n /* List of friends which were defined inline in this class definition.  */\n-#define CLASSTYPE_INLINE_FRIENDS(NODE) (CLASSTYPE_PURE_VIRTUALS (NODE))\n+#define CLASSTYPE_INLINE_FRIENDS(NODE) CLASSTYPE_PURE_VIRTUALS (NODE)\n \n /* Nonzero for _CLASSTYPE means that operator delete is defined.  */\n-#define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->gets_delete)\n+#define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC (NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n \n /* Nonzero if `new NODE[x]' should cause the allocation of extra\n@@ -1285,15 +1297,18 @@ struct lang_type\n \n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n-#define TYPE_HAS_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_type_conversion)\n+#define TYPE_HAS_CONVERSION(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_type_conversion)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n-#define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_assign_ref)\n-#define TYPE_HAS_CONST_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_const_assign_ref)\n+#define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_assign_ref)\n+#define TYPE_HAS_CONST_ASSIGN_REF(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_const_assign_ref)\n \n /* Nonzero means that this _CLASSTYPE node has an X(X&) constructor.  */\n-#define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_init_ref)\n-#define TYPE_HAS_CONST_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_const_init_ref)\n+#define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_init_ref)\n+#define TYPE_HAS_CONST_INIT_REF(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_const_init_ref)\n \n /* Nonzero if this class defines an overloaded operator new.  (An\n    operator new [] doesn't count.)  */\n@@ -1306,40 +1321,44 @@ struct lang_type\n \n /* Nonzero means that this type is being defined.  I.e., the left brace\n    starting the definition of this type has been seen.  */\n-#define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->being_defined)\n+#define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC (NODE)->being_defined)\n /* Nonzero means that this type has been redefined.  In this case, if\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n-#define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->redefined)\n+#define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC (NODE)->redefined)\n \n /* The is the basetype that contains NODE's rtti.  */\n-#define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC(NODE)->rtti)\n+#define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC (NODE)->rtti)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator().  */\n-#define TYPE_OVERLOADS_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_call_overloaded)\n+#define TYPE_OVERLOADS_CALL_EXPR(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_call_overloaded)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator[].  */\n-#define TYPE_OVERLOADS_ARRAY_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_array_ref_overloaded)\n+#define TYPE_OVERLOADS_ARRAY_REF(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_array_ref_overloaded)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator->.  */\n-#define TYPE_OVERLOADS_ARROW(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_arrow_overloaded)\n+#define TYPE_OVERLOADS_ARROW(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_arrow_overloaded)\n \n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    multiple inheritance.  If this is 0 for the root of a type\n    hierarchy, then we can use more efficient search techniques.  */\n-#define TYPE_USES_MULTIPLE_INHERITANCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->uses_multiple_inheritance)\n+#define TYPE_USES_MULTIPLE_INHERITANCE(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->uses_multiple_inheritance)\n \n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    virtual base classes.  If this is 0 for the root of a type\n    hierarchy, then we can use more efficient search techniques.  */\n-#define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3(NODE))\n+#define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3 (NODE))\n \n /* Vector member functions defined in this class.  Each element is\n    either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  All\n    functions with the same name end up in the same slot.  The first\n    two elements are for constructors, and destructors, respectively.\n    Any conversion operators are next, followed by ordinary member\n    functions.  There may be empty entries at the end of the vector.  */\n-#define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n+#define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC (NODE)->methods)\n \n /* The slot in the CLASSTYPE_METHOD_VEC where constructors go.  */\n #define CLASSTYPE_CONSTRUCTOR_SLOT 0\n@@ -1366,7 +1385,7 @@ struct lang_type\n /* Get the value of the Nth mark bit.  */\n #define CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n   (((CLASS_TYPE_P (NODE) ? TYPE_LANG_SPECIFIC (NODE)->marks\t\\\n-     : ((unsigned) TYPE_ALIAS_SET (NODE))) & (1 << N)) != 0)\n+     : ((unsigned) TYPE_ALIAS_SET (NODE))) & (1 << (N))) != 0)\n \n /* Set the Nth mark bit.  */\n #define SET_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n@@ -1381,32 +1400,32 @@ struct lang_type\n    : (void) (TYPE_ALIAS_SET (NODE) &= ~(1 << (N))))\n \n /* Get the value of the mark bits.  */\n-#define CLASSTYPE_MARKED(NODE) CLASSTYPE_MARKED_N(NODE, 0)\n-#define CLASSTYPE_MARKED2(NODE) CLASSTYPE_MARKED_N(NODE, 1)\n-#define CLASSTYPE_MARKED3(NODE) CLASSTYPE_MARKED_N(NODE, 2)\n-#define CLASSTYPE_MARKED4(NODE) CLASSTYPE_MARKED_N(NODE, 3)\n-#define CLASSTYPE_MARKED5(NODE) CLASSTYPE_MARKED_N(NODE, 4)\n-#define CLASSTYPE_MARKED6(NODE) CLASSTYPE_MARKED_N(NODE, 5)\n+#define CLASSTYPE_MARKED(NODE) CLASSTYPE_MARKED_N (NODE, 0)\n+#define CLASSTYPE_MARKED2(NODE) CLASSTYPE_MARKED_N (NODE, 1)\n+#define CLASSTYPE_MARKED3(NODE) CLASSTYPE_MARKED_N (NODE, 2)\n+#define CLASSTYPE_MARKED4(NODE) CLASSTYPE_MARKED_N (NODE, 3)\n+#define CLASSTYPE_MARKED5(NODE) CLASSTYPE_MARKED_N (NODE, 4)\n+#define CLASSTYPE_MARKED6(NODE) CLASSTYPE_MARKED_N (NODE, 5)\n \n /* Macros to modify the above flags */\n-#define SET_CLASSTYPE_MARKED(NODE)    SET_CLASSTYPE_MARKED_N(NODE, 0)\n-#define CLEAR_CLASSTYPE_MARKED(NODE)  CLEAR_CLASSTYPE_MARKED_N(NODE, 0)\n-#define SET_CLASSTYPE_MARKED2(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 1)\n-#define CLEAR_CLASSTYPE_MARKED2(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 1)\n-#define SET_CLASSTYPE_MARKED3(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 2)\n-#define CLEAR_CLASSTYPE_MARKED3(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 2)\n-#define SET_CLASSTYPE_MARKED4(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 3)\n-#define CLEAR_CLASSTYPE_MARKED4(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 3)\n-#define SET_CLASSTYPE_MARKED5(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 4)\n-#define CLEAR_CLASSTYPE_MARKED5(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 4)\n-#define SET_CLASSTYPE_MARKED6(NODE)   SET_CLASSTYPE_MARKED_N(NODE, 5)\n-#define CLEAR_CLASSTYPE_MARKED6(NODE) CLEAR_CLASSTYPE_MARKED_N(NODE, 5)\n+#define SET_CLASSTYPE_MARKED(NODE)    SET_CLASSTYPE_MARKED_N (NODE, 0)\n+#define CLEAR_CLASSTYPE_MARKED(NODE)  CLEAR_CLASSTYPE_MARKED_N (NODE, 0)\n+#define SET_CLASSTYPE_MARKED2(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 1)\n+#define CLEAR_CLASSTYPE_MARKED2(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 1)\n+#define SET_CLASSTYPE_MARKED3(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 2)\n+#define CLEAR_CLASSTYPE_MARKED3(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 2)\n+#define SET_CLASSTYPE_MARKED4(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 3)\n+#define CLEAR_CLASSTYPE_MARKED4(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 3)\n+#define SET_CLASSTYPE_MARKED5(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 4)\n+#define CLEAR_CLASSTYPE_MARKED5(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 4)\n+#define SET_CLASSTYPE_MARKED6(NODE)   SET_CLASSTYPE_MARKED_N (NODE, 5)\n+#define CLEAR_CLASSTYPE_MARKED6(NODE) CLEAR_CLASSTYPE_MARKED_N (NODE, 5)\n \n /* A list of the nested tag-types (class, struct, union, or enum)\n    found within this class.  The TREE_PURPOSE of each node is the name\n    of the type; the TREE_VALUE is the type itself.  This list includes\n    nested member class templates.  */\n-#define CLASSTYPE_TAGS(NODE)\t\t(TYPE_LANG_SPECIFIC(NODE)->tags)\n+#define CLASSTYPE_TAGS(NODE)\t\t(TYPE_LANG_SPECIFIC (NODE)->tags)\n \n /* Nonzero if NODE has a primary base class, i.e., a base class with\n    which it shares the virtual function table pointer.  */\n@@ -1421,7 +1440,7 @@ struct lang_type\n \n /* The number of virtual functions present in this class' virtual\n    function table.  */\n-#define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)\n+#define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC (NODE)->vsize)\n \n /* A chain of BINFOs for the direct and indirect virtual base classes\n    that this type uses in a post-order depth-first left-to-right\n@@ -1431,39 +1450,39 @@ struct lang_type\n    list are all \"real\"; they are the same BINFOs that will be\n    encountered when using dfs_unmarked_real_bases_queue_p and related\n    functions.  */\n-#define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n+#define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC (NODE)->vbases)\n \n /* For a non-virtual BINFO, the BINFO itself; for a virtual BINFO, the\n    binfo_for_vbase.  C is the most derived class for the hierarchy\n    containing BINFO.  */\n #define CANONICAL_BINFO(BINFO, C)\t\t\\\n   (TREE_VIA_VIRTUAL (BINFO)\t\t\t\\\n    ? binfo_for_vbase (BINFO_TYPE (BINFO), C)\t\\\n-   : BINFO)\n+   : (BINFO))\n \n /* Number of direct baseclasses of NODE.  */\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n \n /* These are the size and alignment of the type without its virtual\n    base classes, for when we use this type as a base itself.  */\n-#define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n-#define CLASSTYPE_SIZE_UNIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->size_unit)\n-#define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->align)\n-#define CLASSTYPE_USER_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->user_align)\n+#define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC (NODE)->size)\n+#define CLASSTYPE_SIZE_UNIT(NODE) (TYPE_LANG_SPECIFIC (NODE)->size_unit)\n+#define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC (NODE)->align)\n+#define CLASSTYPE_USER_ALIGN(NODE) (TYPE_LANG_SPECIFIC (NODE)->user_align)\n \n /* The alignment of NODE, without its virtual bases, in bytes.  */\n #define CLASSTYPE_ALIGN_UNIT(NODE) \\\n   (CLASSTYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n /* True if this a Java interface type, declared with \n    '__attribute__ ((java_interface))'. */\n-#define TYPE_JAVA_INTERFACE(NODE) (TYPE_LANG_SPECIFIC(NODE)->java_interface)\n+#define TYPE_JAVA_INTERFACE(NODE) (TYPE_LANG_SPECIFIC (NODE)->java_interface)\n \n /* A cons list of virtual functions which cannot be inherited by\n    derived classes.  When deriving from this type, the derived\n    class must provide its own definition for each of these functions.  */\n-#define CLASSTYPE_PURE_VIRTUALS(NODE) (TYPE_LANG_SPECIFIC(NODE)->pure_virtuals)\n+#define CLASSTYPE_PURE_VIRTUALS(NODE) (TYPE_LANG_SPECIFIC (NODE)->pure_virtuals)\n \n /* Nonzero means that this aggr type has been `closed' by a semicolon.  */\n #define CLASSTYPE_GOT_SEMICOLON(NODE) (TYPE_LANG_SPECIFIC (NODE)->got_semicolon)\n@@ -1472,13 +1491,15 @@ struct lang_type\n    set because base constructors have placed the wrong value there.\n    If this is zero, it means that they placed the right value there,\n    and there is no need to change it.  */\n-#define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->needs_virtual_reinit)\n+#define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->needs_virtual_reinit)\n \n /* Nonzero means that this type has an X() constructor.  */\n-#define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_default_ctor)\n+#define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->has_default_ctor)\n \n /* Nonzero means that this type contains a mutable member */\n-#define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_mutable)\n+#define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n /*  Nonzero means that this class type is a non-POD class.  */\n@@ -1492,45 +1513,51 @@ struct lang_type\n /* A list of class types of which this type is a friend.  The\n    TREE_VALUE is normally a TYPE, but will be a TEMPLATE_DECL in the\n    case of a template friend.  */\n-#define CLASSTYPE_FRIEND_CLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->friend_classes)\n+#define CLASSTYPE_FRIEND_CLASSES(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->friend_classes)\n \n /* A list of the classes which grant friendship to this class.  */\n #define CLASSTYPE_BEFRIENDING_CLASSES(NODE) \\\n   (TYPE_LANG_SPECIFIC (NODE)->befriending_classes)\n \n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n-#define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->declared_class)\n+#define CLASSTYPE_DECLARED_CLASS(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->declared_class)\n \n /* Nonzero if this class has const members which have no specified initialization.  */\n-#define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->const_needs_init)\n+#define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->const_needs_init)\n \n /* Nonzero if this class has ref members which have no specified initialization.  */\n-#define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->ref_needs_init)\n+#define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->ref_needs_init)\n \n /* Nonzero if this class is included from a header file which employs\n    `#pragma interface', and it is not included in its implementation file.  */\n-#define CLASSTYPE_INTERFACE_ONLY(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_only)\n+#define CLASSTYPE_INTERFACE_ONLY(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->interface_only)\n \n /* True if we have already determined whether or not vtables, VTTs,\n    typeinfo, and other similar per-class data should be emitted in\n    this translation unit.  This flag does not indicate whether or not\n    these items should be emitted; it only indicates that we know one\n    way or the other.  */\n #define CLASSTYPE_INTERFACE_KNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown == 0)\n+  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown == 0)\n /* The opposite of CLASSTYPE_INTERFANCE_KNOWN.  */\n #define CLASSTYPE_INTERFACE_UNKNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown)\n+  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown)\n \n #define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = !!(X))\n+  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown = !!(X))\n #define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 1)\n+  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown = 1)\n #define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 0)\n+  (TYPE_LANG_SPECIFIC (NODE)->interface_unknown = 0)\n \n /* Nonzero if a _DECL node requires us to output debug info for this class.  */\n-#define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->debug_requested)\n+#define CLASSTYPE_DEBUG_REQUESTED(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->debug_requested)\n \f\n /* Additional macros for inheritance information.  */\n \n@@ -1547,20 +1574,37 @@ struct lang_type\n \n /* Mark the binfo, whether shared or not. Each instance of a virtual\n    base can be separately marked.  */\n-#define BINFO_UNSHARED_MARKED(NODE) TREE_LANG_FLAG_0(NODE)\n+#define BINFO_UNSHARED_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \n /* Nonzero means marked by DFS or BFS search.  */\n-#define BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED(BINFO_TYPE(NODE)):TREE_LANG_FLAG_0(NODE))\n+#define BINFO_MARKED(NODE)\t\t\t\\\n+  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n+   ? CLASSTYPE_MARKED (BINFO_TYPE (NODE))\t\\\n+   : TREE_LANG_FLAG_0 (NODE))\n /* Macros needed because of C compilers that don't allow conditional\n    expressions to be lvalues.  Grr!  */\n-#define SET_BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_0(NODE)=1))\n-#define CLEAR_BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_0(NODE)=0))\n+#define SET_BINFO_MARKED(NODE)\t\t\t\\\n+  (TREE_VIA_VIRTUAL(NODE)\t\t\t\\\n+   ? SET_CLASSTYPE_MARKED (BINFO_TYPE (NODE))\t\\\n+   : (TREE_LANG_FLAG_0 (NODE) = 1))\n+#define CLEAR_BINFO_MARKED(NODE)\t\t\\\n+  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n+   ? CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (NODE))\t\\\n+   : (TREE_LANG_FLAG_0 (NODE) = 0))\n \n /* Nonzero means that this class is on a path leading to a new vtable.  */\n-#define BINFO_VTABLE_PATH_MARKED(NODE) \\\n-  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):TREE_LANG_FLAG_3(NODE))\n-#define SET_BINFO_VTABLE_PATH_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_3(NODE)=1))\n-#define CLEAR_BINFO_VTABLE_PATH_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_3(NODE)=0))\n+#define BINFO_VTABLE_PATH_MARKED(NODE)\t\t\\\n+  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n+   ? CLASSTYPE_MARKED3 (BINFO_TYPE (NODE))\t\\\n+   : TREE_LANG_FLAG_3 (NODE))\n+#define SET_BINFO_VTABLE_PATH_MARKED(NODE)\t\\\n+  (TREE_VIA_VIRTUAL(NODE)\t\t\t\\\n+   ? SET_CLASSTYPE_MARKED3 (BINFO_TYPE (NODE))\t\\\n+   : (TREE_LANG_FLAG_3 (NODE) = 1))\n+#define CLEAR_BINFO_VTABLE_PATH_MARKED(NODE)\t\\\n+  (TREE_VIA_VIRTUAL (NODE)\t\t\t\\\n+   ? CLEAR_CLASSTYPE_MARKED3 (BINFO_TYPE (NODE))\\\n+   : (TREE_LANG_FLAG_3 (NODE) = 0))\n \n /* Nonzero means B (a BINFO) has its own vtable.  Under the old ABI,\n    secondary vtables are sometimes shared.  Any copies will not have\n@@ -1575,7 +1619,8 @@ struct lang_type\n    derived class and never become non-primary.)  */\n #define SET_BINFO_NEW_VTABLE_MARKED(B, C)\t\t\t\t \\\n   (BINFO_NEW_VTABLE_MARKED (B, C) = 1,\t\t\t\t\t \\\n-   my_friendly_assert (!BINFO_PRIMARY_P (B) || TREE_VIA_VIRTUAL (B), 20000517),\t\t \\\n+   my_friendly_assert (!BINFO_PRIMARY_P (B)\t\t\t\t \\\n+\t\t       || TREE_VIA_VIRTUAL (B), 20000517),\t\t \\\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n \t\t       20000517))\n \n@@ -1595,17 +1640,17 @@ struct lang_type\n \n /* The index in the VTT where this subobject's sub-VTT can be found.\n    NULL_TREE if there is no sub-VTT.  */\n-#define BINFO_SUBVTT_INDEX(NODE) TREE_VEC_ELT ((NODE), 8)\n+#define BINFO_SUBVTT_INDEX(NODE) TREE_VEC_ELT (NODE, 8)\n \n /* The index in the VTT where the vptr for this subobject can be\n    found.  NULL_TREE if there is no secondary vptr in the VTT.  */\n-#define BINFO_VPTR_INDEX(NODE) TREE_VEC_ELT ((NODE), 9)\n+#define BINFO_VPTR_INDEX(NODE) TREE_VEC_ELT (NODE, 9)\n \n /* The binfo of which NODE is a primary base.  (This is different from\n    BINFO_INHERITANCE_CHAIN for virtual base because a virtual base is\n    sometimes a primary base for a class for which it is not an\n    immediate base.)  */\n-#define BINFO_PRIMARY_BASE_OF(NODE) TREE_VEC_ELT ((NODE), 10)\n+#define BINFO_PRIMARY_BASE_OF(NODE) TREE_VEC_ELT (NODE, 10)\n \n /* Nonzero if this binfo has lost its primary base binfo (because that\n    is a nearly-empty virtual base that has been taken by some other\n@@ -1627,7 +1672,7 @@ struct lang_type\n    TREE_PURPOSE is NULL.  Otherwise, the TREE_PURPOSE is the BINFO for\n    the class containing the vfield.  The TREE_VALUE is the class where\n    the vfield was first defined.  */\n-#define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC(NODE)->vfields)\n+#define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC (NODE)->vfields)\n \n /* Get the assoc info that caused this vfield to exist.  */\n #define VF_BINFO_VALUE(NODE) TREE_PURPOSE (NODE)\n@@ -1636,7 +1681,8 @@ struct lang_type\n #define VF_BASETYPE_VALUE(NODE) TREE_VALUE (NODE)\n \n /* Get the value of the top-most type dominating the non-`normal' vfields.  */\n-#define VF_DERIVED_VALUE(NODE) (VF_BINFO_VALUE (NODE) ? BINFO_TYPE (VF_BINFO_VALUE (NODE)) : NULL_TREE)\n+#define VF_DERIVED_VALUE(NODE) \\\n+  (VF_BINFO_VALUE (NODE) ? BINFO_TYPE (VF_BINFO_VALUE (NODE)) : NULL_TREE)\n \n /* The number of bytes by which to adjust the `this' pointer when\n    calling this virtual function.  */\n@@ -1673,18 +1719,18 @@ struct lang_type\n \n /* The binding level associated with the namespace.  */\n #define NAMESPACE_LEVEL(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->decl_flags.u.level)\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.u.level)\n \f\n \n /* If a DECL has DECL_LANG_SPECIFIC, it is either a lang_decl_flags or\n    a lang_decl (which has lang_decl_flags as its initial prefix).\n    This macro is nonzero for tree nodes whose DECL_LANG_SPECIFIC is\n    the full lang_decl, and not just lang_decl_flags.  */\n #define CAN_HAVE_FULL_LANG_DECL_P(NODE)\t\t\\\n-  (!(TREE_CODE ((NODE)) == VAR_DECL\t\t\\\n-     || TREE_CODE ((NODE)) == CONST_DECL\t\\\n-     || TREE_CODE ((NODE)) == FIELD_DECL\t\\\n-     || TREE_CODE ((NODE)) == USING_DECL))\n+  (!(TREE_CODE (NODE) == VAR_DECL\t\t\\\n+     || TREE_CODE (NODE) == CONST_DECL\t\t\\\n+     || TREE_CODE (NODE) == FIELD_DECL\t\t\\\n+     || TREE_CODE (NODE) == USING_DECL))\n \n struct lang_decl_flags\n {\n@@ -1770,7 +1816,7 @@ struct lang_decl\n   } u2;\n };\n \n-#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.id.str)\n+#define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK (NODE)->identifier.id.str)\n \n /* DECL_NEEDED_P holds of a declaration when we need to emit its\n    definition.  This is true when the back-end tells us that\n@@ -1779,11 +1825,11 @@ struct lang_decl\n    just been used somewhere, even if it's not really needed.  We need\n    anything that isn't comdat, but we don't know for sure whether or\n    not something is comdat until end-of-file.  */\n-#define DECL_NEEDED_P(DECL)\t\t\t\t\t\t\\\n-  ((at_eof && TREE_PUBLIC (DECL) && !DECL_COMDAT (DECL))\t\t\\\n-   || (DECL_ASSEMBLER_NAME_SET_P (DECL)\t\t\t\t\t\\\n-       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME ((DECL))))\t\\\n-   || (flag_syntax_only && TREE_USED ((DECL))))\n+#define DECL_NEEDED_P(DECL)\t\t\t\t\t\\\n+  ((at_eof && TREE_PUBLIC (DECL) && !DECL_COMDAT (DECL))\t\\\n+   || (DECL_ASSEMBLER_NAME_SET_P (DECL)\t\t\t\t\\\n+       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)))\t\\\n+   || (flag_syntax_only && TREE_USED (DECL)))\n \n /* Non-zero iff DECL is memory-based.  The DECL_RTL of\n    certain const variables might be a CONST_INT, or a REG\n@@ -1804,16 +1850,17 @@ struct lang_decl\n    we do create DECL_LANG_SPECIFIC for variables with non-C++ linkage.  */\n #define DECL_LANGUAGE(NODE) \t\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE) \t\t\t\t\\\n-   ? DECL_LANG_SPECIFIC(NODE)->decl_flags.language\t\\\n+   ? DECL_LANG_SPECIFIC (NODE)->decl_flags.language\t\\\n    : (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\\\n       ? lang_c : lang_cplusplus))\n \n /* Set the language linkage for NODE to LANGUAGE.  */\n #define SET_DECL_LANGUAGE(NODE, LANGUAGE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.language = LANGUAGE)\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.language = (LANGUAGE))\n \n /* For FUNCTION_DECLs: nonzero means that this function is a constructor.  */\n-#define DECL_CONSTRUCTOR_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_attr)\n+#define DECL_CONSTRUCTOR_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.constructor_attr)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a complete\n    object.  */\n@@ -1914,7 +1961,7 @@ struct lang_decl\n    value of ERROR_MARK is zero, this macro can be used as a predicate\n    to test whether or not NODE is an overloaded operator.  */\n #define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n-  (IDENTIFIER_OPNAME_P (DECL_NAME ((NODE)))\t\t\\\n+  (IDENTIFIER_OPNAME_P (DECL_NAME (NODE))\t\t\\\n    ? DECL_LANG_SPECIFIC (NODE)->u2.operator_code : ERROR_MARK)\n \n /* Non-zero if NODE is an assignment operator.  */\n@@ -1936,7 +1983,7 @@ struct lang_decl\n    detecting circularity in case members are multiply defined.  In the\n    case of a VAR_DECL, it is also used to determine how program storage\n    should be allocated.  */\n-#define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3(NODE))\n+#define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3 (NODE))\n \n /* Nonzero if the DECL was initialized in the class definition itself,\n    rather than outside the class.  */\n@@ -1946,15 +1993,16 @@ struct lang_decl\n /* Nonzero for FUNCTION_DECL means that this decl is just a\n    friend declaration, and should not be added to the list of\n    member functions for this class.  */\n-#define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.friend_attr)\n+#define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.friend_attr)\n \n /* A TREE_LIST of the types which have befriended this FUNCTION_DECL.  */\n #define DECL_BEFRIENDING_CLASSES(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->befriending_classes)\n+  (DECL_LANG_SPECIFIC (NODE)->befriending_classes)\n \n /* Nonzero for FUNCTION_DECL means that this decl is a static\n    member function.  */\n-#define DECL_STATIC_FUNCTION_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.static_function)\n+#define DECL_STATIC_FUNCTION_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.static_function)\n \n /* Nonzero for FUNCTION_DECL means that this decl is a non-static\n    member function.  */\n@@ -1992,15 +2040,18 @@ struct lang_decl\n \n /* Nonzero for _DECL means that this constructor is a non-converting\n    constructor.  */\n-#define DECL_NONCONVERTING_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.nonconverting)\n+#define DECL_NONCONVERTING_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.nonconverting)\n \n /* Nonzero for FUNCTION_DECL means that this member function is a pure\n    virtual function.  */\n-#define DECL_PURE_VIRTUAL_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.pure_virtual)\n+#define DECL_PURE_VIRTUAL_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.pure_virtual)\n \n /* Nonzero for FUNCTION_DECL means that this member function\n    must be overridden by derived classes.  */\n-#define DECL_NEEDS_FINAL_OVERRIDER_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.needs_final_overrider)\n+#define DECL_NEEDS_FINAL_OVERRIDER_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.needs_final_overrider)\n \n /* Nonzero if NODE is a thunk, rather than an ordinary function.  */\n #define DECL_THUNK_P(NODE)\t\t\t\\\n@@ -2120,25 +2171,26 @@ struct lang_decl\n /* If DECL_PENDING_INLINE_P holds, this is the saved text of the\n    function.  */\n #define DECL_PENDING_INLINE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.pending_inline_info)\n+  (DECL_LANG_SPECIFIC (NODE)->u.pending_inline_info)\n \n /* For a TYPE_DECL: if this function has many fields, we'll sort them\n    and put them into a TREE_VEC. */\n #define DECL_SORTED_FIELDS(NODE) \\\n-\t(DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.sorted_fields)\n+  (DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.sorted_fields)\n \n /* True if on the deferred_fns (see decl2.c) list.  */\n #define DECL_DEFERRED_FN(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->decl_flags.deferred)\n+  (DECL_LANG_SPECIFIC (DECL)->decl_flags.deferred)\n \n /* For a VAR_DECL, FUNCTION_DECL, TYPE_DECL or TEMPLATE_DECL:\n    template-specific information.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC(VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK (NODE))->decl_flags.u.template_info)\n+  (DECL_LANG_SPECIFIC (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK (NODE)) \\\n+   ->decl_flags.u.template_info)\n \n /* Template information for a RECORD_TYPE or UNION_TYPE.  */\n #define CLASSTYPE_TEMPLATE_INFO(NODE) \\\n-  (TYPE_LANG_SPECIFIC(RECORD_OR_UNION_TYPE_CHECK (NODE))->template_info)\n+  (TYPE_LANG_SPECIFIC (RECORD_OR_UNION_TYPE_CHECK (NODE))->template_info)\n \n /* Template information for an ENUMERAL_TYPE.  Although an enumeration may\n    not be a primary template, it may be declared within the scope of a\n@@ -2148,7 +2200,7 @@ struct lang_decl\n \n /* Template information for a template template parameter.  */\n #define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) \\\n-  (TYPE_LANG_SPECIFIC(BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK (NODE)) \\\n+  (TYPE_LANG_SPECIFIC (BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK (NODE)) \\\n    ->template_info)\n \n /* Template information for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n@@ -2165,8 +2217,8 @@ struct lang_decl\n    UNION_TYPE to VAL.  */\n #define SET_TYPE_TEMPLATE_INFO(NODE, VAL)\t\\\n   (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\\\n-   ? (ENUM_TEMPLATE_INFO (NODE) = VAL)\t\t\\\n-   : (CLASSTYPE_TEMPLATE_INFO (NODE) = VAL))\n+   ? (ENUM_TEMPLATE_INFO (NODE) = (VAL))\t\\\n+   : (CLASSTYPE_TEMPLATE_INFO (NODE) = (VAL)))\n \n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n #define TI_ARGS(NODE) (TREE_VALUE (NODE))\n@@ -2187,7 +2239,7 @@ struct lang_decl\n /* Non-zero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */\n #define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \\\n-  (NODE != NULL_TREE\t\t\t\t\t\t\\\n+  ((NODE) != NULL_TREE\t\t\t\t\t\t\\\n    && TREE_CODE (NODE) == TREE_VEC\t\t\t\t\\\n    && TREE_VEC_LENGTH (NODE) > 0\t\t\t\t\\\n    && TREE_VEC_ELT (NODE, 0) != NULL_TREE\t\t\t\\\n@@ -2205,12 +2257,12 @@ struct lang_decl\n    args is level 1, not level 0.  */\n #define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n   (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS)\t\\\n-   ? TREE_VEC_ELT ((ARGS), (LEVEL) - 1) : ARGS)\n+   ? TREE_VEC_ELT (ARGS, (LEVEL) - 1) : (ARGS))\n \n /* Set the LEVELth level of the template ARGS to VAL.  This macro does\n    not work with single-level argument vectors.  */\n #define SET_TMPL_ARGS_LEVEL(ARGS, LEVEL, VAL)\t\\\n-  (TREE_VEC_ELT ((ARGS), (LEVEL) - 1) = (VAL))\n+  (TREE_VEC_ELT (ARGS, (LEVEL) - 1) = (VAL))\n \n /* Accesses the IDXth parameter in the LEVELth level of the ARGS.  */\n #define TMPL_ARG(ARGS, LEVEL, IDX)\t\t\t\t\\\n@@ -2278,7 +2330,7 @@ struct lang_decl\n #define TYPE_TI_ARGS(NODE)\t\t\t\\\n   (TI_ARGS (TYPE_TEMPLATE_INFO (NODE)))\n \n-#define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE(NODE)\n+#define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE (NODE)\n \n /* Nonzero if the NODE corresponds to the template parameters for a\n    member template, whose inline definition is being processed after\n@@ -2366,7 +2418,7 @@ extern int flag_new_for_scope;\n   (DECL_LANG_SPECIFIC (DECL_CHECK (NODE))->decl_flags.anticipated_p)\n \n /* Record whether a typedef for type `int' was actually `signed int'.  */\n-#define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n+#define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n /* Returns non-zero if DECL has external linkage, as specified by the\n    language standard.  (This predicate may hold even when the\n@@ -2376,7 +2428,7 @@ extern int flag_new_for_scope;\n   (decl_linkage (DECL) == lk_external)\n \n #define INTEGRAL_CODE_P(CODE) \\\n-  (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)\n+  ((CODE) == INTEGER_TYPE || (CODE) == ENUMERAL_TYPE || (CODE) == BOOLEAN_TYPE)\n \n /* [basic.fundamental]\n \n@@ -2386,8 +2438,8 @@ extern int flag_new_for_scope;\n    Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n    types as well, which is incorrect in C++.  */\n #define CP_INTEGRAL_TYPE_P(TYPE)\t\t\\\n-  (TREE_CODE ((TYPE)) == BOOLEAN_TYPE\t\t\\\n-   || TREE_CODE ((TYPE)) == INTEGER_TYPE)\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE\t\t\\\n+   || TREE_CODE (TYPE) == INTEGER_TYPE)\n \n /* [basic.fundamental]\n \n@@ -2398,7 +2450,7 @@ extern int flag_new_for_scope;\n \n /* Nonzero for _TYPE means that the _TYPE defines\n    at least one constructor.  */\n-#define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1(NODE))\n+#define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n \n /* When appearing in an INDIRECT_REF, it means that the tree structure\n    underneath is actually a call to a constructor.  This is needed\n@@ -2414,14 +2466,14 @@ extern int flag_new_for_scope;\n \n    When appearing in a FIELD_DECL, it means that this field\n    has been duly initialized in its constructor.  */\n-#define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4(NODE))\n+#define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))\n \n #define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR\t   \\\n \t\t\t\t   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE \\\n \t\t\t\t   && ! TREE_HAS_CONSTRUCTOR (NODE))\n \n /* Nonzero for _TYPE means that the _TYPE defines a destructor.  */\n-#define TYPE_HAS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_2(NODE))\n+#define TYPE_HAS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_2 (NODE))\n \n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n@@ -2431,10 +2483,10 @@ extern int flag_new_for_scope;\n   (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n-#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_real_assign_ref)\n-#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_complex_assign_ref)\n-#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_abstract_assign_ref)\n-#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_complex_init_ref)\n+#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_real_assign_ref)\n+#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_complex_assign_ref)\n+#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_abstract_assign_ref)\n+#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_complex_init_ref)\n \n /* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n \n@@ -2455,7 +2507,7 @@ extern int flag_new_for_scope;\n    involve a call to a destructor.  This can apply to objects of\n    ARRAY_TYPE is the type of the elements needs a destructor.  */\n #define TYPE_HAS_NONTRIVIAL_DESTRUCTOR(NODE) \\\n-  (TYPE_LANG_FLAG_4(NODE))\n+  (TYPE_LANG_FLAG_4 (NODE))\n \n /* Nonzero for class type means that copy initialization of this type can use\n    a bitwise copy.  */\n@@ -2488,12 +2540,12 @@ extern int flag_new_for_scope;\n /* Nonzero for _TYPE node means that this type is a pointer to member\n    function type.  */\n #define TYPE_PTRMEMFUNC_P(NODE)\t\t\\\n-  (TREE_CODE(NODE) == RECORD_TYPE\t\\\n-   && TYPE_LANG_SPECIFIC(NODE)\t\t\\\n+  (TREE_CODE (NODE) == RECORD_TYPE\t\\\n+   && TYPE_LANG_SPECIFIC (NODE)\t\t\\\n    && TYPE_PTRMEMFUNC_FLAG (NODE))\n \n #define TYPE_PTRMEMFUNC_FLAG(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->ptrmemfunc_flag)\n+  (TYPE_LANG_SPECIFIC (NODE)->ptrmemfunc_flag)\n \n /* Indicates when overload resolution may resolve to a pointer to\n    member function. [expr.unary.op]/3 */\n@@ -2537,8 +2589,10 @@ enum ptrmemfunc_vbit_where_t\n \n /* These are use to manipulate the canonical RECORD_TYPE from the\n    hashed POINTER_TYPE, and can only be used on the POINTER_TYPE.  */\n-#define TYPE_GET_PTRMEMFUNC_TYPE(NODE) ((tree)TYPE_LANG_SPECIFIC(NODE))\n-#define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) (TYPE_LANG_SPECIFIC(NODE) = ((struct lang_type *)(void*)(VALUE)))\n+#define TYPE_GET_PTRMEMFUNC_TYPE(NODE) \\\n+  ((tree)TYPE_LANG_SPECIFIC (NODE))\n+#define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) \\\n+  (TYPE_LANG_SPECIFIC (NODE) = ((struct lang_type *)(void*)(VALUE)))\n /* Returns the pfn field from a TYPE_PTRMEMFUNC_P.  */\n #define PFN_FROM_PTRMEMFUNC(NODE) pfn_from_ptrmemfunc ((NODE))\n \n@@ -2548,15 +2602,15 @@ enum ptrmemfunc_vbit_where_t\n    TYPE_PTRMEM_POINTED_TO_TYPE; there, the first parameter will have\n    type `const X*'.  */\n #define TYPE_PTRMEM_CLASS_TYPE(NODE)\t\t\t\\\n-  (TYPE_PTRMEM_P ((NODE))\t\t\t\t\\\n-   ? TYPE_OFFSET_BASETYPE (TREE_TYPE ((NODE)))\t\t\\\n-   : TYPE_PTRMEMFUNC_OBJECT_TYPE ((NODE)))\n+  (TYPE_PTRMEM_P (NODE)\t\t\t\t\t\\\n+   ? TYPE_OFFSET_BASETYPE (TREE_TYPE (NODE))\t\t\\\n+   : TYPE_PTRMEMFUNC_OBJECT_TYPE (NODE))\n \n /* For a pointer-to-member type of the form `T X::*', this is `T'.  */\n #define TYPE_PTRMEM_POINTED_TO_TYPE(NODE)\t\t\\\n-   (TYPE_PTRMEM_P ((NODE))\t\t\t\t\\\n+   (TYPE_PTRMEM_P (NODE)\t\t\t\t\\\n     ? TREE_TYPE (TREE_TYPE (NODE))\t\t\t\\\n-    : TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE ((NODE))))\n+    : TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (NODE)))\n \n /* For a pointer-to-member constant `X::Y' this is the RECORD_TYPE for\n    `X'.  */\n@@ -2620,22 +2674,22 @@ enum ptrmemfunc_vbit_where_t\n    For example, if a member that would normally be public in a\n    derived class is made protected, then the derived class and the\n    protected_access_node will appear in the DECL_ACCESS for the node.  */\n-#define DECL_ACCESS(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.u2.access)\n+#define DECL_ACCESS(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.u2.access)\n \n /* Nonzero if the FUNCTION_DECL is a global constructor.  */\n #define DECL_GLOBAL_CTOR_P(NODE) \\\n-  (DECL_LANG_SPECIFIC ((NODE))->decl_flags.global_ctor_p)\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.global_ctor_p)\n \n /* Nonzero if the FUNCTION_DECL is a global destructor.  */\n #define DECL_GLOBAL_DTOR_P(NODE) \\\n-  (DECL_LANG_SPECIFIC ((NODE))->decl_flags.global_dtor_p)\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.global_dtor_p)\n \n /* If DECL_GLOBAL_CTOR_P or DECL_GLOBAL_DTOR_P holds, this macro\n    returns the initialization priority for the function.  Constructors\n    with lower numbers should be run first.  Destructors should be run\n    in the reverse order of constructors.  */\n #define GLOBAL_INIT_PRIORITY(NODE) \\\n-  (DECL_LANG_SPECIFIC ((NODE))->decl_flags.u2.init_priority)\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.u2.init_priority)\n \n /* Accessor macros for C++ template decl nodes.  */\n \n@@ -2650,13 +2704,13 @@ enum ptrmemfunc_vbit_where_t\n    TEMPLATE_PARM_INDEX for the parameter is avilable as the\n    DECL_INITIAL (for a PARM_DECL) or as the TREE_TYPE (for a\n    TYPE_DECL).  */\n-#define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n+#define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS (NODE)\n #define DECL_INNERMOST_TEMPLATE_PARMS(NODE) \\\n    INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (NODE))\n #define DECL_NTPARMS(NODE) \\\n    TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (NODE))\n /* For function, method, class-data templates.  */\n-#define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT_FLD(NODE)\n+#define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT_FLD (NODE)\n /* For a static member variable template, the\n    DECL_TEMPLATE_INSTANTIATIONS list contains the explicitly and\n    implicitly generated instantiations of the variable.  There are no\n@@ -2682,7 +2736,7 @@ enum ptrmemfunc_vbit_where_t\n    <class U> struct S1<T>::S2'.\n \n    This list is not used for function templates.  */\n-#define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n+#define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX (NODE)\n /* For a function template, the DECL_TEMPLATE_SPECIALIZATIONS lists\n    contains all instantiations and specializations of the function,\n    including partial instantiations.  For a partial instantiation\n@@ -2713,7 +2767,7 @@ enum ptrmemfunc_vbit_where_t\n    for the partial specialization.\n \n    This list is not used for static variable templates.  */\n-#define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n+#define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE (NODE)\n \n /* Nonzero for a DECL which is actually a template parameter.  */\n #define DECL_TEMPLATE_PARM_P(NODE)\t\t\\\n@@ -2753,9 +2807,9 @@ enum ptrmemfunc_vbit_where_t\n    itself, so that you can say `S::S'.  This macro does *not* hold for\n    those typedefs.  */\n #define DECL_IMPLICIT_TYPEDEF_P(NODE) \\\n-  (TREE_CODE ((NODE)) == TYPE_DECL && DECL_LANG_FLAG_2 ((NODE)))\n+  (TREE_CODE (NODE) == TYPE_DECL && DECL_LANG_FLAG_2 (NODE))\n #define SET_DECL_IMPLICIT_TYPEDEF_P(NODE) \\\n-  (DECL_LANG_FLAG_2 ((NODE)) = 1)\n+  (DECL_LANG_FLAG_2 (NODE) = 1)\n \n /* A `primary' template is one that has its own template header.  A\n    member function of a class template is a template, but not primary.\n@@ -2766,7 +2820,7 @@ enum ptrmemfunc_vbit_where_t\n   (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)))\n \n /* Returns non-zero if NODE is a primary template.  */\n-#define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == NODE)\n+#define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == (NODE))\n \n #define CLASSTYPE_TEMPLATE_LEVEL(NODE) \\\n   (TREE_INT_CST_LOW (TREE_PURPOSE (CLASSTYPE_TI_TEMPLATE (NODE))))\n@@ -2777,7 +2831,7 @@ enum ptrmemfunc_vbit_where_t\n      1=implicit template instantiation\n      2=explicit template specialization, e.g. int min<int> (int, int);\n      3=explicit template instantiation, e.g. template int min<int> (int, int);  */\n-#define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.use_template)\n+#define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.use_template)\n \n #define DECL_TEMPLATE_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) & 1)\n #define CLASSTYPE_TEMPLATE_INSTANTIATION(NODE) \\\n@@ -2793,16 +2847,16 @@ enum ptrmemfunc_vbit_where_t\n #define DECL_IMPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) == 1)\n #define SET_DECL_IMPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) = 1)\n #define CLASSTYPE_IMPLICIT_INSTANTIATION(NODE) \\\n-  (CLASSTYPE_USE_TEMPLATE(NODE) == 1)\n+  (CLASSTYPE_USE_TEMPLATE (NODE) == 1)\n #define SET_CLASSTYPE_IMPLICIT_INSTANTIATION(NODE) \\\n-  (CLASSTYPE_USE_TEMPLATE(NODE) = 1)\n+  (CLASSTYPE_USE_TEMPLATE (NODE) = 1)\n \n #define DECL_EXPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) == 3)\n #define SET_DECL_EXPLICIT_INSTANTIATION(NODE) (DECL_USE_TEMPLATE (NODE) = 3)\n #define CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n-  (CLASSTYPE_USE_TEMPLATE(NODE) == 3)\n+  (CLASSTYPE_USE_TEMPLATE (NODE) == 3)\n #define SET_CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n-  (CLASSTYPE_USE_TEMPLATE(NODE) = 3)\n+  (CLASSTYPE_USE_TEMPLATE (NODE) = 3)\n \n /* Non-zero if DECL is a friend function which is an instantiation\n    from the point of view of the compiler, but not from the point of\n@@ -2912,15 +2966,15 @@ enum ptrmemfunc_vbit_where_t\n \n /* The parameters for a call-declarator.  */\n #define CALL_DECLARATOR_PARMS(NODE) \\\n-  (TREE_PURPOSE (TREE_OPERAND ((NODE), 1)))\n+  (TREE_PURPOSE (TREE_OPERAND (NODE, 1)))\n \n /* The cv-qualifiers for a call-declarator.  */\n #define CALL_DECLARATOR_QUALS(NODE) \\\n-  (TREE_VALUE (TREE_OPERAND ((NODE), 1)))\n+  (TREE_VALUE (TREE_OPERAND (NODE, 1)))\n \n /* The exception-specification for a call-declarator.  */\n #define CALL_DECLARATOR_EXCEPTION_SPEC(NODE) \\\n-  (TREE_TYPE ((NODE)))\n+  (TREE_TYPE (NODE))\n \n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types { record_type, class_type, union_type, enum_type };\n@@ -3217,8 +3271,10 @@ extern varray_type local_classes;\n   && IDENTIFIER_POINTER (ID_NODE)[2] == 't' \\\n   && IDENTIFIER_POINTER (ID_NODE)[3] == JOINER)\n \n-#define TEMP_NAME_P(ID_NODE) (!strncmp (IDENTIFIER_POINTER (ID_NODE), AUTO_TEMP_NAME, sizeof (AUTO_TEMP_NAME)-1))\n-#define VFIELD_NAME_P(ID_NODE) (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, sizeof(VFIELD_NAME)-1))\n+#define TEMP_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), AUTO_TEMP_NAME, sizeof (AUTO_TEMP_NAME)-1))\n+#define VFIELD_NAME_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), VFIELD_NAME, sizeof(VFIELD_NAME)-1))\n \n /* For anonymous aggregate types, we need some sort of name to\n    hold on to.  In practice, this should not appear, but it should\n@@ -3272,9 +3328,9 @@ extern tree static_dtors;\n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n /* Some macros for char-based bitfields.  */\n-#define B_SET(a,x) (a[x>>3] |= (1 << (x&7)))\n-#define B_CLR(a,x) (a[x>>3] &= ~(1 << (x&7)))\n-#define B_TST(a,x) (a[x>>3] & (1 << (x&7)))\n+#define B_SET(A,X) ((A)[(X)>>3] |=  (1 << ((X)&7)))\n+#define B_CLR(A,X) ((A)[(X)>>3] &= ~(1 << ((X)&7)))\n+#define B_TST(A,X) ((A)[(X)>>3] &   (1 << ((X)&7)))\n \n /* These are uses as bits in flags passed to build_method_call\n    to control its error reporting behavior.\n@@ -3326,11 +3382,11 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define LOOKUP_PREFER_BOTH (6144)\n #define LOOKUP_TEMPLATES_EXPECTED (8192)\n \n-#define LOOKUP_NAMESPACES_ONLY(f)  \\\n-  (((f) & LOOKUP_PREFER_NAMESPACES) && !((f) & LOOKUP_PREFER_TYPES))\n-#define LOOKUP_TYPES_ONLY(f)  \\\n-  (!((f) & LOOKUP_PREFER_NAMESPACES) && ((f) & LOOKUP_PREFER_TYPES))\n-#define LOOKUP_QUALIFIERS_ONLY(f)     ((f) & LOOKUP_PREFER_BOTH)\n+#define LOOKUP_NAMESPACES_ONLY(F)  \\\n+  (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n+#define LOOKUP_TYPES_ONLY(F)  \\\n+  (!((F) & LOOKUP_PREFER_NAMESPACES) && ((F) & LOOKUP_PREFER_TYPES))\n+#define LOOKUP_QUALIFIERS_ONLY(F)     ((F) & LOOKUP_PREFER_BOTH)\n \n \n /* These flags are used by the conversion code.\n@@ -3404,8 +3460,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n /* Returns nonzero iff TYPE1 and TYPE2 are the same type, or if TYPE2\n    is derived from TYPE1, or if TYPE2 is a pointer (reference) to a\n    class derived from the type pointed to (referred to) by TYPE1.  */\n-#define same_or_base_type_p(type1, type2) \\\n-  comptypes ((type1), (type2), COMPARE_BASE)\n+#define same_or_base_type_p(TYPE1, TYPE2) \\\n+  comptypes ((TYPE1), (TYPE2), COMPARE_BASE)\n \n /* These macros are used to access a TEMPLATE_PARM_INDEX.  */\n #define TEMPLATE_PARM_INDEX_CAST(NODE) \\\n@@ -3786,11 +3842,12 @@ extern void cp_warning_at\tPARAMS ((const char *msgid, ...));\n extern void cp_pedwarn_at\tPARAMS ((const char *msgid, ...));\n \n /* XXX Not i18n clean.  */\n-#define cp_deprecated(str) \\\n- do { if (warn_deprecated) \\\n-        warning(\"%s is deprecated, please see the documentation for details\", \\\n-\t\tstr); \\\n- } while (0)\n+#define cp_deprecated(STR)\t\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\t\\\n+    if (warn_deprecated)\t\t\t\t\t\t\t\\\n+      warning (\"%s is deprecated, please see the documentation for details\",\t\\\n+\t       (STR));\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n /* in error.c */\n extern void init_error\t\t\t\tPARAMS ((void));"}]}