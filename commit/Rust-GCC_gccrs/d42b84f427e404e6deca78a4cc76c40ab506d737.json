{"sha": "d42b84f427e404e6deca78a4cc76c40ab506d737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQyYjg0ZjQyN2U0MDRlNmRlY2E3OGE0Y2M3NmM0MGFiNTA2ZDczNw==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@wdc.com", "date": "2019-12-22T00:28:20Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@gcc.gnu.org", "date": "2019-12-22T00:28:20Z"}, "message": "testsuite: Fix run-time tracking down of `libgcc_s'\n\nFix a catastrophic libgo testsuite failure in cross-compilation where\nthe shared `libgcc_s' library cannot be found by the loader at run time\nin build-tree testing and consequently all test cases fail the execution\nstage, giving output (here with the `x86_64-linux-gnu' host and the\n`riscv64-linux-gnu' target, with RISC-V QEMU in the Linux user emulation\nmode as the target board) like:\n\nspawn qemu-riscv64 -E LD_LIBRARY_PATH=.:.../riscv64-linux-gnu/lib64/lp64d/libgo/.libs ./a.exe\n./a.exe: error while loading shared libraries: libgcc_s.so.1: cannot open shared object file: No such file or directory\nFAIL: archive/tar\n\nTo do so rework `gcc-set-multilib-library-path' so as not to rely on the\n`rootme' TCL variable to have been preset in testsuite invocation, which\nonly works for the GCC test suites and not for library test suites, and\nalso use `remote_exec host' rather than `exec' to invoke the compiler in\ndetermination of `libgcc_s' locations, so that the solution works in\nremote testing as well while also avoiding the hardcoded limit of the\nexecutable's path length imposed by `exec'.\n\nThis is based on an observation that the multilib root directory can be\ndetermined by stripping out the multilib directory in effect as printed\nwith the `-print-multi-directory' option from the path produced by the\n`-print-file-name=' option.  And then individual full multilib paths can\nbe assembled for the other multilibs by appending their respective\nmultilib directories to the multilib root directory.\n\nUnlike with the old solution the full multilib paths are not checked for\nthe presence of the shared `libgcc_s' library there, but that is\nsupposed to be harmless.  Also the full multilib path for the multilib\nused with the compiler used for testing will now come first, which\nshould reduce run-time processing in the usual case.\n\nWith this change in place test output instead looks like:\n\nspawn qemu-riscv64 -E LD_LIBRARY_PATH=.:.../riscv64-linux-gnu/lib64/lp64d/libgo/.libs:..././gcc/lib64/lp64d:..././gcc/.:..././gcc/lib32/ilp32:..././gcc/lib32/ilp32d:..././gcc/lib64/lp64 ./a.exe\nPASS\nPASS: archive/tar\n\nNo summary comparison, because the libgo testsuite does not provide one\nin this configuration for some reason, however this change improves\noverall results from 0 PASSes and 159 FAILs to 133 PASSes and 26 FAILs.\n\n\tgcc/testsuite/\n\t* lib/gcc-defs.exp (gcc-set-multilib-library-path): Use\n\t`-print-file-name=' to determine the multilib root directory.\n\tUse `remote_exec host' rather than `exec' to invoke the\n\tcompiler.\n\nFrom-SVN: r279706", "tree": {"sha": "5083b9c0ff8d728b02df77c3ce51e6ef4ecee33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5083b9c0ff8d728b02df77c3ce51e6ef4ecee33b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d42b84f427e404e6deca78a4cc76c40ab506d737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d42b84f427e404e6deca78a4cc76c40ab506d737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d42b84f427e404e6deca78a4cc76c40ab506d737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d42b84f427e404e6deca78a4cc76c40ab506d737/comments", "author": null, "committer": null, "parents": [{"sha": "bcfcf777bd1449f3bdca10766c5044bae75f1b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcfcf777bd1449f3bdca10766c5044bae75f1b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcfcf777bd1449f3bdca10766c5044bae75f1b8b"}], "stats": {"total": 50, "additions": 36, "deletions": 14}, "files": [{"sha": "64a00be0399e08667f103b25e2649c22bdccfeb0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d42b84f427e404e6deca78a4cc76c40ab506d737/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d42b84f427e404e6deca78a4cc76c40ab506d737/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d42b84f427e404e6deca78a4cc76c40ab506d737", "patch": "@@ -1,3 +1,10 @@\n+2019-12-22  Maciej W. Rozycki  <macro@wdc.com>\n+\n+\t* lib/gcc-defs.exp (gcc-set-multilib-library-path): Use\n+\t`-print-file-name=' to determine the multilib root directory.\n+\tUse `remote_exec host' rather than `exec' to invoke the\n+\tcompiler.\n+\n 2019-12-21  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR fortran/93026"}, {"sha": "67f0883e7640ec3cdf46a0c3e75c1f71002a6767", "filename": "gcc/testsuite/lib/gcc-defs.exp", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d42b84f427e404e6deca78a4cc76c40ab506d737/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d42b84f427e404e6deca78a4cc76c40ab506d737/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp?ref=d42b84f427e404e6deca78a4cc76c40ab506d737", "patch": "@@ -324,29 +324,44 @@ proc dg-additional-files-options { options source } {\n # for COMPILER, including multilib directories.\n \n proc gcc-set-multilib-library-path { compiler } {\n-    global rootme\n+    set shlib_ext [get_shlib_extension]\n+    set options [lrange $compiler 1 end]\n+    set compiler [lindex $compiler 0]\n \n-    # ??? rootme will not be set when testing an installed compiler.\n-    # In that case, we should perhaps use some other method to find\n-    # libraries.\n-    if {![info exists rootme]} {\n+    set libgcc_s_x [remote_exec host \"$compiler\" \\\n+\t\t    \"$options -print-file-name=libgcc_s.${shlib_ext}\"]\n+    if { [lindex $libgcc_s_x 0] == 0 \\\n+\t && [set libgcc_s_dir [file dirname [lindex $libgcc_s_x 1]]] != \"\" } {\n+\tset libpath \":${libgcc_s_dir}\"\n+    } else {\n \treturn \"\"\n     }\n \n-    set libpath \":${rootme}\"\n-    set options [lrange $compiler 1 end]\n-    set compiler [lindex $compiler 0]\n-    if { [is_remote host] == 0 && [which $compiler] != 0 } {\n-\tforeach i \"[eval exec $compiler $options --print-multi-lib]\" {\n+    set multi_dir_x [remote_exec host \"$compiler\" \\\n+\t\t     \"$options -print-multi-directory\"]\n+    set multi_lib_x [remote_exec host \"$compiler\" \\\n+\t\t     \"$options -print-multi-lib\"]\n+    if { [lindex $multi_dir_x 0] == 0 && [lindex $multi_lib_x 0] == 0 } {\n+\tset multi_dir [string trim [lindex $multi_dir_x 1]]\n+\tset multi_lib [string trim [lindex $multi_lib_x 1]]\n+\tif { \"$multi_dir\" == \".\" } {\n+\t    set multi_root \"$libgcc_s_dir\"\n+\t} else {\n+\t    set multi_match [string last \"/$multi_dir\" \"$libgcc_s_dir\"]\n+\t    if { \"$multi_match\" < 0 } {\n+\t\treturn $libpath\n+\t    }\n+\t    set multi_root [string range \"$libgcc_s_dir\" \\\n+\t\t\t    0 [expr $multi_match - 1]]\n+\t}\n+\tforeach i \"$multi_lib\" {\n \t    set mldir \"\"\n \t    regexp -- \"\\[a-z0-9=_/\\.-\\]*;\" $i mldir\n \t    set mldir [string trimright $mldir \"\\;@\"]\n-\t    if { \"$mldir\" == \".\" } {\n+\t    if { \"$mldir\" == \"$multi_dir\" } {\n \t\tcontinue\n \t    }\n-\t    if { [llength [glob -nocomplain ${rootme}/${mldir}/libgcc_s*.so.*]] >= 1 } {\n-\t\tappend libpath \":${rootme}/${mldir}\"\n-\t    }\n+\t    append libpath \":${multi_root}/${mldir}\"\n \t}\n     }\n "}]}