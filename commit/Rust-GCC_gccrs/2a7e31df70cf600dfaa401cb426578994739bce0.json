{"sha": "2a7e31df70cf600dfaa401cb426578994739bce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3ZTMxZGY3MGNmNjAwZGZhYTQwMWNiNDI2NTc4OTk0NzM5YmNlMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-05T15:24:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-05T15:24:15Z"}, "message": "c-common.c, [...]: Fix comment typos.\n\n\t* c-common.c, cfgexpand.c, cgraphunit.c, defaults.h,\n\tet-forest.c, expr.c, gimplify.c, global.c, gthr-lynx.h,\n\thard-reg-set.h, modulo-sched.c, optabs.c, postreload-gcse.c,\n\ttree-data-ref.c, tree-flow.h, tree-if-conv.c, tree-inline.c,\n\ttree-sra.c, tree-ssa-loop-im.c, tree-ssa-loop-ivopts.c,\n\ttree-ssa-loop-niter.c, tree-ssa-operands.c,\n\ttree-ssa-operands.h, tree-ssa-propagate.c,\n\ttree-ssa-propagate.h, tree-ssa-threadupdate.c, value-prof.c,\n\tvec.c, vec.h: Fix comment typos.  Follow spelling conventions.\n\nFrom-SVN: r87104", "tree": {"sha": "db2d4b4b49c75785725db3dc511e5abdabfec0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2d4b4b49c75785725db3dc511e5abdabfec0c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a7e31df70cf600dfaa401cb426578994739bce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7e31df70cf600dfaa401cb426578994739bce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a7e31df70cf600dfaa401cb426578994739bce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7e31df70cf600dfaa401cb426578994739bce0/comments", "author": null, "committer": null, "parents": [{"sha": "2addf92620c2d652f72c4cb204fb46d980e784e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2addf92620c2d652f72c4cb204fb46d980e784e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2addf92620c2d652f72c4cb204fb46d980e784e5"}], "stats": {"total": 100, "additions": 56, "deletions": 44}, "files": [{"sha": "6dab2e77b8aaa77f88aeacb685b5276c081a3534", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -1,3 +1,15 @@\n+2004-09-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-common.c, cfgexpand.c, cgraphunit.c, defaults.h,\n+\tet-forest.c, expr.c, gimplify.c, global.c, gthr-lynx.h,\n+\thard-reg-set.h, modulo-sched.c, optabs.c, postreload-gcse.c,\n+\ttree-data-ref.c, tree-flow.h, tree-if-conv.c, tree-inline.c,\n+\ttree-sra.c, tree-ssa-loop-im.c, tree-ssa-loop-ivopts.c,\n+\ttree-ssa-loop-niter.c, tree-ssa-operands.c,\n+\ttree-ssa-operands.h, tree-ssa-propagate.c,\n+\ttree-ssa-propagate.h, tree-ssa-threadupdate.c, value-prof.c,\n+\tvec.c, vec.h: Fix comment typos.  Follow spelling conventions.\n+\n 2004-09-05  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-if-conv.c (gate_tree_if_conversion): Enable only if the"}, {"sha": "95116cd75ae89bad616cc1677ef3dca7f011012c", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -1444,7 +1444,7 @@ check_case_value (tree value)\n    type (ie. before the default conversion to int) of the switch testing\n    expression.\n    TYPE is the promoted type of the testing expression, and ORIG_TYPE is\n-   the type before promiting it.  CASE_LOW_P is a pointer to the lower\n+   the type before promoting it.  CASE_LOW_P is a pointer to the lower\n    bound of the case label, and CASE_HIGH_P is the upper bound or NULL\n    if the case is not a case range.\n    The caller has to make sure that we are not called with NULL for"}, {"sha": "d4456e3d52599289abef212b08533e73b88836c5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -606,7 +606,7 @@ defer_stack_allocation (tree var, bool toplevel)\n }\n \n /* A subroutine of expand_used_vars.  Expand one variable according to\n-   its flavour.  Variables to be placed on the stack are not actually\n+   its flavor.  Variables to be placed on the stack are not actually\n    expanded yet, merely recorded.  */\n \n static void"}, {"sha": "48cb2398f724afb0dd2b0bbe35baa52f85f70c24", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -1261,7 +1261,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n       max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n     }\n \n-  /* Make sure that function is small enought to be considered for inlining.  */\n+  /* Make sure that function is small enough to be considered for inlining.  */\n   if (!max_depth\n       || cgraph_estimate_size_after_inlining (1, node, node)  >= limit)\n     return;"}, {"sha": "4b9cf5db63cd8107a2b5d22c963aec8f12325bf3", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -627,7 +627,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) false\n #endif\n \n-/* True if the targets integer-comparision fucntions return { 0, 1, 2\n+/* True if the targets integer-comparision functions return { 0, 1, 2\n    } to indicate { <, ==, > }.  False if { -1, 0, 1 } is used\n    instead.  The libgcc routines are biased.  */\n #ifndef TARGET_LIB_INT_CMP_BIASED"}, {"sha": "1c5eb9ab5bd4f77aae2b704fb3649140689801fa", "filename": "gcc/et-forest.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -137,7 +137,7 @@ et_recomp_min (struct et_occ *occ)\n }\n \n #ifdef DEBUG_ET\n-/* Checks whether neighbourhood of OCC seems sane.  */\n+/* Checks whether neighborhood of OCC seems sane.  */\n \n static void\n et_check_occ_sanity (struct et_occ *occ)"}, {"sha": "4f4a9aa40020bba39b4901ff72205f42df055c4d", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -3596,7 +3596,7 @@ expand_assignment (tree to, tree from, int want_value)\n \t  if (bitsize >= GET_MODE_BITSIZE (GET_MODE (str_rtx)))\n \t    break;\n \n-\t  /* We can't handle fields split accross multiple entities.  */\n+\t  /* We can't handle fields split across multiple entities.  */\n \t  if (bitpos1 + bitsize > GET_MODE_BITSIZE (GET_MODE (str_rtx)))\n \t    break;\n \n@@ -6120,7 +6120,7 @@ expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,\n \n     case IMAGPART_EXPR:\n       /* The imaginary part of the complex number is always second.\n-\t The expresion is therefore always offset by the size of the\n+\t The expression is therefore always offset by the size of the\n \t scalar type.  */\n       offset = 0;\n       bitpos = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (exp)));"}, {"sha": "87f922c295f471e75c181bf12a5c1d04dad0e69e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -1008,7 +1008,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n \t  gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n \n-\t  /* All occurences of this decl in final gimplified code will be\n+\t  /* All occurrences of this decl in final gimplified code will be\n \t     replaced by indirection.  Setting DECL_VALUE_EXPR does two\n \t     things: First, it lets the rest of the gimplifier know what\n \t     replacement to use.  Second, it lets the debug info know \n@@ -3677,7 +3677,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n \tcase CONST_DECL:\n \t  /* If we require an lvalue, such as for ADDR_EXPR, retain the\n-\t     CONST_DECL node.  Otherwise the decl is replacable by its\n+\t     CONST_DECL node.  Otherwise the decl is replaceable by its\n \t     value.  */\n \t  /* ??? Should be == fb_lvalue, but ADDR_EXPR passes fb_either.  */\n \t  if (fallback & fb_lvalue)"}, {"sha": "5478cd1ba8ba2f48b09bff9402d558d7dddeaa57", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -2176,7 +2176,7 @@ check_earlyclobber (rtx insn)\n     }\n }\n \n-/* The function returns true if register classes C1 and C2 inetrsect.  */\n+/* The function returns true if register classes C1 and C2 intersect.  */\n \n static bool\n regclass_intersect (enum reg_class c1, enum reg_class c2)"}, {"sha": "1ff631d35c43ae630dcde8e0a3b2676ac80a7056", "filename": "gcc/gthr-lynx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fgthr-lynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fgthr-lynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-lynx.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -45,7 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    weak.  If the multi-threaded application includes iostream.h,\n    gthr-posix.h is included and pthread_create will be defined weak.\n    If pthead_create is weak its defining module in libc is not\n-   necessarly included in the link and the symbol is resolved to zero.\n+   necessarily included in the link and the symbol is resolved to zero.\n    Therefore the first call to it will crash.\n \n    Since -mthreads is a multilib switch on LynxOS we know that at this"}, {"sha": "397660c0d074ea1be18516914a205ce3ce3894aa", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -35,7 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the same format as a HARD_REG_SET.  To help make sure this is true,\n    we only try the widest fast integer mode (HOST_WIDEST_FAST_INT)\n    instead of all the smaller types.  This approach loses only if\n-   there are avery few registers and then only in the few cases where\n+   there are very few registers and then only in the few cases where\n    we have an array of HARD_REG_SETs, so it needn't be as complex as\n    it used to be.  */\n "}, {"sha": "1207c31aa4fccdf66b79fc44723b7fb1b9c40f7c", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -1938,7 +1938,7 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n   row = SMODULO (ps_i->cycle, ps->ii);\n \n   /* Find the first must follow and the last must precede\n-     and insert the node immediatly after the must precede\n+     and insert the node immediately after the must precede\n      but make sure that it there is no must follow after it.   */\n   for (next_ps_i = ps->rows[row];\n        next_ps_i;\n@@ -2007,7 +2007,7 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n   if (TEST_BIT (must_follow, next_node->cuid))\n     return false;\n \n-  /* Advace PS_I over its next_in_row in the doubly linked list.  */\n+  /* Advance PS_I over its next_in_row in the doubly linked list.  */\n   prev = ps_i->prev_in_row;\n   next = ps_i->next_in_row;\n "}, {"sha": "cc48ab539490e4ee0a7e47ba6e9ae648edaa5ad4", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -532,7 +532,7 @@ expand_doubleword_shift_condmove (enum machine_mode op1_mode, optab binoptab,\n    masked by it and shifts in the range [BITS_PER_WORD, SHIFT_MASK) will\n    fill with zeros or sign bits as appropriate.\n \n-   If SHIFT_MASK is BITS_PER_WORD - 1, this routine will synthesise\n+   If SHIFT_MASK is BITS_PER_WORD - 1, this routine will synthesize\n    a doubleword shift whose equivalent mask is BITS_PER_WORD * 2 - 1.\n    Doing this preserves semantics required by SHIFT_COUNT_TRUNCATED.\n    In all other cases, shifts by values outside [0, BITS_PER_UNIT * 2)"}, {"sha": "93d81c48241bf480146035e6d55a5ddf371e3bb7", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -86,7 +86,7 @@ static struct\n \n /* We need to keep a hash table of expressions.  The table entries are of\n    type 'struct expr', and for each expression there is a single linked\n-   list of occurences.  */\n+   list of occurrences.  */\n \n /* The table itself.  */\n static htab_t expr_table;\n@@ -107,7 +107,7 @@ struct expr\n static struct obstack expr_obstack;\n \n /* Occurrence of an expression.\n-   There is at most one occurence per basic block.  If a pattern appears\n+   There is at most one occurrence per basic block.  If a pattern appears\n    more than once, the last appearance is used.  */\n \n struct occr\n@@ -422,7 +422,7 @@ lookup_expr_in_table (rtx pat)\n }\n \f\n \n-/* Dump all expressions and occurences that are currently in the\n+/* Dump all expressions and occurrences that are currently in the\n    expression hash table to FILE.  */\n \n /* This helper is called via htab_traverse.  */"}, {"sha": "57f20bb730792326410669b3e5be63d79b0a9f19", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -44,7 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n        - polyhedron dependence\n      or with the chains of recurrences based representation,\n      \n-   - to define a knowledge base for storing the data dependeces \n+   - to define a knowledge base for storing the data dependences \n      information,\n      \n    - to define an interface to access this data."}, {"sha": "1efbbbd930f6c2a2fb61cbbeddea9e64e05fb0d2", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -605,7 +605,7 @@ struct tree_niter_desc\n \t\t\t   to false, then the other fields in this structure\n \t\t\t   should not be used; there is no guarantee that they\n \t\t\t   will be correct.  */\n-  tree may_be_zero;\t/* The booleand expression.  If it evaluates to true,\n+  tree may_be_zero;\t/* The boolean expression.  If it evaluates to true,\n \t\t\t   the loop will exit in the first iteration (i.e.\n \t\t\t   its latch will not be executed), even if the niter\n \t\t\t   field says otherwise.  */"}, {"sha": "da75585c0e4bc3e9345447640c3286240ae8837b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -949,7 +949,7 @@ ifc_temp_var (tree type, tree exp)\n   var = create_tmp_var (type, name);\n   add_referenced_tmp_var (var);\n \n-  /* Build new statement to assigne EXP to new variable.  */\n+  /* Build new statement to assign EXP to new variable.  */\n   stmt = build (MODIFY_EXPR, type, var, exp);\n \n   /* Get SSA name for the new variable and set make new statement"}, {"sha": "0200bfc5966d2128657ca29ce357f26600a56e57", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -1922,7 +1922,7 @@ walk_type_fields (tree type, walk_tree_fn func, void *data, void *htab)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       /* We have to worry about mutually recursive pointers.  These can't\n-\t be written in C.  They can in Ada.  It's pathlogical, but\n+\t be written in C.  They can in Ada.  It's pathological, but\n \t there's an ACATS test (c38102a) that checks it.  Deal with this\n \t by checking if we're pointing to another pointer, that one\n \t points to another pointer, that one does too, and we have no htab."}, {"sha": "dd5d9e500ed9aa406bced094437e8fc59c1e4b49", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -398,7 +398,7 @@ sra_elt_hash (const void *x)\n \n   /* Take into account everything back up the chain.  Given that chain\n      lengths are rarely very long, this should be acceptable.  If we\n-     truely identify this as a performance problem, it should work to\n+     truly identify this as a performance problem, it should work to\n      hash the pointer value \"e->parent\".  */\n   for (p = e->parent; p ; p = p->parent)\n     h = (h * 65521) ^ sra_hash_tree (p->element);"}, {"sha": "d05617db09ed315e27a36d0c5943af00604925d5", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -206,7 +206,7 @@ movement_possibility (tree stmt)\n }\n \n /* Suppose that operand DEF is used inside the LOOP.  Returns the outermost\n-   loop to that we could move the expresion using DEF if it did not have\n+   loop to that we could move the expression using DEF if it did not have\n    other operands, i.e. the outermost loop enclosing LOOP in that the value\n    of DEF is invariant.  */\n \n@@ -587,7 +587,7 @@ loop_commit_inserts (void)\n }\n \n /* Hoist the statements in basic block BB out of the loops prescribed by\n-   data stored in LIM_DATA structres associated with each statement.  Callback\n+   data stored in LIM_DATA structures associated with each statement.  Callback\n    for walk_dominator_tree.  */\n \n static void\n@@ -641,7 +641,7 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n }\n \n /* Hoist the statements out of the loops prescribed by data stored in\n-   LIM_DATA structres associated with each statement.*/\n+   LIM_DATA structures associated with each statement.*/\n \n static void\n move_computations (void)\n@@ -698,7 +698,7 @@ may_move_till (tree ref, tree *index, void *data)\n   return true;\n }\n \n-/* Forces statements definining (invariant) SSA names in expression EXPR to be\n+/* Forces statements defining (invariant) SSA names in expression EXPR to be\n    moved out of the LOOP.  ORIG_LOOP is the loop in that EXPR is used.  */\n \n static void\n@@ -1023,7 +1023,7 @@ rewrite_mem_refs (tree tmp_var, struct mem_ref *mem_refs)\n }\n \n /* Records request for store motion of memory reference REF from LOOP.\n-   MEM_REFS is the list of occurences of the reference REF inside LOOP;\n+   MEM_REFS is the list of occurrences of the reference REF inside LOOP;\n    these references are rewritten by a new temporary variable.\n    Exits from the LOOP are stored in EXITS, there are N_EXITS of them.\n    The initialization of the temporary variable is put to the preheader"}, {"sha": "ba588eb5104cc71be0d57d83282070ed84b24600", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -228,7 +228,7 @@ struct ivopts_data\n #define CONSIDER_ALL_CANDIDATES_BOUND \\\n   ((unsigned) PARAM_VALUE (PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND))\n \n-/* If there are more iv occurences, we just give up (it is quite unlikely that\n+/* If there are more iv occurrences, we just give up (it is quite unlikely that\n    optimizing such a loop would help, and it would take ages).  */\n \n #define MAX_CONSIDERED_USES \\"}, {"sha": "dd5fad9adb55a022d90ad055b37cfec5eb6f1e44", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -190,7 +190,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       /* We want to take care only of <=; this is easy,\n \t as in cases the overflow would make the transformation unsafe the loop\n \t does not roll.  Seemingly it would make more sense to want to take\n-\t care of <, as NE is more simmilar to it, but the problem is that here\n+\t care of <, as NE is more similar to it, but the problem is that here\n \t the transformation would be more difficult due to possibly infinite\n \t loops.  */\n       if (zero_p (step0))\n@@ -266,7 +266,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t obviously if the test for overflow during that transformation\n \t\t passed, we cannot overflow here.  Most importantly any\n \t\t loop with sharp end condition and step 1 falls into this\n-\t\t cathegory, so handling this case specially is definitely\n+\t\t category, so handling this case specially is definitely\n \t\t worth the troubles.  */\n \t      may_xform = boolean_true_node;\n \t    }"}, {"sha": "cf46d8ebefd0f028b45f8a08b5c36cfb02154e35", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -51,7 +51,7 @@ Boston, MA 02111-1307, USA.  */\n    get_stmt_operands() in the primary entry point. \n \n    The operand tree is the parsed by the various get_* routines which look \n-   through the stmt tree for the occurence of operands which may be of \n+   through the stmt tree for the occurrence of operands which may be of \n    interest, and calls are made to the append_* routines whenever one is \n    found.  There are 5 of these routines, each representing one of the \n    5 types of operands. Defs, Uses, Virtual Uses, Virtual May Defs, and \n@@ -1686,9 +1686,9 @@ copy_virtual_operands (tree dst, tree src)\n \n \n /* Specifically for use in DOM's expression analysis.  Given a store, we\n-   create an artifical stmt which looks like a load from the store, this can\n+   create an artificial stmt which looks like a load from the store, this can\n    be used to eliminate redundant loads.  OLD_OPS are the operands from the \n-   store stmt, and NEW_STMT is the new load which reperesent a load of the\n+   store stmt, and NEW_STMT is the new load which represents a load of the\n    values stored.  */\n \n void"}, {"sha": "ad0a916f9ba159f0c91e49bc0d3adfb4390f1ace", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -188,7 +188,7 @@ extern void create_ssa_artficial_load_stmt (stmt_operands_p, tree);\n \n \n /* This structure is used in the operand iterator loops.  It contains the \n-   items required to determine which operand is retreived next.  During\n+   items required to determine which operand is retrieved next.  During\n    optimization, this structure is scalarized, and any unused fields are \n    optimized away, resulting in little overhead.  */\n \n@@ -217,7 +217,7 @@ typedef struct ssa_operand_iterator_d\n #define SSA_OP_VUSE\t\t0x04\t/* VUSE operands.  */\n #define SSA_OP_VMAYUSE\t\t0x08\t/* USE portion of V_MAY_DEFS.  */\n #define SSA_OP_VMAYDEF\t\t0x10\t/* DEF portion of V_MAY_DEFS.  */\n-#define SSA_OP_VMUSTDEF\t\t0x20\t/* V_MUST_DEF defintions.  */\n+#define SSA_OP_VMUSTDEF\t\t0x20\t/* V_MUST_DEF definitions.  */\n \n /* These are commonly grouped operand flags.  */\n #define SSA_OP_VIRTUAL_USES\t(SSA_OP_VUSE | SSA_OP_VMAYUSE)"}, {"sha": "b72c789476ecf137f067def4197f6ce2d43dd210", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -68,7 +68,7 @@\n \n \tSSA_PROP_INTERESTING: S produces a value that can be computed\n \t    at compile time.  Its result can be propagated into the\n-\t    statements that feed from S.  Furhtermore, if S is a\n+\t    statements that feed from S.  Furthermore, if S is a\n \t    conditional jump, only the edge known to be taken is added\n \t    to the work list.  Edges that are known not to execute are\n \t    never simulated."}, {"sha": "6375f5bd6c6fc33613086002dd5efec7c632e1fb", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -40,7 +40,7 @@ enum ssa_prop_result {\n        returned by SSA_PROP_VISIT_STMT should be added to\n        INTERESTING_SSA_EDGES.  If the statement being visited is a\n        conditional jump, SSA_PROP_VISIT_STMT should indicate which edge\n-       out of the basic block should be marked exectuable.  */\n+       out of the basic block should be marked executable.  */\n     SSA_PROP_INTERESTING,\n \n     /* The statement produces a varying (i.e., useless) value and"}, {"sha": "36b8f335a8eb015e510d04bcb6ebd9dfaa95e114", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -208,7 +208,7 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n    to update dominator tree and SSA graph after such changes.\n \n    The key to keeping the SSA graph update managable is to duplicate\n-   the side effects occuring in BB so that those side effects still\n+   the side effects occurring in BB so that those side effects still\n    occur on the paths which bypass BB after redirecting edges.\n \n    We accomplish this by creating duplicates of BB and arranging for"}, {"sha": "3f9caeb223cdc7bc94ac269e7e771f05772e0d73", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -62,7 +62,7 @@ static struct value_prof_hooks *value_prof_hooks;\n    -- list of counters starting from the first one.  */\n \n /* For speculative prefetching, the range in that we do not prefetch (because\n-   we assume that it will be in cache anyway).  The assymetry between min and\n+   we assume that it will be in cache anyway).  The asymmetry between min and\n    max range is trying to reflect the fact that the sequential prefetching\n    of the data is commonly done directly by hardware.  Nevertheless, these\n    values are just a guess and should of course be target-specific.  */\n@@ -971,7 +971,7 @@ speculative_prefetching_transform (rtx insn)\n \n   /* We require that count is at least half of all; this means\n      that for the transformation to fire the value must be constant\n-     at least 50% of time (and 75% gives the garantee of usage).  */\n+     at least 50% of time (and 75% gives the guarantee of usage).  */\n   if (!rtx_equal_p (address, value) || 2 * count < all)\n     return false;\n "}, {"sha": "1f9ac2062822cd38ff555c044613696ff6eba6f5", "filename": "gcc/vec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -49,7 +49,7 @@ vec_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n /* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n    0.  If RESERVE < 0, increase the current allocation exponentially.\n    VEC can be NULL, in which case a new vector is created.  The\n-   vector's trailing array is at VEC_OFFSET offset and consistes of\n+   vector's trailing array is at VEC_OFFSET offset and consists of\n    ELT_SIZE sized elements.  */\n \n void *"}, {"sha": "9708b4823bf115b6c7f9a95240b653cbf42daebf", "filename": "gcc/vec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7e31df70cf600dfaa401cb426578994739bce0/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=2a7e31df70cf600dfaa401cb426578994739bce0", "patch": "@@ -30,7 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    interoperate with the GTY machinery.\n \n    Because of the different behaviour of objects and of pointers to\n-   objects, there are two flavours.  One to deal with a vector of\n+   objects, there are two flavors.  One to deal with a vector of\n    pointers to objects, and one to deal with a vector of objects\n    themselves.  Both of these pass pointers to objects around -- in\n    the former case the pointers are stored into the vector and in the\n@@ -277,7 +277,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Object\n    \n    Remove an element from the IXth position of V. Ordering of\n-   remaining elements is preserverd.  For pointer vectors returns the\n+   remaining elements is preserved.  For pointer vectors returns the\n    removed object.  This is an O(N) operation due to a memmove.  */\n \n #define VEC_ordered_remove(TDEF,V,I)\t\\"}]}