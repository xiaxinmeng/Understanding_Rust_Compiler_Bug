{"sha": "c2bd38e89276e521395d42410655af037ee0c3ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiZDM4ZTg5Mjc2ZTUyMTM5NWQ0MjQxMDY1NWFmMDM3ZWUwYzNlZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2001-12-13T00:43:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-13T00:43:51Z"}, "message": "builtins.c (expand_builtin_memset, [...]): Additional arguments TARGET and MODE.\n\n        * builtins.c (expand_builtin_memset, expand_builtin_memcpy,\n        expand_builtin_strcpy): Additional arguments TARGET and MODE.\n        (expand_builtin_bzero, expand_builtin_strcpy,\n        expand_builtin_strncpy, expand_builtin_bzero): Pass additional\n        TARGET and MODE parameters to the above functions.\n        (expand_builtin_memset, expand_builtin_memcpy): Optimize the\n        case where the LEN parameter is constant zero.\n        (expand_builtin_memcmp): No longer conditional on\n        HAVE_cmpstrsi.  Take an additional mode parameter.  Optimize\n        the cases where len is either constant zero or one.\n        Optimize to call to memcpy, even if the memcpy isn't inlined.\n        (expand_builtin_strncpy): Optimize to call memcpy, even if the\n        memcpy isn't inlined.\n        (expand_builtin_strcmp, expand_builtin_strncmp): Always attempt\n        to optimize to a call to memcmp.\n        (expand_builtin): expand_builtin_memcmp can always be called,\n        and pass the required parameters to expand_builtin_memcmp,\n        expand_builtin_memset, expand_builtin_memcpy and\n        expand_builtin_strcpy.\n\n        * gcc.c-torture/execute/string-opt-14.c: New test case.\n        * gcc.c-torture/execute/string-opt-15.c: New test case.\n\nFrom-SVN: r47960", "tree": {"sha": "d40d346c1448d1fbceadd76b947d2bb4312a9c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d40d346c1448d1fbceadd76b947d2bb4312a9c5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2bd38e89276e521395d42410655af037ee0c3ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bd38e89276e521395d42410655af037ee0c3ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2bd38e89276e521395d42410655af037ee0c3ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bd38e89276e521395d42410655af037ee0c3ed/comments", "author": null, "committer": null, "parents": [{"sha": "897bb55fe36f6908d336f79c9853f1dd16058790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/897bb55fe36f6908d336f79c9853f1dd16058790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/897bb55fe36f6908d336f79c9853f1dd16058790"}], "stats": {"total": 423, "additions": 291, "deletions": 132}, "files": [{"sha": "a6edc7b3cea0cc54efc87120245f64dba8b6d1b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2bd38e89276e521395d42410655af037ee0c3ed", "patch": "@@ -1,3 +1,25 @@\n+2001-12-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin_memset, expand_builtin_memcpy,\n+\texpand_builtin_strcpy): Additional arguments TARGET and MODE.\n+\t(expand_builtin_bzero, expand_builtin_strcpy,\n+\texpand_builtin_strncpy, expand_builtin_bzero): Pass additional\n+\tTARGET and MODE parameters to the above functions.\n+\t(expand_builtin_memset, expand_builtin_memcpy): Optimize the\n+\tcase where the LEN parameter is constant zero.\n+\t(expand_builtin_memcmp): No longer conditional on\n+\tHAVE_cmpstrsi.  Take an additional mode parameter.  Optimize\n+\tthe cases where len is either constant zero or one.\n+\tOptimize to call to memcpy, even if the memcpy isn't inlined.\n+\t(expand_builtin_strncpy): Optimize to call memcpy, even if the\n+\tmemcpy isn't inlined.\n+\t(expand_builtin_strcmp, expand_builtin_strncmp): Always attempt\n+\tto optimize to a call to memcmp.\n+\t(expand_builtin): expand_builtin_memcmp can always be called,\n+\tand pass the required parameters to expand_builtin_memcmp,\n+\texpand_builtin_memset, expand_builtin_memcpy and\n+\texpand_builtin_strcpy.\n+\n 2001-12-12  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config.gcc (arm-*-freebsd*): Add target."}, {"sha": "b6e19940b0df1246a2eaf43a66dab770496f7c73", "filename": "gcc/builtins.c", "status": "modified", "additions": 183, "deletions": 132, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c2bd38e89276e521395d42410655af037ee0c3ed", "patch": "@@ -101,9 +101,8 @@ static rtx expand_builtin_next_arg\tPARAMS ((tree));\n static rtx expand_builtin_va_start\tPARAMS ((int, tree));\n static rtx expand_builtin_va_end\tPARAMS ((tree));\n static rtx expand_builtin_va_copy\tPARAMS ((tree));\n-#ifdef HAVE_cmpstrsi\n-static rtx expand_builtin_memcmp\tPARAMS ((tree, tree, rtx));\n-#endif\n+static rtx expand_builtin_memcmp\tPARAMS ((tree, tree, rtx,\n+                                                 enum machine_mode));\n static rtx expand_builtin_strcmp\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strncmp\tPARAMS ((tree, rtx,\n@@ -118,15 +117,18 @@ static rtx expand_builtin_strspn\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strcspn\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_memcpy\tPARAMS ((tree));\n-static rtx expand_builtin_strcpy\tPARAMS ((tree));\n+static rtx expand_builtin_memcpy\tPARAMS ((tree, rtx,\n+                                                 enum machine_mode));\n+static rtx expand_builtin_strcpy\tPARAMS ((tree, rtx,\n+                                                 enum machine_mode));\n static rtx builtin_strncpy_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strncpy\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx builtin_memset_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n-static rtx expand_builtin_memset\tPARAMS ((tree));\n+static rtx expand_builtin_memset\tPARAMS ((tree, rtx,\n+                                                 enum machine_mode));\n static rtx expand_builtin_bzero\t\tPARAMS ((tree));\n static rtx expand_builtin_strlen\tPARAMS ((tree, rtx));\n static rtx expand_builtin_strstr\tPARAMS ((tree, rtx,\n@@ -1910,11 +1912,16 @@ builtin_memcpy_read_str (data, offset, mode)\n   return c_readstr (str + offset, mode);\n }\n \n-/* Expand a call to the memcpy builtin, with arguments in ARGLIST.  */\n+/* Expand a call to the memcpy builtin, with arguments in ARGLIST.\n+   Return 0 if we failed, the caller should emit a normal call, otherwise\n+   try to get the result in TARGET, if convenient (and in mode MODE if\n+   that's convenient).  */\n \n static rtx\n-expand_builtin_memcpy (arglist)\n+expand_builtin_memcpy (arglist, target, mode)\n      tree arglist;\n+     rtx target;\n+     enum machine_mode mode;\n {\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -1931,10 +1938,22 @@ expand_builtin_memcpy (arglist)\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n \n-      /* If either SRC or DEST is not a pointer type, don't do\n-\t this operation in-line.  */\n-      if (src_align == 0 || dest_align == 0)\n-\treturn 0;\n+      /* If DEST is not a pointer type, call the normal function.  */\n+      if (dest_align == 0)\n+        return 0;\n+\n+      /* If the LEN parameter is zero, return DEST.  */\n+      if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+        {\n+          /* Evaluate and ignore SRC in case it has side-effects.  */\n+          expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+          return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+        }\n+\n+      /* If either SRC is not a pointer type, don't do this\n+         operation in-line.  */\n+      if (src_align == 0)\n+        return 0;\n \n       dest_mem = get_memory_rtx (dest);\n       set_mem_align (dest_mem, dest_align);\n@@ -1970,33 +1989,34 @@ expand_builtin_memcpy (arglist)\n }\n \n /* Expand expression EXP, which is a call to the strcpy builtin.  Return 0\n-   if we failed the caller should emit a normal call.  */\n+   if we failed the caller should emit a normal call, otherwise try to get\n+   the result in TARGET, if convenient (and in mode MODE if that's\n+   convenient).  */\n \n static rtx\n-expand_builtin_strcpy (exp)\n+expand_builtin_strcpy (exp, target, mode)\n      tree exp;\n+     rtx target;\n+     enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  rtx result;\n+  tree fn, len;\n \n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n-  else\n-    {\n-      tree len = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)));\n-\n-      if (len == 0)\n-\treturn 0;\n \n-      len = size_binop (PLUS_EXPR, len, ssize_int (1));\n-      chainon (arglist, build_tree_list (NULL_TREE, len));\n-    }\n+  fn = built_in_decls[BUILT_IN_MEMCPY];\n+  if (!fn)\n+    return 0;\n \n-  result = expand_builtin_memcpy (arglist);\n+  len = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)));\n+  if (len == 0)\n+    return 0;\n \n-  if (! result)\n-    TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n-  return result;\n+  len = size_binop (PLUS_EXPR, len, ssize_int (1));\n+  chainon (arglist, build_tree_list (NULL_TREE, len));\n+  return expand_expr (build_function_call_expr (fn, arglist),\n+                      target, mode, EXPAND_NORMAL);\n }\n \n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n@@ -2033,6 +2053,7 @@ expand_builtin_strncpy (arglist, target, mode)\n     {\n       tree slen = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)));\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      tree fn;\n \n       /* We must be passed a constant len parameter.  */\n       if (TREE_CODE (len) != INTEGER_CST)\n@@ -2081,7 +2102,11 @@ expand_builtin_strncpy (arglist, target, mode)\n \t}\n \n       /* OK transform into builtin memcpy.  */\n-      return expand_builtin_memcpy (arglist);\n+      fn = built_in_decls[BUILT_IN_MEMCPY];\n+      if (!fn)\n+        return 0;\n+      return expand_expr (build_function_call_expr (fn, arglist),\n+                          target, mode, EXPAND_NORMAL);\n     }\n }\n \n@@ -2104,11 +2129,15 @@ builtin_memset_read_str (data, offset, mode)\n }\n \n /* Expand expression EXP, which is a call to the memset builtin.  Return 0\n-   if we failed the caller should emit a normal call.  */\n+   if we failed the caller should emit a normal call, otherwise try to get\n+   the result in TARGET, if convenient (and in mode MODE if that's\n+   convenient).  */\n \n static rtx\n-expand_builtin_memset (exp)\n+expand_builtin_memset (exp, target, mode)\n      tree exp;\n+     rtx target;\n+     enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n \n@@ -2131,6 +2160,14 @@ expand_builtin_memset (exp)\n       if (dest_align == 0)\n \treturn 0;\n \n+      /* If the LEN parameter is zero, return DEST.  */\n+      if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+        {\n+          /* Evaluate and ignore VAL in case it has side-effects.  */\n+          expand_expr (val, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+          return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+        }\n+\n       if (TREE_CODE (val) != INTEGER_CST)\n \treturn 0;\n \n@@ -2184,43 +2221,75 @@ expand_builtin_bzero (exp)\n   size = TREE_VALUE (TREE_CHAIN (arglist));\n \n   /* New argument list transforming bzero(ptr x, int y) to\n-     memset(ptr x, int 0, size_t y).  */\n+     memset(ptr x, int 0, size_t y).   This is done this way\n+     so that if it isn't expanded inline, we fallback to\n+     calling bzero instead of memset.  */\n \n   newarglist = build_tree_list (NULL_TREE, convert (sizetype, size));\n   newarglist = tree_cons (NULL_TREE, integer_zero_node, newarglist);\n   newarglist = tree_cons (NULL_TREE, dest, newarglist);\n \n   TREE_OPERAND (exp, 1) = newarglist;\n-  result = expand_builtin_memset(exp);\n+  result = expand_builtin_memset (exp, const0_rtx, VOIDmode);\n \n   /* Always restore the original arguments.  */\n   TREE_OPERAND (exp, 1) = arglist;\n \n   return result;\n }\n \n-#ifdef HAVE_cmpstrsi\n-\n /* Expand expression EXP, which is a call to the memcmp or the strcmp builtin.\n    ARGLIST is the argument list for this call.  Return 0 if we failed and the\n    caller should emit a normal call, otherwise try to get the result in\n-   TARGET, if convenient.  */\n+   TARGET, if convenient (and in mode MODE, if that's convenient).  */\n \n static rtx\n-expand_builtin_memcmp (exp, arglist, target)\n+expand_builtin_memcmp (exp, arglist, target, mode)\n      tree exp;\n      tree arglist;\n      rtx target;\n+     enum machine_mode mode;\n {\n+  tree arg1, arg2, len;\n+\n   if (!validate_arglist (arglist,\n \t\t      POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n \n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the len parameter is zero, return zero.  */\n+  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+    {\n+      /* Evaluate and ignore arg1 and arg2 in case they have\n+         side-effects.  */\n+      expand_expr (arg1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      expand_expr (arg2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      return const0_rtx;\n+    }\n+\n+  /* If len parameter is one, return an expression corresponding to\n+     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n+  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 1)\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree ind1 =\n+      fold (build1 (CONVERT_EXPR, integer_type_node,\n+                    build1 (INDIRECT_REF, cst_uchar_node,\n+                            build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n+      tree ind2 =\n+      fold (build1 (CONVERT_EXPR, integer_type_node,\n+                    build1 (INDIRECT_REF, cst_uchar_node,\n+                            build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n+      tree result = fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      return expand_expr (result, target, mode, EXPAND_NORMAL);\n+    }\n+\n+#ifdef HAVE_cmpstrsi\n   {\n-    enum machine_mode mode;\n-    tree arg1 = TREE_VALUE (arglist);\n-    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-    tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n     rtx arg1_rtx, arg2_rtx, arg3_rtx;\n     rtx result;\n     rtx insn;\n@@ -2275,9 +2344,11 @@ expand_builtin_memcmp (exp, arglist, target)\n     else\n       return convert_to_mode (mode, result, 0);\n   }\n-}\n #endif\n \n+  return 0;\n+}\n+\n /* Expand expression EXP, which is a call to the strcmp builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient.  */\n@@ -2289,7 +2360,7 @@ expand_builtin_strcmp (exp, target, mode)\n      enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg1, arg2;\n+  tree arg1, arg2, len, len2, fn;\n   const char *p1, *p2;\n \n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n@@ -2325,58 +2396,49 @@ expand_builtin_strcmp (exp, target, mode)\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n-#ifdef HAVE_cmpstrsi\n-  if (! HAVE_cmpstrsi)\n-    return 0;\n-\n-  {\n-    tree len = c_strlen (arg1);\n-    tree len2 = c_strlen (arg2);\n-    rtx result;\n+  len = c_strlen (arg1);\n+  len2 = c_strlen (arg2);\n \n-    if (len)\n-      len = size_binop (PLUS_EXPR, ssize_int (1), len);\n+  if (len)\n+    len = size_binop (PLUS_EXPR, ssize_int (1), len);\n \n-    if (len2)\n-      len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+  if (len2)\n+    len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n \n-    /* If we don't have a constant length for the first, use the length\n-       of the second, if we know it.  We don't require a constant for\n-       this case; some cost analysis could be done if both are available\n-       but neither is constant.  For now, assume they're equally cheap\n-       unless one has side effects.\n+  /* If we don't have a constant length for the first, use the length\n+     of the second, if we know it.  We don't require a constant for\n+     this case; some cost analysis could be done if both are available\n+     but neither is constant.  For now, assume they're equally cheap\n+     unless one has side effects.\n \n-       If both strings have constant lengths, use the smaller.  This\n-       could arise if optimization results in strcpy being called with\n-       two fixed strings, or if the code was machine-generated.  We should\n-       add some code to the `memcmp' handler below to deal with such\n-       situations, someday.  */\n+     If both strings have constant lengths, use the smaller.  This\n+     could arise if optimization results in strcpy being called with\n+     two fixed strings, or if the code was machine-generated.  We should\n+     add some code to the `memcmp' handler below to deal with such\n+     situations, someday.  */\n \n-    if (!len || TREE_CODE (len) != INTEGER_CST)\n-      {\n-\tif (len2 && !TREE_SIDE_EFFECTS (len2))\n-\t  len = len2;\n-\telse if (len == 0)\n-\t  return 0;\n-      }\n-    else if (len2 && TREE_CODE (len2) == INTEGER_CST\n-\t     && tree_int_cst_lt (len2, len))\n-      len = len2;\n+  if (!len || TREE_CODE (len) != INTEGER_CST)\n+    {\n+      if (len2 && !TREE_SIDE_EFFECTS (len2))\n+        len = len2;\n+      else if (len == 0)\n+        return 0;\n+    }\n+  else if (len2 && TREE_CODE (len2) == INTEGER_CST\n+           && tree_int_cst_lt (len2, len))\n+    len = len2;\n \n-    /* If both arguments have side effects, we cannot optimize.  */\n-    if (TREE_SIDE_EFFECTS (len))\n-      return 0;\n+  /* If both arguments have side effects, we cannot optimize.  */\n+  if (TREE_SIDE_EFFECTS (len))\n+    return 0;\n \n-    chainon (arglist, build_tree_list (NULL_TREE, len));\n-    result = expand_builtin_memcmp (exp, arglist, target);\n-    if (! result)\n-      TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n+  fn = built_in_decls[BUILT_IN_MEMCMP];\n+  if (!fn)\n+    return 0;\n \n-    return result;\n-  }\n-#else\n-  return 0;\n-#endif\n+  chainon (arglist, build_tree_list (NULL_TREE, len));\n+  return expand_expr (build_function_call_expr (fn, arglist),\n+                      target, mode, EXPAND_NORMAL);\n }\n \n /* Expand expression EXP, which is a call to the strncmp builtin.  Return 0\n@@ -2390,6 +2452,7 @@ expand_builtin_strncmp (exp, target, mode)\n      enum machine_mode mode;\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n+  tree fn, newarglist, len = 0;\n   tree arg1, arg2, arg3;\n   const char *p1, *p2;\n \n@@ -2442,45 +2505,42 @@ expand_builtin_strncmp (exp, target, mode)\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n-#ifdef HAVE_cmpstrsi\n   /* If c_strlen can determine an expression for one of the string\n      lengths, and it doesn't have side effects, then call\n      expand_builtin_memcmp() using length MIN(strlen(string)+1, arg3).  */\n-  if (HAVE_cmpstrsi)\n-    {\n-      tree newarglist, len = 0;\n-\n-      /* Perhaps one of the strings is really constant, if so prefer\n-         that constant length over the other string's length.  */\n-      if (p1)\n-\tlen = c_strlen (arg1);\n-      else if (p2)\n-\tlen = c_strlen (arg2);\n-\n-      /* If we still don't have a len, try either string arg as long\n-\t as they don't have side effects.  */\n-      if (!len && !TREE_SIDE_EFFECTS (arg1))\n-\tlen = c_strlen (arg1);\n-      if (!len && !TREE_SIDE_EFFECTS (arg2))\n-\tlen = c_strlen (arg2);\n-      /* If we still don't have a length, punt.  */\n-      if (!len)\n-\treturn 0;\n \n-      /* Add one to the string length.  */\n-      len = fold (size_binop (PLUS_EXPR, len, ssize_int (1)));\n+  /* Perhaps one of the strings is really constant, if so prefer\n+     that constant length over the other string's length.  */\n+  if (p1)\n+    len = c_strlen (arg1);\n+  else if (p2)\n+    len = c_strlen (arg2);\n+\n+  /* If we still don't have a len, try either string arg as long\n+     as they don't have side effects.  */\n+  if (!len && !TREE_SIDE_EFFECTS (arg1))\n+    len = c_strlen (arg1);\n+  if (!len && !TREE_SIDE_EFFECTS (arg2))\n+    len = c_strlen (arg2);\n+  /* If we still don't have a length, punt.  */\n+  if (!len)\n+    return 0;\n+\n+  fn = built_in_decls[BUILT_IN_MEMCMP];\n+  if (!fn)\n+    return 0;\n \n-      /* The actual new length parameter is MIN(len,arg3).  */\n-      len = fold (build (MIN_EXPR, TREE_TYPE (len), len, arg3));\n+  /* Add one to the string length.  */\n+  len = fold (size_binop (PLUS_EXPR, len, ssize_int (1)));\n \n-      newarglist = build_tree_list (NULL_TREE, len);\n-      newarglist = tree_cons (NULL_TREE, arg2, newarglist);\n-      newarglist = tree_cons (NULL_TREE, arg1, newarglist);\n-      return expand_builtin_memcmp (exp, newarglist, target);\n-    }\n-#endif\n+  /* The actual new length parameter is MIN(len,arg3).  */\n+  len = fold (build (MIN_EXPR, TREE_TYPE (len), len, arg3));\n \n-  return 0;\n+  newarglist = build_tree_list (NULL_TREE, len);\n+  newarglist = tree_cons (NULL_TREE, arg2, newarglist);\n+  newarglist = tree_cons (NULL_TREE, arg1, newarglist);\n+  return expand_expr (build_function_call_expr (fn, newarglist),\n+                      target, mode, EXPAND_NORMAL);\n }\n \n /* Expand expression EXP, which is a call to the strcat builtin.\n@@ -3661,7 +3721,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n \n     case BUILT_IN_STRCPY:\n-      target = expand_builtin_strcpy (exp);\n+      target = expand_builtin_strcpy (exp, target, mode);\n       if (target)\n \treturn target;\n       break;\n@@ -3723,13 +3783,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n \n     case BUILT_IN_MEMCPY:\n-      target = expand_builtin_memcpy (arglist);\n+      target = expand_builtin_memcpy (arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n \n     case BUILT_IN_MEMSET:\n-      target = expand_builtin_memset (exp);\n+      target = expand_builtin_memset (exp, target, mode);\n       if (target)\n \treturn target;\n       break;\n@@ -3752,21 +3812,12 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn target;\n       break;\n \n-/* These comparison functions need an instruction that returns an actual\n-   index.  An ordinary compare that just sets the condition codes\n-   is not enough.  */\n-#ifdef HAVE_cmpstrsi\n     case BUILT_IN_BCMP:\n     case BUILT_IN_MEMCMP:\n-      target = expand_builtin_memcmp (exp, arglist, target);\n+      target = expand_builtin_memcmp (exp, arglist, target, mode);\n       if (target)\n \treturn target;\n       break;\n-#else\n-    case BUILT_IN_BCMP:\n-    case BUILT_IN_MEMCMP:\n-      break;\n-#endif\n \n     case BUILT_IN_SETJMP:\n       target = expand_builtin_setjmp (arglist, target);"}, {"sha": "f1b7bfb1e5779bb6bcfaaa3c7830cf7a51e5cf2c", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-14.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-14.c?ref=c2bd38e89276e521395d42410655af037ee0c3ed", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2001  Free Software Foundation.\n+\n+   Ensure builtin memset and memcpy are optimized away correctly.\n+\n+   Written by Roger Sayle, 11/23/2001.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memset (void *s, int c, size_t n);\n+extern void *memcpy (void *dest, const void *src, size_t n);\n+\n+char dst[32];\n+char src[32];\n+\n+int\n+main ()\n+{\n+    memset (src, 0, 0);\n+    memcpy (dst, src, 0);\n+    return 0;\n+}\n+\n+#ifdef __OPTIMIZE__\n+/* When optimizing, all the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   should abort.  */\n+\n+static void *\n+memset (void *s, int c, size_t n)\n+{\n+  abort ();\n+}\n+\n+static void *\n+memcpy (void *dest, const void *src, size_t n)\n+{\n+  abort ();\n+}\n+#endif\n+"}, {"sha": "b08ff9b66e5432bad25b034fbc545a3dd9708514", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-15.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bd38e89276e521395d42410655af037ee0c3ed/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-15.c?ref=c2bd38e89276e521395d42410655af037ee0c3ed", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2001  Free Software Foundation.\n+\n+   Ensure that short builtin memcmp are optimized and perform correctly.\n+   On architectures with a cmpstrsi instruction, this test doesn't determine\n+   which optimization is being performed, but it does check for correctness.\n+\n+   Written by Roger Sayle, 12/02/2001.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+\n+int\n+main ()\n+{\n+  char str[8];\n+\n+  strcpy (str, \"3141\");\n+\n+  if ( memcmp (str, str+2, 0) != 0 )\n+    abort ();\n+  if ( memcmp (str+1, str+3, 0) != 0 )\n+    abort ();\n+\n+  if ( memcmp (str+1, str+3, 1) != 0 )\n+    abort ();\n+  if ( memcmp (str, str+2, 1) >= 0 )\n+    abort ();\n+  if ( memcmp (str+2, str, 1) <= 0 )\n+    abort ();\n+\n+  return 0;\n+}\n+\n+#ifdef __OPTIMIZE__\n+/* When optimizing, all the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   should abort.  */\n+static int\n+memcmp (const char *p1, const char *p2, size_t len)\n+{\n+  abort ();\n+}\n+#endif\n+"}]}