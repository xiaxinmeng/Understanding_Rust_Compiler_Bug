{"sha": "544d960a12742dbe8c8e9a968764d4502b239a26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0ZDk2MGExMjc0MmRiZThjOGU5YTk2ODc2NGQ0NTAyYjIzOWEyNg==", "commit": {"author": {"name": "Artjoms Sinkarovs", "email": "artyom.shinkaroff@gmail.com", "date": "2011-08-29T11:55:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-29T11:55:45Z"}, "message": "20011-08-29  Artjoms Sinkarovs  <artyom.shinkaroff@gmail.com>\n\tRichard Guenther  <rguenther@suse.de>\n\n\t* tree.h (constant_boolean_node): Adjust prototype.\n\t* fold-const.c (fold_convert_loc): Move aggregate conversion\n\tleeway down.\n\t(constant_boolean_node): Make value parameter boolean, add\n\tvector type handling.\n\t(fold_unary_loc): Use constant_boolean_node.\n\t(fold_binary_loc): Preserve types properly when folding\n\tCOMPLEX_EXPR <__real x, __imag x>.\n\t* gimplify.c (gimplify_expr): Handle vector comparison.\n\t* tree.def (EQ_EXPR, ...): Document behavior on vector typed\n\tcomparison.\n\t* tree-cfg.c (verify_gimple_comparison): Verify vector typed\n\tcomparisons.\n\nFrom-SVN: r178209", "tree": {"sha": "a6235b0de2204188ae68275b478b1d3c90038b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6235b0de2204188ae68275b478b1d3c90038b41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/544d960a12742dbe8c8e9a968764d4502b239a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544d960a12742dbe8c8e9a968764d4502b239a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544d960a12742dbe8c8e9a968764d4502b239a26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544d960a12742dbe8c8e9a968764d4502b239a26/comments", "author": {"login": "ashinkarov", "id": 892232, "node_id": "MDQ6VXNlcjg5MjIzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/892232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashinkarov", "html_url": "https://github.com/ashinkarov", "followers_url": "https://api.github.com/users/ashinkarov/followers", "following_url": "https://api.github.com/users/ashinkarov/following{/other_user}", "gists_url": "https://api.github.com/users/ashinkarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashinkarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashinkarov/subscriptions", "organizations_url": "https://api.github.com/users/ashinkarov/orgs", "repos_url": "https://api.github.com/users/ashinkarov/repos", "events_url": "https://api.github.com/users/ashinkarov/events{/privacy}", "received_events_url": "https://api.github.com/users/ashinkarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "776bebcdb0de9557b40aa5496c016588da845398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776bebcdb0de9557b40aa5496c016588da845398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/776bebcdb0de9557b40aa5496c016588da845398"}], "stats": {"total": 106, "additions": 81, "deletions": 25}, "files": [{"sha": "c1b6de3fc95215b3946a9fc8ce0ae211883d0f36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=544d960a12742dbe8c8e9a968764d4502b239a26", "patch": "@@ -1,3 +1,20 @@\n+20011-08-29  Artjoms Sinkarovs  <artyom.shinkaroff@gmail.com>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (constant_boolean_node): Adjust prototype.\n+\t* fold-const.c (fold_convert_loc): Move aggregate conversion\n+\tleeway down.\n+\t(constant_boolean_node): Make value parameter boolean, add\n+\tvector type handling.\n+\t(fold_unary_loc): Use constant_boolean_node.\n+\t(fold_binary_loc): Preserve types properly when folding\n+\tCOMPLEX_EXPR <__real x, __imag x>.\n+\t* gimplify.c (gimplify_expr): Handle vector comparison.\n+\t* tree.def (EQ_EXPR, ...): Document behavior on vector typed\n+\tcomparison.\n+\t* tree-cfg.c (verify_gimple_comparison): Verify vector typed\n+\tcomparisons.\n+\n 2011-08-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/48722"}, {"sha": "5807a5533ba208ae88b5282544068d3b0ed419d6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=544d960a12742dbe8c8e9a968764d4502b239a26", "patch": "@@ -1867,9 +1867,6 @@ fold_convert_loc (location_t loc, tree type, tree arg)\n       || TREE_CODE (orig) == ERROR_MARK)\n     return error_mark_node;\n \n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig))\n-    return fold_build1_loc (loc, NOP_EXPR, type, arg);\n-\n   switch (TREE_CODE (type))\n     {\n     case POINTER_TYPE:\n@@ -2017,6 +2014,8 @@ fold_convert_loc (location_t loc, tree type, tree arg)\n       return fold_build1_loc (loc, NOP_EXPR, type, tem);\n \n     default:\n+      if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig))\n+\treturn fold_build1_loc (loc, NOP_EXPR, type, arg);\n       gcc_unreachable ();\n     }\n  fold_convert_exit:\n@@ -5929,17 +5928,22 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n }\n \f\n /* Return a node which has the indicated constant VALUE (either 0 or\n-   1), and is of the indicated TYPE.  */\n+   1 for scalars or {-1,-1,..} or {0,0,...} for vectors),\n+   and is of the indicated TYPE.  */\n \n tree\n-constant_boolean_node (int value, tree type)\n+constant_boolean_node (bool value, tree type)\n {\n   if (type == integer_type_node)\n     return value ? integer_one_node : integer_zero_node;\n   else if (type == boolean_type_node)\n     return value ? boolean_true_node : boolean_false_node;\n+  else if (TREE_CODE (type) == VECTOR_TYPE)\n+    return build_vector_from_val (type,\n+\t\t\t\t  build_int_cst (TREE_TYPE (type),\n+\t\t\t\t\t\t value ? -1 : 0));\n   else\n-    return build_int_cst (type, value);\n+    return fold_convert (type, value ? integer_one_node : integer_zero_node);\n }\n \n \n@@ -7668,8 +7672,8 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t\t\t       TREE_OPERAND (op0, 1));\n \t  else if (!INTEGRAL_TYPE_P (type))\n \t    return build3_loc (loc, COND_EXPR, type, op0,\n-\t\t\t       fold_convert (type, boolean_true_node),\n-\t\t\t       fold_convert (type, boolean_false_node));\n+\t\t\t       constant_boolean_node (true, type),\n+\t\t\t       constant_boolean_node (false, type));\n \t}\n \n       /* Handle cases of two conversions in a row.  */\n@@ -13202,8 +13206,7 @@ fold_binary_loc (location_t loc,\n \treturn build_complex (type, arg0, arg1);\n       if (TREE_CODE (arg0) == REALPART_EXPR\n \t  && TREE_CODE (arg1) == IMAGPART_EXPR\n-\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg0, 0)))\n-\t      == TYPE_MAIN_VARIANT (type))\n+\t  && TREE_TYPE (TREE_OPERAND (arg0, 0)) == type\n \t  && operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t      TREE_OPERAND (arg1, 0), 0))\n \treturn omit_one_operand_loc (loc, type, TREE_OPERAND (arg0, 0),"}, {"sha": "a22b5d3121f6057a96fbaa2a0684105e1e540b1f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=544d960a12742dbe8c8e9a968764d4502b239a26", "patch": "@@ -7349,7 +7349,10 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t{\n \t\t  tree type = TREE_TYPE (TREE_OPERAND (*expr_p, 1));\n \n-\t\t  if (!AGGREGATE_TYPE_P (type))\n+\t\t  /* Vector comparisons need no boolification.  */\n+\t\t  if (TREE_CODE (type) == VECTOR_TYPE)\n+\t\t    goto expr_2;\n+\t\t  else if (!AGGREGATE_TYPE_P (type))\n \t\t    {\n \t\t      tree org_type = TREE_TYPE (*expr_p);\n \t\t      *expr_p = gimple_boolify (*expr_p);"}, {"sha": "bcb8ba9b742a3a31da4df33914f3335d0aebfe2d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=544d960a12742dbe8c8e9a968764d4502b239a26", "patch": "@@ -3193,25 +3193,55 @@ verify_gimple_comparison (tree type, tree op0, tree op1)\n      effective type the comparison is carried out in.  Instead\n      we require that either the first operand is trivially\n      convertible into the second, or the other way around.\n-     The resulting type of a comparison may be any integral type.\n      Because we special-case pointers to void we allow\n      comparisons of pointers with the same mode as well.  */\n-  if ((!useless_type_conversion_p (op0_type, op1_type)\n-       && !useless_type_conversion_p (op1_type, op0_type)\n-       && (!POINTER_TYPE_P (op0_type)\n-\t   || !POINTER_TYPE_P (op1_type)\n-\t   || TYPE_MODE (op0_type) != TYPE_MODE (op1_type)))\n-      || !INTEGRAL_TYPE_P (type)\n-      || (TREE_CODE (type) != BOOLEAN_TYPE\n-\t  && TYPE_PRECISION (type) != 1))\n-    {\n-      error (\"type mismatch in comparison expression\");\n-      debug_generic_expr (type);\n+  if (!useless_type_conversion_p (op0_type, op1_type)\n+      && !useless_type_conversion_p (op1_type, op0_type)\n+      && (!POINTER_TYPE_P (op0_type)\n+\t  || !POINTER_TYPE_P (op1_type)\n+\t  || TYPE_MODE (op0_type) != TYPE_MODE (op1_type)))\n+    {\n+      error (\"mismatching comparison operand types\");\n       debug_generic_expr (op0_type);\n       debug_generic_expr (op1_type);\n       return true;\n     }\n \n+  /* The resulting type of a comparison may be an effective boolean type.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      && (TREE_CODE (type) == BOOLEAN_TYPE\n+\t  || TYPE_PRECISION (type) == 1))\n+    ;\n+  /* Or an integer vector type with the same size and element count\n+     as the comparison operand types.  */\n+  else if (TREE_CODE (type) == VECTOR_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n+    {\n+      if (TREE_CODE (op0_type) != VECTOR_TYPE\n+\t  || TREE_CODE (op1_type) != VECTOR_TYPE)\n+        {\n+          error (\"non-vector operands in vector comparison\");\n+          debug_generic_expr (op0_type);\n+          debug_generic_expr (op1_type);\n+          return true;\n+        }\n+\n+      if (TYPE_VECTOR_SUBPARTS (type) != TYPE_VECTOR_SUBPARTS (op0_type)\n+\t  || (GET_MODE_SIZE (TYPE_MODE (type))\n+\t      != GET_MODE_SIZE (TYPE_MODE (op0_type))))\n+        {\n+          error (\"invalid vector comparison resulting type\");\n+          debug_generic_expr (type);\n+          return true;\n+        }\n+    }\n+  else\n+    {\n+      error (\"bogus comparison result type\");\n+      debug_generic_expr (type);\n+      return true;\n+    }\n+\n   return false;\n }\n "}, {"sha": "ea255d5805d0e97c292a7d7cdefb8645f95671c7", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=544d960a12742dbe8c8e9a968764d4502b239a26", "patch": "@@ -704,7 +704,10 @@ DEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", tcc_expression, 1)\n    The others are allowed only for integer (or pointer or enumeral)\n    or real types.\n    In all cases the operands will have the same type,\n-   and the value is always the type used by the language for booleans.  */\n+   and the value is either the type used by the language for booleans\n+   or an integer vector type of the same size and with the same number\n+   of elements as the comparison operands.  True for a vector of\n+   comparison results has all bits set while false is equal to zero.  */\n DEFTREECODE (LT_EXPR, \"lt_expr\", tcc_comparison, 2)\n DEFTREECODE (LE_EXPR, \"le_expr\", tcc_comparison, 2)\n DEFTREECODE (GT_EXPR, \"gt_expr\", tcc_comparison, 2)"}, {"sha": "06f67f425d9adef3e6f0971960d36607f94be2df", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d960a12742dbe8c8e9a968764d4502b239a26/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=544d960a12742dbe8c8e9a968764d4502b239a26", "patch": "@@ -5274,7 +5274,7 @@ extern tree build_simple_mem_ref_loc (location_t, tree);\n extern double_int mem_ref_offset (const_tree);\n extern tree reference_alias_ptr_type (const_tree);\n extern tree build_invariant_address (tree, tree, HOST_WIDE_INT);\n-extern tree constant_boolean_node (int, tree);\n+extern tree constant_boolean_node (bool, tree);\n extern tree div_if_zero_remainder (enum tree_code, const_tree, const_tree);\n \n extern bool tree_swap_operands_p (const_tree, const_tree, bool);"}]}