{"sha": "da3aca031be736fe4fa8daa57c7efa69dc767160", "node_id": "C_kwDOANBUbNoAKGRhM2FjYTAzMWJlNzM2ZmU0ZmE4ZGFhNTdjN2VmYTY5ZGM3NjcxNjA", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2023-01-29T00:27:26Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2023-01-29T00:27:26Z"}, "message": "Fix find_always_executed_bbs handling of infinite loops\n\nThis patch fixes the stupid typo info find_always_executed_bbs which made\nall edges to be considered as ones closing infinite loops.  This fix has\nsomewhat snowballed as, comparing it to finite_function_p, I noticed a\ndivergence in handling of volatile asms (find_always_executed_bbs is conservative\nand thinks that volatile statement may return or do EH, but it is really\nimpossible and elsewhere we expects that we dont) and I also noticed\na bug in handling early returns which made some loops to be missed.\n\nI also noticed that function assumes that irreducible loops are marked in CFG\nwhich is not necessarily true and it is easy to detect them during the walk.\n\nBootstrapped/regtested x86_64-linux, comitted.\n\ngcc/ChangeLog:\n\n2023-01-29  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-utils.cc: Include calls.h, cfgloop.h and cfganal.h\n\t(stmt_may_terminate_function_p): If assuming return or EH\n\tvolatile asm is safe.\n\t(find_always_executed_bbs): Fix handling of terminating BBS and\n\tinfinite loops; add debug output.\n\t* tree-ssa-alias.cc (stmt_kills_ref_p): Fix debug output\n\ngcc/testsuite/ChangeLog:\n\n2023-01-29  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/ipa/ipa-sra-30.c: New test.\n\t* gcc.dg/ipa/ipa-sra-31.c: New test.\n\t* gcc.dg/tree-ssa/modref-dse-7.c: New test.", "tree": {"sha": "cc55eda6e0d584009f8a9a71b1e50ae2a832b912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc55eda6e0d584009f8a9a71b1e50ae2a832b912"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da3aca031be736fe4fa8daa57c7efa69dc767160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da3aca031be736fe4fa8daa57c7efa69dc767160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da3aca031be736fe4fa8daa57c7efa69dc767160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da3aca031be736fe4fa8daa57c7efa69dc767160/comments", "author": null, "committer": null, "parents": [{"sha": "ee2c965ee205ae12bc78d8641337380df3b1d3f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee2c965ee205ae12bc78d8641337380df3b1d3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee2c965ee205ae12bc78d8641337380df3b1d3f3"}], "stats": {"total": 143, "additions": 121, "deletions": 22}, "files": [{"sha": "8badcc2c1109414373e89859452a0d6f7501a127", "filename": "gcc/ipa-utils.cc", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Fipa-utils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Fipa-utils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.cc?ref=da3aca031be736fe4fa8daa57c7efa69dc767160", "patch": "@@ -40,6 +40,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-modref-tree.h\"\n #include \"ipa-modref.h\"\n #include \"tree-ssa-loop-niter.h\"\n+#include \"calls.h\"\n+#include \"cfgloop.h\"\n+#include \"cfganal.h\"\n \n /* Debugging function for postorder and inorder code. NOTE is a string\n    that is printed before the nodes are printed.  ORDER is an array of\n@@ -796,11 +799,11 @@ stmt_may_terminate_function_p (function *fun, gimple *stmt, bool assume_return_o\n {\n   if (stmt_can_throw_external (fun, stmt))\n     return true;\n+  if (assume_return_or_eh)\n+    return false;\n   gasm *astmt = dyn_cast <gasm *> (stmt);\n   if (astmt && gimple_asm_volatile_p (astmt))\n     return true;\n-  if (assume_return_or_eh)\n-    return false;\n   if (gimple_could_trap_p (stmt))\n     return true;\n   if (gcall *call = dyn_cast <gcall *> (stmt))\n@@ -832,8 +835,14 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n   auto_vec<basic_block, 20> stack;\n   auto_vec<basic_block, 20> terminating_bbs;\n   hash_set<basic_block> visited;\n+  hash_set<basic_block> terminating_bbs_set;\n   edge e;\n   edge_iterator ei;\n+  int flags = flags_from_decl_or_type (fun->decl);\n+  /* PUre and const functions always return.  */\n+  assume_return_or_eh |= (flags & (ECF_CONST|ECF_PURE)) && !(flags & ECF_LOOPING_CONST_OR_PURE);\n+  if (!assume_return_or_eh)\n+    mark_dfs_back_edges (fun);\n \n   /* First walk all BBs reachable from entry stopping on statements that may\n      terminate execution.  Everything past this statement is not going to be executed\n@@ -843,9 +852,8 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n     {\n       basic_block bb = stack.pop ();\n       bool found = false, found_exit = false;\n-      if (!assume_return_or_eh\n-\t  && (EDGE_COUNT (bb->succs) == 0 || (bb->flags & BB_IRREDUCIBLE_LOOP)))\n-\tfound = true;\n+      if (bb->index == EXIT_BLOCK)\n+\tcontinue;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (fun))\n@@ -854,10 +862,28 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n \t      break;\n \t    }\n \t  /* Watch for infinite loops.  */\n-\t  if (!found && (assume_return_or_eh & EDGE_DFS_BACK)\n-\t      && !finite_loop_p (e->src->loop_father))\n-\t    found = true;\n+\t  if (!found\n+\t      && !assume_return_or_eh && (e->flags & EDGE_DFS_BACK))\n+\t    {\n+\t      if (!dom_info_available_p (CDI_DOMINATORS))\n+\t\tcalculate_dominance_info (CDI_DOMINATORS);\n+\t      /* If this is not a loop latch edge it is an irreducible region.\n+\t\t Assume that it is infinite.\n+\t\t TODO: with C++ forced progression we can still walk the\n+\t\t irreducible region and see if it contains any side effects.\n+\t\t Similarly for loops.  -ffinite-loops does not really imply\n+\t\t this since we allow inlining across -ffinite-loops bondary\n+\t\t and thus it can be used only as a loop flag.  */\n+\t      if (e->dest->loop_father->header != e->dest\n+\t\t  || !dominated_by_p (CDI_DOMINATORS, bb, e->dest))\n+\t\tfound = true;\n+\t      else if (!finite_loop_p (e->dest->loop_father))\n+\t\tfound = true;\n+\t    }\n \t}\n+      if (!assume_return_or_eh\n+\t  && (EDGE_COUNT (bb->succs) == 0 || (bb->flags & BB_IRREDUCIBLE_LOOP)))\n+\tfound = true;\n       for (gimple_stmt_iterator si = gsi_start_nondebug_after_labels_bb (bb);\n \t   !gsi_end_p (si) && !found; gsi_next_nondebug (&si))\n \tif (stmt_may_terminate_function_p (fun, gsi_stmt (si), assume_return_or_eh))\n@@ -869,7 +895,10 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n \t{\n \t  visited.add (EXIT_BLOCK_PTR_FOR_FN (fun));\n \t  if (!found_exit)\n-\t    terminating_bbs.safe_push (bb);\n+\t    {\n+\t      terminating_bbs.safe_push (bb);\n+\t      terminating_bbs_set.add (bb);\n+\t    }\n \t}\n       else\n \tFOR_EACH_EDGE (e, ei, bb->succs)\n@@ -883,8 +912,7 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n \n   bitmap ret = BITMAP_ALLOC (NULL);\n   /* A degenerated case when there is no path to exit.  */\n-  if (!visited.contains (EXIT_BLOCK_PTR_FOR_FN (fun))\n-      && terminating_bbs.is_empty ())\n+  if (!visited.contains (EXIT_BLOCK_PTR_FOR_FN (fun)))\n     {\n       bitmap_set_bit (ret,\n \t\t      single_succ_edge\n@@ -945,7 +973,7 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n \t    }\n \t  /* DFS is visiting BB for first time.  */\n \t  *slot = cstate = XOBNEW (&state_obstack, struct astate);\n-\t  cstate->low = cstate->dfs_preorder = next_dfs_num++;\n+\t  cstate->low = cstate->high = cstate->dfs_preorder = next_dfs_num++;\n \t  w.cstate = cstate;\n \t  /* Exit block is special; process all fake edges we identified.  */\n \t  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))\n@@ -981,25 +1009,38 @@ find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n \t  if (!cstate2)\n \t    {\n \t      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (fun))\n-\t        cstate->low = 0;\n+\t\tcstate->low = 0;\n \t      continue;\n \t    }\n \t  cstate->low = MIN (cstate->low, (*cstate2)->low);\n \t  cstate->high = MAX (cstate->high, (*cstate2)->high);\n \t}\n+      if (dump_file && (dump_flags & TDF_DETAILS) && bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+\tfprintf (dump_file, \"BB %i %s preorder %i posorder %i low %i high %i\\n\",\n+\t\t bb->index, terminating_bbs_set.contains (bb) ? \"(terminating)\": \"\",\n+\t\t cstate->dfs_preorder, cstate->dfs_postorder, cstate->low, cstate->high);\n       if (cstate->low == cstate->dfs_preorder && cstate->high == cstate->dfs_postorder\n \t  && bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n \tbitmap_set_bit (ret, bb->index);\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  astate **cstate2 = state.get (e->dest);\n-\t  if (!cstate2)\n-\t    continue;\n-\t  cstate->low = MIN (cstate->low, (*cstate2)->low);\n-\t  cstate->high = MAX (cstate->high, (*cstate2)->high);\n-\t}\n-    }\n+      if (terminating_bbs_set.contains (bb))\n+\tcstate->low = 0;\n+      else\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  {\n+\t    astate **cstate2 = state.get (e->dest);\n+\t    if (!cstate2)\n+\t      continue;\n+\t    cstate->low = MIN (cstate->low, (*cstate2)->low);\n+\t    cstate->high = MAX (cstate->high, (*cstate2)->high);\n+\t  }\n+      }\n   obstack_free (&state_obstack, NULL);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Always executed bbbs %s: \",\n+\t       assume_return_or_eh ? \"(assuming return or EH)\": \"\");\n+      bitmap_print (dump_file, ret, \"\", \"\\n\");\n+    }\n \n   return ret;\n }"}, {"sha": "5c8e8ed8ca168c2c46be2f01028c729ee443345a", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-30.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-30.c?ref=da3aca031be736fe4fa8daa57c7efa69dc767160", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra\"  } */\n+struct list\n+{\n+\t struct list *next;\n+\t int val;\n+};\n+__attribute__ ((noinline))\n+static int reta (int *a)\n+{\n+\treturn *a;\n+}\n+__attribute__ ((noinline))\n+static int\n+kill(struct list *l, int *a)\n+{\n+\tint v;\n+\twhile (l)\n+\t{\n+\t\tv = l->val;\n+\t\tl=l->next;\n+\t}\n+\treturn reta (a) + v;\n+}\n+int\n+test(struct list *l, int *a)\n+{\n+\treturn kill (l, a);\n+}\n+/* Loop in kill may be infinite; do not SRA.  */\n+/* { dg-final { scan-ipa-dump-not \"Created new node kill.isra\"  \"sra\"  } } */"}, {"sha": "0a636d668720ed43fc3b06a921167fd145c0de4f", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-31.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-31.c?ref=da3aca031be736fe4fa8daa57c7efa69dc767160", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra -ffinite-loops\"  } */\n+#include \"ipa-sra-30.c\"\n+/* { dg-final { scan-ipa-dump \"Created new node kill.isra\"  \"sra\"  } } */"}, {"sha": "85a01d30cea850ec90896cd0f2b0fb2baa010a9e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-dse-7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-dse-7.c?ref=da3aca031be736fe4fa8daa57c7efa69dc767160", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\"  } */\n+struct list\n+{\n+\t struct list *next;\n+};\n+__attribute__ ((noinline))\n+void\n+kill(struct list *l, int *a)\n+{\n+\twhile (l)\n+\t\tl=l->next;\n+\t*a = 0;\n+}\n+void\n+test(struct list *l, int *a)\n+{\n+\t*a=12345;\n+\tkill (l, a);\n+\treturn;\n+}\n+/* { dg-final { scan-tree-dump-not \"12345\" \"optimized\"} } */"}, {"sha": "7089e8b5bf3807fe26f042a278d31895cf4cfe1b", "filename": "gcc/tree-ssa-alias.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftree-ssa-alias.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3aca031be736fe4fa8daa57c7efa69dc767160/gcc%2Ftree-ssa-alias.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.cc?ref=da3aca031be736fe4fa8daa57c7efa69dc767160", "patch": "@@ -3522,6 +3522,7 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t\t       \"ipa-modref: call to %s kills \",\n \t\t\t       node->dump_name ());\n \t\t      print_generic_expr (dump_file, ref->base);\n+\t\t      fprintf (dump_file, \"\\n\");\n \t\t    }\n \t\t    ++alias_stats.modref_kill_yes;\n \t\t    return true;"}]}