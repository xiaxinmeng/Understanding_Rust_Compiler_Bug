{"sha": "48c206e044b84dc1362529e5502dcc42c29341bc", "node_id": "C_kwDOANBUbNoAKDQ4YzIwNmUwNDRiODRkYzEzNjI1MjllNTUwMmRjYzQyYzI5MzQxYmM", "commit": {"author": {"name": "Ghjuvan Lacambre", "email": "lacambre@adacore.com", "date": "2022-09-30T13:44:49Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-04T13:47:27Z"}, "message": "ada: Remove sa_messages\n\nSpark and CodePeer do not depend on this unit anymore.\n\ngcc/ada/\n\n\t* sa_messages.ads, sa_messages.adb: Remove files.", "tree": {"sha": "a50676063033ba0e946f4f83a808e337b62ce44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50676063033ba0e946f4f83a808e337b62ce44d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48c206e044b84dc1362529e5502dcc42c29341bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c206e044b84dc1362529e5502dcc42c29341bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c206e044b84dc1362529e5502dcc42c29341bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c206e044b84dc1362529e5502dcc42c29341bc/comments", "author": {"login": "glacambre", "id": 11534587, "node_id": "MDQ6VXNlcjExNTM0NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/11534587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glacambre", "html_url": "https://github.com/glacambre", "followers_url": "https://api.github.com/users/glacambre/followers", "following_url": "https://api.github.com/users/glacambre/following{/other_user}", "gists_url": "https://api.github.com/users/glacambre/gists{/gist_id}", "starred_url": "https://api.github.com/users/glacambre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glacambre/subscriptions", "organizations_url": "https://api.github.com/users/glacambre/orgs", "repos_url": "https://api.github.com/users/glacambre/repos", "events_url": "https://api.github.com/users/glacambre/events{/privacy}", "received_events_url": "https://api.github.com/users/glacambre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d0d27d90dbd8ecab7f8852a807d86a84e31a61c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0d27d90dbd8ecab7f8852a807d86a84e31a61c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0d27d90dbd8ecab7f8852a807d86a84e31a61c"}], "stats": {"total": 806, "additions": 0, "deletions": 806}, "files": [{"sha": "b9b4e932b431a1d693a082774b7a6c48bf203c15", "filename": "gcc/ada/sa_messages.adb", "status": "removed", "additions": 0, "deletions": 539, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0d27d90dbd8ecab7f8852a807d86a84e31a61c/gcc%2Fada%2Fsa_messages.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0d27d90dbd8ecab7f8852a807d86a84e31a61c/gcc%2Fada%2Fsa_messages.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsa_messages.adb?ref=7d0d27d90dbd8ecab7f8852a807d86a84e31a61c", "patch": "@@ -1,539 +0,0 @@\n-------------------------------------------------------------------------------\n---                       C O D E P E E R / S P A R K                        --\n---                                                                          --\n---                     Copyright (C) 2015-2022, AdaCore                     --\n---                                                                          --\n--- This is free software;  you can redistribute it  and/or modify it  under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  This software is distributed in the hope  that it will be useful, --\n--- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n--- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --\n--- License for  more details.  You should have  received  a copy of the GNU --\n--- General  Public  License  distributed  with  this  software;   see  file --\n--- COPYING3.  If not, go to http://www.gnu.org/licenses for a complete copy --\n--- of the license.                                                          --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-pragma Ada_2012;\n-\n-with Ada.Directories; use Ada.Directories;\n-with Ada.Strings.Unbounded.Hash;\n-\n-with Ada.Text_IO;     use Ada.Text_IO;\n-with GNATCOLL.JSON;   use GNATCOLL.JSON;\n-\n-package body SA_Messages is\n-\n-   -----------------------\n-   -- Local subprograms --\n-   -----------------------\n-\n-   function \"<\" (Left, Right : SA_Message) return Boolean is\n-     (if Left.Kind /= Right.Kind then\n-         Left.Kind < Right.Kind\n-      else\n-         Left.Kind in Check_Kind\n-           and then Left.Check_Result < Right.Check_Result);\n-\n-   function \"<\" (Left, Right : Simple_Source_Location) return Boolean is\n-      (if Left.File_Name /= Right.File_Name then\n-          Left.File_Name < Right.File_Name\n-       elsif Left.Line /= Right.Line then\n-          Left.Line < Right.Line\n-       else\n-          Left.Column < Right.Column);\n-\n-   function \"<\" (Left, Right : Source_Locations) return Boolean is\n-     (if Left'Length /= Right'Length then\n-         Left'Length < Right'Length\n-      elsif Left'Length = 0 then\n-         False\n-      elsif Left (Left'Last) /= Right (Right'Last) then\n-         Left (Left'Last) < Right (Right'Last)\n-      else\n-         Left (Left'First .. Left'Last - 1) <\n-           Right (Right'First .. Right'Last - 1));\n-\n-   function \"<\" (Left, Right : Source_Location) return Boolean is\n-     (Left.Locations < Right.Locations);\n-\n-   function Base_Location\n-     (Location : Source_Location) return Simple_Source_Location is\n-     (Location.Locations (1));\n-\n-   function Hash (Key : SA_Message) return Hash_Type;\n-   function Hash (Key : Source_Location) return Hash_Type;\n-\n-   ---------\n-   -- \"<\" --\n-   ---------\n-\n-   function \"<\" (Left, Right : Message_And_Location) return Boolean is\n-     (if Left.Message = Right.Message\n-      then Left.Location < Right.Location\n-      else Left.Message < Right.Message);\n-\n-   ------------\n-   -- Column --\n-   ------------\n-\n-   function Column (Location : Source_Location) return Column_Number is\n-     (Base_Location (Location).Column);\n-\n-   ---------------\n-   -- File_Name --\n-   ---------------\n-\n-   function File_Name (Location : Source_Location) return String is\n-     (To_String (Base_Location (Location).File_Name));\n-\n-   function File_Name (Location : Source_Location) return Unbounded_String is\n-     (Base_Location (Location).File_Name);\n-\n-   ------------------------\n-   -- Enclosing_Instance --\n-   ------------------------\n-\n-   function Enclosing_Instance\n-     (Location : Source_Location) return Source_Location_Or_Null is\n-     (Count     => Location.Count - 1,\n-      Locations => Location.Locations (2 .. Location.Count));\n-\n-   ----------\n-   -- Hash --\n-   ----------\n-\n-   function Hash (Key : Message_And_Location) return Hash_Type is\n-     (Hash (Key.Message) + Hash (Key.Location));\n-\n-   function Hash (Key : SA_Message) return Hash_Type is\n-   begin\n-      return Result : Hash_Type :=\n-                        Hash_Type'Mod (Message_Kind'Pos (Key.Kind))\n-      do\n-         if Key.Kind in Check_Kind then\n-            Result := Result +\n-              Hash_Type'Mod (SA_Check_Result'Pos (Key.Check_Result));\n-         end if;\n-      end return;\n-   end Hash;\n-\n-   function Hash (Key : Source_Location) return Hash_Type is\n-   begin\n-      return Result : Hash_Type := Hash_Type'Mod (Key.Count) do\n-         for Loc of Key.Locations loop\n-            Result := Result + Hash (Loc.File_Name);\n-            Result := Result + Hash_Type'Mod (Loc.Line);\n-            Result := Result + Hash_Type'Mod (Loc.Column);\n-         end loop;\n-      end return;\n-   end Hash;\n-\n-   ---------------\n-   -- Iteration --\n-   ---------------\n-\n-   function Iteration (Location : Source_Location) return Iteration_Id is\n-     (Base_Location (Location).Iteration);\n-\n-   ----------\n-   -- Line --\n-   ----------\n-\n-   function Line (Location : Source_Location) return Line_Number is\n-     (Base_Location (Location).Line);\n-\n-   --------------\n-   -- Location --\n-   --------------\n-\n-   function Location\n-     (Item : Message_And_Location) return Source_Location is\n-     (Item.Location);\n-\n-   ----------\n-   -- Make --\n-   ----------\n-\n-   function Make\n-     (File_Name          : String;\n-      Line               : Line_Number;\n-      Column             : Column_Number;\n-      Iteration          : Iteration_Id;\n-      Enclosing_Instance : Source_Location_Or_Null) return Source_Location\n-   is\n-   begin\n-      return Result : Source_Location\n-                        (Count => Enclosing_Instance.Count + 1)\n-      do\n-         Result.Locations (1) :=\n-           (File_Name => To_Unbounded_String (File_Name),\n-            Line      => Line,\n-            Column    => Column,\n-            Iteration => Iteration);\n-\n-         Result.Locations (2 .. Result.Count) := Enclosing_Instance.Locations;\n-      end return;\n-   end Make;\n-\n-   ------------------\n-   -- Make_Msg_Loc --\n-   ------------------\n-\n-   function Make_Msg_Loc\n-     (Msg : SA_Message;\n-      Loc : Source_Location) return Message_And_Location\n-   is\n-   begin\n-      return Message_And_Location'(Count    => Loc.Count,\n-                                   Message  => Msg,\n-                                   Location => Loc);\n-   end Make_Msg_Loc;\n-\n-   -------------\n-   -- Message --\n-   -------------\n-\n-   function Message (Item : Message_And_Location) return SA_Message is\n-     (Item.Message);\n-\n-   package Field_Names is\n-\n-      --  A Source_Location value is represented in JSON as a two or three\n-      --  field value having fields Message_Kind (a string) and Locations (an\n-      --  array); if the Message_Kind indicates a check kind, then a third\n-      --  field is present: Check_Result (a string). The element type of the\n-      --  Locations array is a value having at least 4 fields:\n-      --  File_Name (a string), Line (an integer), Column (an integer),\n-      --  and Iteration_Kind (an integer); if the Iteration_Kind field\n-      --  has the value corresponding to the enumeration literal Numbered,\n-      --  then two additional integer fields are present, Iteration_Number\n-      --  and Iteration_Of_Total.\n-\n-      Check_Result       : constant String := \"Check_Result\";\n-      Column             : constant String := \"Column\";\n-      File_Name          : constant String := \"File_Name\";\n-      Iteration_Kind     : constant String := \"Iteration_Kind\";\n-      Iteration_Number   : constant String := \"Iteration_Number\";\n-      Iteration_Of_Total : constant String := \"Iteration_Total\";\n-      Line               : constant String := \"Line\";\n-      Locations          : constant String := \"Locations\";\n-      Message_Kind       : constant String := \"Message_Kind\";\n-      Messages           : constant String := \"Messages\";\n-   end Field_Names;\n-\n-   package body Writing is\n-      File : File_Type;\n-      --  The file to which output will be written (in Close, not in Write)\n-\n-      Messages : JSON_Array;\n-      --  Successive calls to Write append messages to this list\n-\n-      -----------------------\n-      -- Local subprograms --\n-      -----------------------\n-\n-      function To_JSON_Array\n-        (Locations : Source_Locations) return JSON_Array;\n-      --  Represent a Source_Locations array as a JSON_Array\n-\n-      function To_JSON_Value\n-        (Location : Simple_Source_Location) return JSON_Value;\n-      --  Represent a Simple_Source_Location as a JSON_Value\n-\n-      -----------\n-      -- Close --\n-      -----------\n-\n-      procedure Close is\n-         Value : constant JSON_Value := Create_Object;\n-\n-      begin\n-         --  only one field for now\n-         Set_Field (Value, Field_Names.Messages, Messages);\n-         Put_Line (File, Write (Item => Value, Compact => False));\n-         Clear (Messages);\n-         Close (File => File);\n-      end Close;\n-\n-      -------------\n-      -- Is_Open --\n-      -------------\n-\n-      function Is_Open return Boolean is (Is_Open (File));\n-\n-      ----------\n-      -- Open --\n-      ----------\n-\n-      procedure Open (File_Name : String) is\n-      begin\n-         Create (File => File, Mode => Out_File, Name => File_Name);\n-         Clear (Messages);\n-      end Open;\n-\n-      -------------------\n-      -- To_JSON_Array --\n-      -------------------\n-\n-      function To_JSON_Array\n-        (Locations : Source_Locations) return JSON_Array\n-      is\n-      begin\n-         return Result : JSON_Array := Empty_Array do\n-            for Location of Locations loop\n-               Append (Result, To_JSON_Value (Location));\n-            end loop;\n-         end return;\n-      end To_JSON_Array;\n-\n-      -------------------\n-      -- To_JSON_Value --\n-      -------------------\n-\n-      function To_JSON_Value\n-        (Location : Simple_Source_Location) return JSON_Value\n-      is\n-      begin\n-         return Result : constant JSON_Value := Create_Object do\n-            Set_Field (Result, Field_Names.File_Name, Location.File_Name);\n-            Set_Field (Result, Field_Names.Line, Integer (Location.Line));\n-            Set_Field (Result, Field_Names.Column, Integer (Location.Column));\n-            Set_Field (Result, Field_Names.Iteration_Kind, Integer'(\n-                       Iteration_Kind'Pos (Location.Iteration.Kind)));\n-\n-            if Location.Iteration.Kind = Numbered then\n-               Set_Field (Result, Field_Names.Iteration_Number,\n-                          Location.Iteration.Number);\n-               Set_Field (Result, Field_Names.Iteration_Of_Total,\n-                          Location.Iteration.Of_Total);\n-            end if;\n-         end return;\n-      end To_JSON_Value;\n-\n-      -----------\n-      -- Write --\n-      -----------\n-\n-      procedure Write (Message : SA_Message; Location : Source_Location) is\n-         Value : constant JSON_Value := Create_Object;\n-\n-      begin\n-         Set_Field (Value, Field_Names.Message_Kind, Message.Kind'Img);\n-\n-         if Message.Kind in Check_Kind then\n-            Set_Field\n-              (Value, Field_Names.Check_Result, Message.Check_Result'Img);\n-         end if;\n-\n-         Set_Field\n-           (Value, Field_Names.Locations, To_JSON_Array (Location.Locations));\n-         Append (Messages, Value);\n-      end Write;\n-   end Writing;\n-\n-   package body Reading is\n-      File       : File_Type;\n-      --  The file from which messages are read (in Open, not in Read)\n-\n-      Messages   : JSON_Array;\n-      --  The list of messages that were read in from File\n-\n-      Next_Index : Positive;\n-      --  The index of the message in Messages which will be returned by the\n-      --  next call to Get.\n-\n-      Parse_Full_Path : Boolean := True;\n-      --  if the full path or only the base name of the file should be parsed\n-\n-      -----------\n-      -- Close --\n-      -----------\n-\n-      procedure Close is\n-      begin\n-         Clear (Messages);\n-         Close (File);\n-      end Close;\n-\n-      ----------\n-      -- Done --\n-      ----------\n-\n-      function Done return Boolean is (Next_Index > Length (Messages));\n-\n-      ---------\n-      -- Get --\n-      ---------\n-\n-      function Get return Message_And_Location is\n-         Value : constant JSON_Value := Get (Messages, Next_Index);\n-\n-         function Get_Message (Kind :  Message_Kind) return SA_Message;\n-         --  Return SA_Message of given kind, filling in any non-discriminant\n-         --  by reading from Value.\n-\n-         function Make\n-           (Location : Source_Location;\n-            Message  : SA_Message) return Message_And_Location;\n-         --  Constructor\n-\n-         function To_Location\n-           (Encoded   : JSON_Array;\n-            Full_Path : Boolean) return Source_Location;\n-         --  Decode a Source_Location from JSON_Array representation\n-\n-         function To_Simple_Location\n-           (Encoded   : JSON_Value;\n-            Full_Path : Boolean) return Simple_Source_Location;\n-         --  Decode a Simple_Source_Location from JSON_Value representation\n-\n-         -----------------\n-         -- Get_Message --\n-         -----------------\n-\n-         function Get_Message (Kind :  Message_Kind) return SA_Message is\n-         begin\n-            --  If we had AI12-0086, then we could use aggregates here (which\n-            --  would be better than field-by-field assignment for the usual\n-            --  maintainability reasons). But we don't, so we won't.\n-\n-            return Result : SA_Message (Kind => Kind) do\n-               if Kind in Check_Kind then\n-                  Result.Check_Result :=\n-                    SA_Check_Result'Value\n-                      (Get (Value, Field_Names.Check_Result));\n-               end if;\n-            end return;\n-         end Get_Message;\n-\n-         ----------\n-         -- Make --\n-         ----------\n-\n-         function Make\n-           (Location : Source_Location;\n-            Message  : SA_Message) return Message_And_Location\n-         is\n-           (Count => Location.Count, Message => Message, Location => Location);\n-\n-         -----------------\n-         -- To_Location --\n-         -----------------\n-\n-         function To_Location\n-           (Encoded   : JSON_Array;\n-            Full_Path : Boolean) return Source_Location is\n-         begin\n-            return Result : Source_Location (Count => Length (Encoded)) do\n-               for I in Result.Locations'Range loop\n-                  Result.Locations (I) :=\n-                    To_Simple_Location (Get (Encoded, I), Full_Path);\n-               end loop;\n-            end return;\n-         end To_Location;\n-\n-         ------------------------\n-         -- To_Simple_Location --\n-         ------------------------\n-\n-         function To_Simple_Location\n-           (Encoded   : JSON_Value;\n-            Full_Path : Boolean) return Simple_Source_Location\n-         is\n-            function Get_Iteration_Id\n-              (Kind : Iteration_Kind) return Iteration_Id;\n-            --  Given the discriminant for an Iteration_Id value, return the\n-            --  entire value.\n-\n-            ----------------------\n-            -- Get_Iteration_Id --\n-            ----------------------\n-\n-            function Get_Iteration_Id (Kind : Iteration_Kind)\n-              return Iteration_Id\n-            is\n-            begin\n-               --  Initialize non-discriminant fields, if any\n-\n-               return Result : Iteration_Id (Kind => Kind) do\n-                  if Kind = Numbered then\n-                     Result :=\n-                       (Kind     => Numbered,\n-                        Number   =>\n-                          Get (Encoded, Field_Names.Iteration_Number),\n-                        Of_Total =>\n-                          Get (Encoded, Field_Names.Iteration_Of_Total));\n-                  end if;\n-               end return;\n-            end Get_Iteration_Id;\n-\n-            --  Local variables\n-\n-            FN : constant Unbounded_String :=\n-                   Get (Encoded, Field_Names.File_Name);\n-\n-         --  Start of processing for To_Simple_Location\n-\n-         begin\n-            return\n-              (File_Name =>\n-                 (if Full_Path then\n-                     FN\n-                  else\n-                     To_Unbounded_String (Simple_Name (To_String (FN)))),\n-               Line      =>\n-                 Line_Number (Integer'(Get (Encoded, Field_Names.Line))),\n-               Column    =>\n-                 Column_Number (Integer'(Get (Encoded, Field_Names.Column))),\n-               Iteration =>\n-                 Get_Iteration_Id\n-                   (Kind => Iteration_Kind'Val (Integer'(Get\n-                              (Encoded, Field_Names.Iteration_Kind)))));\n-         end To_Simple_Location;\n-\n-      --  Start of processing for Get\n-\n-      begin\n-         Next_Index := Next_Index + 1;\n-\n-         return Make\n-           (Message  =>\n-              Get_Message\n-                (Message_Kind'Value (Get (Value, Field_Names.Message_Kind))),\n-            Location =>\n-              To_Location\n-                (Get (Value, Field_Names.Locations), Parse_Full_Path));\n-      end Get;\n-\n-      -------------\n-      -- Is_Open --\n-      -------------\n-\n-      function Is_Open return Boolean is (Is_Open (File));\n-\n-      ----------\n-      -- Open --\n-      ----------\n-\n-      procedure Open (File_Name : String; Full_Path : Boolean := True) is\n-         File_Text : Unbounded_String := Null_Unbounded_String;\n-\n-      begin\n-         Parse_Full_Path := Full_Path;\n-         Open (File => File, Mode => In_File, Name => File_Name);\n-\n-         --  File read here, not in Get, but that's an implementation detail\n-\n-         while not End_Of_File (File) loop\n-            Append (File_Text, Get_Line (File));\n-         end loop;\n-\n-         Messages   := Get (Read (File_Text), Field_Names.Messages);\n-         Next_Index := 1;\n-      end Open;\n-   end Reading;\n-\n-end SA_Messages;"}, {"sha": "c4483974984ba4636fc9adb1a2b5818650696bbe", "filename": "gcc/ada/sa_messages.ads", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d0d27d90dbd8ecab7f8852a807d86a84e31a61c/gcc%2Fada%2Fsa_messages.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d0d27d90dbd8ecab7f8852a807d86a84e31a61c/gcc%2Fada%2Fsa_messages.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsa_messages.ads?ref=7d0d27d90dbd8ecab7f8852a807d86a84e31a61c", "patch": "@@ -1,267 +0,0 @@\n-------------------------------------------------------------------------------\n---                       C O D E P E E R / S P A R K                        --\n---                                                                          --\n---                     Copyright (C) 2015-2022, AdaCore                     --\n---                                                                          --\n--- This is free software;  you can redistribute it  and/or modify it  under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  This software is distributed in the hope  that it will be useful, --\n--- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n--- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --\n--- License for  more details.  You should have  received  a copy of the GNU --\n--- General  Public  License  distributed  with  this  software;   see  file --\n--- COPYING3.  If not, go to http://www.gnu.org/licenses for a complete copy --\n--- of the license.                                                          --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-pragma Ada_2012;\n-\n-with Ada.Containers;        use Ada.Containers;\n-with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n-\n-package SA_Messages is\n-\n-   --  This package can be used for reading/writing a file containing a\n-   --  sequence of static anaysis results. Each element can describe a runtime\n-   --  check whose outcome has been statically determined, or it might be a\n-   --  warning or diagnostic message. It is expected that typically CodePeer\n-   --  will do the writing and SPARK will do the reading; this will allow SPARK\n-   --  to get the benefit of CodePeer's analysis.\n-   --\n-   --  Each item is represented as a pair consisting of a message and an\n-   --  associated source location. Source locations may refer to a location\n-   --  within the expansion of an instance of a generic; this is represented\n-   --  by combining the corresponding location within the generic with the\n-   --  location of the instance (repeated if the instance itself occurs within\n-   --  a generic). In addition, the type Iteration_Id is intended for use in\n-   --  distinguishing messages which refer to a specific iteration of a loop\n-   --  (this case can arise, for example, if CodePeer chooses to unroll a\n-   --  for-loop). This data structure is only general enough to support the\n-   --  kinds of unrolling that are currently planned for CodePeer. For\n-   --  example, an Iteration_Id can only identify an iteration of the nearest\n-   --  enclosing loop of the associated File/Line/Column source location.\n-   --  This is not a problem because CodePeer doesn't unroll loops which\n-   --  contain other loops.\n-\n-   type Message_Kind is (\n-\n-      --  Check kinds\n-\n-      Array_Index_Check,\n-      Divide_By_Zero_Check,\n-      Tag_Check,\n-      Discriminant_Check,\n-      Range_Check,\n-      Overflow_Check,\n-      Assertion_Check,\n-\n-      --  Warning kinds\n-\n-      Suspicious_Range_Precondition_Warning,\n-      Suspicious_First_Precondition_Warning,\n-      Suspicious_Input_Warning,\n-      Suspicious_Constant_Operation_Warning,\n-      Unread_In_Out_Parameter_Warning,\n-      Unassigned_In_Out_Parameter_Warning,\n-      Non_Analyzed_Call_Warning,\n-      Procedure_Does_Not_Return_Warning,\n-      Check_Fails_On_Every_Call_Warning,\n-      Unknown_Call_Warning,\n-      Dead_Store_Warning,\n-      Dead_Outparam_Store_Warning,\n-      Potentially_Dead_Store_Warning,\n-      Same_Value_Dead_Store_Warning,\n-      Dead_Block_Warning,\n-      Infinite_Loop_Warning,\n-      Dead_Edge_Warning,\n-      Plain_Dead_Edge_Warning,\n-      True_Dead_Edge_Warning,\n-      False_Dead_Edge_Warning,\n-      True_Condition_Dead_Edge_Warning,\n-      False_Condition_Dead_Edge_Warning,\n-      Unrepeatable_While_Loop_Warning,\n-      Dead_Block_Continuation_Warning,\n-      Local_Lock_Of_Global_Object_Warning,\n-      Analyzed_Module_Warning,\n-      Non_Analyzed_Module_Warning,\n-      Non_Analyzed_Procedure_Warning,\n-      Incompletely_Analyzed_Procedure_Warning);\n-\n-   --  Assertion_Check includes checks for user-defined PPCs (both specific\n-   --  and class-wide), Assert pragma checks, subtype predicate checks,\n-   --  type invariant checks (specific and class-wide), and checks for\n-   --  implementation-defined assertions such as Assert_And_Cut, Assume,\n-   --  Contract_Cases, Default_Initial_Condition, Initial_Condition,\n-   --  Loop_Invariant, Loop_Variant, Refined_Post, and Subprogram_Variant.\n-   --\n-   --  It might be nice to distinguish these different kinds of assertions\n-   --  as is done in SPARK's VC_Kind enumeration type, but any distinction\n-   --  which isn't already present in CP's BE_Message_Subkind enumeration type\n-   --  would require more work on the CP side.\n-   --\n-   --  The warning kinds are pretty much a copy of the set of\n-   --  Be_Message_Subkind values for which CP's Is_Warning predicate returns\n-   --  True; see descriptive comment for each in CP's message_kinds.ads .\n-\n-   subtype Check_Kind is Message_Kind\n-     range Array_Index_Check .. Assertion_Check;\n-   subtype Warning_Kind is Message_Kind\n-     range Message_Kind'Succ (Check_Kind'Last) .. Message_Kind'Last;\n-\n-   --  Possible outcomes of the static analysis of a runtime check\n-   --\n-   --  Not_Statically_Known_With_Low_Severity could be used instead of of\n-   --  Not_Statically_Known if there is some reason to believe that (although\n-   --  the tool couldn't prove it) the check is likely to always pass (in CP\n-   --  terms, if the corresponding CP message has severity Low as opposed to\n-   --  Medium). It's not clear yet whether SPARK will care about this\n-   --  distinction.\n-\n-   type SA_Check_Result is\n-     (Statically_Known_Success,\n-      Not_Statically_Known_With_Low_Severity,\n-      Not_Statically_Known,\n-      Statically_Known_Failure);\n-\n-   type SA_Message (Kind : Message_Kind := Message_Kind'Last) is record\n-      case Kind is\n-         when Check_Kind =>\n-            Check_Result : SA_Check_Result;\n-\n-         when Warning_Kind =>\n-            null;\n-      end case;\n-   end record;\n-\n-   type Source_Location_Or_Null (<>) is private;\n-   Null_Location : constant Source_Location_Or_Null;\n-   subtype Source_Location is Source_Location_Or_Null with\n-     Dynamic_Predicate => Source_Location /= Null_Location;\n-\n-   type Line_Number is new Positive;\n-   type Column_Number is new Positive;\n-\n-   function File_Name (Location : Source_Location) return String;\n-   function File_Name (Location : Source_Location) return Unbounded_String;\n-   function Line      (Location : Source_Location) return Line_Number;\n-   function Column    (Location : Source_Location) return Column_Number;\n-\n-   type Iteration_Kind is (None, Initial, Subsequent, Numbered);\n-   --  None is for the usual no-unrolling case.\n-   --  Initial and Subsequent are for use in the case where only the first\n-   --  iteration of a loop (or some part thereof, such as the termination\n-   --  test of a while-loop) is unrolled.\n-   --  Numbered is for use in the case where a for-loop with a statically\n-   --  known number of iterations is fully unrolled.\n-\n-   subtype Iteration_Number is Integer range 1 .. 255;\n-   subtype Iteration_Total  is Integer range 2 .. 255;\n-\n-   type Iteration_Id (Kind : Iteration_Kind := None) is record\n-      case Kind is\n-         when Numbered =>\n-            Number   : Iteration_Number;\n-            Of_Total : Iteration_Total;\n-         when others =>\n-            null;\n-      end case;\n-   end record;\n-\n-   function Iteration (Location : Source_Location) return Iteration_Id;\n-\n-   function Enclosing_Instance\n-     (Location : Source_Location) return Source_Location_Or_Null;\n-   --  For a source location occurring within the expansion of an instance of a\n-   --  generic unit, the Line, Column, and File_Name selectors will indicate a\n-   --  location within the generic; the Enclosing_Instance selector yields the\n-   --  location of the declaration of the instance.\n-\n-   function Make\n-     (File_Name : String;\n-      Line      : Line_Number;\n-      Column    : Column_Number;\n-      Iteration : Iteration_Id;\n-      Enclosing_Instance : Source_Location_Or_Null) return Source_Location;\n-   --  Constructor\n-\n-   type Message_And_Location (<>) is private;\n-\n-   function Location (Item : Message_And_Location) return Source_Location;\n-   function Message (Item : Message_And_Location) return SA_Message;\n-\n-   function Make_Msg_Loc\n-     (Msg : SA_Message;\n-      Loc : Source_Location) return Message_And_Location;\n-   --  Selectors\n-\n-   function \"<\" (Left, Right : Message_And_Location) return Boolean;\n-   function Hash (Key : Message_And_Location) return Hash_Type;\n-   --  Actuals for container instances\n-\n-   File_Extension : constant String; -- \".json\" (but could change in future)\n-   --  Clients may wish to use File_Extension in constructing\n-   --  File_Name parameters for calls to Open.\n-\n-   package Writing is\n-      function Is_Open return Boolean;\n-\n-      procedure Open (File_Name : String) with\n-        Precondition  => not Is_Open,\n-        Postcondition => Is_Open;\n-      --  Behaves like Text_IO.Create with respect to error cases\n-\n-      procedure Write (Message : SA_Message; Location : Source_Location);\n-\n-      procedure Close with\n-        Precondition  => Is_Open,\n-        Postcondition => not Is_Open;\n-      --  Behaves like Text_IO.Close with respect to error cases\n-   end Writing;\n-\n-   package Reading is\n-      function Is_Open return Boolean;\n-\n-      procedure Open (File_Name : String; Full_Path : Boolean := True) with\n-        Precondition  => not Is_Open,\n-        Postcondition => Is_Open;\n-      --  Behaves like Text_IO.Open with respect to error cases\n-\n-      function Done return Boolean with\n-        Precondition => Is_Open;\n-\n-      function Get return Message_And_Location with\n-        Precondition => not Done;\n-\n-      procedure Close with\n-        Precondition  => Is_Open,\n-        Postcondition => not Is_Open;\n-      --  Behaves like Text_IO.Close with respect to error cases\n-   end Reading;\n-\n-private\n-   type Simple_Source_Location is record\n-      File_Name : Unbounded_String := Null_Unbounded_String;\n-      Line      : Line_Number      := Line_Number'Last;\n-      Column    : Column_Number    := Column_Number'Last;\n-      Iteration : Iteration_Id     := (Kind => None);\n-   end record;\n-\n-   type Source_Locations is\n-     array (Natural range <>) of Simple_Source_Location;\n-\n-   type Source_Location_Or_Null (Count : Natural) is record\n-      Locations : Source_Locations (1 .. Count);\n-   end record;\n-\n-   Null_Location : constant Source_Location_Or_Null :=\n-                     (Count => 0, Locations => (others => <>));\n-\n-   type Message_And_Location (Count : Positive) is record\n-      Message  : SA_Message;\n-      Location : Source_Location (Count => Count);\n-   end record;\n-\n-   File_Extension : constant String := \".json\";\n-end SA_Messages;"}]}