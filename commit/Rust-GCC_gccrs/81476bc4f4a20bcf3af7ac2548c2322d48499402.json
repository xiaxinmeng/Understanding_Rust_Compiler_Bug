{"sha": "81476bc4f4a20bcf3af7ac2548c2322d48499402", "node_id": "C_kwDOANBUbNoAKDgxNDc2YmM0ZjRhMjBiY2YzYWY3YWMyNTQ4YzIzMjJkNDg0OTk0MDI", "commit": {"author": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-12-06T13:42:46Z"}, "committer": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-12-06T14:03:50Z"}, "message": "OpenMP: omp_get_max_teams, omp_set_num_teams, and omp_{gs}et_teams_thread_limit on offload devices\n\nThis patch adds support for omp_get_max_teams, omp_set_num_teams, and\nomp_{gs}et_teams_thread_limit on offload devices. That includes the usage of\ndevice-specific ICV values (specified as environment variables or changed on a\ndevice). In order to reuse device-specific ICV values, a copy back mechanism is\nimplemented that copies ICV values back from device to the host.\n\nAdditionally, a limitation of the number of teams on gcn offload devices is\nimplemented.  The number of teams is limited by twice the number of compute\nunits (one team is executed on one compute unit).  This avoids queueing\nunnessecary many teams and a corresponding allocation of large amounts of\nmemory.  Without that limitation the memory allocation for a large number of\nuser-specified teams can result in an \"memory access fault\".\nA limitation of the number of teams is already also implemented for nvptx\ndevices (see nvptx_adjust_launch_bounds in libgomp/plugin/plugin-nvptx.c).\n\ngcc/ChangeLog:\n\n\t* gimplify.cc (optimize_target_teams): Set initial num_teams_upper\n\tto \"-2\" instead of \"1\" for non-existing num_teams clause in order to\n\tdisambiguate from the case of an existing num_teams clause with value 1.\n\nlibgomp/ChangeLog:\n\n\t* config/gcn/icv-device.c (omp_get_teams_thread_limit): Added to\n\tallow processing of device-specific values.\n\t(omp_set_teams_thread_limit): Likewise.\n\t(ialias): Likewise.\n\t* config/nvptx/icv-device.c (omp_get_teams_thread_limit): Likewise.\n\t(omp_set_teams_thread_limit): Likewise.\n\t(ialias): Likewise.\n\t* icv-device.c (omp_get_teams_thread_limit): Likewise.\n\t(ialias): Likewise.\n\t(omp_set_teams_thread_limit): Likewise.\n\t* icv.c (omp_set_teams_thread_limit): Removed.\n\t(omp_get_teams_thread_limit): Likewise.\n\t(ialias): Likewise.\n\t* libgomp.texi: Updated documentation for nvptx and gcn corresponding\n\tto the limitation of the number of teams.\n\t* plugin/plugin-gcn.c (limit_teams): New helper function that limits\n\tthe number of teams by twice the number of compute units.\n\t(parse_target_attributes): Limit the number of teams on gcn offload\n\tdevices.\n\t* target.c (get_gomp_offload_icvs): Added teams_thread_limit_var\n\thandling.\n\t(gomp_load_image_to_device): Added a size check for the ICVs struct\n\tvariable.\n\t(gomp_copy_back_icvs): New function that is used in GOMP_target_ext to\n\tcopy back the ICV values from device to host.\n\t(GOMP_target_ext): Update the number of teams and threads in the kernel\n\targs also considering device-specific values.\n\t* testsuite/libgomp.c-c++-common/icv-4.c: Fixed an error in the reading\n\tof OMP_TEAMS_THREAD_LIMIT from the environment.\n\t* testsuite/libgomp.c-c++-common/icv-5.c: Extended.\n\t* testsuite/libgomp.c-c++-common/icv-6.c: Extended.\n\t* testsuite/libgomp.c-c++-common/icv-7.c: Extended.\n\t* testsuite/libgomp.c-c++-common/icv-9.c: New test.\n\t* testsuite/libgomp.fortran/icv-5.f90: New test.\n\t* testsuite/libgomp.fortran/icv-6.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/target-teams-1.c: Adapt expected values for\n\tnum_teams from \"1\" to \"-2\" in cases without num_teams clause.\n\t* g++.dg/gomp/target-teams-1.C: Likewise.\n\t* gfortran.dg/gomp/defaultmap-4.f90: Likewise.\n\t* gfortran.dg/gomp/defaultmap-5.f90: Likewise.\n\t* gfortran.dg/gomp/defaultmap-6.f90: Likewise.", "tree": {"sha": "05f4c4edec59886eab84c6e595023c03fdf5991e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05f4c4edec59886eab84c6e595023c03fdf5991e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81476bc4f4a20bcf3af7ac2548c2322d48499402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81476bc4f4a20bcf3af7ac2548c2322d48499402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81476bc4f4a20bcf3af7ac2548c2322d48499402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81476bc4f4a20bcf3af7ac2548c2322d48499402/comments", "author": null, "committer": null, "parents": [{"sha": "400d9fc1f04336118c3200e2af14a620e7ea1d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400d9fc1f04336118c3200e2af14a620e7ea1d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/400d9fc1f04336118c3200e2af14a620e7ea1d95"}], "stats": {"total": 1070, "additions": 1015, "deletions": 55}, "files": [{"sha": "250782b11409c4a1cee23a7097a7df2fd6038258", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -15233,6 +15233,7 @@ computable_teams_clause (tree *tp, int *walk_subtrees, void *)\n    0 stands for clause not specified at all, use implementation default\n    -1 stands for value that can't be determined easily before entering\n       the target construct.\n+   -2 means that no explicit teams construct was specified\n    If teams construct is not present at all, use 1 for num_teams\n    and 0 for thread_limit (only one team is involved, and the thread\n    limit is implementation defined.  */\n@@ -15251,7 +15252,7 @@ optimize_target_teams (tree target, gimple_seq *pre_p)\n   struct gimplify_omp_ctx *target_ctx = gimplify_omp_ctxp;\n \n   if (teams == NULL_TREE)\n-    num_teams_upper = integer_one_node;\n+    num_teams_upper = build_int_cst (integer_type_node, -2);\n   else\n     for (c = OMP_TEAMS_CLAUSES (teams); c; c = OMP_CLAUSE_CHAIN (c))\n       {"}, {"sha": "74d60e1066e7ffd0bec194b24186fa5d0ee0471f", "filename": "gcc/testsuite/c-c++-common/gomp/target-teams-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-teams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-teams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-teams-1.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -81,5 +81,5 @@ foo (int a, int b, long c, long d)\n /* { dg-final { scan-tree-dump-times \"thread_limit\\\\(-1\\\\)\" 3 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"num_teams\\\\(0\\\\)\" 4 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"thread_limit\\\\(0\\\\)\" 6 \"gimple\" } } */\n-/* { dg-final { scan-tree-dump-times \"num_teams\\\\(1\\\\)\" 2 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(-2\\\\)\" 2 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"thread_limit\\\\(1\\\\)\" 0 \"gimple\" } } */"}, {"sha": "29e55970e452cea1e283dc26ea121372c25c56ff", "filename": "gcc/testsuite/g++.dg/gomp/target-teams-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-teams-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-teams-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-teams-1.C?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -88,5 +88,5 @@ foo (int a, int b, long c, long d)\n /* { dg-final { scan-tree-dump-times \"thread_limit\\\\(-1\\\\)\" 3 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"num_teams\\\\(0\\\\)\" 4 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"thread_limit\\\\(0\\\\)\" 6 \"gimple\" } } */\n-/* { dg-final { scan-tree-dump-times \"num_teams\\\\(1\\\\)\" 2 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"num_teams\\\\(-2\\\\)\" 2 \"gimple\" } } */\n /* { dg-final { scan-tree-dump-times \"thread_limit\\\\(1\\\\)\" 0 \"gimple\" } } */"}, {"sha": "9081159929133840d124fcaf73c7afe36be3bb59", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-4.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-4.f90?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -141,5 +141,5 @@\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxparr \\\\\\[len:\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:strxparr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxp \\\\\\[len:\" 2 \"gimple\" } }\n-! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(alloc\\\\)\" 1 \"gimple\" } }\n-! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(alloc:scalar\\\\) defaultmap\\\\(to:aggregate\\\\) defaultmap\\\\(tofrom:allocatable\\\\) defaultmap\\\\(firstprivate:pointer\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(-2\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(alloc\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(-2\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(alloc:scalar\\\\) defaultmap\\\\(to:aggregate\\\\) defaultmap\\\\(tofrom:allocatable\\\\) defaultmap\\\\(firstprivate:pointer\\\\)\" 1 \"gimple\" } }"}, {"sha": "91566ed4a1c441d1e05cb386b1a9648730b88ee9", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-5.f90?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -141,5 +141,5 @@\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:strxparr \\\\\\[pointer set, len:\" 2 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*strxp \\\\\\[len:\" 1 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxp \\\\\\[len:\" 1 \"gimple\" } }\n-! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(to\\\\)\" 1 \"gimple\" } }\n-! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(to:scalar\\\\) defaultmap\\\\(tofrom:aggregate\\\\) defaultmap\\\\(firstprivate:allocatable\\\\) defaultmap\\\\(default:pointer\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(-2\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(to\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(-2\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(to:scalar\\\\) defaultmap\\\\(tofrom:aggregate\\\\) defaultmap\\\\(firstprivate:allocatable\\\\) defaultmap\\\\(default:pointer\\\\)\" 1 \"gimple\" } }"}, {"sha": "867e41aab82eba50060f28fbbe4f5f9da2e5ad19", "filename": "gcc/testsuite/gfortran.dg/gomp/defaultmap-6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdefaultmap-6.f90?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -101,4 +101,4 @@\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxparr \\\\\\[len:\" 1 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:strxparr \\\\\\[pointer set, len:\" 1 \"gimple\" } }\n ! { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\.strxp \\\\\\[len:\" 1 \"gimple\" } }\n-! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(1\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(default\\\\)\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp target num_teams\\\\(-2\\\\) thread_limit\\\\(0\\\\) defaultmap\\\\(default\\\\)\" 1 \"gimple\" } }"}, {"sha": "eb68881ab49e94e8fe0c01802fe25bbaf936522b", "filename": "libgomp/config/gcn/icv-device.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ficv-device.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -81,6 +81,19 @@ omp_set_num_teams (int num_teams)\n     GOMP_ADDITIONAL_ICVS.nteams = num_teams;\n }\n \n+int\n+omp_get_teams_thread_limit (void)\n+{\n+  return GOMP_ADDITIONAL_ICVS.teams_thread_limit;\n+}\n+\n+void\n+omp_set_teams_thread_limit (int thread_limit)\n+{\n+  if (thread_limit >= 0)\n+    GOMP_ADDITIONAL_ICVS.teams_thread_limit = thread_limit;\n+}\n+\n ialias (omp_set_default_device)\n ialias (omp_get_default_device)\n ialias (omp_get_initial_device)\n@@ -89,3 +102,5 @@ ialias (omp_is_initial_device)\n ialias (omp_get_device_num)\n ialias (omp_get_max_teams)\n ialias (omp_set_num_teams)\n+ialias (omp_get_teams_thread_limit)\n+ialias (omp_set_teams_thread_limit)"}, {"sha": "818e69651d6cab83b073142a8bc20c0f06b9dd39", "filename": "libgomp/config/nvptx/icv-device.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -81,6 +81,19 @@ omp_set_num_teams (int num_teams)\n     GOMP_ADDITIONAL_ICVS.nteams = num_teams;\n }\n \n+int\n+omp_get_teams_thread_limit (void)\n+{\n+  return GOMP_ADDITIONAL_ICVS.teams_thread_limit;\n+}\n+\n+void\n+omp_set_teams_thread_limit (int thread_limit)\n+{\n+  if (thread_limit >= 0)\n+    GOMP_ADDITIONAL_ICVS.teams_thread_limit = thread_limit;\n+}\n+\n ialias (omp_set_default_device)\n ialias (omp_get_default_device)\n ialias (omp_get_initial_device)\n@@ -89,3 +102,5 @@ ialias (omp_is_initial_device)\n ialias (omp_get_device_num)\n ialias (omp_get_max_teams)\n ialias (omp_set_num_teams)\n+ialias (omp_get_teams_thread_limit)\n+ialias (omp_set_teams_thread_limit)"}, {"sha": "48607cefe4a02ca0bcd815068ebfdb447d5460ab", "filename": "libgomp/icv-device.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv-device.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -97,3 +97,20 @@ omp_set_num_teams (int num_teams)\n }\n \n ialias (omp_set_num_teams)\n+\n+int\n+omp_get_teams_thread_limit (void)\n+{\n+  return gomp_teams_thread_limit_var;\n+}\n+\n+ialias (omp_get_teams_thread_limit)\n+\n+void\n+omp_set_teams_thread_limit (int thread_limit)\n+{\n+  if (thread_limit >= 0)\n+    gomp_teams_thread_limit_var = thread_limit;\n+}\n+\n+ialias (omp_set_teams_thread_limit)"}, {"sha": "9aef91cf4846da9ce4dfe2957828a92bf674c1f0", "filename": "libgomp/icv.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ficv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ficv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -148,19 +148,6 @@ omp_get_supported_active_levels (void)\n   return gomp_supported_active_levels;\n }\n \n-void\n-omp_set_teams_thread_limit (int thread_limit)\n-{\n-  if (thread_limit >= 0)\n-    gomp_teams_thread_limit_var = thread_limit;\n-}\n-\n-int\n-omp_get_teams_thread_limit (void)\n-{\n-  return gomp_teams_thread_limit_var;\n-}\n-\n int\n omp_get_cancellation (void)\n {\n@@ -261,8 +248,6 @@ ialias (omp_get_thread_limit)\n ialias (omp_set_max_active_levels)\n ialias (omp_get_max_active_levels)\n ialias (omp_get_supported_active_levels)\n-ialias (omp_set_teams_thread_limit)\n-ialias (omp_get_teams_thread_limit)\n ialias (omp_get_cancellation)\n ialias (omp_get_proc_bind)\n ialias (omp_get_max_task_priority)"}, {"sha": "e8798a09c0e161e06c2dc056d6057f757e26542e", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -4421,7 +4421,7 @@ On the hardware side, there is the hierarchy (fine to coarse):\n @item work item (thread)\n @item wavefront\n @item work group\n-@item compute unite (CU)\n+@item compute unit (CU)\n @end itemize\n \n All OpenMP and OpenACC levels are used, i.e.\n@@ -4436,7 +4436,8 @@ All OpenMP and OpenACC levels are used, i.e.\n The used sizes are\n @itemize\n @item Number of teams is the specified @code{num_teams} (OpenMP) or\n-      @code{num_gangs} (OpenACC) or otherwise the number of CU\n+      @code{num_gangs} (OpenACC) or otherwise the number of CU. It is limited\n+      by two times the number of CU.\n @item Number of wavefronts is 4 for gfx900 and 16 otherwise;\n       @code{num_threads} (OpenMP) and @code{num_workers} (OpenACC)\n       overrides this if smaller.\n@@ -4482,6 +4483,8 @@ The used sizes are\n @itemize\n @item The @code{warp_size} is always 32\n @item CUDA kernel launched: @code{dim=@{#teams,1,1@}, blocks=@{#threads,warp_size,1@}}.\n+@item The number of teams is limited by the number of blocks the device can\n+      host simultaneously.\n @end itemize\n \n Additional information can be obtained by setting the environment variable to"}, {"sha": "f9b8dda75d6898ec18e875f00f39464616546750", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -1150,6 +1150,18 @@ limit_worker_threads (int threads)\n   return threads;\n }\n \n+/* This sets the maximum number of teams to twice the number of GPU Compute\n+   Units to avoid memory waste and corresponding memory access faults.  */\n+\n+static int\n+limit_teams (int teams, struct agent_info *agent)\n+{\n+  int max_teams = 2 * get_cu_count (agent);\n+  if (teams > max_teams)\n+    teams = max_teams;\n+  return teams;\n+}\n+\n /* Parse the target attributes INPUT provided by the compiler and return true\n    if we should run anything all.  If INPUT is NULL, fill DEF with default\n    values, then store INPUT or DEF into *RESULT.\n@@ -1194,7 +1206,7 @@ parse_target_attributes (void **input,\n \t  switch (id & GOMP_TARGET_ARG_ID_MASK)\n \t    {\n \t    case GOMP_TARGET_ARG_NUM_TEAMS:\n-\t      gcn_teams = val;\n+\t      gcn_teams = limit_teams (val, agent);\n \t      break;\n \t    case GOMP_TARGET_ARG_THREAD_LIMIT:\n \t      gcn_threads = limit_worker_threads (val);"}, {"sha": "06809dbc710fb61aceb2f3215c24a29eeff6e7dc", "filename": "libgomp/target.c", "status": "modified", "additions": 184, "deletions": 4, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -2154,6 +2154,19 @@ get_gomp_offload_icvs (int dev_num)\n   else\n     new->icvs.nteams = gomp_default_icv_values.nteams_var;\n \n+  if (dev_x != NULL\n+      && gomp_get_icv_flag (dev_x->flags, GOMP_ICV_TEAMS_THREAD_LIMIT))\n+    new->icvs.teams_thread_limit = dev_x->icvs.teams_thread_limit_var;\n+  else if (dev != NULL\n+\t   && gomp_get_icv_flag (dev->flags, GOMP_ICV_TEAMS_THREAD_LIMIT))\n+    new->icvs.teams_thread_limit = dev->icvs.teams_thread_limit_var;\n+  else if (all != NULL\n+\t   && gomp_get_icv_flag (all->flags, GOMP_ICV_TEAMS_THREAD_LIMIT))\n+    new->icvs.teams_thread_limit = all->icvs.teams_thread_limit_var;\n+  else\n+    new->icvs.teams_thread_limit\n+      = gomp_default_icv_values.teams_thread_limit_var;\n+\n   if (dev_x != NULL\n       && gomp_get_icv_flag (dev_x->flags, GOMP_ICV_DEFAULT_DEVICE))\n     new->icvs.default_device = dev_x->icvs.default_device_var;\n@@ -2290,7 +2303,14 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n \t  int dev_num = (int) (devicep - &devices[0]);\n \t  struct gomp_offload_icvs *icvs = get_gomp_offload_icvs (dev_num);\n \t  size_t var_size = var->end - var->start;\n-\n+\t  if (var_size != sizeof (struct gomp_offload_icvs))\n+\t    {\n+\t      gomp_mutex_unlock (&devicep->lock);\n+\t      if (is_register_lock)\n+\t\tgomp_mutex_unlock (&register_lock);\n+\t      gomp_fatal (\"offload plugin managed 'icv struct' not of expected \"\n+\t\t\t  \"format\");\n+\t    }\n \t  /* Copy the ICVs variable to place on device memory, hereby\n \t     actually designating its device number into effect.  */\n \t  gomp_copy_host2dev (devicep, NULL, (void *) var->start, icvs,\n@@ -2769,6 +2789,20 @@ clear_unsupported_flags (struct gomp_device_descr *devicep, unsigned int flags)\n   return flags;\n }\n \n+static void\n+gomp_copy_back_icvs (struct gomp_device_descr *devicep, int device)\n+{\n+  struct gomp_offload_icv_list *item = gomp_get_offload_icv_item (device);\n+  if (item == NULL)\n+    return;\n+\n+  void *host_ptr = &item->icvs;\n+  void *dev_ptr = omp_get_mapped_ptr (host_ptr, device);\n+  if (dev_ptr != NULL)\n+    gomp_copy_dev2host (devicep, NULL, host_ptr, dev_ptr,\n+\t\t\tsizeof (struct gomp_offload_icvs));\n+}\n+\n /* Like GOMP_target, but KINDS is 16-bit, UNUSED is no longer present,\n    and several arguments have been added:\n    FLAGS is a bitmask, see GOMP_TARGET_FLAG_* in gomp-constants.h.\n@@ -2801,6 +2835,146 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n   size_t tgt_align = 0, tgt_size = 0;\n   bool fpc_done = false;\n \n+  /* Obtain the original TEAMS and THREADS values from ARGS.  */\n+  intptr_t orig_teams = 1, orig_threads = 0;\n+  size_t num_args = 0, len = 1, teams_len = 1, threads_len = 1;\n+  void **tmpargs = args;\n+  while (*tmpargs)\n+    {\n+      intptr_t id = (intptr_t) *tmpargs++, val;\n+      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n+\t{\n+\t  val = (intptr_t) *tmpargs++;\n+\t  len = 2;\n+\t}\n+      else\n+\t{\n+\t  val = id >> GOMP_TARGET_ARG_VALUE_SHIFT;\n+\t  len = 1;\n+\t}\n+      num_args += len;\n+      if ((id & GOMP_TARGET_ARG_DEVICE_MASK) != GOMP_TARGET_ARG_DEVICE_ALL)\n+\tcontinue;\n+      val = val > INT_MAX ? INT_MAX : val;\n+      if ((id & GOMP_TARGET_ARG_ID_MASK) == GOMP_TARGET_ARG_NUM_TEAMS)\n+\t{\n+\t  orig_teams = val;\n+\t  teams_len = len;\n+\t}\n+      else if ((id & GOMP_TARGET_ARG_ID_MASK) == GOMP_TARGET_ARG_THREAD_LIMIT)\n+\t{\n+\t  orig_threads = val;\n+\t  threads_len = len;\n+\t}\n+    }\n+\n+  intptr_t new_teams = orig_teams, new_threads = orig_threads;\n+  /* ORIG_TEAMS == -2: No explicit teams construct specified.  Set to 1.\n+     ORIG_TEAMS == -1: TEAMS construct with NUM_TEAMS clause specified, but the\n+\t\t       value could not be determined.  No change.\n+     ORIG_TEAMS == 0: TEAMS construct without NUM_TEAMS clause.\n+\t\t      Set device-specific value.\n+     ORIG_TEAMS > 0: Value was already set through e.g. NUM_TEAMS clause.\n+\t\t     No change.  */\n+  if (orig_teams == -2)\n+    new_teams = 1;\n+  else if (orig_teams == 0)\n+    {\n+      struct gomp_offload_icv_list *item = gomp_get_offload_icv_item (device);\n+      if (item != NULL)\n+\tnew_teams = item->icvs.nteams;\n+    }\n+  /* The device-specific teams-thread-limit is only set if (a) an explicit TEAMS\n+     region exists, i.e. ORIG_TEAMS > -2, and (b) THREADS was not already set by\n+     e.g. a THREAD_LIMIT clause.  */\n+  if (orig_teams > -2 && orig_threads == 0)\n+    {\n+      struct gomp_offload_icv_list *item = gomp_get_offload_icv_item (device);\n+      if (item != NULL)\n+\tnew_threads = item->icvs.teams_thread_limit;\n+    }\n+\n+  /* Copy and change the arguments list only if TEAMS or THREADS need to be\n+     updated.  */\n+  void **new_args = args;\n+  if (orig_teams != new_teams || orig_threads != new_threads)\n+    {\n+      size_t tms_len = (orig_teams == new_teams\n+\t\t\t? teams_len\n+\t\t\t: (new_teams > -(1 << 15) && new_teams < (1 << 15)\n+\t\t\t   ? 1 : 2));\n+      size_t ths_len = (orig_threads == new_threads\n+\t\t\t? threads_len\n+\t\t\t: (new_threads > -(1 << 15) && new_threads < (1 << 15)\n+\t\t\t   ? 1 : 2));\n+      /* One additional item after the last arg must be NULL.  */\n+      size_t new_args_cnt = num_args - teams_len - threads_len + tms_len\n+\t\t\t    + ths_len + 1;\n+      new_args = (void **) gomp_alloca (new_args_cnt * sizeof (void*));\n+\n+      tmpargs = args;\n+      void **tmp_new_args = new_args;\n+      /* Copy all args except TEAMS and THREADS.  TEAMS and THREADS are copied\n+\t too if they have not been changed and skipped otherwise.  */\n+      while (*tmpargs)\n+\t{\n+\t  intptr_t id = (intptr_t) *tmpargs;\n+\t  if (((id & GOMP_TARGET_ARG_ID_MASK) == GOMP_TARGET_ARG_NUM_TEAMS\n+\t       && orig_teams != new_teams)\n+\t      || ((id & GOMP_TARGET_ARG_ID_MASK) == GOMP_TARGET_ARG_THREAD_LIMIT\n+\t\t  && orig_threads != new_threads))\n+\t    {\n+\t      tmpargs++;\n+\t      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n+\t\ttmpargs++;\n+\t    }\n+\t  else\n+\t    {\n+\t      *tmp_new_args++ = *tmpargs++;\n+\t      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n+\t\t*tmp_new_args++ = *tmpargs++;\n+\t    }\n+\t}\n+\n+      /* Add the new TEAMS arg to the new args list if it has been changed.  */\n+      if (orig_teams != new_teams)\n+\t{\n+\t  intptr_t new_val = new_teams;\n+\t  if (tms_len == 1)\n+\t    {\n+\t      new_val = (new_val << GOMP_TARGET_ARG_VALUE_SHIFT)\n+\t\t\t | GOMP_TARGET_ARG_NUM_TEAMS;\n+\t      *tmp_new_args++ = (void *) new_val;\n+\t    }\n+\t  else\n+\t    {\n+\t      *tmp_new_args++ = (void *) (GOMP_TARGET_ARG_SUBSEQUENT_PARAM\n+\t\t\t\t\t  | GOMP_TARGET_ARG_NUM_TEAMS);\n+\t      *tmp_new_args++ = (void *) new_val;\n+\t    }\n+\t}\n+\n+      /* Add the new THREADS arg to the new args list if it has been changed. */\n+      if (orig_threads != new_threads)\n+\t{\n+\t  intptr_t new_val = new_threads;\n+\t  if (ths_len == 1)\n+\t    {\n+\t      new_val = (new_val << GOMP_TARGET_ARG_VALUE_SHIFT)\n+\t\t\t | GOMP_TARGET_ARG_THREAD_LIMIT;\n+\t      *tmp_new_args++ = (void *) new_val;\n+\t    }\n+\t  else\n+\t    {\n+\t      *tmp_new_args++ = (void *) (GOMP_TARGET_ARG_SUBSEQUENT_PARAM\n+\t\t\t\t\t  | GOMP_TARGET_ARG_THREAD_LIMIT);\n+\t      *tmp_new_args++ = (void *) new_val;\n+\t    }\n+\t}\n+\n+      *tmp_new_args = NULL;\n+    }\n+\n   flags = clear_unsupported_flags (devicep, flags);\n \n   if (flags & GOMP_TARGET_FLAG_NOWAIT)\n@@ -2848,7 +3022,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t  && !thr->task->final_task)\n \t{\n \t  gomp_create_target_task (devicep, fn, mapnum, hostaddrs,\n-\t\t\t\t   sizes, kinds, flags, depend, args,\n+\t\t\t\t   sizes, kinds, flags, depend, new_args,\n \t\t\t\t   GOMP_TARGET_TASK_BEFORE_MAP);\n \t  return;\n \t}\n@@ -2894,7 +3068,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t\t\t      tgt_align, tgt_size);\n \t    }\n \t}\n-      gomp_target_fallback (fn, hostaddrs, devicep, args);\n+      gomp_target_fallback (fn, hostaddrs, devicep, new_args);\n       return;\n     }\n \n@@ -2924,14 +3098,20 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n     }\n   devicep->run_func (devicep->target_id, fn_addr,\n \t\t     tgt_vars ? (void *) tgt_vars->tgt_start : hostaddrs,\n-\t\t     args);\n+\t\t     new_args);\n   if (tgt_vars)\n     {\n       htab_clear (refcount_set);\n       gomp_unmap_vars (tgt_vars, true, &refcount_set);\n     }\n   if (refcount_set)\n     htab_free (refcount_set);\n+\n+  /* Copy back ICVs from device to host.\n+     HOST_PTR is expected to exist since it was added in\n+     gomp_load_image_to_device if not already available.  */\n+  gomp_copy_back_icvs (devicep, device);\n+\n }\n \n /* Handle reverse offload.  This is called by the device plugins for a"}, {"sha": "9da0d635bf5152d7e779a1c68befeb6131ab12e6", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-4.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -16,7 +16,7 @@ main ()\n     }\n   else\n     omp_set_num_teams (6);\n-  if (getenv (\"OMP_TEAMS_THREAD_LIMIT\") == NULL\n+  if (getenv (\"OMP_TEAMS_THREAD_LIMIT\") != NULL\n       && strcmp (getenv (\"OMP_TEAMS_THREAD_LIMIT\"), \"12\") == 0)\n     {\n       if (omp_get_teams_thread_limit () != 12)"}, {"sha": "72d7af6dfd414458b148f37ec422eaba9a61cfa6", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-5.c", "status": "modified", "additions": 188, "deletions": 10, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-5.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -1,25 +1,203 @@\n /* { dg-do run } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_0 \"42\" } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_1 \"43\" } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_2 \"44\" } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"45\" } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"46\" } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS \"47\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"3\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"4\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS \"5\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_0 \"6\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_1 \"7\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_2 \"8\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"2\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV \"3\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT \"4\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_0 \"5\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_1 \"6\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_2 \"7\" } */\n \n #include <omp.h>\n #include <stdlib.h>\n+#include <unistd.h>\n \n int\n main ()\n {\n-  if (omp_get_max_teams () != 47)\n+  if (omp_get_max_teams () != 5\n+      || omp_get_teams_thread_limit () != 4)\n     abort ();\n \n+  #pragma omp teams\n+  {\n+    if (omp_get_num_teams () > 5\n+\t|| omp_get_team_num () >= 5)\n+      abort ();\n+    #pragma omp parallel\n+    if (omp_get_thread_limit () > 4\n+\t|| omp_get_thread_num () >= 4)\n+      abort ();\n+  }\n+\n+  omp_set_num_teams (4);\n+  omp_set_teams_thread_limit (3);\n+  if (omp_get_max_teams () != 4\n+      || omp_get_teams_thread_limit () != 3)\n+    abort ();\n+\n+  #pragma omp teams\n+  {\n+    if (omp_get_num_teams () > 4\n+\t|| omp_get_team_num () >= 4)\n+      abort ();\n+    #pragma omp parallel\n+    if (omp_get_thread_limit () > 3\n+\t|| omp_get_thread_num () >= 3)\n+      abort ();\n+  }\n+\n+  #pragma omp teams num_teams(3) thread_limit(2)\n+  {\n+    if (omp_get_num_teams () != 3\n+\t|| omp_get_team_num () >= 3)\n+    abort ();\n+    #pragma omp parallel\n+    if (omp_get_thread_limit () > 2\n+\t|| omp_get_thread_num () >= 2)\n+      abort ();\n+  }\n+\n+  #pragma omp teams num_teams(5) thread_limit(4)\n+  {\n+    if (omp_get_num_teams () != 5\n+\t|| omp_get_team_num () >= 5)\n+    abort ();\n+    #pragma omp parallel\n+    if (omp_get_thread_limit () > 4\n+\t|| omp_get_thread_num () >= 4)\n+      abort ();\n+  }\n+\n   int num_devices = omp_get_num_devices () > 3 ? 3 : omp_get_num_devices ();\n-  for (int i=0; i < num_devices; i++)\n-    #pragma omp target device (i)\n-      if (omp_get_max_teams () != 42 + i)\n+\n+  for (int i = 0; i < num_devices; i++)\n+    {\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 6 + i\n+\t  || omp_get_teams_thread_limit () != 5 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      #pragma omp parallel\n+      if (omp_get_thread_limit () > 5 + i\n+\t  || omp_get_thread_num () >= 5 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      {\n+\tomp_set_num_teams (5 + i);\n+\tomp_set_teams_thread_limit (4 + i);\n+\tif (omp_get_max_teams () != 5 + i\n+\t    || omp_get_teams_thread_limit () != 4 + i)\n+\t  abort ();\n+      }\n+\n+      /* omp_set_num_teams and omp_set_teams_thread_limit above set the value\n+\t of nteams-var and teams-thread-limit-var ICVs on device 'i', which has\n+\t scope 'device' and should be avaible in subsequent target regions.  */\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 5 + i\n+\t  || omp_get_teams_thread_limit () != 4 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      {\n+\tif (omp_get_num_teams () > 5 + i\n+\t    || omp_get_team_num () >= 5 + i)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > 4 + i\n+\t    || omp_get_thread_num () >= 4 + i)\n+\t  abort ();\n+      }\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams num_teams(6 + i) thread_limit(5 + i)\n+      {\n+\tif (omp_get_num_teams () > 6 + i\n+\t    || omp_get_team_num () >= 6 + i)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > 5 + i\n+\t    || omp_get_thread_num () >= 5 + i\n+\t    || omp_get_num_teams () > 6 + i\n+\t    || omp_get_team_num () >= 6 + i)\n+\t  abort ();\n+      }\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams num_teams(4 + i) thread_limit(3 + i)\n+      {\n+\tif (omp_get_num_teams () > 4 + i\n+\t    || omp_get_team_num () >= 4 + i)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > 3 + i\n+\t    || omp_get_thread_num () >= 3 + i\n+\t    || omp_get_num_teams () > 4 + i\n+\t    || omp_get_team_num () >= 4 + i)\n+\t  abort ();\n+      }\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams thread_limit(3 + i) num_teams(4 + i)\n+      {\n+\tif (omp_get_num_teams () > 4 + i\n+\t    || omp_get_team_num () >= 4 + i)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > 3 + i\n+\t    || omp_get_thread_num () >= 3 + i\n+\t    || omp_get_num_teams () > 4 + i\n+\t    || omp_get_team_num () >= 4 + i)\n+\t  abort ();\n+      }\n+\n+      /* The NUM_TEAMS and THREAD_LIMIT clauses should not change the values\n+\t of the corresponding ICVs.  */\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 5 + i\n+\t  || omp_get_teams_thread_limit () != 4 + i)\n+\tabort ();\n+\n+      /* This tests a large number of teams and threads.  If it is larger than\n+\t 2^15+1 then the according argument in the kernels arguments list\n+\t is encoded with two items instead of one.  */\n+      intptr_t large_num_teams = 66000;\n+      intptr_t large_threads_limit = 67000;\n+      #pragma omp target device (i)\n+      {\n+\tomp_set_num_teams (large_num_teams + i);\n+\tomp_set_teams_thread_limit (large_threads_limit + i);\n+\tif (omp_get_max_teams () != large_num_teams + i\n+\t    || omp_get_teams_thread_limit () != large_threads_limit + i)\n+\t  abort ();\n+      }\n+\n+      #pragma omp target device (i)\n+\tif (omp_get_max_teams () != large_num_teams + i\n+\t    || omp_get_teams_thread_limit () != large_threads_limit + i)\n \tabort ();\n \n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      {\n+\tif (omp_get_num_teams () > large_num_teams + i\n+\t    || omp_get_team_num () >= large_num_teams + i)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > large_threads_limit + i\n+\t    || omp_get_thread_num () >= large_threads_limit + i)\n+\t  abort ();\n+      }\n+    }\n+\n   return 0;\n }"}, {"sha": "1b17f2d977adecc5242deb31c6ae19338588925e", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-6.c", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-6.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -1,9 +1,10 @@\n /* { dg-do run } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"42\" } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"43\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"3\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"4\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"2\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV \"3\" } */\n /* { dg-set-target-env-var OMP_SCHEDULE_ALL \"guided,4\" } */\n /* { dg-set-target-env-var OMP_DYNAMIC_ALL \"true\" } */\n-/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"44\" } */\n /* { dg-set-target-env-var OMP_THREAD_LIMIT_ALL \"45\" } */\n /* { dg-set-target-env-var OMP_NUM_THREADS_ALL \"46,3,2\" } */\n /* { dg-set-target-env-var OMP_MAX_ACTIVE_LEVELS_ALL \"47\" } */\n@@ -12,8 +13,8 @@\n \n /* This tests the hierarchical usage of ICVs on the device, i.e. if\n    OMP_NUM_TEAMS_DEV_<device_num> is not configured, then the value of\n-   OMP_NUM_TEAMS_DEV should be used.  And if there is no environment variable\n-   without suffix, then the corresponding _ALL variant should be used.  */\n+   OMP_NUM_TEAMS_DEV should be used.  And if OMP_NUM_TEAMS (without suffix) is\n+   not defined, then OMP_NUM_TEAMS_ALL should be used for the host.  */\n \n #include <omp.h>\n #include <stdlib.h>\n@@ -26,10 +27,10 @@ main ()\n   int chunk_size;\n   omp_get_schedule(&kind, &chunk_size);\n \n-  if ((!getenv (\"OMP_NUM_TEAMS\") && omp_get_max_teams () != 42)\n+  if ((!getenv (\"OMP_NUM_TEAMS\") && omp_get_max_teams () != 3)\n       || (!getenv (\"OMP_DYNAMIC\") && !omp_get_dynamic ())\n       || (!getenv (\"OMP_SCHEDULE\") && (kind != 3 || chunk_size != 4))\n-      || (!getenv (\"OMP_TEAMS_THREAD_LIMIT\") && omp_get_teams_thread_limit () != 44)\n+      || (!getenv (\"OMP_TEAMS_THREAD_LIMIT\") && omp_get_teams_thread_limit () != 2)\n       || (!getenv (\"OMP_THREAD_LIMIT\") && omp_get_thread_limit () != 45)\n       || (!getenv (\"OMP_NUM_THREADS\") && omp_get_max_threads () != 46)\n       || (!getenv (\"OMP_PROC_BIND\") && omp_get_proc_bind () != omp_proc_bind_spread)\n@@ -44,9 +45,51 @@ main ()\n       name[sizeof (\"OMP_NUM_TEAMS_DEV_1\") - 2] = '0' + i;\n       if (getenv (name))\n \tcontinue;\n-    #pragma omp target device (i)\n-      if (omp_get_max_teams () != 43)\n+\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 4\n+\t  || omp_get_teams_thread_limit () != 3)\n \tabort ();\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      {\n+\tif (omp_get_num_teams () > 4\n+\t    || omp_get_team_num () >= 4)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > 3\n+\t    || omp_get_thread_num () >= 3)\n+\t  abort ();\n+      }\n+\n+      #pragma omp target device (i)\n+      {\n+\tomp_set_num_teams (3 + i);\n+\tomp_set_teams_thread_limit (2 + i);\n+\tif (omp_get_max_teams () != 3 + i\n+\t    || omp_get_teams_thread_limit () != 2 + i)\n+\t  abort ();\n+      }\n+\n+     /* omp_set_num_teams above set the value of nteams-var ICV on device 'i',\n+\t which has scope 'device' and should be avaible in subsequent target\n+\t regions.  */\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 3 + i\n+\t  || omp_get_teams_thread_limit () != 2 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      {\n+\tif (omp_get_num_teams () > 3 + i\n+\t    || omp_get_team_num () >= 3 + i)\n+\t  abort ();\n+\t#pragma omp parallel\n+\tif (omp_get_thread_limit () > 2 + i\n+\t    || omp_get_thread_num () >= 2 + i)\n+\t  abort ();\n+      }\n     }\n \n   return 0;"}, {"sha": "bbbd6dff196b596770d93698c4faf25faef51fd9", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-7.c", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-7.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do run } */\n-/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"42\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"7\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"2\" } */\n \n /* This tests the hierarchical usage of ICVs on the host and on devices, i.e. if\n    OMP_NUM_TEAMS_DEV_<device_num>, OMP_NUM_TEAMS_DEV, and\n@@ -9,18 +10,90 @@\n \n #include <omp.h>\n #include <stdlib.h>\n+#include <string.h>\n \n int\n main ()\n {\n-  if (omp_get_max_teams () != 42)\n+  if ((!getenv (\"OMP_NUM_TEAMS\") && omp_get_max_teams () != 7)\n+      || (!getenv (\"OMP_TEAMS_THREAD_LIMIT\") && omp_get_teams_thread_limit () != 2))\n     abort ();\n \n+  #pragma omp teams\n+  if ((!getenv (\"OMP_NUM_TEAMS\"))\n+      && (omp_get_num_teams () > 7 || omp_get_team_num () >= 7))\n+    abort ();\n+\n+  omp_set_num_teams (9);\n+  omp_set_teams_thread_limit (3);\n+  if (omp_get_max_teams () != 9\n+      || omp_get_teams_thread_limit () != 3)\n+    abort ();\n+\n+  #pragma omp teams\n+  if (omp_get_num_teams () > 9\n+      || omp_get_team_num () >= 9)\n+    abort ();\n+\n+  #pragma omp teams num_teams(5)\n+  if (omp_get_num_teams () > 5\n+      || omp_get_team_num () >= 5)\n+    abort ();\n+\n+  if (getenv (\"OMP_NUM_TEAMS_DEV\") || getenv (\"OMP_TEAMS_THREAD_LIMIT_DEV\"))\n+    return 0;\n+\n   int num_devices = omp_get_num_devices () > 3 ? 3 : omp_get_num_devices ();\n-  for (int i=0; i < num_devices; i++)\n-    #pragma omp target device (i)\n-      if (omp_get_max_teams () != 42)\n+  for (int i = 0; i < num_devices; i++)\n+    {\n+      char nteams[sizeof (\"OMP_NUM_TEAMS_DEV_1\")];\n+      strcpy (nteams, \"OMP_NUM_TEAMS_DEV_1\");\n+      nteams[sizeof (\"OMP_NUM_TEAMS_DEV_1\") - 2] = '0' + i;\n+      char teams_thread_limit[sizeof (\"OMP_TEAMS_THREAD_LIMIT_DEV_1\")];\n+      strcpy (teams_thread_limit, \"OMP_TEAMS_THREAD_LIMIT_DEV_1\");\n+      teams_thread_limit[sizeof (\"OMP_TEAMS_THREAD_LIMIT_DEV_1\") - 2] = '0' + i;\n+      if (getenv (nteams) || getenv (teams_thread_limit))\n+\tcontinue;\n+\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 7\n+\t  || omp_get_teams_thread_limit () != 2)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      if (omp_get_num_teams () > 7\n+\t  || omp_get_team_num () >= 7)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      {\n+\tomp_set_num_teams (8 + i);\n+\tomp_set_teams_thread_limit (4 + i);\n+\tif (omp_get_max_teams () != 8 + i\n+\t    || omp_get_teams_thread_limit () != 4 + i)\n+\t  abort ();\n+      }\n+\n+     /* omp_set_num_teams above set the value of nteams-var ICV on device 'i',\n+\t which has scope 'device' and should be avaible in subsequent target\n+\t regions.  */\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 8 + i\n+\t  || omp_get_teams_thread_limit () != 4 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      if (omp_get_num_teams () > 8 + i\n+\t  || omp_get_team_num () >= 8 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams num_teams(5 + i)\n+      if (omp_get_num_teams () != 5 + i)\n \tabort ();\n+    }\n \n   return 0;\n }"}, {"sha": "21b874f8ae9296084ab5e93e1d980192ffd0b51f", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-9.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-9.c?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+\n+/* This tests usage of ICVs on the host and on devices if no corresponding\n+   environment variables are configured.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  if (omp_get_max_teams () != 0\n+      || omp_get_teams_thread_limit () != 0)\n+    abort ();\n+\n+  omp_set_num_teams (9);\n+  omp_set_teams_thread_limit (2);\n+  if (omp_get_max_teams () != 9\n+      || omp_get_teams_thread_limit () != 2)\n+    abort ();\n+\n+  #pragma omp teams\n+  if (omp_get_num_teams () > 9\n+      || omp_get_team_num () >= 9)\n+    abort ();\n+\n+  #pragma omp teams num_teams(5)\n+  if (omp_get_num_teams () > 5\n+      || omp_get_team_num () >= 5)\n+    abort ();\n+\n+  int num_devices = omp_get_num_devices () > 3 ? 3 : omp_get_num_devices ();\n+  for (int i = 0; i < num_devices; i++)\n+    {\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 0\n+\t  || omp_get_teams_thread_limit () != 0)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      {\n+\tomp_set_num_teams (8 + i);\n+\tomp_set_teams_thread_limit (3 + i);\n+\tif (omp_get_max_teams () != 8 + i\n+\t    || omp_get_teams_thread_limit () != 3 + i)\n+\t  abort ();\n+      }\n+\n+     /* omp_set_num_teams above set the value of nteams-var ICV on device 'i',\n+\t which has scope 'device' and should be avaible in subsequent target\n+\t regions.  */\n+      #pragma omp target device (i)\n+      if (omp_get_max_teams () != 8 + i\n+\t  || omp_get_teams_thread_limit () != 3 + i)\n+\tabort ();\n+\n+      #pragma omp target device (i)\n+      #pragma omp teams\n+      if (omp_get_num_teams () > 8 + i\n+\t  || omp_get_team_num () >= 8 + i)\n+\tabort ();\n+\n+      /* NUM_TEAMS clause has priority over previously set NUM_TEAMS value.  */\n+      #pragma omp target device (i)\n+      #pragma omp teams num_teams(5 + i)\n+      if (omp_get_num_teams () > 5 + i\n+\t  || omp_get_team_num () >= 5 + i)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "05a35fac468c56e9c031bf503218f918df3801e3", "filename": "libgomp/testsuite/libgomp.fortran/icv-5.f90", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ficv-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ficv-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ficv-5.f90?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -0,0 +1,226 @@\n+! { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"3\" }\n+! { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"4\" }\n+! { dg-set-target-env-var OMP_NUM_TEAMS \"5\" }\n+! { dg-set-target-env-var OMP_NUM_TEAMS_DEV_0 \"6\" }\n+! { dg-set-target-env-var OMP_NUM_TEAMS_DEV_1 \"7\" }\n+! { dg-set-target-env-var OMP_NUM_TEAMS_DEV_2 \"8\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"2\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV \"3\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT \"4\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_0 \"5\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_1 \"6\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_2 \"7\" }\n+\n+use omp_lib\n+implicit none (type, external)\n+  integer :: num_devices, i, large_num_teams, large_threads_limit\n+  logical :: err\n+\n+  if (omp_get_num_devices () > 3) then\n+    num_devices = 3\n+  else\n+    num_devices = omp_get_num_devices ()\n+  end if\n+\n+  do i=0,num_devices-1\n+\n+    ! Testing NUM_TEAMS.\n+    if (env_is_set_dev (\"OMP_NUM_TEAMS_DEV_\", i, 6 + i)) then\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_max_teams () /= 6 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 1\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      if (omp_get_num_teams () > 6 + i .or. omp_get_team_num () >= 6 + i) &\n+        err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 2\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      call omp_set_num_teams (5 + i)\n+      if (omp_get_max_teams () /= 5 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 3\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_max_teams () /= 5 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 4\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      if (omp_get_num_teams () > 5 + i .or. omp_get_team_num () >= 5 + i) &\n+        err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 5\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams num_teams(6 + i)\n+      if (omp_get_num_teams () > 6 + i .or. omp_get_team_num () >= 6 + i) &\n+        err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 6\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams num_teams(4 + i)\n+      if (omp_get_num_teams () > 4 + i .or. omp_get_team_num () >= 4 + i) &\n+        err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 7\n+\n+      large_num_teams = 66000\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      call omp_set_num_teams (large_num_teams + i)\n+      if (omp_get_max_teams () /= large_num_teams + i) err = .true.\n+      !$omp end target\n+      if (err) stop 8\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_max_teams () /= large_num_teams + i) err = .true.\n+      !$omp end target\n+      if (err) stop 9\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      if (omp_get_num_teams () > large_num_teams + i &\n+          .or. omp_get_team_num () >= large_num_teams + i) err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 10\n+    end if\n+\n+    ! Testing TEAMS-THREAD-LIMIT\n+    if (env_is_set_dev (\"OMP_TEAMS_THREAD_LIMIT_DEV_\", i, 5 + i)) then\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_teams_thread_limit () /= 5 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 11\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      !$omp parallel\n+      if (omp_get_thread_limit () > 5 + i .or. omp_get_thread_num () >= 5 + i) &\n+        err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 12\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      call omp_set_teams_thread_limit (4 + i)\n+      if (omp_get_teams_thread_limit () /= 4 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 13\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_teams_thread_limit () /= 4 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 14\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      !$omp parallel\n+      if (omp_get_thread_limit () > 4 + i .or. omp_get_thread_num () >= 4 + i) &\n+        err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 15\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams thread_limit(5 + i)\n+      !$omp parallel\n+      if (omp_get_thread_limit () > 5 + i .or. omp_get_thread_num () >= 5 + i) &\n+        err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 16\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams thread_limit(3 + i)\n+      !$omp parallel\n+      if (omp_get_thread_limit () > 3 + i .or. omp_get_thread_num () >= 3 + i) &\n+        err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 17\n+\n+      large_threads_limit = 67000\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      call omp_set_teams_thread_limit (large_threads_limit + i)\n+      if (omp_get_teams_thread_limit () /= large_threads_limit + i) err = .true.\n+      !$omp end target\n+      if (err) stop 18\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_teams_thread_limit () /= large_threads_limit + i) err = .true.\n+      !$omp end target\n+      if (err) stop 19\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      !$omp parallel\n+      if (omp_get_thread_limit () > large_threads_limit + i &\n+          .or. omp_get_thread_num () >= large_threads_limit + i) err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 20\n+    end if\n+\n+  end do\n+\n+contains\n+  logical function env_is_set (name, val)\n+    character(len=*) :: name, val\n+    character(len=40) :: val2\n+    integer :: stat\n+    call get_environment_variable (name, val2, status=stat)\n+    if (stat == 0) then\n+      if (val == val2) then\n+        env_is_set = .true.\n+        return\n+      end if\n+    else if (stat /= 1) then\n+      error stop 30\n+    endif\n+    env_is_set = .false.\n+  end\n+  logical function env_is_set_dev (name, dev_num, val)\n+    character(len=*) :: name\n+    integer :: dev_num, val\n+    character(len=64) :: dev_num_str, env_var, val_str\n+    dev_num_str = ADJUSTL(dev_num_str)\n+    env_var = name // dev_num_str\n+    val_str = ADJUSTL(val_str)\n+    env_is_set_dev = env_is_set (TRIM(env_var), TRIM(val_str))\n+  end\n+end"}, {"sha": "c8e6a0d0f1281c68a0c540788d1d55ac339cfa46", "filename": "libgomp/testsuite/libgomp.fortran/icv-6.f90", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ficv-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81476bc4f4a20bcf3af7ac2548c2322d48499402/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ficv-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ficv-6.f90?ref=81476bc4f4a20bcf3af7ac2548c2322d48499402", "patch": "@@ -0,0 +1,140 @@\n+! { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"3\" }\n+! { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"4\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"2\" }\n+! { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV \"3\" }\n+\n+! This test considers the hierarchical usage of ICVs on the device, i.e. if\n+! e.g. OMP_NUM_TEAMS_DEV_<device_num> is not configured, then the value of\n+! OMP_NUM_TEAMS_DEV should be used for the targets.\n+\n+use omp_lib\n+implicit none (type, external)\n+  integer :: num_devices, i, stat, tmp\n+  logical :: err\n+  character(len=40) :: val\n+\n+  ! The following environment variables should not be set.\n+  call get_environment_variable (\"OMP_NUM_TEAMS_DEV_0\", val, status=stat)\n+  if (stat /= 1) return\n+  call get_environment_variable (\"OMP_NUM_TEAMS_DEV_1\", val, status=stat)\n+  if (stat /= 1) return\n+  call get_environment_variable (\"OMP_NUM_TEAMS_DEV_2\", val, status=stat)\n+  if (stat /= 1) return\n+  call get_environment_variable (\"OMP_TEAMS_THREAD_LIMIT_DEV_0\", val, status=stat)\n+  if (stat /= 1) return\n+  call get_environment_variable (\"OMP_TEAMS_THREAD_LIMIT_DEV_1\", val, status=stat)\n+  if (stat /= 1) return\n+  call get_environment_variable (\"OMP_TEAMS_THREAD_LIMIT_DEV_2\", val, status=stat)\n+  if (stat /= 1) return\n+\n+  if (omp_get_num_devices () > 3) then\n+    num_devices = 3\n+  else\n+    num_devices = omp_get_num_devices ()\n+  end if\n+\n+  do i=0,num_devices-1\n+\n+    ! Testing NUM_TEAMS.\n+    if (env_is_set (\"OMP_NUM_TEAMS_DEV\", \"4\")) then\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_max_teams () /= 4) err = .true.\n+      !$omp end target\n+      if (err) stop 1\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      if (omp_get_num_teams () > 4 .or. omp_get_team_num () >= 4) &\n+        err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 2\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      call omp_set_num_teams (3 + i)\n+      if (omp_get_max_teams () /= 3 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 3\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_max_teams () /= 3 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 4\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      if (omp_get_num_teams () > 3 + i .or. omp_get_team_num () >= 3 + i) &\n+        err = .true.\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 5\n+    end if\n+\n+    ! Testing TEAMS-THREAD-LIMIT\n+    if (env_is_set (\"OMP_TEAMS_THREAD_LIMIT_DEV\", \"3\")) then\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_teams_thread_limit () /= 3) err = .true.\n+      !$omp end target\n+      if (err) stop 6\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      !$omp parallel\n+      if (omp_get_thread_limit () > 3 .or. omp_get_thread_num () >= 3) &\n+        err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 7\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      call omp_set_teams_thread_limit (2 + i)\n+      if (omp_get_teams_thread_limit () /= 2 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 8\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      if (omp_get_teams_thread_limit () /= 2 + i) err = .true.\n+      !$omp end target\n+      if (err) stop 9\n+\n+      err = .false.\n+      !$omp target device(i) map(tofrom: err)\n+      !$omp teams\n+      !$omp parallel\n+      if (omp_get_thread_limit () > 2 + i .or. omp_get_thread_num () >= 2 + i) &\n+        err = .true.\n+      !$omp end parallel\n+      !$omp end teams\n+      !$omp end target\n+      if (err) stop 10\n+    end if\n+\n+  end do\n+\n+contains\n+  logical function env_is_set (name, val)\n+    character(len=*) :: name, val\n+    character(len=40) :: val2\n+    integer :: stat\n+    call get_environment_variable (name, val2, status=stat)\n+    if (stat == 0) then\n+      if (val == val2) then\n+        env_is_set = .true.\n+        return\n+      end if\n+    else if (stat /= 1) then\n+      error stop 10\n+    endif\n+    env_is_set = .false.\n+  end\n+end"}]}