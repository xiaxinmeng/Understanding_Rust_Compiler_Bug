{"sha": "1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkyMGFmYjNjNmFjYWIyYTYxNjZjMGQ2NThlNmViNDEyYzJiMGJiZA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "1999-06-17T00:21:26Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "1999-06-17T00:21:26Z"}, "message": "natPlainSocketImpl.cc (bind): Bind to any/all network interfaces if host==NULL.\n\n        * java/net/natPlainSocketImpl.cc (bind): Bind to any/all network\n        interfaces if host==NULL.\n        (accept): Throw message with InterruptedIOException.\n        (getOption): Cache localAddress.\n        * java/net/natPlainDatagramSocketImpl.cc (bind): Don't need\n        'address' for DatagramSocket.\n        (setTimeToLive): Fix compiler warnings.\n        (getOption): Cache localAddress.\n        * java/net/Socket.java (getLocalAddress): Don't need local\n        InetAddress object. Add FIXME comment about calling checkConnect().\n        * java/net/ServerSocket.java (ServerSocket(int)): Initialize\n        connection queue to 50 as per JDK 1.2 docs.\n        (ServerSocket(int,int)): Listen on all network interfaces by\n        default, per JDK 1.2 docs.\n        * java/net/PlainDatagramSocketImpl.java: Don't need 'address'.\n        Add localAddress caching.\n\nFrom-SVN: r27559", "tree": {"sha": "60f913e68f63815df730459c7b350b60a108a045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60f913e68f63815df730459c7b350b60a108a045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/comments", "author": null, "committer": null, "parents": [{"sha": "06c8baef3a8acf2a560db2859207d488a2500047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c8baef3a8acf2a560db2859207d488a2500047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c8baef3a8acf2a560db2859207d488a2500047"}], "stats": {"total": 143, "additions": 92, "deletions": 51}, "files": [{"sha": "64d7363a4c46cb8795bc6e6cc3ff27106e713606", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -1,3 +1,22 @@\n+1999-06-17  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/net/natPlainSocketImpl.cc (bind): Bind to any/all network\n+\tinterfaces if host==NULL. \n+\t(accept): Throw message with InterruptedIOException.\n+\t(getOption): Cache localAddress.\n+\t* java/net/natPlainDatagramSocketImpl.cc (bind): Don't need\n+\t'address' for DatagramSocket.\n+\t(setTimeToLive): Fix compiler warnings.\n+\t(getOption): Cache localAddress.\n+\t* java/net/Socket.java (getLocalAddress): Don't need local\n+\tInetAddress object. Add FIXME comment about calling checkConnect().\n+\t* java/net/ServerSocket.java (ServerSocket(int)): Initialize\n+\tconnection queue to 50 as per JDK 1.2 docs.\n+\t(ServerSocket(int,int)): Listen on all network interfaces by\n+\tdefault, per JDK 1.2 docs.\n+\t* java/net/PlainDatagramSocketImpl.java: Don't need 'address'.\n+\tAdd localAddress caching. \n+\n 1999-06-15  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/io/FilterOutputStream.java (write(byte[])): Rewrite according\n@@ -56,7 +75,7 @@\n 1999-05-30  Anthony Green  <green@cygnus.com>\n \n \t* java/net/URLStreamHandler.java (parseURL): Parse relative URLs\n-\tcorrectly.  Clean up \"/../\" and \"/./\" path fragments.\n+\tcorrectly.  Clean up \"/../\" an\u001b[Bd \"/./\" path fragments.\n \n 1999-05-28  Warren Levy  <warrenl@cygnus.com>\n "}, {"sha": "541f00a10d8c1d7781195381329221797d812fcf", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -38,11 +38,14 @@ class PlainDatagramSocketImpl extends DatagramSocketImpl\n   int fnum = -1;\n \n   // FIXME: Is this necessary?  Could it help w/ DatagramSocket.getLocalAddress?\n-  InetAddress address;\t\n+  // InetAddress address;\n+  \n+  // localAddress cache  \n+  InetAddress localAddress;\n \n   // These values are set/read by setOption/getOption.\n   int timeout = 0;\n-  InetAddress iface = null;\n+  /* InetAddress iface = null; */\n   int ttl = -1;\n \n   // FIXME: Probably should have bind (and create?) calls from DatagramSocket"}, {"sha": "5cff27bdca057572374b2c7eb46e5c2bfdaf99ef", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -39,6 +39,9 @@ class PlainSocketImpl extends SocketImpl\n \n   // This value is set/read by setOption/getOption.\n   int timeout = 0;\n+  \n+  // localAddress cache\n+  InetAddress localAddress;\n \n   public native void setOption(int optID, Object value) throws SocketException;\n "}, {"sha": "0d40bcc9bd67b29c57810b3bea295d28fcb0f19a", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -28,15 +28,13 @@\n   public ServerSocket (int port)\n     throws java.io.IOException\n   {\n-    // FIXME: JCL p. 1526 says backlog defaults to 50; is 5 to save space\n-    // or a typo?\n-    this(port, 5);\n+    this(port, 50);\n   }\n \n   public ServerSocket (int port, int backlog)\n     throws java.io.IOException\n   {\n-    this(port, backlog, InetAddress.getLocalHost());\n+    this(port, backlog, null);\n   }\n \n   public ServerSocket (int port, int backlog, InetAddress bindAddr)"}, {"sha": "7dded58937b60261ad9bd41cf17c77618fbbc784", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -129,18 +129,17 @@ public InetAddress getInetAddress ()\n \n   public InetAddress getLocalAddress ()\n   {\n-    InetAddress localAddress;\n+    // FIXME: see note in DatagramSocket.java about checkConnect() and security\n     try\n       {\n-\tlocalAddress = (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);\n+\treturn (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);\n       }\n     catch (SocketException x)\n       {\n \t// (hopefully) shouldn't happen\n \tSystem.err.println(x);\n         throw new java.lang.InternalError(\"Error in PlainSocketImpl.getOption\");\n       }\n-    return localAddress;\n   }\n \n   public int getPort ()"}, {"sha": "ef2a3cbdf8895419d1e3f18abfc7b1c8df2f0c09", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -111,8 +111,6 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n     goto error;\n   if (::bind (fnum, ptr, len) == 0)\n     {\n-      // FIXME: Is address really necessary to set?\n-      address = host;\n       socklen_t addrlen = sizeof(u);\n       if (lport != 0)\n         localport = lport;\n@@ -270,6 +268,7 @@ java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n void\n java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n {\n+  this->ttl = ttl;\n   // throws IOException;\n   // FIXME: TODO - PlainDatagramSocketImpl::setTimeToLive\n }\n@@ -279,7 +278,7 @@ java::net::PlainDatagramSocketImpl::getTimeToLive ()\n {\n   // throws IOException;\n   // FIXME: TODO - PlainDatagramSocketImpl::getTimeToLive\n-  return 0;\n+  return ttl;\n }\n \n void\n@@ -438,25 +437,29 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n #endif    \n \tbreak;\n       case _Jv_SO_BINDADDR_:\n-\t// FIXME: Should cache the laddr as an optimization.\n-\tjbyteArray laddr;\n-\tif (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-\t  goto error;\n-\tif (u.address.sin_family == AF_INET)\n-\t  {\n-\t    laddr = JvNewByteArray (4);\n-\t    memcpy (elements (laddr), &u.address.sin_addr, 4);\n-\t  }\n+\t// cache the local address\n+\tif (localAddress == NULL)\n+\t  {\t\n+\t    jbyteArray laddr;\n+\t    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+\t      goto error;\n+\t    if (u.address.sin_family == AF_INET)\n+\t      {\n+\t\tladdr = JvNewByteArray (4);\n+\t\tmemcpy (elements (laddr), &u.address.sin_addr, 4);\n+\t      }\n #ifdef HAVE_INET6\n-        else if (u.address.sin_family == AF_INET6)\n-\t  {\n-\t    laddr = JvNewByteArray (16);\n-\t    memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n-\t  }\n+            else if (u.address.sin_family == AF_INET6)\n+\t      {\n+\t\tladdr = JvNewByteArray (16);\n+\t\tmemcpy (elements (laddr), &u.address6.sin6_addr, 16);\n+\t      }\n #endif\n-\telse\n-\t  goto error;\n-\treturn new java::net::InetAddress (laddr, NULL);\n+\t    else\n+\t      goto error;\n+\t    localAddress = new java::net::InetAddress (laddr, NULL);\n+\t  }\n+\treturn localAddress;  \n \tbreak;\n       case _Jv_SO_REUSEADDR_ :\n #if defined(SO_REUSEADDR)"}, {"sha": "a41a68157c8dd51def50b2623f6092a592fb62bb", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1920afb3c6acab2a6166c0d658e6eb412c2b0bbd/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=1920afb3c6acab2a6166c0d658e6eb412c2b0bbd", "patch": "@@ -65,14 +65,25 @@ void\n java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n {\n   union SockAddr u;\n-  jbyteArray haddress = host->address;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+  jbyte *bytes = NULL;\n+  // FIXME: Use getaddrinfo() to get actual protocol instead of assuming ipv4.\n+  int len = 4;\t// Initialize for INADDR_ANY in case host is NULL.\n+\n+  if (host != NULL)\n+    {\n+      jbyteArray haddress = host->address;\n+      bytes = elements (haddress);\n+      len = haddress->length;\n+    }\n+  \n   if (len == 4)\n     {\n       u.address.sin_family = AF_INET;\n-      memcpy (&u.address.sin_addr, bytes, len);\n+      if (host != NULL)\n+        memcpy (&u.address.sin_addr, bytes, len);\n+      else\n+\tu.address.sin_addr.s_addr = htonl (INADDR_ANY);        \n       len = sizeof (struct sockaddr_in);\n       u.address.sin_port = htons (lport);\n     }\n@@ -183,7 +194,8 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n       if ((retval = select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n \tgoto error;\n       else if (retval == 0)\n-\tJvThrow (new java::io::InterruptedIOException ());\n+\tJvThrow (new java::io::InterruptedIOException (\n+\t         JvNewStringUTF(\"Accept timed out\")));\n     }\n \n   new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n@@ -365,25 +377,29 @@ java::net::PlainSocketImpl::getOption (jint optID)\n #endif    \n \tbreak;\n       case _Jv_SO_BINDADDR_:\n-\t// FIXME: Should cache the laddr as an optimization.\n-\tjbyteArray laddr;\n-\tif (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-\t  goto error;\n-\tif (u.address.sin_family == AF_INET)\n+\t// cache the local address \n+\tif (localAddress == NULL)\n \t  {\n-\t    laddr = JvNewByteArray (4);\n-\t    memcpy (elements (laddr), &u.address.sin_addr, 4);\n-\t  }\n+\t    jbyteArray laddr;\n+\t    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+\t      goto error;\n+\t    if (u.address.sin_family == AF_INET)\n+\t      {\n+\t\tladdr = JvNewByteArray (4);\n+\t\tmemcpy (elements (laddr), &u.address.sin_addr, 4);\n+\t      }\n #ifdef HAVE_INET6\n-        else if (u.address.sin_family == AF_INET6)\n-\t  {\n-\t    laddr = JvNewByteArray (16);\n-\t    memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n-\t  }\n+            else if (u.address.sin_family == AF_INET6)\n+\t      {\n+\t\tladdr = JvNewByteArray (16);\n+\t\tmemcpy (elements (laddr), &u.address6.sin6_addr, 16);\n+\t      }\n #endif\n-\telse\n-\t  goto error;\n-\treturn new java::net::InetAddress (laddr, NULL);\n+\t    else\n+\t      goto error;\n+\t    localAddress = new java::net::InetAddress (laddr, NULL);\n+\t  }\n+\treturn localAddress;\n \tbreak;\n       case _Jv_IP_MULTICAST_IF_ :\n \tJvThrow (new java::net::SocketException ("}]}