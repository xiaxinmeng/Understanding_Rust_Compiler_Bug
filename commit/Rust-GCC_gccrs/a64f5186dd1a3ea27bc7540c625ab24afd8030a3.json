{"sha": "a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY0ZjUxODZkZDFhM2VhMjdiYzc1NDBjNjI1YWIyNGFmZDgwMzBhMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-08-29T18:41:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-08-29T18:41:19Z"}, "message": "re PR fortran/29635 (debug info of modules)\n\n\tPR fortran/29635\n\tPR fortran/23057\n\t* debug.h (struct gcc_debug_hooks): Add NAME and CHILD\n\targuments to imported_module_or_decl.\n\t(debug_nothing_tree_tree): Removed.\n\t(debug_nothing_tree_tree_tree_bool): New prototype.\n\t* debug.c (do_nothing_debug_hooks): Adjust.\n\t(debug_nothing_tree_tree): Removed.\n\t(debug_nothing_tree_tree_tree_bool): New function.\n\t* dwarf2out.c (is_symbol_die): Handle DW_TAG_module.\n\t(gen_variable_die): Put all common vars for the\n\tsame COMMON block under one DW_TAG_common_block.\n\t(declare_in_namespace): Return new context_die, for Fortran\n\treturn the module DIE instead of adding extra declarations into\n\tthe namespace.\n\t(gen_type_die_with_usage): Adjust declare_in_namespace caller.\n\t(gen_namespace_die): If is_fortran (), generate DW_TAG_module\n\tinstead of DW_TAG_namespace.  If DECL_EXTERNAL is set, add\n\tDW_AT_declaration.\n\t(dwarf2out_global_decl): Don't skip Fortran global vars.\n\t(gen_decl_die): Likewise.  Adjust declare_in_namespace callers.\n\t(dwarf2out_imported_module_or_decl): Add NAME and CHILD arguments.\n\tIf NAME is non-NULL, add DW_AT_name.  If CHILD is non-NULL, put\n\tDW_TAG_imported_declaration as child of previous\n\tDW_TAG_imported_module.\n\t* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Adjust.\n\t* sdbout.c (sdb_debug_hooks): Likewise.\n\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n\n\t* name-lookup.c (do_using_directive, cp_emit_debug_info_for_using):\n\tAdjust debug_hooks->imported_module_or_decl callers.\n\n\t* f95-lang.c (gfc_init_ts): New function.\n\t(LANG_HOOKS_INIT_TS): Define.\n\t* gfortran.h (gfc_use_rename): New type, moved from module.c.\n\t(gfc_get_use_rename): New macro, moved from module.c.\n\t(gfc_use_list): New type.\n\t(gfc_get_use_list): New macro.\n\t(gfc_namespace): Add use_stmts field.\n\t(gfc_free_use_stmts): New prototype.\n\t* Make-lang.in (fortran/trans-decl.o): Depend on debug.h.\n\t* module.c (gfc_use_rename, gfc_get_use_rename): Moved to\n\tgfortran.h.\n\t(gfc_use_module): Chain the USE statement info to\n\tns->use_stmts.\n\t(gfc_free_use_stmts): New function.\n\t* symbol.c (gfc_free_namespace): Call gfc_free_use_stmts.\n\t* trans.h (struct module_htab_entry): New type.\n\t(gfc_find_module, gfc_module_add_decl): New functions.\n\t* trans.c (gfc_generate_module_code): Create NAMESPACE_DECL for\n\tthe module, adjust DECL_CONTEXTs of module procedures and\n\tcall gfc_module_add_decl for them.\n\t* trans-common.c (build_common_decl): Set DECL_IGNORED_P\n\ton the common variable.\n\t(create_common): Set DECL_IGNORED_P for use associated vars.\n\t* trans-decl.c: Include debug.h.\n\t(gfc_get_symbol_decl): Set DECL_IGNORED_P on use_assoc vars from\n\tmodules.\n\t(build_function_decl): Allow current_function_decl's context\n\tto be a NAMESPACE_DECL.\n\t(module_htab, cur_module): New variables.\n\t(module_htab_do_hash, module_htab_eq, module_htab_decls_hash,\n\tmodule_htab_decls_eq, gfc_find_module, gfc_module_add_decl): New\n\tfunctions.\n\t(gfc_create_module_variable): Adjust DECL_CONTEXTs of module\n\tvariables and types and call gfc_module_add_decl for them.\n\t(gfc_generate_module_vars): Temporarily set cur_module.\n\t(gfc_trans_use_stmts): New function.\n\t(gfc_generate_function_code): Call it.\n\t(gfc_generate_block_data): Set DECL_IGNORED_P on decl.\n\t* trans-types.c (gfc_get_derived_type): Adjust DECL_CONTEXT\n\tand TYPE_CONTEXT of module derived types.\n\nFrom-SVN: r139773", "tree": {"sha": "b8ebe79cda960c2d7a984748713c834f78fc8847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8ebe79cda960c2d7a984748713c834f78fc8847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca30a5396af8e55bb19746eeb323de7064da6c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca30a5396af8e55bb19746eeb323de7064da6c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca30a5396af8e55bb19746eeb323de7064da6c46"}], "stats": {"total": 572, "additions": 493, "deletions": 79}, "files": [{"sha": "2bed3cd99765a1c81728d3b7e58b0ef6a9a3b13d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -1,3 +1,34 @@\n+2008-08-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/29635\n+\tPR fortran/23057\n+\t* debug.h (struct gcc_debug_hooks): Add NAME and CHILD\n+\targuments to imported_module_or_decl.\n+\t(debug_nothing_tree_tree): Removed.\n+\t(debug_nothing_tree_tree_tree_bool): New prototype.\n+\t* debug.c (do_nothing_debug_hooks): Adjust.\n+\t(debug_nothing_tree_tree): Removed.\n+\t(debug_nothing_tree_tree_tree_bool): New function.\n+\t* dwarf2out.c (is_symbol_die): Handle DW_TAG_module.\n+\t(gen_variable_die): Put all common vars for the\n+\tsame COMMON block under one DW_TAG_common_block.\n+\t(declare_in_namespace): Return new context_die, for Fortran\n+\treturn the module DIE instead of adding extra declarations into\n+\tthe namespace.\n+\t(gen_type_die_with_usage): Adjust declare_in_namespace caller.\n+\t(gen_namespace_die): If is_fortran (), generate DW_TAG_module\n+\tinstead of DW_TAG_namespace.  If DECL_EXTERNAL is set, add\n+\tDW_AT_declaration.\n+\t(dwarf2out_global_decl): Don't skip Fortran global vars.\n+\t(gen_decl_die): Likewise.  Adjust declare_in_namespace callers.\n+\t(dwarf2out_imported_module_or_decl): Add NAME and CHILD arguments.\n+\tIf NAME is non-NULL, add DW_AT_name.  If CHILD is non-NULL, put\n+\tDW_TAG_imported_declaration as child of previous\n+\tDW_TAG_imported_module.\n+\t* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Adjust.\n+\t* sdbout.c (sdb_debug_hooks): Likewise.\n+\t* vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n+\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_remove_node): Do not remove nested nodes."}, {"sha": "00202745f381dd3dff075630916b8e4011c39c1b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -1,3 +1,10 @@\n+2008-08-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/29635\n+\tPR fortran/23057\n+\t* name-lookup.c (do_using_directive, cp_emit_debug_info_for_using):\n+\tAdjust debug_hooks->imported_module_or_decl callers.\n+\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* cp-gimplify.c (cp_gimplify_expr): Add PRED_CONTINUE heuristic."}, {"sha": "7fc6a9341ae4411e6b33811b820d1068134cfa32", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -3490,7 +3490,8 @@ do_using_directive (tree name_space)\n \n   /* Emit debugging info.  */\n   if (!processing_template_decl)\n-    (*debug_hooks->imported_module_or_decl) (name_space, context);\n+    (*debug_hooks->imported_module_or_decl) (name_space, NULL_TREE,\n+\t\t\t\t\t     context, false);\n }\n \n /* Deal with a using-directive seen by the parser.  Currently we only\n@@ -5327,7 +5328,7 @@ cp_emit_debug_info_for_using (tree t, tree context)\n   /* FIXME: Handle TEMPLATE_DECLs.  */\n   for (t = OVL_CURRENT (t); t; t = OVL_NEXT (t))\n     if (TREE_CODE (t) != TEMPLATE_DECL)\n-      (*debug_hooks->imported_module_or_decl) (t, context);\n+      (*debug_hooks->imported_module_or_decl) (t, NULL_TREE, context, false);\n }\n \n #include \"gt-cp-name-lookup.h\""}, {"sha": "68cf28e4ecaecd7a333bca22093d69fc32e126e5", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -369,7 +369,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   dbxout_function_decl,\n   dbxout_global_decl,\t\t         /* global_decl */\n   dbxout_type_decl,\t\t\t /* type_decl */\n-  debug_nothing_tree_tree,               /* imported_module_or_decl */\n+  debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx,\t\t         /* label */\n@@ -401,7 +401,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   debug_nothing_tree,\t\t         /* function_decl */\n   dbxout_global_decl,\t\t         /* global_decl */\n   dbxout_type_decl,\t\t\t /* type_decl */\n-  debug_nothing_tree_tree,               /* imported_module_or_decl */\n+  debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx,\t\t         /* label */"}, {"sha": "84fc2df9566ec7f7e2797d592efa03880d1625de", "filename": "gcc/debug.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -42,7 +42,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_tree,\t\t         /* function_decl */\n   debug_nothing_tree,\t\t         /* global_decl */\n   debug_nothing_tree_int,\t\t /* type_decl */\n-  debug_nothing_tree_tree,               /* imported_module_or_decl */\n+  debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx,\t\t         /* label */\n@@ -66,8 +66,10 @@ debug_nothing_tree (tree decl ATTRIBUTE_UNUSED)\n }\n \n void\n-debug_nothing_tree_tree (tree t1 ATTRIBUTE_UNUSED,\n-\t\t\t tree t2 ATTRIBUTE_UNUSED)\n+debug_nothing_tree_tree_tree_bool (tree t1 ATTRIBUTE_UNUSED,\n+\t\t\t\t   tree t2 ATTRIBUTE_UNUSED,\n+\t\t\t\t   tree t3 ATTRIBUTE_UNUSED,\n+\t\t\t\t   bool b1 ATTRIBUTE_UNUSED)\n {\n }\n "}, {"sha": "956ad0c3fab17e56ca952b6f0f8298f637de9b0b", "filename": "gcc/debug.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -98,7 +98,8 @@ struct gcc_debug_hooks\n   void (* type_decl) (tree decl, int local);\n \n   /* Debug information for imported modules and declarations.  */\n-  void (* imported_module_or_decl) (tree decl, tree context);\n+  void (* imported_module_or_decl) (tree decl, tree name,\n+\t\t\t\t    tree context, bool child);\n \n   /* DECL is an inline function, whose body is present, but which is\n      not being output at this point.  */\n@@ -139,7 +140,7 @@ extern void debug_nothing_int (unsigned int);\n extern void debug_nothing_int_int (unsigned int, unsigned int);\n extern void debug_nothing_tree (tree);\n extern void debug_nothing_tree_int (tree, int);\n-extern void debug_nothing_tree_tree (tree, tree);\n+extern void debug_nothing_tree_tree_tree_bool (tree, tree, tree, bool);\n extern bool debug_true_const_tree (const_tree);\n extern void debug_nothing_rtx (rtx);\n "}, {"sha": "cc27e39dc9ac5a924a47025b019a857db7c2c4e6", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 65, "deletions": 42, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -4485,7 +4485,7 @@ static void dwarf2out_end_block (unsigned, unsigned);\n static bool dwarf2out_ignore_block (const_tree);\n static void dwarf2out_global_decl (tree);\n static void dwarf2out_type_decl (tree, int);\n-static void dwarf2out_imported_module_or_decl (tree, tree);\n+static void dwarf2out_imported_module_or_decl (tree, tree, tree, bool);\n static void dwarf2out_abstract_function (tree);\n static void dwarf2out_var_location (rtx);\n static void dwarf2out_begin_function (tree);\n@@ -5115,7 +5115,7 @@ static void gen_decl_die (tree, dw_die_ref);\n static dw_die_ref force_decl_die (tree);\n static dw_die_ref force_type_die (tree);\n static dw_die_ref setup_namespace_context (tree, dw_die_ref);\n-static void declare_in_namespace (tree, dw_die_ref);\n+static dw_die_ref declare_in_namespace (tree, dw_die_ref);\n static struct dwarf_file_data * lookup_filename (const char *);\n static void retry_incomplete_types (void);\n static void gen_type_die_for_member (tree, tree, dw_die_ref);\n@@ -7196,7 +7196,8 @@ is_symbol_die (dw_die_ref c)\n   return (is_type_die (c)\n \t  || (get_AT (c, DW_AT_declaration)\n \t      && !get_AT (c, DW_AT_specification))\n-\t  || c->die_tag == DW_TAG_namespace);\n+\t  || c->die_tag == DW_TAG_namespace\n+\t  || c->die_tag == DW_TAG_module);\n }\n \n static char *\n@@ -13519,29 +13520,49 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n   com_decl = fortran_common (decl, &off);\n \n   /* Symbol in common gets emitted as a child of the common block, in the form\n-     of a data member.\n-\n-     ??? This creates a new common block die for every common block symbol.\n-     Better to share same common block die for all symbols in that block.  */\n+     of a data member.  */\n   if (com_decl)\n     {\n       tree field;\n       dw_die_ref com_die;\n-      const char *cnam = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (com_decl));\n-      dw_loc_descr_ref loc = loc_descriptor_from_tree (com_decl);\n \n+      if (lookup_decl_die (decl))\n+\treturn;\n       field = TREE_OPERAND (DECL_VALUE_EXPR (decl), 0);\n-      var_die = new_die (DW_TAG_common_block, context_die, decl);\n-      add_name_and_src_coords_attributes (var_die, field);\n-      add_AT_flag (var_die, DW_AT_external, 1);\n-      add_AT_loc (var_die, DW_AT_location, loc);\n+      var_die = lookup_decl_die (com_decl);\n+      if (var_die == NULL)\n+\t{\n+\t  const char *cnam\n+\t    = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (com_decl));\n+\t  dw_loc_descr_ref loc = loc_descriptor_from_tree (com_decl);\n+\n+\t  var_die = new_die (DW_TAG_common_block, context_die, decl);\n+\t  add_name_and_src_coords_attributes (var_die, com_decl);\n+\t  add_AT_flag (var_die, DW_AT_external, 1);\n+\t  if (loc)\n+\t    add_AT_loc (var_die, DW_AT_location, loc);\n+          else if (DECL_EXTERNAL (decl))\n+\t    add_AT_flag (var_die, DW_AT_declaration, 1);\n+\t  add_pubname_string (cnam, var_die); /* ??? needed? */\n+\t  equate_decl_number_to_die (com_decl, var_die);\n+\t}\n+      else if (get_AT (var_die, DW_AT_location) == NULL)\n+\t{\n+\t  dw_loc_descr_ref loc = loc_descriptor_from_tree (com_decl);\n+\n+\t  if (loc)\n+\t    {\n+\t      add_AT_loc (var_die, DW_AT_location, loc);\n+\t      remove_AT (var_die, DW_AT_declaration);\n+\t    }\n+\t}\n       com_die = new_die (DW_TAG_member, var_die, decl);\n       add_name_and_src_coords_attributes (com_die, decl);\n       add_type_attribute (com_die, TREE_TYPE (decl), TREE_READONLY (decl),\n \t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n       add_AT_loc (com_die, DW_AT_data_member_location,\n \t\t  int_loc_descriptor (off));\n-      add_pubname_string (cnam, var_die); /* ??? needed? */\n+      equate_decl_number_to_die (decl, com_die);\n       return;\n     }\n \n@@ -14306,7 +14327,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \t}\n       else\n \t{\n-\t  declare_in_namespace (type, context_die);\n+\t  context_die = declare_in_namespace (type, context_die);\n \t  need_pop = 0;\n \t}\n \n@@ -14678,29 +14699,32 @@ setup_namespace_context (tree thing, dw_die_ref context_die)\n    For compatibility with older debuggers, namespace DIEs only contain\n    declarations; all definitions are emitted at CU scope.  */\n \n-static void\n+static dw_die_ref\n declare_in_namespace (tree thing, dw_die_ref context_die)\n {\n   dw_die_ref ns_context;\n \n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n-    return;\n+    return context_die;\n \n   /* If this decl is from an inlined function, then don't try to emit it in its\n      namespace, as we will get confused.  It would have already been emitted\n      when the abstract instance of the inline function was emitted anyways.  */\n   if (DECL_P (thing) && DECL_ABSTRACT_ORIGIN (thing))\n-    return;\n+    return context_die;\n \n   ns_context = setup_namespace_context (thing, context_die);\n \n   if (ns_context != context_die)\n     {\n+      if (is_fortran ())\n+\treturn ns_context;\n       if (DECL_P (thing))\n \tgen_decl_die (thing, ns_context);\n       else\n \tgen_type_die (thing, ns_context);\n     }\n+  return context_die;\n }\n \n /* Generate a DIE for a namespace or namespace alias.  */\n@@ -14716,8 +14740,11 @@ gen_namespace_die (tree decl)\n     {\n       /* Output a real namespace.  */\n       dw_die_ref namespace_die\n-\t= new_die (DW_TAG_namespace, context_die, decl);\n+\t= new_die (is_fortran () ? DW_TAG_module : DW_TAG_namespace,\n+\t\t   context_die, decl);\n       add_name_and_src_coords_attributes (namespace_die, decl);\n+      if (DECL_EXTERNAL (decl))\n+\tadd_AT_flag (namespace_die, DW_AT_declaration, 1);\n       equate_decl_number_to_die (decl, namespace_die);\n     }\n   else\n@@ -14807,7 +14834,7 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n \t    gen_type_die_for_member (origin, decl, context_die);\n \n \t  /* And its containing namespace.  */\n-\t  declare_in_namespace (decl, context_die);\n+\t  context_die = declare_in_namespace (decl, context_die);\n \t}\n \n       /* Now output a DIE to represent the function itself.  */\n@@ -14852,16 +14879,6 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tbreak;\n \n-      /* If this is the global definition of the Fortran COMMON block, we don't\n-         need to do anything.  Syntactically, the block itself has no identity,\n-         just its constituent identifiers.  */\n-      if (TREE_CODE (decl) == VAR_DECL\n-          && TREE_PUBLIC (decl)\n-          && TREE_STATIC (decl)\n-          && is_fortran ()\n-          && !DECL_HAS_VALUE_EXPR_P (decl))\n-        break;\n-\n       /* Output any DIEs that are needed to specify the type of this data\n \t object.  */\n       if (TREE_CODE (decl) == RESULT_DECL && DECL_BY_REFERENCE (decl))\n@@ -14875,7 +14892,7 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n \tgen_type_die_for_member (origin, decl, context_die);\n \n       /* And its containing namespace.  */\n-      declare_in_namespace (decl, context_die);\n+      context_die = declare_in_namespace (decl, context_die);\n \n       /* Now output the DIE to represent the data object itself.  This gets\n \t complicated because of the possibility that the VAR_DECL really\n@@ -14928,15 +14945,7 @@ dwarf2out_global_decl (tree decl)\n   /* Output DWARF2 information for file-scope tentative data object\n      declarations, file-scope (extern) function declarations (which\n      had no corresponding body) and file-scope tagged type declarations\n-     and definitions which have not yet been forced out.\n-\n-     Ignore the global decl of any Fortran COMMON blocks which also\n-     wind up here though they have already been described in the local\n-     scope for the procedures using them.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && TREE_PUBLIC (decl) && TREE_STATIC (decl) && is_fortran ())\n-    return;\n-\n+     and definitions which have not yet been forced out.  */\n   if (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl))\n     dwarf2out_decl (decl);\n }\n@@ -14950,10 +14959,14 @@ dwarf2out_type_decl (tree decl, int local)\n     dwarf2out_decl (decl);\n }\n \n-/* Output debug information for imported module or decl.  */\n+/* Output debug information for imported module or decl DECL.\n+   NAME is non-NULL name in context if the decl has been renamed.\n+   CHILD is true if decl is one of the renamed decls as part of\n+   importing whole module.  */\n \n static void\n-dwarf2out_imported_module_or_decl (tree decl, tree context)\n+dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n+\t\t\t\t   bool child)\n {\n   dw_die_ref imported_die, at_import_die;\n   dw_die_ref scope_die;\n@@ -14976,6 +14989,14 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)\n     return;\n   scope_die = get_context_die (context);\n \n+  if (child)\n+    {\n+      gcc_assert (scope_die->die_child);\n+      gcc_assert (scope_die->die_child->die_tag == DW_TAG_imported_module);\n+      gcc_assert (TREE_CODE (decl) != NAMESPACE_DECL);\n+      scope_die = scope_die->die_child;\n+    }\n+\n   /* For TYPE_DECL or CONST_DECL, lookup TREE_TYPE.  */\n   if (TREE_CODE (decl) == TYPE_DECL || TREE_CODE (decl) == CONST_DECL)\n     {\n@@ -15026,6 +15047,8 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)\n   xloc = expand_location (input_location);\n   add_AT_file (imported_die, DW_AT_decl_file, lookup_filename (xloc.file));\n   add_AT_unsigned (imported_die, DW_AT_decl_line, xloc.line);\n+  if (name)\n+    add_AT_string (imported_die, DW_AT_name, IDENTIFIER_POINTER (name));\n   add_AT_die_ref (imported_die, DW_AT_import, at_import_die);\n }\n "}, {"sha": "a1a72e6122204802127b7ca5513068710b0a6859", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -1,3 +1,48 @@\n+2008-08-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/29635\n+\tPR fortran/23057\n+\t* f95-lang.c (gfc_init_ts): New function.\n+\t(LANG_HOOKS_INIT_TS): Define.\n+\t* gfortran.h (gfc_use_rename): New type, moved from module.c.\n+\t(gfc_get_use_rename): New macro, moved from module.c.\n+\t(gfc_use_list): New type.\n+\t(gfc_get_use_list): New macro.\n+\t(gfc_namespace): Add use_stmts field.\n+\t(gfc_free_use_stmts): New prototype.\n+\t* Make-lang.in (fortran/trans-decl.o): Depend on debug.h.\n+\t* module.c (gfc_use_rename, gfc_get_use_rename): Moved to\n+\tgfortran.h.\n+\t(gfc_use_module): Chain the USE statement info to\n+\tns->use_stmts.\n+\t(gfc_free_use_stmts): New function.\n+\t* symbol.c (gfc_free_namespace): Call gfc_free_use_stmts.\n+\t* trans.h (struct module_htab_entry): New type.\n+\t(gfc_find_module, gfc_module_add_decl): New functions.\n+\t* trans.c (gfc_generate_module_code): Create NAMESPACE_DECL for\n+\tthe module, adjust DECL_CONTEXTs of module procedures and\n+\tcall gfc_module_add_decl for them.\n+\t* trans-common.c (build_common_decl): Set DECL_IGNORED_P\n+\ton the common variable.\n+\t(create_common): Set DECL_IGNORED_P for use associated vars.\n+\t* trans-decl.c: Include debug.h.\n+\t(gfc_get_symbol_decl): Set DECL_IGNORED_P on use_assoc vars from\n+\tmodules.\n+\t(build_function_decl): Allow current_function_decl's context\n+\tto be a NAMESPACE_DECL.\n+\t(module_htab, cur_module): New variables.\n+\t(module_htab_do_hash, module_htab_eq, module_htab_decls_hash,\n+\tmodule_htab_decls_eq, gfc_find_module, gfc_module_add_decl): New\n+\tfunctions.\n+\t(gfc_create_module_variable): Adjust DECL_CONTEXTs of module\n+\tvariables and types and call gfc_module_add_decl for them.\n+\t(gfc_generate_module_vars): Temporarily set cur_module.\n+\t(gfc_trans_use_stmts): New function.\n+\t(gfc_generate_function_code): Call it.\n+\t(gfc_generate_block_data): Set DECL_IGNORED_P on decl.\n+\t* trans-types.c (gfc_get_derived_type): Adjust DECL_CONTEXT\n+\tand TYPE_CONTEXT of module derived types.\n+\n 2008-08-28  Daniel Kraft  <d@domob.eu>\n \n \t* gfortran.h (enum expr_t): New value `EXPR_COMPCALL'."}, {"sha": "255f07e4f52902d152fa96ad1b8c3e2f5f3e3764", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -314,7 +314,7 @@ fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS) tree-iterator.h\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n   $(CGRAPH_H) $(TARGET_H) $(FUNCTION_H) $(FLAGS_H) $(RTL_H) $(GIMPLE_H) \\\n-  $(TREE_DUMP_H)\n+  $(TREE_DUMP_H) debug.h\n fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n   $(REAL_H) toplev.h $(TARGET_H) $(FLAGS_H) dwarf2out.h\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)"}, {"sha": "30cc98e86d7ff5bc36cfc2976e9caf6e90b43e2a", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -99,6 +99,7 @@ int global_bindings_p (void);\n static void clear_binding_stack (void);\n static void gfc_be_parse_file (int);\n static alias_set_type gfc_get_alias_set (tree);\n+static void gfc_init_ts (void);\n \n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n@@ -112,6 +113,7 @@ static alias_set_type gfc_get_alias_set (tree);\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #undef LANG_HOOKS_GET_ALIAS_SET\n+#undef LANG_HOOKS_INIT_TS\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n #undef LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\n@@ -134,10 +136,11 @@ static alias_set_type gfc_get_alias_set (tree);\n #define LANG_HOOKS_POST_OPTIONS\t\tgfc_post_options\n #define LANG_HOOKS_PRINT_IDENTIFIER     gfc_print_identifier\n #define LANG_HOOKS_PARSE_FILE           gfc_be_parse_file\n-#define LANG_HOOKS_MARK_ADDRESSABLE        gfc_mark_addressable\n-#define LANG_HOOKS_TYPE_FOR_MODE           gfc_type_for_mode\n-#define LANG_HOOKS_TYPE_FOR_SIZE           gfc_type_for_size\n-#define LANG_HOOKS_GET_ALIAS_SET\t   gfc_get_alias_set\n+#define LANG_HOOKS_MARK_ADDRESSABLE\tgfc_mark_addressable\n+#define LANG_HOOKS_TYPE_FOR_MODE\tgfc_type_for_mode\n+#define LANG_HOOKS_TYPE_FOR_SIZE\tgfc_type_for_size\n+#define LANG_HOOKS_GET_ALIAS_SET\tgfc_get_alias_set\n+#define LANG_HOOKS_INIT_TS\t\tgfc_init_ts\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING\tgfc_omp_predetermined_sharing\n #define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\tgfc_omp_clause_default_ctor\n@@ -1189,5 +1192,15 @@ gfc_init_builtin_functions (void)\n #undef DEFINE_MATH_BUILTIN_C\n #undef DEFINE_MATH_BUILTIN\n \n+static void\n+gfc_init_ts (void)\n+{\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[NAMESPACE_DECL][TS_DECL_MINIMAL] = 1;\n+}\n+\n #include \"gt-fortran-f95-lang.h\"\n #include \"gtype-fortran.h\""}, {"sha": "81e48b7a21d5e304b4116b3b70f046fcb0f7fb42", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -1132,6 +1132,35 @@ gfc_entry_list;\n #define gfc_get_entry_list() \\\n   (gfc_entry_list *) gfc_getmem(sizeof(gfc_entry_list))\n \n+/* Lists of rename info for the USE statement.  */\n+\n+typedef struct gfc_use_rename\n+{\n+  char local_name[GFC_MAX_SYMBOL_LEN + 1], use_name[GFC_MAX_SYMBOL_LEN + 1];\n+  struct gfc_use_rename *next;\n+  int found;\n+  gfc_intrinsic_op op;\n+  locus where;\n+}\n+gfc_use_rename;\n+\n+#define gfc_get_use_rename() XCNEW (gfc_use_rename);\n+\n+/* A list of all USE statements in a namespace.  */\n+\n+typedef struct gfc_use_list\n+{\n+  const char *module_name;\n+  int only_flag;\n+  struct gfc_use_rename *rename;\n+  /* Next USE statement.  */\n+  struct gfc_use_list *next;\n+}\n+gfc_use_list;\n+\n+#define gfc_get_use_list() \\\n+  (gfc_use_list *) gfc_getmem(sizeof(gfc_use_list))\n+\n /* Within a namespace, symbols are pointed to by symtree nodes that\n    are linked together in a balanced binary tree.  There can be\n    several symtrees pointing to the same symbol node via USE\n@@ -1232,6 +1261,9 @@ typedef struct gfc_namespace\n   /* A list of all alternate entry points to this procedure (or NULL).  */\n   gfc_entry_list *entries;\n \n+  /* A list of USE statements in this namespace.  */\n+  gfc_use_list *use_stmts;\n+\n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n   int is_block_data;\n \n@@ -2472,6 +2504,7 @@ void gfc_module_init_2 (void);\n void gfc_module_done_2 (void);\n void gfc_dump_module (const char *, int);\n bool gfc_check_access (gfc_access, gfc_access);\n+void gfc_free_use_stmts (gfc_use_list *);\n \n /* primary.c */\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);"}, {"sha": "b67b87839d5c1666abdc23990f26e4512a95e1bd", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -162,20 +162,6 @@ pointer_info;\n #define gfc_get_pointer_info() XCNEW (pointer_info)\n \n \n-/* Lists of rename info for the USE statement.  */\n-\n-typedef struct gfc_use_rename\n-{\n-  char local_name[GFC_MAX_SYMBOL_LEN + 1], use_name[GFC_MAX_SYMBOL_LEN + 1];\n-  struct gfc_use_rename *next;\n-  int found;\n-  gfc_intrinsic_op op;\n-  locus where;\n-}\n-gfc_use_rename;\n-\n-#define gfc_get_use_rename() XCNEW (gfc_use_rename);\n-\n /* Local variables */\n \n /* The FILE for the module we're reading or writing.  */\n@@ -5058,6 +5044,7 @@ gfc_use_module (void)\n   gfc_state_data *p;\n   int c, line, start;\n   gfc_symtree *mod_symtree;\n+  gfc_use_list *use_stmt;\n \n   filename = (char *) alloca (strlen (module_name) + strlen (MODULE_EXTENSION)\n \t\t\t      + 1);\n@@ -5150,6 +5137,33 @@ gfc_use_module (void)\n   pi_root = NULL;\n \n   fclose (module_fp);\n+\n+  use_stmt = gfc_get_use_list ();\n+  use_stmt->module_name = gfc_get_string (module_name);\n+  use_stmt->only_flag = only_flag;\n+  use_stmt->rename = gfc_rename_list;\n+  gfc_rename_list = NULL;\n+  use_stmt->next = gfc_current_ns->use_stmts;\n+  gfc_current_ns->use_stmts = use_stmt;\n+}\n+\n+\n+void\n+gfc_free_use_stmts (gfc_use_list *use_stmts)\n+{\n+  gfc_use_list *next;\n+  for (; use_stmts; use_stmts = next)\n+    {\n+      gfc_use_rename *next_rename;\n+\n+      for (; use_stmts->rename; use_stmts->rename = next_rename)\n+\t{\n+\t  next_rename = use_stmts->rename->next;\n+\t  gfc_free (use_stmts->rename);\n+\t}\n+      next = use_stmts->next;\n+      gfc_free (use_stmts);\n+    }\n }\n \n "}, {"sha": "41e8006809e28d321c286c99180156974c43caeb", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -3023,6 +3023,7 @@ gfc_free_namespace (gfc_namespace *ns)\n \n   gfc_free_equiv (ns->equiv);\n   gfc_free_equiv_lists (ns->equiv_lists);\n+  gfc_free_use_stmts (ns->use_stmts);\n \n   for (i = GFC_INTRINSIC_BEGIN; i != GFC_INTRINSIC_END; i++)\n     gfc_free_interface (ns->op[i]);"}, {"sha": "9e55792f20b86565f58fd5a390455d631b9fdbfc", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -416,6 +416,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n       SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_common_id (com));\n       TREE_PUBLIC (decl) = 1;\n       TREE_STATIC (decl) = 1;\n+      DECL_IGNORED_P (decl) = 1;\n       if (!com->is_bind_c)\n \tDECL_ALIGN (decl) = BIGGEST_ALIGNMENT;\n       else\n@@ -680,6 +681,8 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n       TREE_PUBLIC (var_decl) = TREE_PUBLIC (decl);\n       TREE_STATIC (var_decl) = TREE_STATIC (decl);\n       TREE_USED (var_decl) = TREE_USED (decl);\n+      if (s->sym->attr.use_assoc)\n+\tDECL_IGNORED_P (var_decl) = 1;\n       if (s->sym->attr.target)\n \tTREE_ADDRESSABLE (var_decl) = 1;\n       /* This is a fake variable just for debugging purposes.  */"}, {"sha": "59b33cae33449547bf2efe8c00b42f506b272d18", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 199, "deletions": 4, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"flags.h\"\n #include \"cgraph.h\"\n+#include \"debug.h\"\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n@@ -994,7 +995,11 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n      This is done here rather than in gfc_finish_var_decl because it\n      is different for string length variables.  */\n   if (sym->module)\n-    SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_identifier (sym));\n+    {\n+      SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_identifier (sym));\n+      if (sym->attr.use_assoc)\n+\tDECL_IGNORED_P (decl) = 1;\n+    }\n \n   if (sym->attr.dimension)\n     {\n@@ -1300,7 +1305,9 @@ build_function_decl (gfc_symbol * sym)\n \n   /* Allow only one nesting level.  Allow public declarations.  */\n   gcc_assert (current_function_decl == NULL_TREE\n-\t  || DECL_CONTEXT (current_function_decl) == NULL_TREE);\n+\t      || DECL_CONTEXT (current_function_decl) == NULL_TREE\n+\t      || TREE_CODE (DECL_CONTEXT (current_function_decl))\n+\t\t == NAMESPACE_DECL);\n \n   type = gfc_get_function_type (sym);\n   fndecl = build_decl (FUNCTION_DECL, gfc_sym_identifier (sym), type);\n@@ -2922,6 +2929,88 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   return gfc_finish_block (&body);\n }\n \n+static GTY ((param_is (struct module_htab_entry))) htab_t module_htab;\n+\n+/* Hash and equality functions for module_htab.  */\n+\n+static hashval_t\n+module_htab_do_hash (const void *x)\n+{\n+  return htab_hash_string (((const struct module_htab_entry *)x)->name);\n+}\n+\n+static int\n+module_htab_eq (const void *x1, const void *x2)\n+{\n+  return strcmp ((((const struct module_htab_entry *)x1)->name),\n+\t\t (const char *)x2) == 0;\n+}\n+\n+/* Hash and equality functions for module_htab's decls.  */\n+\n+static hashval_t\n+module_htab_decls_hash (const void *x)\n+{\n+  const_tree t = (const_tree) x;\n+  const_tree n = DECL_NAME (t);\n+  if (n == NULL_TREE)\n+    n = TYPE_NAME (TREE_TYPE (t));\n+  return htab_hash_string (IDENTIFIER_POINTER (n));\n+}\n+\n+static int\n+module_htab_decls_eq (const void *x1, const void *x2)\n+{\n+  const_tree t1 = (const_tree) x1;\n+  const_tree n1 = DECL_NAME (t1);\n+  if (n1 == NULL_TREE)\n+    n1 = TYPE_NAME (TREE_TYPE (t1));\n+  return strcmp (IDENTIFIER_POINTER (n1), (const char *) x2) == 0;\n+}\n+\n+struct module_htab_entry *\n+gfc_find_module (const char *name)\n+{\n+  void **slot;\n+\n+  if (! module_htab)\n+    module_htab = htab_create_ggc (10, module_htab_do_hash,\n+\t\t\t\t   module_htab_eq, NULL);\n+\n+  slot = htab_find_slot_with_hash (module_htab, name,\n+\t\t\t\t   htab_hash_string (name), INSERT);\n+  if (*slot == NULL)\n+    {\n+      struct module_htab_entry *entry = GGC_CNEW (struct module_htab_entry);\n+\n+      entry->name = gfc_get_string (name);\n+      entry->decls = htab_create_ggc (10, module_htab_decls_hash,\n+\t\t\t\t      module_htab_decls_eq, NULL);\n+      *slot = (void *) entry;\n+    }\n+  return (struct module_htab_entry *) *slot;\n+}\n+\n+void\n+gfc_module_add_decl (struct module_htab_entry *entry, tree decl)\n+{\n+  void **slot;\n+  const char *name;\n+\n+  if (DECL_NAME (decl))\n+    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+  else\n+    {\n+      gcc_assert (TREE_CODE (decl) == TYPE_DECL);\n+      name = IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl)));\n+    }\n+  slot = htab_find_slot_with_hash (entry->decls, name,\n+\t\t\t\t   htab_hash_string (name), INSERT);\n+  if (*slot == NULL)\n+    *slot = (void *) decl;\n+}\n+\n+static struct module_htab_entry *cur_module;\n \n /* Output an initialized decl for a module variable.  */\n \n@@ -2941,22 +3030,47 @@ gfc_create_module_variable (gfc_symbol * sym)\n       && sym->ts.type == BT_DERIVED)\n     sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));\n \n+  if (sym->attr.flavor == FL_DERIVED\n+      && sym->backend_decl\n+      && TREE_CODE (sym->backend_decl) == RECORD_TYPE)\n+    {\n+      decl = sym->backend_decl;\n+      gcc_assert (sym->ns->proc_name->attr.flavor == FL_MODULE);\n+      gcc_assert (TYPE_CONTEXT (decl) == NULL_TREE\n+\t\t  || TYPE_CONTEXT (decl) == sym->ns->proc_name->backend_decl);\n+      gcc_assert (DECL_CONTEXT (TYPE_STUB_DECL (decl)) == NULL_TREE\n+\t\t  || DECL_CONTEXT (TYPE_STUB_DECL (decl))\n+\t\t     == sym->ns->proc_name->backend_decl);\n+      TYPE_CONTEXT (decl) = sym->ns->proc_name->backend_decl;\n+      DECL_CONTEXT (TYPE_STUB_DECL (decl)) = sym->ns->proc_name->backend_decl;\n+      gfc_module_add_decl (cur_module, TYPE_STUB_DECL (decl));\n+    }\n+\n   /* Only output variables and array valued, or derived type,\n      parameters.  */\n   if (sym->attr.flavor != FL_VARIABLE\n \t&& !(sym->attr.flavor == FL_PARAMETER\n \t       && (sym->attr.dimension || sym->ts.type == BT_DERIVED)))\n     return;\n \n+  if ((sym->attr.in_common || sym->attr.in_equivalence) && sym->backend_decl)\n+    {\n+      decl = sym->backend_decl;\n+      gcc_assert (DECL_CONTEXT (decl) == NULL_TREE);\n+      gcc_assert (sym->ns->proc_name->attr.flavor == FL_MODULE);\n+      DECL_CONTEXT (decl) = sym->ns->proc_name->backend_decl;\n+      gfc_module_add_decl (cur_module, decl);\n+    }\n+\n   /* Don't generate variables from other modules. Variables from\n      COMMONs will already have been generated.  */\n   if (sym->attr.use_assoc || sym->attr.in_common)\n     return;\n \n   /* Equivalenced variables arrive here after creation.  */\n   if (sym->backend_decl\n-\t&& (sym->equiv_built || sym->attr.in_equivalence))\n-      return;\n+      && (sym->equiv_built || sym->attr.in_equivalence))\n+    return;\n \n   if (sym->backend_decl)\n     internal_error (\"backend decl for module variable %s already exists\",\n@@ -2969,7 +3083,11 @@ gfc_create_module_variable (gfc_symbol * sym)\n \n   /* Create the variable.  */\n   pushdecl (decl);\n+  gcc_assert (DECL_CONTEXT (decl) == NULL_TREE);\n+  gcc_assert (sym->ns->proc_name->attr.flavor == FL_MODULE);\n+  DECL_CONTEXT (decl) = sym->ns->proc_name->backend_decl;\n   rest_of_decl_compilation (decl, 1, 0);\n+  gfc_module_add_decl (cur_module, decl);\n \n   /* Also add length of strings.  */\n   if (sym->ts.type == BT_CHARACTER)\n@@ -2992,6 +3110,7 @@ void\n gfc_generate_module_vars (gfc_namespace * ns)\n {\n   module_namespace = ns;\n+  cur_module = gfc_find_module (ns->proc_name->name);\n \n   /* Check if the frontend left the namespace in a reasonable state.  */\n   gcc_assert (ns->proc_name && !ns->proc_name->tlink);\n@@ -3001,6 +3120,79 @@ gfc_generate_module_vars (gfc_namespace * ns)\n \n   /* Create decls for all the module variables.  */\n   gfc_traverse_ns (ns, gfc_create_module_variable);\n+\n+  cur_module = NULL;\n+}\n+\n+static void\n+gfc_trans_use_stmts (gfc_namespace * ns)\n+{\n+  gfc_use_list *use_stmt;\n+  for (use_stmt = ns->use_stmts; use_stmt; use_stmt = use_stmt->next)\n+    {\n+      struct module_htab_entry *entry\n+\t= gfc_find_module (use_stmt->module_name);\n+      gfc_use_rename *rent;\n+\n+      if (entry->namespace_decl == NULL)\n+\t{\n+\t  entry->namespace_decl\n+\t    = build_decl (NAMESPACE_DECL,\n+\t\t\t  get_identifier (use_stmt->module_name),\n+\t\t\t  void_type_node);\n+\t  DECL_EXTERNAL (entry->namespace_decl) = 1;\n+\t}\n+      if (!use_stmt->only_flag)\n+\t(*debug_hooks->imported_module_or_decl) (entry->namespace_decl,\n+\t\t\t\t\t\t NULL_TREE,\n+\t\t\t\t\t\t ns->proc_name->backend_decl,\n+\t\t\t\t\t\t false);\n+      for (rent = use_stmt->rename; rent; rent = rent->next)\n+\t{\n+\t  tree decl, local_name;\n+\t  void **slot;\n+\n+\t  if (rent->op != INTRINSIC_NONE)\n+\t    continue;\n+\n+\t  slot = htab_find_slot_with_hash (entry->decls, rent->use_name,\n+\t\t\t\t\t   htab_hash_string (rent->use_name),\n+\t\t\t\t\t   INSERT);\n+\t  if (*slot == NULL)\n+\t    {\n+\t      gfc_symtree *st;\n+\n+\t      st = gfc_find_symtree (ns->sym_root,\n+\t\t\t\t     rent->local_name[0]\n+\t\t\t\t     ? rent->local_name : rent->use_name);\n+\t      gcc_assert (st && st->n.sym->attr.use_assoc);\n+\t      if (st->n.sym->backend_decl && DECL_P (st->n.sym->backend_decl))\n+\t\t{\n+\t\t  gcc_assert (DECL_EXTERNAL (entry->namespace_decl));\n+\t\t  decl = copy_node (st->n.sym->backend_decl);\n+\t\t  DECL_CONTEXT (decl) = entry->namespace_decl;\n+\t\t  DECL_EXTERNAL (decl) = 1;\n+\t\t  DECL_IGNORED_P (decl) = 0;\n+\t\t  DECL_INITIAL (decl) = NULL_TREE;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *slot = error_mark_node;\n+\t\t  htab_clear_slot (entry->decls, slot);\n+\t\t  continue;\n+\t\t}\n+\t      *slot = decl;\n+\t    }\n+\t  decl = (tree) *slot;\n+\t  if (rent->local_name[0])\n+\t    local_name = get_identifier (rent->local_name);\n+\t  else\n+\t    local_name = NULL_TREE;\n+\t  (*debug_hooks->imported_module_or_decl) (decl, local_name,\n+\t\t\t\t\t\t   ns->proc_name->backend_decl,\n+\t\t\t\t\t\t   !use_stmt->only_flag);\n+\t}\n+    }\n }\n \n static void\n@@ -3533,6 +3725,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n       gfc_gimplify_function (fndecl);\n       cgraph_finalize_function (fndecl, false);\n     }\n+\n+  gfc_trans_use_stmts (ns);\n }\n \n void\n@@ -3624,6 +3818,7 @@ gfc_generate_block_data (gfc_namespace * ns)\n   decl = build_decl (VAR_DECL, id, gfc_array_index_type);\n   TREE_PUBLIC (decl) = 1;\n   TREE_STATIC (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n \n   pushdecl (decl);\n   rest_of_decl_compilation (decl, 1, 0);"}, {"sha": "dbda199c709f8fd13cee2d6702cdcca711e4d0d6", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -1934,12 +1934,23 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n   gfc_finish_type (typenode);\n   gfc_set_decl_location (TYPE_STUB_DECL (typenode), &derived->declared_at);\n+  if (derived->module && derived->ns->proc_name->attr.flavor == FL_MODULE)\n+    {\n+      if (derived->ns->proc_name->backend_decl\n+\t  && TREE_CODE (derived->ns->proc_name->backend_decl)\n+\t     == NAMESPACE_DECL)\n+\t{\n+\t  TYPE_CONTEXT (typenode) = derived->ns->proc_name->backend_decl;\n+\t  DECL_CONTEXT (TYPE_STUB_DECL (typenode))\n+\t    = derived->ns->proc_name->backend_decl;\n+\t}\n+    }\n \n   derived->backend_decl = typenode;\n \n-    /* Add this backend_decl to all the other, equal derived types.  */\n-    for (dt = gfc_derived_types; dt; dt = dt->next)\n-      copy_dt_decls_ifequal (derived, dt->derived);\n+  /* Add this backend_decl to all the other, equal derived types.  */\n+  for (dt = gfc_derived_types; dt; dt = dt->next)\n+    copy_dt_decls_ifequal (derived, dt->derived);\n \n   return derived->backend_decl;\n }"}, {"sha": "1b115f435fc85b54c3edbc179c77bbe5b531e083", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -1209,17 +1209,41 @@ void\n gfc_generate_module_code (gfc_namespace * ns)\n {\n   gfc_namespace *n;\n+  struct module_htab_entry *entry;\n+\n+  gcc_assert (ns->proc_name->backend_decl == NULL);\n+  ns->proc_name->backend_decl\n+    = build_decl (NAMESPACE_DECL, get_identifier (ns->proc_name->name),\n+\t\t  void_type_node);\n+  gfc_set_decl_location (ns->proc_name->backend_decl,\n+\t\t\t &ns->proc_name->declared_at);\n+  entry = gfc_find_module (ns->proc_name->name);\n+  if (entry->namespace_decl)\n+    /* Buggy sourcecode, using a module before defining it?  */\n+    htab_empty (entry->decls);\n+  entry->namespace_decl = ns->proc_name->backend_decl;\n \n   gfc_generate_module_vars (ns);\n \n   /* We need to generate all module function prototypes first, to allow\n      sibling calls.  */\n   for (n = ns->contained; n; n = n->sibling)\n     {\n+      gfc_entry_list *el;\n+\n       if (!n->proc_name)\n         continue;\n \n       gfc_create_function_decl (n);\n+      gcc_assert (DECL_CONTEXT (n->proc_name->backend_decl) == NULL_TREE);\n+      DECL_CONTEXT (n->proc_name->backend_decl) = ns->proc_name->backend_decl;\n+      gfc_module_add_decl (entry, n->proc_name->backend_decl);\n+      for (el = ns->entries; el; el = el->next)\n+\t{\n+\t  gcc_assert (DECL_CONTEXT (el->sym->backend_decl) == NULL_TREE);\n+\t  DECL_CONTEXT (el->sym->backend_decl) = ns->proc_name->backend_decl;\n+\t  gfc_module_add_decl (entry, el->sym->backend_decl);\n+\t}\n     }\n \n   for (n = ns->contained; n; n = n->sibling)"}, {"sha": "290c92bd11d5eb57cd1e8a4b2207ab8cbcdc7b73", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -429,6 +429,16 @@ void gfc_generate_block_data (gfc_namespace *);\n /* Output a decl for a module variable.  */\n void gfc_generate_module_vars (gfc_namespace *);\n \n+struct module_htab_entry GTY(())\n+{\n+  const char *name;\n+  tree namespace_decl;\n+  htab_t GTY ((param_is (union tree_node))) decls;\n+};\n+\n+struct module_htab_entry *gfc_find_module (const char *);\n+void gfc_module_add_decl (struct module_htab_entry *, tree);\n+\n /* Get and set the current location.  */\n void gfc_set_backend_locus (locus *);\n void gfc_get_backend_locus (locus *);"}, {"sha": "e6f14fa2f7868eed3a15734ddf760c0f80ad0e18", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -329,7 +329,7 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   debug_nothing_tree,\t\t         /* function_decl */\n   sdbout_global_decl,\t\t         /* global_decl */\n   sdbout_symbol,\t\t\t /* type_decl */\n-  debug_nothing_tree_tree,               /* imported_module_or_decl */\n+  debug_nothing_tree_tree_tree_bool,\t /* imported_module_or_decl */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   sdbout_label,\t\t\t         /* label */"}, {"sha": "c655caa53b9b398879e761c5d674178f44c7b2ce", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64f5186dd1a3ea27bc7540c625ab24afd8030a3/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=a64f5186dd1a3ea27bc7540c625ab24afd8030a3", "patch": "@@ -204,7 +204,7 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    vmsdbgout_decl,\n    vmsdbgout_global_decl,\n    debug_nothing_tree_int,\t  /* type_decl */\n-   debug_nothing_tree_tree,       /* imported_module_or_decl */\n+   debug_nothing_tree_tree_tree_bool, /* imported_module_or_decl */\n    debug_nothing_tree,\t\t  /* deferred_inline_function */\n    vmsdbgout_abstract_function,\n    debug_nothing_rtx,\t\t  /* label */"}]}