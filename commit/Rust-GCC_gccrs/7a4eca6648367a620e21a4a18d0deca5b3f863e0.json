{"sha": "7a4eca6648367a620e21a4a18d0deca5b3f863e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E0ZWNhNjY0ODM2N2E2MjBlMjFhNGExOGQwZGVjYTViM2Y4NjNlMA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-08-08T16:36:26Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-08-08T16:36:26Z"}, "message": "re PR target/18506 (Altivec definitions of vec_init)\n\n\tPR target/18506\n\t* config/rs6000/altivec.md (vec_init<mode>): New.\n\t(vec_set<mode>): New.\n\t(vec_extract<mode>): New.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): New.\n\t(rs6000_expand_vector_set): New.\n\t(rs6000_expand_vector_extract): New.\n\t(rs6000_legitimate_offset_address_p): Offset addresses are valid\n\tfor Altivec modes before reload.\n\t(altivec_expand_vec_init_builtin): New.\n\t(get_element_number): New.\n\t(altivec_expand_vec_set_builtin): New.\n\t(altivec_expand_vec_ext_builtin): New.\n\t(altivec_expand_builtin): Expand vec_init, vec_set, and vec_ext\n\tbuiltins.\n\t(altivec_init_builtins): Init vec_init, vec_set, and vec_ext\n\tbuiltins.\n\t* config/rs6000/rs6000.h (rs6000_builtins): Add\n\tALTIVEC_BUILTIN_VEC_INIT_<mode>, ALTIVEC_BUILTIN_VEC_SET_<mode>,\n\tALTIVEC_BUILTIN_VEC_EXT_<mode>.\n\t* config/rs6000/rs6000-protos.h: Declare new functions.\n\nFrom-SVN: r102861", "tree": {"sha": "ef0bea54d1ca336ae0751be8492a4dd5fd1fd8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef0bea54d1ca336ae0751be8492a4dd5fd1fd8db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a4eca6648367a620e21a4a18d0deca5b3f863e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a4eca6648367a620e21a4a18d0deca5b3f863e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a4eca6648367a620e21a4a18d0deca5b3f863e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a4eca6648367a620e21a4a18d0deca5b3f863e0/comments", "author": null, "committer": null, "parents": [{"sha": "47efdea45ed80d81aac8c2e74208bc0631467b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47efdea45ed80d81aac8c2e74208bc0631467b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47efdea45ed80d81aac8c2e74208bc0631467b2f"}], "stats": {"total": 519, "additions": 513, "deletions": 6}, "files": [{"sha": "8df02647f8c11b635ce44cc4c40aabe17dfa69ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a4eca6648367a620e21a4a18d0deca5b3f863e0", "patch": "@@ -1,3 +1,27 @@\n+2005-08-08  David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR target/18506\n+\t* config/rs6000/altivec.md (vec_init<mode>): New.\n+\t(vec_set<mode>): New.\n+\t(vec_extract<mode>): New.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): New.\n+\t(rs6000_expand_vector_set): New.\n+\t(rs6000_expand_vector_extract): New.\n+\t(rs6000_legitimate_offset_address_p): Offset addresses are valid\n+\tfor Altivec modes before reload.\n+\t(altivec_expand_vec_init_builtin): New.\n+\t(get_element_number): New.\n+\t(altivec_expand_vec_set_builtin): New.\n+\t(altivec_expand_vec_ext_builtin): New.\n+\t(altivec_expand_builtin): Expand vec_init, vec_set, and vec_ext\n+\tbuiltins.\n+\t(altivec_init_builtins): Init vec_init, vec_set, and vec_ext\n+\tbuiltins.\n+\t* config/rs6000/rs6000.h (rs6000_builtins): Add\n+\tALTIVEC_BUILTIN_VEC_INIT_<mode>, ALTIVEC_BUILTIN_VEC_SET_<mode>,\n+\tALTIVEC_BUILTIN_VEC_EXT_<mode>.\n+\t* config/rs6000/rs6000-protos.h: Declare new functions.\n+\n 2005-08-08  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (legitimate_pic_address_disp_p): Refuse GOTOFF in 64bit mode."}, {"sha": "2b03502172c25a784da9326c7311ff338ceec4ee", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=7a4eca6648367a620e21a4a18d0deca5b3f863e0", "patch": "@@ -1840,7 +1840,7 @@\n (define_insn \"altivec_lve<VI_char>x\"\n   [(parallel\n     [(set (match_operand:VI 0 \"register_operand\" \"=v\")\n-\t  (match_operand:VI 1 \"memory_operand\" \"m\"))\n+\t  (match_operand:VI 1 \"memory_operand\" \"Z\"))\n      (unspec [(const_int 0)] UNSPEC_LVE)])]\n   \"TARGET_ALTIVEC\"\n   \"lve<VI_char>x %0,%y1\"\n@@ -1849,7 +1849,7 @@\n (define_insn \"*altivec_lvesfx\"\n   [(parallel\n     [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n-\t  (match_operand:V4SF 1 \"memory_operand\" \"m\"))\n+\t  (match_operand:V4SF 1 \"memory_operand\" \"Z\"))\n      (unspec [(const_int 0)] UNSPEC_LVE)])]\n   \"TARGET_ALTIVEC\"\n   \"lvewx %0,%y1\"\n@@ -1907,6 +1907,95 @@\n   \"stvewx %1,%y0\"\n   [(set_attr \"type\" \"vecstore\")])\n \n+(define_expand \"vec_init<mode>\"\n+  [(match_operand:V 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv4si\"\n+  [(match_operand:V4SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_set (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv8hi\"\n+  [(match_operand:V8HI 0 \"register_operand\" \"\")\n+   (match_operand:HI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_set (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv16qi\"\n+  [(match_operand:V16QI 0 \"register_operand\" \"\")\n+   (match_operand:QI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_set (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv4sf\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_set (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv4si\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:V4SI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_extract (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv8hi\"\n+  [(match_operand:HI 0 \"register_operand\" \"\")\n+   (match_operand:V8HI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_extract (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv16qi\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\n+   (match_operand:V16QI 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_extract (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv4sf\"\n+  [(match_operand:SF 0 \"register_operand\" \"\")\n+   (match_operand:V4SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_ALTIVEC\"\n+{\n+  rs6000_expand_vector_extract (operands[0], operands[1], INTVAL (operands[2]));\n+  DONE;\n+})\n+\n ;; Generate\n ;;    vspltis? SCRATCH0,0\n ;;    vsubu?m SCRATCH2,SCRATCH1,%1"}, {"sha": "2b117b4559e02b0b72690491deb236951a49a09a", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=7a4eca6648367a620e21a4a18d0deca5b3f863e0", "patch": "@@ -50,6 +50,9 @@ extern rtx rs6000_got_register (rtx);\n extern rtx find_addr_reg (rtx);\n extern rtx gen_easy_vector_constant_add_self (rtx);\n extern const char *output_vec_const_move (rtx *);\n+extern void rs6000_expand_vector_init (rtx, rtx);\n+extern void rs6000_expand_vector_set (rtx, rtx, int);\n+extern void rs6000_expand_vector_extract (rtx, rtx, int);\n extern void build_mask64_2_operands (rtx, rtx *);\n extern int expand_block_clear (rtx[]);\n extern int expand_block_move (rtx[]);"}, {"sha": "4cb97c59143301ce707526748fc2ee8b5fc1f797", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 383, "deletions": 4, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7a4eca6648367a620e21a4a18d0deca5b3f863e0", "patch": "@@ -684,6 +684,10 @@ static rtx altivec_expand_predicate_builtin (enum insn_code,\n \t\t\t\t\t     const char *, tree, rtx);\n static rtx altivec_expand_lv_builtin (enum insn_code, tree, rtx);\n static rtx altivec_expand_stv_builtin (enum insn_code, tree);\n+static rtx altivec_expand_vec_init_builtin (tree, tree, rtx);\n+static rtx altivec_expand_vec_set_builtin (tree);\n+static rtx altivec_expand_vec_ext_builtin (tree, rtx);\n+static int get_element_number (tree, tree);\n static bool rs6000_handle_option (size_t, const char *, int);\n static void rs6000_parse_tls_size_option (void);\n static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n@@ -2179,6 +2183,170 @@ output_vec_const_move (rtx *operands)\n     return \"li %0,%1\\n\\tevmergelo %0,%0,%0\\n\\tli %0,%2\";\n }\n \n+/* Initialize vector TARGET to VALS.  */\n+\n+void\n+rs6000_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int n_var = 0, one_var = -1;\n+  bool all_same = true, all_const_zero = true;\n+  rtx x, mem;\n+  int i;\n+\n+  for (i = 0; i < n_elts; ++i)\n+    {\n+      x = XVECEXP (vals, 0, i);\n+      if (!CONSTANT_P (x))\n+\t++n_var, one_var = i;\n+      else if (x != CONST0_RTX (inner_mode))\n+\tall_const_zero = false;\n+\n+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n+\tall_same = false;\n+    }\n+\n+  if (n_var == 0)\n+    {\n+      if (mode != V4SFmode && all_const_zero)\n+\t{\n+\t  /* Zero register.  */\n+\t  emit_insn (gen_rtx_SET (VOIDmode, target,\n+\t\t\t\t  gen_rtx_XOR (mode, target, target)));\n+\t  return;\n+\t}\n+      else if (mode != V4SFmode && easy_vector_same (vals, mode))\n+\t{\n+\t  /* Splat immediate.  */\n+\t  x = gen_rtx_VEC_DUPLICATE (mode, CONST_VECTOR_ELT (vals, 0));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+\t  return;\n+\t}\n+      else if (all_same)\n+\t;\t/* Splat vector element.  */\n+      else\n+\t{\n+\t  /* Load from constant pool.  */\n+\t  emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n+\t  return;\n+\t}\n+    }\n+\n+  /* Store value to stack temp.  Load vector element.  Splat.  */\n+  if (all_same)\n+    {\n+      mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode), 0);\n+      emit_move_insn (adjust_address_nv (mem, inner_mode, 0),\n+\t\t      XVECEXP (vals, 0, 0));\n+      x = gen_rtx_UNSPEC (VOIDmode,\n+\t\t\t  gen_rtvec (1, const0_rtx), UNSPEC_LVE);\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t   gen_rtvec (2,\n+\t\t\t\t\t      gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t\t   target, mem),\n+\t\t\t\t\t      x)));\n+      x = gen_rtx_VEC_SELECT (inner_mode, target,\n+\t\t\t      gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t\tgen_rtvec (1, const0_rtx)));\n+      emit_insn (gen_rtx_SET (VOIDmode, target,\n+\t\t\t      gen_rtx_VEC_DUPLICATE (mode, x)));\n+      return;\n+    }\n+\n+  /* One field is non-constant.  Load constant then overwrite\n+     varying field.  */\n+  if (n_var == 1)\n+    {\n+      rtx copy = copy_rtx (vals);\n+\n+      /* Load constant part of vector, substititute neighboring value for\n+\t varying element.  */\n+      XVECEXP (copy, 0, one_var) = XVECEXP (vals, 0, (one_var + 1) % n_elts);\n+      rs6000_expand_vector_init (target, copy);\n+\n+      /* Insert variable.  */\n+      rs6000_expand_vector_set (target, XVECEXP (vals, 0, one_var), one_var);\n+      return;\n+    }\n+\n+  /* Construct the vector in memory one field at a time\n+     and load the whole vector.  */\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  for (i = 0; i < n_elts; i++)\n+    emit_move_insn (adjust_address_nv (mem, inner_mode,\n+\t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n+\t\t    XVECEXP (vals, 0, i));\n+  emit_move_insn (target, mem);\n+}\n+\n+/* Set field ELT of TARGET to VAL.  */\n+\n+void\n+rs6000_expand_vector_set (rtx target, rtx val, int elt)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  rtx reg = gen_reg_rtx (mode);\n+  rtx mask, mem, x;\n+  int width = GET_MODE_SIZE (inner_mode);\n+  int i;\n+\n+  /* Load single variable value.  */\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode), 0);\n+  emit_move_insn (adjust_address_nv (mem, inner_mode, 0), val);\n+  x = gen_rtx_UNSPEC (VOIDmode,\n+\t\t      gen_rtvec (1, const0_rtx), UNSPEC_LVE);\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t       gen_rtvec (2,\n+\t\t\t\t\t  gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t       reg, mem),\n+\t\t\t\t\t  x)));\n+\n+  /* Linear sequence.  */\n+  mask = gen_rtx_PARALLEL (V16QImode, rtvec_alloc (16));\n+  for (i = 0; i < 16; ++i)\n+    XVECEXP (mask, 0, i) = GEN_INT (i);\n+\n+  /* Set permute mask to insert element into target.  */\n+  for (i = 0; i < width; ++i)\n+    XVECEXP (mask, 0, elt*width + i)\n+      = GEN_INT (i + 0x10);\n+  x = gen_rtx_CONST_VECTOR (V16QImode, XVEC (mask, 0));\n+  x = gen_rtx_UNSPEC (mode,\n+\t\t      gen_rtvec (3, target, reg,\n+\t\t\t\t force_reg (V16QImode, x)),\n+\t\t      UNSPEC_VPERM);\n+  emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+}\n+\n+/* Extract field ELT from VEC into TARGET.  */\n+\n+void\n+rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n+{\n+  enum machine_mode mode = GET_MODE (vec);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  rtx mem, x;\n+\n+  /* Allocate mode-sized buffer.  */\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+\n+  /* Add offset to field within buffer matching vector element.  */\n+  mem = adjust_address_nv (mem, mode, elt * GET_MODE_SIZE (inner_mode));\n+\n+  /* Store single field into mode-sized buffer.  */\n+  x = gen_rtx_UNSPEC (VOIDmode,\n+\t\t      gen_rtvec (1, const0_rtx), UNSPEC_STVE);\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t       gen_rtvec (2,\n+\t\t\t\t\t  gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\t       mem, vec),\n+\t\t\t\t\t  x)));\n+  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n+}\n+\n int\n mask64_1or2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       bool allow_one)\n@@ -2499,10 +2667,10 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n     case V8HImode:\n     case V4SFmode:\n     case V4SImode:\n-      /* AltiVec vector modes.  Only reg+reg addressing is valid here,\n-\t which leaves the only valid constant offset of zero, which by\n-\t canonicalization rules is also invalid.  */\n-      return false;\n+      /* AltiVec vector modes.  Only reg+reg addressing is valid and\n+\t constant offset zero should not occur due to canonicalization.\n+\t Allow any offset when not strict before reload.  */\n+      return !strict;\n \n     case V4HImode:\n     case V2SImode:\n@@ -6883,6 +7051,111 @@ altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n   return NULL_RTX;\n }\n \n+/* Expand vec_init builtin.  */\n+static rtx\n+altivec_expand_vec_init_builtin (tree type, tree arglist, rtx target)\n+{\n+  enum machine_mode tmode = TYPE_MODE (type);\n+  enum machine_mode inner_mode = GET_MODE_INNER (tmode);\n+  int i, n_elt = GET_MODE_NUNITS (tmode);\n+  rtvec v = rtvec_alloc (n_elt);\n+\n+  gcc_assert (VECTOR_MODE_P (tmode));\n+\n+  for (i = 0; i < n_elt; ++i, arglist = TREE_CHAIN (arglist))\n+    {\n+      rtx x = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+      RTVEC_ELT (v, i) = gen_lowpart (inner_mode, x);\n+    }\n+\n+  gcc_assert (arglist == NULL);\n+\n+  if (!target || !register_operand (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  rs6000_expand_vector_init (target, gen_rtx_PARALLEL (tmode, v));\n+  return target;\n+}\n+\n+/* Return the integer constant in ARG.  Constrain it to be in the range\n+   of the subparts of VEC_TYPE; issue an error if not.  */\n+\n+static int\n+get_element_number (tree vec_type, tree arg)\n+{\n+  unsigned HOST_WIDE_INT elt, max = TYPE_VECTOR_SUBPARTS (vec_type) - 1;\n+\n+  if (!host_integerp (arg, 1)\n+      || (elt = tree_low_cst (arg, 1), elt > max))\n+    {\n+      error (\"selector must be an integer constant in the range 0..%wi\", max);\n+      return 0;\n+    }\n+\n+  return elt;\n+}\n+\n+/* Expand vec_set builtin.  */\n+static rtx\n+altivec_expand_vec_set_builtin (tree arglist)\n+{\n+  enum machine_mode tmode, mode1;\n+  tree arg0, arg1, arg2;\n+  int elt;\n+  rtx op0, op1;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  tmode = TYPE_MODE (TREE_TYPE (arg0));\n+  mode1 = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n+  gcc_assert (VECTOR_MODE_P (tmode));\n+\n+  op0 = expand_expr (arg0, NULL_RTX, tmode, 0);\n+  op1 = expand_expr (arg1, NULL_RTX, mode1, 0);\n+  elt = get_element_number (TREE_TYPE (arg0), arg2);\n+\n+  if (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode)\n+    op1 = convert_modes (mode1, GET_MODE (op1), op1, true);\n+\n+  op0 = force_reg (tmode, op0);\n+  op1 = force_reg (mode1, op1);\n+\n+  rs6000_expand_vector_set (op0, op1, elt);\n+\n+  return op0;\n+}\n+\n+/* Expand vec_ext builtin.  */\n+static rtx\n+altivec_expand_vec_ext_builtin (tree arglist, rtx target)\n+{\n+  enum machine_mode tmode, mode0;\n+  tree arg0, arg1;\n+  int elt;\n+  rtx op0;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  elt = get_element_number (TREE_TYPE (arg0), arg1);\n+\n+  tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n+  mode0 = TYPE_MODE (TREE_TYPE (arg0));\n+  gcc_assert (VECTOR_MODE_P (mode0));\n+\n+  op0 = force_reg (mode0, op0);\n+\n+  if (optimize || !target || !register_operand (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  rs6000_expand_vector_extract (target, op0, elt);\n+\n+  return target;\n+}\n+\n /* Expand the builtin in EXP and store the result in TARGET.  Store\n    true in *EXPANDEDP if we found a builtin to expand.  */\n static rtx\n@@ -6994,6 +7267,28 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n \n       emit_insn (gen_altivec_dss (op0));\n       return NULL_RTX;\n+\n+    case ALTIVEC_BUILTIN_VEC_INIT_V4SI:\n+    case ALTIVEC_BUILTIN_VEC_INIT_V8HI:\n+    case ALTIVEC_BUILTIN_VEC_INIT_V16QI:\n+    case ALTIVEC_BUILTIN_VEC_INIT_V4SF:\n+      return altivec_expand_vec_init_builtin (TREE_TYPE (exp), arglist, target);\n+\n+    case ALTIVEC_BUILTIN_VEC_SET_V4SI:\n+    case ALTIVEC_BUILTIN_VEC_SET_V8HI:\n+    case ALTIVEC_BUILTIN_VEC_SET_V16QI:\n+    case ALTIVEC_BUILTIN_VEC_SET_V4SF:\n+      return altivec_expand_vec_set_builtin (arglist);\n+\n+    case ALTIVEC_BUILTIN_VEC_EXT_V4SI:\n+    case ALTIVEC_BUILTIN_VEC_EXT_V8HI:\n+    case ALTIVEC_BUILTIN_VEC_EXT_V16QI:\n+    case ALTIVEC_BUILTIN_VEC_EXT_V4SF:\n+      return altivec_expand_vec_ext_builtin (arglist, target);\n+\n+    default:\n+      break;\n+      /* Fall through.  */\n     }\n \n   /* Expand abs* operations.  */\n@@ -7827,6 +8122,8 @@ altivec_init_builtins (void)\n   struct builtin_description *d;\n   struct builtin_description_predicates *dp;\n   size_t i;\n+  tree ftype;\n+\n   tree pfloat_type_node = build_pointer_type (float_type_node);\n   tree pint_type_node = build_pointer_type (integer_type_node);\n   tree pshort_type_node = build_pointer_type (short_integer_type_node);\n@@ -8092,6 +8389,88 @@ altivec_init_builtins (void)\n       /* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */\n       altivec_builtin_mask_for_load = decl;\n     }\n+\n+  /* Access to the vec_init patterns.  */\n+  ftype = build_function_type_list (V4SI_type_node, integer_type_node,\n+\t\t\t\t    integer_type_node, integer_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_init_v4si\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_INIT_V4SI);\n+\n+  ftype = build_function_type_list (V8HI_type_node, short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    short_integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_init_v8hi\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_INIT_V8HI);\n+\n+  ftype = build_function_type_list (V16QI_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, char_type_node,\n+\t\t\t\t    char_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_init_v16qi\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_INIT_V16QI);\n+\n+  ftype = build_function_type_list (V4SF_type_node, float_type_node,\n+\t\t\t\t    float_type_node, float_type_node,\n+\t\t\t\t    float_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_init_v4sf\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_INIT_V4SF);\n+\n+  /* Access to the vec_set patterns.  */\n+  ftype = build_function_type_list (V4SI_type_node, V4SI_type_node,\n+\t\t\t\t    intSI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_set_v4si\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_SET_V4SI);\n+\n+  ftype = build_function_type_list (V8HI_type_node, V8HI_type_node,\n+\t\t\t\t    intHI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_set_v8hi\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_SET_V8HI);\n+\n+  ftype = build_function_type_list (V8HI_type_node, V16QI_type_node,\n+\t\t\t\t    intQI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_set_v16qi\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_SET_V16QI);\n+\n+  ftype = build_function_type_list (V4SF_type_node, V4SF_type_node,\n+\t\t\t\t    float_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_set_v4sf\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_SET_V4SF);\n+\n+  /* Access to the vec_extract patterns.  */\n+  ftype = build_function_type_list (intSI_type_node, V4SI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_ext_v4si\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_EXT_V4SI);\n+\n+  ftype = build_function_type_list (intHI_type_node, V8HI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_ext_v8hi\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_EXT_V8HI);\n+\n+  ftype = build_function_type_list (intQI_type_node, V16QI_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_ext_v16qi\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_EXT_V16QI);\n+\n+  ftype = build_function_type_list (float_type_node, V4SF_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  def_builtin (MASK_ALTIVEC, \"__builtin_vec_ext_v4sf\", ftype,\n+\t       ALTIVEC_BUILTIN_VEC_EXT_V4SF);\n }\n \n static void"}, {"sha": "17c98c0699a1bf9aa1800b70c715b64abf39ac15", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a4eca6648367a620e21a4a18d0deca5b3f863e0/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=7a4eca6648367a620e21a4a18d0deca5b3f863e0", "patch": "@@ -2490,6 +2490,18 @@ enum rs6000_builtins\n   ALTIVEC_BUILTIN_ABS_V16QI,\n   ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n   ALTIVEC_BUILTIN_MASK_FOR_STORE,\n+  ALTIVEC_BUILTIN_VEC_INIT_V4SI,\n+  ALTIVEC_BUILTIN_VEC_INIT_V8HI,\n+  ALTIVEC_BUILTIN_VEC_INIT_V16QI,\n+  ALTIVEC_BUILTIN_VEC_INIT_V4SF,\n+  ALTIVEC_BUILTIN_VEC_SET_V4SI,\n+  ALTIVEC_BUILTIN_VEC_SET_V8HI,\n+  ALTIVEC_BUILTIN_VEC_SET_V16QI,\n+  ALTIVEC_BUILTIN_VEC_SET_V4SF,\n+  ALTIVEC_BUILTIN_VEC_EXT_V4SI,\n+  ALTIVEC_BUILTIN_VEC_EXT_V8HI,\n+  ALTIVEC_BUILTIN_VEC_EXT_V16QI,\n+  ALTIVEC_BUILTIN_VEC_EXT_V4SF,\n \n   /* Altivec overloaded builtins.  */\n   ALTIVEC_BUILTIN_VCMPEQ_P,"}]}