{"sha": "550dfbdcf6d93d88edd469089be54850e19128e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwZGZiZGNmNmQ5M2Q4OGVkZDQ2OTA4OWJlNTQ4NTBlMTkxMjhlMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-11-29T18:03:18Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-11-29T18:03:18Z"}, "message": "PR c/88091 - c-c++-common/Wconversion-real.c etc. FAIL\n\ngcc/c/ChangeLog:\n\n\tPR c/88091\n\t* c-typeck.c (convert_argument): Add a parameter.  Adjust indentation.\n\t(convert_arguments): Add comments.  Pass additional argument to\n\tthe function above.\n\nFrom-SVN: r266634", "tree": {"sha": "7db866b97f8fea818630811afb4d423cc6d91062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7db866b97f8fea818630811afb4d423cc6d91062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550dfbdcf6d93d88edd469089be54850e19128e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550dfbdcf6d93d88edd469089be54850e19128e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550dfbdcf6d93d88edd469089be54850e19128e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550dfbdcf6d93d88edd469089be54850e19128e1/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "673670da1e5dae2aaccbade88d540cf0200f0eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673670da1e5dae2aaccbade88d540cf0200f0eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673670da1e5dae2aaccbade88d540cf0200f0eb3"}], "stats": {"total": 334, "additions": 178, "deletions": 156}, "files": [{"sha": "c82f47bbab8d29f6ea82626d342afdd92a50dd18", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550dfbdcf6d93d88edd469089be54850e19128e1/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550dfbdcf6d93d88edd469089be54850e19128e1/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=550dfbdcf6d93d88edd469089be54850e19128e1", "patch": "@@ -1,3 +1,10 @@\n+2018-11-29  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88091\n+\t* c-typeck.c (convert_argument): Add a parameter.  Adjust indentation.\n+\t(convert_arguments): Add comments.  Pass additional argument to\n+\tthe function above.\n+\n 2018-11-29  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/88172"}, {"sha": "8fbecfce956c0d55ebe19ccacd50eba17fe9fc26", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 171, "deletions": 156, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550dfbdcf6d93d88edd469089be54850e19128e1/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550dfbdcf6d93d88edd469089be54850e19128e1/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=550dfbdcf6d93d88edd469089be54850e19128e1", "patch": "@@ -3186,182 +3186,187 @@ c_build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n \f\n /* Helper for convert_arguments called to convert the VALue of argument\n    number ARGNUM from ORIGTYPE to the corresponding parameter number\n-   PARMNUL and TYPE.  */\n+   PARMNUM and TYPE.\n+   PLOC is the location where the conversion is being performed.\n+   FUNCTION and FUNDECL are the same as in convert_arguments.\n+   VALTYPE is the original type of VAL before the conversion and,\n+   for EXCESS_PRECISION_EXPR, the operand of the expression.\n+   NPC is true if VAL represents the null pointer constant (VAL itself\n+   will have been folded to an integer constant).\n+   RNAME is the same as FUNCTION except in Objective C when it's\n+   the function selector.\n+   EXCESS_PRECISION is true when VAL was originally represented\n+   as EXCESS_PRECISION_EXPR.\n+   WARNOPT is the same as in convert_for_assignment.  */\n \n static tree\n convert_argument (location_t ploc, tree function, tree fundecl,\n-\t\t  tree type, tree origtype, tree val, bool npc,\n-\t\t  tree rname, int parmnum, int argnum,\n+\t\t  tree type, tree origtype, tree val, tree valtype,\n+\t\t  bool npc, tree rname, int parmnum, int argnum,\n \t\t  bool excess_precision, int warnopt)\n {\n-  tree valtype = TREE_TYPE (val);\n-\n-  tree parmval;\n-\n   /* Formal parm type is specified by a function prototype.  */\n \n   if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n     {\n       error_at (ploc, \"type of formal parameter %d is incomplete\",\n \t\tparmnum + 1);\n-      parmval = val;\n+      return val;\n     }\n-  else\n-    {\n-      /* Optionally warn about conversions that differ from the default\n-\t conversions.  */\n-      if (warn_traditional_conversion || warn_traditional)\n-\t{\n-\t  unsigned int formal_prec = TYPE_PRECISION (type);\n \n-\t  if (INTEGRAL_TYPE_P (type)\n-\t      && TREE_CODE (valtype) == REAL_TYPE)\n-\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\"passing argument %d of %qE as integer rather \"\n-\t\t\t\"than floating due to prototype\",\n+  /* Optionally warn about conversions that differ from the default\n+     conversions.  */\n+  if (warn_traditional_conversion || warn_traditional)\n+    {\n+      unsigned int formal_prec = TYPE_PRECISION (type);\n+\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && TREE_CODE (valtype) == REAL_TYPE)\n+\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t    \"passing argument %d of %qE as integer rather \"\n+\t\t    \"than floating due to prototype\",\n+\t\t    argnum, rname);\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && TREE_CODE (valtype) == COMPLEX_TYPE)\n+\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t    \"passing argument %d of %qE as integer rather \"\n+\t\t    \"than complex due to prototype\",\n+\t\t    argnum, rname);\n+      else if (TREE_CODE (type) == COMPLEX_TYPE\n+\t       && TREE_CODE (valtype) == REAL_TYPE)\n+\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t    \"passing argument %d of %qE as complex rather \"\n+\t\t    \"than floating due to prototype\",\n+\t\t    argnum, rname);\n+      else if (TREE_CODE (type) == REAL_TYPE\n+\t       && INTEGRAL_TYPE_P (valtype))\n+\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t    \"passing argument %d of %qE as floating rather \"\n+\t\t    \"than integer due to prototype\",\n+\t\t    argnum, rname);\n+      else if (TREE_CODE (type) == COMPLEX_TYPE\n+\t       && INTEGRAL_TYPE_P (valtype))\n+\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t    \"passing argument %d of %qE as complex rather \"\n+\t\t    \"than integer due to prototype\",\n+\t\t    argnum, rname);\n+      else if (TREE_CODE (type) == REAL_TYPE\n+\t       && TREE_CODE (valtype) == COMPLEX_TYPE)\n+\twarning_at (ploc, OPT_Wtraditional_conversion,\n+\t\t    \"passing argument %d of %qE as floating rather \"\n+\t\t    \"than complex due to prototype\",\n+\t\t    argnum, rname);\n+      /* ??? At some point, messages should be written about\n+\t conversions between complex types, but that's too messy\n+\t to do now.  */\n+      else if (TREE_CODE (type) == REAL_TYPE\n+\t       && TREE_CODE (valtype) == REAL_TYPE)\n+\t{\n+\t  /* Warn if any argument is passed as `float',\n+\t     since without a prototype it would be `double'.  */\n+\t  if (formal_prec == TYPE_PRECISION (float_type_node)\n+\t      && type != dfloat32_type_node)\n+\t    warning_at (ploc, 0,\n+\t\t\t\"passing argument %d of %qE as %<float%> \"\n+\t\t\t\"rather than %<double%> due to prototype\",\n \t\t\targnum, rname);\n-\t  if (INTEGRAL_TYPE_P (type)\n-\t      && TREE_CODE (valtype) == COMPLEX_TYPE)\n-\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\"passing argument %d of %qE as integer rather \"\n-\t\t\t\"than complex due to prototype\",\n-\t\t\targnum, rname);\n-\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n-\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n-\t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\"passing argument %d of %qE as complex rather \"\n-\t\t\t\"than floating due to prototype\",\n-\t\t\targnum, rname);\n-\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t   && INTEGRAL_TYPE_P (valtype))\n+\n+\t  /* Warn if mismatch between argument and prototype\n+\t     for decimal float types.  Warn of conversions with\n+\t     binary float types and of precision narrowing due to\n+\t     prototype.  */\n+\t  else if (type != valtype\n+\t\t   && (type == dfloat32_type_node\n+\t\t       || type == dfloat64_type_node\n+\t\t       || type == dfloat128_type_node\n+\t\t       || valtype == dfloat32_type_node\n+\t\t       || valtype == dfloat64_type_node\n+\t\t       || valtype == dfloat128_type_node)\n+\t\t   && (formal_prec\n+\t\t       <= TYPE_PRECISION (valtype)\n+\t\t       || (type == dfloat128_type_node\n+\t\t\t   && (valtype\n+\t\t\t       != dfloat64_type_node\n+\t\t\t       && (valtype\n+\t\t\t\t   != dfloat32_type_node)))\n+\t\t       || (type == dfloat64_type_node\n+\t\t\t   && (valtype\n+\t\t\t       != dfloat32_type_node))))\n+\t    warning_at (ploc, 0,\n+\t\t\t\"passing argument %d of %qE as %qT \"\n+\t\t\t\"rather than %qT due to prototype\",\n+\t\t\targnum, rname, type, valtype);\n+\n+\t}\n+      /* Detect integer changing in width or signedness.\n+\t These warnings are only activated with\n+\t -Wtraditional-conversion, not with -Wtraditional.  */\n+      else if (warn_traditional_conversion\n+\t       && INTEGRAL_TYPE_P (type)\n+\t       && INTEGRAL_TYPE_P (valtype))\n+\t{\n+\t  tree would_have_been = default_conversion (val);\n+\t  tree type1 = TREE_TYPE (would_have_been);\n+\n+\t  if (val == error_mark_node)\n+\t    /* VAL could have been of incomplete type.  */;\n+\t  else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t\t   && (TYPE_MAIN_VARIANT (type)\n+\t\t       == TYPE_MAIN_VARIANT (valtype)))\n+\t    /* No warning if function asks for enum\n+\t       and the actual arg is that enum type.  */\n+\t    ;\n+\t  else if (formal_prec != TYPE_PRECISION (type1))\n \t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\"passing argument %d of %qE as floating rather \"\n-\t\t\t\"than integer due to prototype\",\n+\t\t\t\"passing argument %d of %qE \"\n+\t\t\t\"with different width due to prototype\",\n \t\t\targnum, rname);\n-\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n-\t\t   && INTEGRAL_TYPE_P (valtype))\n+\t  else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n+\t    ;\n+\t  /* Don't complain if the formal parameter type\n+\t     is an enum, because we can't tell now whether\n+\t     the value was an enum--even the same enum.  */\n+\t  else if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t    ;\n+\t  else if (TREE_CODE (val) == INTEGER_CST\n+\t\t   && int_fits_type_p (val, type))\n+\t    /* Change in signedness doesn't matter\n+\t       if a constant value is unaffected.  */\n+\t    ;\n+\t  /* If the value is extended from a narrower\n+\t     unsigned type, it doesn't matter whether we\n+\t     pass it as signed or unsigned; the value\n+\t     certainly is the same either way.  */\n+\t  else if (TYPE_PRECISION (valtype) < TYPE_PRECISION (type)\n+\t\t   && TYPE_UNSIGNED (valtype))\n+\t    ;\n+\t  else if (TYPE_UNSIGNED (type))\n \t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\"passing argument %d of %qE as complex rather \"\n-\t\t\t\"than integer due to prototype\",\n+\t\t\t\"passing argument %d of %qE \"\n+\t\t\t\"as unsigned due to prototype\",\n \t\t\targnum, rname);\n-\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t   && TREE_CODE (valtype) == COMPLEX_TYPE)\n+\t  else\n \t    warning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t\"passing argument %d of %qE as floating rather \"\n-\t\t\t\"than complex due to prototype\",\n+\t\t\t\"passing argument %d of %qE \"\n+\t\t\t\"as signed due to prototype\",\n \t\t\targnum, rname);\n-\t  /* ??? At some point, messages should be written about\n-\t     conversions between complex types, but that's too messy\n-\t     to do now.  */\n-\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n-\t    {\n-\t      /* Warn if any argument is passed as `float',\n-\t\t since without a prototype it would be `double'.  */\n-\t      if (formal_prec == TYPE_PRECISION (float_type_node)\n-\t\t  && type != dfloat32_type_node)\n-\t\twarning_at (ploc, 0,\n-\t\t\t    \"passing argument %d of %qE as %<float%> \"\n-\t\t\t    \"rather than %<double%> due to prototype\",\n-\t\t\t    argnum, rname);\n-\n-\t      /* Warn if mismatch between argument and prototype\n-\t\t for decimal float types.  Warn of conversions with\n-\t\t binary float types and of precision narrowing due to\n-\t\t prototype.  */\n-\t      else if (type != valtype\n-\t\t       && (type == dfloat32_type_node\n-\t\t\t   || type == dfloat64_type_node\n-\t\t\t   || type == dfloat128_type_node\n-\t\t\t   || valtype == dfloat32_type_node\n-\t\t\t   || valtype == dfloat64_type_node\n-\t\t\t   || valtype == dfloat128_type_node)\n-\t\t       && (formal_prec\n-\t\t\t   <= TYPE_PRECISION (valtype)\n-\t\t\t   || (type == dfloat128_type_node\n-\t\t\t       && (valtype\n-\t\t\t\t   != dfloat64_type_node\n-\t\t\t\t   && (valtype\n-\t\t\t\t       != dfloat32_type_node)))\n-\t\t\t   || (type == dfloat64_type_node\n-\t\t\t       && (valtype\n-\t\t\t\t   != dfloat32_type_node))))\n-\t\twarning_at (ploc, 0,\n-\t\t\t    \"passing argument %d of %qE as %qT \"\n-\t\t\t    \"rather than %qT due to prototype\",\n-\t\t\t    argnum, rname, type, valtype);\n-\n-\t    }\n-\t  /* Detect integer changing in width or signedness.\n-\t     These warnings are only activated with\n-\t     -Wtraditional-conversion, not with -Wtraditional.  */\n-\t  else if (warn_traditional_conversion\n-\t\t   && INTEGRAL_TYPE_P (type)\n-\t\t   && INTEGRAL_TYPE_P (valtype))\n-\t    {\n-\t      tree would_have_been = default_conversion (val);\n-\t      tree type1 = TREE_TYPE (would_have_been);\n-\n-\t      if (val == error_mark_node)\n-\t\t/* VAL could have been of incomplete type.  */;\n-\t      else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t\t       && (TYPE_MAIN_VARIANT (type)\n-\t\t\t   == TYPE_MAIN_VARIANT (valtype)))\n-\t\t/* No warning if function asks for enum\n-\t\t   and the actual arg is that enum type.  */\n-\t\t;\n-\t      else if (formal_prec != TYPE_PRECISION (type1))\n-\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t    \"passing argument %d of %qE \"\n-\t\t\t    \"with different width due to prototype\",\n-\t\t\t    argnum, rname);\n-\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n-\t\t;\n-\t      /* Don't complain if the formal parameter type\n-\t\t is an enum, because we can't tell now whether\n-\t\t the value was an enum--even the same enum.  */\n-\t      else if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t;\n-\t      else if (TREE_CODE (val) == INTEGER_CST\n-\t\t       && int_fits_type_p (val, type))\n-\t\t/* Change in signedness doesn't matter\n-\t\t   if a constant value is unaffected.  */\n-\t\t;\n-\t      /* If the value is extended from a narrower\n-\t\t unsigned type, it doesn't matter whether we\n-\t\t pass it as signed or unsigned; the value\n-\t\t certainly is the same either way.  */\n-\t      else if (TYPE_PRECISION (valtype) < TYPE_PRECISION (type)\n-\t\t       && TYPE_UNSIGNED (valtype))\n-\t\t;\n-\t      else if (TYPE_UNSIGNED (type))\n-\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t    \"passing argument %d of %qE \"\n-\t\t\t    \"as unsigned due to prototype\",\n-\t\t\t    argnum, rname);\n-\t      else\n-\t\twarning_at (ploc, OPT_Wtraditional_conversion,\n-\t\t\t    \"passing argument %d of %qE \"\n-\t\t\t    \"as signed due to prototype\",\n-\t\t\t    argnum, rname);\n-\t    }\n \t}\n+    }\n \n-      /* Possibly restore an EXCESS_PRECISION_EXPR for the\n-\t sake of better warnings from convert_and_check.  */\n-      if (excess_precision)\n-\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n+  /* Possibly restore an EXCESS_PRECISION_EXPR for the\n+     sake of better warnings from convert_and_check.  */\n+  if (excess_precision)\n+    val = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n \n-      parmval = convert_for_assignment (ploc, ploc, type,\n-\t\t\t\t\tval, origtype, ic_argpass,\n-\t\t\t\t\tnpc, fundecl, function,\n-\t\t\t\t\tparmnum + 1, warnopt);\n+  tree parmval = convert_for_assignment (ploc, ploc, type,\n+\t\t\t\t\t val, origtype, ic_argpass,\n+\t\t\t\t\t npc, fundecl, function,\n+\t\t\t\t\t parmnum + 1, warnopt);\n \n-      if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n-\t  && INTEGRAL_TYPE_P (type)\n-\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\tparmval = default_conversion (parmval);\n-    }\n+  if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n+      && INTEGRAL_TYPE_P (type)\n+      && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+    parmval = default_conversion (parmval);\n \n   return parmval;\n }\n@@ -3457,8 +3462,8 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t  }\n     }\n \n-  /* Scan the given expressions and types, producing individual\n-     converted arguments.  */\n+  /* Scan the given expressions (VALUES) and types (TYPELIST), producing\n+     individual converted arguments.  */\n \n   tree typetail, builtin_typetail, val;\n   for (typetail = typelist,\n@@ -3467,14 +3472,23 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n        values && values->iterate (parmnum, &val);\n        ++parmnum)\n     {\n+      /* The type of the function parameter (if it was declared with one).  */\n       tree type = typetail ? TREE_VALUE (typetail) : NULL_TREE;\n+      /* The type of the built-in function parameter (if the function\n+\t is a built-in).  Used to detect type incompatibilities in\n+\t calls to built-ins declared without a prototype.  */\n       tree builtin_type = (builtin_typetail\n \t\t\t   ? TREE_VALUE (builtin_typetail) : NULL_TREE);\n+      /* The original type of the argument being passed to the function.  */\n       tree valtype = TREE_TYPE (val);\n+      /* The called function (or function selector in Objective C).  */\n       tree rname = function;\n       int argnum = parmnum + 1;\n       const char *invalid_func_diag;\n+      /* Set for EXCESS_PRECISION_EXPR arguments.  */\n       bool excess_precision = false;\n+      /* The value of the argument after conversion to the type\n+\t of the function parameter it is passed to.  */\n       tree parmval;\n       /* Some __atomic_* builtins have additional hidden argument at\n \t position 0.  */\n@@ -3558,7 +3572,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t{\n \t  tree origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n \t  parmval = convert_argument (ploc, function, fundecl, type, origtype,\n-\t\t\t\t      val, npc, rname, parmnum, argnum,\n+\t\t\t\t      val, valtype, npc, rname, parmnum, argnum,\n \t\t\t\t      excess_precision, 0);\n \t}\n       else if (promote_float_arg)\n@@ -3610,7 +3624,8 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t     above by applying default conversions instead.  */\n \t  tree origtype = (!origtypes) ? NULL_TREE : (*origtypes)[parmnum];\n \t  convert_argument (ploc, function, fundecl, builtin_type, origtype,\n-\t\t\t    val, npc, rname, parmnum, argnum, excess_precision,\n+\t\t\t    val, valtype, npc, rname, parmnum, argnum,\n+\t\t\t    excess_precision,\n \t\t\t    OPT_Wbuiltin_declaration_mismatch);\n \t}\n "}]}