{"sha": "ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2OGI1Y2ZiOWQxMmNiNTUzNDViZDI2ZWU5MTE0YWVlOTI1ZDQ2YQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-11-10T09:35:11Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-11-10T09:35:11Z"}, "message": "[optabs][ifcvt][1/3] Define negcc, notcc optabs\n\n\t* ifcvt.c (noce_try_inverse_constants): New function.\n\t(noce_process_if_block): Call it.\n\t* optabs.h (emit_conditional_neg_or_complement): Declare prototype.\n\t* optabs.def (negcc_optab, notcc_optab): Declare.\n\t* optabs.c (emit_conditional_neg_or_complement): New function.\n\t* doc/tm.texi (Standard Names): Document negcc, notcc names.\n\nFrom-SVN: r230089", "tree": {"sha": "f7660813bbcbf78ce1bf2c64cd6933e5e449b3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7660813bbcbf78ce1bf2c64cd6933e5e449b3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df554b0e49e59c974e45ab21a3a2b4295ce348b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df554b0e49e59c974e45ab21a3a2b4295ce348b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df554b0e49e59c974e45ab21a3a2b4295ce348b2"}], "stats": {"total": 159, "additions": 159, "deletions": 0}, "files": [{"sha": "2fe062aeb459e6ed3e001099e747f7e1300095a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "patch": "@@ -1,3 +1,12 @@\n+2015-11-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* ifcvt.c (noce_try_inverse_constants): New function.\n+\t(noce_process_if_block): Call it.\n+\t* optabs.h (emit_conditional_neg_or_complement): Declare prototype.\n+\t* optabs.def (negcc_optab, notcc_optab): Declare.\n+\t* optabs.c (emit_conditional_neg_or_complement): New function.\n+\t* doc/tm.texi (Standard Names): Document negcc, notcc names.\n+\n 2015-11-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/68236"}, {"sha": "71a2791a60239b2acfd3f77707e7a9627d4e2ba2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "patch": "@@ -5805,6 +5805,21 @@ move operand 2 or (operands 2 + operand 3) into operand 0 according to the\n comparison in operand 1.  If the comparison is false, operand 2 is moved into\n operand 0, otherwise (operand 2 + operand 3) is moved.\n \n+@cindex @code{neg@var{mode}cc} instruction pattern\n+@item @samp{neg@var{mode}cc}\n+Similar to @samp{mov@var{mode}cc} but for conditional negation.  Conditionally\n+move the negation of operand 2 or the unchanged operand 3 into operand 0\n+according to the comparison in operand 1.  If the comparison is true, the negation\n+of operand 2 is moved into operand 0, otherwise operand 3 is moved.\n+\n+@cindex @code{not@var{mode}cc} instruction pattern\n+@item @samp{not@var{mode}cc}\n+Similar to @samp{neg@var{mode}cc} but for conditional complement.\n+Conditionally move the bitwise complement of operand 2 or the unchanged\n+operand 3 into operand 0 according to the comparison in operand 1.\n+If the comparison is true, the complement of operand 2 is moved into\n+operand 0, otherwise operand 3 is moved.\n+\n @cindex @code{cstore@var{mode}4} instruction pattern\n @item @samp{cstore@var{mode}4}\n Store zero or nonzero in operand 0 according to whether a comparison"}, {"sha": "56e4ed425764da31d8b8bca6840278c4504fc3b6", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "patch": "@@ -1168,6 +1168,83 @@ noce_try_store_flag (struct noce_if_info *if_info)\n     }\n }\n \n+\n+/* Convert \"if (test) x = -A; else x = A\" into\n+   x = A; if (test) x = -x if the machine can do the\n+   conditional negate form of this cheaply.\n+   Try this before noce_try_cmove that will just load the\n+   immediates into two registers and do a conditional select\n+   between them.  If the target has a conditional negate or\n+   conditional invert operation we can save a potentially\n+   expensive constant synthesis.  */\n+\n+static bool\n+noce_try_inverse_constants (struct noce_if_info *if_info)\n+{\n+  if (!noce_simple_bbs (if_info))\n+    return false;\n+\n+  if (!CONST_INT_P (if_info->a)\n+      || !CONST_INT_P (if_info->b)\n+      || !REG_P (if_info->x))\n+    return false;\n+\n+  machine_mode mode = GET_MODE (if_info->x);\n+\n+  HOST_WIDE_INT val_a = INTVAL (if_info->a);\n+  HOST_WIDE_INT val_b = INTVAL (if_info->b);\n+\n+  rtx cond = if_info->cond;\n+\n+  rtx x = if_info->x;\n+  rtx target;\n+\n+  start_sequence ();\n+\n+  rtx_code code;\n+  if (val_b != HOST_WIDE_INT_MIN && val_a == -val_b)\n+    code = NEG;\n+  else if (val_a == ~val_b)\n+    code = NOT;\n+  else\n+    {\n+      end_sequence ();\n+      return false;\n+    }\n+\n+  rtx tmp = gen_reg_rtx (mode);\n+  noce_emit_move_insn (tmp, if_info->a);\n+\n+  target = emit_conditional_neg_or_complement (x, code, mode, cond, tmp, tmp);\n+\n+  if (target)\n+    {\n+      rtx_insn *seq = get_insns ();\n+\n+      if (!seq)\n+\t{\n+\t  end_sequence ();\n+\t  return false;\n+\t}\n+\n+      if (target != if_info->x)\n+\tnoce_emit_move_insn (if_info->x, target);\n+\n+\tseq = end_ifcvt_sequence (if_info);\n+\n+\tif (!seq)\n+\t  return false;\n+\n+\temit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t\t INSN_LOCATION (if_info->insn_a));\n+\treturn true;\n+    }\n+\n+  end_sequence ();\n+  return false;\n+}\n+\n+\n /* Convert \"if (test) x = a; else x = b\", for A and B constant.\n    Also allow A = y + c1, B = y + c2, with a common y between A\n    and B.  */\n@@ -3497,6 +3574,8 @@ noce_process_if_block (struct noce_if_info *if_info)\n     goto success;\n   if (noce_try_abs (if_info))\n     goto success;\n+  if (noce_try_inverse_constants (if_info))\n+    goto success;\n   if (!targetm.have_conditional_execution ()\n       && noce_try_store_flag_constants (if_info))\n     goto success;"}, {"sha": "1e328a66f9173cd2e0109e827f7c9072f68958ab", "filename": "gcc/optabs.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "patch": "@@ -4210,6 +4210,56 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   return NULL_RTX;\n }\n \n+\n+/* Emit a conditional negate or bitwise complement using the\n+   negcc or notcc optabs if available.  Return NULL_RTX if such operations\n+   are not available.  Otherwise return the RTX holding the result.\n+   TARGET is the desired destination of the result.  COMP is the comparison\n+   on which to negate.  If COND is true move into TARGET the negation\n+   or bitwise complement of OP1.  Otherwise move OP2 into TARGET.\n+   CODE is either NEG or NOT.  MODE is the machine mode in which the\n+   operation is performed.  */\n+\n+rtx\n+emit_conditional_neg_or_complement (rtx target, rtx_code code,\n+\t\t\t\t     machine_mode mode, rtx cond, rtx op1,\n+\t\t\t\t     rtx op2)\n+{\n+  optab op = unknown_optab;\n+  if (code == NEG)\n+    op = negcc_optab;\n+  else if (code == NOT)\n+    op = notcc_optab;\n+  else\n+    gcc_unreachable ();\n+\n+  insn_code icode = direct_optab_handler (op, mode);\n+\n+  if (icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n+\n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+\n+  rtx_insn *last = get_last_insn ();\n+  struct expand_operand ops[4];\n+\n+  create_output_operand (&ops[0], target, mode);\n+  create_fixed_operand (&ops[1], cond);\n+  create_input_operand (&ops[2], op1, mode);\n+  create_input_operand (&ops[3], op2, mode);\n+\n+  if (maybe_expand_insn (icode, 4, ops))\n+    {\n+      if (ops[0].value != target)\n+\tconvert_move (target, ops[0].value, false);\n+\n+      return target;\n+    }\n+  delete_insns_since (last);\n+  return NULL_RTX;\n+}\n+\n /* Emit a conditional addition instruction if the machine supports one for that\n    condition and machine mode.\n "}, {"sha": "6fad6d9711e6e0b901b253c851a45ee352a86c00", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "patch": "@@ -183,6 +183,8 @@ OPTAB_D (reload_out_optab, \"reload_out$a\")\n \n OPTAB_DC(cbranch_optab, \"cbranch$a4\", COMPARE)\n OPTAB_D (addcc_optab, \"add$acc\")\n+OPTAB_D (negcc_optab, \"neg$acc\")\n+OPTAB_D (notcc_optab, \"not$acc\")\n OPTAB_D (movcc_optab, \"mov$acc\")\n OPTAB_D (cmov_optab, \"cmov$a6\")\n OPTAB_D (cstore_optab, \"cstore$a4\")"}, {"sha": "5e6fe11ff00996e6aee68bf06a7f15bc2a167e43", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce68b5cfb9d12cb55345bd26ee9114aee925d46a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=ce68b5cfb9d12cb55345bd26ee9114aee925d46a", "patch": "@@ -259,6 +259,10 @@ extern void emit_indirect_jump (rtx);\n rtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, machine_mode,\n \t\t\t   rtx, rtx, machine_mode, int);\n \n+/* Emit a conditional negate or bitwise complement operation.  */\n+rtx emit_conditional_neg_or_complement (rtx, rtx_code, machine_mode, rtx,\n+\t\t\t\t\t rtx, rtx);\n+\n rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, machine_mode,\n \t\t\t  rtx, rtx, machine_mode, int);\n "}]}