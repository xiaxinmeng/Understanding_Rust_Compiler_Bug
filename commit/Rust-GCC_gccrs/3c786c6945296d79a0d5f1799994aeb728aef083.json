{"sha": "3c786c6945296d79a0d5f1799994aeb728aef083", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M3ODZjNjk0NTI5NmQ3OWEwZDVmMTc5OTk5NGFlYjcyOGFlZjA4Mw==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-09-01T22:09:55Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-09-01T22:09:55Z"}, "message": "c-common.h (enum c_tree_index): Add CTI_C_SIZE_TYPE.\n\n\t* c-common.h (enum c_tree_index): Add CTI_C_SIZE_TYPE.\n\t(c_size_type_node): Define.\n\t* c-decl.c (init_decl_processing): Initialize c_size_type_node.\n\t* c-common.c (enum format_lengths, enum format_std_version,\n\tformat_length_info, format_type_detail, BADLEN, NOLENGTHS,\n\tformat_kind_info, printf_length_specs, scanf_length_specs, T89_I,\n\tT99_I, T89_L, T99_LL, TEX_LL, T89_S, T89_UI, T99_UI, T89_UL,\n\tT99_ULL, TEX_ULL, T89_US, T89_F, T99_F, T89_D, T99_D, T89_LD,\n\tT99_LD, T89_C, T99_SC, T99_UC, T89_V, T94_W, TEX_W, T94_WI,\n\tTEX_WI, T99_ST, T99_SST, T99_PD, T99_UPD, T99_IM, T99_UIM,\n\tformat_types): Define.\n\t(format_char_info, print_char_table, scan_char_table,\n\ttime_char_table): Rearrange for new organization of information\n\tabout format length modifiers and standard versions.\n\t(T_ST): Redefine to use c_size_type_node.\n\t(check_format_info): Obtain information about length modifiers and\n\tstandard versions from tables.  Adjust warning message wordings.\n\tUse the name from the user's program for `ll' and `hh' length\n\tmodifiers in warning messages.  Use more informative names for\n\twanted types where available (for wchar_t, wint_t, size_t, signed\n\tsize_t, ptrdiff_t, unsigned ptrdiff_t, intmax_t and uintmax_t).\n\ntestsuite:\n\t* gcc.dg/format-diag-1.c: New test.\n\nFrom-SVN: r36106", "tree": {"sha": "90f159e42be0a2896231846a7d740d3767007896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90f159e42be0a2896231846a7d740d3767007896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c786c6945296d79a0d5f1799994aeb728aef083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c786c6945296d79a0d5f1799994aeb728aef083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c786c6945296d79a0d5f1799994aeb728aef083", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c786c6945296d79a0d5f1799994aeb728aef083/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0435a3f8cab27de41051b3a9e0fe9fa110db6c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435a3f8cab27de41051b3a9e0fe9fa110db6c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0435a3f8cab27de41051b3a9e0fe9fa110db6c5d"}], "stats": {"total": 557, "additions": 359, "deletions": 198}, "files": [{"sha": "52204553f1cafe005ecf528fe0cbc026a43bc752", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c786c6945296d79a0d5f1799994aeb728aef083", "patch": "@@ -1,3 +1,27 @@\n+2000-09-01  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.h (enum c_tree_index): Add CTI_C_SIZE_TYPE.\n+\t(c_size_type_node): Define.\n+\t* c-decl.c (init_decl_processing): Initialize c_size_type_node.\n+\t* c-common.c (enum format_lengths, enum format_std_version,\n+\tformat_length_info, format_type_detail, BADLEN, NOLENGTHS,\n+\tformat_kind_info, printf_length_specs, scanf_length_specs, T89_I,\n+\tT99_I, T89_L, T99_LL, TEX_LL, T89_S, T89_UI, T99_UI, T89_UL,\n+\tT99_ULL, TEX_ULL, T89_US, T89_F, T99_F, T89_D, T99_D, T89_LD,\n+\tT99_LD, T89_C, T99_SC, T99_UC, T89_V, T94_W, TEX_W, T94_WI,\n+\tTEX_WI, T99_ST, T99_SST, T99_PD, T99_UPD, T99_IM, T99_UIM,\n+\tformat_types): Define.\n+\t(format_char_info, print_char_table, scan_char_table,\n+\ttime_char_table): Rearrange for new organization of information\n+\tabout format length modifiers and standard versions.\n+\t(T_ST): Redefine to use c_size_type_node.\n+\t(check_format_info): Obtain information about length modifiers and\n+\tstandard versions from tables.  Adjust warning message wordings.\n+\tUse the name from the user's program for `ll' and `hh' length\n+\tmodifiers in warning messages.  Use more informative names for\n+\twanted types where available (for wchar_t, wint_t, size_t, signed\n+\tsize_t, ptrdiff_t, unsigned ptrdiff_t, intmax_t and uintmax_t).\n+\n 2000-09-01  Jim Wilson  <wilson@cygnus.com>\n \n \t* loop.c (check_final_value): Check for biv use before checking for"}, {"sha": "9c6564721b363ec478aaa220c17c7cf49c7aadb8", "filename": "gcc/c-common.c", "status": "modified", "additions": 310, "deletions": 198, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3c786c6945296d79a0d5f1799994aeb728aef083", "patch": "@@ -1191,128 +1191,268 @@ strip_attrs (specs_attrs)\n /* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against\n    a parameter list.  */\n \n+/* The meaningfully distinct length modifiers for format checking recognised\n+   by GCC.  */\n+enum format_lengths\n+{\n+  FMT_LEN_none,\n+  FMT_LEN_hh,\n+  FMT_LEN_h,\n+  FMT_LEN_l,\n+  FMT_LEN_ll,\n+  FMT_LEN_L,\n+  FMT_LEN_z,\n+  FMT_LEN_t,\n+  FMT_LEN_j,\n+  FMT_LEN_MAX\n+};\n+\n+\n+/* The standard versions in which various format features appeared.  */\n+enum format_std_version\n+{\n+  STD_C89,\n+  STD_C94,\n+  STD_C99,\n+  STD_EXT\n+};\n+\n+\n+/* Structure describing a length modifier supported in format checking, and\n+   possibly a doubled version such as \"hh\".  */\n+typedef struct\n+{\n+  /* Name of the single-character length modifier.  */\n+  const char *name;\n+  /* Index into a format_char_info.types array.  */\n+  enum format_lengths index;\n+  /* Standard version this length appears in.  */\n+  enum format_std_version std;\n+  /* Same, if the modifier can be repeated, or NULL if it can't.  */\n+  const char *double_name;\n+  enum format_lengths double_index;\n+  enum format_std_version double_std;\n+} format_length_info;\n+\n+\n+/* Structure desribing the combination of a conversion specifier\n+   (or a set of specifiers which act identically) and a length modifier.  */\n+typedef struct\n+{\n+  /* The standard version this combination of length and type appeared in.\n+     This is only relevant if greater than those for length and type\n+     individually; otherwise it is ignored.  */\n+  enum format_std_version std;\n+  /* The name to use for the type, if different from that generated internally\n+     (e.g., \"signed size_t\").  */\n+  const char *name;\n+  /* The type itself.  */\n+  tree *type;\n+} format_type_detail;\n+\n+\n+/* Macros to fill out tables of these.  */\n+#define BADLEN\t{ 0, NULL, NULL }\n+#define NOLENGTHS\t{ BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN, BADLEN }\n+\n+\n+/* Structure desribing a format conversion specifier (or a set of specifiers\n+   which act identically), and the length modifiers used with it.  */\n+typedef struct\n+{\n+  const char *format_chars;\n+  int pointer_count;\n+  enum format_std_version std;\n+  /* Types accepted for each length modifier.  */\n+  format_type_detail types[FMT_LEN_MAX];\n+  /* List of other modifier characters allowed with these options.\n+     This lists flags, and additionally \"w\" for width, \"p\" for precision,\n+     \"c\" for generic character pointers being allowed, \"a\" for scanf\n+     \"a\" allocation extension (not applicable in C99 mode), \"*\" for\n+     scanf suppression, \"2\" for strftime two digit year formats, \"3\"\n+     for strftime formats giving two digit years in some locales, \"E\"\n+     and \"O\" for those strftime modifiers, and \"o\" if use of strftime \"O\"\n+     is a GNU extension beyond C99.  */\n+  const char *flag_chars;\n+} format_char_info;\n+\n+\n+/* Structure describing a particular kind of format processed by GCC.  */\n+typedef struct\n+{\n+  /* The name of this kind of format, for use in diagnostics.  */\n+  const char *name;\n+  /* Specifications of the length modifiers accepted; possibly NULL.  */\n+  const format_length_info *length_char_specs;\n+  /* Details of the conversion specification characters accepted.  */\n+  const format_char_info *conversion_specs;\n+} format_kind_info;\n+\n+\n+static const format_length_info printf_length_specs[] =\n+{\n+  { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C99 },\n+  { \"q\", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },\n+  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n+  { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n+  { \"Z\", FMT_LEN_z, STD_EXT, NULL, 0, 0 },\n+  { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n+  { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+\n+/* This differs from printf_length_specs only in that \"Z\" is not accepted.  */\n+static const format_length_info scanf_length_specs[] =\n+{\n+  { \"h\", FMT_LEN_h, STD_C89, \"hh\", FMT_LEN_hh, STD_C99 },\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C99 },\n+  { \"q\", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },\n+  { \"L\", FMT_LEN_L, STD_C89, NULL, 0, 0 },\n+  { \"z\", FMT_LEN_z, STD_C99, NULL, 0, 0 },\n+  { \"t\", FMT_LEN_t, STD_C99, NULL, 0, 0 },\n+  { \"j\", FMT_LEN_j, STD_C99, NULL, 0, 0 },\n+  { NULL, 0, 0, NULL, 0, 0 }\n+};\n+\n+\n #define T_I\t&integer_type_node\n+#define T89_I\t{ STD_C89, NULL, T_I }\n+#define T99_I\t{ STD_C99, NULL, T_I }\n #define T_L\t&long_integer_type_node\n+#define T89_L\t{ STD_C89, NULL, T_L }\n #define T_LL\t&long_long_integer_type_node\n+#define T99_LL\t{ STD_C99, NULL, T_LL }\n+#define TEX_LL\t{ STD_EXT, NULL, T_LL }\n #define T_S\t&short_integer_type_node\n+#define T89_S\t{ STD_C89, NULL, T_S }\n #define T_UI\t&unsigned_type_node\n+#define T89_UI\t{ STD_C89, NULL, T_UI }\n+#define T99_UI\t{ STD_C99, NULL, T_UI }\n #define T_UL\t&long_unsigned_type_node\n+#define T89_UL\t{ STD_C89, NULL, T_UL }\n #define T_ULL\t&long_long_unsigned_type_node\n+#define T99_ULL\t{ STD_C99, NULL, T_ULL }\n+#define TEX_ULL\t{ STD_EXT, NULL, T_ULL }\n #define T_US\t&short_unsigned_type_node\n+#define T89_US\t{ STD_C89, NULL, T_US }\n #define T_F\t&float_type_node\n+#define T89_F\t{ STD_C89, NULL, T_F }\n+#define T99_F\t{ STD_C99, NULL, T_F }\n #define T_D\t&double_type_node\n+#define T89_D\t{ STD_C89, NULL, T_D }\n+#define T99_D\t{ STD_C99, NULL, T_D }\n #define T_LD\t&long_double_type_node\n+#define T89_LD\t{ STD_C89, NULL, T_LD }\n+#define T99_LD\t{ STD_C99, NULL, T_LD }\n #define T_C\t&char_type_node\n+#define T89_C\t{ STD_C89, NULL, T_C }\n #define T_SC\t&signed_char_type_node\n+#define T99_SC\t{ STD_C99, NULL, T_SC }\n #define T_UC\t&unsigned_char_type_node\n+#define T99_UC\t{ STD_C99, NULL, T_UC }\n #define T_V\t&void_type_node\n+#define T89_V\t{ STD_C89, NULL, T_V }\n #define T_W\t&wchar_type_node\n+#define T94_W\t{ STD_C94, \"wchar_t\", T_W }\n+#define TEX_W\t{ STD_EXT, \"wchar_t\", T_W }\n #define T_WI\t&wint_type_node\n-#define T_ST    &sizetype\n+#define T94_WI\t{ STD_C94, \"wint_t\", T_WI }\n+#define TEX_WI\t{ STD_EXT, \"wint_t\", T_WI }\n+#define T_ST    &c_size_type_node\n+#define T99_ST\t{ STD_C99, \"size_t\", T_ST }\n #define T_SST   &signed_size_type_node\n+#define T99_SST\t{ STD_C99, \"signed size_t\", T_SST }\n #define T_PD    &ptrdiff_type_node\n+#define T99_PD\t{ STD_C99, \"ptrdiff_t\", T_PD }\n #define T_UPD   &unsigned_ptrdiff_type_node\n+#define T99_UPD\t{ STD_C99, \"unsigned ptrdiff_t\", T_UPD }\n #define T_IM    NULL /* intmax_t not yet implemented.  */\n+#define T99_IM\t{ STD_C99, \"intmax_t\", T_IM }\n #define T_UIM   NULL /* uintmax_t not yet implemented.  */\n+#define T99_UIM\t{ STD_C99, \"uintmax_t\", T_UIM }\n \n-typedef struct {\n-  const char *format_chars;\n-  int pointer_count;\n-  /* Type of argument if no length modifier is used.  */\n-  tree *nolen;\n-  /* Type of argument if length modifier for shortening to byte is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *hhlen;\n-  /* Type of argument if length modifier for shortening is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *hlen;\n-  /* Type of argument if length modifier `l' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *llen;\n-  /* Type of argument if length modifier `q' or `ll' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *qlen;\n-  /* Type of argument if length modifier `L' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *bigllen;\n-  /* Type of argument if length modifiers 'z' or `Z' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *zlen;\n-  /* Type of argument if length modifier 't' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *tlen;\n-  /* Type of argument if length modifier 'j' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *jlen;\n-  /* List of other modifier characters allowed with these options.  */\n-  const char *flag_chars;\n-} format_char_info;\n+static const format_char_info print_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",  0, STD_C89, { T89_I,   T99_I,   T89_I,   T89_L,   T99_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"-wp0 +'I\" },\n+  { \"oxX\", 0, STD_C89, { T89_UI,  T99_UI,  T89_UI,  T89_UL,  T99_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0#\"    },\n+  { \"u\",   0, STD_C89, { T89_UI,  T99_UI,  T89_UI,  T89_UL,  T99_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"-wp0'I\"   },\n+  { \"fgG\", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'\" },\n+  { \"eE\",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\"  },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\"       },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wpc\"     },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wc\"      },\n+  { \"n\",   1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T99_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\"         },\n+  /* C99 conversion specifiers.  */\n+  { \"F\",   0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#'\" },\n+  { \"aA\",  0, STD_C99, { T99_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"-wp0 +#\"  },\n+  /* X/Open conversion specifiers.  */\n+  { \"C\",   0, STD_EXT, { TEX_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-w\"       },\n+  { \"S\",   1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\"      },\n+  /* GNU conversion specifiers.  */\n+  { \"m\",   0, STD_EXT, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"-wp\"      },\n+  { NULL,  0, 0, NOLENGTHS, NULL }\n+};\n \n-static format_char_info print_char_table[] = {\n-  { \"di\",\t0,\tT_I,\tT_I,\tT_I,\tT_L,\tT_LL,\tT_LL,\tT_SST,\tT_PD,\tT_IM,\t\"-wp0 +'I\"\t},\n-  { \"oxX\",\t0,\tT_UI,\tT_UI,\tT_UI,\tT_UL,\tT_ULL,\tT_ULL,\tT_ST,\tT_UPD,\tT_UIM,\t\"-wp0#\"\t\t},\n-  { \"u\",\t0,\tT_UI,\tT_UI,\tT_UI,\tT_UL,\tT_ULL,\tT_ULL,\tT_ST,\tT_UPD,\tT_UIM,\t\"-wp0'I\"\t\t},\n-/* A GNU extension.  */\n-  { \"m\",\t0,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n-  { \"fFgG\",\t0,\tT_D,\tNULL,\tNULL,\tT_D,\tNULL,\tT_LD,\tNULL,\tNULL,\tNULL,\t\"-wp0 +#'\"\t},\n-  { \"eEaA\",\t0,\tT_D,\tNULL,\tNULL,\tT_D,\tNULL,\tT_LD,\tNULL,\tNULL,\tNULL,\t\"-wp0 +#\"\t},\n-  { \"c\",\t0,\tT_I,\tNULL,\tNULL,\tT_WI,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n-  { \"C\",\t0,\tT_WI,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n-  { \"s\",\t1,\tT_C,\tNULL,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wpc\"\t\t},\n-  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n-  { \"p\",\t1,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"-wc\"\t\t},\n-  { \"n\",\t1,\tT_I,\tT_SC,\tT_S,\tT_L,\tT_LL,\tNULL,\tT_SST,\tT_PD,\tT_IM,\t\"\"\t\t},\n-  { NULL,\t0,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL\t\t}\n+static const format_char_info scan_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"di\",    1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T99_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, \"*w\"   },\n+  { \"ouxX\",  1, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T99_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, \"*w\"   },\n+  { \"efgEG\", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  T89_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w\"   },\n+  { \"c\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*cw\"  },\n+  { \"s\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*acw\" },\n+  { \"[\",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*acw\" },\n+  { \"p\",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\"   },\n+  { \"n\",     1, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T99_LL,  BADLEN,  T99_SST, T99_PD,  T99_IM  }, \"\"     },\n+  /* C99 conversion specifiers.  */\n+  { \"FaA\",   1, STD_C99, { T99_F,   BADLEN,  BADLEN,  T99_D,   BADLEN,  T99_LD,  BADLEN,  BADLEN,  BADLEN  }, \"*w\"   },\n+  /* X/Open conversion specifiers.  */\n+  { \"C\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*w\"   },\n+  { \"S\",     1, STD_EXT, { TEX_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"*aw\"  },\n+  { NULL, 0, 0, NOLENGTHS, NULL }\n };\n \n-static format_char_info scan_char_table[] = {\n-  { \"di\",\t1,\tT_I,\tT_SC,\tT_S,\tT_L,\tT_LL,\tT_LL,\tT_SST,\tT_PD,\tT_IM,\t\"*w\"\t},\n-  { \"ouxX\",\t1,\tT_UI,\tT_UC,\tT_US,\tT_UL,\tT_ULL,\tT_ULL,\tT_ST,\tT_UPD,\tT_UIM,\t\"*w\"\t},\n-  { \"efFgEGaA\",\t1,\tT_F,\tNULL,\tNULL,\tT_D,\tNULL,\tT_LD,\tNULL,\tNULL,\tNULL,\t\"*w\"\t},\n-  { \"c\",\t1,\tT_C,\tNULL,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*cw\"\t},\n-  { \"s\",\t1,\tT_C,\tNULL,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*acw\"\t},\n-  { \"[\",\t1,\tT_C,\tNULL,\tNULL,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*acw\"\t},\n-  { \"C\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*w\"\t},\n-  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*aw\"\t},\n-  { \"p\",\t2,\tT_V,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\t\"*w\"\t},\n-  { \"n\",\t1,\tT_I,\tT_SC,\tT_S,\tT_L,\tT_LL,\tNULL,\tT_SST,\tT_PD,\tT_IM,\t\"\"\t},\n-  { NULL,\t0,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL,\tNULL\t}\n+static format_char_info time_char_table[] =\n+{\n+  /* C89 conversion specifiers.  */\n+  { \"ABZa\",\t\t0, STD_C89, NOLENGTHS, \"^#\" },\n+  { \"b\",\t\t0, STD_C89, NOLENGTHS, \"^\" },\n+  { \"cx\", \t\t0, STD_C89, NOLENGTHS, \"3E\" },\n+  { \"HIMSUWdmw\",\t0, STD_C89, NOLENGTHS, \"-_0Ow\" },\n+  { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Oow\" },\n+  { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\" },\n+  { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\" },\n+  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"2EO-_0w\" },\n+  { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOow\" },\n+  { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\" },\n+  /* C99 conversion specifiers.  */\n+  { \"C\",\t\t0, STD_C99, NOLENGTHS, \"-_0EOow\" },\n+  { \"D\", \t\t0, STD_C99, NOLENGTHS, \"2\" },\n+  { \"eVu\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\" },\n+  { \"FRTnrt\",\t\t0, STD_C99, NOLENGTHS, \"\" },\n+  { \"g\", \t\t0, STD_C99, NOLENGTHS, \"2Oo-_0w\" },\n+  { \"G\",\t\t0, STD_C99, NOLENGTHS, \"-_0Oow\" },\n+  { \"h\",\t\t0, STD_C99, NOLENGTHS, \"^\" },\n+  { \"z\",\t\t0, STD_C99, NOLENGTHS, \"Oo\" },\n+  /* GNU conversion specifiers.  */\n+  { \"kls\",\t\t0, STD_EXT, NOLENGTHS, \"-_0Ow\" },\n+  { \"P\",\t\t0, STD_EXT, NOLENGTHS, \"\" },\n+  { NULL,\t\t0, 0, NOLENGTHS, NULL }\n };\n \n-/* Handle format characters recognized by glibc's strftime.c.\n-   '2' - MUST do years as only two digits\n-   '3' - MAY do years as only two digits (depending on locale)\n-   'E' - E modifier is acceptable\n-   'O' - O modifier is acceptable to Standard C\n-   'o' - O modifier is acceptable as a GNU extension\n-   '9' - added to the C standard in C99\n-   'G' - other GNU extensions  */\n-\n-static format_char_info time_char_table[] = {\n-  { \"y\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"2EO-_0w\" },\n-  { \"D\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"29\" },\n-  { \"g\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"2Oo-_0w9\" },\n-  { \"cx\", \t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"3E\" },\n-  { \"%\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"\" },\n-  { \"X\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"E\" },\n-  { \"FRTnrt\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"9\" },\n-  { \"P\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"G\" },\n-  { \"HIMSUWdmw\",\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Ow\" },\n-  { \"e\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Ow9\" },\n-  { \"j\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Oow\" },\n-  { \"Vu\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Ow9\" },\n-  { \"G\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0Oow9\" },\n-  { \"z\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"Oo9\" },\n-  { \"kls\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0OGw\" },\n-  { \"ABZa\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"^#\" },\n-  { \"p\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"#\" },\n-  { \"b\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"^\" },\n-  { \"h\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"^9\" },\n-  { \"Y\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0EOow\" },\n-  { \"C\",\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \"-_0EOow9\" },\n-  { NULL,\t\t0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }\n+\n+/* This must be in the same order as enum format_type.  */\n+static const format_kind_info format_types[] =\n+{\n+  { \"printf\",   printf_length_specs, print_char_table },\n+  { \"scanf\",    scanf_length_specs,  scan_char_table  },\n+  { \"strftime\", NULL,                time_char_table  }\n };\n \n+\n typedef struct function_format_info\n {\n   struct function_format_info *next;  /* next structure on the list */\n@@ -1694,16 +1834,22 @@ check_format_info (info, params)\n   int i;\n   int arg_num;\n   int suppressed, wide, precise;\n-  int length_char = 0;\n+  const char *length_chars = NULL;\n+  enum format_lengths length_chars_val = FMT_LEN_none;\n+  enum format_std_version length_chars_std = STD_C89;\n   int format_char;\n   int format_length;\n   tree format_tree;\n   tree cur_param;\n   tree cur_type;\n   tree wanted_type;\n+  enum format_std_version wanted_type_std;\n+  const char *wanted_type_name;\n   tree first_fillin_param;\n   const char *format_chars;\n-  format_char_info *fci = NULL;\n+  const format_kind_info *fki = NULL;\n+  const format_length_info *fli = NULL;\n+  const format_char_info *fci = NULL;\n   char flag_chars[8];\n   /* -1 if no conversions taking an operand have been found; 0 if one has\n      and it didn't use $; 1 if $ formats are in use.  */\n@@ -1808,6 +1954,7 @@ check_format_info (info, params)\n \n   first_fillin_param = params;\n   init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n+  fki = &format_types[info->format_type];\n   while (1)\n     {\n       int aflag;\n@@ -2056,52 +2203,44 @@ check_format_info (info, params)\n \n       aflag = 0;\n \n-      if (info->format_type != strftime_format_type)\n+      fli = fki->length_char_specs;\n+      if (fli)\n \t{\n-\t  if (*format_chars == 'h' || *format_chars == 'l')\n-\t    length_char = *format_chars++;\n-\t  else if (*format_chars == 'q' || *format_chars == 'L')\n-\t    {\n-\t      length_char = *format_chars++;\n-\t      if (length_char == 'q' && pedantic)\n-\t\twarning (\"ISO C does not support the `%c' length modifier\",\n-\t\t\t length_char);\n-\t    }\n-\t  else if (*format_chars == 'z'\n-\t\t   || (*format_chars == 'Z'\n-\t\t       && info->format_type == printf_format_type))\n+\t  while (fli->name != 0 && fli->name[0] != *format_chars)\n+\t    fli++;\n+\t  if (fli->name != 0)\n \t    {\n-\t      length_char = *format_chars++;\n-\t      if (pedantic)\n+\t      format_chars++;\n+\t      if (fli->double_name != 0 && fli->name[0] == *format_chars)\n \t\t{\n-\t\t  if (length_char == 'Z')\n-\t\t    warning (\"ISO C does not support the `%c' length modifier\",\n-\t\t\t     length_char);\n-\t\t  else if (!flag_isoc99)\n-\t\t    warning (\"ISO C89 does not support the `%c' length modifier\",\n-\t\t\t     length_char);\n+\t\t  format_chars++;\n+\t\t  length_chars = fli->double_name;\n+\t\t  length_chars_val = fli->double_index;\n+\t\t  length_chars_std = fli->double_std;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  length_chars = fli->name;\n+\t\t  length_chars_val = fli->index;\n+\t\t  length_chars_std = fli->std;\n \t\t}\n-\t    }\n-\t  else if (*format_chars == 't' || *format_chars == 'j')\n-\t    {\n-\t      length_char = *format_chars++;\n-\t      if (pedantic && !flag_isoc99)\n-\t\twarning (\"ISO C89 does not support the `%c' length modifier\",\n-\t\t\t length_char);\n \t    }\n \t  else\n-\t    length_char = 0;\n-\t  if (length_char == 'l' && *format_chars == 'l')\n \t    {\n-\t      length_char = 'q', format_chars++;\n-\t      if (pedantic && !flag_isoc99)\n-\t\twarning (\"ISO C89 does not support the `ll' length modifier\");\n+\t      length_chars = NULL;\n+\t      length_chars_val = FMT_LEN_none;\n+\t      length_chars_std = STD_C89;\n \t    }\n-\t  else if (length_char == 'h' && *format_chars == 'h')\n+\t  if (pedantic)\n \t    {\n-\t      length_char = 'H', format_chars++;\n-\t      if (pedantic && !flag_isoc99)\n-\t\twarning (\"ISO C89 does not support the `hh' length modifier\");\n+\t      /* Warn if the length modifier is non-standard.  */\n+\t      if (length_chars_std == STD_EXT)\n+\t\twarning (\"ISO C does not support the `%s' %s length modifier\",\n+\t\t\t length_chars, fki->name);\n+\t      else if ((length_chars_std == STD_C99 && !flag_isoc99)\n+\t\t       || (length_chars_std == STD_C94 && !flag_isoc94))\n+\t\twarning (\"ISO C89 does not support the `%s' %s length modifier\",\n+\t\t\t length_chars, fki->name);\n \t    }\n \t  if (*format_chars == 'a' && info->format_type == scanf_format_type\n \t      && !flag_isoc99)\n@@ -2114,8 +2253,8 @@ check_format_info (info, params)\n \t\t  format_chars++;\n \t\t}\n \t    }\n-\t  if (suppressed && length_char != 0)\n-\t    warning (\"use of `*' and `%c' together in format\", length_char);\n+\t  if (suppressed && length_chars_val != FMT_LEN_none)\n+\t    warning (\"use of `*' and `%s' together in format\", length_chars);\n \t}\n       format_char = *format_chars;\n       if (format_char == 0\n@@ -2124,30 +2263,8 @@ check_format_info (info, params)\n \t  warning (\"conversion lacks type at end of format\");\n \t  continue;\n \t}\n-      /* The m, C, and S formats are GNU extensions.  */\n-      if (pedantic && info->format_type != strftime_format_type\n-\t  && (format_char == 'm' || format_char == 'C' || format_char == 'S'))\n-\twarning (\"ISO C does not support the `%c' format\", format_char);\n-      /* The a, A and F formats are C99 extensions.  */\n-      if (pedantic && info->format_type != strftime_format_type\n-\t  && (format_char == 'a' || format_char == 'A' || format_char == 'F')\n-\t  && !flag_isoc99)\n-\twarning (\"ISO C89 does not support the `%c' format\", format_char);\n       format_chars++;\n-      switch (info->format_type)\n-\t{\n-\tcase printf_format_type:\n-\t  fci = print_char_table;\n-\t  break;\n-\tcase scanf_format_type:\n-\t  fci = scan_char_table;\n-\t  break;\n-\tcase strftime_format_type:\n-\t  fci = time_char_table;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n+      fci = fki->conversion_specs;\n       while (fci->format_chars != 0\n \t     && index (fci->format_chars, format_char) == 0)\n \t  ++fci;\n@@ -2163,10 +2280,13 @@ check_format_info (info, params)\n \t}\n       if (pedantic)\n \t{\n-\t  if (index (fci->flag_chars, 'G') != 0)\n-\t    warning (\"ISO C does not support `%%%c'\", format_char);\n-\t  if (index (fci->flag_chars, '9') != 0 && !flag_isoc99)\n-\t    warning (\"ISO C89 does not support `%%%c'\", format_char);\n+\t  if (fci->std == STD_EXT)\n+\t    warning (\"ISO C does not support the `%%%c' %s format\",\n+\t\t     format_char, fki->name);\n+\t  else if ((fci->std == STD_C99 && !flag_isoc99)\n+\t\t   || (fci->std == STD_C94 && !flag_isoc94))\n+\t    warning (\"ISO C89 does not support the `%%%c' %s format\",\n+\t\t     format_char, fki->name);\n \t  if (index (flag_chars, 'O') != 0)\n \t    {\n \t      if (index (fci->flag_chars, 'o') != 0)\n@@ -2231,45 +2351,28 @@ check_format_info (info, params)\n \t      || format_char == 'x' || format_char == 'X'))\n \twarning (\"`0' flag ignored with precision specifier and `%c' format\",\n \t\t format_char);\n-      switch (length_char)\n+      wanted_type = (fci->types[length_chars_val].type\n+\t\t     ? *fci->types[length_chars_val].type : 0);\n+      wanted_type_name = fci->types[length_chars_val].name;\n+      wanted_type_std = fci->types[length_chars_val].std;\n+      if (wanted_type == 0)\n+\twarning (\"use of `%s' length modifier with `%c' type character\",\n+\t\t length_chars, format_char);\n+      else if (pedantic\n+\t       /* Warn if non-standard, provided it is more non-standard\n+\t\t  than the length and type characters that may already\n+\t\t  have been warned for.  */\n+\t       && wanted_type_std > length_chars_std\n+\t       && wanted_type_std > fci->std)\n \t{\n-\tdefault: wanted_type = fci->nolen ? *(fci->nolen) : 0; break;\n-\tcase 'H': wanted_type = fci->hhlen ? *(fci->hhlen) : 0; break;\n-\tcase 'h': wanted_type = fci->hlen ? *(fci->hlen) : 0; break;\n-\tcase 'l': wanted_type = fci->llen ? *(fci->llen) : 0; break;\n-\tcase 'q': wanted_type = fci->qlen ? *(fci->qlen) : 0; break;\n-\tcase 'L': wanted_type = fci->bigllen ? *(fci->bigllen) : 0; break;\n-\tcase 'z': case 'Z': wanted_type = (fci->zlen\n-\t\t\t\t\t   ? (TYPE_DOMAIN (*fci->zlen)\n-\t\t\t\t\t      ? TYPE_DOMAIN (*fci->zlen)\n-\t\t\t\t\t      : *fci->zlen)\n-\t\t\t\t\t   : 0); break;\n-\tcase 't': wanted_type = fci->tlen ? *(fci->tlen) : 0; break;\n-\tcase 'j': wanted_type = fci->jlen ? *(fci->jlen) : 0; break;\n+\t  if (wanted_type_std == STD_EXT)\n+\t    warning (\"ISO C does not support the `%%%s%c' %s format\",\n+\t\t     length_chars, format_char, fki->name);\n+\t  else if ((wanted_type_std == STD_C99 && !flag_isoc99)\n+\t\t   || (wanted_type_std == STD_C94 && !flag_isoc94))\n+\t    warning (\"ISO C89 does not support the `%%%s%c' %s format\",\n+\t\t     length_chars, format_char, fki->name);\n \t}\n-      if (wanted_type == 0)\n-\twarning (\"use of `%c' length character with `%c' type character\",\n-\t\t length_char, format_char);\n-      else if (length_char == 'L' && pedantic\n-\t       && !(format_char == 'a' || format_char == 'A'\n-\t\t    || format_char == 'e' || format_char == 'E'\n-\t\t    || format_char == 'f' || format_char == 'F'\n-\t\t    || format_char == 'g' || format_char == 'G'))\n-\twarning (\"ISO C does not support the `L' length modifier with the `%c' type character\",\n-\t\t format_char);\n-      else if (length_char == 'l'\n-\t       && (format_char == 'c' || format_char == 's'\n-\t\t   || format_char == '[')\n-\t       && pedantic && !flag_isoc94)\n-\twarning (\"ISO C89 does not support the `l' length modifier with the `%c' type character\",\n-\t\t format_char);\n-      else if (info->format_type == printf_format_type && pedantic\n-\t       && !flag_isoc99 && length_char == 'l'\n-\t       && (format_char == 'f' || format_char == 'e'\n-\t\t   || format_char == 'E' || format_char == 'g'\n-\t\t   || format_char == 'G'))\n-\twarning (\"ISO C89 does not support the `l' length modifier with the `%c' type character\",\n-\t\t format_char);\n \n       /* Finally. . .check type of argument against desired type!  */\n       if (info->first_arg_num == 0)\n@@ -2424,7 +2527,16 @@ check_format_info (info, params)\n \t    that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n \n \t  if (strcmp (this, that) != 0)\n-\t    warning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n+\t    {\n+\t      /* There may be a better name for the format, e.g. size_t,\n+\t\t but we should allow for programs with a perverse typedef\n+\t\t making size_t something other than what the compiler\n+\t\t thinks.  */\n+\t      if (wanted_type_name != 0\n+\t\t  && strcmp (wanted_type_name, that) != 0)\n+\t\tthis = wanted_type_name;\n+\t      warning (\"%s format, %s arg (arg %d)\", this, that, arg_num);\n+\t    }\n \t}\n     }\n }"}, {"sha": "bec52140efed558af108523ee21d63503e697b8e", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=3c786c6945296d79a0d5f1799994aeb728aef083", "patch": "@@ -91,6 +91,7 @@ enum c_tree_index\n     CTI_SIGNED_WCHAR_TYPE,\n     CTI_UNSIGNED_WCHAR_TYPE,\n     CTI_WINT_TYPE,\n+    CTI_C_SIZE_TYPE, /* For format checking only.  */\n     CTI_SIGNED_SIZE_TYPE, /* For format checking only.  */\n     CTI_UNSIGNED_PTRDIFF_TYPE, /* For format checking only.  */\n     CTI_WIDEST_INT_LIT_TYPE,\n@@ -130,6 +131,7 @@ enum c_tree_index\n #define signed_wchar_type_node\t\tc_global_trees[CTI_SIGNED_WCHAR_TYPE]\n #define unsigned_wchar_type_node\tc_global_trees[CTI_UNSIGNED_WCHAR_TYPE]\n #define wint_type_node\t\t\tc_global_trees[CTI_WINT_TYPE]\n+#define c_size_type_node\t\tc_global_trees[CTI_C_SIZE_TYPE]\n #define signed_size_type_node\t\tc_global_trees[CTI_SIGNED_SIZE_TYPE]\n #define unsigned_ptrdiff_type_node\tc_global_trees[CTI_UNSIGNED_PTRDIFF_TYPE]\n #define widest_integer_literal_type_node c_global_trees[CTI_WIDEST_INT_LIT_TYPE]"}, {"sha": "64823591edc1446c041f1c6b3abcb11be7345987", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3c786c6945296d79a0d5f1799994aeb728aef083", "patch": "@@ -3016,6 +3016,7 @@ init_decl_processing ()\n   if (flag_traditional && TREE_UNSIGNED (t))\n     t = signed_type (t);\n \n+  c_size_type_node = t;\n   set_sizetype (t);\n \n   /* Create the widest literal types.  */"}, {"sha": "73aea90f07f431c7e2d0e696022a90938e457ccc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c786c6945296d79a0d5f1799994aeb728aef083", "patch": "@@ -1,3 +1,7 @@\n+2000-09-01  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/format-diag-1.c: New test.\n+\n 2000-09-01  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/c90-printf-1.c, gcc.dg/c90-printf-2.c,"}, {"sha": "33364d75159178704005dde0051258d91f10c0e4", "filename": "gcc/testsuite/gcc.dg/format-diag-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-diag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c786c6945296d79a0d5f1799994aeb728aef083/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-diag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-diag-1.c?ref=3c786c6945296d79a0d5f1799994aeb728aef083", "patch": "@@ -0,0 +1,18 @@\n+/* Test for format diagnostics.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+extern int printf (const char *, ...);\n+\n+void\n+foo (double d)\n+{\n+  /* This should get a message referring to `hh', not to `H'.  */\n+  printf (\"%hhf\", d); /* { dg-warning \"hh\" \"%hhf warning\" } */\n+  /* This should get a message referring to `ll', not to `q'.  */\n+  printf (\"%llf\", d); /* { dg-warning \"ll\" \"%llf warning\" } */\n+  /* This should get a message referring to `size_t format', not to\n+     `unsigned int format' or similar.  */\n+  printf (\"%zu\", d); /* { dg-warning \"size_t format\" \"size_t format warning\" } */\n+}"}]}