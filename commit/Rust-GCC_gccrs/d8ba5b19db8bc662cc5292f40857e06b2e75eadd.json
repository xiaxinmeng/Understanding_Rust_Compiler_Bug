{"sha": "d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhiYTViMTlkYjhiYzY2MmNjNTI5MmY0MDg1N2UwNmIyZTc1ZWFkZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-10-22T14:44:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-10-22T14:44:48Z"}, "message": "re PR middle-end/45720 (Revision 164367 miscompiled SPEC CPU 2K)\n\n2010-10-22  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/45720\n\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel):\n\tHandle negative step.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop): Likewise.\n\t(vect_create_cond_for_align_checks): Likewise.\n\t(vect_create_cond_for_alias_checks): Likewise.\n\n\t* gcc.dg/torture/pr45720.c: New testcase.\n\nFrom-SVN: r165832", "tree": {"sha": "4383d330bb2bda293ba6501d646c129330f5b813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4383d330bb2bda293ba6501d646c129330f5b813"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fc2854deca262d8a469dea2d0a32fc6e9572c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc2854deca262d8a469dea2d0a32fc6e9572c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc2854deca262d8a469dea2d0a32fc6e9572c9e"}], "stats": {"total": 121, "additions": 104, "deletions": 17}, "files": [{"sha": "2d39d3930b8032197be3f7a2ab6581ee6bbcd3f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "patch": "@@ -1,3 +1,13 @@\n+2010-10-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45720\n+\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel):\n+\tHandle negative step.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop): Likewise.\n+\t(vect_create_cond_for_align_checks): Likewise.\n+\t(vect_create_cond_for_alias_checks): Likewise.\n+\n 2010-10-22  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/46126"}, {"sha": "b853e6e89d281b08f21d8eb1a32e6edbacdfbf13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "patch": "@@ -1,3 +1,8 @@\n+2010-10-22  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45720\n+\t* gcc.dg/torture/pr45720.c: New testcase.\n+\n 2010-10-22  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/46126"}, {"sha": "9de8d1117f678d974ceffdfdea35270333b998d2", "filename": "gcc/testsuite/gcc.dg/torture/pr45720.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45720.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45720.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr45720.c?ref=d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-ftree-vectorize\" } */\n+\n+float val[256];\n+float x;\n+void __attribute__((noinline,noclone))\n+foo(int len, int beg)\n+{\n+  int i;\n+  for (i = len - 1; i >= beg; --i)\n+    x += val[i] * 2;\n+}\n+void __attribute__((noinline,noclone))\n+bar(void)\n+{\n+  int i;\n+  for (i = 255; i >= 0; --i)\n+    x += val[i] * 2;\n+  for (i = 254; i >= 0; --i)\n+    x += val[i] * 2;\n+  for (i = 253; i >= 0; --i)\n+    x += val[i] * 2;\n+  for (i = 252; i >= 0; --i)\n+    x += val[i] * 2;\n+}\n+float y[256];\n+void __attribute__((noinline,noclone))\n+foobar(void)\n+{\n+  int i;\n+  for (i = 0; i < 252; ++i)\n+    {\n+      float l = 0;\n+      l += val[255 - i] * 2;\n+      l += val[254 - i] * 2;\n+      l += val[253 - i] * 2;\n+      l += val[252 - i] * 2;\n+      y[i] = l;\n+    }\n+}\n+int main()\n+{\n+  foo(256-1, 0);\n+  foo(256-2, 0);\n+  foo(256-3, 0);\n+  foo(256-4, 0);\n+  bar();\n+  foobar();\n+  return 0;\n+}"}, {"sha": "b4da5178be930e6550965c78491ca9b620871d72", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "patch": "@@ -1016,10 +1016,11 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n   if (known_alignment_for_access_p (dr)\n       && known_alignment_for_access_p (dr_peel))\n     {\n+      bool negative = tree_int_cst_compare (DR_STEP (dr), size_zero_node) < 0;\n       int misal = DR_MISALIGNMENT (dr);\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      misal += npeel * dr_size;\n-      misal %= GET_MODE_SIZE (TYPE_MODE (vectype));\n+      misal += negative ? -npeel * dr_size : npeel * dr_size;\n+      misal &= GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;\n       SET_DR_MISALIGNMENT (dr, misal);\n       return;\n     }\n@@ -1503,6 +1504,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           if (known_alignment_for_access_p (dr))\n             {\n               unsigned int npeel_tmp;\n+\t      bool negative = tree_int_cst_compare (DR_STEP (dr),\n+\t\t\t\t\t\t    size_zero_node) < 0;\n \n               /* Save info about DR in the hash table.  */\n               if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n@@ -1514,7 +1517,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               nelements = TYPE_VECTOR_SUBPARTS (vectype);\n               mis = DR_MISALIGNMENT (dr) / GET_MODE_SIZE (TYPE_MODE (\n                                                 TREE_TYPE (DR_REF (dr))));\n-              npeel_tmp = (nelements - mis) % vf;\n+              npeel_tmp = (negative\n+\t\t\t   ? (mis - nelements) : (nelements - mis)) & (vf - 1);\n \n               /* For multiple types, it is possible that the bigger type access\n                  will have more than one peeling option.  E.g., a loop with two\n@@ -1707,6 +1711,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       if (known_alignment_for_access_p (dr0))\n         {\n+\t  bool negative = tree_int_cst_compare (DR_STEP (dr0),\n+\t\t\t\t\t\tsize_zero_node) < 0;\n           if (!npeel)\n             {\n               /* Since it's known at compile time, compute the number of\n@@ -1716,7 +1722,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  count.  */\n               mis = DR_MISALIGNMENT (dr0);\n               mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n-              npeel = nelements - mis;\n+              npeel = (negative ? mis - nelements : nelements - mis) & (vf - 1);\n             }\n \n \t  /* For interleaved data access every iteration accesses all the"}, {"sha": "f006182f1ade6386bf02c29a46a1bf26c19fb8ce", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ba5b19db8bc662cc5292f40857e06b2e75eadd/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=d8ba5b19db8bc662cc5292f40857e06b2e75eadd", "patch": "@@ -1993,8 +1993,11 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n   else\n     {\n       gimple_seq new_stmts = NULL;\n+      bool negative = tree_int_cst_compare (DR_STEP (dr), size_zero_node) < 0;\n+      tree offset = negative\n+\t  ? size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1) : NULL_TREE;\n       tree start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n-\t\t\t\t\t\t&new_stmts, NULL_TREE, loop);\n+\t\t\t\t\t\t&new_stmts, offset, loop);\n       tree ptr_type = TREE_TYPE (start_addr);\n       tree size = TYPE_SIZE (ptr_type);\n       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n@@ -2019,7 +2022,10 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n         fold_build2 (RSHIFT_EXPR, type, byte_misalign, elem_size_log);\n \n       /* Create:  (niters_type) (nelements - elem_misalign)&(nelements - 1)  */\n-      iters = fold_build2 (MINUS_EXPR, type, nelements_tree, elem_misalign);\n+      if (negative)\n+\titers = fold_build2 (MINUS_EXPR, type, elem_misalign, nelements_tree);\n+      else\n+\titers = fold_build2 (MINUS_EXPR, type, nelements_tree, elem_misalign);\n       iters = fold_build2 (BIT_AND_EXPR, type, iters, nelements_minus_1);\n       iters = fold_convert (niters_type, iters);\n     }\n@@ -2236,11 +2242,17 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n       tree addr_tmp, addr_tmp_name;\n       tree or_tmp, new_or_tmp_name;\n       gimple addr_stmt, or_stmt;\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (ref_stmt);\n+      tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n+      bool negative = tree_int_cst_compare\n+\t(DR_STEP (STMT_VINFO_DATA_REF (stmt_vinfo)), size_zero_node) < 0;\n+      tree offset = negative\n+\t? size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1) : NULL_TREE;\n \n       /* create: addr_tmp = (int)(address_of_first_vector) */\n       addr_base =\n \tvect_create_addr_base_for_vector_ref (ref_stmt, &new_stmt_list,\n-\t\t\t\t\t      NULL_TREE, loop);\n+\t\t\t\t\t      offset, loop);\n       if (new_stmt_list != NULL)\n \tgimple_seq_add_seq (cond_expr_stmt_list, new_stmt_list);\n \n@@ -2387,6 +2399,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n       tree addr_base_a, addr_base_b;\n       tree segment_length_a, segment_length_b;\n       gimple stmt_a, stmt_b;\n+      tree seg_a_min, seg_a_max, seg_b_min, seg_b_max;\n \n       dr_a = DDR_A (ddr);\n       stmt_a = DR_STMT (DDR_A (ddr));\n@@ -2425,19 +2438,22 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \t  print_generic_expr (vect_dump, DR_REF (dr_b), TDF_SLIM);\n \t}\n \n+      seg_a_min = addr_base_a;\n+      seg_a_max = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr_base_a), \n+\t\t\t       addr_base_a, segment_length_a);\n+      if (tree_int_cst_compare (DR_STEP (dr_a), size_zero_node) < 0)\n+\tseg_a_min = seg_a_max, seg_a_max = addr_base_a;\n+\n+      seg_b_min = addr_base_b;\n+      seg_b_max = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr_base_b),\n+\t\t\t       addr_base_b, segment_length_b);\n+      if (tree_int_cst_compare (DR_STEP (dr_b), size_zero_node) < 0)\n+\tseg_b_min = seg_b_max, seg_b_max = addr_base_b;\n \n       part_cond_expr =\n       \tfold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t  fold_build2 (LT_EXPR, boolean_type_node,\n-\t    fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr_base_a),\n-\t      addr_base_a,\n-\t      segment_length_a),\n-\t    addr_base_b),\n-\t  fold_build2 (LT_EXPR, boolean_type_node,\n-\t    fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr_base_b),\n-\t      addr_base_b,\n-\t      segment_length_b),\n-\t    addr_base_a));\n+\t  fold_build2 (LT_EXPR, boolean_type_node, seg_a_max, seg_b_min),\n+\t  fold_build2 (LT_EXPR, boolean_type_node, seg_b_max, seg_a_min));\n \n       if (*cond_expr)\n \t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,"}]}