{"sha": "e5214479a779ad44390aec0694c11c5493aaad83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyMTQ0NzlhNzc5YWQ0NDM5MGFlYzA2OTRjMTFjNTQ5M2FhYWQ4Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-12-22T14:47:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-12-22T14:47:23Z"}, "message": "In partial ordering for a call, ignore parms for which we don't have a real argument.\n\n        In partial ordering for a call, ignore parms for which we don't have\n        a real argument.\n        * call.c (joust): Pass len to more_specialized.\n        (add_template_candidate_real): Strip 'this', pass len.\n        * pt.c (more_specialized): Pass len down.  Lose explicit_args parm.\n        (get_bindings_order): New fn.  Pass len down.\n        (get_bindings_real): Strip 'this', pass len.\n        (fn_type_unification): Likewise.\n        (type_unification_real): Succeed after checking 'len' args.\n        (most_specialized_instantiation): Lose explicit_args parm.\n        * class.c (resolve_address_of_overloaded_function): Strip 'this',\n        pass len.\n\nFrom-SVN: r38460", "tree": {"sha": "03872ce18ff4048a6f1f283f2b1c17a057af6e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03872ce18ff4048a6f1f283f2b1c17a057af6e7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5214479a779ad44390aec0694c11c5493aaad83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5214479a779ad44390aec0694c11c5493aaad83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5214479a779ad44390aec0694c11c5493aaad83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5214479a779ad44390aec0694c11c5493aaad83/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83ab39071b94a60a1b8fb8e791b8b651b93282fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ab39071b94a60a1b8fb8e791b8b651b93282fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83ab39071b94a60a1b8fb8e791b8b651b93282fa"}], "stats": {"total": 186, "additions": 117, "deletions": 69}, "files": [{"sha": "8da2de1b53e2cebf71dd213c6f5c93dc06870882", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e5214479a779ad44390aec0694c11c5493aaad83", "patch": "@@ -1,4 +1,19 @@\n-2000-12-20  Jason Merrill  <jason@redhat.com>\n+2000-12-22  Jason Merrill  <jason@redhat.com>\n+\n+\tIn partial ordering for a call, ignore parms for which we don't have\n+\ta real argument.\n+\t* call.c (joust): Pass len to more_specialized.\n+\t(add_template_candidate_real): Strip 'this', pass len.\n+\t* pt.c (more_specialized): Pass len down.  Lose explicit_args parm.\n+\t(get_bindings_order): New fn.  Pass len down.\n+\t(get_bindings_real): Strip 'this', pass len.\n+\t(fn_type_unification): Likewise.\n+\t(type_unification_real): Succeed after checking 'len' args.\n+\t(most_specialized_instantiation): Lose explicit_args parm.\n+\t* class.c (resolve_address_of_overloaded_function): Strip 'this', \n+\tpass len.\n+\n+2000-12-21  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst_decl): A FUNCTION_DECL has DECL_RESULT, not\n \tDECL_TEMPLATE_RESULT."}, {"sha": "07d7268bd7bec85aa15b5d57f8f5d7a4b4a43ad6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e5214479a779ad44390aec0694c11c5493aaad83", "patch": "@@ -2147,26 +2147,24 @@ add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n-  tree args_without_in_chrg;\n+  tree args_without_in_chrg = arglist;\n   struct z_candidate *cand;\n   int i;\n   tree fn;\n \n-  /* TEMPLATE_DECLs do not have the in-charge parameter, nor the VTT\n-     parameter.  So, skip it here before attempting to perform\n-     argument deduction.  */\n+  /* We don't do deduction on the in-charge parameter, the VTT\n+     parameter or 'this'.  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (tmpl))\n+    args_without_in_chrg = TREE_CHAIN (args_without_in_chrg);\n+\n   if ((DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (tmpl)\n        || DECL_BASE_CONSTRUCTOR_P (tmpl))\n       && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (tmpl)))\n-    args_without_in_chrg = tree_cons (NULL_TREE, \n-\t\t\t\t      TREE_VALUE (arglist),\n-\t\t\t\t      TREE_CHAIN (TREE_CHAIN (arglist)));\n-  else\n-    args_without_in_chrg = arglist;\n+    args_without_in_chrg = TREE_CHAIN (args_without_in_chrg);\n \n   i = fn_type_unification (tmpl, explicit_targs, targs,\n \t\t\t   args_without_in_chrg,\n-\t\t\t   return_type, strict);\n+\t\t\t   return_type, strict, -1);\n \n   if (i != 0)\n     return candidates;\n@@ -5156,7 +5154,8 @@ joust (cand1, cand2, warn)\n   else if (cand1->template && cand2->template)\n     winner = more_specialized\n       (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template),\n-       NULL_TREE);\n+       /* Never do unification on the 'this' parameter.  */\n+       TREE_VEC_LENGTH (cand1->convs) - !DECL_STATIC_FUNCTION_P (cand1->fn));\n \n   /* or, if not that,\n      the  context  is  an  initialization by user-defined conversion (see"}, {"sha": "4e6babd14ef6c492ebde7adad74fda207545e61c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e5214479a779ad44390aec0694c11c5493aaad83", "patch": "@@ -5953,6 +5953,10 @@ resolve_address_of_overloaded_function (target_type,\n \ttarget_fn_type = TREE_TYPE (target_type);\n       target_arg_types = TYPE_ARG_TYPES (target_fn_type);\n       target_ret_type = TREE_TYPE (target_fn_type);\n+\n+      /* Never do unification on the 'this' parameter.  */\n+      if (TREE_CODE (target_fn_type) == METHOD_TYPE)\n+\ttarget_arg_types = TREE_CHAIN (target_arg_types);\n \t  \n       for (fns = overload; fns; fns = OVL_CHAIN (fns))\n \t{\n@@ -5975,7 +5979,7 @@ resolve_address_of_overloaded_function (target_type,\n \t  targs = make_tree_vec (DECL_NTPARMS (fn));\n \t  if (fn_type_unification (fn, explicit_targs, targs,\n \t\t\t\t   target_arg_types, target_ret_type,\n-\t\t\t\t   DEDUCE_EXACT) != 0)\n+\t\t\t\t   DEDUCE_EXACT, -1) != 0)\n \t    /* Argument deduction failed.  */\n \t    continue;\n \n@@ -5999,8 +6003,7 @@ resolve_address_of_overloaded_function (target_type,\n       /* Now, remove all but the most specialized of the matches.  */\n       if (matches)\n \t{\n-\t  tree match = most_specialized_instantiation (matches, \n-\t\t\t\t\t\t       explicit_targs);\n+\t  tree match = most_specialized_instantiation (matches);\n \n \t  if (match != error_mark_node)\n \t    matches = tree_cons (match, NULL_TREE, NULL_TREE);"}, {"sha": "0a260dfcb79f9a65d1419448ca0bbefaa8b9b1f4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e5214479a779ad44390aec0694c11c5493aaad83", "patch": "@@ -113,13 +113,14 @@ static tree add_outermost_template_args PARAMS ((tree, tree));\n static void maybe_adjust_types_for_deduction PARAMS ((unification_kind_t, tree*,\n \t\t\t\t\t\t    tree*)); \n static int  type_unification_real PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t int, unification_kind_t, int));\n+\t\t\t\t\t int, unification_kind_t, int, int));\n static void note_template_header PARAMS ((int));\n static tree maybe_fold_nontype_arg PARAMS ((tree));\n static tree convert_nontype_argument PARAMS ((tree, tree));\n static tree convert_template_argument PARAMS ((tree, tree, tree, int,\n \t\t\t\t\t      int , tree));\n static tree get_bindings_overload PARAMS ((tree, tree, tree));\n+static tree get_bindings_order PARAMS ((tree, tree, int));\n static int for_each_template_parm PARAMS ((tree, tree_fn_t, void*));\n static tree build_template_parm_index PARAMS ((int, int, int, tree, tree));\n static int inline_needs_template_parms PARAMS ((tree));\n@@ -134,7 +135,7 @@ static tree build_template_decl PARAMS ((tree, tree));\n static int mark_template_parm PARAMS ((tree, void *));\n static tree tsubst_friend_function PARAMS ((tree, tree));\n static tree tsubst_friend_class PARAMS ((tree, tree));\n-static tree get_bindings_real PARAMS ((tree, tree, tree, int));\n+static tree get_bindings_real PARAMS ((tree, tree, tree, int, int));\n static int template_decl_level PARAMS ((tree));\n static tree maybe_get_template_decl_from_type_decl PARAMS ((tree));\n static int check_cv_quals_for_unify PARAMS ((int, tree, tree));\n@@ -7572,10 +7573,8 @@ overload_template_name (type)\n    all the types, and 1 for complete failure.  An error message will be\n    printed only for an incomplete match.\n \n-   If FN is a conversion operator, RETURN_TYPE is the type desired as\n-   the result of the conversion operator.\n-\n-   TPARMS is a vector of template parameters.\n+   If FN is a conversion operator, or we are trying to produce a specific\n+   specialization, RETURN_TYPE is the return type desired.\n \n    The EXPLICIT_TARGS are explicit template arguments provided via a\n    template-id.\n@@ -7599,13 +7598,18 @@ overload_template_name (type)\n      [temp.expl.spec], or when taking the address of a function\n      template, as in [temp.deduct.funcaddr]. \n \n-   The other arguments are as for type_unification.  */\n+   LEN is the number of parms to consider before returning success, or -1\n+   for all.  This is used in partial ordering to avoid comparing parms for\n+   which no actual argument was passed, since they are not considered in\n+   overload resolution (and are explicitly excluded from consideration in\n+   partial ordering in [temp.func.order]/6).  */\n \n int\n fn_type_unification (fn, explicit_targs, targs, args, return_type,\n-\t\t     strict)\n+\t\t     strict, len)\n      tree fn, explicit_targs, targs, args, return_type;\n      unification_kind_t strict;\n+     int len;\n {\n   tree parms;\n   tree fntype;\n@@ -7653,15 +7657,9 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n     }\n      \n   parms = TYPE_ARG_TYPES (fntype);\n-\n-  if (DECL_CONV_FN_P (fn))\n-    {\n-      /* This is a template conversion operator.  Remove `this', since\n-         we could be comparing conversions from different classes.  */\n-      parms = TREE_CHAIN (parms);\n-      args = TREE_CHAIN (args);\n-      my_friendly_assert (return_type != NULL_TREE, 20000227);\n-    }\n+  /* Never do unification on the 'this' parameter.  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+    parms = TREE_CHAIN (parms);\n   \n   if (return_type)\n     {\n@@ -7676,7 +7674,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n      event.  */\n   result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n \t\t\t\t  targs, parms, args, /*subr=*/0,\n-\t\t\t\t  strict, /*allow_incomplete*/1);\n+\t\t\t\t  strict, /*allow_incomplete*/1, len);\n \n   if (result == 0) \n     /* All is well so far.  Now, check:\n@@ -7769,19 +7767,19 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n     *parm = TREE_TYPE (*parm);\n }\n \n-/* Like type_unification.\n+/* Most parms like fn_type_unification.\n \n    If SUBR is 1, we're being called recursively (to unify the\n    arguments of a function or method parameter of a function\n    template).  */\n \n static int\n type_unification_real (tparms, targs, parms, args, subr,\n-\t\t       strict, allow_incomplete)\n+\t\t       strict, allow_incomplete, len)\n      tree tparms, targs, parms, args;\n      int subr;\n      unification_kind_t strict;\n-     int allow_incomplete;\n+     int allow_incomplete, len;\n {\n   tree parm, arg;\n   int i;\n@@ -7815,6 +7813,9 @@ type_unification_real (tparms, targs, parms, args, subr,\n       my_friendly_abort (0);\n     }\n \n+  if (len == 0)\n+    return 0;\n+\n   while (parms\n \t && parms != void_list_node\n \t && args\n@@ -7887,6 +7888,10 @@ type_unification_real (tparms, targs, parms, args, subr,\n \n       if (unify (tparms, targs, parm, arg, sub_strict))\n         return 1;\n+\n+      /* Are we done with the interesting parms?  */\n+      if (--len == 0)\n+\treturn 0;\n     }\n   /* Fail if we've reached the end of the parm list, and more args\n      are present, and the parm list isn't variadic.  */\n@@ -8738,7 +8743,7 @@ unify (tparms, targs, parm, arg, strict)\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t    TYPE_ARG_TYPES (arg), 1, \n-\t\t\t\t    DEDUCE_EXACT, 0);\n+\t\t\t\t    DEDUCE_EXACT, 0, -1);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n@@ -8854,27 +8859,30 @@ mark_decl_instantiated (result, extern_p)\n     defer_fn (result);\n }\n \n-/* Given two function templates PAT1 and PAT2, and explicit template\n-   arguments EXPLICIT_ARGS return:\n+/* Given two function templates PAT1 and PAT2, return:\n \n    1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].\n    -1 if PAT2 is more specialized than PAT1.\n-   0 if neither is more specialized.  */\n+   0 if neither is more specialized.\n+\n+   LEN is passed through to fn_type_unification.  */\n    \n int\n-more_specialized (pat1, pat2, explicit_args)\n-     tree pat1, pat2, explicit_args;\n+more_specialized (pat1, pat2, len)\n+     tree pat1, pat2;\n+     int len;\n {\n   tree targs;\n   int winner = 0;\n \n-  targs\n-    = get_bindings_overload (pat1, DECL_TEMPLATE_RESULT (pat2), explicit_args);\n+  if (len == 0)\n+    return 0;\n+\n+  targs = get_bindings_order (pat1, DECL_TEMPLATE_RESULT (pat2), len);\n   if (targs)\n     --winner;\n \n-  targs\n-    = get_bindings_overload (pat2, DECL_TEMPLATE_RESULT (pat1), explicit_args);\n+  targs = get_bindings_order (pat2, DECL_TEMPLATE_RESULT (pat1), len);\n   if (targs)\n     ++winner;\n \n@@ -8911,12 +8919,12 @@ more_specialized_class (pat1, pat2)\n    DECL from the function template FN, with the explicit template\n    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must\n    also match.  Return NULL_TREE if no satisfactory arguments could be\n-   found.  */\n-\n+   found.  LEN is passed through to fn_type_unification.  */\n+   \n static tree\n-get_bindings_real (fn, decl, explicit_args, check_rettype)\n+get_bindings_real (fn, decl, explicit_args, check_rettype, len)\n      tree fn, decl, explicit_args;\n-     int check_rettype;\n+     int check_rettype, len;\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_tree_vec (ntparms);\n@@ -8953,18 +8961,16 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n \treturn NULL_TREE;\n     }\n \n-  /* If FN is a static member function, adjust the type of DECL\n-     appropriately.  */\n   decl_arg_types = TYPE_ARG_TYPES (decl_type);\n-  if (DECL_STATIC_FUNCTION_P (fn) \n-      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+  /* Never do unification on the 'this' parameter.  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n     decl_arg_types = TREE_CHAIN (decl_arg_types);\n \n   i = fn_type_unification (fn, explicit_args, targs, \n \t\t\t   decl_arg_types,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t                    ? TREE_TYPE (decl_type) : NULL_TREE),\n-\t\t\t   DEDUCE_EXACT);\n+\t\t\t   DEDUCE_EXACT, len);\n \n   if (i != 0)\n     return NULL_TREE;\n@@ -8978,16 +8984,27 @@ tree\n get_bindings (fn, decl, explicit_args)\n      tree fn, decl, explicit_args;\n {\n-  return get_bindings_real (fn, decl, explicit_args, 1);\n+  return get_bindings_real (fn, decl, explicit_args, 1, -1);\n }\n \n-/* But for more_specialized, we only care about the parameter types.  */\n+/* But for resolve_overloaded_unification, we only care about the parameter\n+   types.  */\n \n static tree\n get_bindings_overload (fn, decl, explicit_args)\n      tree fn, decl, explicit_args;\n {\n-  return get_bindings_real (fn, decl, explicit_args, 0);\n+  return get_bindings_real (fn, decl, explicit_args, 0, -1);\n+}\n+\n+/* And for more_specialized, we want to be able to stop partway.  */\n+\n+static tree\n+get_bindings_order (fn, decl, len)\n+     tree fn, decl;\n+     int len;\n+{\n+  return get_bindings_real (fn, decl, NULL_TREE, 0, len);\n }\n \n /* Return the innermost template arguments that, when applied to a\n@@ -9029,15 +9046,13 @@ get_class_bindings (tparms, parms, args)\n /* In INSTANTIATIONS is a list of <INSTANTIATION, TEMPLATE> pairs.\n    Pick the most specialized template, and return the corresponding\n    instantiation, or if there is no corresponding instantiation, the\n-   template itself.  EXPLICIT_ARGS is any template arguments explicitly\n-   mentioned in a template-id.  If there is no most specialized\n-   template, error_mark_node is returned.  If there are no templates\n-   at all, NULL_TREE is returned.  */\n+   template itself.  If there is no most specialized template,\n+   error_mark_node is returned.  If there are no templates at all,\n+   NULL_TREE is returned.  */\n \n tree\n-most_specialized_instantiation (instantiations, explicit_args)\n+most_specialized_instantiation (instantiations)\n      tree instantiations;\n-     tree explicit_args;\n {\n   tree fn, champ;\n   int fate;\n@@ -9048,8 +9063,7 @@ most_specialized_instantiation (instantiations, explicit_args)\n   champ = instantiations;\n   for (fn = TREE_CHAIN (instantiations); fn; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (TREE_VALUE (champ), \n-\t\t\t       TREE_VALUE (fn), explicit_args);\n+      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn), -1);\n       if (fate == 1)\n \t;\n       else\n@@ -9066,8 +9080,7 @@ most_specialized_instantiation (instantiations, explicit_args)\n \n   for (fn = instantiations; fn && fn != champ; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (TREE_VALUE (champ), \n-\t\t\t       TREE_VALUE (fn), explicit_args);\n+      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn), -1);\n       if (fate != 1)\n \treturn error_mark_node;\n     }\n@@ -9095,7 +9108,7 @@ most_specialized (fns, decl, explicit_args)\n \tcandidates = tree_cons (NULL_TREE, candidate, candidates);\n     }\n \n-  return most_specialized_instantiation (candidates, explicit_args);\n+  return most_specialized_instantiation (candidates);\n }\n \n /* If DECL is a specialization of some template, return the most"}, {"sha": "fa5ebdaa0544056f1d44caf2e803fdff3c9fae99", "filename": "gcc/testsuite/g++.old-deja/g++.pt/partial5.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fpartial5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5214479a779ad44390aec0694c11c5493aaad83/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fpartial5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fpartial5.C?ref=e5214479a779ad44390aec0694c11c5493aaad83", "patch": "@@ -0,0 +1,18 @@\n+// Test that partial ordering ignores defaulted parms and 'this'.\n+\n+struct A {\n+  template<class T> int f(T) { return 1; }\n+  template<class T> int f(T*, int=0) { return 0; }\n+  template<class T> int g(T*) { return 0; }\n+  template<class T> static int g(T, int=0) { return 1; }\n+  template<class T> int h(T*) { return 0; }\n+  template<class T> static int h(T, int=0) { return 1; }\n+  template<class T> static int j(T*, short y=0) { return 0; }\n+  template<class T> static int j(T, int=0) { return 1; }\n+};\n+\n+int main(void) {\n+  A a;\n+  int *p;\n+  return (a.f(p) || a.g(p) || a.h(p) || a.j(p));\n+}"}]}