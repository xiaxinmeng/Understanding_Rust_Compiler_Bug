{"sha": "1be38ccb1b4a2208403ffe980073d6ed2bb61490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJlMzhjY2IxYjRhMjIwODQwM2ZmZTk4MDA3M2Q2ZWQyYmI2MTQ5MA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-12T10:36:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-12T10:36:08Z"}, "message": "tree-flow.h (struct ptr_info_def): Add align and misalign fields.\n\n2010-08-12  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (struct ptr_info_def): Add align and misalign fields.\n\t* tree-ssa-alias.c (get_ptr_info): Move ...\n\t* tree-ssanames.c (get_ptr_info): ... here.  Initialize\n\talign and misalign fields conservatively.\n\t* tree-ssa-ccp.c (ccp_finalize): From partially constant pointers\n\tderive alignment information.\n\t(evaluate_stmt): Derive alignment information from memory\n\tallocation functions.\n\t* tree.h (get_pointer_alignment): Make unsigned.\n\t* builtins.c (get_object_alignment): Use alignment information we\n\thave computed for pointers.\n\t(get_pointer_alignment): Likewise.  Make conservative, return\n\tand unsigned value.\n\t(expand_builtin_strlen): Adjust.\n\t(expand_builtin_memcmp): Likewise.\n\t(expand_builtin_strcmp): Likewise.\n\t(expand_builtin_strncmp): Likewise.\n\t(get_builtin_sync_mem): Use at least mode alignment.\n\t(fold_builtin_memset): Adjust.\n\t(fold_builtin_memory_op): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_phi): Alongside alias\n\tinformation also dump pointer alignment knowledge.\n\t(dump_gimple_stmt): Likewise.\n\nFrom-SVN: r163189", "tree": {"sha": "9a3a2a1cd2ab3e673bfae829eadbac8146e824a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a3a2a1cd2ab3e673bfae829eadbac8146e824a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1be38ccb1b4a2208403ffe980073d6ed2bb61490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be38ccb1b4a2208403ffe980073d6ed2bb61490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be38ccb1b4a2208403ffe980073d6ed2bb61490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be38ccb1b4a2208403ffe980073d6ed2bb61490/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a96ad3486e4f3a949bcfccf5aecbd1b5e35c5307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96ad3486e4f3a949bcfccf5aecbd1b5e35c5307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96ad3486e4f3a949bcfccf5aecbd1b5e35c5307"}], "stats": {"total": 319, "additions": 224, "deletions": 95}, "files": [{"sha": "61b30e9f751ce90e79a79ab98057939c7c43e92f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -1,3 +1,29 @@\n+2010-08-12  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (struct ptr_info_def): Add align and misalign fields.\n+\t* tree-ssa-alias.c (get_ptr_info): Move ...\n+\t* tree-ssanames.c (get_ptr_info): ... here.  Initialize\n+\talign and misalign fields conservatively.\n+\t* tree-ssa-ccp.c (ccp_finalize): From partially constant pointers\n+\tderive alignment information.\n+\t(evaluate_stmt): Derive alignment information from memory\n+\tallocation functions.\n+\t* tree.h (get_pointer_alignment): Make unsigned.\n+\t* builtins.c (get_object_alignment): Use alignment information we\n+\thave computed for pointers.\n+\t(get_pointer_alignment): Likewise.  Make conservative, return\n+\tand unsigned value.\n+\t(expand_builtin_strlen): Adjust.\n+\t(expand_builtin_memcmp): Likewise.\n+\t(expand_builtin_strcmp): Likewise.\n+\t(expand_builtin_strncmp): Likewise.\n+\t(get_builtin_sync_mem): Use at least mode alignment.\n+\t(fold_builtin_memset): Adjust.\n+\t(fold_builtin_memory_op): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_phi): Alongside alias\n+\tinformation also dump pointer alignment knowledge.\n+\t(dump_gimple_stmt): Likewise.\n+\n 2010-08-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (LONG_TYPE_SIZE): Remove."}, {"sha": "ad5d6aae048f738b9e667687534c93d12d1f06d3", "filename": "gcc/builtins.c", "status": "modified", "additions": 78, "deletions": 62, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -309,6 +309,7 @@ get_object_alignment (tree exp, unsigned int max_align)\n   else if (TREE_CODE (exp) == MEM_REF)\n     {\n       tree addr = TREE_OPERAND (exp, 0);\n+      struct ptr_info_def *pi;\n       if (TREE_CODE (addr) == BIT_AND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n \t{\n@@ -319,11 +320,52 @@ get_object_alignment (tree exp, unsigned int max_align)\n \t}\n       else\n \talign = BITS_PER_UNIT;\n-      if (TREE_CODE (addr) == ADDR_EXPR)\n+      if (TREE_CODE (addr) == SSA_NAME\n+\t  && (pi = SSA_NAME_PTR_INFO (addr)))\n+\t{\n+\t  bitpos += (pi->misalign * BITS_PER_UNIT) & ~(align - 1);\n+\t  align = MAX (pi->align * BITS_PER_UNIT, align);\n+\t}\n+      else if (TREE_CODE (addr) == ADDR_EXPR)\n \talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0),\n \t\t\t\t\t\t  max_align));\n       bitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n     }\n+  else if (TREE_CODE (exp) == TARGET_MEM_REF\n+\t   && TMR_BASE (exp)\n+\t   && POINTER_TYPE_P (TREE_TYPE (TMR_BASE (exp))))\n+    {\n+      struct ptr_info_def *pi;\n+      tree addr = TMR_BASE (exp);\n+      if (TREE_CODE (addr) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n+\t{\n+\t  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))\n+\t\t   & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));\n+\t  align *= BITS_PER_UNIT;\n+\t  addr = TREE_OPERAND (addr, 0);\n+\t}\n+      else\n+\talign = BITS_PER_UNIT;\n+      if (TREE_CODE (addr) == SSA_NAME\n+\t  && (pi = SSA_NAME_PTR_INFO (addr)))\n+\t{\n+\t  bitpos += (pi->misalign * BITS_PER_UNIT) & ~(align - 1);\n+\t  align = MAX (pi->align * BITS_PER_UNIT, align);\n+\t}\n+      else if (TREE_CODE (addr) == ADDR_EXPR)\n+\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0),\n+\t\t\t\t\t\t  max_align));\n+      if (TMR_OFFSET (exp))\n+\tbitpos += TREE_INT_CST_LOW (TMR_OFFSET (exp)) * BITS_PER_UNIT;\n+      if (TMR_INDEX (exp) && TMR_STEP (exp))\n+\t{\n+\t  unsigned HOST_WIDE_INT step = TREE_INT_CST_LOW (TMR_STEP (exp));\n+\t  align = MIN (align, (step & -step) * BITS_PER_UNIT);\n+\t}\n+      else if (TMR_INDEX (exp))\n+\talign = BITS_PER_UNIT;\n+    }\n   else if (TREE_CODE (exp) == TARGET_MEM_REF\n \t   && TMR_SYMBOL (exp))\n     {\n@@ -417,56 +459,28 @@ can_trust_pointer_alignment (void)\n    Otherwise, look at the expression to see if we can do better, i.e., if the\n    expression is actually pointing at an object whose alignment is tighter.  */\n \n-int\n+unsigned int\n get_pointer_alignment (tree exp, unsigned int max_align)\n {\n-  unsigned int align, inner;\n-\n-  if (!can_trust_pointer_alignment ())\n-    return 0;\n-\n-  if (!POINTER_TYPE_P (TREE_TYPE (exp)))\n-    return 0;\n-\n-  align = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n-  align = MIN (align, max_align);\n-\n-  while (1)\n-    {\n-      switch (TREE_CODE (exp))\n-\t{\n-\tCASE_CONVERT:\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  if (! POINTER_TYPE_P (TREE_TYPE (exp)))\n-\t    return align;\n-\n-\t  inner = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n-\t  align = MIN (inner, max_align);\n-\t  break;\n-\n-\tcase POINTER_PLUS_EXPR:\n-\t  /* If sum of pointer + int, restrict our maximum alignment to that\n-\t     imposed by the integer.  If not, we can't do any better than\n-\t     ALIGN.  */\n-\t  if (! host_integerp (TREE_OPERAND (exp, 1), 1))\n-\t    return align;\n-\n-\t  while (((tree_low_cst (TREE_OPERAND (exp, 1), 1))\n-\t\t  & (max_align / BITS_PER_UNIT - 1))\n-\t\t != 0)\n-\t    max_align >>= 1;\n-\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  break;\n-\n-\tcase ADDR_EXPR:\n-\t  /* See what we are pointing at and look at its alignment.  */\n-\t  return get_object_alignment (TREE_OPERAND (exp, 0), max_align);\n+  STRIP_NOPS (exp);\n \n-\tdefault:\n-\t  return align;\n-\t}\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    return get_object_alignment (TREE_OPERAND (exp, 0), max_align);\n+  else if (TREE_CODE (exp) == SSA_NAME\n+\t   && POINTER_TYPE_P (TREE_TYPE (exp)))\n+    {\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (exp);\n+      unsigned align;\n+      if (!pi)\n+\treturn BITS_PER_UNIT;\n+      if (pi->misalign != 0)\n+\talign = (pi->misalign & -pi->misalign);\n+      else\n+\talign = pi->align;\n+      return MIN (max_align, align * BITS_PER_UNIT);\n     }\n+\n+  return POINTER_TYPE_P (TREE_TYPE (exp)) ? BITS_PER_UNIT : 0;\n }\n \n /* Compute the length of a C string.  TREE_STRING_LENGTH is not the right\n@@ -3293,7 +3307,7 @@ expand_builtin_strlen (tree exp, rtx target,\n       rtx result, src_reg, char_rtx, before_strlen;\n       enum machine_mode insn_mode = target_mode, char_mode;\n       enum insn_code icode = CODE_FOR_nothing;\n-      int align;\n+      unsigned int align;\n \n       /* If the length can be computed at compile-time, return it.  */\n       len = c_strlen (src, 0);\n@@ -4066,9 +4080,9 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     tree arg2 = CALL_EXPR_ARG (exp, 1);\n     tree len = CALL_EXPR_ARG (exp, 2);\n \n-    int arg1_align\n+    unsigned int arg1_align\n       = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-    int arg2_align\n+    unsigned int arg2_align\n       = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n     enum machine_mode insn_mode;\n \n@@ -4168,9 +4182,9 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n       tree arg1 = CALL_EXPR_ARG (exp, 0);\n       tree arg2 = CALL_EXPR_ARG (exp, 1);\n \n-      int arg1_align\n+      unsigned int arg1_align\n \t= get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-      int arg2_align\n+      unsigned int arg2_align\n \t= get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n \n       /* If we don't have POINTER_TYPE, call the function.  */\n@@ -4319,9 +4333,9 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     tree arg2 = CALL_EXPR_ARG (exp, 1);\n     tree arg3 = CALL_EXPR_ARG (exp, 2);\n \n-    int arg1_align\n+    unsigned int arg1_align\n       = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-    int arg2_align\n+    unsigned int arg2_align\n       = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n     enum machine_mode insn_mode\n       = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n@@ -5505,7 +5519,9 @@ get_builtin_sync_mem (tree loc, enum machine_mode mode)\n      satisfy the full barrier semantics of the intrinsic.  */\n   mem = validize_mem (gen_rtx_MEM (mode, addr));\n \n-  set_mem_align (mem, get_pointer_alignment (loc, BIGGEST_ALIGNMENT));\n+  /* The alignment needs to be at least according to that of the mode.  */\n+  set_mem_align (mem, MAX (GET_MODE_ALIGNMENT (mode),\n+\t\t\t   get_pointer_alignment (loc, BIGGEST_ALIGNMENT)));\n   set_mem_alias_set (mem, ALIAS_SET_MEMORY_BARRIER);\n   MEM_VOLATILE_P (mem) = 1;\n \n@@ -8280,7 +8296,7 @@ fold_builtin_memset (location_t loc, tree dest, tree c, tree len,\n   length = tree_low_cst (len, 1);\n   if (GET_MODE_SIZE (TYPE_MODE (etype)) != length\n       || get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n-\t < (int) length)\n+\t < length)\n     return NULL_TREE;\n \n   if (length > HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT)\n@@ -8365,7 +8381,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n   else\n     {\n       tree srctype, desttype;\n-      int src_align, dest_align;\n+      unsigned int src_align, dest_align;\n       tree off0;\n \n       if (endp == 3)\n@@ -8504,8 +8520,8 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \n       src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n       dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n-      if (dest_align < (int) TYPE_ALIGN (desttype)\n-\t  || src_align < (int) TYPE_ALIGN (srctype))\n+      if (dest_align < TYPE_ALIGN (desttype)\n+\t  || src_align < TYPE_ALIGN (srctype))\n \treturn NULL_TREE;\n \n       if (!ignore)\n@@ -8531,7 +8547,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t  && tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len)\n \t  && (!STRICT_ALIGNMENT\n \t      || !destvar\n-\t      || src_align >= (int) TYPE_ALIGN (desttype)))\n+\t      || src_align >= TYPE_ALIGN (desttype)))\n \tsrcvar = fold_build2 (MEM_REF, destvar ? desttype : srctype,\n \t\t\t      srcvar, off0);\n       else\n@@ -8543,15 +8559,15 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n       if (srcvar == NULL_TREE)\n \t{\n \t  if (STRICT_ALIGNMENT\n-\t      && src_align < (int) TYPE_ALIGN (desttype))\n+\t      && src_align < TYPE_ALIGN (desttype))\n \t    return NULL_TREE;\n \t  STRIP_NOPS (src);\n \t  srcvar = fold_build2 (MEM_REF, desttype, src, off0);\n \t}\n       else if (destvar == NULL_TREE)\n \t{\n \t  if (STRICT_ALIGNMENT\n-\t      && dest_align < (int) TYPE_ALIGN (srctype))\n+\t      && dest_align < TYPE_ALIGN (srctype))\n \t    return NULL_TREE;\n \t  STRIP_NOPS (dest);\n \t  destvar = fold_build2 (MEM_REF, srctype, dest, off0);"}, {"sha": "941d3236eeaba1c1bbe4dc46a171dd231ee03575", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -1363,8 +1363,13 @@ dump_gimple_phi (pretty_printer *buffer, gimple phi, int spc, int flags)\n       && POINTER_TYPE_P (TREE_TYPE (lhs))\n       && SSA_NAME_PTR_INFO (lhs))\n     {\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);\n       pp_string (buffer, \"PT = \");\n-      pp_points_to_solution (buffer, &SSA_NAME_PTR_INFO (lhs)->pt);\n+      pp_points_to_solution (buffer, &pi->pt);\n+      newline_and_indent (buffer, spc);\n+      if (pi->align != 1)\n+\tpp_printf (buffer, \"# ALIGN = %u, MISALIGN = %u\",\n+\t\t   pi->align, pi->misalign);\n       newline_and_indent (buffer, spc);\n       pp_string (buffer, \"# \");\n     }\n@@ -1650,9 +1655,16 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t  && POINTER_TYPE_P (TREE_TYPE (lhs))\n \t  && SSA_NAME_PTR_INFO (lhs))\n \t{\n+\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);\n \t  pp_string (buffer, \"# PT = \");\n-\t  pp_points_to_solution (buffer, &SSA_NAME_PTR_INFO (lhs)->pt);\n+\t  pp_points_to_solution (buffer, &pi->pt);\n \t  newline_and_indent (buffer, spc);\n+\t  if (pi->align != 1)\n+\t    {\n+\t      pp_printf (buffer, \"# ALIGN = %u, MISALIGN = %u\",\n+\t\t\t pi->align, pi->misalign);\n+\t      newline_and_indent (buffer, spc);\n+\t    }\n \t}\n     }\n "}, {"sha": "04ba5325f11f0eca6a679bfd6635b9f37b81de09", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -119,6 +119,18 @@ struct GTY(()) ptr_info_def\n {\n   /* The points-to solution.  */\n   struct pt_solution pt;\n+\n+  /* Alignment and misalignment of the pointer in bytes.  Together\n+     align and misalign specify low known bits of the pointer.\n+     ptr & (align - 1) == misalign.  */\n+\n+  /* The power-of-two byte alignment of the object this pointer\n+     points into.  This is usually DECL_ALIGN_UNIT for decls and\n+     MALLOC_ABI_ALIGNMENT for allocated storage.  */\n+  unsigned int align;\n+\n+  /* The byte offset this pointer differs from the above alignment.  */\n+  unsigned int misalign;\n };\n \n "}, {"sha": "eddb9b987c3085e396b6f84837e5986a49e28e6e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -368,27 +368,6 @@ debug_alias_info (void)\n }\n \n \n-/* Return the alias information associated with pointer T.  It creates a\n-   new instance if none existed.  */\n-\n-struct ptr_info_def *\n-get_ptr_info (tree t)\n-{\n-  struct ptr_info_def *pi;\n-\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n-\n-  pi = SSA_NAME_PTR_INFO (t);\n-  if (pi == NULL)\n-    {\n-      pi = ggc_alloc_cleared_ptr_info_def ();\n-      pt_solution_reset (&pi->pt);\n-      SSA_NAME_PTR_INFO (t) = pi;\n-    }\n-\n-  return pi;\n-}\n-\n /* Dump the points-to set *PT into FILE.  */\n \n void"}, {"sha": "5551df2d5a30c05994b2ff1bc3f4634c4e334e65", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -839,8 +839,40 @@ static bool\n ccp_finalize (void)\n {\n   bool something_changed;\n+  unsigned i;\n \n   do_dbg_cnt ();\n+\n+  /* Derive alignment and misalignment information from partially\n+     constant pointers in the lattice.  */\n+  for (i = 1; i < num_ssa_names; ++i)\n+    {\n+      tree name = ssa_name (i);\n+      prop_value_t *val;\n+      struct ptr_info_def *pi;\n+      unsigned int tem, align;\n+\n+      if (!name\n+\t  || !POINTER_TYPE_P (TREE_TYPE (name)))\n+\tcontinue;\n+\n+      val = get_value (name);\n+      if (val->lattice_val != CONSTANT\n+\t  || TREE_CODE (val->value) != INTEGER_CST)\n+\tcontinue;\n+\n+      /* Trailing constant bits specify the alignment, trailing value\n+\t bits the misalignment.  */\n+      tem = val->mask.low;\n+      align = (tem & -tem);\n+      if (align == 1)\n+\tcontinue;\n+\n+      pi = get_ptr_info (name);\n+      pi->align = align;\n+      pi->misalign = TREE_INT_CST_LOW (val->value) & (align - 1);\n+    }\n+\n   /* Perform substitutions based on the known constant values.  */\n   something_changed = substitute_and_fold (get_constant_value,\n \t\t\t\t\t   ccp_fold_stmt, true);\n@@ -1981,6 +2013,7 @@ evaluate_stmt (gimple stmt)\n       && !is_constant)\n     {\n       enum gimple_code code = gimple_code (stmt);\n+      tree fndecl;\n       val.lattice_val = VARYING;\n       val.value = NULL_TREE;\n       val.mask = double_int_minus_one;\n@@ -2026,6 +2059,33 @@ evaluate_stmt (gimple stmt)\n \t      || POINTER_TYPE_P (TREE_TYPE (rhs1)))\n \t    val = bit_value_binop (code, TREE_TYPE (rhs1), rhs1, rhs2);\n \t}\n+      else if (code == GIMPLE_CALL\n+\t       && (fndecl = gimple_call_fndecl (stmt))\n+\t       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\t{\n+\t  switch (DECL_FUNCTION_CODE (fndecl))\n+\t    {\n+\t    case BUILT_IN_MALLOC:\n+\t    case BUILT_IN_REALLOC:\n+\t    case BUILT_IN_CALLOC:\n+\t      val.lattice_val = CONSTANT;\n+\t      val.value = build_int_cst (TREE_TYPE (gimple_get_lhs (stmt)), 0);\n+\t      val.mask = shwi_to_double_int\n+\t\t  \t   (~(((HOST_WIDE_INT) MALLOC_ABI_ALIGNMENT)\n+\t\t\t      / BITS_PER_UNIT - 1));\n+\t      break;\n+\n+\t    case BUILT_IN_ALLOCA:\n+\t      val.lattice_val = CONSTANT;\n+\t      val.value = build_int_cst (TREE_TYPE (gimple_get_lhs (stmt)), 0);\n+\t      val.mask = shwi_to_double_int\n+\t\t  \t   (~(((HOST_WIDE_INT) BIGGEST_ALIGNMENT)\n+\t\t\t      / BITS_PER_UNIT - 1));\n+\t      break;\n+\n+\t    default:;\n+\t    }\n+\t}\n       is_constant = (val.lattice_val == CONSTANT);\n     }\n "}, {"sha": "0d63fe9fe637e851f93253e11b766f31a4a7ef37", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -240,20 +240,29 @@ release_ssa_name (tree var)\n     }\n }\n \n-/* Creates a duplicate of a ssa name NAME defined in statement STMT.  */\n \n-tree\n-duplicate_ssa_name (tree name, gimple stmt)\n+/* Return the alias information associated with pointer T.  It creates a\n+   new instance if none existed.  */\n+\n+struct ptr_info_def *\n+get_ptr_info (tree t)\n {\n-  tree new_name = make_ssa_name (SSA_NAME_VAR (name), stmt);\n-  struct ptr_info_def *old_ptr_info = SSA_NAME_PTR_INFO (name);\n+  struct ptr_info_def *pi;\n \n-  if (old_ptr_info)\n-    duplicate_ssa_name_ptr_info (new_name, old_ptr_info);\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (t)));\n \n-  return new_name;\n-}\n+  pi = SSA_NAME_PTR_INFO (t);\n+  if (pi == NULL)\n+    {\n+      pi = ggc_alloc_cleared_ptr_info_def ();\n+      pt_solution_reset (&pi->pt);\n+      pi->align = 1;\n+      pi->misalign = 0;\n+      SSA_NAME_PTR_INFO (t) = pi;\n+    }\n \n+  return pi;\n+}\n \n /* Creates a duplicate of the ptr_info_def at PTR_INFO for use by\n    the SSA name NAME.  */\n@@ -276,6 +285,21 @@ duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)\n }\n \n \n+/* Creates a duplicate of a ssa name NAME tobe defined by statement STMT.  */\n+\n+tree\n+duplicate_ssa_name (tree name, gimple stmt)\n+{\n+  tree new_name = make_ssa_name (SSA_NAME_VAR (name), stmt);\n+  struct ptr_info_def *old_ptr_info = SSA_NAME_PTR_INFO (name);\n+\n+  if (old_ptr_info)\n+    duplicate_ssa_name_ptr_info (new_name, old_ptr_info);\n+\n+  return new_name;\n+}\n+\n+\n /* Release all the SSA_NAMEs created by STMT.  */\n \n void"}, {"sha": "9a3c93d356f64e325a34748488e933c09e214bd5", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be38ccb1b4a2208403ffe980073d6ed2bb61490/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1be38ccb1b4a2208403ffe980073d6ed2bb61490", "patch": "@@ -5033,7 +5033,7 @@ extern tree build_string_literal (int, const char *);\n extern bool validate_arglist (const_tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern bool can_trust_pointer_alignment (void);\n-extern int get_pointer_alignment (tree, unsigned int);\n+extern unsigned int get_pointer_alignment (tree, unsigned int);\n extern bool is_builtin_name (const char *);\n extern bool is_builtin_fn (tree);\n extern unsigned int get_object_alignment (tree, unsigned int);"}]}