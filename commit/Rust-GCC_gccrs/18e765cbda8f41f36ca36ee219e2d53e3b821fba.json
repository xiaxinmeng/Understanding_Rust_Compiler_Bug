{"sha": "18e765cbda8f41f36ca36ee219e2d53e3b821fba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlNzY1Y2JkYThmNDFmMzZjYTM2ZWUyMTllMmQ1M2UzYjgyMWZiYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-19T20:23:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-19T20:23:44Z"}, "message": "[multiple changes]\n\n1998-10-18 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n        * reorg.c (steal_delay_list_from_target) Check for insns that\n        modify the condition codes and effect the direction of the jump\n        in the sequence.\nSat Oct 17 13:09:09 1998  Graham  <grahams@rcp.co.uk>\n        * function.c (purge_addressof_1): Replace call to\n        emit_insns_before() with emit_insn_before().\n\nFrom-SVN: r23189", "tree": {"sha": "342a09e2dec122b2933a81fc78272e3040cf0cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/342a09e2dec122b2933a81fc78272e3040cf0cf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18e765cbda8f41f36ca36ee219e2d53e3b821fba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e765cbda8f41f36ca36ee219e2d53e3b821fba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e765cbda8f41f36ca36ee219e2d53e3b821fba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e765cbda8f41f36ca36ee219e2d53e3b821fba/comments", "author": null, "committer": null, "parents": [{"sha": "ea4d3ff6e081929a77d3306137d175505106de58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4d3ff6e081929a77d3306137d175505106de58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea4d3ff6e081929a77d3306137d175505106de58"}], "stats": {"total": 42, "additions": 35, "deletions": 7}, "files": [{"sha": "85b586ddda23326bdf5d0f0c75d6ece71c2254da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e765cbda8f41f36ca36ee219e2d53e3b821fba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e765cbda8f41f36ca36ee219e2d53e3b821fba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18e765cbda8f41f36ca36ee219e2d53e3b821fba", "patch": "@@ -1,3 +1,14 @@\n+1998-10-18 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n+\n+\t* reorg.c (steal_delay_list_from_target) Check for insns that\n+\tmodify the condition codes and effect the direction of the jump\n+\tin the sequence.\n+\n+Sat Oct 17 13:09:09 1998  Graham  <grahams@rcp.co.uk>\n+\n+\t* function.c (purge_addressof_1): Replace call to\n+        emit_insns_before() with emit_insn_before().\n+\n Mon Oct 19 19:34:03 1998  Mike Stump <mrs@wrs.com>\n \n \t* libgcc2.c (__pure_virtual): Call __terminate instead of _exit."}, {"sha": "e7f6afacdb5a9d350ec802d1d103013ab1aad74a", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e765cbda8f41f36ca36ee219e2d53e3b821fba/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e765cbda8f41f36ca36ee219e2d53e3b821fba/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=18e765cbda8f41f36ca36ee219e2d53e3b821fba", "patch": "@@ -2860,7 +2860,7 @@ purge_addressof_1 (loc, insn, force, store)\n \n       insns = gen_sequence ();\n       end_sequence ();\n-      emit_insns_before (insns, insn);\n+      emit_insn_before (insns, insn);\n       return;\n     }\n   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)"}, {"sha": "9400615e23ab2daafbcaded616f7a41c184e8ee5", "filename": "gcc/reorg.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e765cbda8f41f36ca36ee219e2d53e3b821fba/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e765cbda8f41f36ca36ee219e2d53e3b821fba/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=18e765cbda8f41f36ca36ee219e2d53e3b821fba", "patch": "@@ -61,6 +61,10 @@ Boston, MA 02111-1307, USA.  */\n    we can hoist insns from the fall-through path for forward branches or\n    steal insns from the target of backward branches.\n \n+   The TMS320C3x and C4x have three branch delay slots.  When the three\n+   slots are filled, the branch penalty is zero.  Most insns can fill the\n+   delay slots except jump insns.\n+\n    Three techniques for filling delay slots have been implemented so far:\n \n    (1) `fill_simple_delay_slots' is the simplest, most efficient way\n@@ -1687,6 +1691,7 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n   int must_annul = *pannul_p;\n   int i;\n   int used_annul = 0;\n+  struct resources cc_set;\n \n   /* We can't do anything if there are more delay slots in SEQ than we\n      can handle, or if we don't know that it will be a taken branch.\n@@ -1696,7 +1701,23 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n      Also, exit if the branch has more than one set, since then it is computing\n      other results that can't be ignored, e.g. the HPPA mov&branch instruction.\n      ??? It may be possible to move other sets into INSN in addition to\n-     moving the instructions in the delay slots.  */\n+     moving the instructions in the delay slots.\n+\n+     We can not steal the delay list if one of the instructions in the\n+     current delay_list modifies the condition codes and the jump in the \n+     sequence is a conditional jump. We can not do this because we can\n+     not change the direction of the jump because the condition codes\n+     will effect the direction of the jump in the sequence. */\n+\n+  CLEAR_RESOURCE (&cc_set);\n+  for (temp = delay_list; temp; temp = XEXP (temp, 1))\n+    {\n+      rtx trial = XEXP (temp, 0);\n+\n+      mark_set_resources (trial, &cc_set, 0, 1);\n+      if (insn_references_resource_p (XVECEXP (seq , 0, 0), &cc_set, 0))\n+        return delay_list;\n+    }\n \n   if (XVECLEN (seq, 0) - 1 > slots_remaining\n       || ! condition_dominates_p (condition, XVECEXP (seq, 0, 0))\n@@ -3716,8 +3737,6 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \n \t\t  delay_list = add_to_delay_list (temp, delay_list);\n \n-\t\t  mark_set_resources (trial, &opposite_needed, 0, 1);\n-\n \t\t  if (slots_to_fill == ++(*pslots_filled))\n \t\t    {\n \t\t      /* Even though we have filled all the slots, we\n@@ -3795,9 +3814,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n     {\n       /* If this is the `true' thread, we will want to follow the jump,\n \t so we can only do this if we have taken everything up to here.  */\n-      if (thread_if_true && trial == new_thread\n-\t  && ! insn_references_resource_p (XVECEXP (PATTERN (trial), 0, 0),\n-\t\t\t\t\t   &opposite_needed, 0))\n+      if (thread_if_true && trial == new_thread)\n \tdelay_list\n \t  = steal_delay_list_from_target (insn, condition, PATTERN (trial),\n \t\t\t\t\t  delay_list, &set, &needed,"}]}