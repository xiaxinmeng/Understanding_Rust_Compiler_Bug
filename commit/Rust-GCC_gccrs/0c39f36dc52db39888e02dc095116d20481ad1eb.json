{"sha": "0c39f36dc52db39888e02dc095116d20481ad1eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzOWYzNmRjNTJkYjM5ODg4ZTAyZGMwOTUxMTZkMjA0ODFhZDFlYg==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2016-04-12T16:31:25Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2016-04-12T16:31:25Z"}, "message": "Document C++17/TR29124 C++ Special Math Functions.\n\n2016-04-12  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\tDocument C++17/TR29124 C++ Special Math Functions.\n\t* include/bits/specfun.h: Add Doxygen markup.\n\nFrom-SVN: r234905", "tree": {"sha": "b1cc9de28b8180547e690da8fe52fe9d7063e57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1cc9de28b8180547e690da8fe52fe9d7063e57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c39f36dc52db39888e02dc095116d20481ad1eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c39f36dc52db39888e02dc095116d20481ad1eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c39f36dc52db39888e02dc095116d20481ad1eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c39f36dc52db39888e02dc095116d20481ad1eb/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4619dc11e4ee5177053a2e8aae5f259ad3546f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4619dc11e4ee5177053a2e8aae5f259ad3546f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4619dc11e4ee5177053a2e8aae5f259ad3546f8"}], "stats": {"total": 851, "additions": 833, "deletions": 18}, "files": [{"sha": "4fb711b35d84dbef8cdf82b48f4917a7856fa318", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c39f36dc52db39888e02dc095116d20481ad1eb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c39f36dc52db39888e02dc095116d20481ad1eb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0c39f36dc52db39888e02dc095116d20481ad1eb", "patch": "@@ -1,3 +1,8 @@\n+2016-04-12  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tDocument C++17/TR29124 C++ Special Math Functions.\n+\t* include/bits/specfun.h: Add Doxygen markup.\n+\n 2016-04-07  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/30_threads/thread/70503.cc: Adjust from xfail to pass."}, {"sha": "77bbda36fd89f7a25ea6f8b8bdd873d34865934c", "filename": "libstdc++-v3/include/bits/specfun.h", "status": "modified", "additions": 828, "deletions": 18, "changes": 846, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c39f36dc52db39888e02dc095116d20481ad1eb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fspecfun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c39f36dc52db39888e02dc095116d20481ad1eb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fspecfun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fspecfun.h?ref=0c39f36dc52db39888e02dc095116d20481ad1eb", "patch": "@@ -1,6 +1,6 @@\n // Mathematical Special Functions for -*- C++ -*-\n \n-// Copyright (C) 2006-2015 Free Software Foundation, Inc.\n+// Copyright (C) 2006-2016 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,12 +34,14 @@\n \n #include <bits/c++config.h>\n \n+#define __STDCPP_MATH_SPEC_FUNCS__ 201003L\n+\n+#define __cpp_lib_math_special_functions 201603L\n+\n #if __STDCPP_WANT_MATH_SPEC_FUNCS__ == 0\n # error include <cmath> and define __STDCPP_WANT_MATH_SPEC_FUNCS__\n #endif\n \n-#define __STDCPP_MATH_SPEC_FUNCS__ 201003L\n-\n #include <bits/stl_algobase.h>\n #include <limits>\n #include <type_traits>\n@@ -69,16 +71,182 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n+  /**\n+   * @mainpage Mathematical Special Functions\n+   *\n+   * @section intro Introduction and History\n+   * The first significant library upgrade on the road to C++2011,\n+   * <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf\">\n+   * TR1</a>, included a set of 23 mathematical functions that significantly\n+   * extended the standard transcendental functions inherited from C and declared\n+   * in @<cmath@>.\n+   *\n+   * Although most components from TR1 were eventually adopted for C++11 these\n+   * math functions were left behind out of concern for implementability.\n+   * The math functions were published as a separate international standard\n+   * <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3060.pdf\">\n+   * IS 29124 - Extensions to the C++ Library to Support Mathematical Special\n+   * Functions</a>.\n+   *\n+   * For C++17 these functions were incorporated into the main standard.\n+   *\n+   * @section contents Contents\n+   * The following functions are implemented in namespace @c std:\n+   * - @ref assoc_laguerre \"assoc_laguerre - Associated Laguerre functions\"\n+   * - @ref assoc_legendre \"assoc_legendre - Associated Legendre functions\"\n+   * - @ref beta \"beta - Beta functions\"\n+   * - @ref comp_ellint_1 \"comp_ellint_1 - Complete elliptic functions of the first kind\"\n+   * - @ref comp_ellint_2 \"comp_ellint_2 - Complete elliptic functions of the second kind\"\n+   * - @ref comp_ellint_3 \"comp_ellint_3 - Complete elliptic functions of the third kind\"\n+   * - @ref cyl_bessel_i \"cyl_bessel_i - Regular modified cylindrical Bessel functions\"\n+   * - @ref cyl_bessel_j \"cyl_bessel_j - Cylindrical Bessel functions of the first kind\"\n+   * - @ref cyl_bessel_k \"cyl_bessel_k - Irregular modified cylindrical Bessel functions\"\n+   * - @ref cyl_neumann \"cyl_neumann - Cylindrical Neumann functions or Cylindrical Bessel functions of the second kind\"\n+   * - @ref ellint_1 \"ellint_1 - Incomplete elliptic functions of the first kind\"\n+   * - @ref ellint_2 \"ellint_2 - Incomplete elliptic functions of the second kind\"\n+   * - @ref ellint_3 \"ellint_3 - Incomplete elliptic functions of the third kind\"\n+   * - @ref expint \"expint - The exponential integral\"\n+   * - @ref hermite \"hermite - Hermite polynomials\"\n+   * - @ref laguerre \"laguerre - Laguerre functions\"\n+   * - @ref legendre \"legendre - Legendre polynomials\"\n+   * - @ref riemann_zeta \"riemann_zeta - The Riemann zeta function\"\n+   * - @ref sph_bessel \"sph_bessel - Spherical Bessel functions\"\n+   * - @ref sph_legendre \"sph_legendre - Spherical Legendre functions\"\n+   * - @ref sph_neumann \"sph_neumann - Spherical Neumann functions\"\n+   *\n+   * The hypergeometric functions were stricken from the TR29124 and C++17\n+   * versions of this math library because of implementation concerns.\n+   * However, since they were in the TR1 version and since they are popular\n+   * we kept them as an extension in namespace @c __gnu_cxx:\n+   * - @ref conf_hyperg \"conf_hyperg - Confluent hypergeometric functions\"\n+   * - @ref hyperg \"hyperg - Hypergeometric functions\"\n+   *\n+   * @section general General Features\n+   *\n+   * @subsection promotion Argument Promotion\n+   * The arguments suppled to the non-suffixed functions will be promoted\n+   * according to the following rules:\n+   * 1. If any argument intended to be floating opint is given an integral value\n+   * That integral value is promoted to double.\n+   * 2. All floating point arguments are promoted up to the largest floating\n+   *    point precision among them.\n+   *\n+   * @subsection NaN NaN Arguments\n+   * If any of the floating point arguments supplied to these functions is\n+   * invalid or NaN (std::numeric_limits<Tp>::quiet_NaN),\n+   * the value NaN is returned.\n+   *\n+   * @section impl Implementation\n+   *\n+   * We strive to implement the underlying math with type generic algorithms\n+   * to the greatest extent possible.  In practice, the functions are thin\n+   * wrappers that dispatch to function templates. Type dependence is\n+   * controlled with std::numeric_limits and functions thereof.\n+   *\n+   * We don't promote @c float to @c double or @c double to <tt>long double</tt>\n+   * reflexively.  The goal is for @c float functions to operate more quickly,\n+   * at the cost of @c float accuracy and possibly a smaller domain of validity.\n+   * Similaryly, <tt>long double</tt> should give you more dynamic range\n+   * and slightly more pecision than @c double on many systems.\n+   *\n+   * @section testing Testing\n+   *\n+   * These functions have been tested against equivalent implementations\n+   * from the <a href=\"http://www.gnu.org/software/gsl\">\n+   * Gnu Scientific Library, GSL</a> and\n+   * <a href=\"http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/index.html>Boost</a>\n+   * and the ratio\n+   * @f[\n+   *   \\frac{|f - f_{test}|}{|f_{test}|}\n+   * @f]\n+   * is generally found to be within 10^-15 for 64-bit double on linux-x86_64 systems\n+   * over most of the ranges of validity.\n+   * \n+   * @todo Provide accuracy comparisons on a per-function basis for a small\n+   *       number of targets.\n+   *\n+   * @section bibliography General Bibliography\n+   *\n+   * @see Abramowitz and Stegun: Handbook of Mathematical Functions,\n+   * with Formulas, Graphs, and Mathematical Tables\n+   * Edited by Milton Abramowitz and Irene A. Stegun,\n+   * National Bureau of Standards  Applied Mathematics Series - 55\n+   * Issued June 1964, Tenth Printing, December 1972, with corrections\n+   * Electronic versions of A&S abound including both pdf and navigable html.\n+   * @see for example  http://people.math.sfu.ca/~cbm/aands/\n+   *\n+   * @see The old A&S has been redone as the\n+   * NIST Digital Library of Mathematical Functions: http://dlmf.nist.gov/\n+   * This version is far more navigable and includes more recent work.\n+   *\n+   * @see An Atlas of Functions: with Equator, the Atlas Function Calculator\n+   * 2nd Edition, by Oldham, Keith B., Myland, Jan, Spanier, Jerome\n+   *\n+   * @see Asymptotics and Special Functions by Frank W. J. Olver,\n+   * Academic Press, 1974\n+   *\n+   * @see Numerical Recipes in C, The Art of Scientific Computing,\n+   * by William H. Press, Second Ed., Saul A. Teukolsky,\n+   * William T. Vetterling, and Brian P. Flannery,\n+   * Cambridge University Press, 1992\n+   *\n+   * @see The Special Functions and Their Approximations: Volumes 1 and 2,\n+   * by Yudell L. Luke, Academic Press, 1969\n+   */\n+\n   // Associated Laguerre polynomials\n \n+  /**\n+   * Return the associated Laguerre polynomial of order @c n,\n+   * degree @c m: @f$ L_n^m(x) @f$ for @c float argument.\n+   *\n+   * @see assoc_laguerre for more details.\n+   */\n   inline float\n   assoc_laguerref(unsigned int __n, unsigned int __m, float __x)\n   { return __detail::__assoc_laguerre<float>(__n, __m, __x); }\n \n+  /**\n+   * Return the associated Laguerre polynomial of order @c n,\n+   * degree @c m: @f$ L_n^m(x) @f$.\n+   *\n+   * @see assoc_laguerre for more details.\n+   */\n   inline long double\n   assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)\n   { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }\n \n+  /**\n+   * Return the associated Laguerre polynomial of nonnegative order @c n,\n+   * nonnegative degree @c m and real argument @c x: @f$ L_n^m(x) @f$.\n+   *\n+   * The associated Laguerre function of real degree @f$ \\alpha @f$,\n+   * @f$ L_n^\\alpha(x) @f$, is defined by\n+   * @f[\n+   * \t L_n^\\alpha(x) = \\frac{(\\alpha + 1)_n}{n!}\n+   * \t\t\t {}_1F_1(-n; \\alpha + 1; x)\n+   * @f]\n+   * where @f$ (\\alpha)_n @f$ is the Pochhammer symbol and\n+   * @f$ {}_1F_1(a; c; x) @f$ is the confluent hypergeometric function.\n+   *\n+   * The associated Laguerre polynomial is defined for integral\n+   * degree @f$ \\alpha = m @f$ by:\n+   * @f[\n+   * \t L_n^m(x) = (-1)^m \\frac{d^m}{dx^m} L_{n + m}(x)\n+   * @f]\n+   * where the Laguerre polynomial is defined by:\n+   * @f[\n+   * \t L_n(x) = \\frac{e^x}{n!} \\frac{d^n}{dx^n} (x^ne^{-x})\n+   * @f]\n+   * and @f$ x >= 0 @f$.\n+   * @see laguerre for details of the Laguerre function of degree @c n\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param __n The order of the Laguerre function, <tt>__n >= 0</tt>.\n+   * @param __m The degree of the Laguerre function, <tt>__m >= 0</tt>.\n+   * @param __x The argument of the Laguerre function, <tt>__x >= 0</tt>.\n+   * @throw std::domain_error if <tt>__x < 0</tt>.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)\n@@ -89,14 +257,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Associated Legendre functions\n \n+  /**\n+   * Return the associated Legendre function of degree @c l and order @c m\n+   * for @c float argument.\n+   *\n+   * @see assoc_legendre for more details.\n+   */\n   inline float\n   assoc_legendref(unsigned int __l, unsigned int __m, float __x)\n   { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }\n \n+  /**\n+   * Return the associated Legendre function of degree @c l and order @c m.\n+   *\n+   * @see assoc_legendre for more details.\n+   */\n   inline long double\n   assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)\n   { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }\n \n+\n+  /**\n+   * Return the associated Legendre function of degree @c l and order @c m.\n+   *\n+   * The associated Legendre function is derived from the Legendre function\n+   * @f$ P_l(x) @f$ by the Rodrigues formula:\n+   * @f[\n+   *   P_l^m(x) = (1 - x^2)^{m/2}\\frac{d^m}{dx^m}P_l(x)\n+   * @f]\n+   * @see legendre for details of the Legendre function of degree @c l\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __l  The degree <tt>__l >= 0</tt>.\n+   * @param  __m  The order <tt>__m <= l</tt>.\n+   * @param  __x  The argument, <tt>abs(__x) <= 1</tt>.\n+   * @throw std::domain_error if <tt>abs(__x) > 1</tt>.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)\n@@ -107,32 +303,89 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Beta functions\n \n+  /**\n+   * Return the beta function, @f$ B(a,b) @f$, for @c float parameters @c a, @c b.\n+   *\n+   * @see beta for more details.\n+   */\n   inline float\n-  betaf(float __x, float __y)\n-  { return __detail::__beta<float>(__x, __y); }\n+  betaf(float __a, float __b)\n+  { return __detail::__beta<float>(__a, __b); }\n \n+  /**\n+   * Return the beta function, @f$B(a,b)@f$, for long double\n+   * parameters @c a, @c b.\n+   *\n+   * @see beta for more details.\n+   */\n   inline long double\n-  betal(long double __x, long double __y)\n-  { return __detail::__beta<long double>(__x, __y); }\n+  betal(long double __a, long double __b)\n+  { return __detail::__beta<long double>(__a, __b); }\n \n-  template<typename _Tpx, typename _Tpy>\n-    inline typename __gnu_cxx::__promote_2<_Tpx, _Tpy>::__type\n-    beta(_Tpx __x, _Tpy __y)\n+  /**\n+   * Return the beta function, @f$B(a,b)@f$, for real parameters @c a, @c b.\n+   *\n+   * The beta function is defined by\n+   * @f[\n+   *   B(a,b) = \\int_0^1 t^{a - 1} (1 - t)^{b - 1} dt\n+   *          = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}\n+   * @f]\n+   * where @f$ a > 0 @f$ and @f$ b > 0 @f$\n+   *\n+   * @tparam _Tpa The floating-point type of the parameter @c __a.\n+   * @tparam _Tpb The floating-point type of the parameter @c __b.\n+   * @param __a The first argument of the beta function, <tt> __a > 0 </tt>.\n+   * @param __b The second argument of the beta function, <tt> __b > 0 </tt>.\n+   * @throw std::domain_error if <tt> __a < 0 </tt> or <tt> __b < 0 </tt>.\n+   */\n+  template<typename _Tpa, typename _Tpb>\n+    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type\n+    beta(_Tpa __a, _Tpb __b)\n     {\n-      typedef typename __gnu_cxx::__promote_2<_Tpx, _Tpy>::__type __type;\n-      return __detail::__beta<__type>(__x, __y);\n+      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;\n+      return __detail::__beta<__type>(__a, __b);\n     }\n \n   // Complete elliptic integrals of the first kind\n \n+  /**\n+   * Return the complete elliptic integral of the first kind @f$ E(k) @f$\n+   * for @c float modulus @c k.\n+   *\n+   * @see comp_ellint_1 for details.\n+   */\n   inline float\n   comp_ellint_1f(float __k)\n   { return __detail::__comp_ellint_1<float>(__k); }\n \n+  /**\n+   * Return the complete elliptic integral of the first kind @f$ E(k) @f$\n+   * for long double modulus @c k.\n+   *\n+   * @see comp_ellint_1 for details.\n+   */\n   inline long double\n   comp_ellint_1l(long double __k)\n   { return __detail::__comp_ellint_1<long double>(__k); }\n \n+  /**\n+   * Return the complete elliptic integral of the first kind\n+   * @f$ K(k) @f$ for real modulus @c k.\n+   *\n+   * The complete elliptic integral of the first kind is defined as\n+   * @f[\n+   *   K(k) = F(k,\\pi/2) = \\int_0^{\\pi/2}\\frac{d\\theta}\n+   * \t\t\t\t\t     {\\sqrt{1 - k^2 sin^2\\theta}}\n+   * @f]\n+   * where @f$ F(k,\\phi) @f$ is the incomplete elliptic integral of the\n+   * first kind and the modulus @f$ |k| <= 1 @f$.\n+   * @see ellint_1 for details of the incomplete elliptic function\n+   * of the first kind.\n+   *\n+   * @tparam _Tp The floating-point type of the modulus @c __k.\n+   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>\n+   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     comp_ellint_1(_Tp __k)\n@@ -143,14 +396,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Complete elliptic integrals of the second kind\n \n+  /**\n+   * Return the complete elliptic integral of the second kind @f$ E(k) @f$\n+   * for @c float modulus @c k.\n+   *\n+   * @see comp_ellint_2 for details.\n+   */\n   inline float\n   comp_ellint_2f(float __k)\n   { return __detail::__comp_ellint_2<float>(__k); }\n \n+  /**\n+   * Return the complete elliptic integral of the second kind @f$ E(k) @f$\n+   * for long double modulus @c k.\n+   *\n+   * @see comp_ellint_2 for details.\n+   */\n   inline long double\n   comp_ellint_2l(long double __k)\n   { return __detail::__comp_ellint_2<long double>(__k); }\n \n+  /**\n+   * Return the complete elliptic integral of the second kind @f$ E(k) @f$\n+   * for real modulus @c k.\n+   *\n+   * The complete elliptic integral of the second kind is defined as\n+   * @f[\n+   *   E(k) = E(k,\\pi/2) = \\int_0^{\\pi/2}\\sqrt{1 - k^2 sin^2\\theta}\n+   * @f]\n+   * where @f$ E(k,\\phi) @f$ is the incomplete elliptic integral of the\n+   * second kind and the modulus @f$ |k| <= 1 @f$.\n+   * @see ellint_2 for details of the incomplete elliptic function\n+   * of the second kind.\n+   *\n+   * @tparam _Tp The floating-point type of the modulus @c __k.\n+   * @param  __k  The modulus, @c abs(__k) <= 1\n+   * @throw std::domain_error if @c abs(__k) > 1.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     comp_ellint_2(_Tp __k)\n@@ -161,14 +443,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Complete elliptic integrals of the third kind\n \n+  /**\n+   * @brief Return the complete elliptic integral of the third kind\n+   * @f$ \\Pi(k,\\nu) @f$ for @c float modulus @c k.\n+   *\n+   * @see comp_ellint_3 for details.\n+   */\n   inline float\n   comp_ellint_3f(float __k, float __nu)\n   { return __detail::__comp_ellint_3<float>(__k, __nu); }\n \n+  /**\n+   * @brief Return the complete elliptic integral of the third kind\n+   * @f$ \\Pi(k,\\nu) @f$ for <tt>long double</tt> modulus @c k.\n+   *\n+   * @see comp_ellint_3 for details.\n+   */\n   inline long double\n   comp_ellint_3l(long double __k, long double __nu)\n   { return __detail::__comp_ellint_3<long double>(__k, __nu); }\n \n+  /**\n+   * Return the complete elliptic integral of the third kind\n+   * @f$ \\Pi(k,\\nu) = \\Pi(k,\\nu,\\pi/2) @f$ for real modulus @c k.\n+   *\n+   * The complete elliptic integral of the third kind is defined as\n+   * @f[\n+   *   \\Pi(k,\\nu) = \\Pi(k,\\nu,\\pi/2) = \\int_0^{\\pi/2}\n+   * \t\t     \\frac{d\\theta}\n+   * \t\t   {(1 - \\nu \\sin^2\\theta)\\sqrt{1 - k^2 \\sin^2\\theta}}\n+   * @f]\n+   * where @f$ \\Pi(k,\\nu,\\phi) @f$ is the incomplete elliptic integral of the\n+   * second kind and the modulus @f$ |k| <= 1 @f$.\n+   * @see ellint_3 for details of the incomplete elliptic function\n+   * of the third kind.\n+   *\n+   * @tparam _Tp The floating-point type of the modulus @c __k.\n+   * @tparam _Tpn The floating-point type of the argument @c __nu.\n+   * @param  __k  The modulus, @c abs(__k) <= 1\n+   * @param  __nu  The argument\n+   * @throw std::domain_error if @c abs(__k) > 1.\n+   */\n   template<typename _Tp, typename _Tpn>\n     inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type\n     comp_ellint_3(_Tp __k, _Tpn __nu)\n@@ -179,14 +494,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Regular modified cylindrical Bessel functions\n \n+  /**\n+   * Return the regular modified Bessel function @f$ I_{\\nu}(x) @f$\n+   * for @c float order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * @see cyl_bessel_i for setails.\n+   */\n   inline float\n   cyl_bessel_if(float __nu, float __x)\n   { return __detail::__cyl_bessel_i<float>(__nu, __x); }\n \n+  /**\n+   * Return the regular modified Bessel function @f$ I_{\\nu}(x) @f$\n+   * for <tt>long double</tt> order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * @see cyl_bessel_i for setails.\n+   */\n   inline long double\n   cyl_bessel_il(long double __nu, long double __x)\n   { return __detail::__cyl_bessel_i<long double>(__nu, __x); }\n \n+  /**\n+   * Return the regular modified Bessel function @f$ I_{\\nu}(x) @f$\n+   * for real order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * The regular modified cylindrical Bessel function is:\n+   * @f[\n+   *  I_{\\nu}(x) = i^{-\\nu}J_\\nu(ix) = \\sum_{k=0}^{\\infty}\n+   * \t\t\\frac{(x/2)^{\\nu + 2k}}{k!\\Gamma(\\nu+k+1)}\n+   * @f]\n+   *\n+   * @tparam _Tpnu The floating-point type of the order @c __nu.\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __nu  The order\n+   * @param  __x   The argument, <tt> __x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tpnu, typename _Tp>\n     inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_bessel_i(_Tpnu __nu, _Tp __x)\n@@ -197,14 +540,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Cylindrical Bessel functions (of the first kind)\n \n+  /**\n+   * Return the Bessel function of the first kind @f$ J_{\\nu}(x) @f$\n+   * for @c float order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * @see cyl_bessel_j for setails.\n+   */\n   inline float\n   cyl_bessel_jf(float __nu, float __x)\n   { return __detail::__cyl_bessel_j<float>(__nu, __x); }\n \n+  /**\n+   * Return the Bessel function of the first kind @f$ J_{\\nu}(x) @f$\n+   * for <tt>long double</tt> order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * @see cyl_bessel_j for setails.\n+   */\n   inline long double\n   cyl_bessel_jl(long double __nu, long double __x)\n   { return __detail::__cyl_bessel_j<long double>(__nu, __x); }\n \n+  /**\n+   * Return the Bessel function @f$ J_{\\nu}(x) @f$ of real order @f$ \\nu @f$\n+   * and argument @f$ x >= 0 @f$.\n+   *\n+   * The cylindrical Bessel function is:\n+   * @f[\n+   *    J_{\\nu}(x) = \\sum_{k=0}^{\\infty}\n+   *              \\frac{(-1)^k (x/2)^{\\nu + 2k}}{k!\\Gamma(\\nu+k+1)}\n+   * @f]\n+   *\n+   * @tparam _Tpnu The floating-point type of the order @c __nu.\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __nu  The order\n+   * @param  __x   The argument, <tt> __x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tpnu, typename _Tp>\n     inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_bessel_j(_Tpnu __nu, _Tp __x)\n@@ -215,14 +586,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Irregular modified cylindrical Bessel functions\n \n+  /**\n+   * Return the irregular modified Bessel function @f$ K_{\\nu}(x) @f$\n+   * for @c float order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * @see cyl_bessel_k for setails.\n+   */\n   inline float\n   cyl_bessel_kf(float __nu, float __x)\n   { return __detail::__cyl_bessel_k<float>(__nu, __x); }\n \n+  /**\n+   * Return the irregular modified Bessel function @f$ K_{\\nu}(x) @f$\n+   * for <tt>long double</tt> order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * @see cyl_bessel_k for setails.\n+   */\n   inline long double\n   cyl_bessel_kl(long double __nu, long double __x)\n   { return __detail::__cyl_bessel_k<long double>(__nu, __x); }\n \n+  /**\n+   * Return the irregular modified Bessel function @f$ K_{\\nu}(x) @f$\n+   * of real order @f$ \\nu @f$ and argument @f$ x @f$.\n+   *\n+   * The irregular modified Bessel function is defined by:\n+   * @f[\n+   * \tK_{\\nu}(x) = \\frac{\\pi}{2}\n+   * \t\t     \\frac{I_{-\\nu}(x) - I_{\\nu}(x)}{\\sin \\nu\\pi}\n+   * @f]\n+   * where for integral @f$ \\nu = n @f$ a limit is taken:\n+   * @f$ lim_{\\nu \\to n} @f$.\n+   * For negative argument we have simply:\n+   * @f[\n+   * \tK_{-\\nu}(x) = K_{\\nu}(x)\n+   * @f]\n+   *\n+   * @tparam _Tpnu The floating-point type of the order @c __nu.\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __nu  The order\n+   * @param  __x   The argument, <tt> __x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tpnu, typename _Tp>\n     inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_bessel_k(_Tpnu __nu, _Tp __x)\n@@ -233,14 +638,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Cylindrical Neumann functions\n \n+  /**\n+   * Return the Neumann function @f$ N_{\\nu}(x) @f$\n+   * of @c float order @f$ \\nu @f$ and argument @f$ x @f$.\n+   *\n+   * @see cyl_neumann for setails.\n+   */\n   inline float\n   cyl_neumannf(float __nu, float __x)\n   { return __detail::__cyl_neumann_n<float>(__nu, __x); }\n \n+  /**\n+   * Return the Neumann function @f$ N_{\\nu}(x) @f$\n+   * of <tt>long double</tt> order @f$ \\nu @f$ and argument @f$ x @f$.\n+   *\n+   * @see cyl_neumann for setails.\n+   */\n   inline long double\n   cyl_neumannl(long double __nu, long double __x)\n   { return __detail::__cyl_neumann_n<long double>(__nu, __x); }\n \n+  /**\n+   * Return the Neumann function @f$ N_{\\nu}(x) @f$\n+   * of real order @f$ \\nu @f$ and argument @f$ x >= 0 @f$.\n+   *\n+   * The Neumann function is defined by:\n+   * @f[\n+   *    N_{\\nu}(x) = \\frac{J_{\\nu}(x) \\cos \\nu\\pi - J_{-\\nu}(x)}\n+   *                      {\\sin \\nu\\pi}\n+   * @f]\n+   * where @f$ x >= 0 @f$ and for integral order @f$ \\nu = n @f$\n+   * a limit is taken: @f$ lim_{\\nu \\to n} @f$.\n+   *\n+   * @tparam _Tpnu The floating-point type of the order @c __nu.\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __nu  The order\n+   * @param  __x   The argument, <tt> __x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tpnu, typename _Tp>\n     inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type\n     cyl_neumann(_Tpnu __nu, _Tp __x)\n@@ -251,14 +686,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Incomplete elliptic integrals of the first kind\n \n+  /**\n+   * Return the incomplete elliptic integral of the first kind @f$ E(k,\\phi) @f$\n+   * for @c float modulus @f$ k @f$ and angle @f$ \\phi @f$.\n+   *\n+   * @see ellint_1 for details.\n+   */\n   inline float\n   ellint_1f(float __k, float __phi)\n   { return __detail::__ellint_1<float>(__k, __phi); }\n \n+  /**\n+   * Return the incomplete elliptic integral of the first kind @f$ E(k,\\phi) @f$\n+   * for <tt>long double</tt> modulus @f$ k @f$ and angle @f$ \\phi @f$.\n+   *\n+   * @see ellint_1 for details.\n+   */\n   inline long double\n   ellint_1l(long double __k, long double __phi)\n   { return __detail::__ellint_1<long double>(__k, __phi); }\n \n+  /**\n+   * Return the incomplete elliptic integral of the first kind @f$ F(k,\\phi) @f$\n+   * for @c real modulus @f$ k @f$ and angle @f$ \\phi @f$.\n+   *\n+   * The incomplete elliptic integral of the first kind is defined as\n+   * @f[\n+   *   F(k,\\phi) = \\int_0^{\\phi}\\frac{d\\theta}\n+   * \t\t\t\t     {\\sqrt{1 - k^2 sin^2\\theta}}\n+   * @f]\n+   * For  @f$ \\phi= \\pi/2 @f$ this becomes the complete elliptic integral of\n+   * the first kind, @f$ K(k) @f$.  @see comp_ellint_1.\n+   *\n+   * @tparam _Tp The floating-point type of the modulus @c __k.\n+   * @tparam _Tpp The floating-point type of the angle @c __phi.\n+   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>\n+   * @param  __phi  The integral limit argument in radians\n+   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.\n+   */\n   template<typename _Tp, typename _Tpp>\n     inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type\n     ellint_1(_Tp __k, _Tpp __phi)\n@@ -269,14 +734,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Incomplete elliptic integrals of the second kind\n \n+  /**\n+   * @brief Return the incomplete elliptic integral of the second kind\n+   * @f$ E(k,\\phi) @f$ for @c float argument.\n+   *\n+   * @see ellint_2 for details.\n+   */\n   inline float\n   ellint_2f(float __k, float __phi)\n   { return __detail::__ellint_2<float>(__k, __phi); }\n \n+  /**\n+   * @brief Return the incomplete elliptic integral of the second kind\n+   * @f$ E(k,\\phi) @f$.\n+   *\n+   * @see ellint_2 for details.\n+   */\n   inline long double\n   ellint_2l(long double __k, long double __phi)\n   { return __detail::__ellint_2<long double>(__k, __phi); }\n \n+  /**\n+   * Return the incomplete elliptic integral of the second kind\n+   * @f$ E(k,\\phi) @f$.\n+   *\n+   * The incomplete elliptic integral of the second kind is defined as\n+   * @f[\n+   *   E(k,\\phi) = \\int_0^{\\phi} \\sqrt{1 - k^2 sin^2\\theta}\n+   * @f]\n+   * For  @f$ \\phi= \\pi/2 @f$ this becomes the complete elliptic integral of\n+   * the second kind, @f$ E(k) @f$.  @see comp_ellint_2.\n+   *\n+   * @tparam _Tp The floating-point type of the modulus @c __k.\n+   * @tparam _Tpp The floating-point type of the angle @c __phi.\n+   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>\n+   * @param  __phi  The integral limit argument in radians\n+   * @return  The elliptic function of the second kind.\n+   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.\n+   */\n   template<typename _Tp, typename _Tpp>\n     inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type\n     ellint_2(_Tp __k, _Tpp __phi)\n@@ -287,14 +782,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Incomplete elliptic integrals of the third kind\n \n+  /**\n+   * @brief Return the incomplete elliptic integral of the third kind\n+   * @f$ \\Pi(k,\\nu,\\phi) @f$ for @c float argument.\n+   *\n+   * @see ellint_3 for details.\n+   */\n   inline float\n   ellint_3f(float __k, float __nu, float __phi)\n   { return __detail::__ellint_3<float>(__k, __nu, __phi); }\n \n+  /**\n+   * @brief Return the incomplete elliptic integral of the third kind\n+   * @f$ \\Pi(k,\\nu,\\phi) @f$.\n+   *\n+   * @see ellint_3 for details.\n+   */\n   inline long double\n   ellint_3l(long double __k, long double __nu, long double __phi)\n   { return __detail::__ellint_3<long double>(__k, __nu, __phi); }\n \n+  /**\n+   * @brief Return the incomplete elliptic integral of the third kind\n+   * @f$ \\Pi(k,\\nu,\\phi) @f$.\n+   *\n+   * The incomplete elliptic integral of the third kind is defined by:\n+   * @f[\n+   *   \\Pi(k,\\nu,\\phi) = \\int_0^{\\phi}\n+   * \t\t\t \\frac{d\\theta}\n+   * \t\t\t {(1 - \\nu \\sin^2\\theta)\n+   * \t\t\t  \\sqrt{1 - k^2 \\sin^2\\theta}}\n+   * @f]\n+   * For  @f$ \\phi= \\pi/2 @f$ this becomes the complete elliptic integral of\n+   * the third kind, @f$ \\Pi(k,\\nu) @f$.  @see comp_ellint_3.\n+   *\n+   * @tparam _Tp The floating-point type of the modulus @c __k.\n+   * @tparam _Tpn The floating-point type of the argument @c __nu.\n+   * @tparam _Tpp The floating-point type of the angle @c __phi.\n+   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>\n+   * @param  __nu  The second argument\n+   * @param  __phi  The integral limit argument in radians\n+   * @return  The elliptic function of the third kind.\n+   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.\n+   */\n   template<typename _Tp, typename _Tpn, typename _Tpp>\n     inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type\n     ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)\n@@ -305,14 +835,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Exponential integrals\n \n+  /**\n+   * Return the exponential integral @f$ Ei(x) @f$ for @c float argument @c x.\n+   *\n+   * @see expint for details.\n+   */\n   inline float\n   expintf(float __x)\n   { return __detail::__expint<float>(__x); }\n \n+  /**\n+   * Return the exponential integral @f$ Ei(x) @f$\n+   * for <tt>long double</tt> argument @c x.\n+   *\n+   * @see expint for details.\n+   */\n   inline long double\n   expintl(long double __x)\n   { return __detail::__expint<long double>(__x); }\n \n+  /**\n+   * Return the exponential integral @f$ Ei(x) @f$ for @c real argument @c x.\n+   *\n+   * The exponential integral is given by\n+   * \\f[\n+   *   Ei(x) = -\\int_{-x}^\\infty \\frac{e^t}{t} dt\n+   * \\f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __x  The argument of the exponential integral function.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     expint(_Tp __x)\n@@ -323,14 +875,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Hermite polynomials\n \n+  /**\n+   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n\n+   * and float argument @c x.\n+   *\n+   * @see hermite for details.\n+   */\n   inline float\n   hermitef(unsigned int __n, float __x)\n   { return __detail::__poly_hermite<float>(__n, __x); }\n \n+  /**\n+   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n\n+   * and <tt>long double</tt> argument @c x.\n+   *\n+   * @see hermite for details.\n+   */\n   inline long double\n   hermitel(unsigned int __n, long double __x)\n   { return __detail::__poly_hermite<long double>(__n, __x); }\n \n+  /**\n+   * Return the Hermite polynomial @f$ H_n(x) @f$ of order n\n+   * and @c real argument @c x.\n+   *\n+   * The Hermite polynomial is defined by:\n+   * @f[\n+   *   H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2}\n+   * @f]\n+   *\n+   * The Hermite polynomial obeys a reflection formula:\n+   * @f[\n+   *   H_n(-x) = (-1)^n H_n(x)\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param __n The order\n+   * @param __x The argument\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     hermite(unsigned int __n, _Tp __x)\n@@ -341,14 +923,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Laguerre polynomials\n \n+  /**\n+   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n\n+   * and @c float argument  @f$ x >= 0 @f$.\n+   *\n+   * @see laguerre for more details.\n+   */\n   inline float\n   laguerref(unsigned int __n, float __x)\n   { return __detail::__laguerre<float>(__n, __x); }\n \n+  /**\n+   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n\n+   * and <tt>long double</tt> argument @f$ x >= 0 @f$.\n+   *\n+   * @see laguerre for more details.\n+   */\n   inline long double\n   laguerrel(unsigned int __n, long double __x)\n   { return __detail::__laguerre<long double>(__n, __x); }\n \n+  /**\n+   * Returns the Laguerre polynomial @f$ L_n(x) @f$\n+   * of nonnegative degree @c n and real argument @f$ x >= 0 @f$.\n+   *\n+   * The Laguerre polynomial is defined by:\n+   * @f[\n+   * \t L_n(x) = \\frac{e^x}{n!} \\frac{d^n}{dx^n} (x^ne^{-x})\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param __n The nonnegative order\n+   * @param __x The argument <tt> __x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     laguerre(unsigned int __n, _Tp __x)\n@@ -359,32 +967,92 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Legendre polynomials\n \n+  /**\n+   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative\n+   * degree @f$ l @f$ and @c float argument @f$ |x| <= 0 @f$.\n+   *\n+   * @see legendre for more details.\n+   */\n   inline float\n-  legendref(unsigned int __n, float __x)\n-  { return __detail::__poly_legendre_p<float>(__n, __x); }\n+  legendref(unsigned int __l, float __x)\n+  { return __detail::__poly_legendre_p<float>(__l, __x); }\n \n+  /**\n+   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative\n+   * degree @f$ l @f$ and <tt>long double</tt> argument @f$ |x| <= 0 @f$.\n+   *\n+   * @see legendre for more details.\n+   */\n   inline long double\n-  legendrel(unsigned int __n, long double __x)\n-  { return __detail::__poly_legendre_p<long double>(__n, __x); }\n+  legendrel(unsigned int __l, long double __x)\n+  { return __detail::__poly_legendre_p<long double>(__l, __x); }\n \n+  /**\n+   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative\n+   * degree @f$ l @f$ and real argument @f$ |x| <= 0 @f$.\n+   *\n+   * The Legendre function of order @f$ l @f$ and argument @f$ x @f$,\n+   * @f$ P_l(x) @f$, is defined by:\n+   * @f[\n+   *   P_l(x) = \\frac{1}{2^l l!}\\frac{d^l}{dx^l}(x^2 - 1)^{l}\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param __l The degree @f$ l >= 0 @f$\n+   * @param __x The argument @c abs(__x) <= 1\n+   * @throw std::domain_error if @c abs(__x) > 1\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n-    legendre(unsigned int __n, _Tp __x)\n+    legendre(unsigned int __l, _Tp __x)\n     {\n       typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n-      return __detail::__poly_legendre_p<__type>(__n, __x);\n+      return __detail::__poly_legendre_p<__type>(__l, __x);\n     }\n \n   // Riemann zeta functions\n \n+  /**\n+   * Return the Riemann zeta function @f$ \\zeta(s) @f$\n+   * for @c float argument @f$ s @f$.\n+   *\n+   * @see riemann_zeta for more details.\n+   */\n   inline float\n   riemann_zetaf(float __s)\n   { return __detail::__riemann_zeta<float>(__s); }\n \n+  /**\n+   * Return the Riemann zeta function @f$ \\zeta(s) @f$\n+   * for <tt>long double</tt> argument @f$ s @f$.\n+   *\n+   * @see riemann_zeta for more details.\n+   */\n   inline long double\n   riemann_zetal(long double __s)\n   { return __detail::__riemann_zeta<long double>(__s); }\n \n+  /**\n+   * Return the Riemann zeta function @f$ \\zeta(s) @f$\n+   * for real argument @f$ s @f$.\n+   *\n+   * The Riemann zeta function is defined by:\n+   * @f[\n+   * \t\\zeta(s) = \\sum_{k=1}^{\\infty} k^{-s} \\hbox{ for } s > 1\n+   * @f]\n+   * and\n+   * @f[\n+   * \t\\zeta(s) = \\frac{1}{1-2^{1-s}}\\sum_{k=1}^{\\infty}(-1)^{k-1}k^{-s}\n+   *              \\hbox{ for } 0 <= s <= 1\n+   * @f]\n+   * For s < 1 use the reflection formula:\n+   * @f[\n+   * \t\\zeta(s) = 2^s \\pi^{s-1} \\sin(\\frac{\\pi s}{2}) \\Gamma(1-s) \\zeta(1-s)\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __s.\n+   * @param __s The argument <tt> s != 1 </tt>\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     riemann_zeta(_Tp __s)\n@@ -395,14 +1063,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Spherical Bessel functions\n \n+  /**\n+   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n\n+   * and @c float argument @f$ x >= 0 @f$.\n+   *\n+   * @see sph_bessel for more details.\n+   */\n   inline float\n   sph_besself(unsigned int __n, float __x)\n   { return __detail::__sph_bessel<float>(__n, __x); }\n \n+  /**\n+   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n\n+   * and <tt>long double</tt> argument @f$ x >= 0 @f$.\n+   *\n+   * @see sph_bessel for more details.\n+   */\n   inline long double\n   sph_bessell(unsigned int __n, long double __x)\n   { return __detail::__sph_bessel<long double>(__n, __x); }\n \n+  /**\n+   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n\n+   * and real argument @f$ x >= 0 @f$.\n+   *\n+   * The spherical Bessel function is defined by:\n+   * @f[\n+   *  j_n(x) = \\left(\\frac{\\pi}{2x} \\right) ^{1/2} J_{n+1/2}(x)\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __n  The integral order <tt> n >= 0 </tt>\n+   * @param  __x  The real argument <tt> x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     sph_bessel(unsigned int __n, _Tp __x)\n@@ -413,14 +1107,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Spherical associated Legendre functions\n \n+  /**\n+   * Return the spherical Legendre function of nonnegative integral\n+   * degree @c l and order @c m and float angle @f$ \\theta @f$ in radians.\n+   *\n+   * @see sph_legendre for details.\n+   */\n   inline float\n   sph_legendref(unsigned int __l, unsigned int __m, float __theta)\n   { return __detail::__sph_legendre<float>(__l, __m, __theta); }\n \n+  /**\n+   * Return the spherical Legendre function of nonnegative integral\n+   * degree @c l and order @c m and <tt>long double</tt> angle @f$ \\theta @f$\n+   * in radians.\n+   *\n+   * @see sph_legendre for details.\n+   */\n   inline long double\n   sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)\n   { return __detail::__sph_legendre<long double>(__l, __m, __theta); }\n \n+  /**\n+   * Return the spherical Legendre function of nonnegative integral\n+   * degree @c l and order @c m and real angle @f$ \\theta @f$ in radians.\n+   *\n+   * The spherical Legendre function is defined by\n+   * @f[\n+   *  Y_l^m(\\theta,\\phi) = (-1)^m[\\frac{(2l+1)}{4\\pi}\n+   *                              \\frac{(l-m)!}{(l+m)!}]\n+   *                   P_l^m(\\cos\\theta) \\exp^{im\\phi}\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the angle @c __theta.\n+   * @param __l The order <tt> __l >= 0 </tt>\n+   * @param __m The degree <tt> __m >= 0 </tt> and <tt> __m <= __l </tt>\n+   * @param __theta The radian polar angle argument\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)\n@@ -431,14 +1154,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Spherical Neumann functions\n \n+  /**\n+   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$\n+   * and @c float argument @f$ x >= 0 @f$.\n+   *\n+   * @see sph_neumann for details.\n+   */\n   inline float\n   sph_neumannf(unsigned int __n, float __x)\n   { return __detail::__sph_neumann<float>(__n, __x); }\n \n+  /**\n+   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$\n+   * and <tt>long double</tt> @f$ x >= 0 @f$.\n+   *\n+   * @see sph_neumann for details.\n+   */\n   inline long double\n   sph_neumannl(unsigned int __n, long double __x)\n   { return __detail::__sph_neumann<long double>(__n, __x); }\n \n+  /**\n+   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$\n+   * and real argument @f$ x >= 0 @f$.\n+   *\n+   * The spherical Neumann function is defined by\n+   * @f[\n+   *    n_n(x) = \\left(\\frac{\\pi}{2x} \\right) ^{1/2} N_{n+1/2}(x)\n+   * @f]\n+   *\n+   * @tparam _Tp The floating-point type of the argument @c __x.\n+   * @param  __n  The integral order <tt> n >= 0 </tt>\n+   * @param  __x  The real argument <tt> __x >= 0 </tt>\n+   * @throw std::domain_error if <tt> __x < 0 </tt>.\n+   */\n   template<typename _Tp>\n     inline typename __gnu_cxx::__promote<_Tp>::__type\n     sph_neumann(unsigned int __n, _Tp __x)\n@@ -457,14 +1206,44 @@ namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n \n   // Confluent hypergeometric functions\n \n+  /**\n+   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$\n+   * of @c float numeratorial parameter @c a, denominatorial parameter @c c,\n+   * and argument @c x.\n+   *\n+   * @see conf_hyperg for details.\n+   */\n   inline float\n   conf_hypergf(float __a, float __c, float __x)\n   { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }\n \n+  /**\n+   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$\n+   * of <tt>long double</tt> numeratorial parameter @c a,\n+   * denominatorial parameter @c c, and argument @c x.\n+   *\n+   * @see conf_hyperg for details.\n+   */\n   inline long double\n   conf_hypergl(long double __a, long double __c, long double __x)\n   { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }\n \n+  /**\n+   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$\n+   * of real numeratorial parameter @c a, denominatorial parameter @c c,\n+   * and argument @c x.\n+   *\n+   * The confluent hypergeometric function is defined by\n+   * @f[\n+   *    {}_1F_1(a;c;x) = \\sum_{n=0}^{\\infty} \\frac{(a)_n x^n}{(c)_n n!}\n+   * @f]\n+   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,\n+   * @f$ (x)_0 = 1 @f$\n+   *\n+   * @param __a The numeratorial parameter\n+   * @param __c The denominatorial parameter\n+   * @param __x The argument\n+   */\n   template<typename _Tpa, typename _Tpc, typename _Tp>\n     inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type\n     conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)\n@@ -475,14 +1254,45 @@ namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n \n   // Hypergeometric functions\n \n+  /**\n+   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$\n+   * of @ float numeratorial parameters @c a and @c b,\n+   * denominatorial parameter @c c, and argument @c x.\n+   *\n+   * @see hyperg for details.\n+   */\n   inline float\n   hypergf(float __a, float __b, float __c, float __x)\n   { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }\n \n+  /**\n+   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$\n+   * of <tt>long double</tt> numeratorial parameters @c a and @c b,\n+   * denominatorial parameter @c c, and argument @c x.\n+   *\n+   * @see hyperg for details.\n+   */\n   inline long double\n   hypergl(long double __a, long double __b, long double __c, long double __x)\n   { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }\n \n+  /**\n+   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$\n+   * of real numeratorial parameters @c a and @c b,\n+   * denominatorial parameter @c c, and argument @c x.\n+   *\n+   * The hypergeometric function is defined by\n+   * @f[\n+   *    {}_2F_1(a;c;x) = \\sum_{n=0}^{\\infty} \\frac{(a)_n (b)_n x^n}{(c)_n n!}\n+   * @f]\n+   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,\n+   * @f$ (x)_0 = 1 @f$\n+   *\n+   * @param __a The first numeratorial parameter\n+   * @param __b The second numeratorial parameter\n+   * @param __c The denominatorial parameter\n+   * @param __x The argument\n+   */\n   template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>\n     inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type\n     hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)"}]}