{"sha": "5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhZjdjMGExNzI2N2RiYmZmMGZlYTc5M2EzYzYwZjliYmQzN2U0NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-02-21T14:42:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-02-21T14:42:27Z"}, "message": "tree.h (DECL_UNINLINABLE): Move from C++ frontend.\n\n        * tree.h (DECL_UNINLINABLE): Move from C++ frontend.\n        (struct tree_decl): Add uninlinable bitfield.\n        * c-decl.c (duplicate_decls): Set it.\n        * integrate.c (function_cannot_inline_p): Check it.\n        * cp-tree.h (struct lang_decl_flags): Remove uninlinable flag.\n        (DECL_UNINLINABLE): Move to middle-end.\n\n        * dwarf2out.c (add_name_and_src_coords_attributes): Don't add\n        DW_AT_MIPS_linkage_name to abstract methods.\n        (dwarf2out_abstract_function): Emit class context before calling\n        set_decl_abstract_flags.  Don't clear DECL_ABSTRACT.\n        (gen_subprogram_die): Remove obsolete code.\n        (gen_member_die): Don't include clones in the member list.\n        (gen_decl_die): Emit abstract info for clone origin.\n        * dwarfout.c (output_type): Don't include clones in the member list.\n        * dbxout.c (dbxout_type_methods): Ignore abstract methods.\n        * toplev.c (note_deferral_of_defined_inline_function): Don't clear\n        DECL_ABSTRACT on a function that already has it set.\n        * class.c (clone_function_decl): Set DECL_ABSTRACT on original fn.\n        * decl.c (duplicate_decls): Preserve DECL_ABSTRACT.\n        * class.c (build_clone): Set DECL_ABSTRACT_ORIGIN for the clone.\n        * optimize.c (maybe_clone_body): Set DECL_ABSTRACT_ORIGIN for the\n        parms and outer BLOCK.  note_deferral_of_defined_inline_function.\n\n        * dwarf2out.c (gen_formal_types_die): Also accept a FUNCTION_DECL.\n        (get_subprogram_die): Pass it in.\n        * method.c (implicitly_declare_fn): Don't set DECL_ARTIFICIAL on\n        second parm of op=.\n\nFrom-SVN: r39945", "tree": {"sha": "1ac1f438d70d628d0614049b355e3d6dba77540d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac1f438d70d628d0614049b355e3d6dba77540d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c88f36654247adb45eb17318a380c47427f1968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c88f36654247adb45eb17318a380c47427f1968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c88f36654247adb45eb17318a380c47427f1968"}], "stats": {"total": 224, "additions": 151, "deletions": 73}, "files": [{"sha": "57d50323ca3c00f5f1fa36eeb5e09ba952a8efbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -1,3 +1,25 @@\n+2001-02-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.h (DECL_UNINLINABLE): Move from C++ frontend.\n+\t(struct tree_decl): Add uninlinable bitfield.\n+\t* c-decl.c (duplicate_decls): Set it.\n+\t* integrate.c (function_cannot_inline_p): Check it.\n+\n+\t* dwarf2out.c (add_name_and_src_coords_attributes): Don't add \n+\tDW_AT_MIPS_linkage_name to abstract methods.\n+\t(dwarf2out_abstract_function): Emit class context before calling\n+\tset_decl_abstract_flags.  Don't clear DECL_ABSTRACT.\n+\t(gen_subprogram_die): Remove obsolete code.\n+\t(gen_member_die): Don't include clones in the member list.\n+\t(gen_decl_die): Emit abstract info for clone origin.\n+\t* dwarfout.c (output_type): Don't include clones in the member list.\n+\t* dbxout.c (dbxout_type_methods): Ignore abstract methods.\n+\t* toplev.c (note_deferral_of_defined_inline_function): Don't clear\n+\tDECL_ABSTRACT on a function that already has it set.\n+\n+\t* dwarf2out.c (gen_formal_types_die): Also accept a FUNCTION_DECL.\n+\t(get_subprogram_die): Pass it in.\n+\n 2001-02-21  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* flow.c (mark_set_1): Make not_dead unsigned long.  For"}, {"sha": "0f104a44cf0de5eaf8979dfb269f8dcd4e9bf91a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -1928,19 +1928,6 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n   /* For functions, static overrides non-static.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      /* If we're redefining a function previously defined as extern\n-\t inline, make sure we emit debug info for the inline before we\n-\t throw it away, in case it was inlined into a function that hasn't\n-\t been written out yet.  */\n-      if (new_is_definition && DECL_INITIAL (olddecl) && TREE_USED (olddecl))\n-\t{\n-\t  note_outlining_of_inline_function (olddecl);\n-\n-\t  /* The new defn must not be inline.\n-\t     FIXME what about -finline-functions? */\n-\t  DECL_INLINE (newdecl) = 0;\n-\t}\n-\n       TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n       /* This is since we don't automatically\n \t copy the attributes of NEWDECL into OLDDECL.  */\n@@ -1974,12 +1961,27 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      /* If either decl says `inline', this fn is inline,\n-\t unless its definition was passed already.  */\n-      if (DECL_INLINE (newdecl) && DECL_INITIAL (olddecl) == 0)\n-\tDECL_INLINE (olddecl) = 1;\n+      /* If we're redefining a function previously defined as extern\n+\t inline, make sure we emit debug info for the inline before we\n+\t throw it away, in case it was inlined into a function that hasn't\n+\t been written out yet.  */\n+      if (new_is_definition && DECL_INITIAL (olddecl) && TREE_USED (olddecl))\n+\t{\n+\t  note_outlining_of_inline_function (olddecl);\n \n-      DECL_INLINE (newdecl) = DECL_INLINE (olddecl);\n+\t  /* The new defn must not be inline.  */\n+\t  DECL_INLINE (newdecl) = 0;\n+\t  DECL_UNINLINABLE (newdecl) = 1;\n+\t}\n+      else\n+\t{\n+\t  /* If either decl says `inline', this fn is inline,\n+\t     unless its definition was passed already.  */\n+\t  if (DECL_INLINE (newdecl) && DECL_INITIAL (olddecl) == 0)\n+\t    DECL_INLINE (olddecl) = 1;\n+\n+\t  DECL_INLINE (newdecl) = DECL_INLINE (olddecl);\n+\t}\n \n       if (DECL_BUILT_IN (olddecl))\n \t{"}, {"sha": "9c0ad71cae24122797792a9082f1fb092c01c8c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -1,3 +1,17 @@\n+2001-02-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-tree.h (struct lang_decl_flags): Remove uninlinable flag.\n+\t(DECL_UNINLINABLE): Move to middle-end.\n+\n+\t* class.c (clone_function_decl): Set DECL_ABSTRACT on original fn.\n+\t* decl.c (duplicate_decls): Preserve DECL_ABSTRACT.\n+\t* class.c (build_clone): Set DECL_ABSTRACT_ORIGIN for the clone.\n+\t* optimize.c (maybe_clone_body): Set DECL_ABSTRACT_ORIGIN for the\n+\tparms and outer BLOCK.  note_deferral_of_defined_inline_function.\n+\n+\t* method.c (implicitly_declare_fn): Don't set DECL_ARTIFICIAL on\n+\tsecond parm of op=.\n+\n 2001-02-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (set_decl_namespace): Allow explicit instantiations in"}, {"sha": "2ba9e037d0a7df70b178f10ac52c23e335dd427d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -4179,6 +4179,7 @@ build_clone (fn, name)\n   clone = copy_decl (fn);\n   /* Remember where this function came from.  */\n   DECL_CLONED_FUNCTION (clone) = fn;\n+  DECL_ABSTRACT_ORIGIN (clone) = fn;\n   /* Reset the function name.  */\n   DECL_NAME (clone) = name;\n   DECL_ASSEMBLER_NAME (clone) = DECL_NAME (clone);\n@@ -4339,6 +4340,9 @@ clone_function_decl (fn, update_method_vec_p)\n       if (update_method_vec_p)\n \tadd_method (DECL_CONTEXT (clone), clone, /*error_p=*/0);\n     }\n+\n+  /* Note that this is an abstract function that is never emitted.  */\n+  DECL_ABSTRACT (fn) = 1;\n }\n \n /* For each of the constructors and destructors in T, create an"}, {"sha": "240832a9c717ade679d38cfe4dee6c64419a5dcb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -1811,7 +1811,7 @@ struct lang_decl_flags\n   unsigned static_function : 1;\n   unsigned pure_virtual : 1;\n   unsigned has_in_charge_parm_p : 1;\n-  unsigned uninlinable : 1;\n+  unsigned has_vtt_parm_p : 1;\n \n   unsigned deferred : 1;\n   unsigned use_template : 2;\n@@ -1828,7 +1828,7 @@ struct lang_decl_flags\n   unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n   unsigned generate_with_vtable_p : 1;\n-  unsigned has_vtt_parm_p : 1;\n+  /* One unused bit.  */\n \n   union {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n@@ -2469,10 +2469,6 @@ extern int flag_new_for_scope;\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n \n-/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n-#define DECL_UNINLINABLE(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.uninlinable)\n-\n /* Returns non-zero if DECL has external linkage, as specified by the\n    language standard.  (This predicate may hold even when the\n    corresponding entity is not actually given external linkage in the"}, {"sha": "85e9fa6b178f85eef2e2f8b73382df760fc04033", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -3626,6 +3626,9 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_INLINE (olddecl) = 1;\n       DECL_INLINE (newdecl) = DECL_INLINE (olddecl);\n \n+      /* Preserve abstractness on cloned [cd]tors.  */\n+      DECL_ABSTRACT (newdecl) = DECL_ABSTRACT (olddecl);\n+\n       if (! types_match)\n \t{\n \t  DECL_LANGUAGE (olddecl) = DECL_LANGUAGE (newdecl);"}, {"sha": "75e713d3799c913e38e48ee815427f3ccfd85bdc", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -1026,8 +1026,6 @@ implicitly_declare_fn (kind, type, const_p)\n \n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 20000408);\n \n-  if (kind != sfk_constructor && kind != sfk_destructor)\n-    DECL_ARTIFICIAL (TREE_CHAIN (DECL_ARGUMENTS (fn))) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_THIS_INLINE (fn) = 1;"}, {"sha": "21c94eafee68a31122952ab18fb93862c6a36275", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -932,6 +932,9 @@ maybe_clone_body (fn)\n       && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n     return 0;\n \n+  /* Emit the DWARF1 abstract instance.  */\n+  note_deferral_of_defined_inline_function (fn);\n+\n   /* We know that any clones immediately follow FN in the TYPE_METHODS\n      list.  */\n   for (clone = TREE_CHAIN (fn);\n@@ -996,6 +999,7 @@ maybe_clone_body (fn)\n \t\t from the CLONE to this parameter.  */\n \t      if (DECL_HAS_VTT_PARM_P (clone))\n \t\t{\n+\t\t  DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n \t\t  splay_tree_insert (id.decl_map,\n \t\t\t\t     (splay_tree_key) parm,\n \t\t\t\t     (splay_tree_value) clone_parm);\n@@ -1013,6 +1017,7 @@ maybe_clone_body (fn)\n \t     function.  */\n \t  else\n \t    {\n+\t      DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n \t      splay_tree_insert (id.decl_map,\n \t\t\t\t (splay_tree_key) parm,\n \t\t\t\t (splay_tree_value) clone_parm);\n@@ -1029,7 +1034,9 @@ maybe_clone_body (fn)\n \n       /* Now, expand this function into RTL, if appropriate.  */\n       function_name_declared_p = 1;\n-      expand_body (finish_function (0));\n+      finish_function (0);\n+      BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);\n+      expand_body (clone);\n       pop_from_top_level ();\n     }\n   "}, {"sha": "05a95a4b39c924b9d9bb69d6df09a4358e60034f", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -841,7 +841,9 @@ dbxout_type_methods (type)\n \n \t  last = fndecl;\n \n-\t  if (DECL_IGNORED_P (fndecl))\n+\t  /* Also ignore abstract methods; those are only interesting to\n+\t     the DWARF backends.  */\n+\t  if (DECL_IGNORED_P (fndecl) || DECL_ABSTRACT (fndecl))\n \t    continue;\n \n \t  if (flag_minimal_debug)"}, {"sha": "ce3efaf0ec0a00fef2de6250891aa8296eb95bda", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -9390,7 +9390,8 @@ add_name_and_src_coords_attributes (die, decl)\n \n       if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n \t  && TREE_PUBLIC (decl)\n-\t  && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n+\t  && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl)\n+\t  && !DECL_ABSTRACT (decl))\n \tadd_AT_string (die, DW_AT_MIPS_linkage_name,\n \t\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n     }\n@@ -9936,24 +9937,22 @@ gen_formal_types_die (function_or_method_type, context_die)\n {\n   register tree link;\n   register tree formal_type = NULL;\n-  register tree first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n+  register tree first_parm_type;\n+  tree arg;\n \n-#if 0\n-  /* In the case where we are generating a formal types list for a C++\n-     non-static member function type, skip over the first thing on the\n-     TYPE_ARG_TYPES list because it only represents the type of the hidden\n-     `this pointer'.  The debugger should be able to figure out (without\n-     being explicitly told) that this non-static member function type takes a\n-     `this pointer' and should be able to figure what the type of that hidden\n-     parameter is from the DW_AT_member attribute of the parent\n-     DW_TAG_subroutine_type DIE.  */\n-  if (TREE_CODE (function_or_method_type) == METHOD_TYPE)\n-    first_parm_type = TREE_CHAIN (first_parm_type);\n-#endif\n+  if (TREE_CODE (function_or_method_type) == FUNCTION_DECL)\n+    {\n+      arg = DECL_ARGUMENTS (function_or_method_type);\n+      function_or_method_type = TREE_TYPE (function_or_method_type);\n+    }\n+  else\n+    arg = NULL_TREE;\n+  \n+  first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n \n   /* Make our first pass over the list of formal parameter types and output a\n      DW_TAG_formal_parameter DIE for each one.  */\n-  for (link = first_parm_type; link; link = TREE_CHAIN (link))\n+  for (link = first_parm_type; link; )\n     {\n       register dw_die_ref parm_die;\n \n@@ -9963,9 +9962,14 @@ gen_formal_types_die (function_or_method_type, context_die)\n \n       /* Output a (nameless) DIE to represent the formal parameter itself.  */\n       parm_die = gen_formal_parameter_die (formal_type, context_die);\n-      if (TREE_CODE (function_or_method_type) == METHOD_TYPE\n-\t  && link == first_parm_type)\n+      if ((TREE_CODE (function_or_method_type) == METHOD_TYPE\n+\t   && link == first_parm_type)\n+\t  || (arg && DECL_ARTIFICIAL (arg)))\n \tadd_AT_flag (parm_die, DW_AT_artificial, 1);\n+\n+      link = TREE_CHAIN (link);\n+      if (arg)\n+\targ = TREE_CHAIN (arg);\n     }\n \n   /* If this function type has an ellipsis, add a\n@@ -10025,19 +10029,34 @@ void\n dwarf2out_abstract_function (decl)\n      tree decl;\n {\n-  register dw_die_ref old_die = lookup_decl_die (decl);\n+  register dw_die_ref old_die;\n   tree save_fn;\n+  tree context;\n+  int was_abstract = DECL_ABSTRACT (decl);\n+\n+  /* Make sure we have the actual abstract inline, not a clone.  */\n+  decl = DECL_ORIGIN (decl);\n \n+  old_die = lookup_decl_die (decl);  \n   if (old_die && get_AT_unsigned (old_die, DW_AT_inline))\n     /* We've already generated the abstract instance.  */\n     return;\n \n+  /* Be sure we've emitted the in-class declaration DIE (if any) first, so\n+     we don't get confused by DECL_ABSTRACT.  */\n+  context = decl_class_context (decl);\n+  if (context)\n+    gen_type_die_for_member\n+      (context, decl, decl_function_context (decl) ? NULL : comp_unit_die);\n+ \n+  /* Pretend we've just finished compiling this function.  */\n   save_fn = current_function_decl;\n   current_function_decl = decl;\n \n   set_decl_abstract_flags (decl, 1);\n   dwarf2out_decl (decl);\n-  set_decl_abstract_flags (decl, 0);\n+  if (! was_abstract)\n+    set_decl_abstract_flags (decl, 0);\n \n   current_function_decl = save_fn;\n }\n@@ -10088,17 +10107,6 @@ gen_subprogram_die (decl, context_die)\n       subr_die = new_die (DW_TAG_subprogram, context_die);\n       add_abstract_origin_attribute (subr_die, origin);\n     }\n-  else if (old_die && DECL_ABSTRACT (decl)\n-\t   && get_AT_unsigned (old_die, DW_AT_inline))\n-    {\n-      /* This must be a redefinition of an extern inline function.\n-\t We can just reuse the old die here.  */\n-      subr_die = old_die;\n-\n-      /* Clear out the inlined attribute and parm types.  */\n-      remove_AT (subr_die, DW_AT_inline);\n-      remove_children (subr_die);\n-    }\n   else if (old_die)\n     {\n       register unsigned file_index\n@@ -10261,7 +10269,7 @@ gen_subprogram_die (decl, context_die)\n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n     ;\n   else if (declaration)\n-    gen_formal_types_die (TREE_TYPE (decl), subr_die);\n+    gen_formal_types_die (decl, subr_die);\n   else\n     {\n       /* Generate DIEs to represent all known formal parameters */\n@@ -10738,6 +10746,10 @@ gen_member_die (type, context_die)\n   /* Now output info about the function members (if any).  */\n   for (member = TYPE_METHODS (type); member; member = TREE_CHAIN (member))\n     {\n+      /* Don't include clones in the member list.  */\n+      if (DECL_ABSTRACT_ORIGIN (member))\n+\tcontinue;\n+\n       child = lookup_decl_die (member);\n       if (child)\n \tsplice_child_die (context_die, child);\n@@ -11266,20 +11278,23 @@ gen_decl_die (decl, context_die)\n \t  && (current_function_decl == NULL_TREE || DECL_ARTIFICIAL (decl)))\n \tbreak;\n \n+      /* If we're emitting a clone, emit info for the abstract instance.  */\n+      if (DECL_ORIGIN (decl) != decl)\n+\tdwarf2out_abstract_function (DECL_ABSTRACT_ORIGIN (decl));\n       /* If we're emitting an out-of-line copy of an inline function,\n \t emit info for the abstract instance and set up to refer to it.  */\n-      if (DECL_INLINE (decl) && ! DECL_ABSTRACT (decl)\n-\t  && ! class_scope_p (context_die)\n-\t  /* dwarf2out_abstract_function won't emit a die if this is just a\n-\t     declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in\n-\t     that case, because that works only if we have a die.  */\n-\t  && DECL_INITIAL (decl) != NULL_TREE)\n+      else if (DECL_INLINE (decl) && ! DECL_ABSTRACT (decl)\n+\t       && ! class_scope_p (context_die)\n+\t       /* dwarf2out_abstract_function won't emit a die if this is just\n+\t\t  a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in\n+\t\t  that case, because that works only if we have a die.  */\n+\t       && DECL_INITIAL (decl) != NULL_TREE)\n \t{\n \t  dwarf2out_abstract_function (decl);\n \t  set_decl_origin_self (decl);\n \t}\n-\n-      if (debug_info_level > DINFO_LEVEL_TERSE)\n+      /* Otherwise we're emitting the primary DIE for this decl.  */\n+      else if (debug_info_level > DINFO_LEVEL_TERSE)\n \t{\n \t  /* Before we describe the FUNCTION_DECL itself, make sure that we\n \t     have described its return type.  */"}, {"sha": "370d14f4d88c52086523bc3ff4c6cb7aa5d5c504", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -4444,7 +4444,13 @@ output_type (type, containing_scope)\n \t      for (func_member = TYPE_METHODS (type);\n \t\t   func_member;\n \t\t   func_member = TREE_CHAIN (func_member))\n-\t\toutput_decl (func_member, type);\n+\t\t{\n+\t\t  /* Don't include clones in the member list.  */\n+\t\t  if (DECL_ABSTRACT_ORIGIN (func_member))\n+\t\t    continue;\n+\n+\t\t  output_decl (func_member, type);\n+\t\t}\n \t    }\n \n \t    --in_class;"}, {"sha": "270a9c5a115317e75491ab391c6e85fa46fb6a97", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -139,6 +139,9 @@ function_cannot_inline_p (fndecl)\n   register tree parms;\n   rtx result;\n \n+  if (DECL_UNINLINABLE (fndecl))\n+    return N_(\"function cannot be inline\");\n+\n   /* No inlines with varargs.  */\n   if ((last && TREE_VALUE (last) != void_type_node)\n       || current_function_varargs)"}, {"sha": "0e592bc2907592ffb805d1d96f0374e413cc158f", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -2661,19 +2661,23 @@ note_deferral_of_defined_inline_function (decl)\n   /* Generate the DWARF info for the \"abstract\" instance of a function\n      which we may later generate inlined and/or out-of-line instances\n      of.  */\n-  if (write_symbols == DWARF_DEBUG && DECL_INLINE (decl))\n+  if (write_symbols == DWARF_DEBUG\n+      && (DECL_INLINE (decl) || DECL_ABSTRACT (decl))\n+      && ! DECL_ABSTRACT_ORIGIN (decl))\n     {\n       /* The front-end may not have set CURRENT_FUNCTION_DECL, but the\n \t DWARF code expects it to be set in this case.  Intuitively,\n \t DECL is the function we just finished defining, so setting\n \t CURRENT_FUNCTION_DECL is sensible.  */\n       tree saved_cfd = current_function_decl;\n+      int was_abstract = DECL_ABSTRACT (decl);\n       current_function_decl = decl;\n \n       /* Let the DWARF code do its work.  */\n       set_decl_abstract_flags (decl, 1);\n       dwarfout_file_scope_decl (decl, 0);\n-      set_decl_abstract_flags (decl, 0);\n+      if (! was_abstract)\n+\tset_decl_abstract_flags (decl, 0);\n \n       /* Reset CURRENT_FUNCTION_DECL.  */\n       current_function_decl = saved_cfd;"}, {"sha": "3d2e38416f1b521a4e33bbb4f6dc828d4d86868f", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5daf7c0a17267dbbff0fea793a3c60f9bbd37e45/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5daf7c0a17267dbbff0fea793a3c60f9bbd37e45", "patch": "@@ -239,8 +239,6 @@ struct tree_common\n            INTEGER_TYPE, ENUMERAL_TYPE, FIELD_DECL\n        DECL_BUILT_IN_NONANSI in\n            FUNCTION_DECL\n-       TREE_PARMLIST in\n-           TREE_PARMLIST (C++)\n        SAVE_EXPR_NOPLACEHOLDER in\n \t   SAVE_EXPR\n \n@@ -1461,6 +1459,9 @@ struct tree_type\n    where it is called.  */\n #define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inline_flag)\n \n+/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n+#define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n+\n /* Nonzero in a FUNCTION_DECL means this is a built-in function\n    that is not specified by ansi C and that users are supposed to be allowed\n    to redefine for any purpose whatever.  */\n@@ -1632,7 +1633,8 @@ struct tree_decl\n   unsigned pointer_depth : 2;\n   unsigned non_addressable : 1;\n   unsigned user_align : 1;\n-  /* Three unused bits.  */\n+  unsigned uninlinable : 1;\n+  /* Two unused bits.  */\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;"}]}