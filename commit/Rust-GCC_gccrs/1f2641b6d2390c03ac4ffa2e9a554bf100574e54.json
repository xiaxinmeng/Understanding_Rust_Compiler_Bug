{"sha": "1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYyNjQxYjZkMjM5MGMwM2FjNGZmYTJlOWE1NTRiZjEwMDU3NGU1NA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2002-04-30T19:18:49Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-04-30T19:18:49Z"}, "message": "mmix.h (MMIX_LAST_STACK_REGISTER_REGNUM): Renamed from MMIX_LAST_REGISTER_FILE_REGNUM.\n\n\t* config/mmix/mmix.h (MMIX_LAST_STACK_REGISTER_REGNUM): Renamed\n\tfrom MMIX_LAST_REGISTER_FILE_REGNUM.\n\t(NO_IMPLICIT_EXTERN_C): Remove cryptic obsolete comment.\n\t(struct machine_function): New member highest_saved_stack_register\n\tpreviously static variable in mmix.c.\n\t(MACHINE_DEPENDENT_REORG): Define.\n\t* config/mmix/mmix.c (highest_saved_stack_register): Deleted.\n\t(MMIX_OUTPUT_REGNO): New.\n\t(mmix_target_asm_function_prologue): Move calculation of last used\n\tsaved-stack-register into...\n\t(mmix_machine_dependent_reorg): New function.  Update to also handle\n\t!TARGET_ABI_GNU.\n\t(mmix_print_operand): Apply MMIX_OUTPUT_REGNO when emitting\n\tregister names, simplify somewhat by new variable regno.\n\t<case 'p'>: Remove fixed FIXME.  Always emit highest used saved\n\tregister.\n\t(mmix_print_operand_address): Apply MMIX_OUTPUT_REGNO when\n\temitting register names.\n\t(mmix_asm_output_reg_push, mmix_asm_output_reg_pop): Ditto.\n\t(mmix_dbx_register_number): Apply MMIX_OUTPUT_REGNO here too.\n\tRemove fixed FIXME.\n\t* config/mmix/mmix-protos.h (mmix_machine_dependent_reorg):\n\tDeclare.\n\n\t* config/mmix/mmix.md (\"divmoddi4\"): Update head comment.\n\nFrom-SVN: r52966", "tree": {"sha": "76037033dc08f78a09ff8e69706a3250e56c2bc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76037033dc08f78a09ff8e69706a3250e56c2bc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/comments", "author": null, "committer": null, "parents": [{"sha": "73985940ada1b0562f600b7545d2510801742d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73985940ada1b0562f600b7545d2510801742d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73985940ada1b0562f600b7545d2510801742d89"}], "stats": {"total": 143, "additions": 110, "deletions": 33}, "files": [{"sha": "9a560f089831eddab04dcb7152e862b086ed6af5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "patch": "@@ -1,3 +1,31 @@\n+2002-04-30  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* config/mmix/mmix.h (MMIX_LAST_STACK_REGISTER_REGNUM): Renamed\n+\tfrom MMIX_LAST_REGISTER_FILE_REGNUM.\n+\t(NO_IMPLICIT_EXTERN_C): Remove cryptic obsolete comment.\n+\t(struct machine_function): New member highest_saved_stack_register\n+\tpreviously static variable in mmix.c.\n+\t(MACHINE_DEPENDENT_REORG): Define.\n+\t* config/mmix/mmix.c (highest_saved_stack_register): Deleted.\n+\t(MMIX_OUTPUT_REGNO): New.\n+\t(mmix_target_asm_function_prologue): Move calculation of last used\n+\tsaved-stack-register into...\n+\t(mmix_machine_dependent_reorg): New function.  Update to also handle\n+\t!TARGET_ABI_GNU.\n+\t(mmix_print_operand): Apply MMIX_OUTPUT_REGNO when emitting\n+\tregister names, simplify somewhat by new variable regno.\n+\t<case 'p'>: Remove fixed FIXME.  Always emit highest used saved\n+\tregister.\n+\t(mmix_print_operand_address): Apply MMIX_OUTPUT_REGNO when\n+\temitting register names.\n+\t(mmix_asm_output_reg_push, mmix_asm_output_reg_pop): Ditto.\n+\t(mmix_dbx_register_number): Apply MMIX_OUTPUT_REGNO here too.\n+\tRemove fixed FIXME.\n+\t* config/mmix/mmix-protos.h (mmix_machine_dependent_reorg):\n+\tDeclare.\n+\n+\t* config/mmix/mmix.md (\"divmoddi4\"): Update head comment.\n+\n 2002-04-30  Richard Henderson  <rth@redhat.com>\n \n \t* config/sparc/sparc.c (emit_soft_tfmode_libcall,"}, {"sha": "eb9c24c602177c319414304854b1e02e95f6d8ef", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "patch": "@@ -125,6 +125,7 @@ extern void mmix_print_operand PARAMS ((FILE *, rtx, int));\n extern void mmix_print_operand_address PARAMS ((FILE *, rtx));\n extern int mmix_valid_comparison PARAMS ((RTX_CODE, enum machine_mode, rtx));\n extern rtx mmix_gen_compare_reg PARAMS ((enum rtx_code, rtx, rtx));\n+extern void mmix_machine_dependent_reorg PARAMS ((rtx));\n #endif /* RTX_CODE */\n \n extern int mmix_asm_preferred_eh_data_format PARAMS ((int, int));"}, {"sha": "af06624e1df6f0eb827efaa163e2dfec80e8d0c9", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "patch": "@@ -62,6 +62,19 @@ Boston, MA 02111-1307, USA.  */\n       || EH_RETURN_DATA_REGNO (2) == REGNO\t\\\n       || EH_RETURN_DATA_REGNO (3) == REGNO))\n \n+/* For the default ABI, we rename registers at output-time to fill the gap\n+   between the (statically partitioned) saved registers and call-clobbered\n+   registers.  In effect this makes unused call-saved registers to be used\n+   as call-clobbered registers.  The benefit comes from keeping the number\n+   of local registers (value of rL) low, since there's a cost of\n+   increasing rL and clearing unused (unset) registers with lower numbers.  */\n+#define MMIX_OUTPUT_REGNO(N)\t\t\t\t\t\\\n+ (TARGET_ABI_GNU \t\t\t\t\t\t\\\n+  || (N) < MMIX_RETURN_VALUE_REGNUM\t\t\t\t\\\n+  || (N) > MMIX_LAST_STACK_REGISTER_REGNUM\t\t\t\\\n+  ? (N) : ((N) - MMIX_RETURN_VALUE_REGNUM\t\t\t\\\n+\t   + cfun->machine->highest_saved_stack_register + 1))\n+\n /* The canonical saved comparison operands for non-cc0 machines, set in\n    the compare expander.  */\n rtx mmix_compare_op0;\n@@ -74,10 +87,6 @@ const char *mmix_cc1_ignored_option;\n \n /* Declarations of locals.  */\n \n-/* This is used in the prologue for what number to pass in a PUSHJ or\n-   PUSHGO insn.  */\n-static int mmix_highest_saved_stack_register;\n-\n /* Intermediate for insn output.  */\n static int mmix_output_destination_register;\n \n@@ -981,19 +990,50 @@ mmix_target_asm_function_prologue (stream, locals_size)\n \t\t\t       cfa_offset);\n \t}\n     }\n+}\n+\n+/* MACHINE_DEPENDENT_REORG.\n+   No actual rearrangements done here; just virtually by calculating the\n+   highest saved stack register number used to modify the register numbers\n+   at output time.  */\n+\n+void\n+mmix_machine_dependent_reorg (first)\n+     rtx first ATTRIBUTE_UNUSED;\n+{\n+  int regno;\n \n   /* We put the number of the highest saved register-file register in a\n      location convenient for the call-patterns to output.  Note that we\n      don't tell dwarf2 about these registers, since it can't restore them\n      anyway.  */\n-  for (regno = MMIX_LAST_REGISTER_FILE_REGNUM;\n+  for (regno = MMIX_LAST_STACK_REGISTER_REGNUM;\n        regno >= 0;\n        regno--)\n     if ((regs_ever_live[regno] && !call_used_regs[regno])\n \t|| (regno == MMIX_FRAME_POINTER_REGNUM && frame_pointer_needed))\n       break;\n \n-  mmix_highest_saved_stack_register = regno;\n+  /* Regardless of whether they're saved (they might be just read), we\n+     mustn't include registers that carry parameters.  We could scan the\n+     insns to see whether they're actually used (and indeed do other less\n+     trivial register usage analysis and transformations), but it seems\n+     wasteful to optimize for unused parameter registers.  As of\n+     2002-04-30, regs_ever_live[n] seems to be set for only-reads too, but\n+     that might change.  */\n+  if (!TARGET_ABI_GNU && regno < current_function_args_info.regs - 1)\n+    {\n+      regno = current_function_args_info.regs - 1;\n+\n+      /* We don't want to let this cause us to go over the limit and make\n+\t incoming parameter registers be misnumbered and treating the last\n+\t parameter register and incoming return value register call-saved.\n+\t Stop things at the unmodified scheme.  */\n+      if (regno > MMIX_RETURN_VALUE_REGNUM - 1)\n+\tregno = MMIX_RETURN_VALUE_REGNUM - 1;\n+    }\n+\n+  cfun->machine->highest_saved_stack_register = regno;\n }\n \n /* TARGET_ASM_FUNCTION_EPILOGUE.  */\n@@ -2165,6 +2205,7 @@ mmix_print_operand (stream, x, code)\n   /* When we add support for different codes later, we can, when needed,\n      drop through to the main handler with a modified operand.  */\n   rtx modified_x = x;\n+  int regno = x != NULL_RTX && REG_P (x) ? REGNO (x) : 0;\n \n   switch (code)\n     {\n@@ -2189,11 +2230,11 @@ mmix_print_operand (stream, x, code)\n     case 'H':\n       /* Highpart.  Must be general register, and not the last one, as\n \t that one cannot be part of a consecutive register pair.  */\n-      if (REGNO (x) > MMIX_LAST_GENERAL_REGISTER - 1)\n-\tinternal_error (\"MMIX Internal: Bad register: %d\", REGNO (x));\n+      if (regno > MMIX_LAST_GENERAL_REGISTER - 1)\n+\tinternal_error (\"MMIX Internal: Bad register: %d\", regno);\n \n       /* This is big-endian, so the high-part is the first one.  */\n-      fprintf (stream, \"%s\", reg_names[REGNO (x)]);\n+      fprintf (stream, \"%s\", reg_names[MMIX_OUTPUT_REGNO (regno)]);\n       return;\n \n     case 'L':\n@@ -2213,11 +2254,11 @@ mmix_print_operand (stream, x, code)\n \t  return;\n \t}\n \n-      if (REGNO (x) > MMIX_LAST_GENERAL_REGISTER - 1)\n-\tinternal_error (\"MMIX Internal: Bad register: %d\", REGNO (x));\n+      if (regno > MMIX_LAST_GENERAL_REGISTER - 1)\n+\tinternal_error (\"MMIX Internal: Bad register: %d\", regno);\n \n       /* This is big-endian, so the low-part is + 1.  */\n-      fprintf (stream, \"%s\", reg_names[REGNO (x) + 1]);\n+      fprintf (stream, \"%s\", reg_names[MMIX_OUTPUT_REGNO (regno) + 1]);\n       return;\n \n       /* Can't use 'a' because that's a generic modifier for address\n@@ -2273,19 +2314,15 @@ mmix_print_operand (stream, x, code)\n \t by the prologue.  The actual operand contains the number of\n \t registers to pass, but we don't use it currently.  Anyway, we\n \t need to output the number of saved registers here.  */\n-      if (TARGET_ABI_GNU)\n-\tfprintf (stream, \"%d\", mmix_highest_saved_stack_register + 1);\n-      else\n-\t/* FIXME: Get the effect of renaming $16, $17.. to the first\n-\t   unused call-saved reg.  */\n-\tfprintf (stream, \"15\");\n+      fprintf (stream, \"%d\",\n+\t       cfun->machine->highest_saved_stack_register + 1);\n       return;\n \n     case 'r':\n       /* Store the register to output a constant to.  */\n       if (! REG_P (x))\n \tfatal_insn (\"MMIX Internal: Expected a register, not this\", x);\n-      mmix_output_destination_register = REGNO (x);\n+      mmix_output_destination_register = MMIX_OUTPUT_REGNO (regno);\n       return;\n \n     case 'I':\n@@ -2332,9 +2369,10 @@ mmix_print_operand (stream, x, code)\n   switch (GET_CODE (modified_x))\n     {\n     case REG:\n-      if (REGNO (modified_x) >= FIRST_PSEUDO_REGISTER)\n-\tinternal_error (\"MMIX Internal: Bad register: %d\", REGNO (modified_x));\n-      fprintf (stream, \"%s\", reg_names[REGNO (modified_x)]);\n+      regno = REGNO (modified_x);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tinternal_error (\"MMIX Internal: Bad register: %d\", regno);\n+      fprintf (stream, \"%s\", reg_names[MMIX_OUTPUT_REGNO (regno)]);\n       return;\n \n     case MEM:\n@@ -2402,7 +2440,7 @@ mmix_print_operand_address (stream, x)\n     {\n       /* I find the generated assembly code harder to read without\n \t the \",0\".  */\n-      fprintf (stream, \"%s,0\",reg_names[REGNO (x)]);\n+      fprintf (stream, \"%s,0\", reg_names[MMIX_OUTPUT_REGNO (REGNO (x))]);\n       return;\n     }\n   else if (GET_CODE (x) == PLUS)\n@@ -2420,11 +2458,12 @@ mmix_print_operand_address (stream, x)\n \n       if (REG_P (x1))\n \t{\n-\t  fprintf (stream, \"%s,\", reg_names[REGNO (x1)]);\n+\t  fprintf (stream, \"%s,\", reg_names[MMIX_OUTPUT_REGNO (REGNO (x1))]);\n \n \t  if (REG_P (x2))\n \t    {\n-\t      fprintf (stream, \"%s\", reg_names[REGNO (x2)]);\n+\t      fprintf (stream, \"%s\",\n+\t\t       reg_names[MMIX_OUTPUT_REGNO (REGNO (x2))]);\n \t      return;\n \t    }\n \t  else if (GET_CODE (x2) == CONST_INT\n@@ -2455,7 +2494,7 @@ mmix_asm_output_reg_push (stream, regno)\n   fprintf (stream, \"\\tSUBU %s,%s,8\\n\\tSTOU %s,%s,0\\n\",\n \t   reg_names[MMIX_STACK_POINTER_REGNUM],\n \t   reg_names[MMIX_STACK_POINTER_REGNUM],\n-\t   reg_names[regno],\n+\t   reg_names[MMIX_OUTPUT_REGNO (regno)],\n \t   reg_names[MMIX_STACK_POINTER_REGNUM]);\n }\n \n@@ -2467,7 +2506,7 @@ mmix_asm_output_reg_pop (stream, regno)\n      int regno;\n {\n   fprintf (stream, \"\\tLDOU %s,%s,0\\n\\tINCL %s,8\\n\",\n-\t   reg_names[regno],\n+\t   reg_names[MMIX_OUTPUT_REGNO (regno)],\n \t   reg_names[MMIX_STACK_POINTER_REGNUM],\n \t   reg_names[MMIX_STACK_POINTER_REGNUM]);\n }\n@@ -2527,8 +2566,11 @@ int\n mmix_dbx_register_number (regno)\n      int regno;\n {\n-  /* FIXME: Implement final register renumbering if necessary.  (Use\n-     target state in cfun).  */\n+  /* Adjust the register number to the one it will be output as, dammit.\n+     It'd be nice if we could check the assumption that we're filling a\n+     gap, but every register between the last saved register and parameter\n+     registers might be a valid parameter register.  */\n+  regno = MMIX_OUTPUT_REGNO (regno);\n \n   /* We need to renumber registers to get the number of the return address\n      register in the range 0..255.  It is also space-saving if registers"}, {"sha": "3abfe29f6a2ce2a0199933c75895532ebbdf675b", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "patch": "@@ -49,7 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #define MMIX_HIMULT_REGNUM 258\n #define MMIX_REMAINDER_REGNUM 260\n #define MMIX_ARG_POINTER_REGNUM 261\n-#define MMIX_LAST_REGISTER_FILE_REGNUM 31\n+#define MMIX_LAST_STACK_REGISTER_REGNUM 31\n \n /* Four registers; \"ideally, these registers should be call-clobbered\", so\n    just grab a bunch of the common clobbered registers.  FIXME: Last\n@@ -91,6 +91,7 @@ extern struct rtx_def *mmix_compare_op1;\n struct machine_function\n  {\n    int has_landing_pad;\n+   int highest_saved_stack_register;\n  };\n \n /* For these target macros, there is no generic documentation here.  You\n@@ -1196,7 +1197,6 @@ const_section ()\t\t\t\t\t\t\\\n \n #define FUNCTION_MODE QImode\n \n-/* When in due time we *will* have some specific headers.  */\n #define NO_IMPLICIT_EXTERN_C\n \n #define HANDLE_SYSV_PRAGMA\n@@ -1206,6 +1206,10 @@ const_section ()\t\t\t\t\t\t\\\n #define NO_DOLLAR_IN_LABEL\n #define NO_DOT_IN_LABEL\n \n+/* Calculate the highest used supposed saved stack register.  */\n+#define MACHINE_DEPENDENT_REORG(INSN) \\\n+ mmix_machine_dependent_reorg (INSN)\n+\n #endif /* GCC_MMIX_H */\n /*\n  * Local variables:"}, {"sha": "05d34a5236f259b513d257e86a296634815aaf55", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2641b6d2390c03ac4ffa2e9a554bf100574e54/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=1f2641b6d2390c03ac4ffa2e9a554bf100574e54", "patch": "@@ -241,8 +241,10 @@\n ;; One day we might persuade GCC to expand divisions with constants the\n ;; way MMIX does; giving the remainder the sign of the divisor.  But even\n ;; then, it might be good to have an option to divide the way \"everybody\n-;; else\" does.  Perhaps then, this option can be on by default.  Until\n-;; then, we do division and modulus in a library function.\n+;; else\" does.  Perhaps then, this option can be on by default.  However,\n+;; it's not likely to happen because major (C, C++, Fortran) language\n+;; standards in effect at 2002-04-29 reportedly demand that the sign of\n+;; the remainder must follow the sign of the dividend.\n \n (define_insn \"divmoddi4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")"}]}