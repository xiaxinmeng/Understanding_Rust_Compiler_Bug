{"sha": "c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzliMzlhNDk1NWY1NmZlNjA5ZWY1NDc4NGY3YmY0OGM0Y2JhNmIxYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-07-28T10:37:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-07-28T10:37:51Z"}, "message": "re PR sanitizer/80998 (Implement -fsanitize=pointer-overflow)\n\n\tPR sanitizer/80998\n\t* sanopt.c (pass_sanopt::execute): Handle IFN_UBSAN_PTR.\n\t* tree-ssa-alias.c (call_may_clobber_ref_p_1): Likewise.\n\t* flag-types.h (enum sanitize_code): Add SANITIZER_POINTER_OVERFLOW.\n\tOr it into SANITIZER_UNDEFINED.\n\t* ubsan.c: Include gimple-fold.h and varasm.h.\n\t(ubsan_expand_ptr_ifn): New function.\n\t(instrument_pointer_overflow): New function.\n\t(maybe_instrument_pointer_overflow): New function.\n\t(instrument_object_size): Formatting fix.\n\t(pass_ubsan::execute): Call instrument_pointer_overflow\n\tand maybe_instrument_pointer_overflow.\n\t* internal-fn.c (expand_UBSAN_PTR): New function.\n\t* ubsan.h (ubsan_expand_ptr_ifn): Declare.\n\t* sanitizer.def (__ubsan_handle_pointer_overflow,\n\t__ubsan_handle_pointer_overflow_abort): New builtins.\n\t* tree-ssa-tail-merge.c (merge_stmts_p): Handle IFN_UBSAN_PTR.\n\t* internal-fn.def (UBSAN_PTR): New internal function.\n\t* opts.c (sanitizer_opts): Add pointer-overflow.\n\t* lto-streamer-in.c (input_function): Handle IFN_UBSAN_PTR.\n\t* fold-const.c (build_range_check): Compute pointer range check in\n\tintegral type if pointer arithmetics would be needed.  Formatting\n\tfixes.\ngcc/testsuite/\n\t* c-c++-common/ubsan/ptr-overflow-1.c: New test.\n\t* c-c++-common/ubsan/ptr-overflow-2.c: New test.\nlibsanitizer/\n\t* ubsan/ubsan_handlers.cc: Cherry-pick upstream r304461.\n\t* ubsan/ubsan_checks.inc: Likewise.\n\t* ubsan/ubsan_handlers.h: Likewise.\n\nFrom-SVN: r250656", "tree": {"sha": "6ddac4284a4bae1e7241b22e28dcaaeb311277f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ddac4284a4bae1e7241b22e28dcaaeb311277f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70affe6aff39d347a0e2b7f12a27e1cad4cae405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70affe6aff39d347a0e2b7f12a27e1cad4cae405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70affe6aff39d347a0e2b7f12a27e1cad4cae405"}], "stats": {"total": 614, "additions": 593, "deletions": 21}, "files": [{"sha": "61d389e541db9d7c76385866094072fdab7931e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1,3 +1,29 @@\n+2017-07-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/80998\n+\t* sanopt.c (pass_sanopt::execute): Handle IFN_UBSAN_PTR.\n+\t* tree-ssa-alias.c (call_may_clobber_ref_p_1): Likewise.\n+\t* flag-types.h (enum sanitize_code): Add SANITIZER_POINTER_OVERFLOW.\n+\tOr it into SANITIZER_UNDEFINED.\n+\t* ubsan.c: Include gimple-fold.h and varasm.h.\n+\t(ubsan_expand_ptr_ifn): New function.\n+\t(instrument_pointer_overflow): New function.\n+\t(maybe_instrument_pointer_overflow): New function.\n+\t(instrument_object_size): Formatting fix.\n+\t(pass_ubsan::execute): Call instrument_pointer_overflow\n+\tand maybe_instrument_pointer_overflow.\n+\t* internal-fn.c (expand_UBSAN_PTR): New function.\n+\t* ubsan.h (ubsan_expand_ptr_ifn): Declare.\n+\t* sanitizer.def (__ubsan_handle_pointer_overflow,\n+\t__ubsan_handle_pointer_overflow_abort): New builtins.\n+\t* tree-ssa-tail-merge.c (merge_stmts_p): Handle IFN_UBSAN_PTR.\n+\t* internal-fn.def (UBSAN_PTR): New internal function.\n+\t* opts.c (sanitizer_opts): Add pointer-overflow.\n+\t* lto-streamer-in.c (input_function): Handle IFN_UBSAN_PTR.\n+\t* fold-const.c (build_range_check): Compute pointer range check in\n+\tintegral type if pointer arithmetics would be needed.  Formatting\n+\tfixes.\n+\n 2017-07-28  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/81460"}, {"sha": "6372d3cb1783d324e1ace4dbe6591edb15fceb9d", "filename": "gcc/flag-types.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -238,14 +238,16 @@ enum sanitize_code {\n   SANITIZE_OBJECT_SIZE = 1UL << 21,\n   SANITIZE_VPTR = 1UL << 22,\n   SANITIZE_BOUNDS_STRICT = 1UL << 23,\n+  SANITIZE_POINTER_OVERFLOW = 1UL << 24,\n   SANITIZE_SHIFT = SANITIZE_SHIFT_BASE | SANITIZE_SHIFT_EXPONENT,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN\n \t\t       | SANITIZE_SI_OVERFLOW | SANITIZE_BOOL | SANITIZE_ENUM\n \t\t       | SANITIZE_BOUNDS | SANITIZE_ALIGNMENT\n \t\t       | SANITIZE_NONNULL_ATTRIBUTE\n \t\t       | SANITIZE_RETURNS_NONNULL_ATTRIBUTE\n-\t\t       | SANITIZE_OBJECT_SIZE | SANITIZE_VPTR,\n+\t\t       | SANITIZE_OBJECT_SIZE | SANITIZE_VPTR\n+\t\t       | SANITIZE_POINTER_OVERFLOW,\n   SANITIZE_UNDEFINED_NONDEFAULT = SANITIZE_FLOAT_DIVIDE | SANITIZE_FLOAT_CAST\n \t\t\t\t  | SANITIZE_BOUNDS_STRICT\n };"}, {"sha": "d40b9aaaeb415e805050e039fdd2f24dd9cd5877", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -4859,21 +4859,21 @@ build_range_check (location_t loc, tree type, tree exp, int in_p,\n \n   if (low == 0)\n     return fold_build2_loc (loc, LE_EXPR, type, exp,\n-\t\t\tfold_convert_loc (loc, etype, high));\n+\t\t\t    fold_convert_loc (loc, etype, high));\n \n   if (high == 0)\n     return fold_build2_loc (loc, GE_EXPR, type, exp,\n-\t\t\tfold_convert_loc (loc, etype, low));\n+\t\t\t    fold_convert_loc (loc, etype, low));\n \n   if (operand_equal_p (low, high, 0))\n     return fold_build2_loc (loc, EQ_EXPR, type, exp,\n-\t\t\tfold_convert_loc (loc, etype, low));\n+\t\t\t    fold_convert_loc (loc, etype, low));\n \n   if (TREE_CODE (exp) == BIT_AND_EXPR\n       && maskable_range_p (low, high, etype, &mask, &value))\n     return fold_build2_loc (loc, EQ_EXPR, type,\n \t\t\t    fold_build2_loc (loc, BIT_AND_EXPR, etype,\n-\t\t\t\t\t      exp, mask),\n+\t\t\t\t\t     exp, mask),\n \t\t\t    value);\n \n   if (integer_zerop (low))\n@@ -4905,7 +4905,7 @@ build_range_check (location_t loc, tree type, tree exp, int in_p,\n \t      exp = fold_convert_loc (loc, etype, exp);\n \t    }\n \t  return fold_build2_loc (loc, GT_EXPR, type, exp,\n-\t\t\t      build_int_cst (etype, 0));\n+\t\t\t\t  build_int_cst (etype, 0));\n \t}\n     }\n \n@@ -4915,25 +4915,15 @@ build_range_check (location_t loc, tree type, tree exp, int in_p,\n   if (etype == NULL_TREE)\n     return NULL_TREE;\n \n+  if (POINTER_TYPE_P (etype))\n+    etype = unsigned_type_for (etype);\n+\n   high = fold_convert_loc (loc, etype, high);\n   low = fold_convert_loc (loc, etype, low);\n   exp = fold_convert_loc (loc, etype, exp);\n \n   value = const_binop (MINUS_EXPR, high, low);\n \n-\n-  if (POINTER_TYPE_P (etype))\n-    {\n-      if (value != 0 && !TREE_OVERFLOW (value))\n-\t{\n-\t  low = fold_build1_loc (loc, NEGATE_EXPR, TREE_TYPE (low), low);\n-          return build_range_check (loc, type,\n-\t\t\t     \t    fold_build_pointer_plus_loc (loc, exp, low),\n-\t\t\t            1, build_int_cst (etype, 0), value);\n-\t}\n-      return 0;\n-    }\n-\n   if (value != 0 && !TREE_OVERFLOW (value))\n     return build_range_check (loc, type,\n \t\t\t      fold_build2_loc (loc, MINUS_EXPR, etype, exp, low),"}, {"sha": "e24ed1695159bdf8db1a424499d24265f6d714ab", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -401,6 +401,14 @@ expand_UBSAN_VPTR (internal_fn, gcall *)\n \n /* This should get expanded in the sanopt pass.  */\n \n+static void\n+expand_UBSAN_PTR (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This should get expanded in the sanopt pass.  */\n+\n static void\n expand_UBSAN_OBJECT_SIZE (internal_fn, gcall *)\n {"}, {"sha": "a9a3f7606eb2a79f64dab1b7fdeef0d308e3061d", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -166,6 +166,7 @@ DEF_INTERNAL_FN (UBSAN_VPTR, ECF_LEAF | ECF_NOTHROW, \".RR..\")\n DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (UBSAN_PTR, ECF_LEAF | ECF_NOTHROW, \".R.\")\n DEF_INTERNAL_FN (UBSAN_OBJECT_SIZE, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "5710e8f126db7a53653d8c19d844a9fccbb8be00", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1143,6 +1143,10 @@ input_function (tree fn_decl, struct data_in *data_in,\n \t\t      if ((flag_sanitize & SANITIZE_OBJECT_SIZE) == 0)\n \t\t\tremove = true;\n \t\t      break;\n+\t\t    case IFN_UBSAN_PTR:\n+\t\t      if ((flag_sanitize & SANITIZE_POINTER_OVERFLOW) == 0)\n+\t\t\tremove = true;\n+\t\t      break;\n \t\t    case IFN_ASAN_MARK:\n \t\t      if ((flag_sanitize & SANITIZE_ADDRESS) == 0)\n \t\t\tremove = true;"}, {"sha": "2f9a6380fe10647af311ef2332f4f69bad121a32", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1521,6 +1521,7 @@ const struct sanitizer_opts_s sanitizer_opts[] =\n \t\t true),\n   SANITIZER_OPT (object-size, SANITIZE_OBJECT_SIZE, true),\n   SANITIZER_OPT (vptr, SANITIZE_VPTR, true),\n+  SANITIZER_OPT (pointer-overflow, SANITIZE_POINTER_OVERFLOW, true),\n   SANITIZER_OPT (all, ~0U, true),\n #undef SANITIZER_OPT\n   { NULL, 0U, 0UL, false }"}, {"sha": "c90fa94c4a9b9f6a1533709437c57ca0fc97c32f", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -448,6 +448,10 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_LOAD_INVALID_VALUE,\n \t\t      \"__ubsan_handle_load_invalid_value\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_POINTER_OVERFLOW,\n+\t\t      \"__ubsan_handle_pointer_overflow\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW_ABORT,\n \t\t      \"__ubsan_handle_divrem_overflow_abort\",\n \t\t      BT_FN_VOID_PTR_PTR_PTR,\n@@ -484,6 +488,10 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_LOAD_INVALID_VALUE_ABORT,\n \t\t      \"__ubsan_handle_load_invalid_value_abort\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_POINTER_OVERFLOW_ABORT,\n+\t\t      \"__ubsan_handle_pointer_overflow_abort\",\n+\t\t      BT_FN_VOID_PTR_PTR_PTR,\n+\t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_FLOAT_CAST_OVERFLOW,\n \t\t      \"__ubsan_handle_float_cast_overflow\",\n \t\t      BT_FN_VOID_PTR_PTR,"}, {"sha": "b845f2fab31a8e6465a66201faf6714448d92271", "filename": "gcc/sanopt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1063,6 +1063,9 @@ pass_sanopt::execute (function *fun)\n \t\tcase IFN_UBSAN_OBJECT_SIZE:\n \t\t  no_next = ubsan_expand_objsize_ifn (&gsi);\n \t\t  break;\n+\t\tcase IFN_UBSAN_PTR:\n+\t\t  no_next = ubsan_expand_ptr_ifn (&gsi);\n+\t\t  break;\n \t\tcase IFN_UBSAN_VPTR:\n \t\t  no_next = ubsan_expand_vptr_ifn (&gsi);\n \t\t  break;"}, {"sha": "5c41f4385371e11a78a460c449819f6d1083c233", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -5,6 +5,10 @@\n \n 2017-07-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR sanitizer/80998\n+\t* c-c++-common/ubsan/ptr-overflow-1.c: New test.\n+\t* c-c++-common/ubsan/ptr-overflow-2.c: New test.\n+\n \tPR tree-optimization/81578\n \t* gcc.dg/pr81578.c: New test.\n "}, {"sha": "8edfbce0327f54a9d866f57a69039ffa8203194c", "filename": "gcc/testsuite/c-c++-common/ubsan/ptr-overflow-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-1.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -0,0 +1,65 @@\n+/* PR sanitizer/80998 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=pointer-overflow -fno-sanitize-recover=pointer-overflow -Wall\" } */\n+\n+struct S { int a; int b; int c[64]; };\n+__attribute__((noinline, noclone)) char *f1 (char *p) { return p + 1; }\n+__attribute__((noinline, noclone)) char *f2 (char *p) { return p - 1; }\n+__attribute__((noinline, noclone)) char *f3 (char *p, int i) { return p + i; }\n+__attribute__((noinline, noclone)) char *f4 (char *p, int i) { return p - i; }\n+__attribute__((noinline, noclone)) char *f5 (char *p, unsigned long int i) { return p + i; }\n+__attribute__((noinline, noclone)) char *f6 (char *p, unsigned long int i) { return p - i; }\n+__attribute__((noinline, noclone)) int *f7 (struct S *p) { return &p->a; }\n+__attribute__((noinline, noclone)) int *f8 (struct S *p) { return &p->b; }\n+__attribute__((noinline, noclone)) int *f9 (struct S *p) { return &p->c[64]; }\n+__attribute__((noinline, noclone)) int *f10 (struct S *p, int i) { return &p->c[i]; }\n+\n+char *volatile p;\n+struct S *volatile q;\n+char a[64];\n+struct S s;\n+int *volatile r;\n+\n+int\n+main ()\n+{\n+  struct S t;\n+  p = &a[32];\n+  p = f1 (p);\n+  p = f1 (p);\n+  p = f2 (p);\n+  p = f3 (p, 1);\n+  p = f3 (p, -1);\n+  p = f3 (p, 3);\n+  p = f3 (p, -6);\n+  p = f4 (p, 1);\n+  p = f4 (p, -1);\n+  p = f4 (p, 3);\n+  p = f4 (p, -6);\n+  p = f5 (p, 1);\n+  p = f5 (p, 3);\n+  p = f6 (p, 1);\n+  p = f6 (p, 3);\n+  if (sizeof (unsigned long) >= sizeof (char *))\n+    {\n+      p = f5 (p, -1);\n+      p = f5 (p, -6);\n+      p = f6 (p, -1);\n+      p = f6 (p, -6);\n+    }\n+  q = &s;\n+  r = f7 (q);\n+  r = f8 (q);\n+  r = f9 (q);\n+  r = f10 (q, 0);\n+  r = f10 (q, 10);\n+  r = f10 (q, 64);\n+  q = &t;\n+  r = f7 (q);\n+  r = f8 (q);\n+  r = f9 (q);\n+  r = f10 (q, 0);\n+  r = f10 (q, 10);\n+  r = f10 (q, 64);\n+  return 0;\n+}"}, {"sha": "a1110a2ddbc29e91a77370ff03104e13b89b7e76", "filename": "gcc/testsuite/c-c++-common/ubsan/ptr-overflow-2.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-2.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -0,0 +1,113 @@\n+/* PR sanitizer/80998 */\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=pointer-overflow -fsanitize-recover=pointer-overflow -fno-ipa-icf -Wall\" } */\n+\n+__attribute__((noinline, noclone)) char * f1 (char *p) { return p + 1; }\n+__attribute__((noinline, noclone)) char * f2 (char *p) { return p - 1; }\n+__attribute__((noinline, noclone)) char * f3 (char *p, int i) { return p + i; }\n+__attribute__((noinline, noclone)) char * f4 (char *p, int i) { return p + i; }\n+__attribute__((noinline, noclone)) char * f5 (char *p, int i) { return p - i; }\n+__attribute__((noinline, noclone)) char * f6 (char *p, int i) { return p - i; }\n+__attribute__((noinline, noclone)) char * f7 (char *p, unsigned long int i) { return p + i; }\n+__attribute__((noinline, noclone)) char * f8 (char *p, unsigned long int i) { return p + i; }\n+__attribute__((noinline, noclone)) char * f9 (char *p, unsigned long int i) { return p - i; }\n+__attribute__((noinline, noclone)) char * f10 (char *p, unsigned long int i) { return p - i; }\n+struct S { int a; int b; int c[64]; };\n+__attribute__((noinline, noclone)) int *f11 (struct S *p) { return &p->a; }\n+__attribute__((noinline, noclone)) int *f12 (struct S *p) { return &p->b; }\n+__attribute__((noinline, noclone)) int *f13 (struct S *p) { return &p->c[64]; }\n+__attribute__((noinline, noclone)) int *f14 (struct S *p, int i) { return &p->c[i]; }\n+__attribute__((noinline, noclone)) int *f15 (struct S *p, int i) { return &p->c[i]; }\n+__attribute__((noinline, noclone)) int *f16 (struct S *p) { return &p->a; }\n+__attribute__((noinline, noclone)) int *f17 (struct S *p) { return &p->b; }\n+__attribute__((noinline, noclone)) int *f18 (struct S *p) { return &p->c[64]; }\n+__attribute__((noinline, noclone)) int *f19 (struct S *p, int i) { return &p->c[i]; }\n+__attribute__((noinline, noclone)) int *f20 (struct S *p, int i) { return &p->c[i]; }\n+__attribute__((noinline, noclone)) int *f21 (struct S *p) { return &p->a; }\n+__attribute__((noinline, noclone)) int *f22 (struct S *p) { return &p->b; }\n+__attribute__((noinline, noclone)) int *f23 (struct S *p) { return &p->c[64]; }\n+__attribute__((noinline, noclone)) int *f24 (struct S *p, int i) { return &p->c[i]; }\n+__attribute__((noinline, noclone)) int *f25 (struct S *p, int i) { return &p->c[i]; }\n+\n+char *volatile p;\n+__UINTPTR_TYPE__ volatile u;\n+struct S *volatile q;\n+int *volatile r;\n+\n+int\n+main ()\n+{\n+  u = ~(__UINTPTR_TYPE__) 0;\n+  p = (char *) u;\n+  p = f1 (p);\n+  u = 0;\n+  p = (char *) u;\n+  p = f2 (p);\n+  u = -(__UINTPTR_TYPE__) 7;\n+  p = (char *) u;\n+  p = f3 (p, 7);\n+  u = 3;\n+  p = (char *) u;\n+  p = f4 (p, -4);\n+  u = 23;\n+  p = (char *) u;\n+  p = f5 (p, 27);\n+  u = -(__UINTPTR_TYPE__) 15;\n+  p = (char *) u;\n+  p = f6 (p, -15);\n+  u = -(__UINTPTR_TYPE__) 29;\n+  p = (char *) u;\n+  p = f7 (p, 31);\n+  u = 23;\n+  p = (char *) u;\n+  p = f9 (p, 24);\n+  if (sizeof (unsigned long) < sizeof (char *))\n+    return 0;\n+  u = 7;\n+  p = (char *) u;\n+  p = f8 (p, -8);\n+  u = -(__UINTPTR_TYPE__) 25;\n+  p = (char *) u;\n+  p = f10 (p, -25);\n+  u = ~(__UINTPTR_TYPE__) 0;\n+  q = (struct S *) u;\n+  r = f11 (q);\n+  r = f12 (q);\n+  r = f13 (q);\n+  r = f14 (q, 0);\n+  r = f15 (q, 63);\n+  u = ~(__UINTPTR_TYPE__) 0 - (17 * sizeof (int));\n+  q = (struct S *) u;\n+  r = f16 (q);\n+  r = f17 (q);\n+  r = f18 (q);\n+  r = f19 (q, 0);\n+  r = f20 (q, 63);\n+  u = 3 * sizeof (int);\n+  q = (struct S *) u;\n+  r = f21 (q);\n+  r = f22 (q);\n+  r = f23 (q);\n+  r = f24 (q, -2);\n+  r = f25 (q, -6);\n+  return 0;\n+}\n+\n+/* { dg-output \":5:6\\[79]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+ overflowed to (0\\[xX])?0\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:6:6\\[79]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?0\\+ overflowed to (0\\[xX])?\\[fF]\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:7:7\\[46]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+9 overflowed to (0\\[xX])?0\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:8:7\\[46]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?0\\+3 overflowed to (0\\[xX])?\\[fF]\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:9:7\\[46]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?0\\+17 overflowed to (0\\[xX])?\\[fF]\\+\\[cC](\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:10:7\\[46]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+1 overflowed to (0\\[xX])?0\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:11:\\[89]\\[80]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+\\[eE]3 overflowed to (0\\[xX])?0\\+2(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:13:\\[89]\\[80]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?0\\+17 overflowed to (0\\[xX])?\\[fF]\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:12:\\[89]\\[80]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?0\\+7 overflowed to (0\\[xX])?\\[fF]\\+(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*:14:\\[89]\\[91]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+\\[eE]7 overflowed to (0\\[xX])?0\\+\" } */\n+/* { dg-output \"(\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:17:\\[67]\\[82]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+ overflowed to (0\\[xX])?0\\+3(\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:18:\\[67]\\[86]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+ overflowed to (0\\[xX])?0\\+107(\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:19:\\[78]\\[52]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+ overflowed to (0\\[xX])?0\\+7(\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:20:\\[78]\\[52]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+ overflowed to (0\\[xX])?0\\+103(\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:23:\\[67]\\[86]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+\\[bB]\\[bB] overflowed to (0\\[xX])?0\\+\\[cC]3(\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:25:\\[78]\\[52]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?\\[fF]\\+\\[bB]\\[bB] overflowed to (0\\[xX])?0\\+\\[bB]\\[fF](\\n|\\r\\n|\\r)\" { target int32 } } */\n+/* { dg-output \"\\[^\\n\\r]*:30:\\[78]\\[52]\\[^\\n\\r]*runtime error: pointer index expression with base (0\\[xX])?0\\+\\[cC] overflowed to (0\\[xX])?\\[fF]\\+\\[cC]\" { target int32 } } */"}, {"sha": "5794d227fe53c5f6eb72c7594813fd0f5897812a", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1991,6 +1991,7 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)\n       case IFN_UBSAN_BOUNDS:\n       case IFN_UBSAN_VPTR:\n       case IFN_UBSAN_OBJECT_SIZE:\n+      case IFN_UBSAN_PTR:\n       case IFN_ASAN_CHECK:\n \treturn false;\n       default:"}, {"sha": "a65ff31d900951c527ccf4f64c0415bb5639b278", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1241,6 +1241,7 @@ merge_stmts_p (gimple *stmt1, gimple *stmt2)\n       case IFN_UBSAN_CHECK_SUB:\n       case IFN_UBSAN_CHECK_MUL:\n       case IFN_UBSAN_OBJECT_SIZE:\n+      case IFN_UBSAN_PTR:\n       case IFN_ASAN_CHECK:\n \t/* For these internal functions, gimple_location is an implicit\n \t   parameter, which will be used explicitly after expansion."}, {"sha": "cca3c2d85d3d01ae5185394987d13d9e625c8566", "filename": "gcc/ubsan.c", "status": "modified", "additions": 300, "deletions": 2, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-object-size.h\"\n #include \"tree-cfg.h\"\n+#include \"gimple-fold.h\"\n+#include \"varasm.h\"\n \n /* Map from a tree to a VAR_DECL tree.  */\n \n@@ -1029,6 +1031,170 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n+/* Expand UBSAN_PTR internal call.  */\n+\n+bool\n+ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n+{\n+  gimple_stmt_iterator gsi = *gsip;\n+  gimple *stmt = gsi_stmt (gsi);\n+  location_t loc = gimple_location (stmt);\n+  gcc_assert (gimple_call_num_args (stmt) == 2);\n+  tree ptr = gimple_call_arg (stmt, 0);\n+  tree off = gimple_call_arg (stmt, 1);\n+\n+  if (integer_zerop (off))\n+    {\n+      gsi_remove (gsip, true);\n+      unlink_stmt_vdef (stmt);\n+      return true;\n+    }\n+\n+  basic_block cur_bb = gsi_bb (gsi);\n+  tree ptrplusoff = make_ssa_name (pointer_sized_int_node);\n+  tree ptri = make_ssa_name (pointer_sized_int_node);\n+  int pos_neg = get_range_pos_neg (off);\n+\n+  /* Split the original block holding the pointer dereference.  */\n+  edge e = split_block (cur_bb, stmt);\n+\n+  /* Get a hold on the 'condition block', the 'then block' and the\n+     'else block'.  */\n+  basic_block cond_bb = e->src;\n+  basic_block fallthru_bb = e->dest;\n+  basic_block then_bb = create_empty_bb (cond_bb);\n+  basic_block cond_pos_bb = NULL, cond_neg_bb = NULL;\n+  add_bb_to_loop (then_bb, cond_bb->loop_father);\n+  loops_state_set (LOOPS_NEED_FIXUP);\n+\n+  /* Set up the fallthrough basic block.  */\n+  e->flags = EDGE_FALSE_VALUE;\n+  if (pos_neg != 3)\n+    {\n+      e->count = cond_bb->count;\n+      e->probability = profile_probability::very_likely ();\n+\n+      /* Connect 'then block' with the 'else block'.  This is needed\n+\t as the ubsan routines we call in the 'then block' are not noreturn.\n+\t The 'then block' only has one outcoming edge.  */\n+      make_single_succ_edge (then_bb, fallthru_bb, EDGE_FALLTHRU);\n+\n+      /* Make an edge coming from the 'cond block' into the 'then block';\n+\t this edge is unlikely taken, so set up the probability\n+\t accordingly.  */\n+      e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+      e->probability = profile_probability::very_unlikely ();\n+    }\n+  else\n+    {\n+      profile_count count = cond_bb->count.apply_probability (PROB_EVEN);\n+      e->count = count;\n+      e->probability = profile_probability::even ();\n+\n+      e = split_block (fallthru_bb, (gimple *) NULL);\n+      cond_neg_bb = e->src;\n+      fallthru_bb = e->dest;\n+      e->count = count;\n+      e->probability = profile_probability::very_likely ();\n+      e->flags = EDGE_FALSE_VALUE;\n+\n+      e = make_edge (cond_neg_bb, then_bb, EDGE_TRUE_VALUE);\n+      e->probability = profile_probability::very_unlikely ();\n+\n+      cond_pos_bb = create_empty_bb (cond_bb);\n+      add_bb_to_loop (cond_pos_bb, cond_bb->loop_father);\n+\n+      e = make_edge (cond_bb, cond_pos_bb, EDGE_TRUE_VALUE);\n+      e->count = count;\n+      e->probability = profile_probability::even ();\n+\n+      e = make_edge (cond_pos_bb, then_bb, EDGE_TRUE_VALUE);\n+      e->probability = profile_probability::very_unlikely ();\n+\n+      e = make_edge (cond_pos_bb, fallthru_bb, EDGE_FALSE_VALUE);\n+      e->count = count;\n+      e->probability = profile_probability::very_likely ();\n+\n+      make_single_succ_edge (then_bb, fallthru_bb, EDGE_FALLTHRU);\n+    }\n+\n+  gimple *g = gimple_build_assign (ptri, NOP_EXPR, ptr);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+  g = gimple_build_assign (ptrplusoff, PLUS_EXPR, ptri, off);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+  /* Update dominance info for the newly created then_bb; note that\n+     fallthru_bb's dominance info has already been updated by\n+     split_block.  */\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+      if (pos_neg == 3)\n+\t{\n+\t  set_immediate_dominator (CDI_DOMINATORS, cond_pos_bb, cond_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, fallthru_bb, cond_bb);\n+\t}\n+    }\n+\n+  /* Put the ubsan builtin call into the newly created BB.  */\n+  if (flag_sanitize_undefined_trap_on_error)\n+    g = gimple_build_call (builtin_decl_implicit (BUILT_IN_TRAP), 0);\n+  else\n+    {\n+      enum built_in_function bcode\n+\t= (flag_sanitize_recover & SANITIZE_POINTER_OVERFLOW)\n+\t  ? BUILT_IN_UBSAN_HANDLE_POINTER_OVERFLOW\n+\t  : BUILT_IN_UBSAN_HANDLE_POINTER_OVERFLOW_ABORT;\n+      tree fn = builtin_decl_implicit (bcode);\n+      tree data\n+\t= ubsan_create_data (\"__ubsan_ptrovf_data\", 1, &loc,\n+\t\t\t     NULL_TREE, NULL_TREE);\n+      data = build_fold_addr_expr_loc (loc, data);\n+      g = gimple_build_call (fn, 3, data, ptr, ptrplusoff);\n+    }\n+  gimple_stmt_iterator gsi2 = gsi_start_bb (then_bb);\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n+\n+  /* Unlink the UBSAN_PTRs vops before replacing it.  */\n+  unlink_stmt_vdef (stmt);\n+\n+  if (TREE_CODE (off) == INTEGER_CST)\n+    g = gimple_build_cond (wi::neg_p (off) ? LT_EXPR : GE_EXPR, ptri,\n+\t\t\t   fold_build1 (NEGATE_EXPR, sizetype, off),\n+\t\t\t   NULL_TREE, NULL_TREE);\n+  else if (pos_neg != 3)\n+    g = gimple_build_cond (pos_neg == 1 ? LT_EXPR : GT_EXPR,\n+\t\t\t   ptrplusoff, ptri, NULL_TREE, NULL_TREE);\n+  else\n+    {\n+      gsi2 = gsi_start_bb (cond_pos_bb);\n+      g = gimple_build_cond (LT_EXPR, ptrplusoff, ptri, NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n+\n+      gsi2 = gsi_start_bb (cond_neg_bb);\n+      g = gimple_build_cond (GT_EXPR, ptrplusoff, ptri, NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      gsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n+\n+      gimple_seq seq = NULL;\n+      tree t = gimple_build (&seq, loc, NOP_EXPR, ssizetype, off);\n+      t = gimple_build (&seq, loc, GE_EXPR, boolean_type_node,\n+\t\t\tt, ssize_int (0));\n+      gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+      g = gimple_build_cond (NE_EXPR, t, boolean_false_node,\n+\t\t\t     NULL_TREE, NULL_TREE);\n+    }\n+  gimple_set_location (g, loc);\n+  /* Replace the UBSAN_PTR with a GIMPLE_COND stmt.  */\n+  gsi_replace (&gsi, g, false);\n+  return false;\n+}\n+\n+\n /* Cached __ubsan_vptr_type_cache decl.  */\n static GTY(()) tree ubsan_vptr_type_cache_decl;\n \n@@ -1234,6 +1400,111 @@ instrument_null (gimple_stmt_iterator gsi, tree t, bool is_lhs)\n     instrument_mem_ref (t, base, &gsi, is_lhs);\n }\n \n+/* Instrument pointer arithmetics PTR p+ OFF.  */\n+\n+static void\n+instrument_pointer_overflow (gimple_stmt_iterator *gsi, tree ptr, tree off)\n+{\n+  if (TYPE_PRECISION (sizetype) != POINTER_SIZE)\n+    return;\n+  gcall *g = gimple_build_call_internal (IFN_UBSAN_PTR, 2, ptr, off);\n+  gimple_set_location (g, gimple_location (gsi_stmt (*gsi)));\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+}\n+\n+/* Instrument pointer arithmetics if any.  */\n+\n+static void\n+maybe_instrument_pointer_overflow (gimple_stmt_iterator *gsi, tree t)\n+{\n+  if (TYPE_PRECISION (sizetype) != POINTER_SIZE)\n+    return;\n+\n+  /* Handle also e.g. &s->i.  */\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  if (!handled_component_p (t) && TREE_CODE (t) != MEM_REF)\n+    return;\n+\n+  HOST_WIDE_INT bitsize, bitpos, bytepos;\n+  tree offset;\n+  machine_mode mode;\n+  int volatilep = 0, reversep, unsignedp = 0;\n+  tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t    &unsignedp, &reversep, &volatilep);\n+  tree moff = NULL_TREE;\n+\n+  bool decl_p = DECL_P (inner);\n+  tree base;\n+  if (decl_p)\n+    {\n+      if (DECL_REGISTER (inner))\n+\treturn;\n+      base = inner;\n+      /* If BASE is a fixed size automatic variable or\n+\t global variable defined in the current TU and bitpos\n+\t fits, don't instrument anything.  */\n+      if (offset == NULL_TREE\n+\t  && bitpos > 0\n+\t  && (VAR_P (base)\n+\t      || TREE_CODE (base) == PARM_DECL\n+\t      || TREE_CODE (base) == RESULT_DECL)\n+\t  && DECL_SIZE (base)\n+\t  && TREE_CODE (DECL_SIZE (base)) == INTEGER_CST\n+\t  && compare_tree_int (DECL_SIZE (base), bitpos) >= 0\n+\t  && (!is_global_var (base) || decl_binds_to_current_def_p (base)))\n+\treturn;\n+    }\n+  else if (TREE_CODE (inner) == MEM_REF)\n+    {\n+      base = TREE_OPERAND (inner, 0);\n+      if (TREE_CODE (base) == ADDR_EXPR\n+\t  && DECL_P (TREE_OPERAND (base, 0))\n+\t  && !TREE_ADDRESSABLE (TREE_OPERAND (base, 0))\n+\t  && !is_global_var (TREE_OPERAND (base, 0)))\n+\treturn;\n+      moff = TREE_OPERAND (inner, 1);\n+      if (integer_zerop (moff))\n+\tmoff = NULL_TREE;\n+    }\n+  else\n+    return;\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (base)) && !DECL_P (base))\n+    return;\n+  bytepos = bitpos / BITS_PER_UNIT;\n+  if (offset == NULL_TREE && bytepos == 0 && moff == NULL_TREE)\n+    return;\n+\n+  tree base_addr = base;\n+  if (decl_p)\n+    base_addr = build1 (ADDR_EXPR,\n+\t\t\tbuild_pointer_type (TREE_TYPE (base)), base);\n+  t = offset;\n+  if (bytepos)\n+    {\n+      if (t)\n+\tt = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t,\n+\t\t\t build_int_cst (TREE_TYPE (t), bytepos));\n+      else\n+\tt = size_int (bytepos);\n+    }\n+  if (moff)\n+    {\n+      if (t)\n+\tt = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t,\n+\t\t\t fold_convert (TREE_TYPE (t), moff));\n+      else\n+\tt = fold_convert (sizetype, moff);\n+    }\n+  t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, true,\n+\t\t\t\tGSI_SAME_STMT);\n+  base_addr = force_gimple_operand_gsi (gsi, base_addr, true, NULL_TREE, true,\n+\t\t\t\t\tGSI_SAME_STMT);\n+  instrument_pointer_overflow (gsi, base_addr, t);\n+}\n+\n /* Build an ubsan builtin call for the signed-integer-overflow\n    sanitization.  CODE says what kind of builtin are we building,\n    LOC is a location, LHSTYPE is the type of LHS, OP0 and OP1\n@@ -1849,7 +2120,7 @@ instrument_object_size (gimple_stmt_iterator *gsi, tree t, bool is_lhs)\n \t{\n \t  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n \t  if (TREE_CODE (rhs1) == SSA_NAME\n-\t    && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs1))\n+\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs1))\n \t    break;\n \t  else\n \t    base = rhs1;\n@@ -1973,7 +2244,8 @@ class pass_ubsan : public gimple_opt_pass\n \t\t\t\t| SANITIZE_ALIGNMENT\n \t\t\t\t| SANITIZE_NONNULL_ATTRIBUTE\n \t\t\t\t| SANITIZE_RETURNS_NONNULL_ATTRIBUTE\n-\t\t\t\t| SANITIZE_OBJECT_SIZE));\n+\t\t\t\t| SANITIZE_OBJECT_SIZE\n+\t\t\t\t| SANITIZE_POINTER_OVERFLOW));\n     }\n \n   virtual unsigned int execute (function *);\n@@ -2065,6 +2337,32 @@ pass_ubsan::execute (function *fun)\n \t\t}\n \t    }\n \n+\t  if (sanitize_flags_p (SANITIZE_POINTER_OVERFLOW, fun->decl))\n+\t    {\n+\t      if (is_gimple_assign (stmt)\n+\t\t  && gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+\t\tinstrument_pointer_overflow (&gsi,\n+\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t     gimple_assign_rhs2 (stmt));\n+\t      if (gimple_store_p (stmt))\n+\t\tmaybe_instrument_pointer_overflow (&gsi,\n+\t\t\t\t\t\t   gimple_get_lhs (stmt));\n+\t      if (gimple_assign_single_p (stmt))\n+\t\tmaybe_instrument_pointer_overflow (&gsi,\n+\t\t\t\t\t\t   gimple_assign_rhs1 (stmt));\n+\t      if (is_gimple_call (stmt))\n+\t\t{\n+\t\t  unsigned args_num = gimple_call_num_args (stmt);\n+\t\t  for (unsigned i = 0; i < args_num; ++i)\n+\t\t    {\n+\t\t      tree arg = gimple_call_arg (stmt, i);\n+\t\t      if (is_gimple_reg (arg))\n+\t\t\tcontinue;\n+\t\t      maybe_instrument_pointer_overflow (&gsi, arg);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  gsi_next (&gsi);\n \t}\n       if (gimple_purge_dead_eh_edges (bb))"}, {"sha": "20a33473689d34c4adcf889a5c87a4c1b44d8c8d", "filename": "gcc/ubsan.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -52,6 +52,7 @@ enum ubsan_encode_value_phase {\n extern bool ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_null_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_objsize_ifn (gimple_stmt_iterator *);\n+extern bool ubsan_expand_ptr_ifn (gimple_stmt_iterator *);\n extern bool ubsan_expand_vptr_ifn (gimple_stmt_iterator *);\n extern bool ubsan_instrument_unreachable (gimple_stmt_iterator *);\n extern tree ubsan_create_data (const char *, int, const location_t *, ...);"}, {"sha": "75c9f0cecd0575423ea81217265473242a8b4080", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -1,3 +1,10 @@\n+2017-07-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/80998\n+\t* ubsan/ubsan_handlers.cc: Cherry-pick upstream r304461.\n+\t* ubsan/ubsan_checks.inc: Likewise.\n+\t* ubsan/ubsan_handlers.h: Likewise.\n+\n 2017-07-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/81066"}, {"sha": "31e9495e3012e9fd2499ba2540215bd6a87e44c9", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -17,6 +17,7 @@\n \n UBSAN_CHECK(GenericUB, \"undefined-behavior\", \"undefined\")\n UBSAN_CHECK(NullPointerUse, \"null-pointer-use\", \"null\")\n+UBSAN_CHECK(PointerOverflow, \"pointer-overflow\", \"pointer-overflow\")\n UBSAN_CHECK(MisalignedPointerUse, \"misaligned-pointer-use\", \"alignment\")\n UBSAN_CHECK(InsufficientObjectSize, \"insufficient-object-size\", \"object-size\")\n UBSAN_CHECK(SignedIntegerOverflow, \"signed-integer-overflow\","}, {"sha": "761ccef63f35954184f09cb29622aa1a4d3af1c1", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -521,6 +521,37 @@ void __ubsan::__ubsan_handle_nonnull_arg_abort(NonNullArgData *Data) {\n   Die();\n }\n \n+static void handlePointerOverflowImpl(PointerOverflowData *Data,\n+                                      ValueHandle Base,\n+                                      ValueHandle Result,\n+                                      ReportOptions Opts) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  ErrorType ET = ErrorType::PointerOverflow;\n+\n+  if (ignoreReport(Loc, Opts, ET))\n+    return;\n+\n+  ScopedReport R(Opts, Loc, ET);\n+\n+  Diag(Loc, DL_Error, \"pointer index expression with base %0 overflowed to %1\")\n+    << (void *)Base << (void*)Result;\n+}\n+\n+void __ubsan::__ubsan_handle_pointer_overflow(PointerOverflowData *Data,\n+                                              ValueHandle Base,\n+                                              ValueHandle Result) {\n+  GET_REPORT_OPTIONS(false);\n+  handlePointerOverflowImpl(Data, Base, Result, Opts);\n+}\n+\n+void __ubsan::__ubsan_handle_pointer_overflow_abort(PointerOverflowData *Data,\n+                                                    ValueHandle Base,\n+                                                    ValueHandle Result) {\n+  GET_REPORT_OPTIONS(true);\n+  handlePointerOverflowImpl(Data, Base, Result, Opts);\n+  Die();\n+}\n+\n static void handleCFIBadIcall(CFICheckFailData *Data, ValueHandle Function,\n                               ReportOptions Opts) {\n   if (Data->CheckKind != CFITCK_ICall)"}, {"sha": "d04554acee3a186e1feb9e745bb96ab57c54742d", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b39a4955f56fe609ef54784f7bf48c4cba6b1a/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=c9b39a4955f56fe609ef54784f7bf48c4cba6b1a", "patch": "@@ -146,6 +146,13 @@ struct NonNullArgData {\n /// \\brief Handle passing null pointer to function with nonnull attribute.\n RECOVERABLE(nonnull_arg, NonNullArgData *Data)\n \n+struct PointerOverflowData {\n+  SourceLocation Loc;\n+};\n+\n+RECOVERABLE(pointer_overflow, PointerOverflowData *Data, ValueHandle Base,\n+            ValueHandle Result)\n+\n /// \\brief Known CFI check kinds.\n /// Keep in sync with the enum of the same name in CodeGenFunction.h\n enum CFITypeCheckKind : unsigned char {"}]}