{"sha": "e3c8ea672563a4f8762b60f302a0a13c788405f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNjOGVhNjcyNTYzYTRmODc2MmI2MGYzMDJhMGExM2M3ODg0MDVmNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-21T23:06:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-21T23:06:16Z"}, "message": "emit-rtl.c (offset_address): Use simplify_gen_binary rather than gen_rtx_PLUS to form the sum.\n\n        * emit-rtl.c (offset_address): Use simplify_gen_binary rather\n        than gen_rtx_PLUS to form the sum.\n        * explow.c (force_reg): Rearrange to not allocate new pseudo\n        when force_operand returns a register.\n        * expr.c (expand_assignment): Allow offset_rtx expansion to\n        return a sum.  Do not force addresses into registers.\n        (expand_expr): Likewise.\n        * simplify-rtx.c (simplify_gen_binary): Use simplify_plus_minus\n        to canonicalize arithmetic that didn't simpify.\n        (simplify_plus_minus): New argument force; update\n        all callers.  Don't split CONST unless we can do something with it,\n        and wouldn't lose the constness of the operands.\n\n        * config/i386/i386.c (legitimize_pic_address): Recognize UNSPECs\n        that we generated earlier.\n\nFrom-SVN: r49945", "tree": {"sha": "a3e850cb8cef839fc826131f523c7a39605ea9d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3e850cb8cef839fc826131f523c7a39605ea9d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3c8ea672563a4f8762b60f302a0a13c788405f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c8ea672563a4f8762b60f302a0a13c788405f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c8ea672563a4f8762b60f302a0a13c788405f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c8ea672563a4f8762b60f302a0a13c788405f7/comments", "author": null, "committer": null, "parents": [{"sha": "c1a046e50ee5d3fe4b789ed2ad51c60db6687788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a046e50ee5d3fe4b789ed2ad51c60db6687788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a046e50ee5d3fe4b789ed2ad51c60db6687788"}], "stats": {"total": 166, "additions": 109, "deletions": 57}, "files": [{"sha": "8a8dcac21e7050a586815fe3ea7c8c1993531e65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3c8ea672563a4f8762b60f302a0a13c788405f7", "patch": "@@ -1,3 +1,21 @@\n+2002-02-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* emit-rtl.c (offset_address): Use simplify_gen_binary rather\n+\tthan gen_rtx_PLUS to form the sum.\n+\t* explow.c (force_reg): Rearrange to not allocate new pseudo\n+\twhen force_operand returns a register.\n+\t* expr.c (expand_assignment): Allow offset_rtx expansion to\n+\treturn a sum.  Do not force addresses into registers.\n+\t(expand_expr): Likewise.\n+\t* simplify-rtx.c (simplify_gen_binary): Use simplify_plus_minus\n+\tto canonicalize arithmetic that didn't simpify.\n+\t(simplify_plus_minus): New argument force; update\n+\tall callers.  Don't split CONST unless we can do something with it,\n+\tand wouldn't lose the constness of the operands.\n+\n+\t* config/i386/i386.c (legitimize_pic_address): Recognize UNSPECs\n+\tthat we generated earlier.\n+\n 2002-02-21  Tom Tromey  <tromey@redhat.com>\n \n \t* dwarf2out.c (DWARF_LINE_MIN_INSTR_LENGTH): Removed."}, {"sha": "009b5d8511bc02c6b63d164bea3f4b0b92f60e6d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e3c8ea672563a4f8762b60f302a0a13c788405f7", "patch": "@@ -4986,11 +4986,15 @@ legitimize_pic_address (orig, reg)\n       if (GET_CODE (addr) == CONST)\n \t{\n \t  addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) == UNSPEC)\n-\t    {\n-\t      /* Check that the unspec is one of the ones we generate?  */\n-\t    }\n-\t  else if (GET_CODE (addr) != PLUS)\n+\n+\t  /* We must match stuff we generate before.  Assume the only\n+\t     unspecs that can get here are ours.  Not that we could do\n+\t     anything with them anyway...  */\n+\t  if (GET_CODE (addr) == UNSPEC\n+\t      || (GET_CODE (addr) == PLUS\n+\t\t  && GET_CODE (XEXP (addr, 0)) == UNSPEC))\n+\t    return orig;\n+\t  if (GET_CODE (addr) != PLUS)\n \t    abort ();\n \t}\n       if (GET_CODE (addr) == PLUS)"}, {"sha": "836fbf5385ab1a29a7bef285dc16d081e3e5865e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e3c8ea672563a4f8762b60f302a0a13c788405f7", "patch": "@@ -2047,9 +2047,26 @@ offset_address (memref, offset, pow2)\n      rtx offset;\n      HOST_WIDE_INT pow2;\n {\n-  rtx new = change_address_1 (memref, VOIDmode,\n-\t\t\t      gen_rtx_PLUS (Pmode, XEXP (memref, 0),\n-\t\t\t\t\t    force_reg (Pmode, offset)), 1);\n+  rtx new, addr = XEXP (memref, 0);\n+\n+  new = simplify_gen_binary (PLUS, Pmode, addr, offset);\n+\n+  /* At this point we don't know _why_ the address is invalid.  It \n+     could have secondary memory refereces, multiplies or anything.\n+\n+     However, if we did go and rearrange things, we can wind up not\n+     being able to recognize the magic around pic_offset_table_rtx.\n+     This stuff is fragile, and is yet another example of why it is\n+     bad to expose PIC machinery too early.  */\n+  if (! memory_address_p (GET_MODE (memref), new)\n+      && GET_CODE (addr) == PLUS\n+      && XEXP (addr, 0) == pic_offset_table_rtx)\n+    {\n+      addr = force_reg (GET_MODE (addr), addr);\n+      new = simplify_gen_binary (PLUS, Pmode, addr, offset);\n+    }\n+\n+  new = change_address_1 (memref, VOIDmode, new, 1);\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */"}, {"sha": "7a770ee897cfa04e17f37d2b566b81e4e432af54", "filename": "gcc/explow.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=e3c8ea672563a4f8762b60f302a0a13c788405f7", "patch": "@@ -732,12 +732,23 @@ force_reg (mode, x)\n   if (GET_CODE (x) == REG)\n     return x;\n \n-  temp = gen_reg_rtx (mode);\n-\n-  if (! general_operand (x, mode))\n-    x = force_operand (x, NULL_RTX);\n-\n-  insn = emit_move_insn (temp, x);\n+  if (general_operand (x, mode))\n+    {\n+      temp = gen_reg_rtx (mode);\n+      insn = emit_move_insn (temp, x);\n+    }\n+  else\n+    {\n+      temp = force_operand (x, NULL_RTX);\n+      if (GET_CODE (temp) == REG)\n+\tinsn = get_last_insn ();\n+      else\n+\t{\n+\t  rtx temp2 = gen_reg_rtx (mode);\n+\t  insn = emit_move_insn (temp2, temp);\n+\t  temp = temp2;\n+\t}\n+    }\n \n   /* Let optimizers know that TEMP's value never changes\n      and that X can be substituted for it.  Don't get confused\n@@ -746,6 +757,7 @@ force_reg (mode, x)\n       && (set = single_set (insn)) != 0\n       && SET_DEST (set) == temp)\n     set_unique_reg_note (insn, REG_EQUAL, x);\n+\n   return temp;\n }\n "}, {"sha": "b7304350b7f648efb20f6609b82e2a3ada1816e8", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e3c8ea672563a4f8762b60f302a0a13c788405f7", "patch": "@@ -3659,7 +3659,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n       if (offset != 0)\n \t{\n-\t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n+\t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, EXPAND_SUM);\n \n \t  if (GET_CODE (to_rtx) != MEM)\n \t    abort ();\n@@ -3682,15 +3682,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t      && (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t      && MEM_ALIGN (to_rtx) == GET_MODE_ALIGNMENT (mode1))\n \t    {\n-\t      rtx temp\n-\t\t= adjust_address (to_rtx, mode1, bitpos / BITS_PER_UNIT);\n-\n-\t      if (GET_CODE (XEXP (temp, 0)) == REG)\n-\t        to_rtx = temp;\n-\t      else\n-\t\tto_rtx = (replace_equiv_address\n-\t\t\t  (to_rtx, force_reg (GET_MODE (XEXP (temp, 0)),\n-\t\t\t\t\t      XEXP (temp, 0))));\n+\t      to_rtx = adjust_address (to_rtx, mode1, bitpos / BITS_PER_UNIT);\n \t      bitpos = 0;\n \t    }\n \n@@ -6852,7 +6844,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (offset != 0)\n \t  {\n-\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n+\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, EXPAND_SUM);\n \n \t    /* If this object is in a register, put it into memory.\n \t       This case can't occur in C, but can in Ada if we have\n@@ -6902,15 +6894,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t\t&& MEM_ALIGN (op0) == GET_MODE_ALIGNMENT (mode1))\n \t      {\n-\t\trtx temp = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n-\n-\t\tif (GET_CODE (XEXP (temp, 0)) == REG)\n-\t\t  op0 = temp;\n-\t\telse\n-\t\t  op0 = (replace_equiv_address\n-\t\t\t (op0,\n-\t\t\t  force_reg (GET_MODE (XEXP (temp, 0)),\n-\t\t\t\t     XEXP (temp, 0))));\n+\t\top0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \t\tbitpos = 0;\n \t      }\n "}, {"sha": "55cbfc6fbbe32b7775508837616faac59d1cd210", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3c8ea672563a4f8762b60f302a0a13c788405f7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=e3c8ea672563a4f8762b60f302a0a13c788405f7", "patch": "@@ -99,7 +99,8 @@ static rtx neg_const_int PARAMS ((enum machine_mode, rtx));\n static int simplify_plus_minus_op_data_cmp PARAMS ((const void *,\n \t\t\t\t\t\t    const void *));\n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx, rtx));\n+\t\t\t\t\t\t enum machine_mode, rtx,\n+\t\t\t\t\t\t rtx, int));\n static void check_fold_consts\t\tPARAMS ((PTR));\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n static void simplify_unary_real\t\tPARAMS ((PTR));\n@@ -137,21 +138,14 @@ simplify_gen_binary (code, mode, op0, op1)\n \n   /* If this simplifies, do it.  */\n   tem = simplify_binary_operation (code, mode, op0, op1);\n-\n   if (tem)\n     return tem;\n \n-  /* Handle addition and subtraction of CONST_INT specially.  Otherwise,\n-     just form the operation.  */\n+  /* Handle addition and subtraction specially.  Otherwise, just form\n+     the operation.  */\n \n-  if (GET_CODE (op1) == CONST_INT\n-      && GET_MODE (op0) != VOIDmode\n-      && (code == PLUS || code == MINUS))\n-    {\n-      if (code == MINUS)\n-\top1 = neg_const_int (mode, op1);\n-      return plus_constant (op0, INTVAL (op1));\n-    }\n+  if (code == PLUS || code == MINUS)\n+    return simplify_plus_minus (code, mode, op0, op1, 1);\n   else\n     return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n@@ -1152,7 +1146,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\t      && GET_CODE (XEXP (op0, 0)) == PLUS)\n \t\t  || (GET_CODE (op1) == CONST\n \t\t      && GET_CODE (XEXP (op1, 0)) == PLUS))\n-\t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n+\t      && (tem = simplify_plus_minus (code, mode, op0, op1, 0)) != 0)\n \t    return tem;\n \t  break;\n \n@@ -1289,7 +1283,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\t      && GET_CODE (XEXP (op0, 0)) == PLUS)\n \t\t  || (GET_CODE (op1) == CONST\n \t\t      && GET_CODE (XEXP (op1, 0)) == PLUS))\n-\t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n+\t      && (tem = simplify_plus_minus (code, mode, op0, op1, 0)) != 0)\n \t    return tem;\n \n \t  /* Don't let a relocatable value get a negative coeff.  */\n@@ -1728,7 +1722,10 @@ simplify_binary_operation (code, mode, op0, op1)\n \n    Rather than test for specific case, we do this by a brute-force method\n    and do all possible simplifications until no more changes occur.  Then\n-   we rebuild the operation.  */\n+   we rebuild the operation. \n+\n+   If FORCE is true, then always generate the rtx.  This is used to \n+   canonicalize stuff emitted from simplify_gen_binary.  */\n \n struct simplify_plus_minus_op_data\n {\n@@ -1749,10 +1746,11 @@ simplify_plus_minus_op_data_cmp (p1, p2)\n }\n \n static rtx\n-simplify_plus_minus (code, mode, op0, op1)\n+simplify_plus_minus (code, mode, op0, op1, force)\n      enum rtx_code code;\n      enum machine_mode mode;\n      rtx op0, op1;\n+     int force;\n {\n   struct simplify_plus_minus_op_data ops[8];\n   rtx result, tem;\n@@ -1786,7 +1784,11 @@ simplify_plus_minus (code, mode, op0, op1)\n \t    case PLUS:\n \t    case MINUS:\n \t      if (n_ops == 7)\n-\t\treturn 0;\n+\t\t{\n+\t\t  if (force)\n+\t\t    abort ();\n+\t\t  return NULL_RTX;\n+\t\t}\n \n \t      ops[n_ops].op = XEXP (this_op, 1);\n \t      ops[n_ops].neg = (this_code == MINUS) ^ this_neg;\n@@ -1804,9 +1806,18 @@ simplify_plus_minus (code, mode, op0, op1)\n \t      break;\n \n \t    case CONST:\n-\t      ops[i].op = XEXP (this_op, 0);\n-\t      input_consts++;\n-\t      changed = 1;\n+\t      if (n_ops < 7\n+\t\t  && GET_CODE (XEXP (this_op, 0)) == PLUS\n+\t\t  && CONSTANT_P (XEXP (XEXP (this_op, 0), 0))\n+\t\t  && CONSTANT_P (XEXP (XEXP (this_op, 0), 1)))\n+\t\t{\n+\t\t  ops[i].op = XEXP (XEXP (this_op, 0), 0);\n+\t\t  ops[n_ops].op = XEXP (XEXP (this_op, 0), 1);\n+\t\t  ops[n_ops].neg = this_neg;\n+\t\t  n_ops++;\n+\t\t  input_consts++;\n+\t\t  changed = 1;\n+\t\t}\n \t      break;\n \n \t    case NOT:\n@@ -1838,9 +1849,14 @@ simplify_plus_minus (code, mode, op0, op1)\n   while (changed);\n \n   /* If we only have two operands, we can't do anything.  */\n-  if (n_ops <= 2)\n+  if (n_ops <= 2 && !force)\n     return NULL_RTX;\n \n+  /* Count the number of CONSTs we didn't split above.  */\n+  for (i = 0; i < n_ops; i++)\n+    if (GET_CODE (ops[i].op) == CONST)\n+      input_consts++;\n+\n   /* Now simplify each pair of operands until nothing changes.  The first\n      time through just simplify constants against each other.  */\n \n@@ -1941,8 +1957,9 @@ simplify_plus_minus (code, mode, op0, op1)\n      sure we count a CONST as two operands.  If we have the same\n      number of operands, but have made more CONSTs than before, this\n      is also an improvement, so accept it.  */\n-  if (n_ops + n_consts > input_ops\n-      || (n_ops + n_consts == input_ops && n_consts <= input_consts))\n+  if (!force\n+      && (n_ops + n_consts > input_ops\n+          || (n_ops + n_consts == input_ops && n_consts <= input_consts)))\n     return NULL_RTX;\n \n   /* Put a non-negated operand first.  If there aren't any, make all"}]}