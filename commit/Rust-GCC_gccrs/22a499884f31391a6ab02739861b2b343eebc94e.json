{"sha": "22a499884f31391a6ab02739861b2b343eebc94e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhNDk5ODg0ZjMxMzkxYTZhYjAyNzM5ODYxYjJiMzQzZWViYzk0ZQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2015-08-04T07:27:19Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2015-08-04T07:27:19Z"}, "message": "re PR fortran/64022 ([F2003][IEEE] ieee_support_flag does not handle kind=10 and kind=16 REAL variables)\n\n\tPR fortran/64022\n\n\t* simplify.c (gfc_simplify_ieee_selected_real_kind): Extend IEEE\n\tsupport to all real kinds.\n\n\t* ieee/ieee_exceptions.F90: Support all real kinds.\n\t* ieee/ieee_arithmetic.F90: Likewise.\n\t* ieee/ieee_helper.c (ieee_class_helper_10,\n\tieee_class_helper_16): New functions\n\t* gfortran.map (GFORTRAN_1.7): Add entries.\n\n\t* gfortran.dg/ieee/ieee_7.f90: Adjust test.\n\t* gfortran.dg/ieee/large_1.f90: New test.\n\nFrom-SVN: r226548", "tree": {"sha": "54d33530ee51771415c90c43ce2de54eb7cc9fef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54d33530ee51771415c90c43ce2de54eb7cc9fef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22a499884f31391a6ab02739861b2b343eebc94e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a499884f31391a6ab02739861b2b343eebc94e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a499884f31391a6ab02739861b2b343eebc94e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a499884f31391a6ab02739861b2b343eebc94e/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad23163d01cb104d39f9b21bad009812fb96042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ad23163d01cb104d39f9b21bad009812fb96042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ad23163d01cb104d39f9b21bad009812fb96042"}], "stats": {"total": 1068, "additions": 811, "deletions": 257}, "files": [{"sha": "46f9a927938490e3e03c6c42b23413101e4afd47", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -1,3 +1,9 @@\n+2015-08-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/64022\n+\t* simplify.c (gfc_simplify_ieee_selected_real_kind): Extend IEEE\n+\tsupport to all real kinds.\n+\n 2015-08-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66942"}, {"sha": "f0fdfbdfa0d48c6d73ad0150d287050109de7f15", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 6, "deletions": 73, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -5556,80 +5556,13 @@ gfc_expr *\n gfc_simplify_ieee_selected_real_kind (gfc_expr *expr)\n {\n   gfc_actual_arglist *arg = expr->value.function.actual;\n-  gfc_expr *p = arg->expr, *r = arg->next->expr,\n-\t   *rad = arg->next->next->expr;\n-  int precision, range, radix, res;\n-  int found_precision, found_range, found_radix, i;\n+  gfc_expr *p = arg->expr, *q = arg->next->expr,\n+\t   *rdx = arg->next->next->expr;\n \n-  if (p)\n-  {\n-    if (p->expr_type != EXPR_CONSTANT\n-\t|| gfc_extract_int (p, &precision) != NULL)\n-      return NULL;\n-  }\n-  else\n-    precision = 0;\n-\n-  if (r)\n-  {\n-    if (r->expr_type != EXPR_CONSTANT\n-\t|| gfc_extract_int (r, &range) != NULL)\n-      return NULL;\n-  }\n-  else\n-    range = 0;\n-\n-  if (rad)\n-  {\n-    if (rad->expr_type != EXPR_CONSTANT\n-\t|| gfc_extract_int (rad, &radix) != NULL)\n-      return NULL;\n-  }\n-  else\n-    radix = 0;\n-\n-  res = INT_MAX;\n-  found_precision = 0;\n-  found_range = 0;\n-  found_radix = 0;\n-\n-  for (i = 0; gfc_real_kinds[i].kind != 0; i++)\n-    {\n-      /* We only support the target's float and double types.  */\n-      if (!gfc_real_kinds[i].c_float && !gfc_real_kinds[i].c_double)\n-\tcontinue;\n-\n-      if (gfc_real_kinds[i].precision >= precision)\n-\tfound_precision = 1;\n-\n-      if (gfc_real_kinds[i].range >= range)\n-\tfound_range = 1;\n-\n-      if (radix == 0 || gfc_real_kinds[i].radix == radix)\n-\tfound_radix = 1;\n-\n-      if (gfc_real_kinds[i].precision >= precision\n-\t  && gfc_real_kinds[i].range >= range\n-\t  && (radix == 0 || gfc_real_kinds[i].radix == radix)\n-\t  && gfc_real_kinds[i].kind < res)\n-\tres = gfc_real_kinds[i].kind;\n-    }\n-\n-  if (res == INT_MAX)\n-    {\n-      if (found_radix && found_range && !found_precision)\n-\tres = -1;\n-      else if (found_radix && found_precision && !found_range)\n-\tres = -2;\n-      else if (found_radix && !found_precision && !found_range)\n-\tres = -3;\n-      else if (found_radix)\n-\tres = -4;\n-      else\n-\tres = -5;\n-    }\n-\n-  return gfc_get_int_expr (gfc_default_integer_kind, &expr->where, res);\n+  /* Currently, if IEEE is supported and this module is built, it means\n+     all our floating-point types conform to IEEE. Hence, we simply handle\n+     IEEE_SELECTED_REAL_KIND like SELECTED_REAL_KIND.  */\n+  return gfc_simplify_selected_real_kind (p, q, rdx);\n }\n \n "}, {"sha": "3a9143d09c13c45e331ccb1fd86ea6872dd94b26", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -1,3 +1,9 @@\n+2015-08-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/64022\n+\t* gfortran.dg/ieee/ieee_7.f90: Adjust test.\n+\t* gfortran.dg/ieee/large_1.f90: New test.\n+\n 2015-08-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR tree-optimization/67043"}, {"sha": "227bf544cc12780254564575f9b46f58e8ea8110", "filename": "gcc/testsuite/gfortran.dg/ieee/ieee_7.f90", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fieee_7.f90?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -1,8 +1,14 @@\n ! { dg-do run }\n \n   use :: ieee_arithmetic\n+  use :: iso_fortran_env, only : real_kinds\n   implicit none\n \n+  ! This should be \n+  ! integer, parameter :: maxreal = maxval(real_kinds)\n+  ! but it works because REAL_KINDS happen to be in increasing order\n+  integer, parameter :: maxreal = real_kinds(size(real_kinds))\n+\n   ! Test IEEE_SELECTED_REAL_KIND in specification expressions\n \n   integer(kind=ieee_selected_real_kind()) :: i1\n@@ -27,8 +33,8 @@\n   end if\n \n   if (ieee_selected_real_kind(0,0,3) /= -5) call abort\n-  if (ieee_selected_real_kind(precision(0.d0)+1) /= -1) call abort\n-  if (ieee_selected_real_kind(0,range(0.d0)+1) /= -2) call abort\n-  if (ieee_selected_real_kind(precision(0.d0)+1,range(0.d0)+1) /= -3) call abort\n+  if (ieee_selected_real_kind(precision(0._maxreal)+1) /= -1) call abort\n+  if (ieee_selected_real_kind(0,range(0._maxreal)+1) /= -2) call abort\n+  if (ieee_selected_real_kind(precision(0._maxreal)+1,range(0._maxreal)+1) /= -3) call abort\n \n end"}, {"sha": "5ec2dab2d05f0439e90f7b75b43a6a66783c0189", "filename": "gcc/testsuite/gfortran.dg/ieee/large_1.f90", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Flarge_1.f90?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -0,0 +1,138 @@\n+! { dg-do run }\n+!\n+! Testing IEEE modules on large real kinds\n+\n+program test\n+\n+  use ieee_arithmetic\n+  implicit none\n+\n+  ! k1 and k2 will be large real kinds, if supported, and single/double\n+  ! otherwise\n+  integer, parameter :: k1 = &\n+    max(ieee_selected_real_kind(precision(0.d0) + 1), kind(0.))\n+  integer, parameter :: k2 = &\n+    max(ieee_selected_real_kind(precision(0._k1) + 1), kind(0.d0))\n+\n+  real(kind=k1) :: x1, y1\n+  real(kind=k2) :: x2, y2\n+\n+  ! Checking ieee_is_finite\n+\n+  if (.not. ieee_is_finite(huge(0._k1))) call abort\n+  if (ieee_is_finite(ieee_value(0._k1, ieee_negative_inf))) call abort\n+  x1 = -42\n+  if (.not. ieee_is_finite(x1)) call abort\n+  if (ieee_is_finite(sqrt(x1))) call abort\n+\n+  if (.not. ieee_is_finite(huge(0._k2))) call abort\n+  if (ieee_is_finite(ieee_value(0._k2, ieee_negative_inf))) call abort\n+  x2 = -42\n+  if (.not. ieee_is_finite(x2)) call abort\n+  if (ieee_is_finite(sqrt(x2))) call abort\n+\n+  ! Other ieee_is intrinsics\n+\n+  if (ieee_is_nan(huge(0._k1))) call abort\n+  if (.not. ieee_is_negative(-huge(0._k1))) call abort\n+  if (.not. ieee_is_normal(-huge(0._k1))) call abort\n+\n+  if (ieee_is_nan(huge(0._k2))) call abort\n+  if (.not. ieee_is_negative(-huge(0._k2))) call abort\n+  if (.not. ieee_is_normal(-huge(0._k2))) call abort\n+\n+  ! ieee_support intrinsics\n+\n+  if (.not. ieee_support_datatype(x1)) call abort\n+  if (.not. ieee_support_denormal(x1)) call abort\n+  if (.not. ieee_support_divide(x1)) call abort\n+  if (.not. ieee_support_inf(x1)) call abort\n+  if (.not. ieee_support_io(x1)) call abort\n+  if (.not. ieee_support_nan(x1)) call abort\n+  if (.not. ieee_support_rounding(ieee_nearest, x1)) call abort\n+  if (.not. ieee_support_sqrt(x1)) call abort\n+  if (.not. ieee_support_standard(x1)) call abort\n+  if (.not. ieee_support_underflow_control(x1)) call abort\n+\n+  if (.not. ieee_support_datatype(x2)) call abort\n+  if (.not. ieee_support_denormal(x2)) call abort\n+  if (.not. ieee_support_divide(x2)) call abort\n+  if (.not. ieee_support_inf(x2)) call abort\n+  if (.not. ieee_support_io(x2)) call abort\n+  if (.not. ieee_support_nan(x2)) call abort\n+  if (.not. ieee_support_rounding(ieee_nearest, x2)) call abort\n+  if (.not. ieee_support_sqrt(x2)) call abort\n+  if (.not. ieee_support_standard(x2)) call abort\n+  if (.not. ieee_support_underflow_control(x2)) call abort\n+\n+  ! ieee_value and ieee_class\n+\n+  if (.not. ieee_is_nan(ieee_value(x1, ieee_quiet_nan))) call abort\n+  if (ieee_class(ieee_value(x1, ieee_positive_denormal)) &\n+    /= ieee_positive_denormal) call abort\n+\n+  if (.not. ieee_is_nan(ieee_value(x2, ieee_quiet_nan))) call abort\n+  if (ieee_class(ieee_value(x2, ieee_positive_denormal)) &\n+    /= ieee_positive_denormal) call abort\n+\n+  ! ieee_unordered\n+\n+  if (.not. ieee_unordered(ieee_value(x1, ieee_quiet_nan), 0._k1)) call abort\n+  if (ieee_unordered(ieee_value(x1, ieee_negative_inf), 0._k1)) call abort\n+\n+  if (.not. ieee_unordered(ieee_value(x2, ieee_quiet_nan), 0._k2)) call abort\n+  if (ieee_unordered(ieee_value(x2, ieee_negative_inf), 0._k2)) call abort\n+\n+  ! ieee_copy_sign\n+\n+  if (.not. ieee_class(ieee_copy_sign(ieee_value(x1, ieee_positive_inf), -1.)) &\n+            == ieee_negative_inf) call abort\n+  if (.not. ieee_class(ieee_copy_sign(0._k1, -42._k2)) &\n+            == ieee_negative_zero) call abort\n+\n+  if (.not. ieee_class(ieee_copy_sign(ieee_value(x2, ieee_positive_inf), -1.)) &\n+            == ieee_negative_inf) call abort\n+  if (.not. ieee_class(ieee_copy_sign(0._k2, -42._k1)) &\n+            == ieee_negative_zero) call abort\n+\n+  ! ieee_logb\n+\n+  if (ieee_logb (42._k1) /= exponent(42._k1) - 1) call abort\n+\n+  if (ieee_logb (42._k2) /= exponent(42._k2) - 1) call abort\n+\n+  ! ieee_next_after\n+\n+  if (ieee_next_after(42._k1, ieee_value(x1, ieee_positive_inf)) &\n+      /= 42._k1 + spacing(42._k1)) call abort\n+\n+  if (ieee_next_after(42._k2, ieee_value(x2, ieee_positive_inf)) &\n+      /= 42._k2 + spacing(42._k2)) call abort\n+\n+  ! ieee_rem\n+\n+  if (ieee_class(ieee_rem(-42._k1, 2._k1)) /= ieee_negative_zero) &\n+    call abort\n+\n+  if (ieee_class(ieee_rem(-42._k2, 2._k2)) /= ieee_negative_zero) &\n+    call abort\n+\n+  ! ieee_rint\n+\n+  if (ieee_rint(-1.1_k1) /= -1._k1) call abort\n+  if (ieee_rint(huge(x1)) /= huge(x1)) call abort\n+\n+  if (ieee_rint(-1.1_k2) /= -1._k2) call abort\n+  if (ieee_rint(huge(x2)) /= huge(x2)) call abort\n+\n+  ! ieee_scalb\n+\n+  x1 = sqrt(42._k1)\n+  if (ieee_scalb(x1, 2) /= 4._k1 * x1) call abort\n+  if (ieee_scalb(x1, -2) /= x1 / 4._k1) call abort\n+\n+  x2 = sqrt(42._k2)\n+  if (ieee_scalb(x2, 2) /= 4._k2 * x2) call abort\n+  if (ieee_scalb(x2, -2) /= x2 / 4._k2) call abort\n+\n+end program test"}, {"sha": "e74bff61dac7b37a41eba47a75900aa9a6017734", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -1,3 +1,12 @@\n+2015-08-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/64022\n+\t* ieee/ieee_exceptions.F90: Support all real kinds.\n+\t* ieee/ieee_arithmetic.F90: Likewise.\n+\t* ieee/ieee_helper.c (ieee_class_helper_10,\n+\tieee_class_helper_16): New functions\n+\t* gfortran.map (GFORTRAN_1.7): Add entries.\n+\n 2015-07-29  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR libgfortran/66650"}, {"sha": "73cdde7857142305e3782d6a13b94cc5bf2e0ad1", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -1276,6 +1276,16 @@ GFORTRAN_1.6 {\n     __ieee_exceptions_MOD_ieee_usual;\n } GFORTRAN_1.5; \n \n+GFORTRAN_1.7 {\n+  global:\n+    __ieee_arithmetic_MOD_ieee_class_10;\n+    __ieee_arithmetic_MOD_ieee_class_16;\n+    __ieee_arithmetic_MOD_ieee_value_10;\n+    __ieee_arithmetic_MOD_ieee_value_16;\n+    __ieee_exceptions_MOD_ieee_support_flag_10;\n+    __ieee_exceptions_MOD_ieee_support_flag_16;\n+} GFORTRAN_1.6; \n+\n F2C_1.0 {\n   global:\n     _gfortran_f2c_specific__abs_c4;"}, {"sha": "89456cf15502bcbc6e00bd6c9fbeb463e1841b46", "filename": "libgfortran/ieee/ieee_arithmetic.F90", "status": "modified", "additions": 582, "deletions": 178, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fieee%2Fieee_arithmetic.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fieee%2Fieee_arithmetic.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_arithmetic.F90?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -95,10 +95,27 @@ module IEEE_ARITHMETIC\n     elemental logical function _gfortran_ieee_is_finite_8(X)\n       real(kind=8), intent(in) :: X\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental logical function _gfortran_ieee_is_finite_10(X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental logical function _gfortran_ieee_is_finite_16(X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_IS_FINITE\n-    procedure _gfortran_ieee_is_finite_4, _gfortran_ieee_is_finite_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_is_finite_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_is_finite_10, &\n+#endif\n+      _gfortran_ieee_is_finite_8, _gfortran_ieee_is_finite_4\n   end interface\n   public :: IEEE_IS_FINITE\n \n@@ -111,10 +128,27 @@ module IEEE_ARITHMETIC\n     elemental logical function _gfortran_ieee_is_nan_8(X)\n       real(kind=8), intent(in) :: X\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental logical function _gfortran_ieee_is_nan_10(X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental logical function _gfortran_ieee_is_nan_16(X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_IS_NAN\n-    procedure _gfortran_ieee_is_nan_4, _gfortran_ieee_is_nan_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_is_nan_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_is_nan_10, &\n+#endif\n+      _gfortran_ieee_is_nan_8, _gfortran_ieee_is_nan_4\n   end interface\n   public :: IEEE_IS_NAN\n \n@@ -127,10 +161,27 @@ module IEEE_ARITHMETIC\n     elemental logical function _gfortran_ieee_is_negative_8(X)\n       real(kind=8), intent(in) :: X\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental logical function _gfortran_ieee_is_negative_10(X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental logical function _gfortran_ieee_is_negative_16(X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_IS_NEGATIVE\n-    procedure _gfortran_ieee_is_negative_4, _gfortran_ieee_is_negative_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_is_negative_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_is_negative_10, &\n+#endif\n+      _gfortran_ieee_is_negative_8, _gfortran_ieee_is_negative_4\n   end interface\n   public :: IEEE_IS_NEGATIVE\n \n@@ -143,64 +194,189 @@ module IEEE_ARITHMETIC\n     elemental logical function _gfortran_ieee_is_normal_8(X)\n       real(kind=8), intent(in) :: X\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental logical function _gfortran_ieee_is_normal_10(X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental logical function _gfortran_ieee_is_normal_16(X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_IS_NORMAL\n-    procedure _gfortran_ieee_is_normal_4, _gfortran_ieee_is_normal_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_is_normal_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_is_normal_10, &\n+#endif\n+      _gfortran_ieee_is_normal_8, _gfortran_ieee_is_normal_4\n   end interface\n   public :: IEEE_IS_NORMAL\n \n   ! IEEE_COPY_SIGN\n \n+#define COPYSIGN_MACRO(A,B) \\\n+  elemental real(kind = A) function \\\n+    _gfortran_ieee_copy_sign_/**/A/**/_/**/B (X,Y) ; \\\n+      real(kind = A), intent(in) :: X ; \\\n+      real(kind = B), intent(in) :: Y ; \\\n+  end function\n+\n   interface\n-    elemental real(kind=4) function _gfortran_ieee_copy_sign_4_4 (X,Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental real(kind=4) function _gfortran_ieee_copy_sign_4_8 (X,Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_copy_sign_8_4 (X,Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_copy_sign_8_8 (X,Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n+COPYSIGN_MACRO(4,4)\n+COPYSIGN_MACRO(4,8)\n+#ifdef HAVE_GFC_REAL_10\n+COPYSIGN_MACRO(4,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+COPYSIGN_MACRO(4,16)\n+#endif\n+COPYSIGN_MACRO(8,4)\n+COPYSIGN_MACRO(8,8)\n+#ifdef HAVE_GFC_REAL_10\n+COPYSIGN_MACRO(8,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+COPYSIGN_MACRO(8,16)\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+COPYSIGN_MACRO(10,4)\n+COPYSIGN_MACRO(10,8)\n+COPYSIGN_MACRO(10,10)\n+#ifdef HAVE_GFC_REAL_16\n+COPYSIGN_MACRO(10,16)\n+#endif\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+COPYSIGN_MACRO(16,4)\n+COPYSIGN_MACRO(16,8)\n+#ifdef HAVE_GFC_REAL_10\n+COPYSIGN_MACRO(16,10)\n+#endif\n+COPYSIGN_MACRO(16,16)\n+#endif\n   end interface\n \n   interface IEEE_COPY_SIGN\n-    procedure _gfortran_ieee_copy_sign_4_4, _gfortran_ieee_copy_sign_4_8, &\n-              _gfortran_ieee_copy_sign_8_4, _gfortran_ieee_copy_sign_8_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_copy_sign_16_16, &\n+#ifdef HAVE_GFC_REAL_10\n+              _gfortran_ieee_copy_sign_16_10, &\n+#endif\n+              _gfortran_ieee_copy_sign_16_8, &\n+              _gfortran_ieee_copy_sign_16_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_copy_sign_10_16, &\n+#endif\n+              _gfortran_ieee_copy_sign_10_10, &\n+              _gfortran_ieee_copy_sign_10_8, &\n+              _gfortran_ieee_copy_sign_10_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_copy_sign_8_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+              _gfortran_ieee_copy_sign_8_10, &\n+#endif\n+              _gfortran_ieee_copy_sign_8_8, &\n+              _gfortran_ieee_copy_sign_8_4, &\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_copy_sign_4_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+              _gfortran_ieee_copy_sign_4_10, &\n+#endif\n+              _gfortran_ieee_copy_sign_4_8, &\n+              _gfortran_ieee_copy_sign_4_4\n   end interface\n   public :: IEEE_COPY_SIGN\n \n   ! IEEE_UNORDERED\n \n+#define UNORDERED_MACRO(A,B) \\\n+  elemental logical function \\\n+    _gfortran_ieee_unordered_/**/A/**/_/**/B (X,Y) ; \\\n+      real(kind = A), intent(in) :: X ; \\\n+      real(kind = B), intent(in) :: Y ; \\\n+  end function\n+\n   interface\n-    elemental logical function _gfortran_ieee_unordered_4_4 (X,Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental logical function _gfortran_ieee_unordered_4_8 (X,Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n-    elemental logical function _gfortran_ieee_unordered_8_4 (X,Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental logical function _gfortran_ieee_unordered_8_8 (X,Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n+UNORDERED_MACRO(4,4)\n+UNORDERED_MACRO(4,8)\n+#ifdef HAVE_GFC_REAL_10\n+UNORDERED_MACRO(4,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+UNORDERED_MACRO(4,16)\n+#endif\n+UNORDERED_MACRO(8,4)\n+UNORDERED_MACRO(8,8)\n+#ifdef HAVE_GFC_REAL_10\n+UNORDERED_MACRO(8,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+UNORDERED_MACRO(8,16)\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+UNORDERED_MACRO(10,4)\n+UNORDERED_MACRO(10,8)\n+UNORDERED_MACRO(10,10)\n+#ifdef HAVE_GFC_REAL_16\n+UNORDERED_MACRO(10,16)\n+#endif\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+UNORDERED_MACRO(16,4)\n+UNORDERED_MACRO(16,8)\n+#ifdef HAVE_GFC_REAL_10\n+UNORDERED_MACRO(16,10)\n+#endif\n+UNORDERED_MACRO(16,16)\n+#endif\n   end interface\n \n   interface IEEE_UNORDERED\n-    procedure _gfortran_ieee_unordered_4_4, _gfortran_ieee_unordered_4_8, &\n-              _gfortran_ieee_unordered_8_4, _gfortran_ieee_unordered_8_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_unordered_16_16, &\n+#ifdef HAVE_GFC_REAL_10\n+              _gfortran_ieee_unordered_16_10, &\n+#endif\n+              _gfortran_ieee_unordered_16_8, &\n+              _gfortran_ieee_unordered_16_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_unordered_10_16, &\n+#endif\n+              _gfortran_ieee_unordered_10_10, &\n+              _gfortran_ieee_unordered_10_8, &\n+              _gfortran_ieee_unordered_10_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_unordered_8_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+              _gfortran_ieee_unordered_8_10, &\n+#endif\n+              _gfortran_ieee_unordered_8_8, &\n+              _gfortran_ieee_unordered_8_4, &\n+#ifdef HAVE_GFC_REAL_16\n+              _gfortran_ieee_unordered_4_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+              _gfortran_ieee_unordered_4_10, &\n+#endif\n+              _gfortran_ieee_unordered_4_8, &\n+              _gfortran_ieee_unordered_4_4\n   end interface\n   public :: IEEE_UNORDERED\n \n@@ -213,64 +389,190 @@ module IEEE_ARITHMETIC\n     elemental real(kind=8) function _gfortran_ieee_logb_8 (X)\n       real(kind=8), intent(in) :: X\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental real(kind=10) function _gfortran_ieee_logb_10 (X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental real(kind=16) function _gfortran_ieee_logb_16 (X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_LOGB\n-    procedure _gfortran_ieee_logb_4, _gfortran_ieee_logb_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_logb_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_logb_10, &\n+#endif\n+      _gfortran_ieee_logb_8, &\n+      _gfortran_ieee_logb_4\n   end interface\n   public :: IEEE_LOGB\n \n   ! IEEE_NEXT_AFTER\n \n+#define NEXT_AFTER_MACRO(A,B) \\\n+  elemental real(kind = A) function \\\n+    _gfortran_ieee_next_after_/**/A/**/_/**/B (X,Y) ; \\\n+      real(kind = A), intent(in) :: X ; \\\n+      real(kind = B), intent(in) :: Y ; \\\n+  end function\n+\n   interface\n-    elemental real(kind=4) function _gfortran_ieee_next_after_4_4 (X, Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental real(kind=4) function _gfortran_ieee_next_after_4_8 (X, Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_next_after_8_4 (X, Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_next_after_8_8 (X, Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n+NEXT_AFTER_MACRO(4,4)\n+NEXT_AFTER_MACRO(4,8)\n+#ifdef HAVE_GFC_REAL_10\n+NEXT_AFTER_MACRO(4,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+NEXT_AFTER_MACRO(4,16)\n+#endif\n+NEXT_AFTER_MACRO(8,4)\n+NEXT_AFTER_MACRO(8,8)\n+#ifdef HAVE_GFC_REAL_10\n+NEXT_AFTER_MACRO(8,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+NEXT_AFTER_MACRO(8,16)\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+NEXT_AFTER_MACRO(10,4)\n+NEXT_AFTER_MACRO(10,8)\n+NEXT_AFTER_MACRO(10,10)\n+#ifdef HAVE_GFC_REAL_16\n+NEXT_AFTER_MACRO(10,16)\n+#endif\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+NEXT_AFTER_MACRO(16,4)\n+NEXT_AFTER_MACRO(16,8)\n+#ifdef HAVE_GFC_REAL_10\n+NEXT_AFTER_MACRO(16,10)\n+#endif\n+NEXT_AFTER_MACRO(16,16)\n+#endif\n   end interface\n \n   interface IEEE_NEXT_AFTER\n-    procedure _gfortran_ieee_next_after_4_4, _gfortran_ieee_next_after_4_8, &\n-              _gfortran_ieee_next_after_8_4, _gfortran_ieee_next_after_8_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_next_after_16_16, &\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_next_after_16_10, &\n+#endif\n+      _gfortran_ieee_next_after_16_8, &\n+      _gfortran_ieee_next_after_16_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_next_after_10_16, &\n+#endif\n+      _gfortran_ieee_next_after_10_10, &\n+      _gfortran_ieee_next_after_10_8, &\n+      _gfortran_ieee_next_after_10_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_next_after_8_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_next_after_8_10, &\n+#endif\n+      _gfortran_ieee_next_after_8_8, &\n+      _gfortran_ieee_next_after_8_4, &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_next_after_4_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_next_after_4_10, &\n+#endif\n+      _gfortran_ieee_next_after_4_8, &\n+      _gfortran_ieee_next_after_4_4\n   end interface\n   public :: IEEE_NEXT_AFTER\n \n   ! IEEE_REM\n \n+#define REM_MACRO(RES,A,B) \\\n+  elemental real(kind = RES) function \\\n+    _gfortran_ieee_rem_/**/A/**/_/**/B (X,Y) ; \\\n+      real(kind = A), intent(in) :: X ; \\\n+      real(kind = B), intent(in) :: Y ; \\\n+  end function\n+\n   interface\n-    elemental real(kind=4) function _gfortran_ieee_rem_4_4 (X, Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_rem_4_8 (X, Y)\n-      real(kind=4), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_rem_8_4 (X, Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=4), intent(in) :: Y\n-    end function\n-    elemental real(kind=8) function _gfortran_ieee_rem_8_8 (X, Y)\n-      real(kind=8), intent(in) :: X\n-      real(kind=8), intent(in) :: Y\n-    end function\n+REM_MACRO(4,4,4)\n+REM_MACRO(8,4,8)\n+#ifdef HAVE_GFC_REAL_10\n+REM_MACRO(10,4,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+REM_MACRO(16,4,16)\n+#endif\n+REM_MACRO(8,8,4)\n+REM_MACRO(8,8,8)\n+#ifdef HAVE_GFC_REAL_10\n+REM_MACRO(10,8,10)\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+REM_MACRO(16,8,16)\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+REM_MACRO(10,10,4)\n+REM_MACRO(10,10,8)\n+REM_MACRO(10,10,10)\n+#ifdef HAVE_GFC_REAL_16\n+REM_MACRO(16,10,16)\n+#endif\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+REM_MACRO(16,16,4)\n+REM_MACRO(16,16,8)\n+#ifdef HAVE_GFC_REAL_10\n+REM_MACRO(16,16,10)\n+#endif\n+REM_MACRO(16,16,16)\n+#endif\n   end interface\n \n   interface IEEE_REM\n-    procedure _gfortran_ieee_rem_4_4, _gfortran_ieee_rem_4_8, &\n-              _gfortran_ieee_rem_8_4, _gfortran_ieee_rem_8_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_rem_16_16, &\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_rem_16_10, &\n+#endif\n+      _gfortran_ieee_rem_16_8, &\n+      _gfortran_ieee_rem_16_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_rem_10_16, &\n+#endif\n+      _gfortran_ieee_rem_10_10, &\n+      _gfortran_ieee_rem_10_8, &\n+      _gfortran_ieee_rem_10_4, &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_rem_8_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_rem_8_10, &\n+#endif\n+      _gfortran_ieee_rem_8_8, &\n+      _gfortran_ieee_rem_8_4, &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_rem_4_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_rem_4_10, &\n+#endif\n+      _gfortran_ieee_rem_4_8, &\n+      _gfortran_ieee_rem_4_4\n   end interface\n   public :: IEEE_REM\n \n@@ -283,10 +585,27 @@ module IEEE_ARITHMETIC\n     elemental real(kind=8) function _gfortran_ieee_rint_8 (X)\n       real(kind=8), intent(in) :: X\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental real(kind=10) function _gfortran_ieee_rint_10 (X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental real(kind=16) function _gfortran_ieee_rint_16 (X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_RINT\n-    procedure _gfortran_ieee_rint_4, _gfortran_ieee_rint_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_rint_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_rint_10, &\n+#endif\n+      _gfortran_ieee_rint_8, _gfortran_ieee_rint_4\n   end interface\n   public :: IEEE_RINT\n \n@@ -301,24 +620,57 @@ module IEEE_ARITHMETIC\n       real(kind=8), intent(in) :: X\n       integer, intent(in) :: I\n     end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental real(kind=10) function _gfortran_ieee_scalb_10 (X, I)\n+      real(kind=10), intent(in) :: X\n+      integer, intent(in) :: I\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental real(kind=16) function _gfortran_ieee_scalb_16 (X, I)\n+      real(kind=16), intent(in) :: X\n+      integer, intent(in) :: I\n+    end function\n+#endif\n   end interface\n \n   interface IEEE_SCALB\n-    procedure _gfortran_ieee_scalb_4, _gfortran_ieee_scalb_8\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_scalb_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_scalb_10, &\n+#endif\n+      _gfortran_ieee_scalb_8, _gfortran_ieee_scalb_4\n   end interface\n   public :: IEEE_SCALB\n \n   ! IEEE_VALUE\n \n   interface IEEE_VALUE\n-    module procedure IEEE_VALUE_4, IEEE_VALUE_8\n+    module procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      IEEE_VALUE_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      IEEE_VALUE_10, &\n+#endif\n+      IEEE_VALUE_8, IEEE_VALUE_4\n   end interface\n   public :: IEEE_VALUE\n \n   ! IEEE_CLASS\n \n   interface IEEE_CLASS\n-    module procedure IEEE_CLASS_4, IEEE_CLASS_8\n+    module procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      IEEE_CLASS_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      IEEE_CLASS_10, &\n+#endif\n+      IEEE_CLASS_8, IEEE_CLASS_4\n   end interface\n   public :: IEEE_CLASS\n \n@@ -424,47 +776,19 @@ elemental logical function IEEE_ROUND_TYPE_NE (X, Y) result(res)\n     res = (X%hidden /= Y%hidden)\n   end function\n \n+\n   ! IEEE_SELECTED_REAL_KIND\n+\n   integer function IEEE_SELECTED_REAL_KIND (P, R, RADIX) result(res)\n     implicit none\n     integer, intent(in), optional :: P, R, RADIX\n-    integer :: p2, r2\n-\n-    p2 = 0 ; r2 = 0\n-    if (present(p)) p2 = p\n-    if (present(r)) r2 = r\n-\n-    ! The only IEEE types we support right now are binary\n-    if (present(radix)) then\n-      if (radix /= 2) then\n-        res = -5\n-        return\n-      endif\n-    endif\n-\n-    ! Does IEEE float fit?\n-    if (precision(0.) >= p2 .and. range(0.) >= r2) then\n-      res = kind(0.)\n-      return\n-    endif\n-\n-    ! Does IEEE double fit?\n-    if (precision(0.d0) >= p2 .and. range(0.d0) >= r2) then\n-      res = kind(0.d0)\n-      return\n-    endif\n-\n-    if (precision(0.d0) < p2 .and. range(0.d0) < r2) then\n-      res = -3\n-      return\n-    endif\n-\n-    if (precision(0.d0) < p2) then\n-      res = -1\n-      return\n-    endif\n-\n-   res = -2\n+\n+    ! Currently, if IEEE is supported and this module is built, it means\n+    ! all our floating-point types conform to IEEE. Hence, we simply call\n+    ! SELECTED_REAL_KIND.\n+\n+    res = SELECTED_REAL_KIND (P, R, RADIX)\n+\n   end function\n \n \n@@ -498,6 +822,39 @@ elemental function IEEE_CLASS_8 (X) result(res)\n     res = IEEE_CLASS_TYPE(_gfortrani_ieee_class_helper_8(X))\n   end function\n \n+#ifdef HAVE_GFC_REAL_10\n+  elemental function IEEE_CLASS_10 (X) result(res)\n+    implicit none\n+    real(kind=10), intent(in) :: X\n+    type(IEEE_CLASS_TYPE) :: res\n+\n+    interface\n+      pure integer function _gfortrani_ieee_class_helper_10(val)\n+        real(kind=10), intent(in) :: val\n+      end function\n+    end interface\n+\n+    res = IEEE_CLASS_TYPE(_gfortrani_ieee_class_helper_10(X))\n+  end function\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+  elemental function IEEE_CLASS_16 (X) result(res)\n+    implicit none\n+    real(kind=16), intent(in) :: X\n+    type(IEEE_CLASS_TYPE) :: res\n+\n+    interface\n+      pure integer function _gfortrani_ieee_class_helper_16(val)\n+        real(kind=16), intent(in) :: val\n+      end function\n+    end interface\n+\n+    res = IEEE_CLASS_TYPE(_gfortrani_ieee_class_helper_16(X))\n+  end function\n+#endif\n+\n+\n   ! IEEE_VALUE\n \n   elemental real(kind=4) function IEEE_VALUE_4(X, C) result(res)\n@@ -576,6 +933,86 @@ elemental real(kind=8) function IEEE_VALUE_8(X, C) result(res)\n      end select\n   end function\n \n+#ifdef HAVE_GFC_REAL_10\n+  elemental real(kind=10) function IEEE_VALUE_10(X, C) result(res)\n+    implicit none\n+    real(kind=10), intent(in) :: X\n+    type(IEEE_CLASS_TYPE), intent(in) :: C\n+\n+    select case (C%hidden)\n+      case (1)     ! IEEE_SIGNALING_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (2)     ! IEEE_QUIET_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (3)     ! IEEE_NEGATIVE_INF\n+        res = huge(res)\n+        res = (-res) * res\n+      case (4)     ! IEEE_NEGATIVE_NORMAL\n+        res = -42\n+      case (5)     ! IEEE_NEGATIVE_DENORMAL\n+        res = -tiny(res)\n+        res = res / 2\n+      case (6)     ! IEEE_NEGATIVE_ZERO\n+        res = 0\n+        res = -res\n+      case (7)     ! IEEE_POSITIVE_ZERO\n+        res = 0\n+      case (8)     ! IEEE_POSITIVE_DENORMAL\n+        res = tiny(res)\n+        res = res / 2\n+      case (9)     ! IEEE_POSITIVE_NORMAL\n+        res = 42\n+      case (10)    ! IEEE_POSITIVE_INF\n+        res = huge(res)\n+        res = res * res\n+      case default ! IEEE_OTHER_VALUE, should not happen\n+        res = 0\n+     end select\n+  end function\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+  elemental real(kind=16) function IEEE_VALUE_16(X, C) result(res)\n+    implicit none\n+    real(kind=16), intent(in) :: X\n+    type(IEEE_CLASS_TYPE), intent(in) :: C\n+\n+    select case (C%hidden)\n+      case (1)     ! IEEE_SIGNALING_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (2)     ! IEEE_QUIET_NAN\n+        res = -1\n+        res = sqrt(res)\n+      case (3)     ! IEEE_NEGATIVE_INF\n+        res = huge(res)\n+        res = (-res) * res\n+      case (4)     ! IEEE_NEGATIVE_NORMAL\n+        res = -42\n+      case (5)     ! IEEE_NEGATIVE_DENORMAL\n+        res = -tiny(res)\n+        res = res / 2\n+      case (6)     ! IEEE_NEGATIVE_ZERO\n+        res = 0\n+        res = -res\n+      case (7)     ! IEEE_POSITIVE_ZERO\n+        res = 0\n+      case (8)     ! IEEE_POSITIVE_DENORMAL\n+        res = tiny(res)\n+        res = res / 2\n+      case (9)     ! IEEE_POSITIVE_NORMAL\n+        res = 42\n+      case (10)    ! IEEE_POSITIVE_INF\n+        res = huge(res)\n+        res = res * res\n+      case default ! IEEE_OTHER_VALUE, should not happen\n+        res = 0\n+     end select\n+  end function\n+#endif\n+\n \n   ! IEEE_GET_ROUNDING_MODE\n \n@@ -663,7 +1100,7 @@ pure logical function IEEE_SUPPORT_ROUNDING_10 (ROUND_VALUE, X) result(res)\n     implicit none\n     real(kind=10), intent(in) :: X\n     type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n-    res = .false.\n+    res = (support_rounding_helper(ROUND_VALUE%hidden) /= 0)\n   end function\n #endif\n \n@@ -672,18 +1109,14 @@ pure logical function IEEE_SUPPORT_ROUNDING_16 (ROUND_VALUE, X) result(res)\n     implicit none\n     real(kind=16), intent(in) :: X\n     type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n-    res = .false.\n+    res = (support_rounding_helper(ROUND_VALUE%hidden) /= 0)\n   end function\n #endif\n \n   pure logical function IEEE_SUPPORT_ROUNDING_NOARG (ROUND_VALUE) result(res)\n     implicit none\n     type(IEEE_ROUND_TYPE), intent(in) :: ROUND_VALUE\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-    res = .false.\n-#else\n     res = (support_rounding_helper(ROUND_VALUE%hidden) /= 0)\n-#endif\n   end function\n \n ! IEEE_SUPPORT_UNDERFLOW_CONTROL\n@@ -704,26 +1137,29 @@ pure logical function IEEE_SUPPORT_UNDERFLOW_CONTROL_8 (X) result(res)\n   pure logical function IEEE_SUPPORT_UNDERFLOW_CONTROL_10 (X) result(res)\n     implicit none\n     real(kind=10), intent(in) :: X\n-    res = .false.\n+    res = (support_underflow_control_helper(10) /= 0)\n   end function\n #endif\n \n #ifdef HAVE_GFC_REAL_16\n   pure logical function IEEE_SUPPORT_UNDERFLOW_CONTROL_16 (X) result(res)\n     implicit none\n     real(kind=16), intent(in) :: X\n-    res = .false.\n+    res = (support_underflow_control_helper(16) /= 0)\n   end function\n #endif\n \n   pure logical function IEEE_SUPPORT_UNDERFLOW_CONTROL_NOARG () result(res)\n     implicit none\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-    res = .false.\n-#else\n     res = (support_underflow_control_helper(4) /= 0 &\n-           .and. support_underflow_control_helper(8) /= 0)\n+           .and. support_underflow_control_helper(8) /= 0 &\n+#ifdef HAVE_GFC_REAL_10\n+           .and. support_underflow_control_helper(10) /= 0 &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+           .and. support_underflow_control_helper(16) /= 0 &\n #endif\n+          )\n   end function\n \n ! IEEE_SUPPORT_* functions\n@@ -746,127 +1182,95 @@ pure logical function NAME/**/_NOARG () result(res) ; \\\n SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_DATATYPE,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_DATATYPE,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_DATATYPE,.true.)\n-#endif\n \n ! IEEE_SUPPORT_DENORMAL\n \n SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_DENORMAL,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_DENORMAL,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_DENORMAL,.true.)\n-#endif\n \n ! IEEE_SUPPORT_DIVIDE\n \n SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_DIVIDE,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_DIVIDE,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_DIVIDE,.true.)\n-#endif\n \n ! IEEE_SUPPORT_INF\n \n SUPPORTMACRO(IEEE_SUPPORT_INF,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_INF,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_INF,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_INF,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_INF,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_INF,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_INF,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_INF,.true.)\n-#endif\n \n ! IEEE_SUPPORT_IO\n \n SUPPORTMACRO(IEEE_SUPPORT_IO,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_IO,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_IO,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_IO,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_IO,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_IO,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_IO,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_IO,.true.)\n-#endif\n \n ! IEEE_SUPPORT_NAN\n \n SUPPORTMACRO(IEEE_SUPPORT_NAN,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_NAN,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_NAN,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_NAN,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_NAN,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_NAN,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_NAN,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_NAN,.true.)\n-#endif\n \n ! IEEE_SUPPORT_SQRT\n \n SUPPORTMACRO(IEEE_SUPPORT_SQRT,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_SQRT,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_SQRT,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_SQRT,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_SQRT,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_SQRT,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_SQRT,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_SQRT,.true.)\n-#endif\n \n ! IEEE_SUPPORT_STANDARD\n \n SUPPORTMACRO(IEEE_SUPPORT_STANDARD,4,.true.)\n SUPPORTMACRO(IEEE_SUPPORT_STANDARD,8,.true.)\n #ifdef HAVE_GFC_REAL_10\n-SUPPORTMACRO(IEEE_SUPPORT_STANDARD,10,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_STANDARD,10,.true.)\n #endif\n #ifdef HAVE_GFC_REAL_16\n-SUPPORTMACRO(IEEE_SUPPORT_STANDARD,16,.false.)\n+SUPPORTMACRO(IEEE_SUPPORT_STANDARD,16,.true.)\n #endif\n-#if defined(HAVE_GFC_REAL_10) || defined(HAVE_GFC_REAL_16)\n-SUPPORTMACRO_NOARG(IEEE_SUPPORT_STANDARD,.false.)\n-#else\n SUPPORTMACRO_NOARG(IEEE_SUPPORT_STANDARD,.true.)\n-#endif\n \n end module IEEE_ARITHMETIC"}, {"sha": "662c42f03e0067449771bdd38faa89c2677c76ed", "filename": "libgfortran/ieee/ieee_exceptions.F90", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fieee%2Fieee_exceptions.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fieee%2Fieee_exceptions.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_exceptions.F90?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -57,9 +57,15 @@ module IEEE_EXCEPTIONS\n   end type\n \n   interface IEEE_SUPPORT_FLAG\n-    module procedure IEEE_SUPPORT_FLAG_NOARG, &\n-                     IEEE_SUPPORT_FLAG_4, &\n-                     IEEE_SUPPORT_FLAG_8\n+    module procedure IEEE_SUPPORT_FLAG_4, &\n+                     IEEE_SUPPORT_FLAG_8, &\n+#ifdef HAVE_GFC_REAL_10\n+                     IEEE_SUPPORT_FLAG_10, &\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+                     IEEE_SUPPORT_FLAG_16, &\n+#endif\n+                     IEEE_SUPPORT_FLAG_NOARG\n   end interface IEEE_SUPPORT_FLAG\n \n   public :: IEEE_SUPPORT_FLAG, IEEE_SUPPORT_HALTING\n@@ -215,4 +221,22 @@ pure logical function IEEE_SUPPORT_FLAG_8 (FLAG, X) result(res)\n     res = IEEE_SUPPORT_FLAG_NOARG(FLAG)\n   end function\n \n+#ifdef HAVE_GFC_REAL_10\n+  pure logical function IEEE_SUPPORT_FLAG_10 (FLAG, X) result(res)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    real(kind=10), intent(in) :: X\n+    res = IEEE_SUPPORT_FLAG_NOARG(FLAG)\n+  end function\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+  pure logical function IEEE_SUPPORT_FLAG_16 (FLAG, X) result(res)\n+    implicit none\n+    type(IEEE_FLAG_TYPE), intent(in) :: FLAG\n+    real(kind=16), intent(in) :: X\n+    res = IEEE_SUPPORT_FLAG_NOARG(FLAG)\n+  end function\n+#endif\n+\n end module IEEE_EXCEPTIONS"}, {"sha": "f3362d42ef35e68923c82da94bb1f19fb8847e6a", "filename": "libgfortran/ieee/ieee_helper.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fieee%2Fieee_helper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a499884f31391a6ab02739861b2b343eebc94e/libgfortran%2Fieee%2Fieee_helper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_helper.c?ref=22a499884f31391a6ab02739861b2b343eebc94e", "patch": "@@ -33,6 +33,16 @@ internal_proto(ieee_class_helper_4);\n extern int ieee_class_helper_8 (GFC_REAL_8 *);\n internal_proto(ieee_class_helper_8);\n \n+#ifdef HAVE_GFC_REAL_10\n+extern int ieee_class_helper_10 (GFC_REAL_10 *);\n+internal_proto(ieee_class_helper_10);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern int ieee_class_helper_16 (GFC_REAL_16 *);\n+internal_proto(ieee_class_helper_16);\n+#endif\n+\n /* Enumeration of the possible floating-point types. These values\n    correspond to the hidden arguments of the IEEE_CLASS_TYPE\n    derived-type of IEEE_ARITHMETIC.  */\n@@ -74,6 +84,14 @@ enum { IEEE_OTHER_VALUE = 0, IEEE_SIGNALING_NAN, IEEE_QUIET_NAN,\n CLASSMACRO(4)\n CLASSMACRO(8)\n \n+#ifdef HAVE_GFC_REAL_10\n+CLASSMACRO(10)\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+CLASSMACRO(16)\n+#endif\n+\n \n #define GFC_FPE_ALL (GFC_FPE_INVALID | GFC_FPE_DENORMAL | \\\n \t\t     GFC_FPE_ZERO | GFC_FPE_OVERFLOW | \\"}]}