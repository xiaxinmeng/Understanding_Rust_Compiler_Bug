{"sha": "cf0e5ca723edbb63719ca075fce3f84eb8e43553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YwZTVjYTcyM2VkYmI2MzcxOWNhMDc1ZmNlM2Y4NGViOGU0MzU1Mw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2019-08-20T09:50:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-20T09:50:19Z"}, "message": "[Ada] Improve speed of discriminated return types\n\nThe compiler now generates faster code for functions that return\ndiscriminated types in many cases where the size is known at compile\ntime.\n\n2019-08-20  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Needs_BIP_Alloc_Form): Call\n\tRequires_Transient_Scope rather than checking constrainedness\n\tand so forth.  We have previously improved\n\tRequires_Transient_Scope to return False in various cases,\n\tnotably a limited record with an access discriminant. This\n\tchange takes advantage of that to avoid using the secondary\n\tstack for functions returning such types.\n\t(Make_Build_In_Place_Call_In_Allocator): Be consistent by\n\tcalling Needs_BIP_Alloc_Form rather than Is_Constrained and so\n\tforth.\n\t* sem_ch4.adb (Analyze_Allocator): The above change causes the\n\tcompiler to generate code that is not legal Ada, in particular\n\tan uninitialized allocator for indefinite subtype.  This is\n\tharmless, so we suppress the error message in this case.\n\nFrom-SVN: r274738", "tree": {"sha": "cd0ad2fd4b60b699963083199c6eae5157111a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd0ad2fd4b60b699963083199c6eae5157111a3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf0e5ca723edbb63719ca075fce3f84eb8e43553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0e5ca723edbb63719ca075fce3f84eb8e43553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf0e5ca723edbb63719ca075fce3f84eb8e43553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0e5ca723edbb63719ca075fce3f84eb8e43553/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31fde973e5cb886dca17e61b84a72a26a81487ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31fde973e5cb886dca17e61b84a72a26a81487ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31fde973e5cb886dca17e61b84a72a26a81487ad"}], "stats": {"total": 174, "additions": 103, "deletions": 71}, "files": [{"sha": "56cb308509737631b5416b4700171290de7eb613", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0e5ca723edbb63719ca075fce3f84eb8e43553/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0e5ca723edbb63719ca075fce3f84eb8e43553/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cf0e5ca723edbb63719ca075fce3f84eb8e43553", "patch": "@@ -1,3 +1,20 @@\n+2019-08-20  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Needs_BIP_Alloc_Form): Call\n+\tRequires_Transient_Scope rather than checking constrainedness\n+\tand so forth.  We have previously improved\n+\tRequires_Transient_Scope to return False in various cases,\n+\tnotably a limited record with an access discriminant. This\n+\tchange takes advantage of that to avoid using the secondary\n+\tstack for functions returning such types.\n+\t(Make_Build_In_Place_Call_In_Allocator): Be consistent by\n+\tcalling Needs_BIP_Alloc_Form rather than Is_Constrained and so\n+\tforth.\n+\t* sem_ch4.adb (Analyze_Allocator): The above change causes the\n+\tcompiler to generate code that is not legal Ada, in particular\n+\tan uninitialized allocator for indefinite subtype.  This is\n+\tharmless, so we suppress the error message in this case.\n+\n 2019-08-20  Gary Dismukes  <dismukes@adacore.com>\n \n \t* ali.adb, ali.ads, aspects.adb, checks.ads, checks.adb,"}, {"sha": "2733ad44b88436ac21269e8b9ccf317ba9da47ff", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 51, "deletions": 58, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0e5ca723edbb63719ca075fce3f84eb8e43553/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0e5ca723edbb63719ca075fce3f84eb8e43553/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=cf0e5ca723edbb63719ca075fce3f84eb8e43553", "patch": "@@ -5615,7 +5615,23 @@ package body Exp_Ch6 is\n       Set_Comes_From_Extended_Return_Statement (Return_Stmt);\n \n       Rewrite (N, Result);\n-      Analyze (N, Suppress => All_Checks);\n+\n+      declare\n+         T : constant Entity_Id := Etype (Ret_Obj_Id);\n+      begin\n+         Analyze (N, Suppress => All_Checks);\n+\n+         --  In some cases, analysis of N can set the Etype of an N_Identifier\n+         --  to a subtype of the Etype of the Entity of the N_Identifier, which\n+         --  gigi doesn't like. Reset the Etypes correctly here.\n+\n+         if Nkind (Expression (Return_Stmt)) = N_Identifier\n+           and then Entity (Expression (Return_Stmt)) = Ret_Obj_Id\n+         then\n+            Set_Etype (Ret_Obj_Id, T);\n+            Set_Etype (Expression (Return_Stmt), T);\n+         end if;\n+      end;\n    end Expand_N_Extended_Return_Statement;\n \n    ----------------------------\n@@ -8108,13 +8124,41 @@ package body Exp_Ch6 is\n       --  since it is already attached on the related finalization master.\n \n       --  Here and in related routines, we must examine the full view of the\n-      --  type, because the view at the point of call may differ from that\n-      --  that in the function body, and the expansion mechanism depends on\n+      --  type, because the view at the point of call may differ from the\n+      --  one in the function body, and the expansion mechanism depends on\n       --  the characteristics of the full view.\n \n-      if Is_Constrained (Underlying_Type (Result_Subt))\n-        and then not Needs_Finalization (Underlying_Type (Result_Subt))\n-      then\n+      if Needs_BIP_Alloc_Form (Function_Id) then\n+         Temp_Init := Empty;\n+\n+         --  Case of a user-defined storage pool. Pass an allocation parameter\n+         --  indicating that the function should allocate its result in the\n+         --  pool, and pass the pool. Use 'Unrestricted_Access because the\n+         --  pool may not be aliased.\n+\n+         if Present (Associated_Storage_Pool (Acc_Type)) then\n+            Alloc_Form := User_Storage_Pool;\n+            Pool :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         =>\n+                  New_Occurrence_Of\n+                    (Associated_Storage_Pool (Acc_Type), Loc),\n+                Attribute_Name => Name_Unrestricted_Access);\n+\n+         --  No user-defined pool; pass an allocation parameter indicating that\n+         --  the function should allocate its result on the heap.\n+\n+         else\n+            Alloc_Form := Global_Heap;\n+            Pool := Make_Null (No_Location);\n+         end if;\n+\n+         --  The caller does not provide the return object in this case, so we\n+         --  have to pass null for the object access actual.\n+\n+         Return_Obj_Actual := Empty;\n+\n+      else\n          --  Replace the initialized allocator of form \"new T'(Func (...))\"\n          --  with an uninitialized allocator of form \"new T\", where T is the\n          --  result subtype of the called function. The call to the function\n@@ -8163,35 +8207,6 @@ package body Exp_Ch6 is\n       --  perform the allocation of the return object, so we pass parameters\n       --  indicating that.\n \n-      else\n-         Temp_Init := Empty;\n-\n-         --  Case of a user-defined storage pool. Pass an allocation parameter\n-         --  indicating that the function should allocate its result in the\n-         --  pool, and pass the pool. Use 'Unrestricted_Access because the\n-         --  pool may not be aliased.\n-\n-         if Present (Associated_Storage_Pool (Acc_Type)) then\n-            Alloc_Form := User_Storage_Pool;\n-            Pool :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         =>\n-                  New_Occurrence_Of\n-                    (Associated_Storage_Pool (Acc_Type), Loc),\n-                Attribute_Name => Name_Unrestricted_Access);\n-\n-         --  No user-defined pool; pass an allocation parameter indicating that\n-         --  the function should allocate its result on the heap.\n-\n-         else\n-            Alloc_Form := Global_Heap;\n-            Pool := Make_Null (No_Location);\n-         end if;\n-\n-         --  The caller does not provide the return object in this case, so we\n-         --  have to pass null for the object access actual.\n-\n-         Return_Obj_Actual := Empty;\n       end if;\n \n       --  Declare the temp object\n@@ -9279,30 +9294,8 @@ package body Exp_Ch6 is\n    function Needs_BIP_Alloc_Form (Func_Id : Entity_Id) return Boolean is\n       pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n-\n    begin\n-      --  A build-in-place function needs to know which allocation form to\n-      --  use when:\n-      --\n-      --  1) The result subtype is unconstrained. In this case, depending on\n-      --     the context of the call, the object may need to be created in the\n-      --     secondary stack, the heap, or a user-defined storage pool.\n-      --\n-      --  2) The result subtype is tagged. In this case the function call may\n-      --     dispatch on result and thus needs to be treated in the same way as\n-      --     calls to functions with class-wide results, because a callee that\n-      --     can be dispatched to may have any of various result subtypes, so\n-      --     if any of the possible callees would require an allocation form to\n-      --     be passed then they all do.\n-      --\n-      --  3) The result subtype needs finalization actions. In this case, based\n-      --     on the context of the call, the object may need to be created at\n-      --     the caller site, in the heap, or in a user-defined storage pool.\n-\n-      return\n-        not Is_Constrained (Func_Typ)\n-          or else Is_Tagged_Type (Func_Typ)\n-          or else Needs_Finalization (Func_Typ);\n+      return Requires_Transient_Scope (Func_Typ);\n    end Needs_BIP_Alloc_Form;\n \n    --------------------------------------"}, {"sha": "0dccd33a5e40f9aa8ed9358d541a9b0a7c2238b4", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf0e5ca723edbb63719ca075fce3f84eb8e43553/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf0e5ca723edbb63719ca075fce3f84eb8e43553/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=cf0e5ca723edbb63719ca075fce3f84eb8e43553", "patch": "@@ -796,25 +796,47 @@ package body Sem_Ch4 is\n                           (\"\\constraint with discriminant values required\", N);\n                      end if;\n \n-                  --  Limited Ada 2005 and general nonlimited case\n+                  --  Limited Ada 2005 and general nonlimited case.\n+                  --  This is an error, except in the case of an\n+                  --  uninitialized allocator that is generated\n+                  --  for a build-in-place function return of a\n+                  --  discriminated but compile-time-known-size\n+                  --  type.\n \n                   else\n-                     Error_Msg_N\n-                       (\"uninitialized unconstrained allocation not \"\n-                        & \"allowed\", N);\n+                     if Original_Node (N) /= N\n+                       and then Nkind (Original_Node (N)) = N_Allocator\n+                     then\n+                        declare\n+                           Qual : constant Node_Id :=\n+                             Expression (Original_Node (N));\n+                           pragma Assert\n+                             (Nkind (Qual) = N_Qualified_Expression);\n+                           Call : constant Node_Id := Expression (Qual);\n+                           pragma Assert\n+                             (Is_Expanded_Build_In_Place_Call (Call));\n+                        begin\n+                           null;\n+                        end;\n \n-                     if Is_Array_Type (Type_Id) then\n+                     else\n                         Error_Msg_N\n-                          (\"\\qualified expression or constraint with \"\n-                           & \"array bounds required\", N);\n+                          (\"uninitialized unconstrained allocation not \"\n+                           & \"allowed\", N);\n \n-                     elsif Has_Unknown_Discriminants (Type_Id) then\n-                        Error_Msg_N (\"\\qualified expression required\", N);\n+                        if Is_Array_Type (Type_Id) then\n+                           Error_Msg_N\n+                             (\"\\qualified expression or constraint with \"\n+                              & \"array bounds required\", N);\n \n-                     else pragma Assert (Has_Discriminants (Type_Id));\n-                        Error_Msg_N\n-                          (\"\\qualified expression or constraint with \"\n-                           & \"discriminant values required\", N);\n+                        elsif Has_Unknown_Discriminants (Type_Id) then\n+                           Error_Msg_N (\"\\qualified expression required\", N);\n+\n+                        else pragma Assert (Has_Discriminants (Type_Id));\n+                           Error_Msg_N\n+                             (\"\\qualified expression or constraint with \"\n+                              & \"discriminant values required\", N);\n+                        end if;\n                      end if;\n                   end if;\n                end if;"}]}