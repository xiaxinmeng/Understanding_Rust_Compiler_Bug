{"sha": "b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzYTQzNmU2YjkzZDMxYTk1MjNlNGIwNThlZGMyZjFkNWQ4ZGM2Ng==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-01-20T08:55:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-20T08:55:07Z"}, "message": "Makefile.in: Remove all bytecode support.\n\n        * Makefile.in: Remove all bytecode support.\n        (OBJS): Make sure last entry is a real object file, not EXTRA_OBJS.\n        * emit-rtl.c: Remove all bytecode support.\n        * expr.c, expr.h function.c, integrate.c: Likewise.\n        * output.h, regclass.c, rtl.h, stmt.c, toplev.c: Likewise.\n        * tree.h, varasm.c: Likewise.\n        * bi-*, bc-*: Delete bytecode related files.\nBytecode suppors disappears :-)\n\nFrom-SVN: r17432", "tree": {"sha": "793698c32df0aae899d0ce491ac76885c5a17592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/793698c32df0aae899d0ce491ac76885c5a17592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/comments", "author": null, "committer": null, "parents": [{"sha": "6885fc8771316b46fb26d315118a18c00f4a5f31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6885fc8771316b46fb26d315118a18c00f4a5f31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6885fc8771316b46fb26d315118a18c00f4a5f31"}], "stats": {"total": 13037, "additions": 3081, "deletions": 9956}, "files": [{"sha": "fb97c92e72a4511d9d3988aaf0210bea3b9ca87e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -1,3 +1,14 @@\n+Tue Jan 20 09:29:09 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Makefile.in: Remove all bytecode support.\n+\t(OBJS): Make sure last entry is a real object file, not EXTRA_OBJS.\n+\t* emit-rtl.c: Remove all bytecode support.\n+\t* expr.c, expr.h function.c, integrate.c: Likewise.\n+\t* output.h, regclass.c, rtl.h, stmt.c, toplev.c: Likewise.\n+\t* tree.h, varasm.c: Likewise.\n+\t* bi-*, bc-*: Delete bytecode related files.\n+\t\n+\n Tue Jan 20 09:02:31 1998  Gavin Koch  (gavin@cygnus.com)\n \n \t* mips/mips.md (divsi3,divdi3,modsi3,moddi3,udivsi3,udivdi3,"}, {"sha": "71328aa97b7ece0c7a386e5e189afb32feaf235f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 18, "deletions": 98, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -579,12 +579,6 @@ C_AND_OBJC_OBJS = c-lex.o c-pragma.o c-decl.o c-typeck.o c-convert.o \\\n # Language-specific object files for C.\n C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n \n-# Files specific to the C interpreter bytecode compiler(s).\n-BC_OBJS = bc-emit.o bc-optab.o\n-\n-# Bytecode header files constructed at build time; vmsconfig.com wants this.\n-BC_ALL = bc-arity.h bc-opcode.h bc-opname.h\n-\n SCHED_PREFIX = @sched_prefix@\n SCHED_CFLAGS = @sched_cflags@\n \n@@ -597,7 +591,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n- profile.o insn-attrtab.o $(out_object_file) getpwd.o convert.o $(EXTRA_OBJS)\n+ profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -620,7 +614,6 @@ STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  genextract$(build_exeext) genflags$(build_exeext) gencodes$(build_exeext) \\\n  genconfig$(build_exeext) genpeep$(build_exeext) genattrtab$(build_exeext) \\\n  genattr$(build_exeext) genopinit$(build_exeext) \\\n- $(BC_ALL) \\\n  stamp-bcarity stamp-bcopcode stamp-bcopname \\\n  bi-arity$(build_exeext) bi-opcode$(build_exeext) bi-opname$(build_exeext) \\\n  xgcc$(exeext) cc1$(exeext) cpp$(exeext) $(EXTRA_PASSES) \\\n@@ -675,7 +668,6 @@ CONFIG_H =\n RTL_BASE_H = rtl.h rtl.def gansidecl.h machmode.h machmode.def\n RTL_H = $(RTL_BASE_H) genrtl.h\n TREE_H = tree.h real.h tree.def gansidecl.h machmode.h machmode.def\n-BYTECODE_H = bytecode.h bc-emit.h bc-optab.h\n BASIC_BLOCK_H = basic-block.h bitmap.h\n DEMANGLE_H = demangle.h gansidecl.h\n RECOG_H = recog.h gansidecl.h\n@@ -789,8 +781,8 @@ compilations: ${OBJS}\n \n # Create a list of the language-independent object files so the language\n # subdirectories needn't mention their names explicitly.\n-stamp-objlist: $(OBJS) $(BC_OBJS)\n-\techo \" $(OBJS) $(BC_OBJS)\" | sed -e 's, \\([a-z0-9]\\), ../\\1,g' -e 's/\\.o/$(objext)/g' >stamp-objlist\n+stamp-objlist: $(OBJS) \n+\techo \" $(OBJS)\" | sed -e 's, \\([a-z0-9]\\), ../\\1,g' -e 's/\\.o/$(objext)/g' >stamp-objlist\n \n # We call this executable `xgcc' rather than `gcc'\n # to avoid confusion if the current directory is in the path\n@@ -811,8 +803,8 @@ specs: xgcc\n gcc-cross: xgcc\n \tcp xgcc$(exeext) gcc-cross$(exeext)\n \n-cc1: $(P) $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)\n+cc1: $(P) $(C_OBJS) $(OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) $(OBJS) $(LIBS)\n \n # Copy float.h from its source.\n gfloat.h: $(FLOAT_H)\n@@ -1324,7 +1316,7 @@ tree.o : tree.c $(CONFIG_H) $(TREE_H) flags.h function.h\n print-tree.o : print-tree.c $(CONFIG_H) $(TREE_H)\n stor-layout.o : stor-layout.c $(CONFIG_H) $(TREE_H) flags.h function.h\n fold-const.o : fold-const.c $(CONFIG_H) $(TREE_H) flags.h \n-toplev.o : toplev.c $(CONFIG_H) $(TREE_H) $(RTL_H) bytecode.h bc-emit.h \\\n+toplev.o : toplev.c $(CONFIG_H) $(TREE_H) $(RTL_H) \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    $(lang_options_files)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(MAYBE_USE_COLLECT2) \\\n@@ -1338,21 +1330,19 @@ rtlanal.o : rtlanal.c $(CONFIG_H) $(RTL_H)\n \n varasm.o : varasm.c $(CONFIG_H) $(TREE_H) $(RTL_H) flags.h function.h \\\n    defaults.h insn-codes.h expr.h hard-reg-set.h regs.h xcoffout.h \\\n-   output.h bytecode.h c-pragma.h\n+   output.h c-pragma.h\n function.o : function.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-codes.h expr.h regs.h hard-reg-set.h insn-config.h \\\n-   $(RECOG_H) output.h bytecode.h bc-emit.h\n+   $(RECOG_H) output.h\n stmt.o : stmt.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-config.h insn-codes.h hard-reg-set.h expr.h except.h \\\n-   loop.h $(RECOG_H) bytecode.h bc-typecd.h bc-typecd.def bc-opcode.h \\\n-   bc-optab.h bc-emit.h\n+   loop.h $(RECOG_H)  \n except.o : except.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-codes.h expr.h regs.h hard-reg-set.h insn-config.h \\\n    $(RECOG_H) output.h except.h\n expr.o : expr.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h function.h regs.h \\\n    insn-flags.h insn-codes.h expr.h insn-config.h $(RECOG_H) output.h \\\n-   typeclass.h bytecode.h bc-opcode.h bc-typecd.h bc-typecd.def bc-optab.h \\\n-   bc-emit.h modemap.def hard-reg-set.h\n+   typeclass.h modemap.def hard-reg-set.h\n calls.o : calls.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h expr.h insn-codes.h \\\n    insn-flags.h regs.h\n expmed.o : expmed.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h  \\\n@@ -1365,22 +1355,20 @@ dbxout.o : dbxout.c $(CONFIG_H) $(TREE_H) $(RTL_H) flags.h regs.h \\\n    insn-config.h reload.h gstab.h xcoffout.h defaults.h output.h\n sdbout.o : sdbout.c $(CONFIG_H) $(TREE_H) $(RTL_H) flags.h except.h \\\n    function.h expr.h output.h hard-reg-set.h regs.h defaults.h real.h \\\n-   insn-config.h bytecode.h obstack.h xcoffout.h c-pragma.h\n+   insn-config.h obstack.h xcoffout.h c-pragma.h\n dwarfout.o : dwarfout.c $(CONFIG_H) $(TREE_H) $(RTL_H) dwarf.h flags.h \\\n    insn-config.h reload.h output.h defaults.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) $(TREE_H) $(RTL_H) dwarf2.h flags.h \\\n    insn-config.h reload.h output.h defaults.h hard-reg-set.h regs.h expr.h\n xcoffout.o : xcoffout.c $(CONFIG_H) $(TREE_H) $(RTL_H) xcoffout.h flags.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h except.h \\\n-   function.h regs.h insn-config.h $(RECOG_H) real.h expr.h obstack.h \\\n-   bytecode.h bc-opcode.h bc-typecd.h bc-typecd.def bc-optab.h bc-emit.h \\\n-   bc-opname.h\n+   function.h regs.h insn-config.h $(RECOG_H) real.h expr.h obstack.h\n real.o : real.c $(CONFIG_H) $(TREE_H)\n getpwd.o : getpwd.c $(CONFIG_H)\n \n integrate.o : integrate.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h integrate.h \\\n    insn-flags.h insn-config.h insn-codes.h expr.h real.h regs.h function.h \\\n-   bytecode.h output.h $(RECOG_H) except.h\n+   output.h $(RECOG_H) except.h\n \n jump.o : jump.c $(CONFIG_H) $(RTL_H) flags.h hard-reg-set.h regs.h \\\n    insn-config.h insn-flags.h $(RECOG_H) expr.h real.h except.h\n@@ -1400,7 +1388,7 @@ combine.o : combine.c $(CONFIG_H) $(RTL_H) flags.h  \\\n    insn-config.h insn-flags.h insn-codes.h insn-attr.h regs.h expr.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h\n regclass.o : regclass.c $(CONFIG_H) $(RTL_H) hard-reg-set.h flags.h \\\n-   $(BASIC_BLOCK_H) regs.h insn-config.h $(RECOG_H) reload.h real.h bytecode.h\n+   $(BASIC_BLOCK_H) regs.h insn-config.h $(RECOG_H) reload.h real.h\n local-alloc.o : local-alloc.c $(CONFIG_H) $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n    regs.h hard-reg-set.h insn-config.h $(RECOG_H) output.h\n bitmap.o : bitmap.c $(CONFIG_H) $(RTL_H) flags.h $(BASIC_BLOCK_H) regs.h\n@@ -1735,74 +1723,6 @@ $(HOST_PREFIX_1)malloc.o: malloc.c\n # that does not need to compile alloca, malloc or whatever.\n $(HOST_PREFIX_1): \n \ttouch $(HOST_PREFIX_1)\n-#\f\n-# Remake bytecode files.\n-BI_OBJ=bi-parser.o bi-lexer.o bi-reverse.o\n-\n-bc-emit.o : bc-emit.c $(CONFIG_H) $(RTL_H) real.h $(BYTECODE_H) \\\n-   bc-arity.h bc-opcode.h bc-typecd.h bc-typecd.def bi-run.h bytetypes.h\n-bc-optab.o : bc-optab.c $(CONFIG_H) $(REAL_H) $(BYTECODE_H) \\\n-   bc-opcode.h bc-typecd.h bc-typecd.def\n-\n-bi-arity: bi-arity.o $(BI_OBJ) $(HOST_LIBDEPS)\n-\t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t bi-arity.o $(BI_OBJ) $(HOST_LIBS)\n-bi-opcode: bi-opcode.o $(BI_OBJ) $(HOST_LIBDEPS)\n-\t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t bi-opcode.o $(BI_OBJ) $(HOST_LIBS)\n-bi-opname: bi-opname.o $(BI_OBJ) $(HOST_LIBDEPS)\n-\t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t bi-opname.o $(BI_OBJ) $(HOST_LIBS)\n-\n-$(srcdir)/bi-parser.h: $(srcdir)/bi-parser.c\n-$(srcdir)/bi-parser.c: $(srcdir)/bi-parser.y\n-\tcd $(srcdir); $(BISON) $(BISONFLAGS) -d bi-parser.y -o bi-parser.c\n-\n-bi-parser.o: $(srcdir)/bi-parser.c bi-defs.h $(build_xm_file)\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n-\t   $(srcdir)/bi-parser.c\n-bi-lexer.o: bi-lexer.c $(srcdir)/bi-parser.h $(build_xm_file)\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n-\t   $(srcdir)/bi-lexer.c\n-bi-arity.o: bi-arity.c bi-defs.h $(build_xm_file)\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n-\t   $(srcdir)/bi-arity.c\n-bi-opcode.o: bi-opcode.c bi-defs.h $(build_xm_file)\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n-\t   $(srcdir)/bi-opcode.c\n-bi-opname.o: bi-opname.c bi-defs.h $(build_xm_file)\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n-\t   $(srcdir)/bi-opname.c\n-bi-reverse.o: bi-reverse.c bi-defs.h\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n-\t   $(srcdir)/bi-reverse.c\n-\n-bc-arity.h: stamp-bcarity ; @true\n-stamp-bcarity : $(srcdir)/bytecode.def bi-arity $(srcdir)/move-if-change\n-\t./bi-arity < $(srcdir)/bytecode.def >tmp-bc-arity.h\n-\t$(srcdir)/move-if-change tmp-bc-arity.h bc-arity.h\n-\ttouch stamp-bcarity\n-\n-bc-opcode.h: stamp-bcopcode ; @true\n-stamp-bcopcode : $(srcdir)/bytecode.def bi-opcode $(srcdir)/move-if-change\n-\t./bi-opcode < $(srcdir)/bytecode.def >tmp-bcopcd.h\n-\t$(srcdir)/move-if-change tmp-bcopcd.h bc-opcode.h\n-\ttouch stamp-bcopcode\n-\n-bc-opname.h: stamp-bcopname ; @true\n-stamp-bcopname : $(srcdir)/bytecode.def bi-opname $(srcdir)/move-if-change\n-\t./bi-opname < $(srcdir)/bytecode.def >tmp-bcopnm.h\n-\t$(srcdir)/move-if-change tmp-bcopnm.h bc-opname.h\n-\ttouch stamp-bcopname\n-\n-bytecode.mostlyclean:\n-\t-rm -f bc-arity.h bc-opcode.h bc-opname.h\n-\n-bytecode.distclean bytecode.clean:\tbytecode.mostlyclean\n-\t-rm -f bi-arity bi-opcode bi-opname bi-lexer\n-\n-bytecode.maintainer-clean: bytecode.clean\n-\t-rm -f bi-parser.c bi-parser.h\n \n #\f\n # Remake cpp and protoize.\n@@ -2112,7 +2032,7 @@ INSTALL: $(srcdir)/install1.texi $(srcdir)/install.texi\n # (less duplicated code).\n \n \n-mostlyclean: bytecode.mostlyclean lang.mostlyclean\n+mostlyclean: lang.mostlyclean\n \t-rm -f $(STAGESTUFF)\n # Delete the temporary source copies for cross compilation.\n \t-rm -f $(HOST_PREFIX_1)rtl.c $(HOST_PREFIX_1)rtlanal.c\n@@ -2153,7 +2073,7 @@ mostlyclean: bytecode.mostlyclean lang.mostlyclean\n \n # Delete all files made by compilation\n # that don't exist in the distribution.\n-clean: mostlyclean bytecode.clean lang.clean\n+clean: mostlyclean lang.clean\n # It may not be quite desirable to delete unprotoize.c here,\n # but the spec for `make clean' requires it.\n # Using unprotoize.c is not quite right in the first place, \n@@ -2179,7 +2099,7 @@ clean: mostlyclean bytecode.clean lang.clean\n \n # Delete all files that users would normally create\n # while building and installing GCC.\n-distclean: clean bytecode.distclean lang.distclean\n+distclean: clean lang.distclean\n \t-rm -f tm.h config.h auto-config.h tconfig.h hconfig.h md cstamp-h\n \t-rm -f config.status config.run config.cache config.bak\n \t-rm -f Make-lang Make-hooks Make-host Make-target\n@@ -2214,7 +2134,7 @@ extraclean: distclean lang.extraclean\n maintainer-clean:\n \t@echo 'This command is intended for maintainers to use; it'\n \t@echo 'deletes files that may need special tools to rebuild.'\n-\t$(MAKE) distclean bytecode.maintainer-clean lang.maintainer-clean\n+\t$(MAKE) distclean lang.maintainer-clean\n \t-rm -f c-parse.y c-gperf.h\n \t-rm -f c-parse.c c-parse.h c-parse.output\n \t-rm -f cexp.c cexp.output TAGS "}, {"sha": "c93195df9e1b80693dc488c6389c851ae0304fb7", "filename": "gcc/bc-emit.c", "status": "removed", "additions": 0, "deletions": 1018, "changes": 1018, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,1018 +0,0 @@\n-/* Output bytecodes for GNU C-compiler.\n-   Copyright (C) 1993, 1994, 1996 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"config.h\"\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else\n-#include <varargs.h>\n-#endif\n-#include \"machmode.h\"\n-#include \"rtl.h\"\n-#include \"real.h\"\n-#include \"obstack.h\"\n-#include \"bytecode.h\"\n-#ifdef __GNUC__\n-#include \"bytetypes.h\"\n-#endif\n-#include \"bc-emit.h\"\n-#include \"bc-opcode.h\"\n-#include \"bc-typecd.h\"\n-#include \"bi-run.h\"\n-\n-#include <stdio.h>\n-\n-extern char *xmalloc (), *xrealloc ();\n-\n-extern struct obstack *rtl_obstack;\n-\n-/* Indexed by mode class, gives the narrowest mode for each class.  */\n-\n-extern enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS];\n-\n-/* Commonly used modes.  */\n-/* Mode whose width is BITS_PER_UNIT */\n-extern enum machine_mode byte_mode;\n-\n-/* Mode whose width is BITS_PER_WORD */\n-extern enum machine_mode word_mode;\n-\n-/* Vector indexed by opcode giving info about the args for each opcode.  */\n-static struct arityvec arityvec[] = {\n-#include \"bc-arity.h\"\n-};\n-\n-/* How to print a symbol name for the assembler.  */\n-\n-static void\n-prsym (file, s)\n-     FILE *file;\n-     char *s;\n-{\n-  if (*s == '*')\n-    fprintf (file, \"%s\", s + 1);\n-  else\n-\n-#ifdef NAMES_HAVE_UNDERSCORES\n-    fprintf (file, \"_%s\", s);\n-#else\n-    fprintf (file, \"%s\", s);\n-#endif\n-\n-}\n-\n-/* Maintain a bucket hash table for symbol names.  */\n-\n-#define HASH_BITS 32\n-#define HASH_SIZE 509\n-\n-static struct bc_sym *hashtab[HASH_SIZE];\n-\n-static unsigned int\n-hash (name)\n-     char *name;\n-{\n-  unsigned int hash = 0;\n-\n-  while (*name)\n-    {\n-      hash = hash << 3 | hash >> HASH_BITS - 3;\n-      hash += *name++;\n-    }\n-\n-  return hash % HASH_SIZE;\n-}\n-\n-\n-/* Look up the named symbol, creating it if it doesn't exist.  */\n-\n-struct bc_sym *\n-sym_lookup (name)\n-     char *name;\n-{\n-  int i;\n-  struct bc_sym *s;\n-\n-  i = hash (name);\n-  for (s = hashtab[i]; s; s = s->next)\n-    if (!strcmp (s->name, name))\n-      return s;\n-\n-  s = (struct bc_sym *) xmalloc (sizeof (struct bc_sym));\n-  s->name = xmalloc (strlen (name) + 1);\n-  strcpy (s->name, name);\n-  s->defined = s->global = s->common = 0;\n-  s->val = 0;\n-  s->next = hashtab[i];\n-  hashtab[i] = s;\n-  return s;\n-}\n-\n-\n-/* Write out .globl and common symbols to the named file.  */\n-\n-static void\n-bc_sym_write (file)\n-     FILE *file;\n-{\n-  int i;\n-  struct bc_sym *s;\n-\n-  for (i = 0; i < HASH_SIZE; ++i)\n-    for (s = hashtab[i]; s; s = s->next)\n-      {\n-\tif (s->global)\n-\t  {\n-\t    fprintf (file, \"\\n\\t.globl \");\n-\t    prsym (file, s->name);\n-\t    putc ('\\n', file);\n-\t    if (s->common)\n-\t      {\n-\t\tfprintf (file, \"\\n\\t.comm \");\n-\t\tprsym (file, s->name);\n-\t\tfprintf (file, \", %lu\\n\", s->val);\n-\t      }\n-\t  }\n-\telse if (s->common)\n-\t  {\n-\t    fprintf (file, \"\\n\\t.lcomm \");\n-\t    prsym (file, s->name);\n-\t    fprintf (file, \", %lu\\n\", s->val);\n-\t  }\n-      }\n-}\n-\n-\f\n-\n-\n-/* Create and initialize a new segment.  */\n-\n-static struct bc_seg *\n-seg_create ()\n-{\n-  struct bc_seg *result;\n-\n-  result = (struct bc_seg *) xmalloc (sizeof (struct bc_seg));\n-  result->alloc = 256;\n-  result->data = xmalloc (result->alloc);\n-  result->size = 0;\n-  result->syms = 0;\n-  result->relocs = 0;\n-  return result;\n-}\n-\n-\n-/* Advance the segment index to the next alignment boundary.  */\n-\n-static void\n-seg_align (seg, log)\n-     struct bc_seg *seg;\n-     int log;\n-{\n-  unsigned int oldsize = seg->size;\n-\n-  seg->size = seg->size + (1 << log) - 1 & ~((1 << log) - 1);\n-  if (seg->size > seg->alloc)\n-    {\n-      while (seg->size > seg->alloc)\n-\tseg->alloc *= 2;\n-      seg->data = xrealloc (seg->data, seg->alloc);\n-    }\n-  bzero (seg->data + oldsize, seg->size - oldsize);\n-}\n-\n-\n-/* Append the given data to the given segment.  */\n-\n-static void\n-seg_data (seg, data, size)\n-     struct bc_seg *seg;\n-     char *data;\n-     unsigned int size;\n-{\n-  if (seg->size + size > seg->alloc)\n-    {\n-      while (seg->size + size > seg->alloc)\n-\tseg->alloc *= 2;\n-      seg->data = xrealloc (seg->data, seg->alloc);\n-    }\n-\n-  bcopy (data, seg->data + seg->size, size);\n-  seg->size += size;\n-}\n-\n-\n-/* Append a zero-filled skip to the given segment.  */\n-\n-static void\n-seg_skip (seg, size)\n-     struct bc_seg *seg;\n-     unsigned int size;\n-{\n-  if (seg->size + size > seg->alloc)\n-    {\n-      while (seg->size + size > seg->alloc)\n-\tseg->alloc *= 2;\n-      seg->data = xrealloc (seg->data, seg->alloc);\n-    }\n-\n-  memset (seg->data + seg->size, 0, size);\n-  seg->size += size;\n-}\n-\n-\n-/* Define the given name as the current offset in the given segment.  It\n-   is an error if the name is already defined.  Return 0 or 1 indicating\n-   failure or success respectively.  */\n-\n-static int\n-seg_defsym (seg, name)\n-     struct bc_seg *seg;\n-     char *name;\n-{\n-  struct bc_sym *sym;\n-  struct bc_segsym *segsym;\n-\n-  sym = sym_lookup (name);\n-  if (sym->defined)\n-    return 0;\n-\n-  sym->defined = 1;\n-  sym->val = seg->size;\n-  segsym = (struct bc_segsym *) xmalloc (sizeof (struct bc_segsym));\n-  segsym->sym = sym;\n-  segsym->next = seg->syms;\n-  seg->syms = segsym;\n-  return 1;\n-}\n-\n-\n-/* Generate in seg's data a reference to the given sym, adjusted by\n-   the given offset.  */\n-\n-static void\n-seg_refsym (seg, name, offset)\n-     struct bc_seg *seg;\n-     char *name;\n-     int offset;\n-{\n-  struct bc_sym *sym;\n-  struct bc_segreloc *segreloc;\n-\n-  sym = sym_lookup (name);\n-  segreloc = (struct bc_segreloc *) xmalloc (sizeof (struct bc_segreloc));\n-  segreloc->offset = seg->size;\n-  segreloc->sym = sym;\n-  segreloc->next = seg->relocs;\n-  seg->relocs = segreloc;\n-  seg_data (seg, (char *) &offset, sizeof offset);\n-}\n-\n-\n-/* Concatenate the contents of given segments into the first argument.  */\n-\n-static void\n-seg_concat (result, seg)\n-     struct bc_seg *result, *seg;\n-{\n-  unsigned int fix;\n-  struct bc_segsym *segsym;\n-  struct bc_segreloc *segreloc;\n-\n-  seg_align (result, MACHINE_SEG_ALIGN);\n-  fix = result->size;\n-  seg_data (result, seg->data, seg->size);\n-  free (seg->data);\n-\n-  /* Go through the symbols and relocs of SEG, adjusting their offsets\n-     for their new location in RESULT.  */\n-  if (seg->syms)\n-    {\n-      segsym = seg->syms;\n-      do\n-\tsegsym->sym->val += fix;\n-      while (segsym->next && (segsym = segsym->next));\n-      segsym->next = result->syms;\n-      result->syms = seg->syms;\n-    }\n-  if (seg->relocs)\n-    {\n-      segreloc = seg->relocs;\n-      do\n-\tsegreloc->offset += fix;\n-      while (segreloc->next && (segreloc = segreloc->next));\n-      segreloc->next = result->relocs;\n-      result->relocs = seg->relocs;\n-    }\n-\n-  free ((char *) seg);\n-}\n-\n-/* Write a segment to a file.  */\n-\n-static void\n-bc_seg_write (seg, file)\n-     struct bc_seg *seg;\n-     FILE *file;\n-{\n-  struct bc_segsym *segsym, *nsegsym, *psegsym;\n-  struct bc_segreloc *segreloc, *nsegreloc, *psegreloc;\n-  int i, offset, flag;\n-\n-  /* Reverse the list of symbols.  */\n-  for (psegsym = 0, segsym = seg->syms; segsym; segsym = nsegsym)\n-    {\n-      nsegsym = segsym->next;\n-      segsym->next = psegsym;\n-      psegsym = segsym;\n-    }\n-  seg->syms = psegsym;\n-\n-  /* Reverse the list of relocs.  */\n-  for (psegreloc = 0, segreloc = seg->relocs; segreloc; segreloc = nsegreloc)\n-    {\n-      nsegreloc = segreloc->next;\n-      segreloc->next = psegreloc;\n-      psegreloc = segreloc;\n-    }\n-  seg->relocs = psegreloc;\n-\n-  /* Output each byte of the segment.  */\n-  for (i = 0, segsym = seg->syms, segreloc = seg->relocs; i < seg->size; ++i)\n-    {\n-      while (segsym && segsym->sym->val == i)\n-\t{\n-\t  if (i % 8 != 0)\n-\t    putc ('\\n', file);\n-\n-\t  BC_WRITE_SEGSYM (segsym, file);\n-\t  segsym = segsym->next;\n-\t  flag = 1;\n-\t}\n-      if (segreloc && segreloc->offset == i)\n-\t{\n-\t  if (i % 8 != 0)\n-\t    putc ('\\n', file);\n-\n-\t  bcopy (seg->data + i, (char *) &offset, sizeof (int));\n-\t  i += sizeof (int) - 1;\n-\n-\t  BC_WRITE_RELOC_ENTRY (segreloc, file, offset);\n-\t  segreloc = segreloc->next;\n-\t  flag = 1;\n-\t}\n-      else\n-\t{\n-\t  if (i % 8 == 0 || flag)\n-\t    BC_START_BYTECODE_LINE (file);\n-\n-\t  BC_WRITE_BYTECODE (i % 8 == 0 || flag ? ' ' : ',',\n-\t\t\t     seg->data[i] & 0xFF,\n-\t\t\t     file);\n-\t  flag = 0;\n-\t  if (i % 8 == 7)\n-\t    putc ('\\n', file);\n-\t}\n-    }\n-\n-  /* Paranoia check--we should have visited all syms and relocs during\n-     the output pass.  */\n-\n-  if (segsym || segreloc)\n-    abort ();\n-}\n-\n-\f\n-\n-/* Text and data segments of the object file in making.  */\n-static struct bc_seg *bc_text_seg;\n-static struct bc_seg *bc_data_seg;\n-\n-/* Called before anything else in this module.  */\n-\n-void\n-bc_initialize ()\n-{\n-  int min_class_size[(int) MAX_MODE_CLASS];\n-  enum machine_mode mode;\n-  int i;\n-\n-  bc_init_mode_to_code_map ();\n-\n-  bc_text_seg = seg_create ();\n-  bc_data_seg = seg_create ();\n-\n-  dconst0 = REAL_VALUE_ATOF (\"0\", DFmode);\n-  dconst1 = REAL_VALUE_ATOF (\"1\", DFmode);\n-  dconst2 = REAL_VALUE_ATOF (\"2\", DFmode);\n-  dconstm1 = REAL_VALUE_ATOF (\"-1\", DFmode);\n-\n-  /* Find the narrowest mode for each class and compute the word and byte\n-     modes.  */\n-\n-  for (i = 0; i < (int) MAX_MODE_CLASS; i++)\n-    min_class_size[i] = 1000;\n-\n-  for (mode = VOIDmode; (int) mode < (int) MAX_MACHINE_MODE;\n-       mode = (enum machine_mode) ((int) mode + 1))\n-    {\n-      if (GET_MODE_SIZE (mode) < min_class_size[(int) GET_MODE_CLASS (mode)])\n-\t{\n-\t  class_narrowest_mode[(int) GET_MODE_CLASS (mode)] = mode;\n-\t  min_class_size[(int) GET_MODE_CLASS (mode)] = GET_MODE_SIZE (mode);\n-\t}\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE_BITSIZE (mode) == BITS_PER_UNIT)\n-\tbyte_mode = mode;\n-\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE_BITSIZE (mode) == BITS_PER_WORD)\n-\tword_mode = mode;\n-    }\n-}\n-\n-\n-/* External addresses referenced in a function.  Rather than trying to\n-   work relocatable address directly into bytecoded functions (which would\n-   require us to provide hairy location info and possibly obey alignment\n-   rules imposed by the architecture) we build an auxiliary table of\n-   pointer constants, and encode just offsets into this table into the\n-   actual bytecode.  */\n-static struct bc_seg *ptrconsts;\n-\n-/* Trampoline code for the function entry.  */\n-struct bc_seg *trampoline;\n-\n-/* Actual byte code of the function.  */\n-struct bc_seg *bytecode;\n-\n-/* List of labels defined in the function.  */\n-struct bc_label *labels;\n-\n-/* List of label references in the function.  */\n-struct bc_labelref *labelrefs;\n-\n-\n-/* Add symbol to pointer table.  Return offset into table where\n-   pointer was stored.  The offset usually goes into the bytecode\n-   stream as a constP literal.  */\n-\n-int\n-bc_define_pointer (p)\n-     char *p;\n-{\n-  int offset = ptrconsts->size;\n-\n-  seg_refsym (ptrconsts, p, 0);\n-  return offset;\n-}\n-\n-\n-/* Begin a bytecoded function.  */\n-\n-int\n-bc_begin_function (name)\n-    char *name;\n-{\n-  ptrconsts = seg_create ();\n-  trampoline = seg_create ();\n-  bytecode = seg_create ();\n-  return seg_defsym (trampoline, name);\n-}\n-\n-\n-/* Force alignment in inline bytecode.  */\n-\n-void\n-bc_align_bytecode (align)\n-    int align;\n-{\n-  seg_align (bytecode, align);\n-}\n-\n-\n-/* Emit data inline into bytecode.  */\n-\n-void\n-bc_emit_bytecode_const (data, size)\n-     char *data;\n-     unsigned int size;\n-{\n-  if (bytecode)\n-    seg_data (bytecode, data, size);\n-}\n-\n-\n-/* Create a new \"bytecode label\", to have its value defined later.\n-   Bytecode labels have nothing to do with the object file symbol table,\n-   and are purely local to a given bytecoded function.  */\n-\n-struct bc_label *\n-bc_get_bytecode_label ()\n-{\n-  struct bc_label *result;\n-\n-  result = (struct bc_label *) xmalloc (sizeof (struct bc_label));\n-  result->defined = 0;\n-  result->next = labels;\n-  result->uid = 0;\n-  labels = result;\n-  return result;\n-}\n-\n-\n-/* Define the given label with the current location counter.  */\n-\n-int\n-bc_emit_bytecode_labeldef (label)\n-     struct bc_label *label;\n-{\n-  extern int bc_new_uid ();\n-\n-  if (!label || label->defined)\n-    return 0;\n-\n-  label->offset = bytecode->size;\n-  label->defined = 1;\n-  label->uid = bc_new_uid ();\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fprintf (stderr, \"$%lx:\\n\", label);\n-#endif\n-\n-  return 1;\n-}\n-\n-\n-/* Generate a location-relative reference to the given bytecode label.\n-   It need not be defined yet; label references will be backpatched later.  */\n-\n-void\n-bc_emit_bytecode_labelref (label)\n-     struct bc_label *label;\n-{\n-  struct bc_labelref *labelref;\n-  static int zero;\n-\n-  labelref = (struct bc_labelref *) xmalloc (sizeof (struct bc_labelref));\n-  labelref->label = label;\n-  labelref->offset = bytecode->size;\n-  labelref->next = labelrefs;\n-  labelrefs = labelref;\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fprintf (stderr, \" $%lx\", label);\n-#endif\n-\n-  seg_data (bytecode, (char *) &zero, sizeof zero);\n-}\n-\n-\n-/* Emit a reference to an external address; generate the reference in the\n-   ptrconst area, and emit an offset in the bytecode.  */\n-\n-void\n-bc_emit_code_labelref (name, offset)\n-     char *name;\n-     int offset;\n-{\n-  int ptroff;\n-\n-  ptroff = ptrconsts->size / sizeof (char *);\n-  seg_data (bytecode, (char *) &ptroff, sizeof ptroff);\n-  seg_refsym (ptrconsts, name, offset);\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fprintf (stderr, \" [external <%x> %s]\", ptroff, name);\n-#endif\n-}\n-\n-\n-/* Backpatch label references in the byte code, and concatenate the bytecode\n-   and pointer constant segments to the cumulative text for the object file.\n-   Return a label name for the pointer constants region.  */\n-\n-char *\n-bc_end_function ()\n-{\n-  int addr;\n-  struct bc_label *label, *next;\n-  struct bc_labelref *ref, *nextref;\n-  char ptrconsts_label[20];\n-  static int nlab;\n-\n-  /* Backpatch bytecode label references.  */\n-  for (ref = labelrefs; ref; ref = ref->next)\n-    if (ref->label->defined)\n-      {\n-\taddr = ref->label->offset;\n-\tbcopy ((char *) &addr, bytecode->data + ref->offset, sizeof addr);\n-      }\n-\n-  /* Free the chains of labelrefs and labeldefs.  */\n-  for (ref = labelrefs; ref; ref = nextref)\n-    {\n-      nextref = ref->next;\n-      free ((char *) ref);\n-    }\n-\n-  for (label = labels; label; label = next)\n-    {\n-      next = label->next;\n-      free ((char *) label);\n-    }\n-\n-  seg_concat (trampoline, bytecode);\n-  seg_align (trampoline, MACHINE_SEG_ALIGN);\n-  sprintf (ptrconsts_label, \"*LP%d\", nlab++);\n-  seg_defsym (trampoline, ptrconsts_label);\n-  seg_concat (trampoline, ptrconsts);\n-  seg_concat (bc_text_seg, trampoline);\n-\n-  labels = 0;\n-  labelrefs = 0;\n-  trampoline = 0;\n-  bytecode = 0;\n-  ptrconsts = 0;\n-\n-  return sym_lookup (ptrconsts_label)->name;\n-}\n-\n-/* Force alignment in const data.  */\n-\n-void\n-bc_align_const (align)\n-     int align;\n-{\n-  seg_align (bc_text_seg, align);\n-}\n-\n-/* Emit const data.  */\n-\n-void\n-bc_emit_const (data, size)\n-     char *data;\n-     unsigned int size;\n-{\n-  seg_data (bc_text_seg, data, size);\n-}\n-\n-/* Emit a zero-filled constant skip.  */\n-\n-void\n-bc_emit_const_skip (size)\n-     unsigned int size;\n-{\n-  seg_skip (bc_text_seg, size);\n-}\n-\n-/* Emit a label definition in const data.  */\n-\n-int\n-bc_emit_const_labeldef (name)\n-     char *name;\n-{\n-  return seg_defsym (bc_text_seg, name);\n-}\n-\n-/* Emit a label reference in const data.  */\n-\n-void\n-bc_emit_const_labelref (name, offset)\n-     char *name;\n-     int offset;\n-{\n-  seg_refsym (bc_text_seg, name, offset);\n-}\n-\n-/* Force alignment in data.  */\n-\n-void\n-bc_align_data (align)\n-     int align;\n-{\n-  seg_align (bc_data_seg, align);\n-}\n-\n-/* Emit data.  */\n-\n-void\n-bc_emit_data (data, size)\n-     char *data;\n-     unsigned int size;\n-{\n-  seg_data (bc_data_seg, data, size);\n-}\n-\n-/* Emit a zero-filled data skip.  */\n-\n-void\n-bc_emit_data_skip (size)\n-     unsigned int size;\n-{\n-  seg_skip (bc_data_seg, size);\n-}\n-\n-/* Emit label definition in data.  */\n-\n-int\n-bc_emit_data_labeldef (name)\n-     char *name;\n-{\n-  return seg_defsym (bc_data_seg, name);\n-}\n-\n-/* Emit label reference in data.  */\n-\n-void\n-bc_emit_data_labelref (name, offset)\n-     char *name;\n-     int offset;\n-{\n-  seg_refsym (bc_data_seg, name, offset);\n-}\n-\n-/* Emit a common block of the given name and size.  Note that\n-   when the .o file is actually written non-global \"common\"\n-   blocks will have to be turned into space in the data section.  */\n-\n-int\n-bc_emit_common (name, size)\n-     char *name;\n-     unsigned int size;\n-{\n-  struct bc_sym *sym;\n-\n-  sym = sym_lookup (name);\n-  if (sym->defined)\n-    return 0;\n-\n-  sym->defined = 1;\n-  sym->common = 1;\n-  sym->val = size;\n-  return 1;\n-}\n-\n-/* Globalize the given label.  */\n-\n-void\n-bc_globalize_label (name)\n-     char *name;\n-{\n-  struct bc_sym *sym;\n-\n-  sym = sym_lookup (name);\n-  sym->global = 1;\n-}\n-\n-static enum { in_text, in_data } section = in_text;\n-\n-void\n-bc_text ()\n-{\n-  section = in_text;\n-}\n-\n-void\n-bc_data ()\n-{\n-  section = in_data;\n-}\n-\n-void\n-bc_align (align)\n-     int align;\n-{\n-  if (section == in_text)\n-    bc_align_const (align);\n-  else\n-    bc_align_data (align);\n-}\n-\n-void\n-bc_emit (data, size)\n-     char *data;\n-     unsigned int size;\n-{\n-  if (section == in_text)\n-    bc_emit_const (data, size);\n-  else\n-    bc_emit_data (data, size);\n-}\n-\n-void\n-bc_emit_skip (size)\n-     unsigned int size;\n-{\n-  if (section == in_text)\n-    bc_emit_const_skip (size);\n-  else\n-    bc_emit_data_skip (size);\n-}\n-\n-int\n-bc_emit_labeldef (name)\n-     char *name;\n-{\n-  if (section == in_text)\n-    return bc_emit_const_labeldef (name);\n-  else\n-    return bc_emit_data_labeldef (name);\n-}\n-\n-void\n-bc_emit_labelref (name, offset)\n-     char *name;\n-     int offset;\n-{\n-  if (section == in_text)\n-    bc_emit_const_labelref (name, offset);\n-  else\n-    bc_emit_data_labelref (name, offset);\n-}\n-\n-void\n-bc_write_file (file)\n-     FILE *file;\n-{\n-  BC_WRITE_FILE (file);\n-}\n-\n-\n-/* Allocate a new bytecode rtx.\n-   If you supply a null BC_LABEL, we generate one.  */\n-\n-rtx\n-bc_gen_rtx (label, offset, bc_label)\n-     char *label;\n-     int offset;\n-     struct bc_label *bc_label;\n-{\n-  rtx r;\n-\n-  if (bc_label == 0)\n-    bc_label = (struct bc_label *) xmalloc (sizeof (struct bc_label));\n-\n-  r = gen_rtx (CODE_LABEL, VOIDmode, label, bc_label);\n-  bc_label->offset = offset;\n-\n-  return r;\n-}\n-\n-\n-/* Print bytecode rtx */\n-\n-void\n-bc_print_rtl (fp, r)\n-     FILE *fp;\n-     rtx r;\n-{\n-#if 0 /* This needs to get fixed to really work again.  */\n-  /* BC_WRITE_RTL has a definition\n-     that doesn't even make sense for this use.  */\n-  BC_WRITE_RTL (r, fp);\n-#endif\n-}\n-\n-\n-/* Emit a bytecode, keeping a running tally of the stack depth.  */\n-\n-void\n-bc_emit_bytecode (bytecode)\n-     enum bytecode_opcode bytecode;\n-{\n-  char byte;\n-  static int prev_lineno = -1;\n-\n-  byte = (char) bytecode;\n-\n-#ifdef BCDEBUG_PRINT_CODE\n-  if (lineno != prev_lineno)\n-    {\n-      fprintf (stderr, \"<line %d>\\n\", lineno);\n-      prev_lineno = lineno;\n-    }\n-\n-  fputs (opcode_name[(unsigned int) bytecode], stderr);\n-#endif\n-\n-  /* Due to errors we are often requested to output bytecodes that\n-     will cause an interpreter stack undeflow when executed.  Instead of\n-     dumping core on such occasions, we omit the bytecode.  Erroneous code\n-     should not be executed, regardless.  This makes life much easier, since\n-     we don't have to deceive ourselves about the known stack depth.  */\n-\n-  bc_emit_bytecode_const (&byte, 1);\n-\n-  if ((stack_depth -= arityvec[(int) bytecode].ninputs) >= 0)\n-    {\n-      if ((stack_depth += arityvec[(int) bytecode].noutputs) > max_stack_depth)\n-\tmax_stack_depth = stack_depth;\n-    }\n-\n-#ifdef VALIDATE_STACK_FOR_BC\n-  VALIDATE_STACK_FOR_BC ();\n-#endif\n-}\n-\n-\n-#ifdef BCDEBUG_PRINT_CODE\n-#define PRLIT(TYPE, PTR)  fprintf (stderr, \" [%x]\", *(TYPE *) PTR)\n-#else\n-#define PRLIT(X,Y)\n-#endif\n-\n-/* Emit a complete bytecode instruction, expecting the correct number\n-   of literal values in the call.  First argument is the instruction, the\n-   remaining arguments are literals of size HOST_WIDE_INT or smaller.  */\n-\n-void\n-bc_emit_instruction VPROTO((enum bytecode_opcode opcode, ...))\n-{\n-#ifndef __STDC__\n-  enum bytecode_opcode opcode;\n-#endif\n-  va_list arguments;\n-  int nliteral, instruction;\n-\n-  VA_START (arguments, opcode);\n-\n-#ifndef __STDC__\n-  opcode = va_arg (arguments, enum bytecode_opcode);\n-#endif\n-\n-  /* Emit instruction bytecode */\n-  bc_emit_bytecode (opcode);\n-  instruction = (int) opcode;\n-\n-  /* Loop literals and emit as bytecode constants */\n-  for (nliteral = 0; nliteral < arityvec[instruction].nliterals; nliteral++)\n-    {\n-      switch (arityvec[instruction].literals[nliteral])\n-\t{\n-/* This conditional is a kludge, but it's necessary\n-   because TYPE might be long long.  */\n-#ifdef __GNUC__\n-\t  /* Expand definitions into case statements */\n-#define DEFTYPECODE(CODE, NAME, MODE, TYPE)\t\t\t\t\\\n-\tcase CODE:\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    TYPE temp = va_arg (arguments, TYPE); \t\t\t\\\n-\t    bc_emit_bytecode_const ((void *) &temp, sizeof temp); \t\\\n-\t    PRLIT (TYPE, &temp); }\t\t\t\t\t\\\n-\t  break;\n-\n-#include \"bc-typecd.def\"\n-\n-#undef DEFTYPECODE\n-#endif /* __GNUC__ */\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-\n-  va_end (arguments);\n-\n-#ifdef BCDEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-}\n-\f\n-/* Emit the machine-code interface trampoline at the beginning of a byte\n-   coded function.  The argument is a label name of the interpreter\n-   bytecode callinfo structure; the return value is a label name for\n-   the beginning of the actual bytecode.  */\n-\n-char *\n-bc_emit_trampoline (callinfo)\n-     char *callinfo;\n-{\n-  char mylab[20];\n-  static int n;\n-\n-  sprintf (mylab, \"*LB%d\", n++);\n-  \n-  BC_EMIT_TRAMPOLINE (trampoline, callinfo);\n-\n-  seg_defsym (bytecode, mylab);\n-  return sym_lookup (mylab)->name;\n-}"}, {"sha": "c00da5b35393fa20939d7f6ff0626f8d3c0344d4", "filename": "gcc/bc-emit.h", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-emit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-emit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.h?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,133 +0,0 @@\n-/* bc-emit.h - declare entry points for producing object files of bytecodes. */\n-\n-/* Internal format of symbol table for the object file. */\n-struct bc_sym\n-{\n-  /* Private copy separately malloc'd. */\n-  char *name;\n-\n-  /* Symbol has a defined value. */\n-  unsigned int defined:1;\n-\n-  /* Symbol has been globalized. */\n-  unsigned int global:1;\n-\n-  /* Symbol is common. */\n-  unsigned int common:1;\n-\n-  /* Value if defined. */\n-  unsigned long int val;\n-\n-  /* Used in internal symbol table structure. */\n-  struct bc_sym *next;\n-};\n-\n-\n-/* List of symbols defined in a particular segment. */\n-struct bc_segsym\n-{\n-  struct bc_sym *sym;\n-  struct bc_segsym *next;\n-};\n-\n-\n-/* List of relocations needed in a particular segment. */\n-struct bc_segreloc\n-{\n-  /* Offset of datum to be relocated. */\n-  unsigned int offset;\n-\n-  /* Symbol to be relocated by. */\n-  struct bc_sym *sym;\n-\n-  struct bc_segreloc *next;\n-};\n-\n-\n-/* Segment of an object file. */\n-struct bc_seg\n-{\n-  /* Size allocated to contents. */\n-  unsigned int alloc;\n-\n-  /* Pointer to base of contents. */\n-  char *data;\n-\n-  /* Actual size of contents. */\n-  unsigned int size;\n-\n-  /* List of symbols defined in this segment. */\n-  struct bc_segsym *syms;\n-\n-  /* List of relocations for this segment. */\n-  struct bc_segreloc *relocs;\n-};\n-\n-\n-/* Anonymous bytecode label within a single function. */\n-struct bc_label\n-{\n-  /* Offset of label from start of segment. */\n-  unsigned int offset;\n-\n-  /* True when offset is valid. */\n-  unsigned int defined:1;\n-\n-  /* Unique bytecode ID, used to determine innermost\n-     block containment */\n-  int uid;\n-\n-  /* Next node in list */\n-  struct bc_label *next;\n-};\n-\n-\n-/* Reference to a bc_label; a list of all such references is kept for\n-   the function, then when it is finished they are backpatched to\n-   contain the correct values. */\n-\n-struct bc_labelref\n-{\n-  /* Label referenced. */\n-  struct bc_label *label;\n-\n-  /* Code offset of reference. */\n-  unsigned int offset;\n-\n-  /* Next labelref in list */\n-  struct bc_labelref *next;\n-};\n-\n-\f\n-\n-extern void bc_initialize();\n-extern int bc_begin_function();\n-extern char *bc_emit_trampoline();\n-extern void bc_emit_bytecode();\n-extern void bc_emit_bytecode_const();\n-extern struct bc_label *bc_get_bytecode_label();\n-extern int bc_emit_bytecode_labeldef();\n-extern void bc_emit_bytecode_labelref();\n-extern void bc_emit_code_labelref();\n-extern char *bc_end_function();\n-extern void bc_align_const();\n-extern void bc_emit_const();\n-extern void bc_emit_const_skip();\n-extern int bc_emit_const_labeldef();\n-extern void bc_emit_const_labelref();\n-extern void bc_align_data();\n-extern void bc_emit_data();\n-extern void bc_emit_data_skip();\n-extern int bc_emit_data_labeldef();\n-extern void bc_emit_data_labelref();\n-extern int bc_define_pointer ();\n-extern int bc_emit_common();\n-extern void bc_globalize_label();\n-extern void bc_text();\n-extern void bc_data();\n-extern void bc_align();\n-extern void bc_emit();\n-extern void bc_emit_skip();\n-extern int bc_emit_labeldef();\n-extern void bc_emit_labelref();\n-extern void bc_write_file();"}, {"sha": "dd134d5f0b32b468136cfd7db16f33b4896b05d2", "filename": "gcc/bc-optab.c", "status": "removed", "additions": 0, "deletions": 810, "changes": 810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-optab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-optab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-optab.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,810 +0,0 @@\n-/* Bytecode conversion definitions for GNU C-compiler.\n-   Copyright (C) 1993, 1994, 1997 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"config.h\"\n-#include <stdio.h>\n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"machmode.h\"\n-#include \"obstack.h\"\n-#include \"bytecode.h\"\n-#include \"bc-typecd.h\"\n-#include \"bc-opcode.h\"\n-#include \"bc-optab.h\"\n-\n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-\n-#ifdef NEED_DECLARATION_FREE\n-extern void free PROTO((void *));\n-#endif\n-\n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n-\n-extern char *xmalloc ();\n-\n-/* Table relating interpreter typecodes to machine modes.  */\n-#define GET_TYPECODE_MODE(CODE) (typecode_mode[((int) CODE)])\n-enum machine_mode typecode_mode[] = {\n-#define DEFTYPECODE(CODE, NAME, MODE, TYPE) MODE,\n-#include \"bc-typecd.def\"\n-#undef DEFTYPECODE\n-};\n-\n-/* Machine mode to type code map */\n-static enum typecode signed_mode_to_code_map[MAX_MACHINE_MODE+1];\n-static enum typecode unsigned_mode_to_code_map[MAX_MACHINE_MODE+1];\n-\n-#define GET_TYPECODE_SIZE(CODE) GET_MODE_SIZE (GET_TYPECODE_MODE (CODE))\n-\n-#define BIG_ARBITRARY_NUMBER 100000\n-\n-/* Table of recipes for conversions among scalar types, to be filled\n-   in as needed at run time.  */\n-static struct conversion_recipe\n-{\n-  unsigned char *opcodes;\t/* Bytecodes to emit in order.  */\n-  int nopcodes;\t\t\t/* Count of bytecodes.  */\n-  int cost;\t\t\t/* A rather arbitrary cost function.  */\n-} conversion_recipe[NUM_TYPECODES][NUM_TYPECODES];\n-\n-/* Binary operator tables.  */\n-struct binary_operator optab_plus_expr[] = {\n-  { addSI, SIcode, SIcode, SIcode },\n-  { addDI, DIcode, DIcode, DIcode },\n-  { addSF, SFcode, SFcode, SFcode },\n-  { addDF, DFcode, DFcode, DFcode },\n-  { addXF, XFcode, XFcode, XFcode },\n-  { addPSI, Pcode, Pcode, SIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_minus_expr[] = {\n-  { subSI, SIcode, SIcode, SIcode },\n-  { subDI, DIcode, DIcode, DIcode },\n-  { subSF, SFcode, SFcode, SFcode },\n-  { subDF, DFcode, DFcode, DFcode },\n-  { subXF, XFcode, XFcode, XFcode },\n-  { subPP, SIcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-/* The ordering of the tables for multiplicative operators\n-   is such that unsigned operations will be preferred to signed\n-   operations when one argument is unsigned.  */\n-\n-struct binary_operator optab_mult_expr[] = {\n-  { mulSU, SUcode, SUcode, SUcode },\n-  { mulDU, DUcode, DUcode, DUcode },\n-  { mulSI, SIcode, SIcode, SIcode },\n-  { mulDI, DIcode, DIcode, DIcode },\n-  { mulSF, SFcode, SFcode, SFcode },\n-  { mulDF, DFcode, DFcode, DFcode },\n-  { mulXF, XFcode, XFcode, XFcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_trunc_div_expr[] = {\n-  { divSU, SUcode, SUcode, SUcode },\n-  { divDU, DUcode, DUcode, DUcode },\n-  { divSI, SIcode, SIcode, SIcode },\n-  { divDI, DIcode, DIcode, DIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_trunc_mod_expr[] = {\n-  { modSU, SUcode, SUcode, SUcode },\n-  { modDU, DUcode, DUcode, DUcode },\n-  { modSI, SIcode, SIcode, SIcode },\n-  { modDI, DIcode, DIcode, DIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_rdiv_expr[] = {\n-  { divSF, SFcode, SFcode, SFcode },\n-  { divDF, DFcode, DFcode, DFcode },\n-  { divXF, XFcode, XFcode, XFcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_bit_and_expr[] = {\n-  { andSI, SIcode, SIcode, SIcode },\n-  { andDI, DIcode, DIcode, DIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_bit_ior_expr[] = {\n-  { iorSI, SIcode, SIcode, SIcode },\n-  { iorDI, DIcode, DIcode, DIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_bit_xor_expr[] = {\n-  { xorSI, SIcode, SIcode, SIcode },\n-  { xorDI, DIcode, DIcode, DIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_lshift_expr[] = {\n-  { lshiftSI, SIcode, SIcode, SIcode },\n-  { lshiftSU, SUcode, SUcode, SIcode },\n-  { lshiftDI, DIcode, DIcode, SIcode },\n-  { lshiftDU, DUcode, DUcode, SIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_rshift_expr[] = {\n-  { rshiftSI, SIcode, SIcode, SIcode },\n-  { rshiftSU, SUcode, SUcode, SIcode },\n-  { rshiftDI, DIcode, DIcode, SIcode },\n-  { rshiftDU, DUcode, DUcode, SIcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_truth_and_expr[] = {\n-  { andSI, SIcode, Tcode, Tcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_truth_or_expr[] = {\n-  { iorSI, SIcode, Tcode, Tcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_lt_expr[] = {\n-  { ltSI, Tcode, SIcode, SIcode },\n-  { ltSU, Tcode, SUcode, SUcode },\n-  { ltDI, Tcode, DIcode, DIcode },\n-  { ltDU, Tcode, DUcode, DUcode },\n-  { ltSF, Tcode, SFcode, SFcode },\n-  { ltDF, Tcode, DFcode, DFcode },\n-  { ltXF, Tcode, XFcode, XFcode },\n-  { ltP, Tcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_le_expr[] = {\n-  { leSI, Tcode, SIcode, SIcode },\n-  { leSU, Tcode, SUcode, SUcode },\n-  { leDI, Tcode, DIcode, DIcode },\n-  { leDU, Tcode, DUcode, DUcode },\n-  { leSF, Tcode, SFcode, SFcode },\n-  { leDF, Tcode, DFcode, DFcode },\n-  { leXF, Tcode, XFcode, XFcode },\n-  { leP, Tcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_ge_expr[] = {\n-  { geSI, Tcode, SIcode, SIcode },\n-  { geSU, Tcode, SUcode, SUcode },\n-  { geDI, Tcode, DIcode, DIcode },\n-  { geDU, Tcode, DUcode, DUcode },\n-  { geSF, Tcode, SFcode, SFcode },\n-  { geDF, Tcode, DFcode, DFcode },\n-  { geXF, Tcode, XFcode, XFcode },\n-  { geP, Tcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_gt_expr[] = {\n-  { gtSI, Tcode, SIcode, SIcode },\n-  { gtSU, Tcode, SUcode, SUcode },\n-  { gtDI, Tcode, DIcode, DIcode },\n-  { gtDU, Tcode, DUcode, DUcode },\n-  { gtSF, Tcode, SFcode, SFcode },\n-  { gtDF, Tcode, DFcode, DFcode },\n-  { gtXF, Tcode, XFcode, XFcode },\n-  { gtP, Tcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_eq_expr[] = {\n-  { eqSI, Tcode, SIcode, SIcode },\n-  { eqDI, Tcode, DIcode, DIcode },\n-  { eqSF, Tcode, SFcode, SFcode },\n-  { eqDF, Tcode, DFcode, DFcode },\n-  { eqXF, Tcode, XFcode, XFcode },\n-  { eqP, Tcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-struct binary_operator optab_ne_expr[] = {\n-  { neSI, Tcode, SIcode, SIcode },\n-  { neDI, Tcode, DIcode, DIcode },\n-  { neSF, Tcode, SFcode, SFcode },\n-  { neDF, Tcode, DFcode, DFcode },\n-  { neXF, Tcode, XFcode, XFcode },\n-  { neP, Tcode, Pcode, Pcode },\n-  { -1, -1, -1, -1 },\n-};\n-\n-/* Unary operator tables.  */\n-struct unary_operator optab_negate_expr[] = {\n-  { negSI, SIcode, SIcode },\n-  { negDI, DIcode, DIcode },\n-  { negSF, SFcode, SFcode },\n-  { negDF, DFcode, DFcode },\n-  { negXF, XFcode, XFcode },\n-  { -1, -1, -1 },\n-};\n-\n-struct unary_operator optab_bit_not_expr[] = {\n-  { notSI, SIcode, SIcode },\n-  { notDI, DIcode, DIcode },\n-  { -1, -1, -1 },\n-};\n-\n-struct unary_operator optab_truth_not_expr[] = {\n-  { notT, SIcode, SIcode },\n-  { -1, -1, -1 },\n-};\n-\n-/* Increment operator tables.  */\n-struct increment_operator optab_predecrement_expr[] = {\n-  { predecQI, QIcode },\n-  { predecQI, QUcode },\n-  { predecHI, HIcode },\n-  { predecHI, HUcode },\n-  { predecSI, SIcode },\n-  { predecSI, SUcode },\n-  { predecDI, DIcode },\n-  { predecDI, DUcode },\n-  { predecP, Pcode },\n-  { predecSF, SFcode },\n-  { predecDF, DFcode },\n-  { predecXF, XFcode },\n-  { -1, -1 },\n-};\n-\n-struct increment_operator optab_preincrement_expr[] = {\n-  { preincQI, QIcode },\n-  { preincQI, QUcode },\n-  { preincHI, HIcode },\n-  { preincHI, HUcode },\n-  { preincSI, SIcode },\n-  { preincSI, SUcode },\n-  { preincDI, DIcode },\n-  { preincDI, DUcode },\n-  { preincP, Pcode },\n-  { preincSF, SFcode },\n-  { preincDF, DFcode },\n-  { preincXF, XFcode },\n-  { -1, -1 },\n-};\n-\n-struct increment_operator optab_postdecrement_expr[] = {\n-  { postdecQI, QIcode },\n-  { postdecQI, QUcode },\n-  { postdecHI, HIcode },\n-  { postdecHI, HUcode },\n-  { postdecSI, SIcode },\n-  { postdecSI, SUcode },\n-  { postdecDI, DIcode },\n-  { postdecDI, DUcode },\n-  { postdecP, Pcode },\n-  { postdecSF, SFcode },\n-  { postdecDF, DFcode },\n-  { postdecXF, XFcode },\n-  { -1, -1 },\n-};\n-\n-struct increment_operator optab_postincrement_expr[] = {\n-  { postincQI, QIcode },\n-  { postincQI, QUcode },\n-  { postincHI, HIcode },\n-  { postincHI, HUcode },\n-  { postincSI, SIcode },\n-  { postincSI, SUcode },\n-  { postincDI, DIcode },\n-  { postincDI, DUcode },\n-  { postincP, Pcode },\n-  { postincSF, SFcode },\n-  { postincDF, DFcode },\n-  { postincXF, XFcode },\n-  { -1, -1 },\n-};\n-\n-/* Table of conversions supported by the interpreter.  */\n-static struct conversion_info\n-{\n-  enum bytecode_opcode opcode;\t/*  here indicates the conversion needs no opcode.  */\n-  enum typecode from;\n-  enum typecode to;\n-  int cost;\t\t\t/* 1 for no-op conversions, 2 for widening conversions,\n-\t\t\t\t   4 for int/float conversions, 8 for narrowing conversions.  */\n-} conversion_info[] = {\n-  { -1, QIcode, QUcode, 1 },\n-  { -1, HIcode, HUcode, 1 },\n-  { -1, SIcode, SUcode, 1 },\n-  { -1, DIcode, DUcode, 1 },\n-  { -1, QUcode, QIcode, 1 },\n-  { -1, HUcode, HIcode, 1 },\n-  { -1, SUcode, SIcode, 1 },\n-  { -1, DUcode, DIcode, 1 },\n-  { -1, Tcode, SIcode, 1 },\n-  { convertQIHI, QIcode, HIcode, 2 },\n-  { convertQUHU, QUcode, HUcode, 2 },\n-  { convertQUSU, QUcode, SUcode, 2 },\n-  { convertHISI, HIcode, SIcode, 2 },\n-  { convertHUSU, HUcode, SUcode, 2 },\n-  { convertSIDI, SIcode, DIcode, 2 },\n-  { convertSUDU, SUcode, DUcode, 2 },\n-  { convertSFDF, SFcode, DFcode, 2 },\n-  { convertDFXF, DFcode, XFcode, 2 },\n-  { convertHIQI, HIcode, QIcode, 8 },\n-  { convertSIQI, SIcode, QIcode, 8 },\n-  { convertSIHI, SIcode, HIcode, 8 },\n-  { convertSUQU, SUcode, QUcode, 8 },\n-  { convertDISI, DIcode, SIcode, 8 },\n-  { convertDFSF, DFcode, SFcode, 8 },\n-  { convertXFDF, XFcode, DFcode, 8 },\n-  { convertPSI, Pcode, SIcode, 2 },\n-  { convertSIP, SIcode, Pcode, 2 },\n-  { convertSIT, SIcode, Tcode, 2 },\n-  { convertDIT, DIcode, Tcode, 2 },\n-  { convertSFT, SFcode, Tcode, 2 },\n-  { convertDFT, DFcode, Tcode, 2 },\n-  { convertXFT, XFcode, Tcode, 2 },\n-  { convertQISI, QIcode, SIcode, 2 },\n-  { convertPT, Pcode, Tcode, 2 },\n-  { convertSISF, SIcode, SFcode, 4 },\n-  { convertSIDF, SIcode, DFcode, 4 },\n-  { convertSIXF, SIcode, XFcode, 4 },\n-  { convertSUSF, SUcode, SFcode, 4 },\n-  { convertSUDF, SUcode, DFcode, 4 },\n-  { convertSUXF, SUcode, XFcode, 4 },\n-  { convertDISF, DIcode, SFcode, 4 },\n-  { convertDIDF, DIcode, DFcode, 4 },\n-  { convertDIXF, DIcode, XFcode, 4 },\n-  { convertDUSF, DUcode, SFcode, 4 },\n-  { convertDUDF, DUcode, DFcode, 4 },\n-  { convertDUXF, DUcode, XFcode, 4 },\n-  { convertSFSI, SFcode, SIcode, 4 },\n-  { convertDFSI, DFcode, SIcode, 4 },\n-  { convertXFSI, XFcode, SIcode, 4 },\n-  { convertSFSU, SFcode, SUcode, 4 },\n-  { convertDFSU, DFcode, SUcode, 4 },\n-  { convertXFSU, XFcode, SUcode, 4 },\n-  { convertSFDI, SFcode, DIcode, 4 },\n-  { convertDFDI, DFcode, DIcode, 4 },\n-  { convertXFDI, XFcode, DIcode, 4 },\n-  { convertSFDU, SFcode, DUcode, 4 },\n-  { convertDFDU, DFcode, DUcode, 4 },\n-  { convertXFDU, XFcode, DUcode, 4 },\n-  { convertSIQI, SIcode, QIcode, 8 },\n-};\n-\n-#define NUM_CONVERSIONS (sizeof conversion_info / sizeof (struct conversion_info))\n-\n-/* List form of a conversion recipe.  */\n-struct conversion_list\n-{\n-  enum bytecode_opcode opcode;\n-  enum typecode to;\n-  int cost;\n-  struct conversion_list *prev;\n-};\n-\n-/* Determine if it is \"reasonable\" to add a given conversion to\n-   a given list of conversions.  The following criteria define\n-   \"reasonable\" conversion lists:\n-   * No typecode appears more than once in the sequence (no loops).\n-   * At most one conversion from integer to float or vice versa is present.\n-   * Either sign extensions or zero extensions may be present, but not both.\n-   * No widening conversions occur after a signed/unsigned conversion.\n-   * The sequence of sizes must be strict nonincreasing or nondecreasing.  */\n-\n-static int\n-conversion_reasonable_p (conversion, list)\n-     struct conversion_info *conversion;\n-     struct conversion_list *list;\n-{\n-  struct conversion_list *curr;\n-  int curr_size, prev_size;\n-  int has_int_float, has_float_int;\n-  int has_sign_extend, has_zero_extend;\n-  int has_signed_unsigned, has_unsigned_signed;\n-\n-  has_int_float = 0;\n-  has_float_int = 0;\n-  has_sign_extend = 0;\n-  has_zero_extend = 0;\n-  has_signed_unsigned = 0;\n-  has_unsigned_signed = 0;\n-\n-  /* Make sure the destination typecode doesn't already appear in\n-     the list.  */\n-  for (curr = list; curr; curr = curr->prev)\n-    if (conversion->to == curr->to)\n-      return 0;\n-\n-  /* Check for certain kinds of conversions.  */\n-  if (TYPECODE_INTEGER_P (conversion->from)\n-      && TYPECODE_FLOAT_P (conversion->to))\n-    has_int_float = 1;\n-  if (TYPECODE_FLOAT_P (conversion->from)\n-      && TYPECODE_INTEGER_P (conversion->to))\n-    has_float_int = 1;\n-  if (TYPECODE_SIGNED_P (conversion->from)\n-      && TYPECODE_SIGNED_P (conversion->to)\n-      && GET_TYPECODE_SIZE (conversion->from)\n-      < GET_TYPECODE_SIZE (conversion->to))\n-    has_sign_extend = 1;\n-  if (TYPECODE_UNSIGNED_P (conversion->from)\n-      && TYPECODE_UNSIGNED_P (conversion->to)\n-      && GET_TYPECODE_SIZE (conversion->from)\n-      < GET_TYPECODE_SIZE (conversion->to))\n-    has_zero_extend = 1;\n-\n-  for (curr = list; curr && curr->prev; curr = curr->prev)\n-    {\n-      if (TYPECODE_INTEGER_P (curr->prev->to)\n-\t  && TYPECODE_FLOAT_P (curr->to))\n-\thas_int_float = 1;\n-      if (TYPECODE_FLOAT_P (curr->prev->to)\n-\t  && TYPECODE_INTEGER_P (curr->to))\n-\thas_float_int = 1;\n-      if (TYPECODE_SIGNED_P (curr->prev->to)\n-\t  && TYPECODE_SIGNED_P (curr->to)\n-\t  && GET_TYPECODE_SIZE (curr->prev->to)\n-\t  < GET_TYPECODE_SIZE (curr->to))\n-\thas_sign_extend = 1;\n-      if (TYPECODE_UNSIGNED_P (curr->prev->to)\n-\t  && TYPECODE_UNSIGNED_P (curr->to)\n-\t  && GET_TYPECODE_SIZE (curr->prev->to)\n-\t  < GET_TYPECODE_SIZE (curr->to))\n-\thas_zero_extend = 1;\n-      if (TYPECODE_SIGNED_P (curr->prev->to)\n-\t  && TYPECODE_UNSIGNED_P (curr->to))\n-\thas_signed_unsigned = 1;\n-      if (TYPECODE_UNSIGNED_P (curr->prev->to)\n-\t  && TYPECODE_SIGNED_P (curr->to))\n-\thas_unsigned_signed = 1;\n-    }\n-\n-  if (TYPECODE_INTEGER_P (conversion->from)\n-      && TYPECODE_INTEGER_P (conversion->to)\n-      && GET_TYPECODE_SIZE (conversion->to)\n-      > GET_TYPECODE_SIZE (conversion->from)\n-      && (has_signed_unsigned || has_unsigned_signed))\n-    return 0;\n-\n-  if (has_float_int && has_int_float || has_sign_extend && has_zero_extend)\n-    return 0;\n-\n-  /* Make sure the sequence of destination typecode sizes is\n-     strictly nondecreasing or strictly nonincreasing.  */\n-  prev_size = GET_TYPECODE_SIZE (conversion->to);\n-  for (curr = list; curr; curr = curr->prev)\n-    {\n-      curr_size = GET_TYPECODE_SIZE (curr->to);\n-      if (curr_size != prev_size)\n-\tbreak;\n-    }\n-  if (!curr)\n-    return 1;\n-\n-  if (curr_size < prev_size)\n-    for (prev_size = curr_size; curr; curr = curr->prev)\n-      {\n-\tcurr_size = GET_TYPECODE_SIZE (curr->to);\n-\tif (curr_size > prev_size)\n-\t  return 0;\n-\tprev_size = curr_size;\n-      }\n-  else\n-    for (prev_size = curr_size; curr; curr = curr->prev)\n-      {\n-\tcurr_size = GET_TYPECODE_SIZE (curr->to);\n-\tif (curr_size < prev_size)\n-\t  return 0;\n-\tprev_size = curr_size;\n-      }\n-  return 1;\n-}\n-\n-\n-/* Exhaustively search all reasonable conversions to find one to\n-   convert the given types.  */\n-\n-static struct conversion_recipe\n-deduce_conversion (from, to)\n-     enum typecode from, to;\n-{\n-  struct rl\n-    {\n-      struct conversion_list *list;\n-      struct rl *next;\n-    } *prev, curr, *good, *temp;\n-  struct conversion_list *conv, *best;\n-  int i, cost, bestcost;\n-  struct conversion_recipe result;\n-  struct obstack recipe_obstack;\n-\n-\n-  obstack_init (&recipe_obstack);\n-  curr.next = (struct rl *) obstack_alloc (&recipe_obstack, sizeof (struct rl));\n-  curr.next->list\n-    = (struct conversion_list *) obstack_alloc (&recipe_obstack,\n-\t\t\t\t\t\tsizeof (struct conversion_list));\n-  curr.next->list->opcode = -1;\n-  curr.next->list->to = from;\n-  curr.next->list->cost = 0;\n-  curr.next->list->prev = 0;\n-  curr.next->next = 0;\n-  good = 0;\n-\n-  while (curr.next)\n-    {\n-      /* Remove successful conversions from further consideration.  */\n-      for (prev = &curr; prev; prev = prev->next)\n-\tif (prev->next && prev->next->list->to == to)\n-\t  {\n-\t    temp = prev->next->next;\n-\t    prev->next->next = good;\n-\t    good = prev->next;\n-\t    prev->next = temp;\n-\t  }\n-\n-      /* Go through each of the pending conversion chains, trying\n-\t all possible candidate conversions on them.  */\n-      for (prev = curr.next, curr.next = 0; prev; prev = prev->next)\n-\tfor (i = 0; i < NUM_CONVERSIONS; ++i)\n-\t  if (conversion_info[i].from == prev->list->to\n-\t      && conversion_reasonable_p (&conversion_info[i], prev->list))\n-\t    {\n-\t      temp = (struct rl *) obstack_alloc (&recipe_obstack,\n-\t\t\t\t\t\t  sizeof (struct rl));\n-\t      temp->list = (struct conversion_list *)\n-\t\tobstack_alloc (&recipe_obstack,\n-\t\t\t       sizeof (struct conversion_list));\n-\t      temp->list->opcode = conversion_info[i].opcode;\n-\t      temp->list->to = conversion_info[i].to;\n-\t      temp->list->cost = conversion_info[i].cost;\n-\t      temp->list->prev = prev->list;\n-\t      temp->next = curr.next;\n-\t      curr.next = temp;\n-\t    }\n-    }\n-\n-  bestcost = BIG_ARBITRARY_NUMBER;\n-  best = 0;\n-  for (temp = good; temp; temp = temp->next)\n-    {\n-      for (conv = temp->list, cost = 0; conv; conv = conv->prev)\n-\tcost += conv->cost;\n-      if (cost < bestcost)\n-\t{\n-\t  bestcost = cost;\n-\t  best = temp->list;\n-\t}\n-    }\n-\n-  if (!best)\n-    abort ();\n-\n-  for (i = 0, conv = best; conv; conv = conv->prev)\n-    if (conv->opcode != -1)\n-      ++i;\n-\n-  result.opcodes = (unsigned char *) xmalloc (i);\n-  result.nopcodes = i;\n-  for (conv = best; conv; conv = conv->prev)\n-    if (conv->opcode != -1)\n-      result.opcodes[--i] = conv->opcode;\n-  result.cost = bestcost;\n-  obstack_free (&recipe_obstack, 0);\n-  return result;\n-}\n-\n-#define DEDUCE_CONVERSION(FROM, TO)\t\t\t\t\\\n-  (conversion_recipe[(int) FROM][(int) TO].opcodes ? 0\t\t\\\n-   : (conversion_recipe[(int) FROM][(int) TO]\t\t\t\\\n-       = deduce_conversion (FROM, TO), 0))\n-\n-\n-/* Emit a conversion between the given scalar types.  */\n-\n-void\n-emit_typecode_conversion (from, to)\n-     enum typecode from, to;\n-{\n-  int i;\n-\n-  DEDUCE_CONVERSION (from, to);\n-  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)\n-    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);\n-}\n-\n-\n-/* Initialize mode_to_code_map[] */\n-\n-void\n-bc_init_mode_to_code_map ()\n-{\n-  int mode;\n-\n-  for (mode = 0; mode < MAX_MACHINE_MODE + 1; mode++)\n-    {\n-      signed_mode_to_code_map[mode]\n-\t= unsigned_mode_to_code_map[mode]\n-\t= LAST_AND_UNUSED_TYPECODE;\n-    }\n-\n-#define DEF_MODEMAP(SYM, CODE, UCODE, CONST, LOAD, STORE) \\\n-  { signed_mode_to_code_map[(int) SYM] = CODE; \\\n-    unsigned_mode_to_code_map[(int) SYM] = UCODE; }\n-#include \"modemap.def\"\n-#undef DEF_MODEMAP\n-\n-  /* Initialize opcode maps for const, load, and store */\n-  bc_init_mode_to_opcode_maps ();\n-}\n-\n-/* Given a machine mode return the preferred typecode.  */\n-\n-enum typecode\n-preferred_typecode (mode, unsignedp)\n-     enum machine_mode mode;\n-     int unsignedp;\n-{\n-  enum typecode code = (unsignedp\n-\t\t\t? unsigned_mode_to_code_map\n-\t\t\t: signed_mode_to_code_map) [MIN ((int) mode,\n-\t\t\t\t\t\t\t (int) MAX_MACHINE_MODE)];\n-\n-  if (code == LAST_AND_UNUSED_TYPECODE)\n-    abort ();\n-\n-  return code;\n-}\n-\n-\n-/* Expand a conversion between the given types.  */\n-\n-void\n-bc_expand_conversion (from, to)\n-     tree from, to;\n-{\n-  enum typecode fcode, tcode;\n-\n-  fcode = preferred_typecode (TYPE_MODE (from), TREE_UNSIGNED (from));\n-  tcode = preferred_typecode (TYPE_MODE (to), TREE_UNSIGNED (to));\n-\n-  emit_typecode_conversion (fcode, tcode);\n-}\n-\n-/* Expand a conversion of the given type to a truth value.  */\n-\n-void\n-bc_expand_truth_conversion (from)\n-     tree from;\n-{\n-  enum typecode fcode;\n-\n-  fcode = preferred_typecode (TYPE_MODE (from), TREE_UNSIGNED (from));\n-  emit_typecode_conversion (fcode, Tcode);\n-}\n-\n-/* Emit an appropriate binary operation.  */\n-\n-void\n-bc_expand_binary_operation (optab, resulttype, arg0, arg1)\n-     struct binary_operator optab[];\n-     tree resulttype, arg0, arg1;\n-{\n-  int i, besti, cost, bestcost;\n-  enum typecode resultcode, arg0code, arg1code;\n-  \n-  resultcode = preferred_typecode (TYPE_MODE (resulttype), TREE_UNSIGNED (resulttype));\n-  arg0code = preferred_typecode (TYPE_MODE (TREE_TYPE (arg0)), TREE_UNSIGNED (resulttype));\n-  arg1code = preferred_typecode (TYPE_MODE (TREE_TYPE (arg1)), TREE_UNSIGNED (resulttype));\n-\n-  besti = -1;\n-  bestcost = BIG_ARBITRARY_NUMBER;\n-\n-  for (i = 0; optab[i].opcode != -1; ++i)\n-    {\n-      cost = 0;\n-      DEDUCE_CONVERSION (arg0code, optab[i].arg0);\n-      cost += conversion_recipe[(int) arg0code][(int) optab[i].arg0].cost;\n-      DEDUCE_CONVERSION (arg1code, optab[i].arg1);\n-      cost += conversion_recipe[(int) arg1code][(int) optab[i].arg1].cost;\n-      if (cost < bestcost)\n-\t{\n-\t  besti = i;\n-\t  bestcost = cost;\n-\t}\n-    }\n-\n-  if (besti == -1)\n-    abort ();\n-\n-  expand_expr (arg1, 0, VOIDmode, 0);\n-  emit_typecode_conversion (arg1code, optab[besti].arg1);\n-  expand_expr (arg0, 0, VOIDmode, 0);\n-  emit_typecode_conversion (arg0code, optab[besti].arg0);\n-  bc_emit_instruction (optab[besti].opcode);\n-  emit_typecode_conversion (optab[besti].result, resultcode);\n-}\n-\n-/* Emit an appropriate unary operation.  */\n-\n-void\n-bc_expand_unary_operation (optab, resulttype, arg0)\n-     struct unary_operator optab[];\n-     tree resulttype, arg0;\n-{\n-  int i, besti, cost, bestcost;\n-  enum typecode resultcode, arg0code;\n-  \n-  resultcode = preferred_typecode (TYPE_MODE (resulttype), TREE_UNSIGNED (resulttype));\n-  arg0code = preferred_typecode (TYPE_MODE (TREE_TYPE (arg0)), TREE_UNSIGNED (TREE_TYPE (arg0)));\n-\n-  besti = -1;\n-  bestcost = BIG_ARBITRARY_NUMBER;\n-\n-  for (i = 0; optab[i].opcode != -1; ++i)\n-    {\n-      DEDUCE_CONVERSION (arg0code, optab[i].arg0);\n-      cost = conversion_recipe[(int) arg0code][(int) optab[i].arg0].cost;\n-      if (cost < bestcost)\n-\t{\n-\t  besti = i;\n-\t  bestcost = cost;\n-\t}\n-    }\n-\n-  if (besti == -1)\n-    abort ();\n-\n-  expand_expr (arg0, 0, VOIDmode, 0);\n-  emit_typecode_conversion (arg0code, optab[besti].arg0);\n-  bc_emit_instruction (optab[besti].opcode);\n-  emit_typecode_conversion (optab[besti].result, resultcode);\n-}\n-\n-\n-/* Emit an appropriate increment.  */\n-\n-void\n-bc_expand_increment (optab, type)\n-     struct increment_operator optab[];\n-     tree type;\n-{\n-  enum typecode code;\n-  int i;\n-\n-  code = preferred_typecode (TYPE_MODE (type), TREE_UNSIGNED (type));\n-  for (i = 0; (int) optab[i].opcode >= 0; ++i)\n-    if (code == optab[i].arg)\n-      {\n-\tbc_emit_instruction (optab[i].opcode);\n-\treturn;\n-      }\n-  abort ();\n-}"}, {"sha": "6ad0b8592f650383bf15e53e4dc6f3c2de456690", "filename": "gcc/bc-optab.h", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-optab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-optab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-optab.h?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,75 +0,0 @@\n-/* Bytecode token definitions for GNU C-compiler.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-extern void bc_expand_conversion ();\n-extern void bc_expand_truth_conversion ();\n-extern void bc_expand_binary_operation ();\n-extern void bc_expand_unary_operation ();\n-\n-struct binary_operator\n-{\n-  enum bytecode_opcode opcode;\n-  enum typecode result;\n-  enum typecode arg0;\n-  enum typecode arg1;\n-};\n-\n-extern struct binary_operator optab_plus_expr[];\n-extern struct binary_operator optab_minus_expr[];\n-extern struct binary_operator optab_mult_expr[];\n-extern struct binary_operator optab_trunc_div_expr[];\n-extern struct binary_operator optab_trunc_mod_expr[];\n-extern struct binary_operator optab_rdiv_expr[];\n-extern struct binary_operator optab_bit_and_expr[];\n-extern struct binary_operator optab_bit_ior_expr[];\n-extern struct binary_operator optab_bit_xor_expr[];\n-extern struct binary_operator optab_lshift_expr[];\n-extern struct binary_operator optab_rshift_expr[];\n-extern struct binary_operator optab_truth_and_expr[];\n-extern struct binary_operator optab_truth_or_expr[];\n-extern struct binary_operator optab_lt_expr[];\n-extern struct binary_operator optab_le_expr[];\n-extern struct binary_operator optab_ge_expr[];\n-extern struct binary_operator optab_gt_expr[];\n-extern struct binary_operator optab_eq_expr[];\n-extern struct binary_operator optab_ne_expr[];\n-\n-struct unary_operator\n-{\n-  enum bytecode_opcode opcode;\n-  enum typecode result;\n-  enum typecode arg0;\n-};\n-\n-extern struct unary_operator optab_negate_expr[];\n-extern struct unary_operator optab_bit_not_expr[];\n-extern struct unary_operator optab_truth_not_expr[];\n-\n-struct increment_operator\n-{\n-  enum bytecode_opcode opcode;\n-  enum typecode arg;\n-};\n-\n-extern struct increment_operator optab_predecrement_expr[];\n-extern struct increment_operator optab_preincrement_expr[];\n-extern struct increment_operator optab_postdecrement_expr[];\n-extern struct increment_operator optab_postincrement_expr[];"}, {"sha": "fd92cdd92822b17a8d76879ae311e7563c516b48", "filename": "gcc/bc-typecd.def", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-typecd.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-typecd.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-typecd.def?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,21 +0,0 @@\n-/* Typecodes used by the interpreter and their related\n-   machine modes and types.\n-\n-   The last argument is used for retrieving the given\n-   type from a varargs list. Due to a bug in varargs,\n-   the type has to be the generic machine type of\n-   larger. */\n-\n-DEFTYPECODE (QIcode, \"QI\", QImode, SItype)\n-DEFTYPECODE (QUcode, \"QU\", QImode, SUtype)\n-DEFTYPECODE (HIcode, \"HI\", HImode, SItype)\n-DEFTYPECODE (HUcode, \"HU\", HImode, SUtype)\n-DEFTYPECODE (SIcode, \"SI\", SImode, SItype)\n-DEFTYPECODE (SUcode, \"SU\", SImode, SUtype)\n-DEFTYPECODE (DIcode, \"DI\", DImode, DItype)\n-DEFTYPECODE (DUcode, \"DU\", DImode, DUtype)\n-DEFTYPECODE (SFcode, \"SF\", SFmode, SFtype)\n-DEFTYPECODE (DFcode, \"DF\", DFmode, DFtype)\n-DEFTYPECODE (XFcode, \"XF\", XFmode, XFtype)\n-DEFTYPECODE (Pcode, \"P\", PSImode, Ptype)\n-DEFTYPECODE (Tcode, \"T\", SImode, SItype)"}, {"sha": "2dcea0e08f5192e6cbb2ae60ed7431bf2d0c3e18", "filename": "gcc/bc-typecd.h", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-typecd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbc-typecd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-typecd.h?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,54 +0,0 @@\n-/* Typecode definitions for Bytecode Interpreter.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef TYPECODE_H\n-#define TYPECODE_H\n-\n-enum typecode\n-{\n-#define DEFTYPECODE(CODE, NAME, MACHMODE, TYPE) CODE,\n-#include \"bc-typecd.def\"\n-#undef DEFTYPECODE\n-\n-  LAST_AND_UNUSED_TYPECODE\n-};\n-\n-/* Determine if a given type is integer.  */\n-#define TYPECODE_INTEGER_P(TYPECODE) ((int) (TYPECODE) < (int) SFcode)\n-\n-/* Determine if a given type is unsigned.  */\n-#define TYPECODE_UNSIGNED_P(TYPECODE) \\\n-  (TYPECODE_INTEGER_P(TYPECODE) && (int) (TYPECODE) & 1)\n-\n-/* Determine if a given type is signed.  */\n-#define TYPECODE_SIGNED_P(TYPECODE) \\\n-  (TYPECODE_INTEGER_P(TYPECODE) && !((int) (TYPECODE) & 1))\n-\n-/* Determine if a given type is floating.  */\n-#define TYPECODE_FLOAT_P(TYPECODE) \\\n-  ((int) (TYPECODE) < (int) Pcode && !TYPECODE_INTEGER_P(TYPECODE))\n-\n-/* Determine if the given type is arithmetic. */\n-#define TYPECODE_ARITH_P(TYPECODE) \\\n-  (TYPECODE_INTEGER_P(TYPECODE) || TYPECODE_FLOAT_P(TYPECODE))\n-\n-#define NUM_TYPECODES ((int) LAST_AND_UNUSED_TYPECODE)\n-\n-#endif"}, {"sha": "ea1f3e1de0869eb9c9f9d944e0e27719d5cf5965", "filename": "gcc/bi-arity.c", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-arity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-arity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-arity.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,91 +0,0 @@\n-/* Bytecode Interpreter utility to generate arity table.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include <stdio.h>\n-#include \"hconfig.h\"\n-#include \"bi-defs.h\"\n-\n-int\n-length (n)\n-     struct node *n;\n-{\n-  int k;\n-\n-  for (k = 0; n; n = n->next)\n-    ++k;\n-  return k;\n-}\n-\n-int\n-main ()\n-{\n-  struct def *d;\n-  struct variation *v;\n-  struct node *n;\n-\n-  yyparse ();\n-  reverse ();\n-\n-  for (d = defs; d; d = d->next)\n-    for (v = d->variations; v; v = v->next)\n-      {\n-\tprintf (\"{ %d, %d, %d, {\", length (v->inputs),\n-\t       length (v->outputs), length (v->literals));\n-\tfor (n = v->literals; n; n = n->next)\n-\t  printf (\"(char) %scode, \", n->text);\n-\tif (v->literals == 0)\n-\t  printf (\"0\");\n-\tprintf (\"}},\\n\");\n-      }\n-\n-  fflush (stdout);\n-  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n-  /* NOTREACHED */\n-  return 0;\n-}\n-\n-/* Safely allocate NBYTES bytes of memory. Returns pointer to block of\n-   memory.  */\n-\n-char *\n-xmalloc (nbytes)\n-     int nbytes;\n-{\n-  char *tmp = (char *) malloc (nbytes);\n-  \n-  if (!tmp)\n-    {\n-      fprintf (stderr, \"can't allocate %d bytes (out of virtual memory)\\n\", nbytes);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n-  return tmp;\n-}\n-\n-/* More 'friendly' abort that prints the line and file.\n-   config.h can #define abort fancy_abort if you like that sort of thing.  */\n-\n-void\n-fancy_abort ()\n-{\n-  fprintf (stderr, \"Internal gcc abort.\\n\");\n-  exit (FATAL_EXIT_CODE);\n-}"}, {"sha": "868312a847dbc6bfb8c68dba5f5f004188d7dabe", "filename": "gcc/bi-defs.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-defs.h?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,48 +0,0 @@\n-/* Definitions for Bytecode Interpreter.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-struct node\n-{\n-  char *text;\n-  struct node *next;\n-};\n-\n-struct variation\n-{\n-  char *name;\n-  int code;\n-  struct node *inputs;\n-  struct node *outputs;\n-  struct node *literals;\n-  struct variation *next;\n-};\n-\n-struct def\n-{\n-  char *basename;\n-  char *template;\n-  struct variation *variations;\n-  struct def *next;\n-};\n-\n-extern struct def *defs;\n-extern int ndefs;\n-extern void reverse();"}, {"sha": "0ec0b1d56d3b05f68394051b584689500d2a6fc5", "filename": "gcc/bi-lexer.c", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-lexer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-lexer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-lexer.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,167 +0,0 @@\n-/* Lexer for scanner of bytecode definition file.\n-   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include <stdio.h>\n-#include \"hconfig.h\"\n-#include \"bi-parser.h\"\n-\n-\n-/* Safely allocate NBYTES bytes of memory.  Returns pointer to block of\n-   memory.  */\n-\n-static char *\n-xmalloc (nbytes)\n-     int nbytes;\n-{\n-  char *tmp = (char *) malloc (nbytes);\n-\n-  if (!tmp)\n-    {\n-      fprintf (stderr, \"can't allocate %d bytes (out of virtual memory)\\n\", nbytes);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n-  return tmp;\n-}\n-\n-\n-/* Safely reallocate BLOCK so its size becomes NBYTES.\n-   The block returned may be different from the one supplied.  */\n-\n-static char *\n-xrealloc (block, nbytes)\n-     char *block;\n-     int nbytes;\n-{\n-  char *tmp = (block\n-\t       ? (char *) realloc (block, nbytes)\n-\t       : (char *) malloc (nbytes));\n-\n-  if (!tmp)\n-    {\n-      fprintf (stderr, \"can't reallocate %d bytes (out of virtual memory)\\n\", nbytes);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n-  return tmp;\n-}\n-\n-\n-/* Scan for string token on standard input.  A string is, for our\n-   purposes here, a sequence of characters that starts with the regexp\n-   ``[^ #\\t\\n(),]'' and is then followed by the regexp ``[^#(),]*''. Any\n-   character is accepted if preceded by a backslash, \"\\\\\".  It is assumed\n-   that the first character has already been checked by the main loop.  */\n-\n-static char *\n-scan_string ()\n-{\n-  char *buffer = NULL;\n-  char *point = NULL;\n-  int buffer_size = 0;\n-  int c;\n-\n-  while ((c = getc (stdin)) != EOF\n-\t && c != '#' && c != '(' && c != ')' && c != ',')\n-    {\n-      /* Extend buffer, if necessary (minus two so there's room for the NUL\n-\t trailer as well as another character if this one is a backslash).  */\n-      if (!buffer_size || (point - buffer >= buffer_size-2))\n-\t{\n-\t  int previous_point_index = point - buffer;\n-\n-\t  buffer_size = (!buffer_size ? 32 : buffer_size * 2);\n-\t  if (!buffer)\n-\t    buffer = xmalloc (buffer_size);\n-\t  else\n-\t    buffer = xrealloc (buffer, buffer_size);\n-\t  \n-\t  point = buffer + previous_point_index;\n-\t}\n-      *point++ = c & 0xff;\n-\n-      if (c == '\\\\')\n-\t{\n-\t  c = getc (stdin);\n-\n-\t  /* Catch special case: backslash at end of file */\n-\t  if (c == EOF)\n-\t    break;\n-\n-\t  *point++ = c;\n-\t}\n-    }\n-  *point = 0;\n-\n-  if (c != EOF)\n-    ungetc (c, stdin);\n-\n-  return buffer;\n-}\n-\n-\n-int\n-yylex ()\n-{\n-  int c;\n-  char *token;\n-\n-\n-  /* First char determines what token we're looking at */\n-  for (;;)\n-    {\n-      c = getc (stdin);\n-\n-      switch (c)\n-\t{\n-\tcase EOF:\n-\t  return 0;\n-\t  \n-\tcase ' ':\n-\tcase '\\t':\n-\tcase '\\n':\n-\t  /* Ignore whitespace */\n-\t  continue;\n-\t  \n-\tcase '#':\n-\t  /* Comments advance to next line */\n-\t  while ((c = getc (stdin)) != '\\n' && c != EOF);\n-\t  continue;\n-\t  \n-\tdefault:\n-\t  if (c != '(' && c != ')' && c != '\\\\' && c != ',')\n-\t    {\n-\t      ungetc (c, stdin);\n-\t      yylval.string = scan_string ();\n-\n-\t      /* Check if string is \"define_operator\"; if so, return\n-\t\t a DEFOP token instead.  */\n-\t      if (!strcmp (yylval.string, \"define_operator\"))\n-\t\t{\n-\t\t  free (yylval.string);\n-\t\t  yylval.string = 0;\n-\t\t  return DEFOP;\n-\t\t}\n-\t      return STRING;\n-\t    }\n-\t  return c & 0xff;\n-\t}\n-    }\n-}"}, {"sha": "795bb6fb2758dc41b1fec4c4fcdc17c023b28613", "filename": "gcc/bi-opcode.c", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-opcode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-opcode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-opcode.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,89 +0,0 @@\n-/* Utility to generate opcode list from bytecode definition.\n-   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include <stdio.h>\n-#include \"hconfig.h\"\n-#include \"bi-defs.h\"\n-\n-int\n-main(argc, argv)\n-     int argc;\n-     char **argv;\n-{\n-  struct def *d;\n-  struct variation *v;\n-  int i;\n-\n-  yyparse();\n-  reverse();\n-\n-\n-  printf (\"/* This file is automatically generated from bytecode.def,\\n\");\n-  printf (\"do not make any changes here. Instead edit bytecode.def.  */\\n\\n\");\n-  printf (\"enum bytecode_opcode\\n{\");\n-\n-  i = 0;\n-  for (d = defs; d; d = d->next)\n-    for (v = d->variations; v; v = v->next)\n-      {\n-\tprintf (\"  %s%s,\\n\", d->basename, v->name);\n-\t++i;\n-      }\n-\n-  puts (\"  LAST_AND_UNUSED_OPCODE\\n};\");\n-\n-  if (i > 256)\n-    fprintf (stderr, \"%s: warning, number of opcodes is %d\\n\", *argv, i);\n-  else\n-    fprintf (stderr, \"(Number of opcodes is %d)\\n\", i);\n-\n-  fflush (stdout);\n-  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n-  /* NOTREACHED */\n-  return 0;\n-}\n-\n-/* Safely allocate NBYTES bytes of memory. Returns pointer to block of\n-   memory.  */\n-\n-char *\n-xmalloc (nbytes)\n-     int nbytes;\n-{\n-  char *tmp = (char *) malloc (nbytes);\n-  \n-  if (!tmp)\n-    {\n-      fprintf (stderr, \"can't allocate %d bytes (out of virtual memory)\\n\", nbytes);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n-  return tmp;\n-}\n-\n-/* More 'friendly' abort that prints the line and file.\n-   config.h can #define abort fancy_abort if you like that sort of thing.  */\n-\n-void\n-fancy_abort ()\n-{\n-  fprintf (stderr, \"Internal gcc abort.\\n\");\n-  exit (FATAL_EXIT_CODE);\n-}"}, {"sha": "2f41dd27dbcee6369276a2fadef5af7ee857cf00", "filename": "gcc/bi-opname.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-opname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-opname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-opname.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,70 +0,0 @@\n-/* Utility to generate opcode name list from bytecode definition file.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include <stdio.h>\n-#include \"hconfig.h\"\n-#include \"bi-defs.h\"\n-\n-int\n-main()\n-{\n-  struct def *d;\n-  struct variation *v;\n-\n-  yyparse();\n-  reverse();\n-\n-  for (d = defs; d; d = d->next)\n-    for (v = d->variations; v; v = v->next)\n-      printf(\"\\\"%s%s\\\",\\n\", d->basename, v->name);\n-\n-  fflush (stdout);\n-  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n-  /* NOTREACHED */\n-  return 0;\n-}\n-\n-/* Safely allocate NBYTES bytes of memory. Returns pointer to block of\n-   memory.  */\n-\n-char *\n-xmalloc (nbytes)\n-     int nbytes;\n-{\n-  char *tmp = (char *) malloc (nbytes);\n-  \n-  if (!tmp)\n-    {\n-      fprintf (stderr, \"can't allocate %d bytes (out of virtual memory)\\n\", nbytes);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n-  return tmp;\n-}\n-\n-/* More 'friendly' abort that prints the line and file.\n-   config.h can #define abort fancy_abort if you like that sort of thing.  */\n-\n-void\n-fancy_abort ()\n-{\n-  fprintf (stderr, \"Internal gcc abort.\\n\");\n-  exit (FATAL_EXIT_CODE);\n-}"}, {"sha": "9f6f2b02e3c41585f671932216d448b893dd1686", "filename": "gcc/bi-parser.c", "status": "removed", "additions": 0, "deletions": 980, "changes": 980, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-parser.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,980 +0,0 @@\n-\n-/*  A Bison parser, made from bi-parser.y with Bison version GNU Bison version 1.24\n-  */\n-\n-#define YYBISON 1  /* Identify Bison output.  */\n-\n-#define\tDEFOP\t258\n-#define\tSTRING\t259\n-\n-#line 22 \"bi-parser.y\"\n-\n-\n-#include <stdio.h>\n-#include \"hconfig.h\"\n-#include \"bi-defs.h\"\n-\n-extern char yytext[];\n-extern int yyleng;\n-\n-\n-/* Chain of all defs built by the parser. */\n-struct def *defs;\n-int ndefs;\n-\n-static struct node *makenode ();\n-static struct variation *makevar ();\n-static struct def *makedef ();\n-\n-void yyerror ();\n-\n-\n-#line 44 \"bi-parser.y\"\n-typedef union\n-{\n-  char *string;\n-  struct def *def;\n-  struct variation *variation;\n-  struct node *node;\n-} YYSTYPE;\n-\n-#ifndef YYLTYPE\n-typedef\n-  struct yyltype\n-    {\n-      int timestamp;\n-      int first_line;\n-      int first_column;\n-      int last_line;\n-      int last_column;\n-      char *text;\n-   }\n-  yyltype;\n-\n-#define YYLTYPE yyltype\n-#endif\n-\n-#include <stdio.h>\n-\n-#ifndef __cplusplus\n-#ifndef __STDC__\n-#define const\n-#endif\n-#endif\n-\n-\n-\n-#define\tYYFINAL\t\t39\n-#define\tYYFLAG\t\t-32768\n-#define\tYYNTBASE\t8\n-\n-#define YYTRANSLATE(x) ((unsigned)(x) <= 259 ? yytranslate[x] : 17)\n-\n-static const char yytranslate[] = {     0,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     5,\n-     7,     2,     2,     6,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     1,     2,     3,     4\n-};\n-\n-#if YYDEBUG != 0\n-static const short yyprhs[] = {     0,\n-     0,     2,     4,     7,    18,    20,    24,    28,    34,    42,\n-    52,    53,    55,    59,    60,    62,    66\n-};\n-\n-static const short yyrhs[] = {     9,\n-     0,    10,     0,     9,    10,     0,     3,     5,     4,     6,\n-    13,     6,     5,    11,     7,     7,     0,    12,     0,    11,\n-     6,    12,     0,     5,    13,     7,     0,     5,    13,     6,\n-    14,     7,     0,     5,    13,     6,    14,     6,    14,     7,\n-     0,     5,    13,     6,    14,     6,    14,     6,    14,     7,\n-     0,     0,     4,     0,     5,    15,     7,     0,     0,    16,\n-     0,    16,     6,    15,     0,     4,     0\n-};\n-\n-#endif\n-\n-#if YYDEBUG != 0\n-static const short yyrline[] = { 0,\n-    60,    65,    67,    71,    76,    78,    82,    85,    87,    89,\n-    93,    95,    98,   101,   105,   108,   112\n-};\n-\n-static const char * const yytname[] = {   \"$\",\"error\",\"$undefined.\",\"DEFOP\",\n-\"STRING\",\"'('\",\"','\",\"')'\",\"top\",\"defs\",\"def\",\"variations\",\"variation\",\"opt_string\",\n-\"list\",\"items\",\"item\",\"\"\n-};\n-#endif\n-\n-static const short yyr1[] = {     0,\n-     8,     9,     9,    10,    11,    11,    12,    12,    12,    12,\n-    13,    13,    14,    14,    15,    15,    16\n-};\n-\n-static const short yyr2[] = {     0,\n-     1,     1,     2,    10,     1,     3,     3,     5,     7,     9,\n-     0,     1,     3,     0,     1,     3,     1\n-};\n-\n-static const short yydefact[] = {     0,\n-     0,     1,     2,     0,     3,     0,    11,    12,     0,     0,\n-     0,    11,     0,     5,     0,     0,     0,    14,     7,     6,\n-     4,     0,     0,    17,     0,    15,    14,     8,    13,     0,\n-     0,    16,    14,     9,     0,    10,     0,     0,     0\n-};\n-\n-static const short yydefgoto[] = {    37,\n-     2,     3,    13,    14,     9,    23,    25,    26\n-};\n-\n-static const short yypact[] = {     2,\n-     6,     2,-32768,     8,-32768,     7,    10,-32768,     9,    11,\n-    12,    10,    -5,-32768,    -3,    12,    13,    14,-32768,-32768,\n--32768,    17,     1,-32768,    15,    18,    14,-32768,-32768,    17,\n-     3,-32768,    14,-32768,    16,-32768,    25,    26,-32768\n-};\n-\n-static const short yypgoto[] = {-32768,\n--32768,    27,-32768,    19,    20,   -27,   -12,-32768\n-};\n-\n-\n-#define\tYYLAST\t\t35\n-\n-\n-static const short yytable[] = {    31,\n-    16,    17,    18,    19,     1,    35,    27,    28,    33,    34,\n-     4,     6,     7,     8,    10,    11,    12,    32,    22,    21,\n-    24,    29,    36,    30,    38,    39,     0,     0,     5,     0,\n-     0,    15,     0,     0,    20\n-};\n-\n-static const short yycheck[] = {    27,\n-     6,     7,     6,     7,     3,    33,     6,     7,     6,     7,\n-     5,     4,     6,     4,     6,     5,     5,    30,     5,     7,\n-     4,     7,     7,     6,     0,     0,    -1,    -1,     2,    -1,\n-    -1,    12,    -1,    -1,    16\n-};\n-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/local/share/bison.simple\"\n-\n-/* Skeleton output parser for bison,\n-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n-\n-/* As a special exception, when this file is copied by Bison into a\n-   Bison output file, you may use that output file without restriction.\n-   This special exception was added by the Free Software Foundation\n-   in version 1.24 of Bison.  */\n-\n-#ifndef alloca\n-#ifdef __GNUC__\n-#define alloca __builtin_alloca\n-#else /* not GNU C.  */\n-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)\n-#include <alloca.h>\n-#else /* not sparc */\n-#if defined (MSDOS) && !defined (__TURBOC__)\n-#include <malloc.h>\n-#else /* not MSDOS, or __TURBOC__ */\n-#if defined(_AIX)\n-#include <malloc.h>\n- #pragma alloca\n-#else /* not MSDOS, __TURBOC__, or _AIX */\n-#ifdef __hpux\n-#ifdef __cplusplus\n-extern \"C\" {\n-void *alloca (unsigned int);\n-};\n-#else /* not __cplusplus */\n-void *alloca ();\n-#endif /* not __cplusplus */\n-#endif /* __hpux */\n-#endif /* not _AIX */\n-#endif /* not MSDOS, or __TURBOC__ */\n-#endif /* not sparc.  */\n-#endif /* not GNU C.  */\n-#endif /* alloca not defined.  */\n-\n-/* This is the parser code that is written into each bison parser\n-  when the %semantic_parser declaration is not specified in the grammar.\n-  It was written by Richard Stallman by simplifying the hairy parser\n-  used when %semantic_parser is specified.  */\n-\n-/* Note: there must be only one dollar sign in this file.\n-   It is replaced by the list of actions, each action\n-   as one case of the switch.  */\n-\n-#define yyerrok\t\t(yyerrstatus = 0)\n-#define yyclearin\t(yychar = YYEMPTY)\n-#define YYEMPTY\t\t-2\n-#define YYEOF\t\t0\n-#define YYACCEPT\treturn(0)\n-#define YYABORT \treturn(1)\n-#define YYERROR\t\tgoto yyerrlab1\n-/* Like YYERROR except do call yyerror.\n-   This remains here temporarily to ease the\n-   transition to the new meaning of YYERROR, for GCC.\n-   Once GCC version 2 has supplanted version 1, this can go.  */\n-#define YYFAIL\t\tgoto yyerrlab\n-#define YYRECOVERING()  (!!yyerrstatus)\n-#define YYBACKUP(token, value) \\\n-do\t\t\t\t\t\t\t\t\\\n-  if (yychar == YYEMPTY && yylen == 1)\t\t\t\t\\\n-    { yychar = (token), yylval = (value);\t\t\t\\\n-      yychar1 = YYTRANSLATE (yychar);\t\t\t\t\\\n-      YYPOPSTACK;\t\t\t\t\t\t\\\n-      goto yybackup;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    { yyerror (\"syntax error: cannot back up\"); YYERROR; }\t\\\n-while (0)\n-\n-#define YYTERROR\t1\n-#define YYERRCODE\t256\n-\n-#ifndef YYPURE\n-#define YYLEX\t\tyylex()\n-#endif\n-\n-#ifdef YYPURE\n-#ifdef YYLSP_NEEDED\n-#ifdef YYLEX_PARAM\n-#define YYLEX\t\tyylex(&yylval, &yylloc, YYLEX_PARAM)\n-#else\n-#define YYLEX\t\tyylex(&yylval, &yylloc)\n-#endif\n-#else /* not YYLSP_NEEDED */\n-#ifdef YYLEX_PARAM\n-#define YYLEX\t\tyylex(&yylval, YYLEX_PARAM)\n-#else\n-#define YYLEX\t\tyylex(&yylval)\n-#endif\n-#endif /* not YYLSP_NEEDED */\n-#endif\n-\n-/* If nonreentrant, generate the variables here */\n-\n-#ifndef YYPURE\n-\n-int\tyychar;\t\t\t/*  the lookahead symbol\t\t*/\n-YYSTYPE\tyylval;\t\t\t/*  the semantic value of the\t\t*/\n-\t\t\t\t/*  lookahead symbol\t\t\t*/\n-\n-#ifdef YYLSP_NEEDED\n-YYLTYPE yylloc;\t\t\t/*  location data for the lookahead\t*/\n-\t\t\t\t/*  symbol\t\t\t\t*/\n-#endif\n-\n-int yynerrs;\t\t\t/*  number of parse errors so far       */\n-#endif  /* not YYPURE */\n-\n-#if YYDEBUG != 0\n-int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n-/* Since this is uninitialized, it does not stop multiple parsers\n-   from coexisting.  */\n-#endif\n-\n-/*  YYINITDEPTH indicates the initial size of the parser's stacks\t*/\n-\n-#ifndef\tYYINITDEPTH\n-#define YYINITDEPTH 200\n-#endif\n-\n-/*  YYMAXDEPTH is the maximum size the stacks can grow to\n-    (effective only if the built-in stack extension method is used).  */\n-\n-#if YYMAXDEPTH == 0\n-#undef YYMAXDEPTH\n-#endif\n-\n-#ifndef YYMAXDEPTH\n-#define YYMAXDEPTH 10000\n-#endif\n-\n-/* Prevent warning if -Wstrict-prototypes.  */\n-#ifdef __GNUC__\n-int yyparse (void);\n-#endif\n-\f\n-#if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n-#define __yy_memcpy(FROM,TO,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n-#else\t\t\t\t/* not GNU C or C++ */\n-#ifndef __cplusplus\n-\n-/* This is the most reliable way to avoid incompatibilities\n-   in available built-in functions on various systems.  */\n-static void\n-__yy_memcpy (from, to, count)\n-     char *from;\n-     char *to;\n-     int count;\n-{\n-  register char *f = from;\n-  register char *t = to;\n-  register int i = count;\n-\n-  while (i-- > 0)\n-    *t++ = *f++;\n-}\n-\n-#else /* __cplusplus */\n-\n-/* This is the most reliable way to avoid incompatibilities\n-   in available built-in functions on various systems.  */\n-static void\n-__yy_memcpy (char *from, char *to, int count)\n-{\n-  register char *f = from;\n-  register char *t = to;\n-  register int i = count;\n-\n-  while (i-- > 0)\n-    *t++ = *f++;\n-}\n-\n-#endif\n-#endif\n-\f\n-#line 192 \"/usr/local/share/bison.simple\"\n-\n-/* The user can define YYPARSE_PARAM as the name of an argument to be passed\n-   into yyparse.  The argument should have type void *.\n-   It should actually point to an object.\n-   Grammar actions can access the variable by casting it\n-   to the proper pointer type.  */\n-\n-#ifdef YYPARSE_PARAM\n-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;\n-#else\n-#define YYPARSE_PARAM\n-#define YYPARSE_PARAM_DECL\n-#endif\n-\n-int\n-yyparse(YYPARSE_PARAM)\n-     YYPARSE_PARAM_DECL\n-{\n-  register int yystate;\n-  register int yyn;\n-  register short *yyssp;\n-  register YYSTYPE *yyvsp;\n-  int yyerrstatus;\t/*  number of tokens to shift before error messages enabled */\n-  int yychar1 = 0;\t\t/*  lookahead token as an internal (translated) token number */\n-\n-  short\tyyssa[YYINITDEPTH];\t/*  the state stack\t\t\t*/\n-  YYSTYPE yyvsa[YYINITDEPTH];\t/*  the semantic value stack\t\t*/\n-\n-  short *yyss = yyssa;\t\t/*  refer to the stacks thru separate pointers */\n-  YYSTYPE *yyvs = yyvsa;\t/*  to allow yyoverflow to reallocate them elsewhere */\n-\n-#ifdef YYLSP_NEEDED\n-  YYLTYPE yylsa[YYINITDEPTH];\t/*  the location stack\t\t\t*/\n-  YYLTYPE *yyls = yylsa;\n-  YYLTYPE *yylsp;\n-\n-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)\n-#else\n-#define YYPOPSTACK   (yyvsp--, yyssp--)\n-#endif\n-\n-  int yystacksize = YYINITDEPTH;\n-\n-#ifdef YYPURE\n-  int yychar;\n-  YYSTYPE yylval;\n-  int yynerrs;\n-#ifdef YYLSP_NEEDED\n-  YYLTYPE yylloc;\n-#endif\n-#endif\n-\n-  YYSTYPE yyval;\t\t/*  the variable used to return\t\t*/\n-\t\t\t\t/*  semantic values from the action\t*/\n-\t\t\t\t/*  routines\t\t\t\t*/\n-\n-  int yylen;\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Starting parse\\n\");\n-#endif\n-\n-  yystate = 0;\n-  yyerrstatus = 0;\n-  yynerrs = 0;\n-  yychar = YYEMPTY;\t\t/* Cause a token to be read.  */\n-\n-  /* Initialize stack pointers.\n-     Waste one element of value and location stack\n-     so that they stay on the same level as the state stack.\n-     The wasted elements are never initialized.  */\n-\n-  yyssp = yyss - 1;\n-  yyvsp = yyvs;\n-#ifdef YYLSP_NEEDED\n-  yylsp = yyls;\n-#endif\n-\n-/* Push a new state, which is found in  yystate  .  */\n-/* In all cases, when you get here, the value and location stacks\n-   have just been pushed. so pushing a state here evens the stacks.  */\n-yynewstate:\n-\n-  *++yyssp = yystate;\n-\n-  if (yyssp >= yyss + yystacksize - 1)\n-    {\n-      /* Give user a chance to reallocate the stack */\n-      /* Use copies of these so that the &'s don't force the real ones into memory. */\n-      YYSTYPE *yyvs1 = yyvs;\n-      short *yyss1 = yyss;\n-#ifdef YYLSP_NEEDED\n-      YYLTYPE *yyls1 = yyls;\n-#endif\n-\n-      /* Get the current used size of the three stacks, in elements.  */\n-      int size = yyssp - yyss + 1;\n-\n-#ifdef yyoverflow\n-      /* Each stack pointer address is followed by the size of\n-\t the data in use in that stack, in bytes.  */\n-#ifdef YYLSP_NEEDED\n-      /* This used to be a conditional around just the two extra args,\n-\t but that might be undefined if yyoverflow is a macro.  */\n-      yyoverflow(\"parser stack overflow\",\n-\t\t &yyss1, size * sizeof (*yyssp),\n-\t\t &yyvs1, size * sizeof (*yyvsp),\n-\t\t &yyls1, size * sizeof (*yylsp),\n-\t\t &yystacksize);\n-#else\n-      yyoverflow(\"parser stack overflow\",\n-\t\t &yyss1, size * sizeof (*yyssp),\n-\t\t &yyvs1, size * sizeof (*yyvsp),\n-\t\t &yystacksize);\n-#endif\n-\n-      yyss = yyss1; yyvs = yyvs1;\n-#ifdef YYLSP_NEEDED\n-      yyls = yyls1;\n-#endif\n-#else /* no yyoverflow */\n-      /* Extend the stack our own way.  */\n-      if (yystacksize >= YYMAXDEPTH)\n-\t{\n-\t  yyerror(\"parser stack overflow\");\n-\t  return 2;\n-\t}\n-      yystacksize *= 2;\n-      if (yystacksize > YYMAXDEPTH)\n-\tyystacksize = YYMAXDEPTH;\n-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));\n-      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));\n-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));\n-      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));\n-#ifdef YYLSP_NEEDED\n-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));\n-      __yy_memcpy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));\n-#endif\n-#endif /* no yyoverflow */\n-\n-      yyssp = yyss + size - 1;\n-      yyvsp = yyvs + size - 1;\n-#ifdef YYLSP_NEEDED\n-      yylsp = yyls + size - 1;\n-#endif\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Stack size increased to %d\\n\", yystacksize);\n-#endif\n-\n-      if (yyssp >= yyss + yystacksize - 1)\n-\tYYABORT;\n-    }\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Entering state %d\\n\", yystate);\n-#endif\n-\n-  goto yybackup;\n- yybackup:\n-\n-/* Do appropriate processing given the current state.  */\n-/* Read a lookahead token if we need one and don't already have one.  */\n-/* yyresume: */\n-\n-  /* First try to decide what to do without reference to lookahead token.  */\n-\n-  yyn = yypact[yystate];\n-  if (yyn == YYFLAG)\n-    goto yydefault;\n-\n-  /* Not known => get a lookahead token if don't already have one.  */\n-\n-  /* yychar is either YYEMPTY or YYEOF\n-     or a valid token in external form.  */\n-\n-  if (yychar == YYEMPTY)\n-    {\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Reading a token: \");\n-#endif\n-      yychar = YYLEX;\n-    }\n-\n-  /* Convert token to internal form (in yychar1) for indexing tables with */\n-\n-  if (yychar <= 0)\t\t/* This means end of input. */\n-    {\n-      yychar1 = 0;\n-      yychar = YYEOF;\t\t/* Don't call YYLEX any more */\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Now at end of input.\\n\");\n-#endif\n-    }\n-  else\n-    {\n-      yychar1 = YYTRANSLATE(yychar);\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\t{\n-\t  fprintf (stderr, \"Next token is %d (%s\", yychar, yytname[yychar1]);\n-\t  /* Give the individual parser a way to print the precise meaning\n-\t     of a token, for further debugging info.  */\n-#ifdef YYPRINT\n-\t  YYPRINT (stderr, yychar, yylval);\n-#endif\n-\t  fprintf (stderr, \")\\n\");\n-\t}\n-#endif\n-    }\n-\n-  yyn += yychar1;\n-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)\n-    goto yydefault;\n-\n-  yyn = yytable[yyn];\n-\n-  /* yyn is what to do for this token type in this state.\n-     Negative => reduce, -yyn is rule number.\n-     Positive => shift, yyn is new state.\n-       New state is final state => don't bother to shift,\n-       just return success.\n-     0, or most negative number => error.  */\n-\n-  if (yyn < 0)\n-    {\n-      if (yyn == YYFLAG)\n-\tgoto yyerrlab;\n-      yyn = -yyn;\n-      goto yyreduce;\n-    }\n-  else if (yyn == 0)\n-    goto yyerrlab;\n-\n-  if (yyn == YYFINAL)\n-    YYACCEPT;\n-\n-  /* Shift the lookahead token.  */\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Shifting token %d (%s), \", yychar, yytname[yychar1]);\n-#endif\n-\n-  /* Discard the token being shifted unless it is eof.  */\n-  if (yychar != YYEOF)\n-    yychar = YYEMPTY;\n-\n-  *++yyvsp = yylval;\n-#ifdef YYLSP_NEEDED\n-  *++yylsp = yylloc;\n-#endif\n-\n-  /* count tokens shifted since error; after three, turn off error status.  */\n-  if (yyerrstatus) yyerrstatus--;\n-\n-  yystate = yyn;\n-  goto yynewstate;\n-\n-/* Do the default action for the current state.  */\n-yydefault:\n-\n-  yyn = yydefact[yystate];\n-  if (yyn == 0)\n-    goto yyerrlab;\n-\n-/* Do a reduction.  yyn is the number of a rule to reduce with.  */\n-yyreduce:\n-  yylen = yyr2[yyn];\n-  if (yylen > 0)\n-    yyval = yyvsp[1-yylen]; /* implement default value of the action */\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    {\n-      int i;\n-\n-      fprintf (stderr, \"Reducing via rule %d (line %d), \",\n-\t       yyn, yyrline[yyn]);\n-\n-      /* Print the symbols being reduced, and their result.  */\n-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)\n-\tfprintf (stderr, \"%s \", yytname[yyrhs[i]]);\n-      fprintf (stderr, \" -> %s\\n\", yytname[yyr1[yyn]]);\n-    }\n-#endif\n-\n-\n-  switch (yyn) {\n-\n-case 1:\n-#line 62 \"bi-parser.y\"\n-{ defs = yyvsp[0].def; ;\n-    break;}\n-case 3:\n-#line 68 \"bi-parser.y\"\n-{ yyvsp[0].def->next = yyvsp[-1].def; yyval.def = yyvsp[0].def; ;\n-    break;}\n-case 4:\n-#line 73 \"bi-parser.y\"\n-{ yyval.def = makedef (yyvsp[-7].string, yyvsp[-5].string, yyvsp[-2].variation); ;\n-    break;}\n-case 6:\n-#line 79 \"bi-parser.y\"\n-{ yyvsp[0].variation->next = yyvsp[-2].variation; yyval.variation = yyvsp[0].variation; ;\n-    break;}\n-case 7:\n-#line 84 \"bi-parser.y\"\n-{ yyval.variation = makevar (yyvsp[-1].string, (struct node *) NULL, (struct node *) NULL, (struct node *) NULL); ;\n-    break;}\n-case 8:\n-#line 86 \"bi-parser.y\"\n-{ yyval.variation = makevar (yyvsp[-3].string, yyvsp[-1].node, (struct node *) NULL, (struct node *) NULL); ;\n-    break;}\n-case 9:\n-#line 88 \"bi-parser.y\"\n-{ yyval.variation = makevar (yyvsp[-5].string, yyvsp[-3].node, yyvsp[-1].node, (struct node *) NULL); ;\n-    break;}\n-case 10:\n-#line 90 \"bi-parser.y\"\n-{ yyval.variation = makevar (yyvsp[-7].string, yyvsp[-5].node, yyvsp[-3].node, yyvsp[-1].node); ;\n-    break;}\n-case 11:\n-#line 94 \"bi-parser.y\"\n-{ yyval.string = \"\"; ;\n-    break;}\n-case 12:\n-#line 95 \"bi-parser.y\"\n-{ yyval.string = yyvsp[0].string; ;\n-    break;}\n-case 13:\n-#line 100 \"bi-parser.y\"\n-{ yyval.node = yyvsp[-1].node; ;\n-    break;}\n-case 14:\n-#line 102 \"bi-parser.y\"\n-{ yyval.node = NULL; ;\n-    break;}\n-case 16:\n-#line 109 \"bi-parser.y\"\n-{ yyvsp[-2].node->next = yyvsp[0].node; yyval.node = yyvsp[-2].node; ;\n-    break;}\n-case 17:\n-#line 114 \"bi-parser.y\"\n-{ yyval.node = makenode (yyvsp[0].string); ;\n-    break;}\n-}\n-   /* the action file gets copied in in place of this dollarsign */\n-#line 487 \"/usr/local/share/bison.simple\"\n-\f\n-  yyvsp -= yylen;\n-  yyssp -= yylen;\n-#ifdef YYLSP_NEEDED\n-  yylsp -= yylen;\n-#endif\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    {\n-      short *ssp1 = yyss - 1;\n-      fprintf (stderr, \"state stack now\");\n-      while (ssp1 != yyssp)\n-\tfprintf (stderr, \" %d\", *++ssp1);\n-      fprintf (stderr, \"\\n\");\n-    }\n-#endif\n-\n-  *++yyvsp = yyval;\n-\n-#ifdef YYLSP_NEEDED\n-  yylsp++;\n-  if (yylen == 0)\n-    {\n-      yylsp->first_line = yylloc.first_line;\n-      yylsp->first_column = yylloc.first_column;\n-      yylsp->last_line = (yylsp-1)->last_line;\n-      yylsp->last_column = (yylsp-1)->last_column;\n-      yylsp->text = 0;\n-    }\n-  else\n-    {\n-      yylsp->last_line = (yylsp+yylen-1)->last_line;\n-      yylsp->last_column = (yylsp+yylen-1)->last_column;\n-    }\n-#endif\n-\n-  /* Now \"shift\" the result of the reduction.\n-     Determine what state that goes to,\n-     based on the state we popped back to\n-     and the rule number reduced by.  */\n-\n-  yyn = yyr1[yyn];\n-\n-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;\n-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n-    yystate = yytable[yystate];\n-  else\n-    yystate = yydefgoto[yyn - YYNTBASE];\n-\n-  goto yynewstate;\n-\n-yyerrlab:   /* here on detecting error */\n-\n-  if (! yyerrstatus)\n-    /* If not already recovering from an error, report this error.  */\n-    {\n-      ++yynerrs;\n-\n-#ifdef YYERROR_VERBOSE\n-      yyn = yypact[yystate];\n-\n-      if (yyn > YYFLAG && yyn < YYLAST)\n-\t{\n-\t  int size = 0;\n-\t  char *msg;\n-\t  int x, count;\n-\n-\t  count = 0;\n-\t  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */\n-\t  for (x = (yyn < 0 ? -yyn : 0);\n-\t       x < (sizeof(yytname) / sizeof(char *)); x++)\n-\t    if (yycheck[x + yyn] == x)\n-\t      size += strlen(yytname[x]) + 15, count++;\n-\t  msg = (char *) malloc(size + 15);\n-\t  if (msg != 0)\n-\t    {\n-\t      strcpy(msg, \"parse error\");\n-\n-\t      if (count < 5)\n-\t\t{\n-\t\t  count = 0;\n-\t\t  for (x = (yyn < 0 ? -yyn : 0);\n-\t\t       x < (sizeof(yytname) / sizeof(char *)); x++)\n-\t\t    if (yycheck[x + yyn] == x)\n-\t\t      {\n-\t\t\tstrcat(msg, count == 0 ? \", expecting `\" : \" or `\");\n-\t\t\tstrcat(msg, yytname[x]);\n-\t\t\tstrcat(msg, \"'\");\n-\t\t\tcount++;\n-\t\t      }\n-\t\t}\n-\t      yyerror(msg);\n-\t      free(msg);\n-\t    }\n-\t  else\n-\t    yyerror (\"parse error; also virtual memory exceeded\");\n-\t}\n-      else\n-#endif /* YYERROR_VERBOSE */\n-\tyyerror(\"parse error\");\n-    }\n-\n-  goto yyerrlab1;\n-yyerrlab1:   /* here on error raised explicitly by an action */\n-\n-  if (yyerrstatus == 3)\n-    {\n-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */\n-\n-      /* return failure if at end of input */\n-      if (yychar == YYEOF)\n-\tYYABORT;\n-\n-#if YYDEBUG != 0\n-      if (yydebug)\n-\tfprintf(stderr, \"Discarding token %d (%s).\\n\", yychar, yytname[yychar1]);\n-#endif\n-\n-      yychar = YYEMPTY;\n-    }\n-\n-  /* Else will try to reuse lookahead token\n-     after shifting the error token.  */\n-\n-  yyerrstatus = 3;\t\t/* Each real token shifted decrements this */\n-\n-  goto yyerrhandle;\n-\n-yyerrdefault:  /* current state does not do anything special for the error token. */\n-\n-#if 0\n-  /* This is wrong; only states that explicitly want error tokens\n-     should shift them.  */\n-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/\n-  if (yyn) goto yydefault;\n-#endif\n-\n-yyerrpop:   /* pop the current state because it cannot handle the error token */\n-\n-  if (yyssp == yyss) YYABORT;\n-  yyvsp--;\n-  yystate = *--yyssp;\n-#ifdef YYLSP_NEEDED\n-  yylsp--;\n-#endif\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    {\n-      short *ssp1 = yyss - 1;\n-      fprintf (stderr, \"Error: state stack now\");\n-      while (ssp1 != yyssp)\n-\tfprintf (stderr, \" %d\", *++ssp1);\n-      fprintf (stderr, \"\\n\");\n-    }\n-#endif\n-\n-yyerrhandle:\n-\n-  yyn = yypact[yystate];\n-  if (yyn == YYFLAG)\n-    goto yyerrdefault;\n-\n-  yyn += YYTERROR;\n-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)\n-    goto yyerrdefault;\n-\n-  yyn = yytable[yyn];\n-  if (yyn < 0)\n-    {\n-      if (yyn == YYFLAG)\n-\tgoto yyerrpop;\n-      yyn = -yyn;\n-      goto yyreduce;\n-    }\n-  else if (yyn == 0)\n-    goto yyerrpop;\n-\n-  if (yyn == YYFINAL)\n-    YYACCEPT;\n-\n-#if YYDEBUG != 0\n-  if (yydebug)\n-    fprintf(stderr, \"Shifting error token, \");\n-#endif\n-\n-  *++yyvsp = yylval;\n-#ifdef YYLSP_NEEDED\n-  *++yylsp = yylloc;\n-#endif\n-\n-  yystate = yyn;\n-  goto yynewstate;\n-}\n-#line 117 \"bi-parser.y\"\n-\n-\n-static struct node *\n-makenode (s)\n-     char *s;\n-{\n-  struct node *n;\n-\n-  n = (struct node *) malloc (sizeof (struct node));\n-  n->text = s;\n-  n->next = NULL;\n-  return n;\n-}\n-\n-static struct variation *\n-makevar (name, inputs, outputs, literals)\n-     char *name;\n-     struct node *inputs, *outputs, *literals;\n-{\n-  struct variation *v;\n-\n-  v = (struct variation *) malloc (sizeof (struct variation));\n-  v->name = name;\n-  v->code = ndefs++;\n-  v->inputs = inputs;\n-  v->outputs = outputs;\n-  v->literals = literals;\n-  v->next = NULL;\n-  return v;\n-}\n-\n-static struct def *\n-makedef (name, template, vars)\n-     char *name, *template;\n-     struct variation *vars;\n-{\n-  struct def *d;\n-\n-  d = (struct def *) malloc (sizeof (struct def));\n-  d->basename = name;\n-  d->template = template;\n-  d->variations = vars;\n-  d->next = NULL;\n-  return d;\n-}\n-\n-void\n-yyerror (s)\n-     char *s;\n-{\n-  fprintf (stderr, \"syntax error in input\\n\");\n-  exit (FATAL_EXIT_CODE);\n-}"}, {"sha": "5beb8628f0818a15e0165d139125486e6b43eb00", "filename": "gcc/bi-parser.h", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-parser.h?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,12 +0,0 @@\n-typedef union\n-{\n-  char *string;\n-  struct def *def;\n-  struct variation *variation;\n-  struct node *node;\n-} YYSTYPE;\n-#define\tDEFOP\t258\n-#define\tSTRING\t259\n-\n-\n-extern YYSTYPE yylval;"}, {"sha": "0a03d0f05ada49342dd2280a5edfdea2bb6307a3", "filename": "gcc/bi-parser.y", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-parser.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-parser.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-parser.y?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,169 +0,0 @@\n-/* Bytecode definition file parser.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-%{\n-\n-#include <stdio.h>\n-#include \"hconfig.h\"\n-#include \"bi-defs.h\"\n-\n-extern char yytext[];\n-extern int yyleng;\n-\n-\n-/* Chain of all defs built by the parser. */\n-struct def *defs;\n-int ndefs;\n-\n-static struct node *makenode ();\n-static struct variation *makevar ();\n-static struct def *makedef ();\n-\n-void yyerror ();\n-\n-%}\n-\n-%union\n-{\n-  char *string;\n-  struct def *def;\n-  struct variation *variation;\n-  struct node *node;\n-}\n-\n-%token <string> DEFOP STRING\n-%type <string> opt_string\n-%type <def> defs def\n-%type <variation> variations variation\n-%type <node> list items item\n-\n-%%\n-\n-top: \n-  defs\n-    { defs = $1; }\n-  ;\n-\n-defs:\n-  def\n-  | defs def\n-    { $2->next = $1; $$ = $2; }\n-  ;\n-\n-def:\n-  DEFOP '(' STRING ',' opt_string ',' '(' variations ')' ')'\n-    { $$ = makedef ($3, $5, $8); }\n-  ;\n-\n-variations:\n-  variation\n-  | variations ',' variation\n-    { $3->next = $1; $$ = $3; }\n-  ;\n-\n-variation:\n-  '(' opt_string ')'\n-    { $$ = makevar ($2, (struct node *) NULL, (struct node *) NULL, (struct node *) NULL); }\n-  | '(' opt_string ',' list ')'\n-    { $$ = makevar ($2, $4, (struct node *) NULL, (struct node *) NULL); }\n-  | '(' opt_string ',' list ',' list ')'\n-    { $$ = makevar ($2, $4, $6, (struct node *) NULL); }\n-  | '(' opt_string ',' list ',' list ',' list ')'\n-    { $$ = makevar ($2, $4, $6, $8); }\n-  ;\n-\n-opt_string:\n-  /* empty */ { $$ = \"\"; }\n-  | STRING { $$ = $1; }\n-  ;\n-\n-list:\n-  '(' items ')'\n-    { $$ = $2; }\n-  | /* empty */\n-    { $$ = NULL; }\n-  ;\n-\n-items:\n-  item\n-  /* Note right recursion. */\n-  | item ',' items\n-    { $1->next = $3; $$ = $1; }\n-  ;\n-\n-item:\n-  STRING\n-    { $$ = makenode ($1); }\n-  ;\n-\n-%%\n-\n-static struct node *\n-makenode (s)\n-     char *s;\n-{\n-  struct node *n;\n-\n-  n = (struct node *) malloc (sizeof (struct node));\n-  n->text = s;\n-  n->next = NULL;\n-  return n;\n-}\n-\n-static struct variation *\n-makevar (name, inputs, outputs, literals)\n-     char *name;\n-     struct node *inputs, *outputs, *literals;\n-{\n-  struct variation *v;\n-\n-  v = (struct variation *) malloc (sizeof (struct variation));\n-  v->name = name;\n-  v->code = ndefs++;\n-  v->inputs = inputs;\n-  v->outputs = outputs;\n-  v->literals = literals;\n-  v->next = NULL;\n-  return v;\n-}\n-\n-static struct def *\n-makedef (name, template, vars)\n-     char *name, *template;\n-     struct variation *vars;\n-{\n-  struct def *d;\n-\n-  d = (struct def *) malloc (sizeof (struct def));\n-  d->basename = name;\n-  d->template = template;\n-  d->variations = vars;\n-  d->next = NULL;\n-  return d;\n-}\n-\n-void\n-yyerror (s)\n-     char *s;\n-{\n-  fprintf (stderr, \"syntax error in input\\n\");\n-  exit (FATAL_EXIT_CODE);\n-}"}, {"sha": "6a84f827e73a4f293849901a403e409f4ad3c100", "filename": "gcc/bi-reverse.c", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-reverse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-reverse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-reverse.c?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,61 +0,0 @@\n-/* Reverse order of definitions obtained from bytecode definition file.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"hconfig.h\"\n-#include \"bi-defs.h\"\n-\n-void\n-reverse()\n-{\n-  struct def *dp, *d, *dn;\n-  struct variation *vp, *v, *vn;\n-\n-  dp = defs;\n-  if (dp)\n-    {\n-      vp = dp->variations;\n-      if (vp)\n-\t{\n-\t  for (v = vp->next, vp->next = 0; v; vp = v, v = vn)\n-\t    {\n-\t      vn = v->next;\n-\t      v->next = vp;\n-\t    }\n-\t  dp->variations = vp;\n-\t}\n-      for (d = dp->next, dp->next = 0; d; dp = d, d = dn)\n-\t{\n-\t  vp = d->variations;\n-\t  if (vp)\n-\t    {\n-\t      for (v = vp->next, vp->next = 0; v; vp = v, v = vn)\n-\t\t{\n-\t\t  vn = v->next;\n-\t\t  v->next = vp;\n-\t\t}\n-\t      d->variations = vp;\n-\t    }\n-\t  dn = d->next;\n-\t  d->next = dp;\n-\t}\n-      defs = dp;\n-    }\n-}"}, {"sha": "dc9192f78b87c6e860da171277366bfb3f54bdc6", "filename": "gcc/bi-run.h", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-run.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6885fc8771316b46fb26d315118a18c00f4a5f31/gcc%2Fbi-run.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-run.h?ref=6885fc8771316b46fb26d315118a18c00f4a5f31", "patch": "@@ -1,159 +0,0 @@\n-/* Definitions for Bytecode Interpreter.\n-   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define MAXLITERALS 5\n-\n-struct arityvec\n-{\n-  char ninputs;\n-  char noutputs;\n-  char nliterals;\n-  char literals[MAXLITERALS];\n-};\n-\n-struct argtype\n-{\n-  int modealign;\t\t/* Argument mode:alignment */\n-  int size;\t\t\t/* Argument size, in bytes */\n-};\n-\n-struct callinfo\n-{\n-  int nargs;\t\t\t/* Number of arguments in call */\n-  struct argtype retvaltype;\t/* Type of return value */\n-  struct argtype argtypes[1];\t/* Argument types */\n-};\n-  \n-/* Structure describing a bytecode function.  If this changes, we also\n-   need to change expand_function_end () in bc-trans.c  */\n-struct bytecode\n-{\n-  int stacksize;\t\t/* Depth required of evaluation stack.  */\n-  int localsize;\t\t/* Size in bytes of local variables.  */\n-  unsigned char *pc0;\t\t/* Initial program counter. */\n-  void **ptrlit;\t\t/* Vector of (relocatable) pointer literals. */\n-  struct callinfo *callinfo;\t/* Vector of procedure call type info. */\n-};\n-\n-\n-#define INTERP_BPC 8\t\t/* Bits per char */\n-#define INTERP_BPI \\\n-  (sizeof (int) * INTERP_BPC)\t/* Bits per int */\n-\n-\n-#ifndef min\n-#define min(L, R)  ((L) < (R) ? (L) : (R))\n-#endif\n-\n-\n-/* bit field operations. */\n-\n-/* Low (high) mask: int with low (high) N bits set */\n-\n-#define LM(N)   ((1 << (N)) - 1)\n-#define HM(N)\t((~LM (INTERP_BPI - (N))))\n-\n-\n-/* Sign-extend SIZE low bits of VALUE to integer (typeof VALUE)\n-   Signed bitfields are loaded from memory by the sxloadBI instruction,\n-   which first retrieves the bitfield with XFIELD and then sign extends\n-   it to an SItype. */\n-\n-#define EXTEND(SIZE, VALUE)\t\t\t\t\t\t      \\\n-  ({ SUtype value = (SUtype) (VALUE);\t\t\t\t\t      \\\n-    (value & (1 << ((SIZE) - 1)) ? value | ~LM (SIZE) : value); })\n-\n-\n-/* Given OFFSET:SIZE for  a bitfield, calculate:\n-\n-   [1] BYTE_OFFSET  = the byte offset of the bit field.\n-   [2] BIT_OFFSET   = the bit offset of the bit field (less than INTERP_BPC).\n-   [3] NBYTES       = the number of integral bytes in the bit field.\n-   [4] TRAILING_BITS= the number of trailing bits (less than INTERP_BPC).\n-\n-\n-   ,        ,        ,        ,        ,    (memory bytes)\n-                    ----------------        (bitfield)\n-   |        |       ||        |    |        (divisions)\n-        ^         ^       ^      ^\n-        |         |       |      |__ [4]  (bits)\n-        |         |       |_________ [3]  (bytes)\n-        |         |_________________ [2]  (bits)\n-        |___________________________ [1]  (bytes)\n-\n-\n-   The above applies to BYTE_LOW_ENDIAN machines. In BYTE_BIG_ENDIAN machines, the\n-   bit numbering is reversed (i.e. bit 0 is the sign bit).\n-\n-   (All right, so I drew this to keep my tongue in cheek while writing the code below,\n-    not because I'm into ASCII art.) */\n-\n-\n-#define BI_PARAMS(OFFSET, SIZE, BYTE_OFFSET, BIT_OFFSET, NBYTES, TRAILING_BITS)\t\t\\\n-  { BYTE_OFFSET = (OFFSET) / (INTERP_BPC);\t\t\t\t\\\n-    BIT_OFFSET = (OFFSET) % (INTERP_BPC);\t\t\t\t\\\n-    NBYTES = ((SIZE) - (INTERP_BPC - (BIT_OFFSET))) / INTERP_BPC;\t\\\n-    if ((NBYTES) < 0 || ((NBYTES) > 64)) \t\t\t\t\\\n-      NBYTES = 0;\t\t\t\t \t\t\t\\\n-    if ((SIZE) + (BIT_OFFSET) <= INTERP_BPC)\t\t\t\t\\\n-      TRAILING_BITS = 0;\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      TRAILING_BITS = ((SIZE) - (INTERP_BPC - (BIT_OFFSET))) % INTERP_BPC; }\n-\n-\n-/* SHIFT_IN_BITS retrieves NBITS bits from SOURCE and shifts into\n-   DEST. The bit field starts OFFSET bits into SOURCE.\n-\n-   OR_IN_BITS copies the NBITS low bits from VALUE into a the bitfield in\n-   DEST offset by OFFSET bits. */\n-\n-\n-#define SHIFT_IN_BITS(DEST, SOURCE, OFFSET, NBITS)\t\t\\\n-  (DEST = ((DEST) << (NBITS))\t\t\t\t\t\\\n-   | (LM ((NBITS))\t\t\t\t\t\t\\\n-      & ((SOURCE)\t\t\t\t\t\t\\\n-\t >> (BYTES_BIG_ENDIAN\t\t\t\t\t\\\n-\t     ? (INTERP_BPC - (OFFSET) - (NBITS))\t\t\\\n-\t     : (OFFSET)))))\n-\n-#define OR_IN_BITS(DEST, VALUE, OFFSET, NBITS)\t\t\t\\\n-  (DEST = ((DEST) & ~(LM ((NBITS))\t\t\t\t\\\n-\t\t      << (BIG_ENDIAN\t\t\t\t\\\n-\t\t\t  ? (INTERP_BPC - (OFFSET) - (NBITS))\t\\\n-\t\t\t  : (OFFSET)))\t\t\t\t\\\n-   | (((VALUE) & LM ((NBITS)))\t\t\t\t\t\\\n-      << (BIG_ENDIAN\t\t\t\t\t\t\\\n-\t  ? (INTERP_BPC - (OFFSET) - (NBITS))\t\t\t\\\n-\t  : (OFFSET)))))\n-\n-/* Procedure call; arguments are a pointer to the function to be called,\n-   a pointer to a place to store the return value, a pointer to a vector\n-   describing the type of procedure call, and the interpreter's stack pointer,\n-   which will point to the first of the arguments at this point.  */\n-\n-#define CALL(FUNC, CALLDESC, RETVAL, SP) __call(FUNC, CALLDESC, RETVAL, SP)\n-\n-\n-/* Procedure return; arguments are a pointer to the calldesc for this\n-   function, and a pointer to the place where the value to be returned\n-   may be found.  Generally the MACHARGS above contain a machine dependent\n-   cookie that is used to determine where to jump to.  */\n-\n-#define PROCRET(CALLDESC, RETVAL) return"}, {"sha": "3a2ba295587472cb226af0f6726006626a00230a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -53,23 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"obstack.h\"\n \n-#include \"bytecode.h\"\n #include \"machmode.h\"\n-#include \"bc-opcode.h\"\n-#include \"bc-typecd.h\"\n-#include \"bc-optab.h\"\n-#include \"bc-emit.h\"\n-\n-/* Opcode names */\n-#ifdef BCDEBUG_PRINT_CODE\n-char *opcode_name[] =\n-{\n-#include \"bc-opname.h\"\n-\n-\"***END***\"\n-};\n-#endif\n-\n \n /* Commonly used modes.  */\n \n@@ -1451,11 +1435,8 @@ gen_label_rtx ()\n {\n   register rtx label;\n \n-  label = (output_bytecode\n-\t   ? gen_rtx_CODE_LABEL (VOIDmode, 0, bc_get_bytecode_label (),\n-\t\t\t\t NULL_RTX, 0, NULL_PTR)\n-\t   : gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX,\n-\t\t\t\t NULL_RTX, label_num++, NULL_PTR));\n+  label = gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX,\n+\t\t\t      NULL_RTX, label_num++, NULL_PTR);\n \n   LABEL_NUSES (label) = 0;\n   return label;\n@@ -2937,13 +2918,6 @@ emit_line_note (file, line)\n      char *file;\n      int line;\n {\n-  if (output_bytecode)\n-    {\n-      /* FIXME: for now we do nothing, but eventually we will have to deal with\n-\t debugging information.  */\n-      return 0;\n-    }\n-\n   emit_filename = file;\n   emit_lineno = line;\n "}, {"sha": "ef2666877a9bfb15d45aca4b3d3bacf471c4d748", "filename": "gcc/expr.c", "status": "modified", "additions": 2894, "deletions": 4217, "changes": 7111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66"}, {"sha": "e818d5ab398c9088c15af4658d9318ee2b6648af", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -936,19 +936,7 @@ extern rtx (*lang_expand_expr) PROTO ((union tree_node *, rtx,\n \t\t\t\t       enum machine_mode,\n \t\t\t\t       enum expand_modifier modifier));\n \n-#ifdef TREE_CODE\n-/* Build bytecode call descriptor for function SUBR. */\n-extern rtx bc_build_calldesc PROTO((tree));\n-\n-/* Emit a type code to be used by the runtime support in handling\n-   parameter passing.   The type code consists of the machine mode\n-   plus the minimal alignment shifted left 8 bits.  */\n-extern tree bc_runtime_type_code PROTO((tree));\n-#endif\n-\n extern void init_all_optabs\t\t\tPROTO ((void));\n extern void init_mov_optab\t\t\tPROTO ((void));\n-extern void bc_adjust_stack\t\t\tPROTO ((int));\n-extern void bc_load_localaddr\t\t\tPROTO ((rtx));\n extern void do_jump_by_parts_greater_rtx\tPROTO ((enum machine_mode, int,\n \t\t\t\t\t\t\trtx, rtx, rtx, rtx));"}, {"sha": "8a4d7d116bfeaf79813d30ff8142ef6ebab0eebd", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 166, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -55,8 +55,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"basic-block.h\"\n #include \"obstack.h\"\n-#include \"bytecode.h\"\n-#include \"bc-emit.h\"\n \n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n@@ -388,19 +386,12 @@ static tree this_function_decl;\n /* Callinfo pointer for the current function.  */\n static rtx this_function_callinfo;\n \n-/* The label in the bytecode file of this function's actual bytecode.\n-   Not an rtx.  */\n-static char *this_function_bytecode;\n-\n /* The call description vector for the current function.  */\n static rtx this_function_calldesc;\n \n /* Size of the local variables allocated for the current function.  */\n int local_vars_size;\n \n-/* Current depth of the bytecode evaluation stack.  */\n-int stack_depth;\n-\n /* Maximum depth of the evaluation stack in this function.  */\n int max_stack_depth;\n \n@@ -1312,9 +1303,6 @@ put_var_into_stack (decl)\n   tree context;\n   int can_use_addressof;\n \n-  if (output_bytecode)\n-    return;\n-  \n   context = decl_function_context (decl);\n \n   /* Get the current rtl used for this object and it's original mode.  */\n@@ -5153,50 +5141,6 @@ all_blocks (block, vector)\n   return n_blocks;\n }\n \f\n-/* Build bytecode call descriptor for function SUBR.  */\n-\n-rtx\n-bc_build_calldesc (subr)\n-  tree subr;\n-{\n-  tree calldesc = 0, arg;\n-  int nargs = 0;\n-\n-  /* Build the argument description vector in reverse order.  */\n-  DECL_ARGUMENTS (subr) = nreverse (DECL_ARGUMENTS (subr));\n-  nargs = 0;\n-\n-  for (arg = DECL_ARGUMENTS (subr); arg; arg = TREE_CHAIN (arg))\n-    {\n-      ++nargs;\n-\n-      calldesc = tree_cons ((tree) 0, size_in_bytes (TREE_TYPE (arg)), calldesc);\n-      calldesc = tree_cons ((tree) 0, bc_runtime_type_code (TREE_TYPE (arg)), calldesc);\n-    }\n-\n-  DECL_ARGUMENTS (subr) = nreverse (DECL_ARGUMENTS (subr));\n-\n-  /* Prepend the function's return type.  */\n-  calldesc = tree_cons ((tree) 0,\n-\t\t\tsize_in_bytes (TREE_TYPE (TREE_TYPE (subr))),\n-\t\t\tcalldesc);\n-\n-  calldesc = tree_cons ((tree) 0,\n-\t\t\tbc_runtime_type_code (TREE_TYPE (TREE_TYPE (subr))),\n-\t\t\tcalldesc);\n-\n-  /* Prepend the arg count.  */\n-  calldesc = tree_cons ((tree) 0, build_int_2 (nargs, 0), calldesc);\n-\n-  /* Output the call description vector and get its address.  */\n-  calldesc = build_nt (CONSTRUCTOR, (tree) 0, calldesc);\n-  TREE_TYPE (calldesc) = build_array_type (integer_type_node,\n-\t\t\t\t\t   build_index_type (build_int_2 (nargs * 2, 0)));\n-\n-  return output_constant_def (calldesc);\n-}\n-\n-\n /* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)\n    and initialize static variables for generating RTL for the statements\n    of the function.  */\n@@ -5207,17 +5151,6 @@ init_function_start (subr, filename, line)\n      char *filename;\n      int line;\n {\n-  if (output_bytecode)\n-    {\n-      this_function_decl = subr;\n-      this_function_calldesc = bc_build_calldesc (subr);\n-      local_vars_size = 0;\n-      stack_depth = 0;\n-      max_stack_depth = 0;\n-      stmt_expr_depth = 0;\n-      return;\n-    }\n-\n   init_stmt_for_function ();\n \n   cse_not_expected = ! optimize;\n@@ -5371,99 +5304,14 @@ mark_varargs ()\n void\n expand_main_function ()\n {\n-  if (!output_bytecode)\n-    {\n-      /* The zero below avoids a possible parse error */\n-      0;\n #if !defined (HAS_INIT_SECTION)\n-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, NAME__MAIN), 0,\n-\t\t\t VOIDmode, 0);\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, NAME__MAIN), 0,\n+\t\t     VOIDmode, 0);\n #endif /* not HAS_INIT_SECTION */\n-    }\n }\n \f\n extern struct obstack permanent_obstack;\n \n-/* Expand start of bytecode function. See comment at\n-   expand_function_start below for details.  */\n-\n-void\n-bc_expand_function_start (subr, parms_have_cleanups)\n-  tree subr;\n-  int parms_have_cleanups;\n-{\n-  char label[20], *name;\n-  static int nlab;\n-  tree thisarg;\n-  int argsz;\n-\n-  if (TREE_PUBLIC (subr))\n-    bc_globalize_label (IDENTIFIER_POINTER (DECL_NAME (subr)));\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fprintf (stderr, \"\\n<func %s>\\n\", IDENTIFIER_POINTER (DECL_NAME (subr)));\n-#endif\n-\n-  for (argsz = 0, thisarg = DECL_ARGUMENTS (subr); thisarg; thisarg = TREE_CHAIN (thisarg))\n-    {\n-      if (DECL_RTL (thisarg))\n-\tabort ();\t\t/* Should be NULL here I think.  */\n-      else if (TREE_CONSTANT (DECL_SIZE (thisarg)))\n-\t{\n-\t  DECL_RTL (thisarg) = bc_gen_rtx ((char *) 0, argsz, (struct bc_label *) 0);\n-\t  argsz += TREE_INT_CST_LOW (DECL_SIZE (thisarg));\n-\t}\n-      else\n-\t{\n-\t  /* Variable-sized objects are pointers to their storage.  */\n-\t  DECL_RTL (thisarg) = bc_gen_rtx ((char *) 0, argsz, (struct bc_label *) 0);\n-\t  argsz += POINTER_SIZE;\n-\t}\n-    }\n-\n-  bc_begin_function (xstrdup (IDENTIFIER_POINTER (DECL_NAME (subr))));\n-\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"LX\", nlab);\n-\n-  ++nlab;\n-  name = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n-  this_function_callinfo = bc_gen_rtx (name, 0, (struct bc_label *) 0);\n-  this_function_bytecode\n-    = bc_emit_trampoline (BYTECODE_LABEL (this_function_callinfo));\n-}\n-\n-\n-/* Expand end of bytecode function. See details the comment of\n-   expand_function_end(), below.  */\n-\n-void\n-bc_expand_function_end ()\n-{\n-  char *ptrconsts;\n-\n-  expand_null_return ();\n-\n-  /* Emit any fixup code. This must be done before the call to\n-     to BC_END_FUNCTION (), since that will cause the bytecode\n-     segment to be finished off and closed.  */\n-\n-  expand_fixups (NULL_RTX);\n-\n-  ptrconsts = bc_end_function ();\n-\n-  bc_align_const (2 /* INT_ALIGN */);\n-\n-  /* If this changes also make sure to change bc-interp.h!  */\n-\n-  bc_emit_const_labeldef (BYTECODE_LABEL (this_function_callinfo));\n-  bc_emit_const ((char *) &max_stack_depth, sizeof max_stack_depth);\n-  bc_emit_const ((char *) &local_vars_size, sizeof local_vars_size);\n-  bc_emit_const_labelref (this_function_bytecode, 0);\n-  bc_emit_const_labelref (ptrconsts, 0);\n-  bc_emit_const_labelref (BYTECODE_LABEL (this_function_calldesc), 0);\n-}\n-\n-\n /* Start the RTL for a new function, and set variables used for\n    emitting RTL.\n    SUBR is the FUNCTION_DECL node.\n@@ -5479,12 +5327,6 @@ expand_function_start (subr, parms_have_cleanups)\n   tree tem;\n   rtx last_ptr;\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_function_start (subr, parms_have_cleanups);\n-      return;\n-    }\n-\n   /* Make sure volatile mem refs aren't considered\n      valid operands of arithmetic insns.  */\n   init_recog_no_volatile ();\n@@ -5719,12 +5561,6 @@ expand_function_end (filename, line, end_bindings)\n   static rtx initial_trampoline;\n #endif\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_function_end ();\n-      return;\n-    }\n-\n #ifdef NON_SAVING_SETJMP\n   /* Don't put any variables in registers if we call setjmp\n      on a machine that fails to restore the registers.  */"}, {"sha": "28731c0060d139adac64630fc5dca2b3acfd6fd4", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -35,7 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"except.h\"\n #include \"function.h\"\n-#include \"bytecode.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -3273,12 +3272,6 @@ output_inline_function (fndecl)\n   rtx head;\n   rtx last;\n \n-  if (output_bytecode)\n-    {\n-      warning (\"`inline' ignored for bytecode output\");\n-      return;\n-    }\n-\n   /* Things we allocate from here on are part of this function, not\n      permanent.  */\n   temporary_allocation ();"}, {"sha": "de06f45b95618374c2297ebad63f24c8cf5fe685", "filename": "gcc/output.h", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -56,20 +56,20 @@ extern void shorten_branches\tPROTO((rtx));\n    for the new function.  The label for the function and associated\n    assembler pseudo-ops have already been output in\n    `assemble_start_function'.  */\n-extern void final_start_function  STDIO_PROTO((rtx, FILE *, int));\n+extern void final_start_function  PROTO((rtx, FILE *, int));\n \n /* Output assembler code for the end of a function.\n    For clarity, args are same as those of `final_start_function'\n    even though not all of them are needed.  */\n-extern void final_end_function  STDIO_PROTO((rtx, FILE *, int));\n+extern void final_end_function  PROTO((rtx, FILE *, int));\n \n /* Output assembler code for some insns: all or part of a function.  */\n-extern void final\t\tSTDIO_PROTO((rtx, FILE *, int, int));\n+extern void final\t\tPROTO((rtx, FILE *, int, int));\n \n /* The final scan for one insn, INSN.  Args are same as in `final', except\n    that INSN is the insn being scanned.  Value returned is the next insn to\n    be scanned.  */\n-extern rtx final_scan_insn\tSTDIO_PROTO((rtx, FILE *, int, int, int));\n+extern rtx final_scan_insn\tPROTO((rtx, FILE *, int, int, int));\n \n /* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n    subreg of.  */\n@@ -93,12 +93,11 @@ extern void output_address\tPROTO((rtx));\n /* Print an integer constant expression in assembler syntax.\n    Addition and subtraction are the only arithmetic\n    that may appear in these expressions.  */\n-extern void output_addr_const STDIO_PROTO((FILE *, rtx));\n+extern void output_addr_const PROTO((FILE *, rtx));\n \n /* Output a string of assembler code, substituting numbers, strings\n    and fixed syntactic prefixes.  */\n-extern void asm_fprintf\t\tSTDIO_PROTO(PVPROTO((FILE *file,\n-\t\t\t\t\t\t     char *p, ...)));\n+extern void asm_fprintf\t\tPROTO(PVPROTO((FILE *file, char *p, ...)));\n \n /* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n    words.  */\n@@ -119,8 +118,8 @@ extern void leaf_renumber_regs_insn PROTO((rtx));\n extern void allocate_for_life_analysis\tPROTO((void));\n extern int regno_uninitialized\t\tPROTO((int));\n extern int regno_clobbered_at_setjmp\tPROTO((int));\n-extern void dump_flow_info\t\tSTDIO_PROTO((FILE *));\n-extern void flow_analysis\t\tSTDIO_PROTO((rtx, int, FILE *));\n+extern void dump_flow_info\t\tPROTO((FILE *));\n+extern void flow_analysis\t\tPROTO((rtx, int, FILE *));\n #endif\n \n /* Functions in varasm.c.  */\n@@ -229,12 +228,6 @@ extern void assemble_string\t\tPROTO((char *, int));\n    initial value (that will be done by the caller).  */\n extern void assemble_variable\t\tPROTO((tree, int, int, int));\n \n-/* Output text storage for constructor CONSTR. */\n-extern void bc_output_constructor\tPROTO((tree, int));\n-\n-/* Create storage for constructor CONSTR. */\n-extern void bc_output_data_constructor\tPROTO((tree));\n-\n /* Output something to declare an external symbol to the assembler.\n    (Most assemblers don't need this, so we normally output nothing.)\n    Do nothing if DECL is not external.  */\n@@ -257,7 +250,7 @@ extern void assemble_label\t\tPROTO((char *));\n    Otherwise NAME is transformed in an implementation-defined way\n    (usually by the addition of an underscore).\n    Many macros in the tm file are defined to call this function.  */\n-extern void assemble_name\t\tSTDIO_PROTO((FILE *, char *));\n+extern void assemble_name\t\tPROTO((FILE *, char *));\n \n #ifdef RTX_CODE\n /* Assemble the integer constant X into an object of SIZE bytes."}, {"sha": "969d89e7d1928a5b8a0031ea8afed347cc7aa6b6", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"reload.h\"\n #include \"real.h\"\n-#include \"bytecode.h\"\n \n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n@@ -424,8 +423,7 @@ init_regs ()\n {\n   /* This finishes what was started by init_reg_sets, but couldn't be done\n      until after register usage was specified.  */\n-  if (!output_bytecode)\n-    init_reg_sets_1 ();\n+  init_reg_sets_1 ();\n \n   init_reg_modes ();\n }\n@@ -483,13 +481,6 @@ fix_register (name, fixed, call_used)\n {\n   int i;\n \n-  if (output_bytecode)\n-    {\n-      warning (\"request to mark `%s' as %s ignored by bytecode compiler\",\n-\t       name, call_used ? \"call-used\" : \"fixed\");\n-      return;\n-    }\n-\n   /* Decode the name and update the primary form of\n      the register info.  */\n "}, {"sha": "0f9d272d89c22ebc3a76fa0b7f1fa7a78ce85961", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -439,17 +439,6 @@ extern char *note_insn_name[];\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n #define LABEL_NUSES(LABEL) ((LABEL)->fld[5].rtint)\n \n-/* The rest is used instead of the above, in a CODE_LABEL,\n-   if bytecode is being output.\n-   We make the slightly kludgy assumption that a LABEL has enough slots\n-   to hold these things.  That happens to be true.  */\n-\n-/* For static or external objects.  */\n-#define BYTECODE_LABEL(X) (XSTR ((X), 0))\n-\n-/* For goto labels inside bytecode functions.  */\n-#define BYTECODE_BC_LABEL(X) (*(struct bc_label **) &XEXP ((X), 1))\n-\n /* The original regno this ADDRESSOF was built for.  */\n #define ADDRESSOF_REGNO(RTX) ((RTX)->fld[1].rtint)\n \n@@ -681,10 +670,6 @@ extern int ceil_log2\t\t\tPROTO((unsigned HOST_WIDE_INT));\n extern rtx plus_constant_wide\t\t PROTO((rtx, HOST_WIDE_INT));\n extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));\n \n-struct bc_label;\n-extern rtx bc_gen_rtx\t\t\tPROTO ((char *, int,\n-\t\t\t\t\t\tstruct bc_label *));\n-\n extern rtx gen_rtx\t\t\tPVPROTO((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, ...));\n extern rtvec gen_rtvec\t\t\tPVPROTO((int, ...));\n@@ -1254,7 +1239,6 @@ extern void emit_jump\t\t\tPROTO ((rtx));\n extern int preserve_subexpressions_p\tPROTO ((void));\n \n /* In expr.c */\n-extern rtx bc_allocate_local\t\tPROTO ((int, int));\n extern void init_expr_once\t\tPROTO ((void));\n \n /* In stupid.c */"}, {"sha": "abda4bf900ea8f02915dccb2bdde680bac09b2f8", "filename": "gcc/stmt.c", "status": "modified", "additions": 39, "deletions": 903, "changes": 942, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -53,12 +53,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"machmode.h\"\n \n-#include \"bytecode.h\"\n-#include \"bc-typecd.h\"\n-#include \"bc-opcode.h\"\n-#include \"bc-optab.h\"\n-#include \"bc-emit.h\"\n-\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n struct obstack stmt_obstack;\n@@ -247,8 +241,7 @@ struct nesting\n \t  /* Sequence number of this binding contour within the function,\n \t     in order of entry.  */\n \t  int block_start_count;\n-\t  /* Nonzero => value to restore stack to on exit.  Complemented by\n-\t     bc_stack_level (see below) when generating bytecodes.  */\n+\t  /* Nonzero => value to restore stack to on exit.  */\n \t  rtx stack_level;\n \t  /* The NOTE that starts this contour.\n \t     Used by expand_goto to check whether the destination\n@@ -276,7 +269,6 @@ struct nesting\n \t  /* Number of function calls seen, as of start of this block.  */\n \t  int function_call_count;\n \t  /* Bytecode specific: stack level to restore stack to on exit.  */\n-\t  int bc_stack_level;\n \t  /* Nonzero if this is associated with a EH region.  */\n \t  int exception_region;\n \t  /* The saved target_temp_slot_level from our outer block.\n@@ -307,10 +299,6 @@ struct nesting\n \t  /* The insn after which the case dispatch should finally\n \t     be emitted.  Zero for a dummy.  */\n \t  rtx start;\n-\t  /* For bytecodes, the case table is in-lined right in the code.\n-\t     A label is needed for skipping over this block. It is only\n-\t     used when generating bytecodes.  */\n-\t  rtx skip_label;\n \t  /* A list of case labels; it is first built as an AVL tree.\n \t     During expand_end_case, this is converted to a list, and may be\n \t     rearranged into a nearly balanced binary tree.  */\n@@ -422,21 +410,6 @@ struct goto_fixup\n      time this goto was seen.\n      The TREE_ADDRESSABLE flag is 1 for a block that has been exited.  */\n   tree cleanup_list_list;\n-\n-  /* Bytecode specific members follow */\n-\n-  /* The label that this jump is jumping to, or 0 for break, continue\n-     or return.  */\n-  struct bc_label *bc_target;\n-\n-  /* The label we use for the fixup patch */\n-  struct bc_label *label;\n-\n-  /* True (non-0) if fixup has been handled */\n-  int bc_handled:1;\n-\n-  /* Like stack_level above, except refers to the interpreter stack */\n-  int bc_stack_level;\n };\n \n static struct goto_fixup *goto_fixup_chain;\n@@ -457,32 +430,13 @@ static int using_eh_for_cleanups_p = 0;\n \n \n static void expand_goto_internal\tPROTO((tree, rtx, rtx));\n-static void bc_expand_goto_internal\tPROTO((enum bytecode_opcode,\n-\t\t\t\t\t       struct bc_label *, tree));\n static int expand_fixup\t\t\tPROTO((tree, rtx, rtx));\n-static void bc_expand_fixup\t\tPROTO((enum bytecode_opcode,\n-\t\t\t\t\t       struct bc_label *, int));\n static void fixup_gotos\t\t\tPROTO((struct nesting *, rtx, tree,\n \t\t\t\t\t       rtx, int));\n-static void bc_fixup_gotos\t\tPROTO((struct nesting *, int, tree,\n-\t\t\t\t\t       rtx, int));\n-static void bc_expand_start_cond\tPROTO((tree, int));\n-static void bc_expand_end_cond\t\tPROTO((void));\n-static void bc_expand_start_else\tPROTO((void));\n-static void bc_expand_end_loop\t\tPROTO((void));\n-static void bc_expand_end_bindings\tPROTO((tree, int, int));\n-static void bc_expand_decl\t\tPROTO((tree, tree));\n-static void bc_expand_variable_local_init PROTO((tree));\n-static void bc_expand_decl_init\t\tPROTO((tree));\n static void expand_null_return_1\tPROTO((rtx, int));\n static void expand_value_return\t\tPROTO((rtx));\n static int tail_recursion_args\t\tPROTO((tree, tree));\n static void expand_cleanups\t\tPROTO((tree, tree, int, int));\n-static void bc_expand_start_case\tPROTO((struct nesting *, tree,\n-\t\t\t\t\t       tree, char *));\n-static int bc_pushcase\t\t\tPROTO((tree, tree));\n-static void bc_check_for_full_enumeration_handling PROTO((tree));\n-static void bc_expand_end_case\t\tPROTO((tree));\n static void do_jump_if_equal\t\tPROTO((rtx, rtx, rtx, int));\n static int estimate_case_costs\t\tPROTO((case_node_ptr));\n static void group_case_nodes\t\tPROTO((case_node_ptr));\n@@ -496,8 +450,6 @@ static void emit_case_nodes\t\tPROTO((rtx, case_node_ptr, rtx, tree));\n static int add_case_node\t\tPROTO((tree, tree, tree, tree *));\n static struct case_node *case_tree2list\tPROTO((case_node *, case_node *));\n \n-extern rtx bc_allocate_local ();\n-extern rtx bc_allocate_variable_array ();\n \f\n void\n using_eh_for_cleanups ()\n@@ -585,15 +537,12 @@ emit_nop ()\n {\n   rtx last_insn;\n \n-  if (!output_bytecode)\n-    {\n-      last_insn = get_last_insn ();\n-      if (!optimize\n-\t  && (GET_CODE (last_insn) == CODE_LABEL\n-\t      || (GET_CODE (last_insn) == NOTE\n-\t\t  && prev_real_insn (last_insn) == 0)))\n-\temit_insn (gen_nop ());\n-    }\n+  last_insn = get_last_insn ();\n+  if (!optimize\n+      && (GET_CODE (last_insn) == CODE_LABEL\n+\t  || (GET_CODE (last_insn) == NOTE\n+\t      && prev_real_insn (last_insn) == 0)))\n+    emit_insn (gen_nop ());\n }\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n@@ -630,28 +579,20 @@ void\n expand_computed_goto (exp)\n      tree exp;\n {\n-  if (output_bytecode)\n-    {\n-      bc_expand_expr (exp);\n-      bc_emit_instruction (jumpP);\n-    }\n-  else\n-    {\n-      rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n+  rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n-      x = convert_memory_address (Pmode, x);\n+  x = convert_memory_address (Pmode, x);\n #endif\n \n-      emit_queue ();\n-      /* Be sure the function is executable.  */\n-      if (flag_check_memory_usage)\n-\temit_library_call (chkr_check_exec_libfunc, 1,\n-\t\t\t   VOIDmode, 1, x, ptr_mode);\n+  emit_queue ();\n+  /* Be sure the function is executable.  */\n+  if (flag_check_memory_usage)\n+    emit_library_call (chkr_check_exec_libfunc, 1,\n+\t\t       VOIDmode, 1, x, ptr_mode);\n \n-      do_pending_stack_adjust ();\n-      emit_indirect_jump (x);\n-    }\n+  do_pending_stack_adjust ();\n+  emit_indirect_jump (x);\n }\n \f\n /* Handle goto statements and the labels that they can go to.  */\n@@ -673,15 +614,6 @@ expand_label (label)\n {\n   struct label_chain *p;\n \n-  if (output_bytecode)\n-    {\n-      if (! DECL_RTL (label))\n-\tDECL_RTL (label) = bc_gen_rtx ((char *) 0, 0, bc_get_bytecode_label ());\n-      if (! bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (DECL_RTL (label))))\n-\terror (\"multiply defined label\");\n-      return;\n-    }\n-\n   do_pending_stack_adjust ();\n   emit_label (label_rtx (label));\n   if (DECL_NAME (label))\n@@ -725,12 +657,6 @@ expand_goto (label)\n {\n   tree context;\n \n-  if (output_bytecode)\n-    {\n-      expand_goto_internal (label, label_rtx (label), NULL_RTX);\n-      return;\n-    }\n-\n   /* Check for a nonlocal goto to a containing function.  */\n   context = decl_function_context (label);\n   if (context != 0 && context != current_function_decl)\n@@ -813,16 +739,6 @@ expand_goto_internal (body, label, last_insn)\n   struct nesting *block;\n   rtx stack_level = 0;\n \n-  /* NOTICE!  If a bytecode instruction other than `jump' is needed,\n-     then the caller has to call bc_expand_goto_internal()\n-     directly. This is rather an exceptional case, and there aren't\n-     that many places where this is necessary.  */\n-  if (output_bytecode)\n-    {\n-      expand_goto_internal (body, label, last_insn);\n-      return;\n-    }\n-\n   if (GET_CODE (label) != CODE_LABEL)\n     abort ();\n \n@@ -876,78 +792,6 @@ expand_goto_internal (body, label, last_insn)\n   emit_jump (label);\n }\n \f\n-/* Generate a jump with OPCODE to the given bytecode LABEL which is\n-   found within BODY.  */\n-\n-static void\n-bc_expand_goto_internal (opcode, label, body)\n-     enum bytecode_opcode opcode;\n-     struct bc_label *label;\n-     tree body;\n-{\n-  struct nesting *block;\n-  int stack_level = -1;\n-\n-  /* If the label is defined, adjust the stack as necessary.\n-     If it's not defined, we have to push the reference on the\n-     fixup list.  */\n-\n-  if (label->defined)\n-    {\n-\n-      /* Find the innermost pending block that contains the label.\n-\t (Check containment by comparing bytecode uids.)  Then restore the\n-\t outermost stack level within that block.  */\n-\n-      for (block = block_stack; block; block = block->next)\n-\t{\n-\t  if (BYTECODE_BC_LABEL (block->data.block.first_insn)->uid < label->uid)\n-\t    break;\n-\t  if (block->data.block.bc_stack_level)\n-\t    stack_level = block->data.block.bc_stack_level;\n-\n-\t  /* Execute the cleanups for blocks we are exiting.  */\n-\t  if (block->data.block.cleanups != 0)\n-\t    {\n-\t      expand_cleanups (block->data.block.cleanups, NULL_TREE, 1, 1);\n-\t      do_pending_stack_adjust ();\n-\t    }\n-\t}\n-\n-      /* Restore the stack level. If we need to adjust the stack, we\n-\t must do so after the jump, since the jump may depend on\n-\t what's on the stack.  Thus, any stack-modifying conditional\n-\t jumps (these are the only ones that rely on what's on the\n-\t stack) go into the fixup list.  */\n-\n-      if (stack_level >= 0\n-\t  && stack_depth != stack_level\n-\t  && opcode != jump)\n-\n-\tbc_expand_fixup (opcode, label, stack_level);\n-      else\n-\t{\n-\t  if (stack_level >= 0)\n-\t    bc_adjust_stack (stack_depth - stack_level);\n-\n-\t  if (body && DECL_BIT_FIELD (body))\n-\t    error (\"jump to `%s' invalidly jumps into binding contour\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (body)));\n-\t  \n-\t  /* Emit immediate jump */\n-\t  bc_emit_bytecode (opcode);\n-\t  bc_emit_bytecode_labelref (label);\n-\t  \n-#ifdef DEBUG_PRINT_CODE\n-\t  fputc ('\\n', stderr);\n-#endif\n-\t}\n-    }\n-  else\n-    /* Put goto in the fixup list */\n-    bc_expand_fixup (opcode, label, stack_level);\n-}\n-\f\n /* Generate if necessary a fixup for a goto\n    whose target label in tree structure (if any) is TREE_LABEL\n    and whose target in rtl is RTL_LABEL.\n@@ -1076,34 +920,6 @@ expand_fixup (tree_label, rtl_label, last_insn)\n }\n \n \n-/* Generate bytecode jump with OPCODE to a fixup routine that links to LABEL.\n-   Make the fixup restore the stack level to STACK_LEVEL.  */\n-\n-static void\n-bc_expand_fixup (opcode, label, stack_level)\n-     enum bytecode_opcode opcode;\n-     struct bc_label *label;\n-     int stack_level;\n-{\n-  struct goto_fixup *fixup\n-    = (struct goto_fixup *) oballoc (sizeof (struct goto_fixup));\n-\n-  fixup->label  = bc_get_bytecode_label ();\n-  fixup->bc_target = label;\n-  fixup->bc_stack_level = stack_level;\n-  fixup->bc_handled = FALSE;\n-\n-  fixup->next = goto_fixup_chain;\n-  goto_fixup_chain = fixup;\n-\n-  /* Insert a jump to the fixup code */\n-  bc_emit_bytecode (opcode);\n-  bc_emit_bytecode_labelref (fixup->label);\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-}\n \f\n /* Expand any needed fixups in the outputmost binding level of the\n    function.  FIRST_INSN is the first insn in the function.  */\n@@ -1138,15 +954,6 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n {\n   register struct goto_fixup *f, *prev;\n \n-  if (output_bytecode)\n-    {\n-      /* ??? The second arg is the bc stack level, which is not the same\n-\t as STACK_LEVEL.  I have no idea what should go here, so I'll\n-\t just pass 0.  */\n-      bc_fixup_gotos (thisblock, 0, cleanup_list, first_insn, dont_jump_in);\n-      return;\n-    }\n-\n   /* F is the fixup we are considering; PREV is the previous one.  */\n   /* We run this loop in two passes so that cleanups of exited blocks\n      are run first, and blocks that are exited are marked so\n@@ -1295,70 +1102,6 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n }\n \n \n-/* When exiting a binding contour, process all pending gotos requiring fixups.\n-   Note: STACK_DEPTH is not altered.\n-\n-   The arguments are currently not used in the bytecode compiler, but we may\n-   need them one day for languages other than C.\n-\n-   THISBLOCK is the structure that describes the block being exited.\n-   STACK_LEVEL is the rtx for the stack level to restore exiting this contour.\n-   CLEANUP_LIST is a list of expressions to evaluate on exiting this contour.\n-   FIRST_INSN is the insn that began this contour.\n-\n-   Gotos that jump out of this contour must restore the\n-   stack level and do the cleanups before actually jumping.\n-\n-   DONT_JUMP_IN nonzero means report error there is a jump into this\n-   contour from before the beginning of the contour.\n-   This is also done if STACK_LEVEL is nonzero.  */\n-\n-static void\n-bc_fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n-     struct nesting *thisblock;\n-     int stack_level;\n-     tree cleanup_list;\n-     rtx first_insn;\n-     int dont_jump_in;\n-{\n-  register struct goto_fixup *f, *prev;\n-  int saved_stack_depth;\n-\n-  /* F is the fixup we are considering; PREV is the previous one.  */\n-\n-  for (prev = 0, f = goto_fixup_chain; f; prev = f, f = f->next)\n-    {\n-      /* Test for a fixup that is inactive because it is already handled.  */\n-      if (f->before_jump == 0)\n-\t{\n-\t  /* Delete inactive fixup from the chain, if that is easy to do.  */\n-\t  if (prev)\n-\t    prev->next = f->next;\n-\t}\n-\n-      /* Emit code to restore the stack and continue */\n-      bc_emit_bytecode_labeldef (f->label);\n-\n-      /* Save stack_depth across call, since bc_adjust_stack will alter\n-         the perceived stack depth via the instructions generated.  */\n-\n-      if (f->bc_stack_level >= 0)\n-\t{\n-\t  saved_stack_depth = stack_depth;\n-\t  bc_adjust_stack (stack_depth - f->bc_stack_level);\n-\t  stack_depth = saved_stack_depth;\n-\t}\n-\n-      bc_emit_bytecode (jump);\n-      bc_emit_bytecode_labelref (f->bc_target);\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-    }\n-\n-  goto_fixup_chain = NULL;\n-}\n \f\n /* Generate RTL for an asm statement (explicit assembler code).\n    BODY is a STRING_CST node containing the assembler code text,\n@@ -1368,12 +1111,6 @@ void\n expand_asm (body)\n      tree body;\n {\n-  if (output_bytecode)\n-    {\n-      error (\"`asm' is invalid when generating bytecode\");\n-      return;\n-    }\n-\n   if (flag_check_memory_usage)\n     {\n       error (\"`asm' cannot be used with `-fcheck-memory-usage'\");\n@@ -1430,12 +1167,6 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   if (noutputs == 0)\n     vol = 1;\n \n-  if (output_bytecode)\n-    {\n-      error (\"`asm' is invalid when generating bytecode\");\n-      return;\n-    }\n-\n   if (flag_check_memory_usage)\n     {\n       error (\"`asm' cannot be used with `-fcheck-memory-usage'\");\n@@ -1789,22 +1520,6 @@ void\n expand_expr_stmt (exp)\n      tree exp;\n {\n-  if (output_bytecode)\n-    {\n-      int org_stack_depth = stack_depth;\n-\n-      bc_expand_expr (exp);\n-\n-      /* Restore stack depth */\n-      if (stack_depth < org_stack_depth)\n-\tabort ();\n-      \n-      bc_emit_instruction (drop);\n-\n-      last_expr_type = TREE_TYPE (exp);\n-      return;\n-    }\n-\n   /* If -W, warn about statements with no side effects,\n      except for an explicit cast to void (e.g. for assert()), and\n      except inside a ({...}) where they may be useful.  */\n@@ -1982,10 +1697,6 @@ expand_start_stmt_expr ()\n   int momentary;\n   tree t;\n \n-  /* When generating bytecode just note down the stack depth */\n-  if (output_bytecode)\n-    return (build_int_2 (stack_depth, 0));\n-\n   /* Make the RTL_EXPR node temporary, not momentary,\n      so that rtl_expr_chain doesn't become garbage.  */\n   momentary = suspend_momentary ();\n@@ -2014,38 +1725,6 @@ tree\n expand_end_stmt_expr (t)\n      tree t;\n {\n-  if (output_bytecode)\n-    {\n-      int i;\n-      tree t;\n-      \n-      \n-      /* At this point, all expressions have been evaluated in order.\n-\t However, all expression values have been popped when evaluated,\n-\t which means we have to recover the last expression value.  This is\n-\t the last value removed by means of a `drop' instruction.  Instead\n-\t of adding code to inhibit dropping the last expression value, it\n-\t is here recovered by undoing the `drop'.  Since `drop' is\n-\t equivalent to `adjustackSI [1]', it can be undone with `adjstackSI\n-\t [-1]'.  */\n-      \n-      bc_adjust_stack (-1);\n-      \n-      if (!last_expr_type)\n-\tlast_expr_type = void_type_node;\n-      \n-      t = make_node (RTL_EXPR);\n-      TREE_TYPE (t) = last_expr_type;\n-      RTL_EXPR_RTL (t) = NULL;\n-      RTL_EXPR_SEQUENCE (t) = NULL;\n-      \n-      /* Don't consider deleting this expr or containing exprs at tree level.  */\n-      TREE_THIS_VOLATILE (t) = 1;\n-      \n-      last_expr_type = 0;\n-      return t;\n-    }\n-\n   OK_DEFER_POP;\n \n   if (last_expr_type == 0)\n@@ -2109,10 +1788,7 @@ expand_start_cond (cond, exitflag)\n   cond_stack = thiscond;\n   nesting_stack = thiscond;\n \n-  if (output_bytecode)\n-    bc_expand_start_cond (cond, exitflag);\n-  else\n-    do_jump (cond, thiscond->data.cond.next_label, NULL_RTX);\n+  do_jump (cond, thiscond->data.cond.next_label, NULL_RTX);\n }\n \n /* Generate RTL between then-clause and the elseif-clause\n@@ -2139,12 +1815,6 @@ expand_start_else ()\n   if (cond_stack->data.cond.endif_label == 0)\n     cond_stack->data.cond.endif_label = gen_label_rtx ();\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_start_else ();\n-      return;\n-    }\n-\n   emit_jump (cond_stack->data.cond.endif_label);\n   emit_label (cond_stack->data.cond.next_label);\n   cond_stack->data.cond.next_label = 0;  /* No more _else or _elseif calls.  */\n@@ -2169,76 +1839,17 @@ expand_end_cond ()\n {\n   struct nesting *thiscond = cond_stack;\n \n-  if (output_bytecode)\n-    bc_expand_end_cond ();\n-  else\n-    {\n-      do_pending_stack_adjust ();\n-      if (thiscond->data.cond.next_label)\n-\temit_label (thiscond->data.cond.next_label);\n-      if (thiscond->data.cond.endif_label)\n-\temit_label (thiscond->data.cond.endif_label);\n-    }\n+  do_pending_stack_adjust ();\n+  if (thiscond->data.cond.next_label)\n+    emit_label (thiscond->data.cond.next_label);\n+  if (thiscond->data.cond.endif_label)\n+    emit_label (thiscond->data.cond.endif_label);\n \n   POPSTACK (cond_stack);\n   last_expr_type = 0;\n }\n \n \n-/* Generate code for the start of an if-then.  COND is the expression\n-   whose truth is to be tested; if EXITFLAG is nonzero this conditional\n-   is to be visible to exit_something.  It is assumed that the caller\n-   has pushed the previous context on the cond stack.  */\n-\n-static void\n-bc_expand_start_cond (cond, exitflag)\n-     tree cond;\n-     int exitflag;\n-{\n-  struct nesting *thiscond = cond_stack;\n-\n-  thiscond->data.case_stmt.nominal_type = cond;\n-  if (! exitflag)\n-    thiscond->exit_label = gen_label_rtx ();\n-  bc_expand_expr (cond);\n-  bc_emit_bytecode (xjumpifnot);\n-  bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (thiscond->exit_label));\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-}\n-\n-/* Generate the label for the end of an if with\n-   no else- clause.  */\n-\n-static void\n-bc_expand_end_cond ()\n-{\n-  struct nesting *thiscond = cond_stack;\n-\n-  bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thiscond->exit_label));\n-}\n-\n-/* Generate code for the start of the else- clause of\n-   an if-then-else.  */\n-\n-static void\n-bc_expand_start_else ()\n-{\n-  struct nesting *thiscond = cond_stack;\n-\n-  thiscond->data.cond.endif_label = thiscond->exit_label;\n-  thiscond->exit_label = gen_label_rtx ();\n-  bc_emit_bytecode (jump);\n-  bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (thiscond->exit_label));\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-\n-  bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thiscond->data.cond.endif_label));\n-}\n \f\n /* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this\n    loop should be exited by `exit_something'.  This is a loop for which\n@@ -2266,12 +1877,6 @@ expand_start_loop (exit_flag)\n   loop_stack = thisloop;\n   nesting_stack = thisloop;\n \n-  if (output_bytecode)\n-    {\n-      bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thisloop->data.loop.start_label));\n-      return thisloop;\n-    }\n-\n   do_pending_stack_adjust ();\n   emit_queue ();\n   emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n@@ -2300,36 +1905,11 @@ expand_start_loop_continue_elsewhere (exit_flag)\n void\n expand_loop_continue_here ()\n {\n-  if (output_bytecode)\n-    {\n-      bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (loop_stack->data.loop.continue_label));\n-      return;\n-    }\n   do_pending_stack_adjust ();\n   emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n   emit_label (loop_stack->data.loop.continue_label);\n }\n \n-/* End a loop.  */\n-\n-static void\n-bc_expand_end_loop ()\n-{\n-  struct nesting *thisloop = loop_stack;\n-\n-  bc_emit_bytecode (jump);\n-  bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (thisloop->data.loop.start_label));\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-\n-  bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thisloop->exit_label));\n-  POPSTACK (loop_stack);\n-  last_expr_type = 0;\n-}\n-\n-\n /* Finish a loop.  Generate a jump back to the top and the loop-exit label.\n    Pop the block off of loop_stack.  */\n \n@@ -2341,12 +1921,6 @@ expand_end_loop ()\n   rtx last_test_insn = 0;\n   int num_insns = 0;\n     \n-  if (output_bytecode)\n-    {\n-      bc_expand_end_loop ();\n-      return;\n-    }\n-\n   insn = get_last_insn ();\n   start_label = loop_stack->data.loop.start_label;\n \n@@ -2497,35 +2071,26 @@ expand_exit_loop_if_false (whichloop, cond)\n      struct nesting *whichloop;\n      tree cond;\n {\n+  rtx label = gen_label_rtx ();\n+  rtx last_insn;\n   last_expr_type = 0;\n+\n   if (whichloop == 0)\n     whichloop = loop_stack;\n   if (whichloop == 0)\n     return 0;\n-  if (output_bytecode)\n-    {\n-      bc_expand_expr (cond);\n-      bc_expand_goto_internal (xjumpifnot,\n-\t\t\t       BYTECODE_BC_LABEL (whichloop->exit_label),\n-\t\t\t       NULL_TREE);\n-    }\n-  else\n-    {\n-      /* In order to handle fixups, we actually create a conditional jump\n-\t around a unconditional branch to exit the loop.  If fixups are\n-\t necessary, they go before the unconditional branch.  */\n+  /* In order to handle fixups, we actually create a conditional jump\n+     around a unconditional branch to exit the loop.  If fixups are\n+     necessary, they go before the unconditional branch.  */\n \n-      rtx label = gen_label_rtx ();\n-      rtx last_insn;\n-\n-      do_jump (cond, NULL_RTX, label);\n-      last_insn = get_last_insn ();\n-      if (GET_CODE (last_insn) == CODE_LABEL)\n-\twhichloop->data.loop.alt_end_label = last_insn;\n-      expand_goto_internal (NULL_TREE, whichloop->data.loop.end_label,\n-\t\t\t    NULL_RTX);\n-      emit_label (label);\n-    }\n+\n+  do_jump (cond, NULL_RTX, label);\n+  last_insn = get_last_insn ();\n+  if (GET_CODE (last_insn) == CODE_LABEL)\n+    whichloop->data.loop.alt_end_label = last_insn;\n+  expand_goto_internal (NULL_TREE, whichloop->data.loop.end_label,\n+\t\t\tNULL_RTX);\n+  emit_label (label);\n \n   return 1;\n }\n@@ -2589,12 +2154,6 @@ expand_null_return ()\n   struct nesting *block = block_stack;\n   rtx last_insn = 0;\n \n-  if (output_bytecode)\n-    {\n-      bc_emit_instruction (ret);\n-      return;\n-    }\n-\n   /* Does any pending block have cleanups?  */\n \n   while (block && block->data.block.cleanups == 0)\n@@ -2726,15 +2285,6 @@ expand_return (retval)\n   int cleanups;\n   struct nesting *block;\n \n-  /* Bytecode returns are quite simple, just leave the result on the\n-     arithmetic stack.  */\n-  if (output_bytecode)\n-    {\n-      bc_expand_expr (retval);\n-      bc_emit_instruction (ret);\n-      return;\n-    }\n-  \n   /* If function wants no value, give it none.  */\n   if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n     {\n@@ -3110,7 +2660,7 @@ expand_start_bindings (exit_flag)\n      int exit_flag;\n {\n   struct nesting *thisblock = ALLOC_NESTING ();\n-  rtx note = output_bytecode ? 0 : emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n+  rtx note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n \n   /* Make an entry on block_stack for the block we are entering.  */\n \n@@ -3143,11 +2693,8 @@ expand_start_bindings (exit_flag)\n   block_stack = thisblock;\n   nesting_stack = thisblock;\n \n-  if (!output_bytecode)\n-    {\n-      /* Make a new level for allocating stack slots.  */\n-      push_temp_slots ();\n-    }\n+  /* Make a new level for allocating stack slots.  */\n+  push_temp_slots ();\n }\n \n /* Specify the scope of temporaries created by TARGET_EXPRs.  Similar\n@@ -3278,12 +2825,6 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       expand_end_bindings (NULL_TREE, 0, 0);\n     }\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_end_bindings (vars, mark_ends, dont_jump_in);\n-      return;\n-    }\n-\n   /* Since expand_eh_region_start does an expand_start_bindings, we\n      have to first end all the bindings that were created by\n      expand_eh_region_start.  */\n@@ -3529,33 +3070,6 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n }\n \n \n-/* End a binding contour.\n-   VARS is the chain of VAR_DECL nodes for the variables bound\n-   in this contour.  MARK_ENDS is nonzer if we should put a note\n-   at the beginning and end of this binding contour.\n-   DONT_JUMP_IN is nonzero if it is not valid to jump into this\n-   contour.  */\n-\n-static void\n-bc_expand_end_bindings (vars, mark_ends, dont_jump_in)\n-     tree vars;\n-     int mark_ends;\n-     int dont_jump_in;\n-{\n-  struct nesting *thisbind = nesting_stack;\n-  tree decl;\n-\n-  if (warn_unused)\n-    for (decl = vars; decl; decl = TREE_CHAIN (decl))\n-      if (! TREE_USED (TREE_VALUE (decl)) && TREE_CODE (TREE_VALUE (decl)) == VAR_DECL)\n-\twarning_with_decl (decl, \"unused variable `%s'\");\n-\n-  if (thisbind->exit_label)\n-    bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thisbind->exit_label));\n-\n-  /* Pop block/bindings off stack */\n-  POPSTACK (block_stack);\n-}\n \f\n /* Generate RTL for the automatic variable declaration DECL.\n    (Other kinds of declarations are simply ignored if seen here.)  */\n@@ -3567,12 +3081,6 @@ expand_decl (decl)\n   struct nesting *thisblock = block_stack;\n   tree type;\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_decl (decl, 0);\n-      return;\n-    }\n-\n   type = TREE_TYPE (decl);\n \n   /* Only automatic variables need any expansion done.\n@@ -3742,50 +3250,6 @@ expand_decl (decl)\n }\n \n \n-/* Generate code for the automatic variable declaration DECL.  For\n-   most variables this just means we give it a stack offset.  The\n-   compiler sometimes emits cleanups without variables and we will\n-   have to deal with those too.  */\n-\n-static void\n-bc_expand_decl (decl, cleanup)\n-     tree decl;\n-     tree cleanup;\n-{\n-  tree type;\n-\n-  if (!decl)\n-    {\n-      /* A cleanup with no variable.  */\n-      if (!cleanup)\n-\tabort ();\n-\n-      return;\n-    }\n-\n-  /* Only auto variables need any work.  */\n-  if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n-    return;\n-\n-  type = TREE_TYPE (decl);\n-\n-  if (type == error_mark_node)\n-    DECL_RTL (decl) = bc_gen_rtx ((char *) 0, 0, (struct bc_label *) 0);\n-\n-  else if (DECL_SIZE (decl) == 0)\n-\n-    /* Variable with incomplete type.  The stack offset herein will be\n-       fixed later in expand_decl_init.  */\n-    DECL_RTL (decl) = bc_gen_rtx ((char *) 0, 0, (struct bc_label *) 0);\n-\n-  else if (TREE_CONSTANT (DECL_SIZE (decl)))\n-    {\n-      DECL_RTL (decl) = bc_allocate_local (TREE_INT_CST_LOW (DECL_SIZE (decl)) / BITS_PER_UNIT,\n-\t\t\t\t\t   DECL_ALIGN (decl));\n-    }\n-  else\n-    DECL_RTL (decl) = bc_allocate_variable_array (DECL_SIZE (decl));\n-}\n \f\n /* Emit code to perform the initialization of a declaration DECL.  */\n \n@@ -3795,12 +3259,6 @@ expand_decl_init (decl)\n {\n   int was_used = TREE_USED (decl);\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_decl_init (decl);\n-      return;\n-    }\n-\n   /* If this is a CONST_DECL, we don't have to generate any code, but\n      if DECL_INITIAL is a constant, call expand_expr to force TREE_CST_RTL\n      to be set while in the obstack containing the constant.  If we don't\n@@ -3844,83 +3302,6 @@ expand_decl_init (decl)\n   free_temp_slots ();\n }\n \n-/* Expand initialization for variable-sized types. Allocate array\n-   using newlocalSI and set local variable, which is a pointer to the\n-   storage.  */\n-\n-static void\n-bc_expand_variable_local_init (decl)\n-     tree decl;\n-{\n-  /* Evaluate size expression and coerce to SI */\n-  bc_expand_expr (DECL_SIZE (decl));\n-\n-  /* Type sizes are always (?) of TREE_CODE INTEGER_CST, so\n-     no coercion is necessary (?) */\n-\n-/*  emit_typecode_conversion (preferred_typecode (TYPE_MODE (DECL_SIZE (decl)),\n-\t\t\t\t\t\tTREE_UNSIGNED (DECL_SIZE (decl))), SIcode); */\n-\n-  /* Emit code to allocate array */\n-  bc_emit_instruction (newlocalSI);\n-\n-  /* Store array pointer in local variable. This is the only instance\n-     where we actually want the address of the pointer to the\n-     variable-size block, rather than the pointer itself.  We avoid\n-     using expand_address() since that would cause the pointer to be\n-     pushed rather than its address. Hence the hard-coded reference;\n-     notice also that the variable is always local (no global\n-     variable-size type variables).  */\n-\n-  bc_load_localaddr (DECL_RTL (decl));\n-  bc_emit_instruction (storeP);\n-}\n-\n-\n-/* Emit code to initialize a declaration.  */\n-\n-static void\n-bc_expand_decl_init (decl)\n-     tree decl;\n-{\n-  int org_stack_depth;\n-\n-  /* Statical initializers are handled elsewhere */\n-\n-  if (TREE_STATIC (decl))\n-    return;\n-\n-  /* Memory original stack depth */\n-  org_stack_depth = stack_depth;\n-\n-  /* If the type is variable-size, we first create its space (we ASSUME\n-     it CAN'T be static).  We do this regardless of whether there's an\n-     initializer assignment or not.  */\n-\n-  if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n-    bc_expand_variable_local_init (decl);\n-\n-  /* Expand initializer assignment */\n-  if (DECL_INITIAL (decl) == error_mark_node)\n-    {\n-      enum tree_code code = TREE_CODE (TREE_TYPE (decl));\n-\n-      if (code == INTEGER_TYPE || code == REAL_TYPE || code == ENUMERAL_TYPE\n-\t  || code == POINTER_TYPE)\n-\n-\texpand_assignment (TREE_TYPE (decl), decl, 0, 0);\n-    }\n-  else if (DECL_INITIAL (decl))\n-    expand_assignment (TREE_TYPE (decl), decl, 0, 0);\n-\n-  /* Restore stack depth */\n-  if (org_stack_depth > stack_depth)\n-    abort ();\n-\n-  bc_adjust_stack (stack_depth - org_stack_depth);\n-}\n- \n-\n /* CLEANUP is an expression to be executed at exit from this binding contour;\n    for example, in C++, it might call the destructor for this variable.\n \n@@ -4383,12 +3764,6 @@ expand_start_case (exit_flag, expr, type, printname)\n   case_stack = thiscase;\n   nesting_stack = thiscase;\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_start_case (thiscase, expr, type, printname);\n-      return;\n-    }\n-\n   do_pending_stack_adjust ();\n \n   /* Make sure case_stmt.start points to something that won't\n@@ -4402,32 +3777,6 @@ expand_start_case (exit_flag, expr, type, printname)\n }\n \n \n-/* Enter a case statement. It is assumed that the caller has pushed\n-   the current context onto the case stack.  */\n-\n-static void\n-bc_expand_start_case (thiscase, expr, type, printname)\n-     struct nesting *thiscase;\n-     tree expr;\n-     tree type;\n-     char *printname;\n-{\n-  bc_expand_expr (expr);\n-  bc_expand_conversion (TREE_TYPE (expr), type);\n-\n-  /* For cases, the skip is a place we jump to that's emitted after\n-     the size of the jump table is known.  */\n-\n-  thiscase->data.case_stmt.skip_label = gen_label_rtx ();\n-  bc_emit_bytecode (jump);\n-  bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (thiscase->data.case_stmt.skip_label));\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-}\n-\n-\n /* Start a \"dummy case statement\" within which case labels are invalid\n    and are not connected to any larger real case statement.\n    This can be used if you don't want to let a case statement jump\n@@ -4501,9 +3850,6 @@ pushcase (value, converter, label, duplicate)\n   tree index_type;\n   tree nominal_type;\n \n-  if (output_bytecode)\n-    return bc_pushcase (value, label);\n-\n   /* Fail if not inside a real case statement.  */\n   if (! (case_stack && case_stack->data.case_stmt.start))\n     return 1;\n@@ -4886,60 +4232,6 @@ add_case_node (low, high, label, duplicate)\n   return 0;\n }\n \n-/* Accumulate one case or default label; VALUE is the value of the\n-   case, or nil for a default label.  If not currently inside a case,\n-   return 1 and do nothing.  If VALUE is a duplicate or overlaps, return\n-   2 and do nothing.  If VALUE is out of range, return 3 and do nothing.\n-   Return 0 on success.  This function is a leftover from the earlier\n-   bytecode compiler, which was based on gcc 1.37.  It should be\n-   merged into pushcase.  */\n-\n-static int\n-bc_pushcase (value, label)\n-     tree value;\n-     tree label;\n-{\n-  struct nesting *thiscase = case_stack;\n-  struct case_node *case_label, *new_label;\n-\n-  if (! thiscase)\n-    return 1;\n-\n-  /* Fail if duplicate, overlap, or out of type range.  */\n-  if (value)\n-    {\n-      value = convert (thiscase->data.case_stmt.nominal_type, value);\n-      if (! int_fits_type_p (value, thiscase->data.case_stmt.nominal_type))\n-\treturn 3;\n-\n-      for (case_label = thiscase->data.case_stmt.case_list;\n-\t   case_label->left; case_label = case_label->left)\n-\tif (! tree_int_cst_lt (case_label->left->high, value))\n-\t  break;\n-\n-      if (case_label != thiscase->data.case_stmt.case_list\n-\t  && ! tree_int_cst_lt (case_label->high, value)\n-\t  || (case_label->left && ! tree_int_cst_lt (value, case_label->left->low)))\n-\treturn 2;\n-\n-      new_label = (struct case_node *) oballoc (sizeof (struct case_node));\n-      new_label->low = new_label->high = copy_node (value);\n-      new_label->code_label = label;\n-      new_label->left = case_label->left;\n-\n-      case_label->left = new_label;\n-      thiscase->data.case_stmt.num_ranges++;\n-    }\n-  else\n-    {\n-      if (thiscase->data.case_stmt.default_label)\n-\treturn 2;\n-      thiscase->data.case_stmt.default_label = label;\n-    }\n-\n-  expand_label (label);\n-  return 0;\n-}\n \f\n /* Returns the number of possible values of TYPE.\n    Returns -1 if the number is unknown or variable.\n@@ -5190,12 +4482,6 @@ check_for_full_enumeration_handling (type)\n   long bytes_needed;\n   tree t;\n \n-  if (output_bytecode)\n-    {\n-      bc_check_for_full_enumeration_handling (type);\n-      return;\n-    }\n-\n   if (! warn_switch)\n     return;\n \n@@ -5303,46 +4589,6 @@ check_for_full_enumeration_handling (type)\n #endif /* 0 */\n }\n \n-\n-/* Check that all enumeration literals are covered by the case\n-   expressions of a switch.  Also warn if there are any cases\n-   that are not elements of the enumerated type.  */\n-\n-static void\n-bc_check_for_full_enumeration_handling (type)\n-     tree type;\n-{\n-  struct nesting *thiscase = case_stack;\n-  struct case_node *c;\n-  tree e;\n-\n-  /* Check for enums not handled.  */\n-  for (e = TYPE_VALUES (type); e; e = TREE_CHAIN (e))\n-    {\n-      for (c = thiscase->data.case_stmt.case_list->left;\n-\t   c && tree_int_cst_lt (c->high, TREE_VALUE (e));\n-\t   c = c->left)\n-\t;\n-      if (! (c && tree_int_cst_equal (c->low, TREE_VALUE (e))))\n-\twarning (\"enumerated value `%s' not handled in switch\",\n-\t\t IDENTIFIER_POINTER (TREE_PURPOSE (e)));\n-    }\n-\n-  /* Check for cases not in the enumeration.  */\n-  for (c = thiscase->data.case_stmt.case_list->left; c; c = c->left)\n-    {\n-      for (e = TYPE_VALUES (type);\n-\t   e && !tree_int_cst_equal (c->low, TREE_VALUE (e));\n-\t   e = TREE_CHAIN (e))\n-\t;\n-      if (! e)\n-\twarning (\"case value `%d' not in enumerated type `%s'\",\n-\t\t TREE_INT_CST_LOW (c->low),\n-\t\t IDENTIFIER_POINTER (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE\n-\t\t\t\t     ? TYPE_NAME (type)\n-\t\t\t\t     : DECL_NAME (TYPE_NAME (type))));\n-    }\n-}\n \f\n /* Terminate a case (Pascal) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n@@ -5366,12 +4612,6 @@ expand_end_case (orig_index)\n   tree index_expr, index_type;\n   int unsignedp;\n \n-  if (output_bytecode)\n-    {\n-      bc_expand_end_case (orig_index);\n-      return;\n-    }\n-\n   table_label = gen_label_rtx ();\n   index_expr = thiscase->data.case_stmt.index_expr;\n   index_type = TREE_TYPE (index_expr);\n@@ -5764,110 +5004,6 @@ case_tree2list (node, right)\n   return node;\n }\n \n-/* Terminate a case statement.  EXPR is the original index\n-   expression.  */\n-\n-static void\n-bc_expand_end_case (expr)\n-     tree expr;\n-{\n-  struct nesting *thiscase = case_stack;\n-  enum bytecode_opcode opcode;\n-  struct bc_label *jump_label;\n-  struct case_node *c;\n-\n-  bc_emit_bytecode (jump);\n-  bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (thiscase->exit_label));\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-\n-  /* Now that the size of the jump table is known, emit the actual\n-     indexed jump instruction.  */\n-  bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thiscase->data.case_stmt.skip_label));\n-\n-  opcode = TYPE_MODE (thiscase->data.case_stmt.nominal_type) == SImode\n-    ? TREE_UNSIGNED (thiscase->data.case_stmt.nominal_type) ? caseSU : caseSI\n-      : TREE_UNSIGNED (thiscase->data.case_stmt.nominal_type) ? caseDU : caseDI;\n-\n-  bc_emit_bytecode (opcode);\n-\n-  /* Now emit the case instructions literal arguments, in order.\n-     In addition to the value on the stack, it uses:\n-     1.  The address of the jump table.\n-     2.  The size of the jump table.\n-     3.  The default label.  */\n-\n-  jump_label = bc_get_bytecode_label ();\n-  bc_emit_bytecode_labelref (jump_label);\n-  bc_emit_bytecode_const ((char *) &thiscase->data.case_stmt.num_ranges,\n-\t\t\t  sizeof thiscase->data.case_stmt.num_ranges);\n-\n-  if (thiscase->data.case_stmt.default_label)\n-    bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (DECL_RTL (thiscase->data.case_stmt.default_label)));\n-  else\n-    bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (thiscase->exit_label));\n-\n-  /* Output the jump table.  */\n-\n-  bc_align_bytecode (3 /* PTR_ALIGN */);\n-  bc_emit_bytecode_labeldef (jump_label);\n-\n-  if (TYPE_MODE (thiscase->data.case_stmt.nominal_type) == SImode)\n-    for (c = thiscase->data.case_stmt.case_list->left; c; c = c->left)\n-      {\n-\topcode = TREE_INT_CST_LOW (c->low);\n-\tbc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\n-\n-\topcode = TREE_INT_CST_LOW (c->high);\n-\tbc_emit_bytecode_const ((char *) &opcode, sizeof opcode);\n-\n-\tbc_emit_bytecode_labelref (BYTECODE_BC_LABEL (DECL_RTL (c->code_label)));\n-      }\n-  else\n-    if (TYPE_MODE (thiscase->data.case_stmt.nominal_type) == DImode)\n-      for (c = thiscase->data.case_stmt.case_list->left; c; c = c->left)\n-\t{\n-\t  bc_emit_bytecode_DI_const (c->low);\n-\t  bc_emit_bytecode_DI_const (c->high);\n-\n-\t  bc_emit_bytecode_labelref (BYTECODE_BC_LABEL (DECL_RTL (c->code_label)));\n-\t}\n-    else\n-      /* Bad mode */\n-      abort ();\n-\n-    \n-  bc_emit_bytecode_labeldef (BYTECODE_BC_LABEL (thiscase->exit_label));\n-\n-  /* Possibly issue enumeration warnings.  */\n-\n-  if (!thiscase->data.case_stmt.default_label\n-      && TREE_CODE (TREE_TYPE (expr)) == ENUMERAL_TYPE\n-      && TREE_CODE (expr) != INTEGER_CST\n-      && warn_switch)\n-    check_for_full_enumeration_handling (TREE_TYPE (expr));\n-\n-\n-#ifdef DEBUG_PRINT_CODE\n-  fputc ('\\n', stderr);\n-#endif\n-\n-  POPSTACK (case_stack);\n-}\n-\n-\n-/* Return unique bytecode ID.  */\n-\n-int \n-bc_new_uid ()\n-{\n-  static int bc_uid = 0;\n-\n-  return (++bc_uid);\n-}\n-\n /* Generate code to jump to LABEL if OP1 and OP2 are equal.  */\n \n static void"}, {"sha": "8387300668929b46f1fd05ecd4b50574b113a39d", "filename": "gcc/toplev.c", "status": "modified", "additions": 53, "deletions": 107, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -72,8 +72,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"defaults.h\"\n #include \"output.h\"\n-#include \"bytecode.h\"\n-#include \"bc-emit.h\"\n #include \"except.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n@@ -306,9 +304,6 @@ int errorcount = 0;\n int warningcount = 0;\n int sorrycount = 0;\n \n-/* Flag to output bytecode instead of native assembler */\n-int output_bytecode = 0;\n-\n /* Pointer to function to compute the name to use to print a declaration.\n    DECL is the declaration in question.\n    VERBOSITY determines what information will be printed:\n@@ -751,7 +746,6 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"regmove\", &flag_regmove, 1},\n   {\"pack-struct\", &flag_pack_struct, 1},\n   {\"stack-check\", &flag_stack_check, 1},\n-  {\"bytecode\", &output_bytecode, 1},\n   {\"argument-alias\", &flag_argument_noalias, 0},\n   {\"argument-noalias\", &flag_argument_noalias, 1},\n   {\"argument-noalias-global\", &flag_argument_noalias, 2},\n@@ -1111,11 +1105,8 @@ fatal_insn (message, insn)\n      char *message;\n      rtx insn;\n {\n-  if (!output_bytecode)\n-    {\n-      error (message);\n-      debug_rtx (insn);\n-    }\n+  error (message);\n+  debug_rtx (insn);\n   if (asm_out_file)\n     fflush (asm_out_file);\n   if (aux_info_file)\n@@ -2262,8 +2253,6 @@ compile_file (name)\n #else\n   init_lex ();\n #endif\n-  /* Some of these really don't need to be called when generating bytecode,\n-     but the options would have to be parsed first to know that. -bson */\n   init_rtl ();\n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n@@ -2431,36 +2420,27 @@ compile_file (name)\n   if (main_input_filename == 0)\n     main_input_filename = name;\n \n-  if (!output_bytecode)\n-    {\n-      ASM_FILE_START (asm_out_file);\n+  ASM_FILE_START (asm_out_file);\n \n #ifdef ASM_COMMENT_START\n-      if (flag_verbose_asm)\n-\t{\n-\t  /* Print the list of options in effect.  */\n-\t  print_version (asm_out_file, ASM_COMMENT_START);\n-\t  print_switch_values (asm_out_file, 0, MAX_LINE,\n+  if (flag_verbose_asm)\n+    {\n+      /* Print the list of options in effect.  */\n+      print_version (asm_out_file, ASM_COMMENT_START);\n+      print_switch_values (asm_out_file, 0, MAX_LINE,\n \t\t\t       ASM_COMMENT_START, \" \", \"\\n\");\n-\t  /* Add a blank line here so it appears in assembler output but not\n-\t     screen output.  */\n-\t  fprintf (asm_out_file, \"\\n\");\n-\t}\n-#endif\n+      /* Add a blank line here so it appears in assembler output but not\n+\t screen output.  */\n+      fprintf (asm_out_file, \"\\n\");\n     }\n+#endif\n \n-  /* Output something to inform GDB that this compilation was by GCC.  Also\n-     serves to tell GDB file consists of bytecodes.  */\n-  if (output_bytecode)\n-    fprintf (asm_out_file, \"bc_gcc2_compiled.:\\n\");\n-  else\n-    {\n+  /* Output something to inform GDB that this compilation was by GCC.  */\n #ifndef ASM_IDENTIFY_GCC\n-      fprintf (asm_out_file, \"gcc2_compiled.:\\n\");\n+  fprintf (asm_out_file, \"gcc2_compiled.:\\n\");\n #else\n-      ASM_IDENTIFY_GCC (asm_out_file);\n+  ASM_IDENTIFY_GCC (asm_out_file);\n #endif\n-    }\n \n   /* Output something to identify which front-end produced this file.  */\n #ifdef ASM_IDENTIFY_LANGUAGE\n@@ -2485,28 +2465,20 @@ compile_file (name)\n   if (flag_function_sections && write_symbols != NO_DEBUG)\n     warning (\"-ffunction-sections may affect debugging on some targets.\");\n \n-  if (output_bytecode)\n-    {\n-      if (profile_flag || profile_block_flag)\n-\terror (\"profiling not supported in bytecode compilation\");\n-    }\n-  else\n-    {\n-      /* ??? Note: There used to be a conditional here\n-\t to call assemble_zeros without fail if DBX_DEBUGGING_INFO is defined.\n-\t This was to guarantee separation between gcc_compiled. and\n-\t the first function, for the sake of dbx on Suns.\n-\t However, having the extra zero here confused the Emacs\n-\t code for unexec, and might confuse other programs too.\n-\t Therefore, I took out that change.\n-\t In future versions we should find another way to solve\n-\t that dbx problem.  -- rms, 23 May 93.  */\n+  /* ??? Note: There used to be a conditional here\n+      to call assemble_zeros without fail if DBX_DEBUGGING_INFO is defined.\n+      This was to guarantee separation between gcc_compiled. and\n+      the first function, for the sake of dbx on Suns.\n+      However, having the extra zero here confused the Emacs\n+      code for unexec, and might confuse other programs too.\n+      Therefore, I took out that change.\n+      In future versions we should find another way to solve\n+      that dbx problem.  -- rms, 23 May 93.  */\n       \n-      /* Don't let the first function fall at the same address\n-\t as gcc_compiled., if profiling.  */\n-      if (profile_flag || profile_block_flag)\n-\tassemble_zeros (UNITS_PER_WORD);\n-    }\n+  /* Don't let the first function fall at the same address\n+     as gcc_compiled., if profiling.  */\n+  if (profile_flag || profile_block_flag)\n+    assemble_zeros (UNITS_PER_WORD);\n \n   /* If dbx symbol table desired, initialize writing it\n      and output the predefined types.  */\n@@ -2535,8 +2507,7 @@ compile_file (name)\n \n   /* Initialize yet another pass.  */\n \n-  if (!output_bytecode)\n-    init_final (main_input_filename);\n+  init_final (main_input_filename);\n   init_branch_prob (dump_base_name);\n \n   start_time = get_run_time ();\n@@ -2792,23 +2763,17 @@ compile_file (name)\n \n   /* Output some stuff at end of file if nec.  */\n \n-  if (!output_bytecode)\n-    {\n-      end_final (dump_base_name);\n-      end_branch_prob (branch_prob_dump_file);\n+  end_final (dump_base_name);\n+  end_branch_prob (branch_prob_dump_file);\n \n #ifdef ASM_FILE_END\n-      ASM_FILE_END (asm_out_file);\n+  ASM_FILE_END (asm_out_file);\n #endif\n-    }\n \n   /* Language-specific end of compilation actions.  */\n \n   lang_finish ();\n \n-  if (output_bytecode)\n-    bc_write_file (asm_out_file);\n-\n   /* Close the dump files.  */\n \n   if (flag_gen_aux_info)\n@@ -2893,29 +2858,26 @@ compile_file (name)\n       fprintf (stderr,\"\\n\");\n       print_time (\"parse\", parse_time);\n \n-      if (!output_bytecode)\n-\t{\n-\t  print_time (\"integration\", integration_time);\n-\t  print_time (\"jump\", jump_time);\n-\t  print_time (\"cse\", cse_time);\n-\t  print_time (\"loop\", loop_time);\n-\t  print_time (\"cse2\", cse2_time);\n-\t  print_time (\"branch-prob\", branch_prob_time);\n-\t  print_time (\"flow\", flow_time);\n-\t  print_time (\"combine\", combine_time);\n-\t  print_time (\"regmove\", regmove_time);\n-\t  print_time (\"sched\", sched_time);\n-\t  print_time (\"local-alloc\", local_alloc_time);\n-\t  print_time (\"global-alloc\", global_alloc_time);\n-\t  print_time (\"sched2\", sched2_time);\n-\t  print_time (\"dbranch\", dbr_sched_time);\n-\t  print_time (\"shorten-branch\", shorten_branch_time);\n-\t  print_time (\"stack-reg\", stack_reg_time);\n-\t  print_time (\"final\", final_time);\n-\t  print_time (\"varconst\", varconst_time);\n-\t  print_time (\"symout\", symout_time);\n-\t  print_time (\"dump\", dump_time);\n-\t}\n+      print_time (\"integration\", integration_time);\n+      print_time (\"jump\", jump_time);\n+      print_time (\"cse\", cse_time);\n+      print_time (\"loop\", loop_time);\n+      print_time (\"cse2\", cse2_time);\n+      print_time (\"branch-prob\", branch_prob_time);\n+      print_time (\"flow\", flow_time);\n+      print_time (\"combine\", combine_time);\n+      print_time (\"regmove\", regmove_time);\n+      print_time (\"sched\", sched_time);\n+      print_time (\"local-alloc\", local_alloc_time);\n+      print_time (\"global-alloc\", global_alloc_time);\n+      print_time (\"sched2\", sched2_time);\n+      print_time (\"dbranch\", dbr_sched_time);\n+      print_time (\"shorten-branch\", shorten_branch_time);\n+      print_time (\"stack-reg\", stack_reg_time);\n+      print_time (\"final\", final_time);\n+      print_time (\"varconst\", varconst_time);\n+      print_time (\"symout\", symout_time);\n+      print_time (\"dump\", dump_time);\n     }\n }\n \f\n@@ -2966,8 +2928,7 @@ rest_of_decl_compilation (decl, asmspec, top_level, at_end)\n \t\t\t&& (DECL_INITIAL (decl) == 0\n \t\t\t    || DECL_INITIAL (decl) == error_mark_node)))\n \t\t   assemble_variable (decl, top_level, at_end, 0);\n-\t       if (!output_bytecode\n-\t\t   && decl == last_assemble_variable_decl)\n+\t       if (decl == last_assemble_variable_decl)\n \t\t {\n \t\t   ASM_FINISH_DECLARE_OBJECT (asm_out_file, decl,\n \t\t\t\t\t      top_level, at_end);\n@@ -3033,9 +2994,6 @@ rest_of_compilation (decl)\n   tree saved_arguments = 0;\n   int failure = 0;\n \n-  if (output_bytecode)\n-    return;\n-\n   /* If we are reconsidering an inline function\n      at the end of compilation, skip the stuff for making it inline.  */\n \n@@ -4392,18 +4350,6 @@ main (argc, argv, envp)\n   if (flag_check_memory_usage)\n     flag_omit_frame_pointer = 0;\n \n-  /* Initialize for bytecode output.  A good idea to do this as soon as\n-     possible after the \"-f\" options have been parsed.  */\n-  if (output_bytecode)\n-    {\n-#ifndef TARGET_SUPPORTS_BYTECODE\n-      /* Just die with a fatal error if not supported */\n-      fatal (\"-fbytecode not supported for this target\");\n-#else\n-      bc_initialize ();\n-#endif\n-    }\n-\n   if (optimize == 0)\n     {\n       /* Inlining does not work if not optimizing,"}, {"sha": "6a5f5e2078f034a3e859724fb749df1dd401b216", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -1964,8 +1964,6 @@ extern tree reorder_blocks\t\tPROTO ((tree *, tree,\n extern void free_temps_for_rtl_expr\tPROTO ((tree));\n extern void instantiate_virtual_regs\tPROTO ((tree, struct rtx_def *));\n extern int max_parm_reg_num\t\tPROTO ((void));\n-extern void bc_expand_function_start\tPROTO ((tree, int));\n-extern void bc_expand_function_end\tPROTO ((void));\n extern void push_function_context\tPROTO ((void));\n extern void pop_function_context\tPROTO ((void));\n extern void push_function_context_to\tPROTO ((tree));\n@@ -1987,8 +1985,6 @@ extern void indent_to\t\t\tPROTO ((FILE *, int));\n /* In expr.c */\n extern void emit_queue\t\t\t\tPROTO ((void));\n extern int apply_args_register_offset\t\tPROTO ((int));\n-extern char * bc_gen_constr_label\t\tPROTO ((void));\n-extern struct rtx_def *bc_allocate_variable_array PROTO ((tree));\n extern struct rtx_def *expand_builtin_return_addr\n \tPROTO ((enum built_in_function, int, struct rtx_def *));\n extern void do_pending_stack_adjust\t\tPROTO ((void));"}, {"sha": "d7f0605c146bdf6a723d0d4a80108562a9779b0d", "filename": "gcc/varasm.c", "status": "modified", "additions": 52, "deletions": 415, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b93a436e6b93d31a9523e4b058edc2f1d5d8dc66/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b93a436e6b93d31a9523e4b058edc2f1d5d8dc66", "patch": "@@ -41,7 +41,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"defaults.h\"\n #include \"real.h\"\n-#include \"bytecode.h\"\n \n #include \"obstack.h\"\n #include \"c-pragma.h\"\n@@ -138,9 +137,7 @@ struct constant_descriptor;\n struct rtx_const;\n struct pool_constant;\n \n-static void bc_make_decl_rtl\t\tPROTO((tree, char *, int));\n static char *strip_reg_name\t\tPROTO((char *));\n-static void bc_output_ascii\t\tPROTO((FILE *, char *, int));\n static int contains_pointers_p\t\tPROTO((tree));\n static void decode_addr_const\t\tPROTO((tree, struct addr_const *));\n static int const_hash\t\t\tPROTO((tree));\n@@ -163,7 +160,6 @@ static void mark_constant_pool\t\tPROTO((void));\n static void mark_constants\t\tPROTO((rtx));\n static int output_addressed_constants\tPROTO((tree));\n static void output_after_function_constants PROTO((void));\n-static void bc_assemble_integer\t\tPROTO((tree, int));\n static void output_constructor\t\tPROTO((tree, int));\n \f\n static enum in_section { no_section, in_text, in_data, in_named\n@@ -198,11 +194,7 @@ text_section ()\n {\n   if (in_section != in_text)\n     {\n-      if (output_bytecode)\n-\tbc_text ();\n-      else\n-\tfprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n-\n+      fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n       in_section = in_text;\n     }\n }\n@@ -214,21 +206,16 @@ data_section ()\n {\n   if (in_section != in_data)\n     {\n-      if (output_bytecode)\n-\tbc_data ();\n-      else\n+      if (flag_shared_data)\n \t{\n-\t  if (flag_shared_data)\n-\t    {\n #ifdef SHARED_SECTION_ASM_OP\n-\t      fprintf (asm_out_file, \"%s\\n\", SHARED_SECTION_ASM_OP);\n+\t  fprintf (asm_out_file, \"%s\\n\", SHARED_SECTION_ASM_OP);\n #else\n-\t      fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n+\t  fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n #endif\n-\t    }\n-\t  else\n-\t    fprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n \t}\n+      else\n+\tfprintf (asm_out_file, \"%s\\n\", DATA_SECTION_ASM_OP);\n \n       in_section = in_data;\n     }\n@@ -329,17 +316,12 @@ bss_section ()\n {\n   if (in_section != in_bss)\n     {\n-      if (output_bytecode)\n-\tbc_data ();\n-      else\n-\t{\n #ifdef SHARED_BSS_SECTION_ASM_OP\n-\t  if (flag_shared_data)\n-\t    fprintf (asm_out_file, \"%s\\n\", SHARED_BSS_SECTION_ASM_OP);\n-\t  else\n+      if (flag_shared_data)\n+\tfprintf (asm_out_file, \"%s\\n\", SHARED_BSS_SECTION_ASM_OP);\n+      else\n #endif\n-\t    fprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\n-\t}\n+\tfprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\n \n       in_section = in_bss;\n     }\n@@ -501,16 +483,6 @@ make_function_rtl (decl)\n   char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   char *new_name = name;\n \n-  if (output_bytecode)\n-    {\n-      if (DECL_RTL (decl) == 0)\n-\tDECL_RTL (decl) = bc_gen_rtx (name, 0, (struct bc_label *) 0);\n-      \n-      /* Record that at least one function has been defined.  */\n-      function_defined = 1;\n-      return;\n-    }\n-\n   /* Rename a nested function to avoid conflicts.  */\n   if (decl_function_context (decl) != 0\n       && DECL_INITIAL (decl) != 0\n@@ -556,47 +528,6 @@ make_function_rtl (decl)\n   function_defined = 1;\n }\n \n-/* Create the DECL_RTL for a declaration for a static or external\n-   variable or static or external function.\n-   ASMSPEC, if not 0, is the string which the user specified\n-   as the assembler symbol name.\n-   TOP_LEVEL is nonzero if this is a file-scope variable.\n-   This is never called for PARM_DECLs.  */\n-\n-static void\n-bc_make_decl_rtl (decl, asmspec, top_level)\n-     tree decl;\n-     char *asmspec;\n-     int top_level;\n-{\n-  register char *name = TREE_STRING_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-  if (DECL_RTL (decl) == 0)\n-    {\n-      /* Print an error message for register variables.  */\n-      if (DECL_REGISTER (decl))\n-\terror (\"global register variables not supported in the interpreter\");\n-\n-      /* Handle ordinary static variables and functions.  */\n-      if (DECL_RTL (decl) == 0)\n-\t{\n-\t  /* Can't use just the variable's own name for a variable\n-\t     whose scope is less than the whole file.\n-\t     Concatenate a distinguishing number.  */\n-\t  if (!top_level && !TREE_PUBLIC (decl) && asmspec == 0)\n-\t    {\n-\t      char *label;\n-\n-\t      ASM_FORMAT_PRIVATE_NAME (label, name, var_labelno);\n-\t      name = obstack_copy0 (saveable_obstack, label, strlen (label));\n-\t      var_labelno++;\n-\t    }\n-\n-\t  DECL_RTL (decl) = bc_gen_rtx (name, 0, (struct bc_label *) 0);\n-\t}\n-    }\n-}\n-\n /* Given NAME, a putative register name, discard any customary prefixes.  */\n \n static char *\n@@ -689,12 +620,6 @@ make_decl_rtl (decl, asmspec, top_level)\n   register char *name = 0;\n   int reg_number;\n \n-  if (output_bytecode)\n-    {\n-      bc_make_decl_rtl (decl, asmspec, top_level);\n-      return;\n-    }\n-\n   reg_number = decode_reg_name (asmspec);\n \n   if (DECL_ASSEMBLER_NAME (decl) != NULL_TREE)\n@@ -889,12 +814,6 @@ void\n assemble_asm (string)\n      tree string;\n {\n-  if (output_bytecode)\n-    {\n-      error (\"asm statements not allowed in interpreter\");\n-      return;\n-    }\n-\n   app_enable ();\n \n   if (TREE_CODE (string) == ADDR_EXPR)\n@@ -1025,12 +944,7 @@ assemble_start_function (decl, fnname)\n   /* Tell assembler to move to target machine's alignment for functions.  */\n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n   if (align > 0)\n-    {\n-      if (output_bytecode)\n-\tBC_OUTPUT_ALIGN (asm_out_file, align);\n-      else\n-\tASM_OUTPUT_ALIGN (asm_out_file, align);\n-    }\n+    ASM_OUTPUT_ALIGN (asm_out_file, align);\n \n #ifdef ASM_OUTPUT_FUNCTION_PREFIX\n   ASM_OUTPUT_FUNCTION_PREFIX (asm_out_file, fnname);\n@@ -1067,24 +981,16 @@ assemble_start_function (decl, fnname)\n \tASM_WEAKEN_LABEL (asm_out_file, fnname);\n       else\n #endif\n-      if (output_bytecode)\n-\tBC_GLOBALIZE_LABEL (asm_out_file, fnname);\n-      else\n-\tASM_GLOBALIZE_LABEL (asm_out_file, fnname);\n+      ASM_GLOBALIZE_LABEL (asm_out_file, fnname);\n     }\n \n   /* Do any machine/system dependent processing of the function name */\n-  if (output_bytecode)\n-    BC_OUTPUT_LABEL (asm_out_file, fnname);\n-  else\n-    {\n #ifdef ASM_DECLARE_FUNCTION_NAME\n-      ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);\n+  ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);\n #else\n-      /* Standard thing is just output label for the function.  */\n-      ASM_OUTPUT_LABEL (asm_out_file, fnname);\n+  /* Standard thing is just output label for the function.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, fnname);\n #endif /* ASM_DECLARE_FUNCTION_NAME */\n-    }\n }\n \n /* Output assembler code associated with defining the size of the\n@@ -1114,12 +1020,6 @@ void\n assemble_zeros (size)\n      int size;\n {\n-  if (output_bytecode)\n-    {\n-      bc_emit_const_skip (size);\n-      return;\n-    }\n-\n #ifdef ASM_NO_SKIP_IN_TEXT\n   /* The `space' pseudo in the text section outputs nop insns rather than 0s,\n      so we must output 0s explicitly in the text section.  */\n@@ -1153,12 +1053,7 @@ assemble_zeros (size)\n   else\n #endif\n     if (size > 0)\n-      {\n-\tif (output_bytecode)\n-\t  BC_OUTPUT_SKIP (asm_out_file, size);\n-\telse\n-\t  ASM_OUTPUT_SKIP (asm_out_file, size);\n-      }\n+      ASM_OUTPUT_SKIP (asm_out_file, size);\n }\n \n /* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\n@@ -1182,12 +1077,6 @@ assemble_string (p, size)\n   int pos = 0;\n   int maximum = 2000;\n \n-  if (output_bytecode)\n-    {\n-      bc_emit (p, size);\n-      return;\n-    }\n-\n   /* If the string is very long, split it up.  */\n \n   while (pos < size)\n@@ -1196,26 +1085,13 @@ assemble_string (p, size)\n       if (thissize > maximum)\n \tthissize = maximum;\n \n-      if (output_bytecode)\n-\tbc_output_ascii (asm_out_file, p, thissize);\n-      else\n-\t{\n-\t  ASM_OUTPUT_ASCII (asm_out_file, p, thissize);\n-\t}\n+      ASM_OUTPUT_ASCII (asm_out_file, p, thissize);\n \n       pos += thissize;\n       p += thissize;\n     }\n }\n \n-static void\n-bc_output_ascii (file, p, size)\n-     FILE *file;\n-     char *p;\n-     int size;\n-{\n-  BC_OUTPUT_ASCII (file, p, size);\n-}\n \f\n /* Assemble everything that is needed for a variable or function declaration.\n    Not used for automatic variables, and not used for function definitions.\n@@ -1242,9 +1118,6 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \n   last_assemble_variable_decl = 0;\n \n-  if (output_bytecode)\n-    return;\n-\n   if (GET_CODE (DECL_RTL (decl)) == REG)\n     {\n       /* Do output symbol info for global register variables, but do nothing\n@@ -1254,22 +1127,19 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \treturn;\n       TREE_ASM_WRITTEN (decl) = 1;\n \n-      if (!output_bytecode)\n-\t{\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n-\t  /* File-scope global variables are output here.  */\n-\t  if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-\t      && top_level)\n-\t    dbxout_symbol (decl, 0);\n+      /* File-scope global variables are output here.  */\n+      if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\t   && top_level)\n+\tdbxout_symbol (decl, 0);\n #endif\n #ifdef SDB_DEBUGGING_INFO\n-\t  if (write_symbols == SDB_DEBUG && top_level\n-\t      /* Leave initialized global vars for end of compilation;\n-\t\t see comment in compile_file.  */\n-\t      && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n-\t    sdbout_symbol (decl, 0);\n+      if (write_symbols == SDB_DEBUG && top_level\n+\t  /* Leave initialized global vars for end of compilation;\n+\t     see comment in compile_file.  */\n+\t  && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n+\tsdbout_symbol (decl, 0);\n #endif\n-\t}\n \n       /* Don't output any DWARF debugging information for variables here.\n \t In the case of local variables, the information for them is output\n@@ -1422,11 +1292,6 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t    ASM_OUTPUT_SHARED_COMMON (asm_out_file, name, size, rounded);\n \t  else\n #endif\n-\t    if (output_bytecode)\n-\t      {\n-\t\tBC_OUTPUT_COMMON (asm_out_file, name, size, rounded);\n-\t      }\n-\t    else\n \t      {\n #ifdef ASM_OUTPUT_ALIGNED_DECL_COMMON\n \t\tASM_OUTPUT_ALIGNED_DECL_COMMON (asm_out_file, decl, name, size,\n@@ -1449,11 +1314,6 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t    ASM_OUTPUT_SHARED_BSS (asm_out_file, decl, name, size, rounded);\n \t  else\n #endif\n-\t    if (output_bytecode)\n-\t      {\n-\t\tBC_OUTPUT_BSS (asm_out_file, name, size, rounded);\n-\t      }\n-\t    else\n \t      {\n #ifdef ASM_OUTPUT_ALIGNED_BSS\n \t\tASM_OUTPUT_ALIGNED_BSS (asm_out_file, decl, name, size,\n@@ -1471,11 +1331,6 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t    ASM_OUTPUT_SHARED_LOCAL (asm_out_file, name, size, rounded);\n \t  else\n #endif\n-\t    if (output_bytecode)\n-\t      {\n-\t\tBC_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n-\t      }\n-\t    else\n \t      {\n #ifdef ASM_OUTPUT_ALIGNED_DECL_LOCAL\n \t\tASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, decl, name, size,\n@@ -1601,26 +1456,16 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n   DECL_ALIGN (decl) = align;\n \n   if (align > BITS_PER_UNIT)\n-    {\n-      if (output_bytecode)\n-\tBC_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n-      else\n-\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n-    }\n+    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n \n   /* Do any machine/system dependent processing of the object.  */\n-  if (output_bytecode)\n-    BC_OUTPUT_LABEL (asm_out_file, name);\n-  else\n-    {\n #ifdef ASM_DECLARE_OBJECT_NAME\n-      last_assemble_variable_decl = decl;\n-      ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);\n+  last_assemble_variable_decl = decl;\n+  ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);\n #else\n-      /* Standard thing is just output label for the object.  */\n-      ASM_OUTPUT_LABEL (asm_out_file, name);\n+  /* Standard thing is just output label for the object.  */\n+  ASM_OUTPUT_LABEL (asm_out_file, name);\n #endif /* ASM_DECLARE_OBJECT_NAME */\n-    }\n \n   if (!dont_output_data)\n     {\n@@ -1693,55 +1538,6 @@ contains_pointers_p (type)\n     }\n }\n \n-/* Output text storage for constructor CONSTR.  */\n-\n-void\n-bc_output_constructor (constr, size)\n-     tree constr;\n-     int size;\n-{\n-  int i;\n-\n-  /* Must always be a literal; non-literal constructors are handled\n-     differently.  */\n-\n-  if (!TREE_CONSTANT (constr))\n-    abort ();\n-\n-  /* Always const */\n-  text_section ();\n-\n-  /* Align */\n-  for (i = 0; TYPE_ALIGN (constr) >= BITS_PER_UNIT << (i + 1); i++)\n-    ;\n-\n-  if (i > 0)\n-    BC_OUTPUT_ALIGN (asm_out_file, i);\n-\n-  /* Output data */\n-  output_constant (constr, size);\n-}\n-\n-/* Create storage for constructor CONSTR.  */\n-\n-void\n-bc_output_data_constructor (constr)\n-    tree constr;\n-{\n-  int i;\n-\n-  /* Put in data section */\n-  data_section ();\n-\n-  /* Align */\n-  for (i = 0; TYPE_ALIGN (constr) >= BITS_PER_UNIT << (i + 1); i++);\n-  if (i > 0)\n-    BC_OUTPUT_ALIGN (asm_out_file, i);\n-\n-  /* The constructor is filled in at runtime.  */\n-  BC_OUTPUT_SKIP (asm_out_file, int_size_in_bytes (TREE_TYPE (constr)));\n-}\n-\n /* Output something to declare an external symbol to the assembler.\n    (Most assemblers don't need this, so we normally output nothing.)\n    Do nothing if DECL is not external.  */\n@@ -1750,9 +1546,6 @@ void\n assemble_external (decl)\n      tree decl;\n {\n-  if (output_bytecode)\n-    return;\n-\n #ifdef ASM_OUTPUT_EXTERNAL\n   if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd'\n       && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl))\n@@ -1777,14 +1570,11 @@ assemble_external_libcall (fun)\n      rtx fun;\n {\n #ifdef ASM_OUTPUT_EXTERNAL_LIBCALL\n-  if (!output_bytecode)\n+  /* Declare library function name external when first used, if nec.  */\n+  if (! SYMBOL_REF_USED (fun))\n     {\n-      /* Declare library function name external when first used, if nec.  */\n-      if (! SYMBOL_REF_USED (fun))\n-\t{\n-\t  SYMBOL_REF_USED (fun) = 1;\n-\t  ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);\n-\t}\n+      SYMBOL_REF_USED (fun) = 1;\n+      ASM_OUTPUT_EXTERNAL_LIBCALL (asm_out_file, fun);\n     }\n #endif\n }\n@@ -1804,10 +1594,7 @@ void\n assemble_label (name)\n      char *name;\n {\n-  if (output_bytecode)\n-    BC_OUTPUT_LABEL (asm_out_file, name);\n-  else\n-    ASM_OUTPUT_LABEL (asm_out_file, name);\n+  ASM_OUTPUT_LABEL (asm_out_file, name);\n }\n \n /* Output to FILE a reference to the assembler name of a C-level name NAME.\n@@ -1834,19 +1621,9 @@ assemble_name (file, name)\n     TREE_SYMBOL_REFERENCED (id) = 1;\n \n   if (name[0] == '*')\n-    {\n-      if (output_bytecode)\n-\tbc_emit_labelref (name, 0);\n-      else\n-\tfputs (&name[1], file);\n-    }\n+    fputs (&name[1], file);\n   else\n-    {\n-      if (output_bytecode)\n-\tBC_OUTPUT_LABELREF (file, name);\n-      else\n-\tASM_OUTPUT_LABELREF (file, name);\n-    }\n+    ASM_OUTPUT_LABELREF (file, name);\n }\n \n /* Allocate SIZE bytes writable static space with a gensym name\n@@ -1877,28 +1654,18 @@ assemble_static_space (size)\n \t\t\t\t       strlen (name) + 2);\n   strcpy (namestring, name);\n \n-  if (output_bytecode)\n-    x = bc_gen_rtx (namestring, 0, (struct bc_label *) 0);\n-  else\n-    x = gen_rtx_SYMBOL_REF (Pmode, namestring);\n+  x = gen_rtx_SYMBOL_REF (Pmode, namestring);\n \n-  if (output_bytecode)\n-    {\n-      BC_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n-    }\n-  else\n-    {\n #ifdef ASM_OUTPUT_ALIGNED_DECL_LOCAL\n-      ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name, size,\n-\t\t\t\t  BIGGEST_ALIGNMENT);\n+  ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name, size,\n+\t\t\t\t BIGGEST_ALIGNMENT);\n #else\n #ifdef ASM_OUTPUT_ALIGNED_LOCAL\n-      ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, BIGGEST_ALIGNMENT);\n+  ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size, BIGGEST_ALIGNMENT);\n #else\n-      ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n+  ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n #endif\n #endif\n-    }\n   return x;\n }\n \n@@ -1914,10 +1681,6 @@ assemble_trampoline_template ()\n   char *name;\n   int align;\n \n-  /* Shouldn't get here */\n-  if (output_bytecode)\n-    abort ();\n-\n   /* By default, put trampoline templates in read-only data section.  */\n \n #ifdef TRAMPOLINE_SECTION\n@@ -2385,13 +2148,9 @@ decode_addr_const (exp, value)\n       break;\n \n     case LABEL_DECL:\n-      if (output_bytecode)\n-\t/* FIXME: this may not be correct, check it */\n-\tx = bc_gen_rtx (TREE_STRING_POINTER (target), 0, (struct bc_label *) 0);\n-      else\n-\tx = gen_rtx_MEM (FUNCTION_MODE,\n-\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t    label_rtx (TREE_OPERAND (exp, 0))));\n+      x = gen_rtx_MEM (FUNCTION_MODE,\n+\t\t       gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t  label_rtx (TREE_OPERAND (exp, 0))));\n       break;\n \n     case REAL_CST:\n@@ -2406,12 +2165,9 @@ decode_addr_const (exp, value)\n       abort ();\n     }\n \n-  if (!output_bytecode)\n-    {\n-      if (GET_CODE (x) != MEM)\n-\tabort ();\n-      x = XEXP (x, 0);\n-    }\n+  if (GET_CODE (x) != MEM)\n+    abort ();\n+  x = XEXP (x, 0);\n \n   value->base = x;\n   value->offset = offset;\n@@ -3179,16 +2935,7 @@ output_constant_def_contents (exp, reloc, labelno)\n #endif\n \n   if (align > BITS_PER_UNIT)\n-    {\n-      if (!output_bytecode)\n-\t{\n-\t  ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n-\t}\n-      else\n-\t{\n-\t  BC_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n-\t}\n-    }\n+    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n \n   /* Output the label itself.  */\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LC\", labelno);\n@@ -3994,10 +3741,7 @@ output_constant (exp, size)\n      This means to fill the space with zeros.  */\n   if (TREE_CODE (exp) == CONSTRUCTOR && CONSTRUCTOR_ELTS (exp) == 0)\n     {\n-      if (output_bytecode)\n-\tbc_emit_const_skip (size);\n-      else\n-\tassemble_zeros (size);\n+      assemble_zeros (size);\n       return;\n     }\n \n@@ -4091,107 +3835,6 @@ output_constant (exp, size)\n     assemble_zeros (size);\n }\n \n-/* Bytecode specific code to output assembler for integer.  */\n-\n-static void\n-bc_assemble_integer (exp, size)\n-    tree exp;\n-    int size;\n-{\n-  tree const_part;\n-  tree addr_part;\n-  tree tmp;\n-\n-  /* FIXME: is this fold() business going to be as good as the\n-     expand_expr() using EXPAND_SUM above in the RTL case?  I\n-     hate RMS.\n-     FIXME: Copied as is from BC-GCC1; may need work. Don't hate. -bson */\n-  \n-  exp = fold (exp);\n-  \n-  while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR\n-\t || TREE_CODE (exp) == NON_LVALUE_EXPR)\n-    exp = TREE_OPERAND (exp, 0);\n-  if (TREE_CODE (exp) == INTEGER_CST)\n-    {\n-      const_part = exp;\n-      addr_part = 0;\n-    }\n-  else if (TREE_CODE (exp) == PLUS_EXPR)\n-    {\n-      const_part = TREE_OPERAND (exp, 0);\n-      while (TREE_CODE (const_part) == NOP_EXPR\n-\t     || TREE_CODE (const_part) == CONVERT_EXPR\n-\t     || TREE_CODE (const_part) == NON_LVALUE_EXPR)\n-\tconst_part = TREE_OPERAND (const_part, 0);\n-      addr_part = TREE_OPERAND (exp, 1);\n-      while (TREE_CODE (addr_part) == NOP_EXPR\n-\t     || TREE_CODE (addr_part) == CONVERT_EXPR\n-\t     || TREE_CODE (addr_part) == NON_LVALUE_EXPR)\n-\taddr_part = TREE_OPERAND (addr_part, 0);\n-      if (TREE_CODE (const_part) != INTEGER_CST)\n-\ttmp = const_part, const_part = addr_part, addr_part = tmp;\n-      if (TREE_CODE (const_part) != INTEGER_CST\n-\t  || TREE_CODE (addr_part) != ADDR_EXPR)\n-\tabort ();\t\t/* FIXME: we really haven't considered\n-\t\t\t\t   all the possible cases here.  */\n-    }\n-  else if (TREE_CODE (exp) == ADDR_EXPR)\n-    {\n-      const_part = integer_zero_node;\n-      addr_part = exp;\n-    }\n-  else\n-    abort ();\t\t/* FIXME: ditto previous.  */\n-  \n-  if (addr_part == 0)\n-    {\n-      if (size == 1)\n-\t{\n-\t  char c = TREE_INT_CST_LOW (const_part);\n-\t  bc_emit (&c, 1);\n-\t  size -= 1;\n-\t}\n-      else if (size == 2)\n-\t{\n-\t  short s = TREE_INT_CST_LOW (const_part);\n-\t  bc_emit ((char *) &s, 2);\n-\t  size -= 2;\n-\t}\n-      else if (size == 4)\n-\t{\n-\t  int i = TREE_INT_CST_LOW (const_part);\n-\t  bc_emit ((char *) &i, 4);\n-\t  size -= 4;\n-\t}\n-      else if (size == 8)\n-\t{\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    {\n-\t      int i = TREE_INT_CST_HIGH (const_part);\n-\t      bc_emit ((char *) &i, 4);\n-\t      i = TREE_INT_CST_LOW (const_part);\n-\t      bc_emit ((char *) &i, 4);\n-\t    }\n-\t  else\n-\t    {\n-\t      int i = TREE_INT_CST_LOW (const_part);\n-\t      bc_emit ((char *) &i, 4);\n-\t      i = TREE_INT_CST_HIGH (const_part);\n-\t      bc_emit ((char *) &i, 4);\n-\t    }\n-\t  size -= 8;\n-\t}\n-    }\n-  else\n-    if (size == 4\n-\t&& TREE_CODE (TREE_OPERAND (addr_part, 0)) == VAR_DECL)\n-      bc_emit_labelref (IDENTIFIER_POINTER\n-\t\t\t(DECL_ASSEMBLER_NAME (TREE_OPERAND (addr_part, 0))),\n-\t\t\tTREE_INT_CST_LOW (const_part));\n-    else\n-      abort ();\t\t/* FIXME: there may be more cases.  */\n-}\n \f\n /* Subroutine of output_constant, used for CONSTRUCTORs\n    (aggregate constants).\n@@ -4299,10 +3942,7 @@ output_constructor (exp, size)\n \t     if each element has the proper size.  */\n \t  if ((field != 0 || index != 0) && bitpos != total_bytes)\n \t    {\n-\t      if (!output_bytecode)\n-\t\tassemble_zeros (bitpos - total_bytes);\n-\t      else\n-\t\tbc_emit_const_skip (bitpos - total_bytes);\n+\t      assemble_zeros (bitpos - total_bytes);\n \t      total_bytes = bitpos;\n \t    }\n \n@@ -4563,9 +4203,6 @@ assemble_alias (decl, target)\n \tASM_WEAKEN_LABEL (asm_out_file, name);\n       else\n #endif\n-      if (output_bytecode)\n-\tBC_GLOBALIZE_LABEL (asm_out_file, name);\n-      else\n \tASM_GLOBALIZE_LABEL (asm_out_file, name);\n     }\n "}]}