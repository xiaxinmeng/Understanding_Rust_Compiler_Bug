{"sha": "d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1NTYzNWU2Yjk2ZDVkOWU2N2E1MjZiNmRmZDUzNGNkOWE5ZGQ1Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-06-06T12:13:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-06-06T12:13:36Z"}, "message": "Refactor SFINAE constraints on std::tuple constructors\n\nReplace the _TC class template with the better-named _TupleConstraints\none, which provides a different set of member functions. The new members\ndo not distinguish construction from lvalues and rvalues, but expects\nthe caller to do that by providing different template arguments. Within\nthe std::tuple primary template and std::tuple<T1, T2> partial\nspecialization the _TupleConstraints members are used via new alias\ntemplates like _ImplicitCtor and _ExplicitCtor which makes the\nconstructor constraints less verbose and repetitive. For example, where\nwe previously had:\n\n     template<typename... _UElements, typename\n             enable_if<\n                _TMC<_UElements...>::template\n                   _MoveConstructibleTuple<_UElements...>()\n                 && _TMC<_UElements...>::template\n                   _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                 && (sizeof...(_Elements) >= 1),\n       bool>::type=true>\n       constexpr tuple(_UElements&&... __elements)\n\nWe now have:\n\n     template<typename... _UElements,\n             bool _Valid = __valid_args<_UElements...>(),\n             _ImplicitCtor<_Valid, _UElements...> = true>\n      constexpr\n      tuple(_UElements&&... __elements)\n\nThere are two semantic changes as a result of the refactoring:\n\n- The allocator-extended default constructor is now constrained.\n- The rewritten constraints fix PR 90700.\n\n\t* include/std/tuple (_TC): Replace with _TupleConstraints.\n\t(_TupleConstraints): New helper for SFINAE constraints, with more\n\texpressive member functions to reduce duplication when used.\n\t(tuple::_TC2, tuple::_TMC, tuple::_TNTC): Remove.\n\t(tuple::_TCC): Replace dummy type parameter with bool non-type\n\tparameter that can be used to check the pack size.\n\t(tuple::_ImplicitDefaultCtor, tuple::_ExplicitDefaultCtor)\n\t(tuple::_ImplicitCtor, tuple::_ExplicitCtor): New alias templates for\n\tchecking constraints in constructors.\n\t(tuple::__valid_args, tuple::_UseOtherCtor, tuple::__use_other_ctor):\n\tNew SFINAE helpers.\n\t(tuple::tuple): Use new helpers to reduce repitition in constraints.\n\t(tuple::tuple(allocator_arg_t, const Alloc&)): Constrain.\n\t(tuple<T1, T2>::_TCC, tuple<T1, T2>::_ImplicitDefaultCtor)\n\t(tuple<T1, T2>::_ExplicitDefaultCtor, tuple<T1, T2>::_ImplicitCtor)\n\t(tuple<T1, T2>::_ExplicitCtor): New alias templates for checking\n\tconstraints in constructors.\n\t(tuple::__is_alloc_arg()): New SFINAE helpers.\n\t(tuple<T1, T2>::tuple): Use new helpers to reduce repitition in\n\tconstraints.\n\t(tuple<T1, T2>::tuple(allocator_arg_t, const Alloc&)): Constrain.\n\t* testsuite/20_util/tuple/cons/90700.cc: New test.\n\t* testsuite/20_util/tuple/cons/allocators.cc: Add default constructor\n\tto meet new constraint on allocator-extended default constructor.\n\nFrom-SVN: r271998", "tree": {"sha": "a04a6cf1307706d62e1a1154cd84c49ebcba208c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a04a6cf1307706d62e1a1154cd84c49ebcba208c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec573765e58cf9dd90e9daba3269d179582a7d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec573765e58cf9dd90e9daba3269d179582a7d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec573765e58cf9dd90e9daba3269d179582a7d24"}], "stats": {"total": 1010, "additions": 492, "deletions": 518}, "files": [{"sha": "18c830698877a6fa6e8dcb5e51fae2dea172c1c1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "patch": "@@ -1,3 +1,30 @@\n+2019-06-06  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/tuple (_TC): Replace with _TupleConstraints.\n+\t(_TupleConstraints): New helper for SFINAE constraints, with more\n+\texpressive member functions to reduce duplication when used.\n+\t(tuple::_TC2, tuple::_TMC, tuple::_TNTC): Remove.\n+\t(tuple::_TCC): Replace dummy type parameter with bool non-type\n+\tparameter that can be used to check the pack size.\n+\t(tuple::_ImplicitDefaultCtor, tuple::_ExplicitDefaultCtor)\n+\t(tuple::_ImplicitCtor, tuple::_ExplicitCtor): New alias templates for\n+\tchecking constraints in constructors.\n+\t(tuple::__valid_args, tuple::_UseOtherCtor, tuple::__use_other_ctor):\n+\tNew SFINAE helpers.\n+\t(tuple::tuple): Use new helpers to reduce repitition in constraints.\n+\t(tuple::tuple(allocator_arg_t, const Alloc&)): Constrain.\n+\t(tuple<T1, T2>::_TCC, tuple<T1, T2>::_ImplicitDefaultCtor)\n+\t(tuple<T1, T2>::_ExplicitDefaultCtor, tuple<T1, T2>::_ImplicitCtor)\n+\t(tuple<T1, T2>::_ExplicitCtor): New alias templates for checking\n+\tconstraints in constructors.\n+\t(tuple::__is_alloc_arg()): New SFINAE helpers.\n+\t(tuple<T1, T2>::tuple): Use new helpers to reduce repitition in\n+\tconstraints.\n+\t(tuple<T1, T2>::tuple(allocator_arg_t, const Alloc&)): Constrain.\n+\t* testsuite/20_util/tuple/cons/90700.cc: New test.\n+\t* testsuite/20_util/tuple/cons/allocators.cc: Add default constructor\n+\tto meet new constraint on allocator-extended default constructor.\n+\n 2019-06-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/stl_map.h (map): Disable static assert for C++98 mode."}, {"sha": "980dd6d627017ed72f65eed4194b1b5e3eea7b1f", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 383, "deletions": 517, "changes": 900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "patch": "@@ -433,331 +433,285 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Concept utility functions, reused in conditionally-explicit\n   // constructors.\n-  template<bool, typename... _Elements>\n-  struct _TC\n-  {\n-    template<typename... _UElements>\n-    static constexpr bool _ConstructibleTuple()\n-    {\n-      return __and_<is_constructible<_Elements, const _UElements&>...>::value;\n-    }\n-\n-    template<typename... _UElements>\n-    static constexpr bool _ImplicitlyConvertibleTuple()\n-    {\n-      return __and_<is_convertible<const _UElements&, _Elements>...>::value;\n-    }\n-\n-    template<typename... _UElements>\n-    static constexpr bool _MoveConstructibleTuple()\n-    {\n-      return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n-    }\n-\n-    template<typename... _UElements>\n-    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n-    {\n-      return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n-    }\n-\n-    template<typename _SrcTuple>\n-    static constexpr bool _NonNestedTuple()\n-    {\n-      return  __and_<__not_<is_same<tuple<_Elements...>,\n-\t\t\t\t    __remove_cvref_t<_SrcTuple>>>,\n-                     __not_<is_convertible<_SrcTuple, _Elements...>>,\n-                     __not_<is_constructible<_Elements..., _SrcTuple>>\n-              >::value;\n-    }\n-\n-    template<typename... _UElements>\n-    static constexpr bool _NotSameTuple()\n-    {\n-      return  __not_<is_same<tuple<_Elements...>,\n-\t\t\t     __remove_cvref_t<_UElements>...>>::value;\n-    }\n-  };\n-\n-  template<typename... _Elements>\n-  struct _TC<false, _Elements...>\n-  {\n-    template<typename... _UElements>\n-    static constexpr bool _ConstructibleTuple()\n+  template<bool, typename... _Types>\n+    struct _TupleConstraints\n     {\n-      return false;\n-    }\n+      // Constraint for a non-explicit constructor.\n+      // True iff each Ti in _Types... can be constructed from Ui in _UTypes...\n+      // and every Ui is implicitly convertible to Ti.\n+      template<typename... _UTypes>\n+\tstatic constexpr bool __is_implicitly_constructible()\n+\t{\n+\t  return __and_<is_constructible<_Types, _UTypes>...,\n+\t\t\tis_convertible<_UTypes, _Types>...\n+\t\t\t>::value;\n+\t}\n \n-    template<typename... _UElements>\n-    static constexpr bool _ImplicitlyConvertibleTuple()\n-    {\n-      return false;\n-    }\n+      // Constraint for a non-explicit constructor.\n+      // True iff each Ti in _Types... can be constructed from Ui in _UTypes...\n+      // but not every Ui is implicitly convertible to Ti.\n+      template<typename... _UTypes>\n+\tstatic constexpr bool __is_explicitly_constructible()\n+\t{\n+\t  return __and_<is_constructible<_Types, _UTypes>...,\n+\t\t\t__not_<__and_<is_convertible<_UTypes, _Types>...>>\n+\t\t\t>::value;\n+\t}\n \n-    template<typename... _UElements>\n-    static constexpr bool _MoveConstructibleTuple()\n-    {\n-      return false;\n-    }\n+      static constexpr bool __is_implicitly_default_constructible()\n+      {\n+\treturn __and_<std::__is_implicitly_default_constructible<_Types>...\n+\t\t      >::value;\n+      }\n \n-    template<typename... _UElements>\n-    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n-    {\n-      return false;\n-    }\n+      static constexpr bool __is_explicitly_default_constructible()\n+      {\n+\treturn __and_<is_default_constructible<_Types>...,\n+\t\t      __not_<__and_<\n+\t\t\tstd::__is_implicitly_default_constructible<_Types>...>\n+\t\t      >>::value;\n+      }\n+    };\n \n-    template<typename... _UElements>\n-    static constexpr bool _NonNestedTuple()\n+  // Partial specialization used when a required precondition isn't met,\n+  // e.g. when sizeof...(_Types) != sizeof...(_UTypes).\n+  template<typename... _Types>\n+    struct _TupleConstraints<false, _Types...>\n     {\n-      return true;\n-    }\n+      template<typename... _UTypes>\n+\tstatic constexpr bool __is_implicitly_constructible()\n+\t{ return false; }\n \n-    template<typename... _UElements>\n-    static constexpr bool _NotSameTuple()\n-    {\n-      return true;\n-    }\n-  };\n+      template<typename... _UTypes>\n+\tstatic constexpr bool __is_explicitly_constructible()\n+\t{ return false; }\n+    };\n \n   /// Primary class template, tuple\n   template<typename... _Elements>\n     class tuple : public _Tuple_impl<0, _Elements...>\n     {\n       typedef _Tuple_impl<0, _Elements...> _Inherited;\n \n-      // Used for constraining the default constructor so\n-      // that it becomes dependent on the constraints.\n-      template<typename _Dummy>\n-      struct _TC2\n-      {\n-        static constexpr bool _DefaultConstructibleTuple()\n-        {\n-          return __and_<is_default_constructible<_Elements>...>::value;\n-        }\n-        static constexpr bool _ImplicitlyDefaultConstructibleTuple()\n-        {\n-          return __and_<__is_implicitly_default_constructible<_Elements>...>\n-            ::value;\n-        }\n-      };\n+      template<bool _Cond>\n+\tusing _TCC = _TupleConstraints<_Cond, _Elements...>;\n+\n+      // Constraint for non-explicit default constructor\n+      template<bool _Dummy>\n+\tusing _ImplicitDefaultCtor = __enable_if_t<\n+\t  _TCC<_Dummy>::__is_implicitly_default_constructible(),\n+\t  bool>;\n+\n+      // Constraint for explicit default constructor\n+      template<bool _Dummy>\n+\tusing _ExplicitDefaultCtor = __enable_if_t<\n+\t  _TCC<_Dummy>::__is_explicitly_default_constructible(),\n+\t  bool>;\n+\n+      // Constraint for non-explicit constructors\n+      template<bool _Cond, typename... _Args>\n+\tusing _ImplicitCtor = __enable_if_t<\n+\t  _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),\n+\t  bool>;\n+\n+      // Constraint for non-explicit constructors\n+      template<bool _Cond, typename... _Args>\n+\tusing _ExplicitCtor = __enable_if_t<\n+\t  _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),\n+\t  bool>;\n \n       template<typename... _UElements>\n \tstatic constexpr\n \t__enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>\n \t__assignable()\n \t{ return __and_<is_assignable<_Elements&, _UElements>...>::value; }\n \n+      // Condition for noexcept-specifier of an assignment operator.\n       template<typename... _UElements>\n \tstatic constexpr bool __nothrow_assignable()\n \t{\n \t  return\n \t    __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;\n \t}\n+\n+      // Condition for noexcept-specifier of a constructor.\n       template<typename... _UElements>\n \tstatic constexpr bool __nothrow_constructible()\n \t{\n \t  return\n \t    __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;\n \t}\n \n-    public:\n-      template<typename _Dummy = void,\n-               typename enable_if<_TC2<_Dummy>::\n-                                    _ImplicitlyDefaultConstructibleTuple(),\n-                                  bool>::type = true>\n-      constexpr tuple()\n-      noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)\n-      : _Inherited() { }\n+      // Constraint for tuple(_UTypes&&...) where sizeof...(_UTypes) == 1.\n+      template<typename _Up>\n+\tstatic constexpr bool __valid_args()\n+\t{\n+\t  return sizeof...(_Elements) == 1\n+\t    && !is_same<tuple, __remove_cvref_t<_Up>>::value;\n+\t}\n \n-      template<typename _Dummy = void,\n-               typename enable_if<_TC2<_Dummy>::\n-                                    _DefaultConstructibleTuple()\n-                                  &&\n-                                  !_TC2<_Dummy>::\n-                                    _ImplicitlyDefaultConstructibleTuple(),\n-                                  bool>::type = false>\n-      explicit constexpr tuple()\n-      noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)\n-      : _Inherited() { }\n-\n-      // Shortcut for the cases where constructors taking _Elements...\n-      // need to be constrained.\n-      template<typename _Dummy> using _TCC =\n-        _TC<is_same<_Dummy, void>::value,\n-            _Elements...>;\n+      // Constraint for tuple(_UTypes&&...) where sizeof...(_UTypes) > 1.\n+      template<typename, typename, typename... _Tail>\n+\tstatic constexpr bool __valid_args()\n+\t{ return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }\n+\n+      /* Constraint for constructors with a tuple<UTypes...> parameter ensures\n+       * that the constructor is only viable when it would not interfere with\n+       * tuple(UTypes&&...) or tuple(const tuple&) or tuple(tuple&&).\n+       * Such constructors are only viable if:\n+       * either sizeof...(Types) != 1,\n+       * or (when Types... expands to T and UTypes... expands to U)\n+       * is_convertible_v<TUPLE, T>, is_constructible_v<T, TUPLE>,\n+       * and is_same_v<T, U> are all false.\n+       */\n+      template<typename _Tuple, typename = tuple,\n+\t       typename = __remove_cvref_t<_Tuple>>\n+\tstruct _UseOtherCtor\n+\t: false_type\n+\t{ };\n+      // If TUPLE is convertible to the single element in *this,\n+      // then TUPLE should match tuple(UTypes&&...) instead.\n+      template<typename _Tuple, typename _Tp, typename _Up>\n+\tstruct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>\n+\t: __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>\n+\t{ };\n+      // If TUPLE and *this each have a single element of the same type,\n+      // then TUPLE should match a copy/move constructor instead.\n+      template<typename _Tuple, typename _Tp>\n+\tstruct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>\n+\t: true_type\n+\t{ };\n+\n+      // Return true iff sizeof...(Types) == 1 && tuple_size_v<TUPLE> == 1\n+      // and the single element in Types can be initialized from TUPLE,\n+      // or is the same type as tuple_element_t<0, TUPLE>.\n+      template<typename _Tuple>\n+\tstatic constexpr bool __use_other_ctor()\n+\t{ return _UseOtherCtor<_Tuple>::value; }\n \n+    public:\n       template<typename _Dummy = void,\n-               typename enable_if<\n-                 _TCC<_Dummy>::template\n-                   _ConstructibleTuple<_Elements...>()\n-                 && _TCC<_Dummy>::template\n-                   _ImplicitlyConvertibleTuple<_Elements...>()\n-                 && (sizeof...(_Elements) >= 1),\n-               bool>::type=true>\n-        constexpr tuple(const _Elements&... __elements)\n-        noexcept(__nothrow_constructible<const _Elements&...>())\n-      : _Inherited(__elements...) { }\n+\t       _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>\n+\tconstexpr\n+\ttuple()\n+\tnoexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)\n+\t: _Inherited() { }\n \n       template<typename _Dummy = void,\n-               typename enable_if<\n-                 _TCC<_Dummy>::template\n-                   _ConstructibleTuple<_Elements...>()\n-                 && !_TCC<_Dummy>::template\n-                   _ImplicitlyConvertibleTuple<_Elements...>()\n-                 && (sizeof...(_Elements) >= 1),\n-               bool>::type=false>\n-      explicit constexpr tuple(const _Elements&... __elements)\n-      noexcept(__nothrow_constructible<const _Elements&...>())\n-      : _Inherited(__elements...) { }\n-\n-      // Shortcut for the cases where constructors taking _UElements...\n-      // need to be constrained.\n-      template<typename... _UElements> using _TMC =\n-                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))\n-\t\t      && (_TC<(sizeof...(_UElements)==1), _Elements...>::\n-\t\t\t  template _NotSameTuple<_UElements...>()),\n-                      _Elements...>;\n-\n-      // Shortcut for the cases where constructors taking tuple<_UElements...>\n-      // need to be constrained.\n-      template<typename... _UElements> using _TMCT =\n-                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))\n-\t\t      && !is_same<tuple<_Elements...>,\n-\t\t\t\t  tuple<_UElements...>>::value,\n-                      _Elements...>;\n-\n-      template<typename... _UElements, typename\n-\t       enable_if<\n-\t\t  _TMC<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && _TMC<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n-                  && (sizeof...(_Elements) >= 1),\n-        bool>::type=true>\n-        constexpr tuple(_UElements&&... __elements)\n-        noexcept(__nothrow_constructible<_UElements...>())\n-        : _Inherited(std::forward<_UElements>(__elements)...) { }\n-\n-      template<typename... _UElements, typename\n-        enable_if<\n-\t\t  _TMC<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && !_TMC<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n-                  && (sizeof...(_Elements) >= 1),\n-        bool>::type=false>\n-        explicit constexpr tuple(_UElements&&... __elements)\n-        noexcept(__nothrow_constructible<_UElements...>())\n+\t       _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>\n+\texplicit constexpr\n+\ttuple()\n+\tnoexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)\n+\t: _Inherited() { }\n+\n+      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),\n+\t       _ImplicitCtor<_NotEmpty, const _Elements&...> = true>\n+\tconstexpr\n+\ttuple(const _Elements&... __elements)\n+\tnoexcept(__nothrow_constructible<const _Elements&...>())\n+\t: _Inherited(__elements...) { }\n+\n+      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),\n+\t       _ExplicitCtor<_NotEmpty, const _Elements&...> = false>\n+\texplicit constexpr\n+\ttuple(const _Elements&... __elements)\n+\tnoexcept(__nothrow_constructible<const _Elements&...>())\n+\t: _Inherited(__elements...) { }\n+\n+      template<typename... _UElements,\n+\t       bool _Valid = __valid_args<_UElements...>(),\n+\t       _ImplicitCtor<_Valid, _UElements...> = true>\n+\tconstexpr\n+\ttuple(_UElements&&... __elements)\n+\tnoexcept(__nothrow_constructible<_UElements...>())\n+\t: _Inherited(std::forward<_UElements>(__elements)...) { }\n+\n+      template<typename... _UElements,\n+\t       bool _Valid = __valid_args<_UElements...>(),\n+\t       _ExplicitCtor<_Valid, _UElements...> = false>\n+\texplicit constexpr\n+\ttuple(_UElements&&... __elements)\n+\tnoexcept(__nothrow_constructible<_UElements...>())\n \t: _Inherited(std::forward<_UElements>(__elements)...) {\t}\n \n       constexpr tuple(const tuple&) = default;\n \n       constexpr tuple(tuple&&) = default;\n \n-      // Shortcut for the cases where constructors taking tuples\n-      // must avoid creating temporaries.\n-      template<typename _Dummy> using _TNTC =\n-        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,\n-            _Elements...>;\n-\n-      template<typename... _UElements, typename _Dummy = void, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _ConstructibleTuple<_UElements...>()\n-                  && _TMCT<_UElements...>::template\n-                    _ImplicitlyConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<const tuple<_UElements...>&>(),\n-        bool>::type=true>\n-        constexpr tuple(const tuple<_UElements...>& __in)\n-        noexcept(__nothrow_constructible<const _UElements&...>())\n-        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n-        { }\n-\n-      template<typename... _UElements, typename _Dummy = void, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _ConstructibleTuple<_UElements...>()\n-                  && !_TMCT<_UElements...>::template\n-                    _ImplicitlyConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<const tuple<_UElements...>&>(),\n-        bool>::type=false>\n-        explicit constexpr tuple(const tuple<_UElements...>& __in)\n-        noexcept(__nothrow_constructible<const _UElements&...>())\n-        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n-        { }\n-\n-      template<typename... _UElements, typename _Dummy = void, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && _TMCT<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<tuple<_UElements...>&&>(),\n-        bool>::type=true>\n-        constexpr tuple(tuple<_UElements...>&& __in)\n-        noexcept(__nothrow_constructible<_UElements...>())\n-        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n-\n-      template<typename... _UElements, typename _Dummy = void, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && !_TMCT<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<tuple<_UElements...>&&>(),\n-        bool>::type=false>\n-        explicit constexpr tuple(tuple<_UElements...>&& __in)\n-        noexcept(__nothrow_constructible<_UElements...>())\n-        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n+      template<typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t   && !__use_other_ctor<const tuple<_UElements...>&>(),\n+\t       _ImplicitCtor<_Valid, const _UElements&...> = true>\n+\tconstexpr\n+\ttuple(const tuple<_UElements...>& __in)\n+\tnoexcept(__nothrow_constructible<const _UElements&...>())\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n+\n+      template<typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t   && !__use_other_ctor<const tuple<_UElements...>&>(),\n+\t       _ExplicitCtor<_Valid, const _UElements&...> = false>\n+\texplicit constexpr\n+\ttuple(const tuple<_UElements...>& __in)\n+\tnoexcept(__nothrow_constructible<const _UElements&...>())\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n+\n+      template<typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t     && !__use_other_ctor<tuple<_UElements...>&&>(),\n+\t       _ImplicitCtor<_Valid, _UElements...> = true>\n+\tconstexpr\n+\ttuple(tuple<_UElements...>&& __in)\n+\tnoexcept(__nothrow_constructible<_UElements...>())\n+\t: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n+\n+      template<typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t     && !__use_other_ctor<tuple<_UElements...>&&>(),\n+\t       _ExplicitCtor<_Valid, _UElements...> = false>\n+\texplicit constexpr\n+\ttuple(tuple<_UElements...>&& __in)\n+\tnoexcept(__nothrow_constructible<_UElements...>())\n+\t: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n \n       // Allocator-extended constructors.\n \n-      template<typename _Alloc>\n+      template<typename _Alloc,\n+\t       _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a)\n \t: _Inherited(__tag, __a) { }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-               typename enable_if<\n-                 _TCC<_Dummy>::template\n-                   _ConstructibleTuple<_Elements...>()\n-                 && _TCC<_Dummy>::template\n-                   _ImplicitlyConvertibleTuple<_Elements...>(),\n-               bool>::type=true>\n+      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),\n+\t       _ImplicitCtor<_NotEmpty, const _Elements&...> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const _Elements&... __elements)\n \t: _Inherited(__tag, __a, __elements...) { }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-               typename enable_if<\n-                 _TCC<_Dummy>::template\n-                   _ConstructibleTuple<_Elements...>()\n-                 && !_TCC<_Dummy>::template\n-                   _ImplicitlyConvertibleTuple<_Elements...>(),\n-               bool>::type=false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n-                       const _Elements&... __elements)\n+      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),\n+\t       _ExplicitCtor<_NotEmpty, const _Elements&...> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const _Elements&... __elements)\n \t: _Inherited(__tag, __a, __elements...) { }\n \n-      template<typename _Alloc, typename... _UElements, typename\n-        enable_if<_TMC<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && _TMC<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n-        bool>::type=true>\n+      template<typename _Alloc, typename... _UElements,\n+\t       bool _Valid = __valid_args<_UElements...>(),\n+\t       _ImplicitCtor<_Valid, _UElements...> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      _UElements&&... __elements)\n \t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n-       \t{ }\n-\n-      template<typename _Alloc, typename... _UElements, typename\n-        enable_if<_TMC<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && !_TMC<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n-        bool>::type=false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t{ }\n+\n+      template<typename _Alloc, typename... _UElements,\n+\t\t bool _Valid = __valid_args<_UElements...>(),\n+\t       _ExplicitCtor<_Valid, _UElements...> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      _UElements&&... __elements)\n \t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n-        { }\n+\t{ }\n \n       template<typename _Alloc>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n@@ -767,61 +721,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-\t       typename... _UElements, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _ConstructibleTuple<_UElements...>()\n-                  && _TMCT<_UElements...>::template\n-                    _ImplicitlyConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<tuple<_UElements...>&&>(),\n-        bool>::type=true>\n+      template<typename _Alloc, typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t     && !__use_other_ctor<const tuple<_UElements...>&>(),\n+\t       _ImplicitCtor<_Valid, const _UElements&...> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_UElements...>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-\t       typename... _UElements, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _ConstructibleTuple<_UElements...>()\n-                  && !_TMCT<_UElements...>::template\n-                    _ImplicitlyConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<tuple<_UElements...>&&>(),\n-        bool>::type=false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+      template<typename _Alloc, typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t     && !__use_other_ctor<const tuple<_UElements...>&>(),\n+\t       _ExplicitCtor<_Valid, const _UElements&...> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_UElements...>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-\t       typename... _UElements, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && _TMCT<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<tuple<_UElements...>&&>(),\n-        bool>::type=true>\n+      template<typename _Alloc, typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t     && !__use_other_ctor<tuple<_UElements...>&&>(),\n+\t       _ImplicitCtor<_Valid, _UElements...> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      tuple<_UElements...>&& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-\t       typename... _UElements, typename\n-        enable_if<_TMCT<_UElements...>::template\n-                    _MoveConstructibleTuple<_UElements...>()\n-                  && !_TMCT<_UElements...>::template\n-                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n-                  && _TNTC<_Dummy>::template\n-                    _NonNestedTuple<tuple<_UElements...>&&>(),\n-        bool>::type=false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+      template<typename _Alloc, typename... _UElements,\n+\t       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))\n+\t\t\t     && !__use_other_ctor<tuple<_UElements...>&&>(),\n+\t       _ExplicitCtor<_Valid, _UElements...> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      tuple<_UElements...>&& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n@@ -910,6 +846,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n \n+      // Constraint for non-explicit default constructor\n+      template<bool _Dummy, typename _U1, typename _U2>\n+\tusing _ImplicitDefaultCtor = __enable_if_t<\n+\t  _TupleConstraints<_Dummy, _U1, _U2>::\n+\t    __is_implicitly_default_constructible(),\n+\t  bool>;\n+\n+      // Constraint for explicit default constructor\n+      template<bool _Dummy, typename _U1, typename _U2>\n+\tusing _ExplicitDefaultCtor = __enable_if_t<\n+\t  _TupleConstraints<_Dummy, _U1, _U2>::\n+\t    __is_explicitly_default_constructible(),\n+\t  bool>;\n+\n+      template<bool _Dummy>\n+\tusing _TCC = _TupleConstraints<_Dummy, _T1, _T2>;\n+\n+      // Constraint for non-explicit constructors\n+      template<bool _Cond, typename _U1, typename _U2>\n+\tusing _ImplicitCtor = __enable_if_t<\n+\t  _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),\n+\t  bool>;\n+\n+      // Constraint for non-explicit constructors\n+      template<bool _Cond, typename _U1, typename _U2>\n+\tusing _ExplicitCtor = __enable_if_t<\n+\t  _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),\n+\t  bool>;\n+\n       template<typename _U1, typename _U2>\n \tstatic constexpr bool __assignable()\n \t{\n@@ -937,215 +902,146 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t      is_nothrow_default_constructible<_T2>>::value;\n       }\n \n+      template<typename _U1>\n+\tstatic constexpr bool __is_alloc_arg()\n+\t{ return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }\n+\n     public:\n-      template <typename _U1 = _T1,\n-                typename _U2 = _T2,\n-                typename enable_if<__and_<\n-                                     __is_implicitly_default_constructible<_U1>,\n-                                     __is_implicitly_default_constructible<_U2>>\n-                                   ::value, bool>::type = true>\n-\tconstexpr tuple()\n+      template<bool _Dummy = true,\n+\t       _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>\n+\tconstexpr\n+\ttuple()\n \tnoexcept(__nothrow_default_constructible())\n \t: _Inherited() { }\n \n-      template <typename _U1 = _T1,\n-                typename _U2 = _T2,\n-                typename enable_if<\n-                  __and_<\n-                    is_default_constructible<_U1>,\n-                    is_default_constructible<_U2>,\n-                    __not_<\n-                      __and_<__is_implicitly_default_constructible<_U1>,\n-                             __is_implicitly_default_constructible<_U2>>>>\n-                  ::value, bool>::type = false>\n-\texplicit constexpr tuple()\n+      template<bool _Dummy = true,\n+\t       _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>\n+\texplicit constexpr\n+\ttuple()\n \tnoexcept(__nothrow_default_constructible())\n \t: _Inherited() { }\n \n-      // Shortcut for the cases where constructors taking _T1, _T2\n-      // need to be constrained.\n-      template<typename _Dummy> using _TCC =\n-        _TC<is_same<_Dummy, void>::value, _T1, _T2>;\n-\n-      template<typename _Dummy = void, typename\n-               enable_if<_TCC<_Dummy>::template\n-                           _ConstructibleTuple<_T1, _T2>()\n-                         && _TCC<_Dummy>::template\n-                           _ImplicitlyConvertibleTuple<_T1, _T2>(),\n-\tbool>::type = true>\n-        constexpr tuple(const _T1& __a1, const _T2& __a2)\n-        noexcept(__nothrow_constructible<const _T1&, const _T2&>())\n-        : _Inherited(__a1, __a2) { }\n-\n-      template<typename _Dummy = void, typename\n-               enable_if<_TCC<_Dummy>::template\n-                           _ConstructibleTuple<_T1, _T2>()\n-                         && !_TCC<_Dummy>::template\n-                           _ImplicitlyConvertibleTuple<_T1, _T2>(),\n-\tbool>::type = false>\n-        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)\n-        noexcept(__nothrow_constructible<const _T1&, const _T2&>())\n-        : _Inherited(__a1, __a2) { }\n-\n-      // Shortcut for the cases where constructors taking _U1, _U2\n-      // need to be constrained.\n-      using _TMC = _TC<true, _T1, _T2>;\n-\n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()\n-\t          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,\n-\tbool>::type = true>\n-        constexpr tuple(_U1&& __a1, _U2&& __a2)\n-        noexcept(__nothrow_constructible<_U1, _U2>())\n+      template<bool _Dummy = true,\n+\t       _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>\n+\tconstexpr\n+\ttuple(const _T1& __a1, const _T2& __a2)\n+\tnoexcept(__nothrow_constructible<const _T1&, const _T2&>())\n+\t: _Inherited(__a1, __a2) { }\n+\n+      template<bool _Dummy = true,\n+\t       _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>\n+\texplicit constexpr\n+\ttuple(const _T1& __a1, const _T2& __a2)\n+\tnoexcept(__nothrow_constructible<const _T1&, const _T2&>())\n+\t: _Inherited(__a1, __a2) { }\n+\n+      template<typename _U1, typename _U2,\n+\t       _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>\n+\tconstexpr\n+\ttuple(_U1&& __a1, _U2&& __a2)\n+\tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()\n-\t          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,\n-\tbool>::type = false>\n-        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)\n-        noexcept(__nothrow_constructible<_U1, _U2>())\n+      template<typename _U1, typename _U2,\n+\t       _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>\n+\texplicit constexpr\n+\ttuple(_U1&& __a1, _U2&& __a2)\n+\tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n \n       constexpr tuple(const tuple&) = default;\n \n       constexpr tuple(tuple&&) = default;\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n-        constexpr tuple(const tuple<_U1, _U2>& __in)\n-        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n+      template<typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, const _U1&, const _U2&> = true>\n+\tconstexpr\n+\ttuple(const tuple<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-        explicit constexpr tuple(const tuple<_U1, _U2>& __in)\n-        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n+      template<typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, const _U1&, const _U2&> = false>\n+\texplicit constexpr\n+\ttuple(const tuple<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n-        constexpr tuple(tuple<_U1, _U2>&& __in)\n-        noexcept(__nothrow_constructible<_U1, _U2>())\n+      template<typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, _U1, _U2> = true>\n+\tconstexpr\n+\ttuple(tuple<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-        explicit constexpr tuple(tuple<_U1, _U2>&& __in)\n-        noexcept(__nothrow_constructible<_U1, _U2>())\n+      template<typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, _U1, _U2> = false>\n+\texplicit constexpr\n+\ttuple(tuple<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n-        constexpr tuple(const pair<_U1, _U2>& __in)\n-        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n+      template<typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, const _U1&, const _U2&> = true>\n+\tconstexpr\n+\ttuple(const pair<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(__in.first, __in.second) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-        explicit constexpr tuple(const pair<_U1, _U2>& __in)\n-        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n+      template<typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, const _U1&, const _U2&> = false>\n+\texplicit constexpr\n+\ttuple(const pair<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(__in.first, __in.second) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n-        constexpr tuple(pair<_U1, _U2>&& __in)\n-        noexcept(__nothrow_constructible<_U1, _U2>())\n+      template<typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, _U1, _U2> = true>\n+\tconstexpr\n+\ttuple(pair<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n-      template<typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-        explicit constexpr tuple(pair<_U1, _U2>&& __in)\n-        noexcept(__nothrow_constructible<_U1, _U2>())\n+      template<typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, _U1, _U2> = false>\n+\texplicit constexpr\n+\ttuple(pair<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n       // Allocator-extended constructors.\n \n-      template<typename _Alloc>\n+      template<typename _Alloc,\n+\t       _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a)\n \t: _Inherited(__tag, __a) { }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-               typename enable_if<\n-                 _TCC<_Dummy>::template\n-                   _ConstructibleTuple<_T1, _T2>()\n-                 && _TCC<_Dummy>::template\n-                   _ImplicitlyConvertibleTuple<_T1, _T2>(),\n-               bool>::type=true>\n+      template<typename _Alloc, bool _Dummy = true,\n+\t       _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const _T1& __a1, const _T2& __a2)\n \t: _Inherited(__tag, __a, __a1, __a2) { }\n \n-      template<typename _Alloc, typename _Dummy = void,\n-               typename enable_if<\n-                 _TCC<_Dummy>::template\n-                   _ConstructibleTuple<_T1, _T2>()\n-                 && !_TCC<_Dummy>::template\n-                   _ImplicitlyConvertibleTuple<_T1, _T2>(),\n-               bool>::type=false>\n-\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+      template<typename _Alloc, bool _Dummy = true,\n+\t       _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const _T1& __a1, const _T2& __a2)\n \t: _Inherited(__tag, __a, __a1, __a2) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, _U1, _U2> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)\n \t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n \t             std::forward<_U2>(__a2)) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n-                       _U1&& __a1, _U2&& __a2)\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, _U1, _U2> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      _U1&& __a1, _U2&& __a2)\n \t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n \t             std::forward<_U2>(__a2)) { }\n \n@@ -1157,89 +1053,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, const _U1&, const _U2&> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_U1, _U2>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, const _U1&, const _U2&> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const tuple<_U1, _U2>& __in)\n \t: _Inherited(__tag, __a,\n \t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, _U1, _U2> = true>\n \ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n-                       tuple<_U1, _U2>&& __in)\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, _U1, _U2> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)\n \t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n \t{ }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n-        tuple(allocator_arg_t __tag, const _Alloc& __a,\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, const _U1&, const _U2&> = true>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const pair<_U1, _U2>& __in)\n \t: _Inherited(__tag, __a, __in.first, __in.second) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _ConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, const _U1&, const _U2&> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n \t      const pair<_U1, _U2>& __in)\n \t: _Inherited(__tag, __a, __in.first, __in.second) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && _TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = true>\n-        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ImplicitCtor<true, _U1, _U2> = true>\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n \t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n-      template<typename _Alloc, typename _U1, typename _U2, typename\n-        enable_if<_TMC::template\n-                    _MoveConstructibleTuple<_U1, _U2>()\n-                  && !_TMC::template\n-                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n-\tbool>::type = false>\n-        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n-                       pair<_U1, _U2>&& __in)\n+      template<typename _Alloc, typename _U1, typename _U2,\n+\t       _ExplicitCtor<true, _U1, _U2> = false>\n+\texplicit\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n \t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n "}, {"sha": "08e7787bf4fe0e0a73e02e3b2a0b3f990522363a", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/90700.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2F90700.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2F90700.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2F90700.cc?ref=d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <tuple>\n+#include <memory>\n+\n+struct X { };\n+\n+struct Y\n+{\n+  Y(const std::tuple<X>&) = delete;\n+  Y(std::tuple<X>&&) { throw 1; }\n+  Y(const X&) { }\n+};\n+\n+struct Z\n+{\n+  Z(X&&) { }\n+  Z(const std::tuple<X>&) { throw 1; }\n+  Z(std::tuple<X>&&) = delete;\n+};\n+\n+void\n+test01()\n+{\n+  // PR libstdc++/90700 wrong constraints on constructor\n+  const std::allocator<int> a;\n+  const std::tuple<X> x;\n+\n+  static_assert(!std::is_convertible<const std::tuple<X>&, Y>::value, \"\");\n+  static_assert(!std::is_constructible<Y, const std::tuple<X>&>::value, \"\");\n+  static_assert(!std::is_same<Y, X>::value, \"\");\n+  // should use tuple<Y>::tuple<X>(allocator_arg_t, const A&, const tuple<X>&)\n+  // and construct Y from X:\n+  std::tuple<Y> y(std::allocator_arg, a, x);\n+}\n+\n+void\n+test02()\n+{\n+  const std::allocator<int> a;\n+  std::tuple<X> x;\n+\n+  static_assert(!std::is_convertible<std::tuple<X>, Z>::value, \"\");\n+  static_assert(!std::is_constructible<Z, std::tuple<X>>::value, \"\");\n+  static_assert(!std::is_same<Z, X>::value, \"\");\n+  // should use tuple<Z>::tuple<X>(allocator_arg_t, const A&, tuple<X>&&)\n+  // and construct Z from X:\n+  std::tuple<Z> z(std::allocator_arg, a, std::move(x));\n+}"}, {"sha": "c804bb884e90de8aba1420e5892a134043967618", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d355635e6b96d5d9e67a526b6dfd534cd9a9dd57/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fallocators.cc?ref=d355635e6b96d5d9e67a526b6dfd534cd9a9dd57", "patch": "@@ -186,18 +186,33 @@ void test03()\n   struct dr2586\n   {\n     using allocator_type = std::allocator<int>;\n+    dr2586() { }\n     dr2586(std::allocator_arg_t, allocator_type&&) { }\n-    dr2586(const allocator_type&) { }\n+    dr2586(const allocator_type&) : expected(true) { }\n+    bool expected = false;\n   };\n \n   const dr2586::allocator_type a;\n   std::tuple<dr2586> t{std::allocator_arg, a};\n+  VERIFY( std::get<0>(t).expected );\n+}\n+\n+void test04()\n+{\n+  struct X {\n+    X(std::allocator_arg_t) { }\n+  };\n+\n+  // The element types are not default constructible, so the allocator-extended\n+  // default constructor should not participate in overload resolution.\n+  std::tuple<X, void(&)()> t(std::allocator_arg, *+[]{});\n }\n \n int main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n   return 0;\n }"}]}