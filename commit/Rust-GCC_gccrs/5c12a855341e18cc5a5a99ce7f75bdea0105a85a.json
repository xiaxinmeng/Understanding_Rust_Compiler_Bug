{"sha": "5c12a855341e18cc5a5a99ce7f75bdea0105a85a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMxMmE4NTUzNDFlMThjYzVhNWE5OWNlN2Y3NWJkZWEwMTA1YTg1YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-21T00:01:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-21T00:01:50Z"}, "message": "[libiberty patch] PEX-unix forking\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg01170.html\n\t* pex-unix.c (pex_child_error): Delete.\n\t(pex_unix_exec_child): Commonize error paths to single message &\n\texit.\n\nFrom-SVN: r263679", "tree": {"sha": "6971600931bce9f69392811ac995b47717686d7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6971600931bce9f69392811ac995b47717686d7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c12a855341e18cc5a5a99ce7f75bdea0105a85a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c12a855341e18cc5a5a99ce7f75bdea0105a85a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c12a855341e18cc5a5a99ce7f75bdea0105a85a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c12a855341e18cc5a5a99ce7f75bdea0105a85a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7e94dc09a4470fde623197382e8dea4553e2d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e94dc09a4470fde623197382e8dea4553e2d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e94dc09a4470fde623197382e8dea4553e2d6b"}], "stats": {"total": 163, "additions": 77, "deletions": 86}, "files": [{"sha": "22d995f8cfb80bccddeb8865571ca84e86e5f01c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c12a855341e18cc5a5a99ce7f75bdea0105a85a/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c12a855341e18cc5a5a99ce7f75bdea0105a85a/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5c12a855341e18cc5a5a99ce7f75bdea0105a85a", "patch": "@@ -1,3 +1,9 @@\n+2018-08-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* pex-unix.c (pex_child_error): Delete.\n+\t(pex_unix_exec_child): Commonize error paths to single message &\n+\texit.\n+\n 2018-07-30  Tom Tromey  <tom@tromey.com>\n \n \t* cplus-dem.c (remember_Btype): Don't call memcpy with LEN==0."}, {"sha": "ea5ee4c141bbac682e0dd89e7e4ae65e1db45f22", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 71, "deletions": 86, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c12a855341e18cc5a5a99ce7f75bdea0105a85a/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c12a855341e18cc5a5a99ce7f75bdea0105a85a/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=5c12a855341e18cc5a5a99ce7f75bdea0105a85a", "patch": "@@ -298,8 +298,6 @@ pex_wait (struct pex_obj *obj, pid_t pid, int *status, struct pex_time *time)\n #endif /* ! defined (HAVE_WAITPID) */\n #endif /* ! defined (HAVE_WAIT4) */\n \n-static void pex_child_error (struct pex_obj *, const char *, const char *, int)\n-     ATTRIBUTE_NORETURN;\n static int pex_unix_open_read (struct pex_obj *, const char *, int);\n static int pex_unix_open_write (struct pex_obj *, const char *, int, int);\n static pid_t pex_unix_exec_child (struct pex_obj *, int, const char *,\n@@ -366,28 +364,6 @@ pex_unix_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)\n   return close (fd);\n }\n \n-/* Report an error from a child process.  We don't use stdio routines,\n-   because we might be here due to a vfork call.  */\n-\n-static void\n-pex_child_error (struct pex_obj *obj, const char *executable,\n-\t\t const char *errmsg, int err)\n-{\n-  int retval = 0;\n-#define writeerr(s) retval |= (write (STDERR_FILE_NO, s, strlen (s)) < 0)\n-  writeerr (obj->pname);\n-  writeerr (\": error trying to exec '\");\n-  writeerr (executable);\n-  writeerr (\"': \");\n-  writeerr (errmsg);\n-  writeerr (\": \");\n-  writeerr (xstrerror (err));\n-  writeerr (\"\\n\");\n-#undef writeerr\n-  /* Exit with -2 if the error output failed, too.  */\n-  _exit (retval == 0 ? -1 : -2);\n-}\n-\n /* Execute a child.  */\n \n #if defined(HAVE_SPAWNVE) && defined(HAVE_SPAWNVPE)\n@@ -592,21 +568,22 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n                      int in, int out, int errdes,\n \t\t     int toclose, const char **errmsg, int *err)\n {\n-  pid_t pid;\n+  pid_t pid = -1;\n \n   /* We declare these to be volatile to avoid warnings from gcc about\n      them being clobbered by vfork.  */\n-  volatile int sleep_interval;\n+  volatile int sleep_interval = 1;\n   volatile int retries;\n \n   /* We vfork and then set environ in the child before calling execvp.\n      This clobbers the parent's environ so we need to restore it.\n      It would be nice to use one of the exec* functions that takes an\n-     environment as a parameter, but that may have portability issues.  */\n+     environment as a parameter, but that may have portability\n+     issues.   */\n   char **save_environ = environ;\n \n-  sleep_interval = 1;\n-  pid = -1;\n+  const char *bad_fn = NULL;\n+\n   for (retries = 0; retries < 4; ++retries)\n     {\n       pid = vfork ();\n@@ -625,57 +602,76 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \n     case 0:\n       /* Child process.  */\n-      if (in != STDIN_FILE_NO)\n+      if (!bad_fn && in != STDIN_FILE_NO)\n \t{\n \t  if (dup2 (in, STDIN_FILE_NO) < 0)\n-\t    pex_child_error (obj, executable, \"dup2\", errno);\n-\t  if (close (in) < 0)\n-\t    pex_child_error (obj, executable, \"close\", errno);\n+\t    bad_fn = \"dup2\";\n+\t  else if (close (in) < 0)\n+\t    bad_fn = \"close\";\n \t}\n-      if (out != STDOUT_FILE_NO)\n+      if (!bad_fn && out != STDOUT_FILE_NO)\n \t{\n \t  if (dup2 (out, STDOUT_FILE_NO) < 0)\n-\t    pex_child_error (obj, executable, \"dup2\", errno);\n-\t  if (close (out) < 0)\n-\t    pex_child_error (obj, executable, \"close\", errno);\n+\t    bad_fn = \"dup2\";\n+\t  else if (close (out) < 0)\n+\t    bad_fn = \"close\";\n \t}\n-      if (errdes != STDERR_FILE_NO)\n+      if (!bad_fn && errdes != STDERR_FILE_NO)\n \t{\n \t  if (dup2 (errdes, STDERR_FILE_NO) < 0)\n-\t    pex_child_error (obj, executable, \"dup2\", errno);\n-\t  if (close (errdes) < 0)\n-\t    pex_child_error (obj, executable, \"close\", errno);\n+\t    bad_fn = \"dup2\";\n+\t  else if (close (errdes) < 0)\n+\t    bad_fn = \"close\";\n \t}\n-      if (toclose >= 0)\n+      if (!bad_fn && toclose >= 0)\n \t{\n \t  if (close (toclose) < 0)\n-\t    pex_child_error (obj, executable, \"close\", errno);\n+\t    bad_fn = \"close\";\n \t}\n-      if ((flags & PEX_STDERR_TO_STDOUT) != 0)\n+      if (!bad_fn && (flags & PEX_STDERR_TO_STDOUT) != 0)\n \t{\n \t  if (dup2 (STDOUT_FILE_NO, STDERR_FILE_NO) < 0)\n-\t    pex_child_error (obj, executable, \"dup2\", errno);\n+\t    bad_fn = \"dup2\";\n \t}\n-\n-      if (env)\n+      if (!bad_fn)\n \t{\n-\t  /* NOTE: In a standard vfork implementation this clobbers the\n-\t     parent's copy of environ \"too\" (in reality there's only one copy).\n-\t     This is ok as we restore it below.  */\n-\t  environ = (char**) env;\n+\t  if (env)\n+\t    /* NOTE: In a standard vfork implementation this clobbers\n+\t       the parent's copy of environ \"too\" (in reality there's\n+\t       only one copy).  This is ok as we restore it below.  */\n+\t    environ = (char**) env;\n+\t  if ((flags & PEX_SEARCH) != 0)\n+\t    {\n+\t      execvp (executable, to_ptr32 (argv));\n+\t      bad_fn = \"execvp\";\n+\t    }\n+\t  else\n+\t    {\n+\t      execv (executable, to_ptr32 (argv));\n+\t      bad_fn = \"execv\";\n+\t    }\n \t}\n \n-      if ((flags & PEX_SEARCH) != 0)\n-\t{\n-\t  execvp (executable, to_ptr32 (argv));\n-\t  pex_child_error (obj, executable, \"execvp\", errno);\n-\t}\n-      else\n-\t{\n-\t  execv (executable, to_ptr32 (argv));\n-\t  pex_child_error (obj, executable, \"execv\", errno);\n-\t}\n+      /* Something failed, report an error.  We don't use stdio\n+\t routines, because we might be here due to a vfork call.  */\n+      {\n+\tssize_t retval = 0;\n+\tint err = errno;\n+\n+#define writeerr(s) (retval |= write (STDERR_FILE_NO, s, strlen (s)))\n+\twriteerr (obj->pname);\n+\twriteerr (\": error trying to exec '\");\n+\twriteerr (executable);\n+\twriteerr (\"': \");\n+\twriteerr (bad_fn);\n+\twriteerr (\": \");\n+\twriteerr (xstrerror (err));\n+\twriteerr (\"\\n\");\n+#undef writeerr\n \n+\t/* Exit with -2 if the error output failed, too.  */\n+\t_exit (retval < 0 ? -2 : -1);\n+      }\n       /* NOTREACHED */\n       return (pid_t) -1;\n \n@@ -689,32 +685,21 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t the child's copy of environ.  */\n       environ = save_environ;\n \n-      if (in != STDIN_FILE_NO)\n-\t{\n-\t  if (close (in) < 0)\n-\t    {\n-\t      *err = errno;\n-\t      *errmsg = \"close\";\n-\t      return (pid_t) -1;\n-\t    }\n-\t}\n-      if (out != STDOUT_FILE_NO)\n+      if (!bad_fn && in != STDIN_FILE_NO)\n+\tif (close (in) < 0)\n+\t  bad_fn = \"close\";\n+      if (!bad_fn && out != STDOUT_FILE_NO)\n+\tif (close (out) < 0)\n+\t  bad_fn = \"close\";\n+      if (!bad_fn && errdes != STDERR_FILE_NO)\n+\tif (close (errdes) < 0)\n+\t  bad_fn = \"close\";\n+\n+      if (bad_fn)\n \t{\n-\t  if (close (out) < 0)\n-\t    {\n-\t      *err = errno;\n-\t      *errmsg = \"close\";\n-\t      return (pid_t) -1;\n-\t    }\n-\t}\n-      if (errdes != STDERR_FILE_NO)\n-\t{\n-\t  if (close (errdes) < 0)\n-\t    {\n-\t      *err = errno;\n-\t      *errmsg = \"close\";\n-\t      return (pid_t) -1;\n-\t    }\n+\t  *err = errno;\n+\t  *errmsg = bad_fn;\n+\t  return (pid_t) -1;\n \t}\n \n       return pid;"}]}