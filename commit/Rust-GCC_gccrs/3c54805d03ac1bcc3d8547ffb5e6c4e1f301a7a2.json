{"sha": "3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2", "node_id": "C_kwDOANBUbNoAKDNjNTQ4MDVkMDNhYzFiY2MzZDg1NDdmZmI1ZTZjNGUxZjMwMWE3YTI", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-16T12:22:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-16T13:37:38Z"}, "message": "libstdc++: Fix std::any pretty printer\n\nThe recent changes to FilteringTypePrinter affect the result of\ngdb.lookup_type('std::string') in StdExpAnyPrinter, causing it to always\nreturn the std::__cxx11::basic_string specialization. This then causes a\ngdb.error exception when trying to lookup the std::any manager type for\na specliaization using that string, but that manager was never\ninstantiated in the program. This causes FAILs when running the tests\nwith -D_GLIBCXX_USE_CXX11_ABI=0:\n\nFAIL: libstdc++-prettyprinters/libfundts.cc print as\nFAIL: libstdc++-prettyprinters/libfundts.cc print as\n\nThe ugly solution used in this patch is to repeat the lookup for every\ntype that std::string could be a typedef for, and hope it only works for\none of them.\n\nlibstdc++-v3/ChangeLog:\n\n\t* python/libstdcxx/v6/printers.py (StdExpAnyPrinter): Make\n\texpansion of std::string in manager name more robust.", "tree": {"sha": "fe996f1a3c2f9c230f8f478495f5112ec2bb06a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe996f1a3c2f9c230f8f478495f5112ec2bb06a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "922816220210c53eb889733b5832cbd39353ff8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922816220210c53eb889733b5832cbd39353ff8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/922816220210c53eb889733b5832cbd39353ff8c"}], "stats": {"total": 31, "additions": 28, "deletions": 3}, "files": [{"sha": "1abf0a4bce36fa3b6b68d928734be6367834520a", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=3c54805d03ac1bcc3d8547ffb5e6c4e1f301a7a2", "patch": "@@ -1272,9 +1272,34 @@ def __init__ (self, typename, val):\n             mgrname = m.group(1)\n             # FIXME need to expand 'std::string' so that gdb.lookup_type works\n             if 'std::string' in mgrname:\n-                mgrname = re.sub(\"std::string(?!\\w)\", str(gdb.lookup_type('std::string').strip_typedefs()), m.group(1))\n-\n-            mgrtype = gdb.lookup_type(mgrname)\n+                # This lookup for std::string might return the __cxx11 version,\n+                # but that's not necessarily the one used by the std::any\n+                # manager function we're trying to find.\n+                strings = {str(gdb.lookup_type('std::string').strip_typedefs())}\n+                # So also consider all the other possible std::string types!\n+                s = 'basic_string<char, std::char_traits<char>, std::allocator<char> >'\n+                quals = ['std::', 'std::__cxx11::', 'std::' + _versioned_namespace]\n+                strings |= {q+s for q in quals} # set of unique strings\n+                mgrtypes = []\n+                for s in strings:\n+                    try:\n+                        x = re.sub(\"std::string(?!\\w)\", s, m.group(1))\n+                        # The following lookup might raise gdb.error if the\n+                        # manager function was never instantiated for 's' in the\n+                        # program, because there will be no such type.\n+                        mgrtypes.append(gdb.lookup_type(x))\n+                    except gdb.error:\n+                        pass\n+                if len(mgrtypes) != 1:\n+                    # FIXME: this is unlikely in practice, but possible for\n+                    # programs that use both old and new string types with\n+                    # std::any in a single program. Can we do better?\n+                    # Maybe find the address of each type's _S_manage and\n+                    # compare to the address stored in _M_manager?\n+                    raise ValueError('Cannot uniquely determine std::string type used in std::any')\n+                mgrtype = mgrtypes[0]\n+            else:\n+                mgrtype = gdb.lookup_type(mgrname)\n             self.contained_type = mgrtype.template_argument(0)\n             valptr = None\n             if '::_Manager_internal' in mgrname:"}]}