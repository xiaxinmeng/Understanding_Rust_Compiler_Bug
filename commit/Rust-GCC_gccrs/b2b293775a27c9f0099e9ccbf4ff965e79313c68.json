{"sha": "b2b293775a27c9f0099e9ccbf4ff965e79313c68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJiMjkzNzc1YTI3YzlmMDA5OWU5Y2NiZjRmZjk2NWU3OTMxM2M2OA==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-10-28T01:05:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-28T01:05:53Z"}, "message": "[PATCH 7/9] ENABLE_CHECKING refactoring: middle-end, LTO FE\n\n[PATCH 7/9] ENABLE_CHECKING refactoring: middle-end, LTO FE\ngcc/lto/ChangeLog:\n2015-10-27  Mikhail Maltsev  <maltsevm@gmail.com>\n\n\t* lto.c (unify_scc): Use flag_checking and remove ENABLE_CHECKING\n\tconditionals.\n\t(lto_fixup_state): Likewise.\n\t(do_whole_program_analysis): Use\n\tsymtab_node::checking_verify_symtab_nodes and remove ENABLE_CHECKING\n\tconditionals.\n\ngcc/ChangeLog:\n\n2015-10-27  Mikhail Maltsev  <maltsevm@gmail.com>\n\n\t* attribs.c (check_attribute_tables): New function, broken out from...\n\t(init_attributes): Use it.\n\t* cfgcleanup.c (try_optimize_cfg): Use flag_checking, CHECKING_P\n\tgcc_checking_assert and checking_* functions to eliminate\n\tENABLE_CHECKING conditionals.\n\t* cfgexpand.c (expand_goto, expand_debug_expr): Likewise.\n\t(pass_expand::execute): Likewise.\n\t* cgraphclones.c (symbol_table::materialize_all_clones): Likewise.\n\t* cgraphunit.c (mark_functions_to_output): Likewise.\n\t(cgraph_node::expand_thunk): Likewise.\n\t(symbol_table::compile): Likewise.\n\t* ddg.c (add_cross_iteration_register_deps): Likewise.\n\t(create_ddg_all_sccs): Likewise.\n\t* df-core.c (df_finish_pass, df_analyze): Likewise.\n\t* diagnostic-core.h: Likewise.\n\t* diagnostic.c (diagnostic_report_diagnostic): Likewise.\n\t* dominance.c (calculate_dominance_info): Likewise.\n\t* dwarf2out.c (add_AT_die_ref): Likewise.\n\t(const_ok_for_output_1, mem_loc_descriptor): Likewise.\n\t(loc_list_from_tree, gen_lexical_block_die): Likewise.\n\tgen_type_die_with_usage, gen_type_die): Likewise.\n\t(dwarf2out_decl): Likewise.\n\t* emit-rtl.c (verify_rtx_sharing, reorder_insns_nobb): Likewise.\n\t* except.c (duplicate_eh_regions): Likewise.\n\t* fwprop.c (register_active_defs, update_df_init): Likewise.\n\t(fwprop_init, fwprop_done): Likewise.\n\t(update_uses): Likewise.\n\t* ggc-page.c (ggc_grow): Likewise.\n\t* gimplify.c (gimplify_body): Likewise.\n\t(gimplify_hasher::equal): Likewise.\n\t* graphite-isl-ast-to-gimple.c (graphite_verify): Likewise.\n\t* graphite-scop-detection.c (canonicalize_loop_closed_ssa_form):\n\tLikewise.\n\t* graphite-sese-to-poly.c (rewrite_reductions_out_of_ssa): Likewise.\n\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Likwise.\n\t* hash-table.h (::find_empty_slot_for_expand): Likewise.\n\t* ifcvt.c (if_convert): Likewise.\n\t* ipa-cp.c (ipcp_propagate_stage): Likewise.\n\t* ipa-devirt.c (type_in_anonymous_namespace_p): Likewise.\n\t(odr_type_p, odr_types_equivalent_p): Likewise.\n\t(add_type_duplicate, get_odr_type): Likewise.\n\t* ipa-icf.c (sem_item_optimizer::execute): Likewise.\n\t(sem_item_optimizer::subdivide_classes_by_equality): Likewise.\n\t(sem_item_optimizer::verify_classes): Likewise.\n\t(sem_item_optimizer::traverse_congruence_split): Likewise.\n\t(sem_item_optimizer::checking_verify_classes): New.\n\t* ipa-icf.h (sem_item_optimizer::checking_verify_classes): Add new\n\tmethod.\n\t* cfgrtl.c (commit_edge_insertions): Likewise.\n\t(fixup_reorder_chain, cfg_layout_finalize): Likewise.\n\t(rtl_flow_call_edges_add): Likewise.\n\t* cgraph.c (symbol_table::create_edge): Likewise.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n\t* cgraph.h (symtab_node): Likewise.\n\t(symtab_node::checking_verify_symtab_nodes): Define.\n\t(cgraph_node::checking_verify_cgraph_nodes): Define.\n\t* cfghooks.h (checking_verify_flow_info): Define.\n\t* cfgloop.h (checking_verify_loop_structure): Define.\n\t* dominance.h (checking_verify_dominators): Define.\n\t* et-forest.c: Fix comment.\n\t* ipa-inline-analysis.c (compute_inline_parameters): Use flag_checking,\n\tCHECKING_P gcc_checking_assert and checking_* functions to eliminate\n\tENABLE_CHECKING conditionals.\n\t* ipa-inline-transform.c (save_inline_function_body): Likewise.\n\t* ipa-inline.c (inline_small_functions): Likewise.\n\t(early_inliner): Likewise.\n\t* ipa-inline.h (estimate_edge_growth): Likewise.\n\t* ipa-visibility.c (function_and_variable_visibility): Likewise.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Likewise.\n\t(ipa_single_use): Likewise.\n\t* ira-int.h: Likewise.\n\t* ira.c (ira): Likewise.\n\t* loop-doloop.c (doloop_optimize_loops): Likewise.\n\t* loop-init.c (loop_optimizer_init, fix_loop_structure): Likewise.\n\t* loop-invariant.c (move_loop_invariants): Likewise.\n\t* lra-assigns.c (lra_assign): Likewise.\n\t* lra-constraints.c (lra_constraints): Likewise.\n\t* lra-eliminations.c (lra_eliminate): Likewise.\n\t* lra-int.h (struct lra_reg): Likewise.\n\t* lra-lives.c (check_pseudos_live_through_calls): Likewise.\n\t(lra_create_live_ranges_1): Likewise.\n\t* lra-remat.c (create_remat_bb_data): Likewise.\n\t* lra.c (lra_update_insn_recog_data, restore_scratches): Likewise.\n\t(lra): Likewise.\n\t(check_rtl): Always define. Remove incorrect guard around\n\textract_constrain_insn call.\n\t* lto-cgraph.c (input_cgraph_1: Use flag_checking,\n\tCHECKING_P gcc_checking_assert and checking_* functions to eliminate\n\tENABLE_CHECKING conditionals.\n\t* lto-streamer-out.c (DFS::DFS): Likewise.\n\t(lto_output): Likewise.\n\t* lto-streamer.c (lto_streamer_init): Likewise.\n\t* omp-low.c (scan_omp_target, expand_omp_taskreg): Likewise.\n\texpand_omp_target, execute_expand_omp): Likewise.\n\t(lower_omp_target): Likewise.\n\t* passes.c (execute_function_todo): Likewise.\n\t(execute_todo, execute_one_pass): Likewise.\n\t(verify_curr_properties): Always define.\n\t* predict.c (tree_estimate_probability: Use flag_checking,\n\tCHECKING_P gcc_checking_assert and checking_* functions to eliminate\n\tENABLE_CHECKING conditionals.\n\t(propagate_freq): Likewise.\n\t* pretty-print.c (pp_format): Likewise.\n\t* real.c (real_to_decimal_for_mode): Likewise.\n\t* recog.c (split_all_insns): Likewise.\n\t* regcprop.c (kill_value_one_regno): Likewise.\n\t(copy_value): Likewise.\n\t(validate_value_data): Define unconditionally.\n\t* reload.c: Fix comment.\n\t* timevar.c: Include options.h\n\t* tree-ssa.h (checking_verify_ssa): Define.\n\t* tree-ssa-loop-manip.h (checking_verify_loop_closed_ssa): Define.\n\t* sched-deps.c (CHECK): Remove unused macro.\n\t(add_or_update_dep_1, sd_add_dep: Use flag_checking, CHECKING_P\n\tgcc_checking_assert and checking_* functions to eliminate\n\tENABLE_CHECKING conditionals.\n\t* sel-sched-ir.c (free_regset_pool, tidy_control_flow): Likewise.\n\t* sel-sched.c (struct moveop_static_params): Likewise.\n\t(find_best_reg_for_expr, move_cond_jump): Likewise.\n\t(move_op_orig_expr_not_found): Likewise.\n\t(code_motion_process_successors, move_op): Likewise.\n\t* ssa-iterators.h (first_readonly_imm_use): Likewise.\n\t(next_readonly_imm_use): Likewise.\n\t* store-motion.c (compute_store_table): Likewise.\n\t* symbol-summary.h (function_summary::function_summary): Likewise.\n\t* target.h (cumulative_args_t): Likewise.\n\t(get_cumulative_args, pack_cumulative_args): Likewise.\n\t* timevar.c: (timer::print): Likewise.\n\t* trans-mem.c (ipa_tm_execute): Likewise.\n\t* tree-cfg.c (move_stmt_op): Likewise.\n\t(move_sese_region_to_fn): Likewise.\n\t(gimple_flow_call_edges_add): Likewise.\n\t* tree-cfgcleanup.c (cleanup_tree_cfg_noloop, repair_loop_structures):\n\tLikewise.\n\t* tree-eh.c (remove_unreachable_handlers): Likewise.\n\t* tree-if-conv.c (pass_if_conversion::execute): Likewise.\n\t* tree-inline.c (expand_call_inline, optimize_inline_calls): Likewise.\n\t* tree-into-ssa.c (update_ssa): Likewise.\n\t* tree-loop-distribution.c (pass_loop_distribution::execute): Likewise.\n\t* tree-outof-ssa.c (eliminate_useless_phis, rewrite_trees): Likewise.\n\t* tree-parloops.c (pass_parallelize_loops::execute): Likewise.\n\t* tree-predcom.c (suitable_component_p): Likewise.\n\t* tree-profile.c (gimple_gen_const_delta_profiler): Likewise.\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Likewise.\n\t* tree-ssa-live.c (verify_live_on_entry): Likewise.\n\t* tree-ssa-live.h (register_ssa_partition): Likewise.\n\t* tree-ssa-loop-ivcanon.c (tree_unroll_loops_completely): Likewise.\n\t* tree-ssa-loop-manip.c (add_exit_phi): Likewise.\n\t(tree_transform_and_unroll_loop): Likewise.\n\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree-ssa-propagate.c (replace_exp_1): Likewise.\n\t* tree-ssa-structalias.c (rewrite_constraints): Likewise.\n\t* tree-ssa-ter.c (free_temp_expr_table): Likewise.\n\t* tree-ssa-threadupdate.c (duplicate_thread_path): Likewise.\n\t* tree-ssanames.c (release_ssa_name_fn): Likewise.\n\t* tree-stdarg.c (expand_ifn_va_arg): Likewise.\n\t* tree-vect-loop-manip.c\n\t(slpeel_tree_duplicate_loop_to_edge_cfg): Likewise.\n\t(slpeel_checking_verify_cfg_after_peeling): Likewise.\n\t(vect_do_peeling_for_loop_bound): Likewise.\n\t(vect_do_peeling_for_alignment): Likewise.\n\t* tree-vrp.c (supports_overflow_infinity): Likewise.\n\t(set_value_range): Likewise.\n\t* tree.c (free_lang_data_in_cgraph): Likewise.\n\t* value-prof.c (gimple_remove_histogram_value): Likewise.\n\t(free_hist): Likewise.\n\t* var-tracking.c (canonicalize_values_star): Likewise.\n\t(compute_bb_dataflow, vt_find_locations, vt_emit_notes): Likewise.\n\nFrom-SVN: r229470", "tree": {"sha": "6dea5725e0326fbaa54c656cfc3a0921c3884e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dea5725e0326fbaa54c656cfc3a0921c3884e38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2b293775a27c9f0099e9ccbf4ff965e79313c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2b293775a27c9f0099e9ccbf4ff965e79313c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2b293775a27c9f0099e9ccbf4ff965e79313c68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2b293775a27c9f0099e9ccbf4ff965e79313c68/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15517b4e79d3c59cc837c6806f2928afc8a7057b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15517b4e79d3c59cc837c6806f2928afc8a7057b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15517b4e79d3c59cc837c6806f2928afc8a7057b"}], "stats": {"total": 1835, "additions": 917, "deletions": 918}, "files": [{"sha": "2e88f597586b965d20bdd77304cc2bfe442bb071", "filename": "gcc/ChangeLog", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1,3 +1,175 @@\n+2015-10-27  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* attribs.c (check_attribute_tables): New function, broken out from...\n+\t(init_attributes): Use it.\n+\t* cfgcleanup.c (try_optimize_cfg): Use flag_checking, CHECKING_P\n+\tgcc_checking_assert and checking_* functions to eliminate\n+\tENABLE_CHECKING conditionals.\n+\t* cfgexpand.c (expand_goto, expand_debug_expr): Likewise.\n+\t(pass_expand::execute): Likewise.\n+\t* cgraphclones.c (symbol_table::materialize_all_clones): Likewise.\n+\t* cgraphunit.c (mark_functions_to_output): Likewise.\n+\t(cgraph_node::expand_thunk): Likewise.\n+\t(symbol_table::compile): Likewise.\n+\t* ddg.c (add_cross_iteration_register_deps): Likewise.\n+\t(create_ddg_all_sccs): Likewise.\n+\t* df-core.c (df_finish_pass, df_analyze): Likewise.\n+\t* diagnostic-core.h: Likewise.\n+\t* diagnostic.c (diagnostic_report_diagnostic): Likewise.\n+\t* dominance.c (calculate_dominance_info): Likewise.\n+\t* dwarf2out.c (add_AT_die_ref): Likewise.\n+\t(const_ok_for_output_1, mem_loc_descriptor): Likewise.\n+\t(loc_list_from_tree, gen_lexical_block_die): Likewise.\n+\tgen_type_die_with_usage, gen_type_die): Likewise.\n+\t(dwarf2out_decl): Likewise.\n+\t* emit-rtl.c (verify_rtx_sharing, reorder_insns_nobb): Likewise.\n+\t* except.c (duplicate_eh_regions): Likewise.\n+\t* fwprop.c (register_active_defs, update_df_init): Likewise.\n+\t(fwprop_init, fwprop_done): Likewise.\n+\t(update_uses): Likewise.\n+\t* ggc-page.c (ggc_grow): Likewise.\n+\t* gimplify.c (gimplify_body): Likewise.\n+\t(gimplify_hasher::equal): Likewise.\n+\t* graphite-isl-ast-to-gimple.c (graphite_verify): Likewise.\n+\t* graphite-scop-detection.c (canonicalize_loop_closed_ssa_form):\n+\tLikewise.\n+\t* graphite-sese-to-poly.c (rewrite_reductions_out_of_ssa): Likewise.\n+\t(rewrite_cross_bb_scalar_deps_out_of_ssa): Likwise.\n+\t* hash-table.h (::find_empty_slot_for_expand): Likewise.\n+\t* ifcvt.c (if_convert): Likewise.\n+\t* ipa-cp.c (ipcp_propagate_stage): Likewise.\n+\t* ipa-devirt.c (type_in_anonymous_namespace_p): Likewise.\n+\t(odr_type_p, odr_types_equivalent_p): Likewise.\n+\t(add_type_duplicate, get_odr_type): Likewise.\n+\t* ipa-icf.c (sem_item_optimizer::execute): Likewise.\n+\t(sem_item_optimizer::subdivide_classes_by_equality): Likewise.\n+\t(sem_item_optimizer::verify_classes): Likewise.\n+\t(sem_item_optimizer::traverse_congruence_split): Likewise.\n+\t(sem_item_optimizer::checking_verify_classes): New.\n+\t* ipa-icf.h (sem_item_optimizer::checking_verify_classes): Add new\n+\tmethod.\n+\t* cfgrtl.c (commit_edge_insertions): Likewise.\n+\t(fixup_reorder_chain, cfg_layout_finalize): Likewise.\n+\t(rtl_flow_call_edges_add): Likewise.\n+\t* cgraph.c (symbol_table::create_edge): Likewise.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n+\t* cgraph.h (symtab_node): Likewise.\n+\t(symtab_node::checking_verify_symtab_nodes): Define.\n+\t(cgraph_node::checking_verify_cgraph_nodes): Define.\n+\t* cfghooks.h (checking_verify_flow_info): Define.\n+\t* cfgloop.h (checking_verify_loop_structure): Define.\n+\t* dominance.h (checking_verify_dominators): Define.\n+\t* et-forest.c: Fix comment.\n+\t* ipa-inline-analysis.c (compute_inline_parameters): Use flag_checking,\n+\tCHECKING_P gcc_checking_assert and checking_* functions to eliminate\n+\tENABLE_CHECKING conditionals.\n+\t* ipa-inline-transform.c (save_inline_function_body): Likewise.\n+\t* ipa-inline.c (inline_small_functions): Likewise.\n+\t(early_inliner): Likewise.\n+\t* ipa-inline.h (estimate_edge_growth): Likewise.\n+\t* ipa-visibility.c (function_and_variable_visibility): Likewise.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Likewise.\n+\t(ipa_single_use): Likewise.\n+\t* ira-int.h: Likewise.\n+\t* ira.c (ira): Likewise.\n+\t* loop-doloop.c (doloop_optimize_loops): Likewise.\n+\t* loop-init.c (loop_optimizer_init, fix_loop_structure): Likewise.\n+\t* loop-invariant.c (move_loop_invariants): Likewise.\n+\t* lra-assigns.c (lra_assign): Likewise.\n+\t* lra-constraints.c (lra_constraints): Likewise.\n+\t* lra-eliminations.c (lra_eliminate): Likewise.\n+\t* lra-int.h (struct lra_reg): Likewise.\n+\t* lra-lives.c (check_pseudos_live_through_calls): Likewise.\n+\t(lra_create_live_ranges_1): Likewise.\n+\t* lra-remat.c (create_remat_bb_data): Likewise.\n+\t* lra.c (lra_update_insn_recog_data, restore_scratches): Likewise.\n+\t(lra): Likewise.\n+\t(check_rtl): Always define. Remove incorrect guard around\n+\textract_constrain_insn call.\n+\t* lto-cgraph.c (input_cgraph_1: Use flag_checking,\n+\tCHECKING_P gcc_checking_assert and checking_* functions to eliminate\n+\tENABLE_CHECKING conditionals.\n+\t* lto-streamer-out.c (DFS::DFS): Likewise.\n+\t(lto_output): Likewise.\n+\t* lto-streamer.c (lto_streamer_init): Likewise.\n+\t* omp-low.c (scan_omp_target, expand_omp_taskreg): Likewise.\n+\texpand_omp_target, execute_expand_omp): Likewise.\n+\t(lower_omp_target): Likewise.\n+\t* passes.c (execute_function_todo): Likewise.\n+\t(execute_todo, execute_one_pass): Likewise.\n+\t(verify_curr_properties): Always define.\n+\t* predict.c (tree_estimate_probability: Use flag_checking,\n+\tCHECKING_P gcc_checking_assert and checking_* functions to eliminate\n+\tENABLE_CHECKING conditionals.\n+\t(propagate_freq): Likewise.\n+\t* pretty-print.c (pp_format): Likewise.\n+\t* real.c (real_to_decimal_for_mode): Likewise.\n+\t* recog.c (split_all_insns): Likewise.\n+\t* regcprop.c (kill_value_one_regno): Likewise.\n+\t(copy_value): Likewise.\n+\t(validate_value_data): Define unconditionally.\n+\t* reload.c: Fix comment.\n+\t* timevar.c: Include options.h\n+\t* tree-ssa.h (checking_verify_ssa): Define.\n+\t* tree-ssa-loop-manip.h (checking_verify_loop_closed_ssa): Define.\n+\t* sched-deps.c (CHECK): Remove unused macro.\n+\t(add_or_update_dep_1, sd_add_dep: Use flag_checking, CHECKING_P\n+\tgcc_checking_assert and checking_* functions to eliminate\n+\tENABLE_CHECKING conditionals.\n+\t* sel-sched-ir.c (free_regset_pool, tidy_control_flow): Likewise.\n+\t* sel-sched.c (struct moveop_static_params): Likewise.\n+\t(find_best_reg_for_expr, move_cond_jump): Likewise.\n+\t(move_op_orig_expr_not_found): Likewise.\n+\t(code_motion_process_successors, move_op): Likewise.\n+\t* ssa-iterators.h (first_readonly_imm_use): Likewise.\n+\t(next_readonly_imm_use): Likewise.\n+\t* store-motion.c (compute_store_table): Likewise.\n+\t* symbol-summary.h (function_summary::function_summary): Likewise.\n+\t* target.h (cumulative_args_t): Likewise.\n+\t(get_cumulative_args, pack_cumulative_args): Likewise.\n+\t* timevar.c: (timer::print): Likewise.\n+\t* trans-mem.c (ipa_tm_execute): Likewise.\n+\t* tree-cfg.c (move_stmt_op): Likewise.\n+\t(move_sese_region_to_fn): Likewise.\n+\t(gimple_flow_call_edges_add): Likewise.\n+\t* tree-cfgcleanup.c (cleanup_tree_cfg_noloop, repair_loop_structures):\n+\tLikewise.\n+\t* tree-eh.c (remove_unreachable_handlers): Likewise.\n+\t* tree-if-conv.c (pass_if_conversion::execute): Likewise.\n+\t* tree-inline.c (expand_call_inline, optimize_inline_calls): Likewise.\n+\t* tree-into-ssa.c (update_ssa): Likewise.\n+\t* tree-loop-distribution.c (pass_loop_distribution::execute): Likewise.\n+\t* tree-outof-ssa.c (eliminate_useless_phis, rewrite_trees): Likewise.\n+\t* tree-parloops.c (pass_parallelize_loops::execute): Likewise.\n+\t* tree-predcom.c (suitable_component_p): Likewise.\n+\t* tree-profile.c (gimple_gen_const_delta_profiler): Likewise.\n+\t* tree-ssa-alias.c (refs_may_alias_p_1): Likewise.\n+\t* tree-ssa-live.c (verify_live_on_entry): Likewise.\n+\t* tree-ssa-live.h (register_ssa_partition): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (tree_unroll_loops_completely): Likewise.\n+\t* tree-ssa-loop-manip.c (add_exit_phi): Likewise.\n+\t(tree_transform_and_unroll_loop): Likewise.\n+\t* tree-ssa-math-opts.c (pass_cse_reciprocals::execute): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-ssa-propagate.c (replace_exp_1): Likewise.\n+\t* tree-ssa-structalias.c (rewrite_constraints): Likewise.\n+\t* tree-ssa-ter.c (free_temp_expr_table): Likewise.\n+\t* tree-ssa-threadupdate.c (duplicate_thread_path): Likewise.\n+\t* tree-ssanames.c (release_ssa_name_fn): Likewise.\n+\t* tree-stdarg.c (expand_ifn_va_arg): Likewise.\n+\t* tree-vect-loop-manip.c\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): Likewise.\n+\t(slpeel_checking_verify_cfg_after_peeling): Likewise.\n+\t(vect_do_peeling_for_loop_bound): Likewise.\n+\t(vect_do_peeling_for_alignment): Likewise.\n+\t* tree-vrp.c (supports_overflow_infinity): Likewise.\n+\t(set_value_range): Likewise.\n+\t* tree.c (free_lang_data_in_cgraph): Likewise.\n+\t* value-prof.c (gimple_remove_histogram_value): Likewise.\n+\t(free_hist): Likewise.\n+\t* var-tracking.c (canonicalize_values_star): Likewise.\n+\t(compute_bb_dataflow, vt_find_locations, vt_emit_notes): Likewise.\n+\n 2015-10-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* internal-fn.def (IFN_GOACC_DIM_SIZE, IFN_GOACC_DIM_POS,"}, {"sha": "e7af7b043d10cf6b3e532ba8354c8b76861b1c4c", "filename": "gcc/attribs.c", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -174,8 +174,58 @@ find_attribute_namespace (const char* ns)\n   return NULL;\n }\n \n-/* Initialize attribute tables, and make some sanity checks\n-   if --enable-checking.  */\n+/* Make some sanity checks on the attribute tables.  */\n+\n+static void\n+check_attribute_tables (void)\n+{\n+  for (size_t i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n+    for (size_t j = 0; attribute_tables[i][j].name != NULL; j++)\n+      {\n+\t/* The name must not begin and end with __.  */\n+\tconst char *name = attribute_tables[i][j].name;\n+\tint len = strlen (name);\n+\n+\tgcc_assert (!(name[0] == '_' && name[1] == '_'\n+\t\t      && name[len - 1] == '_' && name[len - 2] == '_'));\n+\n+\t/* The minimum and maximum lengths must be consistent.  */\n+\tgcc_assert (attribute_tables[i][j].min_length >= 0);\n+\n+\tgcc_assert (attribute_tables[i][j].max_length == -1\n+\t\t    || (attribute_tables[i][j].max_length\n+\t\t\t>= attribute_tables[i][j].min_length));\n+\n+\t/* An attribute cannot require both a DECL and a TYPE.  */\n+\tgcc_assert (!attribute_tables[i][j].decl_required\n+\t\t    || !attribute_tables[i][j].type_required);\n+\n+\t  /* If an attribute requires a function type, in particular\n+\t     it requires a type.  */\n+\tgcc_assert (!attribute_tables[i][j].function_type_required\n+\t\t    || attribute_tables[i][j].type_required);\n+      }\n+\n+  /* Check that each name occurs just once in each table.  */\n+  for (size_t i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n+    for (size_t j = 0; attribute_tables[i][j].name != NULL; j++)\n+      for (size_t k = j + 1; attribute_tables[i][k].name != NULL; k++)\n+\tgcc_assert (strcmp (attribute_tables[i][j].name,\n+\t\t\t    attribute_tables[i][k].name));\n+\n+  /* Check that no name occurs in more than one table.  Names that\n+     begin with '*' are exempt, and may be overridden.  */\n+  for (size_t i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n+    for (size_t j = i + 1; j < ARRAY_SIZE (attribute_tables); j++)\n+      for (size_t k = 0; attribute_tables[i][k].name != NULL; k++)\n+\tfor (size_t l = 0; attribute_tables[j][l].name != NULL; l++)\n+\t  gcc_assert (attribute_tables[i][k].name[0] == '*'\n+\t\t      || strcmp (attribute_tables[i][k].name,\n+\t\t\t\t attribute_tables[j][l].name));\n+}\n+\n+/* Initialize attribute tables, and make some sanity checks if checking is\n+   enabled.  */\n \n void\n init_attributes (void)\n@@ -195,62 +245,8 @@ init_attributes (void)\n     if (attribute_tables[i] == NULL)\n       attribute_tables[i] = empty_attribute_table;\n \n-#ifdef ENABLE_CHECKING\n-  /* Make some sanity checks on the attribute tables.  */\n-  for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n-    {\n-      int j;\n-\n-      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n-\t{\n-\t  /* The name must not begin and end with __.  */\n-\t  const char *name = attribute_tables[i][j].name;\n-\t  int len = strlen (name);\n-\n-\t  gcc_assert (!(name[0] == '_' && name[1] == '_'\n-\t\t\t&& name[len - 1] == '_' && name[len - 2] == '_'));\n-\n-\t  /* The minimum and maximum lengths must be consistent.  */\n-\t  gcc_assert (attribute_tables[i][j].min_length >= 0);\n-\n-\t  gcc_assert (attribute_tables[i][j].max_length == -1\n-\t\t      || (attribute_tables[i][j].max_length\n-\t\t\t  >= attribute_tables[i][j].min_length));\n-\n-\t  /* An attribute cannot require both a DECL and a TYPE.  */\n-\t  gcc_assert (!attribute_tables[i][j].decl_required\n-\t\t      || !attribute_tables[i][j].type_required);\n-\n-\t  /* If an attribute requires a function type, in particular\n-\t     it requires a type.  */\n-\t  gcc_assert (!attribute_tables[i][j].function_type_required\n-\t\t      || attribute_tables[i][j].type_required);\n-\t}\n-    }\n-\n-  /* Check that each name occurs just once in each table.  */\n-  for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n-    {\n-      int j, k;\n-      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n-\tfor (k = j + 1; attribute_tables[i][k].name != NULL; k++)\n-\t  gcc_assert (strcmp (attribute_tables[i][j].name,\n-\t\t\t      attribute_tables[i][k].name));\n-    }\n-  /* Check that no name occurs in more than one table.  Names that\n-     begin with '*' are exempt, and may be overridden.  */\n-  for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n-    {\n-      size_t j, k, l;\n-\n-      for (j = i + 1; j < ARRAY_SIZE (attribute_tables); j++)\n-\tfor (k = 0; attribute_tables[i][k].name != NULL; k++)\n-\t  for (l = 0; attribute_tables[j][l].name != NULL; l++)\n-\t    gcc_assert (attribute_tables[i][k].name[0] == '*'\n-\t\t\t|| strcmp (attribute_tables[i][k].name,\n-\t\t\t\t   attribute_tables[j][l].name));\n-    }\n-#endif\n+  if (flag_checking)\n+    check_attribute_tables ();\n \n   for (i = 0; i < ARRAY_SIZE (attribute_tables); ++i)\n     /* Put all the GNU attributes into the \"gnu\" namespace.  */"}, {"sha": "c9b132d8ec25535b431980f9e2587308166754e5", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2873,11 +2873,8 @@ try_optimize_cfg (int mode)\n                  to detect and fix during edge forwarding, and in some cases\n                  is only visible after newly unreachable blocks are deleted,\n                  which will be done in fixup_partitions.  */\n-              fixup_partitions ();\n-\n-#ifdef ENABLE_CHECKING\n-              verify_flow_info ();\n-#endif\n+\t      fixup_partitions ();\n+\t      checking_verify_flow_info ();\n             }\n \n \t  changed_overall |= changed;"}, {"sha": "200520a28cc62dccb76efc04ca1725f7c727dc97", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -3269,12 +3269,13 @@ expand_computed_goto (tree exp)\n static void\n expand_goto (tree label)\n {\n-#ifdef ENABLE_CHECKING\n-  /* Check for a nonlocal goto to a containing function.  Should have\n-     gotten translated to __builtin_nonlocal_goto.  */\n-  tree context = decl_function_context (label);\n-  gcc_assert (!context || context == current_function_decl);\n-#endif\n+  if (flag_checking)\n+    {\n+      /* Check for a nonlocal goto to a containing function.  Should have\n+\t gotten translated to __builtin_nonlocal_goto.  */\n+      tree context = decl_function_context (label);\n+      gcc_assert (!context || context == current_function_decl);\n+    }\n \n   emit_jump (jump_target_rtx (label));\n }\n@@ -5056,12 +5057,12 @@ expand_debug_expr (tree exp)\n \n     default:\n     flag_unsupported:\n-#ifdef ENABLE_CHECKING\n-      debug_tree (exp);\n-      gcc_unreachable ();\n-#else\n+      if (flag_checking)\n+\t{\n+\t  debug_tree (exp);\n+\t  gcc_unreachable ();\n+\t}\n       return NULL;\n-#endif\n     }\n }\n \n@@ -6422,9 +6423,7 @@ pass_expand::execute (function *fun)\n      gcc.c-torture/execute/ipa-sra-2.c execution, -Os -m32 fails otherwise.  */\n   cleanup_cfg (CLEANUP_NO_INSN_DEL);\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n \n   /* Initialize pseudos allocated for hard registers.  */\n   emit_initial_value_sets ();"}, {"sha": "a0cb6fd4e32fbea67b478903136142ae9f8edf7b", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -186,6 +186,18 @@ struct cfg_hooks\n };\n \n extern void verify_flow_info (void);\n+\n+/* Check control flow invariants, if internal consistency checks are\n+   enabled.  */\n+\n+static inline void\n+checking_verify_flow_info (void)\n+{\n+  /* TODO: Add a separate option for -fchecking=cfg.  */\n+  if (flag_checking)\n+    verify_flow_info ();\n+}\n+\n extern void dump_bb (FILE *, basic_block, int, int);\n extern void dump_bb_for_graph (pretty_printer *, basic_block);\n extern void dump_flow_info (FILE *, int);"}, {"sha": "6af68939edaded2eb614fb386be7170b8efc79c4", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -311,6 +311,16 @@ extern void delete_loop (struct loop *);\n \n extern void verify_loop_structure (void);\n \n+/* Check loop structure invariants, if internal consistency checks are\n+   enabled.  */\n+\n+static inline void\n+checking_verify_loop_structure (void)\n+{\n+  if (flag_checking)\n+    verify_loop_structure ();\n+}\n+\n /* Loop analysis.  */\n extern bool just_once_each_iteration_p (const struct loop *, const_basic_block);\n gcov_type expected_loop_iterations_unbounded (const struct loop *);"}, {"sha": "14b9406733aa5c52cda566dde1330411778891fb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2096,9 +2096,7 @@ commit_edge_insertions (void)\n      which will be done by fixup_partitions.  */\n   fixup_partitions ();\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n \t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n@@ -3722,9 +3720,8 @@ fixup_reorder_chain (void)\n     insn = NEXT_INSN (insn);\n \n   set_last_insn (insn);\n-#ifdef ENABLE_CHECKING\n-  verify_insn_chain ();\n-#endif\n+  if (flag_checking)\n+    verify_insn_chain ();\n \n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n@@ -4312,9 +4309,7 @@ break_superblocks (void)\n void\n cfg_layout_finalize (void)\n {\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n   force_one_exit_fallthru ();\n   rtl_register_cfg_hooks ();\n   if (reload_completed && !targetm.have_epilogue ())\n@@ -4324,10 +4319,9 @@ cfg_layout_finalize (void)\n   rebuild_jump_labels (get_insns ());\n   delete_dead_jumptables ();\n \n-#ifdef ENABLE_CHECKING\n-  verify_insn_chain ();\n-  verify_flow_info ();\n-#endif\n+  if (flag_checking)\n+    verify_insn_chain ();\n+  checking_verify_flow_info ();\n }\n \n \n@@ -4892,13 +4886,11 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \t\t block in CFG already.  Calling make_edge in such case would\n \t\t cause us to mark that edge as fake and remove it later.  */\n \n-#ifdef ENABLE_CHECKING\n-\t      if (split_at_insn == BB_END (bb))\n+\t      if (flag_checking && split_at_insn == BB_END (bb))\n \t\t{\n \t\t  e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t\t  gcc_assert (e == NULL);\n \t\t}\n-#endif\n \n \t      /* Note that the following may create a new basic block\n \t\t and renumber the existing basic blocks.  */"}, {"sha": "69804c352bcd14d02ecdbc2474963ee094a4e8e9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -832,11 +832,9 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n     {\n       /* This is a rather expensive check possibly triggering\n \t construction of call stmt hashtable.  */\n-#ifdef ENABLE_CHECKING\n       cgraph_edge *e;\n-      gcc_checking_assert (\n-\t!(e = caller->get_edge (call_stmt)) || e->speculative);\n-#endif\n+      gcc_checking_assert (!(e = caller->get_edge (call_stmt))\n+\t\t\t   || e->speculative);\n \n       gcc_assert (is_gimple_call (call_stmt));\n     }\n@@ -1282,9 +1280,6 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n   gcall *new_stmt;\n   gimple_stmt_iterator gsi;\n   bool skip_bounds = false;\n-#ifdef ENABLE_CHECKING\n-  cgraph_node *node;\n-#endif\n \n   if (e->speculative)\n     {\n@@ -1402,13 +1397,11 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t  && !skip_bounds))\n     return e->call_stmt;\n \n-#ifdef ENABLE_CHECKING\n-  if (decl)\n+  if (flag_checking && decl)\n     {\n-      node = cgraph_node::get (decl);\n+      cgraph_node *node = cgraph_node::get (decl);\n       gcc_assert (!node || !node->clone.combined_args_to_skip);\n     }\n-#endif\n \n   if (symtab->dump_file)\n     {"}, {"sha": "0a0ff70ac1fdc72ce57d851c6d2d0a4db720c44b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -362,7 +362,6 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      and NULL otherwise.  */\n   static inline symtab_node *get (const_tree decl)\n   {\n-#ifdef ENABLE_CHECKING\n     /* Check that we are called for sane type of object - functions\n        and static or external variables.  */\n     gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n@@ -374,7 +373,6 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n        memcpy/memset on the tree nodes.  */\n     gcc_checking_assert (!decl->decl_with_vis.symtab_node\n \t\t\t || decl->decl_with_vis.symtab_node->decl == decl);\n-#endif\n     return decl->decl_with_vis.symtab_node;\n   }\n \n@@ -398,6 +396,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Verify symbol table for internal consistency.  */\n   static DEBUG_FUNCTION void verify_symtab_nodes (void);\n \n+  /* Perform internal consistency checks, if they are enabled.  */\n+  static inline void checking_verify_symtab_nodes (void);\n+\n   /* Type of the symbol.  */\n   ENUM_BITFIELD (symtab_type) type : 8;\n \n@@ -558,6 +559,13 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   symtab_node *ultimate_alias_target_1 (enum availability *avail = NULL);\n };\n \n+inline void\n+symtab_node::checking_verify_symtab_nodes (void)\n+{\n+  if (flag_checking)\n+    symtab_node::verify_symtab_nodes ();\n+}\n+\n /* Walk all aliases for NODE.  */\n #define FOR_EACH_ALIAS(node, alias) \\\n   for (unsigned x_i = 0; node->iterate_direct_aliases (x_i, alias); x_i++)\n@@ -1205,6 +1213,9 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* Verify whole cgraph structure.  */\n   static void DEBUG_FUNCTION verify_cgraph_nodes (void);\n \n+  /* Verify cgraph, if consistency checking is enabled.  */\n+  static inline void checking_verify_cgraph_nodes (void);\n+\n   /* Worker to bring NODE local.  */\n   static bool make_local (cgraph_node *node, void *);\n \n@@ -2753,6 +2764,15 @@ cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n   return true;\n }\n \n+/* Verify cgraph, if consistency checking is enabled.  */\n+\n+inline void\n+cgraph_node::checking_verify_cgraph_nodes (void)\n+{\n+  if (flag_checking)\n+    cgraph_node::verify_cgraph_nodes ();\n+}\n+\n /* Return true when variable can be removed from variable pool\n    if all direct calls are eliminated.  */\n "}, {"sha": "f36ef34e3a5683ebfb9d14b80a930f0049b6bcf5", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1074,9 +1074,8 @@ symbol_table::materialize_all_clones (void)\n \n   if (symtab->dump_file)\n     fprintf (symtab->dump_file, \"Materializing clones\\n\");\n-#ifdef ENABLE_CHECKING\n-  cgraph_node::verify_cgraph_nodes ();\n-#endif\n+\n+  cgraph_node::checking_verify_cgraph_nodes ();\n \n   /* We can also do topological order, but number of iterations should be\n      bounded by number of IPA passes since single IPA pass is probably not\n@@ -1145,9 +1144,9 @@ symbol_table::materialize_all_clones (void)\n       node->clear_stmts_in_references ();\n   if (symtab->dump_file)\n     fprintf (symtab->dump_file, \"Materialization Call site updates done.\\n\");\n-#ifdef ENABLE_CHECKING\n-  cgraph_node::verify_cgraph_nodes ();\n-#endif\n+\n+  cgraph_node::checking_verify_cgraph_nodes ();\n+\n   symtab->remove_unreachable_nodes (symtab->dump_file);\n }\n "}, {"sha": "eab8c7f28aa3c217d1646585663effb302a1ff98", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1325,13 +1325,12 @@ handle_alias_pairs (void)\n static void\n mark_functions_to_output (void)\n {\n-  cgraph_node *node;\n-#ifdef ENABLE_CHECKING\n   bool check_same_comdat_groups = false;\n+  cgraph_node *node;\n \n-  FOR_EACH_FUNCTION (node)\n-    gcc_assert (!node->process);\n-#endif\n+  if (flag_checking)\n+    FOR_EACH_FUNCTION (node)\n+      gcc_assert (!node->process);\n \n   FOR_EACH_FUNCTION (node)\n     {\n@@ -1365,15 +1364,14 @@ mark_functions_to_output (void)\n \t}\n       else if (node->same_comdat_group)\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  check_same_comdat_groups = true;\n-#endif\n+\t  if (flag_checking)\n+\t    check_same_comdat_groups = true;\n \t}\n       else\n \t{\n \t  /* We should've reclaimed all functions that are not needed.  */\n-#ifdef ENABLE_CHECKING\n-\t  if (!node->global.inlined_to\n+\t  if (flag_checking\n+\t      && !node->global.inlined_to\n \t      && gimple_has_body_p (decl)\n \t      /* FIXME: in ltrans unit when offline copy is outside partition but inline copies\n \t\t are inside partition, we can end up not removing the body since we no longer\n@@ -1386,7 +1384,6 @@ mark_functions_to_output (void)\n \t      node->debug ();\n \t      internal_error (\"failed to reclaim unneeded function\");\n \t    }\n-#endif\n \t  gcc_assert (node->global.inlined_to\n \t\t      || !gimple_has_body_p (decl)\n \t\t      || node->in_other_partition\n@@ -1397,8 +1394,7 @@ mark_functions_to_output (void)\n \t}\n \n     }\n-#ifdef ENABLE_CHECKING\n-  if (check_same_comdat_groups)\n+  if (flag_checking && check_same_comdat_groups)\n     FOR_EACH_FUNCTION (node)\n       if (node->same_comdat_group && !node->process)\n \t{\n@@ -1418,7 +1414,6 @@ mark_functions_to_output (void)\n \t\t\t      \"comdat group\");\n \t    }\n \t}\n-#endif\n }\n \n /* DECL is FUNCTION_DECL.  Initialize datastructures so DECL is a function\n@@ -1887,9 +1882,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       TREE_ASM_WRITTEN (thunk_fndecl) = false;\n       delete_unreachable_blocks ();\n       update_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-      verify_flow_info ();\n-#endif\n+      checking_verify_flow_info ();\n       free_dominance_info (CDI_DOMINATORS);\n \n       /* Since we want to emit the thunk, we explicitly mark its name as\n@@ -2373,9 +2366,7 @@ symbol_table::compile (void)\n   if (seen_error ())\n     return;\n \n-#ifdef ENABLE_CHECKING\n-  symtab_node::verify_symtab_nodes ();\n-#endif\n+  symtab_node::checking_verify_symtab_nodes ();\n \n   timevar_push (TV_CGRAPHOPT);\n   if (pre_ipa_mem_report)\n@@ -2424,9 +2415,7 @@ symbol_table::compile (void)\n   (*debug_hooks->assembly_start) ();\n   if (!quiet_flag)\n     fprintf (stderr, \"Assembling functions:\\n\");\n-#ifdef ENABLE_CHECKING\n-  symtab_node::verify_symtab_nodes ();\n-#endif\n+  symtab_node::checking_verify_symtab_nodes ();\n \n   materialize_all_clones ();\n   bitmap_obstack_initialize (NULL);\n@@ -2482,7 +2471,8 @@ symbol_table::compile (void)\n       fprintf (dump_file, \"\\nFinal \");\n       symtab_node::dump_table (dump_file);\n     }\n-#ifdef ENABLE_CHECKING\n+  if (!flag_checking)\n+    return;\n   symtab_node::verify_symtab_nodes ();\n   /* Double check that all inline clones are gone and that all\n      function bodies have been released from memory.  */\n@@ -2501,7 +2491,6 @@ symbol_table::compile (void)\n       if (error_found)\n \tinternal_error (\"nodes with unreleased memory found\");\n     }\n-#endif\n }\n \n "}, {"sha": "b03ab9378f7145813c9b6c25c4bf15d443dabdfe", "filename": "gcc/ddg.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -300,19 +300,16 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n   rtx_insn *def_insn = DF_REF_INSN (last_def);\n   ddg_node_ptr last_def_node = get_node_of_insn (g, def_insn);\n   ddg_node_ptr use_node;\n-#ifdef ENABLE_CHECKING\n-  struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n-#endif\n   df_ref first_def = df_bb_regno_first_def_find (g->bb, regno);\n \n   gcc_assert (last_def_node);\n   gcc_assert (first_def);\n \n-#ifdef ENABLE_CHECKING\n-  if (DF_REF_ID (last_def) != DF_REF_ID (first_def))\n-    gcc_assert (!bitmap_bit_p (&bb_info->gen,\n-\t\t\t       DF_REF_ID (first_def)));\n-#endif\n+  if (flag_checking && DF_REF_ID (last_def) != DF_REF_ID (first_def))\n+    {\n+      struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n+      gcc_assert (!bitmap_bit_p (&bb_info->gen, DF_REF_ID (first_def)));\n+    }\n \n   /* Create inter-loop true dependences and anti dependences.  */\n   for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)\n@@ -1013,7 +1010,6 @@ order_sccs (ddg_all_sccs_ptr g)\n \t (int (*) (const void *, const void *)) compare_sccs);\n }\n \n-#ifdef ENABLE_CHECKING\n /* Check that every node in SCCS belongs to exactly one strongly connected\n    component and that no element of SCCS is empty.  */\n static void\n@@ -1033,7 +1029,6 @@ check_sccs (ddg_all_sccs_ptr sccs, int num_nodes)\n     }\n   sbitmap_free (tmp);\n }\n-#endif\n \n /* Perform the Strongly Connected Components decomposing algorithm on the\n    DDG and return DDG_ALL_SCCS structure that contains them.  */\n@@ -1079,9 +1074,10 @@ create_ddg_all_sccs (ddg_ptr g)\n   sbitmap_free (from);\n   sbitmap_free (to);\n   sbitmap_free (scc_nodes);\n-#ifdef ENABLE_CHECKING\n-  check_sccs (sccs, num_nodes);\n-#endif\n+\n+  if (flag_checking)\n+    check_sccs (sccs, num_nodes);\n+\n   return sccs;\n }\n "}, {"sha": "72a5eb59920f78e7ecc2ad12d98f7109d2358355", "filename": "gcc/df-core.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -682,10 +682,8 @@ df_finish_pass (bool verify ATTRIBUTE_UNUSED)\n #endif\n #endif\n \n-#ifdef ENABLE_CHECKING\n-  if (verify)\n+  if (flag_checking && verify)\n     df->changeable_flags |= DF_VERIFY_SCHEDULED;\n-#endif\n }\n \n \n@@ -1273,12 +1271,14 @@ df_analyze (void)\n   for (i = 0; i < df->n_blocks; i++)\n     bitmap_set_bit (current_all_blocks, df->postorder[i]);\n \n-#ifdef ENABLE_CHECKING\n-  /* Verify that POSTORDER_INVERTED only contains blocks reachable from\n-     the ENTRY block.  */\n-  for (i = 0; i < df->n_blocks_inverted; i++)\n-    gcc_assert (bitmap_bit_p (current_all_blocks, df->postorder_inverted[i]));\n-#endif\n+  if (flag_checking)\n+    {\n+      /* Verify that POSTORDER_INVERTED only contains blocks reachable from\n+\t the ENTRY block.  */\n+      for (i = 0; i < df->n_blocks_inverted; i++)\n+\tgcc_assert (bitmap_bit_p (current_all_blocks,\n+\t\t\t\t  df->postorder_inverted[i]));\n+    }\n \n   /* Make sure that we have pruned any unreachable blocks from these\n      sets.  */"}, {"sha": "6cc1e6b3ee52a27112fbc4f1e7aa2ba241bcc1ca", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -48,7 +48,7 @@ extern const char *trim_filename (const char *);\n /* None of these functions are suitable for ATTRIBUTE_PRINTF, because\n    each language front end can extend them with its own set of format\n    specifiers.  We must use custom format checks.  */\n-#if (ENABLE_CHECKING && GCC_VERSION >= 4001) || GCC_VERSION == BUILDING_GCC_VERSION\n+#if (CHECKING_P && GCC_VERSION >= 4001) || GCC_VERSION == BUILDING_GCC_VERSION\n #define ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (GCC_DIAG_STYLE, m, n))) ATTRIBUTE_NONNULL(m)\n #else\n #define ATTRIBUTE_GCC_DIAG(m, n) ATTRIBUTE_NONNULL(m)"}, {"sha": "11c369d829277aff97ef028d248d21421e269d40", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -736,12 +736,12 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \n   if (diagnostic->kind == DK_ICE || diagnostic->kind == DK_ICE_NOBT)\n     {\n-#ifndef ENABLE_CHECKING\n       /* When not checking, ICEs are converted to fatal errors when an\n \t error has already occurred.  This is counteracted by\n \t abort_on_error.  */\n-      if ((diagnostic_kind_count (context, DK_ERROR) > 0\n-\t   || diagnostic_kind_count (context, DK_SORRY) > 0)\n+      if (!CHECKING_P\n+\t  && (diagnostic_kind_count (context, DK_ERROR) > 0\n+\t      || diagnostic_kind_count (context, DK_SORRY) > 0)\n \t  && !context->abort_on_error)\n \t{\n \t  expanded_location s \n@@ -750,7 +750,6 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \t\t   s.file, s.line);\n \t  exit (ICE_EXIT_CODE);\n \t}\n-#endif\n       if (context->internal_error)\n \t(*context->internal_error) (context,\n \t\t\t\t    diagnostic->message.format_spec,"}, {"sha": "a72b0c1bc621f36b2b1043e9798e1a0e2a391152", "filename": "gcc/dominance.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -634,9 +634,7 @@ calculate_dominance_info (cdi_direction dir)\n \n   if (dom_computed[dir_index] == DOM_OK)\n     {\n-#if ENABLE_CHECKING\n-      verify_dominators (dir);\n-#endif\n+      checking_verify_dominators (dir);\n       return;\n     }\n \n@@ -665,11 +663,7 @@ calculate_dominance_info (cdi_direction dir)\n       dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n     }\n   else\n-    {\n-#if ENABLE_CHECKING\n-      verify_dominators (dir);\n-#endif\n-    }\n+    checking_verify_dominators (dir);\n \n   compute_dom_fast_query (dir);\n "}, {"sha": "7254f2f6fdcab66b23f42395f51f6a7a8029c359", "filename": "gcc/dominance.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -60,6 +60,17 @@ extern bool dominated_by_p (enum cdi_direction, const_basic_block,\n unsigned bb_dom_dfs_in (enum cdi_direction, basic_block);\n unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);\n extern void verify_dominators (enum cdi_direction);\n+\n+/* Verify invariants of computed dominance information, if internal consistency\n+   checks are enabled.  */\n+\n+static inline void\n+checking_verify_dominators (cdi_direction dir)\n+{\n+  if (flag_checking)\n+    verify_dominators (dir);\n+}\n+\n basic_block recompute_dominator (enum cdi_direction, basic_block);\n extern void iterate_fix_dominators (enum cdi_direction,\n \t\t\t\t    vec<basic_block> , bool);"}, {"sha": "6e0db4191941eabb3ddb891e0174b45d5981abdf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -4149,15 +4149,12 @@ static inline void\n add_AT_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind, dw_die_ref targ_die)\n {\n   dw_attr_node attr;\n+  gcc_checking_assert (targ_die != NULL);\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (targ_die != NULL);\n-#else\n   /* With LTO we can end up trying to reference something we didn't create\n      a DIE for.  Avoid crashing later on a NULL referenced DIE.  */\n   if (targ_die == NULL)\n     return;\n-#endif\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_die_ref;\n@@ -5723,7 +5720,6 @@ debug_dwarf (void)\n   print_die (comp_unit_die (), stderr);\n }\n \n-#ifdef ENABLE_CHECKING\n /* Sanity checks on DIEs.  */\n \n static void\n@@ -5786,7 +5782,6 @@ check_die (dw_die_ref die)\n \t\t    && a->dw_attr != DW_AT_GNU_all_call_sites);\n     }\n }\n-#endif\n \f\n /* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU\n    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL\n@@ -11763,14 +11758,14 @@ const_ok_for_output_1 (rtx rtl)\n     {\n       /* If delegitimize_address couldn't do anything with the UNSPEC, assume\n \t we can't express it in the debug info.  */\n-#ifdef ENABLE_CHECKING\n       /* Don't complain about TLS UNSPECs, those are just too hard to\n \t delegitimize.  Note this could be a non-decl SYMBOL_REF such as\n \t one in a constant pool entry, so testing SYMBOL_REF_TLS_MODEL\n \t rather than DECL_THREAD_LOCAL_P is not just an optimization.  */\n-      if (XVECLEN (rtl, 0) == 0\n-\t  || GET_CODE (XVECEXP (rtl, 0, 0)) != SYMBOL_REF\n-\t  || SYMBOL_REF_TLS_MODEL (XVECEXP (rtl, 0, 0)) == TLS_MODEL_NONE)\n+      if (flag_checking\n+\t  && (XVECLEN (rtl, 0) == 0\n+\t      || GET_CODE (XVECEXP (rtl, 0, 0)) != SYMBOL_REF\n+\t      || SYMBOL_REF_TLS_MODEL (XVECEXP (rtl, 0, 0)) == TLS_MODEL_NONE))\n \tinform (current_function_decl\n \t\t? DECL_SOURCE_LOCATION (current_function_decl)\n \t\t: UNKNOWN_LOCATION,\n@@ -11782,7 +11777,6 @@ const_ok_for_output_1 (rtx rtl)\n #else\n \t\t\"non-delegitimized UNSPEC %d found in variable location\",\n \t\tXINT (rtl, 1));\n-#endif\n #endif\n       expansion_failed (NULL_TREE, rtl,\n \t\t\t\"UNSPEC hasn't been delegitimized.\\n\");\n@@ -13570,12 +13564,12 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n       goto symref;\n \n     default:\n-#ifdef ENABLE_CHECKING\n-      print_rtl (stderr, rtl);\n-      gcc_unreachable ();\n-#else\n+      if (flag_checking)\n+\t{\n+\t  print_rtl (stderr, rtl);\n+\t  gcc_unreachable ();\n+\t}\n       break;\n-#endif\n     }\n \n   if (mem_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n@@ -15098,15 +15092,14 @@ loc_list_from_tree (tree loc, int want_address,\n \t  return 0;\n \t}\n \n-#ifdef ENABLE_CHECKING\n       /* Otherwise this is a generic code; we should just lists all of\n \t these explicitly.  We forgot one.  */\n-      gcc_unreachable ();\n-#else\n+      if (flag_checking)\n+\tgcc_unreachable ();\n+\n       /* In a release build, we want to degrade gracefully: better to\n \t generate incomplete debugging information than to crash.  */\n       return NULL;\n-#endif\n     }\n \n   if (!ret && !list_ret)\n@@ -19908,18 +19901,17 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die)\n     {\n       if (old_die)\n \t{\n-#ifdef ENABLE_CHECKING\n \t  /* This must have been generated early and it won't even\n \t     need location information since it's a DW_AT_inline\n \t     function.  */\n-\t  for (dw_die_ref c = context_die; c; c = c->die_parent)\n-\t    if (c->die_tag == DW_TAG_inlined_subroutine\n-\t\t|| c->die_tag == DW_TAG_subprogram)\n-\t      {\n-\t\tgcc_assert (get_AT (c, DW_AT_inline));\n-\t\tbreak;\n-\t      }\n-#endif\n+\t  if (flag_checking)\n+\t    for (dw_die_ref c = context_die; c; c = c->die_parent)\n+\t      if (c->die_tag == DW_TAG_inlined_subroutine\n+\t\t  || c->die_tag == DW_TAG_subprogram)\n+\t\t{\n+\t\t  gcc_assert (get_AT (c, DW_AT_inline));\n+\t\t  break;\n+\t\t}\n \t  return;\n \t}\n     }\n@@ -20736,10 +20728,8 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n \n-#ifdef ENABLE_CHECKING\n-  if (type)\n+  if (flag_checking && type)\n      verify_type (type);\n-#endif\n \n   if (TYPE_NAME (type) != NULL_TREE\n       && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n@@ -20933,11 +20923,12 @@ gen_type_die (tree type, dw_die_ref context_die)\n   if (type != error_mark_node)\n     {\n       gen_type_die_with_usage (type, context_die, DINFO_USAGE_DIR_USE);\n-#ifdef ENABLE_CHECKING\n-      dw_die_ref die = lookup_type_die (type);\n-      if (die)\n-\tcheck_die (die);\n-#endif\n+      if (flag_checking)\n+\t{\n+\t  dw_die_ref die = lookup_type_die (type);\n+\t  if (die)\n+\t    check_die (die);\n+\t}\n     }\n }\n \n@@ -21975,11 +21966,12 @@ dwarf2out_decl (tree decl)\n \n   gen_decl_die (decl, NULL, context_die);\n \n-#ifdef ENABLE_CHECKING\n-  dw_die_ref die = lookup_decl_die (decl);\n-  if (die)\n-    check_die (die);\n-#endif\n+  if (flag_checking)\n+    {\n+      dw_die_ref die = lookup_decl_die (decl);\n+      if (die)\n+\tcheck_die (die);\n+    }\n }\n \n /* Write the debugging output for DECL.  */"}, {"sha": "8d2e81cab65159af736bf97c08a14ca4ea803932", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2733,16 +2733,14 @@ verify_rtx_sharing (rtx orig, rtx insn)\n \n   /* This rtx may not be shared.  If it has already been seen,\n      replace it with a copy of itself.  */\n-#ifdef ENABLE_CHECKING\n-  if (RTX_FLAG (x, used))\n+  if (flag_checking && RTX_FLAG (x, used))\n     {\n       error (\"invalid rtl sharing found in the insn\");\n       debug_rtx (insn);\n       error (\"shared rtx\");\n       debug_rtx (x);\n       internal_error (\"internal consistency failure\");\n     }\n-#endif\n   gcc_assert (!RTX_FLAG (x, used));\n \n   RTX_FLAG (x, used) = 1;\n@@ -4259,12 +4257,12 @@ delete_insns_since (rtx_insn *from)\n void\n reorder_insns_nobb (rtx_insn *from, rtx_insn *to, rtx_insn *after)\n {\n-#ifdef ENABLE_CHECKING\n-  rtx_insn *x;\n-  for (x = from; x != to; x = NEXT_INSN (x))\n-    gcc_assert (after != x);\n-  gcc_assert (after != to);\n-#endif\n+  if (flag_checking)\n+    {\n+      for (rtx_insn *x = from; x != to; x = NEXT_INSN (x))\n+\tgcc_assert (after != x);\n+      gcc_assert (after != to);\n+    }\n \n   /* Splice this bunch out of where it is now.  */\n   if (PREV_INSN (from))"}, {"sha": "bf2f7656ed29ed1c6c65c49ccbd55d3919bc5a96", "filename": "gcc/et-forest.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -28,7 +28,7 @@ License along with libiberty; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"et-forest.h\"\n \n-/* We do not enable this with ENABLE_CHECKING, since it is awfully slow.  */\n+/* We do not enable this with CHECKING_P, since it is awfully slow.  */\n #undef DEBUG_ET\n \n #ifdef DEBUG_ET"}, {"sha": "5765d58b3e84b8f90efb32712c6ed4f941b5441b", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -612,9 +612,8 @@ duplicate_eh_regions (struct function *ifun,\n   struct duplicate_eh_regions_data data;\n   eh_region outer_region;\n \n-#ifdef ENABLE_CHECKING\n-  verify_eh_tree (ifun);\n-#endif\n+  if (flag_checking)\n+    verify_eh_tree (ifun);\n \n   data.label_map = map;\n   data.label_map_data = map_data;\n@@ -632,9 +631,8 @@ duplicate_eh_regions (struct function *ifun,\n \tduplicate_eh_regions_1 (&data, r, outer_region);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  verify_eh_tree (cfun);\n-#endif\n+  if (flag_checking)\n+    verify_eh_tree (cfun);\n \n   return data.eh_map;\n }"}, {"sha": "c9b29e65ba58d2798f17694d535183d6036da7a1", "filename": "gcc/fwprop.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -843,9 +843,7 @@ all_uses_available_at (rtx_insn *def_insn, rtx_insn *target_insn)\n \n \f\n static df_ref *active_defs;\n-#ifdef ENABLE_CHECKING\n static sparseset active_defs_check;\n-#endif\n \n /* Fill the ACTIVE_DEFS array with the use->def link for the registers\n    mentioned in USE_REC.  Register the valid entries in ACTIVE_DEFS_CHECK\n@@ -859,9 +857,8 @@ register_active_defs (df_ref use)\n       df_ref def = get_def_for_use (use);\n       int regno = DF_REF_REGNO (use);\n \n-#ifdef ENABLE_CHECKING\n-      sparseset_set_bit (active_defs_check, regno);\n-#endif\n+      if (flag_checking)\n+\tsparseset_set_bit (active_defs_check, regno);\n       active_defs[regno] = def;\n     }\n }\n@@ -876,9 +873,8 @@ register_active_defs (df_ref use)\n static void\n update_df_init (rtx_insn *def_insn, rtx_insn *insn)\n {\n-#ifdef ENABLE_CHECKING\n-  sparseset_clear (active_defs_check);\n-#endif\n+  if (flag_checking)\n+    sparseset_clear (active_defs_check);\n   register_active_defs (DF_INSN_USES (def_insn));\n   register_active_defs (DF_INSN_USES (insn));\n   register_active_defs (DF_INSN_EQ_USES (insn));\n@@ -899,9 +895,7 @@ update_uses (df_ref use)\n       if (DF_REF_ID (use) >= (int) use_def_ref.length ())\n         use_def_ref.safe_grow_cleared (DF_REF_ID (use) + 1);\n \n-#ifdef ENABLE_CHECKING\n-      gcc_assert (sparseset_bit_p (active_defs_check, regno));\n-#endif\n+      gcc_checking_assert (sparseset_bit_p (active_defs_check, regno));\n       use_def_ref[DF_REF_ID (use)] = active_defs[regno];\n     }\n }\n@@ -1407,9 +1401,8 @@ fwprop_init (void)\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n   active_defs = XNEWVEC (df_ref, max_reg_num ());\n-#ifdef ENABLE_CHECKING\n-  active_defs_check = sparseset_alloc (max_reg_num ());\n-#endif\n+  if (flag_checking)\n+    active_defs_check = sparseset_alloc (max_reg_num ());\n }\n \n static void\n@@ -1419,9 +1412,8 @@ fwprop_done (void)\n \n   use_def_ref.release ();\n   free (active_defs);\n-#ifdef ENABLE_CHECKING\n-  sparseset_free (active_defs_check);\n-#endif\n+  if (flag_checking)\n+    sparseset_free (active_defs_check);\n \n   free_dominance_info (CDI_DOMINATORS);\n   cleanup_cfg (0);"}, {"sha": "deb21bba464728816f0aa08f0a4997ab5a4af778", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2201,12 +2201,11 @@ ggc_collect (void)\n void\n ggc_grow (void)\n {\n-#ifndef ENABLE_CHECKING\n-  G.allocated_last_gc = MAX (G.allocated_last_gc,\n-\t\t\t     G.allocated);\n-#else\n-  ggc_collect ();\n-#endif\n+  if (!flag_checking)\n+    G.allocated_last_gc = MAX (G.allocated_last_gc,\n+\t\t\t       G.allocated);\n+  else\n+    ggc_collect ();\n   if (!quiet_flag)\n     fprintf (stderr, \" {GC start %luk} \", (unsigned long) G.allocated / 1024);\n }"}, {"sha": "4390f7d489035f72ea6ab1089298fa902d32d0b8", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -10319,10 +10319,8 @@ gimplify_body (tree fndecl, bool do_parms)\n   pop_gimplify_context (outer_bind);\n   gcc_assert (gimplify_ctxp == NULL);\n \n-#ifdef ENABLE_CHECKING\n-  if (!seen_error ())\n+  if (flag_checking && !seen_error ())\n     verify_gimple_in_seq (gimple_bind_body (outer_bind));\n-#endif\n \n   timevar_pop (TV_TREE_GIMPLIFY);\n   input_location = saved_location;\n@@ -10614,11 +10612,9 @@ gimplify_hasher::equal (const elt_t *p1, const elt_t *p2)\n   if (!operand_equal_p (t1, t2, 0))\n     return false;\n \n-#ifdef ENABLE_CHECKING\n   /* Only allow them to compare equal if they also hash equal; otherwise\n      results are nondeterminate, and we fail bootstrap comparison.  */\n-  gcc_assert (hash (p1) == hash (p2));\n-#endif\n+  gcc_checking_assert (hash (p1) == hash (p2));\n \n   return true;\n }"}, {"sha": "fc4af5a25ea7d2d58a636294a252f355f335bf08", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -106,10 +106,8 @@ gmp_cst_to_tree (tree type, mpz_t val)\n static inline void\n graphite_verify (void)\n {\n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-  verify_loop_closed_ssa (true);\n-#endif\n+  checking_verify_loop_structure ();\n+  checking_verify_loop_closed_ssa (true);\n }\n \n /* IVS_PARAMS maps ISL's scattering and parameter identifiers"}, {"sha": "81158e5a1cbc4c3c1a34c9503aded9d2233bbf2f", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -259,21 +259,16 @@ canonicalize_loop_closed_ssa (loop_p loop)\n static void\n canonicalize_loop_closed_ssa_form (void)\n {\n-  loop_p loop;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa (true);\n-#endif\n+  checking_verify_loop_closed_ssa (true);\n \n+  loop_p loop;\n   FOR_EACH_LOOP (loop, 0)\n     canonicalize_loop_closed_ssa (loop);\n \n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   update_ssa (TODO_update_ssa);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa (true);\n-#endif\n+  checking_verify_loop_closed_ssa (true);\n }\n \n /* Can all ivs be represented by a signed integer?"}, {"sha": "91abcca503c3212c314ce0f0606fddcf8c394e7d", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1522,9 +1522,7 @@ rewrite_reductions_out_of_ssa (scop_p scop)\n       }\n \n   update_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa (true);\n-#endif\n+  checking_verify_loop_closed_ssa (true);\n }\n \n /* Rewrite the scalar dependence of DEF used in USE_STMT with a memory\n@@ -1699,9 +1697,7 @@ rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p scop)\n     {\n       scev_reset_htab ();\n       update_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-      verify_loop_closed_ssa (true);\n-#endif\n+      checking_verify_loop_closed_ssa (true);\n     }\n }\n "}, {"sha": "192be3036373a6c128c7646e7e493dd577a0e2da", "filename": "gcc/hash-table.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -638,9 +638,7 @@ hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n \n   if (is_empty (*slot))\n     return slot;\n-#ifdef ENABLE_CHECKING\n   gcc_checking_assert (!is_deleted (*slot));\n-#endif\n \n   hash2 = hash_table_mod2 (hash, m_size_prime_index);\n   for (;;)\n@@ -652,9 +650,7 @@ hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n       slot = m_entries + index;\n       if (is_empty (*slot))\n         return slot;\n-#ifdef ENABLE_CHECKING\n       gcc_checking_assert (!is_deleted (*slot));\n-#endif\n     }\n }\n "}, {"sha": "ca537550d45c54aa254611d92fa34eb591c3bfd0", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -5093,9 +5093,7 @@ if_convert (bool after_combine)\n   if (optimize == 1)\n     df_remove_problem (df_live);\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n }\n \f\n /* If-conversion and CFG cleanup.  */"}, {"sha": "d1c6236e289554d3e1aaa3edcf2bc4c520c0fa31", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2920,9 +2920,8 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n \t     overall_size, max_new_size);\n \n   propagate_constants_topo (topo);\n-#ifdef ENABLE_CHECKING\n-  ipcp_verify_propagated_values ();\n-#endif\n+  if (flag_checking)\n+    ipcp_verify_propagated_values ();\n   topo->constants.propagate_effects ();\n   topo->contexts.propagate_effects ();\n "}, {"sha": "69dec056a32c22a827d19f485457b10cd50f644e", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -272,11 +272,10 @@ type_in_anonymous_namespace_p (const_tree t)\n     {\n       /* C++ FE uses magic <anon> as assembler names of anonymous types.\n  \t verify that this match with type_in_anonymous_namespace_p.  */\n-#ifdef ENABLE_CHECKING\n       if (in_lto_p)\n-\tgcc_assert (!strcmp (\"<anon>\",\n-\t\t    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n-#endif\n+\tgcc_checking_assert (!strcmp (\"<anon>\",\n+\t\t\t\t      IDENTIFIER_POINTER\n+\t\t\t\t\t(DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n       return true;\n     }\n   return false;\n@@ -300,15 +299,13 @@ odr_type_p (const_tree t)\n   if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n       && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))))\n     {\n-#ifdef ENABLE_CHECKING\n       /* C++ FE uses magic <anon> as assembler names of anonymous types.\n  \t verify that this match with type_in_anonymous_namespace_p.  */\n-      gcc_assert (!type_with_linkage_p (t)\n-\t\t  || strcmp (\"<anon>\",\n-\t\t\t     IDENTIFIER_POINTER\n-\t\t\t        (DECL_ASSEMBLER_NAME (TYPE_NAME (t))))\n-\t\t  || type_in_anonymous_namespace_p (t));\n-#endif\n+      gcc_checking_assert (!type_with_linkage_p (t)\n+\t\t\t   || strcmp (\"<anon>\",\n+\t\t\t\t      IDENTIFIER_POINTER\n+\t\t\t\t\t(DECL_ASSEMBLER_NAME (TYPE_NAME (t))))\n+\t\t\t   || type_in_anonymous_namespace_p (t));\n       return true;\n     }\n   return false;\n@@ -1777,11 +1774,10 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n bool\n odr_types_equivalent_p (tree type1, tree type2)\n {\n-  hash_set<type_pair> visited;\n+  gcc_checking_assert (odr_or_derived_type_p (type1)\n+\t\t       && odr_or_derived_type_p (type2));\n \n-#ifdef ENABLE_CHECKING\n-  gcc_assert (odr_or_derived_type_p (type1) && odr_or_derived_type_p (type2));\n-#endif\n+  hash_set<type_pair> visited;\n   return odr_types_equivalent_p (type1, type2, false, NULL,\n \t\t\t         &visited, UNKNOWN_LOCATION, UNKNOWN_LOCATION);\n }\n@@ -2000,8 +1996,8 @@ add_type_duplicate (odr_type val, tree type)\n     }\n   gcc_assert (val->odr_violated || !odr_must_violate);\n   /* Sanity check that all bases will be build same way again.  */\n-#ifdef ENABLE_CHECKING\n-  if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n+  if (flag_checking\n+      && COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n       && TREE_CODE (val->type) == RECORD_TYPE\n       && TREE_CODE (type) == RECORD_TYPE\n       && TYPE_BINFO (val->type) && TYPE_BINFO (type)\n@@ -2030,7 +2026,6 @@ add_type_duplicate (odr_type val, tree type)\n \t    j++;\n \t  }\n     }\n-#endif\n \n \n   /* Regularize things a little.  During LTO same types may come with\n@@ -2136,16 +2131,15 @@ get_odr_type (tree type, bool insert)\n       if (slot && *slot)\n \t{\n \t  val = *slot;\n-#ifdef ENABLE_CHECKING\n-\t  if (in_lto_p && can_be_vtable_hashed_p (type))\n+\t  if (flag_checking\n+\t      && in_lto_p && can_be_vtable_hashed_p (type))\n \t    {\n \t      hash = hash_odr_vtable (type);\n \t      vtable_slot = odr_vtable_hash->find_slot_with_hash (type, hash,\n \t\t\t\t\t\t                  NO_INSERT);\n \t      gcc_assert (!vtable_slot || *vtable_slot == *slot);\n \t      vtable_slot = NULL;\n \t    }\n-#endif\n \t}\n       else if (*vtable_slot)\n \tval = *vtable_slot;"}, {"sha": "175f70f311f22e2ba6ad7273544afdb553f8b3e0", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2599,7 +2599,7 @@ sem_item_optimizer::execute (void)\n   dump_cong_classes ();\n \n   process_cong_reduction ();\n-  verify_classes ();\n+  checking_verify_classes ();\n \n   if (dump_file)\n     fprintf (dump_file, \"Dump after callgraph-based congruence reduction\\n\");\n@@ -2618,7 +2618,7 @@ sem_item_optimizer::execute (void)\n \n   process_cong_reduction ();\n   dump_cong_classes ();\n-  verify_classes ();\n+  checking_verify_classes ();\n   bool merged_p = merge_classes (prev_class_count);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2883,7 +2883,7 @@ sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n \t}\n     }\n \n-  verify_classes ();\n+  checking_verify_classes ();\n }\n \n /* Subdivide classes by address references that members of the class\n@@ -2977,39 +2977,46 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n   return newly_created_classes;\n }\n \n-/* Verify congruence classes if checking is enabled.  */\n+/* Verify congruence classes, if checking is enabled.  */\n+\n+void\n+sem_item_optimizer::checking_verify_classes (void)\n+{\n+  if (flag_checking)\n+    verify_classes ();\n+}\n+\n+/* Verify congruence classes.  */\n \n void\n sem_item_optimizer::verify_classes (void)\n {\n-#if ENABLE_CHECKING\n   for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n        it != m_classes.end (); ++it)\n     {\n       for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n \t{\n \t  congruence_class *cls = (*it)->classes[i];\n \n-\t  gcc_checking_assert (cls);\n-\t  gcc_checking_assert (cls->members.length () > 0);\n+\t  gcc_assert (cls);\n+\t  gcc_assert (cls->members.length () > 0);\n \n \t  for (unsigned int j = 0; j < cls->members.length (); j++)\n \t    {\n \t      sem_item *item = cls->members[j];\n \n-\t      gcc_checking_assert (item);\n-\t      gcc_checking_assert (item->cls == cls);\n+\t      gcc_assert (item);\n+\t      gcc_assert (item->cls == cls);\n \n \t      for (unsigned k = 0; k < item->usages.length (); k++)\n \t\t{\n \t\t  sem_usage_pair *usage = item->usages[k];\n-\t\t  gcc_checking_assert (usage->item->index_in_class <\n-\t\t\t\t       usage->item->cls->members.length ());\n+\t\t  gcc_assert (usage->item->index_in_class <\n+\t\t\t      usage->item->cls->members.length ());\n \t\t}\n \t    }\n \t}\n     }\n-#endif\n }\n \n /* Disposes split map traverse function. CLS_PTR is pointer to congruence\n@@ -3054,10 +3061,11 @@ sem_item_optimizer::traverse_congruence_split (congruence_class * const &cls,\n \t  add_item_to_class (tc, cls->members[i]);\n \t}\n \n-#ifdef ENABLE_CHECKING\n-      for (unsigned int i = 0; i < 2; i++)\n-\tgcc_checking_assert (newclasses[i]->members.length ());\n-#endif\n+      if (flag_checking)\n+\t{\n+\t  for (unsigned int i = 0; i < 2; i++)\n+\t    gcc_assert (newclasses[i]->members.length ());\n+\t}\n \n       if (splitter_cls == cls)\n \toptimizer->splitter_class_removed = true;\n@@ -3152,11 +3160,9 @@ sem_item_optimizer::do_congruence_step_for_index (congruence_class *cls,\n \t  else\n \t    b = *slot;\n \n-#if ENABLE_CHECKING\n \t  gcc_checking_assert (usage->item->cls);\n \t  gcc_checking_assert (usage->item->index_in_class <\n \t\t\t       usage->item->cls->members.length ());\n-#endif\n \n \t  bitmap_set_bit (b, usage->item->index_in_class);\n \t}"}, {"sha": "365e86fd35f1262ac7e12430f267d18ef9e8123e", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -479,6 +479,9 @@ class sem_item_optimizer\n   void dump (void);\n \n   /* Verify congruence classes if checking is enabled.  */\n+  void checking_verify_classes (void);\n+\n+  /* Verify congruence classes.  */\n   void verify_classes (void);\n \n   /* Write IPA ICF summary for symbols.  */"}, {"sha": "e93d445ccc63b9f8f75ecb2434906461ca7f6af9", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2964,10 +2964,12 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->size = info->self_size;\n   info->stack_frame_offset = 0;\n   info->estimated_stack_size = info->estimated_self_stack_size;\n-#ifdef ENABLE_CHECKING\n-  inline_update_overall_summary (node);\n-  gcc_assert (info->time == info->self_time && info->size == info->self_size);\n-#endif\n+  if (flag_checking)\n+    {\n+      inline_update_overall_summary (node);\n+      gcc_assert (info->time == info->self_time\n+\t\t  && info->size == info->self_size);\n+    }\n \n   pop_cfun ();\n }"}, {"sha": "1d7bcaa2420ac37f52dc77d32389c3c1794e7d43", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -491,10 +491,9 @@ save_inline_function_body (struct cgraph_node *node)\n       first_clone->remove_symbol_and_inline_clones ();\n       first_clone = NULL;\n     }\n-#ifdef ENABLE_CHECKING\n-  else\n+  else if (flag_checking)\n     first_clone->verify ();\n-#endif\n+\n   return first_clone;\n }\n "}, {"sha": "db98755ba8e0f4e76b3581bc0c60ef90ac23f130", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1878,7 +1878,7 @@ inline_small_functions (void)\n       if (!edge->inline_failed || !edge->callee->analyzed)\n \tcontinue;\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n       /* Be sure that caches are maintained consistent.  */\n       sreal cached_badness = edge_badness (edge, false);\n  \n@@ -2632,9 +2632,8 @@ early_inliner (function *fun)\n   if (ipa_node_params_sum)\n     return 0;\n \n-#ifdef ENABLE_CHECKING\n-  node->verify ();\n-#endif\n+  if (flag_checking)\n+    node->verify ();\n   node->remove_all_references ();\n \n   /* Rebuild this reference because it dosn't depend on"}, {"sha": "323d1172b44526715511a65c36f59ea139625858", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -299,10 +299,8 @@ estimate_edge_size (struct cgraph_edge *edge)\n static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n-#ifdef ENABLE_CHECKING\n   gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size\n \t\t       || !edge->callee->analyzed);\n-#endif\n   return (estimate_edge_size (edge)\n \t  - inline_edge_summary (edge)->call_stmt_size);\n }"}, {"sha": "0ae438856e14f6008187b9f0e0eb609bf4426569", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -464,16 +464,15 @@ function_and_variable_visibility (bool whole_program)\n \t what comdat group they are in when they won't be emitted in this TU.  */\n       if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  symtab_node *n;\n-\n-\t  for (n = node->same_comdat_group;\n-\t       n != node;\n-\t       n = n->same_comdat_group)\n-\t      /* If at least one of same comdat group functions is external,\n-\t\t all of them have to be, otherwise it is a front-end bug.  */\n-\t      gcc_assert (DECL_EXTERNAL (n->decl));\n-#endif\n+\t  if (flag_checking)\n+\t    {\n+\t      for (symtab_node *n = node->same_comdat_group;\n+\t\t   n != node;\n+\t\t   n = n->same_comdat_group)\n+\t\t/* If at least one of same comdat group functions is external,\n+\t\t   all of them have to be, otherwise it is a front-end bug.  */\n+\t\tgcc_assert (DECL_EXTERNAL (n->decl));\n+\t    }\n \t  node->dissolve_same_comdat_group_list ();\n \t}\n       gcc_assert ((!DECL_WEAK (node->decl)"}, {"sha": "6dc23ae9e624383ed9729250b69fd335cae7ec15", "filename": "gcc/ipa.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -319,12 +319,13 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n   build_type_inheritance_graph ();\n   if (file)\n     fprintf (file, \"\\nReclaiming functions:\");\n-#ifdef ENABLE_CHECKING\n-  FOR_EACH_FUNCTION (node)\n-    gcc_assert (!node->aux);\n-  FOR_EACH_VARIABLE (vnode)\n-    gcc_assert (!vnode->aux);\n-#endif\n+  if (flag_checking)\n+    {\n+      FOR_EACH_FUNCTION (node)\n+\tgcc_assert (!node->aux);\n+      FOR_EACH_VARIABLE (vnode)\n+\tgcc_assert (!vnode->aux);\n+    }\n   /* Mark functions whose bodies are obviously needed.\n      This is mostly when they can be referenced externally.  Inline clones\n      are special since their declarations are shared with master clone and thus\n@@ -678,9 +679,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n   if (file)\n     fprintf (file, \"\\n\");\n \n-#ifdef ENABLE_CHECKING\n-  symtab_node::verify_symtab_nodes ();\n-#endif\n+  symtab_node::checking_verify_symtab_nodes ();\n \n   /* If we removed something, perhaps profile could be improved.  */\n   if (changed && optimize && inline_edge_summary_vec.exists ())\n@@ -1370,13 +1369,12 @@ ipa_single_use (void)\n     {\n       if (var->aux != BOTTOM)\n \t{\n-#ifdef ENABLE_CHECKING\n \t  /* Not having the single user known means that the VAR is\n \t     unreachable.  Either someone forgot to remove unreachable\n \t     variables or the reachability here is wrong.  */\n \n-          gcc_assert (single_user_map.get (var));\n-#endif\n+\t  gcc_checking_assert (single_user_map.get (var));\n+\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Variable %s/%i is used by single function\\n\","}, {"sha": "d4160d3b008b54061c01cf90e09d06f5c2198019", "filename": "gcc/ira-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n /* To provide consistency in naming, all IRA external variables,\n    functions, common typedefs start with prefix ira_.  */\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n #define ENABLE_IRA_CHECKING\n #endif\n "}, {"sha": "8e71d5042abb6ae26ca8cbff38e4916c7a4e9813", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -5153,9 +5153,9 @@ ira (FILE *f)\n     df_remove_problem (df_live);\n   gcc_checking_assert (df_live == NULL);\n \n-#ifdef ENABLE_CHECKING\n-  df->changeable_flags |= DF_VERIFY_SCHEDULED;\n-#endif\n+  if (flag_checking)\n+    df->changeable_flags |= DF_VERIFY_SCHEDULED;\n+\n   df_analyze ();\n \n   init_reg_equiv ();"}, {"sha": "592ae1f283fac1f111257724460c15041abf209c", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -734,7 +734,5 @@ doloop_optimize_loops (void)\n \n   iv_analysis_done ();\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n+  checking_verify_loop_structure ();\n }"}, {"sha": "cd96e701c7e1399f0b622375f816dae420ce1285", "filename": "gcc/loop-init.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -104,10 +104,8 @@ loop_optimizer_init (unsigned flags)\n       /* Ensure that the dominators are computed, like flow_loops_find does.  */\n       calculate_dominance_info (CDI_DOMINATORS);\n \n-#ifdef ENABLE_CHECKING\n       if (!needs_fixup)\n-\tverify_loop_structure ();\n-#endif\n+\tchecking_verify_loop_structure ();\n \n       /* Clear all flags.  */\n       if (recorded_exits)\n@@ -129,9 +127,7 @@ loop_optimizer_init (unsigned flags)\n   /* Dump loops.  */\n   flow_loops_dump (dump_file, NULL, 1);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n+  checking_verify_loop_structure ();\n \n   timevar_pop (TV_LOOP_INIT);\n }\n@@ -323,9 +319,7 @@ fix_loop_structure (bitmap changed_bbs)\n   /* Apply flags to loops.  */\n   apply_loop_flags (current_loops->state | record_exits);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n+  checking_verify_loop_structure ();\n \n   timevar_pop (TV_LOOP_INIT);\n "}, {"sha": "696f0ee758ec3965eb943076f1f1aabd60a143a3", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2137,7 +2137,5 @@ move_loop_invariants (void)\n   invariant_table = NULL;\n   invariant_table_size = 0;\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n }"}, {"sha": "a17e22c60e2db806d4fa4f4ea577c8b704f0e043", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1591,15 +1591,13 @@ lra_assign (void)\n   bitmap_initialize (&all_spilled_pseudos, &reg_obstack);\n   create_live_range_start_chains ();\n   setup_live_pseudos_and_spill_after_risky_transforms (&all_spilled_pseudos);\n-#ifdef ENABLE_CHECKING\n-  if (!flag_ipa_ra)\n+  if (flag_checking && !flag_ipa_ra)\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n       if (lra_reg_info[i].nrefs != 0 && reg_renumber[i] >= 0\n \t  && lra_reg_info[i].call_p\n \t  && overlaps_hard_reg_set_p (call_used_reg_set,\n \t\t\t\t      PSEUDO_REGNO_MODE (i), reg_renumber[i]))\n \tgcc_unreachable ();\n-#endif\n   /* Setup insns to process on the next constraint pass.  */\n   bitmap_initialize (&changed_pseudo_bitmap, &reg_obstack);\n   init_live_reload_and_inheritance_pseudos ();"}, {"sha": "bc7a29290f289285e6ceb51b12aaec6c38d6bb74", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -4455,8 +4455,7 @@ lra_constraints (bool first_p)\n   bitmap_clear (&equiv_insn_bitmap);\n   /* If we used a new hard regno, changed_p should be true because the\n      hard reg is assigned to a new pseudo.  */\n-#ifdef ENABLE_CHECKING\n-  if (! changed_p)\n+  if (flag_checking && !changed_p)\n     {\n       for (i = FIRST_PSEUDO_REGISTER; i < new_regno_start; i++)\n \tif (lra_reg_info[i].nrefs != 0\n@@ -4468,7 +4467,6 @@ lra_constraints (bool first_p)\n \t      lra_assert (df_regs_ever_live_p (hard_regno + j));\n \t  }\n     }\n-#endif\n   return changed_p;\n }\n "}, {"sha": "448e645fdb24df48d99f47d2398af0aab08bc755", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1436,11 +1436,11 @@ lra_eliminate (bool final_p, bool first_p)\n   bitmap_initialize (&insns_with_changed_offsets, &reg_obstack);\n   if (final_p)\n     {\n-#ifdef ENABLE_CHECKING\n-      update_reg_eliminate (&insns_with_changed_offsets);\n-      if (! bitmap_empty_p (&insns_with_changed_offsets))\n-\tgcc_unreachable ();\n-#endif\n+      if (flag_checking)\n+\t{\n+\t  update_reg_eliminate (&insns_with_changed_offsets);\n+\t  gcc_assert (bitmap_empty_p (&insns_with_changed_offsets));\n+\t}\n       /* We change eliminable hard registers in insns so we should do\n \t this for all insns containing any eliminable hard\n \t register.  */"}, {"sha": "02b0ae4b3842400cdfed9f601e2bfbb82e436530", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -91,12 +91,10 @@ struct lra_reg\n   /* True if the pseudo should not be assigned to a stack register.  */\n   bool no_stack_p;\n #endif\n-#ifdef ENABLE_CHECKING\n   /* True if the pseudo crosses a call.\t It is setup in lra-lives.c\n      and used to check that the pseudo crossing a call did not get a\n      call used hard register.  */\n   bool call_p;\n-#endif\n   /* Number of references and execution frequencies of the register in\n      *non-debug* insns.\t */\n   int nrefs, freq;"}, {"sha": "a2c55426e934f438e48668d9339aaf1047f88c4a", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -590,9 +590,7 @@ check_pseudos_live_through_calls (int regno)\n   for (hr = 0; hr < FIRST_PSEUDO_REGISTER; hr++)\n     if (HARD_REGNO_CALL_PART_CLOBBERED (hr, PSEUDO_REGNO_MODE (regno)))\n       SET_HARD_REG_BIT (lra_reg_info[regno].conflict_hard_regs, hr);\n-#ifdef ENABLE_CHECKING\n   lra_reg_info[regno].call_p = true;\n-#endif\n   if (! sparseset_bit_p (pseudos_live_through_setjumps, regno))\n     return;\n   sparseset_clear_bit (pseudos_live_through_setjumps, regno);\n@@ -1229,9 +1227,7 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n \tlra_reg_info[i].biggest_mode = GET_MODE (regno_reg_rtx[i]);\n       else\n \tlra_reg_info[i].biggest_mode = VOIDmode;\n-#ifdef ENABLE_CHECKING\n       lra_reg_info[i].call_p = false;\n-#endif\n       if (i >= FIRST_PSEUDO_REGISTER\n \t  && lra_reg_info[i].nrefs != 0)\n \t{"}, {"sha": "68ce5025350ce566fc5f8ef32fabf1bc5fdd44b6", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -578,10 +578,8 @@ create_remat_bb_data (void)\n \t\t\t   last_basic_block_for_fn (cfun));\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n-#ifdef ENABLE_CHECKING\n-      if (bb->index < 0 || bb->index >= last_basic_block_for_fn (cfun))\n-\tabort ();\n-#endif\n+      gcc_checking_assert (bb->index >= 0\n+\t\t\t   && bb->index < last_basic_block_for_fn (cfun));\n       bb_info = get_remat_bb_data (bb);\n       bb_info->bb = bb;\n       bitmap_initialize (&bb_info->changed_regs, &reg_obstack);"}, {"sha": "cc5a850bd2e6726a9b673a919aecbcf75a2fb389", "filename": "gcc/lra.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1199,30 +1199,22 @@ lra_update_insn_recog_data (rtx_insn *insn)\n \t  decode_asm_operands (PATTERN (insn), NULL,\n \t\t\t       data->operand_loc,\n \t\t\t       constraints, operand_mode, NULL);\n-#ifdef ENABLE_CHECKING\n-\t  {\n-\t    int i;\n \n-\t    for (i = 0; i < nop; i++)\n+\t  if (flag_checking)\n+\t    for (int i = 0; i < nop; i++)\n \t      lra_assert\n \t\t(insn_static_data->operand[i].mode == operand_mode[i]\n \t\t && insn_static_data->operand[i].constraint == constraints[i]\n \t\t && ! insn_static_data->operand[i].is_operator);\n-\t  }\n-#endif\n \t}\n-#ifdef ENABLE_CHECKING\n-      {\n-\tint i;\n \n-\tfor (i = 0; i < insn_static_data->n_operands; i++)\n+      if (flag_checking)\n+\tfor (int i = 0; i < insn_static_data->n_operands; i++)\n \t  lra_assert\n \t    (insn_static_data->operand[i].type\n \t     == (insn_static_data->operand[i].constraint[0] == '=' ? OP_OUT\n \t\t : insn_static_data->operand[i].constraint[0] == '+' ? OP_INOUT\n \t\t : OP_IN));\n-      }\n-#endif\n     }\n   else\n     {\n@@ -2004,8 +1996,6 @@ restore_scratches (void)\n \n \f\n \n-#ifdef ENABLE_CHECKING\n-\n /* Function checks RTL for correctness.\t If FINAL_P is true, it is\n    done at the end of LRA and the check is more rigorous.  */\n static void\n@@ -2024,9 +2014,7 @@ check_rtl (bool final_p)\n       {\n \tif (final_p)\n \t  {\n-#ifdef ENABLED_CHECKING\n \t    extract_constrain_insn (insn);\n-#endif\n \t    continue;\n \t  }\n \t/* LRA code is based on assumption that all addresses can be\n@@ -2039,7 +2027,6 @@ check_rtl (bool final_p)\n \t  fatal_insn_not_found (insn);\n       }\n }\n-#endif /* #ifdef ENABLE_CHECKING */\n \n /* Determine if the current function has an exception receiver block\n    that reaches the exit block via non-exceptional edges  */\n@@ -2233,10 +2220,9 @@ lra (FILE *f)\n \n   init_insn_recog_data ();\n \n-#ifdef ENABLE_CHECKING\n   /* Some quick check on RTL generated by previous passes.  */\n-  check_rtl (false);\n-#endif\n+  if (flag_checking)\n+    check_rtl (false);\n \n   lra_in_progress = 1;\n \n@@ -2437,9 +2423,8 @@ lra (FILE *f)\n      by this, so unshare everything here.  */\n   unshare_all_rtl_again (get_insns ());\n \n-#ifdef ENABLE_CHECKING\n-  check_rtl (true);\n-#endif\n+  if (flag_checking)\n+    check_rtl (true);\n \n   timevar_pop (TV_LRA);\n }"}, {"sha": "eb6f7b6f8a59ff159a86ba8cec9c48a8737bafe2", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1560,10 +1560,11 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   lto_input_toplevel_asms (file_data, order_base);\n \n   /* AUX pointers should be all non-zero for function nodes read from the stream.  */\n-#ifdef ENABLE_CHECKING\n-  FOR_EACH_VEC_ELT (nodes, i, node)\n-    gcc_assert (node->aux || !is_a <cgraph_node *> (node));\n-#endif\n+  if (flag_checking)\n+    {\n+      FOR_EACH_VEC_ELT (nodes, i, node)\n+\tgcc_assert (node->aux || !is_a <cgraph_node *> (node));\n+    }\n   FOR_EACH_VEC_ELT (nodes, i, node)\n     {\n       int ref;"}, {"sha": "d54beca66236e9dd46215a38f78a8b45da7286ca", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -607,17 +607,12 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t\tstd::swap (sccstack[first + i],\n \t\t\t   sccstack[first + entry_start + i]);\n \n-\t      if (scc_entry_len == 1)\n-\t\t; /* We already sorted SCC deterministically in hash_scc.  */\n-\t      else\n-\t\t/* Check that we have only one SCC.\n-\t\t   Naturally we may have conflicts if hash function is not\n- \t\t   strong enough.  Lets see how far this gets.  */\n-\t\t{\n-#ifdef ENABLE_CHECKING\n-\t\t  gcc_unreachable ();\n-#endif\n-\t\t}\n+\t      /* We already sorted SCC deterministically in hash_scc.  */\n+\n+\t      /* Check that we have only one SCC.\n+\t\t Naturally we may have conflicts if hash function is not\n+\t\t strong enough.  Lets see how far this gets.  */\n+\t      gcc_checking_assert (scc_entry_len == 1);\n \t    }\n \n \t  /* Write LTO_tree_scc.  */\n@@ -2277,12 +2272,13 @@ void\n lto_output (void)\n {\n   struct lto_out_decl_state *decl_state;\n-#ifdef ENABLE_CHECKING\n-  bitmap output = lto_bitmap_alloc ();\n-#endif\n+  bitmap output = NULL;\n   int i, n_nodes;\n   lto_symtab_encoder_t encoder = lto_get_out_decl_state ()->symtab_node_encoder;\n \n+  if (flag_checking)\n+    output = lto_bitmap_alloc ();\n+\n   /* Initialize the streamer.  */\n   lto_streamer_init ();\n \n@@ -2296,10 +2292,11 @@ lto_output (void)\n \t  if (lto_symtab_encoder_encode_body_p (encoder, node)\n \t      && !node->alias)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n-\t      bitmap_set_bit (output, DECL_UID (node->decl));\n-#endif\n+\t      if (flag_checking)\n+\t\t{\n+\t\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n+\t\t  bitmap_set_bit (output, DECL_UID (node->decl));\n+\t\t}\n \t      decl_state = lto_new_out_decl_state ();\n \t      lto_push_out_decl_state (decl_state);\n \t      if (gimple_has_body_p (node->decl) || !flag_wpa\n@@ -2326,10 +2323,11 @@ lto_output (void)\n \t      && !node->alias)\n \t    {\n \t      timevar_push (TV_IPA_LTO_CTORS_OUT);\n-#ifdef ENABLE_CHECKING\n-\t      gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n-\t      bitmap_set_bit (output, DECL_UID (node->decl));\n-#endif\n+\t      if (flag_checking)\n+\t\t{\n+\t\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n+\t\t  bitmap_set_bit (output, DECL_UID (node->decl));\n+\t\t}\n \t      decl_state = lto_new_out_decl_state ();\n \t      lto_push_out_decl_state (decl_state);\n \t      if (DECL_INITIAL (node->decl) != error_mark_node\n@@ -2353,7 +2351,7 @@ lto_output (void)\n \n   output_offload_tables ();\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n   lto_bitmap_free (output);\n #endif\n }"}, {"sha": "92b313addeb43665fa0fe99f3ada9f60f11a092c", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -297,13 +297,12 @@ static hash_table<tree_hash_entry> *tree_htab;\n void\n lto_streamer_init (void)\n {\n-#ifdef ENABLE_CHECKING\n   /* Check that all the TS_* handled by the reader and writer routines\n      match exactly the structures defined in treestruct.def.  When a\n      new TS_* astructure is added, the streamer should be updated to\n      handle it.  */\n-  streamer_check_handled_ts_structures ();\n-#endif\n+  if (flag_checking)\n+    streamer_check_handled_ts_structures ();\n \n #ifdef LTO_STREAMER_DEBUG\n   tree_htab = new hash_table<tree_hash_entry> (31);"}, {"sha": "4ec06b8db6bf2199fa76acbe0251b07d9c59d2d0", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1,3 +1,12 @@\n+2015-10-27  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* lto.c (unify_scc): Use flag_checking and remove ENABLE_CHECKING\n+\tconditionals.\n+\t(lto_fixup_state): Likewise.\n+\t(do_whole_program_analysis): Use\n+\tsymtab_node::checking_verify_symtab_nodes and remove ENABLE_CHECKING\n+\tconditionals.\n+\n 2015-10-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* lto-lang.c (DEF_FUNCTION_TYPE_9, DEF_FUNCTION_TYPE_10,"}, {"sha": "def681d09dd3f6ac4d3f05c224ce8a75cc5ec315", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1586,19 +1586,18 @@ unify_scc (struct data_in *data_in, unsigned from,\n \t  num_sccs_merged++;\n \t  total_scc_size_merged += len;\n \n-#ifdef ENABLE_CHECKING\n-\t  for (unsigned i = 0; i < len; ++i)\n-\t    {\n-\t      tree t = map[2*i+1];\n-\t      enum tree_code code = TREE_CODE (t);\n-\t      /* IDENTIFIER_NODEs should be singletons and are merged by the\n-\t\t streamer.  The others should be singletons, too, and we\n-\t\t should not merge them in any way.  */\n-\t      gcc_assert (code != TRANSLATION_UNIT_DECL\n-\t\t\t  && code != IDENTIFIER_NODE\n-\t\t\t  && !streamer_handle_as_builtin_p (t));\n-\t    }\n-#endif\n+\t  if (flag_checking)\n+\t    for (unsigned i = 0; i < len; ++i)\n+\t      {\n+\t\ttree t = map[2*i+1];\n+\t\tenum tree_code code = TREE_CODE (t);\n+\t\t/* IDENTIFIER_NODEs should be singletons and are merged by the\n+\t\t   streamer.  The others should be singletons, too, and we\n+\t\t   should not merge them in any way.  */\n+\t\tgcc_assert (code != TRANSLATION_UNIT_DECL\n+\t\t\t    && code != IDENTIFIER_NODE\n+\t\t\t    && !streamer_handle_as_builtin_p (t));\n+\t      }\n \n \t  /* Fixup the streamer cache with the prevailing nodes according\n \t     to the tree node mapping computed by compare_tree_sccs.  */\n@@ -2636,10 +2635,8 @@ lto_fixup_state (struct lto_in_decl_state *state)\n       for (i = 0; i < vec_safe_length (trees); i++)\n \t{\n \t  tree t = (*trees)[i];\n-#ifdef ENABLE_CHECKING\n-\t  if (TYPE_P (t))\n+\t  if (flag_checking && TYPE_P (t))\n \t    verify_type (t);\n-#endif\n \t  if (VAR_OR_FUNCTION_DECL_P (t)\n \t      && (TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n \t    (*trees)[i] = lto_symtab_prevailing_decl (t);\n@@ -3101,9 +3098,8 @@ do_whole_program_analysis (void)\n       fprintf (symtab->dump_file, \"Optimized \");\n       symtab_node::dump_table (symtab->dump_file);\n     }\n-#ifdef ENABLE_CHECKING\n-  symtab_node::verify_symtab_nodes ();\n-#endif\n+\n+  symtab_node::checking_verify_symtab_nodes ();\n   bitmap_obstack_release (NULL);\n \n   /* We are about to launch the final LTRANS phase, stop the WPA timer.  */"}, {"sha": "754783537a2672f531091e7a06284ba78ea9a2de", "filename": "gcc/omp-low.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -3127,14 +3127,14 @@ scan_omp_target (gomp_target *stmt, omp_context *outer_ctx)\n     {\n       TYPE_FIELDS (ctx->record_type)\n \t= nreverse (TYPE_FIELDS (ctx->record_type));\n-#ifdef ENABLE_CHECKING\n-      tree field;\n-      unsigned int align = DECL_ALIGN (TYPE_FIELDS (ctx->record_type));\n-      for (field = TYPE_FIELDS (ctx->record_type);\n-\t   field;\n-\t   field = DECL_CHAIN (field))\n-\tgcc_assert (DECL_ALIGN (field) == align);\n-#endif\n+      if (flag_checking)\n+\t{\n+\t  unsigned int align = DECL_ALIGN (TYPE_FIELDS (ctx->record_type));\n+\t  for (tree field = TYPE_FIELDS (ctx->record_type);\n+\t       field;\n+\t       field = DECL_CHAIN (field))\n+\t    gcc_assert (DECL_ALIGN (field) == align);\n+\t}\n       layout_type (ctx->record_type);\n       if (offloaded)\n \tfixup_child_record_type (ctx);\n@@ -6742,10 +6742,8 @@ expand_omp_taskreg (struct omp_region *region)\n \t}\n       if (gimple_in_ssa_p (cfun))\n \tupdate_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-      if (!loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n+      if (flag_checking && !loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n \tverify_loop_structure ();\n-#endif\n       pop_cfun ();\n     }\n \n@@ -11562,10 +11560,8 @@ expand_omp_target (struct omp_region *region)\n \t  if (changed)\n \t    cleanup_tree_cfg ();\n \t}\n-#ifdef ENABLE_CHECKING\n-      if (!loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n+      if (flag_checking && !loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n \tverify_loop_structure ();\n-#endif\n       pop_cfun ();\n     }\n \n@@ -12102,10 +12098,8 @@ execute_expand_omp (void)\n \n   expand_omp (root_omp_region);\n \n-#ifdef ENABLE_CHECKING\n-  if (!loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n+  if (flag_checking && !loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n     verify_loop_structure ();\n-#endif\n   cleanup_tree_cfg ();\n \n   free_omp_regions ();\n@@ -14260,7 +14254,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       default:\n \tbreak;\n       case OMP_CLAUSE_MAP:\n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n \t/* First check what we're prepared to handle in the following.  */\n \tswitch (OMP_CLAUSE_MAP_KIND (c))\n \t  {"}, {"sha": "43dd4e0840763ef0ac0960f4bf1a863fb0c01a08", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1952,9 +1952,8 @@ execute_function_todo (function *fn, void *data)\n \n   gcc_assert (dom_info_state (fn, CDI_POST_DOMINATORS) == DOM_NONE);\n   /* If we've seen errors do not bother running any verifiers.  */\n-  if (!seen_error ())\n+  if (flag_checking && !seen_error ())\n     {\n-#if defined ENABLE_CHECKING\n       dom_state pre_verify_state = dom_info_state (fn, CDI_DOMINATORS);\n       dom_state pre_verify_pstate = dom_info_state (fn, CDI_POST_DOMINATORS);\n \n@@ -1988,7 +1987,6 @@ execute_function_todo (function *fn, void *data)\n       /* Make sure verifiers don't change dominator state.  */\n       gcc_assert (dom_info_state (fn, CDI_DOMINATORS) == pre_verify_state);\n       gcc_assert (dom_info_state (fn, CDI_POST_DOMINATORS) == pre_verify_pstate);\n-#endif\n     }\n \n   fn->last_verified = flags & TODO_verify_all;\n@@ -2008,11 +2006,10 @@ execute_function_todo (function *fn, void *data)\n static void\n execute_todo (unsigned int flags)\n {\n-#if defined ENABLE_CHECKING\n-  if (cfun\n+  if (flag_checking\n+      && cfun\n       && need_ssa_update_p (cfun))\n     gcc_assert (flags & TODO_update_ssa_any);\n-#endif\n \n   timevar_push (TV_TODO);\n \n@@ -2076,14 +2073,12 @@ clear_last_verified (function *fn, void *data ATTRIBUTE_UNUSED)\n /* Helper function. Verify that the properties has been turn into the\n    properties expected by the pass.  */\n \n-#ifdef ENABLE_CHECKING\n-static void\n+static void DEBUG_FUNCTION\n verify_curr_properties (function *fn, void *data)\n {\n   unsigned int props = (size_t)data;\n   gcc_assert ((fn->curr_properties & props) == props);\n }\n-#endif\n \n /* Initialize pass dump file.  */\n /* This is non-static so that the plugins can use it.  */\n@@ -2331,10 +2326,9 @@ execute_one_pass (opt_pass *pass)\n   /* Run pre-pass verification.  */\n   execute_todo (pass->todo_flags_start);\n \n-#ifdef ENABLE_CHECKING\n-  do_per_function (verify_curr_properties,\n-\t\t   (void *)(size_t)pass->properties_required);\n-#endif\n+  if (flag_checking)\n+    do_per_function (verify_curr_properties,\n+\t\t     (void *)(size_t)pass->properties_required);\n \n   /* If a timevar is present, start it.  */\n   if (pass->tv_id != TV_NONE)"}, {"sha": "4482d4783810bf184cd804fea8fab3ef92d733ce", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2205,8 +2205,6 @@ tree_bb_level_predictions (void)\n     }\n }\n \n-#ifdef ENABLE_CHECKING\n-\n /* Callback for hash_map::traverse, asserts that the pointer map is\n    empty.  */\n \n@@ -2217,7 +2215,6 @@ assert_is_empty (const_basic_block const &, edge_prediction *const &value,\n   gcc_assert (!value);\n   return false;\n }\n-#endif\n \n /* Predict branch probabilities and estimate profile for basic block BB.  */\n \n@@ -2352,9 +2349,9 @@ tree_estimate_probability (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     combine_predictions_for_bb (bb);\n \n-#ifdef ENABLE_CHECKING\n-  bb_predictions->traverse<void *, assert_is_empty> (NULL);\n-#endif\n+  if (flag_checking)\n+    bb_predictions->traverse<void *, assert_is_empty> (NULL);\n+\n   delete bb_predictions;\n   bb_predictions = NULL;\n \n@@ -2545,11 +2542,10 @@ propagate_freq (basic_block head, bitmap tovisit)\n       /* Compute frequency of basic block.  */\n       if (bb != head)\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    gcc_assert (!bitmap_bit_p (tovisit, e->src->index)\n-\t\t\t|| (e->flags & EDGE_DFS_BACK));\n-#endif\n+\t  if (flag_checking)\n+\t    FOR_EACH_EDGE (e, ei, bb->preds)\n+\t      gcc_assert (!bitmap_bit_p (tovisit, e->src->index)\n+\t\t\t  || (e->flags & EDGE_DFS_BACK));\n \n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (EDGE_INFO (e)->back_edge)"}, {"sha": "b24402de12dfa76a56ee2757262831e6270274fd", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -625,10 +625,9 @@ pp_format (pretty_printer *pp, text_info *text)\n       *formatters[argno] = XOBFINISH (&buffer->chunk_obstack, const char *);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  for (; argno < PP_NL_ARGMAX; argno++)\n-    gcc_assert (!formatters[argno]);\n-#endif\n+  if (CHECKING_P)\n+    for (; argno < PP_NL_ARGMAX; argno++)\n+      gcc_assert (!formatters[argno]);\n \n   /* Revert to normal obstack and wrapping mode.  */\n   buffer->obstack = &buffer->formatted_obstack;"}, {"sha": "a29212643f5cea70fdb201fa985cd1f4d97d6aa9", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1808,15 +1808,13 @@ real_to_decimal_for_mode (char *str, const REAL_VALUE_TYPE *r_orig,\n   /* Append the exponent.  */\n   sprintf (last, \"e%+d\", dec_exp);\n \n-#ifdef ENABLE_CHECKING\n   /* Verify that we can read the original value back in.  */\n-  if (mode != VOIDmode)\n+  if (flag_checking && mode != VOIDmode)\n     {\n       real_from_string (&r, str);\n       real_convert (&r, mode, &r);\n       gcc_assert (real_identical (&r, r_orig));\n     }\n-#endif\n }\n \n /* Likewise, except always uses round-to-nearest.  */"}, {"sha": "2cd06f58e77af6443bdf8363a8afaaec15834920", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2975,9 +2975,7 @@ split_all_insns (void)\n   if (changed)\n     find_many_sub_basic_blocks (blocks);\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n \n   sbitmap_free (blocks);\n }"}, {"sha": "bc8111c1a2ca838b2409fa79fb4bd617da235d72", "filename": "gcc/regcprop.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -100,9 +100,7 @@ static bool replace_oldest_value_addr (rtx *, enum reg_class,\n static bool replace_oldest_value_mem (rtx, rtx_insn *, struct value_data *);\n static bool copyprop_hardreg_forward_1 (basic_block, struct value_data *);\n extern void debug_value_data (struct value_data *);\n-#ifdef ENABLE_CHECKING\n static void validate_value_data (struct value_data *);\n-#endif\n \n /* Free all queued updates for DEBUG_INSNs that change some reg to\n    register REGNO.  */\n@@ -150,9 +148,8 @@ kill_value_one_regno (unsigned int regno, struct value_data *vd)\n   if (vd->e[regno].debug_insn_changes)\n     free_debug_insn_changes (vd, regno);\n \n-#ifdef ENABLE_CHECKING\n-  validate_value_data (vd);\n-#endif\n+  if (flag_checking)\n+    validate_value_data (vd);\n }\n \n /* Kill the value in register REGNO for NREGS, and any other registers\n@@ -365,9 +362,8 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n     continue;\n   vd->e[i].next_regno = dr;\n \n-#ifdef ENABLE_CHECKING\n-  validate_value_data (vd);\n-#endif\n+  if (flag_checking)\n+    validate_value_data (vd);\n }\n \n /* Return true if a mode change from ORIG to NEW is allowed for REGNO.  */\n@@ -1141,7 +1137,6 @@ copyprop_hardreg_forward_bb_without_debug_insn (basic_block bb)\n   skip_debug_insn_p = false;\n }\n \n-#ifdef ENABLE_CHECKING\n static void\n validate_value_data (struct value_data *vd)\n {\n@@ -1187,7 +1182,7 @@ validate_value_data (struct value_data *vd)\n \t\t      i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n \t\t      vd->e[i].next_regno);\n }\n-#endif\n+\n \f\n namespace {\n "}, {"sha": "32eec0230c4b9c6c499b09abd26634e5ec9781f0", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -85,7 +85,7 @@ a register with any other reload.  */\n \n #define REG_OK_STRICT\n \n-/* We do not enable this with ENABLE_CHECKING, since it is awfully slow.  */\n+/* We do not enable this with CHECKING_P, since it is awfully slow.  */\n #undef DEBUG_RELOAD\n \n #include \"config.h\""}, {"sha": "c53a51f95ecfc88ced6ba6c4ad1414b5b6e9eb55", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -47,12 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef INSN_SCHEDULING\n \n-#ifdef ENABLE_CHECKING\n-#define CHECK (true)\n-#else\n-#define CHECK (false)\n-#endif\n-\n /* Holds current parameters for the dependency analyzer.  */\n struct sched_deps_info_def *sched_deps_info;\n \n@@ -505,9 +499,8 @@ static enum DEPS_ADJUST_RESULT maybe_add_or_update_dep_1 (dep_t, bool,\n \t\t\t\t\t\t\t  rtx, rtx);\n static enum DEPS_ADJUST_RESULT add_or_update_dep_1 (dep_t, bool, rtx, rtx);\n \n-#ifdef ENABLE_CHECKING\n static void check_dep (dep_t, bool);\n-#endif\n+\n \f\n /* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n \n@@ -1228,9 +1221,8 @@ add_or_update_dep_1 (dep_t new_dep, bool resolved_p,\n   gcc_assert (INSN_P (DEP_PRO (new_dep)) && INSN_P (DEP_CON (new_dep))\n \t      && DEP_PRO (new_dep) != DEP_CON (new_dep));\n \n-#ifdef ENABLE_CHECKING\n-  check_dep (new_dep, mem1 != NULL);\n-#endif\n+  if (flag_checking)\n+    check_dep (new_dep, mem1 != NULL);\n \n   if (true_dependency_cache != NULL)\n     {\n@@ -1348,9 +1340,8 @@ sd_add_dep (dep_t dep, bool resolved_p)\n \n   add_to_deps_list (DEP_NODE_BACK (n), con_back_deps);\n \n-#ifdef ENABLE_CHECKING\n-  check_dep (dep, false);\n-#endif\n+  if (flag_checking)\n+    check_dep (dep, false);\n \n   add_to_deps_list (DEP_NODE_FORW (n), pro_forw_deps);\n \n@@ -4515,7 +4506,6 @@ debug_ds (ds_t s)\n   fprintf (stderr, \"\\n\");\n }\n \n-#ifdef ENABLE_CHECKING\n /* Verify that dependence type and status are consistent.\n    If RELAXED_P is true, then skip dep_weakness checks.  */\n static void\n@@ -4600,7 +4590,6 @@ check_dep (dep_t dep, bool relaxed_p)\n \tgcc_assert (ds & BEGIN_CONTROL);\n     }\n }\n-#endif /* ENABLE_CHECKING */\n \n /* The following code discovers opportunities to switch a memory reference\n    and an increment by modifying the address.  We ensure that this is done"}, {"sha": "b109a5b3004a55b48deb554b13291424a169bb86", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -954,7 +954,6 @@ return_regset_to_pool (regset rs)\n   regset_pool.v[regset_pool.n++] = rs;\n }\n \n-#ifdef ENABLE_CHECKING\n /* This is used as a qsort callback for sorting regset pool stacks.\n    X and XX are addresses of two regsets.  They are never equal.  */\n static int\n@@ -968,44 +967,42 @@ cmp_v_in_regset_pool (const void *x, const void *xx)\n     return -1;\n   gcc_unreachable ();\n }\n-#endif\n \n-/*  Free the regset pool possibly checking for memory leaks.  */\n+/* Free the regset pool possibly checking for memory leaks.  */\n void\n free_regset_pool (void)\n {\n-#ifdef ENABLE_CHECKING\n-  {\n-    regset *v = regset_pool.v;\n-    int i = 0;\n-    int n = regset_pool.n;\n+  if (flag_checking)\n+    {\n+      regset *v = regset_pool.v;\n+      int i = 0;\n+      int n = regset_pool.n;\n \n-    regset *vv = regset_pool.vv;\n-    int ii = 0;\n-    int nn = regset_pool.nn;\n+      regset *vv = regset_pool.vv;\n+      int ii = 0;\n+      int nn = regset_pool.nn;\n \n-    int diff = 0;\n+      int diff = 0;\n \n-    gcc_assert (n <= nn);\n+      gcc_assert (n <= nn);\n \n-    /* Sort both vectors so it will be possible to compare them.  */\n-    qsort (v, n, sizeof (*v), cmp_v_in_regset_pool);\n-    qsort (vv, nn, sizeof (*vv), cmp_v_in_regset_pool);\n+      /* Sort both vectors so it will be possible to compare them.  */\n+      qsort (v, n, sizeof (*v), cmp_v_in_regset_pool);\n+      qsort (vv, nn, sizeof (*vv), cmp_v_in_regset_pool);\n \n-    while (ii < nn)\n-      {\n-        if (v[i] == vv[ii])\n-          i++;\n-        else\n-          /* VV[II] was lost.  */\n-          diff++;\n+      while (ii < nn)\n+\t{\n+\t  if (v[i] == vv[ii])\n+\t    i++;\n+\t  else\n+\t    /* VV[II] was lost.  */\n+\t    diff++;\n \n-        ii++;\n-      }\n+\t  ii++;\n+\t}\n \n-    gcc_assert (diff == regset_pool.diff);\n-  }\n-#endif\n+      gcc_assert (diff == regset_pool.diff);\n+    }\n \n   /* If not true - we have a memory leak.  */\n   gcc_assert (regset_pool.diff == 0);\n@@ -3623,7 +3620,6 @@ insn_is_the_only_one_in_bb_p (insn_t insn)\n   return sel_bb_head_p (insn) && sel_bb_end_p (insn);\n }\n \n-#ifdef ENABLE_CHECKING\n /* Check that the region we're scheduling still has at most one\n    backedge.  */\n static void\n@@ -3644,7 +3640,6 @@ verify_backedges (void)\n       gcc_assert (n <= 1);\n     }\n }\n-#endif\n \f\n \n /* Functions to work with control flow.  */\n@@ -3889,10 +3884,12 @@ tidy_control_flow (basic_block xbb, bool full_tidying)\n \tsel_recompute_toporder ();\n     }\n \n-#ifdef ENABLE_CHECKING\n-  verify_backedges ();\n-  verify_dominators (CDI_DOMINATORS);\n-#endif\n+  /* TODO: use separate flag for CFG checking.  */\n+  if (flag_checking)\n+    {\n+      verify_backedges ();\n+      verify_dominators (CDI_DOMINATORS);\n+    }\n \n   return changed;\n }"}, {"sha": "30fcfdb7ed919e9c1a8706f954040986ac26ce32", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -378,10 +378,8 @@ struct moveop_static_params\n      they are to be removed.  */\n   int uid;\n \n-#ifdef ENABLE_CHECKING\n   /* This is initialized to the insn on which the driver stopped its traversal.  */\n   insn_t failed_insn;\n-#endif\n \n   /* True if we scheduled an insn with different register.  */\n   bool was_renamed;\n@@ -1655,17 +1653,15 @@ find_best_reg_for_expr (expr_t expr, blist_t bnds, bool *is_orig_reg_p)\n   collect_unavailable_regs_from_bnds (expr, bnds, used_regs, &reg_rename_data,\n \t\t\t\t      &original_insns);\n \n-#ifdef ENABLE_CHECKING\n   /* If after reload, make sure we're working with hard regs here.  */\n-  if (reload_completed)\n+  if (flag_checking && reload_completed)\n     {\n       reg_set_iterator rsi;\n       unsigned i;\n \n       EXECUTE_IF_SET_IN_REG_SET (used_regs, FIRST_PSEUDO_REGISTER, i, rsi)\n         gcc_unreachable ();\n     }\n-#endif\n \n   if (EXPR_SEPARABLE_P (expr))\n     {\n@@ -3593,7 +3589,6 @@ vinsn_vec_has_expr_p (vinsn_vec_t vinsn_vec, expr_t expr)\n   return false;\n }\n \n-#ifdef ENABLE_CHECKING\n /* Return true if either of expressions from ORIG_OPS can be blocked\n    by previously created bookkeeping code.  STATIC_PARAMS points to static\n    parameters of move_op.  */\n@@ -3635,7 +3630,6 @@ av_set_could_be_blocked_by_bookkeeping_p (av_set_t orig_ops, void *static_params\n \n   return false;\n }\n-#endif\n \n /* Clear VINSN_VEC and detach vinsns.  */\n static void\n@@ -4889,11 +4883,10 @@ move_cond_jump (rtx_insn *insn, bnd_t bnd)\n   block_bnd = BLOCK_FOR_INSN (BND_TO (bnd));\n   prev = BND_TO (bnd);\n \n-#ifdef ENABLE_CHECKING\n   /* Moving of jump should not cross any other jumps or beginnings of new\n      basic blocks.  The only exception is when we move a jump through\n      mutually exclusive insns along fallthru edges.  */\n-  if (block_from != block_bnd)\n+  if (flag_checking && block_from != block_bnd)\n     {\n       bb = block_from;\n       for (link = PREV_INSN (insn); link != PREV_INSN (prev);\n@@ -4908,7 +4901,6 @@ move_cond_jump (rtx_insn *insn, bnd_t bnd)\n             }\n         }\n     }\n-#endif\n \n   /* Jump is moved to the boundary.  */\n   next = PREV_INSN (insn);\n@@ -6205,9 +6197,7 @@ move_op_orig_expr_not_found (insn_t insn, av_set_t orig_ops ATTRIBUTE_UNUSED,\n {\n   moveop_static_params_p sparams = (moveop_static_params_p) static_params;\n \n-#ifdef ENABLE_CHECKING\n   sparams->failed_insn = insn;\n-#endif\n \n   /* If we're scheduling separate expr, in order to generate correct code\n      we need to stop the search at bookkeeping code generated with the\n@@ -6380,20 +6370,17 @@ code_motion_process_successors (insn_t insn, av_set_t orig_ops,\n         }\n     }\n \n-#ifdef ENABLE_CHECKING\n   /* Here, RES==1 if original expr was found at least for one of the\n      successors.  After the loop, RES may happen to have zero value\n      only if at some point the expr searched is present in av_set, but is\n      not found below.  In most cases, this situation is an error.\n      The exception is when the original operation is blocked by\n      bookkeeping generated for another fence or for another path in current\n      move_op.  */\n-  gcc_assert (res == 1\n-\t      || (res == 0\n-\t\t  && av_set_could_be_blocked_by_bookkeeping_p (orig_ops,\n-\t\t\t\t\t\t\t       static_params))\n-\t      || res == -1);\n-#endif\n+  gcc_checking_assert (res == 1\n+\t\t       || (res == 0\n+\t\t\t    && av_set_could_be_blocked_by_bookkeeping_p (orig_ops, static_params))\n+\t\t       || res == -1);\n \n   /* Merge data, clean up, etc.  */\n   if (res != -1 && code_motion_path_driver_info->after_merge_succs)\n@@ -6695,9 +6682,7 @@ move_op (insn_t insn, av_set_t orig_ops, expr_t expr_vliw,\n   sparams.dest = dest;\n   sparams.c_expr = c_expr;\n   sparams.uid = INSN_UID (EXPR_INSN_RTX (expr_vliw));\n-#ifdef ENABLE_CHECKING\n   sparams.failed_insn = NULL;\n-#endif\n   sparams.was_renamed = false;\n   lparams.e1 = NULL;\n "}, {"sha": "fa7ad3b436c3dff1582be90e7927c55add28047f", "filename": "gcc/ssa-iterators.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -344,9 +344,7 @@ first_readonly_imm_use (imm_use_iterator *imm, tree var)\n {\n   imm->end_p = &(SSA_NAME_IMM_USE_NODE (var));\n   imm->imm_use = imm->end_p->next;\n-#ifdef ENABLE_CHECKING\n   imm->iter_node.next = imm->imm_use->next;\n-#endif\n   if (end_readonly_imm_use_p (imm))\n     return NULL_USE_OPERAND_P;\n   return imm->imm_use;\n@@ -358,14 +356,15 @@ next_readonly_imm_use (imm_use_iterator *imm)\n {\n   use_operand_p old = imm->imm_use;\n \n-#ifdef ENABLE_CHECKING\n   /* If this assertion fails, it indicates the 'next' pointer has changed\n      since the last bump.  This indicates that the list is being modified\n      via stmt changes, or SET_USE, or somesuch thing, and you need to be\n      using the SAFE version of the iterator.  */\n-  gcc_assert (imm->iter_node.next == old->next);\n-  imm->iter_node.next = old->next->next;\n-#endif\n+  if (flag_checking)\n+    {\n+      gcc_assert (imm->iter_node.next == old->next);\n+      imm->iter_node.next = old->next->next;\n+    }\n \n   imm->imm_use = old->next;\n   if (end_readonly_imm_use_p (imm))"}, {"sha": "ed1a399e4ff3a7db0ccfba0782ecc50c3aaa3a79", "filename": "gcc/store-motion.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -644,9 +644,6 @@ compute_store_table (void)\n {\n   int ret;\n   basic_block bb;\n-#ifdef ENABLE_CHECKING\n-  unsigned regno;\n-#endif\n   rtx_insn *insn;\n   rtx_insn *tmp;\n   df_ref def;\n@@ -692,11 +689,12 @@ compute_store_table (void)\n \t      last_set_in[DF_REF_REGNO (def)] = 0;\n \t}\n \n-#ifdef ENABLE_CHECKING\n-      /* last_set_in should now be all-zero.  */\n-      for (regno = 0; regno < max_gcse_regno; regno++)\n-\tgcc_assert (!last_set_in[regno]);\n-#endif\n+      if (flag_checking)\n+\t{\n+\t  /* last_set_in should now be all-zero.  */\n+\t  for (unsigned regno = 0; regno < max_gcse_regno; regno++)\n+\t    gcc_assert (!last_set_in[regno]);\n+\t}\n \n       /* Clear temporary marks.  */\n       for (ptr = first_st_expr (); ptr != NULL; ptr = next_st_expr (ptr))"}, {"sha": "4a1a510bdf8b0ef9917f9165f26c38d8a9db7608", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -39,14 +39,12 @@ class GTY((user)) function_summary <T *>\n   function_summary (symbol_table *symtab, bool ggc = false): m_ggc (ggc),\n     m_map (13, ggc), m_insertion_enabled (true), m_symtab (symtab)\n   {\n-#ifdef ENABLE_CHECKING\n-    cgraph_node *node;\n-\n-    FOR_EACH_FUNCTION (node)\n-    {\n-      gcc_checking_assert (node->summary_uid > 0);\n-    }\n-#endif\n+    if (flag_checking)\n+      {\n+\tcgraph_node *node;\n+\tFOR_EACH_FUNCTION (node)\n+\t  gcc_assert (node->summary_uid > 0);\n+      }\n \n     m_symtab_insertion_hook =\n       symtab->add_cgraph_insertion_hook"}, {"sha": "ffc4d6aef540e0b9994b06e5a03bfeabed95e240", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -52,21 +52,21 @@\n #include \"tm.h\"\n #include \"hard-reg-set.h\"\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n \n struct cumulative_args_t { void *magic; void *p; };\n \n-#else /* !ENABLE_CHECKING */\n+#else /* !CHECKING_P */\n \n /* When using a GCC build compiler, we could use\n    __attribute__((transparent_union)) to get cumulative_args_t function\n    arguments passed like scalars where the ABI would mandate a less\n    efficient way of argument passing otherwise.  However, that would come\n-   at the cost of less type-safe !ENABLE_CHECKING compilation.  */\n+   at the cost of less type-safe !CHECKING_P compilation.  */\n \n union cumulative_args_t { void *p; };\n \n-#endif /* !ENABLE_CHECKING */\n+#endif /* !CHECKING_P */\n \n /* Types used by the record_gcc_switches() target function.  */\n enum print_switch_type\n@@ -200,9 +200,9 @@ extern struct gcc_target targetm;\n static inline CUMULATIVE_ARGS *\n get_cumulative_args (cumulative_args_t arg)\n {\n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n   gcc_assert (arg.magic == CUMULATIVE_ARGS_MAGIC);\n-#endif /* ENABLE_CHECKING */\n+#endif /* CHECKING_P */\n   return (CUMULATIVE_ARGS *) arg.p;\n }\n \n@@ -211,9 +211,9 @@ pack_cumulative_args (CUMULATIVE_ARGS *arg)\n {\n   cumulative_args_t ret;\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n   ret.magic = CUMULATIVE_ARGS_MAGIC;\n-#endif /* ENABLE_CHECKING */\n+#endif /* CHECKING_P */\n   ret.p = (void *) arg;\n   return ret;\n }"}, {"sha": "35438506d9abefedd7459511d16fd8ec48ce9ba8", "filename": "gcc/timevar.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"timevar.h\"\n+#include \"options.h\"\n \n #ifndef HAVE_CLOCK_T\n typedef int clock_t;\n@@ -727,10 +728,13 @@ timer::print (FILE *fp)\n #endif\n   fprintf (fp, \"%8u kB\\n\", (unsigned) (total->ggc_mem >> 10));\n \n-#ifdef ENABLE_CHECKING\n-  fprintf (fp, \"Extra diagnostic checks enabled; compiler may run slowly.\\n\");\n-  fprintf (fp, \"Configure with --enable-checking=release to disable checks.\\n\");\n-#endif\n+  if (flag_checking)\n+    {\n+      fprintf (fp, \"Extra diagnostic checks enabled; \"\n+\t\t   \"compiler may run slowly.\\n\");\n+      fprintf (fp, \"Configure with --enable-checking=release \"\n+\t\t   \"to disable checks.\\n\");\n+    }\n #ifndef ENABLE_ASSERT_CHECKING\n   fprintf (fp, \"Internal checks disabled; compiler is not suited for release.\\n\");\n   fprintf (fp, \"Configure with --enable-checking=release to enable checks.\\n\");"}, {"sha": "d0b54eff6ef9a3c2a3104b261df98daeb965ebff", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -5341,9 +5341,7 @@ ipa_tm_execute (void)\n   enum availability a;\n   unsigned int i;\n \n-#ifdef ENABLE_CHECKING\n-  cgraph_node::verify_cgraph_nodes ();\n-#endif\n+  cgraph_node::checking_verify_cgraph_nodes ();\n \n   bitmap_obstack_initialize (&tm_obstack);\n   initialize_original_copy_tables ();\n@@ -5589,9 +5587,7 @@ ipa_tm_execute (void)\n   FOR_EACH_FUNCTION (node)\n     node->aux = NULL;\n \n-#ifdef ENABLE_CHECKING\n-  cgraph_node::verify_cgraph_nodes ();\n-#endif\n+  cgraph_node::checking_verify_cgraph_nodes ();\n \n   return 0;\n }"}, {"sha": "e0d66aaa77b2c95900fdf0ab2e3d125a885fdf23", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -6469,14 +6469,12 @@ move_stmt_op (tree *tp, int *walk_subtrees, void *data)\n \t  || (p->orig_block == NULL_TREE\n \t      && block != NULL_TREE))\n \tTREE_SET_BLOCK (t, p->new_block);\n-#ifdef ENABLE_CHECKING\n-      else if (block != NULL_TREE)\n+      else if (flag_checking && block != NULL_TREE)\n \t{\n \t  while (block && TREE_CODE (block) == BLOCK && block != p->orig_block)\n \t    block = BLOCK_SUPERCONTEXT (block);\n \t  gcc_assert (block == p->orig_block);\n \t}\n-#endif\n     }\n   else if (DECL_P (t) || TREE_CODE (t) == SSA_NAME)\n     {\n@@ -7061,9 +7059,9 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   bbs.create (0);\n   bbs.safe_push (entry_bb);\n   gather_blocks_in_sese_region (entry_bb, exit_bb, &bbs);\n-#ifdef ENABLE_CHECKING\n-  verify_sese (entry_bb, exit_bb, &bbs);\n-#endif\n+\n+  if (flag_checking)\n+    verify_sese (entry_bb, exit_bb, &bbs);\n \n   /* The blocks that used to be dominated by something in BBS will now be\n      dominated by the new block.  */\n@@ -7905,13 +7903,11 @@ gimple_flow_call_edges_add (sbitmap blocks)\n \t\t     no edge to the exit block in CFG already.\n \t\t     Calling make_edge in such case would cause us to\n \t\t     mark that edge as fake and remove it later.  */\n-#ifdef ENABLE_CHECKING\n-\t\t  if (stmt == last_stmt)\n+\t\t  if (flag_checking && stmt == last_stmt)\n \t\t    {\n \t\t      e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t\t      gcc_assert (e == NULL);\n \t\t    }\n-#endif\n \n \t\t  /* Note that the following may create a new basic block\n \t\t     and renumber the existing basic blocks.  */"}, {"sha": "aba8848a2e4734358eab45835625be179d2b3b0d", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -729,9 +729,7 @@ cleanup_tree_cfg_noloop (void)\n     }\n   else\n     {\n-#ifdef ENABLE_CHECKING\n-      verify_dominators (CDI_DOMINATORS);\n-#endif\n+      checking_verify_dominators (CDI_DOMINATORS);\n       changed = false;\n     }\n \n@@ -740,9 +738,7 @@ cleanup_tree_cfg_noloop (void)\n   gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n   compact_blocks ();\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n+  checking_verify_flow_info ();\n \n   timevar_pop (TV_TREE_CLEANUP_CFG);\n \n@@ -777,9 +773,7 @@ repair_loop_structures (void)\n \n   BITMAP_FREE (changed_bbs);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n+  checking_verify_loop_structure ();\n   scev_reset ();\n \n   timevar_pop (TV_REPAIR_LOOPS);"}, {"sha": "f6c2d06f39be10f9d5f23e309407f344992eb46e", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -703,7 +703,7 @@ maybe_record_in_goto_queue (struct leh_state *state, gimple *stmt)\n }\n \n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n /* We do not process GIMPLE_SWITCHes for now.  As long as the original source\n    was in fact structured, and we've not yet done jump threading, then none\n    of the labels will leave outer GIMPLE_TRY_FINALLY nodes. Verify this.  */\n@@ -3921,9 +3921,8 @@ remove_unreachable_handlers (void)\n   sbitmap_free (r_reachable);\n   sbitmap_free (lp_reachable);\n \n-#ifdef ENABLE_CHECKING\n-  verify_eh_tree (cfun);\n-#endif\n+  if (flag_checking)\n+    verify_eh_tree (cfun);\n }\n \n /* Remove unreachable handlers if any landing pads have been removed after"}, {"sha": "ae79f0eefa34aba7e040453912cf00211c8cc472", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2787,13 +2787,12 @@ pass_if_conversion::execute (function *fun)\n \t    && !loop->dont_vectorize))\n       todo |= tree_if_conversion (loop);\n \n-#ifdef ENABLE_CHECKING\n-  {\n-    basic_block bb;\n-    FOR_EACH_BB_FN (bb, fun)\n-      gcc_assert (!bb->aux);\n-  }\n-#endif\n+  if (flag_checking)\n+    {\n+      basic_block bb;\n+      FOR_EACH_BB_FN (bb, fun)\n+\tgcc_assert (!bb->aux);\n+    }\n \n   return todo;\n }"}, {"sha": "00c0c84b655e274fb782ea7599d1b596cef286bc", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -4481,10 +4481,8 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n   fn = cg_edge->callee->decl;\n   cg_edge->callee->get_untransformed_body ();\n \n-#ifdef ENABLE_CHECKING\n-  if (cg_edge->callee->decl != id->dst_node->decl)\n+  if (flag_checking && cg_edge->callee->decl != id->dst_node->decl)\n     cg_edge->callee->verify ();\n-#endif\n \n   /* We will be inlining this callee.  */\n   id->eh_lp_nr = lookup_stmt_eh_lp (stmt);\n@@ -4973,7 +4971,7 @@ optimize_inline_calls (tree fn)\n \n   pop_gimplify_context (NULL);\n \n-#ifdef ENABLE_CHECKING\n+  if (flag_checking)\n     {\n       struct cgraph_edge *e;\n \n@@ -4983,7 +4981,6 @@ optimize_inline_calls (tree fn)\n       for (e = id.dst_node->callees; e; e = e->next_callee)\n \tgcc_assert (e->inline_failed);\n     }\n-#endif\n \n   /* Fold queued statements.  */\n   fold_marked_statements (last, id.statements_to_fold);\n@@ -4999,9 +4996,8 @@ optimize_inline_calls (tree fn)\n   number_blocks (fn);\n \n   delete_unreachable_blocks_update_callgraph (&id);\n-#ifdef ENABLE_CHECKING\n-  id.dst_node->verify ();\n-#endif\n+  if (flag_checking)\n+    id.dst_node->verify ();\n \n   /* It would be nice to check SSA/CFG/statement consistency here, but it is\n      not possible yet - the IPA passes might make various functions to not"}, {"sha": "732a5719033a2ca0e23a8f7ff0906f284797afd8", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -3169,44 +3169,45 @@ update_ssa (unsigned update_flags)\n   if (!need_ssa_update_p (cfun))\n     return;\n \n-#ifdef ENABLE_CHECKING\n-  timevar_push (TV_TREE_STMT_VERIFY);\n+  if (flag_checking)\n+    {\n+      timevar_push (TV_TREE_STMT_VERIFY);\n \n-  bool err = false;\n+      bool err = false;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      FOR_EACH_BB_FN (bb, cfun)\n \t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\n-\t  ssa_op_iter i;\n-\t  use_operand_p use_p;\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, i, SSA_OP_ALL_USES)\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t    {\n-\t      tree use = USE_FROM_PTR (use_p);\n-\t      if (TREE_CODE (use) != SSA_NAME)\n-\t\tcontinue;\n+\t      gimple *stmt = gsi_stmt (gsi);\n \n-\t      if (SSA_NAME_IN_FREE_LIST (use))\n+\t      ssa_op_iter i;\n+\t      use_operand_p use_p;\n+\t      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, i, SSA_OP_ALL_USES)\n \t\t{\n-\t\t  error (\"statement uses released SSA name:\");\n-\t\t  debug_gimple_stmt (stmt);\n-\t\t  fprintf (stderr, \"The use of \");\n-\t\t  print_generic_expr (stderr, use, 0);\n-\t\t  fprintf (stderr,\" should have been replaced\\n\");\n-\t\t  err = true;\n+\t\t  tree use = USE_FROM_PTR (use_p);\n+\t\t  if (TREE_CODE (use) != SSA_NAME)\n+\t\t    continue;\n+\n+\t\t  if (SSA_NAME_IN_FREE_LIST (use))\n+\t\t    {\n+\t\t      error (\"statement uses released SSA name:\");\n+\t\t      debug_gimple_stmt (stmt);\n+\t\t      fprintf (stderr, \"The use of \");\n+\t\t      print_generic_expr (stderr, use, 0);\n+\t\t      fprintf (stderr,\" should have been replaced\\n\");\n+\t\t      err = true;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n-    }\n \n-  if (err)\n-    internal_error (\"cannot update SSA form\");\n+      if (err)\n+\tinternal_error (\"cannot update SSA form\");\n \n-  timevar_pop (TV_TREE_STMT_VERIFY);\n-#endif\n+      timevar_pop (TV_TREE_STMT_VERIFY);\n+    }\n \n   timevar_push (TV_TREE_SSA_INCREMENTAL);\n \n@@ -3271,29 +3272,28 @@ update_ssa (unsigned update_flags)\n \t placement heuristics.  */\n       prepare_block_for_update (start_bb, insert_phi_p);\n \n-#ifdef ENABLE_CHECKING\n-      for (i = 1; i < num_ssa_names; ++i)\n-\t{\n-\t  tree name = ssa_name (i);\n-\t  if (!name\n-\t      || virtual_operand_p (name))\n-\t    continue;\n-\n-\t  /* For all but virtual operands, which do not have SSA names\n-\t     with overlapping life ranges, ensure that symbols marked\n-\t     for renaming do not have existing SSA names associated with\n-\t     them as we do not re-write them out-of-SSA before going\n-\t     into SSA for the remaining symbol uses.  */\n-\t  if (marked_for_renaming (SSA_NAME_VAR (name)))\n-\t    {\n-\t      fprintf (stderr, \"Existing SSA name for symbol marked for \"\n-\t\t       \"renaming: \");\n-\t      print_generic_expr (stderr, name, TDF_SLIM);\n-\t      fprintf (stderr, \"\\n\");\n-\t      internal_error (\"SSA corruption\");\n-\t    }\n-\t}\n-#endif\n+      if (flag_checking)\n+\tfor (i = 1; i < num_ssa_names; ++i)\n+\t  {\n+\t    tree name = ssa_name (i);\n+\t    if (!name\n+\t\t|| virtual_operand_p (name))\n+\t      continue;\n+\n+\t    /* For all but virtual operands, which do not have SSA names\n+\t       with overlapping life ranges, ensure that symbols marked\n+\t       for renaming do not have existing SSA names associated with\n+\t       them as we do not re-write them out-of-SSA before going\n+\t       into SSA for the remaining symbol uses.  */\n+\t    if (marked_for_renaming (SSA_NAME_VAR (name)))\n+\t      {\n+\t\tfprintf (stderr, \"Existing SSA name for symbol marked for \"\n+\t\t\t \"renaming: \");\n+\t\tprint_generic_expr (stderr, name, TDF_SLIM);\n+\t\tfprintf (stderr, \"\\n\");\n+\t\tinternal_error (\"SSA corruption\");\n+\t      }\n+\t  }\n     }\n   else\n     {"}, {"sha": "18025c82c11a38dff31a24e45129abd6138db17d", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1821,9 +1821,7 @@ pass_loop_distribution::execute (function *fun)\n       rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n+  checking_verify_loop_structure ();\n \n   return 0;\n }"}, {"sha": "1c4c63c2f30a17f053219b136ecec82d7c840fa0", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -841,24 +841,23 @@ eliminate_useless_phis (void)\n \t  result = gimple_phi_result (phi);\n \t  if (virtual_operand_p (result))\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      size_t i;\n \t      /* There should be no arguments which are not virtual, or the\n \t         results will be incorrect.  */\n-\t      for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t        {\n-\t\t  tree arg = PHI_ARG_DEF (phi, i);\n-\t\t  if (TREE_CODE (arg) == SSA_NAME\n-\t\t      && !virtual_operand_p (arg))\n-\t\t    {\n-\t\t      fprintf (stderr, \"Argument of PHI is not virtual (\");\n-\t\t      print_generic_expr (stderr, arg, TDF_SLIM);\n-\t\t      fprintf (stderr, \"), but the result is :\");\n-\t\t      print_gimple_stmt (stderr, phi, 0, TDF_SLIM);\n-\t\t      internal_error (\"SSA corruption\");\n-\t\t    }\n-\t\t}\n-#endif\n+\t      if (flag_checking)\n+\t\tfor (size_t i = 0; i < gimple_phi_num_args (phi); i++)\n+\t\t  {\n+\t\t    tree arg = PHI_ARG_DEF (phi, i);\n+\t\t    if (TREE_CODE (arg) == SSA_NAME\n+\t\t\t&& !virtual_operand_p (arg))\n+\t\t      {\n+\t\t\tfprintf (stderr, \"Argument of PHI is not virtual (\");\n+\t\t\tprint_generic_expr (stderr, arg, TDF_SLIM);\n+\t\t\tfprintf (stderr, \"), but the result is :\");\n+\t\t\tprint_gimple_stmt (stderr, phi, 0, TDF_SLIM);\n+\t\t\tinternal_error (\"SSA corruption\");\n+\t\t      }\n+\t\t  }\n+\n \t      remove_phi_node (&gsi, true);\n \t    }\n           else\n@@ -884,9 +883,11 @@ eliminate_useless_phis (void)\n    variable.  */\n \n static void\n-rewrite_trees (var_map map ATTRIBUTE_UNUSED)\n+rewrite_trees (var_map map)\n {\n-#ifdef ENABLE_CHECKING\n+  if (!flag_checking)\n+    return;\n+\n   basic_block bb;\n   /* Search for PHIs where the destination has no partition, but one\n      or more arguments has a partition.  This should not happen and can\n@@ -918,7 +919,6 @@ rewrite_trees (var_map map ATTRIBUTE_UNUSED)\n \t    }\n \t}\n     }\n-#endif\n }\n \n /* Given the out-of-ssa info object SA (with prepared partitions)"}, {"sha": "300ec6b612de34bca538fc00c693f0b7e6351d10", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2784,9 +2784,7 @@ pass_parallelize_loops::execute (function *fun)\n     {\n       fun->curr_properties &= ~(PROP_gimple_eomp);\n \n-#ifdef ENABLE_CHECKING\n-      verify_loop_structure ();\n-#endif\n+      checking_verify_loop_structure ();\n \n       return TODO_update_ssa;\n     }"}, {"sha": "5f6e1b0c3e9dab35ec33207a011d9853e74d96d0", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -896,13 +896,9 @@ suitable_component_p (struct loop *loop, struct component *comp)\n       if (!determine_offset (first->ref, a->ref, &a->offset))\n \treturn false;\n \n-#ifdef ENABLE_CHECKING\n-      {\n-\tenum ref_step_type a_step;\n-\tok = suitable_reference_p (a->ref, &a_step);\n-\tgcc_assert (ok && a_step == comp->comp_step);\n-      }\n-#endif\n+      enum ref_step_type a_step;\n+      gcc_checking_assert (suitable_reference_p (a->ref, &a_step)\n+\t\t\t   && a_step == comp->comp_step);\n     }\n \n   /* If there is a write inside the component, we must know whether the"}, {"sha": "54bc6445a3935ca203427a802c3f5dbd688222cd", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -461,9 +461,8 @@ gimple_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED,\n \t\t\t       unsigned base ATTRIBUTE_UNUSED)\n {\n   /* FIXME implement this.  */\n-#ifdef ENABLE_CHECKING\n-  internal_error (\"unimplemented functionality\");\n-#endif\n+  if (flag_checking)\n+    internal_error (\"unimplemented functionality\");\n   gcc_unreachable ();\n }\n "}, {"sha": "a5bd8314a0a73f3522060341a49eafc239641323", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1442,12 +1442,7 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n \t\t\t\t      ao_ref_alias_set (ref2), -1,\n \t\t\t\t      tbaa_p);\n \n-  /* We really do not want to end up here, but returning true is safe.  */\n-#ifdef ENABLE_CHECKING\n   gcc_unreachable ();\n-#else\n-  return true;\n-#endif\n }\n \n static bool"}, {"sha": "a61026d9a6343be076b9686e32b7add54e291872", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -52,9 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"cfgloop.h\"\n \n-#ifdef ENABLE_CHECKING\n-static void  verify_live_on_entry (tree_live_info_p);\n-#endif\n+static void verify_live_on_entry (tree_live_info_p);\n \n \n /* VARMAP maintains a mapping from SSA version number to real variables.\n@@ -1153,9 +1151,8 @@ calculate_live_ranges (var_map map, bool want_livein)\n \n   live_worklist (live);\n \n-#ifdef ENABLE_CHECKING\n-  verify_live_on_entry (live);\n-#endif\n+  if (flag_checking)\n+    verify_live_on_entry (live);\n \n   calculate_live_on_exit (live);\n \n@@ -1292,7 +1289,6 @@ debug (tree_live_info_d *ptr)\n }\n \n \n-#ifdef ENABLE_CHECKING\n /* Verify that SSA_VAR is a non-virtual SSA_NAME.  */\n \n void\n@@ -1422,4 +1418,3 @@ verify_live_on_entry (tree_live_info_p live)\n     }\n   gcc_assert (num <= 0);\n }\n-#endif"}, {"sha": "0cb3a1a4ed0a7b96f35f90b64756a490cf41b555", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -80,9 +80,7 @@ extern void remove_unused_locals (void);\n extern void dump_var_map (FILE *, var_map);\n extern void debug (_var_map &ref);\n extern void debug (_var_map *ptr);\n-#ifdef ENABLE_CHECKING\n extern void register_ssa_partition_check (tree ssa_var);\n-#endif\n \n \n /* Return number of partitions in MAP.  */\n@@ -181,12 +179,10 @@ num_basevars (var_map map)\n    partitions may be filtered out by a view later.  */\n \n static inline void\n-register_ssa_partition (var_map map ATTRIBUTE_UNUSED,\n-\t\t\ttree ssa_var ATTRIBUTE_UNUSED)\n+register_ssa_partition (var_map map ATTRIBUTE_UNUSED, tree ssa_var)\n {\n-#if defined ENABLE_CHECKING\n-  register_ssa_partition_check (ssa_var);\n-#endif\n+  if (flag_checking)\n+    register_ssa_partition_check (ssa_var);\n }\n \n "}, {"sha": "25f297c35de65b9c551fa2345b6f19eccc315a20", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1376,10 +1376,8 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  /* Clean up the information about numbers of iterations, since\n \t     complete unrolling might have invalidated it.  */\n \t  scev_reset ();\n-#ifdef ENABLE_CHECKING\n-\t  if (loops_state_satisfies_p (LOOP_CLOSED_SSA))\n+\t  if (flag_checking && loops_state_satisfies_p (LOOP_CLOSED_SSA))\n \t    verify_loop_closed_ssa (true);\n-#endif\n \t}\n       if (loop_closed_ssa_invalidated)\n         BITMAP_FREE (loop_closed_ssa_invalidated);"}, {"sha": "ba2340f86dc84e896f9f9f7d5edfe8c01ab25d9f", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -278,22 +278,22 @@ add_exit_phi (basic_block exit, tree var)\n   edge e;\n   edge_iterator ei;\n \n-#ifdef ENABLE_CHECKING\n   /* Check that at least one of the edges entering the EXIT block exits\n      the loop, or a superloop of that loop, that VAR is defined in.  */\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n-  basic_block def_bb = gimple_bb (def_stmt);\n-  FOR_EACH_EDGE (e, ei, exit->preds)\n+  if (flag_checking)\n     {\n-      struct loop *aloop = find_common_loop (def_bb->loop_father,\n-\t\t\t\t\t     e->src->loop_father);\n-      if (!flow_bb_inside_loop_p (aloop, e->dest))\n-\tbreak;\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+      basic_block def_bb = gimple_bb (def_stmt);\n+      FOR_EACH_EDGE (e, ei, exit->preds)\n+\t{\n+\t  struct loop *aloop = find_common_loop (def_bb->loop_father,\n+\t\t\t\t\t\t e->src->loop_father);\n+\t  if (!flow_bb_inside_loop_p (aloop, e->dest))\n+\t    break;\n+\t}\n+      gcc_assert (e);\n     }\n \n-  gcc_checking_assert (e);\n-#endif\n-\n   phi = create_phi_node (NULL_TREE, exit);\n   create_new_def_for (var, phi, gimple_phi_result_ptr (phi));\n   FOR_EACH_EDGE (e, ei, exit->preds)\n@@ -1368,11 +1368,9 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   gimple_cond_set_rhs (exit_if, exit_bound);\n   update_stmt (exit_if);\n \n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-  verify_loop_structure ();\n-  verify_loop_closed_ssa (true);\n-#endif\n+  checking_verify_flow_info ();\n+  checking_verify_loop_structure ();\n+  checking_verify_loop_closed_ssa (true);\n }\n \n /* Wrapper over tree_transform_and_unroll_loop for case we do not"}, {"sha": "96b02a6f2a7fc7f5f1af09cf2b4e4729f25f142d", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -27,6 +27,14 @@ extern void create_iv (tree, tree, tree, struct loop *, gimple_stmt_iterator *,\n extern void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n extern void rewrite_virtuals_into_loop_closed_ssa (struct loop *);\n extern void verify_loop_closed_ssa (bool);\n+\n+static inline void\n+checking_verify_loop_closed_ssa (bool verify_ssa_p)\n+{\n+  if (flag_checking)\n+    verify_loop_closed_ssa (verify_ssa_p);\n+}\n+\n extern basic_block split_loop_exit_edge (edge);\n extern basic_block ip_end_pos (struct loop *);\n extern basic_block ip_normal_pos (struct loop *);"}, {"sha": "cb6c749e283d47fc72464583da2ee989eda10289", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -541,10 +541,9 @@ pass_cse_reciprocals::execute (function *fun)\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n-#ifdef ENABLE_CHECKING\n-  FOR_EACH_BB_FN (bb, fun)\n-    gcc_assert (!bb->aux);\n-#endif\n+  if (flag_checking)\n+    FOR_EACH_BB_FN (bb, fun)\n+      gcc_assert (!bb->aux);\n \n   for (arg = DECL_ARGUMENTS (fun->decl); arg; arg = DECL_CHAIN (arg))\n     if (FLOAT_TYPE_P (TREE_TYPE (arg))"}, {"sha": "92d1ab27b0f507bff14cd2c80b76837ce1c15314", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -881,12 +881,13 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n     }\n \n   /* If we get here, something has gone wrong.  */\n-#ifdef ENABLE_CHECKING\n-  fprintf (stderr, \"unhandled expression in get_expr_operands():\\n\");\n-  debug_tree (expr);\n-  fputs (\"\\n\", stderr);\n-#endif\n-  gcc_unreachable ();\n+  if (flag_checking)\n+    {\n+      fprintf (stderr, \"unhandled expression in get_expr_operands():\\n\");\n+      debug_tree (expr);\n+      fputs (\"\\n\", stderr);\n+      gcc_unreachable ();\n+    }\n }\n \n "}, {"sha": "363f439839bdf52e91dbefeb86a369efdb87d001", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1501,14 +1501,14 @@ static void\n replace_exp_1 (use_operand_p op_p, tree val,\n     \t       bool for_propagation ATTRIBUTE_UNUSED)\n {\n-#if defined ENABLE_CHECKING\n-  tree op = USE_FROM_PTR (op_p);\n-\n-  gcc_assert (!(for_propagation\n-\t\t&& TREE_CODE (op) == SSA_NAME\n-\t\t&& TREE_CODE (val) == SSA_NAME\n-\t\t&& !may_propagate_copy (op, val)));\n-#endif\n+  if (flag_checking)\n+    {\n+      tree op = USE_FROM_PTR (op_p);\n+      gcc_assert (!(for_propagation\n+\t\t  && TREE_CODE (op) == SSA_NAME\n+\t\t  && TREE_CODE (val) == SSA_NAME\n+\t\t  && !may_propagate_copy (op, val)));\n+    }\n \n   if (TREE_CODE (val) == SSA_NAME)\n     SET_USE (op_p, val);"}, {"sha": "52b0813ba58d14d9372286e9b526173d9fc9522d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2544,10 +2544,11 @@ rewrite_constraints (constraint_graph_t graph,\n   int i;\n   constraint_t c;\n \n-#ifdef ENABLE_CHECKING\n-  for (unsigned int j = 0; j < graph->size; j++)\n-    gcc_assert (find (j) == j);\n-#endif\n+  if (flag_checking)\n+    {\n+      for (unsigned int j = 0; j < graph->size; j++)\n+\tgcc_assert (find (j) == j);\n+    }\n \n   FOR_EACH_VEC_ELT (constraints, i, c)\n     {"}, {"sha": "b2d19ed8dcf596dd18d81b5d6cdbfb9455c9a7a9", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -182,9 +182,7 @@ struct temp_expr_table\n /* A place for the many, many bitmaps we create.  */\n static bitmap_obstack ter_bitmap_obstack;\n \n-#ifdef ENABLE_CHECKING\n extern void debug_ter (FILE *, temp_expr_table *);\n-#endif\n \n \n /* Create a new TER table for MAP.  */\n@@ -232,16 +230,16 @@ free_temp_expr_table (temp_expr_table *t)\n {\n   bitmap ret = NULL;\n \n-#ifdef ENABLE_CHECKING\n-  unsigned x;\n-  for (x = 0; x <= num_var_partitions (t->map); x++)\n-    gcc_assert (!t->kill_list[x]);\n-  for (x = 0; x < num_ssa_names; x++)\n+  if (flag_checking)\n     {\n-      gcc_assert (t->expr_decl_uids[x] == NULL);\n-      gcc_assert (t->partition_dependencies[x] == NULL);\n+      for (unsigned x = 0; x <= num_var_partitions (t->map); x++)\n+\tgcc_assert (!t->kill_list[x]);\n+      for (unsigned x = 0; x < num_ssa_names; x++)\n+\t{\n+\t  gcc_assert (t->expr_decl_uids[x] == NULL);\n+\t  gcc_assert (t->partition_dependencies[x] == NULL);\n+\t}\n     }\n-#endif\n \n   BITMAP_FREE (t->partition_in_use);\n   BITMAP_FREE (t->new_replaceable_dependencies);\n@@ -748,7 +746,6 @@ dump_replaceable_exprs (FILE *f, bitmap expr)\n }\n \n \n-#ifdef ENABLE_CHECKING\n /* Dump the status of the various tables in the expression table.  This is used\n    exclusively to debug TER.  F is the place to send debug info and T is the\n    table being debugged.  */\n@@ -796,4 +793,3 @@ debug_ter (FILE *f, temp_expr_table *t)\n \n   fprintf (f, \"\\n----------\\n\");\n }\n-#endif"}, {"sha": "90a9172334e0487e95a2312bf07e512745fa5808", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -2510,9 +2510,8 @@ duplicate_thread_path (edge entry, edge exit,\n       scale_bbs_frequencies_int (region_copy, n_region, entry_freq, total_freq);\n     }\n \n-#ifdef ENABLE_CHECKING\n-  verify_jump_thread (region_copy, n_region);\n-#endif\n+  if (flag_checking)\n+    verify_jump_thread (region_copy, n_region);\n \n   /* Remove the last branch in the jump thread path.  */\n   remove_ctrl_stmt_and_useless_edges (region_copy[n_region - 1], exit->dest);"}, {"sha": "5a409e5f5d5beef82360f03ecd5d45e226bfc929", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -77,5 +77,13 @@ redirect_edge_var_map_location (edge_var_map *v)\n   return v->locus;\n }\n \n+/* Verify SSA invariants, if internal consistency checks are enabled.  */\n+\n+static inline void\n+checking_verify_ssa (bool check_modified_stmt, bool check_ssa_operands)\n+{\n+  if (flag_checking)\n+    verify_ssa (check_modified_stmt, check_ssa_operands);\n+}\n \n #endif /* GCC_TREE_SSA_H */"}, {"sha": "90d75b68714806f367e5618a470ecfcaa41e394b", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -336,9 +336,8 @@ release_ssa_name_fn (struct function *fn, tree var)\n       if (MAY_HAVE_DEBUG_STMTS)\n \tinsert_debug_temp_for_var_def (NULL, var);\n \n-#ifdef ENABLE_CHECKING\n-      verify_imm_links (stderr, var);\n-#endif\n+      if (flag_checking)\n+\tverify_imm_links (stderr, var);\n       while (imm->next != imm)\n \tdelink_imm_use (imm->next);\n "}, {"sha": "a38443dae7c54d5d7959f414f37ba14a1115285b", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -1107,13 +1107,14 @@ expand_ifn_va_arg (function *fun)\n   if ((fun->curr_properties & PROP_gimple_lva) == 0)\n     expand_ifn_va_arg_1 (fun);\n \n-#if ENABLE_CHECKING\n-  basic_block bb;\n-  gimple_stmt_iterator i;\n-  FOR_EACH_BB_FN (bb, fun)\n-    for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n-      gcc_assert (!gimple_call_ifn_va_arg_p (gsi_stmt (i)));\n-#endif\n+  if (flag_checking)\n+    {\n+      basic_block bb;\n+      gimple_stmt_iterator i;\n+      FOR_EACH_BB_FN (bb, fun)\n+\tfor (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+\t  gcc_assert (!gimple_call_ifn_va_arg_p (gsi_stmt (i)));\n+    }\n }\n \n namespace {"}, {"sha": "d9d01ecf581bef7ecdcb42fccb1243837c17c34c", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -919,9 +919,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n   free (new_bbs);\n   free (bbs);\n \n-#ifdef ENABLE_CHECKING\n-  verify_dominators (CDI_DOMINATORS);\n-#endif\n+  checking_verify_dominators (CDI_DOMINATORS);\n \n   return new_loop;\n }\n@@ -1003,11 +1001,13 @@ slpeel_can_duplicate_loop_p (const struct loop *loop, const_edge e)\n   return true;\n }\n \n-#ifdef ENABLE_CHECKING\n static void\n-slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n-                                 struct loop *second_loop)\n+slpeel_checking_verify_cfg_after_peeling (struct loop *first_loop,\n+\t\t\t\t\t  struct loop *second_loop)\n {\n+  if (!flag_checking)\n+    return;\n+\n   basic_block loop1_exit_bb = single_exit (first_loop)->dest;\n   basic_block loop2_entry_bb = loop_preheader_edge (second_loop)->src;\n   basic_block loop1_entry_bb = loop_preheader_edge (first_loop)->src;\n@@ -1035,7 +1035,6 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n      second_loop.  */\n   /* TODO */\n }\n-#endif\n \n /* If the run time cost model check determines that vectorization is\n    not profitable and hence scalar loop should be generated then set\n@@ -1773,9 +1772,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo,\n \t\t\t\t     0, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n-#ifdef ENABLE_CHECKING\n-  slpeel_verify_cfg_after_peeling (loop, new_loop);\n-#endif\n+  slpeel_checking_verify_cfg_after_peeling (loop, new_loop);\n \n   /* A guard that controls whether the new_loop is to be executed or skipped\n      is placed in LOOP->exit.  LOOP->exit therefore has two successors - one\n@@ -2032,9 +2029,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n \t\t\t\t   bound, 0);\n \n   gcc_assert (new_loop);\n-#ifdef ENABLE_CHECKING\n-  slpeel_verify_cfg_after_peeling (new_loop, loop);\n-#endif\n+  slpeel_checking_verify_cfg_after_peeling (new_loop, loop);\n   /* For vectorization factor N, we need to copy at most N-1 values \n      for alignment and this means N-2 loopback edge executions.  */\n   max_iter = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 2;"}, {"sha": "3138ae7a08fdfb76efd12f49b6ed98ff39507b9d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -242,9 +242,7 @@ static inline bool\n supports_overflow_infinity (const_tree type)\n {\n   tree min = vrp_val_min (type), max = vrp_val_max (type);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (needs_overflow_infinity (type));\n-#endif\n+  gcc_checking_assert (needs_overflow_infinity (type));\n   return (min != NULL_TREE\n \t  && CONSTANT_CLASS_P (min)\n \t  && max != NULL_TREE\n@@ -373,9 +371,9 @@ static void\n set_value_range (value_range *vr, enum value_range_type t, tree min,\n \t\t tree max, bitmap equiv)\n {\n-#if defined ENABLE_CHECKING\n   /* Check the validity of the range.  */\n-  if (t == VR_RANGE || t == VR_ANTI_RANGE)\n+  if (flag_checking\n+      && (t == VR_RANGE || t == VR_ANTI_RANGE))\n     {\n       int cmp;\n \n@@ -395,12 +393,12 @@ set_value_range (value_range *vr, enum value_range_type t, tree min,\n \t\t    || !is_overflow_infinity (max));\n     }\n \n-  if (t == VR_UNDEFINED || t == VR_VARYING)\n-    gcc_assert (min == NULL_TREE && max == NULL_TREE);\n-\n-  if (t == VR_UNDEFINED || t == VR_VARYING)\n-    gcc_assert (equiv == NULL || bitmap_empty_p (equiv));\n-#endif\n+  if (flag_checking\n+      && (t == VR_UNDEFINED || t == VR_VARYING))\n+    {\n+      gcc_assert (min == NULL_TREE && max == NULL_TREE);\n+      gcc_assert (equiv == NULL || bitmap_empty_p (equiv));\n+    }\n \n   vr->type = t;\n   vr->min = min;"}, {"sha": "530e7a982063491afa91f52446387eb9b55aae2a", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -5952,10 +5952,11 @@ free_lang_data_in_cgraph (void)\n   /* Traverse every type found freeing its language data.  */\n   FOR_EACH_VEC_ELT (fld.types, i, t)\n     free_lang_data_in_type (t);\n-#ifdef ENABLE_CHECKING\n-  FOR_EACH_VEC_ELT (fld.types, i, t)\n-    verify_type (t);\n-#endif\n+  if (flag_checking)\n+    {\n+      FOR_EACH_VEC_ELT (fld.types, i, t)\n+\tverify_type (t);\n+    }\n \n   delete fld.pset;\n   fld.worklist.release ();"}, {"sha": "e371c24195e442db826ad6d9d97258f96926bb2f", "filename": "gcc/value-prof.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -230,9 +230,8 @@ gimple_remove_histogram_value (struct function *fun, gimple *stmt,\n       hist2->hvalue.next = hist->hvalue.next;\n     }\n   free (hist->hvalue.counters);\n-#ifdef ENABLE_CHECKING\n-  memset (hist, 0xab, sizeof (*hist));\n-#endif\n+  if (flag_checking)\n+    memset (hist, 0xab, sizeof (*hist));\n   free (hist);\n }\n \n@@ -595,9 +594,8 @@ free_hist (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   histogram_value hist = *(histogram_value *) slot;\n   free (hist->hvalue.counters);\n-#ifdef ENABLE_CHECKING\n-  memset (hist, 0xab, sizeof (*hist));\n-#endif\n+  if (flag_checking)\n+    memset (hist, 0xab, sizeof (*hist));\n   free (hist);\n   return 1;\n }"}, {"sha": "60c0320f693de13b50530baf675ce4c1a66a5a79", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2b293775a27c9f0099e9ccbf4ff965e79313c68/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=b2b293775a27c9f0099e9ccbf4ff965e79313c68", "patch": "@@ -399,7 +399,7 @@ struct variable\n /* Macro to access MEM_OFFSET as an HOST_WIDE_INT.  Evaluates MEM twice.  */\n #define INT_MEM_OFFSET(mem) (MEM_OFFSET_KNOWN_P (mem) ? MEM_OFFSET (mem) : 0)\n \n-#if ENABLE_CHECKING && (GCC_VERSION >= 2007)\n+#if CHECKING_P && (GCC_VERSION >= 2007)\n \n /* Access VAR's Ith part's offset, checking that it's not a one-part\n    variable.  */\n@@ -3571,7 +3571,6 @@ loc_cmp (rtx x, rtx y)\n   return 0;\n }\n \n-#if ENABLE_CHECKING\n /* Check the order of entries in one-part variables.   */\n \n int\n@@ -3603,7 +3602,6 @@ canonicalize_loc_order_check (variable **slot,\n \n   return 1;\n }\n-#endif\n \n /* Mark with VALUE_RECURSED_INTO values that have neighbors that are\n    more likely to be chosen as canonical for an equivalence set.\n@@ -3832,17 +3830,16 @@ canonicalize_values_star (variable **slot, dataflow_set *set)\n \t    else\n \t      gcc_unreachable ();\n \n-#if ENABLE_CHECKING\n-\t    while (list)\n-\t      {\n-\t\tif (list->offset == 0\n-\t\t    && (dv_as_opaque (list->dv) == dv_as_opaque (dv)\n-\t\t\t|| dv_as_opaque (list->dv) == dv_as_opaque (cdv)))\n-\t\t  gcc_unreachable ();\n+\t    if (flag_checking)\n+\t      while (list)\n+\t\t{\n+\t\t  if (list->offset == 0\n+\t\t      && (dv_as_opaque (list->dv) == dv_as_opaque (dv)\n+\t\t\t  || dv_as_opaque (list->dv) == dv_as_opaque (cdv)))\n+\t\t    gcc_unreachable ();\n \n-\t\tlist = list->next;\n-\t      }\n-#endif\n+\t\t  list = list->next;\n+\t\t}\n \t  }\n       }\n \n@@ -6930,10 +6927,9 @@ compute_bb_dataflow (basic_block bb)\n \t->traverse <dataflow_set *, canonicalize_values_mark> (out);\n       shared_hash_htab (out->vars)\n \t->traverse <dataflow_set *, canonicalize_values_star> (out);\n-#if ENABLE_CHECKING\n-      shared_hash_htab (out->vars)\n-\t->traverse <dataflow_set *, canonicalize_loc_order_check> (out);\n-#endif\n+      if (flag_checking)\n+\tshared_hash_htab (out->vars)\n+\t  ->traverse <dataflow_set *, canonicalize_loc_order_check> (out);\n     }\n   changed = dataflow_set_different (&old_out, out);\n   dataflow_set_destroy (&old_out);\n@@ -7038,13 +7034,14 @@ vt_find_locations (void)\n \t\t  if (adjust)\n \t\t    {\n \t\t      dataflow_post_merge_adjust (in, &VTI (bb)->permp);\n-#if ENABLE_CHECKING\n-\t\t      /* Merge and merge_adjust should keep entries in\n-\t\t\t canonical order.  */\n-\t\t      shared_hash_htab (in->vars)\n-\t\t\t->traverse <dataflow_set *,\n-\t\t\t\t    canonicalize_loc_order_check> (in);\n-#endif\n+\n+\t\t      if (flag_checking)\n+\t\t\t/* Merge and merge_adjust should keep entries in\n+\t\t\t   canonical order.  */\n+\t\t\tshared_hash_htab (in->vars)\n+\t\t\t  ->traverse <dataflow_set *,\n+\t\t\t\t      canonicalize_loc_order_check> (in);\n+\n \t\t      if (dst_can_be_shared)\n \t\t\t{\n \t\t\t  shared_hash_destroy (in->vars);\n@@ -9465,11 +9462,12 @@ vt_emit_notes (void)\n \t again.  */\n       dataflow_set_clear (&VTI (bb)->in);\n     }\n-#ifdef ENABLE_CHECKING\n-  shared_hash_htab (cur.vars)\n-    ->traverse <variable_table_type *, emit_notes_for_differences_1>\n-      (shared_hash_htab (empty_shared_hash));\n-#endif\n+\n+  if (flag_checking)\n+    shared_hash_htab (cur.vars)\n+      ->traverse <variable_table_type *, emit_notes_for_differences_1>\n+\t(shared_hash_htab (empty_shared_hash));\n+\n   dataflow_set_destroy (&cur);\n \n   if (MAY_HAVE_DEBUG_INSNS)"}]}