{"sha": "6c20b7e97e520789f6fcd11f3b6326394fbc1697", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMyMGI3ZTk3ZTUyMDc4OWY2ZmNkMTFmM2I2MzI2Mzk0ZmJjMTY5Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-11-21T20:29:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-21T20:29:06Z"}, "message": "except.c (expand_start_eh_spec): Use the try/catch code.\n\n\t* except.c (expand_start_eh_spec): Use the try/catch code.\n\t(expand_end_eh_spec): Likewise.  Call __check_eh_spec instead of\n\tdoing everything inline.\n\t(init_exception_processing): throw_type_match now takes\n \tconst void pointers.\n\t* exception.cc (__check_eh_spec): New fn.\n\t* inc/exception: Neither terminate nor unexpected return.\n\t* decl.c: Make const_ptr_type_node public.\n\t* tinfo2.cc (__throw_type_match_rtti): Take the typeinfos constly.\n\nFrom-SVN: r16651", "tree": {"sha": "08a80a0118110f30726b12db5089245356d08258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08a80a0118110f30726b12db5089245356d08258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c20b7e97e520789f6fcd11f3b6326394fbc1697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c20b7e97e520789f6fcd11f3b6326394fbc1697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c20b7e97e520789f6fcd11f3b6326394fbc1697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c20b7e97e520789f6fcd11f3b6326394fbc1697/comments", "author": null, "committer": null, "parents": [{"sha": "d32ecec207b26815c17a7347cf20dc3feccef062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32ecec207b26815c17a7347cf20dc3feccef062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d32ecec207b26815c17a7347cf20dc3feccef062"}], "stats": {"total": 212, "additions": 128, "deletions": 84}, "files": [{"sha": "88c9d2edac02fea728924c4cb6d1df3ca5374198", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6c20b7e97e520789f6fcd11f3b6326394fbc1697", "patch": "@@ -1,5 +1,15 @@\n Fri Nov 21 12:22:07 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* except.c (expand_start_eh_spec): Use the try/catch code.\n+\t(expand_end_eh_spec): Likewise.  Call __check_eh_spec instead of\n+\tdoing everything inline.\n+\t(init_exception_processing): throw_type_match now takes\n+ \tconst void pointers.\n+\t* exception.cc (__check_eh_spec): New fn.\n+\t* inc/exception: Neither terminate nor unexpected return.\n+\t* decl.c: Make const_ptr_type_node public.\n+\t* tinfo2.cc (__throw_type_match_rtti): Take the typeinfos constly.\n+\n \t* except.c (expand_start_catch_block): We only need the rethrow\n  \tregion for non-sjlj exceptions.\n \t(expand_end_catch_block): Likewise.  Use outer_context_label_stack."}, {"sha": "7b2e1c246224fadb53a5229a4e1bb24c50697199", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6c20b7e97e520789f6fcd11f3b6326394fbc1697", "patch": "@@ -239,7 +239,7 @@ tree void_zero_node;\n /* Nodes for types `void *' and `const void *'.  */\n \n tree ptr_type_node;\n-static tree const_ptr_type_node;\n+tree const_ptr_type_node;\n \n /* Nodes for types `char *' and `const char *'.  */\n "}, {"sha": "bd26053dfcef3d343a828eb348d4b6db5ab6e40a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 63, "deletions": 79, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6c20b7e97e520789f6fcd11f3b6326394fbc1697", "patch": "@@ -197,6 +197,7 @@ static tree saved_pc;\n \n extern int throw_used;\n extern rtx catch_clauses;\n+extern tree const_ptr_type_node;\n \n /* ========================================================================= */\n \n@@ -263,8 +264,8 @@ init_exception_processing ()\n \t\t\t? \"__throw_type_match_rtti\"\n \t\t\t: \"__throw_type_match\",\n \t\t\tbuild_function_type (ptr_type_node,\n-\t\t\t\t\t     tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t\ttree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t     tree_cons (NULL_TREE, const_ptr_type_node,\n+\t\t\t\t\t\t\ttree_cons (NULL_TREE, const_ptr_type_node,\n \t\t\t\t\t\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t\t\t\t\t\t      void_list_node)))),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n@@ -1020,101 +1021,84 @@ expand_builtin_throw ()\n #endif /* DWARF2_UNWIND_INFO */\n }\n \n+/* An exception spec is implemented more or less like:\n+\n+   try {\n+     function body;\n+   } catch (...) {\n+     void *p[] = { typeid(raises) };\n+     __check_eh_spec (p, count);\n+   }\n+\n+   __check_eh_spec in exception.cc handles all the details.  */\n \n void\n expand_start_eh_spec ()\n {\n-  expand_eh_region_start ();\n+  expand_start_try_stmts ();\n }\n \n static void\n expand_end_eh_spec (raises)\n      tree raises;\n {\n-  tree expr, second_try;\n-  rtx check = gen_label_rtx ();\n-  rtx cont;\n-  rtx ret = gen_reg_rtx (Pmode);\n-  rtx flag = gen_reg_rtx (TYPE_MODE (integer_type_node));\n-  rtx end = gen_label_rtx ();\n-\n-  expr = make_node (RTL_EXPR);\n-  TREE_TYPE (expr) = void_type_node;\n-  RTL_EXPR_RTL (expr) = const0_rtx;\n-  TREE_SIDE_EFFECTS (expr) = 1;\n-  do_pending_stack_adjust ();\n-  start_sequence_for_rtl_expr (expr);\n-  cont = gen_label_rtx ();\n-  emit_move_insn (ret, gen_rtx (LABEL_REF, Pmode, cont));\n-  emit_jump (check);\n-  emit_label (cont);\n-  jumpif (make_tree (integer_type_node, flag), end);\n-  do_function_call (Terminate, NULL_TREE, NULL_TREE);\n-  assemble_external (TREE_OPERAND (Terminate, 0));\n-  emit_barrier ();\n-  do_pending_stack_adjust ();\n-  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n-  end_sequence ();\n-  \n-  second_try = expr;\n+  tree tmp, fn, decl, types = NULL_TREE;\n+  int count = 0;\n \n-  expr = make_node (RTL_EXPR);\n-  TREE_TYPE (expr) = void_type_node;\n-  RTL_EXPR_RTL (expr) = const0_rtx;\n-  TREE_SIDE_EFFECTS (expr) = 1;\n-  do_pending_stack_adjust ();\n-  start_sequence_for_rtl_expr (expr);\n+  expand_start_all_catch ();\n+  expand_start_catch_block (NULL_TREE, NULL_TREE);\n \n-  cont = gen_label_rtx ();\n-  emit_move_insn (ret, gen_rtx (LABEL_REF, Pmode, cont));\n-  emit_jump (check);\n-  emit_label (cont);\n-  jumpif (make_tree (integer_type_node, flag), end);\n-  expand_eh_region_start ();\n-  do_function_call (Unexpected, NULL_TREE, NULL_TREE);\n-  assemble_external (TREE_OPERAND (Unexpected, 0));\n-  emit_barrier ();\n+  /* Build up an array of type_infos.  */\n+  for (; raises && TREE_VALUE (raises); raises = TREE_CHAIN (raises))\n+    {\n+      types = expr_tree_cons\n+\t(NULL_TREE, build_eh_type_type (TREE_VALUE (raises)), types);\n+      ++count;\n+    }\n \n-  expand_eh_region_end (second_try);\n-  \n-  emit_label (check);\n-  emit_move_insn (flag, const1_rtx);\n-  cont = gen_label_rtx ();\n+  types = build_nt (CONSTRUCTOR, NULL_TREE, types);\n+  TREE_HAS_CONSTRUCTOR (types) = 1;\n \n-  push_eh_info ();\n+  /* We can't pass the CONSTRUCTOR directly, so stick it in a variable.  */\n+  tmp = build_array_type (const_ptr_type_node, NULL_TREE);\n+  decl = build_decl (VAR_DECL, NULL_TREE, tmp);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_INITIAL (decl) = types;\n+  cp_finish_decl (decl, types, NULL_TREE, 0, 0);\n+\n+  decl = decay_conversion (decl);\n \n-  while (raises)\n+  fn = get_identifier (\"__check_eh_spec\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n     {\n-      tree exp;\n-      tree match_type = TREE_VALUE (raises);\n-      \n-      if (match_type)\n-\t{\n-\t  /* check TREE_VALUE (raises) here */\n-\t  exp = get_eh_value ();\n-\t  exp = expr_tree_cons (NULL_TREE,\n-\t\t\t   build_eh_type_type (match_type),\n-\t\t\t   expr_tree_cons (NULL_TREE,\n-\t\t\t\t      get_eh_type (),\n-\t\t\t\t      expr_tree_cons (NULL_TREE, exp, NULL_TREE)));\n-\t  exp = build_function_call (CatchMatch, exp);\n-\t  assemble_external (TREE_OPERAND (CatchMatch, 0));\n-\n-\t  jumpif (exp, cont);\n-\t}\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n \n-      raises = TREE_CHAIN (raises);\n-    }\n-  emit_move_insn (flag, const0_rtx);\n-  emit_label (cont);\n-  emit_indirect_jump (ret);\n-  emit_label (end);\n-  \n-  do_pending_stack_adjust ();\n-  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n-  end_sequence ();\n+      tmp = tree_cons\n+\t(NULL_TREE, integer_type_node, tree_cons\n+\t (NULL_TREE, TREE_TYPE (decl), void_list_node));\n+      tmp = build_function_type\t(void_type_node, tmp);\n   \n-  expand_eh_region_end (expr);\n+      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      TREE_THIS_VOLATILE (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      assemble_external (fn);\n+      pop_obstacks ();\n+    }\n+\n+  tmp = expr_tree_cons (NULL_TREE, build_int_2 (count, 0), expr_tree_cons\n+\t\t\t(NULL_TREE, decl, NULL_TREE));\n+  tmp = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), tmp);\n+  expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  expand_end_catch_block ();\n+  expand_end_all_catch ();\n }\n \n /* This is called to expand all the toplevel exception handling"}, {"sha": "28071183c0f59180a61deb09e3d2147b4a66b12d", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=6c20b7e97e520789f6fcd11f3b6326394fbc1697", "patch": "@@ -47,7 +47,8 @@ __default_unexpected ()\n   terminate ();\n }\n \n-static unexpected_handler __unexpected_func = __default_unexpected;\n+static unexpected_handler __unexpected_func __attribute__((__noreturn__))\n+  = __default_unexpected;\n \n terminate_handler\n set_terminate (terminate_handler func)\n@@ -159,6 +160,54 @@ __uncatch_exception (void)\n   /* otherwise __throw will call terminate(); don't crash here.  */\n }\n \n+/* As per [except.unexpected]:\n+   If an exception is thrown, we check it against the spec.  If it doesn't\n+   match, we call unexpected ().  If unexpected () throws, we check that\n+   exception against the spec.  If it doesn't match, if the spec allows\n+   bad_exception we throw that; otherwise we call terminate ().\n+\n+   The compiler treats an exception spec as a try block with a generic\n+   handler that just calls this function with a list of the allowed\n+   exception types, so we have an active exception that can be rethrown.\n+\n+   This function does not return.  */   \n+\n+extern \"C\" void\n+__check_eh_spec (int n, const void **spec)\n+{\n+  cp_eh_info *p = __cp_exception_info ();\n+\n+  for (int i = 0; i < n; ++i)\n+    {\n+      if (__throw_type_match_rtti (spec[i], p->type, p->value))\n+\tthrow;\n+    }\n+\n+  try\n+    {\n+      unexpected ();\n+    }\n+  catch (...)\n+    {\n+      // __exception_info is an artificial var pushed into each catch block.\n+      p = __exception_info;\n+      for (int i = 0; i < n; ++i)\n+\t{\n+\t  if (__throw_type_match_rtti (spec[i], p->type, p->value))\n+\t    throw;\n+\t}\n+\n+      const type_info &bad_exc = typeid (bad_exception);\n+      for (int i = 0; i < n; ++i)\n+\t{\n+\t  if (__throw_type_match_rtti (spec[i], &bad_exc, p->value))\n+\t    throw bad_exception ();\n+\t}\n+\n+      terminate ();\n+    }\n+}\n+\n extern \"C\" void\n __throw_bad_cast (void)\n {"}, {"sha": "3e66beed5183f7a72c66352b0fc1caaadeecbf46", "filename": "gcc/cp/inc/exception", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Finc%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Finc%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fexception?ref=6c20b7e97e520789f6fcd11f3b6326394fbc1697", "patch": "@@ -29,9 +29,9 @@ typedef void (*terminate_handler) ();\n typedef void (*unexpected_handler) ();\n \n terminate_handler set_terminate (terminate_handler);\n-void terminate (void);\n+void terminate (void) __attribute__ ((__noreturn__));\n unexpected_handler set_unexpected (unexpected_handler);\n-void unexpected (void);\n+void unexpected (void) __attribute__ ((__noreturn__));\n bool uncaught_exception ();\n } // extern \"C++\"\n "}, {"sha": "531348895271dcf9049ea0db8830eb14fd375001", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c20b7e97e520789f6fcd11f3b6326394fbc1697/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=6c20b7e97e520789f6fcd11f3b6326394fbc1697", "patch": "@@ -119,7 +119,8 @@ struct __array_type_info : public type_info {\n    variables and thrown objects.  */\n \n extern \"C\" void*\n-__throw_type_match_rtti (void *catch_type_r, void *throw_type_r, void *objptr)\n+__throw_type_match_rtti (const void *catch_type_r, const void *throw_type_r,\n+\t\t\t void *objptr)\n {\n   const type_info &catch_type = *(const type_info *)catch_type_r;\n   const type_info &throw_type = *(const type_info *)throw_type_r;"}]}