{"sha": "e4249b10038bd906f50c00759b37807dd2fffede", "node_id": "C_kwDOANBUbNoAKGU0MjQ5YjEwMDM4YmQ5MDZmNTBjMDA3NTliMzc4MDdkZDJmZmZlZGU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T07:21:55Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T16:55:14Z"}, "message": "path solver: Add related SSAs to solvable set.\n\nThe path solver takes an initial set of SSA names which are deemed\ninteresting.  These are then solved along the path.  Adding any copies\nof said SSA names to the list of interesting names yields significantly\nbetter results.  This patch adds said copies to the already provided\nlist.\n\nCurrently this code is guarded by \"m_resolve\", which is the more\nexpensive mode, but it would be reasonable to make it available always,\nespecially since adding more imports usually has minimal impact on the\nprocessing time.  I will investigate and make it universally available\nif this is indeed the case.\n\ngcc/ChangeLog:\n\n\t* gimple-range-path.cc (path_range_query::add_to_imports): New.\n\t(path_range_query::add_copies_to_imports): New.\n\t(path_range_query::precompute_ranges): Call\n\tadd_copies_to_imports.\n\t* gimple-range-path.h (class path_range_query): Add prototypes\n\tfor add_copies_to_imports and add_to_imports.", "tree": {"sha": "4e94b6b32e1e053a51f79d5427220ee6141fbd92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e94b6b32e1e053a51f79d5427220ee6141fbd92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4249b10038bd906f50c00759b37807dd2fffede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4249b10038bd906f50c00759b37807dd2fffede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4249b10038bd906f50c00759b37807dd2fffede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4249b10038bd906f50c00759b37807dd2fffede/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "062c8727df2d9972b73f10445a7585e0129bd63e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062c8727df2d9972b73f10445a7585e0129bd63e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062c8727df2d9972b73f10445a7585e0129bd63e"}], "stats": {"total": 84, "additions": 82, "deletions": 2}, "files": [{"sha": "a8ead3da4dcf5bc6ad2344e033a815e03313aa18", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4249b10038bd906f50c00759b37807dd2fffede/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4249b10038bd906f50c00759b37807dd2fffede/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=e4249b10038bd906f50c00759b37807dd2fffede", "patch": "@@ -343,6 +343,71 @@ path_range_query::adjust_for_non_null_uses (basic_block bb)\n     }\n }\n \n+// If NAME is a supported SSA_NAME, add it the bitmap in IMPORTS.\n+\n+bool\n+path_range_query::add_to_imports (tree name, bitmap imports)\n+{\n+  if (TREE_CODE (name) == SSA_NAME\n+      && irange::supports_type_p (TREE_TYPE (name)))\n+    return bitmap_set_bit (imports, SSA_NAME_VERSION (name));\n+  return false;\n+}\n+\n+// Add the copies of any SSA names in IMPORTS to IMPORTS.\n+//\n+// These are hints for the solver.  Adding more elements (within\n+// reason) doesn't slow us down, because we don't solve anything that\n+// doesn't appear in the path.  On the other hand, not having enough\n+// imports will limit what we can solve.\n+\n+void\n+path_range_query::add_copies_to_imports ()\n+{\n+  auto_vec<tree> worklist (bitmap_count_bits (m_imports));\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      worklist.quick_push (name);\n+    }\n+\n+  while (!worklist.is_empty ())\n+    {\n+      tree name = worklist.pop ();\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+      if (is_gimple_assign (def_stmt))\n+\t{\n+\t  // ?? Adding assignment copies doesn't get us much.  At the\n+\t  // time of writing, we got 63 more threaded paths across the\n+\t  // .ii files from a bootstrap.\n+\t  add_to_imports (gimple_assign_rhs1 (def_stmt), m_imports);\n+\t  tree rhs = gimple_assign_rhs2 (def_stmt);\n+\t  if (rhs && add_to_imports (rhs, m_imports))\n+\t    worklist.safe_push (rhs);\n+\t  rhs = gimple_assign_rhs3 (def_stmt);\n+\t  if (rhs && add_to_imports (rhs, m_imports))\n+\t    worklist.safe_push (rhs);\n+\t}\n+      else if (gphi *phi = dyn_cast <gphi *> (def_stmt))\n+\t{\n+\t  for (size_t i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      edge e = gimple_phi_arg_edge (phi, i);\n+\t      tree arg = gimple_phi_arg (phi, i)->def;\n+\n+\t      if (TREE_CODE (arg) == SSA_NAME\n+\t\t  && m_path->contains (e->src)\n+\t\t  && bitmap_set_bit (m_imports, SSA_NAME_VERSION (arg)))\n+\t\tworklist.safe_push (arg);\n+\t    }\n+\t}\n+    }\n+}\n+\n // Precompute the ranges for IMPORTS along PATH.\n //\n // IMPORTS are the set of SSA names, any of which could potentially\n@@ -353,11 +418,12 @@ path_range_query::precompute_ranges (const vec<basic_block> &path,\n \t\t\t\t     const bitmap_head *imports)\n {\n   set_path (path);\n-  m_imports = imports;\n+  bitmap_copy (m_imports, imports);\n   m_undefined_path = false;\n \n   if (m_resolve)\n     {\n+      add_copies_to_imports ();\n       m_oracle->reset_path ();\n       precompute_relations (path);\n     }\n@@ -379,6 +445,18 @@ path_range_query::precompute_ranges (const vec<basic_block> &path,\n     {\n       basic_block bb = curr_bb ();\n \n+      if (m_resolve)\n+\t{\n+\t  gori_compute &gori = m_ranger.gori ();\n+\t  tree name;\n+\n+\t  // Exported booleans along the path, may help conditionals.\n+\t  // Add them as interesting imports.\n+\t  FOR_EACH_GORI_EXPORT_NAME (gori, bb, name)\n+\t    if (TREE_CODE (TREE_TYPE (name)) == BOOLEAN_TYPE)\n+\t      bitmap_set_bit (m_imports, SSA_NAME_VERSION (name));\n+\t}\n+\n       precompute_ranges_in_block (bb);\n       adjust_for_non_null_uses (bb);\n "}, {"sha": "f23cce18391f743da8242a350ce0582ebf10d2cd", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4249b10038bd906f50c00759b37807dd2fffede/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4249b10038bd906f50c00759b37807dd2fffede/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=e4249b10038bd906f50c00759b37807dd2fffede", "patch": "@@ -61,6 +61,8 @@ class path_range_query : public range_query\n   void ssa_range_in_phi (irange &r, gphi *phi);\n   void precompute_relations (const vec<basic_block> &);\n   void precompute_phi_relations (basic_block bb, basic_block prev);\n+  void add_copies_to_imports ();\n+  bool add_to_imports (tree name, bitmap imports);\n \n   // Path navigation.\n   void set_path (const vec<basic_block> &);\n@@ -82,7 +84,7 @@ class path_range_query : public range_query\n   // Path being analyzed.\n   const vec<basic_block> *m_path;\n \n-  const bitmap_head *m_imports;\n+  auto_bitmap m_imports;\n   gimple_ranger &m_ranger;\n   non_null_ref m_non_null;\n   path_oracle *m_oracle;"}]}