{"sha": "fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3M2ZjM2QzOTk1NmViZjIyOTk4ZGVhOGJmZmE5NmZhZDM0ZDZmMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:10:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:10:12Z"}, "message": "[multiple changes]\n\n2015-10-26  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* sysdep.c (__gnat_get_task_options): Workaround a VxWorks\n\tbug where VX_DEALLOC_TCB task option is forbidden when calling\n\ttaskCreate but allowed in VX_USR_TASK_OPTIONS.\n\n2015-10-26  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_unst.ads, exp_unst.adb (Is_Uplevel_Referenced): New subprogram.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Constant_Indexing_OK): New predicate, subsidiary\n\tof Try_Container_Indexing, that implements the name resolution\n\trules given in RM 4.1.6 (13-15).\n\nFrom-SVN: r229355", "tree": {"sha": "c7f43e850cb4a4897668e4927af675c26278cd8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7f43e850cb4a4897668e4927af675c26278cd8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/comments", "author": null, "committer": null, "parents": [{"sha": "e3d6bccc831ddd49e6b8e888df5e301c2da339b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d6bccc831ddd49e6b8e888df5e301c2da339b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d6bccc831ddd49e6b8e888df5e301c2da339b4"}], "stats": {"total": 217, "additions": 195, "deletions": 22}, "files": [{"sha": "6b12af2500547894701f82cfcf7d90e71b89e0a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "patch": "@@ -1,3 +1,19 @@\n+2015-10-26  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* sysdep.c (__gnat_get_task_options): Workaround a VxWorks\n+\tbug where VX_DEALLOC_TCB task option is forbidden when calling\n+\ttaskCreate but allowed in VX_USR_TASK_OPTIONS.\n+\n+2015-10-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_unst.ads, exp_unst.adb (Is_Uplevel_Referenced): New subprogram.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Constant_Indexing_OK): New predicate, subsidiary\n+\tof Try_Container_Indexing, that implements the name resolution\n+\trules given in RM 4.1.6 (13-15).\n+\n 2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch3.adb, sem_util.adb: Minor reformatting."}, {"sha": "b555fe705619ccb25a320275fe94cd275c2e1a69", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "patch": "@@ -119,6 +119,21 @@ package body Exp_Unst is\n      Table_Increment      => 200,\n      Table_Name           => \"Unnest_Urefs\");\n \n+   ---------------------------\n+   -- Is_Uplevel_Referenced --\n+   ---------------------------\n+\n+   function Is_Uplevel_Referenced (E : Entity_Id) return Boolean is\n+   begin\n+      for J in Urefs.First .. Urefs.Last loop\n+         if Urefs.Table (J).Ent = E then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      return False;\n+   end Is_Uplevel_Referenced;\n+\n    -----------------------\n    -- Unnest_Subprogram --\n    -----------------------"}, {"sha": "1458853610ce3c2017ab9655f6f965665e94460a", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "patch": "@@ -686,4 +686,7 @@ package Exp_Unst is\n    --  adds the ARECP parameter to all nested subprograms which need it, and\n    --  modifies all uplevel references appropriately.\n \n+   function Is_Uplevel_Referenced (E : Entity_Id) return Boolean;\n+   --  Determines if E has some uplevel reference from a nested subprogram\n+\n end Exp_Unst;"}, {"sha": "c354de8a4984e46b378431f7df997572d62802b0", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 149, "deletions": 19, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "patch": "@@ -7161,18 +7161,147 @@ package body Sem_Ch4 is\n       Prefix : Node_Id;\n       Exprs  : List_Id) return Boolean\n    is\n+      function Constant_Indexing_OK return Boolean;\n+      --  Constant_Indexing is legal if there is no Variable_Indexing defined\n+      --  for the type, or else node not a target of assignment, or an actual\n+      --  for an IN OUT or OUT formal (RM 4.1.6 (11)).\n+\n+      --------------------------\n+      -- Constant_Indexing_OK --\n+      --------------------------\n+\n+      function Constant_Indexing_OK return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         if No (Find_Value_Of_Aspect\n+                 (Etype (Prefix), Aspect_Variable_Indexing))\n+         then\n+            return True;\n+\n+         elsif not Is_Variable (Prefix) then\n+            return True;\n+         end if;\n+\n+         Par := N;\n+         while Present (Par) loop\n+            if Nkind (Parent (Par)) = N_Assignment_Statement\n+              and then Par = Name (Parent (Par))\n+            then\n+               return False;\n+\n+            --  The call may be overloaded, in which case we assume that its\n+            --  resolution does not depend on the type of the parameter that\n+            --  includes the indexing operation.\n+\n+            elsif Nkind_In (Parent (Par), N_Function_Call,\n+                                          N_Procedure_Call_Statement)\n+              and then Is_Entity_Name (Name (Parent (Par)))\n+            then\n+               declare\n+                  Actual : Node_Id;\n+                  Formal : Entity_Id;\n+                  Proc   : Entity_Id;\n+\n+               begin\n+                  --  We should look for an interpretation with the proper\n+                  --  number of formals, and determine whether it is an\n+                  --  In_Parameter, but for now assume that in the overloaded\n+                  --  case constant indexing is legal. To be improved ???\n+\n+                  if Is_Overloaded (Name (Parent (Par))) then\n+                     return True;\n+\n+                  else\n+                     Proc := Entity (Name (Parent (Par)));\n+\n+                     --  If this is an indirect call, get formals from\n+                     --  designated type.\n+\n+                     if Is_Access_Subprogram_Type (Etype (Proc)) then\n+                        Proc := Designated_Type (Etype (Proc));\n+                     end if;\n+                  end if;\n+\n+                  Formal := First_Formal (Proc);\n+                  Actual := First_Actual (Parent (Par));\n+\n+                  --  Find corresponding actual\n+\n+                  while Present (Actual) loop\n+                     exit when Actual = Par;\n+                     Next_Actual (Actual);\n+\n+                     if Present (Formal) then\n+                        Next_Formal (Formal);\n+\n+                     --  Otherwise this is a parameter mismatch, the error is\n+                     --  reported elsewhere.\n+\n+                     else\n+                        return False;\n+                     end if;\n+                  end loop;\n+\n+                  return Ekind (Formal) = E_In_Parameter;\n+               end;\n+\n+            elsif Nkind (Parent (Par)) = N_Object_Renaming_Declaration then\n+               return False;\n+\n+            --  If the indexed component is a prefix it may be the first actual\n+            --  of a prefixed call. Retrieve the called entity, if any, and\n+            --  check its first formal.\n+\n+            elsif Nkind (Parent (Par)) = N_Selected_Component then\n+               declare\n+                  Sel : constant Node_Id   := Selector_Name (Parent (Par));\n+                  Nam : constant Entity_Id := Current_Entity (Sel);\n+\n+               begin\n+                  if Present (Nam)\n+                    and then Is_Overloadable (Nam)\n+                    and then Present (First_Formal (Nam))\n+                  then\n+                     return Ekind (First_Formal (Nam)) = E_In_Parameter;\n+                  end if;\n+               end;\n+\n+            elsif Nkind ((Par)) in N_Op then\n+               return True;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         --  In all other cases, constant indexing is legal\n+\n+         return True;\n+      end Constant_Indexing_OK;\n+\n+      --  Local variables\n+\n       Loc       : constant Source_Ptr := Sloc (N);\n-      C_Type    : Entity_Id;\n       Assoc     : List_Id;\n+      C_Type    : Entity_Id;\n       Func      : Entity_Id;\n       Func_Name : Node_Id;\n       Indexing  : Node_Id;\n \n+   --  Start of processing for Try_Container_Indexing\n+\n    begin\n+      --  Node may have been analyzed already when testing for a prefixed\n+      --  call, in which case do not redo analysis.\n+\n+      if Present (Generalized_Indexing (N)) then\n+         return True;\n+      end if;\n+\n       C_Type := Etype (Prefix);\n \n-      --  If indexing a class-wide container, obtain indexing primitive\n-      --  from specific type.\n+      --  If indexing a class-wide container, obtain indexing primitive from\n+      --  specific type.\n \n       if Is_Class_Wide_Type (C_Type) then\n          C_Type := Etype (Base_Type (C_Type));\n@@ -7182,23 +7311,23 @@ package body Sem_Ch4 is\n \n       Func_Name := Empty;\n \n-      if Is_Variable (Prefix) then\n+      if Constant_Indexing_OK then\n          Func_Name :=\n-           Find_Value_Of_Aspect (Etype (Prefix), Aspect_Variable_Indexing);\n+           Find_Value_Of_Aspect (Etype (Prefix), Aspect_Constant_Indexing);\n       end if;\n \n       if No (Func_Name) then\n          Func_Name :=\n-           Find_Value_Of_Aspect (Etype (Prefix), Aspect_Constant_Indexing);\n+           Find_Value_Of_Aspect (Etype (Prefix), Aspect_Variable_Indexing);\n       end if;\n \n       --  If aspect does not exist the expression is illegal. Error is\n       --  diagnosed in caller.\n \n       if No (Func_Name) then\n \n-         --  The prefix itself may be an indexing of a container: rewrite\n-         --  as such and re-analyze.\n+         --  The prefix itself may be an indexing of a container: rewrite as\n+         --  such and re-analyze.\n \n          if Has_Implicit_Dereference (Etype (Prefix)) then\n             Build_Explicit_Dereference\n@@ -7213,14 +7342,14 @@ package body Sem_Ch4 is\n       --  value of the inherited aspect is the Reference operation declared\n       --  for the parent type.\n \n-      --  However, Reference is also a primitive operation of the type, and\n-      --  the inherited operation has a different signature. We retrieve the\n-      --  right ones (the function may be overloaded) from the list of\n-      --  primitive operations of the derived type.\n+      --  However, Reference is also a primitive operation of the type, and the\n+      --  inherited operation has a different signature. We retrieve the right\n+      --  ones (the function may be overloaded) from the list of primitive\n+      --  operations of the derived type.\n \n-      --  Note that predefined containers are typically all derived from one\n-      --  of the Controlled types. The code below is motivated by containers\n-      --  that are derived from other types with a Reference aspect.\n+      --  Note that predefined containers are typically all derived from one of\n+      --  the Controlled types. The code below is motivated by containers that\n+      --  are derived from other types with a Reference aspect.\n \n       elsif Is_Derived_Type (C_Type)\n         and then Etype (First_Formal (Entity (Func_Name))) /= Etype (Prefix)\n@@ -7238,8 +7367,8 @@ package body Sem_Ch4 is\n \n       --  The generalized indexing node is the one on which analysis and\n       --  resolution take place. Before expansion the original node is replaced\n-      --  with the generalized indexing node, which is a call, possibly with\n-      --  a dereference operation.\n+      --  with the generalized indexing node, which is a call, possibly with a\n+      --  dereference operation.\n \n       if Comes_From_Source (N) then\n          Check_Compiler_Unit (\"generalized indexing\", N);\n@@ -7279,7 +7408,8 @@ package body Sem_Ch4 is\n       else\n          Indexing :=\n            Make_Function_Call (Loc,\n-             Name => Make_Identifier (Loc, Chars (Func_Name)),\n+             Name                   =>\n+               Make_Identifier (Loc, Chars (Func_Name)),\n              Parameter_Associations => Assoc);\n \n          Set_Parent (Indexing, Parent (N));\n@@ -7297,7 +7427,7 @@ package body Sem_Ch4 is\n                Analyze_One_Call (Indexing, It.Nam, False, Success);\n \n                if Success then\n-                  Set_Etype (Name (Indexing), It.Typ);\n+                  Set_Etype  (Name (Indexing), It.Typ);\n                   Set_Entity (Name (Indexing), It.Nam);\n                   Set_Etype (N, Etype (Indexing));\n "}, {"sha": "21cd37cc540d38aada3705bd2246b126959d2fb1", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa73fc3d39956ebf22998dea8bffa96fad34d6f2/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=fa73fc3d39956ebf22998dea8bffa96fad34d6f2", "patch": "@@ -865,10 +865,19 @@ __gnat_get_task_options (void)\n \n   /* Mask those bits that are not under user control */\n #ifdef VX_USR_TASK_OPTIONS\n-  return options & VX_USR_TASK_OPTIONS;\n-#else\n-  return options;\n+  /* O810-007, TSR 00043679:\n+     Workaround a bug in Vx-7 where VX_DEALLOC_TCB == VX_PRIVATE_UMASK and:\n+     - VX_DEALLOC_TCB is an internal option not to be used by users\n+     - VX_PRIVATE_UMASK as a user-definable option\n+     This leads to VX_USR_TASK_OPTIONS allowing 0x8000 as VX_PRIVATE_UMASK but\n+     taskCreate refusing this option (VX_DEALLOC_TCB is not allowed)\n+  */\n+# if defined (VX_PRIVATE_UMASK) && (VX_DEALLOC_TCB == VX_PRIVATE_UMASK)\n+  options &= ~VX_DEALLOC_TCB;\n+# endif\n+  options &= VX_USR_TASK_OPTIONS;\n #endif\n+  return options;\n }\n \n #endif"}]}