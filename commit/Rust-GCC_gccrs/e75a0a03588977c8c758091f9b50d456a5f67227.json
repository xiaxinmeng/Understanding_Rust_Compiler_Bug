{"sha": "e75a0a03588977c8c758091f9b50d456a5f67227", "node_id": "C_kwDOANBUbNoAKGU3NWEwYTAzNTg4OTc3YzhjNzU4MDkxZjliNTBkNDU2YTVmNjcyMjc", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-15T09:41:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-15T09:43:44Z"}, "message": "dwarf2cfi: Improve cfa_reg comparisons [PR103619]\n\nOn Tue, Dec 14, 2021 at 10:32:21AM -0700, Jeff Law wrote:\n> I think the attached testcase should trigger on c6x with -mbig-endian -O2 -g\n\nThanks.  Finally I see what's going on.  c6x doesn't really need the CFA\nwith span > 1 (and I bet neither does armbe), the only reason why\ndwf_cfa_reg is called is that the code in 13 cases just tries to compare\nthe CFA against dwf_cfa_reg (some_reg).  And that dwf_cfa_reg on some reg\nthat usually isn't a CFA reg results in targetm.dwarf_register_span hook\ncall, which on targets like c6x or armeb and others for some registers\ncreates a PARALLEL with various REGs in it, then the loop with the assertion\nand finally operator== which just notes that the reg is different and fails.\n\nThis seems compile time memory and time inefficient.\n\nThe following so far untested patch instead adds an extra operator== and !=\nfor comparison of cfa_reg with rtx, which has the most common case where it\nis a different register number done early without actually invoking\ndwf_cfa_reg.  This means the assertion in dwf_cfa_reg can stay as is (at\nleast until some big endian target needs to have hard frame pointer or stack\npointer with span > 1 as well).\nI've removed a different assertion there because it is redundant - dwf_regno\nalready has exactly that assertion in it too.\n\nAnd I've included those 2 tweaks to avoid creating a REG in GC memory when\nwe can use {stack,hard_frame}_pointer_rtx which is already initialized to\nthe same REG we need by init_emit_regs.\n\nOn Tue, Dec 14, 2021 at 03:05:37PM -0700, Jeff Law wrote:\n> So if someone is unfamiliar with the underlying issues here and needs to\n> twiddle dwarf2cfi, how are they supposed to know if they should compare\n> directly or use dwf_cfa_reg?\n\nComparison without dwf_cfa_reg should be used whenever possible, because\nfor registers which are never CFA related that won't call\ntargetm.dwarf_register_span uselessly.\n\nThe only comparisons with dwf_cfa_reg I've kept are the:\n            regno = dwf_cfa_reg (XEXP (XEXP (dest, 0), 0));\n\n            if (cur_cfa->reg == regno)\n              offset -= cur_cfa->offset;\n            else if (cur_trace->cfa_store.reg == regno)\n              offset -= cur_trace->cfa_store.offset;\n            else\n              {\n                gcc_assert (cur_trace->cfa_temp.reg == regno);\n                offset -= cur_trace->cfa_temp.offset;\n              }\nand\n            struct cfa_reg regno = dwf_cfa_reg (XEXP (dest, 0));\n\n            if (cur_cfa->reg == regno)\n              offset = -cur_cfa->offset;\n            else if (cur_trace->cfa_store.reg == regno)\n              offset = -cur_trace->cfa_store.offset;\n            else\n              {\n                gcc_assert (cur_trace->cfa_temp.reg == regno);\n                offset = -cur_trace->cfa_temp.offset;\n              }\nand there are 2 reasons for it:\n1) there is an assertion, which guarantees it must compare equal to one of\nthose 3 cfa related struct cfa_reg structs, so it must be some CFA related\nregister (so, right now, targetm.dwarf_register_span shouldn't return\nnon-NULL in those on anything but gcn)\n2) it is compared 3 times in a row, so for the GCN case doing\n            if (cur_cfa->reg == XEXP (XEXP (dest, 0), 0))\n              offset -= cur_cfa->offset;\n            else if (cur_trace->cfa_store.reg == XEXP (XEXP (dest, 0), 0))\n              offset -= cur_trace->cfa_store.offset;\n            else\n              {\n                gcc_assert (cur_trace->cfa_temp.reg == XEXP (XEXP (dest, 0), 0));\n                offset -= cur_trace->cfa_temp.offset;\n              }\ncould actually create more GC allocated garbage than the way it is written\nnow.  But doing it that way would work fine.\n\nI think for most of the comparisons even comparing with dwf_cfa_reg would\nwork but be less compile time/memory efficient (e.g. those assertions that\nit is equal to some CFA related cfa_reg or in any spots where only the CFA\nrelated regs may appear in the frame related patterns).\n\nI'm aware just of a single spot where comparison with dwf_cfa_reg doesn't\nwork (when the assert is in dwf_cfa_reg), that is the spot that was ICEing\non your testcase, where we save arbitrary call saved register:\n      if (REG_P (src)\n          && REGNO (src) != STACK_POINTER_REGNUM\n          && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n          && cur_cfa->reg == src)\n\n2021-12-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/103619\n\t* dwarf2cfi.c (dwf_cfa_reg): Remove gcc_assert.\n\t(operator==, operator!=): New overloaded operators.\n\t(dwarf2out_frame_debug_adjust_cfa, dwarf2out_frame_debug_cfa_offset,\n\tdwarf2out_frame_debug_expr): Compare vars with cfa_reg type directly\n\twith REG rtxes rather than with dwf_cfa_reg results on those REGs.\n\t(create_cie_data): Use stack_pointer_rtx instead of\n\tgen_rtx_REG (Pmode, STACK_POINTER_REGNUM).\n\t(execute_dwarf2_frame): Use hard_frame_pointer_rtx instead of\n\tgen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM).", "tree": {"sha": "c36ce7bd86fc83fab68875edc72484ebcf40dfd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c36ce7bd86fc83fab68875edc72484ebcf40dfd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e75a0a03588977c8c758091f9b50d456a5f67227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75a0a03588977c8c758091f9b50d456a5f67227", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e75a0a03588977c8c758091f9b50d456a5f67227", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75a0a03588977c8c758091f9b50d456a5f67227/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "127c7178d5ec502d95862fd823537cbca1a0cb99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127c7178d5ec502d95862fd823537cbca1a0cb99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/127c7178d5ec502d95862fd823537cbca1a0cb99"}], "stats": {"total": 58, "additions": 37, "deletions": 21}, "files": [{"sha": "b8aa805fa77156b51e33119a9184a9281c8dec7d", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e75a0a03588977c8c758091f9b50d456a5f67227/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e75a0a03588977c8c758091f9b50d456a5f67227/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=e75a0a03588977c8c758091f9b50d456a5f67227", "patch": "@@ -1113,8 +1113,6 @@ dwf_cfa_reg (rtx reg)\n {\n   struct cfa_reg result;\n \n-  gcc_assert (REGNO (reg) < FIRST_PSEUDO_REGISTER);\n-\n   result.reg = dwf_regno (reg);\n   result.span = 1;\n   result.span_width = 0;\n@@ -1144,6 +1142,28 @@ dwf_cfa_reg (rtx reg)\n   return result;\n }\n \n+/* More efficient comparisons that don't call targetm.dwarf_register_span\n+   unnecessarily.  These cfa_reg vs. rtx comparisons should be done at\n+   least for call-saved REGs that might not be CFA related (like stack\n+   pointer, hard frame pointer or DRAP registers are), in other cases it is\n+   just a compile time and memory optimization.  */\n+\n+static bool\n+operator== (cfa_reg &cfa, rtx reg)\n+{\n+  unsigned int regno = dwf_regno (reg);\n+  if (cfa.reg != regno)\n+    return false;\n+  struct cfa_reg other = dwf_cfa_reg (reg);\n+  return cfa == other;\n+}\n+\n+static inline bool\n+operator!= (cfa_reg &cfa, rtx reg)\n+{\n+  return !(cfa == reg);\n+}\n+\n /* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n \n static bool\n@@ -1313,7 +1333,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n   switch (GET_CODE (src))\n     {\n     case PLUS:\n-      gcc_assert (dwf_cfa_reg (XEXP (src, 0)) == cur_cfa->reg);\n+      gcc_assert (cur_cfa->reg == XEXP (src, 0));\n       cur_cfa->offset -= rtx_to_poly_int64 (XEXP (src, 1));\n       break;\n \n@@ -1346,11 +1366,11 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      gcc_assert (dwf_cfa_reg (addr) == cur_cfa->reg);\n+      gcc_assert (cur_cfa->reg == addr);\n       offset = -cur_cfa->offset;\n       break;\n     case PLUS:\n-      gcc_assert (dwf_cfa_reg (XEXP (addr, 0)) == cur_cfa->reg);\n+      gcc_assert (cur_cfa->reg == XEXP (addr, 0));\n       offset = rtx_to_poly_int64 (XEXP (addr, 1)) - cur_cfa->offset;\n       break;\n     default:\n@@ -1797,7 +1817,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n-\t  if (cur_cfa->reg == dwf_cfa_reg (src))\n+\t  if (cur_cfa->reg == src)\n \t    {\n \t      /* Rule 1 */\n \t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n@@ -1828,7 +1848,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t{\n \t\t  gcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n \t\t\t      && fde->drap_reg != INVALID_REGNUM\n-\t\t\t      && cur_cfa->reg != dwf_cfa_reg (src)\n+\t\t\t      && cur_cfa->reg != src\n \t\t\t      && fde->rule18);\n \t\t  fde->rule18 = 0;\n \t\t  /* The save of hard frame pointer has been deferred\n@@ -1852,8 +1872,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      /* Adjusting SP.  */\n \t      if (REG_P (XEXP (src, 1)))\n \t\t{\n-\t\t  gcc_assert (dwf_cfa_reg (XEXP (src, 1))\n-\t\t\t      == cur_trace->cfa_temp.reg);\n+\t\t  gcc_assert (cur_trace->cfa_temp.reg == XEXP (src, 1));\n \t\t  offset = cur_trace->cfa_temp.offset;\n \t\t}\n \t      else if (!poly_int_rtx_p (XEXP (src, 1), &offset))\n@@ -1886,7 +1905,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      gcc_assert (frame_pointer_needed);\n \n \t      gcc_assert (REG_P (XEXP (src, 0))\n-\t\t\t  && dwf_cfa_reg (XEXP (src, 0)) == cur_cfa->reg);\n+\t\t\t  && cur_cfa->reg == XEXP (src, 0));\n \t      offset = rtx_to_poly_int64 (XEXP (src, 1));\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n@@ -1899,7 +1918,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n-\t\t  && dwf_cfa_reg (XEXP (src, 0)) == cur_cfa->reg\n+\t\t  && cur_cfa->reg == XEXP (src, 0)\n \t\t  && poly_int_rtx_p (XEXP (src, 1), &offset))\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n@@ -1914,7 +1933,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      /* Rule 5 */\n \t      else if (REG_P (XEXP (src, 0))\n-\t\t       && dwf_cfa_reg (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n+\t\t       && cur_trace->cfa_temp.reg == XEXP (src, 0)\n \t\t       && XEXP (src, 1) == stack_pointer_rtx)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n@@ -1945,7 +1964,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  /* Rule 7 */\n \tcase IOR:\n \t  gcc_assert (REG_P (XEXP (src, 0))\n-\t\t      && dwf_cfa_reg (XEXP (src, 0)) == cur_trace->cfa_temp.reg\n+\t\t      && cur_trace->cfa_temp.reg == XEXP (src, 0)\n \t\t      && CONST_INT_P (XEXP (src, 1)));\n \n \t  cur_trace->cfa_temp.reg = dwf_cfa_reg (dest);\n@@ -1981,7 +2000,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      dwarf2out_flush_queued_reg_saves ();\n \n               gcc_assert (cur_trace->cfa_store.reg\n-\t\t\t  == dwf_cfa_reg (XEXP (src, 0)));\n+\t\t\t  == XEXP (src, 0));\n               fde->stack_realign = 1;\n               fde->stack_realignment = INTVAL (XEXP (src, 1));\n               cur_trace->cfa_store.offset = 0;\n@@ -2109,8 +2128,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t  /* Rule 14 */\n \tcase POST_INC:\n-\t  gcc_assert (cur_trace->cfa_temp.reg\n-\t\t      == dwf_cfa_reg (XEXP (XEXP (dest, 0), 0)));\n+\t  gcc_assert (cur_trace->cfa_temp.reg == XEXP (XEXP (dest, 0), 0));\n \t  offset = -cur_trace->cfa_temp.offset;\n \t  cur_trace->cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n \t  break;\n@@ -2128,7 +2146,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n       if (REG_P (src)\n \t  && REGNO (src) != STACK_POINTER_REGNUM\n \t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n-\t  && dwf_cfa_reg (src) == cur_cfa->reg)\n+\t  && cur_cfa->reg == src)\n \t{\n \t  /* We're storing the current CFA reg into the stack.  */\n \n@@ -3210,8 +3228,7 @@ create_cie_data (void)\n   dw_cfa_location loc;\n   dw_trace_info cie_trace;\n \n-  dw_stack_pointer_regnum = dwf_cfa_reg (gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t      STACK_POINTER_REGNUM));\n+  dw_stack_pointer_regnum = dwf_cfa_reg (stack_pointer_rtx);\n \n   memset (&cie_trace, 0, sizeof (cie_trace));\n   cur_trace = &cie_trace;\n@@ -3270,8 +3287,7 @@ static unsigned int\n execute_dwarf2_frame (void)\n {\n   /* Different HARD_FRAME_POINTER_REGNUM might coexist in the same file.  */\n-  dw_frame_pointer_regnum\n-    = dwf_cfa_reg (gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM));\n+  dw_frame_pointer_regnum = dwf_cfa_reg (hard_frame_pointer_rtx);\n \n   /* The first time we're called, compute the incoming frame state.  */\n   if (cie_cfi_vec == NULL)"}]}