{"sha": "e7208389c8381feaf8c7c60d975b06c446978006", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcyMDgzODljODM4MWZlYWY4YzdjNjBkOTc1YjA2YzQ0Njk3ODAwNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-12T06:52:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-06-12T06:52:55Z"}, "message": "gcc.c: Document new %@{...} sequence.\n\n\t* gcc.c: Document new %@{...} sequence.\n\t(LINK_COMMAND_SPEC): Use it for the -L switches.\n\t(cpp_unique_options): Use it for the -I switches.\n\t(at_file_argbuf): New global variable.\n\t(in_at_file): Likewise.\n\t(alloc_args): Create at_file_argbuf.\n\t(clear_args): Truncate at_file_argbuf.\n\t(store_arg): If in_at_file, push the argument onto at_file_argbuf.\n\t(open_at_file): New function.\n\t(close_at_file): Likewise.\n\t(create_at_file): Delete.\n\t(do_spec_1) <'i'>: Use open_at_file/close_at_file.\n\t<'o'>: Likewise.\n\t<'@'>: New case.\n\t(validate_switches_from_spec): Deal with %@{...} sequence.\n\t(validate_switches): Likewise.\n\t(driver::finalize): Call clear_args.\n\nFrom-SVN: r261474", "tree": {"sha": "8c49fe34a426b41b89f2e74730e877035217085a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c49fe34a426b41b89f2e74730e877035217085a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7208389c8381feaf8c7c60d975b06c446978006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7208389c8381feaf8c7c60d975b06c446978006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7208389c8381feaf8c7c60d975b06c446978006", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7208389c8381feaf8c7c60d975b06c446978006/comments", "author": null, "committer": null, "parents": [{"sha": "bfad8f66406ce515ee02ca38ec38cc890011f416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfad8f66406ce515ee02ca38ec38cc890011f416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfad8f66406ce515ee02ca38ec38cc890011f416"}], "stats": {"total": 263, "additions": 150, "deletions": 113}, "files": [{"sha": "9c9087575e47de470d33f7d8ae59b2ae5876a39b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7208389c8381feaf8c7c60d975b06c446978006/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7208389c8381feaf8c7c60d975b06c446978006/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7208389c8381feaf8c7c60d975b06c446978006", "patch": "@@ -1,3 +1,23 @@\n+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c: Document new %@{...} sequence.\n+\t(LINK_COMMAND_SPEC): Use it for the -L switches.\n+\t(cpp_unique_options): Use it for the -I switches.\n+\t(at_file_argbuf): New global variable.\n+\t(in_at_file): Likewise.\n+\t(alloc_args): Create at_file_argbuf.\n+\t(clear_args): Truncate at_file_argbuf.\n+\t(store_arg): If in_at_file, push the argument onto at_file_argbuf.\n+\t(open_at_file): New function.\n+\t(close_at_file): Likewise.\n+\t(create_at_file): Delete.\n+\t(do_spec_1) <'i'>: Use open_at_file/close_at_file.\n+\t<'o'>: Likewise.\n+\t<'@'>: New case.\n+\t(validate_switches_from_spec): Deal with %@{...} sequence.\n+\t(validate_switches): Likewise.\n+\t(driver::finalize): Call clear_args.\n+\n 2018-06-11  Rasmus Villemoes  <rasmus.villemoes@prevas.dk>\n \n \t* config/vx-common.h (USE_TM_CLONE_REGISTRY): #define to 0."}, {"sha": "405d2e38d446c79eeb928f8549d7c7e1a267c02a", "filename": "gcc/gcc.c", "status": "modified", "additions": 130, "deletions": 113, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7208389c8381feaf8c7c60d975b06c446978006/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7208389c8381feaf8c7c60d975b06c446978006/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=e7208389c8381feaf8c7c60d975b06c446978006", "patch": "@@ -476,8 +476,11 @@ or with constant text in a single argument.\n \tinto the sequence of arguments that %o will substitute later.\n  %V\tindicates that this compilation produces no \"output file\".\n  %W{...}\n-\tlike %{...} but mark last argument supplied within\n-\tas a file to be deleted on failure.\n+\tlike %{...} but marks the last argument supplied within as a file\n+\tto be deleted on failure.\n+ %@{...}\n+\tlike %{...} but puts the result into a FILE and substitutes @FILE\n+\tif an @file argument has been supplied.\n  %o\tsubstitutes the names of all the output files, with spaces\n \tautomatically placed around them.  You should write spaces\n \taround the %o as well or the results are undefined.\n@@ -1034,7 +1037,7 @@ proper position among the other output files.  */\n    \"%{fuse-ld=*:-fuse-ld=%*} \" LINK_COMPRESS_DEBUG_SPEC \\\n    \"%X %{o*} %{e*} %{N} %{n} %{r}\\\n     %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}} \\\n-    %{static|no-pie|static-pie:} %{L*} %(mfwrap) %(link_libgcc) \" \\\n+    %{static|no-pie|static-pie:} %@{L*} %(mfwrap) %(link_libgcc) \" \\\n     VTABLE_VERIFICATION_SPEC \" \" SANITIZER_EARLY_SPEC \" %o \"\" \\\n     %{fopenacc|fopenmp|%:gt(%{ftree-parallelize-loops=*:%*} 1):\\\n \t%:include(libgomp.spec)%(link_gomp)}\\\n@@ -1109,7 +1112,7 @@ static const char *trad_capable_cpp =\n    therefore no dependency entry, confuses make into thinking a .o\n    file that happens to exist is up-to-date.  */\n static const char *cpp_unique_options =\n-\"%{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I\\\n+\"%{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %@{I*&F*} %{P} %I\\\n  %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\\\n@@ -1924,9 +1927,14 @@ set_spec (const char *name, const char *spec, bool user_p)\n typedef const char *const_char_p; /* For DEF_VEC_P.  */\n \n /* Vector of pointers to arguments in the current line of specifications.  */\n-\n static vec<const_char_p> argbuf;\n \n+/* Likewise, but for the current @file.  */\n+static vec<const_char_p> at_file_argbuf;\n+\n+/* Whether an @file is currently open.  */\n+static bool in_at_file = false;\n+\n /* Were the options -c, -S or -E passed.  */\n static int have_c = 0;\n \n@@ -1966,6 +1974,7 @@ static void\n alloc_args (void)\n {\n   argbuf.create (10);\n+  at_file_argbuf.create (10);\n }\n \n /* Clear out the vector of arguments (after a command is executed).  */\n@@ -1974,6 +1983,7 @@ static void\n clear_args (void)\n {\n   argbuf.truncate (0);\n+  at_file_argbuf.truncate (0);\n }\n \n /* Add one argument to the vector at the end.\n@@ -1986,7 +1996,10 @@ clear_args (void)\n static void\n store_arg (const char *arg, int delete_always, int delete_failure)\n {\n-  argbuf.safe_push (arg);\n+  if (in_at_file)\n+    at_file_argbuf.safe_push (arg);\n+  else\n+    argbuf.safe_push (arg);\n \n   if (delete_always || delete_failure)\n     {\n@@ -1999,6 +2012,67 @@ store_arg (const char *arg, int delete_always, int delete_failure)\n       record_temp_file (arg, delete_always, delete_failure);\n     }\n }\n+\n+/* Open a temporary @file into which subsequent arguments will be stored.  */\n+\n+static void\n+open_at_file (void)\n+{\n+   if (in_at_file)\n+     fatal_error (input_location, \"cannot open nested response file\");\n+   else\n+     in_at_file = true;\n+}\n+\n+/* Close the temporary @file and add @file to the argument list.  */\n+\n+static void\n+close_at_file (void)\n+{\n+  if (!in_at_file)\n+    fatal_error (input_location, \"cannot close nonexistent response file\");\n+\n+  in_at_file = false;\n+\n+  const unsigned int n_args = at_file_argbuf.length ();\n+  if (n_args == 0)\n+    return;\n+\n+  char **argv = (char **) alloca (sizeof (char *) * (n_args + 1));\n+  char *temp_file = make_temp_file (\"\");\n+  char *at_argument = concat (\"@\", temp_file, NULL);\n+  FILE *f = fopen (temp_file, \"w\");\n+  int status;\n+  unsigned int i;\n+\n+  /* Copy the strings over.  */\n+  for (i = 0; i < n_args; i++)\n+    argv[i] = CONST_CAST (char *, at_file_argbuf[i]);\n+  argv[i] = NULL;\n+\n+  at_file_argbuf.truncate (0);\n+\n+  if (f == NULL)\n+    fatal_error (input_location, \"could not open temporary response file %s\",\n+\t\t temp_file);\n+\n+  status = writeargv (argv, f);\n+\n+  if (status)\n+    fatal_error (input_location,\n+\t\t \"could not write to temporary response file %s\",\n+\t\t temp_file);\n+\n+  status = fclose (f);\n+\n+  if (status == EOF)\n+    fatal_error (input_location, \"could not close temporary response file %s\",\n+\t\t temp_file);\n+\n+  store_arg (at_argument, 0, 0);\n+\n+  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);\n+}\n \f\n /* Load specs from a file name named FILENAME, replacing occurrences of\n    various different types of line-endings, \\r\\n, \\n\\r and just \\r, with\n@@ -5081,39 +5155,6 @@ spec_path (char *path, void *data)\n   return NULL;\n }\n \n-/* Create a temporary FILE with the contents of ARGV. Add @FILE to the\n-   argument list. */\n-\n-static void\n-create_at_file (char **argv)\n-{\n-  char *temp_file = make_temp_file (\"\");\n-  char *at_argument = concat (\"@\", temp_file, NULL);\n-  FILE *f = fopen (temp_file, \"w\");\n-  int status;\n-\n-  if (f == NULL)\n-    fatal_error (input_location, \"could not open temporary response file %s\",\n-\t\t temp_file);\n-\n-  status = writeargv (argv, f);\n-\n-  if (status)\n-    fatal_error (input_location,\n-\t\t \"could not write to temporary response file %s\",\n-\t\t temp_file);\n-\n-  status = fclose (f);\n-\n-  if (EOF == status)\n-    fatal_error (input_location, \"could not close temporary response file %s\",\n-\t\t temp_file);\n-\n-  store_arg (at_argument, 0, 0);\n-\n-  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);\n-}\n-\n /* True if we should compile INFILE. */\n \n static bool\n@@ -5526,41 +5567,22 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t  case 'i':\n \t    if (combine_inputs)\n \t      {\n+\t\t/* We are going to expand `%i' into `@FILE', where FILE\n+\t\t   is a newly-created temporary filename.  The filenames\n+\t\t   that would usually be expanded in place of %o will be\n+\t\t   written to the temporary file.  */\n \t\tif (at_file_supplied)\n-\t\t  {\n-\t\t    /* We are going to expand `%i' to `@FILE', where FILE\n-\t\t       is a newly-created temporary filename.  The filenames\n-\t\t       that would usually be expanded in place of %o will be\n-\t\t       written to the temporary file.  */\n-\t\t    char **argv;\n-\t\t    int n_files = 0;\n-\t\t    int j;\n-\n-\t\t    for (i = 0; i < n_infiles; i++)\n-\t\t      if (compile_input_file_p (&infiles[i]))\n-\t\t\tn_files++;\n-\n-\t\t    argv = (char **) alloca (sizeof (char *) * (n_files + 1));\n-\n-\t\t    /* Copy the strings over.  */\n-\t\t    for (i = 0, j = 0; i < n_infiles; i++)\n-\t\t      if (compile_input_file_p (&infiles[i]))\n-\t\t\t{\n-\t\t\t  argv[j] = CONST_CAST (char *, infiles[i].name);\n-\t\t\t  infiles[i].compiled = true;\n-\t\t\t  j++;\n-\t\t\t}\n-\t\t    argv[j] = NULL;\n+\t\t  open_at_file ();\n \n-\t\t    create_at_file (argv);\n-\t\t  }\n-\t\telse\n-\t\t  for (i = 0; (int) i < n_infiles; i++)\n-\t\t    if (compile_input_file_p (&infiles[i]))\n-\t\t      {\n-\t\t\tstore_arg (infiles[i].name, 0, 0);\n-\t\t\tinfiles[i].compiled = true;\n-\t\t      }\n+\t\tfor (i = 0; (int) i < n_infiles; i++)\n+\t\t  if (compile_input_file_p (&infiles[i]))\n+\t\t    {\n+\t\t      store_arg (infiles[i].name, 0, 0);\n+\t\t      infiles[i].compiled = true;\n+\t\t    }\n+\n+\t\tif (at_file_supplied)\n+\t\t  close_at_file ();\n \t      }\n \t    else\n \t      {\n@@ -5633,45 +5655,20 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t    break;\n \n \t  case 'o':\n-\t    {\n-\t      int max = n_infiles;\n-\t      max += lang_specific_extra_outfiles;\n-\n-              if (HAVE_GNU_LD && at_file_supplied)\n-                {\n-                  /* We are going to expand `%o' to `@FILE', where FILE\n-                     is a newly-created temporary filename.  The filenames\n-                     that would usually be expanded in place of %o will be\n-                     written to the temporary file.  */\n-\n-                  char **argv;\n-                  int n_files, j;\n-\n-                  /* Convert OUTFILES into a form suitable for writeargv.  */\n-\n-                  /* Determine how many are non-NULL.  */\n-                  for (n_files = 0, i = 0; i < max; i++)\n-                    n_files += outfiles[i] != NULL;\n-\n-                  argv = (char **) alloca (sizeof (char *) * (n_files + 1));\n-\n-                  /* Copy the strings over.  */\n-                  for (i = 0, j = 0; i < max; i++)\n-                    if (outfiles[i])\n-                      {\n-                        argv[j] = CONST_CAST (char *, outfiles[i]);\n-                        j++;\n-                      }\n-                  argv[j] = NULL;\n-\n-\t\t  create_at_file (argv);\n-                }\n-              else\n-                for (i = 0; i < max; i++)\n-\t          if (outfiles[i])\n-\t\t    store_arg (outfiles[i], 0, 0);\n-\t      break;\n-\t    }\n+\t    /* We are going to expand `%o' into `@FILE', where FILE\n+\t       is a newly-created temporary filename.  The filenames\n+\t       that would usually be expanded in place of %o will be\n+\t       written to the temporary file.  */\n+\t    if (at_file_supplied)\n+\t      open_at_file ();\n+\n+\t    for (i = 0; i < n_infiles + lang_specific_extra_outfiles; i++)\n+\t      if (outfiles[i])\n+\t\tstore_arg (outfiles[i], 0, 0);\n+\n+\t    if (at_file_supplied)\n+\t      close_at_file ();\n+\t    break;\n \n \t  case 'O':\n \t    obstack_grow (&obstack, TARGET_OBJECT_SUFFIX, strlen (TARGET_OBJECT_SUFFIX));\n@@ -5712,6 +5709,20 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      break;\n \t    }\n \n+\t  case '@':\n+\t    /* Handle the {...} following the %@.  */\n+\t    if (*p != '{')\n+\t      fatal_error (input_location,\n+\t\t\t   \"spec %qs has invalid %<%%@%c%>\", spec, *p);\n+\t    if (at_file_supplied)\n+\t      open_at_file ();\n+\t    p = handle_braces (p + 1);\n+\t    if (at_file_supplied)\n+\t      close_at_file ();\n+\t    if (p == 0)\n+\t      return -1;\n+\t    break;\n+\n \t  /* %x{OPTION} records OPTION for %X to output.  */\n \t  case 'x':\n \t    {\n@@ -8501,7 +8512,11 @@ validate_switches_from_spec (const char *spec, bool user)\n   const char *p = spec;\n   char c;\n   while ((c = *p++))\n-    if (c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{')))\n+    if (c == '%'\n+\t&& (*p == '{'\n+\t    || *p == '<'\n+\t    || (*p == 'W' && *++p == '{')\n+\t    || (*p == '@' && *++p == '{')))\n       /* We have a switch spec.  */\n       p = validate_switches (p + 1, user);\n }\n@@ -8583,6 +8598,8 @@ validate_switches (const char *start, bool user_spec)\n \t\tp = validate_switches (p+1, user_spec);\n \t      else if (p[0] == 'W' && p[1] == '{')\n \t\tp = validate_switches (p+2, user_spec);\n+\t      else if (p[0] == '@' && p[1] == '{')\n+\t\tp = validate_switches (p+2, user_spec);\n \t    }\n \t  else\n \t    p++;\n@@ -10141,7 +10158,7 @@ driver::finalize ()\n \n   processing_spec_function = 0;\n \n-  argbuf.truncate (0);\n+  clear_args ();\n \n   have_c = 0;\n   have_o = 0;"}]}