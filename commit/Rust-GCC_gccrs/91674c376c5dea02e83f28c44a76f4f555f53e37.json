{"sha": "91674c376c5dea02e83f28c44a76f4f555f53e37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2NzRjMzc2YzVkZWEwMmU4M2YyOGM0NGE3NmY0ZjU1NWY1M2UzNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-01-24T21:43:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-01-24T21:43:41Z"}, "message": "Garbage collect constant pool entries and don't output unnecessary ones\n\nFrom-SVN: r13550", "tree": {"sha": "d4636a6890102984b597b02aeb965528e9cad529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4636a6890102984b597b02aeb965528e9cad529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91674c376c5dea02e83f28c44a76f4f555f53e37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91674c376c5dea02e83f28c44a76f4f555f53e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91674c376c5dea02e83f28c44a76f4f555f53e37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91674c376c5dea02e83f28c44a76f4f555f53e37/comments", "author": null, "committer": null, "parents": [{"sha": "38734e55b348c29115121efadb90275d3f150e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38734e55b348c29115121efadb90275d3f150e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38734e55b348c29115121efadb90275d3f150e81"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "1bf3e5104e6d6b82bb5f6b80ac0f986b1120c8fb", "filename": "gcc/varasm.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91674c376c5dea02e83f28c44a76f4f555f53e37/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91674c376c5dea02e83f28c44a76f4f555f53e37/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=91674c376c5dea02e83f28c44a76f4f555f53e37", "patch": "@@ -143,6 +143,8 @@ static int compare_constant_rtx\t\tPROTO((enum machine_mode, rtx,\n static struct constant_descriptor *record_constant_rtx PROTO((enum machine_mode,\n \t\t\t\t\t\t\t      rtx));\n static struct pool_constant *find_pool_constant PROTO((rtx));\n+static void mark_constant_pool\t\tPROTO((void));\n+static void mark_constants\t\tPROTO((rtx));\n static int output_addressed_constants\tPROTO((tree));\n static void output_after_function_constants PROTO((void));\n static void bc_assemble_integer\t\tPROTO((tree, int));\n@@ -3116,6 +3118,7 @@ struct pool_constant\n   int labelno;\n   int align;\n   int offset;\n+  int mark;\n };\n \n /* Pointers to first and last constant in pool.  */\n@@ -3483,6 +3486,7 @@ force_const_mem (mode, x)\n       pool->labelno = const_labelno;\n       pool->align = align;\n       pool->offset = pool_offset;\n+      pool->mark = 0;\n       pool->next = 0;\n \n       if (last_pool == 0)\n@@ -3596,6 +3600,12 @@ output_constant_pool (fnname, fndecl)\n   rtx x;\n   union real_extract u;\n \n+  /* It is possible for gcc to call force_const_mem and then to later\n+     discard the instructions which refer to the constant.  In such a\n+     case we do not need to output the constant.  */\n+  if (flag_expensive_optimizations)\n+    mark_constant_pool ();\n+\n #ifdef ASM_OUTPUT_POOL_PROLOGUE\n   ASM_OUTPUT_POOL_PROLOGUE (asm_out_file, fnname, fndecl, pool_offset);\n #endif\n@@ -3604,6 +3614,9 @@ output_constant_pool (fnname, fndecl)\n     {\n       x = pool->constant;\n \n+      if (flag_expensive_optimizations && ! pool->mark)\n+\tcontinue;\n+\n       /* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF)\n \t whose CODE_LABEL has been deleted.  This can occur if a jump table\n \t is eliminated by optimization.  If so, write a constant of zero\n@@ -3666,6 +3679,89 @@ output_constant_pool (fnname, fndecl)\n   /* Done with this pool.  */\n   first_pool = last_pool = 0;\n }\n+\n+/* Look through the instructions for this function, and mark all the\n+   entries in the constant pool which are actually being used.  */\n+\n+static void\n+mark_constant_pool ()\n+{\n+  register rtx insn;\n+\n+  if (first_pool == 0)\n+    return;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      mark_constants (PATTERN (insn));\n+\n+  for (insn = current_function_epilogue_delay_list;\n+       insn;\n+       insn = XEXP (insn, 1))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      mark_constants (PATTERN (insn));\n+}\n+\n+static void\n+mark_constants (x)\n+     register rtx x;\n+{\n+  register int i;\n+  register char *format_ptr;\n+\n+  if (x == 0)\n+    return;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      if (CONSTANT_POOL_ADDRESS_P (x))\n+\tfind_pool_constant (x)->mark = 1;\n+      return;\n+    }\n+\n+  /* Insns may appear inside a SEQUENCE.  Only check the patterns of\n+     insns, not any notes that may be attached.  We don't want to mark\n+     a constant just because it happens to appear in a REG_EQUIV note.  */\n+  if (GET_RTX_CLASS (GET_CODE (x)) == 'i')\n+    {\n+      mark_constants (PATTERN (x));\n+      return;\n+    }\n+\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (x));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  mark_constants (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  if (XVEC (x, i) != 0)\n+\t    {\n+\t      register int j;\n+\n+\t      for (j = 0; j < XVECLEN (x, i); j++)\n+\t\tmark_constants (XVECEXP (x, i, j));\n+\t    }\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\tcase '0':\n+\tcase 'i':\n+\tcase 'w':\n+\tcase 'n':\n+\tcase 'u':\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+}\n \f\n /* Find all the constants whose addresses are referenced inside of EXP,\n    and make sure assembler code with a label has been output for each one."}]}