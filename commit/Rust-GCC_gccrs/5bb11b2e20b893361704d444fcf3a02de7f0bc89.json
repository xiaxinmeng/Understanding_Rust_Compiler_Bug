{"sha": "5bb11b2e20b893361704d444fcf3a02de7f0bc89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiMTFiMmUyMGI4OTMzNjE3MDRkNDQ0ZmNmM2EwMmRlN2YwYmM4OQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-01-08T23:28:56Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-01-08T23:28:56Z"}, "message": "In gcc/java:\n\n\t* class.c (make_class_data): Push initial value for \"arrayclass\".\n\t* decl.c (init_decl_processing): Add new class field \"arrayclass\".\n\nIn libjava:\n\t* java/lang/Class.h (_Jv_InitClass): Use __builtin_expect.\n\t(_Jv_NewArrayClass): Renamed from _Jv_FindArrayClass.\n\t(_Jv_GetArrayClass): New inline function.\n\t(arrayclass): New field.\n\t* prims.cc (_Jv_NewObjectArray): Use _Jv_GetArrayClass. Don't use\n\t_Jv_GetArrayElementFromElementType.\n\t(_Jv_NewPrimArray): Ditto.\n\t(_Jv_PrimClass constructor): Initialize \"depth\", \"ancestors\", and\n\t\"idt\" for completeness. Initialze \"arrayclass\" using _Jv_NewArrayClass.\n\tSet Modifier::ABSTRACT.\n\t* java/lang/natClassLoader.cc (_Jv_NewClass): Initialize \"arrayclass\".\n\t(_Jv_NewArrayClass): Renamed from _Jv_FindArrayClass. Now void.\n\tNow synchronized. Array classes are now referenced from\n\telementClass->arrayclass. Don't use _Jv_FindClassInCache.\n\tSet array classes' accessibility flags correctly. Optimize so that\n\tall array classes share the same IDT.\n\t* java/lang/reflect/natArray.cc (newInstance): Use _Jv_GetArrayClass.\n\t* java/lang/reflect/natMethod.cc (_Jv_GetTypesFromSignature): Ditto.\n\t* java/lang/natClass.cc (_getFields): Increment offset. Prevent fields\n\tin superclasses from overwriting classes own fields.\n\t(_Jv_IsAssignableFrom): Check for NULL source idt instead of calling\n\tModifier::isAbstract().\n\t(null_idt): New static field.\n\t(_Jv_PrepareConstantTimeTables): Optimize case where class implements\n\tno interfaces.\n\t(_Jv_IndexOf): Made inline.\n\t* boehm.cc (_Jv_MarkObj): Mark \"arrayclass\" field.\n\nFrom-SVN: r38808", "tree": {"sha": "be919e8f9daa4b9caa6045e085c18aa82e8c4a09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be919e8f9daa4b9caa6045e085c18aa82e8c4a09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bb11b2e20b893361704d444fcf3a02de7f0bc89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb11b2e20b893361704d444fcf3a02de7f0bc89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb11b2e20b893361704d444fcf3a02de7f0bc89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb11b2e20b893361704d444fcf3a02de7f0bc89/comments", "author": null, "committer": null, "parents": [{"sha": "5bab9296f5a87f0bf7c8785b87d92db9a3b5ecf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bab9296f5a87f0bf7c8785b87d92db9a3b5ecf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bab9296f5a87f0bf7c8785b87d92db9a3b5ecf9"}], "stats": {"total": 266, "additions": 173, "deletions": 93}, "files": [{"sha": "ebf96fac18fd68434d962d603a4961e3ded631a1", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -1,3 +1,8 @@\n+2001-01-05  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* class.c (make_class_data): Push initial value for \"arrayclass\".\n+\t* decl.c (init_decl_processing): Add new class field \"arrayclass\".\n+\n 2001-01-05  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \tFrom patha@softlab.ericsson.se:"}, {"sha": "ae715f14efcac4fdf3ff67cad944aa9f3d68a299", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -1441,6 +1441,7 @@ make_class_data (type)\n   PUSH_FIELD_VALUE (cons, \"depth\", integer_zero_node);\n   PUSH_FIELD_VALUE (cons, \"ancestors\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"idt\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"arrayclass\", null_pointer_node);\n \n   FINISH_RECORD_CONSTRUCTOR (cons);\n "}, {"sha": "8d7887809e9511de76341eeb0d3bf5eabcd0769c", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -672,6 +672,7 @@ init_decl_processing ()\n   PUSH_FIELD (class_type_node, field, \"depth\", short_type_node);\n   PUSH_FIELD (class_type_node, field, \"ancestors\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"idt\", ptr_type_node);  \n+  PUSH_FIELD (class_type_node, field, \"arrayclass\", ptr_type_node);  \n   for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);"}, {"sha": "42421be56dab0992c7143ddcaba0c027640f2907", "filename": "libjava/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -1,3 +1,33 @@\n+2001-01-08  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/lang/Class.h (_Jv_InitClass): Use __builtin_expect.\n+\t(_Jv_NewArrayClass): Renamed from _Jv_FindArrayClass.\n+\t(_Jv_GetArrayClass): New inline function.\n+\t(arrayclass): New field.\n+\t* prims.cc (_Jv_NewObjectArray): Use _Jv_GetArrayClass. Don't use\n+\t_Jv_GetArrayElementFromElementType. \n+\t(_Jv_NewPrimArray): Ditto.\n+\t(_Jv_PrimClass constructor): Initialize \"depth\", \"ancestors\", and\n+\t\"idt\" for completeness. Initialze \"arrayclass\" using _Jv_NewArrayClass.\n+\tSet Modifier::ABSTRACT.\n+\t* java/lang/natClassLoader.cc (_Jv_NewClass): Initialize \"arrayclass\".\n+\t(_Jv_NewArrayClass): Renamed from _Jv_FindArrayClass. Now void. \n+\tNow synchronized. Array classes are now referenced from\n+\telementClass->arrayclass. Don't use _Jv_FindClassInCache.\n+\tSet array classes' accessibility flags correctly. Optimize so that\n+\tall array classes share the same IDT.\n+\t* java/lang/reflect/natArray.cc (newInstance): Use _Jv_GetArrayClass.\n+\t* java/lang/reflect/natMethod.cc (_Jv_GetTypesFromSignature): Ditto.\n+\t* java/lang/natClass.cc (_getFields): Increment offset. Prevent fields\n+\tin superclasses from overwriting classes own fields.\n+\t(_Jv_IsAssignableFrom): Check for NULL source idt instead of calling\n+\tModifier::isAbstract().\n+\t(null_idt): New static field.\n+\t(_Jv_PrepareConstantTimeTables): Optimize case where class implements\n+\tno interfaces.\n+\t(_Jv_IndexOf): Made inline.\n+\t* boehm.cc (_Jv_MarkObj): Mark \"arrayclass\" field.\n+\n 2001-01-08  Tom Tromey  <tromey@redhat.com>\n \n \tFix for PR java/1586:"}, {"sha": "49b4eab27fde9e7ea4de877384e511f667eaa942", "filename": "libjava/boehm.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -225,6 +225,8 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n \t}\n       p = (ptr_t) c->loader;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n+      p = (ptr_t) c->arrayclass;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cDlabel);\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))"}, {"sha": "12e3ed5838fb32d083b5cde636df8ca1d8ac6c45", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -210,7 +210,7 @@ class java::lang::Class : public java::lang::Object\n   inline friend void \n   _Jv_InitClass (jclass klass)\n   {\n-    if (klass->state == JV_STATE_DONE)\n+    if (__builtin_expect (klass->state == JV_STATE_DONE, true))\n       return;\n     klass->initializeClass ();  \n   }\n@@ -254,9 +254,9 @@ class java::lang::Class : public java::lang::Object\n \t\t\t       java::lang::ClassLoader *loader);\n   friend jclass _Jv_FindClassInCache (_Jv_Utf8Const *name,\n \t\t\t\t      java::lang::ClassLoader *loader);\n-  friend jclass _Jv_FindArrayClass (jclass element,\n-\t\t\t\t    java::lang::ClassLoader *loader,\n-\t\t\t\t    _Jv_VTable *array_vtable = 0);\n+  friend void _Jv_NewArrayClass (jclass element,\n+\t\t\t\t java::lang::ClassLoader *loader,\n+\t\t\t\t _Jv_VTable *array_vtable = 0);\n   friend jclass _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n \t\t\t      java::lang::ClassLoader *loader);\n \n@@ -268,6 +268,16 @@ class java::lang::Class : public java::lang::Object\n   friend jshort _Jv_AppendPartialITable (jclass, jclass, void **, jshort);\n   friend jshort _Jv_FindIIndex (jclass *, jshort *, jshort);\n \n+  // Return array class corresponding to element type KLASS, creating it if\n+  // neccessary.\n+  inline friend jclass\n+  _Jv_GetArrayClass (jclass klass, java::lang::ClassLoader *loader)\n+  {\n+    if (__builtin_expect (!klass->arrayclass, false))\n+      _Jv_NewArrayClass (klass, loader);\n+    return klass->arrayclass;\n+  }\n+\n #ifdef INTERPRETER\n   friend jboolean _Jv_IsInterpretedClass (jclass);\n   friend void _Jv_InitField (jobject, jclass, _Jv_Field*);\n@@ -302,8 +312,7 @@ class java::lang::Class : public java::lang::Object\n   // Class constants.\n   _Jv_Constants constants;\n   // Methods.  If this is an array class, then this field holds a\n-  // pointer to the element type.  If this is a primitive class, this\n-  // is used to cache a pointer to the appropriate array type.\n+  // pointer to the element type.\n   _Jv_Method *methods;\n   // Number of methods.  If this class is primitive, this holds the\n   // character used to represent this type in a signature.\n@@ -337,6 +346,8 @@ class java::lang::Class : public java::lang::Object\n   jclass *ancestors;\n   // Interface Dispatch Table.\n   _Jv_IDispatchTable *idt;\n+  // Pointer to the class that represents an array of this class.\n+  jclass arrayclass;\n };\n \n #endif /* __JAVA_LANG_CLASS_H__ */"}, {"sha": "3a02b46a8af9b9c5ad93748c2fd3600019a8c41b", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -421,7 +421,7 @@ java::lang::Class::_getFields (JArray<java::lang::reflect::Field *> *result,\n \t  rfield->offset = (char *) field - (char *) fields;\n \t  rfield->declaringClass = this;\n \t  rfield->name = _Jv_NewStringUtf8Const (field->name);\n-\t  (elements (result))[offset + i] = rfield;\n+\t  (elements (result))[offset++] = rfield;\n \t}\n     }\n   jclass superclass = getSuperclass();\n@@ -929,8 +929,7 @@ _Jv_IsAssignableFrom (jclass target, jclass source)\n       // Abstract classes have no IDT, and IDTs provide no way to check\n       // two interfaces for assignability.\n       if (__builtin_expect \n-         (java::lang::reflect::Modifier::isAbstract (source->accflags)\n-          || source->isInterface(), false))\n+          (source->idt == NULL || source->isInterface(), false))\n         return _Jv_InterfaceAssignableFrom (target, source);\n \t\n       _Jv_IDispatchTable *cl_idt = source->idt;\n@@ -1007,6 +1006,8 @@ _Jv_CheckArrayStore (jobject arr, jobject obj)\n #define INITIAL_IOFFSETS_LEN 4\n #define INITIAL_IFACES_LEN 4\n \n+static _Jv_IDispatchTable null_idt = { {SHRT_MAX, 0, NULL} };\n+\n // Generate tables for constant-time assignment testing and interface\n // method lookup. This implements the technique described by Per Bothner\n // <per@bothner.com> on the java-discuss mailing list on 1999-09-02:\n@@ -1028,8 +1029,10 @@ _Jv_PrepareConstantTimeTables (jclass klass)\n   // interfaces or primitive types.\n    \n   jclass klass0 = klass;\n+  jboolean has_interfaces = 0;\n   while (klass0 != &ObjectClass)\n     {\n+      has_interfaces += klass0->interface_count;\n       klass0 = klass0->superclass;\n       klass->depth++;\n     }\n@@ -1051,6 +1054,14 @@ _Jv_PrepareConstantTimeTables (jclass klass)\n     \n   if (java::lang::reflect::Modifier::isAbstract (klass->accflags))\n     return;\n+  \n+  // Optimization: If class implements no interfaces, use a common\n+  // predefined interface table.\n+  if (!has_interfaces)\n+    {\n+      klass->idt = &null_idt;\n+      return;\n+    }\n \n   klass->idt = \n     (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n@@ -1095,7 +1106,7 @@ _Jv_PrepareConstantTimeTables (jclass klass)\n }\n \n // Return index of item in list, or -1 if item is not present.\n-jshort\n+inline jshort\n _Jv_IndexOf (void *item, void **list, jshort list_len)\n {\n   for (int i=0; i < list_len; i++)"}, {"sha": "979de3fc2d684e9affd854f89112da1599b6330f", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 85, "deletions": 65, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -530,34 +530,43 @@ _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n   ret->depth = 0;\n   ret->ancestors = NULL;\n   ret->idt = NULL;\n+  ret->arrayclass = NULL;\n \n   _Jv_RegisterClass (ret);\n \n   return ret;\n }\n \n-jclass\n-_Jv_FindArrayClass (jclass element, java::lang::ClassLoader *loader,\n-\t\t    _Jv_VTable *array_vtable)\n+static _Jv_IDispatchTable *array_idt = NULL;\n+static jshort array_depth = 0;\n+static jclass *array_ancestors = NULL;\n+\n+// Create a class representing an array of ELEMENT and store a pointer to it\n+// in element->arrayclass. LOADER is the ClassLoader which _initiated_ the \n+// instantiation of this array. ARRAY_VTABLE is the vtable to use for the new \n+// array class. This parameter is optional.\n+void\n+_Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n+\t\t   _Jv_VTable *array_vtable)\n {\n+  JvSynchronize sync (element);\n+\n   _Jv_Utf8Const *array_name;\n   int len;\n+\n+  if (element->arrayclass)\n+    return;\n+\n   if (element->isPrimitive())\n-    {\n-      // For primitive types the array is cached in the class.\n-      jclass ret = (jclass) element->methods;\n-      if (ret)\n-\treturn ret;\n-      len = 3;\n-    }\n+    len = 3;\n   else\n     len = element->name->length + 5;\n \n   {\n     char signature[len];\n     int index = 0;\n     signature[index++] = '[';\n-    // Compute name of array class to see if we've already cached it.\n+    // Compute name of array class.\n     if (element->isPrimitive())\n       {\n \tsignature[index++] = (char) element->method_count;\n@@ -576,65 +585,76 @@ _Jv_FindArrayClass (jclass element, java::lang::ClassLoader *loader,\n     array_name = _Jv_makeUtf8Const (signature, index);\n   }\n \n-  jclass array_class = _Jv_FindClassInCache (array_name, element->loader);\n-\n-  if (! array_class)\n+  // Create new array class.\n+  jclass array_class = _Jv_NewClass (array_name, &ObjectClass,\n+  \t\t\t\t     element->loader);\n+\n+  // Note that `vtable_method_count' doesn't include the initial\n+  // gc_descr slot.\n+  JvAssert (ObjectClass.vtable_method_count == NUM_OBJECT_METHODS);\n+  int dm_count = ObjectClass.vtable_method_count;\n+\n+  // Create a new vtable by copying Object's vtable (except the\n+  // class pointer, of course).  Note that we allocate this as\n+  // unscanned memory -- the vtables are handled specially by the\n+  // GC.\n+  int size = (sizeof (_Jv_VTable) + ((dm_count - 1) * sizeof (void *)));\n+  _Jv_VTable *vtable;\n+  if (array_vtable)\n+    vtable = array_vtable;\n+  else\n+    vtable = (_Jv_VTable *) _Jv_AllocBytes (size);\n+  vtable->clas = array_class;\n+  memcpy (vtable->method, ObjectClass.vtable->method,\n+\t  dm_count * sizeof (void *));\n+  vtable->gc_descr = ObjectClass.vtable->gc_descr;\n+  array_class->vtable = vtable;\n+  array_class->vtable_method_count = ObjectClass.vtable_method_count;\n+\n+  // Stash the pointer to the element type.\n+  array_class->methods = (_Jv_Method *) element;\n+\n+  // Register our interfaces.\n+  static jclass interfaces[] = { &CloneableClass, &SerializableClass };\n+  array_class->interfaces = interfaces;\n+  array_class->interface_count = sizeof interfaces / sizeof interfaces[0];\n+\n+  // Since all array classes have the same interface dispatch table, we can \n+  // cache one and reuse it. It is not neccessary to synchronize this.\n+  if (!array_idt)\n     {\n-      // Create new array class.\n-      array_class = _Jv_NewClass (array_name, &ObjectClass, element->loader);\n-\n-      // Note that `vtable_method_count' doesn't include the initial\n-      // gc_descr slot.\n-      JvAssert (ObjectClass.vtable_method_count == NUM_OBJECT_METHODS);\n-      int dm_count = ObjectClass.vtable_method_count;\n-\n-      // Create a new vtable by copying Object's vtable (except the\n-      // class pointer, of course).  Note that we allocate this as\n-      // unscanned memory -- the vtables are handled specially by the\n-      // GC.\n-      int size = (sizeof (_Jv_VTable) + ((dm_count - 1) * sizeof (void *)));\n-      _Jv_VTable *vtable;\n-      if (array_vtable)\n-\tvtable = array_vtable;\n-      else\n-\tvtable = (_Jv_VTable *) _Jv_AllocBytes (size);\n-      vtable->clas = array_class;\n-      memcpy (vtable->method, ObjectClass.vtable->method,\n-\t      dm_count * sizeof (void *));\n-      vtable->gc_descr = ObjectClass.vtable->gc_descr;\n-      array_class->vtable = vtable;\n-      array_class->vtable_method_count = ObjectClass.vtable_method_count;\n-\n-      // Stash the pointer to the element type.\n-      array_class->methods = (_Jv_Method *) element;\n-\n-      // Register our interfaces.\n-      static jclass interfaces[] = { &CloneableClass, &SerializableClass };\n-      array_class->interfaces = interfaces;\n-      array_class->interface_count = sizeof interfaces / sizeof interfaces[0];\n-\n-      // FIXME: Shouldn't this be synchronized? _Jv_PrepareConstantTimeTables\n-      // needs to be called with the mutex for array_class held.\n-      // Generate the interface dispatch table.\n       _Jv_PrepareConstantTimeTables (array_class);\n+      array_idt = array_class->idt;\n+      array_depth = array_class->depth;\n+      array_ancestors = array_class->ancestors;\n+    }\n+  else\n+    {\n+      array_class->idt = array_idt;\n+      array_class->depth = array_depth;\n+      array_class->ancestors = array_ancestors;\n+    }\n \n-      // as per vmspec 5.3.3.2\n-      array_class->accflags = element->accflags;\n-\n-      // FIXME: initialize other Class instance variables,\n-      // e.g. `fields'.\n+  using namespace java::lang::reflect;\n+  {\n+    // Array classes are \"abstract final\"...\n+    _Jv_ushort accflags = Modifier::FINAL | Modifier::ABSTRACT;\n+    // ... and inherit accessibility from element type, per vmspec 5.3.3.2\n+    accflags |= (element->accflags & Modifier::PUBLIC);\n+    accflags |= (element->accflags & Modifier::PROTECTED);\n+    accflags |= (element->accflags & Modifier::PRIVATE);      \n+    array_class->accflags = accflags;\n+  }\n \n-      // say this class is initialized and ready to go!\n-      array_class->state = JV_STATE_DONE;\n+  // An array class has no visible instance fields. \"length\" is invisible to \n+  // reflection.\n \n-      // vmspec, section 5.3.3 describes this\n-      if (element->loader != loader)\n-\t_Jv_RegisterInitiatingLoader (array_class, loader);\n-    }\n+  // say this class is initialized and ready to go!\n+  array_class->state = JV_STATE_DONE;\n \n-  // For primitive types, point back at this array.\n-  if (element->isPrimitive())\n-    element->methods = (_Jv_Method *) array_class;\n+  // vmspec, section 5.3.3 describes this\n+  if (element->loader != loader)\n+    _Jv_RegisterInitiatingLoader (array_class, loader);\n \n-  return array_class;\n+  element->arrayclass = array_class;\n }"}, {"sha": "1680456d0b33f5463297d83b3f1d11afecdd1bfb", "filename": "libjava/java/lang/reflect/natArray.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -54,7 +54,7 @@ java::lang::reflect::Array::newInstance (jclass componentType, jintArray dimensi\n   jclass arrayType = componentType;\n   for (int i = 0;  i < ndims;  i++)  // FIXME 2nd arg should \n                                      // be \"current\" loader\n-    arrayType = _Jv_FindArrayClass (arrayType, 0);\n+    arrayType = _Jv_GetArrayClass (arrayType, 0);\n \n   return _Jv_NewMultiArray (arrayType, ndims, dims);\n }"}, {"sha": "4e9d3ceea4ab820f872b0fabf3d32dae2e89c59a", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -286,7 +286,7 @@ _Jv_GetTypesFromSignature (jmethodID method,\n \n       // FIXME: 2'nd argument should be \"current loader\"\n       while (--num_arrays >= 0)\n-\ttype = _Jv_FindArrayClass (type, 0);\n+\ttype = _Jv_GetArrayClass (type, 0);\n       // ARGPTR can be NULL if we are processing the return value of a\n       // call from Constructor.\n       if (argPtr)"}, {"sha": "c4c7316dfcea2d3ce6030ff21ef4cfd48d370a54", "filename": "libjava/prims.cc", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb11b2e20b893361704d444fcf3a02de7f0bc89/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=5bb11b2e20b893361704d444fcf3a02de7f0bc89", "patch": "@@ -394,31 +394,25 @@ _Jv_NewObjectArray (jsize count, jclass elementClass, jobject init)\n \n   JvAssert (! elementClass->isPrimitive ());\n \n+  // Ensure that elements pointer is properly aligned.\n   jobjectArray obj = NULL;\n-  size_t size = (size_t) _Jv_GetArrayElementFromElementType (obj,\n-\t\t\t\t\t\t\t     elementClass);\n-\n-  // Check for overflow.\n-  if (__builtin_expect ((size_t) count > \n-\t\t\t(SIZE_T_MAX - size) / sizeof (jobject), false))\n-    JvThrow (no_memory);\n-\n+  size_t size = (size_t) elements (obj);\n   size += count * sizeof (jobject);\n \n-  // FIXME: second argument should be \"current loader\" //\n-  jclass klass = _Jv_FindArrayClass (elementClass, 0);\n+  // FIXME: second argument should be \"current loader\"\n+  jclass klass = _Jv_GetArrayClass (elementClass, 0);\n \n   obj = (jobjectArray) _Jv_AllocArray (size, klass);\n   if (__builtin_expect (! obj, false))\n     JvThrow (no_memory);\n   // Cast away const.\n   jsize *lp = const_cast<jsize *> (&obj->length);\n   *lp = count;\n-  jobject *ptr = elements(obj);\n   // We know the allocator returns zeroed memory.  So don't bother\n   // zeroing it again.\n   if (init)\n     {\n+      jobject *ptr = elements(obj);\n       while (--count >= 0)\n \t*ptr++ = init;\n     }\n@@ -443,7 +437,7 @@ _Jv_NewPrimArray (jclass eltype, jint count)\n \t\t\t(SIZE_T_MAX - size) / elsize, false))\n     JvThrow (no_memory);\n \n-  jclass klass = _Jv_FindArrayClass (eltype, 0);\n+  jclass klass = _Jv_GetArrayClass (eltype, 0);\n \n   __JArray *arr = (__JArray*) _Jv_AllocObj (size + elsize * count, klass);\n   if (__builtin_expect (! arr, false))\n@@ -529,7 +523,7 @@ class _Jv_PrimClass : public java::lang::Class\n       // the same order they are declared in Class.h.\n       next = NULL;\n       name = _Jv_makeUtf8Const ((char *) cname, -1);\n-      accflags = Modifier::PUBLIC | Modifier::FINAL;\n+      accflags = Modifier::PUBLIC | Modifier::FINAL | Modifier::ABSTRACT;\n       superclass = NULL;\n       constants.size = 0;\n       constants.tags = NULL;\n@@ -547,10 +541,15 @@ class _Jv_PrimClass : public java::lang::Class\n       interface_count = 0;\n       state = JV_STATE_DONE;\n       thread = NULL;\n+      depth = -1;\n+      ancestors = NULL;\n+      idt = NULL;\n \n       // Note that we have to set `methods' to NULL.\n       if (sig != 'V')\n-\t_Jv_FindArrayClass (this, NULL, (_Jv_VTable *) array_vtable);\n+\t_Jv_NewArrayClass (this, NULL, (_Jv_VTable *) array_vtable);\n+      else\n+        arrayclass = NULL;\n     }\n };\n \n@@ -606,8 +605,8 @@ _Jv_FindClassFromSignature (char *sig, java::lang::ClassLoader *loader)\n \n       }\n     case '[':\n-      return _Jv_FindArrayClass (_Jv_FindClassFromSignature (&sig[1], loader),\n-\t\t\t\t loader);\n+      return _Jv_GetArrayClass (_Jv_FindClassFromSignature (&sig[1], loader),\n+\t\t\t\tloader);\n     }\n   JvFail (\"couldn't understand class signature\");\n   return NULL;\t\t\t// Placate compiler."}]}