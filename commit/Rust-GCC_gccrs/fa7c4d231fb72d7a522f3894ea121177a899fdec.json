{"sha": "fa7c4d231fb72d7a522f3894ea121177a899fdec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3YzRkMjMxZmI3MmQ3YTUyMmYzODk0ZWExMjExNzdhODk5ZmRlYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-18T11:55:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-18T11:55:47Z"}, "message": "[multiple changes]\n\n2005-03-17  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* gnat_ugn.texi: Document gnatmem restriction\n\n2005-03-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* snames.adb: Document new TSS names introduced by exp_dist/exp_tss\n\tcleanup\n\n2005-03-17  Robert Dewar  <dewar@adacore.com>\n\n\t* s-interr.ads, s-interr.adb, sem_ch3.adb, prj.ads, prj.adb,\n\ta-interr.adb, a-interr.ads, s-interr-sigaction.adb, s-interr-dummy.adb,\n\ts-interr-vms.adb, s-interr-vxworks.adb: Minor reformatting\n\n\t* casing.adb: Comment improvements\n\n2005-03-17  Pascal Obry  <obry@adacore.com>\n\n\t* g-expect.adb: Minor reformatting.\n\nFrom-SVN: r96678", "tree": {"sha": "4b33a5dc68585402508fa243369778006f1ade16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b33a5dc68585402508fa243369778006f1ade16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa7c4d231fb72d7a522f3894ea121177a899fdec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa7c4d231fb72d7a522f3894ea121177a899fdec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa7c4d231fb72d7a522f3894ea121177a899fdec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa7c4d231fb72d7a522f3894ea121177a899fdec/comments", "author": null, "committer": null, "parents": [{"sha": "8095d0fa91c3cc9af26742b032159149b9f1e9d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8095d0fa91c3cc9af26742b032159149b9f1e9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8095d0fa91c3cc9af26742b032159149b9f1e9d4"}], "stats": {"total": 443, "additions": 224, "deletions": 219}, "files": [{"sha": "a603a57cfde348de1b5b54df281ef426ed395d99", "filename": "gcc/ada/a-interr.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fa-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fa-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-interr.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--                      Copyright (C) 1995-2005 AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -73,8 +73,7 @@ package body Ada.Interrupts is\n    ---------------------\n \n    function Current_Handler\n-     (Interrupt : Interrupt_ID)\n-      return      Parameterless_Handler\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler\n    is\n    begin\n       return To_Ada (SI.Current_Handler (SI.Interrupt_ID (Interrupt)));\n@@ -84,7 +83,7 @@ package body Ada.Interrupts is\n    -- Detach_Handler --\n    --------------------\n \n-   procedure Detach_Handler (Interrupt : in Interrupt_ID) is\n+   procedure Detach_Handler (Interrupt : Interrupt_ID) is\n    begin\n       SI.Detach_Handler (SI.Interrupt_ID (Interrupt), False);\n    end Detach_Handler;"}, {"sha": "e857069b9e331e4aedc2d886e289031487b4cd5b", "filename": "gcc/ada/a-interr.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fa-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fa-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-interr.ads?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -49,8 +49,7 @@ package Ada.Interrupts is\n    function Is_Attached (Interrupt : Interrupt_ID) return Boolean;\n \n    function Current_Handler\n-     (Interrupt : Interrupt_ID)\n-      return      Parameterless_Handler;\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler;\n \n    procedure Attach_Handler\n      (New_Handler : Parameterless_Handler;"}, {"sha": "33ed33889f5673b9bcbd3dab222642dc880589eb", "filename": "gcc/ada/casing.adb", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fcasing.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fcasing.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcasing.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -140,6 +140,17 @@ package body Casing is\n       Ptr := 1;\n \n       while Ptr <= Name_Len loop\n+\n+         --  Wide character. Note that we do nothing with casing in this case.\n+         --  In Ada 2005 mode, required folding of lower case letters happened\n+         --  as the identifier was scanned, and we do not attempt any further\n+         --  messing with case (note that in any case we do not know how to\n+         --  fold upper case to lower case in wide character mode). We also\n+         --  do not bother with recognizing punctuation as equivalent to an\n+         --  underscore. There is nothing functional at this stage in doing\n+         --  the requested casing operation, beyond folding to upper case\n+         --  when it is mandatory, which does not involve underscores.\n+\n          if Name_Buffer (Ptr) = ASCII.ESC\n            or else Name_Buffer (Ptr) = '['\n            or else (Upper_Half_Encoding\n@@ -148,12 +159,16 @@ package body Casing is\n             Skip_Wide (Name_Buffer, Ptr);\n             After_Und := False;\n \n+         --  Underscore, or non-identifer character (error case)\n+\n          elsif Name_Buffer (Ptr) = '_'\n             or else not Identifier_Char (Name_Buffer (Ptr))\n          then\n             After_Und := True;\n             Ptr := Ptr + 1;\n \n+         --  Lower case letter\n+\n          elsif Is_Lower_Case_Letter (Name_Buffer (Ptr)) then\n             if Actual_Casing = All_Upper_Case\n               or else (After_Und and then Actual_Casing = Mixed_Case)\n@@ -164,6 +179,8 @@ package body Casing is\n             After_Und := False;\n             Ptr := Ptr + 1;\n \n+         --  Upper case letter\n+\n          elsif Is_Upper_Case_Letter (Name_Buffer (Ptr)) then\n             if Actual_Casing = All_Lower_Case\n               or else (not After_Und and then Actual_Casing = Mixed_Case)\n@@ -174,7 +191,9 @@ package body Casing is\n             After_Und := False;\n             Ptr := Ptr + 1;\n \n-         else  --  all other characters\n+         --  Other identifier character (must be digit)\n+\n+         else\n             After_Und := False;\n             Ptr := Ptr + 1;\n          end if;"}, {"sha": "2eed9164b204ae9cf1e4b010bc341dad232b5bcd", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -31,12 +31,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System;        use System;\n-with Ada.Calendar;  use Ada.Calendar;\n+with System;       use System;\n+with Ada.Calendar; use Ada.Calendar;\n \n with GNAT.IO;\n-with GNAT.OS_Lib;   use GNAT.OS_Lib;\n-with GNAT.Regpat;   use GNAT.Regpat;\n+with GNAT.OS_Lib;  use GNAT.OS_Lib;\n+with GNAT.Regpat;  use GNAT.Regpat;\n \n with Unchecked_Deallocation;\n \n@@ -762,9 +762,7 @@ package body GNAT.Expect is\n    ------------------\n \n    function Get_Error_Fd\n-     (Descriptor : Process_Descriptor)\n-      return       GNAT.OS_Lib.File_Descriptor\n-   is\n+     (Descriptor : Process_Descriptor) return GNAT.OS_Lib.File_Descriptor is\n    begin\n       return Descriptor.Error_Fd;\n    end Get_Error_Fd;\n@@ -774,9 +772,7 @@ package body GNAT.Expect is\n    ------------------\n \n    function Get_Input_Fd\n-     (Descriptor : Process_Descriptor)\n-      return       GNAT.OS_Lib.File_Descriptor\n-   is\n+     (Descriptor : Process_Descriptor) return GNAT.OS_Lib.File_Descriptor is\n    begin\n       return Descriptor.Input_Fd;\n    end Get_Input_Fd;\n@@ -786,9 +782,7 @@ package body GNAT.Expect is\n    -------------------\n \n    function Get_Output_Fd\n-     (Descriptor : Process_Descriptor)\n-      return       GNAT.OS_Lib.File_Descriptor\n-   is\n+     (Descriptor : Process_Descriptor) return GNAT.OS_Lib.File_Descriptor is\n    begin\n       return Descriptor.Output_Fd;\n    end Get_Output_Fd;\n@@ -798,9 +792,7 @@ package body GNAT.Expect is\n    -------------\n \n    function Get_Pid\n-     (Descriptor : Process_Descriptor)\n-      return       Process_Id\n-   is\n+     (Descriptor : Process_Descriptor) return Process_Id is\n    begin\n       return Descriptor.Pid;\n    end Get_Pid;\n@@ -847,7 +839,7 @@ package body GNAT.Expect is\n \n       Arg        : String_Access;\n       Arg_List   : String_List (1 .. Args'Length + 2);\n-      C_Arg_List :  aliased array (1 .. Args'Length + 2) of System.Address;\n+      C_Arg_List : aliased array (1 .. Args'Length + 2) of System.Address;\n \n       Command_With_Path : String_Access;\n \n@@ -1004,9 +996,9 @@ package body GNAT.Expect is\n    ----------\n \n    procedure Send\n-     (Descriptor : in out Process_Descriptor;\n-      Str        : String;\n-      Add_LF     : Boolean := True;\n+     (Descriptor   : in out Process_Descriptor;\n+      Str          : String;\n+      Add_LF       : Boolean := True;\n       Empty_Buffer : Boolean := False)\n    is\n       Full_Str    : constant String := Str & ASCII.LF;"}, {"sha": "246c9103112ef6b7231eaef18bbb4ce54ad1ee8d", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -18140,7 +18140,7 @@ allocation and deallocation routines that record call information. This\n allows to obtain accurate dynamic memory usage history at a minimal cost to\n the execution speed. Note however, that @code{gnatmem} is not supported on\n all platforms (currently, it is supported on AIX, HP-UX, GNU/Linux x86,\n-Solaris (sparc and x86) and Windows NT/2000/XP (x86).\n+32-bit Solaris (sparc and x86) and Windows NT/2000/XP (x86).\n \n @noindent\n The @code{gnatmem} command has the form"}, {"sha": "37237d36b27a27212c637ddb6f064c2741e038b7", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -650,7 +650,7 @@ package body Prj is\n    end Set;\n \n    procedure Set\n-     (Language_Processing : in Language_Processing_Data;\n+     (Language_Processing : Language_Processing_Data;\n       For_Language        : Language_Index;\n       In_Project          : in out Project_Data;\n       In_Tree             : Project_Tree_Ref)\n@@ -672,8 +672,7 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Supp_Languages.Table\n-                                                                (Supp_Index);\n+                  Supp := In_Tree.Supp_Languages.Table (Supp_Index);\n \n                   if Supp.Index = For_Language then\n                      In_Tree.Supp_Languages.Table\n@@ -755,8 +754,8 @@ package body Prj is\n    -- Standard_Naming_Data --\n    --------------------------\n \n-   function Standard_Naming_Data (Tree : Project_Tree_Ref := No_Project_Tree)\n-                                  return Naming_Data\n+   function Standard_Naming_Data\n+     (Tree : Project_Tree_Ref := No_Project_Tree) return Naming_Data\n    is\n    begin\n       if Tree = No_Project_Tree then\n@@ -793,8 +792,7 @@ package body Prj is\n \n             begin\n                while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Supp_Suffixes.Table\n-                                                             (Supp_Index);\n+                  Supp := In_Tree.Supp_Suffixes.Table (Supp_Index);\n \n                   if Supp.Index = Language then\n                      return Supp.Suffix;"}, {"sha": "aa58c2f5eb24d6d77c36fbbca6db97e2366c61ed", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -513,8 +513,8 @@ package Prj is\n \n    end record;\n \n-   function Standard_Naming_Data (Tree : Project_Tree_Ref := No_Project_Tree)\n-                                  return Naming_Data;\n+   function Standard_Naming_Data\n+     (Tree : Project_Tree_Ref := No_Project_Tree) return Naming_Data;\n    pragma Inline (Standard_Naming_Data);\n    --  The standard GNAT naming scheme when Tree is No_Project_Tree.\n    --  Otherwise, return the default naming scheme for the project tree Tree,"}, {"sha": "01c3ba19b0fa5a1d59af8f47a3213a95593c5673", "filename": "gcc/ada/s-interr-dummy.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-dummy.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2004, Ada Core Technologies               --\n+--                      Copyright (C) 1995-2005 AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,10 +32,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is an OS/2 version of this package.\n-\n---  This version is a stub, for systems that\n---  do not support interrupts (or signals).\n+--  This version is for systems that do not support interrupts (or signals)\n \n with Ada.Exceptions;\n \n@@ -93,8 +90,7 @@ package body System.Interrupts is\n    ---------------------\n \n    function Current_Handler\n-     (Interrupt : Interrupt_ID)\n-      return      Parameterless_Handler\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler\n    is\n    begin\n       Unimplemented;\n@@ -155,7 +151,6 @@ package body System.Interrupts is\n       return   Boolean\n    is\n       pragma Warnings (Off, Object);\n-\n    begin\n       Unimplemented;\n       return True;\n@@ -166,7 +161,6 @@ package body System.Interrupts is\n       return   Boolean\n    is\n       pragma Warnings (Off, Object);\n-\n    begin\n       Unimplemented;\n       return True;"}, {"sha": "d8e7f9ef3bfb9f161abaae94ce700308af31775d", "filename": "gcc/ada/s-interr-sigaction.adb", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-sigaction.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-sigaction.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-sigaction.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---              Copyright (C) 1998-2004 Free Software Fundation             --\n+--              Copyright (C) 1998-2005 Free Software Fundation             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the IRIX & NT version of this package.\n+--  This is the IRIX & NT version of this package\n \n with Ada.Task_Identification;\n --  used for Task_Id\n@@ -120,15 +120,15 @@ package body System.Interrupts is\n    --  that contain interrupt handlers.\n \n    procedure Signal_Handler (Sig : Interrupt_ID);\n-   --  This procedure is used to handle all the signals.\n+   --  This procedure is used to handle all the signals\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n    --  Handlers. These definitions are used to register the handlers\n    --  specified by the pragma Interrupt_Handler.\n \n-   --\n-   --  Handler Registration:\n-   --\n+   --------------------------\n+   -- Handler Registration --\n+   --------------------------\n \n    type Registered_Handler;\n    type R_Link is access all Registered_Handler;\n@@ -362,15 +362,14 @@ package body System.Interrupts is\n \n       if not Restoration and then not Static\n \n-         --  Tries to overwrite a static Interrupt Handler with a\n-         --  dynamic Handler\n+         --  Tries to overwrite a static Interrupt Handler with dynamic handle\n \n-        and then (Descriptors (Interrupt).Static\n+        and then\n+          (Descriptors (Interrupt).Static\n \n-                     --  The new handler is not specified as an\n-                     --  Interrupt Handler by a pragma.\n+            --  New handler not specified as an Interrupt Handler by a pragma\n \n-                     or else not Is_Registered (New_Handler))\n+             or else not Is_Registered (New_Handler))\n       then\n          Raise_Exception (Program_Error'Identity,\n            \"Trying to overwrite a static Interrupt Handler with a \" &\n@@ -569,10 +568,10 @@ package body System.Interrupts is\n       Descriptors (Interrupt).T := T;\n       Descriptors (Interrupt).E := E;\n \n-      --  Indicate the attachment of Interrupt Entry in ATCB.\n-      --  This is need so that when an Interrupt Entry task terminates\n-      --  the binding can be cleaned. The call to unbinding must be\n-      --  make by the task before it terminates.\n+      --  Indicate the attachment of Interrupt Entry in ATCB. This is needed so\n+      --  that when an Interrupt Entry task terminates the binding can be\n+      --  cleaned up. The call to unbinding must be make by the task before it\n+      --  terminates.\n \n       T.Interrupt_Entry := True;\n    end Bind_Interrupt_To_Entry;\n@@ -597,7 +596,7 @@ package body System.Interrupts is\n          end if;\n       end loop;\n \n-      --  Indicate in ATCB that no Interrupt Entries are attached.\n+      --  Indicate in ATCB that no Interrupt Entries are attached\n \n       T.Interrupt_Entry := True;\n    end Detach_Interrupt_Entries;\n@@ -674,8 +673,8 @@ package body System.Interrupts is\n \n          Initialization.Undefer_Abort (Self_Id);\n \n-         --  Undefer abort here to allow a window for this task\n-         --  to be aborted  at the time of system shutdown.\n+         --  Undefer abort here to allow a window for this task to be aborted\n+         --  at the time of system shutdown.\n \n       end loop;\n    end Server_Task;"}, {"sha": "01b42b697172d12c09a99741c77f48283873e78c", "filename": "gcc/ada/s-interr-vms.adb", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vms.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is an OpenVMS/Alpha version of this package.\n+--  This is an OpenVMS/Alpha version of this package\n \n --  Invariants:\n \n@@ -140,9 +140,8 @@ package body System.Interrupts is\n    -- Local Tasks --\n    -----------------\n \n-   --  WARNING: System.Tasking.Stages performs calls to this task\n-   --  with low-level constructs. Do not change this spec without synchro-\n-   --  nizing it.\n+   --  WARNING: System.Tasking.Stages performs calls to this task with\n+   --  low-level constructs. Do not change this spec without synchronizing it.\n \n    task Interrupt_Manager is\n       entry Detach_Interrupt_Entries (T : Task_Id);\n@@ -183,10 +182,10 @@ package body System.Interrupts is\n \n    task type Server_Task (Interrupt : Interrupt_ID) is\n       pragma Priority (System.Interrupt_Priority'Last);\n-      --  Note: the above pragma Priority is strictly speaking improper\n-      --  since it is outside the range of allowed priorities, but the\n-      --  compiler treats system units specially and does not apply\n-      --  this range checking rule to system units.\n+      --  Note: the above pragma Priority is strictly speaking improper since\n+      --  it is outside the range of allowed priorities, but the compiler\n+      --  treats system units specially and does not apply this range checking\n+      --  rule to system units.\n \n    end Server_Task;\n \n@@ -210,9 +209,9 @@ package body System.Interrupts is\n                     (others => (null, Static => False));\n    pragma Volatile_Components (User_Handler);\n    --  Holds the protected procedure handler (if any) and its Static\n-   --  information  for each interrupt. A handler is a Static one if\n-   --  it is specified through the pragma Attach_Handler.\n-   --  Attach_Handler. Otherwise, not static)\n+   --  information for each interrupt. A handler is a Static one if it is\n+   --  specified through the pragma Attach_Handler. Attach_Handler. Otherwise,\n+   --  not static)\n \n    User_Entry : array (Interrupt_ID'Range) of Entry_Assoc :=\n                   (others => (T => Null_Task, E => Null_Task_Entry));\n@@ -221,7 +220,7 @@ package body System.Interrupts is\n \n    Blocked : constant array (Interrupt_ID'Range) of Boolean :=\n      (others => False);\n---  ??? pragma Volatile_Components (Blocked);\n+   --  ??? pragma Volatile_Components (Blocked);\n    --  True iff the corresponding interrupt is blocked in the process level\n \n    Ignored : array (Interrupt_ID'Range) of Boolean := (others => False);\n@@ -238,13 +237,13 @@ package body System.Interrupts is\n    Server_ID : array (Interrupt_ID'Range) of Task_Id :=\n                  (others => Null_Task);\n    pragma Atomic_Components (Server_ID);\n-   --  Holds the Task_Id of the Server_Task for each interrupt.\n-   --  Task_Id is needed to accomplish locking per Interrupt base. Also\n-   --  is needed to decide whether to create a new Server_Task.\n+   --  Holds the Task_Id of the Server_Task for each interrupt. Task_Id is\n+   --  needed to accomplish locking per Interrupt base. Also is needed to\n+   --  decide whether to create a new Server_Task.\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n-   --  Handlers. These definitions are used to register the handlers\n-   --  specified by the pragma Interrupt_Handler.\n+   --  Handlers. These definitions are used to register the handlers specified\n+   --  by the pragma Interrupt_Handler.\n \n    type Registered_Handler;\n    type R_Link is access all Registered_Handler;\n@@ -334,7 +333,6 @@ package body System.Interrupts is\n       end loop;\n \n       return False;\n-\n    end Is_Registered;\n \n    -----------------\n@@ -415,9 +413,9 @@ package body System.Interrupts is\n            Interrupt_ID'Image (Interrupt) & \" is reserved\");\n       end if;\n \n-      --  ??? Since Parameterless_Handler is not Atomic, the\n-      --  current implementation is wrong. We need a new service in\n-      --  Interrupt_Manager to ensure atomicity.\n+      --  ??? Since Parameterless_Handler is not Atomic, the current\n+      --  implementation is wrong. We need a new service in Interrupt_Manager\n+      --  to ensure atomicity.\n \n       return User_Handler (Interrupt).H;\n    end Current_Handler;\n@@ -452,19 +450,20 @@ package body System.Interrupts is\n    -- Exchange_Handler --\n    ----------------------\n \n-   --  Calling this procedure with New_Handler = null and Static = True\n-   --  means we want to detach the current handler regardless of the\n-   --  previous handler's binding status (ie. do not care if it is a\n-   --  dynamic or static handler).\n+   --  Calling this procedure with New_Handler = null and Static = True means\n+   --  we want to detach the current handler regardless of the previous\n+   --  handler's binding status (ie. do not care if it is dynamic or static\n+   --  handler).\n \n-   --  This option is needed so that during the finalization of a PO, we\n-   --  can detach handlers attached through pragma Attach_Handler.\n+   --  This option is needed so that during the finalization of a PO, we can\n+   --  detach handlers attached through pragma Attach_Handler.\n \n    procedure Exchange_Handler\n      (Old_Handler : out Parameterless_Handler;\n       New_Handler : Parameterless_Handler;\n       Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False) is\n+      Static      : Boolean := False)\n+   is\n    begin\n       if Is_Reserved (Interrupt) then\n          Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n@@ -1152,25 +1151,24 @@ package body System.Interrupts is\n    end Install_Handlers;\n \n --  Elaboration code for package System.Interrupts\n+\n begin\n \n    --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent.\n \n    Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n \n-   --  During the elaboration of this package body we want RTS to\n-   --  inherit the interrupt mask from the Environment Task.\n+   --  During the elaboration of this package body we want RTS to inherit the\n+   --  interrupt mask from the Environment Task.\n \n-   --  The Environment Task should have gotten its mask from\n-   --  the enclosing process during the RTS start up. (See\n-   --  in s-inmaop.adb). Pass the Interrupt_Mask of the Environment\n-   --  task to the Interrupt_Manager.\n+   --  The Environment Task should have gotten its mask from the enclosing\n+   --  process during the RTS start up. (See in s-inmaop.adb). Pass the\n+   --  Interrupt_Mask of the Environment task to the Interrupt_Manager.\n \n-   --  Note : At this point we know that all tasks (including\n-   --  RTS internal servers) are masked for non-reserved signals\n-   --  (see s-taprop.adb). Only the Interrupt_Manager will have\n-   --  masks set up differently inheriting the original Environment\n-   --  Task's mask.\n+   --  Note : At this point we know that all tasks (including RTS internal\n+   --  servers) are masked for non-reserved signals (see s-taprop.adb). Only\n+   --  the Interrupt_Manager will have masks set up differently inheriting the\n+   --  original Environment Task's mask.\n \n    Interrupt_Manager.Initialize (IMOP.Environment_Mask);\n end System.Interrupts;"}, {"sha": "c9f993b376d457d6c1affd85787a492a4758c724", "filename": "gcc/ada/s-interr-vxworks.adb", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vxworks.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,27 +33,27 @@\n \n --  Invariants:\n \n---  All user-handleable signals are masked at all times in all\n---  tasks/threads except possibly for the Interrupt_Manager task.\n+--  All user-handleable signals are masked at all times in all tasks/threads\n+--  except possibly for the Interrupt_Manager task.\n \n---  When a user task wants to have the effect of masking/unmasking an\n---  signal, it must call Block_Interrupt/Unblock_Interrupt, which\n---  will have the effect of unmasking/masking the signal in the\n---  Interrupt_Manager task.  These comments do not apply to vectored\n---  hardware interrupts, which may be masked or unmasked using routined\n---  interfaced to the relevant VxWorks system calls.\n+--  When a user task wants to have the effect of masking/unmasking an signal,\n+--  it must call Block_Interrupt/Unblock_Interrupt, which will have the effect\n+--  of unmasking/masking the signal in the Interrupt_Manager task. These\n+--  comments do not apply to vectored hardware interrupts, which may be masked\n+--  or unmasked using routined interfaced to the relevant VxWorks system\n+--  calls.\n \n---  Once we associate a Signal_Server_Task with an signal, the task never\n---  goes away, and we never remove the association. On the other hand, it\n---  is more convenient to terminate an associated Interrupt_Server_Task\n---  for a vectored hardware interrupt (since we use a binary semaphore\n---  for synchronization with the umbrella handler).\n+--  Once we associate a Signal_Server_Task with an signal, the task never goes\n+--  away, and we never remove the association. On the other hand, it is more\n+--  convenient to terminate an associated Interrupt_Server_Task for a vectored\n+--  hardware interrupt (since we use a binary semaphore for synchronization\n+--  with the umbrella handler).\n \n --  There is no more than one signal per Signal_Server_Task and no more than\n---  one Signal_Server_Task per signal.  The same relation holds for hardware\n---  interrupts and Interrupt_Server_Task's at any given time.  That is,\n---  only one non-terminated Interrupt_Server_Task exists for a give\n---  interrupt at any time.\n+--  one Signal_Server_Task per signal. The same relation holds for hardware\n+--  interrupts and Interrupt_Server_Task's at any given time. That is, only\n+--  one non-terminated Interrupt_Server_Task exists for a give interrupt at\n+--  any time.\n \n --  Within this package, the lock L is used to protect the various status\n --  tables. If there is a Server_Task associated with a signal or interrupt,\n@@ -124,9 +124,8 @@ package body System.Interrupts is\n    -- Local Tasks --\n    -----------------\n \n-   --  WARNING: System.Tasking.Stages performs calls to this task\n-   --  with low-level constructs. Do not change this spec without synchro-\n-   --  nizing it.\n+   --  WARNING: System.Tasking.Stages performs calls to this task with\n+   --  low-level constructs. Do not change this spec without synchronizing it.\n \n    task Interrupt_Manager is\n       entry Detach_Interrupt_Entries (T : Task_Id);\n@@ -331,7 +330,8 @@ package body System.Interrupts is\n    ---------------------\n \n    function Current_Handler\n-     (Interrupt : Interrupt_ID) return Parameterless_Handler is\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler\n+   is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n \n@@ -386,7 +386,8 @@ package body System.Interrupts is\n      (Old_Handler : out Parameterless_Handler;\n       New_Handler : Parameterless_Handler;\n       Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False) is\n+      Static      : Boolean := False)\n+   is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       Interrupt_Manager.Exchange_Handler\n@@ -421,7 +422,7 @@ package body System.Interrupts is\n    -- Finalize_Interrupt_Servers --\n    --------------------------------\n \n-   --  Restore default handlers for interrupt servers.\n+   --  Restore default handlers for interrupt servers\n \n    --  This is called by the Interrupt_Manager task when it receives the abort\n    --  signal during program finalization.\n@@ -456,7 +457,6 @@ package body System.Interrupts is\n       return   Boolean\n    is\n       pragma Unreferenced (Object);\n-\n    begin\n       return True;\n    end Has_Interrupt_Or_Attach_Handler;\n@@ -466,7 +466,6 @@ package body System.Interrupts is\n       return   Boolean\n    is\n       pragma Unreferenced (Object);\n-\n    begin\n       return True;\n    end Has_Interrupt_Or_Attach_Handler;\n@@ -500,9 +499,11 @@ package body System.Interrupts is\n \n    procedure Install_Handlers\n      (Object       : access Static_Interrupt_Protection;\n-      New_Handlers : New_Handler_Array) is\n+      New_Handlers : New_Handler_Array)\n+   is\n    begin\n       for N in New_Handlers'Range loop\n+\n          --  We need a lock around this ???\n \n          Object.Previous_Handlers (N).Interrupt := New_Handlers (N).Interrupt;\n@@ -687,6 +688,7 @@ package body System.Interrupts is\n \n    procedure Register_Interrupt_Handler (Handler_Addr : System.Address) is\n       New_Node_Ptr : R_Link;\n+\n    begin\n       --  This routine registers a handler as usable for dynamic\n       --  interrupt handler association. Routines attaching and detaching\n@@ -727,7 +729,8 @@ package body System.Interrupts is\n    ------------------\n \n    function Unblocked_By\n-     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id is\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id\n+   is\n    begin\n       Unimplemented (\"Unblocked_By\");\n       return Null_Task;\n@@ -836,8 +839,9 @@ package body System.Interrupts is\n          --  status of the Current_Handler.\n \n          if not Static and then User_Handler (Interrupt).Static then\n-            --  Trying to detach a static Interrupt Handler.\n-            --  raise Program_Error.\n+\n+            --  Trying to detach a static Interrupt Handler. raise\n+            --  Program_Error.\n \n             Raise_Exception (Program_Error'Identity,\n               \"Trying to detach a static Interrupt Handler\");\n@@ -864,9 +868,11 @@ package body System.Interrupts is\n          New_Handler : Parameterless_Handler;\n          Interrupt   : Interrupt_ID;\n          Static      : Boolean;\n-         Restoration : Boolean := False) is\n+         Restoration : Boolean := False)\n+      is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n+\n             --  If an interrupt entry is already installed, raise\n             --  Program_Error. (propagate it to the caller).\n \n@@ -909,7 +915,7 @@ package body System.Interrupts is\n \n          if New_Handler = null then\n \n-            --  The null handler means we are detaching the handler.\n+            --  The null handler means we are detaching the handler\n \n             User_Handler (Interrupt).Static := False;\n \n@@ -935,11 +941,13 @@ package body System.Interrupts is\n          end if;\n \n          if (New_Handler = null) and then Old_Handler /= null then\n+\n             --  Restore default handler\n \n             Unbind_Handler (Interrupt);\n \n          elsif Old_Handler = null then\n+\n             --  Save default handler\n \n             Bind_Handler (Interrupt);\n@@ -1046,7 +1054,7 @@ package body System.Interrupts is\n                      end if;\n                   end loop;\n \n-                  --  Indicate in ATCB that no interrupt entries are attached.\n+                  --  Indicate in ATCB that no interrupt entries are attached\n \n                   T.Interrupt_Entry := False;\n                end Detach_Interrupt_Entries;\n@@ -1140,7 +1148,7 @@ package body System.Interrupts is\n    end Interrupt_Server_Task;\n \n begin\n-   --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent.\n+   --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent\n \n    Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n end System.Interrupts;"}, {"sha": "de93ca1ecc8a87380db1e43221f976590cdb3ad2", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -157,20 +157,20 @@ package body System.Interrupts is\n       entry Initialize (Mask : IMNG.Interrupt_Mask);\n \n       entry Attach_Handler\n-        (New_Handler : in Parameterless_Handler;\n-         Interrupt   : in Interrupt_ID;\n-         Static      : in Boolean;\n-         Restoration : in Boolean := False);\n+        (New_Handler : Parameterless_Handler;\n+         Interrupt   : Interrupt_ID;\n+         Static      : Boolean;\n+         Restoration : Boolean := False);\n \n       entry Exchange_Handler\n         (Old_Handler : out Parameterless_Handler;\n-         New_Handler : in Parameterless_Handler;\n-         Interrupt   : in Interrupt_ID;\n-         Static      : in Boolean);\n+         New_Handler : Parameterless_Handler;\n+         Interrupt   : Interrupt_ID;\n+         Static      : Boolean);\n \n       entry Detach_Handler\n-        (Interrupt   : in Interrupt_ID;\n-         Static      : in Boolean);\n+        (Interrupt   : Interrupt_ID;\n+         Static      : Boolean);\n \n       entry Bind_Interrupt_To_Entry\n         (T         : Task_Id;\n@@ -256,7 +256,7 @@ package body System.Interrupts is\n    type R_Link is access all Registered_Handler;\n \n    type Registered_Handler is record\n-      H :    System.Address := System.Null_Address;\n+      H    : System.Address := System.Null_Address;\n       Next : R_Link := null;\n    end record;\n \n@@ -287,9 +287,9 @@ package body System.Interrupts is\n    --  can detach handlers attached through pragma Attach_Handler.\n \n    procedure Attach_Handler\n-     (New_Handler : in Parameterless_Handler;\n-      Interrupt   : in Interrupt_ID;\n-      Static      : in Boolean := False)\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean := False)\n    is\n    begin\n       if Is_Reserved (Interrupt) then\n@@ -352,9 +352,9 @@ package body System.Interrupts is\n            Interrupt_ID'Image (Interrupt) & \" is reserved\");\n       end if;\n \n-      --  ??? Since Parameterless_Handler is not Atomic, the\n-      --  current implementation is wrong. We need a new service in\n-      --  Interrupt_Manager to ensure atomicity.\n+      --  ??? Since Parameterless_Handler is not Atomic, the current\n+      --  implementation is wrong. We need a new service in Interrupt_Manager\n+      --  to ensure atomicity.\n \n       return User_Handler (Interrupt).H;\n    end Current_Handler;\n@@ -632,15 +632,15 @@ package body System.Interrupts is\n       New_Node_Ptr : R_Link;\n \n    begin\n-      --  This routine registers the Handler as usable for Dynamic\n-      --  Interrupt Handler. Routines attaching and detaching Handler\n-      --  dynamically should first consult if the Handler is rgistered.\n-      --  A Program Error should be raised if it is not registered.\n+      --  This routine registers the Handler as usable for Dynamic Interrupt\n+      --  Handler. Routines attaching and detaching Handler dynamically should\n+      --  first consult if the Handler is registered. A Program Error should\n+      --  be raised if it is not registered.\n \n-      --  The pragma Interrupt_Handler can only appear in the library\n-      --  level PO definition and instantiation. Therefore, we do not need\n-      --  to implement Unregistering operation. Neither we need to\n-      --  protect the queue structure using a Lock.\n+      --  The pragma Interrupt_Handler can only appear in the library level PO\n+      --  definition and instantiation. Therefore, we do not need to implement\n+      --  Unregistering operation. Neither we need to protect the queue\n+      --  structure using a Lock.\n \n       pragma Assert (Handler_Addr /= System.Null_Address);\n \n@@ -1014,10 +1014,10 @@ package body System.Interrupts is\n          begin\n             select\n                accept Attach_Handler\n-                  (New_Handler : in Parameterless_Handler;\n-                   Interrupt   : in Interrupt_ID;\n-                   Static      : in Boolean;\n-                   Restoration : in Boolean := False)\n+                  (New_Handler : Parameterless_Handler;\n+                   Interrupt   : Interrupt_ID;\n+                   Static      : Boolean;\n+                   Restoration : Boolean := False)\n                do\n                   Unprotected_Exchange_Handler\n                     (Old_Handler, New_Handler, Interrupt, Static, Restoration);\n@@ -1026,18 +1026,18 @@ package body System.Interrupts is\n             or\n                accept Exchange_Handler\n                   (Old_Handler : out Parameterless_Handler;\n-                   New_Handler : in Parameterless_Handler;\n-                   Interrupt   : in Interrupt_ID;\n-                   Static      : in Boolean)\n+                   New_Handler : Parameterless_Handler;\n+                   Interrupt   : Interrupt_ID;\n+                   Static      : Boolean)\n                do\n                   Unprotected_Exchange_Handler\n                     (Old_Handler, New_Handler, Interrupt, Static);\n                end Exchange_Handler;\n \n             or\n                accept Detach_Handler\n-                 (Interrupt   : in Interrupt_ID;\n-                  Static      : in Boolean)\n+                 (Interrupt   : Interrupt_ID;\n+                  Static      : Boolean)\n                do\n                   Unprotected_Detach_Handler (Interrupt, Static);\n                end Detach_Handler;"}, {"sha": "94f6dd3e533bd3c25d197943993d437b84fb7f6f", "filename": "gcc/ada/s-interr.ads", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fs-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.ads?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,7 @@\n --  It is made a child of System to allow visibility of various\n --  runtime system internal data and operations.\n \n---  See System.Interrupt_Management for core interrupt/signal interfaces.\n+--  See System.Interrupt_Management for core interrupt/signal interfaces\n \n --  These two packages are separated in order to allow\n --  System.Interrupt_Management to be used without requiring the whole\n@@ -95,8 +95,7 @@ package System.Interrupts is\n    function Is_Handler_Attached (Interrupt : Interrupt_ID) return Boolean;\n \n    function Current_Handler\n-     (Interrupt : Interrupt_ID)\n-      return Parameterless_Handler;\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler;\n \n    --  Calling the following procedures with New_Handler = null\n    --  and Static = true means that we want to modify the current handler\n@@ -119,8 +118,7 @@ package System.Interrupts is\n       Static    : Boolean := False);\n \n    function Reference\n-     (Interrupt : Interrupt_ID)\n-     return       System.Address;\n+     (Interrupt : Interrupt_ID) return System.Address;\n \n    --------------------------------\n    -- Interrupt Entries Services --\n@@ -150,8 +148,7 @@ package System.Interrupts is\n    procedure Unblock_Interrupt (Interrupt : Interrupt_ID);\n \n    function Unblocked_By\n-     (Interrupt   : Interrupt_ID)\n-      return System.Tasking.Task_Id;\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id;\n    --  It returns the ID of the last Task which Unblocked this Interrupt.\n    --  It returns Null_Task if no tasks have ever requested the\n    --  Unblocking operation or the Interrupt is currently Blocked.\n@@ -185,38 +182,36 @@ package System.Interrupts is\n \n    --  There are two kinds of protected objects that deal with interrupts:\n \n-   --  (1) Only Interrupt_Handler pragmas are used. We need to be able to\n-   --  tell if an Interrupt_Handler applies to a given procedure, so\n+   --  (1) Only Interrupt_Handler pragmas are used. We need to be able to tell\n+   --  if an Interrupt_Handler applies to a given procedure, so\n    --  Register_Interrupt_Handler has to be called for all the potential\n-   --  handlers, it should be done by calling Register_Interrupt_Handler\n-   --  with the handler code address. On finalization, which can happen only\n-   --  has part of library level finalization since PO with\n-   --  Interrupt_Handler pragmas can only be declared at library level,\n-   --  nothing special needs to be done since the default handlers have been\n-   --  restored as part of task completion which is done just before global\n-   --  finalization.  Dynamic_Interrupt_Protection should be used in this\n-   --  case.\n+   --  handlers, it should be done by calling Register_Interrupt_Handler with\n+   --  the handler code address. On finalization, which can happen only has\n+   --  part of library level finalization since PO with Interrupt_Handler\n+   --  pragmas can only be declared at library level, nothing special needs to\n+   --  be done since the default handlers have been restored as part of task\n+   --  completion which is done just before global finalization.\n+   --  Dynamic_Interrupt_Protection should be used in this case.\n \n    --  (2) Attach_Handler pragmas are used, and possibly Interrupt_Handler\n-   --  pragma. We need to attach the handlers to the given interrupts when\n-   --  the objet is elaborated. This should be done by constructing an array\n-   --  of pairs (interrupt, handler) from the pragmas and calling\n-   --  Install_Handlers with it (types to be used are New_Handler_Item and\n-   --  New_Handler_Array). On finalization, we need to restore the handlers\n-   --  that were installed before the elaboration of the PO, so we need to\n-   --  store these previous handlers. This is also done by Install_Handlers,\n-   --  the room for these informations is provided by adding a discriminant\n-   --  which is the number of Attach_Handler pragmas and an array of this\n-   --  size in the protection type, Static_Interrupt_Protection.\n+   --  pragma. We need to attach the handlers to the given interrupts when the\n+   --  objet is elaborated. This should be done by constructing an array of\n+   --  pairs (interrupt, handler) from the pragmas and calling Install_Handlers\n+   --  with it (types to be used are New_Handler_Item and New_Handler_Array).\n+   --  On finalization, we need to restore the handlers that were installed\n+   --  before the elaboration of the PO, so we need to store these previous\n+   --  handlers. This is also done by Install_Handlers, the room for these\n+   --  informations is provided by adding a discriminant which is the number\n+   --  of Attach_Handler pragmas and an array of this size in the protection\n+   --  type, Static_Interrupt_Protection.\n \n    procedure Register_Interrupt_Handler\n      (Handler_Addr : System.Address);\n-   --  This routine should be called by the compiler to allow the\n-   --  handler be used as an Interrupt Handler. That means call this\n-   --  procedure for each pragma Interrup_Handler providing the\n-   --  address of the handler (not including the pointer to the\n-   --  actual PO, this way this routine is called only once for\n-   --  each type definition of PO).\n+   --  This routine should be called by the compiler to allow the handler be\n+   --  used as an Interrupt Handler. That means call this procedure for each\n+   --  pragma Interrup_Handler providing the address of the handler (not\n+   --  including the pointer to the actual PO, this way this routine is called\n+   --  only once for each type definition of PO).\n \n    type Static_Handler_Index is range 0 .. Integer'Last;\n    subtype Positive_Static_Handler_Index is\n@@ -228,7 +223,7 @@ package System.Interrupts is\n       Handler   : Parameterless_Handler;\n       Static    : Boolean;\n    end record;\n-   --  Contains all the information needed to restore a previous handler.\n+   --  Contains all the information needed to restore a previous handler\n \n    type Previous_Handler_Array is array\n      (Positive_Static_Handler_Index range <>) of Previous_Handler_Item;\n@@ -237,7 +232,7 @@ package System.Interrupts is\n       Interrupt : Interrupt_ID;\n       Handler   : Parameterless_Handler;\n    end record;\n-   --  Contains all the information from an Attach_Handler pragma.\n+   --  Contains all the information from an Attach_Handler pragma\n \n    type New_Handler_Array is\n      array (Positive_Static_Handler_Index range <>) of New_Handler_Item;\n@@ -253,7 +248,7 @@ package System.Interrupts is\n \n    function Has_Interrupt_Or_Attach_Handler\n      (Object : access Dynamic_Interrupt_Protection) return Boolean;\n-   --  Returns True.\n+   --  Returns True\n \n    --  Case (2)\n \n@@ -267,17 +262,16 @@ package System.Interrupts is\n      end record;\n \n    function Has_Interrupt_Or_Attach_Handler\n-     (Object : access Static_Interrupt_Protection)\n-      return   Boolean;\n-   --  Returns True.\n+     (Object : access Static_Interrupt_Protection) return Boolean;\n+   --  Returns True\n \n    procedure Finalize (Object : in out Static_Interrupt_Protection);\n    --  Restore previous handlers as required by C.3.1(12) then call\n    --  Finalize (Protection).\n \n    procedure Install_Handlers\n      (Object       : access Static_Interrupt_Protection;\n-      New_Handlers : in New_Handler_Array);\n+      New_Handlers : New_Handler_Array);\n    --  Store the old handlers in Object.Previous_Handlers and install\n    --  the new static handlers.\n "}, {"sha": "609871aa1c8a2f81f4f91a2a530c7f582a285ebb", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -9603,13 +9603,15 @@ package body Sem_Ch3 is\n          end if;\n       end Comes_From_Generic;\n \n+   --  Start of processing for Derived_Type_Declaration\n+\n    begin\n       Parent_Type := Find_Type_Of_Subtype_Indic (Indic);\n \n       if Parent_Type = Any_Type\n         or else Etype (Parent_Type) = Any_Type\n         or else (Is_Class_Wide_Type (Parent_Type)\n-                  and then Etype (Parent_Type) = T)\n+                   and then Etype (Parent_Type) = T)\n       then\n          --  If Parent_Type is undefined or illegal, make new type into a\n          --  subtype of Any_Type, and set a few attributes to prevent cascaded"}, {"sha": "66f13453c50c4fa843ebb064f7c87df8530e3156", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa7c4d231fb72d7a522f3894ea121177a899fdec/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=fa7c4d231fb72d7a522f3894ea121177a899fdec", "patch": "@@ -735,15 +735,18 @@ package body Snames is\n    --    xxxDF   deep finalize routine for type xxx                 (Exp_TSS)\n    --    xxxDI   deep initialize routine for type xxx               (Exp_TSS)\n    --    xxxEQ   composite equality routine for record type xxx     (Exp_TSS)\n+   --    xxxFA   PolyORB/DSA From_Any converter for type xxx        (Exp_TSS)\n    --    xxxIP   initialization procedure for type xxx              (Exp_TSS)\n-   --    xxxRA   RAs type access routine for type xxx               (Exp_TSS)\n-   --    xxxRD   RAs type dereference routine for type xxx          (Exp_TSS)\n+   --    xxxRA   RAS type access routine for type xxx               (Exp_TSS)\n+   --    xxxRD   RAS type dereference routine for type xxx          (Exp_TSS)\n    --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\n    --    xxxSA   array/slice assignment for controlled comp. arrays (Exp_TSS)\n    --    xxxSI   stream input attribute subprogram for type xxx     (Exp_TSS)\n    --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\n    --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)\n    --    xxxSW   stream write attribute subprogram for type xxx     (Exp_TSS)\n+   --    xxxTA   PolyORB/DSA To_Any converter for type xxx          (Exp_TSS)\n+   --    xxxTC   PolyORB/DSA Typecode for type xxx                  (Exp_TSS)\n \n    --  Implicit type names\n "}]}