{"sha": "90d9a8e6ef72bd85839fb092605aa6d945616178", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBkOWE4ZTZlZjcyYmQ4NTgzOWZiMDkyNjA1YWE2ZDk0NTYxNjE3OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-03-06T14:44:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-03-06T14:44:44Z"}, "message": "Revert \"Allow deduction guides to look into primary template.\"\n\n\t* cp-tree.h, parser.c, pt.c, search.c: Revert.\n\nFrom-SVN: r245924", "tree": {"sha": "24a671533c97b963526a66b929f8a952b56080e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a671533c97b963526a66b929f8a952b56080e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90d9a8e6ef72bd85839fb092605aa6d945616178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d9a8e6ef72bd85839fb092605aa6d945616178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d9a8e6ef72bd85839fb092605aa6d945616178", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d9a8e6ef72bd85839fb092605aa6d945616178/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8d25fd0dd7e0feffc395ff1db1f2e9d815fb78a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d25fd0dd7e0feffc395ff1db1f2e9d815fb78a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8d25fd0dd7e0feffc395ff1db1f2e9d815fb78a"}], "stats": {"total": 128, "additions": 55, "deletions": 73}, "files": [{"sha": "fc9757b294b071bc9310dc0efd3c11135d7d1163", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=90d9a8e6ef72bd85839fb092605aa6d945616178", "patch": "@@ -1,3 +1,8 @@\n+2017-03-06  Jason Merrill  <jason@redhat.com>\n+\n+\tRevert \"Allow deduction guides to look into primary template.\"\n+\t* cp-tree.h, parser.c, pt.c, search.c: Revert.\n+\n 2017-03-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/70266"}, {"sha": "68f2722d6da916c2c7d61edcc171e226caaa34c3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=90d9a8e6ef72bd85839fb092605aa6d945616178", "patch": "@@ -1272,7 +1272,6 @@ struct GTY(()) saved_scope {\n   vec<tree, va_gc> *lang_base;\n   tree lang_name;\n   tree template_parms;\n-  tree deduction_guide_type;\n   cp_binding_level *x_previous_class_level;\n   tree x_saved_tree;\n \n@@ -5423,9 +5422,6 @@ struct cp_decl_specifier_seq {\n   BOOL_BITFIELD gnu_thread_keyword_p : 1;\n   /* True iff the type is a decltype.  */\n   BOOL_BITFIELD decltype_p : 1;\n-  /* True iff the declaration declares a constructor or C++17 deduction\n-     guide.  */\n-  BOOL_BITFIELD constructor_p : 1;\n };\n \n /* The various kinds of declarators.  */"}, {"sha": "e6848701150020f02cd683b271a8d32ba01540ea", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=90d9a8e6ef72bd85839fb092605aa6d945616178", "patch": "@@ -13313,8 +13313,6 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t   && constructor_possible_p\n \t   && (cp_parser_constructor_declarator_p\n \t       (parser, decl_spec_seq_has_spec_p (decl_specs, ds_friend))));\n-      if (constructor_p)\n-\tdecl_specs->constructor_p = true;\n \n       /* If we don't have a DECL_SPEC yet, then we must be looking at\n \t a type-specifier.  */\n@@ -19012,7 +19010,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   enum cpp_ttype initialization_kind;\n   bool is_direct_init = false;\n   bool is_non_constant_init;\n-  int ctor_dtor_or_conv_p = decl_specifiers->constructor_p ? -1 : 0;\n+  int ctor_dtor_or_conv_p;\n   bool friend_p = cp_parser_friend_p (decl_specifiers);\n   tree pushed_scope = NULL_TREE;\n   bool range_for_decl_p = false;\n@@ -19050,9 +19048,6 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   parser->default_arg_ok_p = saved_default_arg_ok_p;\n \n-  if (cxx_dialect >= cxx1z)\n-    scope_chain->deduction_guide_type = NULL_TREE;\n-\n   /* If the DECLARATOR was erroneous, there's no need to go\n      further.  */\n   if (declarator == cp_error_declarator)\n@@ -19100,6 +19095,25 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   if (function_declarator_p (declarator))\n     {\n+      /* Handle C++17 deduction guides.  */\n+      if (!decl_specifiers->type\n+\t  && ctor_dtor_or_conv_p <= 0\n+\t  && cxx_dialect >= cxx1z)\n+\t{\n+\t  cp_declarator *id = get_id_declarator (declarator);\n+\t  tree name = id->u.id.unqualified_name;\n+\t  parser->scope = id->u.id.qualifying_scope;\n+\t  tree tmpl = cp_parser_lookup_name_simple (parser, name, id->id_loc);\n+\t  if (tmpl\n+\t      && (DECL_CLASS_TEMPLATE_P (tmpl)\n+\t\t  || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))\n+\t    {\n+\t      id->u.id.unqualified_name = dguide_name (tmpl);\n+\t      id->u.id.sfk = sfk_deduction_guide;\n+\t      ctor_dtor_or_conv_p = 1;\n+\t    }\n+\t}\n+\n       /* Check to see if the token indicates the start of a\n \t function-definition.  */\n       if (cp_parser_token_starts_function_definition_p (token))\n@@ -19418,10 +19432,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \n    If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to\n    detect constructors, destructors, deduction guides, or conversion operators.\n-   The caller should set it before the call, to -1 if parsing the\n-   decl-specifier-seq determined that we're declaring a constructor or\n-   deduction guide, or 0 otherwise.  This function sets it to -1 if the\n-   declarator is a name, and +1 if it is a function. Usually you just want to\n+   It is set to -1 if the declarator is a name, and +1 if it is a\n+   function. Otherwise it is set to zero. Usually you just want to\n    test for >0, but internally the negative value is used.\n \n    (The reason for CTOR_DTOR_OR_CONV_P is that a declaration must have\n@@ -19452,6 +19464,11 @@ cp_parser_declarator (cp_parser* parser,\n   tree class_type;\n   tree gnu_attributes = NULL_TREE, std_attributes = NULL_TREE;\n \n+  /* Assume this is not a constructor, destructor, or type-conversion\n+     operator.  */\n+  if (ctor_dtor_or_conv_p)\n+    *ctor_dtor_or_conv_p = 0;\n+\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     gnu_attributes = cp_parser_gnu_attributes_opt (parser);\n \n@@ -19749,6 +19766,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  /* Parse an array-declarator.  */\n \t  tree bounds, attrs;\n \n+\t  if (ctor_dtor_or_conv_p)\n+\t    *ctor_dtor_or_conv_p = 0;\n+\n \t  first = false;\n \t  parser->default_arg_ok_p = false;\n \t  parser->in_declarator_p = true;\n@@ -20003,34 +20023,6 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t      *ctor_dtor_or_conv_p = -1;\n \t\t  }\n \t      }\n-\n-\t    if (cxx_dialect >= cxx1z\n-\t\t&& sfk == sfk_none\n-\t\t&& ctor_dtor_or_conv_p\n-\t\t&& *ctor_dtor_or_conv_p == -1)\n-\t      {\n-\t\t/* If *ctor_dtor_or_conv_p is set and we aren't declaring a\n-\t\t   constructor, we must be declaring a deduction guide.  */\n-\t\ttree tmpl;\n-\t\tif (qualifying_scope)\n-\t\t  tmpl = (lookup_qualified_name\n-\t\t\t  (qualifying_scope, unqualified_name,\n-\t\t\t   /*prefer_type*/false, /*complain*/true));\n-\t\telse\n-\t\t  tmpl = lookup_name (unqualified_name);\n-\t\tif (tmpl\n-\t\t    && (DECL_CLASS_TEMPLATE_P (tmpl)\n-\t\t\t|| DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))\n-\t\t  {\n-\t\t    unqualified_name = dguide_name (tmpl);\n-\t\t    scope_chain->deduction_guide_type\n-\t\t      = TREE_TYPE (unqualified_name);\n-\t\t    sfk = sfk_deduction_guide;\n-\t\t  }\n-\t\telse\n-\t\t  gcc_checking_assert (false);\n-\t      }\n-\n \t    declarator = make_id_declarator (qualifying_scope,\n \t\t\t\t\t     unqualified_name,\n \t\t\t\t\t     sfk);\n@@ -23259,7 +23251,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      cp_declarator *declarator;\n \t      tree initializer;\n \t      tree asm_specification;\n-\t      int ctor_dtor_or_conv_p = decl_specifiers.constructor_p ? -1 : 0;\n+\t      int ctor_dtor_or_conv_p;\n \n \t      /* Parse the declarator.  */\n \t      declarator\n@@ -28342,7 +28334,7 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n \t\t     declarator.  */\n \t\t  do\n \t\t    {\n-\t\t      int ctor_dtor_or_conv_p = 0;\n+\t\t      int ctor_dtor_or_conv_p;\n \t\t      cp_lexer_consume_token (parser->lexer);\n \t\t      cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t\t    &ctor_dtor_or_conv_p,\n@@ -29663,7 +29655,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t{\n \t  tree width = NULL_TREE, attributes, first_attribute, decl;\n \t  cp_declarator *declarator = NULL;\n-\t  int ctor_dtor_or_conv_p = 0;\n+\t  int ctor_dtor_or_conv_p;\n \n \t  /* Check for a (possibly unnamed) bitfield declaration.  */\n \t  token = cp_lexer_peek_token (parser->lexer);"}, {"sha": "416f1323f4fa5ff3e89549cc27322c00a9875ce3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=90d9a8e6ef72bd85839fb092605aa6d945616178", "patch": "@@ -14641,6 +14641,15 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     have to substitute this with one having context `D<int>'.  */\n \n \t  tree context = tsubst (DECL_CONTEXT (t), args, complain, in_decl);\n+\t  if (dependent_scope_p (context))\n+\t    {\n+\t      /* When rewriting a constructor into a deduction guide, a\n+\t\t non-dependent name can become dependent, so memtmpl<args>\n+\t\t becomes context::template memtmpl<args>.  */\n+\t      tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t      return build_qualified_name (type, context, DECL_NAME (t),\n+\t\t\t\t\t   /*template*/true);\n+\t    }\n \t  return lookup_field (context, DECL_NAME(t), 0, false);\n \t}\n       else\n@@ -16624,6 +16633,14 @@ tsubst_copy_and_build (tree t,\n \tif (targs == error_mark_node)\n \t  return error_mark_node;\n \n+\tif (TREE_CODE (templ) == SCOPE_REF)\n+\t  {\n+\t    tree name = TREE_OPERAND (templ, 1);\n+\t    tree tid = lookup_template_function (name, targs);\n+\t    TREE_OPERAND (templ, 1) = tid;\n+\t    return templ;\n+\t  }\n+\n \tif (variable_template_p (templ))\n \t  RETURN (lookup_and_finish_template_variable (templ, targs, complain));\n \n@@ -23459,9 +23476,6 @@ bool\n dependent_scope_p (tree scope)\n {\n   return (scope && TYPE_P (scope) && dependent_type_p (scope)\n-\t  && !(cxx_dialect >= cxx1z\n-\t       && scope_chain->deduction_guide_type\n-\t       && same_type_p (scope, scope_chain->deduction_guide_type))\n \t  && !currently_open_class (scope));\n }\n \n@@ -25012,7 +25026,6 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n       if (outer_args)\n \tctor = tsubst (ctor, outer_args, complain, ctor);\n       type = DECL_CONTEXT (ctor);\n-      scope_chain->deduction_guide_type = type;\n       tree fn_tmpl;\n       if (TREE_CODE (ctor) == TEMPLATE_DECL)\n \t{\n@@ -25105,7 +25118,6 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n \t  current_template_parms = save_parms;\n \t  --processing_template_decl;\n \t}\n-      scope_chain->deduction_guide_type = NULL_TREE;\n     }\n \n   if (!memtmpl)"}, {"sha": "09c1b4e6456d24682eb3246de361a4e8354f6ba4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d9a8e6ef72bd85839fb092605aa6d945616178/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=90d9a8e6ef72bd85839fb092605aa6d945616178", "patch": "@@ -1279,13 +1279,6 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n     if (tree t = currently_open_class (type))\n       type = t;\n \n-  /* Declaration of a deduction guide can look inside the primary class\n-     template; replace a compatible type with the real one.  */\n-  if (cxx_dialect >= cxx1z\n-      && scope_chain->deduction_guide_type\n-      && same_type_p (type, scope_chain->deduction_guide_type))\n-    type = scope_chain->deduction_guide_type;\n-\n   if (!basetype_path)\n     basetype_path = TYPE_BINFO (type);\n "}, {"sha": "ee21d147fd6528fdaa714c703fac957a1403c9de", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction37.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8d25fd0dd7e0feffc395ff1db1f2e9d815fb78a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8d25fd0dd7e0feffc395ff1db1f2e9d815fb78a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction37.C?ref=a8d25fd0dd7e0feffc395ff1db1f2e9d815fb78a", "patch": "@@ -1,16 +0,0 @@\n-// { dg-options -std=c++1z }\n-\n-template <class T> struct A\n-{\n-  using value_t = T;\n-  A(value_t);\n-};\n-\n-template <class T>\n-A(typename A<T>::value_t) -> A<double>;\n-\n-template <class,class> struct same;\n-template <class T> struct same<T,T> {};\n-\n-A a(42);\n-same<decltype(a),A<double>> s1;"}]}