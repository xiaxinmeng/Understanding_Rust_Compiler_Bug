{"sha": "d2f7fa08bd557db89d771b648631bb98c61a631e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJmN2ZhMDhiZDU1N2RiODlkNzcxYjY0ODYzMWJiOThjNjFhNjMxZQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2020-02-11T00:21:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-08T07:50:54Z"}, "message": "[Ada] gnatbind: Deterministic No_Entry_Calls_In_Elaboration_Code messages\n\n2020-06-08  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* bindo-graphs.adb (function Add_Edge): Rename\n\tAdd_Edge_With_Return to Add_Edge; we can tell it returns because\n\tit's a function, and overloading seems appropriate in this case.\n\tIf Activates_Task=True, and we're not going to add a new edge\n\tbecause an existing Pred-->Succ edge already exists, then set\n\tActivates_Task to True on the preexisting edge.  This ensures\n\tthat the message:\n\n\tinfo: use pragma Restrictions (No_Entry_Calls_In_Elaboration_Code)\n\n\tappears when appropriate, no matter in what order the edges\n\thappened to be processed.\n\t(procedure Add_Edge): Remove redundant assertions.\n\t(Activates_Task): Other kinds of edges can have\n\tActivates_Task=True.  For example, if we had a With_Edge and\n\tthen an Invocation_Edge with Activates_Task=True, then the\n\tWith_Edge has Activates_Task set to True.\n\t(Add_Edge_Kind_Check): New procedure to prevent other bugs of\n\tthis nature. For example, if we were to sometimes call Add_Edge\n\tfor a Spec_Before_Body_Edge followed by Add_Edge for a\n\tWith_Edge, and sometimes in the other order, that would cause a\n\tsimilar bug to what we're fixing here.\n\t(Set_Is_Recorded_Edge): Val parameter is not used. Get rid of\n\tit.\n\t(Set_Activates_Task): New procedure to set the Activates_Task flag.\n\t* bindo-graphs.ads (Library_Graph_Edge_Kind): Reorder the\n\tenumeration literals to facilitate Add_Edge_Kind_Check.\n\t* ali.adb (Known_ALI_Lines): The comment about \"still available\"\n\twas wrong. Fix that by erasing the comment, and encoding the\n\trelevant information in real code. Take advantage of Ada's full\n\tcoverage rules by removing \"others =>\".  Also DRY.", "tree": {"sha": "85f3a2a14c330404c4592e7b66c3bfddadc5eea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85f3a2a14c330404c4592e7b66c3bfddadc5eea3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2f7fa08bd557db89d771b648631bb98c61a631e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2f7fa08bd557db89d771b648631bb98c61a631e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2f7fa08bd557db89d771b648631bb98c61a631e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2f7fa08bd557db89d771b648631bb98c61a631e/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f7294f23e87c4e0a48e50814ab7bb9a4a756a9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7294f23e87c4e0a48e50814ab7bb9a4a756a9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7294f23e87c4e0a48e50814ab7bb9a4a756a9f"}], "stats": {"total": 277, "additions": 198, "deletions": 79}, "files": [{"sha": "6b0d6c75d45427ba15c8e92f3e898738e96cc614", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f7fa08bd557db89d771b648631bb98c61a631e/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f7fa08bd557db89d771b648631bb98c61a631e/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=d2f7fa08bd557db89d771b648631bb98c61a631e", "patch": "@@ -242,31 +242,33 @@ package body ALI is\n \n    --  The following variable records which characters currently are used as\n    --  line type markers in the ALI file. This is used in Scan_ALI to detect\n-   --  (or skip) invalid lines. The following letters are still available:\n-   --\n-   --    B F H J K O Q Z\n+   --  (or skip) invalid lines.\n \n    Known_ALI_Lines : constant array (Character range 'A' .. 'Z') of Boolean :=\n-     ('A'    => True,  --  argument\n-      'C'    => True,  --  SCO information\n-      'D'    => True,  --  dependency\n-      'E'    => True,  --  external\n-      'G'    => True,  --  invocation graph\n-      'I'    => True,  --  interrupt\n-      'L'    => True,  --  linker option\n-      'M'    => True,  --  main program\n-      'N'    => True,  --  notes\n-      'P'    => True,  --  program\n-      'R'    => True,  --  restriction\n-      'S'    => True,  --  specific dispatching\n-      'T'    => True,  --  task stack information\n-      'U'    => True,  --  unit\n-      'V'    => True,  --  version\n-      'W'    => True,  --  with\n-      'X'    => True,  --  xref\n-      'Y'    => True,  --  limited_with\n-      'Z'    => True,  --  implicit with from instantiation\n-      others => False);\n+     ('A' | --  argument\n+      'C' | --  SCO information\n+      'D' | --  dependency\n+      'E' | --  external\n+      'G' | --  invocation graph\n+      'I' | --  interrupt\n+      'L' | --  linker option\n+      'M' | --  main program\n+      'N' | --  notes\n+      'P' | --  program\n+      'R' | --  restriction\n+      'S' | --  specific dispatching\n+      'T' | --  task stack information\n+      'U' | --  unit\n+      'V' | --  version\n+      'W' | --  with\n+      'X' | --  xref\n+      'Y' | --  limited_with\n+      'Z'   --  implicit with from instantiation\n+          => True,\n+\n+      --  Still available:\n+\n+      'B' | 'F' | 'H' | 'J' | 'K' | 'O' | 'Q' => False);\n \n    ------------------------------\n    -- Add_Invocation_Construct --"}, {"sha": "cb9cb12853db73c052569ec4520ba8341b47c9f2", "filename": "gcc/ada/bindo-graphs.adb", "status": "modified", "additions": 163, "deletions": 49, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f7fa08bd557db89d771b648631bb98c61a631e/gcc%2Fada%2Fbindo-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f7fa08bd557db89d771b648631bb98c61a631e/gcc%2Fada%2Fbindo-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.adb?ref=d2f7fa08bd557db89d771b648631bb98c61a631e", "patch": "@@ -1060,18 +1060,30 @@ package body Bindo.Graphs is\n       --  corresponding specs or bodies, where the body is a predecessor\n       --  and the spec is a successor. Add all edges to list Edges.\n \n-      function Add_Edge_With_Return\n+      procedure Add_Edge_Kind_Check\n+        (G              : Library_Graph;\n+         Pred           : Library_Graph_Vertex_Id;\n+         Succ           : Library_Graph_Vertex_Id;\n+         Kind           : Library_Graph_Edge_Kind);\n+      --  This is called by Add_Edge in the case where there is already a\n+      --  Pred-->Succ edge, to assert that the new Kind is appropriate. Raises\n+      --  Program_Error if a bug is detected. The purpose is to prevent bugs\n+      --  where calling Add_Edge in different orders produces different output.\n+\n+      function Add_Edge\n         (G              : Library_Graph;\n          Pred           : Library_Graph_Vertex_Id;\n          Succ           : Library_Graph_Vertex_Id;\n          Kind           : Library_Graph_Edge_Kind;\n          Activates_Task : Boolean) return Library_Graph_Edge_Id;\n-      pragma Inline (Add_Edge_With_Return);\n+      pragma Inline (Add_Edge);\n       --  Create a new edge in library graph G with source vertex Pred and\n       --  destination vertex Succ, and return its handle. Kind denotes the\n       --  nature of the edge. Activates_Task should be set when the edge\n       --  involves a task activation. If Pred and Succ are already related,\n-      --  no edge is created and No_Library_Graph_Edge is returned.\n+      --  no edge is created and No_Library_Graph_Edge is returned, but if\n+      --  Activates_Task is True, then the flag of the existing edge is\n+      --  updated.\n \n       function At_Least_One_Edge_Satisfies\n         (G         : Library_Graph;\n@@ -1277,6 +1289,12 @@ package body Bindo.Graphs is\n       --    * Cycle_Limit is the upper bound of the number of cycles to be\n       --      discovered.\n \n+      function Find_Edge\n+        (G    : Library_Graph;\n+         Pred : Library_Graph_Vertex_Id;\n+         Succ : Library_Graph_Vertex_Id) return Library_Graph_Edge_Id;\n+      --  There must be an edge Pred-->Succ; this returns it\n+\n       function Find_First_Lower_Precedence_Cycle\n         (G     : Library_Graph;\n          Cycle : Library_Graph_Cycle_Id) return Library_Graph_Cycle_Id;\n@@ -1502,6 +1520,11 @@ package body Bindo.Graphs is\n       --  is the number of invocation edges along the cycle path. Indent is\n       --  the desired indentation level for tracing.\n \n+      procedure Set_Activates_Task\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id);\n+      --  Set the Activates_Task flag of the Edge to True\n+\n       procedure Set_Component_Attributes\n         (G    : Library_Graph;\n          Comp : Component_Id;\n@@ -1518,11 +1541,10 @@ package body Bindo.Graphs is\n \n       procedure Set_Is_Recorded_Edge\n         (G   : Library_Graph;\n-         Rel : Predecessor_Successor_Relation;\n-         Val : Boolean := True);\n+         Rel : Predecessor_Successor_Relation);\n       pragma Inline (Set_Is_Recorded_Edge);\n       --  Mark a predecessor vertex and a successor vertex described by\n-      --  relation Rel as already linked depending on value Val.\n+      --  relation Rel as already linked.\n \n       procedure Set_LGC_Attributes\n         (G     : Library_Graph;\n@@ -1635,12 +1657,7 @@ package body Bindo.Graphs is\n          Edge : Library_Graph_Edge_Id) return Boolean\n       is\n       begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Edge));\n-\n-         return\n-           Kind (G, Edge) = Invocation_Edge\n-            and then Get_LGE_Attributes (G, Edge).Activates_Task;\n+         return Get_LGE_Attributes (G, Edge).Activates_Task;\n       end Activates_Task;\n \n       -------------------------------\n@@ -1674,7 +1691,7 @@ package body Bindo.Graphs is\n          --  the body may be visited first, yet Corresponding_Item will still\n          --  attempt to create the Body_Before_Spec edge. This is OK because\n          --  successor and predecessor are kept consistent in both cases, and\n-         --  Add_Edge_With_Return will prevent the creation of the second edge.\n+         --  Add_Edge will prevent the creation of the second edge.\n \n          --  Assume that no Body_Before_Spec is necessary\n \n@@ -1684,7 +1701,7 @@ package body Bindo.Graphs is\n \n          if Is_Body_With_Spec (G, Vertex) then\n             Edge :=\n-              Add_Edge_With_Return\n+              Add_Edge\n                 (G              => G,\n                  Pred           => Vertex,\n                  Succ           => Corresponding_Item (G, Vertex),\n@@ -1695,7 +1712,7 @@ package body Bindo.Graphs is\n \n          elsif Is_Spec_With_Body (G, Vertex) then\n             Edge :=\n-              Add_Edge_With_Return\n+              Add_Edge\n                 (G              => G,\n                  Pred           => Corresponding_Item (G, Vertex),\n                  Succ           => Vertex,\n@@ -1745,30 +1762,72 @@ package body Bindo.Graphs is\n          Kind           : Library_Graph_Edge_Kind;\n          Activates_Task : Boolean)\n       is\n-         Edge : Library_Graph_Edge_Id;\n-         pragma Unreferenced (Edge);\n-\n-      begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Pred));\n-         pragma Assert (Present (Succ));\n-         pragma Assert (Kind /= No_Edge);\n-         pragma Assert (not Activates_Task or else Kind = Invocation_Edge);\n-\n-         Edge :=\n-           Add_Edge_With_Return\n+         Ignore : constant Library_Graph_Edge_Id :=\n+           Add_Edge\n              (G              => G,\n               Pred           => Pred,\n               Succ           => Succ,\n               Kind           => Kind,\n               Activates_Task => Activates_Task);\n+      begin\n+         null;\n       end Add_Edge;\n \n-      --------------------------\n-      -- Add_Edge_With_Return --\n-      --------------------------\n+      -------------------------\n+      -- Add_Edge_Kind_Check --\n+      -------------------------\n+\n+      procedure Add_Edge_Kind_Check\n+        (G              : Library_Graph;\n+         Pred           : Library_Graph_Vertex_Id;\n+         Succ           : Library_Graph_Vertex_Id;\n+         Kind           : Library_Graph_Edge_Kind)\n+      is\n+         Old_Edge : constant Library_Graph_Edge_Id :=\n+           Find_Edge (G, Pred, Succ);\n+         Attributes : constant Library_Graph_Edge_Attributes :=\n+           Get_LGE_Attributes (G, Old_Edge);\n+         OK : Boolean;\n+      begin\n+         case Kind is\n+            --  We call Add_Edge with Body_Before_Spec_Edge twice -- once\n+            --  for  the spec and once for the body, but no other Kind can\n+            --  be spec-->body.\n+\n+            when Body_Before_Spec_Edge =>\n+               OK := Attributes.Kind = Body_Before_Spec_Edge;\n+\n+            --  Spec_Before_Body_Edge comes first\n+\n+            when Spec_Before_Body_Edge =>\n+               OK := False;\n+\n+            --  With clauses and forced edges come after Spec_Before_Body_Edge\n+\n+            when With_Edge | Elaborate_Edge | Elaborate_All_Edge\n+              | Forced_Edge =>\n+               OK := Attributes.Kind <= Kind;\n+\n+            --  Invocation_Edge can come after anything, including another\n+            --  Invocation_Edge.\n+\n+            when Invocation_Edge =>\n+               OK := True;\n+\n+            when No_Edge =>\n+               OK := False;\n+         end case;\n+\n+         if not OK then\n+            raise Program_Error;\n+         end if;\n+      end Add_Edge_Kind_Check;\n+\n+      --------------\n+      -- Add_Edge --\n+      --------------\n \n-      function Add_Edge_With_Return\n+      function Add_Edge\n         (G              : Library_Graph;\n          Pred           : Library_Graph_Vertex_Id;\n          Succ           : Library_Graph_Vertex_Id;\n@@ -1778,19 +1837,29 @@ package body Bindo.Graphs is\n          pragma Assert (Present (G));\n          pragma Assert (Present (Pred));\n          pragma Assert (Present (Succ));\n-         pragma Assert (Kind /= No_Edge);\n+         pragma Assert (Kind = Invocation_Edge or else not Activates_Task);\n+         --  Only invocation edges can activate tasks\n \n          Rel : constant Predecessor_Successor_Relation :=\n-                 (Predecessor => Pred,\n-                  Successor   => Succ);\n+           (Predecessor => Pred, Successor => Succ);\n \n          Edge : Library_Graph_Edge_Id;\n \n       begin\n-         --  Nothing to do when the predecessor and successor are already\n-         --  related by an edge.\n+         --  If we already have a Pred-->Succ edge, we don't add another\n+         --  one. But we need to update Activates_Task, in order to avoid\n+         --  depending on the order of processing of edges. If we have\n+         --  Pred-->Succ with Activates_Task=True, and another Pred-->Succ with\n+         --  Activates_Task=False, we want Activates_Task to be True no matter\n+         --  which order we processed those two Add_Edge calls.\n \n          if Is_Recorded_Edge (G, Rel) then\n+            pragma Debug (Add_Edge_Kind_Check (G, Pred, Succ, Kind));\n+\n+            if Activates_Task then\n+               Set_Activates_Task (G, Find_Edge (G, Pred, Succ));\n+            end if;\n+\n             return No_Library_Graph_Edge;\n          end if;\n \n@@ -1834,7 +1903,7 @@ package body Bindo.Graphs is\n          Increment_Library_Graph_Edge_Count (G, Kind);\n \n          return Edge;\n-      end Add_Edge_With_Return;\n+      end Add_Edge;\n \n       ----------------\n       -- Add_Vertex --\n@@ -3141,6 +3210,44 @@ package body Bindo.Graphs is\n          LGV_Lists.Destroy (Visited_Stack);\n       end Find_Cycles_In_Component;\n \n+      ---------------\n+      -- Find_Edge --\n+      ---------------\n+\n+      function Find_Edge\n+        (G    : Library_Graph;\n+         Pred : Library_Graph_Vertex_Id;\n+         Succ : Library_Graph_Vertex_Id) return Library_Graph_Edge_Id\n+      is\n+         Result : Library_Graph_Edge_Id := No_Library_Graph_Edge;\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : Edges_To_Successors_Iterator :=\n+           Iterate_Edges_To_Successors (G, Pred);\n+\n+      begin\n+         --  IMPORTANT:\n+         --\n+         --    * The iteration must run to completion in order to unlock the\n+         --      edges to successors.\n+\n+         --  This does a linear search through the successors of Pred.\n+         --  Efficiency is not a problem, because this is called only when\n+         --  Activates_Task is True, which is rare, and anyway, there aren't\n+         --  usually large numbers of successors.\n+\n+         while Has_Next (Iter) loop\n+            Next (Iter, Edge);\n+\n+            if Succ = Successor (G, Edge) then\n+               pragma Assert (not Present (Result));\n+               Result := Edge;\n+            end if;\n+         end loop;\n+\n+         pragma Assert (Present (Result));\n+         return Result;\n+      end Find_Edge;\n+\n       ---------------------------------------\n       -- Find_First_Lower_Precedence_Cycle --\n       ---------------------------------------\n@@ -4459,9 +4566,6 @@ package body Bindo.Graphs is\n          Edge : Library_Graph_Edge_Id) return Library_Graph_Edge_Kind\n       is\n       begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Edge));\n-\n          return Get_LGE_Attributes (G, Edge).Kind;\n       end Kind;\n \n@@ -5097,6 +5201,21 @@ package body Bindo.Graphs is\n               and then LGE_Lists.Equal (Left.Path, Right.Path);\n       end Same_Library_Graph_Cycle_Attributes;\n \n+      ------------------------\n+      -- Set_Activates_Task --\n+      ------------------------\n+\n+      procedure Set_Activates_Task\n+        (G    : Library_Graph;\n+         Edge : Library_Graph_Edge_Id)\n+      is\n+         Attributes : Library_Graph_Edge_Attributes :=\n+           Get_LGE_Attributes (G, Edge);\n+      begin\n+         Attributes.Activates_Task := True;\n+         Set_LGE_Attributes (G, Edge, Attributes);\n+      end Set_Activates_Task;\n+\n       ------------------------------\n       -- Set_Component_Attributes --\n       ------------------------------\n@@ -5175,19 +5294,14 @@ package body Bindo.Graphs is\n \n       procedure Set_Is_Recorded_Edge\n         (G   : Library_Graph;\n-         Rel : Predecessor_Successor_Relation;\n-         Val : Boolean := True)\n+         Rel : Predecessor_Successor_Relation)\n       is\n       begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Rel.Predecessor));\n          pragma Assert (Present (Rel.Successor));\n \n-         if Val then\n-            RE_Sets.Insert (G.Recorded_Edges, Rel);\n-         else\n-            RE_Sets.Delete (G.Recorded_Edges, Rel);\n-         end if;\n+         RE_Sets.Insert (G.Recorded_Edges, Rel);\n       end Set_Is_Recorded_Edge;\n \n       ------------------------\n@@ -5211,9 +5325,9 @@ package body Bindo.Graphs is\n       ------------------------\n \n       procedure Set_LGE_Attributes\n-        (G      : Library_Graph;\n+        (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id;\n-         Val    : Library_Graph_Edge_Attributes)\n+         Val  : Library_Graph_Edge_Attributes)\n       is\n       begin\n          pragma Assert (Present (G));"}, {"sha": "21278aabbaab96756b4e48d79e980a160fcba631", "filename": "gcc/ada/bindo-graphs.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f7fa08bd557db89d771b648631bb98c61a631e/gcc%2Fada%2Fbindo-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f7fa08bd557db89d771b648631bb98c61a631e/gcc%2Fada%2Fbindo-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.ads?ref=d2f7fa08bd557db89d771b648631bb98c61a631e", "patch": "@@ -702,14 +702,23 @@ package Bindo.Graphs is\n \n          No_Cycle_Kind);\n \n-      --  The following type represents the various kinds of library edges\n+      --  The following type represents the various kinds of library edges.\n+      --  The order is important here, and roughly corresponds to the order\n+      --  in which edges are added to the graph. See Add_Edge_Kind_Check for\n+      --  details.\n \n       type Library_Graph_Edge_Kind is\n         (Body_Before_Spec_Edge,\n          --  Successor denotes spec, Predecessor denotes a body. This is a\n          --  special edge kind used only during the discovery of components.\n          --  Note that a body can never be elaborated before its spec.\n \n+         Spec_Before_Body_Edge,\n+         --  Successor denotes a body, Predecessor denotes a spec\n+\n+         With_Edge,\n+         --  Successor withs Predecessor\n+\n          Elaborate_Edge,\n          --  Successor withs Predecessor, and has pragma Elaborate for it\n \n@@ -724,12 +733,6 @@ package Bindo.Graphs is\n          --  An invocation construct in unit Successor invokes a target in unit\n          --  Predecessor.\n \n-         Spec_Before_Body_Edge,\n-         --  Successor denotes a body, Predecessor denotes a spec\n-\n-         With_Edge,\n-         --  Successor withs Predecessor\n-\n          No_Edge);\n \n       -----------"}]}