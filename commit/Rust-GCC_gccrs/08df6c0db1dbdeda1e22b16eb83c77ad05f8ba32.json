{"sha": "08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhkZjZjMGRiMWRiZGVkYTFlMjJiMTZlYjgzYzc3YWQwNWY4YmEzMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-08-02T00:34:11Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-08-02T00:34:11Z"}, "message": "re PR debug/52983 (internal compiler error: in df_uses_record, at df-scan.c:3243)\n\nPR debug/52983\n* valtrack.h, valtrack.c: New.\n* Makefile.in (VALTRACK_H): New.\n(OBJS): Add valtrack.o.\n(valtrack.o): New.\n(cselib.o, dce.o, df-problems.o, combine.o): Add VALTRACK_H.\n* combine.c: Include valtrack.h.\n(make_compound_operation): Publish.\n(cleanup_auto_inc_dec): Move to valtrack.c.\n(struct rtx_subst_pair, propagate_for_debug_subst): Likewise.\n(propagate_for_debug): Likewise.  Add this_basic_block parameter.\nAdjust all callers.\n* cselib.c: Include valtrack.h.\n* dce.c: Likewise.\n* df-problems.c: Likewise.\n(dead_debug_init, dead_debug_reset_uses): Move to valtrack.c.\n(dead_debug_finish, dead_debug_add): Likewise.\n(dead_debug_insert_temp): Likewise.\n* df.h (struct dead_debug_use): Move to valtrack.h.\n(struct dead_debug, enum debug_temp_where): Likewise.\n(dead_debug_init, dead_debug_reset_uses): Move to valtrack.h.\n(dead_debug_finish, dead_debug_add): Likewise.\n(dead_debug_insert_temp): Likewise.\n* rtl.h (make_compound_operation): Declare.\n\nFrom-SVN: r190061", "tree": {"sha": "e8586f90b0101adcc1ada9b7625fd4d25cb71a67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8586f90b0101adcc1ada9b7625fd4d25cb71a67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/comments", "author": null, "committer": null, "parents": [{"sha": "57e8ecc3bacd6f3794c535eafc3114b56b40321b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e8ecc3bacd6f3794c535eafc3114b56b40321b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57e8ecc3bacd6f3794c535eafc3114b56b40321b"}], "stats": {"total": 1141, "additions": 624, "deletions": 517}, "files": [{"sha": "ea9a7b1422222d384cf0a8cb5f20fa26db683088", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -1,3 +1,30 @@\n+2012-08-01  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/52983\n+\t* valtrack.h, valtrack.c: New.\n+\t* Makefile.in (VALTRACK_H): New.\n+\t(OBJS): Add valtrack.o.\n+\t(valtrack.o): New.\n+\t(cselib.o, dce.o, df-problems.o, combine.o): Add VALTRACK_H.\n+\t* combine.c: Include valtrack.h.\n+\t(make_compound_operation): Publish.\n+\t(cleanup_auto_inc_dec): Move to valtrack.c.\n+\t(struct rtx_subst_pair, propagate_for_debug_subst): Likewise.\n+\t(propagate_for_debug): Likewise.  Add this_basic_block parameter.\n+\tAdjust all callers.\n+\t* cselib.c: Include valtrack.h.\n+\t* dce.c: Likewise.\n+\t* df-problems.c: Likewise.\n+\t(dead_debug_init, dead_debug_reset_uses): Move to valtrack.c.\n+\t(dead_debug_finish, dead_debug_add): Likewise.\n+\t(dead_debug_insert_temp): Likewise.\n+\t* df.h (struct dead_debug_use): Move to valtrack.h.\n+\t(struct dead_debug, enum debug_temp_where): Likewise.\n+\t(dead_debug_init, dead_debug_reset_uses): Move to valtrack.h.\n+\t(dead_debug_finish, dead_debug_add): Likewise.\n+\t(dead_debug_insert_temp): Likewise.\n+\t* rtl.h (make_compound_operation): Declare.\n+\n 2012-08-01  Catherine Moore  <clm@codesourcery.com>\n \t    Sandra Loosemore  <sandra@codesourcery.com>\n "}, {"sha": "b2c4d4f656d943bc8bdfe70a49745edfe2d9c29e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -904,6 +904,7 @@ CGRAPH_H = cgraph.h $(VEC_H) $(TREE_H) $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n \tcif-code.def ipa-ref.h ipa-ref-inline.h $(LINKER_PLUGIN_API_H)\n DF_H = df.h $(BITMAP_H) $(REGSET_H) sbitmap.h $(BASIC_BLOCK_H) \\\n \talloc-pool.h $(TIMEVAR_H)\n+VALTRACK_H = valtrack.h $(BITMAP_H) $(DF_H) $(RTL_H) $(BASIC_BLOCK_H)\n RESOURCE_H = resource.h hard-reg-set.h $(DF_H)\n DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h $(DIAGNOSTIC_CORE_H)\n@@ -1447,6 +1448,7 @@ OBJS = \\\n \ttree-vectorizer.o \\\n \ttree-vrp.o \\\n \ttree.o \\\n+\tvaltrack.o \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\\n \tvarasm.o \\\n@@ -2947,7 +2949,7 @@ cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    $(DF_H) $(DBGCNT_H)\n dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(EXCEPT_H) $(DF_H) cselib.h \\\n-   $(DBGCNT_H) dce.h $(TREE_PASS_H) $(DBGCNT_H) $(TM_P_H) \\\n+   $(DBGCNT_H) dce.h $(VALTRACK_H) $(TREE_PASS_H) $(DBGCNT_H) $(TM_P_H) \\\n    $(EMIT_RTL_H)\n dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n@@ -3039,7 +3041,7 @@ df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \\\n-   $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(EXCEPT_H) dce.h vecprim.h\n+   $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(EXCEPT_H) dce.h vecprim.h $(VALTRACK_H)\n df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h \\\n@@ -3048,6 +3050,8 @@ df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(R\n regstat.o : regstat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TM_P_H) $(FLAGS_H) $(REGS_H) $(EXCEPT_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(TIMEVAR_H) $(DF_H)\n+valtrack.o : valtrack.c $(VALTRACK_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   coretypes.h $(TM_H) $(FUNCTION_H) $(REGS_H) $(EMIT_RTL_H)\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) bitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n@@ -3144,9 +3148,10 @@ et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(FUNCTION_H) insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) hard-reg-set.h \\\n-   $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(TREE_H) $(TARGET_H) $(PARAMS_H) $(OPTABS_H) \\\n-   insn-codes.h $(TREE_PASS_H) $(DF_H) vecprim.h $(CGRAPH_H) \\\n-   $(OBSTACK_H)\n+   $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(TREE_H) $(TARGET_H) \\\n+   output.h $(PARAMS_H) $(OPTABS_H) \\\n+   insn-codes.h $(TREE_PASS_H) $(DF_H) $(VALTRACK_H) \\\n+   vecprim.h $(CGRAPH_H) $(OBSTACK_H)\n reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) addresses.h $(REGS_H) \\\n    insn-config.h $(RECOG_H) reload.h $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "dbc6ff6f9621b75b185c5261f3c8f6a1f3ba5bc6", "filename": "gcc/combine.c", "status": "modified", "additions": 16, "deletions": 164, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -100,6 +100,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n+#include \"valtrack.h\"\n #include \"cgraph.h\"\n #include \"obstack.h\"\n \n@@ -424,7 +425,6 @@ static const_rtx expand_field_assignment (const_rtx);\n static rtx make_extraction (enum machine_mode, rtx, HOST_WIDE_INT,\n \t\t\t    rtx, unsigned HOST_WIDE_INT, int, int, int);\n static rtx extract_left_shift (rtx, int);\n-static rtx make_compound_operation (rtx, enum rtx_code);\n static int get_pos_from_mask (unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT *);\n static rtx canon_reg_for_combine (rtx, rtx);\n@@ -2357,161 +2357,6 @@ reg_subword_p (rtx x, rtx reg)\n \t && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT;\n }\n \n-#ifdef AUTO_INC_DEC\n-/* Replace auto-increment addressing modes with explicit operations to access\n-   the same addresses without modifying the corresponding registers.  */\n-\n-static rtx\n-cleanup_auto_inc_dec (rtx src, enum machine_mode mem_mode)\n-{\n-  rtx x = src;\n-  const RTX_CODE code = GET_CODE (x);\n-  int i;\n-  const char *fmt;\n-\n-  switch (code)\n-    {\n-    case REG:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-    case SCRATCH:\n-      /* SCRATCH must be shared because they represent distinct values.  */\n-      return x;\n-    case CLOBBER:\n-      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n-\treturn x;\n-      break;\n-\n-    case CONST:\n-      if (shared_const_p (x))\n-\treturn x;\n-      break;\n-\n-    case MEM:\n-      mem_mode = GET_MODE (x);\n-      break;\n-\n-    case PRE_INC:\n-    case PRE_DEC:\n-      gcc_assert (mem_mode != VOIDmode && mem_mode != BLKmode);\n-      return gen_rtx_PLUS (GET_MODE (x),\n-\t\t\t   cleanup_auto_inc_dec (XEXP (x, 0), mem_mode),\n-\t\t\t   GEN_INT (code == PRE_INC\n-\t\t\t\t    ? GET_MODE_SIZE (mem_mode)\n-\t\t\t\t    : -GET_MODE_SIZE (mem_mode)));\n-\n-    case POST_INC:\n-    case POST_DEC:\n-    case PRE_MODIFY:\n-    case POST_MODIFY:\n-      return cleanup_auto_inc_dec (code == PRE_MODIFY\n-\t\t\t\t   ? XEXP (x, 1) : XEXP (x, 0),\n-\t\t\t\t   mem_mode);\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Copy the various flags, fields, and other information.  We assume\n-     that all fields need copying, and then clear the fields that should\n-     not be copied.  That is the sensible default behavior, and forces\n-     us to explicitly document why we are *not* copying a flag.  */\n-  x = shallow_copy_rtx (x);\n-\n-  /* We do not copy the USED flag, which is used as a mark bit during\n-     walks over the RTL.  */\n-  RTX_FLAG (x, used) = 0;\n-\n-  /* We do not copy FRAME_RELATED for INSNs.  */\n-  if (INSN_P (x))\n-    RTX_FLAG (x, frame_related) = 0;\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e')\n-      XEXP (x, i) = cleanup_auto_inc_dec (XEXP (x, i), mem_mode);\n-    else if (fmt[i] == 'E' || fmt[i] == 'V')\n-      {\n-\tint j;\n-\tXVEC (x, i) = rtvec_alloc (XVECLEN (x, i));\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  XVECEXP (x, i, j)\n-\t    = cleanup_auto_inc_dec (XVECEXP (src, i, j), mem_mode);\n-      }\n-\n-  return x;\n-}\n-#endif\n-\n-/* Auxiliary data structure for propagate_for_debug_stmt.  */\n-\n-struct rtx_subst_pair\n-{\n-  rtx to;\n-  bool adjusted;\n-};\n-\n-/* DATA points to an rtx_subst_pair.  Return the value that should be\n-   substituted.  */\n-\n-static rtx\n-propagate_for_debug_subst (rtx from, const_rtx old_rtx, void *data)\n-{\n-  struct rtx_subst_pair *pair = (struct rtx_subst_pair *)data;\n-\n-  if (!rtx_equal_p (from, old_rtx))\n-    return NULL_RTX;\n-  if (!pair->adjusted)\n-    {\n-      pair->adjusted = true;\n-#ifdef AUTO_INC_DEC\n-      pair->to = cleanup_auto_inc_dec (pair->to, VOIDmode);\n-#else\n-      pair->to = copy_rtx (pair->to);\n-#endif\n-      pair->to = make_compound_operation (pair->to, SET);\n-      return pair->to;\n-    }\n-  return copy_rtx (pair->to);\n-}\n-\n-/* Replace all the occurrences of DEST with SRC in DEBUG_INSNs between INSN\n-   and LAST, not including INSN, but including LAST.  Also stop at the end\n-   of THIS_BASIC_BLOCK.  */\n-\n-static void\n-propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src)\n-{\n-  rtx next, loc, end = NEXT_INSN (BB_END (this_basic_block));\n-\n-  struct rtx_subst_pair p;\n-  p.to = src;\n-  p.adjusted = false;\n-\n-  next = NEXT_INSN (insn);\n-  last = NEXT_INSN (last);\n-  while (next != last && next != end)\n-    {\n-      insn = next;\n-      next = NEXT_INSN (insn);\n-      if (DEBUG_INSN_P (insn))\n-\t{\n-\t  loc = simplify_replace_fn_rtx (INSN_VAR_LOCATION_LOC (insn),\n-\t\t\t\t\t dest, propagate_for_debug_subst, &p);\n-\t  if (loc == INSN_VAR_LOCATION_LOC (insn))\n-\t    continue;\n-\t  INSN_VAR_LOCATION_LOC (insn) = loc;\n-\t  df_insn_rescan (insn);\n-\t}\n-    }\n-}\n-\n /* Delete the unconditional jump INSN and adjust the CFG correspondingly.\n    Note that the INSN should be deleted *after* removing dead edges, so\n    that the kept edge is the fallthrough edge for a (set (pc) (pc))\n@@ -3971,7 +3816,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t\t   i2src while its original mode is temporarily\n \t\t   restored, and then clear i2scratch so that we don't\n \t\t   do it again later.  */\n-\t\tpropagate_for_debug (i2, last_combined_insn, reg, i2src);\n+\t\tpropagate_for_debug (i2, last_combined_insn, reg, i2src,\n+\t\t\t\t     this_basic_block);\n \t\ti2scratch = false;\n \t\t/* Put back the new mode.  */\n \t\tadjust_reg_mode (reg, new_mode);\n@@ -4005,10 +3851,12 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t\t   with this copy we have created; then, replace the\n \t\t   copy with the SUBREG of the original shared reg,\n \t\t   once again changed to the new mode.  */\n-\t\tpropagate_for_debug (first, last, reg, tempreg);\n+\t\tpropagate_for_debug (first, last, reg, tempreg,\n+\t\t\t\t     this_basic_block);\n \t\tadjust_reg_mode (reg, new_mode);\n \t\tpropagate_for_debug (first, last, tempreg,\n-\t\t\t\t     lowpart_subreg (old_mode, reg, new_mode));\n+\t\t\t\t     lowpart_subreg (old_mode, reg, new_mode),\n+\t\t\t\t     this_basic_block);\n \t      }\n \t  }\n     }\n@@ -4220,14 +4068,16 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n     if (newi2pat)\n       {\n \tif (MAY_HAVE_DEBUG_INSNS && i2scratch)\n-\t  propagate_for_debug (i2, last_combined_insn, i2dest, i2src);\n+\t  propagate_for_debug (i2, last_combined_insn, i2dest, i2src,\n+\t\t\t       this_basic_block);\n \tINSN_CODE (i2) = i2_code_number;\n \tPATTERN (i2) = newi2pat;\n       }\n     else\n       {\n \tif (MAY_HAVE_DEBUG_INSNS && i2src)\n-\t  propagate_for_debug (i2, last_combined_insn, i2dest, i2src);\n+\t  propagate_for_debug (i2, last_combined_insn, i2dest, i2src,\n+\t\t\t       this_basic_block);\n \tSET_INSN_DELETED (i2);\n       }\n \n@@ -4236,7 +4086,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \tLOG_LINKS (i1) = NULL;\n \tREG_NOTES (i1) = 0;\n \tif (MAY_HAVE_DEBUG_INSNS)\n-\t  propagate_for_debug (i1, last_combined_insn, i1dest, i1src);\n+\t  propagate_for_debug (i1, last_combined_insn, i1dest, i1src,\n+\t\t\t       this_basic_block);\n \tSET_INSN_DELETED (i1);\n       }\n \n@@ -4245,7 +4096,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \tLOG_LINKS (i0) = NULL;\n \tREG_NOTES (i0) = 0;\n \tif (MAY_HAVE_DEBUG_INSNS)\n-\t  propagate_for_debug (i0, last_combined_insn, i0dest, i0src);\n+\t  propagate_for_debug (i0, last_combined_insn, i0dest, i0src,\n+\t\t\t       this_basic_block);\n \tSET_INSN_DELETED (i0);\n       }\n \n@@ -7596,7 +7448,7 @@ extract_left_shift (rtx x, int count)\n    being kludges), it is MEM.  When processing the arguments of a comparison\n    or a COMPARE against zero, it is COMPARE.  */\n \n-static rtx\n+rtx\n make_compound_operation (rtx x, enum rtx_code in_code)\n {\n   enum rtx_code code = GET_CODE (x);"}, {"sha": "88a74b4274ea2f4e1e5a3ab1a55042eaa9053331", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"dumpfile.h\"\n #include \"cselib.h\"\n+#include \"valtrack.h\"\n #include \"params.h\"\n #include \"alloc-pool.h\"\n #include \"target.h\""}, {"sha": "c951865f765ca83ef1394b21e000e11b1766b21c", "filename": "gcc/dce.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"cselib.h\"\n #include \"dce.h\"\n+#include \"valtrack.h\"\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"tm_p.h\""}, {"sha": "8699304e0384fcff8ccf2528fed704f2ad14101c", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 306, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"dce.h\"\n #include \"vecprim.h\"\n+#include \"valtrack.h\"\n #include \"dumpfile.h\"\n \n /* Note that turning REG_DEAD_DEBUGGING on will cause\n@@ -3047,312 +3048,6 @@ df_create_unused_note (rtx insn, df_ref def,\n }\n \n \n-/* Initialize DEBUG to an empty list, and clear USED, if given.  */\n-void\n-dead_debug_init (struct dead_debug *debug, bitmap used)\n-{\n-  debug->head = NULL;\n-  debug->used = used;\n-  debug->to_rescan = NULL;\n-  if (used)\n-    bitmap_clear (used);\n-}\n-\n-/* Reset all debug uses in HEAD, and clear DEBUG->to_rescan bits of\n-   each reset insn.  DEBUG is not otherwise modified.  If HEAD is\n-   DEBUG->head, DEBUG->head will be set to NULL at the end.\n-   Otherwise, entries from DEBUG->head that pertain to reset insns\n-   will be removed, and only then rescanned.  */\n-\n-static void\n-dead_debug_reset_uses (struct dead_debug *debug, struct dead_debug_use *head)\n-{\n-  bool got_head = (debug->head == head);\n-  bitmap rescan;\n-  struct dead_debug_use **tailp = &debug->head;\n-  struct dead_debug_use *cur;\n-  bitmap_iterator bi;\n-  unsigned int uid;\n-\n-  if (got_head)\n-    rescan = NULL;\n-  else\n-    rescan = BITMAP_ALLOC (NULL);\n-\n-  while (head)\n-    {\n-      struct dead_debug_use *next = head->next;\n-      rtx insn;\n-\n-      insn = DF_REF_INSN (head->use);\n-      if (!next || DF_REF_INSN (next->use) != insn)\n-\t{\n-\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n-\t  if (got_head)\n-\t    df_insn_rescan_debug_internal (insn);\n-\t  else\n-\t    bitmap_set_bit (rescan, INSN_UID (insn));\n-\t  if (debug->to_rescan)\n-\t    bitmap_clear_bit (debug->to_rescan, INSN_UID (insn));\n-\t}\n-      XDELETE (head);\n-      head = next;\n-    }\n-\n-  if (got_head)\n-    {\n-      debug->head = NULL;\n-      return;\n-    }\n-\n-  while ((cur = *tailp))\n-    if (bitmap_bit_p (rescan, INSN_UID (DF_REF_INSN (cur->use))))\n-      {\n-\t*tailp = cur->next;\n-\tXDELETE (cur);\n-      }\n-    else\n-      tailp = &cur->next;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (rescan, 0, uid, bi)\n-    {\n-      struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n-      if (insn_info)\n-\tdf_insn_rescan_debug_internal (insn_info->insn);\n-    }\n-\n-  BITMAP_FREE (rescan);\n-}\n-\n-/* Reset all debug insns with pending uses.  Release the bitmap in it,\n-   unless it is USED.  USED must be the same bitmap passed to\n-   dead_debug_init.  */\n-void\n-dead_debug_finish (struct dead_debug *debug, bitmap used)\n-{\n-  if (debug->used != used)\n-    BITMAP_FREE (debug->used);\n-\n-  dead_debug_reset_uses (debug, debug->head);\n-\n-  if (debug->to_rescan)\n-    {\n-      bitmap_iterator bi;\n-      unsigned int uid;\n-\n-      EXECUTE_IF_SET_IN_BITMAP (debug->to_rescan, 0, uid, bi)\n-\t{\n-\t  struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n-\t  if (insn_info)\n-\t    df_insn_rescan (insn_info->insn);\n-\t}\n-      BITMAP_FREE (debug->to_rescan);\n-    }\n-}\n-\n-/* Add USE to DEBUG.  It must be a dead reference to UREGNO in a debug\n-   insn.  Create a bitmap for DEBUG as needed.  */\n-void\n-dead_debug_add (struct dead_debug *debug, df_ref use, unsigned int uregno)\n-{\n-  struct dead_debug_use *newddu = XNEW (struct dead_debug_use);\n-\n-  newddu->use = use;\n-  newddu->next = debug->head;\n-  debug->head = newddu;\n-\n-  if (!debug->used)\n-    debug->used = BITMAP_ALLOC (NULL);\n-\n-  /* ??? If we dealt with split multi-registers below, we should set\n-     all registers for the used mode in case of hardware\n-     registers.  */\n-  bitmap_set_bit (debug->used, uregno);\n-}\n-\n-/* If UREGNO is referenced by any entry in DEBUG, emit a debug insn\n-   before or after INSN (depending on WHERE), that binds a debug temp\n-   to the widest-mode use of UREGNO, if WHERE is *_WITH_REG, or the\n-   value stored in UREGNO by INSN otherwise, and replace all uses of\n-   UREGNO in DEBUG with uses of the debug temp.  INSN must be where\n-   UREGNO dies, if WHERE is *_BEFORE_*, or where it is set otherwise.\n-   Return the number of debug insns emitted.  */\n-int\n-dead_debug_insert_temp (struct dead_debug *debug, unsigned int uregno,\n-\t\t\trtx insn, enum debug_temp_where where)\n-{\n-  struct dead_debug_use **tailp = &debug->head;\n-  struct dead_debug_use *cur;\n-  struct dead_debug_use *uses = NULL;\n-  struct dead_debug_use **usesp = &uses;\n-  rtx reg = NULL;\n-  rtx breg;\n-  rtx dval;\n-  rtx bind;\n-\n-  if (!debug->used || !bitmap_clear_bit (debug->used, uregno))\n-    return 0;\n-\n-  /* Move all uses of uregno from debug->head to uses, setting mode to\n-     the widest referenced mode.  */\n-  while ((cur = *tailp))\n-    {\n-      if (DF_REF_REGNO (cur->use) == uregno)\n-\t{\n-\t  *usesp = cur;\n-\t  usesp = &cur->next;\n-\t  *tailp = cur->next;\n-\t  cur->next = NULL;\n-\t  if (!reg\n-\t      || (GET_MODE_BITSIZE (GET_MODE (reg))\n-\t\t  < GET_MODE_BITSIZE (GET_MODE (*DF_REF_REAL_LOC (cur->use)))))\n-\t    reg = *DF_REF_REAL_LOC (cur->use);\n-\t}\n-      else\n-\ttailp = &(*tailp)->next;\n-    }\n-\n-  /* We may have dangling bits in debug->used for registers that were part\n-     of a multi-register use, one component of which has been reset.  */\n-  if (reg == NULL)\n-    {\n-      gcc_checking_assert (!uses);\n-      return 0;\n-    }\n-\n-  gcc_checking_assert (uses);\n-\n-  breg = reg;\n-  /* Recover the expression INSN stores in REG.  */\n-  if (where == DEBUG_TEMP_BEFORE_WITH_VALUE)\n-    {\n-      rtx set = single_set (insn);\n-      rtx dest, src;\n-\n-      if (set)\n-\t{\n-\t  dest = SET_DEST (set);\n-\t  src = SET_SRC (set);\n-\t  /* Lose if the REG-setting insn is a CALL.  */\n-\t  if (GET_CODE (src) == CALL)\n-\t    {\n-\t      while (uses)\n-\t\t{\n-\t\t  cur = uses->next;\n-\t\t  XDELETE (uses);\n-\t\t  uses = cur;\n-\t\t}\n-\t      return 0;\n-\t    }\n-\t}\n-\n-      /* ??? Should we try to extract it from a PARALLEL?  */\n-      if (!set)\n-\tbreg = NULL;\n-      /* Cool, it's the same REG, we can use SRC.  */\n-      else if (dest == reg)\n-\tbreg = copy_rtx (src);\n-      else if (REG_P (dest))\n-\t{\n-\t  /* Hmm...  Something's fishy, we should be setting REG here.  */\n-\t  if (REGNO (dest) != REGNO (reg))\n-\t    breg = NULL;\n-\t  /* If we're not overwriting all the hardware registers that\n-\t     setting REG in its mode would, we won't know what to bind\n-\t     the debug temp to.  ??? We could bind the debug_expr to a\n-\t     CONCAT or PARALLEL with the split multi-registers, and\n-\t     replace them as we found the corresponding sets.  */\n-\t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n-\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n-\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n-\t    breg = NULL;\n-\t  /* Ok, it's the same (hardware) REG, but with a different\n-\t     mode, so SUBREG it.  */\n-\t  else\n-\t    breg = lowpart_subreg (GET_MODE (reg), copy_rtx (src),\n-\t\t\t\t   GET_MODE (dest));\n-\t}\n-      else if (GET_CODE (dest) == SUBREG)\n-\t{\n-\t  /* We should be setting REG here.  Lose.  */\n-\t  if (REGNO (SUBREG_REG (dest)) != REGNO (reg))\n-\t    breg = NULL;\n-\t  /* Lose if we're setting something other than the lowpart of\n-\t     REG.  */\n-\t  else if (!subreg_lowpart_p (dest))\n-\t    breg = NULL;\n-\t  /* If we're not overwriting all the hardware registers that\n-\t     setting REG in its mode would, we won't know what to bind\n-\t     the debug temp to.  */\n-\t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n-\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n-\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n-\t    breg = NULL;\n-\t  /* Yay, we can use SRC, just adjust its mode.  */\n-\t  else\n-\t    breg = lowpart_subreg (GET_MODE (reg), copy_rtx (src),\n-\t\t\t\t   GET_MODE (dest));\n-\t}\n-      /* Oh well, we're out of luck.  */\n-      else\n-\tbreg = NULL;\n-\n-      /* We couldn't figure out the value stored in REG, so reset all\n-\t of its pending debug uses.  */\n-      if (!breg)\n-\t{\n-\t  dead_debug_reset_uses (debug, uses);\n-\t  return 0;\n-\t}\n-    }\n-\n-  /* If there's a single (debug) use of an otherwise unused REG, and\n-     the debug use is not part of a larger expression, then it\n-     probably doesn't make sense to introduce a new debug temp.  */\n-  if (where == DEBUG_TEMP_AFTER_WITH_REG && !uses->next)\n-    {\n-      rtx next = DF_REF_INSN (uses->use);\n-\n-      if (DEBUG_INSN_P (next) && reg == INSN_VAR_LOCATION_LOC (next))\n-\t{\n-\t  XDELETE (uses);\n-\t  return 0;\n-\t}\n-    }\n-\n-  /* Create DEBUG_EXPR (and DEBUG_EXPR_DECL).  */\n-  dval = make_debug_expr_from_rtl (reg);\n-\n-  /* Emit a debug bind insn before the insn in which reg dies.  */\n-  bind = gen_rtx_VAR_LOCATION (GET_MODE (reg),\n-\t\t\t       DEBUG_EXPR_TREE_DECL (dval), breg,\n-\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n-\n-  if (where == DEBUG_TEMP_AFTER_WITH_REG)\n-    bind = emit_debug_insn_after (bind, insn);\n-  else\n-    bind = emit_debug_insn_before (bind, insn);\n-  df_insn_rescan (bind);\n-\n-  /* Adjust all uses.  */\n-  while ((cur = uses))\n-    {\n-      if (GET_MODE (*DF_REF_REAL_LOC (cur->use)) == GET_MODE (reg))\n-\t*DF_REF_REAL_LOC (cur->use) = dval;\n-      else\n-\t*DF_REF_REAL_LOC (cur->use)\n-\t  = gen_lowpart_SUBREG (GET_MODE (*DF_REF_REAL_LOC (cur->use)), dval);\n-      /* ??? Should we simplify subreg of subreg?  */\n-      if (debug->to_rescan == NULL)\n-\tdebug->to_rescan = BITMAP_ALLOC (NULL);\n-      bitmap_set_bit (debug->to_rescan, INSN_UID (DF_REF_INSN (cur->use)));\n-      uses = cur->next;\n-      XDELETE (cur);\n-    }\n-\n-  return 1;\n-}\n-\n /* Recompute the REG_DEAD and REG_UNUSED notes and compute register\n    info: lifetime, bb, and number of defs and uses for basic block\n    BB.  The three bitvectors are scratch regs used here.  */"}, {"sha": "e59ae126f2e8e8b81c0e2d37e6dcde2976fb475b", "filename": "gcc/df.h", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -1101,46 +1101,4 @@ extern void union_defs (df_ref, struct web_entry *,\n \t\t\tunsigned int *used, struct web_entry *,\n \t\t\tbool (*fun) (struct web_entry *, struct web_entry *));\n \n-/* Debug uses of dead regs.  */\n-\n-/* Node of a linked list of uses of dead REGs in debug insns.  */\n-struct dead_debug_use\n-{\n-  df_ref use;\n-  struct dead_debug_use *next;\n-};\n-\n-/* Linked list of the above, with a bitmap of the REGs in the\n-   list.  */\n-struct dead_debug\n-{\n-  struct dead_debug_use *head;\n-  bitmap used;\n-  bitmap to_rescan;\n-};\n-\n-/* This type controls the behavior of dead_debug_insert_temp WRT\n-   UREGNO and INSN.  */\n-enum debug_temp_where\n-  {\n-    /* Bind a newly-created debug temporary to a REG for UREGNO, and\n-       insert the debug insn before INSN.  REG is expected to die at\n-       INSN.  */\n-    DEBUG_TEMP_BEFORE_WITH_REG = -1,\n-    /* Bind a newly-created debug temporary to the value INSN stores\n-       in REG, and insert the debug insn before INSN.  */\n-    DEBUG_TEMP_BEFORE_WITH_VALUE = 0,\n-    /* Bind a newly-created debug temporary to a REG for UREGNO, and\n-       insert the debug insn after INSN.  REG is expected to be set at\n-       INSN.  */\n-    DEBUG_TEMP_AFTER_WITH_REG = 1\n-  };\n-\n-extern void dead_debug_init (struct dead_debug *, bitmap);\n-extern void dead_debug_finish (struct dead_debug *, bitmap);\n-extern void dead_debug_add (struct dead_debug *, df_ref, unsigned int);\n-extern int dead_debug_insert_temp (struct dead_debug *,\n-\t\t\t\t   unsigned int uregno, rtx insn,\n-\t\t\t\t   enum debug_temp_where);\n-\n #endif /* GCC_DF_H */"}, {"sha": "82c3e59f7c273b95e8ac3f2ccb854fcb00d26e5f", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -2460,6 +2460,7 @@ extern unsigned int extended_count (const_rtx, enum machine_mode, int);\n extern rtx remove_death (unsigned int, rtx);\n extern void dump_combine_stats (FILE *);\n extern void dump_combine_total_stats (FILE *);\n+extern rtx make_compound_operation (rtx, enum rtx_code);\n \n /* In cfgcleanup.c  */\n extern void delete_dead_jumptables (void);"}, {"sha": "3e03599ac682573eace7ecedbfb51aed5a404399", "filename": "gcc/valtrack.c", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -0,0 +1,492 @@\n+/* Infrastructure for tracking user variable locations and values\n+   throughout compilation.\n+   Copyright (C) 2010, 2011, 2012  Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva <aoliva@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"valtrack.h\"\n+#include \"function.h\"\n+#include \"regs.h\"\n+#include \"emit-rtl.h\"\n+\n+/* Replace auto-increment addressing modes with explicit operations to access\n+   the same addresses without modifying the corresponding registers.  */\n+\n+#ifdef AUTO_INC_DEC\n+static rtx\n+cleanup_auto_inc_dec (rtx src, enum machine_mode mem_mode ATTRIBUTE_UNUSED)\n+{\n+  rtx x = src;\n+  const RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+      /* SCRATCH must be shared because they represent distinct values.  */\n+      return x;\n+    case CLOBBER:\n+      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n+\treturn x;\n+      break;\n+\n+    case CONST:\n+      if (shared_const_p (x))\n+\treturn x;\n+      break;\n+\n+    case MEM:\n+      mem_mode = GET_MODE (x);\n+      break;\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+      gcc_assert (mem_mode != VOIDmode && mem_mode != BLKmode);\n+      return gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t   cleanup_auto_inc_dec (XEXP (x, 0), mem_mode),\n+\t\t\t   GEN_INT (code == PRE_INC\n+\t\t\t\t    ? GET_MODE_SIZE (mem_mode)\n+\t\t\t\t    : -GET_MODE_SIZE (mem_mode)));\n+\n+    case POST_INC:\n+    case POST_DEC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return cleanup_auto_inc_dec (code == PRE_MODIFY\n+\t\t\t\t   ? XEXP (x, 1) : XEXP (x, 0),\n+\t\t\t\t   mem_mode);\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Copy the various flags, fields, and other information.  We assume\n+     that all fields need copying, and then clear the fields that should\n+     not be copied.  That is the sensible default behavior, and forces\n+     us to explicitly document why we are *not* copying a flag.  */\n+  x = shallow_copy_rtx (x);\n+\n+  /* We do not copy the USED flag, which is used as a mark bit during\n+     walks over the RTL.  */\n+  RTX_FLAG (x, used) = 0;\n+\n+  /* We do not copy FRAME_RELATED for INSNs.  */\n+  if (INSN_P (x))\n+    RTX_FLAG (x, frame_related) = 0;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      XEXP (x, i) = cleanup_auto_inc_dec (XEXP (x, i), mem_mode);\n+    else if (fmt[i] == 'E' || fmt[i] == 'V')\n+      {\n+\tint j;\n+\tXVEC (x, i) = rtvec_alloc (XVECLEN (x, i));\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  XVECEXP (x, i, j)\n+\t    = cleanup_auto_inc_dec (XVECEXP (src, i, j), mem_mode);\n+      }\n+\n+  return x;\n+}\n+#endif\n+\n+/* Auxiliary data structure for propagate_for_debug_stmt.  */\n+\n+struct rtx_subst_pair\n+{\n+  rtx to;\n+  bool adjusted;\n+};\n+\n+/* DATA points to an rtx_subst_pair.  Return the value that should be\n+   substituted.  */\n+\n+static rtx\n+propagate_for_debug_subst (rtx from, const_rtx old_rtx, void *data)\n+{\n+  struct rtx_subst_pair *pair = (struct rtx_subst_pair *)data;\n+\n+  if (!rtx_equal_p (from, old_rtx))\n+    return NULL_RTX;\n+  if (!pair->adjusted)\n+    {\n+      pair->adjusted = true;\n+#ifdef AUTO_INC_DEC\n+      pair->to = cleanup_auto_inc_dec (pair->to, VOIDmode);\n+#else\n+      pair->to = copy_rtx (pair->to);\n+#endif\n+      pair->to = make_compound_operation (pair->to, SET);\n+      return pair->to;\n+    }\n+  return copy_rtx (pair->to);\n+}\n+\n+/* Replace all the occurrences of DEST with SRC in DEBUG_INSNs between INSN\n+   and LAST, not including INSN, but including LAST.  Also stop at the end\n+   of THIS_BASIC_BLOCK.  */\n+\n+void\n+propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src,\n+\t\t     basic_block this_basic_block)\n+{\n+  rtx next, loc, end = NEXT_INSN (BB_END (this_basic_block));\n+\n+  struct rtx_subst_pair p;\n+  p.to = src;\n+  p.adjusted = false;\n+\n+  next = NEXT_INSN (insn);\n+  last = NEXT_INSN (last);\n+  while (next != last && next != end)\n+    {\n+      insn = next;\n+      next = NEXT_INSN (insn);\n+      if (DEBUG_INSN_P (insn))\n+\t{\n+\t  loc = simplify_replace_fn_rtx (INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t\t\t dest, propagate_for_debug_subst, &p);\n+\t  if (loc == INSN_VAR_LOCATION_LOC (insn))\n+\t    continue;\n+\t  INSN_VAR_LOCATION_LOC (insn) = loc;\n+\t  df_insn_rescan (insn);\n+\t}\n+    }\n+}\n+\n+/* Initialize DEBUG to an empty list, and clear USED, if given.  */\n+void\n+dead_debug_init (struct dead_debug *debug, bitmap used)\n+{\n+  debug->head = NULL;\n+  debug->used = used;\n+  debug->to_rescan = NULL;\n+  if (used)\n+    bitmap_clear (used);\n+}\n+\n+/* Reset all debug uses in HEAD, and clear DEBUG->to_rescan bits of\n+   each reset insn.  DEBUG is not otherwise modified.  If HEAD is\n+   DEBUG->head, DEBUG->head will be set to NULL at the end.\n+   Otherwise, entries from DEBUG->head that pertain to reset insns\n+   will be removed, and only then rescanned.  */\n+\n+static void\n+dead_debug_reset_uses (struct dead_debug *debug, struct dead_debug_use *head)\n+{\n+  bool got_head = (debug->head == head);\n+  bitmap rescan;\n+  struct dead_debug_use **tailp = &debug->head;\n+  struct dead_debug_use *cur;\n+  bitmap_iterator bi;\n+  unsigned int uid;\n+\n+  if (got_head)\n+    rescan = NULL;\n+  else\n+    rescan = BITMAP_ALLOC (NULL);\n+\n+  while (head)\n+    {\n+      struct dead_debug_use *next = head->next;\n+      rtx insn;\n+\n+      insn = DF_REF_INSN (head->use);\n+      if (!next || DF_REF_INSN (next->use) != insn)\n+\t{\n+\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t  if (got_head)\n+\t    df_insn_rescan_debug_internal (insn);\n+\t  else\n+\t    bitmap_set_bit (rescan, INSN_UID (insn));\n+\t  if (debug->to_rescan)\n+\t    bitmap_clear_bit (debug->to_rescan, INSN_UID (insn));\n+\t}\n+      XDELETE (head);\n+      head = next;\n+    }\n+\n+  if (got_head)\n+    {\n+      debug->head = NULL;\n+      return;\n+    }\n+\n+  while ((cur = *tailp))\n+    if (bitmap_bit_p (rescan, INSN_UID (DF_REF_INSN (cur->use))))\n+      {\n+\t*tailp = cur->next;\n+\tXDELETE (cur);\n+      }\n+    else\n+      tailp = &cur->next;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (rescan, 0, uid, bi)\n+    {\n+      struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n+      if (insn_info)\n+\tdf_insn_rescan_debug_internal (insn_info->insn);\n+    }\n+\n+  BITMAP_FREE (rescan);\n+}\n+\n+/* Reset all debug insns with pending uses.  Release the bitmap in it,\n+   unless it is USED.  USED must be the same bitmap passed to\n+   dead_debug_init.  */\n+void\n+dead_debug_finish (struct dead_debug *debug, bitmap used)\n+{\n+  if (debug->used != used)\n+    BITMAP_FREE (debug->used);\n+\n+  dead_debug_reset_uses (debug, debug->head);\n+\n+  if (debug->to_rescan)\n+    {\n+      bitmap_iterator bi;\n+      unsigned int uid;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (debug->to_rescan, 0, uid, bi)\n+\t{\n+\t  struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n+\t  if (insn_info)\n+\t    df_insn_rescan (insn_info->insn);\n+\t}\n+      BITMAP_FREE (debug->to_rescan);\n+    }\n+}\n+\n+/* Add USE to DEBUG.  It must be a dead reference to UREGNO in a debug\n+   insn.  Create a bitmap for DEBUG as needed.  */\n+void\n+dead_debug_add (struct dead_debug *debug, df_ref use, unsigned int uregno)\n+{\n+  struct dead_debug_use *newddu = XNEW (struct dead_debug_use);\n+\n+  newddu->use = use;\n+  newddu->next = debug->head;\n+  debug->head = newddu;\n+\n+  if (!debug->used)\n+    debug->used = BITMAP_ALLOC (NULL);\n+\n+  /* ??? If we dealt with split multi-registers below, we should set\n+     all registers for the used mode in case of hardware\n+     registers.  */\n+  bitmap_set_bit (debug->used, uregno);\n+}\n+\n+/* If UREGNO is referenced by any entry in DEBUG, emit a debug insn\n+   before or after INSN (depending on WHERE), that binds a debug temp\n+   to the widest-mode use of UREGNO, if WHERE is *_WITH_REG, or the\n+   value stored in UREGNO by INSN otherwise, and replace all uses of\n+   UREGNO in DEBUG with uses of the debug temp.  INSN must be where\n+   UREGNO dies, if WHERE is *_BEFORE_*, or where it is set otherwise.\n+   Return the number of debug insns emitted.  */\n+int\n+dead_debug_insert_temp (struct dead_debug *debug, unsigned int uregno,\n+\t\t\trtx insn, enum debug_temp_where where)\n+{\n+  struct dead_debug_use **tailp = &debug->head;\n+  struct dead_debug_use *cur;\n+  struct dead_debug_use *uses = NULL;\n+  struct dead_debug_use **usesp = &uses;\n+  rtx reg = NULL;\n+  rtx breg;\n+  rtx dval;\n+  rtx bind;\n+\n+  if (!debug->used || !bitmap_clear_bit (debug->used, uregno))\n+    return 0;\n+\n+  /* Move all uses of uregno from debug->head to uses, setting mode to\n+     the widest referenced mode.  */\n+  while ((cur = *tailp))\n+    {\n+      if (DF_REF_REGNO (cur->use) == uregno)\n+\t{\n+\t  *usesp = cur;\n+\t  usesp = &cur->next;\n+\t  *tailp = cur->next;\n+\t  cur->next = NULL;\n+\t  if (!reg\n+\t      || (GET_MODE_BITSIZE (GET_MODE (reg))\n+\t\t  < GET_MODE_BITSIZE (GET_MODE (*DF_REF_REAL_LOC (cur->use)))))\n+\t    reg = *DF_REF_REAL_LOC (cur->use);\n+\t}\n+      else\n+\ttailp = &(*tailp)->next;\n+    }\n+\n+  /* We may have dangling bits in debug->used for registers that were part\n+     of a multi-register use, one component of which has been reset.  */\n+  if (reg == NULL)\n+    {\n+      gcc_checking_assert (!uses);\n+      return 0;\n+    }\n+\n+  gcc_checking_assert (uses);\n+\n+  breg = reg;\n+  /* Recover the expression INSN stores in REG.  */\n+  if (where == DEBUG_TEMP_BEFORE_WITH_VALUE)\n+    {\n+      rtx set = single_set (insn);\n+      rtx dest, src;\n+\n+      if (set)\n+\t{\n+\t  dest = SET_DEST (set);\n+\t  src = SET_SRC (set);\n+\t  /* Lose if the REG-setting insn is a CALL.  */\n+\t  if (GET_CODE (src) == CALL)\n+\t    {\n+\t      while (uses)\n+\t\t{\n+\t\t  cur = uses->next;\n+\t\t  XDELETE (uses);\n+\t\t  uses = cur;\n+\t\t}\n+\t      return 0;\n+\t    }\n+\t}\n+\n+      /* ??? Should we try to extract it from a PARALLEL?  */\n+      if (!set)\n+\tbreg = NULL;\n+      /* Cool, it's the same REG, we can use SRC.  */\n+      else if (dest == reg)\n+\tbreg = copy_rtx (src);\n+      else if (REG_P (dest))\n+\t{\n+\t  /* Hmm...  Something's fishy, we should be setting REG here.  */\n+\t  if (REGNO (dest) != REGNO (reg))\n+\t    breg = NULL;\n+\t  /* If we're not overwriting all the hardware registers that\n+\t     setting REG in its mode would, we won't know what to bind\n+\t     the debug temp to.  ??? We could bind the debug_expr to a\n+\t     CONCAT or PARALLEL with the split multi-registers, and\n+\t     replace them as we found the corresponding sets.  */\n+\t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n+\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n+\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n+\t    breg = NULL;\n+\t  /* Ok, it's the same (hardware) REG, but with a different\n+\t     mode, so SUBREG it.  */\n+\t  else\n+\t    breg = lowpart_subreg (GET_MODE (reg), copy_rtx (src),\n+\t\t\t\t   GET_MODE (dest));\n+\t}\n+      else if (GET_CODE (dest) == SUBREG)\n+\t{\n+\t  /* We should be setting REG here.  Lose.  */\n+\t  if (REGNO (SUBREG_REG (dest)) != REGNO (reg))\n+\t    breg = NULL;\n+\t  /* Lose if we're setting something other than the lowpart of\n+\t     REG.  */\n+\t  else if (!subreg_lowpart_p (dest))\n+\t    breg = NULL;\n+\t  /* If we're not overwriting all the hardware registers that\n+\t     setting REG in its mode would, we won't know what to bind\n+\t     the debug temp to.  */\n+\t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n+\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n+\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n+\t    breg = NULL;\n+\t  /* Yay, we can use SRC, just adjust its mode.  */\n+\t  else\n+\t    breg = lowpart_subreg (GET_MODE (reg), copy_rtx (src),\n+\t\t\t\t   GET_MODE (dest));\n+\t}\n+      /* Oh well, we're out of luck.  */\n+      else\n+\tbreg = NULL;\n+\n+      /* We couldn't figure out the value stored in REG, so reset all\n+\t of its pending debug uses.  */\n+      if (!breg)\n+\t{\n+\t  dead_debug_reset_uses (debug, uses);\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* If there's a single (debug) use of an otherwise unused REG, and\n+     the debug use is not part of a larger expression, then it\n+     probably doesn't make sense to introduce a new debug temp.  */\n+  if (where == DEBUG_TEMP_AFTER_WITH_REG && !uses->next)\n+    {\n+      rtx next = DF_REF_INSN (uses->use);\n+\n+      if (DEBUG_INSN_P (next) && reg == INSN_VAR_LOCATION_LOC (next))\n+\t{\n+\t  XDELETE (uses);\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* Create DEBUG_EXPR (and DEBUG_EXPR_DECL).  */\n+  dval = make_debug_expr_from_rtl (reg);\n+\n+  /* Emit a debug bind insn before the insn in which reg dies.  */\n+  bind = gen_rtx_VAR_LOCATION (GET_MODE (reg),\n+\t\t\t       DEBUG_EXPR_TREE_DECL (dval), breg,\n+\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n+\n+  if (where == DEBUG_TEMP_AFTER_WITH_REG)\n+    bind = emit_debug_insn_after (bind, insn);\n+  else\n+    bind = emit_debug_insn_before (bind, insn);\n+  df_insn_rescan (bind);\n+\n+  /* Adjust all uses.  */\n+  while ((cur = uses))\n+    {\n+      if (GET_MODE (*DF_REF_REAL_LOC (cur->use)) == GET_MODE (reg))\n+\t*DF_REF_REAL_LOC (cur->use) = dval;\n+      else\n+\t*DF_REF_REAL_LOC (cur->use)\n+\t  = gen_lowpart_SUBREG (GET_MODE (*DF_REF_REAL_LOC (cur->use)), dval);\n+      /* ??? Should we simplify subreg of subreg?  */\n+      if (debug->to_rescan == NULL)\n+\tdebug->to_rescan = BITMAP_ALLOC (NULL);\n+      bitmap_set_bit (debug->to_rescan, INSN_UID (DF_REF_INSN (cur->use)));\n+      uses = cur->next;\n+      XDELETE (cur);\n+    }\n+\n+  return 1;\n+}"}, {"sha": "9f96f210b1aa149909938f167268695c6efe5766", "filename": "gcc/valtrack.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fvaltrack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32/gcc%2Fvaltrack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.h?ref=08df6c0db1dbdeda1e22b16eb83c77ad05f8ba32", "patch": "@@ -0,0 +1,75 @@\n+/* Infrastructure for tracking user variable locations and values\n+   throughout compilation.\n+   Copyright (C) 2010, 2011, 2012  Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva <aoliva@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VALTRACK_H\n+#define GCC_VALTRACK_H\n+\n+#include \"bitmap.h\"\n+#include \"df.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+\n+/* Debug uses of dead regs.  */\n+\n+/* Node of a linked list of uses of dead REGs in debug insns.  */\n+struct dead_debug_use\n+{\n+  df_ref use;\n+  struct dead_debug_use *next;\n+};\n+\n+/* Linked list of the above, with a bitmap of the REGs in the\n+   list.  */\n+struct dead_debug\n+{\n+  struct dead_debug_use *head;\n+  bitmap used;\n+  bitmap to_rescan;\n+};\n+\n+/* This type controls the behavior of dead_debug_insert_temp WRT\n+   UREGNO and INSN.  */\n+enum debug_temp_where\n+  {\n+    /* Bind a newly-created debug temporary to a REG for UREGNO, and\n+       insert the debug insn before INSN.  REG is expected to die at\n+       INSN.  */\n+    DEBUG_TEMP_BEFORE_WITH_REG = -1,\n+    /* Bind a newly-created debug temporary to the value INSN stores\n+       in REG, and insert the debug insn before INSN.  */\n+    DEBUG_TEMP_BEFORE_WITH_VALUE = 0,\n+    /* Bind a newly-created debug temporary to a REG for UREGNO, and\n+       insert the debug insn after INSN.  REG is expected to be set at\n+       INSN.  */\n+    DEBUG_TEMP_AFTER_WITH_REG = 1\n+  };\n+\n+extern void dead_debug_init (struct dead_debug *, bitmap);\n+extern void dead_debug_finish (struct dead_debug *, bitmap);\n+extern void dead_debug_add (struct dead_debug *, df_ref, unsigned int);\n+extern int dead_debug_insert_temp (struct dead_debug *,\n+\t\t\t\t   unsigned int uregno, rtx insn,\n+\t\t\t\t   enum debug_temp_where);\n+\n+extern void propagate_for_debug (rtx, rtx, rtx, rtx, basic_block);\n+\n+\n+#endif /* GCC_VALTRACK_H */"}]}