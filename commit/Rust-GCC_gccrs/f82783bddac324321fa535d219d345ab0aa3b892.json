{"sha": "f82783bddac324321fa535d219d345ab0aa3b892", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyNzgzYmRkYWMzMjQzMjFmYTUzNWQyMTlkMzQ1YWIwYWEzYjg5Mg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-03-03T00:38:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-03-03T00:38:20Z"}, "message": "gengtype.c (main): Handle double_int type.\n\n\t* gengtype.c (main): Handle double_int type.\n\t* tree.h (struct tree_int_cst): Make type of int_cst double_int.\n\t* double-int.c: New file.\n\t* double-int.h: New file.\n\t* system.h: Include doubleint.h.\n\t* Makefile.in (SYSTEM_H): Include double-int.h.\n\t(double-int.o): Add.\n\nFrom-SVN: r111663", "tree": {"sha": "5f4ce06a46059b33cacd4d5c9a4b58ab6147793f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f4ce06a46059b33cacd4d5c9a4b58ab6147793f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f82783bddac324321fa535d219d345ab0aa3b892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82783bddac324321fa535d219d345ab0aa3b892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82783bddac324321fa535d219d345ab0aa3b892", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82783bddac324321fa535d219d345ab0aa3b892/comments", "author": null, "committer": null, "parents": [{"sha": "778f0e89180557c7817da8cbb4876dd1ceb18888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/778f0e89180557c7817da8cbb4876dd1ceb18888", "html_url": "https://github.com/Rust-GCC/gccrs/commit/778f0e89180557c7817da8cbb4876dd1ceb18888"}], "stats": {"total": 540, "additions": 531, "deletions": 9}, "files": [{"sha": "a2508b6668011b324ced503d754172a27ae298d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -1,3 +1,13 @@\n+2006-03-03  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gengtype.c (main): Handle double_int type.\n+\t* tree.h (struct tree_int_cst): Make type of int_cst double_int.\n+\t* double-int.c: New file.\n+\t* double-int.h: New file.\n+\t* system.h: Include doubleint.h.\n+\t* Makefile.in (SYSTEM_H): Include double-int.h.\n+\t(double-int.o): Add.\n+\n 2006-03-03  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/26478"}, {"sha": "4b9526a1452dacd240fa8af67755c199419218cc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -773,7 +773,7 @@ INSN_ATTR_H = insn-attr.h $(srcdir)/insn-addr.h $(srcdir)/varray.h\n C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H)\n C_PRAGMA_H = c-pragma.h $(CPPLIB_H)\n C_TREE_H = c-tree.h $(C_COMMON_H) toplev.h $(DIAGNOSTIC_H)\n-SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h\n+SYSTEM_H = system.h hwint.h double-int.h $(srcdir)/../include/libiberty.h\n PREDICT_H = predict.h predict.def\n CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \\\n \t$(srcdir)/../libcpp/include/cpplib.h\n@@ -952,7 +952,7 @@ C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n OBJS-common = \\\n- tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t\t\t   \\\n+ double-int.o tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n  gimplify.o tree-pretty-print.o tree-into-ssa.o\t\t\t\t   \\\n  tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o tree-ssa-uncprop.o\t\t   \\\n@@ -1781,6 +1781,8 @@ prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) prefix.h \\\n convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(FLAGS_H) convert.h toplev.h langhooks.h real.h\n \n+double-int.o: double-int.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n+\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) toplev.h $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n    langhooks.h $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) intl.h \\"}, {"sha": "ab1975f09a9f21735f449027a80722fa69433941", "filename": "gcc/double-int.c", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -0,0 +1,344 @@\n+/* Operations with long integers.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+\n+/* Returns mask for PREC bits.  */\n+\n+static inline double_int\n+double_int_mask (unsigned prec)\n+{\n+  unsigned HOST_WIDE_INT m;\n+  double_int mask;\n+\n+  if (prec > HOST_BITS_PER_WIDE_INT)\n+    {\n+      prec -= HOST_BITS_PER_WIDE_INT;\n+      m = ((unsigned HOST_WIDE_INT) 2 << (prec - 1)) - 1;\n+      mask.high = (HOST_WIDE_INT) m;\n+      mask.low = ALL_ONES;\n+    }\n+  else\n+    {\n+      mask.high = 0;\n+      mask.low = ((unsigned HOST_WIDE_INT) 2 << (prec - 1)) - 1;\n+    }\n+\n+  return mask;\n+}\n+\n+/* Clears the bits of CST over the precision PREC.  If UNS is false, the bits\n+   outside of the precision are set to the sign bit (i.e., the PREC-th one),\n+   otherwise they are set to zero.\n+ \n+   This corresponds to returning the value represented by PREC lowermost bits\n+   of CST, with the given signedness.  */\n+\n+double_int\n+double_int_ext (double_int cst, unsigned prec, bool uns)\n+{\n+  if (uns)\n+    return double_int_zext (cst, prec);\n+  else\n+    return double_int_sext (cst, prec);\n+}\n+\n+/* The same as double_int_ext with UNS = true.  */\n+\n+double_int\n+double_int_zext (double_int cst, unsigned prec)\n+{\n+  double_int mask = double_int_mask (prec);\n+  double_int r;\n+\n+  r.low = cst.low & ~mask.low;\n+  r.high = cst.high & ~mask.high;\n+\n+  return r;\n+}\n+\n+/* The same as double_int_ext with UNS = false.  */\n+\n+double_int\n+double_int_sext (double_int cst, unsigned prec)\n+{\n+  double_int mask = double_int_mask (prec);\n+  double_int r;\n+  unsigned HOST_WIDE_INT snum;\n+\n+  if (prec <= HOST_BITS_PER_WIDE_INT)\n+    snum = cst.low;\n+  else\n+    {\n+      prec -= HOST_BITS_PER_WIDE_INT;\n+      snum = (unsigned HOST_WIDE_INT) cst.high;\n+    }\n+  if (((snum >> (prec - 1)) & 1) == 1)\n+    {\n+      r.low = cst.low | mask.low;\n+      r.high = cst.high | mask.high;\n+    }\n+  else\n+    {\n+      r.low = cst.low & ~mask.low;\n+      r.high = cst.high & ~mask.high;\n+    } \n+\n+  return r;\n+}\n+\n+/* Constructs long integer from tree CST.  The extra bits over the precision of\n+   the number are filled with sign bit if CST is signed, and with zeros if it\n+   is unsigned.  */\n+\n+double_int\n+tree_to_double_int (tree cst)\n+{\n+  /* We do not need to call double_int_restrict here to ensure the semantics as\n+     described, as this is the default one for trees.  */\n+  return TREE_INT_CST (cst);\n+}\n+\n+/* Returns true if CST fits in unsigned HOST_WIDE_INT.  */\n+\n+bool\n+double_int_fits_in_uhwi_p (double_int cst)\n+{\n+  return cst.high == 0;\n+}\n+\n+/* Returns true if CST fits in signed HOST_WIDE_INT.  */\n+\n+bool\n+double_int_fits_in_shwi_p (double_int cst)\n+{\n+  if (cst.high == 0)\n+    return (HOST_WIDE_INT) cst.low >= 0;\n+  else if (cst.high == -1)\n+    return (HOST_WIDE_INT) cst.low < 0;\n+  else\n+    return false;\n+}\n+\n+/* Returns true if CST fits in HOST_WIDE_INT if UNS is false, or in\n+   unsigned HOST_WIDE_INT if UNS is true.  */\n+\n+bool\n+double_int_fits_in_hwi_p (double_int cst, bool uns)\n+{\n+  if (uns)\n+    return double_int_fits_in_uhwi_p (cst);\n+  else\n+    return double_int_fits_in_shwi_p (cst);\n+}\n+\n+/* Returns value of CST as a signed number.  CST must satisfy\n+   double_int_fits_in_shwi_p.  */\n+\n+HOST_WIDE_INT\n+double_int_to_shwi (double_int cst)\n+{\n+  return (HOST_WIDE_INT) cst.low;\n+}\n+\n+/* Returns value of CST as an unsigned number.  CST must satisfy\n+   double_int_fits_in_uhwi_p.  */\n+\n+unsigned HOST_WIDE_INT\n+double_int_to_uhwi (double_int cst)\n+{\n+  return cst.low;\n+}\n+\n+/* Returns A * B.  */\n+\n+double_int\n+double_int_mul (double_int a, double_int b)\n+{\n+  double_int ret;\n+  mul_double (a.low, a.high, b.low, b.high, &ret.low, &ret.high);\n+  return ret;\n+}\n+\n+/* Returns A + B.  */\n+\n+double_int\n+double_int_add (double_int a, double_int b)\n+{\n+  double_int ret;\n+  add_double (a.low, a.high, b.low, b.high, &ret.low, &ret.high);\n+  return ret;\n+}\n+\n+/* Returns -A.  */\n+\n+double_int\n+double_int_neg (double_int a)\n+{\n+  double_int ret;\n+  neg_double (a.low, a.high, &ret.low, &ret.high);\n+  return ret;\n+}\n+\n+/* Returns A / B (computed as unsigned depending on UNS, and rounded as\n+   specified by CODE).  CODE is enum tree_code in fact, but double_int.h\n+   must be included before tree.h.  */\n+\n+double_int\n+double_int_div (double_int a, double_int b, bool uns, unsigned code)\n+{\n+  unsigned HOST_WIDE_INT rem_lo;\n+  HOST_WIDE_INT rem_hi;\n+  double_int ret;\n+\n+  div_and_round_double (code, uns, a.low, a.high, b.low, b.high,\n+\t\t\t&ret.low, &ret.high, &rem_lo, &rem_hi);\n+  return ret;\n+}\n+\n+/* The same as double_int_div with UNS = false.  */\n+\n+double_int\n+double_int_sdiv (double_int a, double_int b, unsigned code)\n+{\n+  return double_int_div (a, b, false, code);\n+}\n+\n+/* The same as double_int_div with UNS = true.  */\n+\n+double_int\n+double_int_udiv (double_int a, double_int b, unsigned code)\n+{\n+  return double_int_div (a, b, true, code);\n+}\n+\n+/* Constructs tree in type TYPE from with value given by CST.  */\n+\n+tree\n+double_int_to_tree (tree type, double_int cst)\n+{\n+  cst = double_int_ext (cst, TYPE_PRECISION (type), TYPE_UNSIGNED (type));\n+\n+  return build_int_cst_wide (type, cst.low, cst.high);\n+}\n+\n+/* Returns true if CST is negative.  Of course, CST is considered to\n+   be signed.  */\n+\n+bool\n+double_int_negative_p (double_int cst)\n+{\n+  return cst.high < 0;\n+}\n+\n+/* Returns -1 if A < B, 0 if A == B and 1 if A > B.  Signedness of the\n+   comparison is given by UNS.  */\n+\n+int\n+double_int_cmp (double_int a, double_int b, bool uns)\n+{\n+  if (uns)\n+    return double_int_ucmp (a, b);\n+  else\n+    return double_int_scmp (a, b);\n+}\n+\n+/* Compares two unsigned values A and B.  Returns -1 if A < B, 0 if A == B,\n+   and 1 if A > B.  */\n+\n+int\n+double_int_ucmp (double_int a, double_int b)\n+{\n+  if ((unsigned HOST_WIDE_INT) a.high < (unsigned HOST_WIDE_INT) b.high)\n+    return -1;\n+  if ((unsigned HOST_WIDE_INT) a.high > (unsigned HOST_WIDE_INT) b.high)\n+    return 1;\n+  if (a.low < b.low)\n+    return -1;\n+  if (a.low > b.low)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Compares two signed values A and B.  Returns -1 if A < B, 0 if A == B,\n+   and 1 if A > B.  */\n+\n+int\n+double_int_scmp (double_int a, double_int b)\n+{\n+  if (a.high < b.high)\n+    return -1;\n+  if (a.high > b.high)\n+    return 1;\n+  if ((HOST_WIDE_INT) a.low < (HOST_WIDE_INT) b.low)\n+    return -1;\n+  if ((HOST_WIDE_INT) a.low > (HOST_WIDE_INT) b.low)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Splits last digit of *CST (taken as unsigned) in BASE and returns it.  */\n+\n+static unsigned\n+double_int_split_digit (double_int *cst, unsigned base)\n+{\n+  unsigned HOST_WIDE_INT resl, reml;\n+  HOST_WIDE_INT resh, remh;\n+\n+  div_and_round_double (FLOOR_DIV_EXPR, true, cst->low, cst->high, base, 0,\n+\t\t\t&resl, &resh, &reml, &remh);\n+  cst->high = resh;\n+  cst->low = resl;\n+\n+  return reml;\n+}\n+\n+/* Dumps CST to FILE.  If UNS is true, CST is considered to be unsigned,\n+   otherwise it is signed.  */\n+\n+void\n+dump_double_int (FILE *file, double_int cst, bool uns)\n+{\n+  unsigned digits[100], n;\n+  int i;\n+\n+  if (double_int_zero_p (cst))\n+    {\n+      fprintf (file, \"0\");\n+      return;\n+    }\n+\n+  if (!uns && double_int_negative_p (cst))\n+    {\n+      fprintf (file, \"-\");\n+      cst = double_int_neg (cst);\n+    }\n+\n+  for (n = 0; !double_int_zero_p (cst); n++)\n+    digits[n] = double_int_split_digit (&cst, 10);\n+  for (i = n - 1; i >= 0; i--)\n+    fprintf (file, \"%u\", digits[i]);\n+}"}, {"sha": "c6113f336a6331187c9020ef5183e8bddce2e266", "filename": "gcc/double-int.h", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -0,0 +1,169 @@\n+/* Operations with long integers.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef DOUBLE_INT_H\n+#define DOUBLE_INT_H\n+\n+/* A large integer is currently represented as a pair of HOST_WIDE_INTs.\n+   It therefore represents a number with precision of\n+   2 * HOST_BITS_PER_WIDE_INT bits (it is however possible that the\n+   internal representation will change, if numbers with greater precision\n+   are needed, so the users should not rely on it).  The representation does\n+   not contain any information about signedness of the represented value, so\n+   it can be used to represent both signed and unsigned numbers.  For\n+   operations where the results depend on signedness (division, comparisons),\n+   it must be specified separately.  For each such operation, there are three\n+   versions of the function -- double_int_op, that takes an extra UNS argument\n+   giving the signedness of the values, and double_int_sop and double_int_uop\n+   that stand for its specializations for signed and unsigned values.\n+\n+   You may also represent with numbers in smaller precision using double_int.\n+   You however need to use double_int_ext (that fills in the bits of the\n+   number over the prescribed precision with zeros or with the sign bit) before\n+   operations that do not perform arithmetics modulo 2^precision (comparisons,\n+   division), and possibly before storing the results, if you want to keep\n+   them in some canonical form).  In general, the signedness of double_int_ext\n+   should match the signedness of the operation.\n+\n+   ??? The components of double_int differ in signedness mostly for\n+   historical reasons (they replace an older structure used to represent\n+   numbers with precision wigher than HOST_WIDE_INT).  It might be less\n+   confusing to have them both signed or both unsigned.  */\n+\n+typedef struct\n+{\n+  unsigned HOST_WIDE_INT low;\n+  HOST_WIDE_INT high;\n+} double_int;\n+\n+union tree_node;\n+\n+/* Constructors and conversions.  */\n+\n+union tree_node *double_int_to_tree (union tree_node *, double_int);\n+double_int tree_to_double_int (union tree_node *tree);\n+\n+/* Constructs double_int from integer CST.  The bits over the precision of\n+   HOST_WIDE_INT are filled with the sign bit.  */\n+\n+static inline double_int\n+shwi_to_double_int (HOST_WIDE_INT cst)\n+{\n+  double_int r;\n+  \n+  r.low = (unsigned HOST_WIDE_INT) cst;\n+  r.high = cst < 0 ? -1 : 0;\n+\n+  return r;\n+}\n+\n+/* Some useful constants.  */\n+\n+#define double_int_minus_one (shwi_to_double_int (-1))\n+#define double_int_zero (shwi_to_double_int (0))\n+#define double_int_one (shwi_to_double_int (1))\n+#define double_int_two (shwi_to_double_int (2))\n+#define double_int_ten (shwi_to_double_int (10))\n+\n+/* Constructs double_int from unsigned integer CST.  The bits over the\n+   precision of HOST_WIDE_INT are filled with zeros.  */\n+\n+static inline double_int\n+uhwi_to_double_int (unsigned HOST_WIDE_INT cst)\n+{\n+  double_int r;\n+  \n+  r.low = cst;\n+  r.high = 0;\n+\n+  return r;\n+}\n+\n+/* The following operations perform arithmetics modulo 2^precision,\n+   so you do not need to call double_int_ext between them, even if\n+   you are representing numbers with precision less than\n+   2 * HOST_BITS_PER_WIDE_INT bits.  */\n+\n+double_int double_int_mul (double_int, double_int);\n+double_int double_int_add (double_int, double_int);\n+double_int double_int_neg (double_int);\n+\n+/* You must ensure that double_int_ext is called on the operands\n+   of the following operations, if the precision of the numbers\n+   is less than 2 * HOST_BITS_PER_WIDE_INT bits.  */\n+bool double_int_fits_in_hwi_p (double_int, bool);\n+bool double_int_fits_in_shwi_p (double_int);\n+bool double_int_fits_in_uhwi_p (double_int);\n+HOST_WIDE_INT double_int_to_shwi (double_int);\n+unsigned HOST_WIDE_INT double_int_to_uhwi (double_int);\n+double_int double_int_div (double_int, double_int, bool, unsigned);\n+double_int double_int_sdiv (double_int, double_int, unsigned);\n+double_int double_int_udiv (double_int, double_int, unsigned);\n+bool double_int_negative_p (double_int);\n+int double_int_cmp (double_int, double_int, bool);\n+int double_int_scmp (double_int, double_int);\n+int double_int_ucmp (double_int, double_int);\n+void dump_double_int (FILE *, double_int, bool);\n+\n+/* Zero and sign extension of numbers in smaller precisions.  */\n+\n+double_int double_int_ext (double_int, unsigned, bool);\n+double_int double_int_sext (double_int, unsigned);\n+double_int double_int_zext (double_int, unsigned);\n+\n+#define ALL_ONES (~((unsigned HOST_WIDE_INT) 0))\n+\n+/* The operands of the following comparison functions must be processed\n+   with double_int_ext, if their precision is less than\n+   2 * HOST_BITS_PER_WIDE_INT bits.  */\n+\n+/* Returns true if CST is zero.  */\n+\n+static inline bool\n+double_int_zero_p (double_int cst)\n+{\n+  return cst.low == 0 && cst.high == 0;\n+}\n+\n+/* Returns true if CST is one.  */\n+\n+static inline bool\n+double_int_one_p (double_int cst)\n+{\n+  return cst.low == 1 && cst.high == 0;\n+}\n+\n+/* Returns true if CST is minus one.  */\n+\n+static inline bool\n+double_int_minus_one_p (double_int cst)\n+{\n+  return (cst.low == ALL_ONES && cst.high == -1);\n+}\n+\n+/* Returns true if CST1 == CST2.  */\n+\n+static inline bool\n+double_int_equal_p (double_int cst1, double_int cst2)\n+{\n+  return cst1.low == cst2.low && cst1.high == cst2.high;\n+}\n+\n+#endif /* DOUBLE_INT_H */"}, {"sha": "a30e2946e183878a3b8088de64f7a5461ce1f8ba", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -3037,6 +3037,7 @@ main(int ARG_UNUSED (argc), char ** ARG_UNUSED (argv))\n \n   do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n   do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n+  do_scalar_typedef (\"double_int\", &pos);\n   do_scalar_typedef (\"uint8\", &pos);\n   do_scalar_typedef (\"jword\", &pos);\n   do_scalar_typedef (\"JCF_u2\", &pos);"}, {"sha": "d3100e15f1ae782ac55e0265f692cf375da91692", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -609,6 +609,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n # define FALSE false\n #endif /* !__cplusplus */\n \n+/* Get definition of double_int.  */\n+#include \"double-int.h\"\n \n /* Some compilers do not allow the use of unsigned char in bitfields.  */\n #define BOOL_BITFIELD unsigned int"}, {"sha": "963569c51e4a9bb97bbad1d960294769d0612438", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82783bddac324321fa535d219d345ab0aa3b892/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f82783bddac324321fa535d219d345ab0aa3b892", "patch": "@@ -1239,13 +1239,7 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n struct tree_int_cst GTY(())\n {\n   struct tree_common common;\n-  /* A sub-struct is necessary here because the function `const_hash'\n-     wants to scan both words as a unit and taking the address of the\n-     sub-struct yields the properly inclusive bounded pointer.  */\n-  struct tree_int_cst_lowhi {\n-    unsigned HOST_WIDE_INT low;\n-    HOST_WIDE_INT high;\n-  } int_cst;\n+  double_int int_cst;\n };\n \n /* In a REAL_CST node.  struct real_value is an opaque entity, with"}]}