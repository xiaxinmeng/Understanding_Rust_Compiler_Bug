{"sha": "5e1c00fac7db1ff2c586a8664dec5745bbf50fa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUxYzAwZmFjN2RiMWZmMmM1ODZhODY2NGRlYzU3NDViYmY1MGZhNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@gnat.com", "date": "2004-10-27T13:01:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-27T13:01:38Z"}, "message": "exp_ch4.adb (Expand_N_Op_Eq): Make sure we expand a loop for array compares if the component is atomic.\n\n2004-10-26  Robert Dewar  <dewar@gnat.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Eq): Make sure we expand a loop for array\n\tcompares if the component is atomic.\n\n\t* exp_ch5.adb (Expand_Assign_Array): Make sure we expand a loop for\n\tarray assignment if the component type is atomic.\n\nFrom-SVN: r89650", "tree": {"sha": "1283a68f1d7a2cea2d52cf117ec13b4e4ff90a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1283a68f1d7a2cea2d52cf117ec13b4e4ff90a56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6/comments", "author": null, "committer": null, "parents": [{"sha": "6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1"}], "stats": {"total": 112, "additions": 67, "deletions": 45}, "files": [{"sha": "c89582b3a4e3eb51d5a3eb6304e0403bdd6adef4", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=5e1c00fac7db1ff2c586a8664dec5745bbf50fa6", "patch": "@@ -250,7 +250,7 @@ package body Exp_Ch4 is\n       if Kind = N_Op_Not then\n          if Nkind (Op1) in N_Binary_Op then\n \n-            --  Use negated version of the binary operators.\n+            --  Use negated version of the binary operators\n \n             if Nkind (Op1) = N_Op_And then\n                Proc_Name := RTE (RE_Vector_Nand);\n@@ -428,7 +428,7 @@ package body Exp_Ch4 is\n             if Controlled_Type (T)\n               and then Ekind (PtrT) = E_Anonymous_Access_Type\n             then\n-               --  Create local finalization list for access parameter.\n+               --  Create local finalization list for access parameter\n \n                Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n             end if;\n@@ -535,7 +535,7 @@ package body Exp_Ch4 is\n                   if Controlled_Type (T)\n                     and then Ekind (PtrT) = E_Anonymous_Access_Type\n                   then\n-                     --  Create local finalization list for access parameter.\n+                     --  Create local finalization list for access parameter\n \n                      Flist :=\n                        Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n@@ -964,7 +964,7 @@ package body Exp_Ch4 is\n         (Arr : Entity_Id;\n          Nam : Name_Id;\n          Num : Int) return Node_Id;\n-      --  This builds the attribute reference Arr'Nam (Expr).\n+      --  This builds the attribute reference Arr'Nam (Expr)\n \n       function Component_Equality (Typ : Entity_Id) return Node_Id;\n       --  Create one statement to compare corresponding components,\n@@ -1152,7 +1152,7 @@ package body Exp_Ch4 is\n            Handle_One_Dimension (N + 1, Next_Index (Index)));\n \n          if Need_Separate_Indexes then\n-            --  Generate guard for loop, followed by increments of indices.\n+            --  Generate guard for loop, followed by increments of indices\n \n             Append_To (Stm_List,\n                Make_Exit_Statement (Loc,\n@@ -1852,48 +1852,48 @@ package body Exp_Ch4 is\n       --    L := Si'First;       otherwise (where I is the input param given)\n \n       function H return Node_Id;\n-      --  Builds reference to identifier H.\n+      --  Builds reference to identifier H\n \n       function Ind_Val (E : Node_Id) return Node_Id;\n       --  Builds expression Ind_Typ'Val (E);\n \n       function L return Node_Id;\n-      --  Builds reference to identifier L.\n+      --  Builds reference to identifier L\n \n       function L_Pos return Node_Id;\n-      --  Builds expression Integer_Type'(Ind_Typ'Pos (L)).\n-      --  We qualify the expression to avoid universal_integer computations\n-      --  whenever possible, in the expression for the upper bound H.\n+      --  Builds expression Integer_Type'(Ind_Typ'Pos (L)). We qualify the\n+      --  expression to avoid universal_integer computations whenever possible,\n+      --  in the expression for the upper bound H.\n \n       function L_Succ return Node_Id;\n-      --  Builds expression Ind_Typ'Succ (L).\n+      --  Builds expression Ind_Typ'Succ (L)\n \n       function One return Node_Id;\n-      --  Builds integer literal one.\n+      --  Builds integer literal one\n \n       function P return Node_Id;\n-      --  Builds reference to identifier P.\n+      --  Builds reference to identifier P\n \n       function P_Succ return Node_Id;\n-      --  Builds expression Ind_Typ'Succ (P).\n+      --  Builds expression Ind_Typ'Succ (P)\n \n       function R return Node_Id;\n-      --  Builds reference to identifier R.\n+      --  Builds reference to identifier R\n \n       function S (I : Nat) return Node_Id;\n-      --  Builds reference to identifier Si, where I is the value given.\n+      --  Builds reference to identifier Si, where I is the value given\n \n       function S_First (I : Nat) return Node_Id;\n-      --  Builds expression Si'First, where I is the value given.\n+      --  Builds expression Si'First, where I is the value given\n \n       function S_Last (I : Nat) return Node_Id;\n-      --  Builds expression Si'Last, where I is the value given.\n+      --  Builds expression Si'Last, where I is the value given\n \n       function S_Length (I : Nat) return Node_Id;\n-      --  Builds expression Si'Length, where I is the value given.\n+      --  Builds expression Si'Length, where I is the value given\n \n       function S_Length_Test (I : Nat) return Node_Id;\n-      --  Builds expression Si'Length /= 0, where I is the value given.\n+      --  Builds expression Si'Length /= 0, where I is the value given\n \n       -------------------\n       -- Copy_Into_R_S --\n@@ -3957,8 +3957,8 @@ package body Exp_Ch4 is\n                --  Lhs of equality\n \n                if Nkind (Lhs) = N_Selected_Component\n-                 and then Has_Per_Object_Constraint (\n-                            Entity (Selector_Name (Lhs)))\n+                 and then Has_Per_Object_Constraint\n+                            (Entity (Selector_Name (Lhs)))\n                then\n                   --  Enclosing record is an Unchecked_Union, use formal A\n \n@@ -3977,11 +3977,11 @@ package body Exp_Ch4 is\n                        Make_Selected_Component (Loc,\n                          Prefix => Prefix (Lhs),\n                          Selector_Name =>\n-                           New_Copy (Get_Discriminant_Value (\n-                             First_Discriminant (Lhs_Type),\n-                             Lhs_Type,\n-                             Stored_Constraint (Lhs_Type))));\n-\n+                           New_Copy\n+                             (Get_Discriminant_Value\n+                                (First_Discriminant (Lhs_Type),\n+                                 Lhs_Type,\n+                                 Stored_Constraint (Lhs_Type))));\n                   end if;\n \n                --  Comment needed here ???\n@@ -3990,21 +3990,21 @@ package body Exp_Ch4 is\n                   --  Infer the discriminant value\n \n                   Lhs_Discr_Val :=\n-                    New_Copy (Get_Discriminant_Value (\n-                      First_Discriminant (Lhs_Type),\n-                      Lhs_Type,\n-                      Stored_Constraint (Lhs_Type)));\n-\n+                    New_Copy\n+                      (Get_Discriminant_Value\n+                         (First_Discriminant (Lhs_Type),\n+                          Lhs_Type,\n+                          Stored_Constraint (Lhs_Type)));\n                end if;\n \n                --  Rhs of equality\n \n                if Nkind (Rhs) = N_Selected_Component\n-                  and then Has_Per_Object_Constraint (\n-                             Entity (Selector_Name (Rhs)))\n+                 and then Has_Per_Object_Constraint\n+                            (Entity (Selector_Name (Rhs)))\n                then\n-                  if Is_Unchecked_Union (Scope\n-                       (Entity (Selector_Name (Rhs))))\n+                  if Is_Unchecked_Union\n+                       (Scope (Entity (Selector_Name (Rhs))))\n                   then\n                      Rhs_Discr_Val :=\n                        Make_Identifier (Loc,\n@@ -4260,12 +4260,15 @@ package body Exp_Ch4 is\n          elsif Is_Bit_Packed_Array (Typl) then\n             Expand_Packed_Eq (N);\n \n-         --  For non-floating-point elementary types, the primitive equality\n-         --  always applies, and block-bit comparison is fine. Floating-point\n-         --  is an exception because of negative zeroes.\n+         --  Where the component type is elementary we can use a block bit\n+         --  comparison (if supported on the target) exception in the case\n+         --  of floating-point (negative zero issues require element by\n+         --  element comparison), and atomic types (where we must be sure\n+         --  to load elements independently).\n \n          elsif Is_Elementary_Type (Component_Type (Typl))\n            and then not Is_Floating_Point_Type (Component_Type (Typl))\n+           and then not Is_Atomic (Component_Type (Typl))\n            and then Support_Composite_Compare_On_Target\n          then\n             null;\n@@ -4337,7 +4340,6 @@ package body Exp_Ch4 is\n                end if;\n \n                Prim := First_Elmt (Primitive_Operations (Typl));\n-\n                while Present (Prim) loop\n                   exit when Chars (Node (Prim)) = Name_Op_Eq\n                     and then Etype (First_Formal (Node (Prim))) =\n@@ -5299,7 +5301,7 @@ package body Exp_Ch4 is\n             Build_Boolean_Array_Proc_Call (Parent (N), Opnd, Empty);\n             return;\n \n-         --  Special case the negation of a binary operation.\n+         --  Special case the negation of a binary operation\n \n          elsif (Nkind (Opnd) = N_Op_And\n                  or else Nkind (Opnd) = N_Op_Or\n@@ -5324,14 +5326,14 @@ package body Exp_Ch4 is\n                if N = Op1\n                  and then Nkind (Op2) = N_Op_Not\n                then\n-                  --  (not A) op (not B) can be reduced to a single call.\n+                  --  (not A) op (not B) can be reduced to a single call\n \n                   return;\n \n                elsif N = Op2\n                  and then Nkind (Parent (N)) = N_Op_Xor\n                then\n-                  --  A xor (not B) can also be special-cased.\n+                  --  A xor (not B) can also be special-cased\n \n                   return;\n                end if;\n@@ -6878,7 +6880,9 @@ package body Exp_Ch4 is\n       --    only if Conversion_OK is set, i.e. if the fixed-point values\n       --    are to be treated as integers.\n \n-      --  No other conversions should be passed to Gigi.\n+      --  No other conversions should be passed to Gigi\n+\n+      --  Check: are these rules stated in sinfo??? if so, why restate here???\n \n       --  The only remaining step is to generate a range check if we still\n       --  have a type conversion at this stage and Do_Range_Check is set.\n@@ -7867,7 +7871,7 @@ package body Exp_Ch4 is\n       --  is safe. The operand can be empty in the case of negation.\n \n       function Is_Unaliased (N : Node_Id) return Boolean;\n-      --  Check that N is a stand-alone entity.\n+      --  Check that N is a stand-alone entity\n \n       ------------------\n       -- Is_Unaliased --"}, {"sha": "198d216b7b8c8ee2064d35c4533cef22183a1c4e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1c00fac7db1ff2c586a8664dec5745bbf50fa6/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=5e1c00fac7db1ff2c586a8664dec5745bbf50fa6", "patch": "@@ -330,6 +330,24 @@ package body Exp_Ch5 is\n       elsif Has_Controlled_Component (L_Type) then\n          Loop_Required := True;\n \n+         --  If object is atomic, we cannot tolerate a loop\n+\n+      elsif Is_Atomic_Object (Act_Lhs)\n+              or else\n+            Is_Atomic_Object (Act_Rhs)\n+      then\n+         return;\n+\n+      --  Loop is required if we have atomic components since we have to\n+      --  be sure to do any accesses on an element by element basis.\n+\n+      elsif Has_Atomic_Components (L_Type)\n+        or else Has_Atomic_Components (R_Type)\n+        or else Is_Atomic (Component_Type (L_Type))\n+        or else Is_Atomic (Component_Type (R_Type))\n+      then\n+         Loop_Required := True;\n+\n       --  Case where no slice is involved\n \n       elsif not L_Slice and not R_Slice then"}]}