{"sha": "e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdkNzJmYjk5ZGJjODA3OTAxODVkNjdiYWVkNmEwY2E3ZThiYmRhOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-22T09:21:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-22T09:21:53Z"}, "message": "[multiple changes]\n\n2009-06-22  Robert Dewar  <dewar@adacore.com>\n\n\t* sinput.adb, sinput.ads (Expr_First_Char, Expr_Last_Char): Replaced\n\tby Sloc_Range.\n\n\t* freeze.adb: Minor comment updates\n\n\t* s-valrea.adb (Bad_Based_Value): New procedure\n\t(Scan_Real): Raise exceptions with messages\n\n2009-06-22  Matthew Gingell  <gingell@adacore.com>\n\n\t* adaint.h: Complete previous change.\n\n2009-06-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.ads, exp_ch3.adb: Minor reformatting\n\n2009-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Check_Overriding_Indicator): When style checks are\n\tenabled, emit warning when a non-controlling argument of the overriding\n\toperation appears out of place vis-a-vis of the formal of the\n\toverridden operation.\n\nFrom-SVN: r148782", "tree": {"sha": "6d6b44b943763453e0e83639cca92341263a0474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d6b44b943763453e0e83639cca92341263a0474"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/comments", "author": null, "committer": null, "parents": [{"sha": "03456e44cfa6f5b10bf37689d497d05514dd47a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03456e44cfa6f5b10bf37689d497d05514dd47a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03456e44cfa6f5b10bf37689d497d05514dd47a4"}], "stats": {"total": 480, "additions": 189, "deletions": 291}, "files": [{"sha": "80e21d13a5ac81c0b56982c83390fc10037dacc5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -1,3 +1,28 @@\n+2009-06-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinput.adb, sinput.ads (Expr_First_Char, Expr_Last_Char): Replaced\n+\tby Sloc_Range.\n+\n+\t* freeze.adb: Minor comment updates\n+\n+\t* s-valrea.adb (Bad_Based_Value): New procedure\n+\t(Scan_Real): Raise exceptions with messages\n+\n+2009-06-22  Matthew Gingell  <gingell@adacore.com>\n+\n+\t* adaint.h: Complete previous change.\n+\n+2009-06-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch7.ads, exp_ch3.adb: Minor reformatting\n+\n+2009-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Overriding_Indicator): When style checks are\n+\tenabled, emit warning when a non-controlling argument of the overriding\n+\toperation appears out of place vis-a-vis of the formal of the\n+\toverridden operation.\n+\n 2009-06-22  Vincent Celier  <celier@adacore.com>\n \n \t* gnatcmd.adb (Check_Files): Close temporary files after all file names"}, {"sha": "e8fb40bc4a99f853c7e2fbb66086e68a311341f6", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -58,6 +58,7 @@\n #define FOPEN fopen\n #define STAT stat\n #define FSTAT fstat\n+#define LSTAT lstat\n #define STRUCT_STAT struct stat\n #endif\n "}, {"sha": "458f300b8dd849fe262151a88083149ac28e367e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -1854,7 +1854,7 @@ package body Exp_Ch3 is\n          --  Take a copy of Exp to ensure that later copies of this component\n          --  declaration in derived types see the original tree, not a node\n          --  rewritten during expansion of the init_proc. If the copy contains\n-         --  itypes, the scope of the new itypes is the init.proc being built.\n+         --  itypes, the scope of the new itypes is the init_proc being built.\n \n          Exp := New_Copy_Tree (Exp, New_Scope => Proc_Id);\n \n@@ -1885,7 +1885,7 @@ package body Exp_Ch3 is\n          end if;\n \n          --  Adjust the component if controlled except if it is an aggregate\n-         --  that will be expanded inline\n+         --  that will be expanded inline.\n \n          if Kind = N_Qualified_Expression then\n             Kind := Nkind (Expression (N));"}, {"sha": "a7c5cd7ba5a9ec0b4db1c0ff69abd1eb6ca0b72c", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,8 +75,8 @@ package Exp_Ch7 is\n    --  E is an entity representing a controlled object, a controlled type or a\n    --  scope. If Ref is not empty, it is a reference to a controlled record,\n    --  the closest Final list is in the controller component of the record\n-   --  containing Ref otherwise this function returns a reference to the final\n-   --  list attached to the closest dynamic scope (that can be E itself)\n+   --  containing Ref, otherwise this function returns a reference to the final\n+   --  list attached to the closest dynamic scope (which can be E itself),\n    --  creating this final list if necessary.\n \n    function Has_New_Controlled_Component (E : Entity_Id) return Boolean;"}, {"sha": "e68086cdc98f8179efc25ca824f3b1d1f29db680", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -2451,7 +2451,7 @@ package body Freeze is\n                           and then Convention (E) = Convention_C\n                         then\n                            Error_Msg_N\n-                             (\"?& is a tagged type which does not \"\n+                             (\"?& involves a tagged type which does not \"\n                               & \"correspond to any C type!\", Formal);\n \n                         --  Check wrong convention subprogram pointer\n@@ -2600,15 +2600,30 @@ package body Freeze is\n                         end if;\n                      end if;\n \n-                     --  VM functions returning unconstrained arrays are\n-                     --  correctly handled with the .NET/JVM compilers. Don't\n-                     --  display this warning in those cases.\n+                     --  Give warning for suspicous return of a result of an\n+                     --  unconstrained array type in a foreign convention\n+                     --  function.\n \n-                     if Is_Array_Type (R_Type)\n+                     if Has_Foreign_Convention (E)\n+\n+                       --  We are looking for a return of unconstrained array\n+\n+                       and then Is_Array_Type (R_Type)\n                        and then not Is_Constrained (R_Type)\n+\n+                       --  Exclude imported routines, the warning does not\n+                       --  belong on the import, but on the routine definition.\n+\n                        and then not Is_Imported (E)\n+\n+                       --  Exclude VM case, since both .NET and JVM can handle\n+                       --  return of unconstrained arrays without a problem.\n+\n                        and then VM_Target = No_VM\n-                       and then Has_Foreign_Convention (E)\n+\n+                       --  Check that general warning is enabled, and that it\n+                       --  is not suppressed for this particular case.\n+\n                        and then Warn_On_Export_Import\n                        and then not Has_Warnings_Off (E)\n                        and then not Has_Warnings_Off (R_Type)\n@@ -5047,14 +5062,24 @@ package body Freeze is\n             elsif Is_Generic_Type (Etype (E)) then\n                null;\n \n-            --  VM functions returning unconstrained arrays are\n-            --  correctly handled with the .NET/JVM compilers. Don't\n-            --  display this warning in those cases.\n+            --  Display warning if returning unconstrained array\n \n             elsif Is_Array_Type (Retype)\n               and then not Is_Constrained (Retype)\n+\n+              --  Exclude cases where descriptor mechanism is set, since the\n+              --  VMS descriptor mechanisms allow such unconstrained returns.\n+\n               and then Mechanism (E) not in Descriptor_Codes\n+\n+              --  Check appropriate warning is enabled (should we check for\n+              --  Warnings (Off) on specific entities here, probably so???)\n+\n               and then Warn_On_Export_Import\n+\n+               --  Exclude the VM case, since return of unconstrained arrays\n+               --  is properly handled in both the JVM and .NET cases.\n+\n               and then VM_Target = No_VM\n             then\n                Error_Msg_N\n@@ -5084,9 +5109,9 @@ package body Freeze is\n          end if;\n       end if;\n \n-      --  For VMS, descriptor mechanisms for parameters are allowed only\n-      --  for imported/exported subprograms.  Moreover, the NCA descriptor\n-      --  is not allowed for parameters of exported subprograms.\n+      --  For VMS, descriptor mechanisms for parameters are allowed only for\n+      --  imported/exported subprograms. Moreover, the NCA descriptor is not\n+      --  allowed for parameters of exported subprograms.\n \n       if OpenVMS_On_Target then\n          if Is_Exported (E) then"}, {"sha": "2e8306aabdc85a5d8dc371baa06ee2424226faac", "filename": "gcc/ada/s-valrea.adb", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valrea.adb?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -89,6 +89,10 @@ package body System.Val_Real is\n       --  necessarily required in a case like this where the result is not\n       --  a machine number, but it is certainly a desirable behavior.\n \n+      procedure Bad_Based_Value;\n+      pragma No_Return (Bad_Based_Value);\n+      --  Raise exception for bad based value\n+\n       procedure Scanf;\n       --  Scans integer literal value starting at current character position.\n       --  For each digit encountered, Uval is multiplied by 10.0, and the new\n@@ -98,6 +102,16 @@ package body System.Val_Real is\n       --  return P points past the last character. On entry, the current\n       --  character is known to be a digit, so a numeral is definitely present.\n \n+      ---------------------\n+      -- Bad_Based_Value --\n+      ---------------------\n+\n+      procedure Bad_Based_Value is\n+      begin\n+         raise Constraint_Error with\n+           \"invalid based literal for 'Value\";\n+      end Bad_Based_Value;\n+\n       -----------\n       -- Scanf --\n       -----------\n@@ -181,7 +195,8 @@ package body System.Val_Real is\n       --  Any other initial character is an error\n \n       else\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"invalid character in 'Value string\";\n       end if;\n \n       --  Deal with based case\n@@ -219,7 +234,7 @@ package body System.Val_Real is\n \n             loop\n                if P > Max then\n-                  raise Constraint_Error;\n+                  Bad_Based_Value;\n \n                elsif Str (P) in Digs then\n                   Digit := Character'Pos (Str (P)) - Character'Pos ('0');\n@@ -233,7 +248,7 @@ package body System.Val_Real is\n                     Character'Pos (Str (P)) - (Character'Pos ('a') - 10);\n \n                else\n-                  raise Constraint_Error;\n+                  Bad_Based_Value;\n                end if;\n \n                --  Save up trailing zeroes after the decimal point\n@@ -267,7 +282,7 @@ package body System.Val_Real is\n                P := P + 1;\n \n                if P > Max then\n-                  raise Constraint_Error;\n+                  Bad_Based_Value;\n \n                elsif Str (P) = '_' then\n                   Scan_Underscore (Str, P, Ptr, Max, True);\n@@ -282,7 +297,7 @@ package body System.Val_Real is\n                      After_Point := 1;\n \n                      if P > Max then\n-                        raise Constraint_Error;\n+                        Bad_Based_Value;\n                      end if;\n                   end if;\n \n@@ -358,7 +373,7 @@ package body System.Val_Real is\n       --  Here is where we check for a bad based number\n \n       if Bad_Base then\n-         raise Constraint_Error;\n+         Bad_Based_Value;\n \n       --  If OK, then deal with initial minus sign, note that this processing\n       --  is done even if Uval is zero, so that -0.0 is correctly interpreted."}, {"sha": "d49ab79a43d662a66b6c4542e621a0cbf4f7cfdd", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -4374,6 +4374,48 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  The overriding operation is type conformant with the overridden one,\n+      --  but the names of the formals are not required to match. If the names\n+      --  appear permuted in the overriding operation  this is a possible\n+      --  source of confusion that is worth diagnosing. Controlling formals\n+      --  often carry names that reflect the type, and it is not worthwhile\n+      --  requiring that their names match.\n+\n+      if Style_Check\n+        and then Present (Overridden_Subp)\n+        and then Nkind (Subp) /= N_Defining_Operator_Symbol\n+      then\n+         declare\n+            Form1 : Entity_Id;\n+            Form2 : Entity_Id;\n+\n+         begin\n+            Form1 := First_Formal (Subp);\n+            Form2 := First_Formal (Overridden_Subp);\n+\n+            if Present (Form1) then\n+               Form1 := Next_Formal (Form1);\n+               Form2 := Next_Formal (Form2);\n+            end if;\n+\n+            while Present (Form1) loop\n+               if not Is_Controlling_Formal (Form1)\n+                 and then Present (Next_Formal (Form2))\n+                 and then Chars (Form1) = Chars (Next_Formal (Form2))\n+               then\n+                  Error_Msg_Node_2 := Alias (Overridden_Subp);\n+                  Error_Msg_Sloc := Sloc (Error_Msg_Node_2);\n+                  Error_Msg_NE (\"& does not match corresponding formal of&#\",\n+                     Form1, Form1);\n+                  exit;\n+               end if;\n+\n+               Next_Formal (Form1);\n+               Next_Formal (Form2);\n+            end loop;\n+         end;\n+      end if;\n+\n       if Present (Overridden_Subp) then\n          if Must_Not_Override (Spec) then\n             Error_Msg_Sloc := Sloc (Overridden_Subp);"}, {"sha": "9f5637d0a32c39334993d8fefd7b69972c6b1060", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 43, "deletions": 254, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -37,7 +37,6 @@ with Debug;    use Debug;\n with Opt;      use Opt;\n with Output;   use Output;\n with Tree_IO;  use Tree_IO;\n-with Sinfo;    use Sinfo;\n with System;   use System;\n with Widechar; use Widechar;\n \n@@ -240,246 +239,6 @@ package body Sinput is\n       return;\n    end Build_Location_String;\n \n-   ---------------------\n-   -- Expr_First_Char --\n-   ---------------------\n-\n-   function Expr_First_Char (Expr : Node_Id) return Source_Ptr is\n-\n-      function First_Char (Expr : Node_Id; PC : Nat) return Source_Ptr;\n-      --  Internal recursive function used to traverse the expression tree.\n-      --  Returns the source pointer corresponding to the first location of\n-      --  the subexpression N, followed by backing up the given (PC) number of\n-      --  preceding left parentheses.\n-\n-      ----------------\n-      -- First_Char --\n-      ----------------\n-\n-      function First_Char (Expr : Node_Id; PC : Nat) return Source_Ptr is\n-         N     : constant Node_Id   := Original_Node (Expr);\n-         Count : constant Nat       := PC + Paren_Count (N);\n-         Kind  : constant N_Subexpr := Nkind (N);\n-         Loc   : Source_Ptr;\n-\n-      begin\n-         case Kind is\n-            when N_And_Then  |\n-                 N_In        |\n-                 N_Not_In    |\n-                 N_Or_Else   |\n-                 N_Binary_Op  =>\n-               return First_Char (Left_Opnd (N), Count);\n-\n-            when N_Attribute_Reference  |\n-                 N_Expanded_Name        |\n-                 N_Explicit_Dereference |\n-                 N_Indexed_Component    |\n-                 N_Reference            |\n-                 N_Selected_Component   |\n-                 N_Slice                =>\n-               return First_Char (Prefix (N), Count);\n-\n-            when N_Function_Call =>\n-               return First_Char (Sinfo.Name (N), Count);\n-\n-            when N_Qualified_Expression |\n-                 N_Type_Conversion      =>\n-               return First_Char (Subtype_Mark (N), Count);\n-\n-            when N_Range =>\n-               return First_Char (Low_Bound (N), Count);\n-\n-            --  Nodes that should not appear in original expression trees\n-\n-            when N_Procedure_Call_Statement  |\n-                 N_Raise_xxx_Error           |\n-                 N_Subprogram_Info           |\n-                 N_Unchecked_Expression      |\n-                 N_Unchecked_Type_Conversion |\n-                 N_Conditional_Expression    =>\n-               raise Program_Error;\n-\n-            --  Cases where the Sloc points to the start of the tokem, but we\n-            --  still need to handle the sequence of left parentheses.\n-\n-            when N_Identifier          |\n-                 N_Operator_Symbol     |\n-                 N_Character_Literal   |\n-                 N_Integer_Literal     |\n-                 N_Null                |\n-                 N_Unary_Op            |\n-                 N_Aggregate           |\n-                 N_Allocator           |\n-                 N_Extension_Aggregate |\n-                 N_Real_Literal        |\n-                 N_String_Literal      =>\n-\n-               Loc := Sloc (N);\n-\n-               --  Skip past parens\n-\n-               --  This is not right, it does not deal with skipping comments\n-               --  and probably also has wide character problems ???\n-\n-               if Count > 0 then\n-                  declare\n-                     SFI : constant Source_File_Index :=\n-                             Get_Source_File_Index (Loc);\n-                     Src : constant Source_Buffer_Ptr := Source_Text (SFI);\n-                     Fst : constant Source_Ptr        := Source_First (SFI);\n-\n-                  begin\n-                     for J in 1 .. Count loop\n-                        loop\n-                           exit when Loc = Fst;\n-                           Loc := Loc - 1;\n-                           exit when Src (Loc) >= ' ';\n-                        end loop;\n-\n-                        exit when Src (Loc) /= '(';\n-                     end loop;\n-                  end;\n-               end if;\n-\n-               return Loc;\n-         end case;\n-      end First_Char;\n-\n-   --  Start of processing for Expr_First_Char\n-\n-   begin\n-      pragma Assert (Nkind (Expr) in N_Subexpr);\n-      return First_Char (Expr, 0);\n-   end Expr_First_Char;\n-\n-   --------------------\n-   -- Expr_Last_Char --\n-   --------------------\n-\n-   function Expr_Last_Char (Expr : Node_Id) return Source_Ptr is\n-\n-      function Last_Char (Expr : Node_Id; PC : Nat) return Source_Ptr;\n-      --  Internal recursive function used to traverse the expression tree.\n-      --  Returns the source pointer corresponding to the last location of\n-      --  the subexpression N, followed by ztepping to the last of the given\n-      --  number of right parentheses.\n-\n-      ---------------\n-      -- Last_Char --\n-      ---------------\n-\n-      function Last_Char (Expr : Node_Id; PC : Nat) return Source_Ptr is\n-         N     : constant Node_Id   := Original_Node (Expr);\n-         Count : constant Nat       := PC + Paren_Count (N);\n-         Kind  : constant N_Subexpr := Nkind (N);\n-         Loc   : Source_Ptr;\n-\n-      begin\n-         case Kind is\n-            when N_And_Then  |\n-                 N_In        |\n-                 N_Not_In    |\n-                 N_Or_Else   |\n-                 N_Binary_Op  =>\n-               return Last_Char (Right_Opnd (N), Count);\n-\n-            when N_Attribute_Reference  |\n-                 N_Expanded_Name        |\n-                 N_Explicit_Dereference |\n-                 N_Indexed_Component    |\n-                 N_Reference            |\n-                 N_Selected_Component   |\n-                 N_Slice                =>\n-               return Last_Char (Prefix (N), Count);\n-\n-            when N_Function_Call =>\n-               return Last_Char (Sinfo.Name (N), Count);\n-\n-            when N_Qualified_Expression |\n-                 N_Type_Conversion      =>\n-               return Last_Char (Subtype_Mark (N), Count);\n-\n-            when N_Range =>\n-               return Last_Char (Low_Bound (N), Count);\n-\n-            --  Nodes that should not appear in original expression trees\n-\n-            when N_Procedure_Call_Statement  |\n-                 N_Raise_xxx_Error           |\n-                 N_Subprogram_Info           |\n-                 N_Unchecked_Expression      |\n-                 N_Unchecked_Type_Conversion |\n-                 N_Conditional_Expression    =>\n-               raise Program_Error;\n-\n-            --  Cases where the Sloc points to the start of the token, but we\n-            --  still need to handle the sequence of left parentheses.\n-\n-            when N_Identifier          |\n-                 N_Operator_Symbol     |\n-                 N_Character_Literal   |\n-                 N_Integer_Literal     |\n-                 N_Null                |\n-                 N_Unary_Op            |\n-                 N_Aggregate           |\n-                 N_Allocator           |\n-                 N_Extension_Aggregate |\n-                 N_Real_Literal        |\n-                 N_String_Literal      =>\n-\n-               Loc := Sloc (N);\n-\n-               --  Now we have two tasks, first we are pointing to the start\n-               --  of the token below, second, we need to skip parentheses.\n-\n-               --  Skipping to the end of a token is not easy, we can't just\n-               --  skip to a space, since we may have e.g. X*YAR+Z, and if we\n-               --  are finding the end of the subexpression X*YAR, we don't\n-               --  want to skip past the +Z. Also we have to worry about\n-               --  skipping comments, and about wide characters ???\n-\n-               declare\n-                  SFI : constant Source_File_Index :=\n-                          Get_Source_File_Index (Loc);\n-                  Src : constant Source_Buffer_Ptr := Source_Text (SFI);\n-                  Lst : constant Source_Ptr        := Source_Last (SFI);\n-\n-               begin\n-                  --  Scan through first blank character, to get to the end\n-                  --  of this token. As noted above that's not really right???\n-\n-                  loop\n-                     exit when Loc = Lst or else Src (Loc + 1) <= ' ';\n-                     Loc := Loc + 1;\n-                  end loop;\n-\n-                  --  Skip past parens, but this also ignores comments ???\n-\n-                  if Count > 0 then\n-                     for J in 1 .. Count loop\n-                        loop\n-                           exit when Loc = Lst;\n-                           Loc := Loc + 1;\n-                           exit when Src (Loc) >= ' ';\n-                        end loop;\n-\n-                        exit when Src (Loc) /= ')';\n-                     end loop;\n-                  end if;\n-               end;\n-\n-               return Loc;\n-         end case;\n-      end Last_Char;\n-\n-   --  Start of processing for Expr_Last_Char\n-\n-   begin\n-      pragma Assert (Nkind (Expr) in N_Subexpr);\n-      return Last_Char (Expr, 0);\n-   end Expr_Last_Char;\n-\n    -----------------------\n    -- Get_Column_Number --\n    -----------------------\n@@ -525,8 +284,7 @@ package body Sinput is\n    -----------------------------\n \n    function Get_Logical_Line_Number\n-     (P    : Source_Ptr)\n-      return Logical_Line_Number\n+     (P : Source_Ptr) return Logical_Line_Number\n    is\n       SFR : Source_File_Record\n               renames Source_File.Table (Get_Source_File_Index (P));\n@@ -546,8 +304,7 @@ package body Sinput is\n    ------------------------------\n \n    function Get_Physical_Line_Number\n-     (P    : Source_Ptr)\n-      return Physical_Line_Number\n+     (P : Source_Ptr) return Physical_Line_Number\n    is\n       Sfile : Source_File_Index;\n       Table : Lines_Table_Ptr;\n@@ -711,7 +468,6 @@ package body Sinput is\n \n    begin\n       S := P;\n-\n       while S > Sfirst\n         and then Src (S - 1) /= CR\n         and then Src (S - 1) /= LF\n@@ -723,9 +479,8 @@ package body Sinput is\n    end Line_Start;\n \n    function Line_Start\n-     (L    : Physical_Line_Number;\n-      S    : Source_File_Index)\n-      return Source_Ptr\n+     (L : Physical_Line_Number;\n+      S : Source_File_Index) return Source_Ptr\n    is\n    begin\n       return Source_File.Table (S).Lines_Table (L);\n@@ -794,8 +549,7 @@ package body Sinput is\n \n    function Physical_To_Logical\n      (Line : Physical_Line_Number;\n-      S    : Source_File_Index)\n-      return Logical_Line_Number\n+      S    : Source_File_Index) return Logical_Line_Number\n    is\n       SFR : Source_File_Record renames Source_File.Table (S);\n \n@@ -935,6 +689,44 @@ package body Sinput is\n       end;\n    end Skip_Line_Terminators;\n \n+   ----------------\n+   -- Sloc_Range --\n+   ----------------\n+\n+   procedure Sloc_Range (Expr : Node_Id; Min, Max : out Source_Ptr) is\n+\n+      function Process (N : Node_Id) return Traverse_Result;\n+      --  Process function for traversing the expression tree\n+\n+      procedure Traverse is new Traverse_Proc (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      function Process (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Sloc (N) < Min then\n+            if Sloc (N) > No_Location then\n+               Min := Sloc (N);\n+            end if;\n+         elsif Sloc (N) > Max then\n+            if Sloc (N) > No_Location then\n+               Max := Sloc (N);\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Process;\n+\n+   --  Start of processing for Sloc_Range\n+\n+   begin\n+      Min := Sloc (Expr);\n+      Max := Sloc (Expr);\n+      Traverse (Expr);\n+   end Sloc_Range;\n+\n    -------------------\n    -- Source_Offset --\n    -------------------\n@@ -943,7 +735,6 @@ package body Sinput is\n       Sindex : constant Source_File_Index := Get_Source_File_Index (S);\n       Sfirst : constant Source_Ptr :=\n                  Source_File.Table (Sindex).Source_First;\n-\n    begin\n       return Nat (S - Sfirst);\n    end Source_Offset;\n@@ -1368,7 +1159,6 @@ package body Sinput is\n       else\n          return Source_File.Table (S).Source_Last;\n       end if;\n-\n    end Source_Last;\n \n    function Source_Text (S : SFI) return Source_Buffer_Ptr is\n@@ -1378,7 +1168,6 @@ package body Sinput is\n       else\n          return Source_File.Table (S).Source_Text;\n       end if;\n-\n    end Source_Text;\n \n    function Template (S : SFI) return SFI is"}, {"sha": "945d26e7d4a9de6466c5faaed3d16764a780310c", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d72fb99dbc80790185d67baed6a0ca7e8bbda8/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=e7d72fb99dbc80790185d67baed6a0ca7e8bbda8", "patch": "@@ -471,14 +471,6 @@ package Sinput is\n    --  ASCII.NUL, with Name_Length indicating the length not including the\n    --  terminating Nul.\n \n-   function Expr_First_Char (Expr : Node_Id) return Source_Ptr;\n-   --  Given a node for a subexpression, returns the source location of the\n-   --  first character of the expression.\n-\n-   function Expr_Last_Char (Expr : Node_Id) return Source_Ptr;\n-   --  Given a node for a subexpression, returns the source location of the\n-   --  last character of the expression.\n-\n    function Get_Column_Number (P : Source_Ptr) return Column_Number;\n    --  The ones-origin column number of the specified Source_Ptr value is\n    --  determined and returned. Tab characters if present are assumed to\n@@ -571,12 +563,12 @@ package Sinput is\n    procedure Skip_Line_Terminators\n      (P        : in out Source_Ptr;\n       Physical : out Boolean);\n-   --  On entry, P points to a line terminator that has been encountered, which\n-   --  is one of FF,LF,VT,CR or a wide character sequence whose value is in\n-   --  category Separator,Line or Separator,Paragraph. P points just past the\n-   --  character that was scanned. The purpose of this routine is to\n-   --  distinguish physical and logical line endings. A physical line ending is\n-   --  one of:\n+   --  On entry, P points to a line terminator that has been encountered,\n+   --  which is one of FF,LF,VT,CR or a wide character sequence whose value is\n+   --  in category Separator,Line or Separator,Paragraph. P points just past\n+   --  the character that was scanned. The purpose of this routine is to\n+   --  distinguish physical and logical line endings. A physical line ending\n+   --  is one of:\n    --\n    --     CR on its own (MAC System 7)\n    --     LF on its own (Unix and unix-like systems)\n@@ -603,6 +595,15 @@ package Sinput is\n    --  makes sure that the lines table for the current source file has an\n    --  appropriate entry for the start of the new physical line.\n \n+   procedure Sloc_Range (Expr : Node_Id; Min, Max : out Source_Ptr);\n+   --  Given a node for a subexpression, returns the minimum and maximum source\n+   --  locations of any node in the expression subtree. This is not quite the\n+   --  same as the locations of the first and last token in the expresion\n+   --  because parentheses at the outer level do not have a recorded Sloc.\n+   --\n+   --  Note: if the tree for the expression contains no \"real\" Sloc values,\n+   --  i.e. values > No_Location, then both Min and Max are set to Sloc (Expr).\n+\n    function Source_Offset (S : Source_Ptr) return Nat;\n    --  Returns the zero-origin offset of the given source location from the\n    --  start of its corresponding unit. This is used for creating canonical"}]}