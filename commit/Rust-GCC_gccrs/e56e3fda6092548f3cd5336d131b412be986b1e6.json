{"sha": "e56e3fda6092548f3cd5336d131b412be986b1e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2ZTNmZGE2MDkyNTQ4ZjNjZDUzMzZkMTMxYjQxMmJlOTg2YjFlNg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-06-24T07:07:56Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-06-24T07:07:56Z"}, "message": "re PR fortran/52473 (CSHIFT slow - inline it?)\n\n2017-06-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n        PR fortran/52473\n\t* Makefile.am:  Add i_cshift1a_c.  Add rules to generate files\n\tfrom cshift1a.m4.\n\t* Makefile.in: Regenerated.\n\t* m4/cshift1a.m4: New file.\n\t* m4/cshift.m4 (cshift1): Split up inner loop by removing\n\tcondition. Use memcpy where possible.  Call helper functions\n\tbased on dtype.\n\t* libgfortran.h: Add prototypes for cshift1_16_c10,\n\tcshift1_16_c16, cshift1_16_c4, cshift1_16_c8, cshift1_16_i1,\n\tcshift1_16_i16, cshift1_16_i2, cshift1_16_i4, cshift1_16_i8,\n\tcshift1_16_r10, cshift1_16_r16, cshift1_16_r4, cshift1_16_r8,\n\tcshift1_4_c10, cshift1_4_c16, cshift1_4_c4, cshift1_4_c8,\n\tcshift1_4_i1, cshift1_4_i16, cshift1_4_i2, cshift1_4_i4,\n\tcshift1_4_i8, cshift1_4_r10, cshift1_4_r16, cshift1_4_r4,\n\tcshift1_4_r8, cshift1_8_c10, cshift1_8_c16, cshift1_8_c4,\n\tcshift1_8_c8, cshift1_8_i1, cshift1_8_i16, cshift1_8_i2,\n\tcshift1_8_i4, cshift1_8_i8, cshift1_8_r10, cshift1_8_r16,\n\tcshift1_8_r4 and cshift1_8_r8.\n\t* generated/cshift1_16_c10.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_c16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_c4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_c8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_i1.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_i16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_i2.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_i4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_i8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_r10.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_r16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_r4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_16_r8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_c10.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_c16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_c4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_c8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_i1.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_i16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_i2.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_i4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_i8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_r10.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_r16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_r4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_4_r8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_c10.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_c16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_c4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_c8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_i1.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_i16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_i2.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_i4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_i8.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_r10.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_r16.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_r4.c: New file, generated from cshift1a.m4.\n\t* generated/cshift1_8_r8.c: New file, generated from cshift1a.m4.\n\n2017-06-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n        PR fortran/52473\n\t* gfortran.dg/cshift_2.f90:  New test.\n\nFrom-SVN: r249620", "tree": {"sha": "2c28733ee096cbdb641e42b511b18f7c28205330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c28733ee096cbdb641e42b511b18f7c28205330"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e56e3fda6092548f3cd5336d131b412be986b1e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56e3fda6092548f3cd5336d131b412be986b1e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56e3fda6092548f3cd5336d131b412be986b1e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56e3fda6092548f3cd5336d131b412be986b1e6/comments", "author": null, "committer": null, "parents": [{"sha": "ef5b7d19b688bb92178f41f504133f0ee51bffc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef5b7d19b688bb92178f41f504133f0ee51bffc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef5b7d19b688bb92178f41f504133f0ee51bffc6"}], "stats": {"total": 9252, "additions": 9183, "deletions": 69}, "files": [{"sha": "eefa2c4771556868aa37ede8af50c37c09ca4dcc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -1,3 +1,8 @@\n+2017-06-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+        PR fortran/52473\n+\t* gfortran.dg/cshift_2.f90:  New test.\n+\n 2017-06-23  Jim Wilson  <jim.wilson@linaro.org>\n \n \tPR middle-end/79794"}, {"sha": "66a6e2b726864c556af724ad8ef7dffe8f1d6312", "filename": "gcc/testsuite/gfortran.dg/cshift_2.f90", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_2.f90?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,152 @@\n+! { dg-do  run }\n+! Test CSHIFT with array argument for shift\n+module rnd\n+  implicit none\n+contains\n+  subroutine fill(a,n)\n+    integer, intent(out), dimension(:,:) :: a\n+    integer, intent(in) :: n\n+    real, dimension(size(a,1),size(a,2)) :: r\n+    call random_number(r)\n+    a = int(2*n*r-n)\n+  end subroutine fill\n+end module rnd\n+\n+module csh\n+  implicit none\n+contains\n+  subroutine emul_cshift(a,sh_in,dim, c)\n+    integer, dimension(:,:,:), intent(in) :: a\n+    integer, dimension(:,:,:), intent(out) :: c\n+    integer, dimension(:,:), intent(in) :: sh_in\n+    integer, intent(in) :: dim\n+    integer :: sh, rsh\n+    integer :: s1, s2, s3, n, i\n+    integer :: n1, n2, n3\n+    n1 = size(a,1)\n+    n2 = size(a,2)\n+    n3 = size(a,3)\n+    if (dim == 1) then\n+       n = n1\n+       do s2=1,n2\n+          do s3=1,n3\n+             sh = modulo(sh_in(s2,s3), n)\n+             rsh = n - sh\n+             do i=1,rsh\n+                c(i,s2,s3) = a(i+sh,s2,s3)\n+             end do\n+             do i=rsh+1,n\n+                c(i,s2,s3) = a(i-rsh,s2,s3)\n+             end do\n+          end do\n+       end do\n+    else if (dim == 2) then\n+       n = n2\n+       do s3=1,n3\n+          do s1=1,n1\n+             sh = modulo(sh_in(s1,s3),n)\n+             rsh = n - sh\n+             do i=1,rsh\n+                c(s1,i,s3) = a(s1,i+sh,s3)\n+             end do\n+             do i=rsh+1,n\n+                c(s1,i,s3) = a(s1,i-rsh,s3)\n+             end do\n+          end do\n+       end do\n+\n+    else if (dim == 3) then\n+       n = n3\n+       do s2=1,n2\n+          do s1=1,n1\n+             sh = modulo(sh_in(s1,s2),n)\n+             rsh = n - sh\n+             do i=1,rsh\n+                c(s1,s2,i) = a(s1,s2,i+sh)\n+             end do\n+             do i=rsh+1,n\n+                c(s1,s2,i) = a(s1,s2,i-rsh)\n+             end do\n+          end do\n+       end do\n+    else\n+       stop \"Illegal dim\"\n+    end if\n+  end subroutine emul_cshift\n+end module csh\n+program main\n+  use csh\n+  use rnd\n+  implicit none\n+  integer, parameter :: n1=30,n2=40,n3=50\n+  integer, dimension(n1,n2,n3) :: a, b,c\n+  integer :: s1, s2, s3\n+  integer :: dim\n+  integer, dimension(:,:), allocatable :: sh1, sh2, sh3\n+  integer, dimension(:), allocatable :: sh_shift\n+  integer :: sh, rsh\n+  integer :: i,j,k,v\n+  type t\n+     integer :: i1, i2, i3\n+  end type t\n+  type(t), dimension(n1,n2,n3) :: ta, tb\n+\n+  v = 1\n+  do k=1,n3\n+     do j=1,n2\n+        do i=1,n1\n+           a(i,j,k) = v\n+           v = v + 1\n+        end do\n+     end do\n+  end do\n+\n+  ta%i1 = a\n+  ta%i2 = a+a\n+  ta%i3 = a+a+a\n+  allocate(sh1(n2,n3))\n+  allocate(sh2(n1,n3))\n+  allocate(sh3(n1,n2))\n+\n+  call fill(sh1,10)\n+  call fill(sh2,10)\n+  call fill(sh3,10)\n+\n+  b = cshift(a,sh1,1)\n+  call emul_cshift(a,sh1,1,c)\n+  if (any(b /= c)) then\n+     print *,b\n+     print *,c\n+     call abort\n+  end if\n+  tb = cshift(ta,sh1,1)\n+  if (any(tb%i1 /= c)) call abort\n+  \n+  b = cshift(a,sh2,2)\n+  call emul_cshift(a,sh2,2,c)\n+  if (any(b /= c)) call abort\n+  tb = cshift(ta,sh2,2)\n+  if (any (tb%i2 /= c*2)) call abort\n+\n+  b = cshift(a,sh3,3)\n+  call emul_cshift(a,sh3,3,c)\n+  if (any(b /= c)) call abort\n+  tb = cshift(ta,sh3,3)\n+  if (any(tb%i3 /= c*3)) call abort\n+\n+  b = -42\n+  c = -42\n+  b(1:n1:2,:,:) = cshift(a(1:n1/2,:,:),sh1,1)\n+  call emul_cshift(a(1:n1/2,:,:), sh1, 1, c(1:n1:2,:,:))\n+  if (any(b /= c)) call abort\n+\n+  tb%i1 = -42\n+  tb%i2 = -2*42\n+  tb%i3 = -3*42\n+  tb(1:n1:2,:,:) = cshift(ta(1:n1/2,:,:),sh1,1)\n+  if (any(tb%i1 /= b)) call abort\n+  if (any(tb%i2 /= 2*b)) call abort\n+  if (any(tb%i3 /= 3*b)) call abort\n+  \n+9000 format (99(3(I3,1X),2X))\n+end program main"}, {"sha": "de85da9bef63d9ada9fad53a5de5fb1bf7f2699e", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -1,3 +1,64 @@\n+2017-06-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+        PR fortran/52473\n+\t* Makefile.am:  Add i_cshift1a_c.  Add rules to generate files\n+\tfrom cshift1a.m4.\n+\t* Makefile.in: Regenerated.\n+\t* m4/cshift1a.m4: New file.\n+\t* m4/cshift.m4 (cshift1): Split up inner loop by removing\n+\tcondition. Use memcpy where possible.  Call helper functions\n+\tbased on dtype.\n+\t* libgfortran.h: Add prototypes for cshift1_16_c10,\n+\tcshift1_16_c16, cshift1_16_c4, cshift1_16_c8, cshift1_16_i1,\n+\tcshift1_16_i16, cshift1_16_i2, cshift1_16_i4, cshift1_16_i8,\n+\tcshift1_16_r10, cshift1_16_r16, cshift1_16_r4, cshift1_16_r8,\n+\tcshift1_4_c10, cshift1_4_c16, cshift1_4_c4, cshift1_4_c8,\n+\tcshift1_4_i1, cshift1_4_i16, cshift1_4_i2, cshift1_4_i4,\n+\tcshift1_4_i8, cshift1_4_r10, cshift1_4_r16, cshift1_4_r4,\n+\tcshift1_4_r8, cshift1_8_c10, cshift1_8_c16, cshift1_8_c4,\n+\tcshift1_8_c8, cshift1_8_i1, cshift1_8_i16, cshift1_8_i2,\n+\tcshift1_8_i4, cshift1_8_i8, cshift1_8_r10, cshift1_8_r16,\n+\tcshift1_8_r4 and cshift1_8_r8.\n+\t* generated/cshift1_16_c10.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_c16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_c4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_c8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_i1.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_i16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_i2.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_i4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_i8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_r10.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_r16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_r4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_16_r8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_c10.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_c16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_c4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_c8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_i1.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_i16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_i2.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_i4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_i8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_r10.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_r16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_r4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_4_r8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_c10.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_c16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_c4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_c8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_i1.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_i16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_i2.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_i4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_i8.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_r10.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_r16.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_r4.c: New file, generated from cshift1a.m4.\n+\t* generated/cshift1_8_r8.c: New file, generated from cshift1a.m4.\n+\n 2017-06-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/52473"}, {"sha": "c5982a7d9db3c6d782efa2e9de5bb784628ce25c", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -524,13 +524,53 @@ $(srcdir)/generated/cshift0_c4.c \\\n $(srcdir)/generated/cshift0_c8.c \\\n $(srcdir)/generated/cshift0_c10.c \\\n $(srcdir)/generated/cshift0_c16.c\n- \n \n i_cshift1_c= \\\n $(srcdir)/generated/cshift1_4.c \\\n $(srcdir)/generated/cshift1_8.c \\\n $(srcdir)/generated/cshift1_16.c\n \n+i_cshift1a_c = \\\n+$(srcdir)/generated/cshift1_4_i1.c \\\n+$(srcdir)/generated/cshift1_4_i2.c \\\n+$(srcdir)/generated/cshift1_4_i4.c \\\n+$(srcdir)/generated/cshift1_4_i8.c \\\n+$(srcdir)/generated/cshift1_4_i16.c \\\n+$(srcdir)/generated/cshift1_4_r4.c \\\n+$(srcdir)/generated/cshift1_4_r8.c \\\n+$(srcdir)/generated/cshift1_4_r10.c \\\n+$(srcdir)/generated/cshift1_4_r16.c \\\n+$(srcdir)/generated/cshift1_4_c4.c \\\n+$(srcdir)/generated/cshift1_4_c8.c \\\n+$(srcdir)/generated/cshift1_4_c10.c \\\n+$(srcdir)/generated/cshift1_4_c16.c \\\n+$(srcdir)/generated/cshift1_8_i1.c \\\n+$(srcdir)/generated/cshift1_8_i2.c \\\n+$(srcdir)/generated/cshift1_8_i4.c \\\n+$(srcdir)/generated/cshift1_8_i8.c \\\n+$(srcdir)/generated/cshift1_8_i16.c \\\n+$(srcdir)/generated/cshift1_8_r4.c \\\n+$(srcdir)/generated/cshift1_8_r8.c \\\n+$(srcdir)/generated/cshift1_8_r10.c \\\n+$(srcdir)/generated/cshift1_8_r16.c \\\n+$(srcdir)/generated/cshift1_8_c4.c \\\n+$(srcdir)/generated/cshift1_8_c8.c \\\n+$(srcdir)/generated/cshift1_8_c10.c \\\n+$(srcdir)/generated/cshift1_8_c16.c \\\n+$(srcdir)/generated/cshift1_16_i1.c \\\n+$(srcdir)/generated/cshift1_16_i2.c \\\n+$(srcdir)/generated/cshift1_16_i4.c \\\n+$(srcdir)/generated/cshift1_16_i8.c \\\n+$(srcdir)/generated/cshift1_16_i16.c \\\n+$(srcdir)/generated/cshift1_16_r4.c \\\n+$(srcdir)/generated/cshift1_16_r8.c \\\n+$(srcdir)/generated/cshift1_16_r10.c \\\n+$(srcdir)/generated/cshift1_16_r16.c \\\n+$(srcdir)/generated/cshift1_16_c4.c \\\n+$(srcdir)/generated/cshift1_16_c8.c \\\n+$(srcdir)/generated/cshift1_16_c10.c \\\n+$(srcdir)/generated/cshift1_16_c16.c\n+\n in_pack_c = \\\n $(srcdir)/generated/in_pack_i1.c \\\n $(srcdir)/generated/in_pack_i2.c \\\n@@ -658,7 +698,8 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc\n+    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n+    $(i_cshift1a_c)\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n@@ -986,6 +1027,9 @@ $(i_cshift0_c): m4/cshift0.m4 $(I_M4_DEPS)\n $(i_cshift1_c): m4/cshift1.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift1.m4 > $@\n \n+$(i_cshift1a_c): m4/cshift1a.m4 $(I_M$_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift1a.m4 > $@\n+\n $(in_pack_c): m4/in_pack.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 in_pack.m4 > $@\n "}, {"sha": "d80223c82e490577e3bf7759b2f0e81104cd8f95", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 389, "deletions": 19, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -302,7 +302,20 @@ am__objects_35 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n \tcshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \\\n \tcshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \\\n \tcshift0_c10.lo cshift0_c16.lo\n-am__objects_36 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n+am__objects_36 = cshift1_4_i1.lo cshift1_4_i2.lo cshift1_4_i4.lo \\\n+\tcshift1_4_i8.lo cshift1_4_i16.lo cshift1_4_r4.lo \\\n+\tcshift1_4_r8.lo cshift1_4_r10.lo cshift1_4_r16.lo \\\n+\tcshift1_4_c4.lo cshift1_4_c8.lo cshift1_4_c10.lo \\\n+\tcshift1_4_c16.lo cshift1_8_i1.lo cshift1_8_i2.lo \\\n+\tcshift1_8_i4.lo cshift1_8_i8.lo cshift1_8_i16.lo \\\n+\tcshift1_8_r4.lo cshift1_8_r8.lo cshift1_8_r10.lo \\\n+\tcshift1_8_r16.lo cshift1_8_c4.lo cshift1_8_c8.lo \\\n+\tcshift1_8_c10.lo cshift1_8_c16.lo cshift1_16_i1.lo \\\n+\tcshift1_16_i2.lo cshift1_16_i4.lo cshift1_16_i8.lo \\\n+\tcshift1_16_i16.lo cshift1_16_r4.lo cshift1_16_r8.lo \\\n+\tcshift1_16_r10.lo cshift1_16_r16.lo cshift1_16_c4.lo \\\n+\tcshift1_16_c8.lo cshift1_16_c10.lo cshift1_16_c16.lo\n+am__objects_37 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n@@ -312,14 +325,14 @@ am__objects_36 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_25) $(am__objects_26) $(am__objects_27) \\\n \t$(am__objects_28) $(am__objects_29) $(am__objects_30) \\\n \t$(am__objects_31) $(am__objects_32) $(am__objects_33) \\\n-\t$(am__objects_34) $(am__objects_35)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_37 = close.lo file_pos.lo format.lo \\\n+\t$(am__objects_34) $(am__objects_35) $(am__objects_36)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_38 = close.lo file_pos.lo format.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tfbuf.lo\n-am__objects_38 = size_from_kind.lo $(am__objects_37)\n-@LIBGFOR_MINIMAL_FALSE@am__objects_39 = access.lo c99_functions.lo \\\n+am__objects_39 = size_from_kind.lo $(am__objects_38)\n+@LIBGFOR_MINIMAL_FALSE@am__objects_40 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tctime.lo date_and_time.lo dtime.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tenv.lo etime.lo execute_command_line.lo \\\n@@ -329,19 +342,19 @@ am__objects_38 = size_from_kind.lo $(am__objects_37)\n @LIBGFOR_MINIMAL_FALSE@\trename.lo stat.lo symlnk.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tsystem_clock.lo time.lo umask.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tunlink.lo\n-@IEEE_SUPPORT_TRUE@am__objects_40 = ieee_helper.lo\n-am__objects_41 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n+@IEEE_SUPPORT_TRUE@am__objects_41 = ieee_helper.lo\n+am__objects_42 = associated.lo abort.lo args.lo cshift0.lo eoshift0.lo \\\n \teoshift2.lo erfc_scaled.lo extends_type_of.lo fnum.lo \\\n \tierrno.lo ishftc.lo mvbits.lo move_alloc.lo pack_generic.lo \\\n \tselected_char_kind.lo size.lo spread_generic.lo \\\n \tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n \treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n \tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\t$(am__objects_39) $(am__objects_40)\n-@IEEE_SUPPORT_TRUE@am__objects_42 = ieee_arithmetic.lo \\\n+\t$(am__objects_40) $(am__objects_41)\n+@IEEE_SUPPORT_TRUE@am__objects_43 = ieee_arithmetic.lo \\\n @IEEE_SUPPORT_TRUE@\tieee_exceptions.lo ieee_features.lo\n-am__objects_43 =\n-am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_44 =\n+am__objects_45 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -365,19 +378,19 @@ am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_45 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_46 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_46 = misc_specifics.lo\n-am__objects_47 = $(am__objects_44) $(am__objects_45) $(am__objects_46) \\\n+am__objects_47 = misc_specifics.lo\n+am__objects_48 = $(am__objects_45) $(am__objects_46) $(am__objects_47) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_48 = $(am__objects_3) $(am__objects_36) $(am__objects_38) \\\n-\t$(am__objects_41) $(am__objects_42) $(am__objects_43) \\\n-\t$(am__objects_47)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_48)\n+am__objects_49 = $(am__objects_3) $(am__objects_37) $(am__objects_39) \\\n+\t$(am__objects_42) $(am__objects_43) $(am__objects_44) \\\n+\t$(am__objects_48)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_49)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -954,6 +967,47 @@ $(srcdir)/generated/cshift1_4.c \\\n $(srcdir)/generated/cshift1_8.c \\\n $(srcdir)/generated/cshift1_16.c\n \n+i_cshift1a_c = \\\n+$(srcdir)/generated/cshift1_4_i1.c \\\n+$(srcdir)/generated/cshift1_4_i2.c \\\n+$(srcdir)/generated/cshift1_4_i4.c \\\n+$(srcdir)/generated/cshift1_4_i8.c \\\n+$(srcdir)/generated/cshift1_4_i16.c \\\n+$(srcdir)/generated/cshift1_4_r4.c \\\n+$(srcdir)/generated/cshift1_4_r8.c \\\n+$(srcdir)/generated/cshift1_4_r10.c \\\n+$(srcdir)/generated/cshift1_4_r16.c \\\n+$(srcdir)/generated/cshift1_4_c4.c \\\n+$(srcdir)/generated/cshift1_4_c8.c \\\n+$(srcdir)/generated/cshift1_4_c10.c \\\n+$(srcdir)/generated/cshift1_4_c16.c \\\n+$(srcdir)/generated/cshift1_8_i1.c \\\n+$(srcdir)/generated/cshift1_8_i2.c \\\n+$(srcdir)/generated/cshift1_8_i4.c \\\n+$(srcdir)/generated/cshift1_8_i8.c \\\n+$(srcdir)/generated/cshift1_8_i16.c \\\n+$(srcdir)/generated/cshift1_8_r4.c \\\n+$(srcdir)/generated/cshift1_8_r8.c \\\n+$(srcdir)/generated/cshift1_8_r10.c \\\n+$(srcdir)/generated/cshift1_8_r16.c \\\n+$(srcdir)/generated/cshift1_8_c4.c \\\n+$(srcdir)/generated/cshift1_8_c8.c \\\n+$(srcdir)/generated/cshift1_8_c10.c \\\n+$(srcdir)/generated/cshift1_8_c16.c \\\n+$(srcdir)/generated/cshift1_16_i1.c \\\n+$(srcdir)/generated/cshift1_16_i2.c \\\n+$(srcdir)/generated/cshift1_16_i4.c \\\n+$(srcdir)/generated/cshift1_16_i8.c \\\n+$(srcdir)/generated/cshift1_16_i16.c \\\n+$(srcdir)/generated/cshift1_16_r4.c \\\n+$(srcdir)/generated/cshift1_16_r8.c \\\n+$(srcdir)/generated/cshift1_16_r10.c \\\n+$(srcdir)/generated/cshift1_16_r16.c \\\n+$(srcdir)/generated/cshift1_16_c4.c \\\n+$(srcdir)/generated/cshift1_16_c8.c \\\n+$(srcdir)/generated/cshift1_16_c10.c \\\n+$(srcdir)/generated/cshift1_16_c16.c\n+\n in_pack_c = \\\n $(srcdir)/generated/in_pack_i1.c \\\n $(srcdir)/generated/in_pack_i2.c \\\n@@ -1081,7 +1135,8 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc\n+    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n+    $(i_cshift1a_c)\n \n \n # Machine generated specifics\n@@ -1437,8 +1492,47 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctime.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/date_and_time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dtime.Plo@am__quote@\n@@ -4890,6 +4984,279 @@ cshift0_c16.lo: $(srcdir)/generated/cshift0_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_c16.lo `test -f '$(srcdir)/generated/cshift0_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c16.c\n \n+cshift1_4_i1.lo: $(srcdir)/generated/cshift1_4_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_i1.lo -MD -MP -MF $(DEPDIR)/cshift1_4_i1.Tpo -c -o cshift1_4_i1.lo `test -f '$(srcdir)/generated/cshift1_4_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_i1.Tpo $(DEPDIR)/cshift1_4_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_i1.c' object='cshift1_4_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_i1.lo `test -f '$(srcdir)/generated/cshift1_4_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i1.c\n+\n+cshift1_4_i2.lo: $(srcdir)/generated/cshift1_4_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_i2.lo -MD -MP -MF $(DEPDIR)/cshift1_4_i2.Tpo -c -o cshift1_4_i2.lo `test -f '$(srcdir)/generated/cshift1_4_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_i2.Tpo $(DEPDIR)/cshift1_4_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_i2.c' object='cshift1_4_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_i2.lo `test -f '$(srcdir)/generated/cshift1_4_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i2.c\n+\n+cshift1_4_i4.lo: $(srcdir)/generated/cshift1_4_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_i4.lo -MD -MP -MF $(DEPDIR)/cshift1_4_i4.Tpo -c -o cshift1_4_i4.lo `test -f '$(srcdir)/generated/cshift1_4_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_i4.Tpo $(DEPDIR)/cshift1_4_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_i4.c' object='cshift1_4_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_i4.lo `test -f '$(srcdir)/generated/cshift1_4_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i4.c\n+\n+cshift1_4_i8.lo: $(srcdir)/generated/cshift1_4_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_i8.lo -MD -MP -MF $(DEPDIR)/cshift1_4_i8.Tpo -c -o cshift1_4_i8.lo `test -f '$(srcdir)/generated/cshift1_4_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_i8.Tpo $(DEPDIR)/cshift1_4_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_i8.c' object='cshift1_4_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_i8.lo `test -f '$(srcdir)/generated/cshift1_4_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i8.c\n+\n+cshift1_4_i16.lo: $(srcdir)/generated/cshift1_4_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_i16.lo -MD -MP -MF $(DEPDIR)/cshift1_4_i16.Tpo -c -o cshift1_4_i16.lo `test -f '$(srcdir)/generated/cshift1_4_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_i16.Tpo $(DEPDIR)/cshift1_4_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_i16.c' object='cshift1_4_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_i16.lo `test -f '$(srcdir)/generated/cshift1_4_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_i16.c\n+\n+cshift1_4_r4.lo: $(srcdir)/generated/cshift1_4_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_r4.lo -MD -MP -MF $(DEPDIR)/cshift1_4_r4.Tpo -c -o cshift1_4_r4.lo `test -f '$(srcdir)/generated/cshift1_4_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_r4.Tpo $(DEPDIR)/cshift1_4_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_r4.c' object='cshift1_4_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_r4.lo `test -f '$(srcdir)/generated/cshift1_4_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r4.c\n+\n+cshift1_4_r8.lo: $(srcdir)/generated/cshift1_4_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_r8.lo -MD -MP -MF $(DEPDIR)/cshift1_4_r8.Tpo -c -o cshift1_4_r8.lo `test -f '$(srcdir)/generated/cshift1_4_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_r8.Tpo $(DEPDIR)/cshift1_4_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_r8.c' object='cshift1_4_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_r8.lo `test -f '$(srcdir)/generated/cshift1_4_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r8.c\n+\n+cshift1_4_r10.lo: $(srcdir)/generated/cshift1_4_r10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_r10.lo -MD -MP -MF $(DEPDIR)/cshift1_4_r10.Tpo -c -o cshift1_4_r10.lo `test -f '$(srcdir)/generated/cshift1_4_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_r10.Tpo $(DEPDIR)/cshift1_4_r10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_r10.c' object='cshift1_4_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_r10.lo `test -f '$(srcdir)/generated/cshift1_4_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r10.c\n+\n+cshift1_4_r16.lo: $(srcdir)/generated/cshift1_4_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_r16.lo -MD -MP -MF $(DEPDIR)/cshift1_4_r16.Tpo -c -o cshift1_4_r16.lo `test -f '$(srcdir)/generated/cshift1_4_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_r16.Tpo $(DEPDIR)/cshift1_4_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_r16.c' object='cshift1_4_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_r16.lo `test -f '$(srcdir)/generated/cshift1_4_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_r16.c\n+\n+cshift1_4_c4.lo: $(srcdir)/generated/cshift1_4_c4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_c4.lo -MD -MP -MF $(DEPDIR)/cshift1_4_c4.Tpo -c -o cshift1_4_c4.lo `test -f '$(srcdir)/generated/cshift1_4_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_c4.Tpo $(DEPDIR)/cshift1_4_c4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_c4.c' object='cshift1_4_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_c4.lo `test -f '$(srcdir)/generated/cshift1_4_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c4.c\n+\n+cshift1_4_c8.lo: $(srcdir)/generated/cshift1_4_c8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_c8.lo -MD -MP -MF $(DEPDIR)/cshift1_4_c8.Tpo -c -o cshift1_4_c8.lo `test -f '$(srcdir)/generated/cshift1_4_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_c8.Tpo $(DEPDIR)/cshift1_4_c8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_c8.c' object='cshift1_4_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_c8.lo `test -f '$(srcdir)/generated/cshift1_4_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c8.c\n+\n+cshift1_4_c10.lo: $(srcdir)/generated/cshift1_4_c10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_c10.lo -MD -MP -MF $(DEPDIR)/cshift1_4_c10.Tpo -c -o cshift1_4_c10.lo `test -f '$(srcdir)/generated/cshift1_4_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_c10.Tpo $(DEPDIR)/cshift1_4_c10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_c10.c' object='cshift1_4_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_c10.lo `test -f '$(srcdir)/generated/cshift1_4_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c10.c\n+\n+cshift1_4_c16.lo: $(srcdir)/generated/cshift1_4_c16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_4_c16.lo -MD -MP -MF $(DEPDIR)/cshift1_4_c16.Tpo -c -o cshift1_4_c16.lo `test -f '$(srcdir)/generated/cshift1_4_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_4_c16.Tpo $(DEPDIR)/cshift1_4_c16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_4_c16.c' object='cshift1_4_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_4_c16.lo `test -f '$(srcdir)/generated/cshift1_4_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_4_c16.c\n+\n+cshift1_8_i1.lo: $(srcdir)/generated/cshift1_8_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_i1.lo -MD -MP -MF $(DEPDIR)/cshift1_8_i1.Tpo -c -o cshift1_8_i1.lo `test -f '$(srcdir)/generated/cshift1_8_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_i1.Tpo $(DEPDIR)/cshift1_8_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_i1.c' object='cshift1_8_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_i1.lo `test -f '$(srcdir)/generated/cshift1_8_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i1.c\n+\n+cshift1_8_i2.lo: $(srcdir)/generated/cshift1_8_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_i2.lo -MD -MP -MF $(DEPDIR)/cshift1_8_i2.Tpo -c -o cshift1_8_i2.lo `test -f '$(srcdir)/generated/cshift1_8_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_i2.Tpo $(DEPDIR)/cshift1_8_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_i2.c' object='cshift1_8_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_i2.lo `test -f '$(srcdir)/generated/cshift1_8_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i2.c\n+\n+cshift1_8_i4.lo: $(srcdir)/generated/cshift1_8_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_i4.lo -MD -MP -MF $(DEPDIR)/cshift1_8_i4.Tpo -c -o cshift1_8_i4.lo `test -f '$(srcdir)/generated/cshift1_8_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_i4.Tpo $(DEPDIR)/cshift1_8_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_i4.c' object='cshift1_8_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_i4.lo `test -f '$(srcdir)/generated/cshift1_8_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i4.c\n+\n+cshift1_8_i8.lo: $(srcdir)/generated/cshift1_8_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_i8.lo -MD -MP -MF $(DEPDIR)/cshift1_8_i8.Tpo -c -o cshift1_8_i8.lo `test -f '$(srcdir)/generated/cshift1_8_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_i8.Tpo $(DEPDIR)/cshift1_8_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_i8.c' object='cshift1_8_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_i8.lo `test -f '$(srcdir)/generated/cshift1_8_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i8.c\n+\n+cshift1_8_i16.lo: $(srcdir)/generated/cshift1_8_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_i16.lo -MD -MP -MF $(DEPDIR)/cshift1_8_i16.Tpo -c -o cshift1_8_i16.lo `test -f '$(srcdir)/generated/cshift1_8_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_i16.Tpo $(DEPDIR)/cshift1_8_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_i16.c' object='cshift1_8_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_i16.lo `test -f '$(srcdir)/generated/cshift1_8_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_i16.c\n+\n+cshift1_8_r4.lo: $(srcdir)/generated/cshift1_8_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_r4.lo -MD -MP -MF $(DEPDIR)/cshift1_8_r4.Tpo -c -o cshift1_8_r4.lo `test -f '$(srcdir)/generated/cshift1_8_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_r4.Tpo $(DEPDIR)/cshift1_8_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_r4.c' object='cshift1_8_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_r4.lo `test -f '$(srcdir)/generated/cshift1_8_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r4.c\n+\n+cshift1_8_r8.lo: $(srcdir)/generated/cshift1_8_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_r8.lo -MD -MP -MF $(DEPDIR)/cshift1_8_r8.Tpo -c -o cshift1_8_r8.lo `test -f '$(srcdir)/generated/cshift1_8_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_r8.Tpo $(DEPDIR)/cshift1_8_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_r8.c' object='cshift1_8_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_r8.lo `test -f '$(srcdir)/generated/cshift1_8_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r8.c\n+\n+cshift1_8_r10.lo: $(srcdir)/generated/cshift1_8_r10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_r10.lo -MD -MP -MF $(DEPDIR)/cshift1_8_r10.Tpo -c -o cshift1_8_r10.lo `test -f '$(srcdir)/generated/cshift1_8_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_r10.Tpo $(DEPDIR)/cshift1_8_r10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_r10.c' object='cshift1_8_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_r10.lo `test -f '$(srcdir)/generated/cshift1_8_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r10.c\n+\n+cshift1_8_r16.lo: $(srcdir)/generated/cshift1_8_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_r16.lo -MD -MP -MF $(DEPDIR)/cshift1_8_r16.Tpo -c -o cshift1_8_r16.lo `test -f '$(srcdir)/generated/cshift1_8_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_r16.Tpo $(DEPDIR)/cshift1_8_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_r16.c' object='cshift1_8_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_r16.lo `test -f '$(srcdir)/generated/cshift1_8_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_r16.c\n+\n+cshift1_8_c4.lo: $(srcdir)/generated/cshift1_8_c4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_c4.lo -MD -MP -MF $(DEPDIR)/cshift1_8_c4.Tpo -c -o cshift1_8_c4.lo `test -f '$(srcdir)/generated/cshift1_8_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_c4.Tpo $(DEPDIR)/cshift1_8_c4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_c4.c' object='cshift1_8_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_c4.lo `test -f '$(srcdir)/generated/cshift1_8_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c4.c\n+\n+cshift1_8_c8.lo: $(srcdir)/generated/cshift1_8_c8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_c8.lo -MD -MP -MF $(DEPDIR)/cshift1_8_c8.Tpo -c -o cshift1_8_c8.lo `test -f '$(srcdir)/generated/cshift1_8_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_c8.Tpo $(DEPDIR)/cshift1_8_c8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_c8.c' object='cshift1_8_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_c8.lo `test -f '$(srcdir)/generated/cshift1_8_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c8.c\n+\n+cshift1_8_c10.lo: $(srcdir)/generated/cshift1_8_c10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_c10.lo -MD -MP -MF $(DEPDIR)/cshift1_8_c10.Tpo -c -o cshift1_8_c10.lo `test -f '$(srcdir)/generated/cshift1_8_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_c10.Tpo $(DEPDIR)/cshift1_8_c10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_c10.c' object='cshift1_8_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_c10.lo `test -f '$(srcdir)/generated/cshift1_8_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c10.c\n+\n+cshift1_8_c16.lo: $(srcdir)/generated/cshift1_8_c16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_8_c16.lo -MD -MP -MF $(DEPDIR)/cshift1_8_c16.Tpo -c -o cshift1_8_c16.lo `test -f '$(srcdir)/generated/cshift1_8_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_8_c16.Tpo $(DEPDIR)/cshift1_8_c16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_8_c16.c' object='cshift1_8_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_8_c16.lo `test -f '$(srcdir)/generated/cshift1_8_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_8_c16.c\n+\n+cshift1_16_i1.lo: $(srcdir)/generated/cshift1_16_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_i1.lo -MD -MP -MF $(DEPDIR)/cshift1_16_i1.Tpo -c -o cshift1_16_i1.lo `test -f '$(srcdir)/generated/cshift1_16_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_i1.Tpo $(DEPDIR)/cshift1_16_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_i1.c' object='cshift1_16_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_i1.lo `test -f '$(srcdir)/generated/cshift1_16_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i1.c\n+\n+cshift1_16_i2.lo: $(srcdir)/generated/cshift1_16_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_i2.lo -MD -MP -MF $(DEPDIR)/cshift1_16_i2.Tpo -c -o cshift1_16_i2.lo `test -f '$(srcdir)/generated/cshift1_16_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_i2.Tpo $(DEPDIR)/cshift1_16_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_i2.c' object='cshift1_16_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_i2.lo `test -f '$(srcdir)/generated/cshift1_16_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i2.c\n+\n+cshift1_16_i4.lo: $(srcdir)/generated/cshift1_16_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_i4.lo -MD -MP -MF $(DEPDIR)/cshift1_16_i4.Tpo -c -o cshift1_16_i4.lo `test -f '$(srcdir)/generated/cshift1_16_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_i4.Tpo $(DEPDIR)/cshift1_16_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_i4.c' object='cshift1_16_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_i4.lo `test -f '$(srcdir)/generated/cshift1_16_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i4.c\n+\n+cshift1_16_i8.lo: $(srcdir)/generated/cshift1_16_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_i8.lo -MD -MP -MF $(DEPDIR)/cshift1_16_i8.Tpo -c -o cshift1_16_i8.lo `test -f '$(srcdir)/generated/cshift1_16_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_i8.Tpo $(DEPDIR)/cshift1_16_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_i8.c' object='cshift1_16_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_i8.lo `test -f '$(srcdir)/generated/cshift1_16_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i8.c\n+\n+cshift1_16_i16.lo: $(srcdir)/generated/cshift1_16_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_i16.lo -MD -MP -MF $(DEPDIR)/cshift1_16_i16.Tpo -c -o cshift1_16_i16.lo `test -f '$(srcdir)/generated/cshift1_16_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_i16.Tpo $(DEPDIR)/cshift1_16_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_i16.c' object='cshift1_16_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_i16.lo `test -f '$(srcdir)/generated/cshift1_16_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_i16.c\n+\n+cshift1_16_r4.lo: $(srcdir)/generated/cshift1_16_r4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_r4.lo -MD -MP -MF $(DEPDIR)/cshift1_16_r4.Tpo -c -o cshift1_16_r4.lo `test -f '$(srcdir)/generated/cshift1_16_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_r4.Tpo $(DEPDIR)/cshift1_16_r4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_r4.c' object='cshift1_16_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_r4.lo `test -f '$(srcdir)/generated/cshift1_16_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r4.c\n+\n+cshift1_16_r8.lo: $(srcdir)/generated/cshift1_16_r8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_r8.lo -MD -MP -MF $(DEPDIR)/cshift1_16_r8.Tpo -c -o cshift1_16_r8.lo `test -f '$(srcdir)/generated/cshift1_16_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_r8.Tpo $(DEPDIR)/cshift1_16_r8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_r8.c' object='cshift1_16_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_r8.lo `test -f '$(srcdir)/generated/cshift1_16_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r8.c\n+\n+cshift1_16_r10.lo: $(srcdir)/generated/cshift1_16_r10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_r10.lo -MD -MP -MF $(DEPDIR)/cshift1_16_r10.Tpo -c -o cshift1_16_r10.lo `test -f '$(srcdir)/generated/cshift1_16_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_r10.Tpo $(DEPDIR)/cshift1_16_r10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_r10.c' object='cshift1_16_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_r10.lo `test -f '$(srcdir)/generated/cshift1_16_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r10.c\n+\n+cshift1_16_r16.lo: $(srcdir)/generated/cshift1_16_r16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_r16.lo -MD -MP -MF $(DEPDIR)/cshift1_16_r16.Tpo -c -o cshift1_16_r16.lo `test -f '$(srcdir)/generated/cshift1_16_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_r16.Tpo $(DEPDIR)/cshift1_16_r16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_r16.c' object='cshift1_16_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_r16.lo `test -f '$(srcdir)/generated/cshift1_16_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_r16.c\n+\n+cshift1_16_c4.lo: $(srcdir)/generated/cshift1_16_c4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_c4.lo -MD -MP -MF $(DEPDIR)/cshift1_16_c4.Tpo -c -o cshift1_16_c4.lo `test -f '$(srcdir)/generated/cshift1_16_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_c4.Tpo $(DEPDIR)/cshift1_16_c4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_c4.c' object='cshift1_16_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_c4.lo `test -f '$(srcdir)/generated/cshift1_16_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c4.c\n+\n+cshift1_16_c8.lo: $(srcdir)/generated/cshift1_16_c8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_c8.lo -MD -MP -MF $(DEPDIR)/cshift1_16_c8.Tpo -c -o cshift1_16_c8.lo `test -f '$(srcdir)/generated/cshift1_16_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_c8.Tpo $(DEPDIR)/cshift1_16_c8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_c8.c' object='cshift1_16_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_c8.lo `test -f '$(srcdir)/generated/cshift1_16_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c8.c\n+\n+cshift1_16_c10.lo: $(srcdir)/generated/cshift1_16_c10.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_c10.lo -MD -MP -MF $(DEPDIR)/cshift1_16_c10.Tpo -c -o cshift1_16_c10.lo `test -f '$(srcdir)/generated/cshift1_16_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c10.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_c10.Tpo $(DEPDIR)/cshift1_16_c10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_c10.c' object='cshift1_16_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_c10.lo `test -f '$(srcdir)/generated/cshift1_16_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c10.c\n+\n+cshift1_16_c16.lo: $(srcdir)/generated/cshift1_16_c16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift1_16_c16.lo -MD -MP -MF $(DEPDIR)/cshift1_16_c16.Tpo -c -o cshift1_16_c16.lo `test -f '$(srcdir)/generated/cshift1_16_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cshift1_16_c16.Tpo $(DEPDIR)/cshift1_16_c16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift1_16_c16.c' object='cshift1_16_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift1_16_c16.lo `test -f '$(srcdir)/generated/cshift1_16_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift1_16_c16.c\n+\n size_from_kind.lo: io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT size_from_kind.lo -MD -MP -MF $(DEPDIR)/size_from_kind.Tpo -c -o size_from_kind.lo `test -f 'io/size_from_kind.c' || echo '$(srcdir)/'`io/size_from_kind.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/size_from_kind.Tpo $(DEPDIR)/size_from_kind.Plo\n@@ -5824,6 +6191,9 @@ fpu-target.inc: fpu-target.h $(srcdir)/libgfortran.h\n @MAINTAINER_MODE_TRUE@$(i_cshift1_c): m4/cshift1.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift1.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_cshift1a_c): m4/cshift1a.m4 $(I_M$_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift1a.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(in_pack_c): m4/in_pack.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 in_pack.m4 > $@\n "}, {"sha": "eb7a83be4184628871dde7d3bd363ba2c049c58b", "filename": "libgfortran/generated/cshift1_16.c", "status": "modified", "additions": 124, "deletions": 12, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -61,12 +61,13 @@ cshift1 (gfc_array_char * const restrict ret,\n   GFC_INTEGER_16 sh;\n   index_type arraysize;\n   index_type size;\n-\n+  index_type type_size;\n+  \n   if (pwhich)\n     which = *pwhich - 1;\n   else\n     which = 0;\n-\n+ \n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n@@ -111,6 +112,98 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (arraysize == 0)\n     return;\n \n+  /* See if we should dispatch to a helper function.  */\n+\n+  type_size = GFC_DTYPE_TYPE_SIZE (array);\n+\n+  switch (type_size)\n+  {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+    case GFC_DTYPE_DERIVED_1:\n+      cshift1_16_i1 ((gfc_array_i1 *)ret, (gfc_array_i1 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      cshift1_16_i2 ((gfc_array_i2 *)ret, (gfc_array_i2 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      cshift1_16_i4 ((gfc_array_i4 *)ret, (gfc_array_i4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      cshift1_16_i8 ((gfc_array_i8 *)ret, (gfc_array_i8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_INTEGER_16)\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      cshift1_16_i16 ((gfc_array_i16 *)ret, (gfc_array_i16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_REAL_4:\n+      cshift1_16_r4 ((gfc_array_r4 *)ret, (gfc_array_r4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      cshift1_16_r8 ((gfc_array_r8 *)ret, (gfc_array_r8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_REAL_10)\n+    case GFC_DTYPE_REAL_10:\n+      cshift1_16_r10 ((gfc_array_r10 *)ret, (gfc_array_r10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_REAL_16)\n+    case GFC_DTYPE_REAL_16:\n+      cshift1_16_r16 ((gfc_array_r16 *)ret, (gfc_array_r16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      cshift1_16_c4 ((gfc_array_c4 *)ret, (gfc_array_c4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      cshift1_16_c8 ((gfc_array_c8 *)ret, (gfc_array_c8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_COMPLEX_10)\n+    case GFC_DTYPE_COMPLEX_10:\n+      cshift1_16_c10 ((gfc_array_c10 *)ret, (gfc_array_c10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_COMPLEX_16)\n+    case GFC_DTYPE_COMPLEX_16:\n+      cshift1_16_c16 ((gfc_array_c16 *)ret, (gfc_array_c16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    default:\n+      break;\n+    \n+  }\n+  \n   extent[0] = 1;\n   count[0] = 0;\n   n = 0;\n@@ -162,22 +255,41 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       /* Do the shift for this dimension.  */\n       sh = *hptr;\n-      sh = (div (sh, len)).rem;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n       if (sh < 0)\n         sh += len;\n+      if (unlikely (sh >= len || sh < 0))\n+        {\n+\t  sh = sh % len;\n+\t  if (sh < 0)\n+\t    sh += len;\n+\t}\n \n       src = &sptr[sh * soffset];\n       dest = rptr;\n-\n-      for (n = 0; n < len; n++)\n+      if (soffset == size && roffset == size)\n+      {\n+        size_t len1 = sh * size;\n+\tsize_t len2 = (len - sh) * size;\n+\tmemcpy (rptr, sptr + len1, len2);\n+\tmemcpy (rptr + len2, sptr, len1);\n+      }\n+      else\n         {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          if (n == len - sh - 1)\n-            src = sptr;\n-          else\n-            src += soffset;\n-        }\n+\t  for (n = 0; n < len - sh; n++)\n+            {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t    for (src = sptr, n = 0; n < sh; n++)\n+\t      {\n+\t\tmemcpy (dest, src, size);\n+\t\tdest += roffset;\n+\t\tsrc += soffset;\n+\t      }\n+\t  }\n \n       /* Advance to the next section.  */\n       rptr += rstride0;"}, {"sha": "1dfe807310c4c17f8eaad349179dde9a7657ffe2", "filename": "libgfortran/generated/cshift1_16_c10.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_c10.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_10) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_c10 (gfc_array_c10 * const restrict ret,\n+\t\tconst gfc_array_c10 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_10 *rptr;\n+  GFC_COMPLEX_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_10 *sptr;\n+  const GFC_COMPLEX_10 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_10);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_10);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "8e7fa051600f377648d28f2268abf4aad5788a74", "filename": "libgfortran/generated/cshift1_16_c16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_c16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_c16 (gfc_array_c16 * const restrict ret,\n+\t\tconst gfc_array_c16 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_16 *rptr;\n+  GFC_COMPLEX_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_16 *sptr;\n+  const GFC_COMPLEX_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "a8582946c6bd68a397f431f8669fa32f86826af9", "filename": "libgfortran/generated/cshift1_16_c4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_c4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_c4 (gfc_array_c4 * const restrict ret,\n+\t\tconst gfc_array_c4 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_4 *rptr;\n+  GFC_COMPLEX_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_4 *sptr;\n+  const GFC_COMPLEX_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "c2d0c96c2c20ec318702ddb1f2cfe23c49b8fd9d", "filename": "libgfortran/generated/cshift1_16_c8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_c8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_c8 (gfc_array_c8 * const restrict ret,\n+\t\tconst gfc_array_c8 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_8 *rptr;\n+  GFC_COMPLEX_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_8 *sptr;\n+  const GFC_COMPLEX_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "575da16c26097270d85fe35e1998f2d35a603dcd", "filename": "libgfortran/generated/cshift1_16_i1.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_i1.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_i1 (gfc_array_i1 * const restrict ret,\n+\t\tconst gfc_array_i1 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_1 *rptr;\n+  GFC_INTEGER_1 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_1 *sptr;\n+  const GFC_INTEGER_1 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_1);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_1);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "24b556e2a5e8cdff982ee7c60d214f899e7bc280", "filename": "libgfortran/generated/cshift1_16_i16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_i16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_i16 (gfc_array_i16 * const restrict ret,\n+\t\tconst gfc_array_i16 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_16 *rptr;\n+  GFC_INTEGER_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_16 *sptr;\n+  const GFC_INTEGER_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "2f6d6b4ba6d4c1e07473ef1254b88ab7a802cea5", "filename": "libgfortran/generated/cshift1_16_i2.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_i2.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_i2 (gfc_array_i2 * const restrict ret,\n+\t\tconst gfc_array_i2 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_2 *rptr;\n+  GFC_INTEGER_2 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_2 *sptr;\n+  const GFC_INTEGER_2 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_2);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_2);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "cec3912fd8d4ebc451ba06b29e82d1fe65fbfcbe", "filename": "libgfortran/generated/cshift1_16_i4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_i4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_i4 (gfc_array_i4 * const restrict ret,\n+\t\tconst gfc_array_i4 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_4 *rptr;\n+  GFC_INTEGER_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_4 *sptr;\n+  const GFC_INTEGER_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "b05cf571d3eb17ef1a3ebd79adac6c2ee3d57cfe", "filename": "libgfortran/generated/cshift1_16_i8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_i8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_i8 (gfc_array_i8 * const restrict ret,\n+\t\tconst gfc_array_i8 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_8 *rptr;\n+  GFC_INTEGER_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_8 *sptr;\n+  const GFC_INTEGER_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "19f2ae517deb98efde2a42cc77561a752573bd78", "filename": "libgfortran/generated/cshift1_16_r10.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_r10.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_r10 (gfc_array_r10 * const restrict ret,\n+\t\tconst gfc_array_r10 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_10 *rptr;\n+  GFC_REAL_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_10 *sptr;\n+  const GFC_REAL_10 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_10);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_10);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "1437f5e6a223026b2b0ef43906f37af92e634f23", "filename": "libgfortran/generated/cshift1_16_r16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_r16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_r16 (gfc_array_r16 * const restrict ret,\n+\t\tconst gfc_array_r16 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_16 *rptr;\n+  GFC_REAL_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_16 *sptr;\n+  const GFC_REAL_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "24febca34c62a91700c1a6ce8e65d0ad64952e2c", "filename": "libgfortran/generated/cshift1_16_r4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_r4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_r4 (gfc_array_r4 * const restrict ret,\n+\t\tconst gfc_array_r4 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_4 *rptr;\n+  GFC_REAL_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_4 *sptr;\n+  const GFC_REAL_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "ad0ec5ee27c07fe4194a7460a470ce0cb82cadde", "filename": "libgfortran/generated/cshift1_16_r8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_r8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_r8 (gfc_array_r8 * const restrict ret,\n+\t\tconst gfc_array_r8 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_8 *rptr;\n+  GFC_REAL_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_8 *sptr;\n+  const GFC_REAL_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "b753f236173e5f1cb5598e629e6ae9c11122e004", "filename": "libgfortran/generated/cshift1_4.c", "status": "modified", "additions": 124, "deletions": 12, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -61,12 +61,13 @@ cshift1 (gfc_array_char * const restrict ret,\n   GFC_INTEGER_4 sh;\n   index_type arraysize;\n   index_type size;\n-\n+  index_type type_size;\n+  \n   if (pwhich)\n     which = *pwhich - 1;\n   else\n     which = 0;\n-\n+ \n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n@@ -111,6 +112,98 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (arraysize == 0)\n     return;\n \n+  /* See if we should dispatch to a helper function.  */\n+\n+  type_size = GFC_DTYPE_TYPE_SIZE (array);\n+\n+  switch (type_size)\n+  {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+    case GFC_DTYPE_DERIVED_1:\n+      cshift1_4_i1 ((gfc_array_i1 *)ret, (gfc_array_i1 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      cshift1_4_i2 ((gfc_array_i2 *)ret, (gfc_array_i2 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      cshift1_4_i4 ((gfc_array_i4 *)ret, (gfc_array_i4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      cshift1_4_i8 ((gfc_array_i8 *)ret, (gfc_array_i8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_INTEGER_16)\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      cshift1_4_i16 ((gfc_array_i16 *)ret, (gfc_array_i16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_REAL_4:\n+      cshift1_4_r4 ((gfc_array_r4 *)ret, (gfc_array_r4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      cshift1_4_r8 ((gfc_array_r8 *)ret, (gfc_array_r8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_REAL_10)\n+    case GFC_DTYPE_REAL_10:\n+      cshift1_4_r10 ((gfc_array_r10 *)ret, (gfc_array_r10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_REAL_16)\n+    case GFC_DTYPE_REAL_16:\n+      cshift1_4_r16 ((gfc_array_r16 *)ret, (gfc_array_r16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      cshift1_4_c4 ((gfc_array_c4 *)ret, (gfc_array_c4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      cshift1_4_c8 ((gfc_array_c8 *)ret, (gfc_array_c8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_COMPLEX_10)\n+    case GFC_DTYPE_COMPLEX_10:\n+      cshift1_4_c10 ((gfc_array_c10 *)ret, (gfc_array_c10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_COMPLEX_16)\n+    case GFC_DTYPE_COMPLEX_16:\n+      cshift1_4_c16 ((gfc_array_c16 *)ret, (gfc_array_c16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    default:\n+      break;\n+    \n+  }\n+  \n   extent[0] = 1;\n   count[0] = 0;\n   n = 0;\n@@ -162,22 +255,41 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       /* Do the shift for this dimension.  */\n       sh = *hptr;\n-      sh = (div (sh, len)).rem;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n       if (sh < 0)\n         sh += len;\n+      if (unlikely (sh >= len || sh < 0))\n+        {\n+\t  sh = sh % len;\n+\t  if (sh < 0)\n+\t    sh += len;\n+\t}\n \n       src = &sptr[sh * soffset];\n       dest = rptr;\n-\n-      for (n = 0; n < len; n++)\n+      if (soffset == size && roffset == size)\n+      {\n+        size_t len1 = sh * size;\n+\tsize_t len2 = (len - sh) * size;\n+\tmemcpy (rptr, sptr + len1, len2);\n+\tmemcpy (rptr + len2, sptr, len1);\n+      }\n+      else\n         {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          if (n == len - sh - 1)\n-            src = sptr;\n-          else\n-            src += soffset;\n-        }\n+\t  for (n = 0; n < len - sh; n++)\n+            {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t    for (src = sptr, n = 0; n < sh; n++)\n+\t      {\n+\t\tmemcpy (dest, src, size);\n+\t\tdest += roffset;\n+\t\tsrc += soffset;\n+\t      }\n+\t  }\n \n       /* Advance to the next section.  */\n       rptr += rstride0;"}, {"sha": "e3cebef8dd1e4c32fbc7703a8b592d95b136abd3", "filename": "libgfortran/generated/cshift1_4_c10.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_c10.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_10) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_c10 (gfc_array_c10 * const restrict ret,\n+\t\tconst gfc_array_c10 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_10 *rptr;\n+  GFC_COMPLEX_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_10 *sptr;\n+  const GFC_COMPLEX_10 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_10);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_10);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "d57ae9713b38ba6f1211fbb0d6c7ee32d8d616a7", "filename": "libgfortran/generated/cshift1_4_c16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_c16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_c16 (gfc_array_c16 * const restrict ret,\n+\t\tconst gfc_array_c16 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_16 *rptr;\n+  GFC_COMPLEX_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_16 *sptr;\n+  const GFC_COMPLEX_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "c456f315ff38fd2a4e3824f637b330131ed6e6a3", "filename": "libgfortran/generated/cshift1_4_c4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_c4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_c4 (gfc_array_c4 * const restrict ret,\n+\t\tconst gfc_array_c4 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_4 *rptr;\n+  GFC_COMPLEX_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_4 *sptr;\n+  const GFC_COMPLEX_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "767db2893dd1f3a1c5e058ebf02d9c5a5dabc064", "filename": "libgfortran/generated/cshift1_4_c8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_c8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_8) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_c8 (gfc_array_c8 * const restrict ret,\n+\t\tconst gfc_array_c8 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_8 *rptr;\n+  GFC_COMPLEX_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_8 *sptr;\n+  const GFC_COMPLEX_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "49961d4f9355141a438987ba784719403cc2f951", "filename": "libgfortran/generated/cshift1_4_i1.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_i1.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_i1 (gfc_array_i1 * const restrict ret,\n+\t\tconst gfc_array_i1 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_1 *rptr;\n+  GFC_INTEGER_1 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_1 *sptr;\n+  const GFC_INTEGER_1 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_1);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_1);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "5dd277c1494b15c3add9a06f50021e692be0ea4a", "filename": "libgfortran/generated/cshift1_4_i16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_i16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_i16 (gfc_array_i16 * const restrict ret,\n+\t\tconst gfc_array_i16 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_16 *rptr;\n+  GFC_INTEGER_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_16 *sptr;\n+  const GFC_INTEGER_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "0638f1516768fa97475fce5860a453d4048b13f0", "filename": "libgfortran/generated/cshift1_4_i2.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_i2.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_i2 (gfc_array_i2 * const restrict ret,\n+\t\tconst gfc_array_i2 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_2 *rptr;\n+  GFC_INTEGER_2 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_2 *sptr;\n+  const GFC_INTEGER_2 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_2);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_2);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "acc0db419450d91631c933a0bc950a9a4e745201", "filename": "libgfortran/generated/cshift1_4_i4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_i4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_i4 (gfc_array_i4 * const restrict ret,\n+\t\tconst gfc_array_i4 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_4 *rptr;\n+  GFC_INTEGER_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_4 *sptr;\n+  const GFC_INTEGER_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "38db5781ad2c59cc12c41579033640682d17fb37", "filename": "libgfortran/generated/cshift1_4_i8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_i8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_i8 (gfc_array_i8 * const restrict ret,\n+\t\tconst gfc_array_i8 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_8 *rptr;\n+  GFC_INTEGER_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_8 *sptr;\n+  const GFC_INTEGER_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "603e1e988b236485d2e5ae7e02f035d007f4072a", "filename": "libgfortran/generated/cshift1_4_r10.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_r10.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_r10 (gfc_array_r10 * const restrict ret,\n+\t\tconst gfc_array_r10 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_10 *rptr;\n+  GFC_REAL_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_10 *sptr;\n+  const GFC_REAL_10 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_10);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_10);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "a1a30cec84f7c53cc00518440846571ed9cade94", "filename": "libgfortran/generated/cshift1_4_r16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_r16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_r16 (gfc_array_r16 * const restrict ret,\n+\t\tconst gfc_array_r16 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_16 *rptr;\n+  GFC_REAL_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_16 *sptr;\n+  const GFC_REAL_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "f6feb219beaa4847d14ca25d118e7d121d9a002e", "filename": "libgfortran/generated/cshift1_4_r4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_r4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_r4 (gfc_array_r4 * const restrict ret,\n+\t\tconst gfc_array_r4 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_4 *rptr;\n+  GFC_REAL_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_4 *sptr;\n+  const GFC_REAL_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "126966a9a7d81c2aba8ea5149606d3ae01628174", "filename": "libgfortran/generated/cshift1_4_r8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_r8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_r8 (gfc_array_r8 * const restrict ret,\n+\t\tconst gfc_array_r8 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_8 *rptr;\n+  GFC_REAL_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_8 *sptr;\n+  const GFC_REAL_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "1acfd3895aea6999c9554bf18bfb57f4acdc42cb", "filename": "libgfortran/generated/cshift1_8.c", "status": "modified", "additions": 124, "deletions": 12, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -61,12 +61,13 @@ cshift1 (gfc_array_char * const restrict ret,\n   GFC_INTEGER_8 sh;\n   index_type arraysize;\n   index_type size;\n-\n+  index_type type_size;\n+  \n   if (pwhich)\n     which = *pwhich - 1;\n   else\n     which = 0;\n-\n+ \n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n@@ -111,6 +112,98 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (arraysize == 0)\n     return;\n \n+  /* See if we should dispatch to a helper function.  */\n+\n+  type_size = GFC_DTYPE_TYPE_SIZE (array);\n+\n+  switch (type_size)\n+  {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+    case GFC_DTYPE_DERIVED_1:\n+      cshift1_8_i1 ((gfc_array_i1 *)ret, (gfc_array_i1 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      cshift1_8_i2 ((gfc_array_i2 *)ret, (gfc_array_i2 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      cshift1_8_i4 ((gfc_array_i4 *)ret, (gfc_array_i4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      cshift1_8_i8 ((gfc_array_i8 *)ret, (gfc_array_i8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_INTEGER_16)\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      cshift1_8_i16 ((gfc_array_i16 *)ret, (gfc_array_i16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_REAL_4:\n+      cshift1_8_r4 ((gfc_array_r4 *)ret, (gfc_array_r4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      cshift1_8_r8 ((gfc_array_r8 *)ret, (gfc_array_r8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_REAL_10)\n+    case GFC_DTYPE_REAL_10:\n+      cshift1_8_r10 ((gfc_array_r10 *)ret, (gfc_array_r10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_REAL_16)\n+    case GFC_DTYPE_REAL_16:\n+      cshift1_8_r16 ((gfc_array_r16 *)ret, (gfc_array_r16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      cshift1_8_c4 ((gfc_array_c4 *)ret, (gfc_array_c4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      cshift1_8_c8 ((gfc_array_c8 *)ret, (gfc_array_c8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_COMPLEX_10)\n+    case GFC_DTYPE_COMPLEX_10:\n+      cshift1_8_c10 ((gfc_array_c10 *)ret, (gfc_array_c10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_COMPLEX_16)\n+    case GFC_DTYPE_COMPLEX_16:\n+      cshift1_8_c16 ((gfc_array_c16 *)ret, (gfc_array_c16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    default:\n+      break;\n+    \n+  }\n+  \n   extent[0] = 1;\n   count[0] = 0;\n   n = 0;\n@@ -162,22 +255,41 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       /* Do the shift for this dimension.  */\n       sh = *hptr;\n-      sh = (div (sh, len)).rem;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n       if (sh < 0)\n         sh += len;\n+      if (unlikely (sh >= len || sh < 0))\n+        {\n+\t  sh = sh % len;\n+\t  if (sh < 0)\n+\t    sh += len;\n+\t}\n \n       src = &sptr[sh * soffset];\n       dest = rptr;\n-\n-      for (n = 0; n < len; n++)\n+      if (soffset == size && roffset == size)\n+      {\n+        size_t len1 = sh * size;\n+\tsize_t len2 = (len - sh) * size;\n+\tmemcpy (rptr, sptr + len1, len2);\n+\tmemcpy (rptr + len2, sptr, len1);\n+      }\n+      else\n         {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          if (n == len - sh - 1)\n-            src = sptr;\n-          else\n-            src += soffset;\n-        }\n+\t  for (n = 0; n < len - sh; n++)\n+            {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t    for (src = sptr, n = 0; n < sh; n++)\n+\t      {\n+\t\tmemcpy (dest, src, size);\n+\t\tdest += roffset;\n+\t\tsrc += soffset;\n+\t      }\n+\t  }\n \n       /* Advance to the next section.  */\n       rptr += rstride0;"}, {"sha": "182ad63f175c5d090bbe2525668d1ea5e135694a", "filename": "libgfortran/generated/cshift1_8_c10.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_c10.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_10) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_c10 (gfc_array_c10 * const restrict ret,\n+\t\tconst gfc_array_c10 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_10 *rptr;\n+  GFC_COMPLEX_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_10 *sptr;\n+  const GFC_COMPLEX_10 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_10);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_10);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "7e28785148bccbdd5be357be7ee0564bcebb6c44", "filename": "libgfortran/generated/cshift1_8_c16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_c16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_c16 (gfc_array_c16 * const restrict ret,\n+\t\tconst gfc_array_c16 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_16 *rptr;\n+  GFC_COMPLEX_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_16 *sptr;\n+  const GFC_COMPLEX_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "205025601c26a583fcbfdc8e0589b07a72d9ce23", "filename": "libgfortran/generated/cshift1_8_c4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_c4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_c4 (gfc_array_c4 * const restrict ret,\n+\t\tconst gfc_array_c4 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_4 *rptr;\n+  GFC_COMPLEX_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_4 *sptr;\n+  const GFC_COMPLEX_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "2f5ab1cb022027d8f6af37c570639063bc6e8e00", "filename": "libgfortran/generated/cshift1_8_c8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_c8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_c8 (gfc_array_c8 * const restrict ret,\n+\t\tconst gfc_array_c8 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_8 *rptr;\n+  GFC_COMPLEX_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_8 *sptr;\n+  const GFC_COMPLEX_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "eb84edaccaaf77c730c26e6a8dc6041825072fae", "filename": "libgfortran/generated/cshift1_8_i1.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_i1.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_i1 (gfc_array_i1 * const restrict ret,\n+\t\tconst gfc_array_i1 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_1 *rptr;\n+  GFC_INTEGER_1 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_1 *sptr;\n+  const GFC_INTEGER_1 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_1);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_1);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "bd0762784f9f6dd2fede3c18f76f3f9ea84d2fc9", "filename": "libgfortran/generated/cshift1_8_i16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_i16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_i16 (gfc_array_i16 * const restrict ret,\n+\t\tconst gfc_array_i16 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_16 *rptr;\n+  GFC_INTEGER_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_16 *sptr;\n+  const GFC_INTEGER_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "648d3073caeca2df574cef879990014b84ef3ccd", "filename": "libgfortran/generated/cshift1_8_i2.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_i2.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_i2 (gfc_array_i2 * const restrict ret,\n+\t\tconst gfc_array_i2 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_2 *rptr;\n+  GFC_INTEGER_2 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_2 *sptr;\n+  const GFC_INTEGER_2 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_2);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_2);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "9cfc43182a0826f744e0723084602f658a4983d1", "filename": "libgfortran/generated/cshift1_8_i4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_i4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_i4 (gfc_array_i4 * const restrict ret,\n+\t\tconst gfc_array_i4 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_4 *rptr;\n+  GFC_INTEGER_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_4 *sptr;\n+  const GFC_INTEGER_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "3d737a7a9f079c3ae2eab27f12439c66a7bbcb66", "filename": "libgfortran/generated/cshift1_8_i8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_i8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_i8 (gfc_array_i8 * const restrict ret,\n+\t\tconst gfc_array_i8 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_8 *rptr;\n+  GFC_INTEGER_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_8 *sptr;\n+  const GFC_INTEGER_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_INTEGER_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_INTEGER_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "65e2eb32fcb99d5012fe1f9e5f6cdab10e236ade", "filename": "libgfortran/generated/cshift1_8_r10.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_r10.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_10) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_r10 (gfc_array_r10 * const restrict ret,\n+\t\tconst gfc_array_r10 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_10 *rptr;\n+  GFC_REAL_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_10 *sptr;\n+  const GFC_REAL_10 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_10);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_10);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "97d7f7b0c706d2b5c863baa2f6010d465cf42366", "filename": "libgfortran/generated/cshift1_8_r16.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_r16.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_16) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_r16 (gfc_array_r16 * const restrict ret,\n+\t\tconst gfc_array_r16 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_16 *rptr;\n+  GFC_REAL_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_16 *sptr;\n+  const GFC_REAL_16 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_16);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_16);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "bf2ea5f74e62a7acc2e12225154f080715c4e367", "filename": "libgfortran/generated/cshift1_8_r4.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_r4.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_4) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_r4 (gfc_array_r4 * const restrict ret,\n+\t\tconst gfc_array_r4 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_4 *rptr;\n+  GFC_REAL_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_4 *sptr;\n+  const GFC_REAL_4 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_4);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_4);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "5f3c08baaf7e6dda4522de88781597436c358858", "filename": "libgfortran/generated/cshift1_8_r8.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fgenerated%2Fcshift1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_r8.c?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_r8 (gfc_array_r8 * const restrict ret,\n+\t\tconst gfc_array_r8 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_8 *rptr;\n+  GFC_REAL_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_8 *sptr;\n+  const GFC_REAL_8 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_8);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_8);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "22f412357a7319265ab04304cc27c8f0dcb95cea", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -1418,4 +1418,317 @@ void cshift0_c16 (gfc_array_c16 *, const gfc_array_c16 *, ptrdiff_t, int);\n internal_proto(cshift0_c16);\n #endif\n \n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_1)\n+void cshift1_4_i1 (gfc_array_i1 * const restrict,\n+\tconst gfc_array_i1 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_i1);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_2)\n+void cshift1_4_i2 (gfc_array_i2 * const restrict,\n+\tconst gfc_array_i2 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_i2);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+void cshift1_4_i4 (gfc_array_i4 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_i4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_8)\n+void cshift1_4_i8 (gfc_array_i8 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_i8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_16)\n+void cshift1_4_i16 (gfc_array_i16 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_i16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_1)\n+void cshift1_8_i1 (gfc_array_i1 * const restrict,\n+\tconst gfc_array_i1 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_i1);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_2)\n+void cshift1_8_i2 (gfc_array_i2 * const restrict,\n+\tconst gfc_array_i2 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_i2);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_4)\n+void cshift1_8_i4 (gfc_array_i4 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_i4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+void cshift1_8_i8 (gfc_array_i8 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_i8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_16)\n+void cshift1_8_i16 (gfc_array_i16 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_i16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_1)\n+void cshift1_16_i1 (gfc_array_i1 * const restrict,\n+\tconst gfc_array_i1 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_i1);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_2)\n+void cshift1_16_i2 (gfc_array_i2 * const restrict,\n+\tconst gfc_array_i2 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_i2);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_4)\n+void cshift1_16_i4 (gfc_array_i4 * const restrict,\n+\tconst gfc_array_i4 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_i4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_8)\n+void cshift1_16_i8 (gfc_array_i8 * const restrict,\n+\tconst gfc_array_i8 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_i8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+void cshift1_16_i16 (gfc_array_i16 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst gfc_array_i16 * const restrict,\n+\tconst GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_i16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_REAL_4)\n+void cshift1_4_r4 (gfc_array_r4 * const restrict,\n+        const gfc_array_r4 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_r4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_REAL_8)\n+void cshift1_4_r8 (gfc_array_r8 * const restrict,\n+        const gfc_array_r8 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_r8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_REAL_10)\n+void cshift1_4_r10 (gfc_array_r10 * const restrict,\n+        const gfc_array_r10 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_r10);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_REAL_16)\n+void cshift1_4_r16 (gfc_array_r16 * const restrict,\n+        const gfc_array_r16 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_r16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_REAL_4)\n+void cshift1_8_r4 (gfc_array_r4 * const restrict,\n+        const gfc_array_r4 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_r4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_REAL_8)\n+void cshift1_8_r8 (gfc_array_r8 * const restrict,\n+        const gfc_array_r8 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_r8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_REAL_10)\n+void cshift1_8_r10 (gfc_array_r10 * const restrict,\n+        const gfc_array_r10 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_r10);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_REAL_16)\n+void cshift1_8_r16 (gfc_array_r16 * const restrict,\n+        const gfc_array_r16 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_r16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_REAL_4)\n+void cshift1_16_r4 (gfc_array_r4 * const restrict,\n+        const gfc_array_r4 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_r4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_REAL_8)\n+void cshift1_16_r8 (gfc_array_r8 * const restrict,\n+        const gfc_array_r8 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_r8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_REAL_10)\n+void cshift1_16_r10 (gfc_array_r10 * const restrict,\n+        const gfc_array_r10 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_r10);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_REAL_16)\n+void cshift1_16_r16 (gfc_array_r16 * const restrict,\n+        const gfc_array_r16 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_r16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_COMPLEX_4)\n+void cshift1_4_c4 (gfc_array_c4 * const restrict,\n+        const gfc_array_c4 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_c4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_COMPLEX_8)\n+void cshift1_4_c8 (gfc_array_c8 * const restrict,\n+        const gfc_array_c8 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_c8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_COMPLEX_10)\n+void cshift1_4_c10 (gfc_array_c10 * const restrict,\n+        const gfc_array_c10 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_c10);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_COMPLEX_16)\n+void cshift1_4_c16 (gfc_array_c16 * const restrict,\n+        const gfc_array_c16 * const restrict,\n+        const gfc_array_i4 * const restrict,\n+        const GFC_INTEGER_4 * const restrict);\n+internal_proto(cshift1_4_c16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_COMPLEX_4)\n+void cshift1_8_c4 (gfc_array_c4 * const restrict,\n+        const gfc_array_c4 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_c4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_COMPLEX_8)\n+void cshift1_8_c8 (gfc_array_c8 * const restrict,\n+        const gfc_array_c8 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_c8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_COMPLEX_10)\n+void cshift1_8_c10 (gfc_array_c10 * const restrict,\n+        const gfc_array_c10 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_c10);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_COMPLEX_16)\n+void cshift1_8_c16 (gfc_array_c16 * const restrict,\n+        const gfc_array_c16 * const restrict,\n+        const gfc_array_i8 * const restrict,\n+        const GFC_INTEGER_8 * const restrict);\n+internal_proto(cshift1_8_c16);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_COMPLEX_4)\n+void cshift1_16_c4 (gfc_array_c4 * const restrict,\n+        const gfc_array_c4 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_c4);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_COMPLEX_8)\n+void cshift1_16_c8 (gfc_array_c8 * const restrict,\n+        const gfc_array_c8 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_c8);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_COMPLEX_10)\n+void cshift1_16_c10 (gfc_array_c10 * const restrict,\n+        const gfc_array_c10 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_c10);\n+#endif\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_COMPLEX_16)\n+void cshift1_16_c16 (gfc_array_c16 * const restrict,\n+        const gfc_array_c16 * const restrict,\n+        const gfc_array_i16 * const restrict,\n+        const GFC_INTEGER_16 * const restrict);\n+internal_proto(cshift1_16_c16);\n+#endif\n+\n+\n #endif  /* LIBGFOR_H  */"}, {"sha": "07e8580643c0faa06507b3888b12120be3499809", "filename": "libgfortran/m4/cshift1.m4", "status": "modified", "additions": 124, "deletions": 12, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fm4%2Fcshift1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fm4%2Fcshift1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fcshift1.m4?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -62,12 +62,13 @@ cshift1 (gfc_array_char * const restrict ret,\n   'atype_name` sh;\n   index_type arraysize;\n   index_type size;\n-\n+  index_type type_size;\n+  \n   if (pwhich)\n     which = *pwhich - 1;\n   else\n     which = 0;\n-\n+ \n   if (which < 0 || (which + 1) > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument ''`DIM''` is out of range in call to ''`CSHIFT''`\");\n \n@@ -112,6 +113,98 @@ cshift1 (gfc_array_char * const restrict ret,\n   if (arraysize == 0)\n     return;\n \n+  /* See if we should dispatch to a helper function.  */\n+\n+  type_size = GFC_DTYPE_TYPE_SIZE (array);\n+\n+  switch (type_size)\n+  {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+    case GFC_DTYPE_DERIVED_1:\n+      cshift1_'atype_kind`_i1 ((gfc_array_i1 *)ret, (gfc_array_i1 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      cshift1_'atype_kind`_i2 ((gfc_array_i2 *)ret, (gfc_array_i2 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+ \n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      cshift1_'atype_kind`_i4 ((gfc_array_i4 *)ret, (gfc_array_i4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      cshift1_'atype_kind`_i8 ((gfc_array_i8 *)ret, (gfc_array_i8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_INTEGER_16)\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      cshift1_'atype_kind`_i16 ((gfc_array_i16 *)ret, (gfc_array_i16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_REAL_4:\n+      cshift1_'atype_kind`_r4 ((gfc_array_r4 *)ret, (gfc_array_r4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      cshift1_'atype_kind`_r8 ((gfc_array_r8 *)ret, (gfc_array_r8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_REAL_10)\n+    case GFC_DTYPE_REAL_10:\n+      cshift1_'atype_kind`_r10 ((gfc_array_r10 *)ret, (gfc_array_r10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_REAL_16)\n+    case GFC_DTYPE_REAL_16:\n+      cshift1_'atype_kind`_r16 ((gfc_array_r16 *)ret, (gfc_array_r16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      cshift1_'atype_kind`_c4 ((gfc_array_c4 *)ret, (gfc_array_c4 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      cshift1_'atype_kind`_c8 ((gfc_array_c8 *)ret, (gfc_array_c8 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+\n+#if defined (HAVE_COMPLEX_10)\n+    case GFC_DTYPE_COMPLEX_10:\n+      cshift1_'atype_kind`_c10 ((gfc_array_c10 *)ret, (gfc_array_c10 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+#if defined (HAVE_COMPLEX_16)\n+    case GFC_DTYPE_COMPLEX_16:\n+      cshift1_'atype_kind`_c16 ((gfc_array_c16 *)ret, (gfc_array_c16 *) array,\n+      \t\t\th, pwhich);\n+      return;\n+#endif\n+\n+    default:\n+      break;\n+    \n+  }\n+  \n   extent[0] = 1;\n   count[0] = 0;\n   n = 0;\n@@ -163,22 +256,41 @@ cshift1 (gfc_array_char * const restrict ret,\n     {\n       /* Do the shift for this dimension.  */\n       sh = *hptr;\n-      sh = (div (sh, len)).rem;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n       if (sh < 0)\n         sh += len;\n+      if (unlikely (sh >= len || sh < 0))\n+        {\n+\t  sh = sh % len;\n+\t  if (sh < 0)\n+\t    sh += len;\n+\t}\n \n       src = &sptr[sh * soffset];\n       dest = rptr;\n-\n-      for (n = 0; n < len; n++)\n+      if (soffset == size && roffset == size)\n+      {\n+        size_t len1 = sh * size;\n+\tsize_t len2 = (len - sh) * size;\n+\tmemcpy (rptr, sptr + len1, len2);\n+\tmemcpy (rptr + len2, sptr, len1);\n+      }\n+      else\n         {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          if (n == len - sh - 1)\n-            src = sptr;\n-          else\n-            src += soffset;\n-        }\n+\t  for (n = 0; n < len - sh; n++)\n+            {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t    for (src = sptr, n = 0; n < sh; n++)\n+\t      {\n+\t\tmemcpy (dest, src, size);\n+\t\tdest += roffset;\n+\t\tsrc += soffset;\n+\t      }\n+\t  }\n \n       /* Advance to the next section.  */\n       rptr += rstride0;"}, {"sha": "63d210445061e5102f3e2442551fb2a31d2df241", "filename": "libgfortran/m4/cshift1a.m4", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fm4%2Fcshift1a.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56e3fda6092548f3cd5336d131b412be986b1e6/libgfortran%2Fm4%2Fcshift1a.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fcshift1a.m4?ref=e56e3fda6092548f3cd5336d131b412be986b1e6", "patch": "@@ -0,0 +1,194 @@\n+`/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>'\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)\n+\n+void\n+cshift1'rtype_qual`_'atype_code` ('atype` * const restrict ret,\n+\t\tconst 'atype` * const restrict array,\n+\t\tconst 'rtype` * const restrict h,\n+\t\tconst 'rtype_name` * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  'atype_name` *rptr;\n+  'atype_name` *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const 'atype_name` *sptr;\n+  const 'atype_name` *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const 'rtype_name` *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  'rtype_name` sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof ('atype_name`);\n+\t  size_t len2 = (len - sh) * sizeof ('atype_name`);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif'"}]}