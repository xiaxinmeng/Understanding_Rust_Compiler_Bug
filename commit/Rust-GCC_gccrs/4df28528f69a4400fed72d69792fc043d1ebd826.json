{"sha": "4df28528f69a4400fed72d69792fc043d1ebd826", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmMjg1MjhmNjlhNDQwMGZlZDcyZDY5NzkyZmMwNDNkMWViZDgyNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-04-24T20:44:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-04-24T20:44:45Z"}, "message": "re PR tree-optimization/31602 (Overflow warning causes GDB -Werror build failure)\n\n./:\tPR tree-optimization/31602\n\t* tree-ssa-loop-ch.c (copy_loop_headers): Set TREE_NO_WARNING for\n\tconditionals in the copied loop header.\n\t* tree-cfg.c (fold_cond_expr_cond): Don't issue undefined overflow\n\twarnings if TREE_NO_WARNING is set.\n\t* doc/invoke.texi (Warning Options): Clarify that\n\t-Wstrict-overflow does not warn about loops.\ntestsuite/:\n\tPR tree-optimization/31602\n\t* gcc.dg/Wstrict-overflow-11.c: We no longer issue a warning.\n\nFrom-SVN: r124120", "tree": {"sha": "99bf754860728790f12fd6d1c13768b33b045464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99bf754860728790f12fd6d1c13768b33b045464"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df28528f69a4400fed72d69792fc043d1ebd826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df28528f69a4400fed72d69792fc043d1ebd826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df28528f69a4400fed72d69792fc043d1ebd826", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df28528f69a4400fed72d69792fc043d1ebd826/comments", "author": null, "committer": null, "parents": [{"sha": "7c4a92651592752bb73c2f672f3fa358b6839c1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4a92651592752bb73c2f672f3fa358b6839c1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4a92651592752bb73c2f672f3fa358b6839c1f"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "88718264dcbab2754ab0c27ac2c6851bf3c68440", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4df28528f69a4400fed72d69792fc043d1ebd826", "patch": "@@ -1,3 +1,13 @@\n+2007-04-24  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR tree-optimization/31602\n+\t* tree-ssa-loop-ch.c (copy_loop_headers): Set TREE_NO_WARNING for\n+\tconditionals in the copied loop header.\n+\t* tree-cfg.c (fold_cond_expr_cond): Don't issue undefined overflow\n+\twarnings if TREE_NO_WARNING is set.\n+\t* doc/invoke.texi (Warning Options): Clarify that\n+\t-Wstrict-overflow does not warn about loops.\n+\n 2007-04-24  Janis Johnson  <janis187@us.ibm.com>\n \n \t* config/rs6000/rs6000.c (function_arg_advance): For 32-bit ELF ABI,"}, {"sha": "cea120c1dc0194455900bf3d8f8a585f7dfde514", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4df28528f69a4400fed72d69792fc043d1ebd826", "patch": "@@ -3029,7 +3029,10 @@ perfectly safe if the values of the variables involved are such that\n overflow never does, in fact, occur.  Therefore this warning can\n easily give a false positive: a warning about code which is not\n actually a problem.  To help focus on important issues, several\n-warning levels are defined.\n+warning levels are defined.  No warnings are issued for the use of\n+undefined signed overflow when estimating how many iterations a loop\n+will require, in particular when determining whether a loop will be\n+executed at all.\n \n @table @option\n @item -Wstrict-overflow=1"}, {"sha": "6a69bff59d13e14e454fc01903f85405746e05e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4df28528f69a4400fed72d69792fc043d1ebd826", "patch": "@@ -1,3 +1,8 @@\n+2007-04-24  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR tree-optimization/31602\n+\t* gcc.dg/Wstrict-overflow-11.c: We no longer issue a warning.\n+\n 2007-04-24  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.target/powerpc/ppc32-abi-dfp-1.c: New test."}, {"sha": "3caf1cb6f09fa56d7b9142983d62cd231d2a615c", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-11.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-11.c?ref=4df28528f69a4400fed72d69792fc043d1ebd826", "patch": "@@ -3,14 +3,16 @@\n \n /* Based on strict-overflow-5.c.  */\n \n-/* We can only unroll when using strict overflow semantics.  */\n+/* We can only unroll when using strict overflow semantics.  But we\n+   don't issue a warning for relying on undefined overflow in\n+   loops.  */\n \n int foo (int i)\n {\n   int index;\n   int r=0;\n  \n-  for (index = i; index <= i+4; index+=2) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+  for (index = i; index <= i+4; index+=2)\n     r++;\n  \n   return r;"}, {"sha": "a621d9d6b0588b6199ff15468ff5bd8d35e2a43b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4df28528f69a4400fed72d69792fc043d1ebd826", "patch": "@@ -416,7 +416,9 @@ fold_cond_expr_cond (void)\n \t  cond = fold (COND_EXPR_COND (stmt));\n \t  zerop = integer_zerop (cond);\n \t  onep = integer_onep (cond);\n-\t  fold_undefer_overflow_warnings (zerop || onep, stmt,\n+\t  fold_undefer_overflow_warnings (((zerop || onep)\n+\t\t\t\t\t   && !TREE_NO_WARNING (stmt)),\n+\t\t\t\t\t  stmt,\n \t\t\t\t\t  WARN_STRICT_OVERFLOW_CONDITIONAL);\n \t  if (zerop)\n \t    COND_EXPR_COND (stmt) = boolean_false_node;"}, {"sha": "e2e272b2266f2441054cca69aa5157ebdc0bb9ce", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df28528f69a4400fed72d69792fc043d1ebd826/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=4df28528f69a4400fed72d69792fc043d1ebd826", "patch": "@@ -1,5 +1,5 @@\n /* Loop header copying on trees.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -200,6 +200,27 @@ copy_loop_headers (void)\n \t  continue;\n \t}\n \n+      /* If the loop has the form \"for (i = j; i < j + 10; i++)\" then\n+\t this copying can introduce a case where we rely on undefined\n+\t signed overflow to eliminate the preheader condition, because\n+\t we assume that \"j < j + 10\" is true.  We don't want to warn\n+\t about that case for -Wstrict-overflow, because in general we\n+\t don't warn about overflow involving loops.  Prevent the\n+\t warning by setting TREE_NO_WARNING.  */\n+      if (warn_strict_overflow > 0)\n+\t{\n+\t  unsigned int i;\n+\n+\t  for (i = 0; i < n_bbs; ++i)\n+\t    {\n+\t      tree last;\n+\n+\t      last = last_stmt (copied_bbs[i]);\n+\t      if (TREE_CODE (last) == COND_EXPR)\n+\t\tTREE_NO_WARNING (last) = 1;\n+\t    }\n+\t}\n+\n       /* Ensure that the latch and the preheader is simple (we know that they\n \t are not now, since there was the loop exit condition.  */\n       split_edge (loop_preheader_edge (loop));"}]}