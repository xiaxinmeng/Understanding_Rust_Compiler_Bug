{"sha": "c93d7fae7b9825449c023d42eb40641c0ad80be2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkzZDdmYWU3Yjk4MjU0NDljMDIzZDQyZWI0MDY0MWMwYWQ4MGJlMg==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-05-22T06:47:48Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-05-22T06:47:48Z"}, "message": "Implement invocation interface; don't create new thread for main.\n\nFrom-SVN: r42428", "tree": {"sha": "ecfc0fb5d915f5f6596ef061114d1b6b7ec5270a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecfc0fb5d915f5f6596ef061114d1b6b7ec5270a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c93d7fae7b9825449c023d42eb40641c0ad80be2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93d7fae7b9825449c023d42eb40641c0ad80be2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93d7fae7b9825449c023d42eb40641c0ad80be2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93d7fae7b9825449c023d42eb40641c0ad80be2/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb"}], "stats": {"total": 2428, "additions": 472, "deletions": 1956}, "files": [{"sha": "20adc2aaf6bf631b1f4ae942900bc41a35bac915", "filename": "libjava/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -1,3 +1,46 @@\n+2001-05-21  Per Bothner  <per@bothner.com>\n+\n+\tImplement invocation interface; don't create new thread for main.\n+\t* java/lang/Thread.java (gen_name):  Make native.\n+\t(<init>(Thread,THreadGroup,Runnable,String)):  New private\n+\tconstructor, used by other constructors, and _Jv_AttachCurrentThread.\n+\t* java/lang/natThread.cc (gen_name):  New implementation.\n+\t(_Jv_AttachCurrentThread, _Jv_DetachCurrentThread):  New.\n+\t* prims.cc (main_init):  Removed, replaced by _Jv_CreateJavaVM.\n+\t(_Jv_CreateJavaVM):  New runtime initialization procedure.\n+\t(runFirst):  New proecdure - mostly code from old FirstThread::run.\n+\t(JvRunMain, _Jv_RunMain):  Re-write to use new invocation code.\n+\t* gcj/cni.h (JvCreateJavaVM, JvAttachCurrentThread,\n+\tJvDetachCurrentThread):  New inline wrappers.\n+\t* gcj/javaprims.h (_Jv_CreateJavaVM, _Jv_AttachCurrentThread,\n+\t_Jv_DetachCurrentThread):  New declarations.\n+\t* gnu/gcj/runtime/FirstThread.java:  Gutted.  Now contains only ...\n+\t(getMain): new static method.\n+\t* gnu/gcj/runtime/natFirstThread.cc:  Removed;  run method replaced\n+\tby runFirst in prims.cc.\n+\t(java/lang/Thread.h):  Update for new invocation interface.\n+\t* include/posix-threads.h (_Jv_ThreadRegister,\n+\t_Jv_ThreadUnRegister):  New declarations.\n+\t* posix-threads.cc (_Jv_ThreadRegister, _Jv_ThreadUnRegister):  New.\n+\t(really_start):  Use new _Jv_ThreadRegister.\n+\t* include/no-threads.h (_Jv_ThreadInitData):  No longer inline.\n+\t(_Jv_ThreadRegister, _Jv_ThreadUnRegister):  New empty inlines.\n+\t* no-threads.cc (_Jv_ThreadInitData):  Set _Jv_OnlyThread here.\n+\tComplain of called when _Jv_OnlyThread already set.\n+\t(_Jv_ThreadStart):  Always JvFail.\n+\t* include/win32-threads.h  (_Jv_Thread_t):  New thread_obj field.\n+\t(_Jv_ThreadRegister, _Jv_ThreadUnRegister):  New declarations.\n+\t* win32-threads.cc (struct starter):  Remove objet field -\n+\twe use _Jv_Thread_t's new thread_obj field instead.\n+\t(_Jv_ThreadInitData):  Set _Jv_Thread_t's thread_obj field.\n+\t(_Jv_ThreadRegister, _Jv_ThreadUnRegister):  New.\n+\t(really_start):  Use new _Jv_ThreadRegister.\n+\t* jni.cc (_Jv_JNI_AttachCurrentThread):  Use _Jv_AttachCurrentThread.\n+\t(_Jv_JNI_DetachCurrentThread):  Use _Jv_DetachCurrentThread.\n+\t* gnu/gcj/jni/NativeThread.java, gnu/gcj/jni/natNativeThread.cc:\n+\tRemoved - no longer needed with new invocation interface.\n+\t* Makefile.am:  Update for removed/added files.\n+\n 2001-05-21  Per Bothner  <per@bothner.com>\n \n \t* Makefile.am (libgcj_la_DEPENDENCIES):  Add $(nat_files)."}, {"sha": "7c1ba9839f75f382d2dd5b12a15bfe73336897cf", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -303,12 +303,12 @@ gnu/gcj/runtime/FirstThread.h: gnu/gcj/runtime/FirstThread.class libgcj.jar\n java/lang/Thread.h: java/lang/Thread.class libgcj.jar\n \t$(GCJH) -classpath $(top_builddir) \\\n \t\t-prepend 'class _Jv_JNIEnv;' \\\n-\t\t-prepend 'extern \"Java\" { namespace gnu { namespace gcj { namespace jni { class NativeThread; } } } };' \\\n \t\t-prepend '#define _JV_NOT_OWNER 1' \\\n \t\t-prepend '#define _JV_INTERRUPTED 2' \\\n \t\t-friend '_Jv_JNIEnv * _Jv_GetCurrentJNIEnv ();' \\\n \t\t-friend 'void _Jv_SetCurrentJNIEnv (_Jv_JNIEnv *env);' \\\n-\t\t-friend 'class gnu::gcj::jni::NativeThread;' \\\n+\t\t-friend 'java::lang::Thread* _Jv_AttachCurrentThread(jstring name, java::lang::ThreadGroup* group);' \\\n+\t\t-friend 'jint _Jv_DetachCurrentThread ();' \\\n \t\t$(basename $<)\n \n java/lang/String.h: java/lang/String.class libgcj.jar\n@@ -1008,7 +1008,6 @@ gnu/gcj/RawData.java \\\n gnu/gcj/io/DefaultMimeTypes.java \\\n gnu/gcj/io/MimeTypes.java \\\n gnu/gcj/io/SimpleSHSStream.java\t\\\n-gnu/gcj/jni/NativeThread.java \\\n gnu/gcj/math/MPN.java \\\n gnu/gcj/protocol/file/Connection.java \\\n gnu/gcj/protocol/file/Handler.java \\\n@@ -1308,8 +1307,6 @@ gnu/gcj/convert/natOutput_EUCJIS.cc \\\n gnu/gcj/convert/natOutput_SJIS.cc \\\n gnu/gcj/io/natSimpleSHSStream.cc \\\n gnu/gcj/io/shs.cc \\\n-gnu/gcj/jni/natNativeThread.cc \\\n-gnu/gcj/runtime/natFirstThread.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/io/natObjectInputStream.cc \\"}, {"sha": "ea1bbfdbc4c5b798be17c6bedb0ee389ec2e3550", "filename": "libjava/Makefile.in", "status": "modified", "additions": 63, "deletions": 1562, "changes": 1625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2"}, {"sha": "0df9a7bbacbde6491aef189a5fbf666ae8b95772", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -73,6 +73,7 @@ CXXCPP = @CXXCPP@\n DIRLTDL = @DIRLTDL@\n DIVIDESPEC = @DIVIDESPEC@\n DLLTOOL = @DLLTOOL@\n+EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n GCC_UNWIND_INCLUDE = @GCC_UNWIND_INCLUDE@\n GCDEPS = @GCDEPS@\n@@ -202,7 +203,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "b1254a2e191d4f8fb54fee7a1b66c5b3d8b5de0c", "filename": "libjava/gcj/cni.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgcj%2Fcni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgcj%2Fcni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fcni.h?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -118,4 +118,22 @@ JvFree (void *ptr)\n {\n   return _Jv_Free (ptr);\n }\n+\n+extern inline jint\n+JvCreateJavaVM (void* vm_args)\n+{\n+  return _Jv_CreateJavaVM (vm_args);\n+}\n+\n+extern inline java::lang::Thread*\n+JvAttachCurrentThread (jstring name, java::lang::ThreadGroup* group)\n+{\n+  return _Jv_AttachCurrentThread (name, group);\n+}\n+\n+extern inline jint\n+JvDetachCurrentThread (void)\n+{\n+  return _Jv_DetachCurrentThread ();\n+}\n #endif /* __GCJ_CNI_H__ */"}, {"sha": "71558daee27e4c565b1ebb22c83aff0cdcbe0f08", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -380,6 +380,11 @@ extern \"C\" jstring _Jv_NewStringLatin1(const char*, jsize)\n extern \"C\" jsize _Jv_GetStringUTFLength (jstring);\n extern \"C\" jsize _Jv_GetStringUTFRegion (jstring, jsize, jsize, char *);\n \n+extern jint _Jv_CreateJavaVM (void* /*vm_args*/);\n+extern \"C\" java::lang::Thread*\n+_Jv_AttachCurrentThread(jstring name, java::lang::ThreadGroup* group);\n+extern \"C\" jint _Jv_DetachCurrentThread (void);\n+\n extern \"C\" void _Jv_Throw (jthrowable) __attribute__ ((__noreturn__));\n extern \"C\" void* _Jv_Malloc (jsize) __attribute__((__malloc__));\n extern \"C\" void* _Jv_Realloc (void *, jsize);"}, {"sha": "4d3eb78ac74a5f243bbccfe29353b1edb40f2d5e", "filename": "libjava/gnu/gcj/jni/NativeThread.java", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb/libjava%2Fgnu%2Fgcj%2Fjni%2FNativeThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb/libjava%2Fgnu%2Fgcj%2Fjni%2FNativeThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fjni%2FNativeThread.java?ref=b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb", "patch": "@@ -1,29 +0,0 @@\n-// NativeThread.java - Wrapper for attached user threads.\n-\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.jni;\n-\n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date February 9, 2000\n- */\n-\n-public class NativeThread extends Thread\n-{\n-  public NativeThread (ThreadGroup g, String name)\n-  {\n-    super (g, null, name);\n-    init ();\n-  }\n-\n-  // Call this to mark the thread as finished.\n-  public native void finish ();\n-  public native void init ();\n-}"}, {"sha": "359b572ca539efaecc70299d7d4e903755d2c28d", "filename": "libjava/gnu/gcj/jni/natNativeThread.cc", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb/libjava%2Fgnu%2Fgcj%2Fjni%2FnatNativeThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb/libjava%2Fgnu%2Fgcj%2Fjni%2FnatNativeThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fjni%2FnatNativeThread.cc?ref=b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb", "patch": "@@ -1,30 +0,0 @@\n-// natNativeThread.cc - Native side of attached threads.\n-\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-// Written by Tom Tromey <tromey@cygnus.com>\n-\n-#include <config.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <gnu/gcj/jni/NativeThread.h>\n-#include <java/lang/Thread.h>\n-\n-void\n-gnu::gcj::jni::NativeThread::finish ()\n-{\n-  finish_ ();\n-}\n-\n-void\n-gnu::gcj::jni::NativeThread::init ()\n-{\n-  alive_flag = true;\t\t// alive_flag is private in java.lang.Thread\n-}"}, {"sha": "fd59261c8c83b497ab68a65c22089a67c8e79318", "filename": "libjava/gnu/gcj/runtime/FirstThread.java", "status": "modified", "additions": 9, "deletions": 39, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgnu%2Fgcj%2Fruntime%2FFirstThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fgnu%2Fgcj%2Fruntime%2FFirstThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FFirstThread.java?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -19,59 +19,29 @@\n \n // This is entirely internal to our implementation.\n \n-final class FirstThread extends Thread\n+final class FirstThread\n {\n-  public native void run ();\n-\n-  public FirstThread (Class k, Object o)\n-  {\n-    super (null, null, \"main\");\n-    klass = k;\n-    klass_name = null;\n-    args = o;\n-  }\n-\n-  public FirstThread (String class_name, Object o)\n-  {\n-    super (null, null, \"main\");\n-    klass = null;\n-    klass_name = class_name;\n-    args = o;\n-  }\n-\n-  private static void die (String s)\n-  {\n-    System.err.println(s);\n-    System.exit(1);\n-  }\n-\n-  public static void main (String[] args)\n+  public static String getMain (String name)\n   {\n+    String mainName = null;\n     try {\n \n-      JarFile j = new JarFile (args[0]);\n+      JarFile j = new JarFile (name);\n \n       Attributes a = j.getManifest().getMainAttributes();\n \n-      jarMainClassName = a.getValue(Attributes.Name.MAIN_CLASS);\n+      mainName = a.getValue(Attributes.Name.MAIN_CLASS);\n \n-      if (jarMainClassName != null)\n-      {\n-\tjarMainClassName = jarMainClassName.replace('/','.');\n-\treturn;\n-      }\n     } catch (Exception e) {\n       // empty\n     }\n \n-    System.err.println (\"Failed to load Main-Class manifest attribute from\\n\"\n-\t\t\t+ args[0]);\n+    if (mainName == null)\n+      System.err.println (\"Failed to load Main-Class manifest attribute from\\n\"\n+\t\t\t  + name);\n+    return mainName;\n   }\n \n-  // If interpreter is invoked with -jar, the main class name is recorded\n-  // here.\n-  public static String jarMainClassName;\n-\n   // Private data.\n   private Class klass;\n   private String klass_name;"}, {"sha": "c4ba261bdfef9579d5c933b24b797d201d807efd", "filename": "libjava/gnu/gcj/runtime/natFirstThread.cc", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatFirstThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatFirstThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatFirstThread.cc?ref=b4fbaca7cb5c6ff5fb5e24e554d510257cb488eb", "patch": "@@ -1,147 +0,0 @@\n-// natFirstThread.cc - Implementation of FirstThread native methods.\n-\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include <stdlib.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <jni.h>\n-\n-#include <gnu/gcj/runtime/FirstThread.h>\n-#include <java/lang/Class.h>\n-#include <java/lang/String.h>\n-#include <java/lang/System.h>\n-#include <java/lang/reflect/Modifier.h>\n-#include <java/io/PrintStream.h>\n-\n-#ifdef ENABLE_JVMPI\n-#include <jvmpi.h>\n-#include <java/lang/ThreadGroup.h>\n-#include <java/lang/UnsatisfiedLinkError.h>\n-#endif\n-\n-#define DIE(Message)  die (JvNewStringLatin1 (Message))\n-\n-typedef void main_func (jobject);\n-\n-#ifdef WITH_JVMPI\n-extern void (*_Jv_JVMPI_Notify_THREAD_START) (JVMPI_Event *event);\n-#endif\n-\n-/* This will be non-NULL if the user has preloaded a JNI library, or\n-   linked one into the executable.  */\n-extern \"C\" \n-{\n-#pragma weak JNI_OnLoad\n-  extern jint JNI_OnLoad (JavaVM *, void *) __attribute__((weak));\n-}\n-\n-void\n-gnu::gcj::runtime::FirstThread::run (void)\n-{\n-\n-  Utf8Const* main_signature = _Jv_makeUtf8Const (\"([Ljava.lang.String;)V\", 22);\n-  Utf8Const* main_name = _Jv_makeUtf8Const (\"main\", 4);\n-\n-  /* Some systems let you preload shared libraries before running a\n-     program.  Under Linux, this is done by setting the LD_PRELOAD\n-     environment variable.  We take advatage of this here to allow for\n-     dynamically loading a JNI library into a fully linked executable.  */\n-\n-  if (JNI_OnLoad != NULL)\n-    {\n-      JavaVM *vm = _Jv_GetJavaVM ();\n-      if (vm == NULL)\n-\t{\n-\t  // FIXME: what?\n-\t  return;\n-\t}\n-      jint vers = JNI_OnLoad (vm, NULL);\n-      if (vers != JNI_VERSION_1_1 && vers != JNI_VERSION_1_2)\n-\t{\n-\t  // FIXME: unload the library.\n-\t  throw new java::lang::UnsatisfiedLinkError (JvNewStringLatin1 (\"unrecognized version from preloaded JNI_OnLoad\"));\n-\t}\n-    }\n-\n-  if (klass == NULL)\n-    klass = java::lang::Class::forName (klass_name);\n-  if (klass != NULL)\n-    _Jv_InitClass (klass);\n-\n-  _Jv_Method *meth = _Jv_GetMethodLocal (klass, main_name, main_signature);\n-\n-  // Some checks from Java Spec section 12.1.4.\n-  if (meth == NULL)\n-    DIE (\"no suitable method `main' in class\");\n-  if (! java::lang::reflect::Modifier::isStatic(meth->accflags))\n-    DIE (\"`main' must be static\");\n-  if (! java::lang::reflect::Modifier::isPublic(meth->accflags))\n-    DIE (\"`main' must be public\");\n-\n-#ifdef WITH_JVMPI\n-  if (_Jv_JVMPI_Notify_THREAD_START)\n-    {\n-      JVMPI_Event event;\n-\n-      jstring thread_name = getName ();\n-      jstring group_name = NULL, parent_name = NULL;\n-      java::lang::ThreadGroup *group = getThreadGroup ();\n-\n-      if (group)\n-\t{\n-\t  group_name = group->getName ();\n-\t  group = group->getParent ();\n-\n-\t  if (group)\n-\t    parent_name = group->getName ();\n-\t}\n-\n-      int thread_len = thread_name ? JvGetStringUTFLength (thread_name) : 0;\n-      int group_len = group_name ? JvGetStringUTFLength (group_name) : 0;\n-      int parent_len = parent_name ? JvGetStringUTFLength (parent_name) : 0;\n-\n-      char thread_chars[thread_len + 1];\n-      char group_chars[group_len + 1];\n-      char parent_chars[parent_len + 1];\n-\n-      if (thread_name)\n-\tJvGetStringUTFRegion (thread_name, 0, \n-\t\t\t      thread_name->length(), thread_chars);\n-      if (group_name)\n-\tJvGetStringUTFRegion (group_name, 0, \n-\t\t\t      group_name->length(), group_chars);\n-      if (parent_name)\n-\tJvGetStringUTFRegion (parent_name, 0, \n-\t\t\t      parent_name->length(), parent_chars);\n-\n-      thread_chars[thread_len] = '\\0';\n-      group_chars[group_len] = '\\0';\n-      parent_chars[parent_len] = '\\0';\n-\n-      event.event_type = JVMPI_EVENT_THREAD_START;\n-      event.env_id = NULL;\n-      event.u.thread_start.thread_name = thread_chars;\n-      event.u.thread_start.group_name = group_chars;\n-      event.u.thread_start.parent_name = parent_chars;\n-      event.u.thread_start.thread_id = (jobjectID) this;\n-      event.u.thread_start.thread_env_id = _Jv_GetCurrentJNIEnv ();\n-\n-      _Jv_DisableGC ();\n-      (*_Jv_JVMPI_Notify_THREAD_START) (&event);\n-      _Jv_EnableGC ();\n-    }\n-#endif\n-\n-  main_func *real_main = (main_func *) meth->ncode;\n-  (*real_main) (args);\n-}"}, {"sha": "541fa325bd3023224dcffd6c468b83fd916d7960", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -73,6 +73,7 @@ CXXCPP = @CXXCPP@\n DIRLTDL = @DIRLTDL@\n DIVIDESPEC = @DIVIDESPEC@\n DLLTOOL = @DLLTOOL@\n+EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n GCC_UNWIND_INCLUDE = @GCC_UNWIND_INCLUDE@\n GCDEPS = @GCDEPS@"}, {"sha": "1cd2471b8cfd90c7e8c8484c43aa08337dce0d4f", "filename": "libjava/include/no-threads.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2Fno-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2Fno-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fno-threads.h?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -102,11 +102,8 @@ _Jv_InitThreads (void)\n {\n }\n \n-inline _Jv_Thread_t *\n-_Jv_ThreadInitData (java::lang::Thread *)\n-{\n-  return NULL;\n-}\n+_Jv_Thread_t *\n+_Jv_ThreadInitData (java::lang::Thread *);\n \n inline void\n _Jv_ThreadDestroyData (_Jv_Thread_t *data)\n@@ -130,6 +127,16 @@ _Jv_ThreadSetPriority (_Jv_Thread_t *, jint)\n {\n }\n \n+inline void\n+_Jv_ThreadRegister (_Jv_Thread_t *data)\n+{\n+}\n+\n+inline void\n+_Jv_ThreadUnRegister (void)\n+{\n+}\n+\n void _Jv_ThreadStart (java::lang::Thread *, _Jv_Thread_t *,\n \t\t      _Jv_ThreadStartFunc *meth);\n "}, {"sha": "ad09bedd45a264e0b9b15c115eadee50570cb50d", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -194,6 +194,9 @@ _Jv_ThreadYield (void)\n #endif /* HAVE_SCHED_YIELD */\n }\n \n+void _Jv_ThreadRegister (_Jv_Thread_t *data);\n+void _Jv_ThreadUnRegister ();\n+\n void _Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio);\n \n void _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,"}, {"sha": "a6466322f8a5c66f029fc6f36099fd8b9b296de5", "filename": "libjava/include/win32-threads.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2Fwin32-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Finclude%2Fwin32-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-threads.h?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -25,6 +25,7 @@ typedef struct\n {\n   int flags;            // Flags are defined in implementation.\n   HANDLE handle;        // Actual handle to the thread\n+  java::lang::Thread *thread_obj;\n } _Jv_Thread_t;\n \n typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n@@ -120,6 +121,9 @@ _Jv_ThreadYield (void)\n   Sleep (0);\n }\n \n+void _Jv_ThreadRegister (_Jv_Thread_t *data);\n+void _Jv_ThreadUnRegister ();\n+\n void _Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio);\n void _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n \t\t      _Jv_ThreadStartFunc *meth);"}, {"sha": "8cc9cffdac5b707b028c94b0c184ca5981dd6cb6", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -1,6 +1,6 @@\n // Thread.java - Thread class.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -209,18 +209,20 @@ public final void stop ()\n \n   private final native void initialize_native ();\n \n-  private final synchronized static String gen_name ()\n+  private final native static String gen_name ();\n+\n+  public Thread (ThreadGroup g, Runnable r, String n)\n   {\n-    String n;\n-    n = \"Thread-\" + nextThreadNumber;\n-    ++nextThreadNumber;\n-    return n;\n+    this (currentThread (), g, r, n);\n+\n+    // The Class Libraries book says ``threadName cannot be null''.  I\n+    // take this to mean NullPointerException.\n+    if (n == null)\n+      throw new NullPointerException ();\n   }\n \n-  public Thread (ThreadGroup g, Runnable r, String n)\n+  private Thread (Thread current, ThreadGroup g, Runnable r, String n)\n   {\n-    Thread current = currentThread ();\n-          \n     if (g == null)\n       {\n \t// If CURRENT is null, then we are bootstrapping the first thread. \n@@ -233,24 +235,15 @@ public Thread (ThreadGroup g, Runnable r, String n)\n     else\n       group = g;\n       \n-    group.checkAccess();\n-\n-    // The Class Libraries book says ``threadName cannot be null''.  I\n-    // take this to mean NullPointerException.\n-    if (n == null)\n-      throw new NullPointerException ();\n-\n-    name = n;\n-    group.addThread(this);\n-    runnable = r;\n-\n     data = null;\n     interrupt_flag = false;\n     alive_flag = false;\n     startable_flag = true;\n \n     if (current != null)\n       {\n+\tgroup.checkAccess();\n+\n \tdaemon_flag = current.isDaemon();\n         int gmax = group.getMaxPriority();\n \tint pri = current.getPriority();\n@@ -263,6 +256,10 @@ public Thread (ThreadGroup g, Runnable r, String n)\n \tpriority = NORM_PRIORITY;\n       }\n \n+    name = n;\n+    group.addThread(this);\n+    runnable = r;\n+\n     initialize_native ();\n   }\n \n@@ -315,9 +312,6 @@ public String toString ()\n   private boolean startable_flag;\n   private ClassLoader context_class_loader;\n \n-  // Our native data.\n+  // Our native data - points to an instance of struct natThread.\n   private Object data;\n-\n-  // Next thread number to assign.\n-  private static int nextThreadNumber = 0;\n }"}, {"sha": "66ce7d22c789c81d8499b563b208ff86599854e0", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -1,6 +1,6 @@\n // natThread.cc - Native part of Thread class.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -59,7 +59,7 @@ java::lang::Thread::initialize_native (void)\n {\n   natThread *nt = (natThread *) _Jv_AllocBytes (sizeof (natThread));\n   \n-  // The native thread data is kept in a Object field, not a rawdata, so that\n+  // The native thread data is kept in a Object field, not a RawData, so that\n   // the GC allocator can be used and a finalizer run after the thread becomes\n   // unreachable. Note that this relies on the GC's ability to finalize \n   // non-Java objects. FIXME?\n@@ -322,6 +322,34 @@ java::lang::Thread::suspend (void)\n     (JvNewStringLatin1 (\"java::lang::Thread::suspend unimplemented\"));\n }\n \n+static int nextThreadNumber = 0;\n+\n+jstring\n+java::lang::Thread::gen_name (void)\n+{\n+  jint i;\n+  jclass sync = &java::lang::Thread::class$;\n+  {\n+    JvSynchronize dummy(sync); \n+    i = ++nextThreadNumber;\n+  }\n+\n+  // Use an array large enough for \"-2147483648\"; i.e. 11 chars, + \"Thread-\".\n+  jchar buffer[7+11];\n+  jchar *bufend = (jchar *) ((char *) buffer + sizeof(buffer));\n+  i = _Jv_FormatInt (bufend, i);\n+  jchar *ptr = bufend - i;\n+  // Prepend \"Thread-\".\n+  *--ptr = '-';\n+  *--ptr = 'd';\n+  *--ptr = 'a';\n+  *--ptr = 'e';\n+  *--ptr = 'r';\n+  *--ptr = 'h';\n+  *--ptr = 'T';\n+  return JvNewString (ptr, bufend - ptr);\n+}\n+\n void\n java::lang::Thread::yield (void)\n {\n@@ -344,3 +372,33 @@ _Jv_SetCurrentJNIEnv (JNIEnv *env)\n   JvAssert (t != NULL);\n   ((natThread *) t->data)->jni_env = env;\n }\n+\n+java::lang::Thread*\n+_Jv_AttachCurrentThread(jstring name, java::lang::ThreadGroup* group)\n+{\n+  java::lang::Thread *thread = _Jv_ThreadCurrent ();\n+  if (thread != NULL)\n+    return thread;\n+  if (name == NULL)\n+    name = java::lang::Thread::gen_name ();\n+  thread = new java::lang::Thread (NULL, group, NULL, name);\n+  thread->startable_flag = false;\n+  thread->alive_flag = true;\n+  natThread *nt = (natThread *) thread->data;\n+  _Jv_ThreadRegister (nt->thread);\n+  return thread;\n+}\n+\n+jint\n+_Jv_DetachCurrentThread (void)\n+{\n+  java::lang::Thread *t = _Jv_ThreadCurrent ();\n+  if (t == NULL)\n+    return -1;\n+\n+  _Jv_ThreadUnRegister ();\n+  // Release the monitors.\n+  t->finish_ ();\n+\n+  return 0;\n+}"}, {"sha": "625d239c5bc90d51e38ff30edd1f23b9659bdd12", "filename": "libjava/jni.cc", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -40,20 +40,20 @@ details.  */\n #include <java/util/Hashtable.h>\n #include <java/lang/Integer.h>\n #include <java/lang/ThreadGroup.h>\n-#include <gnu/gcj/jni/NativeThread.h>\n+#include <java/lang/Thread.h>\n \n #include <gcj/method.h>\n #include <gcj/field.h>\n \n #include <java-interp.h>\n+#include <java-threads.h>\n \n // FIXME: remove these defines.\n #define ClassClass java::lang::Class::class$\n #define ObjectClass java::lang::Object::class$\n #define ThrowableClass java::lang::Throwable::class$\n #define MethodClass java::lang::reflect::Method::class$\n #define ThreadGroupClass java::lang::ThreadGroup::class$\n-#define NativeThreadClass gnu::gcj::jni::NativeThread::class$\n \n // This enum is used to select different template instantiations in\n // the invocation code.\n@@ -1862,7 +1862,7 @@ _Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv, void *args)\n     {\n       try\n \t{\n-\t  (void) new gnu::gcj::jni::NativeThread (group, name);\n+\t  _Jv_AttachCurrentThread (name, group);\n \t}\n       catch (jthrowable t)\n \t{\n@@ -1916,28 +1916,11 @@ _Jv_JNI_DestroyJavaVM (JavaVM *vm)\n   return JNI_ERR;\n }\n \n-static jint\n+jint\n _Jv_JNI_DetachCurrentThread (JavaVM *)\n {\n-  java::lang::Thread *t = _Jv_ThreadCurrent ();\n-  if (t == NULL)\n-    return JNI_EDETACHED;\n-\n-  // FIXME: we only allow threads attached via AttachCurrentThread to\n-  // be detached.  I have no idea how we could implement detaching\n-  // other threads, given the requirement that we must release all the\n-  // monitors.  That just seems evil.\n-  JvAssert ((&NativeThreadClass)->isInstance (t));\n-\n-  // FIXME: release the monitors.  We'll take this to mean all\n-  // monitors acquired via the JNI interface.  This means we have to\n-  // keep track of them.\n-\n-  gnu::gcj::jni::NativeThread *nt\n-    = reinterpret_cast<gnu::gcj::jni::NativeThread *> (t);\n-  nt->finish ();\n-\n-  return 0;\n+  jint code = _Jv_DetachCurrentThread ();\n+  return code  ? JNI_EDETACHED : 0;\n }\n \n static jint"}, {"sha": "fcfa713e45e45e753a62cb65f0996fb3385fe91f", "filename": "libjava/no-threads.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fno-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fno-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fno-threads.cc?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -16,14 +16,20 @@ details.  */\n \n java::lang::Thread *_Jv_OnlyThread = NULL;\n \n-void\n-_Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *,\n-\t\t _Jv_ThreadStartFunc *meth)\n+_Jv_Thread_t *\n+_Jv_ThreadInitData (java::lang::Thread * thread)\n {\n   // Don't use JvAssert, since we want this to fail even when compiled\n   // without assertions.\n   if (_Jv_OnlyThread)\n     JvFail (\"only thread already running\");\n   _Jv_OnlyThread = thread;\n-  (*meth) (thread);\n+  return NULL;\n+}\n+\n+void\n+_Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *,\n+\t\t _Jv_ThreadStartFunc *meth)\n+{\n+  JvFail (\"Thread.start called but threads not available\");\n }"}, {"sha": "286bf83116fc1fcc09990876ee397f40645e7f42", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -326,6 +326,25 @@ _Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio)\n     }\n }\n \n+void\n+_Jv_ThreadRegister (_Jv_Thread_t *data)\n+{\n+  pthread_setspecific (_Jv_ThreadKey, data->thread_obj);\n+  pthread_setspecific (_Jv_ThreadDataKey, data);\n+\n+  // glibc 2.1.3 doesn't set the value of `thread' until after start_routine\n+  // is called. Since it may need to be accessed from the new thread, work \n+  // around the potential race here by explicitly setting it again.\n+  data->thread = pthread_self ();\n+}\n+\n+void\n+_Jv_ThreadUnRegister ()\n+{\n+  pthread_setspecific (_Jv_ThreadKey, NULL);\n+  pthread_setspecific (_Jv_ThreadDataKey, NULL);\n+}\n+\n // This function is called when a thread is started.  We don't arrange\n // to call the `run' method directly, because this function must\n // return a value.\n@@ -334,13 +353,7 @@ really_start (void *x)\n {\n   struct starter *info = (struct starter *) x;\n \n-  pthread_setspecific (_Jv_ThreadKey, info->data->thread_obj);\n-  pthread_setspecific (_Jv_ThreadDataKey, info->data);\n-\n-  // glibc 2.1.3 doesn't set the value of `thread' until after start_routine\n-  // is called. Since it may need to be accessed from the new thread, work \n-  // around the potential race here by explicitly setting it again.\n-  info->data->thread = pthread_self ();\n+  _Jv_ThreadRegister (info->data);\n \n   info->method (info->data->thread_obj);\n   "}, {"sha": "6bcf646ddea69c6a113ee273da97a0e29309cf84", "filename": "libjava/prims.cc", "status": "modified", "additions": 174, "deletions": 66, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -36,6 +36,7 @@ details.  */\n \n #ifdef ENABLE_JVMPI\n #include <jvmpi.h>\n+#include <java/lang/ThreadGroup.h>\n #endif\n \n #ifndef DISABLE_GETENV_PROPERTIES\n@@ -62,6 +63,7 @@ details.  */\n #include <java/lang/System.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/io/PrintStream.h>\n+#include <java/lang/UnsatisfiedLinkError.h>\n \n #ifdef USE_LTDL\n #include <ltdl.h>\n@@ -74,8 +76,10 @@ static java::lang::OutOfMemoryError *no_memory;\n // Largest representable size_t.\n #define SIZE_T_MAX ((size_t) (~ (size_t) 0))\n \n+static const char *no_properties[] = { NULL };\n+\n // Properties set at compile time.\n-const char **_Jv_Compiler_Properties;\n+const char **_Jv_Compiler_Properties = no_properties;\n \n // The JAR file to add to the beginning of java.class.path.\n const char *_Jv_Jar_Class_Path;\n@@ -92,6 +96,8 @@ static char * _Jv_execName;\n const char **_Jv_argv;\n int _Jv_argc;\n \n+typedef void main_func (jobject);\n+\n #ifdef ENABLE_JVMPI\n // Pointer to JVMPI notification functions.\n void (*_Jv_JVMPI_Notify_OBJECT_ALLOC) (JVMPI_Event *event);\n@@ -640,51 +646,15 @@ win32_exception_handler (LPEXCEPTION_POINTERS e)\n \n #endif\n \n-static void\n-main_init ()\n+/* This will be non-NULL if the user has preloaded a JNI library, or\n+   linked one into the executable.  */\n+extern \"C\" \n {\n-  // Turn stack trace generation off while creating exception objects.\n-  _Jv_InitClass (&java::lang::Throwable::class$);\n-  java::lang::Throwable::trace_enabled = 0;\n-  \n-  INIT_SEGV;\n-#ifdef HANDLE_FPE\n-  INIT_FPE;\n-#else\n-  arithexception = new java::lang::ArithmeticException\n-    (JvNewStringLatin1 (\"/ by zero\"));\n-#endif\n-\n-  no_memory = new java::lang::OutOfMemoryError;\n-\n-  java::lang::Throwable::trace_enabled = 1;\n-\n-#ifdef USE_LTDL\n-  LTDL_SET_PRELOADED_SYMBOLS ();\n-#endif\n-\n-#ifdef USE_WINSOCK\n-  // Initialise winsock for networking\n-  WSADATA data;\n-  if (WSAStartup (MAKEWORD (1, 1), &data))\n-      MessageBox (NULL, \"Error initialising winsock library.\", \"Error\", MB_OK | MB_ICONEXCLAMATION);\n-#endif /* USE_WINSOCK */\n-\n-#ifdef USE_WIN32_SIGNALLING\n-  // Install exception handler\n-  SetUnhandledExceptionFilter (win32_exception_handler);\n-#else\n-  // We only want this on POSIX systems.\n-  struct sigaction act;\n-  act.sa_handler = SIG_IGN;\n-  sigemptyset (&act.sa_mask);\n-  act.sa_flags = 0;\n-  sigaction (SIGPIPE, &act, NULL);\n-#endif /* USE_WIN32_SIGNALLING */\n-\n-  _Jv_JNI_Init ();\n+#pragma weak JNI_OnLoad\n+  extern jint JNI_OnLoad (JavaVM *, void *) __attribute__((weak));\n }\n \n+\n #ifndef DISABLE_GETENV_PROPERTIES\n \n static char *\n@@ -828,15 +798,162 @@ process_gcj_properties ()\n }\n #endif // DISABLE_GETENV_PROPERTIES\n \n-void\n-JvRunMain (jclass klass, int argc, const char **argv)\n+jint\n+_Jv_CreateJavaVM (void* /*vm_args*/)\n {\n   PROCESS_GCJ_PROPERTIES;\n \n+  // Turn stack trace generation off while creating exception objects.\n+  _Jv_InitClass (&java::lang::Throwable::class$);\n+  java::lang::Throwable::trace_enabled = 0;\n+  \n+  INIT_SEGV;\n+#ifdef HANDLE_FPE\n+  INIT_FPE;\n+#else\n+  arithexception = new java::lang::ArithmeticException\n+    (JvNewStringLatin1 (\"/ by zero\"));\n+#endif\n+\n+  no_memory = new java::lang::OutOfMemoryError;\n+\n+  java::lang::Throwable::trace_enabled = 1;\n+\n+#ifdef USE_LTDL\n+  LTDL_SET_PRELOADED_SYMBOLS ();\n+#endif\n+\n+#ifdef USE_WINSOCK\n+  // Initialise winsock for networking\n+  WSADATA data;\n+  if (WSAStartup (MAKEWORD (1, 1), &data))\n+      MessageBox (NULL, \"Error initialising winsock library.\", \"Error\", MB_OK | MB_ICONEXCLAMATION);\n+#endif /* USE_WINSOCK */\n+\n+#ifdef USE_WIN32_SIGNALLING\n+  // Install exception handler\n+  SetUnhandledExceptionFilter (win32_exception_handler);\n+#else\n+  // We only want this on POSIX systems.\n+  struct sigaction act;\n+  act.sa_handler = SIG_IGN;\n+  sigemptyset (&act.sa_mask);\n+  act.sa_flags = 0;\n+  sigaction (SIGPIPE, &act, NULL);\n+#endif /* USE_WIN32_SIGNALLING */\n+\n+  _Jv_JNI_Init ();\n+\n+  /* Some systems let you preload shared libraries before running a\n+     program.  Under Linux, this is done by setting the LD_PRELOAD\n+     environment variable.  We take advatage of this here to allow for\n+     dynamically loading a JNI library into a fully linked executable.  */\n+\n+  if (JNI_OnLoad != NULL)\n+    {\n+      JavaVM *vm = _Jv_GetJavaVM ();\n+      if (vm == NULL)\n+\t{\n+\t  // FIXME: what?\n+\t  return -1;\n+\t}\n+      jint vers = JNI_OnLoad (vm, NULL);\n+      if (vers != JNI_VERSION_1_1 && vers != JNI_VERSION_1_2)\n+\t{\n+\t  // FIXME: unload the library.\n+\t  _Jv_Throw (new java::lang::UnsatisfiedLinkError (JvNewStringLatin1 (\"unrecognized version from preloaded JNI_OnLoad\")));\n+\t}\n+    }\n+  return 0;\n+}\n+\n+static void\n+runFirst (::java::lang::Class *klass, ::java::lang::Object *args)\n+{\n+  Utf8Const* main_signature = _Jv_makeUtf8Const (\"([Ljava.lang.String;)V\", 22);\n+  Utf8Const* main_name = _Jv_makeUtf8Const (\"main\", 4);\n+\n+  _Jv_Method *meth = _Jv_GetMethodLocal (klass, main_name, main_signature);\n+\n+  // Some checks from Java Spec section 12.1.4.\n+  const char *msg = NULL;\n+  if (meth == NULL)\n+    msg = \"no suitable method `main' in class\";\n+  else if (! java::lang::reflect::Modifier::isStatic(meth->accflags))\n+    msg = \"`main' must be static\";\n+  else if (! java::lang::reflect::Modifier::isPublic(meth->accflags))\n+    msg =  \"`main' must be public\";\n+  if (msg != NULL)\n+    {\n+      fprintf (stderr, \"%s\\n\", msg);\n+      ::exit(1);\n+    }\n+\n+#ifdef WITH_JVMPI\n+  if (_Jv_JVMPI_Notify_THREAD_START)\n+    {\n+      JVMPI_Event event;\n+\n+      jstring thread_name = getName ();\n+      jstring group_name = NULL, parent_name = NULL;\n+      java::lang::ThreadGroup *group = getThreadGroup ();\n+\n+      if (group)\n+\t{\n+\t  group_name = group->getName ();\n+\t  group = group->getParent ();\n+\n+\t  if (group)\n+\t    parent_name = group->getName ();\n+\t}\n+\n+      int thread_len = thread_name ? JvGetStringUTFLength (thread_name) : 0;\n+      int group_len = group_name ? JvGetStringUTFLength (group_name) : 0;\n+      int parent_len = parent_name ? JvGetStringUTFLength (parent_name) : 0;\n+\n+      char thread_chars[thread_len + 1];\n+      char group_chars[group_len + 1];\n+      char parent_chars[parent_len + 1];\n+\n+      if (thread_name)\n+\tJvGetStringUTFRegion (thread_name, 0, \n+\t\t\t      thread_name->length(), thread_chars);\n+      if (group_name)\n+\tJvGetStringUTFRegion (group_name, 0, \n+\t\t\t      group_name->length(), group_chars);\n+      if (parent_name)\n+\tJvGetStringUTFRegion (parent_name, 0, \n+\t\t\t      parent_name->length(), parent_chars);\n+\n+      thread_chars[thread_len] = '\\0';\n+      group_chars[group_len] = '\\0';\n+      parent_chars[parent_len] = '\\0';\n+\n+      event.event_type = JVMPI_EVENT_THREAD_START;\n+      event.env_id = NULL;\n+      event.u.thread_start.thread_name = thread_chars;\n+      event.u.thread_start.group_name = group_chars;\n+      event.u.thread_start.parent_name = parent_chars;\n+      event.u.thread_start.thread_id = (jobjectID) this;\n+      event.u.thread_start.thread_env_id = _Jv_GetCurrentJNIEnv ();\n+\n+      _Jv_DisableGC ();\n+      (*_Jv_JVMPI_Notify_THREAD_START) (&event);\n+      _Jv_EnableGC ();\n+    }\n+#endif\n+\n+  main_func *real_main = (main_func *) meth->ncode;\n+  (*real_main) (args);\n+}\n+\n+void\n+JvRunMain (jclass klass, int argc, const char **argv)\n+{\n   _Jv_argv = argv;\n   _Jv_argc = argc;\n \n-  main_init ();\n+  _Jv_CreateJavaVM (NULL);\n #ifdef HAVE_PROC_SELF_EXE\n   char exec_name[20];\n   sprintf (exec_name, \"/proc/%d/exe\", getpid ());\n@@ -845,10 +962,9 @@ JvRunMain (jclass klass, int argc, const char **argv)\n   _Jv_ThisExecutable (argv[0]);\n #endif\n \n+  main_thread = _Jv_AttachCurrentThread (JvNewStringLatin1 (\"main\"), NULL);\n   arg_vec = JvConvertArgv (argc - 1, argv + 1);\n-  main_thread = new gnu::gcj::runtime::FirstThread (klass, arg_vec);\n-\n-  main_thread->start();\n+  runFirst (klass, arg_vec);\n   _Jv_ThreadWait ();\n \n   int status = (int) java::lang::ThreadGroup::had_uncaught_exception;\n@@ -860,33 +976,26 @@ void\n _Jv_RunMain (const char *name, int argc, const char **argv, bool is_jar)\n {\n   jstring class_name;\n-  PROCESS_GCJ_PROPERTIES;\n \n-  main_init ();\n+  _Jv_CreateJavaVM (NULL);\n \n #ifdef HAVE_PROC_SELF_EXE\n   char exec_name[20];\n   sprintf (exec_name, \"/proc/%d/exe\", getpid ());\n   _Jv_ThisExecutable (exec_name);\n #endif\n \n+  main_thread = _Jv_AttachCurrentThread (JvNewStringLatin1 (\"main\"), NULL);\n+\n   if (is_jar)\n     {\n       // name specifies a jar file.  We must now extract the\n-      // Main-Class attribute from the jar's manifest file.  This is\n-      // done by gnu.gcj.runtime.FirstThread.main.\n+      // Main-Class attribute from the jar's manifest file.\n+      // This is done by gnu.gcj.runtime.FirstThread.getMain.\n       _Jv_Jar_Class_Path = strdup (name);\n-      arg_vec = JvConvertArgv (1, &_Jv_Jar_Class_Path);\n-\n-      main_thread = \n-\tnew gnu::gcj::runtime::FirstThread (&gnu::gcj::runtime::FirstThread::class$,\n-\t\t\t\t\t    arg_vec);\n-      main_thread->start();\n-      _Jv_ThreadWait ();\n-      \n-      // FirstThread.main extracts the main class name and stores it\n-      // here.\n-      class_name = gnu::gcj::runtime::FirstThread::jarMainClassName;\n+      jstring jar_name = JvNewStringLatin1 (name);\n+      // FirstThread.getMain extracts the main class name.\n+      class_name = gnu::gcj::runtime::FirstThread::getMain (jar_name);\n \n       // We need a new ClassLoader because the classpath must be the\n       // jar file only.  The easiest way to do this is to lose our\n@@ -900,8 +1009,7 @@ _Jv_RunMain (const char *name, int argc, const char **argv, bool is_jar)\n \n   if (class_name)\n     {\n-      main_thread = new gnu::gcj::runtime::FirstThread (class_name, arg_vec);\n-      main_thread->start();\n+      runFirst(java::lang::Class::forName (class_name), arg_vec);\n       _Jv_ThreadWait ();\n     }\n "}, {"sha": "9d72715ec1eae58fa421952cb292385e99b2e5d9", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -73,6 +73,7 @@ CXXCPP = @CXXCPP@\n DIRLTDL = @DIRLTDL@\n DIVIDESPEC = @DIVIDESPEC@\n DLLTOOL = @DLLTOOL@\n+EXCEPTIONSPEC = @EXCEPTIONSPEC@\n EXEEXT = @EXEEXT@\n GCC_UNWIND_INCLUDE = @GCC_UNWIND_INCLUDE@\n GCDEPS = @GCDEPS@\n@@ -122,14 +123,10 @@ libgcj_basedir = @libgcj_basedir@\n AUTOMAKE_OPTIONS = foreign dejagnu\n \n # Setup the testing framework, if you have one\n-EXPECT = `if [ -f $(top_builddir)/../expect/expect ] ; then \\\n-            echo $(top_builddir)/../expect/expect ; \\\n-          else echo expect ; fi`\n+EXPECT = `if [ -f $(top_builddir)/../expect/expect ] ; then             echo $(top_builddir)/../expect/expect ;           else echo expect ; fi`\n \n \n-RUNTEST = `if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \\\n-\t       echo $(top_srcdir)/../dejagnu/runtest ; \\\n-\t    else echo runtest; fi`\n+RUNTEST = `if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \t       echo $(top_srcdir)/../dejagnu/runtest ; \t    else echo runtest; fi`\n \n \n RUNTESTFLAGS = @AM_RUNTESTFLAGS@"}, {"sha": "974f15622a57a2f700cc03a7763e8f26b2317570", "filename": "libjava/win32-threads.cc", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fwin32-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93d7fae7b9825449c023d42eb40641c0ad80be2/libjava%2Fwin32-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32-threads.cc?ref=c93d7fae7b9825449c023d42eb40641c0ad80be2", "patch": "@@ -35,7 +35,6 @@ extern \"C\"\n struct starter\n {\n   _Jv_ThreadStartFunc *method;\n-  java::lang::Thread *object;\n   _Jv_Thread_t *data;\n };\n \n@@ -124,10 +123,11 @@ _Jv_InitThreads (void)\n }\n \n _Jv_Thread_t *\n-_Jv_ThreadInitData (java::lang::Thread *)\n+_Jv_ThreadInitData (java::lang::Thread* obj)\n {\n   _Jv_Thread_t *data = new _Jv_Thread_t;\n   data->flags = 0;\n+  data->thread_obj = obj;\n \n   return data;\n }\n@@ -176,6 +176,20 @@ _Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio)\n     }\n }\n \n+void\n+_Jv_ThreadRegister (_Jv_Thread_t *data)\n+{\n+  TlsSetValue (_Jv_ThreadKey, data->thread_obj);\n+  TlsSetValue (_Jv_ThreadDataKey, data);\n+}\n+\n+void\n+_Jv_ThreadUnRegister ()\n+{\n+  TlsSetValue (_Jv_ThreadKey, NULL);\n+  TlsSetValue (_Jv_ThreadDataKey, NULL);\n+}\n+\n // This function is called when a thread is started.  We don't arrange\n // to call the `run' method directly, because this function must\n // return a value.\n@@ -184,9 +198,9 @@ really_start (void* x)\n {\n   struct starter *info = (struct starter *) x;\n \n-  TlsSetValue (_Jv_ThreadKey, info->object);\n-  TlsSetValue (_Jv_ThreadDataKey, info->data);\n-  info->method (info->object);\n+  _Jv_ThreadRegister (info->data);\n+\n+  info->method (info->data->thread_obj);\n \n   if (! (info->data->flags & FLAG_DAEMON))\n     {\n@@ -214,7 +228,6 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data, _Jv_ThreadStart\n   // FIXME: handle marking the info object for GC.\n   info = (struct starter *) _Jv_AllocBytes (sizeof (struct starter));\n   info->method = meth;\n-  info->object = thread;\n   info->data = data;\n \n   if (! thread->isDaemon ())"}]}