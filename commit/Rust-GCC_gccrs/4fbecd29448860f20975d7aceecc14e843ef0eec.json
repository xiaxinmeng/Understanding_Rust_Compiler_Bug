{"sha": "4fbecd29448860f20975d7aceecc14e843ef0eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiZWNkMjk0NDg4NjBmMjA5NzVkN2FjZWVjYzE0ZTg0M2VmMGVlYw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2002-05-24T10:40:47Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-05-24T10:40:47Z"}, "message": "Merge JDK 1.4 exception chaining support from classpath.\n\n\t* java/lang/Throwable.java: Merge 1.4 support from classpath.\n\t(stackTraceBytes): Rename from stackTrace.\n\t* java/lang/Exception.java: Merge from classpath.\n\t* java/lang/StackTraceElement: New file from classpath.\n\t* gcj/javaprims.h: Rebuild CNI namespace declarations.\n\t* Makefile.am: Add StackTraceElement.\n\t* Makefile.in: Rebuilt.\n\nFrom-SVN: r53836", "tree": {"sha": "53a1d2512cd2b65a2d5c7ae0bf2924fdfc4a45b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53a1d2512cd2b65a2d5c7ae0bf2924fdfc4a45b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fbecd29448860f20975d7aceecc14e843ef0eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbecd29448860f20975d7aceecc14e843ef0eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbecd29448860f20975d7aceecc14e843ef0eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbecd29448860f20975d7aceecc14e843ef0eec/comments", "author": null, "committer": null, "parents": [{"sha": "7efda05490056e0aa23cd533dce528294af6b4b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efda05490056e0aa23cd533dce528294af6b4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7efda05490056e0aa23cd533dce528294af6b4b1"}], "stats": {"total": 798, "additions": 731, "deletions": 67}, "files": [{"sha": "16c71d7c2b950ee77f02ceb22183f72dcd5220e0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -1,3 +1,14 @@\n+2002-05-24  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\tMerge JDK 1.4 exception chaining support from classpath.\n+\t* java/lang/Throwable.java: Merge 1.4 support from classpath.\n+\t(stackTraceBytes): Rename from stackTrace.\n+\t* java/lang/Exception.java: Merge from classpath.\n+\t* java/lang/StackTraceElement: New file from classpath.\n+\t* gcj/javaprims.h: Rebuild CNI namespace declarations.\n+\t* Makefile.am: Add StackTraceElement.\n+\t* Makefile.in: Rebuilt.\n+\n 2002-05-23  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* Makefile.am (all-recursive): Depend on $all_java_class_files so that"}, {"sha": "a96a3cccb182d277c163740e2853f90b58e9458b", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -1084,6 +1084,7 @@ java/lang/SecurityException.java \\\n java/lang/SecurityManager.java \\\n java/lang/Short.java \\\n java/lang/StackOverflowError.java \\\n+java/lang/StackTraceElement.java \\\n java/lang/StrictMath.java \\\n java/lang/String.java \\\n java/lang/StringBuffer.java \\\n@@ -1418,7 +1419,7 @@ gnu/java/security/provider/SHA1PRNG.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n gnu/java/text/LineBreakIterator.java \\\n-gnu/java/text/SentenceBreakIterator.java\t\\\n+gnu/java/text/SentenceBreakIterator.java \\\n gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n java/lang/ref/PhantomReference.java \\"}, {"sha": "8fff46ef37edbdb6609dc2649711043d6af6eb84", "filename": "libjava/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -851,6 +851,7 @@ java/lang/SecurityException.java \\\n java/lang/SecurityManager.java \\\n java/lang/Short.java \\\n java/lang/StackOverflowError.java \\\n+java/lang/StackTraceElement.java \\\n java/lang/StrictMath.java \\\n java/lang/String.java \\\n java/lang/StringBuffer.java \\\n@@ -1180,7 +1181,7 @@ gnu/java/security/provider/SHA1PRNG.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n gnu/java/text/LineBreakIterator.java \\\n-gnu/java/text/SentenceBreakIterator.java\t\\\n+gnu/java/text/SentenceBreakIterator.java \\\n gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n java/lang/ref/PhantomReference.java \\\n@@ -2267,7 +2268,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/Runtime.P .deps/java/lang/RuntimeException.P \\\n .deps/java/lang/RuntimePermission.P .deps/java/lang/SecurityException.P \\\n .deps/java/lang/SecurityManager.P .deps/java/lang/Short.P \\\n-.deps/java/lang/StackOverflowError.P .deps/java/lang/StrictMath.P \\\n+.deps/java/lang/StackOverflowError.P \\\n+.deps/java/lang/StackTraceElement.P .deps/java/lang/StrictMath.P \\\n .deps/java/lang/String.P .deps/java/lang/StringBuffer.P \\\n .deps/java/lang/StringIndexOutOfBoundsException.P \\\n .deps/java/lang/System.P .deps/java/lang/Thread.P \\"}, {"sha": "1f1a33b9417df616eb050c46886bc24d85765a77", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -193,6 +193,7 @@ extern \"Java\"\n       class SecurityManager;\n       class Short;\n       class StackOverflowError;\n+      class StackTraceElement;\n       class StrictMath;\n       class String;\n       class String$CaseInsensitiveComparator;\n@@ -241,32 +242,43 @@ extern \"Java\"\n     {\n       class AbstractCollection;\n       class AbstractList;\n-      class AbstractList$AbstractListItr;\n       class AbstractMap;\n       class AbstractSequentialList;\n       class AbstractSet;\n       class ArrayList;\n       class Arrays;\n+      class Arrays$ArrayList;\n       class Arrays$ListImpl;\n       class BasicMapEntry;\n       class BitSet;\n       class Calendar;\n       class Collection;\n       class Collections;\n+      class Collections$CopiesList;\n+      class Collections$EmptyList;\n+      class Collections$EmptyMap;\n+      class Collections$EmptySet;\n       class Collections$ReverseComparator;\n+      class Collections$SingletonList;\n+      class Collections$SingletonMap;\n+      class Collections$SingletonSet;\n       class Collections$SynchronizedCollection;\n       class Collections$SynchronizedIterator;\n       class Collections$SynchronizedList;\n       class Collections$SynchronizedListIterator;\n       class Collections$SynchronizedMap;\n+      class Collections$SynchronizedMapEntry;\n+      class Collections$SynchronizedRandomAccessList;\n       class Collections$SynchronizedSet;\n       class Collections$SynchronizedSortedMap;\n       class Collections$SynchronizedSortedSet;\n       class Collections$UnmodifiableCollection;\n+      class Collections$UnmodifiableEntrySet;\n       class Collections$UnmodifiableIterator;\n       class Collections$UnmodifiableList;\n       class Collections$UnmodifiableListIterator;\n       class Collections$UnmodifiableMap;\n+      class Collections$UnmodifiableRandomAccessList;\n       class Collections$UnmodifiableSet;\n       class Collections$UnmodifiableSortedMap;\n       class Collections$UnmodifiableSortedSet;\n@@ -288,10 +300,12 @@ extern \"Java\"\n       class Hashtable$HashEntry;\n       class Hashtable$HashIterator;\n       class IdentityHashMap;\n+      class IdentityHashMap$IdentityEntry;\n       class IdentityHashMap$IdentityIterator;\n       class Iterator;\n       class LinkedHashMap;\n       class LinkedHashMap$LinkedHashEntry;\n+      class LinkedHashSet;\n       class LinkedList;\n       class LinkedList$Entry;\n       class LinkedList$LinkedListItr;\n@@ -311,7 +325,9 @@ extern \"Java\"\n       class PropertyResourceBundle;\n       class Random;\n       class RandomAccess;\n+      class RandomAccessSubList;\n       class ResourceBundle;\n+      class ResourceBundle$Security;\n       class Set;\n       class SimpleTimeZone;\n       class SortedMap;\n@@ -329,12 +345,11 @@ extern \"Java\"\n       class TreeMap$Node;\n       class TreeMap$SubMap;\n       class TreeMap$TreeIterator;\n-      class TreeMap$VerifyResult;\n       class TreeSet;\n       class Vector;\n       class WeakHashMap;\n-      class WeakHashMap$Entry;\n       class WeakHashMap$WeakBucket;\n+      class WeakHashMap$WeakEntry;\n       class WeakHashMap$WeakEntrySet;\n       namespace jar\n       {\n@@ -372,7 +387,7 @@ extern \"Java\"\n         class ZipOutputStream;\n       };\n     };\n-  };\n+  };  \n };\n   \n typedef struct java::lang::Object* jobject;"}, {"sha": "edf5de228c810e094ed600fd7c738b2fe1f2f67e", "filename": "libjava/java/lang/Exception.java", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fjava%2Flang%2FException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fjava%2Flang%2FException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FException.java?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -1,14 +1,14 @@\n /* Exception.java -- generic exception thrown to indicate an exceptional\n    condition has occurred.\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,40 +39,66 @@\n \n package java.lang;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n-\n /**\n- * Exceptions may be thrown by one part of a Java program and caught\n- * by another in order to deal with the cause of the exception, such as\n+ * The root class of all exceptions worth catching in a program.  This\n+ * includes the special category of <code>RuntimeException</code>, which\n+ * does not need to be declared in a throws clause.  Exceptions can be used\n+ * to represent almost any exceptional behavior, such as programming errors,\n  * mouse movements, keyboard clicking, etc.\n  *\n- * @since JDK 1.0\n- * \n  * @author Brian Jones\n  * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 18, 1998.\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @status updated to 1.4\n  */\n public class Exception extends Throwable\n {\n-  static final long serialVersionUID = -3387516993124229948L;\n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n+  private static final long serialVersionUID = -3387516993124229948L;\n \n   /**\n-   * Create an exception without a message.\n+   * Create an exception without a message. The cause remains uninitialized.\n+   *\n+   * @see #initCause(Throwable)\n    */\n   public Exception()\n-    {\n-      super();\n-    }\n+  {\n+  }\n \n   /**\n-   * Create an exception with a message.\n+   * Create an exception with a message. The cause remains uninitialized.\n+   *\n+   * @param s the message\n+   * @see #initCause(Throwable)\n    */\n   public Exception(String s)\n-    {\n-      super(s);\n-    }\n+  {\n+    super(s);\n+  }\n+\n+  /**\n+   * Create an exception with a message and a cause.\n+   *\n+   * @param s the message string\n+   * @param cause the cause of this error\n+   * @since 1.4\n+   */\n+  public Exception(String s, Throwable cause)\n+  {\n+    super(s, cause);\n+  }\n+\n+  /**\n+   * Create an exception with a given cause, and a message of\n+   * <code>cause == null ? null : cause.toString()</code>.\n+   *\n+   * @param cause the cause of this exception\n+   * @since 1.4\n+   */\n+  public Exception(Throwable cause)\n+  {\n+    super(cause);\n+  }\n }"}, {"sha": "9c60ab16410378eda5b4f166afe742b57656475d", "filename": "libjava/java/lang/StackTraceElement.java", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fjava%2Flang%2FStackTraceElement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fjava%2Flang%2FStackTraceElement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStackTraceElement.java?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -0,0 +1,259 @@\n+/* StackTraceElement.java -- One function call or call stack element\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * One function call or stack trace element. Gives information about\n+ * the execution point such as the source file name, the line number,\n+ * the fully qualified class name, the method name and whether this method\n+ * is native, if this information is known.\n+ *\n+ * @author Mark Wielaard <mark@klomp.org>\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.4\n+ * @status updated to 1.4\n+ */\n+public class StackTraceElement implements Serializable\n+{\n+  /**\n+   * Compatible with JDK 1.4+.\n+   */\n+  private static final long serialVersionUID = 6992337162326171013L;\n+\n+  /**\n+   * The name of the file, null if unknown.\n+   *\n+   * @serial the source code filename, if known\n+   */\n+  private final String fileName;\n+\n+  /**\n+   * The line number in the file, negative if unknown.\n+   *\n+   * @serial the source code line number, if known\n+   */\n+  private final int lineNumber;\n+\n+  /**\n+   * The fully qualified class name, null if unknown.\n+   *\n+   * @serial the enclosing class, if known\n+   */\n+  private final String className;\n+\n+  /**\n+   * The method name in the class, null if unknown.\n+   *\n+   * @serial the enclosing method, if known\n+   */\n+  private final String methodName;\n+\n+  /** Whether the method is native. */\n+  private final transient boolean isNative;\n+\n+  /**\n+   * A package local constructor for the StackTraceElement class, to be\n+   * called by the Virtual Machine as part of Throwable.fillInStackTrace.\n+   * There are no public constructors defined for this class. Creation\n+   * of new elements is implementation specific.\n+   *\n+   * @param fileName the name of the file, null if unknown\n+   * @param lineNumber the line in the file, negative if unknown\n+   * @param className the fully qualified name of the class, null if unknown\n+   * @param methodName the name of the method, null if unknown\n+   * @param isNative true if native, false otherwise\n+   */\n+  StackTraceElement(String fileName, int lineNumber, String className,\n+                    String methodName, boolean isNative)\n+  {\n+    this.fileName = fileName;\n+    this.lineNumber = lineNumber;\n+    this.className = className;\n+    this.methodName = methodName;\n+    this.isNative = isNative;\n+  }\n+\n+  /**\n+   * Returns the name of the file, or null if unknown. This is usually\n+   * obtained from the <code>SourceFile</code> attribute of the class file\n+   * format, if present.\n+   *\n+   * @return the file name\n+   */\n+  public String getFileName()\n+  {\n+    return fileName;\n+  }\n+\n+  /**\n+   * Returns the line number in the file, or a negative number if unknown.\n+   * This is usually obtained from the <code>LineNumberTable</code> attribute\n+   * of the method in the class file format, if present.\n+   *\n+   * @return the line number\n+   */\n+  public int getLineNumber()\n+  {\n+    return lineNumber;\n+  }\n+\n+  /**\n+   * Returns the fully qualified class name, or null if unknown.\n+   *\n+   * @return the class name\n+   */\n+  public String getClassName()\n+  {\n+    return className;\n+  }\n+\n+  /**\n+   * Returns the method name in the class, or null if unknown. If the\n+   * execution point is in a constructor, the name is\n+   * <code>&lt;init&gt;</code>; if the execution point is in the class\n+   * initializer, the name is <code>&lt;clinit&gt;</code>.\n+   *\n+   * @return the method name\n+   */\n+  public String getMethodName()\n+  {\n+    return methodName;\n+  }\n+\n+  /**\n+   * Returns true if the method is native, or false if it is not or unknown.\n+   *\n+   * @return whether the method is native\n+   */\n+  public boolean isNativeMethod()\n+  {\n+    return isNative;\n+  }\n+\n+  /**\n+   * Returns a string representation of this stack trace element. The\n+   * returned String is implementation specific. This implementation\n+   * returns the following String: \"[class][.][method]([file][:line])\".\n+   * If the fully qualified class name or the method is unknown it is\n+   * omitted including the point seperator. If the source file name is\n+   * unknown it is replaced by \"Unknown Source\" if the method is not native\n+   * or by \"Native Method\" if the method is native. If the line number\n+   * is unknown it and the colon are omitted.\n+   *\n+   * @return a string representation of this execution point\n+   */\n+  public String toString()\n+  {\n+    StringBuffer sb = new StringBuffer();\n+    if (className != null)\n+      {\n+        sb.append(className);\n+        if (methodName != null)\n+          sb.append('.');\n+      }\n+    if (methodName != null)\n+      sb.append(methodName);\n+    sb.append('(');\n+    if (fileName != null)\n+      sb.append(fileName);\n+    else\n+      sb.append(isNative ? \"Native Method\" : \"Unknown Source\");\n+    if (lineNumber >= 0)\n+      sb.append(':').append(lineNumber);\n+    sb.append(')');\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Returns true if the given object is also a StackTraceElement and all\n+   * attributes, except the native flag, are equal (either the same attribute\n+   * between the two elments are null, or both satisfy Object.equals).\n+   *\n+   * @param o the object to compare\n+   * @return true if the two are equal\n+   */\n+  public boolean equals(Object o)\n+  {\n+    if (! (o instanceof StackTraceElement))\n+      return false;\n+    StackTraceElement e = (StackTraceElement) o;\n+    return equals(fileName, e.fileName)\n+      && lineNumber == e.lineNumber\n+      && equals(className, e.className)\n+      && equals(methodName, e.methodName);\n+  }\n+\n+  /**\n+   * Returns the hashCode of this StackTraceElement. This implementation\n+   * computes the hashcode by xor-ing the hashcode of all attributes except\n+   * the native flag.\n+   *\n+   * @return the hashcode\n+   */\n+  public int hashCode()\n+  {\n+    return hashCode(fileName) ^ lineNumber ^ hashCode(className)\n+      ^ hashCode(methodName);\n+  }\n+\n+  /**\n+   * Compare two objects according to Collection semantics.\n+   *\n+   * @param o1 the first object\n+   * @param o2 the second object\n+   * @return o1 == null ? o2 == null : o1.equals(o2)\n+   */\n+  private static final boolean equals(Object o1, Object o2)\n+  {\n+    return o1 == null ? o2 == null : o1.equals(o2);\n+  }\n+\n+  /**\n+   * Hash an object according to Collection semantics.\n+   *\n+   * @param o the object to hash\n+   * @return o1 == null ? 0 : o1.hashCode()\n+   */\n+  private static final int hashCode(Object o)\n+  {\n+    return o == null ? 0 : o.hashCode();\n+  }\n+}"}, {"sha": "d5488b877e7fcd59cd6b9cdcd84f59cf9e736b20", "filename": "libjava/java/lang/Throwable.java", "status": "modified", "additions": 388, "deletions": 38, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fjava%2Flang%2FThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fbecd29448860f20975d7aceecc14e843ef0eec/libjava%2Fjava%2Flang%2FThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThrowable.java?ref=4fbecd29448860f20975d7aceecc14e843ef0eec", "patch": "@@ -1,21 +1,50 @@\n-// Throwable.java - Superclass for all exceptions.\n+/* java.lang.Throwable -- Reference implementation of root class for\n+   all Exceptions and Errors\n+   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n package java.lang;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n+\n import java.io.Serializable;\n-import java.io.OutputStreamWriter;\n-import java.io.OutputStream;\n-import java.io.FilterOutputStream;\n+import java.io.PrintWriter;\n+import java.io.PrintStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n \n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n@@ -98,38 +127,341 @@ public void close () throws IOException\n   }    \n }\n \n+/**\n+ * Throwable is the superclass of all exceptions that can be raised.\n+ *\n+ * <p>There are two special cases: {@link Error} and {@link RuntimeException}:\n+ * these two classes (and their subclasses) are considered unchecked\n+ * exceptions, and are either frequent enough or catastrophic enough that you\n+ * do not need to declare them in <code>throws</code> clauses.  Everything\n+ * else is a checked exception, and is ususally a subclass of\n+ * {@link Exception}; these exceptions have to be handled or declared.\n+ *\n+ * <p>Instances of this class are usually created with knowledge of the\n+ * execution context, so that you can get a stack trace of the problem spot\n+ * in the code.  Also, since JDK 1.4, Throwables participate in \"exception\n+ * chaining.\"  This means that one exception can be caused by another, and\n+ * preserve the information of the original.\n+ *\n+ * <p>One reason this is useful is to wrap exceptions to conform to an\n+ * interface.  For example, it would be bad design to require all levels\n+ * of a program interface to be aware of the low-level exceptions thrown\n+ * at one level of abstraction. Another example is wrapping a checked\n+ * exception in an unchecked one, to communicate that failure occured\n+ * while still obeying the method throws clause of a superclass.\n+ *\n+ * <p>A cause is assigned in one of two ways; but can only be assigned once\n+ * in the lifetime of the Throwable.  There are new constructors added to\n+ * several classes in the exception hierarchy that directly initialize the\n+ * cause, or you can use the <code>initCause</code> method. This second\n+ * method is especially useful if the superclass has not been retrofitted\n+ * with new constructors:<br>\n+ * <pre>\n+ * try\n+ *   {\n+ *     lowLevelOp();\n+ *   }\n+ * catch (LowLevelException lle)\n+ *   {\n+ *     throw (HighLevelException) new HighLevelException().initCause(lle);\n+ *   }\n+ * </pre>\n+ * Notice the cast in the above example; without it, your method would need\n+ * a throws clase that declared Throwable, defeating the purpose of chainig\n+ * your exceptions.\n+ *\n+ * <p>By convention, exception classes have two constructors: one with no\n+ * arguments, and one that takes a String for a detail message.  Further,\n+ * classes which are likely to be used in an exception chain also provide\n+ * a constructor that takes a Throwable, with or without a detail message\n+ * string.\n+ *\n+ * <p>Another 1.4 feature is the StackTrace, a means of reflection that\n+ * allows the program to inspect the context of the exception, and which is\n+ * serialized, so that remote procedure calls can correctly pass exceptions.\n+ *\n+ * @author Brian Jones\n+ * @author John Keiser\n+ * @author Mark Wielaard\n+ * @author Tom Tromey\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status still missing 1.4 functionality\n+ */\n public class Throwable implements Serializable\n {\n-  public native Throwable fillInStackTrace ();\n+  /**\n+   * Compatible with JDK 1.0+.\n+   */\n+  private static final long serialVersionUID = -3042686055658047285L;\n+\n+  /**\n+   * The detail message.\n+   *\n+   * @serial specific details about the exception, may be null\n+   */\n+  private String detailMessage;\n+\n+  /**\n+   * The cause of the throwable, including null for an unknown or non-chained\n+   * cause. This may only be set once; so the field is set to\n+   * <code>this</code> until initialized.\n+   *\n+   * @serial the cause, or null if unknown, or this if not yet set\n+   * @since 1.4\n+   */\n+  private Throwable cause = this;\n+\n+  /**\n+   * The stack trace, in a serialized form.\n+   *\n+   * @serial the elements of the stack trace; this is non-null, and has\n+   *         no null entries\n+   * @since 1.4\n+   */\n+  // XXX Don't initialize this, once fillInStackTrace() does it.\n+  private StackTraceElement[] stackTrace = {};\n+\n+  /**\n+   * Instantiate this Throwable with an empty message. The cause remains\n+   * uninitialized.  {@link #fillInStackTrace()} will be called to set\n+   * up the stack trace.\n+   */\n+  public Throwable()\n+  {\n+    this((String) null);\n+  }\n \n-  public String getLocalizedMessage ()\n+  /**\n+   * Instantiate this Throwable with the given message. The cause remains\n+   * uninitialized.  {@link #fillInStackTrace()} will be called to set\n+   * up the stack trace.\n+   *\n+   * @param message the message to associate with the Throwable\n+   */\n+  public Throwable(String message)\n   {\n-    return getMessage ();\n+    fillInStackTrace();\n+    detailMessage = message;  \n   }\n \n-  public String getMessage ()\n+  /**\n+   * Instantiate this Throwable with the given message and cause. Note that\n+   * the message is unrelated to the message of the cause.\n+   * {@link #fillInStackTrace()} will be called to set up the stack trace.\n+   *\n+   * @param message the message to associate with the Throwable\n+   * @param cause the cause, may be null\n+   * @since 1.4\n+   */\n+  public Throwable(String message, Throwable cause)\n+  {\n+    this(message);\n+    initCause(cause);\n+  }\n+\n+  /**\n+   * Instantiate this Throwable with the given cause. The message is then\n+   * built as <code>cause == null ? null : cause.toString()</code>.\n+   * {@link #fillInStackTrace()} will be called to set up the stack trace.\n+   *\n+   * @param cause the cause, may be null\n+   * @since 1.4\n+   */\n+  public Throwable(Throwable cause)\n+  {\n+    this(cause == null ? null : cause.toString(), cause);\n+  }\n+\n+  /**\n+   * Get the message associated with this Throwable.\n+   *\n+   * @return the error message associated with this Throwable, may be null\n+   */\n+  public String getMessage()\n   {\n     return detailMessage;\n   }\n \n-  public void printStackTrace ()\n+  /**\n+   * Get a localized version of this Throwable's error message.\n+   * This method must be overridden in a subclass of Throwable\n+   * to actually produce locale-specific methods.  The Throwable\n+   * implementation just returns getMessage().\n+   *\n+   * @return a localized version of this error message\n+   * @see #getMessage()\n+   * @since 1.1\n+   */\n+  public String getLocalizedMessage()\n+  {\n+    return getMessage();\n+  }\n+\n+  /**\n+   * Returns the cause of this exception, or null if the cause is not known\n+   * or non-existant. This cause is initialized by the new constructors,\n+   * or by calling initCause.\n+   *\n+   * @return the cause of this Throwable\n+   * @since 1.4\n+   */\n+  public Throwable getCause()\n   {\n-    printStackTrace (System.err);\n+    return cause == this ? null : cause;\n   }\n \n-  public void printStackTrace (PrintStream ps)\n+  /**\n+   * Initialize the cause of this Throwable.  This may only be called once\n+   * during the object lifetime, including implicitly by chaining\n+   * constructors.\n+   *\n+   * @param cause the cause of this Throwable, may be null\n+   * @return this\n+   * @throws IllegalArgumentException if cause is this (a Throwable can't be\n+   *         its own cause!)\n+   * @throws IllegalStateException if the cause has already been set\n+   * @since 1.4\n+   */\n+  public Throwable initCause(Throwable cause)\n   {\n-    PrintWriter writer = new PrintWriter (ps);\n-    printStackTrace (writer);\n+    if (cause == this)\n+      throw new IllegalArgumentException();\n+    if (this.cause != this)\n+      throw new IllegalStateException();\n+    this.cause = cause;\n+    return this;\n   }\n \n+  /**\n+   * Get a human-readable representation of this Throwable. The detail message\n+   * is retrieved by getLocalizedMessage().  Then, with a null detail\n+   * message, this string is simply the object's class name; otherwise\n+   * the string is <code>getClass().getName() + \": \" + message</code>.\n+   *\n+   * @return a human-readable String represting this Throwable\n+   */\n+  public String toString()\n+  {\n+    String msg = getLocalizedMessage();\n+    return getClass().getName() + (msg == null ? \"\" : \": \" + msg);\n+  }\n+\n+  /**\n+   * Print a stack trace to the standard error stream. This stream is the\n+   * current contents of <code>System.err</code>. The first line of output\n+   * is the result of {@link #toString()}, and the remaining lines represent\n+   * the data created by {@link #fillInStackTrace()}. While the format is\n+   * unspecified, this implementation uses the suggested format, demonstrated\n+   * by this example:<br>\n+   * <pre>\n+   * public class Junk\n+   * {\n+   *   public static void main(String args[])\n+   *   {\n+   *     try\n+   *       {\n+   *         a();\n+   *       }\n+   *     catch(HighLevelException e)\n+   *       {\n+   *         e.printStackTrace();\n+   *       }\n+   *   }\n+   *   static void a() throws HighLevelException\n+   *   {\n+   *     try\n+   *       {\n+   *         b();\n+   *       }\n+   *     catch(MidLevelException e)\n+   *       {\n+   *         throw new HighLevelException(e);\n+   *       }\n+   *   }\n+   *   static void b() throws MidLevelException\n+   *   {\n+   *     c();\n+   *   }\n+   *   static void c() throws MidLevelException\n+   *   {\n+   *     try\n+   *       {\n+   *         d();\n+   *       }\n+   *     catch(LowLevelException e)\n+   *       {\n+   *         throw new MidLevelException(e);\n+   *       }\n+   *   }\n+   *   static void d() throws LowLevelException\n+   *   {\n+   *     e();\n+   *   }\n+   *   static void e() throws LowLevelException\n+   *   {\n+   *     throw new LowLevelException();\n+   *   }\n+   * }\n+   * class HighLevelException extends Exception\n+   * {\n+   *   HighLevelException(Throwable cause) { super(cause); }\n+   * }\n+   * class MidLevelException extends Exception\n+   * {\n+   *   MidLevelException(Throwable cause)  { super(cause); }\n+   * }\n+   * class LowLevelException extends Exception\n+   * {\n+   * }\n+   * </pre>\n+   * <p>\n+   * <pre>\n+   *  HighLevelException: MidLevelException: LowLevelException\n+   *          at Junk.a(Junk.java:13)\n+   *          at Junk.main(Junk.java:4)\n+   *  Caused by: MidLevelException: LowLevelException\n+   *          at Junk.c(Junk.java:23)\n+   *          at Junk.b(Junk.java:17)\n+   *          at Junk.a(Junk.java:11)\n+   *          ... 1 more\n+   *  Caused by: LowLevelException\n+   *          at Junk.e(Junk.java:30)\n+   *          at Junk.d(Junk.java:27)\n+   *          at Junk.c(Junk.java:21)\n+   *          ... 3 more\n+   * </pre>\n+   */\n+  public void printStackTrace()\n+  {\n+    printStackTrace(System.err);\n+  }\n+\n+  /**\n+   * Print a stack trace to the specified PrintStream. See\n+   * {@link #printStackTrace()} for the sample format.\n+   *\n+   * @param s the PrintStream to write the trace to\n+   */\n+  public void printStackTrace(PrintStream s)\n+  {\n+    printStackTrace(new PrintWriter(s));\n+  }\n+\n+  /**\n+   * Print a stack trace to the specified PrintWriter. See\n+   * {@link #printStackTrace()} for the sample format.\n+   *\n+   * @param w the PrintWriter to write the trace to\n+   * @since 1.1\n+   */\n   public void printStackTrace (PrintWriter wr)\n   {\n     try\n       {\n \tCPlusPlusDemangler cPlusPlusFilter = new CPlusPlusDemangler (wr);\n \tPrintWriter writer = new PrintWriter (cPlusPlusFilter);\n-\tprintRawStackTrace (writer);\t\n+\tprintRawStackTrace (writer);\n \twriter.close ();\n \tif (cPlusPlusFilter.written == 0) // The demangler has failed...\n \t  printRawStackTrace (wr);\n@@ -140,32 +472,50 @@ public void printStackTrace (PrintWriter wr)\n       }\n   }\n \n-  public Throwable ()\n-  {\n-    detailMessage = null;\n-    fillInStackTrace ();\n-  }\n+  /**\n+   * Fill in the stack trace with the current execution stack.\n+   *\n+   * @return this same throwable\n+   * @see #printStackTrace()\n+   */\n+  public native Throwable fillInStackTrace();\n \n-  public Throwable (String message)\n+  /**\n+   * Provides access to the information printed in {@link #printStackTrace()}.\n+   * The array is non-null, with no null entries, although the virtual\n+   * machine is allowed to skip stack frames.  If the array is not 0-length,\n+   * then slot 0 holds the information on the stack frame where the Throwable\n+   * was created (or at least where <code>fillInStackTrace()</code> was\n+   * called).\n+   *\n+   * @return an array of stack trace information, as available from the VM\n+   * @since 1.4\n+   */\n+  public StackTraceElement[] getStackTrace()\n   {\n-    detailMessage = message;\n-    fillInStackTrace ();\n+    return stackTrace;\n   }\n \n-  public String toString ()\n+  /**\n+   * Change the stack trace manually. This method is designed for remote\n+   * procedure calls, which intend to alter the stack trace before or after\n+   * serialization according to the context of the remote call.\n+   *\n+   * @param stackTrace the new trace to use\n+   * @throws NullPointerException if stackTrace is null or has null elements\n+   * @since 1.4\n+   */\n+  public void setStackTrace(StackTraceElement[] stackTrace)\n   {\n-    return ((detailMessage == null)\n-\t    ? getClass().getName()\n-\t    : getClass().getName() + \": \" + getMessage ());\n+    for (int i = stackTrace.length; --i >= 0; )\n+      if (stackTrace[i] == null)\n+        throw new NullPointerException();\n+    this.stackTrace = stackTrace;\n   }\n \n   private native final void printRawStackTrace (PrintWriter wr);\n   \n-  // Name of this field comes from serialization spec.\n-  private String detailMessage;\n-\n   // Setting this flag to false prevents fillInStackTrace() from running.\n   static boolean trace_enabled = true;\n-  private transient byte stackTrace[];\n-  private static final long serialVersionUID = -3042686055658047285L;\n+  private transient byte stackTraceBytes[];\n }"}]}