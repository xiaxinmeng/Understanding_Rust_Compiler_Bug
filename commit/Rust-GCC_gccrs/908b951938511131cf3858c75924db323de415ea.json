{"sha": "908b951938511131cf3858c75924db323de415ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA4Yjk1MTkzODUxMTEzMWNmMzg1OGM3NTkyNGRiMzIzZGU0MTVlYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-12-08T09:05:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-12-08T09:05:38Z"}, "message": "re PR tree-optimization/51315 (unaligned memory accesses generated with -ftree-sra)\n\n\tPR tree-optimization/51315\n\t* tree.h (get_object_or_type_alignment): Declare.\n\t* expr.c (get_object_or_type_alignment): Move to...\n\t* builtins.c (get_object_or_type_alignment): ...here.  Add assertion.\n\t* tree-sra.c (tree_non_mode_aligned_mem_p): Rename to...\n\t(tree_non_aligned_mem_p): ...this.  Add ALIGN parameter.  Look into\n\tMEM_REFs and use get_object_or_type_alignment for them.\n\t(build_accesses_from_assign): Adjust for above change.\n\t(access_precludes_ipa_sra_p): Likewise.\n\nFrom-SVN: r182102", "tree": {"sha": "f9866f9a7ab239814de604e3414349d48cdece0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9866f9a7ab239814de604e3414349d48cdece0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/908b951938511131cf3858c75924db323de415ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908b951938511131cf3858c75924db323de415ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/908b951938511131cf3858c75924db323de415ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908b951938511131cf3858c75924db323de415ea/comments", "author": null, "committer": null, "parents": [{"sha": "c37257a1f686bdd260a2edc445f8b3f24dceec2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37257a1f686bdd260a2edc445f8b3f24dceec2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37257a1f686bdd260a2edc445f8b3f24dceec2e"}], "stats": {"total": 193, "additions": 158, "deletions": 35}, "files": [{"sha": "1f26fa946c4d565e8f9392d8d5496475e2242d20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -1,3 +1,15 @@\n+2011-12-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR tree-optimization/51315\n+\t* tree.h (get_object_or_type_alignment): Declare.\n+\t* expr.c (get_object_or_type_alignment): Move to...\n+\t* builtins.c (get_object_or_type_alignment): ...here.  Add assertion.\n+\t* tree-sra.c (tree_non_mode_aligned_mem_p): Rename to...\n+\t(tree_non_aligned_mem_p): ...this.  Add ALIGN parameter.  Look into\n+\tMEM_REFs and use get_object_or_type_alignment for them.\n+\t(build_accesses_from_assign): Adjust for above change.\n+\t(access_precludes_ipa_sra_p): Likewise.\n+\n 2011-12-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/48437"}, {"sha": "b00749848a61657e3f81cddd7b700de97a90fb67", "filename": "gcc/builtins.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -452,6 +452,31 @@ get_object_alignment (tree exp)\n   return align;\n }\n \n+/* Return the alignment of object EXP, also considering its type when we do\n+   not know of explicit misalignment.  Only handle MEM_REF and TARGET_MEM_REF.\n+\n+   ??? Note that, in the general case, the type of an expression is not kept\n+   consistent with misalignment information by the front-end, for example when\n+   taking the address of a member of a packed structure.  However, in most of\n+   the cases, expressions have the alignment of their type so we optimistically\n+   fall back to this alignment when we cannot compute a misalignment.  */\n+\n+unsigned int\n+get_object_or_type_alignment (tree exp)\n+{\n+  unsigned HOST_WIDE_INT misalign;\n+  unsigned int align = get_object_alignment_1 (exp, &misalign);\n+\n+  gcc_assert (TREE_CODE (exp) == MEM_REF || TREE_CODE (exp) == TARGET_MEM_REF);\n+\n+  if (misalign != 0)\n+    align = (misalign & -misalign);\n+  else\n+    align = MAX (TYPE_ALIGN (TREE_TYPE (exp)), align);\n+\n+  return align;\n+}\n+\n /* Return the alignment in bits of EXP, a pointer valued expression.\n    The alignment returned is, by default, the alignment of the thing that\n    EXP points to.  If it is not a POINTER_TYPE, 0 is returned."}, {"sha": "b2166bdac817442c6f4027def49b9ae7de7e7aba", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -4544,27 +4544,6 @@ get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n     }\n }\n \n-/* Return the alignment of the object EXP, also considering its type\n-   when we do not know of explicit misalignment.\n-   ???  Note that, in the general case, the type of an expression is not kept\n-   consistent with misalignment information by the front-end, for\n-   example when taking the address of a member of a packed structure.\n-   However, in most of the cases, expressions have the alignment of\n-   their type, so we optimistically fall back to the alignment of the\n-   type when we cannot compute a misalignment.  */\n-\n-static unsigned int\n-get_object_or_type_alignment (tree exp)\n-{\n-  unsigned HOST_WIDE_INT misalign;\n-  unsigned int align = get_object_alignment_1 (exp, &misalign);\n-  if (misalign != 0)\n-    align = (misalign & -misalign);\n-  else\n-    align = MAX (TYPE_ALIGN (TREE_TYPE (exp)), align);\n-  return align;\n-}\n-\n /* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL\n    is true, try generating a nontemporal store.  */\n "}, {"sha": "898478b87a29730c1b4d2601a75cafb7549726fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -1,3 +1,7 @@\n+2011-12-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20111208-1.c: New test.\n+\n 2011-12-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/48437"}, {"sha": "8bcb10accb54e558f17aa2d97d3b6d2079409df5", "filename": "gcc/testsuite/gcc.c-torture/execute/20111208-1.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111208-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111208-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20111208-1.c?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -0,0 +1,94 @@\n+/* PR tree-optimization/51315 */\n+/* Reported by Jurij Smakov <jurij@wooyd.org> */\n+\n+typedef unsigned int size_t;\n+\n+extern void *memcpy (void *__restrict __dest,\n+       __const void *__restrict __src, size_t __n)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));\n+\n+extern size_t strlen (__const char *__s)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));\n+\n+typedef short int int16_t;\n+typedef int int32_t;\n+\n+extern void abort (void);\n+\n+int a;\n+\n+static void __attribute__ ((noinline,noclone))\n+do_something (int item)\n+{\n+  a = item;\n+}\n+\n+int\n+pack_unpack (char *s, char *p)\n+{\n+  char *send, *pend;\n+  char type;\n+  int integer_size;\n+\n+  send = s + strlen (s);\n+  pend = p + strlen (p);\n+\n+  while (p < pend)\n+    {\n+      type = *p++;\n+\n+      switch (type)\n+ {\n+ case 's':\n+   integer_size = 2;\n+   goto unpack_integer;\n+\n+ case 'l':\n+   integer_size = 4;\n+   goto unpack_integer;\n+\n+ unpack_integer:\n+   switch (integer_size)\n+     {\n+     case 2:\n+       {\n+  union\n+  {\n+    int16_t i;\n+    char a[sizeof (int16_t)];\n+  }\n+  v;\n+  memcpy (v.a, s, sizeof (int16_t));\n+  s += sizeof (int16_t);\n+  do_something (v.i);\n+       }\n+       break;\n+\n+     case 4:\n+       {\n+  union\n+  {\n+    int32_t i;\n+    char a[sizeof (int32_t)];\n+  }\n+  v;\n+  memcpy (v.a, s, sizeof (int32_t));\n+  s += sizeof (int32_t);\n+  do_something (v.i);\n+       }\n+       break;\n+     }\n+   break;\n+ }\n+    }\n+  return (int) *s;\n+}\n+\n+int\n+main (void)\n+{\n+  int n = pack_unpack (\"\\200\\001\\377\\376\\035\\300\", \"sl\");\n+  if (n != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "346519a6af57b3d3fc2e76a6a7b43dead5a5a7fe", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -1067,26 +1067,29 @@ disqualify_ops_if_throwing_stmt (gimple stmt, tree lhs, tree rhs)\n   return false;\n }\n \n-/* Return true iff type of EXP is not sufficiently aligned.  */\n+/* Return true if EXP is a memory reference less aligned than ALIGN.  This is\n+   invoked only on strict-alignment targets.  */\n \n static bool\n-tree_non_mode_aligned_mem_p (tree exp)\n+tree_non_aligned_mem_p (tree exp, unsigned int align)\n {\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-  unsigned int align;\n+  unsigned int exp_align;\n \n   if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n     exp = TREE_OPERAND (exp, 0);\n \n-  if (TREE_CODE (exp) == SSA_NAME\n-      || TREE_CODE (exp) == MEM_REF\n-      || mode == BLKmode\n-      || is_gimple_min_invariant (exp)\n-      || !STRICT_ALIGNMENT)\n+  if (TREE_CODE (exp) == SSA_NAME || is_gimple_min_invariant (exp))\n     return false;\n \n-  align = get_object_alignment (exp);\n-  if (GET_MODE_ALIGNMENT (mode) > align)\n+  /* get_object_alignment will fall back to BITS_PER_UNIT if it cannot\n+     compute an explicit alignment.  Pretend that dereferenced pointers\n+     are always aligned on strict-alignment targets.  */\n+  if (TREE_CODE (exp) == MEM_REF || TREE_CODE (exp) == TARGET_MEM_REF)\n+    exp_align = get_object_or_type_alignment (exp);\n+  else\n+    exp_align = get_object_alignment (exp);\n+\n+  if (exp_align < align)\n     return true;\n \n   return false;\n@@ -1120,7 +1123,9 @@ build_accesses_from_assign (gimple stmt)\n   if (lacc)\n     {\n       lacc->grp_assignment_write = 1;\n-      lacc->grp_unscalarizable_region |= tree_non_mode_aligned_mem_p (rhs);\n+      if (STRICT_ALIGNMENT\n+\t  && tree_non_aligned_mem_p (rhs, get_object_alignment (lhs)))\n+        lacc->grp_unscalarizable_region = 1;\n     }\n \n   if (racc)\n@@ -1129,7 +1134,9 @@ build_accesses_from_assign (gimple stmt)\n       if (should_scalarize_away_bitmap && !gimple_has_volatile_ops (stmt)\n \t  && !is_gimple_reg_type (racc->type))\n \tbitmap_set_bit (should_scalarize_away_bitmap, DECL_UID (racc->base));\n-      racc->grp_unscalarizable_region |= tree_non_mode_aligned_mem_p (lhs);\n+      if (STRICT_ALIGNMENT\n+\t  && tree_non_aligned_mem_p (lhs, get_object_alignment (rhs)))\n+        racc->grp_unscalarizable_region = 1;\n     }\n \n   if (lacc && racc\n@@ -3705,7 +3712,8 @@ access_precludes_ipa_sra_p (struct access *access)\n \t  || gimple_code (access->stmt) == GIMPLE_ASM))\n     return true;\n \n-  if (tree_non_mode_aligned_mem_p (access->expr))\n+  if (STRICT_ALIGNMENT\n+      && tree_non_aligned_mem_p (access->expr, TYPE_ALIGN (access->type)))\n     return true;\n \n   return false;"}, {"sha": "a72a3f613e461f3ecd543e3062e665850742394b", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908b951938511131cf3858c75924db323de415ea/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908b951938511131cf3858c75924db323de415ea/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=908b951938511131cf3858c75924db323de415ea", "patch": "@@ -5457,6 +5457,7 @@ extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern bool is_builtin_fn (tree);\n extern unsigned int get_object_alignment_1 (tree, unsigned HOST_WIDE_INT *);\n extern unsigned int get_object_alignment (tree);\n+extern unsigned int get_object_or_type_alignment (tree);\n extern unsigned int get_pointer_alignment (tree);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);"}]}