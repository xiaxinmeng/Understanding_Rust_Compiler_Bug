{"sha": "990bee10e7f467d0a2eaed58363b69896553a648", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkwYmVlMTBlN2Y0NjdkMGEyZWFlZDU4MzYzYjY5ODk2NTUzYTY0OA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-12-14T18:45:35Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-12-14T18:45:35Z"}, "message": "Warning fixes:\n\n\t* compress.c: Include stdlib.h and compress.h.\n\t(rcsid): Delete.\n\t(report_str_error): Make static.\n\t(ez_inflate_str): Delete unused variable.  Add parens in if-stmt.\n\t(hrd_inflate_str): Likewise.\n\n\t* compress.h (init_compression, end_compression, init_inflation,\n\tend_inflation): Prototype void arguments.\n\n\t* dostime.c (rcsid): Delete.\n\n\t* jargrep.c: Include ctype.h, stdlib.h, zlib.h and compress.h.\n\tMake functions static.  Cast ctype function argument to `unsigned\n\tchar'.  Add parens in if-stmts.  Constify.\n\t(Usage): Change into a macro.\n\t(jargrep): Remove unused parameter.\n\n\t* jartool.c: Constify.  Add parens in if-stmts.  Align\n\tsigned/unsigned char pointers in functions calls using casts.\n\t(rcsid): Delete.\n\t(list_jar): Fix printf format specifier.\n\t(usage): Chop long string into bits.  Reformat.\n\n\t* pushback.c (rcsid): Delete.\n\nFrom-SVN: r38254", "tree": {"sha": "4038c59b8993142fec6dcdc3b59d41af2314c771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4038c59b8993142fec6dcdc3b59d41af2314c771"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/990bee10e7f467d0a2eaed58363b69896553a648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/990bee10e7f467d0a2eaed58363b69896553a648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/990bee10e7f467d0a2eaed58363b69896553a648", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/990bee10e7f467d0a2eaed58363b69896553a648/comments", "author": null, "committer": null, "parents": [{"sha": "ad46e8819b6ff19173ded53b8415e8ca89a82275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad46e8819b6ff19173ded53b8415e8ca89a82275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad46e8819b6ff19173ded53b8415e8ca89a82275"}], "stats": {"total": 266, "additions": 181, "deletions": 85}, "files": [{"sha": "f06b120afe911ffcc9c91e620a3a168a16b43243", "filename": "fastjar/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2FChangeLog?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -1,3 +1,30 @@\n+2000-12-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* compress.c: Include stdlib.h and compress.h.\n+\t(rcsid): Delete.\n+\t(report_str_error): Make static.\n+\t(ez_inflate_str): Delete unused variable.  Add parens in if-stmt.\n+\t(hrd_inflate_str): Likewise.\n+\n+\t* compress.h (init_compression, end_compression, init_inflation,\n+\tend_inflation): Prototype void arguments.\n+\n+\t* dostime.c (rcsid): Delete.\n+\n+\t* jargrep.c: Include ctype.h, stdlib.h, zlib.h and compress.h.\n+\tMake functions static.  Cast ctype function argument to `unsigned\n+\tchar'.  Add parens in if-stmts.  Constify.\n+\t(Usage): Change into a macro.\n+\t(jargrep): Remove unused parameter.\n+\n+\t* jartool.c: Constify.  Add parens in if-stmts.  Align\n+\tsigned/unsigned char pointers in functions calls using casts.\n+\t(rcsid): Delete.\n+\t(list_jar): Fix printf format specifier.\n+\t(usage): Chop long string into bits.  Reformat.\n+\n+\t* pushback.c (rcsid): Delete.\n+\n 2000-12-13  Tom Tromey  <tromey@redhat.com>\n \n \t* jartool.c (extract_jar): Use strchr, not index."}, {"sha": "e88eff5ee4a28c7356a70445bed63509528901aa", "filename": "fastjar/compress.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fcompress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fcompress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fcompress.c?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -1,6 +1,11 @@\n-/* $Id: compress.c,v 1.7 2000/09/13 14:02:02 cory Exp $\n+/* $Id: compress.c,v 1.1 2000/12/09 03:08:23 apbianco Exp $\n \n    $Log: compress.c,v $\n+   Revision 1.1  2000/12/09 03:08:23  apbianco\n+   2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+           * fastjar: Imported.\n+\n    Revision 1.7  2000/09/13 14:02:02  cory\n    Reformatted some of the code to more closly match the layout of the orriginal\n    fastjar utility.\n@@ -67,16 +72,18 @@\n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n+#ifdef STDC_HEADERS\n+#include <stdlib.h>\n+#endif\n \n #include <sys/types.h>\n \n #include \"jartool.h\"\n #include \"pushback.h\"\n+#include \"compress.h\"\n \n extern int seekable;\n \n-static char rcsid[] = \"$Id: compress.c,v 1.7 2000/09/13 14:02:02 cory Exp $\";\n-\n static z_stream zs;\n \n void init_compression(){\n@@ -335,7 +342,7 @@ purpose: Put out an error message corresponding to error code returned from zlib\n Be suitably cryptic seeing I don't really know exactly what these errors mean.\n */\n \n-void report_str_error(int val) {\n+static void report_str_error(int val) {\n \tswitch(val) {\n \tcase Z_STREAM_END:\n \t\tbreak;\n@@ -376,10 +383,9 @@ static Bytef *ez_inflate_str(pb_file *pbf, ub4 csize, ub4 usize) {\n \tBytef *out_buff;\n \tBytef *in_buff;\n \tunsigned int rdamt;\n-\tub4 crc = 0;\n \n-\tif(zs.next_in = in_buff = (Bytef *) malloc(csize)) {\n-\t\tif(zs.next_out = out_buff = (Bytef *) malloc(usize + 1)) { \n+\tif((zs.next_in = in_buff = (Bytef *) malloc(csize))) {\n+\t\tif((zs.next_out = out_buff = (Bytef *) malloc(usize + 1))) { \n \t\t\tif((rdamt = pb_read(pbf, zs.next_in, csize)) == csize) {\n \t\t\t\tzs.avail_in = csize;\n \t\t\t\tzs.avail_out = usize;\n@@ -430,7 +436,6 @@ static Bytef *hrd_inflate_str(pb_file *pbf, ub4 *csize, ub4 *usize) {\n \tunsigned int rdamt;\n \tint i;\n \tint zret;\n-\tub4 crc = 0;\n \n \ti = 1; \n \tout_buff = NULL;\n@@ -441,7 +446,7 @@ static Bytef *hrd_inflate_str(pb_file *pbf, ub4 *csize, ub4 *usize) {\n \t\tzs.avail_out = 0;\n \t\tzs.next_in = in_buff;\n \t\tdo {\n-\t\t\tif(tmp = (Bytef *) realloc(out_buff, (RDSZ * i) + 1)) {\n+\t\t\tif((tmp = (Bytef *) realloc(out_buff, (RDSZ * i) + 1))) {\n \t\t\t\tout_buff = tmp;\n \t\t\t\tzs.next_out = &(out_buff[(RDSZ * (i - 1)) - zs.avail_out]);\n \t\t\t\tzs.avail_out += RDSZ;"}, {"sha": "9b3341e5ae942f5eb9bb90ccd4cdfef2930da9ea", "filename": "fastjar/compress.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fcompress.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fcompress.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fcompress.h?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -1,6 +1,11 @@\n-/* $Id: compress.h,v 1.1.1.1 1999/12/06 03:09:12 toast Exp $\n+/* $Id: compress.h,v 1.1 2000/12/09 03:08:23 apbianco Exp $\n \n    $Log: compress.h,v $\n+   Revision 1.1  2000/12/09 03:08:23  apbianco\n+   2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+           * fastjar: Imported.\n+\n    Revision 1.1.1.1  1999/12/06 03:09:12  toast\n    initial checkin..\n \n@@ -38,14 +43,15 @@\n  */\n \n /* Initializes the compression data structure(s) */\n-void init_compression();\n+void init_compression(void);\n \n /* Compresses the file specified by in_fd and appends it to out_fd */\n int compress_file(int in_fd, int out_fd, struct zipentry *ze);\n \n /* Frees memory used by compression function */\n-void end_compression();\n+void end_compression(void);\n \n-void init_inflation();\n+void init_inflation(void);\n int inflate_file(pb_file *, int, struct zipentry *);\n-void end_inflation();\n+void end_inflation(void);\n+Bytef *inflate_string(pb_file *, ub4 *, ub4 *);"}, {"sha": "834ef4284aaddf3c40f2edb455a1236d9ebb2659", "filename": "fastjar/dostime.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fdostime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fdostime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fdostime.c?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -20,9 +20,14 @@\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n \n-/* $Id: dostime.c,v 1.1.1.1 1999/12/06 03:09:12 toast Exp $\n+/* $Id: dostime.c,v 1.1 2000/12/09 03:08:23 apbianco Exp $\n \n    $Log: dostime.c,v $\n+   Revision 1.1  2000/12/09 03:08:23  apbianco\n+   2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+           * fastjar: Imported.\n+\n    Revision 1.1.1.1  1999/12/06 03:09:12  toast\n    initial checkin..\n \n@@ -55,8 +60,6 @@\n \n #include \"dostime.h\"\n \n-static char rcsid[] = \"$Id: dostime.c,v 1.1.1.1 1999/12/06 03:09:12 toast Exp $\";\n-\n /*\n \n  Copyright (C) 1990-1997 Mark Adler, Richard B. Wales, Jean-loup Gailly,"}, {"sha": "1f40eb3576d4d697f6bd9bc224d6b525392e1628", "filename": "fastjar/jargrep.c", "status": "modified", "additions": 54, "deletions": 33, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fjargrep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fjargrep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fjargrep.c?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -21,9 +21,21 @@\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n \n-/* $Id: jargrep.c,v 1.1 2000/12/09 03:08:23 apbianco Exp $\n+/* $Id: jargrep.c,v 1.2 2000/12/11 02:59:55 apbianco Exp $\n \n $Log: jargrep.c,v $\n+Revision 1.2  2000/12/11 02:59:55  apbianco\n+2000-12-10  Robert Lipe <robertlipe@usa.net>\n+\n+\t* jargrep.c (jargrep): Added null statement after case.\n+\n+2000-12-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* Makefile: Removed.\n+\t* Makefile.in: Rebuilt with `-i' and `--enable-foreign'.\n+\n+(http://gcc.gnu.org/ml/gcc/2000-12/msg00294.html)\n+\n Revision 1.1  2000/12/09 03:08:23  apbianco\n 2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n@@ -49,12 +61,18 @@ will test some other platforms later.\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <fcntl.h>\n+#include <ctype.h>\n+#ifdef STDC_HEADERS\n+#include <stdlib.h>\n+#endif\n #include \"jargrep.h\"\n #include \"jartool.h\"\n #include \"pushback.h\"\n #include \"zipfile.h\"\n+#include \"zlib.h\"\n+#include \"compress.h\"\n \n-char *Usage = { \"Usage: %s [-bcinsw] <-e regexp | regexp> file(s)\\n\" };\n+#define Usage \"Usage: %s [-bcinsw] <-e regexp | regexp> file(s)\\n\"\n \n extern char *optarg;\n \n@@ -66,7 +84,7 @@ together.\n returns: TRUE if options are valid, FALSE otherwise.\n */\n \n-int opt_valid(int options) {\n+static int opt_valid(int options) {\n \tint retflag;\n \n \tif((options & JG_PRINT_COUNT) && \n@@ -90,18 +108,17 @@ expression.\n returns: Newly allocated compile regular expression ready to be used in an regexec call.\n */\n \n-regex_t *create_regexp(char *regstr, int options) {\n+static regex_t *create_regexp(const char *regstr, int options) {\n \tregex_t *exp;\n-\tint exp_flags = 0;\n \tint errcode;\n \tint msgsize;\n \tchar *errmsg;\n \n-\tif(exp = (regex_t *) malloc(sizeof(regex_t)))\n+\tif((exp = (regex_t *) malloc(sizeof(regex_t))))\n \t{\n-\t\tif(errcode = regcomp(exp, regstr, (options & JG_IGNORE_CASE) ? REG_ICASE : 0)) {\n+\t\tif((errcode = regcomp(exp, regstr, (options & JG_IGNORE_CASE) ? REG_ICASE : 0))) {\n \t\t\tfprintf(stderr, \"regcomp of regex failed,\\n\");\n-\t\t\tif(errmsg = (char *) malloc(msgsize = regerror(errcode, exp, NULL, 0) + 1)) {\n+\t\t\tif((errmsg = (char *) malloc(msgsize = regerror(errcode, exp, NULL, 0) + 1))) {\n \t\t\t\tregerror(errcode, exp, errmsg, msgsize);\n \t\t\t\tfprintf(stderr, \"Error: %s\\n\", errmsg);\n \t\t\t\tfree(exp);\n@@ -135,7 +152,7 @@ we have read beyound the embedded file list and can exit knowing we have read al\n relevent information.  2 means we still haven't reached embdedded file list and need to\n do some more reading.\n */\n-int check_sig(ub1 *scratch, pb_file *pbfp) {\n+static int check_sig(ub1 *scratch, pb_file *pbfp) {\n \tub4 signature;\n \tint retflag = 0;\n \n@@ -175,7 +192,7 @@ args\tcsize\t\tPointer to embedded file's compressed size.\n Purpose: Unpack the series of values from file_header.\n */\n \n-void decd_siz(ub4 *csize, ub4 *usize, ub2 *fnlen, ub2 *eflen, ub2 *flags, ub2 *method, ub1 *file_header) {\n+static void decd_siz(ub4 *csize, ub4 *usize, ub2 *fnlen, ub2 *eflen, ub2 *flags, ub2 *method, ub1 *file_header) {\n     *csize = UNPACK_UB4(file_header, LOC_CSIZE);\n #ifdef DEBUG    \n     printf(\"Compressed size is %u\\n\", *csize);\n@@ -216,7 +233,7 @@ purpose:\tRead in the embedded file name from jar file.\n returns: Pointer to newly allocated string containing file name.\n */\n \n-char *new_filename(pb_file *pbf, ub4 len) {\n+static char *new_filename(pb_file *pbf, ub4 len) {\n \tchar *filename;\n \n \tif(!(filename = (char *) malloc(len + 1))) {\n@@ -241,10 +258,10 @@ purpose:\tCreate a string containing the contents of the embedded noncompressed f\n returns: Pointer to newly allocated string containing embedded file contents.\n */\n \n-char *read_string(pb_file *pbf, int size) {\n+static char *read_string(pb_file *pbf, int size) {\n \tchar *page;\n \t\n-\tif(page = (char *) malloc(size + 1)) {\n+\tif((page = (char *) malloc(size + 1))) {\n \t\tpb_read(pbf, page, size);\n \t\tpage[size] = '\\0';\n \t}\n@@ -270,16 +287,16 @@ The matching line that is printed out by jargrep is generated by this function.\n returns: Pointer to newly allocated string containing matched expression.\n */\n \n-char *extract_line(char *stream, regoff_t begin, regoff_t end, int *b) {\n+static char *extract_line(const char *stream, regoff_t begin, regoff_t end, int *b) {\n \tint e;\n \tint length;\n \tchar *retstr;\n \n-\tfor(*b = begin; *b >= 0 && !iscntrl(stream[*b]); (*b)--);\n+\tfor(*b = begin; *b >= 0 && !iscntrl((unsigned char)stream[*b]); (*b)--);\n \t(*b)++;\n-\tfor(e = end; stream[e] == '\\t' || !iscntrl(stream[e]); e++);\n+\tfor(e = end; stream[e] == '\\t' || !iscntrl((unsigned char)stream[e]); e++);\n \tlength = e - *b;\n-\tif(retstr = (char *) malloc(length + 1)) {\n+\tif((retstr = (char *) malloc(length + 1))) {\n \t\tsprintf(retstr, \"%d:\", *b);\n \t\tstrncpy(retstr, &(stream[*b]), length);\n \t\tretstr[length] = '\\0';\n@@ -302,24 +319,26 @@ word and not a substring of another word.\n returns: TRUE if it is a word, FALSE of it is a substring.\n */\n \n-int chk_wrd(regex_t *exp, char *str) {\n+static int chk_wrd(regex_t *exp, const char *str) {\n \tint wrd_fnd = FALSE;\n \tint regflag;\n \tint frnt_ok;\n \tint bck_ok;\n-\tchar *str2;\n+\tconst char *str2;\n \tregmatch_t match;\n \n \tstr2 = str;\n \tfrnt_ok = bck_ok = FALSE;\n \twhile(!wrd_fnd && !(regflag = regexec(exp, str2, 1, &match, 0))) {\n \t\tif(!match.rm_so && (str2 == str)) frnt_ok = TRUE;\n-\t\telse if(!isalnum(str2[match.rm_so - 1]) && str2[match.rm_so - 1] != '_')\n+\t\telse if(!isalnum((unsigned char)str2[match.rm_so - 1])\n+\t\t\t&& str2[match.rm_so - 1] != '_')\n \t\t\tfrnt_ok = TRUE;\n \t\telse frnt_ok = FALSE;\n \t\tif(frnt_ok) {\n \t\t\tif(str2[match.rm_eo] == '\\0') bck_ok = TRUE;\n-\t\t\telse if(!isalnum(str2[match.rm_eo]) && str2[match.rm_eo] != '_')\n+\t\t\telse if(!isalnum((unsigned char)str2[match.rm_eo])\n+\t\t\t\t&& str2[match.rm_eo] != '_')\n \t\t\t\tbck_ok = TRUE;\n \t\t\telse bck_ok = FALSE;\n \t\t}\n@@ -348,7 +367,7 @@ purpose:\tControl output of jargrep.  Output is controlled by which options have\n set at the command line.\n */\n \n-void prnt_mtchs(regex_t *exp, char *filename, char *stream, regmatch_t *pmatch, regmatch_t *nl_offset, int num, int lines, int options) {\n+static void prnt_mtchs(regex_t *exp, const char *filename, const char *stream, regmatch_t *pmatch, regmatch_t *nl_offset, int num, int lines, int options) {\n \tint i;\n \tint j = 0;\n \tint ln_cnt;\n@@ -388,13 +407,13 @@ args:\tpbf\t\tPointer to pushback file pointer for jar file.\n purpose:\tVerify the CRC matches that as what is stored in the jar file.\n */\n \n-void check_crc(pb_file *pbf, char *stream, ub4 usize) {\n+static void check_crc(pb_file *pbf, const char *stream, ub4 usize) {\n \tub4 crc;\n \tub4 lcrc;\n \tub1 scratch[16];\n \n \tcrc = crc32(crc, NULL, 0);\n-\tcrc = crc32(crc, stream, usize);\n+\tcrc = crc32(crc, (const unsigned char *)stream, usize);\n \tif(pb_read(pbf, scratch, 16) != 16) {\n \t\tperror(\"read\");\n         exit(1);\n@@ -420,11 +439,13 @@ permits grepping of binary files as well by converting non ASCII and control cha\n into '\\n'.\n */\n \n-void mk_ascii(char *stream, int usize) {\n-\tint i;\n+static void mk_ascii(char *stream, size_t usize) {\n+\tsize_t i;\n \n \tfor(i = 0; i < usize; i++) \n-\t\tif(stream[i] != '\\t' && (iscntrl(stream[i]) || (unsigned char) stream[i] >= 128))\n+\t\tif(stream[i] != '\\t'\n+\t\t   && (iscntrl((unsigned char)stream[i])\n+\t\t       || (unsigned char) stream[i] >= 128))\n \t\t\tstream[i] = '\\n';\n }\n \n@@ -439,7 +460,7 @@ returns:  Pointer to newly allocated array of regmatch_t which gives indexes to\n and end of matches.  NULL is returned upon no matches found.\n */\n \n-regmatch_t *fnd_match(regex_t *exp, char *str_stream, int *i) {\n+static regmatch_t *fnd_match(regex_t *exp, const char *str_stream, int *i) {\n \tint regflag;\n \tregmatch_t match;\n \tregmatch_t *match_array;\n@@ -449,8 +470,8 @@ regmatch_t *fnd_match(regex_t *exp, char *str_stream, int *i) {\n \tfor(*i = 0, regflag = regexec(exp, str_stream, 1, &match, 0); !regflag; \n \t\tregflag = regexec(exp, &(str_stream[match.rm_eo]), 1, &match, 0), (*i)++)\n \t{\n-\t\tif(tmp = (regmatch_t *) \n-\t\t\trealloc(match_array, sizeof(regmatch_t) * ((*i) + 1))) \n+\t\tif((tmp = (regmatch_t *) \n+\t\t    realloc(match_array, sizeof(regmatch_t) * ((*i) + 1))))\n \t\t{\n \t\t\tmatch_array = tmp;\n \t\t\tif(*i) {\n@@ -483,7 +504,7 @@ read and then the embeded file is extracted and grepped.\n returns: FALSE upon failure, TRUE otherwise.\n */\n \n-int cont_grep(regex_t *exp, regex_t *nl_exp, int fd, char *jarfile, pb_file *pbf, int options) {\n+static int cont_grep(regex_t *exp, regex_t *nl_exp, int fd, pb_file *pbf, int options) {\n \tint retflag = TRUE;\n \tint i;\n \tint j;\n@@ -538,7 +559,7 @@ purpose:\tOpen jar file.  Check signatures.  When right signature is found go to\n grep routine.\n */\n \n-void jargrep(regex_t *exp, regex_t *nl_exp, char *jarfile, int options) {\n+static void jargrep(regex_t *exp, regex_t *nl_exp, const char *jarfile, int options){\n \tint fd;\n \tint floop = TRUE;\n \tpb_file pbf;\n@@ -559,7 +580,7 @@ void jargrep(regex_t *exp, regex_t *nl_exp, char *jarfile, int options) {\n \t\t\telse {\n \t\t\t\tswitch (check_sig(scratch, &pbf)) {\n \t\t\t\tcase 0:\n-\t\t\t\t\tfloop = cont_grep(exp, nl_exp, fd, jarfile, &pbf, options);\n+\t\t\t\t\tfloop = cont_grep(exp, nl_exp, fd, &pbf, options);\n \t\t\t\t\tbreak;\n \t\t\t\tcase 1:\n \t\t\t\t\tfloop = FALSE;"}, {"sha": "5a5f235388a9aef041a51cb14ea998b4869a6e06", "filename": "fastjar/jartool.c", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fjartool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fjartool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fjartool.c?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -17,9 +17,12 @@\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n \n-/* $Id: jartool.c,v 1.1 2000/12/09 03:08:23 apbianco Exp $\n+/* $Id: jartool.c,v 1.2 2000/12/13 18:11:57 tromey Exp $\n \n    $Log: jartool.c,v $\n+   Revision 1.2  2000/12/13 18:11:57  tromey\n+   \t* jartool.c (extract_jar): Use strchr, not index.\n+\n    Revision 1.1  2000/12/09 03:08:23  apbianco\n    2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n@@ -169,23 +172,22 @@\n #endif\n \n static char version_string[] = VERSION;\n-static char rcsid[] = \"$Id: jartool.c,v 1.1 2000/12/09 03:08:23 apbianco Exp $\";\n \n extern int errno;\n \n-void usage(char*);\n+void usage(const char*);\n void add_entry(struct zipentry *);\n-void init_headers();\n+void init_headers(void);\n \n int consume(pb_file *, int);\n int list_jar(int, char**, int);\n int extract_jar(int, char**, int);\n-int add_file_to_jar(int, int, char*, struct stat*);\n-int add_to_jar(int, char*, char*);\n+int add_file_to_jar(int, int, const char*, struct stat*);\n+int add_to_jar(int, const char*, const char*);\n int create_central_header(int);\n-int make_manifest(int, char*);\n+int make_manifest(int, const char*);\n static void init_args(char **, int);\n-static char *get_next_arg ();\n+static char *get_next_arg (void);\n \n /* global variables */\n ub1 file_header[30];\n@@ -371,7 +373,7 @@ int main(int argc, char **argv){\n   }\n \n   if(action == ACTION_CREATE || action == ACTION_UPDATE){\n-    char *arg;\n+    const char *arg;\n     init_headers();\n \n    if((action == ACTION_UPDATE) && file) {\n@@ -397,8 +399,8 @@ int main(int argc, char **argv){\n     while ((arg = get_next_arg ())){\n \n       if(!strcmp(arg, \"-C\")){\n-\tchar *dir_to_change = get_next_arg ();\n-\tchar *file_to_add = get_next_arg ();\n+\tconst char *dir_to_change = get_next_arg ();\n+\tconst char *file_to_add = get_next_arg ();\n         if(!dir_to_change \n \t   || !file_to_add\n \t   || add_to_jar(jarfd, dir_to_change, file_to_add)){\n@@ -570,7 +572,7 @@ void add_entry(struct zipentry *ze){\n   number_of_entries++;\n }\n \n-int make_manifest(int jfd, char *mf_name){\n+int make_manifest(int jfd, const char *mf_name){\n   time_t current_time;\n   int nlen;   /* length of file name */\n   int mod_time; /* file modification time */\n@@ -622,14 +624,14 @@ int make_manifest(int jfd, char *mf_name){\n     int mf_len = 37 + strlen(VERSION);\n     char *mf;\n \n-    if(mf = (char *) malloc(mf_len + 1)) {\n+    if((mf = (char *) malloc(mf_len + 1))) {\n     uLong crc;\n \n     sprintf(mf, \"Manifest-Version: 1.0\\nCreated-By: %s\\n\\n\", VERSION);\n \n     crc = crc32(0L, Z_NULL, 0);\n     \n-    crc = crc32(crc, mf, mf_len);\n+    crc = crc32(crc, (const unsigned char *)mf, mf_len);\n \n     nlen = 20;  /* once again, trust me */\n \n@@ -703,7 +705,7 @@ int make_manifest(int jfd, char *mf_name){\n   return 0;\n }\n \n-int add_to_jar(int fd, char *new_dir, char *file){\n+int add_to_jar(int fd, const char *new_dir, const char *file){\n   struct stat statbuf;\n   DIR *dir;\n   struct dirent *de;\n@@ -857,7 +859,7 @@ int add_to_jar(int fd, char *new_dir, char *file){\n   return 0;\n }\n \n-int add_file_to_jar(int jfd, int ffd, char *fname, struct stat *statbuf){\n+int add_file_to_jar(int jfd, int ffd, const char *fname, struct stat *statbuf){\n \n   unsigned short file_name_length;\n   unsigned long mod_time;\n@@ -1259,7 +1261,7 @@ int extract_jar(int fd, char **files, int file_num){\n       handle = FALSE;\n       \n       for(j = 0; j < file_num; j++)\n-        if(strcmp(files[j], filename) == 0){\n+        if(strcmp(files[j], (const char *)filename) == 0){\n           handle = TRUE;\n           break;\n         }\n@@ -1271,16 +1273,16 @@ int extract_jar(int fd, char **files, int file_num){\n     /* OK, there is some directory information in the file.  Nothing to do\n        but ensure the directory(s) exist, and create them if they don't.\n        What a pain! */\n-    if(strchr(filename, '/') != NULL && handle){\n+    if(strchr((const char *)filename, '/') != NULL && handle){\n       /* Loop through all the directories in the path, (everything w/ a '/') */\n-      ub1 *start = filename;\n+      const ub1 *start = filename;\n       char *tmp_buff;\n       struct stat sbuf;\n \n-      tmp_buff = malloc(sizeof(char) * strlen(filename));\n+      tmp_buff = malloc(sizeof(char) * strlen((const char *)filename));\n \n       for(;;){\n-        ub1 *idx = strchr(start, '/');\n+        const ub1 *idx = (const unsigned char *)strchr((const char *)start, '/');\n \n         if(idx == NULL)\n           break;\n@@ -1290,7 +1292,7 @@ int extract_jar(int fd, char **files, int file_num){\n         }\n         start = idx + 1;\n \n-        strncpy(tmp_buff, filename, (idx - filename));\n+        strncpy(tmp_buff, (const char *)filename, (idx - filename));\n         tmp_buff[(idx - filename)] = '\\0';\n \n #ifdef DEBUG    \n@@ -1327,26 +1329,26 @@ int extract_jar(int fd, char **files, int file_num){\n       }\n \n       /* only a directory */\n-      if(strlen(start) == 0)\n+      if(strlen((const char *)start) == 0)\n         dir = TRUE;\n \n #ifdef DEBUG    \n-      printf(\"Leftovers are \\\"%s\\\" (%d)\\n\", start, strlen(start));\n+      printf(\"Leftovers are \\\"%s\\\" (%d)\\n\", start, strlen((const char *)start));\n #endif\n \n       /* If the entry was just a directory, don't write to file, etc */\n-      if(strlen(start) == 0)\n+      if(strlen((const char *)start) == 0)\n         f_fd = -1;\n \n       free(tmp_buff);\n     }\n \n     if(f_fd != -1 && handle){\n-      f_fd = creat(filename, 00644);\n+      f_fd = creat((const char *)filename, 00644);\n \n       if(f_fd < 0){\n         fprintf(stderr, \"Error extracting JAR archive!\\n\");\n-        perror(filename);\n+        perror((const char *)filename);\n         exit(1);\n       }\n     }\n@@ -1568,7 +1570,7 @@ int list_jar(int fd, char **files, int file_num){\n          we'll only display those, otherwise we'll display everything */\n       if(file_num > 0){\n         for(j = 0; j < file_num; j++)\n-          if(strcmp(files[j], filename) == 0){\n+          if(strcmp(files[j], (const char *)filename) == 0){\n             if(verbose)\n               printf(\"%6d %s %s\\n\", usize, ascii_date, filename);\n             else\n@@ -1705,15 +1707,15 @@ int list_jar(int fd, char **files, int file_num){\n         \n \n #ifdef DEBUG\n-        printf(\"Skipping %d bytes\\n\", size);\n+        printf(\"Skipping %ld bytes\\n\", (long)size);\n #endif\n \n         consume(&pbf, size);\n       }\n       /* print out the listing */\n       if(file_num > 0){\n         for(j = 0; j < file_num; j++)\n-          if(strcmp(files[j], filename) == 0){\n+          if(strcmp(files[j], (const char *)filename) == 0){\n             if(verbose)\n               printf(\"%6d %s %s\\n\", usize, ascii_date, filename);\n             else\n@@ -1755,8 +1757,37 @@ int consume(pb_file *pbf, int amt){\n   return 0;\n }\n \n-void usage(char *filename){\n-  fprintf(stderr, \"Usage: %s {ctxuV}[vfm0ME@] [jar-file] [manifest-file] [-C dir] files ...\\nOptions\\n -c  create new archive\\n -t  list table of contents for archive\\n -x  extract named (or all) files from archive\\n -u  update existing archive\\n -V  display version information\\n -v  generate verbose output on standard output\\n -f  specify archive file name\\n -m  include manifest information from specified manifest file\\n -0  store only; use no ZIP compression\\n -M  Do not create a manifest file for the entries\\n -C  change to the specified directory and include the following file\\n -E  don't include the files found in a directory\\n -@  Read names from stdin\\nIf any file is a directory then it is processed recursively.\\nThe manifest file name and the archive file name needs to be specified\\nin the same order the 'm' and 'f' flags are specified.\\n\\nExample 1: to archive two class files into an archive called classes.jar: \\n     jar cvf classes.jar Foo.class Bar.class \\nExample 2: use an existing manifest file 'mymanifest' and archive all the\\n     files in the foo/ directory into 'classes.jar': \\n     jar cvfm classes.jar mymanifest -C foo/ .\\n\", filename);\n+void usage(const char *filename){\n+  fprintf(stderr, \"\\\n+Usage: %s {ctxuV}[vfm0ME@] [jar-file] [manifest-file] [-C dir] files ...\\n\\\n+Options\\n\\\n+ -c  create new archive\\n\\\n+ -t  list table of contents for archive\\n\\\n+ -x  extract named (or all) files from archive\\n\\\n+\", filename);\n+  fprintf(stderr, \"\\\n+ -u  update existing archive\\n\\\n+ -V  display version information\\n\\\n+ -v  generate verbose output on standard output\\n\\\n+ -f  specify archive file name\\n\\\n+ -m  include manifest information from specified manifest file\\n\\\n+ -0  store only; use no ZIP compression\\n\\\n+ -M  Do not create a manifest file for the entries\\n\\\n+ -C  change to the specified directory and include the following file\\n\\\n+ -E  don't include the files found in a directory\\n\\\n+ -@  Read names from stdin\\n\\\n+\");\n+  fprintf(stderr, \"\\\n+If any file is a directory then it is processed recursively.\\n\\\n+The manifest file name and the archive file name needs to be specified\\n\\\n+in the same order the 'm' and 'f' flags are specified.\\n\\\n+\\n\\\n+Example 1: to archive two class files into an archive called classes.jar: \\n\\\n+     jar cvf classes.jar Foo.class Bar.class \\n\\\n+Example 2: use an existing manifest file 'mymanifest' and archive all the\\n\\\n+     files in the foo/ directory into 'classes.jar': \\n\\\n+     jar cvfm classes.jar mymanifest -C foo/ .\\n\\\n+\");\n \n   exit(1);\n }"}, {"sha": "26a267364a6e210cb3640b81dbfe1120a78ad40d", "filename": "fastjar/pushback.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fpushback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990bee10e7f467d0a2eaed58363b69896553a648/fastjar%2Fpushback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fastjar%2Fpushback.c?ref=990bee10e7f467d0a2eaed58363b69896553a648", "patch": "@@ -1,6 +1,11 @@\n-/* $Id: pushback.c,v 1.2 2000/08/23 19:42:17 cory Exp $\n+/* $Id: pushback.c,v 1.1 2000/12/09 03:08:23 apbianco Exp $\n \n    $Log: pushback.c,v $\n+   Revision 1.1  2000/12/09 03:08:23  apbianco\n+   2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+           * fastjar: Imported.\n+\n    Revision 1.2  2000/08/23 19:42:17  cory\n    Added support for more Unix platforms.  The following code has been hacked\n    to work on AIX, Solaris, True 64, and HP-UX.\n@@ -43,8 +48,6 @@\n #include \"jartool.h\"\n #include \"pushback.h\"\n \n-static char rcsid[] = \"$Id: pushback.c,v 1.2 2000/08/23 19:42:17 cory Exp $\";\n-\n void pb_init(pb_file *pbf, int fd){\n   pbf->fd = fd;\n   pbf->next = pbf->pb_buff;"}]}