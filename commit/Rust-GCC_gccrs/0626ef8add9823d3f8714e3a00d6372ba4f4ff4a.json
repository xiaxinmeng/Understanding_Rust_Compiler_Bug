{"sha": "0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYyNmVmOGFkZDk4MjNkM2Y4NzE0ZTNhMDBkNjM3MmJhNGY0ZmY0YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2001-12-05T01:39:41Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2001-12-05T01:39:41Z"}, "message": "rtl.h (initialize_uninitialized_subregs): New prototype.\n\n\n2001-12-04  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* rtl.h (initialize_uninitialized_subregs): New prototype.\n\t* toplev.c (rest_of_compilation): Call initialize_uninitialized_subregs\n\twhen optimization is on.\n\t* flow.c (find_regno_partial): Find subregs within an expression.\n\t(initialize_uninitialized_subregs): Initialize live on entry registers\n\twhich are used in subreg expressions.\n\nFrom-SVN: r47644", "tree": {"sha": "c7ac63b712fa3bf7681fd15b7941fa3e71cdc688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7ac63b712fa3bf7681fd15b7941fa3e71cdc688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/comments", "author": null, "committer": null, "parents": [{"sha": "ee0a48c5e8998fba3a4050c77794ef234793a1d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee0a48c5e8998fba3a4050c77794ef234793a1d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee0a48c5e8998fba3a4050c77794ef234793a1d2"}], "stats": {"total": 135, "additions": 132, "deletions": 3}, "files": [{"sha": "b39061469319309b6fdefc25b30505ed62ae8477", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "patch": "@@ -1,3 +1,12 @@\n+2001-12-04  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* rtl.h (initialize_uninitialized_subregs): New prototype.\n+\t* toplev.c (rest_of_compilation): Call initialize_uninitialized_subregs\n+\twhen optimization is on.\n+\t* flow.c (find_regno_partial): Find subregs within an expression.\n+\t(initialize_uninitialized_subregs): Initialize live on entry registers\n+\twhich are used in subreg expressions.\n+\n 2001-12-04  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* Makefile.in:  Add INSTALL_SCRIPT using INSTALL definition."}, {"sha": "cf7d4a0fda8f0ff9d99cd185653e668d29628543", "filename": "gcc/flow.c", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "patch": "@@ -306,6 +306,8 @@ static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t enum rtx_code, rtx, rtx,\n \t\t\t\t\t\t rtx, int));\n+static int find_regno_partial\t\tPARAMS ((rtx *, void *));\n+\n #ifdef HAVE_conditional_execution\n static int mark_regno_cond_dead\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t int, rtx));\n@@ -1290,6 +1292,112 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n   free (queue);\n }\n+\n+\f\n+/* This structure is used to pass parameters to an from the\n+   the function find_regno_partial(). It is used to pass in the \n+   register number we are looking, as well as to return any rtx \n+   we find.  */\n+\n+typedef struct {\n+  unsigned regno_to_find;\n+  rtx retval;\n+} find_regno_partial_param;\n+\n+\n+/* Find the rtx for the reg numbers specified in 'data' if it is\n+   part of an expression which only uses part of the register.  Return\n+   it in the structure passed in.  */\n+static int \n+find_regno_partial (ptr, data)\n+     rtx *ptr;\n+     void *data;\n+{\n+  find_regno_partial_param *param = (find_regno_partial_param *)data;\n+  unsigned reg = param->regno_to_find;\n+  param->retval = NULL_RTX;\n+\n+  if (*ptr == NULL_RTX)\n+    return 0;\n+\n+  switch (GET_CODE (*ptr)) \n+    {\n+      case ZERO_EXTRACT:\n+      case SIGN_EXTRACT:\n+      case STRICT_LOW_PART:\n+        if (GET_CODE (XEXP (*ptr, 0)) == REG && REGNO (XEXP (*ptr, 0)) == reg)\n+\t  {\n+\t    param->retval = *ptr;\n+\t    return 1;\n+\t  }\n+\tbreak;\n+\n+      case SUBREG:\n+        if (GET_CODE (SUBREG_REG (*ptr)) == REG \n+\t    && REGNO (SUBREG_REG (*ptr)) == reg)\n+\t  {\n+\t    param->retval = *ptr;\n+\t    return 1;\n+\t  }\n+\tbreak;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Process all immediate successors of the entry block looking for pseudo\n+   registers which are live on entry. Find all of those whose first \n+   instance is a partial register reference of some kind, and initialize \n+   them to 0 after the entry block.  This will prevent bit sets within\n+   registers whose value is unknown, and may contain some kind of sticky \n+   bits we don't want.  */\n+\n+int\n+initialize_uninitialized_subregs () \n+{\n+  rtx insn;\n+  edge e;\n+  int reg, did_something = 0;\n+  find_regno_partial_param param;\n+\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    {\n+      basic_block bb = e->dest;\n+      regset map = bb->global_live_at_start;\n+      EXECUTE_IF_SET_IN_REG_SET (map,\n+\t\t\t\t FIRST_PSEUDO_REGISTER, reg,\n+\t{\n+\t  int uid = REGNO_FIRST_UID (reg);\n+\t  rtx i;\n+\n+\t  /* Find an insn which mentions the register we are looking for.\n+\t     Its preferable to have an instance of the register's rtl since\n+\t     there may be various flags set which we need to duplicate.  \n+\t     If we can't find it, its probably an automatic whose initial\n+\t     value doesnt matter, or hopefully something we dont care about. */\n+\t  for (i = get_insns (); i && INSN_UID (i) != uid; i = NEXT_INSN (i))\n+\t    ;\n+\t  if (i != NULL_RTX)\n+\t    {\n+\t      /* Found the insn, now get the REG rtx, if we can.  */\n+\t      param.regno_to_find = reg;\n+\t      for_each_rtx (&i, find_regno_partial, &param);\n+\t      if (param.retval != NULL_RTX)\n+\t\t{\n+\t\t  insn = gen_move_insn (param.retval, \n+\t\t\t\t        CONST0_RTX (GET_MODE (param.retval)));\n+\t\t  insert_insn_on_edge (insn, e);\n+\t\t  did_something = 1;\n+\t\t}\n+\t    }\n+\t});\n+    }\n+\n+  if (did_something)\n+    commit_edge_insertions ();\n+  return did_something;\n+}\n+\n \f\n /* Subroutines of life analysis.  */\n "}, {"sha": "b76376ac5c61331eb201c4c77b04cf1369dabbc8", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "patch": "@@ -1903,10 +1903,11 @@ extern void move_by_pieces\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t unsigned int));\n \n /* In flow.c */\n-extern void recompute_reg_usage\t\tPARAMS ((rtx, int));\n+extern void recompute_reg_usage\t\t\tPARAMS ((rtx, int));\n+extern int initialize_uninitialized_subregs\tPARAMS ((void));\n #ifdef BUFSIZ\n-extern void print_rtl_with_bb\t\tPARAMS ((FILE *, rtx));\n-extern void dump_flow_info\t\tPARAMS ((FILE *));\n+extern void print_rtl_with_bb\t\t\tPARAMS ((FILE *, rtx));\n+extern void dump_flow_info\t\t\tPARAMS ((FILE *));\n #endif\n \n /* In expmed.c */"}, {"sha": "fc2e8b6cdabb69d4442385af47e5c32b93d00282", "filename": "gcc/toplev.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0626ef8add9823d3f8714e3a00d6372ba4f4ff4a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0626ef8add9823d3f8714e3a00d6372ba4f4ff4a", "patch": "@@ -3017,6 +3017,17 @@ rest_of_compilation (decl)\n \tsetjmp_args_warning ();\n     }\n \n+  if (optimize)\n+    {\n+      if (initialize_uninitialized_subregs ())\n+\t{\n+\t  /* Insns were inserted, so things might look a bit different.  */\n+\t  insns = get_insns();\n+\t  life_analysis (insns, rtl_dump_file, \n+\t\t\t (PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES));\n+\t}\n+    }\n+\n   close_dump_file (DFI_life, print_rtl_with_bb, insns);\n \n   ggc_collect ();"}]}