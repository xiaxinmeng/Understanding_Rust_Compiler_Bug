{"sha": "ff2efe85eb639b398d150365db037fedadecc4d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyZWZlODVlYjYzOWIzOThkMTUwMzY1ZGIwMzdmZWRhZGVjYzRkOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-25T15:26:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-25T15:26:02Z"}, "message": "[multiple changes]\n\n2010-10-25  Pascal Obry  <obry@adacore.com>\n\t\n\t* adaint.c (__gnat_file_time_name_attr): Use GetFileAttributesEx to get\n\tthe timestamp. A bit faster than opening/closing the file.\n\t(__gnat_stat_to_attr): Remove kludge for Windows.\n\t(__gnat_file_exists_attr): Likewise.\n\tThe timestamp is now retreived using GetFileAttributesEx as faster.\n\n2010-10-25  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Derive_Interface_Subprogram): New subprogram.\n\t(Derive_Subprograms): For abstract private types transfer to the full\n\tview entities of uncovered interface primitives. Required because if\n\tthe interface primitives are left in the private part of the package\n\tthey will be decorated as hidden when the analysis of the enclosing\n\tpackage completes (and hence the interface primitive is not visible\n\tfor dispatching calls).\n\n2010-10-25  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Added bounded set and bounded map\n\tcontainers.\n\t* a-crbltr.ads: Added declaration of generic package for bounded tree\n\ttypes.\n\t* a-rbtgbo.ads, a-rbtgbo.adb, a-rbtgbk.ads, a-rbtgbk.adb, a-btgbso.ads,\n\ta-btgbso.adb, a-cborse.ads, a-cborse.adb, a-cborma.ads, a-cborma.adb:\n\tNew.\n\n2010-10-25  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_util.adb: Minor reformatting.\n\t* usage.adb: Fix usage line for -gnatwh.\n\n2010-10-25  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Package_Instantiation): For an\n\tinstantiation in an RCI spec, omit package body if instantiation comes\n\tfrom source, even as a nested\n\tpackage.\n\t* exp_dist.adb (Add_Calling_Stubs_To_Declarations,\n\t*_Support.Add_Receiving_Stubs_To_Declarations): Handle the case of\n\tnested packages, package instantiations and subprogram instantiations.\n\nFrom-SVN: r165920", "tree": {"sha": "dbc2802781e13245b9de316aac743d8ec5a7862b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbc2802781e13245b9de316aac743d8ec5a7862b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2efe85eb639b398d150365db037fedadecc4d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2efe85eb639b398d150365db037fedadecc4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2efe85eb639b398d150365db037fedadecc4d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2efe85eb639b398d150365db037fedadecc4d8/comments", "author": null, "committer": null, "parents": [{"sha": "f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6b5dc8e1f88f71b3a523ff651bfdc32aa3c890b"}], "stats": {"total": 7274, "additions": 6942, "deletions": 332}, "files": [{"sha": "f772cf4878d708667bc749817883b337904fd8f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -1,3 +1,46 @@\n+2010-10-25  Pascal Obry  <obry@adacore.com>\n+\t\n+\t* adaint.c (__gnat_file_time_name_attr): Use GetFileAttributesEx to get\n+\tthe timestamp. A bit faster than opening/closing the file.\n+\t(__gnat_stat_to_attr): Remove kludge for Windows.\n+\t(__gnat_file_exists_attr): Likewise.\n+\tThe timestamp is now retreived using GetFileAttributesEx as faster.\n+\n+2010-10-25  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Derive_Interface_Subprogram): New subprogram.\n+\t(Derive_Subprograms): For abstract private types transfer to the full\n+\tview entities of uncovered interface primitives. Required because if\n+\tthe interface primitives are left in the private part of the package\n+\tthey will be decorated as hidden when the analysis of the enclosing\n+\tpackage completes (and hence the interface primitive is not visible\n+\tfor dispatching calls).\n+\n+2010-10-25  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Added bounded set and bounded map\n+\tcontainers.\n+\t* a-crbltr.ads: Added declaration of generic package for bounded tree\n+\ttypes.\n+\t* a-rbtgbo.ads, a-rbtgbo.adb, a-rbtgbk.ads, a-rbtgbk.adb, a-btgbso.ads,\n+\ta-btgbso.adb, a-cborse.ads, a-cborse.adb, a-cborma.ads, a-cborma.adb:\n+\tNew.\n+\n+2010-10-25  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_util.adb: Minor reformatting.\n+\t* usage.adb: Fix usage line for -gnatwh.\n+\n+2010-10-25  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Package_Instantiation): For an\n+\tinstantiation in an RCI spec, omit package body if instantiation comes\n+\tfrom source, even as a nested\n+\tpackage.\n+\t* exp_dist.adb (Add_Calling_Stubs_To_Declarations,\n+\t*_Support.Add_Receiving_Stubs_To_Declarations): Handle the case of\n+\tnested packages, package instantiations and subprogram instantiations.\n+\n 2010-10-25  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb (Expand_Predicated_Loop): Remove code for loop through"}, {"sha": "d5a2d0dc4bab85dc236b8534e4590e1a3caa1821", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -79,12 +79,15 @@ GNATRTL_TASKING_OBJS= \\\n # Objects needed for non-tasking.\n GNATRTL_NONTASKING_OBJS= \\\n   a-assert$(objext) \\\n+  a-btgbso$(objext) \\\n   a-calari$(objext) \\\n   a-calcon$(objext) \\\n   a-caldel$(objext) \\\n   a-calend$(objext) \\\n   a-calfor$(objext) \\\n   a-catizo$(objext) \\\n+  a-cborse$(objext) \\\n+  a-cborma$(objext) \\\n   a-cdlili$(objext) \\\n   a-cgaaso$(objext) \\\n   a-cgarso$(objext) \\\n@@ -180,6 +183,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-nuflra$(objext) \\\n   a-numaux$(objext) \\\n   a-numeri$(objext) \\\n+  a-rbtgbo$(objext) \\\n+  a-rbtgbk$(objext) \\\n   a-rbtgso$(objext) \\\n   a-scteio$(objext) \\\n   a-secain$(objext) \\"}, {"sha": "7d6ca3db779d55066984460481c3d62abff4d17c", "filename": "gcc/ada/a-btgbso.adb", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-btgbso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-btgbso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-btgbso.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,605 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--       ADA.CONTAINERS.RED_BLACK_TREES.GENERIC_BOUNDED_SET_OPERATIONS      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Copy (Source : Set_Type) return Set_Type;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Set_Type) return Set_Type is\n+   begin\n+      return Target : Set_Type (Source.Length) do\n+         Assign (Target => Target, Source => Source);\n+      end return;\n+   end Copy;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Set_Difference (Target : in out Set_Type; Source : Set_Type) is\n+      Tgt, Src : Count_Type;\n+\n+      TN : Nodes_Type renames Target.Nodes;\n+      SN : Nodes_Type renames Source.Nodes;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         if Target.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is busy)\";\n+         end if;\n+\n+         Tree_Operations.Clear_Tree (Target);\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Tgt := Target.First;\n+      Src := Source.First;\n+      loop\n+         if Tgt = 0 then\n+            return;\n+         end if;\n+\n+         if Src = 0 then\n+            return;\n+         end if;\n+\n+         if Is_Less (TN (Tgt), SN (Src)) then\n+            Tgt := Tree_Operations.Next (Target, Tgt);\n+\n+         elsif Is_Less (SN (Src), TN (Tgt)) then\n+            Src := Tree_Operations.Next (Source, Src);\n+\n+         else\n+            declare\n+               X : constant Count_Type := Tgt;\n+            begin\n+               Tgt := Tree_Operations.Next (Target, Tgt);\n+\n+               Tree_Operations.Delete_Node_Sans_Free (Target, X);\n+               Tree_Operations.Free (Target, X);\n+            end;\n+\n+            Src := Tree_Operations.Next (Source, Src);\n+         end if;\n+      end loop;\n+   end Set_Difference;\n+\n+   function Set_Difference (Left, Right : Set_Type) return Set_Type is\n+      L_Node : Count_Type;\n+      R_Node : Count_Type;\n+\n+      Dst_Node : Count_Type;\n+      pragma Warnings (Off, Dst_Node);\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return S : Set_Type (0);  -- Empty set\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return S : Set_Type (0);  -- Empty set\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Copy (Left);\n+      end if;\n+\n+      return Result : Set_Type (Left.Length) do\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = 0 then\n+               return;\n+            end if;\n+\n+            if R_Node = 0 then\n+               while L_Node /= 0 loop\n+                  Insert_With_Hint\n+                    (Dst_Set  => Result,\n+                     Dst_Hint => 0,\n+                     Src_Node => Left.Nodes (L_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Tree_Operations.Next (Left, L_Node);\n+               end loop;\n+\n+               return;\n+            end if;\n+\n+            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+               Insert_With_Hint\n+                 (Dst_Set  => Result,\n+                  Dst_Hint => 0,\n+                  Src_Node => Left.Nodes (L_Node),\n+                  Dst_Node => Dst_Node);\n+\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+\n+            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+\n+            else\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+            end if;\n+         end loop;\n+      end return;\n+   end Set_Difference;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Set_Intersection\n+     (Target : in out Set_Type;\n+      Source : Set_Type)\n+   is\n+      Tgt : Count_Type;\n+      Src : Count_Type;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      if Source.Length = 0 then\n+         Tree_Operations.Clear_Tree (Target);\n+         return;\n+      end if;\n+\n+      Tgt := Target.First;\n+      Src := Source.First;\n+      while Tgt /= 0\n+        and then Src /= 0\n+      loop\n+         if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n+            declare\n+               X : constant Count_Type := Tgt;\n+            begin\n+               Tgt := Tree_Operations.Next (Target, Tgt);\n+\n+               Tree_Operations.Delete_Node_Sans_Free (Target, X);\n+               Tree_Operations.Free (Target, X);\n+            end;\n+\n+         elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n+            Src := Tree_Operations.Next (Source, Src);\n+\n+         else\n+            Tgt := Tree_Operations.Next (Target, Tgt);\n+            Src := Tree_Operations.Next (Source, Src);\n+         end if;\n+      end loop;\n+\n+      while Tgt /= 0 loop\n+         declare\n+            X : constant Count_Type := Tgt;\n+         begin\n+            Tgt := Tree_Operations.Next (Target, Tgt);\n+\n+            Tree_Operations.Delete_Node_Sans_Free (Target, X);\n+            Tree_Operations.Free (Target, X);\n+         end;\n+      end loop;\n+   end Set_Intersection;\n+\n+   function Set_Intersection (Left, Right : Set_Type) return Set_Type is\n+      L_Node : Count_Type;\n+      R_Node : Count_Type;\n+\n+      Dst_Node : Count_Type;\n+      pragma Warnings (Off, Dst_Node);\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Copy (Left);\n+      end if;\n+\n+      return Result : Set_Type (Count_Type'Min (Left.Length, Right.Length)) do\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = 0 then\n+               return;\n+            end if;\n+\n+            if R_Node = 0 then\n+               return;\n+            end if;\n+\n+            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+\n+            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+\n+            else\n+               Insert_With_Hint\n+                 (Dst_Set  => Result,\n+                  Dst_Hint => 0,\n+                  Src_Node => Left.Nodes (L_Node),\n+                  Dst_Node => Dst_Node);\n+\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+            end if;\n+         end loop;\n+      end return;\n+   end Set_Intersection;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Set_Subset\n+     (Subset : Set_Type;\n+      Of_Set : Set_Type) return Boolean\n+   is\n+      Subset_Node : Count_Type;\n+      Set_Node    : Count_Type;\n+\n+   begin\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      if Subset.Length > Of_Set.Length then\n+         return False;\n+      end if;\n+\n+      Subset_Node := Subset.First;\n+      Set_Node    := Of_Set.First;\n+      loop\n+         if Set_Node = 0 then\n+            return Subset_Node = 0;\n+         end if;\n+\n+         if Subset_Node = 0 then\n+            return True;\n+         end if;\n+\n+         if Is_Less (Subset.Nodes (Subset_Node), Of_Set.Nodes (Set_Node)) then\n+            return False;\n+         end if;\n+\n+         if Is_Less (Of_Set.Nodes (Set_Node), Subset.Nodes (Subset_Node)) then\n+            Set_Node := Tree_Operations.Next (Of_Set, Set_Node);\n+         else\n+            Set_Node := Tree_Operations.Next (Of_Set, Set_Node);\n+            Subset_Node := Tree_Operations.Next (Subset, Subset_Node);\n+         end if;\n+      end loop;\n+   end Set_Subset;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Set_Overlap (Left, Right : Set_Type) return Boolean is\n+      L_Node : Count_Type;\n+      R_Node : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left.Length /= 0;\n+      end if;\n+\n+      L_Node := Left.First;\n+      R_Node := Right.First;\n+      loop\n+         if L_Node = 0\n+           or else R_Node = 0\n+         then\n+            return False;\n+         end if;\n+\n+         if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+            L_Node := Tree_Operations.Next (Left, L_Node);\n+\n+         elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+            R_Node := Tree_Operations.Next (Right, R_Node);\n+\n+         else\n+            return True;\n+         end if;\n+      end loop;\n+   end Set_Overlap;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Set_Symmetric_Difference\n+     (Target : in out Set_Type;\n+      Source : Set_Type)\n+   is\n+      Tgt : Count_Type;\n+      Src : Count_Type;\n+\n+      New_Tgt_Node : Count_Type;\n+      pragma Warnings (Off, New_Tgt_Node);\n+\n+   begin\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      if Target'Address = Source'Address then\n+         Tree_Operations.Clear_Tree (Target);\n+         return;\n+      end if;\n+\n+      Tgt := Target.First;\n+      Src := Source.First;\n+      loop\n+         if Tgt = 0 then\n+            while Src /= 0 loop\n+               Insert_With_Hint\n+                 (Dst_Set  => Target,\n+                  Dst_Hint => 0,\n+                  Src_Node => Source.Nodes (Src),\n+                  Dst_Node => New_Tgt_Node);\n+\n+               Src := Tree_Operations.Next (Source, Src);\n+            end loop;\n+\n+            return;\n+         end if;\n+\n+         if Src = 0 then\n+            return;\n+         end if;\n+\n+         if Is_Less (Target.Nodes (Tgt), Source.Nodes (Src)) then\n+            Tgt := Tree_Operations.Next (Target, Tgt);\n+\n+         elsif Is_Less (Source.Nodes (Src), Target.Nodes (Tgt)) then\n+            Insert_With_Hint\n+              (Dst_Set  => Target,\n+               Dst_Hint => Tgt,\n+               Src_Node => Source.Nodes (Src),\n+               Dst_Node => New_Tgt_Node);\n+\n+            Src := Tree_Operations.Next (Source, Src);\n+\n+         else\n+            declare\n+               X : constant Count_Type := Tgt;\n+            begin\n+               Tgt := Tree_Operations.Next (Target, Tgt);\n+\n+               Tree_Operations.Delete_Node_Sans_Free (Target, X);\n+               Tree_Operations.Free (Target, X);\n+            end;\n+\n+            Src := Tree_Operations.Next (Source, Src);\n+         end if;\n+      end loop;\n+   end Set_Symmetric_Difference;\n+\n+   function Set_Symmetric_Difference\n+     (Left, Right : Set_Type) return Set_Type\n+   is\n+      L_Node : Count_Type;\n+      R_Node : Count_Type;\n+\n+      Dst_Node : Count_Type;\n+      pragma Warnings (Off, Dst_Node);\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return S : Set_Type (0);  -- Empty set\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Copy (Left);\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Copy (Right);\n+      end if;\n+\n+      return Result : Set_Type (Left.Length + Right.Length) do\n+         L_Node := Left.First;\n+         R_Node := Right.First;\n+         loop\n+            if L_Node = 0 then\n+               while R_Node /= 0 loop\n+                  Insert_With_Hint\n+                    (Dst_Set  => Result,\n+                     Dst_Hint => 0,\n+                     Src_Node => Right.Nodes (R_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  R_Node := Tree_Operations.Next (Right, R_Node);\n+               end loop;\n+\n+               return;\n+            end if;\n+\n+            if R_Node = 0 then\n+               while L_Node /= 0 loop\n+                  Insert_With_Hint\n+                    (Dst_Set  => Result,\n+                     Dst_Hint => 0,\n+                     Src_Node => Left.Nodes (L_Node),\n+                     Dst_Node => Dst_Node);\n+\n+                  L_Node := Tree_Operations.Next (Left, L_Node);\n+               end loop;\n+\n+               return;\n+            end if;\n+\n+            if Is_Less (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+               Insert_With_Hint\n+                 (Dst_Set  => Result,\n+                  Dst_Hint => 0,\n+                  Src_Node => Left.Nodes (L_Node),\n+                  Dst_Node => Dst_Node);\n+\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+\n+            elsif Is_Less (Right.Nodes (R_Node), Left.Nodes (L_Node)) then\n+               Insert_With_Hint\n+                 (Dst_Set  => Result,\n+                  Dst_Hint => 0,\n+                  Src_Node => Right.Nodes (R_Node),\n+                  Dst_Node => Dst_Node);\n+\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+\n+            else\n+               L_Node := Tree_Operations.Next (Left, L_Node);\n+               R_Node := Tree_Operations.Next (Right, R_Node);\n+            end if;\n+         end loop;\n+      end return;\n+   end Set_Symmetric_Difference;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Set_Union (Target : in out Set_Type; Source : Set_Type) is\n+      Hint : Count_Type := 0;\n+\n+      procedure Process (Node : Count_Type);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is new Tree_Operations.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Node : Count_Type) is\n+      begin\n+         Insert_With_Hint\n+           (Dst_Set  => Target,\n+            Dst_Hint => Hint,\n+            Src_Node => Source.Nodes (Node),\n+            Dst_Node => Hint);\n+      end Process;\n+\n+   --  Start of processing for Union\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      --  Note that there's no way to decide apriori whether the\n+      --  target has enough capacity for the union with source.\n+      --  We cannot simply compare the sum of the existing lengths\n+      --  to the capacity of the target, because equivalent items\n+      --  from source are not included in the union.\n+\n+      Iterate (Source);\n+   end Set_Union;\n+\n+   function Set_Union (Left, Right : Set_Type) return Set_Type is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Copy (Left);\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Copy (Right);\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Copy (Left);\n+      end if;\n+\n+      return Result : Set_Type (Left.Length + Right.Length) do\n+         Assign (Target => Result, Source => Left);\n+\n+         Insert_Right : declare\n+            Hint : Count_Type := 0;\n+\n+            procedure Process (Node : Count_Type);\n+            pragma Inline (Process);\n+\n+            procedure Iterate is\n+              new Tree_Operations.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n+            procedure Process (Node : Count_Type) is\n+            begin\n+               Insert_With_Hint\n+                 (Dst_Set  => Result,\n+                  Dst_Hint => Hint,\n+                  Src_Node => Right.Nodes (Node),\n+                  Dst_Node => Hint);\n+            end Process;\n+\n+         --  Start of processing for Insert_Right\n+\n+         begin\n+            Iterate (Right);\n+         end Insert_Right;\n+      end return;\n+   end Set_Union;\n+\n+end Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations;"}, {"sha": "06b58297eb0d6951b20bbcfb93bded5727bde713", "filename": "gcc/ada/a-btgbso.ads", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-btgbso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-btgbso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-btgbso.ads?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,103 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--       ADA.CONTAINERS.RED_BLACK_TREES.GENERIC_BOUNDED_SET_OPERATIONS      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Tree_Type is used to implement ordered containers. This package declares\n+--  set-based tree operations.\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n+\n+generic\n+   with package Tree_Operations is new Generic_Bounded_Operations (<>);\n+\n+   type Set_Type is new Tree_Operations.Tree_Types.Tree_Type with private;\n+\n+   use Tree_Operations.Tree_Types;\n+\n+   with procedure Assign (Target : in out Set_Type; Source : Set_Type);\n+\n+   with procedure Insert_With_Hint\n+     (Dst_Set  : in out Set_Type;\n+      Dst_Hint : Count_Type;\n+      Src_Node : Node_Type;\n+      Dst_Node : out Count_Type);\n+\n+   with function Is_Less (Left, Right : Node_Type) return Boolean;\n+\n+package Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations is\n+   pragma Pure;\n+\n+   procedure Set_Union (Target : in out Set_Type; Source : Set_Type);\n+   --  Attempts to insert each element of Source in Target. If Target is\n+   --  busy then Program_Error is raised. We say \"attempts\" here because\n+   --  if these are unique-element sets, then the insertion should fail\n+   --  (not insert a new item) when the insertion item from Source is\n+   --  equivalent to an item already in Target. If these are multisets\n+   --  then of course the attempt should always succeed.\n+\n+   function Set_Union (Left, Right : Set_Type) return Set_Type;\n+   --  Makes a copy of Left, and attempts to insert each element of\n+   --  Right into the copy, then returns the copy.\n+\n+   procedure Set_Intersection (Target : in out Set_Type; Source : Set_Type);\n+   --  Removes elements from Target that are not equivalent to items in\n+   --  Source. If Target is busy then Program_Error is raised.\n+\n+   function Set_Intersection (Left, Right : Set_Type) return Set_Type;\n+   --  Returns a set comprising all the items in Left equivalent to items in\n+   --  Right.\n+\n+   procedure Set_Difference (Target : in out Set_Type; Source : Set_Type);\n+   --  Removes elements from Target that are equivalent to items in Source. If\n+   --  Target is busy then Program_Error is raised.\n+\n+   function Set_Difference (Left, Right : Set_Type) return Set_Type;\n+   --  Returns a set comprising all the items in Left not equivalent to items\n+   --  in Right.\n+\n+   procedure Set_Symmetric_Difference\n+     (Target : in out Set_Type;\n+      Source : Set_Type);\n+   --  Removes from Target elements that are equivalent to items in Source,\n+   --  and inserts into Target items from Source not equivalent elements in\n+   --  Target. If Target is busy then Program_Error is raised.\n+\n+   function Set_Symmetric_Difference (Left, Right : Set_Type) return Set_Type;\n+   --  Returns a set comprising the union of the elements in Left not\n+   --  equivalent to items in Right, and the elements in Right not equivalent\n+   --  to items in Left.\n+\n+   function Set_Subset (Subset : Set_Type; Of_Set : Set_Type) return Boolean;\n+   --  Returns False if Subset contains at least one element not equivalent to\n+   --  any item in Of_Set; returns True otherwise.\n+\n+   function Set_Overlap (Left, Right : Set_Type) return Boolean;\n+   --  Returns True if at least one element of Left is equivalent to an item in\n+   --  Right; returns False otherwise.\n+\n+end Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations;"}, {"sha": "64c248f7b506aafc8cb74d09384a12225b498ed5", "filename": "gcc/ada/a-cborma.adb", "status": "added", "additions": 1348, "deletions": 0, "changes": 1348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,1348 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . B O U N D E D _ O R D E R E D _ M A P S  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Bounded_Ordered_Maps is\n+\n+   -----------------------------\n+   -- Node Access Subprograms --\n+   -----------------------------\n+\n+   --  These subprograms provide a functional interface to access fields\n+   --  of a node, and a procedural interface for modifying these values.\n+\n+   function Color (Node : Node_Type) return Color_Type;\n+   pragma Inline (Color);\n+\n+   function Left (Node : Node_Type) return Count_Type;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Type) return Count_Type;\n+   pragma Inline (Parent);\n+\n+   function Right (Node : Node_Type) return Count_Type;\n+   pragma Inline (Right);\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type);\n+   pragma Inline (Set_Parent);\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type);\n+   pragma Inline (Set_Right);\n+\n+   procedure Set_Color (Node : in out Node_Type; Color : Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Is_Greater_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Greater_Key_Node);\n+\n+   function Is_Less_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Less_Key_Node);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package Tree_Operations is\n+      new Red_Black_Trees.Generic_Bounded_Operations (Tree_Types);\n+\n+   use Tree_Operations;\n+\n+   package Key_Ops is\n+     new Red_Black_Trees.Generic_Bounded_Keys\n+       (Tree_Operations     => Tree_Operations,\n+        Key_Type            => Key_Type,\n+        Is_Less_Key_Node    => Is_Less_Key_Node,\n+        Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n+      end if;\n+\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"Left cursor of \"\"<\"\" is bad\");\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"Right cursor of \"\"<\"\" is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return LN.Key < RN.Key;\n+      end;\n+   end \"<\";\n+\n+   function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"Left cursor of \"\"<\"\" is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+\n+      begin\n+         return LN.Key < Right;\n+      end;\n+   end \"<\";\n+\n+   function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n+   begin\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"Right cursor of \"\"<\"\" is bad\");\n+\n+      declare\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return Left < RN.Key;\n+      end;\n+   end \"<\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Map) return Boolean is\n+      function Is_Equal_Node_Node (L, R : Node_Type) return Boolean;\n+      pragma Inline (Is_Equal_Node_Node);\n+\n+      function Is_Equal is\n+        new Tree_Operations.Generic_Equal (Is_Equal_Node_Node);\n+\n+      ------------------------\n+      -- Is_Equal_Node_Node --\n+      ------------------------\n+\n+      function Is_Equal_Node_Node\n+        (L, R : Node_Type) return Boolean is\n+      begin\n+         if L.Key < R.Key then\n+            return False;\n+\n+         elsif R.Key < L.Key then\n+            return False;\n+\n+         else\n+            return L.Element = R.Element;\n+         end if;\n+      end Is_Equal_Node_Node;\n+\n+   --  Start of processing for \"=\"\n+\n+   begin\n+      return Is_Equal (Left, Right);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n+      end if;\n+\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"Left cursor of \"\">\"\" is bad\");\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"Right cursor of \"\">\"\" is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return RN.Key < LN.Key;\n+      end;\n+   end \">\";\n+\n+   function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"Left cursor of \"\">\"\" is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+\n+      begin\n+         return Right < LN.Key;\n+      end;\n+   end \">\";\n+\n+   function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n+   begin\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"Right cursor of \"\">\"\" is bad\");\n+\n+      declare\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return RN.Key < Left;\n+      end;\n+   end \">\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Map; Source : Map) is\n+      procedure Append_Element (Source_Node : Count_Type);\n+\n+      procedure Append_Elements is\n+         new Tree_Operations.Generic_Iteration (Append_Element);\n+\n+      --------------------\n+      -- Append_Element --\n+      --------------------\n+\n+      procedure Append_Element (Source_Node : Count_Type) is\n+         SN : Node_Type renames Source.Nodes (Source_Node);\n+\n+         procedure Set_Element (Node : in out Node_Type);\n+         pragma Inline (Set_Element);\n+\n+         function New_Node return Count_Type;\n+         pragma Inline (New_Node);\n+\n+         procedure Insert_Post is\n+            new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+         procedure Unconditional_Insert_Sans_Hint is\n+            new Key_Ops.Generic_Unconditional_Insert (Insert_Post);\n+\n+         procedure Unconditional_Insert_Avec_Hint is\n+            new Key_Ops.Generic_Unconditional_Insert_With_Hint\n+              (Insert_Post,\n+               Unconditional_Insert_Sans_Hint);\n+\n+         procedure Allocate is\n+            new Tree_Operations.Generic_Allocate (Set_Element);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Count_Type is\n+            Result : Count_Type;\n+\n+         begin\n+            Allocate (Target, Result);\n+            return Result;\n+         end New_Node;\n+\n+         -----------------\n+         -- Set_Element --\n+         -----------------\n+\n+         procedure Set_Element (Node : in out Node_Type) is\n+         begin\n+            Node.Key := SN.Key;\n+            Node.Element := SN.Element;\n+         end Set_Element;\n+\n+         Target_Node : Count_Type;\n+\n+      --  Start of processing for Append_Element\n+\n+      begin\n+         Unconditional_Insert_Avec_Hint\n+           (Tree  => Target,\n+            Hint  => 0,\n+            Key   => SN.Key,\n+            Node  => Target_Node);\n+      end Append_Element;\n+\n+   --  Start of processing for Assign\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      Tree_Operations.Clear_Tree (Target);\n+      Append_Elements (Source);\n+   end Assign;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Count_Type := Key_Ops.Ceiling (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) is\n+   begin\n+      Tree_Operations.Clear_Tree (Container);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Type) return Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Map; Capacity : Count_Type := 0) return Map is\n+      C : Count_Type;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := Source.Length;\n+\n+      elsif Capacity >= Source.Length then\n+         C := Capacity;\n+\n+      else\n+         raise Capacity_Error with \"Capacity value too small\";\n+      end if;\n+\n+      return Target : Map (Capacity => C) do\n+         Assign (Target => Target, Source => Source);\n+      end return;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor) is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Delete equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor of Delete designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"Position cursor of Delete is bad\");\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container, Position.Node);\n+      Tree_Operations.Free (Container, Position.Node);\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+      X : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if X = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+      Tree_Operations.Free (Container, X);\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Map) is\n+      X : constant Count_Type := Container.First;\n+\n+   begin\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end if;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Map) is\n+      X : constant Count_Type := Container.Last;\n+\n+   begin\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end if;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of function Element equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"Position cursor of function Element is bad\");\n+\n+      return Position.Container.Nodes (Position.Node).Element;\n+   end Element;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      return Container.Nodes (Node).Element;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end if;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+   begin\n+      if Container.First = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Map) return Element_Type is\n+   begin\n+      if Container.First = 0 then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.First).Element;\n+   end First_Element;\n+\n+   ---------------\n+   -- First_Key --\n+   ---------------\n+\n+   function First_Key (Container : Map) return Key_Type is\n+   begin\n+      if Container.First = 0 then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.First).Key;\n+   end First_Key;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Count_Type := Key_Ops.Floor (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Floor;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (map is locked)\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+\n+         begin\n+            N.Key := Key;\n+            N.Element := New_Item;\n+         end;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Assign (Node : in out Node_Type);\n+      pragma Inline (Assign);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Allocate is\n+         new Tree_Operations.Generic_Allocate (Assign);\n+\n+      ------------\n+      -- Assign --\n+      ------------\n+\n+      procedure Assign (Node : in out Node_Type) is\n+      begin\n+         Node.Key := Key;\n+         Node.Element := New_Item;\n+      end Assign;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      Insert_Sans_Hint\n+        (Container,\n+         Key,\n+         Position.Node,\n+         Inserted);\n+\n+      Position.Container := Container'Unrestricted_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with \"key already in map\";\n+      end if;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Assign (Node : in out Node_Type);\n+      pragma Inline (Assign);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Key_Ops.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Allocate is\n+         new Tree_Operations.Generic_Allocate (Assign);\n+\n+      ------------\n+      -- Assign --\n+      ------------\n+\n+      procedure Assign (Node : in out Node_Type) is\n+      begin\n+         Node.Key := Key;\n+         --  Node.Element := New_Item;\n+      end Assign;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      Insert_Sans_Hint\n+        (Container,\n+         Key,\n+         Position.Node,\n+         Inserted);\n+\n+      Position.Container := Container'Unrestricted_Access;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------------------\n+   -- Is_Greater_Key_Node --\n+   -------------------------\n+\n+   function Is_Greater_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      --  k > node same as node < k\n+\n+      return Right.Key < Left;\n+   end Is_Greater_Key_Node;\n+\n+   ----------------------\n+   -- Is_Less_Key_Node --\n+   ----------------------\n+\n+   function Is_Less_Key_Node\n+     (Left  : Key_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      return Left < Right.Key;\n+   end Is_Less_Key_Node;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+         new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (Container);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Cursor) return Key_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of function Key equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"Position cursor of function Key is bad\");\n+\n+      return Position.Container.Nodes (Position.Node).Key;\n+   end Key;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Map) return Cursor is\n+   begin\n+      if Container.Last = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Map) return Element_Type is\n+   begin\n+      if Container.Last = 0 then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.Last).Element;\n+   end Last_Element;\n+\n+   --------------\n+   -- Last_Key --\n+   --------------\n+\n+   function Last_Key (Container : Map) return Key_Type is\n+   begin\n+      if Container.Last = 0 then\n+         raise Constraint_Error with \"map is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.Last).Key;\n+   end Last_Key;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Left;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Map; Source : in out Map) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Assign (Target => Target, Source => Source);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"Position cursor of Next is bad\");\n+\n+      declare\n+         M : Map renames Position.Container.all;\n+\n+         Node : constant Count_Type :=\n+                  Tree_Operations.Next (M, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"Position cursor of Previous is bad\");\n+\n+      declare\n+         M : Map renames Position.Container.all;\n+\n+         Node : constant Count_Type :=\n+                  Tree_Operations.Previous (M, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"Position cursor of Query_Element is bad\");\n+\n+      declare\n+         M : Map renames Position.Container.all;\n+         N : Node_Type renames M.Nodes (Position.Node);\n+\n+         B : Natural renames M.Busy;\n+         L : Natural renames M.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (N.Key, N.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map)\n+   is\n+      procedure Read_Element (Node : in out Node_Type);\n+      pragma Inline (Read_Element);\n+\n+      procedure Allocate is\n+         new Tree_Operations.Generic_Allocate (Read_Element);\n+\n+      procedure Read_Elements is\n+         new Tree_Operations.Generic_Read (Allocate);\n+\n+      ------------------\n+      -- Read_Element --\n+      ------------------\n+\n+      procedure Read_Element (Node : in out Node_Type) is\n+      begin\n+         Key_Type'Read (Stream, Node.Key);\n+         Element_Type'Read (Stream, Node.Element);\n+      end Read_Element;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Read_Elements (Stream, Container);\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with \"key not in map\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (map is locked)\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Node);\n+\n+      begin\n+         N.Key := Key;\n+         N.Element := New_Item;\n+      end;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element designates wrong map\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (map is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"Position cursor of Replace_Element is bad\");\n+\n+      Container.Nodes (Position.Node).Element := New_Item;\n+   end Replace_Element;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+         new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container'Unrestricted_Access.all.Busy;\n+\n+      --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (Container);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Right;\n+   end Right;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Color_Type)\n+   is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor of Update_Element designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"Position cursor of Update_Element is bad\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (N.Key, N.Element);\n+\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Update_Element;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map)\n+   is\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write_Nodes is\n+         new Tree_Operations.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Key_Type'Write (Stream, Node.Key);\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Node;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Write_Nodes (Stream, Container);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Write;\n+\n+end Ada.Containers.Bounded_Ordered_Maps;"}, {"sha": "74dac9851688d6a7a7c55f0e0fe19489153c3edf", "filename": "gcc/ada/a-cborma.ads", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.ads?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,244 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . B O U N D E D _ O R D E R E D _ M A P S  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Red_Black_Trees;\n+private with Ada.Streams;\n+\n+generic\n+   type Key_Type is private;\n+   type Element_Type is private;\n+\n+   with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Ordered_Maps is\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+   type Map (Capacity : Count_Type) is tagged private;\n+   pragma Preelaborable_Initialization (Map);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Map : constant Map;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+\n+   function Length (Container : Map) return Count_Type;\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+\n+   procedure Clear (Container : in out Map);\n+\n+   function Key (Position : Cursor) return Key_Type;\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access\n+                   procedure (Key : Key_Type; Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+                   procedure (Key : Key_Type; Element : in out Element_Type));\n+\n+   procedure Assign (Target : in out Map; Source : Map);\n+\n+   function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Map);\n+\n+   procedure Delete_Last (Container : in out Map);\n+\n+   function First (Container : Map) return Cursor;\n+\n+   function First_Element (Container : Map) return Element_Type;\n+\n+   function First_Key (Container : Map) return Key_Type;\n+\n+   function Last (Container : Map) return Cursor;\n+\n+   function Last_Element (Container : Map) return Element_Type;\n+\n+   function Last_Key (Container : Map) return Key_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean;\n+\n+   function \">\" (Left, Right : Cursor) return Boolean;\n+\n+   function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+   function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+\n+   function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+   function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   type Node_Type is record\n+      Parent  : Count_Type;\n+      Left    : Count_Type;\n+      Right   : Count_Type;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Key     : Key_Type;\n+      Element : Element_Type;\n+   end record;\n+\n+   package Tree_Types is\n+     new Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n+\n+   type Map (Capacity : Count_Type) is\n+     new Tree_Types.Tree_Type (Capacity) with null record;\n+\n+   type Map_Access is access all Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   use Red_Black_Trees;\n+   use Tree_Types;\n+   use Ada.Streams;\n+\n+   type Cursor is record\n+      Container : Map_Access;\n+      Node      : Count_Type;\n+   end record;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, 0);\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   Empty_Map : constant Map := Map'(Tree_Type with Capacity => 0);\n+\n+end Ada.Containers.Bounded_Ordered_Maps;"}, {"sha": "12d253c648fda82af2437cd16e293290dabc2f8b", "filename": "gcc/ada/a-cborse.adb", "status": "added", "additions": 1718, "deletions": 0, "changes": 1718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,1718 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . B O U N D E D _ O R D E R E D _ S E T S  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations;\n+pragma Elaborate_All\n+  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations);\n+\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Bounded_Ordered_Sets is\n+\n+   ------------------------------\n+   -- Access to Fields of Node --\n+   ------------------------------\n+\n+   --  These subprograms provide functional notation for access to fields\n+   --  of a node, and procedural notation for modifying these fields.\n+\n+   function Color (Node : Node_Type) return Red_Black_Trees.Color_Type;\n+   pragma Inline (Color);\n+\n+   function Left (Node : Node_Type) return Count_Type;\n+   pragma Inline (Left);\n+\n+   function Parent (Node : Node_Type) return Count_Type;\n+   pragma Inline (Parent);\n+\n+   function Right (Node : Node_Type) return Count_Type;\n+   pragma Inline (Right);\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Red_Black_Trees.Color_Type);\n+   pragma Inline (Set_Color);\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type);\n+   pragma Inline (Set_Left);\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type);\n+   pragma Inline (Set_Right);\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type);\n+   pragma Inline (Set_Parent);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert_With_Hint\n+     (Dst_Set  : in out Set;\n+      Dst_Hint : Count_Type;\n+      Src_Node : Node_Type;\n+      Dst_Node : out Count_Type);\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Greater_Element_Node);\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean;\n+   pragma Inline (Is_Less_Element_Node);\n+\n+   function Is_Less_Node_Node (L, R : Node_Type) return Boolean;\n+   pragma Inline (Is_Less_Node_Node);\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Index     : Count_Type;\n+      Item      : Element_Type);\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package Tree_Operations is\n+      new Red_Black_Trees.Generic_Bounded_Operations (Tree_Types);\n+\n+   use Tree_Operations;\n+\n+   package Element_Keys is\n+      new Red_Black_Trees.Generic_Bounded_Keys\n+        (Tree_Operations     => Tree_Operations,\n+         Key_Type            => Element_Type,\n+         Is_Less_Key_Node    => Is_Less_Element_Node,\n+         Is_Greater_Key_Node => Is_Greater_Element_Node);\n+\n+   package Set_Ops is\n+      new Red_Black_Trees.Generic_Bounded_Set_Operations\n+        (Tree_Operations  => Tree_Operations,\n+         Set_Type         => Set,\n+         Assign           => Assign,\n+         Insert_With_Hint => Insert_With_Hint,\n+         Is_Less          => Is_Less_Node_Node);\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n+      declare\n+         LN : Nodes_Type renames Left.Container.Nodes;\n+         RN : Nodes_Type renames Right.Container.Nodes;\n+      begin\n+         return LN (Left.Node).Element < RN (Right.Node).Element;\n+      end;\n+   end \"<\";\n+\n+   function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      return Left.Container.Nodes (Left.Node).Element < Right;\n+   end \"<\";\n+\n+   function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n+   begin\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n+      return Left < Right.Container.Nodes (Right.Node).Element;\n+   end \"<\";\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Set) return Boolean is\n+      function Is_Equal_Node_Node (L, R : Node_Type) return Boolean;\n+      pragma Inline (Is_Equal_Node_Node);\n+\n+      function Is_Equal is\n+         new Tree_Operations.Generic_Equal (Is_Equal_Node_Node);\n+\n+      ------------------------\n+      -- Is_Equal_Node_Node --\n+      ------------------------\n+\n+      function Is_Equal_Node_Node (L, R : Node_Type) return Boolean is\n+      begin\n+         return L.Element = R.Element;\n+      end Is_Equal_Node_Node;\n+\n+   --  Start of processing for Is_Equal\n+\n+   begin\n+      return Is_Equal (Left, Right);\n+   end \"=\";\n+\n+   ---------\n+   -- \">\" --\n+   ---------\n+\n+   function \">\" (Left, Right : Cursor) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n+      --  L > R same as R < L\n+\n+      declare\n+         LN : Nodes_Type renames Left.Container.Nodes;\n+         RN : Nodes_Type renames Right.Container.Nodes;\n+      begin\n+         return RN (Right.Node).Element < LN (Left.Node).Element;\n+      end;\n+   end \">\";\n+\n+   function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n+   begin\n+      if Right.Node = 0 then\n+         raise Constraint_Error with \"Right cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.all, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n+      return Right.Container.Nodes (Right.Node).Element < Left;\n+   end \">\";\n+\n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with \"Left cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.all, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      return Right < Left.Container.Nodes (Left.Node).Element;\n+   end \">\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Set; Source : Set) is\n+      procedure Append_Element (Source_Node : Count_Type);\n+\n+      procedure Append_Elements is\n+         new Tree_Operations.Generic_Iteration (Append_Element);\n+\n+      --------------------\n+      -- Append_Element --\n+      --------------------\n+\n+      procedure Append_Element (Source_Node : Count_Type) is\n+         SN : Node_Type renames Source.Nodes (Source_Node);\n+\n+         procedure Set_Element (Node : in out Node_Type);\n+         pragma Inline (Set_Element);\n+\n+         function New_Node return Count_Type;\n+         pragma Inline (New_Node);\n+\n+         procedure Insert_Post is\n+            new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+         procedure Unconditional_Insert_Sans_Hint is\n+            new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+         procedure Unconditional_Insert_Avec_Hint is\n+            new Element_Keys.Generic_Unconditional_Insert_With_Hint\n+              (Insert_Post,\n+               Unconditional_Insert_Sans_Hint);\n+\n+         procedure Allocate is\n+            new Tree_Operations.Generic_Allocate (Set_Element);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Count_Type is\n+            Result : Count_Type;\n+\n+         begin\n+            Allocate (Target, Result);\n+            return Result;\n+         end New_Node;\n+\n+         -----------------\n+         -- Set_Element --\n+         -----------------\n+\n+         procedure Set_Element (Node : in out Node_Type) is\n+         begin\n+            Node.Element := SN.Element;\n+         end Set_Element;\n+\n+         Target_Node : Count_Type;\n+\n+      --  Start of processing for Append_Element\n+\n+      begin\n+         Unconditional_Insert_Avec_Hint\n+           (Tree  => Target,\n+            Hint  => 0,\n+            Key   => SN.Element,\n+            Node  => Target_Node);\n+      end Append_Element;\n+\n+   --  Start of processing for Assign\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      Target.Clear;\n+      Append_Elements (Source);\n+   end Assign;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Count_Type :=\n+               Element_Keys.Ceiling (Container, Item);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Ceiling;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Set) is\n+   begin\n+      Tree_Operations.Clear_Tree (Container);\n+   end Clear;\n+\n+   -----------\n+   -- Color --\n+   -----------\n+\n+   function Color (Node : Node_Type) return Red_Black_Trees.Color_Type is\n+   begin\n+      return Node.Color;\n+   end Color;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Set;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy (Source : Set; Capacity : Count_Type := 0) return Set is\n+      C : Count_Type;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := Source.Length;\n+\n+      elsif Capacity >= Source.Length then\n+         C := Capacity;\n+\n+      else\n+         raise Capacity_Error with \"Capacity value too small\";\n+      end if;\n+\n+      return Target : Set (Capacity => C) do\n+         Assign (Target => Target, Source => Source);\n+      end return;\n+   end Copy;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor) is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container, Position.Node);\n+      Tree_Operations.Free (Container, Position.Node);\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   procedure Delete (Container : in out Set; Item : Element_Type) is\n+      X : constant Count_Type := Element_Keys.Find (Container, Item);\n+\n+   begin\n+      if X = 0 then\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+      Tree_Operations.Free (Container, X);\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First (Container : in out Set) is\n+      X : constant Count_Type := Container.First;\n+\n+   begin\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end if;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last (Container : in out Set) is\n+      X : constant Count_Type := Container.Last;\n+\n+   begin\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end if;\n+   end Delete_Last;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference (Target : in out Set; Source : Set)\n+      renames Set_Ops.Set_Difference;\n+\n+   function Difference (Left, Right : Set) return Set\n+      renames Set_Ops.Set_Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"bad cursor in Element\");\n+\n+      return Position.Container.Nodes (Position.Node).Element;\n+   end Element;\n+\n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Elements;\n+\n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+      function Is_Equivalent_Node_Node (L, R : Node_Type) return Boolean;\n+      pragma Inline (Is_Equivalent_Node_Node);\n+\n+      function Is_Equivalent is\n+         new Tree_Operations.Generic_Equal (Is_Equivalent_Node_Node);\n+\n+      -----------------------------\n+      -- Is_Equivalent_Node_Node --\n+      -----------------------------\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Type) return Boolean is\n+      begin\n+         if L.Element < R.Element then\n+            return False;\n+         elsif R.Element < L.Element then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Is_Equivalent_Node_Node;\n+\n+   --  Start of processing for Equivalent_Sets\n+\n+   begin\n+      return Is_Equivalent (Left, Right);\n+   end Equivalent_Sets;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type) is\n+      X : constant Count_Type := Element_Keys.Find (Container, Item);\n+\n+   begin\n+      if X /= 0 then\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end if;\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Set) return Cursor is\n+   begin\n+      if Container.First = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : Set) return Element_Type is\n+   begin\n+      if Container.First = 0 then\n+         raise Constraint_Error with \"set is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.First).Element;\n+   end First_Element;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor is\n+      Node : constant Count_Type := Element_Keys.Floor (Container, Item);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Floor;\n+\n+   ------------------\n+   -- Generic_Keys --\n+   ------------------\n+\n+   package body Generic_Keys is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean;\n+      pragma Inline (Is_Greater_Key_Node);\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean;\n+      pragma Inline (Is_Less_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+        new Red_Black_Trees.Generic_Bounded_Keys\n+          (Tree_Operations     => Tree_Operations,\n+           Key_Type            => Key_Type,\n+           Is_Less_Key_Node    => Is_Less_Key_Node,\n+           Is_Greater_Key_Node => Is_Greater_Key_Node);\n+\n+      -------------\n+      -- Ceiling --\n+      -------------\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Count_Type :=\n+                  Key_Keys.Ceiling (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unrestricted_Access, Node);\n+      end Ceiling;\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type) is\n+         X : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if X = 0 then\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n+         end if;\n+\n+         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+         Tree_Operations.Free (Container, X);\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in set\";\n+         end if;\n+\n+         return Container.Nodes (Node).Element;\n+      end Element;\n+\n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+      begin\n+         if Left < Right\n+           or else Right < Left\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Equivalent_Keys;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type) is\n+         X : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if X /= 0 then\n+            Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+            Tree_Operations.Free (Container, X);\n+         end if;\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unrestricted_Access, Node);\n+      end Find;\n+\n+      -----------\n+      -- Floor --\n+      -----------\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor is\n+         Node : constant Count_Type := Key_Keys.Floor (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unrestricted_Access, Node);\n+      end Floor;\n+\n+      -------------------------\n+      -- Is_Greater_Key_Node --\n+      -------------------------\n+\n+      function Is_Greater_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean\n+      is\n+      begin\n+         return Key (Right.Element) < Left;\n+      end Is_Greater_Key_Node;\n+\n+      ----------------------\n+      -- Is_Less_Key_Node --\n+      ----------------------\n+\n+      function Is_Less_Key_Node\n+        (Left  : Key_Type;\n+         Right : Node_Type) return Boolean\n+      is\n+      begin\n+         return Left < Key (Right.Element);\n+      end Is_Less_Key_Node;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         if Position.Node = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n+         end if;\n+\n+         pragma Assert (Vet (Position.Container.all, Position.Node),\n+                        \"bad cursor in Key\");\n+\n+         return Key (Position.Container.Nodes (Position.Node).Element);\n+      end Key;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n+         end if;\n+\n+         Replace_Element (Container, Node, New_Item);\n+      end Replace;\n+\n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access procedure (Element : in out Element_Type))\n+      is\n+      begin\n+         if Position.Node = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong set\";\n+         end if;\n+\n+         pragma Assert (Vet (Container, Position.Node),\n+                        \"bad cursor in Update_Element_Preserving_Key\");\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+            E : Element_Type renames N.Element;\n+            K : constant Key_Type := Key (E);\n+\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if Equivalent_Keys (K, Key (E)) then\n+               return;\n+            end if;\n+         end;\n+\n+         Tree_Operations.Delete_Node_Sans_Free (Container, Position.Node);\n+         Tree_Operations.Free (Container, Position.Node);\n+\n+         raise Program_Error with \"key was modified\";\n+      end Update_Element_Preserving_Key;\n+\n+   end Generic_Keys;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      return Position /= No_Element;\n+   end Has_Element;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include (Container : in out Set; New_Item : Element_Type) is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (set is locked)\";\n+         end if;\n+\n+         Container.Nodes (Position.Node).Element := New_Item;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+      Insert_Sans_Hint\n+        (Container,\n+         New_Item,\n+         Position.Node,\n+         Inserted);\n+\n+      Position.Container := Container'Unrestricted_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n+      end if;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_Sans_Hint --\n+   ----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Set_Element (Node : in out Node_Type);\n+      pragma Inline (Set_Element);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Conditional_Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Allocate is\n+         new Tree_Operations.Generic_Allocate (Set_Element);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+      -----------------\n+      -- Set_Element --\n+      -----------------\n+\n+      procedure Set_Element (Node : in out Node_Type) is\n+      begin\n+         Node.Element := New_Item;\n+      end Set_Element;\n+\n+   --  Start of processing for Insert_Sans_Hint\n+\n+   begin\n+      Conditional_Insert_Sans_Hint\n+        (Container,\n+         New_Item,\n+         Node,\n+         Inserted);\n+   end Insert_Sans_Hint;\n+\n+   ----------------------\n+   -- Insert_With_Hint --\n+   ----------------------\n+\n+   procedure Insert_With_Hint\n+     (Dst_Set  : in out Set;\n+      Dst_Hint : Count_Type;\n+      Src_Node : Node_Type;\n+      Dst_Node : out Count_Type)\n+   is\n+      Success : Boolean;\n+      pragma Unreferenced (Success);\n+\n+      procedure Set_Element (Node : in out Node_Type);\n+      pragma Inline (Set_Element);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+         new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Insert_Sans_Hint is\n+         new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+         new Element_Keys.Generic_Conditional_Insert_With_Hint\n+           (Insert_Post,\n+            Insert_Sans_Hint);\n+\n+      procedure Allocate is\n+         new Tree_Operations.Generic_Allocate (Set_Element);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+\n+      begin\n+         Allocate (Dst_Set, Result);\n+         return Result;\n+      end New_Node;\n+\n+      -----------------\n+      -- Set_Element --\n+      -----------------\n+\n+      procedure Set_Element (Node : in out Node_Type) is\n+      begin\n+         Node.Element := Src_Node.Element;\n+      end Set_Element;\n+\n+   --  Start of processing for Insert_With_Hint\n+\n+   begin\n+      Local_Insert_With_Hint\n+        (Dst_Set,\n+         Dst_Hint,\n+         Src_Node.Element,\n+         Dst_Node,\n+         Success);\n+   end Insert_With_Hint;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Intersection (Target : in out Set; Source : Set)\n+      renames Set_Ops.Set_Intersection;\n+\n+   function Intersection (Left, Right : Set) return Set\n+      renames Set_Ops.Set_Intersection;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -----------------------------\n+   -- Is_Greater_Element_Node --\n+   -----------------------------\n+\n+   function Is_Greater_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      --  Compute e > node same as node < e\n+\n+      return Right.Element < Left;\n+   end Is_Greater_Element_Node;\n+\n+   --------------------------\n+   -- Is_Less_Element_Node --\n+   --------------------------\n+\n+   function Is_Less_Element_Node\n+     (Left  : Element_Type;\n+      Right : Node_Type) return Boolean\n+   is\n+   begin\n+      return Left < Right.Element;\n+   end Is_Less_Element_Node;\n+\n+   -----------------------\n+   -- Is_Less_Node_Node --\n+   -----------------------\n+\n+   function Is_Less_Node_Node (L, R : Node_Type) return Boolean is\n+   begin\n+      return L.Element < R.Element;\n+   end Is_Less_Node_Node;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean\n+      renames Set_Ops.Set_Subset;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is\n+        new Tree_Operations.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n+\n+      S : Set renames Container'Unrestricted_Access.all;\n+      B : Natural renames S.Busy;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (S);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : Set) return Cursor is\n+   begin\n+      if Container.Last = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : Set) return Element_Type is\n+   begin\n+      if Container.Last = 0 then\n+         raise Constraint_Error with \"set is empty\";\n+      end if;\n+\n+      return Container.Nodes (Container.Last).Element;\n+   end Last_Element;\n+\n+   ----------\n+   -- Left --\n+   ----------\n+\n+   function Left (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Left;\n+   end Left;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Assign (Target => Target, Source => Source);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"bad cursor in Next\");\n+\n+      declare\n+         Node : constant Count_Type :=\n+                  Tree_Operations.Next (Position.Container.all, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean\n+      renames Set_Ops.Set_Overlap;\n+\n+   ------------\n+   -- Parent --\n+   ------------\n+\n+   function Parent (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Parent;\n+   end Parent;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position = No_Element then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n+      declare\n+         Node : constant Count_Type :=\n+                  Tree_Operations.Previous\n+                    (Position.Container.all,\n+                     Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.all, Position.Node),\n+                     \"bad cursor in Query_Element\");\n+\n+      declare\n+         S : Set renames Position.Container.all;\n+\n+         B : Natural renames S.Busy;\n+         L : Natural renames S.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (S.Nodes (Position.Node).Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+      procedure Read_Element (Node : in out Node_Type);\n+      pragma Inline (Read_Element);\n+\n+      procedure Allocate is\n+         new Tree_Operations.Generic_Allocate (Read_Element);\n+\n+      procedure Read_Elements is\n+         new Tree_Operations.Generic_Read (Allocate);\n+\n+      ------------------\n+      -- Read_Element --\n+      ------------------\n+\n+      procedure Read_Element (Node : in out Node_Type) is\n+      begin\n+         Element_Type'Read (Stream, Node.Element);\n+      end Read_Element;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Read_Elements (Stream, Container);\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n+      Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is locked)\";\n+      end if;\n+\n+      Container.Nodes (Node).Element := New_Item;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Index     : Count_Type;\n+      Item      : Element_Type)\n+   is\n+      pragma Assert (Index /= 0);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert_Post is\n+         new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Local_Insert_Sans_Hint is\n+         new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n+\n+      procedure Local_Insert_With_Hint is\n+         new Element_Keys.Generic_Conditional_Insert_With_Hint\n+           (Local_Insert_Post,\n+            Local_Insert_Sans_Hint);\n+\n+      Nodes : Nodes_Type renames Container.Nodes;\n+      Node  : Node_Type renames Nodes (Index);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+      begin\n+         Node.Element := Item;\n+         Node.Color := Red_Black_Trees.Red;\n+         Node.Parent := 0;\n+         Node.Right := 0;\n+         Node.Left := 0;\n+\n+         return Index;\n+      end New_Node;\n+\n+      Hint      : Count_Type;\n+      Result    : Count_Type;\n+      Inserted  : Boolean;\n+\n+   --  Start of processing for Replace_Element\n+\n+   begin\n+      if Item < Node.Element\n+        or else Node.Element < Item\n+      then\n+         null;\n+\n+      else\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (set is locked)\";\n+         end if;\n+\n+         Node.Element := Item;\n+         return;\n+      end if;\n+\n+      Hint := Element_Keys.Ceiling (Container, Item);\n+\n+      if Hint = 0 then\n+         null;\n+\n+      elsif Item < Nodes (Hint).Element then\n+         if Hint = Index then\n+            if Container.Lock > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (set is locked)\";\n+            end if;\n+\n+            Node.Element := Item;\n+            return;\n+         end if;\n+\n+      else\n+         pragma Assert (not (Nodes (Hint).Element < Item));\n+         raise Program_Error with \"attempt to replace existing element\";\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container, Index);\n+\n+      Local_Insert_With_Hint\n+        (Tree     => Container,\n+         Position => Hint,\n+         Key      => Item,\n+         Node     => Result,\n+         Inserted => Inserted);\n+\n+      pragma Assert (Inserted);\n+      pragma Assert (Result = Index);\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Replace_Element (Container, Position.Node, New_Item);\n+   end Replace_Element;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Reverse_Iterate is\n+         new Tree_Operations.Generic_Reverse_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n+\n+      S : Set renames Container'Unrestricted_Access.all;\n+      B : Natural renames S.Busy;\n+\n+   --  Start of processing for Reverse_Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (S);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n+\n+   -----------\n+   -- Right --\n+   -----------\n+\n+   function Right (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Right;\n+   end Right;\n+\n+   ---------------\n+   -- Set_Color --\n+   ---------------\n+\n+   procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Red_Black_Trees.Color_Type)\n+   is\n+   begin\n+      Node.Color := Color;\n+   end Set_Color;\n+\n+   --------------\n+   -- Set_Left --\n+   --------------\n+\n+   procedure Set_Left (Node : in out Node_Type; Left : Count_Type) is\n+   begin\n+      Node.Left := Left;\n+   end Set_Left;\n+\n+   ----------------\n+   -- Set_Parent --\n+   ----------------\n+\n+   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type) is\n+   begin\n+      Node.Parent := Parent;\n+   end Set_Parent;\n+\n+   ---------------\n+   -- Set_Right --\n+   ---------------\n+\n+   procedure Set_Right (Node : in out Node_Type; Right : Count_Type) is\n+   begin\n+      Node.Right := Right;\n+   end Set_Right;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set)\n+      renames Set_Ops.Set_Symmetric_Difference;\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set\n+      renames Set_Ops.Set_Symmetric_Difference;\n+\n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      Node     : Count_Type;\n+      Inserted : Boolean;\n+   begin\n+      return S : Set (1) do\n+         Insert_Sans_Hint (S, New_Item, Node, Inserted);\n+         pragma Assert (Inserted);\n+      end return;\n+   end To_Set;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Union (Target : in out Set; Source : Set)\n+      renames Set_Ops.Set_Union;\n+\n+   function Union (Left, Right : Set) return Set\n+      renames Set_Ops.Set_Union;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set)\n+   is\n+      procedure Write_Element\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Element);\n+\n+      procedure Write_Elements is\n+         new Tree_Operations.Generic_Write (Write_Element);\n+\n+      -------------------\n+      -- Write_Element --\n+      -------------------\n+\n+      procedure Write_Element\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Element;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Write_Elements (Stream, Container);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Write;\n+\n+end Ada.Containers.Bounded_Ordered_Sets;"}, {"sha": "f9719dcdbc63641b09ce259904448924aee862d5", "filename": "gcc/ada/a-cborse.ads", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-cborse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.ads?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,294 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . B O U N D E D _ O R D E R E D _ S E T S  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Red_Black_Trees;\n+private with Ada.Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Ordered_Sets is\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+\n+   type Set (Capacity : Count_Type) is tagged private;\n+   pragma Preelaborable_Initialization (Set);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Set : constant Set;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n+   function To_Set (New_Item : Element_Type) return Set;\n+\n+   function Length (Container : Set) return Count_Type;\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+\n+   procedure Clear (Container : in out Set);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Assign (Target : in out Set; Source : Set);\n+\n+   function Copy (Source : Set; Capacity : Count_Type := 0) return Set;\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace\n+     (Container : in out Set;\n+      New_Item  : Element_Type);\n+\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor);\n+\n+   procedure Delete_First (Container : in out Set);\n+\n+   procedure Delete_Last (Container : in out Set);\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+\n+   function Union (Left, Right : Set) return Set;\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+\n+   function Intersection (Left, Right : Set) return Set;\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+\n+   function Difference (Left, Right : Set) return Set;\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+\n+   function \"xor\" (Left, Right : Set) return Set renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function First_Element (Container : Set) return Element_Type;\n+\n+   function Last (Container : Set) return Cursor;\n+\n+   function Last_Element (Container : Set) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function \"<\" (Left, Right : Cursor) return Boolean;\n+\n+   function \">\" (Left, Right : Cursor) return Boolean;\n+\n+   function \"<\" (Left : Cursor; Right : Element_Type) return Boolean;\n+\n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean;\n+\n+   function \"<\" (Left : Element_Type; Right : Cursor) return Boolean;\n+\n+   function \">\" (Left : Element_Type; Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      type Key_Type (<>) is private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n+\n+   package Generic_Keys is\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+      function Key (Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Floor (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type));\n+\n+   end Generic_Keys;\n+\n+private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n+   type Node_Type is record\n+      Parent  : Count_Type;\n+      Left    : Count_Type;\n+      Right   : Count_Type;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Element : Element_Type;\n+   end record;\n+\n+   package Tree_Types is\n+     new Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n+\n+   type Set (Capacity : Count_Type) is\n+     new Tree_Types.Tree_Type (Capacity) with null record;\n+\n+   type Set_Access is access all Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Set_Access;\n+      Node      : Count_Type;\n+   end record;\n+\n+   use Tree_Types;\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, 0);\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set := Set'(Tree_Type with Capacity => 0);\n+\n+end Ada.Containers.Bounded_Ordered_Sets;"}, {"sha": "30ceff71cc98328a55e38b0deb2ba52e16c9f5d9", "filename": "gcc/ada/a-crbltr.ads", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-crbltr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-crbltr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbltr.ads?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,4 +48,21 @@ package Ada.Containers.Red_Black_Trees is\n       end record;\n    end Generic_Tree_Types;\n \n+   generic\n+      type Node_Type is private;\n+   package Generic_Bounded_Tree_Types is\n+      type Nodes_Type is array (Count_Type range <>) of Node_Type;\n+\n+      type Tree_Type (Capacity : Count_Type) is tagged record\n+         First  : Count_Type := 0;\n+         Last   : Count_Type := 0;\n+         Root   : Count_Type := 0;\n+         Length : Count_Type := 0;\n+         Busy   : Natural := 0;\n+         Lock   : Natural := 0;\n+         Free   : Count_Type'Base := -1;\n+         Nodes  : Nodes_Type (1 .. Capacity);\n+      end record;\n+   end Generic_Bounded_Tree_Types;\n+\n end Ada.Containers.Red_Black_Trees;"}, {"sha": "b12ae84107627ee85204f06ff0b1c876fe550ab5", "filename": "gcc/ada/a-rbtgbk.adb", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbk.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,599 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--            ADA.CONTAINERS.RED_BLACK_TREES.GENERIC_BOUNDED_KEYS           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys is\n+\n+   package Ops renames Tree_Operations;\n+\n+   -------------\n+   -- Ceiling --\n+   -------------\n+\n+   --  AKA Lower_Bound\n+\n+   function Ceiling\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type\n+   is\n+      Y : Count_Type;\n+      X : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      Y := 0;\n+\n+      X := Tree.Root;\n+      while X /= 0 loop\n+         if Is_Greater_Key_Node (Key, N (X)) then\n+            X := Ops.Right (N (X));\n+         else\n+            Y := X;\n+            X := Ops.Left (N (X));\n+         end if;\n+      end loop;\n+\n+      return Y;\n+   end Ceiling;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type\n+   is\n+      Y : Count_Type;\n+      X : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      Y := 0;\n+\n+      X := Tree.Root;\n+      while X /= 0 loop\n+         if Is_Greater_Key_Node (Key, N (X)) then\n+            X := Ops.Right (N (X));\n+         else\n+            Y := X;\n+            X := Ops.Left (N (X));\n+         end if;\n+      end loop;\n+\n+      if Y = 0 then\n+         return 0;\n+      end if;\n+\n+      if Is_Less_Key_Node (Key, N (Y)) then\n+         return 0;\n+      end if;\n+\n+      return Y;\n+   end Find;\n+\n+   -----------\n+   -- Floor --\n+   -----------\n+\n+   function Floor\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type\n+   is\n+      Y : Count_Type;\n+      X : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      Y := 0;\n+\n+      X := Tree.Root;\n+      while X /= 0 loop\n+         if Is_Less_Key_Node (Key, N (X)) then\n+            X := Ops.Left (N (X));\n+         else\n+            Y := X;\n+            X := Ops.Right (N (X));\n+         end if;\n+      end loop;\n+\n+      return Y;\n+   end Floor;\n+\n+   --------------------------------\n+   -- Generic_Conditional_Insert --\n+   --------------------------------\n+\n+   procedure Generic_Conditional_Insert\n+     (Tree     : in out Tree_Type'Class;\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean)\n+   is\n+      Y : Count_Type;\n+      X : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      Y := 0;\n+\n+      X := Tree.Root;\n+      Inserted := True;\n+      while X /= 0 loop\n+         Y := X;\n+         Inserted := Is_Less_Key_Node (Key, N (X));\n+         X := (if Inserted then Ops.Left (N (X)) else Ops.Right (N (X)));\n+      end loop;\n+\n+      --  If Inserted is True, then this means either that Tree is\n+      --  empty, or there was a least one node (strictly) greater than\n+      --  Key. Otherwise, it means that Key is equal to or greater than\n+      --  every node.\n+\n+      if Inserted then\n+         if Y = Tree.First then\n+            Insert_Post (Tree, Y, True, Node);\n+            return;\n+         end if;\n+\n+         Node := Ops.Previous (Tree, Y);\n+\n+      else\n+         Node := Y;\n+      end if;\n+\n+      --  Here Node has a value that is less than or equal to Key. We\n+      --  now have to resolve whether Key is equal to or greater than\n+      --  Node, which determines whether the insertion succeeds.\n+\n+      if Is_Greater_Key_Node (Key, N (Node)) then\n+         Insert_Post (Tree, Y, Inserted, Node);\n+         Inserted := True;\n+         return;\n+      end if;\n+\n+      Inserted := False;\n+   end Generic_Conditional_Insert;\n+\n+   ------------------------------------------\n+   -- Generic_Conditional_Insert_With_Hint --\n+   ------------------------------------------\n+\n+   procedure Generic_Conditional_Insert_With_Hint\n+     (Tree      : in out Tree_Type'Class;\n+      Position  : Count_Type;\n+      Key       : Key_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean)\n+   is\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      --  The purpose of a hint is to avoid a search from the root of\n+      --  tree. If we have it hint it means we only need to traverse the\n+      --  subtree rooted at the hint to find the nearest neighbor. Note\n+      --  that finding the neighbor means merely walking the tree; this\n+      --  is not a search and the only comparisons that occur are with\n+      --  the hint and its neighbor.\n+\n+      --  If Position is 0, this is interpreted to mean that Key is\n+      --  large relative to the nodes in the tree. If the tree is empty,\n+      --  or Key is greater than the last node in the tree, then we're\n+      --  done; otherwise the hint was \"wrong\" and we must search.\n+\n+      if Position = 0 then  -- largest\n+         if Tree.Last = 0\n+           or else Is_Greater_Key_Node (Key, N (Tree.Last))\n+         then\n+            Insert_Post (Tree, Tree.Last, False, Node);\n+            Inserted := True;\n+         else\n+            Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      pragma Assert (Tree.Length > 0);\n+\n+      --  A hint can either name the node that immediately follows Key,\n+      --  or immediately precedes Key. We first test whether Key is\n+      --  less than the hint, and if so we compare Key to the node that\n+      --  precedes the hint. If Key is both less than the hint and\n+      --  greater than the hint's preceding neighbor, then we're done;\n+      --  otherwise we must search.\n+\n+      --  Note also that a hint can either be an anterior node or a leaf\n+      --  node. A new node is always inserted at the bottom of the tree\n+      --  (at least prior to rebalancing), becoming the new left or\n+      --  right child of leaf node (which prior to the insertion must\n+      --  necessarily be null, since this is a leaf). If the hint names\n+      --  an anterior node then its neighbor must be a leaf, and so\n+      --  (here) we insert after the neighbor. If the hint names a leaf\n+      --  then its neighbor must be anterior and so we insert before the\n+      --  hint.\n+\n+      if Is_Less_Key_Node (Key, N (Position)) then\n+         declare\n+            Before : constant Count_Type := Ops.Previous (Tree, Position);\n+\n+         begin\n+            if Before = 0 then\n+               Insert_Post (Tree, Tree.First, True, Node);\n+               Inserted := True;\n+\n+            elsif Is_Greater_Key_Node (Key, N (Before)) then\n+               if Ops.Right (N (Before)) = 0 then\n+                  Insert_Post (Tree, Before, False, Node);\n+               else\n+                  Insert_Post (Tree, Position, True, Node);\n+               end if;\n+\n+               Inserted := True;\n+\n+            else\n+               Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+            end if;\n+         end;\n+\n+         return;\n+      end if;\n+\n+      --  We know that Key isn't less than the hint so we try again,\n+      --  this time to see if it's greater than the hint. If so we\n+      --  compare Key to the node that follows the hint. If Key is both\n+      --  greater than the hint and less than the hint's next neighbor,\n+      --  then we're done; otherwise we must search.\n+\n+      if Is_Greater_Key_Node (Key, N (Position)) then\n+         declare\n+            After : constant Count_Type := Ops.Next (Tree, Position);\n+\n+         begin\n+            if After = 0 then\n+               Insert_Post (Tree, Tree.Last, False, Node);\n+               Inserted := True;\n+\n+            elsif Is_Less_Key_Node (Key, N (After)) then\n+               if Ops.Right (N (Position)) = 0 then\n+                  Insert_Post (Tree, Position, False, Node);\n+               else\n+                  Insert_Post (Tree, After, True, Node);\n+               end if;\n+\n+               Inserted := True;\n+\n+            else\n+               Conditional_Insert_Sans_Hint (Tree, Key, Node, Inserted);\n+            end if;\n+         end;\n+\n+         return;\n+      end if;\n+\n+      --  We know that Key is neither less than the hint nor greater\n+      --  than the hint, and that's the definition of equivalence.\n+      --  There's nothing else we need to do, since a search would just\n+      --  reach the same conclusion.\n+\n+      Node := Position;\n+      Inserted := False;\n+   end Generic_Conditional_Insert_With_Hint;\n+\n+   -------------------------\n+   -- Generic_Insert_Post --\n+   -------------------------\n+\n+   procedure Generic_Insert_Post\n+     (Tree   : in out Tree_Type'Class;\n+      Y      : Count_Type;\n+      Before : Boolean;\n+      Z      : out Count_Type)\n+   is\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      if Tree.Length >= Tree.Capacity then\n+         raise Capacity_Error with \"not enough capacity to insert new item\";\n+      end if;\n+\n+      if Tree.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Z := New_Node;\n+      pragma Assert (Z /= 0);\n+\n+      if Y = 0 then\n+         pragma Assert (Tree.Length = 0);\n+         pragma Assert (Tree.Root = 0);\n+         pragma Assert (Tree.First = 0);\n+         pragma Assert (Tree.Last = 0);\n+\n+         Tree.Root := Z;\n+         Tree.First := Z;\n+         Tree.Last := Z;\n+\n+      elsif Before then\n+         pragma Assert (Ops.Left (N (Y)) = 0);\n+\n+         Ops.Set_Left (N (Y), Z);\n+\n+         if Y = Tree.First then\n+            Tree.First := Z;\n+         end if;\n+\n+      else\n+         pragma Assert (Ops.Right (N (Y)) = 0);\n+\n+         Ops.Set_Right (N (Y), Z);\n+\n+         if Y = Tree.Last then\n+            Tree.Last := Z;\n+         end if;\n+      end if;\n+\n+      Ops.Set_Color (N (Z), Red);\n+      Ops.Set_Parent (N (Z), Y);\n+      Ops.Rebalance_For_Insert (Tree, Z);\n+      Tree.Length := Tree.Length + 1;\n+   end Generic_Insert_Post;\n+\n+   -----------------------\n+   -- Generic_Iteration --\n+   -----------------------\n+\n+   procedure Generic_Iteration\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type)\n+   is\n+      procedure Iterate (Index : Count_Type);\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      procedure Iterate (Index : Count_Type) is\n+         J : Count_Type;\n+         N : Nodes_Type renames Tree.Nodes;\n+\n+      begin\n+         J := Index;\n+         while J /= 0 loop\n+            if Is_Less_Key_Node (Key, N (J)) then\n+               J := Ops.Left (N (J));\n+            elsif Is_Greater_Key_Node (Key, N (J)) then\n+               J := Ops.Right (N (J));\n+            else\n+               Iterate (Ops.Left (N (J)));\n+               Process (J);\n+               J := Ops.Right (N (J));\n+            end if;\n+         end loop;\n+      end Iterate;\n+\n+   --  Start of processing for Generic_Iteration\n+\n+   begin\n+      Iterate (Tree.Root);\n+   end Generic_Iteration;\n+\n+   -------------------------------\n+   -- Generic_Reverse_Iteration --\n+   -------------------------------\n+\n+   procedure Generic_Reverse_Iteration\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type)\n+   is\n+      procedure Iterate (Index : Count_Type);\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      procedure Iterate (Index : Count_Type) is\n+         J : Count_Type;\n+         N : Nodes_Type renames Tree.Nodes;\n+\n+      begin\n+         J := Index;\n+         while J /= 0 loop\n+            if Is_Less_Key_Node (Key, N (J)) then\n+               J := Ops.Left (N (J));\n+            elsif Is_Greater_Key_Node (Key, N (J)) then\n+               J := Ops.Right (N (J));\n+            else\n+               Iterate (Ops.Right (N (J)));\n+               Process (J);\n+               J := Ops.Left (N (J));\n+            end if;\n+         end loop;\n+      end Iterate;\n+\n+   --  Start of processing for Generic_Reverse_Iteration\n+\n+   begin\n+      Iterate (Tree.Root);\n+   end Generic_Reverse_Iteration;\n+\n+   ----------------------------------\n+   -- Generic_Unconditional_Insert --\n+   ----------------------------------\n+\n+   procedure Generic_Unconditional_Insert\n+     (Tree : in out Tree_Type'Class;\n+      Key  : Key_Type;\n+      Node : out Count_Type)\n+   is\n+      Y : Count_Type;\n+      X : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+      Before : Boolean;\n+\n+   begin\n+      Y := 0;\n+      Before := False;\n+\n+      X := Tree.Root;\n+      while X /= 0 loop\n+         Y := X;\n+         Before := Is_Less_Key_Node (Key, N (X));\n+         X := (if Before then Ops.Left (N (X)) else Ops.Right (N (X)));\n+      end loop;\n+\n+      Insert_Post (Tree, Y, Before, Node);\n+   end Generic_Unconditional_Insert;\n+\n+   --------------------------------------------\n+   -- Generic_Unconditional_Insert_With_Hint --\n+   --------------------------------------------\n+\n+   procedure Generic_Unconditional_Insert_With_Hint\n+     (Tree : in out Tree_Type'Class;\n+      Hint : Count_Type;\n+      Key  : Key_Type;\n+      Node : out Count_Type)\n+   is\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      --  There are fewer constraints for an unconditional insertion\n+      --  than for a conditional insertion, since we allow duplicate\n+      --  keys. So instead of having to check (say) whether Key is\n+      --  (strictly) greater than the hint's previous neighbor, here we\n+      --  allow Key to be equal to or greater than the previous node.\n+\n+      --  There is the issue of what to do if Key is equivalent to the\n+      --  hint. Does the new node get inserted before or after the hint?\n+      --  We decide that it gets inserted after the hint, reasoning that\n+      --  this is consistent with behavior for non-hint insertion, which\n+      --  inserts a new node after existing nodes with equivalent keys.\n+\n+      --  First we check whether the hint is null, which is interpreted\n+      --  to mean that Key is large relative to existing nodes.\n+      --  Following our rule above, if Key is equal to or greater than\n+      --  the last node, then we insert the new node immediately after\n+      --  last. (We don't have an operation for testing whether a key is\n+      --  \"equal to or greater than\" a node, so we must say instead \"not\n+      --  less than\", which is equivalent.)\n+\n+      if Hint = 0 then  -- largest\n+         if Tree.Last = 0 then\n+            Insert_Post (Tree, 0, False, Node);\n+         elsif Is_Less_Key_Node (Key, N (Tree.Last)) then\n+            Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+         else\n+            Insert_Post (Tree, Tree.Last, False, Node);\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      pragma Assert (Tree.Length > 0);\n+\n+      --  We decide here whether to insert the new node prior to the\n+      --  hint. Key could be equivalent to the hint, so in theory we\n+      --  could write the following test as \"not greater than\" (same as\n+      --  \"less than or equal to\"). If Key were equivalent to the hint,\n+      --  that would mean that the new node gets inserted before an\n+      --  equivalent node. That wouldn't break any container invariants,\n+      --  but our rule above says that new nodes always get inserted\n+      --  after equivalent nodes. So here we test whether Key is both\n+      --  less than the hint and equal to or greater than the hint's\n+      --  previous neighbor, and if so insert it before the hint.\n+\n+      if Is_Less_Key_Node (Key, N (Hint)) then\n+         declare\n+            Before : constant Count_Type := Ops.Previous (Tree, Hint);\n+         begin\n+            if Before = 0 then\n+               Insert_Post (Tree, Hint, True, Node);\n+            elsif Is_Less_Key_Node (Key, N (Before)) then\n+               Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+            elsif Ops.Right (N (Before)) = 0 then\n+               Insert_Post (Tree, Before, False, Node);\n+            else\n+               Insert_Post (Tree, Hint, True, Node);\n+            end if;\n+         end;\n+\n+         return;\n+      end if;\n+\n+      --  We know that Key isn't less than the hint, so it must be equal\n+      --  or greater. So we just test whether Key is less than or equal\n+      --  to (same as \"not greater than\") the hint's next neighbor, and\n+      --  if so insert it after the hint.\n+\n+      declare\n+         After : constant Count_Type := Ops.Next (Tree, Hint);\n+      begin\n+         if After = 0 then\n+            Insert_Post (Tree, Hint, False, Node);\n+         elsif Is_Greater_Key_Node (Key, N (After)) then\n+            Unconditional_Insert_Sans_Hint (Tree, Key, Node);\n+         elsif Ops.Right (N (Hint)) = 0 then\n+            Insert_Post (Tree, Hint, False, Node);\n+         else\n+            Insert_Post (Tree, After, True, Node);\n+         end if;\n+      end;\n+   end Generic_Unconditional_Insert_With_Hint;\n+\n+   -----------------\n+   -- Upper_Bound --\n+   -----------------\n+\n+   function Upper_Bound\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type\n+   is\n+      Y : Count_Type;\n+      X : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      Y := 0;\n+\n+      X := Tree.Root;\n+      while X /= 0 loop\n+         if Is_Less_Key_Node (Key, N (X)) then\n+            Y := X;\n+            X := Ops.Left (N (X));\n+         else\n+            X := Ops.Right (N (X));\n+         end if;\n+      end loop;\n+\n+      return Y;\n+   end Upper_Bound;\n+\n+end Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;"}, {"sha": "a96ef28cff3916cde6761b79e2530be17c5c2a49", "filename": "gcc/ada/a-rbtgbk.ads", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbk.ads?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,193 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--            ADA.CONTAINERS.RED_BLACK_TREES.GENERIC_BOUNDED_KEYS           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Tree_Type is used to implement ordered containers. This package declares\n+--  the tree operations that depend on keys.\n+\n+with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n+\n+generic\n+   with package Tree_Operations is new Generic_Bounded_Operations (<>);\n+\n+   use Tree_Operations.Tree_Types;\n+\n+   type Key_Type (<>) is limited private;\n+\n+   with function Is_Less_Key_Node\n+     (L : Key_Type;\n+      R : Node_Type) return Boolean;\n+\n+   with function Is_Greater_Key_Node\n+     (L : Key_Type;\n+      R : Node_Type) return Boolean;\n+\n+package Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys is\n+   pragma Pure;\n+\n+   generic\n+      with function New_Node return Count_Type;\n+\n+   procedure Generic_Insert_Post\n+     (Tree   : in out Tree_Type'Class;\n+      Y      : Count_Type;\n+      Before : Boolean;\n+      Z      : out Count_Type);\n+   --  Completes an insertion after the insertion position has been\n+   --  determined. On output Z contains the index of the newly inserted\n+   --  node, allocated using Allocate. If Tree is busy then\n+   --  Program_Error is raised. If Y is 0, then Tree must be empty.\n+   --  Otherwise Y denotes the insertion position, and Before specifies\n+   --  whether the new node is Y's left (True) or right (False) child.\n+\n+   generic\n+      with procedure Insert_Post\n+        (T : in out Tree_Type'Class;\n+         Y : Count_Type;\n+         B : Boolean;\n+         Z : out Count_Type);\n+\n+   procedure Generic_Conditional_Insert\n+     (Tree     : in out Tree_Type'Class;\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean);\n+   --  Inserts a new node in Tree, but only if the tree does not already\n+   --  contain Key. Generic_Conditional_Insert first searches for a key\n+   --  equivalent to Key in Tree. If an equivalent key is found, then on\n+   --  output Node designates the node with that key and Inserted is\n+   --  False; there is no allocation and Tree is not modified. Otherwise\n+   --  Node designates a new node allocated using Insert_Post, and\n+   --  Inserted is True.\n+\n+   generic\n+      with procedure Insert_Post\n+        (T : in out Tree_Type'Class;\n+         Y : Count_Type;\n+         B : Boolean;\n+         Z : out Count_Type);\n+\n+   procedure Generic_Unconditional_Insert\n+     (Tree : in out Tree_Type'Class;\n+      Key  : Key_Type;\n+      Node : out Count_Type);\n+   --  Inserts a new node in Tree. On output Node designates the new\n+   --  node, which is allocated using Insert_Post. The node is inserted\n+   --  immediately after already-existing equivalent keys.\n+\n+   generic\n+      with procedure Insert_Post\n+        (T : in out Tree_Type'Class;\n+         Y : Count_Type;\n+         B : Boolean;\n+         Z : out Count_Type);\n+\n+      with procedure Unconditional_Insert_Sans_Hint\n+        (Tree    : in out Tree_Type'Class;\n+         Key     : Key_Type;\n+         Node    : out Count_Type);\n+\n+   procedure Generic_Unconditional_Insert_With_Hint\n+     (Tree : in out Tree_Type'Class;\n+      Hint : Count_Type;\n+      Key  : Key_Type;\n+      Node : out Count_Type);\n+   --  Inserts a new node in Tree near position Hint, to avoid having to\n+   --  search from the root for the insertion position. If Hint is 0\n+   --  then Generic_Unconditional_Insert_With_Hint attempts to insert\n+   --  the new node after Tree.Last. If Hint is non-zero then if Key is\n+   --  less than Hint, it attempts to insert the new node immediately\n+   --  prior to Hint. Otherwise it attempts to insert the node\n+   --  immediately following Hint. We say \"attempts\" above to emphasize\n+   --  that insertions always preserve invariants with respect to key\n+   --  order, even when there's a hint. So if Key can't be inserted\n+   --  immediately near Hint, then the new node is inserted in the\n+   --  normal way, by searching for the correct position starting from\n+   --  the root.\n+\n+   generic\n+      with procedure Insert_Post\n+        (T : in out Tree_Type'Class;\n+         Y : Count_Type;\n+         B : Boolean;\n+         Z : out Count_Type);\n+\n+      with procedure Conditional_Insert_Sans_Hint\n+        (Tree     : in out Tree_Type'Class;\n+         Key      : Key_Type;\n+         Node     : out Count_Type;\n+         Inserted : out Boolean);\n+\n+   procedure Generic_Conditional_Insert_With_Hint\n+     (Tree     : in out Tree_Type'Class;\n+      Position : Count_Type;       -- the hint\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean);\n+   --  Inserts a new node in Tree if the tree does not already contain\n+   --  Key, using Position as a hint about where to insert the new node.\n+   --  See Generic_Unconditional_Insert_With_Hint for more details about\n+   --  hint semantics.\n+\n+   function Find\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type;\n+   --  Searches Tree for the smallest node equivalent to Key\n+\n+   function Ceiling\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type;\n+   --  Searches Tree for the smallest node equal to or greater than Key\n+\n+   function Floor\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type;\n+   --  Searches Tree for the largest node less than or equal to Key\n+\n+   function Upper_Bound\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type) return Count_Type;\n+   --  Searches Tree for the smallest node greater than Key\n+\n+   generic\n+      with procedure Process (Index : Count_Type);\n+   procedure Generic_Iteration\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type);\n+   --  Calls Process for each node in Tree equivalent to Key, in order\n+   --  from earliest in range to latest.\n+\n+   generic\n+      with procedure Process (Index : Count_Type);\n+   procedure Generic_Reverse_Iteration\n+     (Tree : Tree_Type'Class;\n+      Key  : Key_Type);\n+   --  Calls Process for each node in Tree equivalent to Key, but in\n+   --  order from largest in range to earliest.\n+\n+end Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;"}, {"sha": "88743b3ce5b87dd2a93b287ca8a6aed3c832b7f6", "filename": "gcc/ada/a-rbtgbo.adb", "status": "added", "additions": 1118, "deletions": 0, "changes": 1118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbo.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,1118 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--         ADA.CONTAINERS.RED_BLACK_TREES.GENERIC_BOUNDED_OPERATIONS        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  The references below to \"CLR\" refer to the following book, from which\n+--  several of the algorithms here were adapted:\n+--     Introduction to Algorithms\n+--     by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest\n+--     Publisher: The MIT Press (June 18, 1990)\n+--     ISBN: 0262031418\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Delete_Fixup (Tree : in out Tree_Type'Class; Node : Count_Type);\n+   procedure Delete_Swap (Tree : in out Tree_Type'Class; Z, Y : Count_Type);\n+\n+   procedure Left_Rotate  (Tree : in out Tree_Type'Class; X : Count_Type);\n+   procedure Right_Rotate (Tree : in out Tree_Type'Class; Y : Count_Type);\n+\n+   ----------------\n+   -- Clear_Tree --\n+   ----------------\n+\n+   procedure Clear_Tree (Tree : in out Tree_Type'Class) is\n+   begin\n+      if Tree.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Tree.First := 0;\n+      Tree.Last := 0;\n+      Tree.Root := 0;\n+      Tree.Length := 0;\n+      --  Tree.Busy\n+      --  Tree.Lock\n+      Tree.Free := -1;\n+   end Clear_Tree;\n+\n+   ------------------\n+   -- Delete_Fixup --\n+   ------------------\n+\n+   procedure Delete_Fixup\n+     (Tree : in out Tree_Type'Class;\n+      Node : Count_Type)\n+   is\n+\n+      --  CLR p274\n+\n+      X : Count_Type;\n+      W : Count_Type;\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      X := Node;\n+      while X /= Tree.Root\n+        and then Color (N (X)) = Black\n+      loop\n+         if X = Left (N (Parent (N (X)))) then\n+            W :=  Right (N (Parent (N (X))));\n+\n+            if Color (N (W)) = Red then\n+               Set_Color (N (W), Black);\n+               Set_Color (N (Parent (N (X))), Red);\n+               Left_Rotate (Tree, Parent (N (X)));\n+               W := Right (N (Parent (N (X))));\n+            end if;\n+\n+            if (Left (N (W))  = 0 or else Color (N (Left (N (W)))) = Black)\n+              and then\n+               (Right (N (W)) = 0 or else Color (N (Right (N (W)))) = Black)\n+            then\n+               Set_Color (N (W), Red);\n+               X := Parent (N (X));\n+\n+            else\n+               if Right (N (W)) = 0\n+                 or else Color (N (Right (N (W)))) = Black\n+               then\n+                  --  As a condition for setting the color of the left child to\n+                  --  black, the left child access value must be non-null. A\n+                  --  truth table analysis shows that if we arrive here, that\n+                  --  condition holds, so there's no need for an explicit test.\n+                  --  The assertion is here to document what we know is true.\n+\n+                  pragma Assert (Left (N (W)) /= 0);\n+                  Set_Color (N (Left (N (W))), Black);\n+\n+                  Set_Color (N (W), Red);\n+                  Right_Rotate (Tree, W);\n+                  W := Right (N (Parent (N (X))));\n+               end if;\n+\n+               Set_Color (N (W), Color (N (Parent (N (X)))));\n+               Set_Color (N (Parent (N (X))), Black);\n+               Set_Color (N (Right (N (W))), Black);\n+               Left_Rotate  (Tree, Parent (N (X)));\n+               X := Tree.Root;\n+            end if;\n+\n+         else\n+            pragma Assert (X = Right (N (Parent (N (X)))));\n+\n+            W :=  Left (N (Parent (N (X))));\n+\n+            if Color (N (W)) = Red then\n+               Set_Color (N (W), Black);\n+               Set_Color (N (Parent (N (X))), Red);\n+               Right_Rotate (Tree, Parent (N (X)));\n+               W := Left (N (Parent (N (X))));\n+            end if;\n+\n+            if (Left (N (W))  = 0 or else Color (N (Left (N (W)))) = Black)\n+                  and then\n+               (Right (N (W)) = 0 or else Color (N (Right (N (W)))) = Black)\n+            then\n+               Set_Color (N (W), Red);\n+               X := Parent (N (X));\n+\n+            else\n+               if Left (N (W)) = 0\n+                 or else Color (N (Left (N (W)))) = Black\n+               then\n+                  --  As a condition for setting the color of the right child\n+                  --  to black, the right child access value must be non-null.\n+                  --  A truth table analysis shows that if we arrive here, that\n+                  --  condition holds, so there's no need for an explicit test.\n+                  --  The assertion is here to document what we know is true.\n+\n+                  pragma Assert (Right (N (W)) /= 0);\n+                  Set_Color (N (Right (N (W))), Black);\n+\n+                  Set_Color (N (W), Red);\n+                  Left_Rotate (Tree, W);\n+                  W := Left (N (Parent (N (X))));\n+               end if;\n+\n+               Set_Color (N (W), Color (N (Parent (N (X)))));\n+               Set_Color (N (Parent (N (X))), Black);\n+               Set_Color (N (Left (N (W))), Black);\n+               Right_Rotate (Tree, Parent (N (X)));\n+               X := Tree.Root;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      Set_Color (N (X), Black);\n+   end Delete_Fixup;\n+\n+   ---------------------------\n+   -- Delete_Node_Sans_Free --\n+   ---------------------------\n+\n+   procedure Delete_Node_Sans_Free\n+     (Tree : in out Tree_Type'Class;\n+      Node : Count_Type)\n+   is\n+      --  CLR p273\n+\n+      X, Y : Count_Type;\n+\n+      Z : constant Count_Type := Node;\n+      pragma Assert (Z /= 0);\n+\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      if Tree.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      pragma Assert (Tree.Length > 0);\n+      pragma Assert (Tree.Root /= 0);\n+      pragma Assert (Tree.First /= 0);\n+      pragma Assert (Tree.Last /= 0);\n+      pragma Assert (Parent (N (Tree.Root)) = 0);\n+\n+      pragma Assert ((Tree.Length > 1)\n+                        or else (Tree.First = Tree.Last\n+                                   and then Tree.First = Tree.Root));\n+\n+      pragma Assert ((Left (N (Node)) = 0)\n+                        or else (Parent (N (Left (N (Node)))) = Node));\n+\n+      pragma Assert ((Right (N (Node)) = 0)\n+                        or else (Parent (N (Right (N (Node)))) = Node));\n+\n+      pragma Assert (((Parent (N (Node)) = 0) and then (Tree.Root = Node))\n+                        or else ((Parent (N (Node)) /= 0) and then\n+                                  ((Left (N (Parent (N (Node)))) = Node)\n+                                      or else\n+                                   (Right (N (Parent (N (Node)))) = Node))));\n+\n+      if Left (N (Z)) = 0 then\n+         if Right (N (Z)) = 0 then\n+            if Z = Tree.First then\n+               Tree.First := Parent (N (Z));\n+            end if;\n+\n+            if Z = Tree.Last then\n+               Tree.Last := Parent (N (Z));\n+            end if;\n+\n+            if Color (N (Z)) = Black then\n+               Delete_Fixup (Tree, Z);\n+            end if;\n+\n+            pragma Assert (Left (N (Z)) = 0);\n+            pragma Assert (Right (N (Z)) = 0);\n+\n+            if Z = Tree.Root then\n+               pragma Assert (Tree.Length = 1);\n+               pragma Assert (Parent (N (Z)) = 0);\n+               Tree.Root := 0;\n+            elsif Z = Left (N (Parent (N (Z)))) then\n+               Set_Left (N (Parent (N (Z))), 0);\n+            else\n+               pragma Assert (Z = Right (N (Parent (N (Z)))));\n+               Set_Right (N (Parent (N (Z))), 0);\n+            end if;\n+\n+         else\n+            pragma Assert (Z /= Tree.Last);\n+\n+            X := Right (N (Z));\n+\n+            if Z = Tree.First then\n+               Tree.First := Min (Tree, X);\n+            end if;\n+\n+            if Z = Tree.Root then\n+               Tree.Root := X;\n+            elsif Z = Left (N (Parent (N (Z)))) then\n+               Set_Left (N (Parent (N (Z))), X);\n+            else\n+               pragma Assert (Z = Right (N (Parent (N (Z)))));\n+               Set_Right (N (Parent (N (Z))), X);\n+            end if;\n+\n+            Set_Parent (N (X), Parent (N (Z)));\n+\n+            if Color (N (Z)) = Black then\n+               Delete_Fixup (Tree, X);\n+            end if;\n+         end if;\n+\n+      elsif Right (N (Z)) = 0 then\n+         pragma Assert (Z /= Tree.First);\n+\n+         X := Left (N (Z));\n+\n+         if Z = Tree.Last then\n+            Tree.Last := Max (Tree, X);\n+         end if;\n+\n+         if Z = Tree.Root then\n+            Tree.Root := X;\n+         elsif Z = Left (N (Parent (N (Z)))) then\n+            Set_Left (N (Parent (N (Z))), X);\n+         else\n+            pragma Assert (Z = Right (N (Parent (N (Z)))));\n+            Set_Right (N (Parent (N (Z))), X);\n+         end if;\n+\n+         Set_Parent (N (X), Parent (N (Z)));\n+\n+         if Color (N (Z)) = Black then\n+            Delete_Fixup (Tree, X);\n+         end if;\n+\n+      else\n+         pragma Assert (Z /= Tree.First);\n+         pragma Assert (Z /= Tree.Last);\n+\n+         Y := Next (Tree, Z);\n+         pragma Assert (Left (N (Y)) = 0);\n+\n+         X := Right (N (Y));\n+\n+         if X = 0 then\n+            if Y = Left (N (Parent (N (Y)))) then\n+               pragma Assert (Parent (N (Y)) /= Z);\n+               Delete_Swap (Tree, Z, Y);\n+               Set_Left (N (Parent (N (Z))), Z);\n+\n+            else\n+               pragma Assert (Y = Right (N (Parent (N (Y)))));\n+               pragma Assert (Parent (N (Y)) = Z);\n+               Set_Parent (N (Y), Parent (N (Z)));\n+\n+               if Z = Tree.Root then\n+                  Tree.Root := Y;\n+               elsif Z = Left (N (Parent (N (Z)))) then\n+                  Set_Left (N (Parent (N (Z))), Y);\n+               else\n+                  pragma Assert (Z = Right (N (Parent (N (Z)))));\n+                  Set_Right (N (Parent (N (Z))), Y);\n+               end if;\n+\n+               Set_Left (N (Y), Z);\n+               Set_Parent (N (Left (N (Y))), Y);\n+               Set_Right (N (Y), Z);\n+               Set_Parent (N (Z), Y);\n+               Set_Left (N (Z), 0);\n+               Set_Right (N (Z), 0);\n+\n+               declare\n+                  Y_Color : constant Color_Type := Color (N (Y));\n+               begin\n+                  Set_Color (N (Y), Color (N (Z)));\n+                  Set_Color (N (Z), Y_Color);\n+               end;\n+            end if;\n+\n+            if Color (N (Z)) = Black then\n+               Delete_Fixup (Tree, Z);\n+            end if;\n+\n+            pragma Assert (Left (N (Z)) = 0);\n+            pragma Assert (Right (N (Z)) = 0);\n+\n+            if Z = Right (N (Parent (N (Z)))) then\n+               Set_Right (N (Parent (N (Z))), 0);\n+            else\n+               pragma Assert (Z = Left (N (Parent (N (Z)))));\n+               Set_Left (N (Parent (N (Z))), 0);\n+            end if;\n+\n+         else\n+            if Y = Left (N (Parent (N (Y)))) then\n+               pragma Assert (Parent (N (Y)) /= Z);\n+\n+               Delete_Swap (Tree, Z, Y);\n+\n+               Set_Left (N (Parent (N (Z))), X);\n+               Set_Parent (N (X), Parent (N (Z)));\n+\n+            else\n+               pragma Assert (Y = Right (N (Parent (N (Y)))));\n+               pragma Assert (Parent (N (Y)) = Z);\n+\n+               Set_Parent (N (Y), Parent (N (Z)));\n+\n+               if Z = Tree.Root then\n+                  Tree.Root := Y;\n+               elsif Z = Left (N (Parent (N (Z)))) then\n+                  Set_Left (N (Parent (N (Z))), Y);\n+               else\n+                  pragma Assert (Z = Right (N (Parent (N (Z)))));\n+                  Set_Right (N (Parent (N (Z))), Y);\n+               end if;\n+\n+               Set_Left (N (Y), Left (N (Z)));\n+               Set_Parent (N (Left (N (Y))), Y);\n+\n+               declare\n+                  Y_Color : constant Color_Type := Color (N (Y));\n+               begin\n+                  Set_Color (N (Y), Color (N (Z)));\n+                  Set_Color (N (Z), Y_Color);\n+               end;\n+            end if;\n+\n+            if Color (N (Z)) = Black then\n+               Delete_Fixup (Tree, X);\n+            end if;\n+         end if;\n+      end if;\n+\n+      Tree.Length := Tree.Length - 1;\n+   end Delete_Node_Sans_Free;\n+\n+   -----------------\n+   -- Delete_Swap --\n+   -----------------\n+\n+   procedure Delete_Swap\n+     (Tree : in out Tree_Type'Class;\n+      Z, Y : Count_Type)\n+   is\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+      pragma Assert (Z /= Y);\n+      pragma Assert (Parent (N (Y)) /= Z);\n+\n+      Y_Parent : constant Count_Type := Parent (N (Y));\n+      Y_Color  : constant Color_Type  := Color (N (Y));\n+\n+   begin\n+      Set_Parent (N (Y), Parent (N (Z)));\n+      Set_Left (N (Y), Left (N (Z)));\n+      Set_Right (N (Y), Right (N (Z)));\n+      Set_Color (N (Y), Color (N (Z)));\n+\n+      if Tree.Root = Z then\n+         Tree.Root := Y;\n+      elsif Right (N (Parent (N (Y)))) = Z then\n+         Set_Right (N (Parent (N (Y))), Y);\n+      else\n+         pragma Assert (Left (N (Parent (N (Y)))) = Z);\n+         Set_Left (N (Parent (N (Y))), Y);\n+      end if;\n+\n+      if Right (N (Y)) /= 0 then\n+         Set_Parent (N (Right (N (Y))), Y);\n+      end if;\n+\n+      if Left (N (Y)) /= 0 then\n+         Set_Parent (N (Left (N (Y))), Y);\n+      end if;\n+\n+      Set_Parent (N (Z), Y_Parent);\n+      Set_Color (N (Z), Y_Color);\n+      Set_Left (N (Z), 0);\n+      Set_Right (N (Z), 0);\n+   end Delete_Swap;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Tree : in out Tree_Type'Class; X : Count_Type) is\n+      pragma Assert (X > 0);\n+      pragma Assert (X <= Tree.Capacity);\n+\n+      N : Nodes_Type renames Tree.Nodes;\n+      --  pragma Assert (N (X).Prev >= 0);  -- node is active\n+      --  Find a way to mark a node as active vs. inactive; we could\n+      --  use a special value in Color_Type for this.  ???\n+\n+   begin\n+      --  The set container actually contains two data structures: a list for\n+      --  the \"active\" nodes that contain elements that have been inserted\n+      --  onto the tree, and another for the \"inactive\" nodes of the free\n+      --  store.\n+      --\n+      --  We desire that merely declaring an object should have only minimal\n+      --  cost; specially, we want to avoid having to initialize the free\n+      --  store (to fill in the links), especially if the capacity is large.\n+      --\n+      --  The head of the free list is indicated by Container.Free. If its\n+      --  value is non-negative, then the free store has been initialized\n+      --  in the \"normal\" way: Container.Free points to the head of the list\n+      --  of free (inactive) nodes, and the value 0 means the free list is\n+      --  empty. Each node on the free list has been initialized to point\n+      --  to the next free node (via its Parent component), and the value 0\n+      --  means that this is the last free node.\n+      --\n+      --  If Container.Free is negative, then the links on the free store\n+      --  have not been initialized. In this case the link values are\n+      --  implied: the free store comprises the components of the node array\n+      --  started with the absolute value of Container.Free, and continuing\n+      --  until the end of the array (Nodes'Last).\n+      --\n+      --  ???\n+      --  It might be possible to perform an optimization here. Suppose that\n+      --  the free store can be represented as having two parts: one\n+      --  comprising the non-contiguous inactive nodes linked together\n+      --  in the normal way, and the other comprising the contiguous\n+      --  inactive nodes (that are not linked together, at the end of the\n+      --  nodes array). This would allow us to never have to initialize\n+      --  the free store, except in a lazy way as nodes become inactive.\n+\n+      --  When an element is deleted from the list container, its node\n+      --  becomes inactive, and so we set its Prev component to a negative\n+      --  value, to indicate that it is now inactive. This provides a useful\n+      --  way to detect a dangling cursor reference.\n+\n+      --  The comment above is incorrect; we need some other way to\n+      --  indicate a node is inactive, for example by using a special\n+      --  Color_Type value.  ???\n+      --  N (X).Prev := -1;  -- Node is deallocated (not on active list)\n+\n+      if Tree.Free >= 0 then\n+         --  The free store has previously been initialized. All we need to\n+         --  do here is link the newly-free'd node onto the free list.\n+\n+         Set_Parent (N (X), Tree.Free);\n+         Tree.Free := X;\n+\n+      elsif X + 1 = abs Tree.Free then\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive immediately precedes the start of the free store. All\n+         --  we need to do is move the start of the free store back by one.\n+\n+         Tree.Free := Tree.Free + 1;\n+\n+      else\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive does not immediately precede the free store. Here we\n+         --  first initialize the free store (meaning the links are given\n+         --  values in the traditional way), and then link the newly-free'd\n+         --  node onto the head of the free store.\n+\n+         --  ???\n+         --  See the comments above for an optimization opportunity. If\n+         --  the next link for a node on the free store is negative, then\n+         --  this means the remaining nodes on the free store are\n+         --  physically contiguous, starting as the absolute value of\n+         --  that index value.\n+\n+         Tree.Free := abs Tree.Free;\n+\n+         if Tree.Free > Tree.Capacity then\n+            Tree.Free := 0;\n+\n+         else\n+            for I in Tree.Free .. Tree.Capacity - 1 loop\n+               Set_Parent (N (I), I + 1);\n+            end loop;\n+\n+            Set_Parent (N (Tree.Capacity), 0);\n+         end if;\n+\n+         Set_Parent (N (X), Tree.Free);\n+         Tree.Free := X;\n+      end if;\n+   end Free;\n+\n+   -----------------------\n+   -- Generic_Allocate --\n+   -----------------------\n+\n+   procedure Generic_Allocate\n+     (Tree : in out Tree_Type'Class;\n+      Node : out Count_Type)\n+   is\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      if Tree.Free >= 0 then\n+         Node := Tree.Free;\n+\n+         --  We always perform the assignment first, before we\n+         --  change container state, in order to defend against\n+         --  exceptions duration assignment.\n+\n+         Set_Element (N (Node));\n+         Tree.Free := Parent (N (Node));\n+\n+      else\n+         --  A negative free store value means that the links of the nodes\n+         --  in the free store have not been initialized. In this case, the\n+         --  nodes are physically contiguous in the array, starting at the\n+         --  index that is the absolute value of the Container.Free, and\n+         --  continuing until the end of the array (Nodes'Last).\n+\n+         Node := abs Tree.Free;\n+\n+         --  As above, we perform this assignment first, before modifying\n+         --  any container state.\n+\n+         Set_Element (N (Node));\n+         Tree.Free := Tree.Free - 1;\n+      end if;\n+   end Generic_Allocate;\n+\n+   -------------------\n+   -- Generic_Equal --\n+   -------------------\n+\n+   function Generic_Equal (Left, Right : Tree_Type'Class) return Boolean is\n+      L_Node : Count_Type;\n+      R_Node : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      L_Node := Left.First;\n+      R_Node := Right.First;\n+      while L_Node /= 0 loop\n+         if not Is_Equal (Left.Nodes (L_Node), Right.Nodes (R_Node)) then\n+            return False;\n+         end if;\n+\n+         L_Node := Next (Left, L_Node);\n+         R_Node := Next (Right, R_Node);\n+      end loop;\n+\n+      return True;\n+   end Generic_Equal;\n+\n+   -----------------------\n+   -- Generic_Iteration --\n+   -----------------------\n+\n+   procedure Generic_Iteration (Tree : Tree_Type'Class) is\n+      procedure Iterate (P : Count_Type);\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      procedure Iterate (P : Count_Type) is\n+         X : Count_Type := P;\n+      begin\n+         while X /= 0 loop\n+            Iterate (Left (Tree.Nodes (X)));\n+            Process (X);\n+            X := Right (Tree.Nodes (X));\n+         end loop;\n+      end Iterate;\n+\n+   --  Start of processing for Generic_Iteration\n+\n+   begin\n+      Iterate (Tree.Root);\n+   end Generic_Iteration;\n+\n+   ------------------\n+   -- Generic_Read --\n+   ------------------\n+\n+   procedure Generic_Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Tree   : in out Tree_Type'Class)\n+   is\n+      Len : Count_Type'Base;\n+\n+      Node, Last_Node : Count_Type;\n+\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+   begin\n+      Clear_Tree (Tree);\n+      Count_Type'Base'Read (Stream, Len);\n+\n+      if Len < 0 then\n+         raise Program_Error with \"bad container length (corrupt stream)\";\n+      end if;\n+\n+      if Len = 0 then\n+         return;\n+      end if;\n+\n+      if Len > Tree.Capacity then\n+         raise Constraint_Error with \"length exceeds capacity\";\n+      end if;\n+\n+      --  Use Unconditional_Insert_With_Hint here instead ???\n+\n+      Allocate (Tree, Node);\n+      pragma Assert (Node /= 0);\n+\n+      Set_Color (N (Node), Black);\n+\n+      Tree.Root := Node;\n+      Tree.First := Node;\n+      Tree.Last := Node;\n+      Tree.Length := 1;\n+\n+      for J in Count_Type range 2 .. Len loop\n+         Last_Node := Node;\n+         pragma Assert (Last_Node = Tree.Last);\n+\n+         Allocate (Tree, Node);\n+         pragma Assert (Node /= 0);\n+\n+         Set_Color (N (Node), Red);\n+         Set_Right (N (Last_Node), Right => Node);\n+         Tree.Last := Node;\n+         Set_Parent (N (Node), Parent => Last_Node);\n+\n+         Rebalance_For_Insert (Tree, Node);\n+         Tree.Length := Tree.Length + 1;\n+      end loop;\n+   end Generic_Read;\n+\n+   -------------------------------\n+   -- Generic_Reverse_Iteration --\n+   -------------------------------\n+\n+   procedure Generic_Reverse_Iteration (Tree : Tree_Type'Class) is\n+      procedure Iterate (P : Count_Type);\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      procedure Iterate (P : Count_Type) is\n+         X : Count_Type := P;\n+      begin\n+         while X /= 0 loop\n+            Iterate (Right (Tree.Nodes (X)));\n+            Process (X);\n+            X := Left (Tree.Nodes (X));\n+         end loop;\n+      end Iterate;\n+\n+   --  Start of processing for Generic_Reverse_Iteration\n+\n+   begin\n+      Iterate (Tree.Root);\n+   end Generic_Reverse_Iteration;\n+\n+   -------------------\n+   -- Generic_Write --\n+   -------------------\n+\n+   procedure Generic_Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Tree   : Tree_Type'Class)\n+   is\n+      procedure Process (Node : Count_Type);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is\n+         new Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Node : Count_Type) is\n+      begin\n+         Write_Node (Stream, Tree.Nodes (Node));\n+      end Process;\n+\n+   --  Start of processing for Generic_Write\n+\n+   begin\n+      Count_Type'Base'Write (Stream, Tree.Length);\n+      Iterate (Tree);\n+   end Generic_Write;\n+\n+   -----------------\n+   -- Left_Rotate --\n+   -----------------\n+\n+   procedure Left_Rotate (Tree : in out Tree_Type'Class; X : Count_Type) is\n+      --  CLR p266\n+\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+      Y : constant Count_Type := Right (N (X));\n+      pragma Assert (Y /= 0);\n+\n+   begin\n+      Set_Right (N (X), Left (N (Y)));\n+\n+      if Left (N (Y)) /= 0 then\n+         Set_Parent (N (Left (N (Y))), X);\n+      end if;\n+\n+      Set_Parent (N (Y), Parent (N (X)));\n+\n+      if X = Tree.Root then\n+         Tree.Root := Y;\n+      elsif X = Left (N (Parent (N (X)))) then\n+         Set_Left (N (Parent (N (X))), Y);\n+      else\n+         pragma Assert (X = Right (N (Parent (N (X)))));\n+         Set_Right (N (Parent (N (X))), Y);\n+      end if;\n+\n+      Set_Left (N (Y), X);\n+      Set_Parent (N (X), Y);\n+   end Left_Rotate;\n+\n+   ---------\n+   -- Max --\n+   ---------\n+\n+   function Max\n+     (Tree : Tree_Type'Class;\n+      Node : Count_Type) return Count_Type\n+   is\n+      --  CLR p248\n+\n+      X : Count_Type := Node;\n+      Y : Count_Type;\n+\n+   begin\n+      loop\n+         Y := Right (Tree.Nodes (X));\n+\n+         if Y = 0 then\n+            return X;\n+         end if;\n+\n+         X := Y;\n+      end loop;\n+   end Max;\n+\n+   ---------\n+   -- Min --\n+   ---------\n+\n+   function Min\n+     (Tree : Tree_Type'Class;\n+      Node : Count_Type) return Count_Type\n+   is\n+      --  CLR p248\n+\n+      X : Count_Type := Node;\n+      Y : Count_Type;\n+\n+   begin\n+      loop\n+         Y := Left (Tree.Nodes (X));\n+\n+         if Y = 0 then\n+            return X;\n+         end if;\n+\n+         X := Y;\n+      end loop;\n+   end Min;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (Tree : Tree_Type'Class;\n+      Node : Count_Type) return Count_Type\n+   is\n+   begin\n+      --  CLR p249\n+\n+      if Node = 0 then\n+         return 0;\n+      end if;\n+\n+      if Right (Tree.Nodes (Node)) /= 0 then\n+         return Min (Tree, Right (Tree.Nodes (Node)));\n+      end if;\n+\n+      declare\n+         X : Count_Type := Node;\n+         Y : Count_Type := Parent (Tree.Nodes (Node));\n+\n+      begin\n+         while Y /= 0\n+           and then X = Right (Tree.Nodes (Y))\n+         loop\n+            X := Y;\n+            Y := Parent (Tree.Nodes (Y));\n+         end loop;\n+\n+         return Y;\n+      end;\n+   end Next;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   function Previous\n+     (Tree : Tree_Type'Class;\n+      Node : Count_Type) return Count_Type\n+   is\n+   begin\n+      if Node = 0 then\n+         return 0;\n+      end if;\n+\n+      if Left (Tree.Nodes (Node)) /= 0 then\n+         return Max (Tree, Left (Tree.Nodes (Node)));\n+      end if;\n+\n+      declare\n+         X : Count_Type := Node;\n+         Y : Count_Type := Parent (Tree.Nodes (Node));\n+\n+      begin\n+         while Y /= 0\n+           and then X = Left (Tree.Nodes (Y))\n+         loop\n+            X := Y;\n+            Y := Parent (Tree.Nodes (Y));\n+         end loop;\n+\n+         return Y;\n+      end;\n+   end Previous;\n+\n+   --------------------------\n+   -- Rebalance_For_Insert --\n+   --------------------------\n+\n+   procedure Rebalance_For_Insert\n+     (Tree : in out Tree_Type'Class;\n+      Node : Count_Type)\n+   is\n+      --  CLR p.268\n+\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+      X : Count_Type := Node;\n+      pragma Assert (X /= 0);\n+      pragma Assert (Color (N (X)) = Red);\n+\n+      Y : Count_Type;\n+\n+   begin\n+      while X /= Tree.Root and then Color (N (Parent (N (X)))) = Red loop\n+         if Parent (N (X)) = Left (N (Parent (N (Parent (N (X)))))) then\n+            Y := Right (N (Parent (N (Parent (N (X))))));\n+\n+            if Y /= 0 and then Color (N (Y)) = Red then\n+               Set_Color (N (Parent (N (X))), Black);\n+               Set_Color (N (Y), Black);\n+               Set_Color (N (Parent (N (Parent (N (X))))), Red);\n+               X := Parent (N (Parent (N (X))));\n+\n+            else\n+               if X = Right (N (Parent (N (X)))) then\n+                  X := Parent (N (X));\n+                  Left_Rotate (Tree, X);\n+               end if;\n+\n+               Set_Color (N (Parent (N (X))), Black);\n+               Set_Color (N (Parent (N (Parent (N (X))))), Red);\n+               Right_Rotate (Tree, Parent (N (Parent (N (X)))));\n+            end if;\n+\n+         else\n+            pragma Assert (Parent (N (X)) =\n+                             Right (N (Parent (N (Parent (N (X)))))));\n+\n+            Y := Left (N (Parent (N (Parent (N (X))))));\n+\n+            if Y /= 0 and then Color (N (Y)) = Red then\n+               Set_Color (N (Parent (N (X))), Black);\n+               Set_Color (N (Y), Black);\n+               Set_Color (N (Parent (N (Parent (N (X))))), Red);\n+               X := Parent (N (Parent (N (X))));\n+\n+            else\n+               if X = Left (N (Parent (N (X)))) then\n+                  X := Parent (N (X));\n+                  Right_Rotate (Tree, X);\n+               end if;\n+\n+               Set_Color (N (Parent (N (X))), Black);\n+               Set_Color (N (Parent (N (Parent (N (X))))), Red);\n+               Left_Rotate (Tree, Parent (N (Parent (N (X)))));\n+            end if;\n+         end if;\n+      end loop;\n+\n+      Set_Color (N (Tree.Root), Black);\n+   end Rebalance_For_Insert;\n+\n+   ------------------\n+   -- Right_Rotate --\n+   ------------------\n+\n+   procedure Right_Rotate (Tree : in out Tree_Type'Class; Y : Count_Type) is\n+      N : Nodes_Type renames Tree.Nodes;\n+\n+      X : constant Count_Type := Left (N (Y));\n+      pragma Assert (X /= 0);\n+\n+   begin\n+      Set_Left (N (Y), Right (N (X)));\n+\n+      if Right (N (X)) /= 0 then\n+         Set_Parent (N (Right (N (X))), Y);\n+      end if;\n+\n+      Set_Parent (N (X), Parent (N (Y)));\n+\n+      if Y = Tree.Root then\n+         Tree.Root := X;\n+      elsif Y = Left (N (Parent (N (Y)))) then\n+         Set_Left (N (Parent (N (Y))), X);\n+      else\n+         pragma Assert (Y = Right (N (Parent (N (Y)))));\n+         Set_Right (N (Parent (N (Y))), X);\n+      end if;\n+\n+      Set_Right (N (X), Y);\n+      Set_Parent (N (Y), X);\n+   end Right_Rotate;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Tree : Tree_Type'Class; Index : Count_Type) return Boolean is\n+      Nodes : Nodes_Type renames Tree.Nodes;\n+      Node  : Node_Type renames Nodes (Index);\n+\n+   begin\n+      if Parent (Node) = Index\n+        or else Left (Node) = Index\n+        or else Right (Node) = Index\n+      then\n+         return False;\n+      end if;\n+\n+      if Tree.Length = 0\n+        or else Tree.Root = 0\n+        or else Tree.First = 0\n+        or else Tree.Last = 0\n+      then\n+         return False;\n+      end if;\n+\n+      if Parent (Nodes (Tree.Root)) /= 0 then\n+         return False;\n+      end if;\n+\n+      if Left (Nodes (Tree.First)) /= 0 then\n+         return False;\n+      end if;\n+\n+      if Right (Nodes (Tree.Last)) /= 0 then\n+         return False;\n+      end if;\n+\n+      if Tree.Length = 1 then\n+         if Tree.First /= Tree.Last\n+           or else Tree.First /= Tree.Root\n+         then\n+            return False;\n+         end if;\n+\n+         if Index /= Tree.First then\n+            return False;\n+         end if;\n+\n+         if Parent (Node) /= 0\n+           or else Left (Node) /= 0\n+           or else Right (Node) /= 0\n+         then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end if;\n+\n+      if Tree.First = Tree.Last then\n+         return False;\n+      end if;\n+\n+      if Tree.Length = 2 then\n+         if Tree.First /= Tree.Root\n+           and then Tree.Last /= Tree.Root\n+         then\n+            return False;\n+         end if;\n+\n+         if Tree.First /= Index\n+           and then Tree.Last /= Index\n+         then\n+            return False;\n+         end if;\n+      end if;\n+\n+      if Left (Node) /= 0\n+        and then Parent (Nodes (Left (Node))) /= Index\n+      then\n+         return False;\n+      end if;\n+\n+      if Right (Node) /= 0\n+        and then Parent (Nodes (Right (Node))) /= Index\n+      then\n+         return False;\n+      end if;\n+\n+      if Parent (Node) = 0 then\n+         if Tree.Root /= Index then\n+            return False;\n+         end if;\n+\n+      elsif Left (Nodes (Parent (Node))) /= Index\n+        and then Right (Nodes (Parent (Node))) /= Index\n+      then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Vet;\n+\n+end Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;"}, {"sha": "b6aae737fd3b78d472d892f32362b60676193260", "filename": "gcc/ada/a-rbtgbo.ads", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fa-rbtgbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbo.ads?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -0,0 +1,155 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--         ADA.CONTAINERS.RED_BLACK_TREES.GENERIC_BOUNDED_OPERATIONS        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Tree_Type is used to implement the ordered containers. This package\n+--  declares the tree operations that do not depend on keys.\n+\n+with Ada.Streams; use Ada.Streams;\n+\n+generic\n+   with package Tree_Types is new Generic_Bounded_Tree_Types (<>);\n+   use Tree_Types;\n+\n+   with function  Parent (Node : Node_Type) return Count_Type is <>;\n+\n+   with procedure Set_Parent\n+     (Node   : in out Node_Type;\n+      Parent : Count_Type) is <>;\n+\n+   with function  Left (Node : Node_Type) return Count_Type is <>;\n+\n+   with procedure Set_Left\n+     (Node : in out Node_Type;\n+      Left : Count_Type) is <>;\n+\n+   with function  Right (Node : Node_Type) return Count_Type is <>;\n+\n+   with procedure Set_Right\n+     (Node  : in out Node_Type;\n+      Right : Count_Type) is <>;\n+\n+   with function  Color (Node : Node_Type) return Color_Type is <>;\n+\n+   with procedure Set_Color\n+     (Node  : in out Node_Type;\n+      Color : Color_Type) is <>;\n+\n+package Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations is\n+   pragma Pure;\n+\n+   function Min (Tree : Tree_Type'Class; Node : Count_Type) return Count_Type;\n+   --  Returns the smallest-valued node of the subtree rooted at Node\n+\n+   function Max (Tree : Tree_Type'Class; Node : Count_Type) return Count_Type;\n+   --  Returns the largest-valued node of the subtree rooted at Node\n+\n+   function Vet (Tree : Tree_Type'Class; Index : Count_Type) return Boolean;\n+   --  Inspects Node to determine (to the extent possible) whether\n+   --  the node is valid; used to detect if the node is dangling.\n+\n+   function Next\n+     (Tree : Tree_Type'Class;\n+      Node : Count_Type) return Count_Type;\n+   --  Returns the smallest node greater than Node\n+\n+   function Previous\n+     (Tree : Tree_Type'Class;\n+      Node : Count_Type) return Count_Type;\n+   --  Returns the largest node less than Node\n+\n+   generic\n+      with function Is_Equal (L, R : Node_Type) return Boolean;\n+   function Generic_Equal (Left, Right : Tree_Type'Class) return Boolean;\n+   --  Uses Is_Equal to perform a node-by-node comparison of the\n+   --  Left and Right trees; processing stops as soon as the first\n+   --  non-equal node is found.\n+\n+   procedure Delete_Node_Sans_Free\n+     (Tree : in out Tree_Type'Class; Node : Count_Type);\n+   --  Removes Node from Tree without deallocating the node. If Tree\n+   --  is busy then Program_Error is raised.\n+\n+   procedure Clear_Tree (Tree : in out Tree_Type'Class);\n+   --  Clears Tree by deallocating all of its nodes. If Tree is busy then\n+   --  Program_Error is raised.\n+\n+   generic\n+      with procedure Process (Node : Count_Type) is <>;\n+   procedure Generic_Iteration (Tree : Tree_Type'Class);\n+   --  Calls Process for each node in Tree, in order from smallest-valued\n+   --  node to largest-valued node.\n+\n+   generic\n+      with procedure Process (Node : Count_Type) is <>;\n+   procedure Generic_Reverse_Iteration (Tree : Tree_Type'Class);\n+   --  Calls Process for each node in Tree, in order from largest-valued\n+   --  node to smallest-valued node.\n+\n+   generic\n+      with procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+   procedure Generic_Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Tree   : Tree_Type'Class);\n+   --  Used to implement stream attribute T'Write. Generic_Write\n+   --  first writes the number of nodes into Stream, then calls\n+   --  Write_Node for each node in Tree.\n+\n+   generic\n+      with procedure Allocate\n+        (Tree : in out Tree_Type'Class;\n+         Node : out Count_Type);\n+   procedure Generic_Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Tree   : in out Tree_Type'Class);\n+   --  Used to implement stream attribute T'Read. Generic_Read\n+   --  first clears Tree. It then reads the number of nodes out of\n+   --  Stream, and calls Read_Node for each node in Stream.\n+\n+   procedure Rebalance_For_Insert\n+     (Tree : in out Tree_Type'Class;\n+      Node : Count_Type);\n+   --  This rebalances Tree to complete the insertion of Node (which\n+   --  must already be linked in at its proper insertion position).\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (Tree : in out Tree_Type'Class;\n+      Node : out Count_Type);\n+   --  Claim a node from the free store. Generic_Allocate first\n+   --  calls Set_Element on the potential node, and then returns\n+   --  the node's index as the value of the Node parameter.\n+\n+   procedure Free (Tree : in out Tree_Type'Class; X : Count_Type);\n+   --  Return a node back to the free store, from where it had\n+   --  been previously claimed via Generic_Allocate.\n+\n+end Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;"}, {"sha": "855ce34895a1a046cf8610e3f01bd099a3033db5", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -1099,11 +1099,7 @@ __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr)\n        either case. */\n     attr->file_length = statbuf.st_size;  /* all systems */\n \n-#ifndef __MINGW32__\n-  /* on Windows requires extra system call, see comment in\n-     __gnat_file_exists_attr */\n   attr->exists = !ret;\n-#endif\n \n #if !defined (_WIN32) || defined (RTX)\n   /* on Windows requires extra system call, see __gnat_is_readable_file_attr */\n@@ -1343,7 +1339,8 @@ win32_filetime (HANDLE h)\n }\n \n /* As above but starting from a FILETIME.  */\n-static void f2t (const FILETIME *ft, time_t *t)\n+static void\n+f2t (const FILETIME *ft, time_t *t)\n {\n   union\n   {\n@@ -1363,18 +1360,14 @@ __gnat_file_time_name_attr (char* name, struct file_attributes* attr)\n {\n    if (attr->timestamp == (OS_Time)-2) {\n #if defined (_WIN32) && !defined (RTX)\n+      BOOL res;\n+      WIN32_FILE_ATTRIBUTE_DATA fad;\n       time_t ret = -1;\n       TCHAR wname[GNAT_MAX_PATH_LEN];\n       S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n \n-      HANDLE h = CreateFile\n-        (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n-         OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0);\n-\n-      if (h != INVALID_HANDLE_VALUE) {\n-         ret = win32_filetime (h);\n-         CloseHandle (h);\n-      }\n+      if (res = GetFileAttributesEx (wname, GetFileExInfoStandard, &fad))\n+\tf2t (&fad.ftLastWriteTime, &ret);\n       attr->timestamp = (OS_Time) ret;\n #else\n       __gnat_stat_to_attr (-1, name, attr);\n@@ -1713,17 +1706,17 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n \n   if (res == FALSE)\n     switch (GetLastError()) {\n-    case ERROR_ACCESS_DENIED:\n-    case ERROR_SHARING_VIOLATION:\n-    case ERROR_LOCK_VIOLATION:\n-    case ERROR_SHARING_BUFFER_EXCEEDED:\n-      return EACCES;\n-    case ERROR_BUFFER_OVERFLOW:\n-      return ENAMETOOLONG;\n-    case ERROR_NOT_ENOUGH_MEMORY:\n-      return ENOMEM;\n-    default:\n-      return ENOENT;\n+      case ERROR_ACCESS_DENIED:\n+      case ERROR_SHARING_VIOLATION:\n+      case ERROR_LOCK_VIOLATION:\n+      case ERROR_SHARING_BUFFER_EXCEEDED:\n+\treturn EACCES;\n+      case ERROR_BUFFER_OVERFLOW:\n+\treturn ENAMETOOLONG;\n+      case ERROR_NOT_ENOUGH_MEMORY:\n+\treturn ENOMEM;\n+      default:\n+\treturn ENOENT;\n     }\n \n   f2t (&fad.ftCreationTime, &statbuf->st_ctime);\n@@ -1758,16 +1751,7 @@ int\n __gnat_file_exists_attr (char* name, struct file_attributes* attr)\n {\n    if (attr->exists == ATTR_UNSET) {\n-#ifdef __MINGW32__\n-      /*  On Windows do not use __gnat_stat() because of a bug in Microsoft\n-         _stat() routine. When the system time-zone is set with a negative\n-         offset the _stat() routine fails on specific files like CON:  */\n-      TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n-      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n-      attr->exists = GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n-#else\n       __gnat_stat_to_attr (-1, name, attr);\n-#endif\n    }\n \n    return attr->exists;"}, {"sha": "3ad20602b38953818ac6d053e0d2a495bd1d75ed", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 326, "deletions": 254, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -41,6 +41,7 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n@@ -225,9 +226,7 @@ package body Exp_Dist is\n    --  In either case, this means stubs cannot contain a default-initialized\n    --  object declaration of such type.\n \n-   procedure Add_Calling_Stubs_To_Declarations\n-     (Pkg_Spec : Node_Id;\n-      Decls    : List_Id);\n+   procedure Add_Calling_Stubs_To_Declarations (Pkg_Spec : Node_Id);\n    --  Add calling stubs to the declarative part\n \n    function Could_Be_Asynchronous (Spec : Node_Id) return Boolean;\n@@ -915,27 +914,145 @@ package body Exp_Dist is\n    --  since this require separate mechanisms ('Input is a function while\n    --  'Read is a procedure).\n \n+   generic\n+      with procedure Process_Subprogram_Declaration (Decl : Node_Id);\n+      --  Generate calling or receiving stub for this subprogram declaration\n+\n+   procedure Build_Package_Stubs (Pkg_Spec : Node_Id);\n+   --  Recursively visit the given RCI Package_Specification, calling\n+   --  Process_Subprogram_Declaration for each remote subprogram.\n+\n+   -------------------------\n+   -- Build_Package_Stubs --\n+   -------------------------\n+\n+   procedure Build_Package_Stubs (Pkg_Spec : Node_Id) is\n+      Decls : constant List_Id := Visible_Declarations (Pkg_Spec);\n+      Decl  : Node_Id;\n+\n+      procedure Visit_Nested_Pkg (Nested_Pkg_Decl : Node_Id);\n+      --  Recurse for the given nested package declaration\n+\n+      -----------------------\n+      -- Visit_Nested_Spec --\n+      -----------------------\n+\n+      procedure Visit_Nested_Pkg (Nested_Pkg_Decl : Node_Id) is\n+         Nested_Pkg_Spec : constant Node_Id := Specification (Nested_Pkg_Decl);\n+      begin\n+         Push_Scope (Scope_Of_Spec (Nested_Pkg_Spec));\n+         Build_Package_Stubs (Nested_Pkg_Spec);\n+         Pop_Scope;\n+      end Visit_Nested_Pkg;\n+\n+   --  Start of processing for Build_Package_Stubs\n+\n+   begin\n+      Decl := First (Decls);\n+      while Present (Decl) loop\n+         case Nkind (Decl) is\n+            when N_Subprogram_Declaration =>\n+\n+               --  Note: we test Comes_From_Source on Spec, not Decl, because\n+               --  in the case of a subprogram instance, only the specification\n+               --  (not the declaration) is marked as coming from source.\n+\n+               if Comes_From_Source (Specification (Decl)) then\n+                  Process_Subprogram_Declaration (Decl);\n+               end if;\n+\n+            when N_Package_Declaration =>\n+\n+               --  Case of a nested package or package instantiation coming\n+               --  from source. Note that the anonymous wrapper package for\n+               --  subprogram instances is not flagged Is_Generic_Instance at\n+               --  this point, so there is a distinct circuit to handle them\n+               --  (see case N_Subprogram_Instantiation below).\n+\n+               declare\n+                  Pkg_Ent : constant Entity_Id :=\n+                              Defining_Unit_Name (Specification (Decl));\n+               begin\n+                  if Comes_From_Source (Decl)\n+                    or else\n+                      (Is_Generic_Instance (Pkg_Ent)\n+                         and then Comes_From_Source\n+                                    (Get_Package_Instantiation_Node (Pkg_Ent)))\n+                  then\n+                     Visit_Nested_Pkg (Decl);\n+                  end if;\n+               end;\n+\n+            when N_Subprogram_Instantiation =>\n+\n+               --  The subprogram declaration for an instance of a generic\n+               --  subprogram is wrapped in a package that does not come from\n+               --  source, so we need to explicitly traverse it here.\n+\n+               if Comes_From_Source (Decl) then\n+                  Visit_Nested_Pkg (Instance_Spec (Decl));\n+               end if;\n+\n+            when others =>\n+               null;\n+         end case;\n+         Next (Decl);\n+      end loop;\n+   end Build_Package_Stubs;\n+\n    ---------------------------------------\n    -- Add_Calling_Stubs_To_Declarations --\n    ---------------------------------------\n \n-   procedure Add_Calling_Stubs_To_Declarations\n-     (Pkg_Spec : Node_Id;\n-      Decls    : List_Id)\n-   is\n+   procedure Add_Calling_Stubs_To_Declarations (Pkg_Spec : Node_Id) is\n+      Loc   : constant Source_Ptr := Sloc (Pkg_Spec);\n+\n       Current_Subprogram_Number : Int := First_RCI_Subprogram_Id;\n       --  Subprogram id 0 is reserved for calls received from\n       --  remote access-to-subprogram dereferences.\n \n-      Current_Declaration : Node_Id;\n-      Loc                 : constant Source_Ptr := Sloc (Pkg_Spec);\n       RCI_Instantiation   : Node_Id;\n-      Subp_Stubs          : Node_Id;\n-      Subp_Str            : String_Id;\n \n-      pragma Warnings (Off, Subp_Str);\n+      procedure Visit_Subprogram (Decl : Node_Id);\n+      --  Generate calling stub for one remote subprogram\n+\n+      ----------------------\n+      -- Visit_Subprogram --\n+      ----------------------\n+\n+      procedure Visit_Subprogram (Decl : Node_Id) is\n+         Loc        : constant Source_Ptr := Sloc (Decl);\n+         Spec       : constant Node_Id := Specification (Decl);\n+         Subp_Stubs : Node_Id;\n+         Subp_Str   : String_Id;\n+         pragma Warnings (Off, Subp_Str);\n+\n+      begin\n+         Assign_Subprogram_Identifier\n+           (Defining_Unit_Name (Spec), Current_Subprogram_Number, Subp_Str);\n+\n+         Subp_Stubs :=\n+           Build_Subprogram_Calling_Stubs (\n+             Vis_Decl     => Decl,\n+             Subp_Id      =>\n+               Build_Subprogram_Id (Loc, Defining_Unit_Name (Spec)),\n+             Asynchronous =>\n+               Nkind (Spec) = N_Procedure_Specification\n+                 and then Is_Asynchronous (Defining_Unit_Name (Spec)));\n+\n+         Append_To (List_Containing (Decl), Subp_Stubs);\n+         Analyze (Subp_Stubs);\n+\n+         Current_Subprogram_Number := Current_Subprogram_Number + 1;\n+      end Visit_Subprogram;\n+\n+      procedure Visit_Spec is new Build_Package_Stubs (Visit_Subprogram);\n+\n+   --  Start of processing for Add_Calling_Stubs_To_Declarations\n \n    begin\n+      Push_Scope (Scope_Of_Spec (Pkg_Spec));\n+\n       --  The first thing added is an instantiation of the generic package\n       --  System.Partition_Interface.RCI_Locator with the name of this remote\n       --  package. This will act as an interface with the name server to\n@@ -945,51 +1062,21 @@ package body Exp_Dist is\n       RCI_Instantiation := RCI_Package_Locator (Loc, Pkg_Spec);\n       RCI_Cache         := Defining_Unit_Name (RCI_Instantiation);\n \n-      Append_To (Decls, RCI_Instantiation);\n+      Append_To (Visible_Declarations (Pkg_Spec), RCI_Instantiation);\n       Analyze (RCI_Instantiation);\n \n       --  For each subprogram declaration visible in the spec, we do build a\n       --  body. We also increment a counter to assign a different Subprogram_Id\n-      --  to each subprograms. The receiving stubs processing do use the same\n+      --  to each subprograms. The receiving stubs processing uses the same\n       --  mechanism and will thus assign the same Id and do the correct\n       --  dispatching.\n \n       Overload_Counter_Table.Reset;\n       PolyORB_Support.Reserve_NamingContext_Methods;\n \n-      Current_Declaration := First (Visible_Declarations (Pkg_Spec));\n-      while Present (Current_Declaration) loop\n-         if Nkind (Current_Declaration) = N_Subprogram_Declaration\n-           and then Comes_From_Source (Current_Declaration)\n-         then\n-            Assign_Subprogram_Identifier\n-              (Defining_Unit_Name (Specification (Current_Declaration)),\n-               Current_Subprogram_Number,\n-               Subp_Str);\n-\n-            Subp_Stubs :=\n-              Build_Subprogram_Calling_Stubs (\n-                Vis_Decl     => Current_Declaration,\n-                Subp_Id      =>\n-                  Build_Subprogram_Id (Loc,\n-                    Defining_Unit_Name (Specification (Current_Declaration))),\n-                Asynchronous =>\n-                  Nkind (Specification (Current_Declaration)) =\n-                                                 N_Procedure_Specification\n-                    and then\n-                      Is_Asynchronous (Defining_Unit_Name (Specification\n-                        (Current_Declaration))));\n-\n-            Append_To (Decls, Subp_Stubs);\n-            Analyze (Subp_Stubs);\n-\n-            Current_Subprogram_Number := Current_Subprogram_Number + 1;\n-         end if;\n+      Visit_Spec (Pkg_Spec);\n \n-         --  Need to handle the case of nested packages???\n-\n-         Next (Current_Declaration);\n-      end loop;\n+      Pop_Scope;\n    end Add_Calling_Stubs_To_Declarations;\n \n    -----------------------------\n@@ -2819,12 +2906,8 @@ package body Exp_Dist is\n \n    procedure Expand_Calling_Stubs_Bodies (Unit_Node : Node_Id) is\n       Spec  : constant Node_Id := Specification (Unit_Node);\n-      Decls : constant List_Id := Visible_Declarations (Spec);\n    begin\n-      Push_Scope (Scope_Of_Spec (Spec));\n-      Add_Calling_Stubs_To_Declarations\n-        (Specification (Unit_Node), Decls);\n-      Pop_Scope;\n+      Add_Calling_Stubs_To_Declarations (Spec);\n    end Expand_Calling_Stubs_Bodies;\n \n    -----------------------------------\n@@ -3685,6 +3768,7 @@ package body Exp_Dist is\n          Pkg_RPC_Receiver_Body       : Node_Id;\n          --  A Pkg_RPC_Receiver is built to decode the request\n \n+         Lookup_RAS      : Node_Id;\n          Lookup_RAS_Info : constant Entity_Id := Make_Temporary (Loc, 'R');\n          --  A remote subprogram is created to allow peers to look up RAS\n          --  information using subprogram ids.\n@@ -3693,9 +3777,8 @@ package body Exp_Dist is\n          Subp_Index : Entity_Id;\n          --  Subprogram_Id as read from the incoming stream\n \n-         Current_Declaration       : Node_Id;\n-         Current_Subprogram_Number : Int := First_RCI_Subprogram_Id;\n-         Current_Stubs             : Node_Id;\n+         Current_Subp_Number : Int := First_RCI_Subprogram_Id;\n+         Current_Stubs       : Node_Id;\n \n          Subp_Info_Array : constant Entity_Id := Make_Temporary (Loc, 'I');\n          Subp_Info_List  : constant List_Id := New_List;\n@@ -3713,6 +3796,9 @@ package body Exp_Dist is\n          --  associating Subprogram_Number with the subprogram declared\n          --  by Declaration, for which we have receiving stubs in Stubs.\n \n+         procedure Visit_Subprogram (Decl : Node_Id);\n+         --  Generate receiving stub for one remote subprogram\n+\n          ---------------------\n          -- Append_Stubs_To --\n          ---------------------\n@@ -3736,6 +3822,76 @@ package body Exp_Dist is\n                         New_Occurrence_Of (Request_Parameter, Loc))))));\n          end Append_Stubs_To;\n \n+         ----------------------\n+         -- Visit_Subprogram --\n+         ----------------------\n+\n+         procedure Visit_Subprogram (Decl : Node_Id) is\n+            Loc      : constant Source_Ptr := Sloc (Decl);\n+            Spec     : constant Node_Id    := Specification (Decl);\n+            Subp_Def : constant Entity_Id  := Defining_Unit_Name (Spec);\n+\n+            Subp_Val : String_Id;\n+            pragma Warnings (Off, Subp_Val);\n+\n+         begin\n+            --  Build receiving stub\n+\n+            Current_Stubs :=\n+              Build_Subprogram_Receiving_Stubs\n+                (Vis_Decl     => Decl,\n+                 Asynchronous =>\n+                   Nkind (Spec) = N_Procedure_Specification\n+                     and then Is_Asynchronous (Subp_Def));\n+\n+            Append_To (Decls, Current_Stubs);\n+            Analyze (Current_Stubs);\n+\n+            --  Build RAS proxy\n+\n+            Add_RAS_Proxy_And_Analyze (Decls,\n+              Vis_Decl           => Decl,\n+              All_Calls_Remote_E => All_Calls_Remote_E,\n+              Proxy_Object_Addr  => Proxy_Object_Addr);\n+\n+            --  Compute distribution identifier\n+\n+            Assign_Subprogram_Identifier\n+              (Subp_Def, Current_Subp_Number,  Subp_Val);\n+\n+            pragma Assert (Current_Subp_Number = Get_Subprogram_Id (Subp_Def));\n+\n+            --  Add subprogram descriptor (RCI_Subp_Info) to the subprograms\n+            --  table for this receiver. This aggregate must be kept consistent\n+            --  with the declaration of RCI_Subp_Info in\n+            --  System.Partition_Interface.\n+\n+            Append_To (Subp_Info_List,\n+              Make_Component_Association (Loc,\n+                Choices    => New_List (\n+                  Make_Integer_Literal (Loc, Current_Subp_Number)),\n+\n+                Expression =>\n+                  Make_Aggregate (Loc,\n+                    Component_Associations => New_List (\n+\n+                      --  Addr =>\n+\n+                      Make_Component_Association (Loc,\n+                        Choices    =>\n+                          New_List (Make_Identifier (Loc, Name_Addr)),\n+                        Expression =>\n+                          New_Occurrence_Of (Proxy_Object_Addr, Loc))))));\n+\n+            Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n+                             Stubs             => Current_Stubs,\n+                             Subprogram_Number => Current_Subp_Number);\n+\n+            Current_Subp_Number := Current_Subp_Number + 1;\n+         end Visit_Subprogram;\n+\n+         procedure Visit_Spec is new Build_Package_Stubs (Visit_Subprogram);\n+\n       --  Start of processing for Add_Receiving_Stubs_To_Declarations\n \n       begin\n@@ -3800,7 +3956,7 @@ package body Exp_Dist is\n \n          --  Build a subprogram for RAS information lookups\n \n-         Current_Declaration :=\n+         Lookup_RAS :=\n            Make_Subprogram_Declaration (Loc,\n              Specification =>\n                Make_Function_Specification (Loc,\n@@ -3816,19 +3972,17 @@ package body Exp_Dist is\n                        New_Occurrence_Of (RTE (RE_Subprogram_Id), Loc))),\n                  Result_Definition =>\n                    New_Occurrence_Of (RTE (RE_Unsigned_64), Loc)));\n-\n-         Append_To (Decls, Current_Declaration);\n-         Analyze (Current_Declaration);\n+         Append_To (Decls, Lookup_RAS);\n+         Analyze (Lookup_RAS);\n \n          Current_Stubs := Build_Subprogram_Receiving_Stubs\n-           (Vis_Decl     => Current_Declaration,\n+           (Vis_Decl     => Lookup_RAS,\n             Asynchronous => False);\n          Append_To (Decls, Current_Stubs);\n          Analyze (Current_Stubs);\n \n          Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n-           Stubs       =>\n-             Current_Stubs,\n+           Stubs             => Current_Stubs,\n            Subprogram_Number => 1);\n \n          --  For each subprogram, the receiving stub will be built and a\n@@ -3841,87 +3995,7 @@ package body Exp_Dist is\n \n          Overload_Counter_Table.Reset;\n \n-         Current_Declaration := First (Visible_Declarations (Pkg_Spec));\n-         while Present (Current_Declaration) loop\n-            if Nkind (Current_Declaration) = N_Subprogram_Declaration\n-              and then Comes_From_Source (Current_Declaration)\n-            then\n-               declare\n-                  Loc : constant Source_Ptr := Sloc (Current_Declaration);\n-                  --  While specifically processing Current_Declaration, use\n-                  --  its Sloc as the location of all generated nodes.\n-\n-                  Subp_Def : constant Entity_Id :=\n-                               Defining_Unit_Name\n-                                 (Specification (Current_Declaration));\n-\n-                  Subp_Val : String_Id;\n-                  pragma Warnings (Off, Subp_Val);\n-\n-               begin\n-                  --  Build receiving stub\n-\n-                  Current_Stubs :=\n-                    Build_Subprogram_Receiving_Stubs\n-                      (Vis_Decl     => Current_Declaration,\n-                       Asynchronous =>\n-                         Nkind (Specification (Current_Declaration)) =\n-                             N_Procedure_Specification\n-                           and then Is_Asynchronous (Subp_Def));\n-\n-                  Append_To (Decls, Current_Stubs);\n-                  Analyze (Current_Stubs);\n-\n-                  --  Build RAS proxy\n-\n-                  Add_RAS_Proxy_And_Analyze (Decls,\n-                    Vis_Decl           => Current_Declaration,\n-                    All_Calls_Remote_E => All_Calls_Remote_E,\n-                    Proxy_Object_Addr  => Proxy_Object_Addr);\n-\n-                  --  Compute distribution identifier\n-\n-                  Assign_Subprogram_Identifier\n-                    (Subp_Def,\n-                     Current_Subprogram_Number,\n-                     Subp_Val);\n-\n-                  pragma Assert\n-                    (Current_Subprogram_Number = Get_Subprogram_Id (Subp_Def));\n-\n-                  --  Add subprogram descriptor (RCI_Subp_Info) to the\n-                  --  subprograms table for this receiver. The aggregate\n-                  --  below must be kept consistent with the declaration\n-                  --  of type RCI_Subp_Info in System.Partition_Interface.\n-\n-                  Append_To (Subp_Info_List,\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        Make_Integer_Literal (Loc,\n-                          Current_Subprogram_Number)),\n-\n-                      Expression =>\n-                        Make_Aggregate (Loc,\n-                          Component_Associations => New_List (\n-                            Make_Component_Association (Loc,\n-                              Choices => New_List (\n-                                Make_Identifier (Loc, Name_Addr)),\n-                              Expression =>\n-                                New_Occurrence_Of (\n-                                  Proxy_Object_Addr, Loc))))));\n-\n-                  Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n-                    Stubs             => Current_Stubs,\n-                    Subprogram_Number => Current_Subprogram_Number);\n-               end;\n-\n-               Current_Subprogram_Number := Current_Subprogram_Number + 1;\n-            end if;\n-\n-            --  Need to handle case of a nested package???\n-\n-            Next (Current_Declaration);\n-         end loop;\n+         Visit_Spec (Pkg_Spec);\n \n          --  If we receive an invalid Subprogram_Id, it is best to do nothing\n          --  rather than raising an exception since we do not want someone\n@@ -6654,13 +6728,10 @@ package body Exp_Dist is\n          Dispatch_On_Address : constant List_Id := New_List;\n          Dispatch_On_Name    : constant List_Id := New_List;\n \n-         Current_Declaration       : Node_Id;\n-         Current_Stubs             : Node_Id;\n-         Current_Subprogram_Number : Int := First_RCI_Subprogram_Id;\n+         Current_Subp_Number : Int := First_RCI_Subprogram_Id;\n \n          Subp_Info_Array : constant Entity_Id := Make_Temporary (Loc, 'I');\n-\n-         Subp_Info_List : constant List_Id := New_List;\n+         Subp_Info_List  : constant List_Id := New_List;\n \n          Register_Pkg_Actuals : constant List_Id := New_List;\n \n@@ -6681,6 +6752,9 @@ package body Exp_Dist is\n          --  object, used in the context of calls through remote\n          --  access-to-subprogram types.\n \n+         procedure Visit_Subprogram (Decl : Node_Id);\n+         --  Generate receiving stub for one remote subprogram\n+\n          ---------------------\n          -- Append_Stubs_To --\n          ---------------------\n@@ -6744,6 +6818,110 @@ package body Exp_Dist is\n                     Make_Integer_Literal (Loc, Subp_Number)))));\n          end Append_Stubs_To;\n \n+         ----------------------\n+         -- Visit_Subprogram --\n+         ----------------------\n+\n+         procedure Visit_Subprogram (Decl : Node_Id) is\n+            Loc      : constant Source_Ptr := Sloc (Decl);\n+            Spec     : constant Node_Id    := Specification (Decl);\n+            Subp_Def : constant Entity_Id  := Defining_Unit_Name (Spec);\n+\n+            Subp_Val : String_Id;\n+\n+            Subp_Dist_Name : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars =>\n+                  New_External_Name\n+                    (Related_Id   => Chars (Subp_Def),\n+                     Suffix       => 'D',\n+                     Suffix_Index => -1));\n+\n+            Current_Stubs  : Node_Id;\n+            Proxy_Obj_Addr : Entity_Id;\n+\n+         begin\n+            --  Build receiving stub\n+\n+            Current_Stubs :=\n+              Build_Subprogram_Receiving_Stubs\n+                (Vis_Decl     => Decl,\n+                 Asynchronous =>\n+                   Nkind (Spec) = N_Procedure_Specification\n+                 and then Is_Asynchronous (Subp_Def));\n+\n+            Append_To (Decls, Current_Stubs);\n+            Analyze (Current_Stubs);\n+\n+            --  Build RAS proxy\n+\n+            Add_RAS_Proxy_And_Analyze (Decls,\n+              Vis_Decl           => Decl,\n+              All_Calls_Remote_E => All_Calls_Remote_E,\n+              Proxy_Object_Addr  => Proxy_Obj_Addr);\n+\n+            --  Compute distribution identifier\n+\n+            Assign_Subprogram_Identifier\n+              (Subp_Def, Current_Subp_Number, Subp_Val);\n+\n+            pragma Assert\n+              (Current_Subp_Number = Get_Subprogram_Id (Subp_Def));\n+\n+            Append_To (Decls,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Subp_Dist_Name,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_String, Loc),\n+                Expression          =>\n+                  Make_String_Literal (Loc, Subp_Val)));\n+            Analyze (Last (Decls));\n+\n+            --  Add subprogram descriptor (RCI_Subp_Info) to the subprograms\n+            --  table for this receiver. The aggregate below must be kept\n+            --  consistent with the declaration of RCI_Subp_Info in\n+            --  System.Partition_Interface.\n+\n+            Append_To (Subp_Info_List,\n+              Make_Component_Association (Loc,\n+                Choices    =>\n+                  New_List (Make_Integer_Literal (Loc, Current_Subp_Number)),\n+\n+                Expression =>\n+                  Make_Aggregate (Loc,\n+                    Expressions => New_List (\n+\n+                      --  Name =>\n+\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix         =>\n+                          New_Occurrence_Of (Subp_Dist_Name, Loc),\n+                        Attribute_Name => Name_Address),\n+\n+                      --  Name_Length =>\n+\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix         =>\n+                          New_Occurrence_Of (Subp_Dist_Name, Loc),\n+                        Attribute_Name => Name_Length),\n+\n+                      --  Addr =>\n+\n+                      New_Occurrence_Of (Proxy_Obj_Addr, Loc)))));\n+\n+            Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n+              Declaration     => Decl,\n+              Stubs           => Current_Stubs,\n+              Subp_Number     => Current_Subp_Number,\n+              Subp_Dist_Name  => Subp_Dist_Name,\n+              Subp_Proxy_Addr => Proxy_Obj_Addr);\n+\n+            Current_Subp_Number := Current_Subp_Number + 1;\n+         end Visit_Subprogram;\n+\n+         procedure Visit_Spec is new Build_Package_Stubs (Visit_Subprogram);\n+\n       --  Start of processing for Add_Receiving_Stubs_To_Declarations\n \n       begin\n@@ -6804,113 +6982,7 @@ package body Exp_Dist is\n          Overload_Counter_Table.Reset;\n          Reserve_NamingContext_Methods;\n \n-         Current_Declaration := First (Visible_Declarations (Pkg_Spec));\n-         while Present (Current_Declaration) loop\n-            if Nkind (Current_Declaration) = N_Subprogram_Declaration\n-              and then Comes_From_Source (Current_Declaration)\n-            then\n-               declare\n-                  Loc : constant Source_Ptr := Sloc (Current_Declaration);\n-                  --  While specifically processing Current_Declaration, use\n-                  --  its Sloc as the location of all generated nodes.\n-\n-                  Subp_Def : constant Entity_Id :=\n-                               Defining_Unit_Name\n-                                 (Specification (Current_Declaration));\n-\n-                  Subp_Val : String_Id;\n-\n-                  Subp_Dist_Name : constant Entity_Id :=\n-                                     Make_Defining_Identifier (Loc,\n-                                       Chars =>\n-                                         New_External_Name\n-                                           (Related_Id   => Chars (Subp_Def),\n-                                            Suffix       => 'D',\n-                                            Suffix_Index => -1));\n-\n-                  Proxy_Object_Addr : Entity_Id;\n-\n-               begin\n-                  --  Build receiving stub\n-\n-                  Current_Stubs :=\n-                    Build_Subprogram_Receiving_Stubs\n-                      (Vis_Decl     => Current_Declaration,\n-                       Asynchronous =>\n-                         Nkind (Specification (Current_Declaration)) =\n-                             N_Procedure_Specification\n-                           and then Is_Asynchronous (Subp_Def));\n-\n-                  Append_To (Decls, Current_Stubs);\n-                  Analyze (Current_Stubs);\n-\n-                  --  Build RAS proxy\n-\n-                  Add_RAS_Proxy_And_Analyze (Decls,\n-                    Vis_Decl           => Current_Declaration,\n-                    All_Calls_Remote_E => All_Calls_Remote_E,\n-                    Proxy_Object_Addr  => Proxy_Object_Addr);\n-\n-                  --  Compute distribution identifier\n-\n-                  Assign_Subprogram_Identifier\n-                    (Subp_Def,\n-                     Current_Subprogram_Number,\n-                     Subp_Val);\n-\n-                  pragma Assert\n-                    (Current_Subprogram_Number = Get_Subprogram_Id (Subp_Def));\n-\n-                  Append_To (Decls,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Subp_Dist_Name,\n-                      Constant_Present    => True,\n-                      Object_Definition   =>\n-                        New_Occurrence_Of (Standard_String, Loc),\n-                      Expression          =>\n-                        Make_String_Literal (Loc, Subp_Val)));\n-                  Analyze (Last (Decls));\n-\n-                  --  Add subprogram descriptor (RCI_Subp_Info) to the\n-                  --  subprograms table for this receiver. The aggregate\n-                  --  below must be kept consistent with the declaration\n-                  --  of type RCI_Subp_Info in System.Partition_Interface.\n-\n-                  Append_To (Subp_Info_List,\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        Make_Integer_Literal (Loc, Current_Subprogram_Number)),\n-\n-                      Expression =>\n-                        Make_Aggregate (Loc,\n-                          Expressions => New_List (\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix =>\n-                                New_Occurrence_Of (Subp_Dist_Name, Loc),\n-                              Attribute_Name => Name_Address),\n-\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix         =>\n-                                New_Occurrence_Of (Subp_Dist_Name, Loc),\n-                              Attribute_Name => Name_Length),\n-\n-                            New_Occurrence_Of (Proxy_Object_Addr, Loc)))));\n-\n-                  Append_Stubs_To (Pkg_RPC_Receiver_Cases,\n-                    Declaration     => Current_Declaration,\n-                    Stubs           => Current_Stubs,\n-                    Subp_Number     => Current_Subprogram_Number,\n-                    Subp_Dist_Name  => Subp_Dist_Name,\n-                    Subp_Proxy_Addr => Proxy_Object_Addr);\n-               end;\n-\n-               Current_Subprogram_Number := Current_Subprogram_Number + 1;\n-            end if;\n-\n-            --  Need to handle case of a nested package???\n-\n-            Next (Current_Declaration);\n-         end loop;\n+         Visit_Spec (Pkg_Spec);\n \n          Append_To (Decls,\n            Make_Object_Declaration (Loc,"}, {"sha": "9e1f1852f39a46be01afc647bcc8933dcaa906b5", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -507,7 +507,9 @@ package body Impunit is\n    Non_Imp_File_Names_12 : constant File_List := (\n      \"s-multip\",    -- System.Multiprocessors\n      \"s-mudido\",    -- System.Multiprocessors.Dispatching_Domains\n-     \"a-cobove\");   -- Ada.Containers.Bounded_Vectors\n+     \"a-cobove\",    -- Ada.Containers.Bounded_Vectors\n+     \"a-cborse\",    -- Ada.Containers.Bounded_Ordered_Sets\n+     \"a-cborma\");   -- Ada.Containers.Bounded_Ordered_Maps\n \n    -----------------------\n    -- Alternative Units --"}, {"sha": "32058f0971c0077f4cf1a7eb56f1bafc437cb749", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -3314,12 +3314,13 @@ package body Sem_Ch12 is\n             end if;\n          end;\n \n-         --  If we are generating the calling stubs from the instantiation of\n-         --  a generic RCI package, we will not use the body of the generic\n-         --  package.\n+         --  If we are generating calling stubs, we never need a body for an\n+         --  instantiation from source. However normal processing occurs for\n+         --  any generic instantiation appearing in generated code, since we\n+         --  do not generate stubs in that case.\n \n          if Distribution_Stub_Mode = Generate_Caller_Stub_Body\n-           and then Is_Compilation_Unit (Defining_Entity (N))\n+              and then Comes_From_Source (N)\n          then\n             Needs_Body := False;\n          end if;\n@@ -4000,6 +4001,9 @@ package body Sem_Ch12 is\n          Check_Formal_Packages (Pack_Id);\n          Set_Is_Generic_Instance (Pack_Id, False);\n \n+         --  Why do we clear Is_Generic_Instance??? We set it 20 lines\n+         --  above???\n+\n          --  Body of the enclosing package is supplied when instantiating the\n          --  subprogram body, after semantic analysis is completed.\n "}, {"sha": "c0410dfcd7b009db87c1b3177c01e5f60f1da8bc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 117, "deletions": 10, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -12949,9 +12949,18 @@ package body Sem_Ch3 is\n                   Collect_Primitive_Operations (Parent_Type);\n \n       function Check_Derived_Type return Boolean;\n-      --  Check that all primitive inherited from Parent_Type are found in\n+      --  Check that all the entities derived from Parent_Type are found in\n       --  the list of primitives of Derived_Type exactly in the same order.\n \n+      procedure Derive_Interface_Subprogram\n+        (New_Subp    : in out Entity_Id;\n+         Subp        : Entity_Id;\n+         Actual_Subp : Entity_Id);\n+      --  Derive New_Subp from the ultimate alias of the parent subprogram Subp\n+      --  (which is an interface primitive). If Generic_Actual is present then\n+      --  Actual_Subp is the actual subprogram corresponding with the generic\n+      --  subprogram Subp.\n+\n       function Check_Derived_Type return Boolean is\n          E        : Entity_Id;\n          Elmt     : Elmt_Id;\n@@ -13027,6 +13036,45 @@ package body Sem_Ch3 is\n          return True;\n       end Check_Derived_Type;\n \n+      ---------------------------------\n+      -- Derive_Interface_Subprogram --\n+      ---------------------------------\n+\n+      procedure Derive_Interface_Subprogram\n+        (New_Subp    : in out Entity_Id;\n+         Subp        : Entity_Id;\n+         Actual_Subp : Entity_Id)\n+      is\n+         Iface_Subp : constant Entity_Id := Ultimate_Alias (Subp);\n+         Iface_Type : constant Entity_Id := Find_Dispatching_Type (Iface_Subp);\n+\n+      begin\n+         pragma Assert (Is_Interface (Iface_Type));\n+\n+         Derive_Subprogram\n+           (New_Subp     => New_Subp,\n+            Parent_Subp  => Iface_Subp,\n+            Derived_Type => Derived_Type,\n+            Parent_Type  => Iface_Type,\n+            Actual_Subp  => Actual_Subp);\n+\n+         --  Given that this new interface entity corresponds with a primitive\n+         --  of the parent that was not overridden we must leave it associated\n+         --  with its parent primitive to ensure that it will share the same\n+         --  dispatch table slot when overridden.\n+\n+         if No (Actual_Subp) then\n+            Set_Alias (New_Subp, Subp);\n+\n+         --  For instantiations this is not needed since the previous call to\n+         --  Derive_Subprogram leaves the entity well decorated.\n+\n+         else\n+            pragma Assert (Alias (New_Subp) = Actual_Subp);\n+            null;\n+         end if;\n+      end Derive_Interface_Subprogram;\n+\n       --  Local variables\n \n       Alias_Subp   : Entity_Id;\n@@ -13179,7 +13227,7 @@ package body Sem_Ch3 is\n             Alias_Subp := Ultimate_Alias (Subp);\n \n             --  Do not derive internal entities of the parent that link\n-            --  interface primitives and its covering primitive. These\n+            --  interface primitives with their covering primitive. These\n             --  entities will be added to this type when frozen.\n \n             if Present (Interface_Alias (Subp)) then\n@@ -13334,15 +13382,74 @@ package body Sem_Ch3 is\n                 (Nkind (Parent (Alias_Subp)) = N_Procedure_Specification\n                   and then Null_Present (Parent (Alias_Subp)))\n             then\n-               Derive_Subprogram\n-                 (New_Subp     => New_Subp,\n-                  Parent_Subp  => Alias_Subp,\n-                  Derived_Type => Derived_Type,\n-                  Parent_Type  => Find_Dispatching_Type (Alias_Subp),\n-                  Actual_Subp  => Act_Subp);\n+               --  If this is an abstract private type then we transfer the\n+               --  derivation of the interface primitive from the partial view\n+               --  to the full view. This is safe because all the interfaces\n+               --  must be visible in the partial view. Done to avoid adding\n+               --  a new interface derivation to the private part of the\n+               --  enclosing package; otherwise this new derivation would be\n+               --  decorated as hidden when the analysis of the enclosing\n+               --  package completes.\n+\n+               if Is_Abstract_Type (Derived_Type)\n+                 and then In_Private_Part (Current_Scope)\n+                 and then Has_Private_Declaration (Derived_Type)\n+               then\n+                  declare\n+                     Partial_View : Entity_Id;\n+                     Elmt         : Elmt_Id;\n+                     Ent          : Entity_Id;\n+\n+                  begin\n+                     Partial_View := First_Entity (Current_Scope);\n+                     loop\n+                        exit when No (Partial_View)\n+                          or else (Has_Private_Declaration (Partial_View)\n+                                     and then\n+                                   Full_View (Partial_View) = Derived_Type);\n+\n+                        Next_Entity (Partial_View);\n+                     end loop;\n+\n+                     --  If the partial view was not found then the source code\n+                     --  has errors and the derivation is not needed.\n \n-               if No (Generic_Actual) then\n-                  Set_Alias (New_Subp, Subp);\n+                     if Present (Partial_View) then\n+                        Elmt :=\n+                          First_Elmt (Primitive_Operations (Partial_View));\n+                        while Present (Elmt) loop\n+                           Ent := Node (Elmt);\n+\n+                           if Present (Alias (Ent))\n+                             and then Ultimate_Alias (Ent) = Alias (Subp)\n+                           then\n+                              Append_Elmt\n+                                (Ent, Primitive_Operations (Derived_Type));\n+                              exit;\n+                           end if;\n+\n+                           Next_Elmt (Elmt);\n+                        end loop;\n+\n+                        --  If the interface primitive was not found in the\n+                        --  partial view then this interface primitive was\n+                        --  overridden. We add a derivation to activate in\n+                        --  Derive_Progenitor_Subprograms the machinery to\n+                        --  search for it.\n+\n+                        if No (Elmt) then\n+                           Derive_Interface_Subprogram\n+                             (New_Subp    => New_Subp,\n+                              Subp        => Subp,\n+                              Actual_Subp => Act_Subp);\n+                        end if;\n+                     end if;\n+                  end;\n+               else\n+                  Derive_Interface_Subprogram\n+                    (New_Subp     => New_Subp,\n+                     Subp         => Subp,\n+                     Actual_Subp  => Act_Subp);\n                end if;\n \n             --  Case 3: Common derivation"}, {"sha": "21524073715cfc774b5c959f6ebcd9db5a59ead4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -3045,21 +3045,20 @@ package body Sem_Util is\n             Set_Scope (Def_Id, Current_Scope);\n             return;\n \n-         --  Analogous to privals, the discriminal generated for an entry\n-         --  index parameter acts as a weak declaration. Perform minimal\n-         --  decoration to avoid bogus errors.\n+         --  Analogous to privals, the discriminal generated for an entry index\n+         --  parameter acts as a weak declaration. Perform minimal decoration\n+         --  to avoid bogus errors.\n \n          elsif Is_Discriminal (Def_Id)\n            and then Ekind (Discriminal_Link (Def_Id)) = E_Entry_Index_Parameter\n          then\n             Set_Scope (Def_Id, Current_Scope);\n             return;\n \n-         --  In the body or private part of an instance, a type extension\n-         --  may introduce a component with the same name as that of an\n-         --  actual. The legality rule is not enforced, but the semantics\n-         --  of the full type with two components of the same name are not\n-         --  clear at this point ???\n+         --  In the body or private part of an instance, a type extension may\n+         --  introduce a component with the same name as that of an actual. The\n+         --  legality rule is not enforced, but the semantics of the full type\n+         --  with two components of same name are not clear at this point???\n \n          elsif In_Instance_Not_Visible then\n             null;\n@@ -3073,9 +3072,9 @@ package body Sem_Util is\n          then\n             null;\n \n-         --  Conversely, with front-end inlining we may compile the parent\n-         --  body first, and a child unit subsequently. The context is now\n-         --  the parent spec, and body entities are not visible.\n+         --  Conversely, with front-end inlining we may compile the parent body\n+         --  first, and a child unit subsequently. The context is now the\n+         --  parent spec, and body entities are not visible.\n \n          elsif Is_Child_Unit (Def_Id)\n            and then Is_Package_Body_Entity (E)\n@@ -3089,8 +3088,8 @@ package body Sem_Util is\n             Error_Msg_Sloc := Sloc (E);\n \n             --  If the previous declaration is an incomplete type declaration\n-            --  this may be an attempt to complete it with a private type.\n-            --  The following avoids confusing cascaded errors.\n+            --  this may be an attempt to complete it with a private type. The\n+            --  following avoids confusing cascaded errors.\n \n             if Nkind (Parent (E)) = N_Incomplete_Type_Declaration\n               and then Nkind (Parent (Def_Id)) = N_Private_Type_Declaration\n@@ -3113,9 +3112,9 @@ package body Sem_Util is\n                Error_Msg_N (\"& conflicts with declaration#\", E);\n                return;\n \n-            --  If the name of the unit appears in its own context clause,\n-            --  a dummy package with the name has already been created, and\n-            --  the error emitted. Try to continue quietly.\n+            --  If the name of the unit appears in its own context clause, a\n+            --  dummy package with the name has already been created, and the\n+            --  error emitted. Try to continue quietly.\n \n             elsif Error_Posted (E)\n               and then Sloc (E) = No_Location\n@@ -3144,9 +3143,9 @@ package body Sem_Util is\n                Error_Msg_N (\"\\generic units cannot be overloaded\", Def_Id);\n             end if;\n \n-            --  If entity is in standard, then we are in trouble, because\n-            --  it means that we have a library package with a duplicated\n-            --  name. That's hard to recover from, so abort!\n+            --  If entity is in standard, then we are in trouble, because it\n+            --  means that we have a library package with a duplicated name.\n+            --  That's hard to recover from, so abort!\n \n             if S = Standard_Standard then\n                raise Unrecoverable_Error;\n@@ -3160,17 +3159,17 @@ package body Sem_Util is\n          end if;\n       end if;\n \n-      --  If we fall through, declaration is OK , or OK enough to continue\n+      --  If we fall through, declaration is OK, at least OK enough to continue\n \n-      --  If Def_Id is a discriminant or a record component we are in the\n-      --  midst of inheriting components in a derived record definition.\n-      --  Preserve their Ekind and Etype.\n+      --  If Def_Id is a discriminant or a record component we are in the midst\n+      --  of inheriting components in a derived record definition. Preserve\n+      --  their Ekind and Etype.\n \n       if Ekind_In (Def_Id, E_Discriminant, E_Component) then\n          null;\n \n-      --  If a type is already set, leave it alone (happens whey a type\n-      --  declaration is reanalyzed following a call to the optimizer)\n+      --  If a type is already set, leave it alone (happens when a type\n+      --  declaration is reanalyzed following a call to the optimizer).\n \n       elsif Present (Etype (Def_Id)) then\n          null;\n@@ -3227,8 +3226,8 @@ package body Sem_Util is\n \n          and then In_Extended_Main_Source_Unit (Def_Id)\n \n-         --  Finally, the hidden entity must be either immediately visible\n-         --  or use visible (from a used package)\n+         --  Finally, the hidden entity must be either immediately visible or\n+         --  use visible (i.e. from a used package).\n \n          and then\n            (Is_Immediately_Visible (C)"}, {"sha": "57d8ee9c7a37f351ee2f63ddb7d0465bd093e3f7", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2efe85eb639b398d150365db037fedadecc4d8/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=ff2efe85eb639b398d150365db037fedadecc4d8", "patch": "@@ -425,8 +425,8 @@ begin\n    Write_Line (\"        F*   turn off warnings for unreferenced formal\");\n    Write_Line (\"        g*+  turn on warnings for unrecognized pragma\");\n    Write_Line (\"        G    turn off warnings for unrecognized pragma\");\n-   Write_Line (\"        h    turn on warnings for hiding variable\");\n-   Write_Line (\"        H*   turn off warnings for hiding variable\");\n+   Write_Line (\"        h    turn on warnings for hiding declarations\");\n+   Write_Line (\"        H*   turn off warnings for hiding declarations\");\n    Write_Line (\"        .h   turn on warnings for holes in records\");\n    Write_Line (\"        .H*  turn off warnings for holes in records\");\n    Write_Line (\"        i*+  turn on warnings for implementation unit\");"}]}