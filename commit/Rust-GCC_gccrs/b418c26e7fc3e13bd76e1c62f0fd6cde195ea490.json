{"sha": "b418c26e7fc3e13bd76e1c62f0fd6cde195ea490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQxOGMyNmU3ZmMzZTEzYmQ3NmUxYzYyZjBmZDZjZGUxOTVlYTQ5MA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-12-24T01:33:02Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-12-24T01:33:02Z"}, "message": "(check_dbra_loop): Don't reverse loop if there is a\nsingle memory store to an invariant address.\n\nFrom-SVN: r6290", "tree": {"sha": "78e2420383d7bd46fba0ada14eb1719d598bf3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78e2420383d7bd46fba0ada14eb1719d598bf3a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b418c26e7fc3e13bd76e1c62f0fd6cde195ea490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b418c26e7fc3e13bd76e1c62f0fd6cde195ea490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b418c26e7fc3e13bd76e1c62f0fd6cde195ea490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b418c26e7fc3e13bd76e1c62f0fd6cde195ea490/comments", "author": null, "committer": null, "parents": [{"sha": "fb99c21cfafa28704c637df116f483000b2cb65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb99c21cfafa28704c637df116f483000b2cb65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb99c21cfafa28704c637df116f483000b2cb65b"}], "stats": {"total": 13, "additions": 13, "deletions": 0}, "files": [{"sha": "631d1fc98f600b8dd725c930a515f67f37afdee7", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b418c26e7fc3e13bd76e1c62f0fd6cde195ea490/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b418c26e7fc3e13bd76e1c62f0fd6cde195ea490/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b418c26e7fc3e13bd76e1c62f0fd6cde195ea490", "patch": "@@ -5685,6 +5685,9 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n       int num_nonfixed_reads = 0;\n       /* 1 if the iteration var is used only to count iterations.  */\n       int no_use_except_counting = 0;\n+      /* 1 if the loop has no memory store, or it has a single memory store\n+\t which is reversible.  */\n+      int reversible_mem_store = 1;\n \n       for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n \tif (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n@@ -5721,6 +5724,15 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t      }\n \t}\n \n+      /* If the loop has a single store, and the destination address is\n+\t invariant, then we can't reverse the loop, because this address\n+\t might then have the wrong value at loop exit.\n+\t This would work if the source was invariant also, however, in that\n+\t case, the insn should have been moved out of the loop.  */\n+\n+      if (num_mem_sets == 1)\n+\treversible_mem_store = ! invariant_p (XEXP (loop_store_mems[0], 0));\n+\n       /* This code only acts for innermost loops.  Also it simplifies\n \t the memory address check by only reversing loops with\n \t zero or one memory access.\n@@ -5730,6 +5742,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n       if (num_nonfixed_reads <= 1\n \t  && !loop_has_call\n \t  && !loop_has_volatile\n+\t  && reversible_mem_store\n \t  && (no_use_except_counting\n \t      || (bl->giv_count + bl->biv_count + num_mem_sets\n \t\t  + num_movables + 2 == insn_count)))"}]}