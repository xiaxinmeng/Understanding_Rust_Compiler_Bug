{"sha": "cf427f02bb7cc5a0103f5821e7b4f042c9275320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y0MjdmMDJiYjdjYzVhMDEwM2Y1ODIxZTdiNGYwNDJjOTI3NTMyMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T09:21:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T09:21:46Z"}, "message": "[multiple changes]\n\n2012-10-01  Vincent Pucci  <pucci@adacore.com>\n\n\t* s-gearop.adb (Vector_Matrix_Product): Dimensions check fixed. Index\n\tof Left in S evaluation fixed.\n\n2012-10-01  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): Avoid\n\tpremature freezing caused by the internally generated subprogram\n\t_postconditions.\n\t* checks.adb (Expr_Known_Valid): Float literals are assumed to be valid\n\tin VM targets.\n\n2012-10-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* sinput.ads, sinput.adb, sinput-l.adb sinput-c.adb (Sinput): New\n\tInstances table, tracking all generic instantiations. Source file\n\tattribute Instance replaces previous Instantiation attribute with an\n\tindex into the Instances table.\n\t(Iterate_On_Instances): New generic procedure.\n\t(Create_Instantiation_Source): Record instantiations in Instances.\n\t(Tree_Read, Tree_Write): Read/write the instance table.\n\t* scils.ads, scos.adb (SCO_Instance_Table): New table, contains\n\tinformation copied from Sinput.Instance_Table, but self-contained\n\twithin the SCO data structures.\n\t* par_sco.ads, par_sco.adb (To_Source_Location): Move to library level.\n\t(Record_Instance): New subprogram, used by...\n\t(Populate_SCO_Instance_Table): New subprogram to fill\n\tthe SCO instance table from the Sinput one (called by SCO_Output).\n\t* opt.ads (Generate_SCO_Instance_Table): New option.\n\t* put_scos.adb (Write_Instance_Table): New subprogram, used by...\n\t(Put_SCOs): Dump the instance table at the end of SCO information\n\tif requested.\n\t* get_scos.adb (Get_SCOs): Read SCO_Instance_Table.\n\t* types.h: Add declaration for Instance_Id.\n\t* back_end.adb (Call_Back_End): Pass instance ids in source file\n\tinformation table.\n\t(Scan_Back_End_Switches): -fdebug-instances sets\n\tOpt.Generate_SCO_Instance_Table.\n\t* gcc-interface/gigi.h: File_Info_Type includes instance id.\n\t* gcc-interface/trans.c: Under -fdebug-instances, set instance\n\tid in line map from same in file info.\n\n2012-10-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_elab.adb: Minor reformatting\n\t(Check_Elab_Call): Minor fix to debugging code\n\t(add special circuit for the valid case where a 'Access attribute\n\treference is passed to Check_Elab_Call).\n\n2012-10-01  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch3.adb: Minor reformatting.\n\nFrom-SVN: r191904", "tree": {"sha": "6b99a1a18cf0a2a891e7b4e27a89c683d64aab0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b99a1a18cf0a2a891e7b4e27a89c683d64aab0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf427f02bb7cc5a0103f5821e7b4f042c9275320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf427f02bb7cc5a0103f5821e7b4f042c9275320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf427f02bb7cc5a0103f5821e7b4f042c9275320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf427f02bb7cc5a0103f5821e7b4f042c9275320/comments", "author": null, "committer": null, "parents": [{"sha": "d85be3ba3ba37ceb2b08a62f0974cb6883c24637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d85be3ba3ba37ceb2b08a62f0974cb6883c24637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d85be3ba3ba37ceb2b08a62f0974cb6883c24637"}], "stats": {"total": 791, "additions": 571, "deletions": 220}, "files": [{"sha": "c8f663554478f301f13e717446c4814a9e619d05", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -1,3 +1,57 @@\n+2012-10-01  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* s-gearop.adb (Vector_Matrix_Product): Dimensions check fixed. Index\n+\tof Left in S evaluation fixed.\n+\n+2012-10-01  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): Avoid\n+\tpremature freezing caused by the internally generated subprogram\n+\t_postconditions.\n+\t* checks.adb (Expr_Known_Valid): Float literals are assumed to be valid\n+\tin VM targets.\n+\n+2012-10-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sinput.ads, sinput.adb, sinput-l.adb sinput-c.adb (Sinput): New\n+\tInstances table, tracking all generic instantiations. Source file\n+\tattribute Instance replaces previous Instantiation attribute with an\n+\tindex into the Instances table.\n+\t(Iterate_On_Instances): New generic procedure.\n+\t(Create_Instantiation_Source): Record instantiations in Instances.\n+\t(Tree_Read, Tree_Write): Read/write the instance table.\n+\t* scils.ads, scos.adb (SCO_Instance_Table): New table, contains\n+\tinformation copied from Sinput.Instance_Table, but self-contained\n+\twithin the SCO data structures.\n+\t* par_sco.ads, par_sco.adb (To_Source_Location): Move to library level.\n+\t(Record_Instance): New subprogram, used by...\n+\t(Populate_SCO_Instance_Table): New subprogram to fill\n+\tthe SCO instance table from the Sinput one (called by SCO_Output).\n+\t* opt.ads (Generate_SCO_Instance_Table): New option.\n+\t* put_scos.adb (Write_Instance_Table): New subprogram, used by...\n+\t(Put_SCOs): Dump the instance table at the end of SCO information\n+\tif requested.\n+\t* get_scos.adb (Get_SCOs): Read SCO_Instance_Table.\n+\t* types.h: Add declaration for Instance_Id.\n+\t* back_end.adb (Call_Back_End): Pass instance ids in source file\n+\tinformation table.\n+\t(Scan_Back_End_Switches): -fdebug-instances sets\n+\tOpt.Generate_SCO_Instance_Table.\n+\t* gcc-interface/gigi.h: File_Info_Type includes instance id.\n+\t* gcc-interface/trans.c: Under -fdebug-instances, set instance\n+\tid in line map from same in file info.\n+\n+2012-10-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_elab.adb: Minor reformatting\n+\t(Check_Elab_Call): Minor fix to debugging code\n+\t(add special circuit for the valid case where a 'Access attribute\n+\treference is passed to Check_Elab_Call).\n+\n+2012-10-01  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch3.adb: Minor reformatting.\n+\n 2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch3.ads (Build_Array_Invariant_Proc): moved to body."}, {"sha": "0cfd45fac30d6c860fb6f94c3d7509be74c30c1d", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -76,6 +76,7 @@ package body Back_End is\n \n       type File_Info_Type is record\n          File_Name        : File_Name_Type;\n+         Instance         : Instance_Id;\n          Num_Source_Lines : Nat;\n       end record;\n \n@@ -119,6 +120,7 @@ package body Back_End is\n \n       for J in 1 .. Last_Source_File loop\n          File_Info_Array (J).File_Name        := Full_Debug_Name (J);\n+         File_Info_Array (J).Instance         := Instance (J);\n          File_Info_Array (J).Num_Source_Lines :=\n            Nat (Physical_To_Logical (Last_Source_Line (J), J));\n       end loop;\n@@ -243,6 +245,12 @@ package body Back_End is\n             elsif Switch_Chars (First .. Last) = \"fdump-scos\" then\n                Opt.Generate_SCO := True;\n \n+            --  Back end switch -fdebug-instances also enables instance table\n+            --  SCO generation.\n+\n+            elsif Switch_Chars (First .. Last) = \"fdebug-instances\" then\n+               Opt.Generate_SCO_Instance_Table := True;\n+\n             end if;\n          end if;\n       end Scan_Back_End_Switches;"}, {"sha": "19a54d5658e0042895c846f55084da27511e393b", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -4599,6 +4599,13 @@ package body Checks is\n       then\n          return True;\n \n+      --  Real literals are assumed to be valid in VM targets\n+\n+      elsif VM_Target /= No_VM\n+        and then Nkind (Expr) = N_Real_Literal\n+      then\n+         return True;\n+\n       --  If we have a type conversion or a qualification of a known valid\n       --  value, then the result will always be valid.\n "}, {"sha": "454348fa89293b3f181b163b73368494151c08b5", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -659,7 +659,7 @@ package body Exp_Ch3 is\n       --  but it properly belongs with the array type declaration. However, if\n       --  the freeze node is for a subtype of a type declared in another unit\n       --  it seems preferable to use the freeze node as the source location of\n-      --  of the init proc. In any case this is preferable for gcov usage, and\n+      --  the init proc. In any case this is preferable for gcov usage, and\n       --  the Sloc is not otherwise used by the compiler.\n \n       if In_Open_Scopes (Scope (A_Type)) then"}, {"sha": "d4a81762f82cba7a0244101d7f62c1b041472a53", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -228,7 +228,8 @@ extern const char *ref_filename;\n struct File_Info_Type\n {\n   File_Name_Type File_Name;\n-  Nat Num_Source_Lines;\n+  Instance_Id    Instance;\n+  Nat            Num_Source_Lines;\n };\n \n #ifdef __cplusplus"}, {"sha": "661d9bfd7785680672326303a8204d0798d75f35", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -293,6 +293,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   tree int64_type = gnat_type_for_size (64, 0);\n   struct elab_info *info;\n   int i;\n+  struct line_map *map;\n \n   max_gnat_nodes = max_gnat_node;\n \n@@ -325,7 +326,12 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \n       /* We create the line map for a source file at once, with a fixed number\n \t of columns chosen to avoid jumping over the next power of 2.  */\n-      linemap_add (line_table, LC_ENTER, 0, filename, 1);\n+      map = (struct line_map *) linemap_add\n+                                  (line_table, LC_ENTER, 0, filename, 1);\n+#ifdef ORDINARY_MAP_INSTANCE\n+      if (flag_debug_instances)\n+        ORDINARY_MAP_INSTANCE(map) = file_info_ptr[i].Instance;\n+#endif\n       linemap_line_start (line_table, file_info_ptr[i].Num_Source_Lines, 252);\n       linemap_position_for_column (line_table, 252 - 1);\n       linemap_add (line_table, LC_LEAVE, 0, NULL, 0);"}, {"sha": "4fb00102929d29265f4b82edaf0867ceca2e4d86", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -225,7 +225,7 @@ begin\n \n       case C is\n \n-         --  Header entry\n+         --  Header or instance table entry\n \n          when ' ' =>\n \n@@ -236,26 +236,71 @@ begin\n                  SCO_Table.Last;\n             end if;\n \n-            --  Scan out dependency number and file name\n-\n             Skip_Spaces;\n-            Dnum := Get_Int;\n \n-            Skip_Spaces;\n+            case Nextc is\n \n-            N := 0;\n-            while Nextc > ' ' loop\n-               N := N + 1;\n-               Buf (N) := Getc;\n-            end loop;\n+               --  Instance table entry\n+\n+               when 'i' =>\n+                  declare\n+                     Inum : SCO_Instance_Index;\n+                  begin\n+                     Skipc;\n+                     Skip_Spaces;\n+\n+                     Inum := SCO_Instance_Index (Get_Int);\n+                     SCO_Instance_Table.Increment_Last;\n+                     pragma Assert (SCO_Instance_Table.Last = Inum);\n+\n+                     Skip_Spaces;\n+                     declare\n+                        SIE : SCO_Instance_Table_Entry\n+                                renames SCO_Instance_Table.Table (Inum);\n+                     begin\n+                        SIE.Inst_Dep_Num := Get_Int;\n+                        C := Getc;\n+                        pragma Assert (C = '|');\n+                        Get_Source_Location (SIE.Inst_Loc);\n+\n+                        if not At_EOL then\n+                           Skip_Spaces;\n+                           SIE.Enclosing_Instance :=\n+                             SCO_Instance_Index (Get_Int);\n+                           pragma Assert (SIE.Enclosing_Instance in\n+                                            SCO_Instance_Table.First\n+                                         .. SCO_Instance_Table.Last);\n+                        end if;\n+                     end;\n+                  end;\n \n-            --  Make new unit table entry (will fill in To later)\n+               --  Unit header\n+\n+               when '0' .. '9' =>\n+                  --  Scan out dependency number and file name\n+\n+                  Dnum := Get_Int;\n+\n+                  Skip_Spaces;\n+\n+                  N := 0;\n+                  while Nextc > ' ' loop\n+                     N := N + 1;\n+                     Buf (N) := Getc;\n+                  end loop;\n+\n+                  --  Make new unit table entry (will fill in To later)\n+\n+                  SCO_Unit_Table.Append (\n+                    (File_Name => new String'(Buf (1 .. N)),\n+                     Dep_Num   => Dnum,\n+                     From      => SCO_Table.Last + 1,\n+                     To        => 0));\n+\n+                     when others =>\n+                        raise Program_Error;\n \n-            SCO_Unit_Table.Append (\n-              (File_Name => new String'(Buf (1 .. N)),\n-               Dep_Num   => Dnum,\n-               From      => SCO_Table.Last + 1,\n-               To        => 0));\n+            end case;\n \n          --  Statement entry\n "}, {"sha": "c90c5eca884fd4e00be9fd77d819ef1a64a9ca03", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -648,9 +648,14 @@ package Opt is\n \n    Generate_SCO : Boolean := False;\n    --  GNAT\n-   --  True when switch -gnateS is used. When True, Source Coverage Obligation\n-   --  (SCO) information is generated and output in the ALI file. See unit\n-   --  Par_SCO for full details.\n+   --  True when switch -fdump-scos (or -gnateS) is used. When True, Source\n+   --  Coverage Obligation (SCO) information is generated and output in the ALI\n+   --  file. See unit Par_SCO for full details.\n+\n+   Generate_SCO_Instance_Table : Boolean := False;\n+   --  GNAT\n+   --  True when switch -fdebug-instances is used. When True, a table of\n+   --  instances is included in SCOs.\n \n    Generating_Code : Boolean := False;\n    --  GNAT"}, {"sha": "29c033832180f644a8951d523cdc7431d3513e26", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -102,6 +102,9 @@ package body Par_SCO is\n    --  excluding OR and AND) and returns True if so, False otherwise, it does\n    --  no other processing.\n \n+   function To_Source_Location (S : Source_Ptr) return Source_Location;\n+   --  Converts Source_Ptr value to Source_Location (line/col) format\n+\n    procedure Process_Decisions\n      (N           : Node_Id;\n       T           : Character;\n@@ -138,6 +141,9 @@ package body Par_SCO is\n    end record;\n    No_Dominant : constant Dominant_Info := (' ', Empty);\n \n+   procedure Record_Instance (Id : Instance_Id; Inst_Sloc : Source_Ptr);\n+   --  Add one entry from the instance table to the corresponding SCO table\n+\n    procedure Traverse_Declarations_Or_Statements\n      (L : List_Id;\n       D : Dominant_Info := No_Dominant;\n@@ -696,16 +702,37 @@ package body Par_SCO is\n       Debug_Put_SCOs;\n    end pscos;\n \n+   ---------------------\n+   -- Record_Instance --\n+   ---------------------\n+\n+   procedure Record_Instance (Id : Instance_Id; Inst_Sloc : Source_Ptr) is\n+      Inst_Src  : constant Source_File_Index :=\n+                    Get_Source_File_Index (Inst_Sloc);\n+   begin\n+      SCO_Instance_Table.Append\n+        ((Inst_Dep_Num       => Dependency_Num (Unit (Inst_Src)),\n+          Inst_Loc           => To_Source_Location (Inst_Sloc),\n+          Enclosing_Instance => SCO_Instance_Index (Instance (Inst_Src))));\n+      pragma Assert\n+        (SCO_Instance_Table.Last = SCO_Instance_Index (Id));\n+   end Record_Instance;\n+\n    ----------------\n    -- SCO_Output --\n    ----------------\n \n    procedure SCO_Output is\n+      procedure Populate_SCO_Instance_Table is\n+        new Sinput.Iterate_On_Instances (Record_Instance);\n+\n    begin\n       if Debug_Flag_Dot_OO then\n          dsco;\n       end if;\n \n+      Populate_SCO_Instance_Table;\n+\n       --  Sort the unit tables based on dependency numbers\n \n       Unit_Table_Sort : declare\n@@ -949,26 +976,6 @@ package body Par_SCO is\n       Pragma_Sloc : Source_Ptr := No_Location;\n       Pragma_Name : Pragma_Id  := Unknown_Pragma)\n    is\n-      function To_Source_Location (S : Source_Ptr) return Source_Location;\n-      --  Converts Source_Ptr value to Source_Location (line/col) format\n-\n-      ------------------------\n-      -- To_Source_Location --\n-      ------------------------\n-\n-      function To_Source_Location (S : Source_Ptr) return Source_Location is\n-      begin\n-         if S = No_Location then\n-            return No_Source_Location;\n-         else\n-            return\n-              (Line => Get_Logical_Line_Number (S),\n-               Col  => Get_Column_Number (S));\n-         end if;\n-      end To_Source_Location;\n-\n-   --  Start of processing for Set_Table_Entry\n-\n    begin\n       SCO_Table.Append\n         ((C1          => C1,\n@@ -980,6 +987,21 @@ package body Par_SCO is\n           Pragma_Name => Pragma_Name));\n    end Set_Table_Entry;\n \n+   ------------------------\n+   -- To_Source_Location --\n+   ------------------------\n+\n+   function To_Source_Location (S : Source_Ptr) return Source_Location is\n+   begin\n+      if S = No_Location then\n+         return No_Source_Location;\n+      else\n+         return\n+           (Line => Get_Logical_Line_Number (S),\n+            Col  => Get_Column_Number (S));\n+      end if;\n+   end To_Source_Location;\n+\n    -----------------------------------------\n    -- Traverse_Declarations_Or_Statements --\n    -----------------------------------------"}, {"sha": "62a7467f6478fd14236ed657f1c487684f8b4db6", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -61,9 +61,9 @@ package Par_SCO is\n    --  True if Loc is the source location of a disabled pragma\n \n    procedure SCO_Output;\n-   --  Outputs SCO lines for all units, with appropriate section headers, for\n-   --  unit U in the ALI file, as recorded by previous calls to SCO_Record,\n-   --  possibly modified by calls to Set_SCO_Condition.\n+   --  Outputs SCO lines for all units, with appropriate section headers, as\n+   --  recorded by previous calls to SCO_Record, possibly modified by calls to\n+   --  Set_SCO_Condition.\n \n    procedure dsco;\n    --  Debug routine to dump internal SCO table. This is a raw format dump"}, {"sha": "05184d7a985b7cc2ffe985d68bb811403a211f24", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Opt;     use Opt;\n with Par_SCO; use Par_SCO;\n with SCOs;    use SCOs;\n with Snames;  use Snames;\n@@ -34,6 +35,9 @@ procedure Put_SCOs is\n    procedure Write_SCO_Initiate (SU : SCO_Unit_Index);\n    --  Start SCO line for unit SU, also emitting SCO unit header if necessary\n \n+   procedure Write_Instance_Table;\n+   --  Output the SCO table of instances\n+\n    procedure Output_Range (T : SCO_Table_Entry);\n    --  Outputs T.From and T.To in line:col-line:col format\n \n@@ -76,6 +80,33 @@ procedure Put_SCOs is\n       end loop;\n    end Output_String;\n \n+   --------------------------\n+   -- Write_Instance_Table --\n+   --------------------------\n+\n+   procedure Write_Instance_Table is\n+   begin\n+      for J in 1 .. SCO_Instance_Table.Last loop\n+         declare\n+            SIE : SCO_Instance_Table_Entry\n+                    renames SCO_Instance_Table.Table (J);\n+         begin\n+            Output_String (\"C i \");\n+            Write_Info_Nat (Nat (J));\n+            Write_Info_Char (' ');\n+            Write_Info_Nat (SIE.Inst_Dep_Num);\n+            Write_Info_Char ('|');\n+            Output_Source_Location (SIE.Inst_Loc);\n+\n+            if SIE.Enclosing_Instance > 0 then\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (Nat (SIE.Enclosing_Instance));\n+            end if;\n+            Write_Info_Terminate;\n+         end;\n+      end loop;\n+   end Write_Instance_Table;\n+\n    ------------------------\n    -- Write_SCO_Initiate --\n    ------------------------\n@@ -270,4 +301,8 @@ begin\n          end loop;\n       end;\n    end loop;\n+\n+   if Opt.Generate_SCO_Instance_Table then\n+      Write_Instance_Table;\n+   end if;\n end Put_SCOs;"}, {"sha": "f84280ee8bb41bb89cf88d7d56feaa904eb7e1e5", "filename": "gcc/ada/s-gearop.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fs-gearop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fs-gearop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-gearop.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -902,7 +902,7 @@ package body System.Generic_Array_Operations is\n    is\n    begin\n       return R : Result_Vector (Right'Range (2)) do\n-         if Left'Length /= Right'Length (2) then\n+         if Left'Length /= Right'Length (1) then\n             raise Constraint_Error with\n               \"incompatible dimensions in vector-matrix multiplication\";\n          end if;\n@@ -913,7 +913,7 @@ package body System.Generic_Array_Operations is\n \n             begin\n                for K in Right'Range (1) loop\n-                  S := S + Left (J - Right'First (1)\n+                  S := S + Left (K - Right'First (1)\n                                    + Left'First) * Right (K, J);\n                end loop;\n "}, {"sha": "fa8c66d6d0e5853032bfe9e4d340fc830b654bf0", "filename": "gcc/ada/scos.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fscos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fscos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ package body SCOs is\n    begin\n       SCO_Table.Init;\n       SCO_Unit_Table.Init;\n+      SCO_Instance_Table.Init;\n \n       --  Set dummy zeroth entry for sort routine, real entries start at 1\n "}, {"sha": "d2d2c54982cb8ef56e029330becfdc2f6af44ca6", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -246,7 +246,7 @@ package SCOs is\n \n    --    For each decision, a decision line is generated with the form:\n \n-   --      C* sloc expression [chaining]\n+   --      C* sloc expression\n \n    --    Here * is one of the following characters:\n \n@@ -308,35 +308,6 @@ package SCOs is\n    --    condition, and that is true even if the Ada 2005 set membership\n    --    form is used, e.g. A in (2,7,11.15).\n \n-   --    The expression can be followed by chaining indicators of the form\n-   --    Tsloc-range or Fsloc-range, where the sloc-range is that of some\n-   --    entry on a CS line.\n-\n-   --    T* is present when the statement with the given sloc range is executed\n-   --    if, and only if, the decision evaluates to TRUE.\n-\n-   --    F* is present when the statement with the given sloc range is executed\n-   --    if, and only if, the decision evaluates to FALSE.\n-\n-   --    For an IF statement or ELSIF part, a T chaining indicator is always\n-   --    present, with the sloc range of the first statement in the\n-   --    corresponding sequence.\n-\n-   --    For an ELSE part, the last decision in the IF statement (that of the\n-   --    last ELSIF part, if any, or that of the IF statement if there is no\n-   --    ELSIF part) has an F chaining indicator with the sloc range of the\n-   --    first statement in the sequence of the ELSE part.\n-\n-   --    For a WHILE loop, a T chaining indicator is always present, with the\n-   --    sloc range of the first statement in the loop, but no F chaining\n-   --    indicator is ever present.\n-\n-   --    For an EXIT WHEN statement, an F chaining indicator is present if\n-   --    there is an immediately following sequence in the same sequence of\n-   --    statements.\n-\n-   --    In all other cases, chaining indicators are omitted\n-\n    --    Implementation permission: a SCO generator is permitted to emit a\n    --    narrower SLOC range for a condition if the corresponding code\n    --    generation circuitry ensures that all debug information for the code\n@@ -360,6 +331,19 @@ package SCOs is\n    --    entries appear in one logical statement sequence, continuation lines\n    --    are marked by Cc and appear immediately after the CC line.\n \n+   --  Generic instances\n+\n+   --    A table of all generic instantiations in the compilation is generated\n+   --    whose entries have the form:\n+\n+   --      C i index dependency-number|sloc [enclosing]\n+\n+   --    Where index is the 1-based index of the entry in the table,\n+   --    dependency-number and sloc indicate the source location of the\n+   --    instantiation, and enclosing is the index of the enclosing\n+   --    instantiation in the table (for a nested instantiation), or is\n+   --    omitted for an outer instantiation.\n+\n    --  Disabled pragmas\n \n    --    No SCO is generated for disabled pragmas\n@@ -471,12 +455,6 @@ package SCOs is\n    --      To   = ending source location\n    --      Last = False for all but the last entry, True for last entry\n \n-   --    Element (chaining indicator)\n-   --      C1   = 'H' (cHain)\n-   --      C2   = 'T' or 'F' (chaining on decision true/false)\n-   --      From = starting source location of chained statement\n-   --      To   = ending source location of chained statement\n-\n    --    Note: the sequence starting with a decision, and continuing with\n    --    operators and elements up to and including the first one labeled with\n    --    Last = True, indicate the sequence to be output on one decision line.\n@@ -515,6 +493,27 @@ package SCOs is\n      Table_Initial        => 20,\n      Table_Increment      => 200);\n \n+   -----------------------\n+   -- Generic instances --\n+   -----------------------\n+\n+   type SCO_Instance_Index is new Nat;\n+\n+   type SCO_Instance_Table_Entry is record\n+      Inst_Dep_Num : Nat;\n+      Inst_Loc     : Source_Location;\n+      --  File and source location of instantiation\n+\n+      Enclosing_Instance : SCO_Instance_Index;\n+   end record;\n+\n+   package SCO_Instance_Table is new GNAT.Table (\n+     Table_Component_Type => SCO_Instance_Table_Entry,\n+     Table_Index_Type     => SCO_Instance_Index,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 20,\n+     Table_Increment      => 200);\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "78ec8a0ba95a4e2706269fb4848600973e5c47d1", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -2152,7 +2152,9 @@ package body Sem_Ch3 is\n          --  explicitly checked that all required types are properly frozen,\n          --  and we do not cause general freezing here. This special circuit\n          --  is used when the encountered body is marked as having already\n-         --  been analyzed.\n+         --  been analyzed (although we must take into account the special\n+         --  case of the internally generated subprogram _postconditions,\n+         --  may not have been analyzed yet)\n \n          --  In all other cases (bodies that come from source, and expander\n          --  generated bodies that have not been analyzed yet), freeze all\n@@ -2168,6 +2170,11 @@ package body Sem_Ch3 is\n                                           N_Task_Body)\n                        or else\n                      Nkind (Next_Node) in N_Body_Stub)\n+           and then not\n+             (Ada_Version = Ada_2012\n+                and then Nkind (Next_Node) = N_Subprogram_Body\n+                and then Chars (Defining_Entity (Next_Node))\n+                           = Name_uPostconditions)\n          then\n             Adjust_D;\n             Freeze_All (Freeze_From, D);"}, {"sha": "e96d2317f289eebc5394d98fddd17a12edab8cb1", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -153,7 +153,7 @@ package body Sem_Elab is\n    --  This is set True till the compilation is complete, including the\n    --  insertion of all instance bodies. Then when Check_Elab_Calls is called,\n    --  the delay table is used to make the delayed calls and this flag is reset\n-   --  to False, so that the calls are processed\n+   --  to False, so that the calls are processed.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -1162,8 +1162,6 @@ package body Sem_Elab is\n       Ent : Entity_Id;\n       P   : Node_Id;\n \n-   --  Start of processing for Check_Elab_Call\n-\n    begin\n       --  If the call does not come from the main unit, there is nothing to\n       --  check. Elaboration call from units in the context of the main unit\n@@ -1206,10 +1204,17 @@ package body Sem_Elab is\n       if Debug_Flag_LL then\n          Write_Str (\"  Check_Elab_Call: \");\n \n-         if No (Name (N))\n-           or else not Is_Entity_Name (Name (N))\n-         then\n+         if Nkind (N) = N_Attribute_Reference then\n+            if not Is_Entity_Name (Prefix (N)) then\n+               Write_Str (\"<<not entity name>>\");\n+            else\n+               Write_Name (Chars (Entity (Prefix (N))));\n+            end if;\n+            Write_Str (\"'Access\");\n+\n+         elsif No (Name (N)) or else not Is_Entity_Name (Name (N)) then\n             Write_Str (\"<<not entity name>> \");\n+\n          else\n             Write_Name (Chars (Entity (Name (N))));\n          end if;"}, {"sha": "4ad212b431433dde517355f4834754236efbf952", "filename": "gcc/ada/sinput-c.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-c.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -178,9 +178,10 @@ package body Sinput.C is\n                Full_Debug_Name     => Path_Id,\n                Full_File_Name      => Path_Id,\n                Full_Ref_Name       => Path_Id,\n+               Instance            => No_Instance_Id,\n                Identifier_Casing   => Unknown,\n+               Inlined_Call        => No_Location,\n                Inlined_Body        => False,\n-               Instantiation       => No_Location,\n                Keyword_Casing      => Unknown,\n                Last_Source_Line    => 1,\n                License             => Unknown,"}, {"sha": "59d2aed4f99333174321079c123049e886d851ed", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 156, "deletions": 89, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,8 @@ with Prep;     use Prep;\n with Prepcomp; use Prepcomp;\n with Scans;    use Scans;\n with Scn;      use Scn;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with System;   use System;\n@@ -138,127 +140,191 @@ package body Sinput.L is\n       Source_File.Append (Source_File.Table (Xold));\n       Xnew := Source_File.Last;\n \n-      Source_File.Table (Xnew).Inlined_Body  := Inlined_Body;\n-      Source_File.Table (Xnew).Instantiation := Sloc (Inst_Node);\n-      Source_File.Table (Xnew).Template      := Xold;\n+      declare\n+         Sold : Source_File_Record renames Source_File.Table (Xold);\n+         Snew : Source_File_Record renames Source_File.Table (Xnew);\n \n-      --  Now we need to compute the new values of Source_First, Source_Last\n-      --  and adjust the source file pointer to have the correct virtual\n-      --  origin for the new range of values.\n+         Inst_Spec : Node_Id;\n \n-      Source_File.Table (Xnew).Source_First :=\n-        Source_File.Table (Xnew - 1).Source_Last + 1;\n-      A.Adjust := Source_File.Table (Xnew).Source_First - A.Lo;\n-      Source_File.Table (Xnew).Source_Last := A.Hi + A.Adjust;\n+      begin\n+         Snew.Inlined_Body  := Inlined_Body;\n+         Snew.Template      := Xold;\n \n-      Set_Source_File_Index_Table (Xnew);\n+         --  For a genuine generic instantiation, assign new instance id.\n+         --  For inlined bodies, we retain that of the template, but we\n+         --  save the call location.\n \n-      Source_File.Table (Xnew).Sloc_Adjust :=\n-        Source_File.Table (Xold).Sloc_Adjust - A.Adjust;\n+         if Inlined_Body then\n+            Snew.Inlined_Call := Sloc (Inst_Node);\n \n-      if Debug_Flag_L then\n-         Write_Eol;\n-         Write_Str (\"*** Create instantiation source for \");\n+         else\n \n-         if Nkind (Dnod) in N_Proper_Body\n-           and then Was_Originally_Stub (Dnod)\n-         then\n-            Write_Str (\"subunit \");\n+            --  If the spec has been instantiated already, and we are now\n+            --  creating the instance source for the corresponding body now,\n+            --  retrieve the instance id that was assigned to the spec, which\n+            --  corresponds to the same instantiation sloc.\n+\n+            Inst_Spec := Instance_Spec (Inst_Node);\n+            if Present (Inst_Spec) then\n+               declare\n+                  Inst_Spec_Ent     : Entity_Id;\n+                  --  Instance spec entity\n+\n+                  Inst_Spec_Sloc    : Source_Ptr;\n+                  --  Virtual sloc of the spec instance source\n+\n+                  Inst_Spec_Inst_Id : Instance_Id;\n+                  --  Instance id assigned to the instance spec\n+\n+               begin\n+                  Inst_Spec_Ent := Defining_Entity (Inst_Spec);\n+\n+                  --  For a subprogram instantiation, we want the subprogram\n+                  --  instance, not the wrapper package.\n+\n+                  if Present (Related_Instance (Inst_Spec_Ent)) then\n+                     Inst_Spec_Ent := Related_Instance (Inst_Spec_Ent);\n+                  end if;\n+\n+                  --  The specification of the instance entity has a virtual\n+                  --  sloc within the instance sloc range.\n+                  --  ??? But the Unit_Declaration_Node has the sloc of the\n+                  --  instantiation, which is somewhat of an oddity.\n+\n+                  Inst_Spec_Sloc    :=\n+                    Sloc (Specification (Unit_Declaration_Node\n+                                           (Inst_Spec_Ent)));\n+                  Inst_Spec_Inst_Id :=\n+                    Source_File.Table\n+                      (Get_Source_File_Index (Inst_Spec_Sloc)).Instance;\n+\n+                  pragma Assert\n+                    (Sloc (Inst_Node) = Instances.Table (Inst_Spec_Inst_Id));\n+                  Snew.Instance := Inst_Spec_Inst_Id;\n+               end;\n \n-         elsif Ekind (Template_Id) = E_Generic_Package then\n-            if Nkind (Dnod) = N_Package_Body then\n-               Write_Str (\"body of package \");\n             else\n-               Write_Str (\"spec of package \");\n+               Instances.Append (Sloc (Inst_Node));\n+               Snew.Instance := Instances.Last;\n             end if;\n+         end if;\n \n-         elsif Ekind (Template_Id) = E_Function then\n-            Write_Str (\"body of function \");\n+         --  Now we need to compute the new values of Source_First,\n+         --  Source_Last and adjust the source file pointer to have the\n+         --  correct virtual origin for the new range of values.\n \n-         elsif Ekind (Template_Id) = E_Procedure then\n-            Write_Str (\"body of procedure \");\n+         Snew.Source_First := Source_File.Table (Xnew - 1).Source_Last + 1;\n+         A.Adjust := Snew.Source_First - A.Lo;\n+         Snew.Source_Last := A.Hi + A.Adjust;\n \n-         elsif Ekind (Template_Id) = E_Generic_Function then\n-            Write_Str (\"spec of function \");\n+         Set_Source_File_Index_Table (Xnew);\n \n-         elsif Ekind (Template_Id) = E_Generic_Procedure then\n-            Write_Str (\"spec of procedure \");\n+         Snew.Sloc_Adjust := Sold.Sloc_Adjust - A.Adjust;\n \n-         elsif Ekind (Template_Id) = E_Package_Body then\n-            Write_Str (\"body of package \");\n+         if Debug_Flag_L then\n+            Write_Eol;\n+            Write_Str (\"*** Create instantiation source for \");\n \n-         else pragma Assert (Ekind (Template_Id) = E_Subprogram_Body);\n+            if Nkind (Dnod) in N_Proper_Body\n+              and then Was_Originally_Stub (Dnod)\n+            then\n+               Write_Str (\"subunit \");\n \n-            if Nkind (Dnod) = N_Procedure_Specification then\n-               Write_Str (\"body of procedure \");\n-            else\n+            elsif Ekind (Template_Id) = E_Generic_Package then\n+               if Nkind (Dnod) = N_Package_Body then\n+                  Write_Str (\"body of package \");\n+               else\n+                  Write_Str (\"spec of package \");\n+               end if;\n+\n+            elsif Ekind (Template_Id) = E_Function then\n                Write_Str (\"body of function \");\n+\n+            elsif Ekind (Template_Id) = E_Procedure then\n+               Write_Str (\"body of procedure \");\n+\n+            elsif Ekind (Template_Id) = E_Generic_Function then\n+               Write_Str (\"spec of function \");\n+\n+            elsif Ekind (Template_Id) = E_Generic_Procedure then\n+               Write_Str (\"spec of procedure \");\n+\n+            elsif Ekind (Template_Id) = E_Package_Body then\n+               Write_Str (\"body of package \");\n+\n+            else pragma Assert (Ekind (Template_Id) = E_Subprogram_Body);\n+\n+               if Nkind (Dnod) = N_Procedure_Specification then\n+                  Write_Str (\"body of procedure \");\n+               else\n+                  Write_Str (\"body of function \");\n+               end if;\n             end if;\n-         end if;\n \n-         Write_Name (Chars (Template_Id));\n-         Write_Eol;\n+            Write_Name (Chars (Template_Id));\n+            Write_Eol;\n \n-         Write_Str (\"  new source index = \");\n-         Write_Int (Int (Xnew));\n-         Write_Eol;\n+            Write_Str (\"  new source index = \");\n+            Write_Int (Int (Xnew));\n+            Write_Eol;\n \n-         Write_Str (\"  copying from file name = \");\n-         Write_Name (File_Name (Xold));\n-         Write_Eol;\n+            Write_Str (\"  copying from file name = \");\n+            Write_Name (File_Name (Xold));\n+            Write_Eol;\n \n-         Write_Str (\"  old source index = \");\n-         Write_Int (Int (Xold));\n-         Write_Eol;\n+            Write_Str (\"  old source index = \");\n+            Write_Int (Int (Xold));\n+            Write_Eol;\n \n-         Write_Str (\"  old lo = \");\n-         Write_Int (Int (A.Lo));\n-         Write_Eol;\n+            Write_Str (\"  old lo = \");\n+            Write_Int (Int (A.Lo));\n+            Write_Eol;\n \n-         Write_Str (\"  old hi = \");\n-         Write_Int (Int (A.Hi));\n-         Write_Eol;\n+            Write_Str (\"  old hi = \");\n+            Write_Int (Int (A.Hi));\n+            Write_Eol;\n \n-         Write_Str (\"  new lo = \");\n-         Write_Int (Int (Source_File.Table (Xnew).Source_First));\n-         Write_Eol;\n+            Write_Str (\"  new lo = \");\n+            Write_Int (Int (Snew.Source_First));\n+            Write_Eol;\n \n-         Write_Str (\"  new hi = \");\n-         Write_Int (Int (Source_File.Table (Xnew).Source_Last));\n-         Write_Eol;\n+            Write_Str (\"  new hi = \");\n+            Write_Int (Int (Snew.Source_Last));\n+            Write_Eol;\n \n-         Write_Str (\"  adjustment factor = \");\n-         Write_Int (Int (A.Adjust));\n-         Write_Eol;\n+            Write_Str (\"  adjustment factor = \");\n+            Write_Int (Int (A.Adjust));\n+            Write_Eol;\n \n-         Write_Str (\"  instantiation location: \");\n-         Write_Location (Sloc (Inst_Node));\n-         Write_Eol;\n-      end if;\n+            Write_Str (\"  instantiation location: \");\n+            Write_Location (Sloc (Inst_Node));\n+            Write_Eol;\n+         end if;\n \n-      --  For a given character in the source, a higher subscript will be used\n-      --  to access the instantiation, which means that the virtual origin must\n-      --  have a corresponding lower value. We compute this new origin by\n-      --  taking the address of the appropriate adjusted element in the old\n-      --  array. Since this adjusted element will be at a negative subscript,\n-      --  we must suppress checks.\n+         --  For a given character in the source, a higher subscript will be\n+         --  used to access the instantiation, which means that the virtual\n+         --  origin must have a corresponding lower value. We compute this new\n+         --  origin by taking the address of the appropriate adjusted element\n+         --  in the old array. Since this adjusted element will be at a\n+         --  negative subscript, we must suppress checks.\n \n-      declare\n-         pragma Suppress (All_Checks);\n+         declare\n+            pragma Suppress (All_Checks);\n \n-         pragma Warnings (Off);\n-         --  This unchecked conversion is aliasing safe, since it is never used\n-         --  to create improperly aliased pointer values.\n+            pragma Warnings (Off);\n+            --  This unchecked conversion is aliasing safe, since it is never\n+            --  used to create improperly aliased pointer values.\n \n-         function To_Source_Buffer_Ptr is new\n-           Unchecked_Conversion (Address, Source_Buffer_Ptr);\n+            function To_Source_Buffer_Ptr is new\n+              Unchecked_Conversion (Address, Source_Buffer_Ptr);\n \n-         pragma Warnings (On);\n+            pragma Warnings (On);\n \n-      begin\n-         Source_File.Table (Xnew).Source_Text :=\n-           To_Source_Buffer_Ptr\n-             (Source_File.Table (Xold).Source_Text (-A.Adjust)'Address);\n+         begin\n+            Snew.Source_Text :=\n+              To_Source_Buffer_Ptr\n+                (Sold.Source_Text (-A.Adjust)'Address);\n+         end;\n       end;\n    end Create_Instantiation_Source;\n \n@@ -433,9 +499,10 @@ package body Sinput.L is\n                   Full_Debug_Name     => Osint.Full_Source_Name,\n                   Full_File_Name      => Osint.Full_Source_Name,\n                   Full_Ref_Name       => Osint.Full_Source_Name,\n+                  Instance            => No_Instance_Id,\n                   Identifier_Casing   => Unknown,\n+                  Inlined_Call        => No_Location,\n                   Inlined_Body        => False,\n-                  Instantiation       => No_Location,\n                   Keyword_Casing      => Unknown,\n                   Last_Source_Line    => 1,\n                   License             => Unknown,"}, {"sha": "29be59ac688805926f8fcbe45d201904c7a59852", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -477,8 +477,26 @@ package body Sinput is\n       First_Time_Around  := True;\n \n       Source_File.Init;\n+\n+      Instances.Init;\n+      Instances.Append (No_Location);\n+      pragma Assert (Instances.Last = No_Instance_Id);\n    end Initialize;\n \n+   -------------------\n+   -- Instantiation --\n+   -------------------\n+\n+   function Instantiation (S : SFI) return Source_Ptr is\n+      SIE : Source_File_Record renames Source_File.Table (S);\n+   begin\n+      if SIE.Inlined_Body then\n+         return SIE.Inlined_Call;\n+      else\n+         return Instances.Table (SIE.Instance);\n+      end if;\n+   end Instantiation;\n+\n    -------------------------\n    -- Instantiation_Depth --\n    -------------------------\n@@ -511,6 +529,17 @@ package body Sinput is\n       return Instantiation (Get_Source_File_Index (S));\n    end Instantiation_Location;\n \n+   --------------------------\n+   -- Iterate_On_Instances --\n+   --------------------------\n+\n+   procedure Iterate_On_Instances is\n+   begin\n+      for J in 1 .. Instances.Last loop\n+         Process (J, Instances.Table (J));\n+      end loop;\n+   end Iterate_On_Instances;\n+\n    ----------------------\n    -- Last_Source_File --\n    ----------------------\n@@ -852,7 +881,7 @@ package body Sinput is\n                Tmp1 : Source_Buffer_Ptr;\n \n             begin\n-               if S.Instantiation /= No_Location then\n+               if S.Instance /= No_Instance_Id then\n                   null;\n \n                else\n@@ -887,9 +916,10 @@ package body Sinput is\n       Source_Cache_First := 1;\n       Source_Cache_Last  := 0;\n \n-      --  Read in source file table\n+      --  Read in source file table and instance table\n \n       Source_File.Tree_Read;\n+      Instances.Tree_Read;\n \n       --  The pointers we read in there for the source buffer and lines\n       --  table pointers are junk. We now read in the actual data that\n@@ -904,7 +934,7 @@ package body Sinput is\n             --  we share the data for the generic template entry. Since the\n             --  template always occurs first, we can safely refer to its data.\n \n-            if S.Instantiation /= No_Location then\n+            if S.Instance /= No_Instance_Id then\n                declare\n                   ST : Source_File_Record renames\n                          Source_File.Table (S.Template);\n@@ -1004,6 +1034,7 @@ package body Sinput is\n    procedure Tree_Write is\n    begin\n       Source_File.Tree_Write;\n+      Instances.Tree_Write;\n \n       --  The pointers we wrote out there for the source buffer and lines\n       --  table pointers are junk, we now write out the actual data that\n@@ -1018,7 +1049,7 @@ package body Sinput is\n             --  shared with the generic template. When the tree is read, the\n             --  pointers must be set, but no extra data needs to be written.\n \n-            if S.Instantiation /= No_Location then\n+            if S.Instance /= No_Instance_Id then\n                null;\n \n             --  For the normal case, write out the data of the tables\n@@ -1131,6 +1162,11 @@ package body Sinput is\n       return Source_File.Table (S).Debug_Source_Name;\n    end Debug_Source_Name;\n \n+   function Instance (S : SFI) return Instance_Id is\n+   begin\n+      return Source_File.Table (S).Instance;\n+   end Instance;\n+\n    function File_Name (S : SFI) return File_Name_Type is\n    begin\n       return Source_File.Table (S).File_Name;\n@@ -1171,10 +1207,10 @@ package body Sinput is\n       return Source_File.Table (S).Inlined_Body;\n    end Inlined_Body;\n \n-   function Instantiation (S : SFI) return Source_Ptr is\n+   function Inlined_Call (S : SFI) return Source_Ptr is\n    begin\n-      return Source_File.Table (S).Instantiation;\n-   end Instantiation;\n+      return Source_File.Table (S).Inlined_Call;\n+   end Inlined_Call;\n \n    function Keyword_Casing (S : SFI) return Casing_Type is\n    begin"}, {"sha": "f678ff62984980141ac52d94194ebc490136c5d1", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -83,6 +83,9 @@ package Sinput is\n       Preproc);\n       --  Source file with preprocessing commands to be preprocessed\n \n+   type Instance_Id is new Nat;\n+   No_Instance_Id : constant Instance_Id;\n+\n    ----------------------------\n    -- Source License Control --\n    ----------------------------\n@@ -198,6 +201,12 @@ package Sinput is\n    --    Only processing in Sprint that generates this file is permitted to\n    --    set this field.\n \n+   --  Instance : Instance_Id (read-only)\n+   --    For entries corresponding to a generic instantiation, unique\n+   --    identifier denoting the full chain of nested instantiations. Set to\n+   --    No_Instance_Id for the case of a normal, non-instantiation entry.\n+   --    See below for details on the handling of generic instantiations.\n+\n    --  License : License_Type;\n    --    License status of source file\n \n@@ -249,16 +258,16 @@ package Sinput is\n    --    This value is used for formatting of error messages, and also is used\n    --    in the detection of keywords misused as identifiers.\n \n-   --  Instantiation : Source_Ptr;\n-   --    Source file location of the instantiation if this source file entry\n-   --    represents a generic instantiation. Set to No_Location for the case\n-   --    of a normal non-instantiation entry. See section below for details.\n+   --  Inlined_Call : Source_Ptr;\n+   --    Source file location of the subprogram call if this source file entry\n+   --    represents an inlined body. Set to No_Location otherwise.\n    --    This field is read-only for clients.\n \n    --  Inlined_Body : Boolean;\n    --    This can only be set True if Instantiation has a value other than\n    --    No_Location. If true it indicates that the instantiation is actually\n    --    an instance of an inlined body.\n+   --    ??? Redundant, always equal to (Inlined_Call /= No_Location)\n \n    --  Template : Source_File_Index; (read-only)\n    --    Source file index of the source file containing the template if this\n@@ -289,7 +298,8 @@ package Sinput is\n    function Full_Ref_Name     (S : SFI) return File_Name_Type;\n    function Identifier_Casing (S : SFI) return Casing_Type;\n    function Inlined_Body      (S : SFI) return Boolean;\n-   function Instantiation     (S : SFI) return Source_Ptr;\n+   function Inlined_Call      (S : SFI) return Source_Ptr;\n+   function Instance          (S : SFI) return Instance_Id;\n    function Keyword_Casing    (S : SFI) return Casing_Type;\n    function Last_Source_Line  (S : SFI) return Physical_Line_Number;\n    function License           (S : SFI) return License_Type;\n@@ -408,17 +418,31 @@ package Sinput is\n    --  to point to the same text, because of the virtual origin pointers used\n    --  in the source table.\n \n-   --  The Instantiation field of this source file index entry, usually set\n-   --  to No_Source_File, instead contains the Sloc of the instantiation. In\n-   --  the case of nested instantiations, this Sloc may itself refer to an\n-   --  instantiation, so the complete chain can be traced.\n+   --  The Instantiation_Id field of this source file index entry, set\n+   --  to No_Instance_Id for normal entries, instead contains a value that\n+   --  uniquely identifies a particular instantiation, and the associated\n+   --  entry in the Instances table. The source location of the instantiation\n+   --  can be retrieved using function Instantiation below. In the case of\n+   --  nested instantiations, the Instances table can be used to trace the\n+   --  complete chain of nested instantiations.\n \n-   --  Two routines are used to build these special entries in the source\n-   --  file table. Create_Instantiation_Source is first called to build\n+   --  Two routines are used to build the special instance entries in the\n+   --  source file table. Create_Instantiation_Source is first called to build\n    --  the virtual source table entry for the instantiation, and then the\n    --  Sloc values in the copy are adjusted using Adjust_Instantiation_Sloc.\n    --  See child unit Sinput.L for details on these two routines.\n \n+   generic\n+      with procedure Process (Id : Instance_Id; Inst_Sloc : Source_Ptr);\n+   procedure Iterate_On_Instances;\n+   --  Execute Process for each entry in the instance table\n+\n+   function Instantiation (S : SFI) return Source_Ptr;\n+   --  For a source file entry that represents an inlined body, source location\n+   --  of the inlined call. Otherwise, for a source file entry that represents\n+   --  a generic instantiation, source location of the instantiation. Returns\n+   --  No_Location in all other cases.\n+\n    -----------------\n    -- Global Data --\n    -----------------\n@@ -722,25 +746,37 @@ package Sinput is\n \n private\n    pragma Inline (File_Name);\n-   pragma Inline (First_Mapped_Line);\n    pragma Inline (Full_File_Name);\n-   pragma Inline (Identifier_Casing);\n-   pragma Inline (Instantiation);\n-   pragma Inline (Keyword_Casing);\n-   pragma Inline (Last_Source_Line);\n-   pragma Inline (Last_Source_File);\n+   pragma Inline (File_Type);\n+   pragma Inline (Reference_Name);\n+   pragma Inline (Full_Ref_Name);\n+   pragma Inline (Debug_Source_Name);\n+   pragma Inline (Full_Debug_Name);\n+   pragma Inline (Instance);\n    pragma Inline (License);\n    pragma Inline (Num_SRef_Pragmas);\n-   pragma Inline (Num_Source_Files);\n-   pragma Inline (Num_Source_Lines);\n-   pragma Inline (Reference_Name);\n-   pragma Inline (Set_Keyword_Casing);\n-   pragma Inline (Set_Identifier_Casing);\n+   pragma Inline (First_Mapped_Line);\n+   pragma Inline (Source_Text);\n    pragma Inline (Source_First);\n    pragma Inline (Source_Last);\n-   pragma Inline (Source_Text);\n-   pragma Inline (Template);\n    pragma Inline (Time_Stamp);\n+   pragma Inline (Source_Checksum);\n+   pragma Inline (Last_Source_Line);\n+   pragma Inline (Keyword_Casing);\n+   pragma Inline (Identifier_Casing);\n+   pragma Inline (Inlined_Call);\n+   pragma Inline (Inlined_Body);\n+   pragma Inline (Template);\n+   pragma Inline (Unit);\n+\n+   pragma Inline (Set_Keyword_Casing);\n+   pragma Inline (Set_Identifier_Casing);\n+\n+   pragma Inline (Last_Source_File);\n+   pragma Inline (Num_Source_Files);\n+   pragma Inline (Num_Source_Lines);\n+\n+   No_Instance_Id : constant Instance_Id := 0;\n \n    -------------------------\n    -- Source_Lines Tables --\n@@ -781,18 +817,19 @@ private\n       Full_Debug_Name   : File_Name_Type;\n       Full_File_Name    : File_Name_Type;\n       Full_Ref_Name     : File_Name_Type;\n+      Instance          : Instance_Id;\n       Num_SRef_Pragmas  : Nat;\n       First_Mapped_Line : Logical_Line_Number;\n       Source_Text       : Source_Buffer_Ptr;\n       Source_First      : Source_Ptr;\n       Source_Last       : Source_Ptr;\n       Source_Checksum   : Word;\n       Last_Source_Line  : Physical_Line_Number;\n-      Instantiation     : Source_Ptr;\n       Template          : Source_File_Index;\n       Unit              : Unit_Number_Type;\n       Time_Stamp        : Time_Stamp_Type;\n       File_Type         : Type_Of_File;\n+      Inlined_Call      : Source_Ptr;\n       Inlined_Body      : Boolean;\n       License           : License_Type;\n       Keyword_Casing    : Casing_Type;\n@@ -839,17 +876,18 @@ private\n       Full_Debug_Name     at 12 range 0 .. 31;\n       Full_File_Name      at 16 range 0 .. 31;\n       Full_Ref_Name       at 20 range 0 .. 31;\n+      Instance            at 48 range 0 .. 31;\n       Num_SRef_Pragmas    at 24 range 0 .. 31;\n       First_Mapped_Line   at 28 range 0 .. 31;\n       Source_First        at 32 range 0 .. 31;\n       Source_Last         at 36 range 0 .. 31;\n       Source_Checksum     at 40 range 0 .. 31;\n       Last_Source_Line    at 44 range 0 .. 31;\n-      Instantiation       at 48 range 0 .. 31;\n       Template            at 52 range 0 .. 31;\n       Unit                at 56 range 0 .. 31;\n       Time_Stamp          at 60 range 0 .. 8 * Time_Stamp_Length - 1;\n       File_Type           at 74 range 0 .. 7;\n+      Inlined_Call        at 88 range 0 .. 31;\n       Inlined_Body        at 75 range 0 .. 7;\n       License             at 76 range 0 .. 7;\n       Keyword_Casing      at 77 range 0 .. 7;\n@@ -860,12 +898,12 @@ private\n       --  The following fields are pointers, so we have to specialize their\n       --  lengths using pointer size, obtained above as Standard'Address_Size.\n \n-      Source_Text         at 88 range 0      .. AS - 1;\n-      Lines_Table         at 88 range AS     .. AS * 2 - 1;\n-      Logical_Lines_Table at 88 range AS * 2 .. AS * 3 - 1;\n+      Source_Text         at 92 range 0      .. AS - 1;\n+      Lines_Table         at 92 range AS     .. AS * 2 - 1;\n+      Logical_Lines_Table at 92 range AS * 2 .. AS * 3 - 1;\n    end record;\n \n-   for Source_File_Record'Size use 88 * 8 + AS * 3;\n+   for Source_File_Record'Size use 92 * 8 + AS * 3;\n    --  This ensures that we did not leave out any fields\n \n    package Source_File is new Table.Table (\n@@ -876,6 +914,17 @@ private\n      Table_Increment      => Alloc.Source_File_Increment,\n      Table_Name           => \"Source_File\");\n \n+   --  Auxiliary table containing source location of instantiations. Index 0\n+   --  is used for code that does not come from an instance.\n+\n+   package Instances is new Table.Table (\n+     Table_Component_Type => Source_Ptr,\n+     Table_Index_Type     => Instance_Id,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Source_File_Initial,\n+     Table_Increment      => Alloc.Source_File_Increment,\n+     Table_Name           => \"Instances\");\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "a0f28910d1139931df1ed4d2c6ae34a67cd4ea63", "filename": "gcc/ada/types.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf427f02bb7cc5a0103f5821e7b4f042c9275320/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=cf427f02bb7cc5a0103f5821e7b4f042c9275320", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -130,6 +130,9 @@ typedef Text_Ptr Source_Ptr;\n /* Used for Sloc in all nodes in the representation of package Standard.  */\n #define Standard_Location -2\n \n+/* Instance identifiers */\n+typedef Nat Instance_Id;\n+\n /* Type used for union of all possible ID values covering all ranges */\n typedef int Union_Id;\n "}]}