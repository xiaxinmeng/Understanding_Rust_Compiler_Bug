{"sha": "63570af0b58a3c354723bc78b75d76dbb0750f47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1NzBhZjBiNThhM2MzNTQ3MjNiYzc4Yjc1ZDc2ZGJiMDc1MGY0Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-07T18:42:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-07T18:42:41Z"}, "message": "Make more use of VECTOR_CST_ENCODED_ELT\n\nThis patch makes various bits of code operate directly on the new\nVECTOR_CST encoding, instead of using VECTOR_CST_ELT on all elements\nof the vector.\n\nPrevious patches handled operations that produce a new VECTOR_CST,\nwhile this patch handles things like predicates.  It also makes\nprint_node dump the encoding instead of the full vector that\nthe encoding represents.\n\n2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vector-builder.h\n\t(tree_vector_builder::binary_encoded_nelts): Declare.\n\t* tree-vector-builder.c\n\t(tree_vector_builder::binary_encoded_nelts): New function.\n\t* fold-const.c (negate_expr_p): Likewise.\n\t(operand_equal_p, fold_checksum_tree): Likewise.\n\t* tree-loop-distribution.c (const_with_all_bytes_same): Likewise.\n\t* tree.c (integer_zerop, integer_onep, integer_all_onesp, real_zerop)\n\t(real_onep, real_minus_onep, add_expr, initializer_zerop): Likewise.\n\t(uniform_vector_p): Likewise.\n\t* varasm.c (const_hash_1, compare_constant): Likewise.\n\t* tree-ssa-ccp.c: Include tree-vector-builder.h.\n\t(valid_lattice_transition): Operate directly on the VECTOR_CST\n\tencoding.\n\t* ipa-icf.c: Include tree-vector-builder.h.\n\t(sem_variable::equals): Operate directly on the VECTOR_CST encoding.\n\t* print-tree.c (print_node): Print encoding of VECTOR_CSTs.\n\nFrom-SVN: r255480", "tree": {"sha": "7b1f2b8c0da2c3908d22d25dcea31ceacd492de2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b1f2b8c0da2c3908d22d25dcea31ceacd492de2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63570af0b58a3c354723bc78b75d76dbb0750f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63570af0b58a3c354723bc78b75d76dbb0750f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63570af0b58a3c354723bc78b75d76dbb0750f47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63570af0b58a3c354723bc78b75d76dbb0750f47/comments", "author": null, "committer": null, "parents": [{"sha": "44e1aae4dbd8198a26ab0ec5958e073e2c9cc772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e1aae4dbd8198a26ab0ec5958e073e2c9cc772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44e1aae4dbd8198a26ab0ec5958e073e2c9cc772"}], "stats": {"total": 250, "additions": 137, "deletions": 113}, "files": [{"sha": "1cee5e8290700e0d0680882e3cc0f5d9d631caad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -1,3 +1,23 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vector-builder.h\n+\t(tree_vector_builder::binary_encoded_nelts): Declare.\n+\t* tree-vector-builder.c\n+\t(tree_vector_builder::binary_encoded_nelts): New function.\n+\t* fold-const.c (negate_expr_p): Likewise.\n+\t(operand_equal_p, fold_checksum_tree): Likewise.\n+\t* tree-loop-distribution.c (const_with_all_bytes_same): Likewise.\n+\t* tree.c (integer_zerop, integer_onep, integer_all_onesp, real_zerop)\n+\t(real_onep, real_minus_onep, add_expr, initializer_zerop): Likewise.\n+\t(uniform_vector_p): Likewise.\n+\t* varasm.c (const_hash_1, compare_constant): Likewise.\n+\t* tree-ssa-ccp.c: Include tree-vector-builder.h.\n+\t(valid_lattice_transition): Operate directly on the VECTOR_CST\n+\tencoding.\n+\t* ipa-icf.c: Include tree-vector-builder.h.\n+\t(sem_variable::equals): Operate directly on the VECTOR_CST encoding.\n+\t* print-tree.c (print_node): Print encoding of VECTOR_CSTs.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree.c (build_vector): Delete."}, {"sha": "0f110765f44ba42754ddca3dbdcaf36f0809182d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -410,10 +410,10 @@ negate_expr_p (tree t)\n \tif (FLOAT_TYPE_P (TREE_TYPE (type)) || TYPE_OVERFLOW_WRAPS (type))\n \t  return true;\n \n-\tint count = VECTOR_CST_NELTS (t), i;\n-\n-\tfor (i = 0; i < count; i++)\n-\t  if (!negate_expr_p (VECTOR_CST_ELT (t, i)))\n+\t/* Steps don't prevent negation.  */\n+\tunsigned int count = vector_cst_encoded_nelts (t);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  if (!negate_expr_p (VECTOR_CST_ENCODED_ELT (t, i)))\n \t    return false;\n \n \treturn true;\n@@ -2981,17 +2981,19 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n       case VECTOR_CST:\n \t{\n-\t  unsigned i;\n+\t  if (VECTOR_CST_LOG2_NPATTERNS (arg0)\n+\t      != VECTOR_CST_LOG2_NPATTERNS (arg1))\n+\t    return 0;\n \n-\t  if (VECTOR_CST_NELTS (arg0) != VECTOR_CST_NELTS (arg1))\n+\t  if (VECTOR_CST_NELTS_PER_PATTERN (arg0)\n+\t      != VECTOR_CST_NELTS_PER_PATTERN (arg1))\n \t    return 0;\n \n-\t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n-\t    {\n-\t      if (!operand_equal_p (VECTOR_CST_ELT (arg0, i),\n-\t\t\t\t    VECTOR_CST_ELT (arg1, i), flags))\n-\t\treturn 0;\n-\t    }\n+\t  unsigned int count = vector_cst_encoded_nelts (arg0);\n+\t  for (unsigned int i = 0; i < count; ++i)\n+\t    if (!operand_equal_p (VECTOR_CST_ENCODED_ELT (arg0, i),\n+\t\t\t\t  VECTOR_CST_ENCODED_ELT (arg1, i), flags))\n+\t      return 0;\n \t  return 1;\n \t}\n \n@@ -11992,8 +11994,9 @@ fold_checksum_tree (const_tree expr, struct md5_ctx *ctx,\n \t  fold_checksum_tree (TREE_IMAGPART (expr), ctx, ht);\n \t  break;\n \tcase VECTOR_CST:\n-\t  for (i = 0; i < (int) VECTOR_CST_NELTS (expr); ++i)\n-\t    fold_checksum_tree (VECTOR_CST_ELT (expr, i), ctx, ht);\n+\t  len = vector_cst_encoded_nelts (expr);\n+\t  for (i = 0; i < len; ++i)\n+\t    fold_checksum_tree (VECTOR_CST_ENCODED_ELT (expr, i), ctx, ht);\n \t  break;\n \tdefault:\n \t  break;"}, {"sha": "a8d3b80031877917e573c46c2d8c0e1b90947d79", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -83,6 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-icf.h\"\n #include \"stor-layout.h\"\n #include \"dbgcnt.h\"\n+#include \"tree-vector-builder.h\"\n \n using namespace ipa_icf_gimple;\n \n@@ -2024,17 +2025,17 @@ sem_variable::equals (tree t1, tree t2)\n \t\t\t\t\t\t&TREE_REAL_CST (t2)));\n     case VECTOR_CST:\n       {\n-\tunsigned i;\n-\n         if (VECTOR_CST_NELTS (t1) != VECTOR_CST_NELTS (t2))\n           return return_false_with_msg (\"VECTOR_CST nelts mismatch\");\n \n-\tfor (i = 0; i < VECTOR_CST_NELTS (t1); ++i)\n-\t  if (!sem_variable::equals (VECTOR_CST_ELT (t1, i),\n-\t\t\t\t     VECTOR_CST_ELT (t2, i)))\n-\t    return 0;\n+\tunsigned int count\n+\t  = tree_vector_builder::binary_encoded_nelts (t1, t2);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  if (!sem_variable::equals (VECTOR_CST_ENCODED_ELT (t1, i),\n+\t\t\t\t     VECTOR_CST_ENCODED_ELT (t2, i)))\n+\t    return false;\n \n-\treturn 1;\n+\treturn true;\n       }\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:"}, {"sha": "2139a7278eaadab2986a1b14116422942216a7d8", "filename": "gcc/print-tree.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -761,24 +761,18 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n \n \tcase VECTOR_CST:\n \t  {\n-\t    /* Big enough for 2 UINT_MAX plus the string below.  */\n+\t    /* Big enough for UINT_MAX plus the string below.  */\n \t    char buf[32];\n-\t    unsigned i;\n \n-\t    for (i = 0; i < VECTOR_CST_NELTS (node); ++i)\n+\t    fprintf (file, \" npatterns:%u nelts-per-pattern:%u\",\n+\t\t     VECTOR_CST_NPATTERNS (node),\n+\t\t     VECTOR_CST_NELTS_PER_PATTERN (node));\n+\t    unsigned int count = vector_cst_encoded_nelts (node);\n+\t    for (unsigned int i = 0; i < count; ++i)\n \t      {\n-\t\tunsigned j;\n-\t\t/* Coalesce the output of identical consecutive elements.  */\n-\t\tfor (j = i + 1; j < VECTOR_CST_NELTS (node); j++)\n-\t\t  if (VECTOR_CST_ELT (node, j) != VECTOR_CST_ELT (node, i))\n-\t\t    break;\n-\t\tj--;\n-\t\tif (i == j)\n-\t\t  sprintf (buf, \"elt:%u: \", i);\n-\t\telse\n-\t\t  sprintf (buf, \"elt:%u...%u: \", i, j);\n-\t\tprint_node (file, buf, VECTOR_CST_ELT (node, i), indent + 4);\n-\t\ti = j;\n+\t\tsprintf (buf, \"elt:%u: \", i);\n+\t\tprint_node (file, buf, VECTOR_CST_ENCODED_ELT (node, i),\n+\t\t\t    indent + 4);\n \t      }\n \t  }\n \t  break;"}, {"sha": "29825cc3f53041f9d3830961c8798a4e31eb24e2", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -944,13 +944,16 @@ const_with_all_bytes_same (tree val)\n \t    return 0;\n \t  break;\n \tcase VECTOR_CST:\n-\t  unsigned int j;\n-\t  for (j = 0; j < VECTOR_CST_NELTS (val); ++j)\n-\t    if (const_with_all_bytes_same (VECTOR_CST_ELT (val, j)))\n-\t      break;\n-\t  if (j == VECTOR_CST_NELTS (val))\n-\t    return 0;\n-\t  break;\n+\t  {\n+\t    unsigned int count = vector_cst_encoded_nelts (val);\n+\t    unsigned int j;\n+\t    for (j = 0; j < count; ++j)\n+\t      if (const_with_all_bytes_same (VECTOR_CST_ENCODED_ELT (val, j)))\n+\t\tbreak;\n+\t    if (j == count)\n+\t      return 0;\n+\t    break;\n+\t  }\n \tdefault:\n \t  break;\n \t}"}, {"sha": "3acddf9124737c984366180c10a1442df94e43cc", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -147,6 +147,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"tree-vector-builder.h\"\n \n /* Possible lattice values.  */\n typedef enum\n@@ -465,11 +466,14 @@ valid_lattice_transition (ccp_prop_value_t old_val, ccp_prop_value_t new_val)\n   else if (VECTOR_FLOAT_TYPE_P (type)\n \t   && !HONOR_NANS (type))\n     {\n-      for (unsigned i = 0; i < VECTOR_CST_NELTS (old_val.value); ++i)\n+      unsigned int count\n+\t= tree_vector_builder::binary_encoded_nelts (old_val.value,\n+\t\t\t\t\t\t     new_val.value);\n+      for (unsigned int i = 0; i < count; ++i)\n \tif (!REAL_VALUE_ISNAN\n-\t       (TREE_REAL_CST (VECTOR_CST_ELT (old_val.value, i)))\n-\t    && !operand_equal_p (VECTOR_CST_ELT (old_val.value, i),\n-\t\t\t\t VECTOR_CST_ELT (new_val.value, i), 0))\n+\t       (TREE_REAL_CST (VECTOR_CST_ENCODED_ELT (old_val.value, i)))\n+\t    && !operand_equal_p (VECTOR_CST_ENCODED_ELT (old_val.value, i),\n+\t\t\t\t VECTOR_CST_ENCODED_ELT (new_val.value, i), 0))\n \t  return false;\n       return true;\n     }"}, {"sha": "88b9d1a94808b904b50af9533d2df7a7660f5b8e", "filename": "gcc/tree-vector-builder.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -96,6 +96,24 @@ tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n   return true;\n }\n \n+/* Return the number of elements that the caller needs to operate on in\n+   order to handle a binary operation on VECTOR_CSTs T1 and T2.  This static\n+   function is used instead of new_binary_operation if the result of the\n+   operation is not a VECTOR_CST.  */\n+\n+unsigned int\n+tree_vector_builder::binary_encoded_nelts (tree t1, tree t2)\n+{\n+  unsigned int nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1));\n+  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2)));\n+  /* See new_binary_operation for details.  */\n+  unsigned int npatterns = least_common_multiple (VECTOR_CST_NPATTERNS (t1),\n+\t\t\t\t\t\t  VECTOR_CST_NPATTERNS (t2));\n+  unsigned int nelts_per_pattern = MAX (VECTOR_CST_NELTS_PER_PATTERN (t1),\n+\t\t\t\t\tVECTOR_CST_NELTS_PER_PATTERN (t2));\n+  return MIN (npatterns * nelts_per_pattern, nelts);\n+}\n+\n /* Return a vector element with the value BASE + FACTOR * STEP.  */\n \n tree"}, {"sha": "a7b9bdb577cac30f4fd12abbfa6dd40532b160b5", "filename": "gcc/tree-vector-builder.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.h?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -40,6 +40,8 @@ class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n   bool new_unary_operation (tree, tree, bool);\n   bool new_binary_operation (tree, tree, tree, bool);\n \n+  static unsigned int binary_encoded_nelts (tree, tree);\n+\n private:\n   bool equal_p (const_tree, const_tree) const;\n   bool allow_steps_p () const;"}, {"sha": "053670cb6b979fd26f913abcc84f6b6a2c310976", "filename": "gcc/tree.c", "status": "modified", "additions": 31, "deletions": 54, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -2338,13 +2338,9 @@ integer_zerop (const_tree expr)\n       return (integer_zerop (TREE_REALPART (expr))\n \t      && integer_zerop (TREE_IMAGPART (expr)));\n     case VECTOR_CST:\n-      {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\t  if (!integer_zerop (VECTOR_CST_ELT (expr, i)))\n-\t    return false;\n-\treturn true;\n-      }\n+      return (VECTOR_CST_NPATTERNS (expr) == 1\n+\t      && VECTOR_CST_DUPLICATE_P (expr)\n+\t      && integer_zerop (VECTOR_CST_ENCODED_ELT (expr, 0)));\n     default:\n       return false;\n     }\n@@ -2364,13 +2360,9 @@ integer_onep (const_tree expr)\n       return (integer_onep (TREE_REALPART (expr))\n \t      && integer_zerop (TREE_IMAGPART (expr)));\n     case VECTOR_CST:\n-      {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\t  if (!integer_onep (VECTOR_CST_ELT (expr, i)))\n-\t    return false;\n-\treturn true;\n-      }\n+      return (VECTOR_CST_NPATTERNS (expr) == 1\n+\t      && VECTOR_CST_DUPLICATE_P (expr)\n+\t      && integer_onep (VECTOR_CST_ENCODED_ELT (expr, 0)));\n     default:\n       return false;\n     }\n@@ -2401,13 +2393,9 @@ integer_all_onesp (const_tree expr)\n     return 1;\n \n   else if (TREE_CODE (expr) == VECTOR_CST)\n-    {\n-      unsigned i;\n-      for (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\tif (!integer_all_onesp (VECTOR_CST_ELT (expr, i)))\n-\t  return 0;\n-      return 1;\n-    }\n+    return (VECTOR_CST_NPATTERNS (expr) == 1\n+\t    && VECTOR_CST_DUPLICATE_P (expr)\n+\t    && integer_all_onesp (VECTOR_CST_ENCODED_ELT (expr, 0)));\n \n   else if (TREE_CODE (expr) != INTEGER_CST)\n     return 0;\n@@ -2630,9 +2618,11 @@ real_zerop (const_tree expr)\n \t     && real_zerop (TREE_IMAGPART (expr));\n     case VECTOR_CST:\n       {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\t  if (!real_zerop (VECTOR_CST_ELT (expr, i)))\n+\t/* Don't simply check for a duplicate because the predicate\n+\t   accepts both +0.0 and -0.0.  */\n+\tunsigned count = vector_cst_encoded_nelts (expr);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  if (!real_zerop (VECTOR_CST_ENCODED_ELT (expr, i)))\n \t    return false;\n \treturn true;\n       }\n@@ -2657,13 +2647,9 @@ real_onep (const_tree expr)\n       return real_onep (TREE_REALPART (expr))\n \t     && real_zerop (TREE_IMAGPART (expr));\n     case VECTOR_CST:\n-      {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\t  if (!real_onep (VECTOR_CST_ELT (expr, i)))\n-\t    return false;\n-\treturn true;\n-      }\n+      return (VECTOR_CST_NPATTERNS (expr) == 1\n+\t      && VECTOR_CST_DUPLICATE_P (expr)\n+\t      && real_onep (VECTOR_CST_ENCODED_ELT (expr, 0)));\n     default:\n       return false;\n     }\n@@ -2684,13 +2670,9 @@ real_minus_onep (const_tree expr)\n       return real_minus_onep (TREE_REALPART (expr))\n \t     && real_zerop (TREE_IMAGPART (expr));\n     case VECTOR_CST:\n-      {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\t  if (!real_minus_onep (VECTOR_CST_ELT (expr, i)))\n-\t    return false;\n-\treturn true;\n-      }\n+      return (VECTOR_CST_NPATTERNS (expr) == 1\n+\t      && VECTOR_CST_DUPLICATE_P (expr)\n+\t      && real_minus_onep (VECTOR_CST_ENCODED_ELT (expr, 0)));\n     default:\n       return false;\n     }\n@@ -7102,9 +7084,11 @@ add_expr (const_tree t, inchash::hash &hstate, unsigned int flags)\n       return;\n     case VECTOR_CST:\n       {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (t); ++i)\n-\t  inchash::add_expr (VECTOR_CST_ELT (t, i), hstate, flags);\n+\thstate.add_int (VECTOR_CST_NPATTERNS (t));\n+\thstate.add_int (VECTOR_CST_NELTS_PER_PATTERN (t));\n+\tunsigned int count = vector_cst_encoded_nelts (t);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  inchash::add_expr (VECTOR_CST_ENCODED_ELT (t, i), hstate, flags);\n \treturn;\n       }\n     case SSA_NAME:\n@@ -10431,13 +10415,9 @@ initializer_zerop (const_tree init)\n \t    && ! REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (TREE_IMAGPART (init))));\n \n     case VECTOR_CST:\n-      {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (init); ++i)\n-\t  if (!initializer_zerop (VECTOR_CST_ELT (init, i)))\n-\t    return false;\n-\treturn true;\n-      }\n+      return (VECTOR_CST_NPATTERNS (init) == 1\n+\t      && VECTOR_CST_DUPLICATE_P (init)\n+\t      && initializer_zerop (VECTOR_CST_ENCODED_ELT (init, 0)));\n \n     case CONSTRUCTOR:\n       {\n@@ -10486,12 +10466,9 @@ uniform_vector_p (const_tree vec)\n \n   if (TREE_CODE (vec) == VECTOR_CST)\n     {\n-      first = VECTOR_CST_ELT (vec, 0);\n-      for (i = 1; i < VECTOR_CST_NELTS (vec); ++i)\n-\tif (!operand_equal_p (first, VECTOR_CST_ELT (vec, i), 0))\n-\t  return NULL_TREE;\n-\n-      return first;\n+      if (VECTOR_CST_NPATTERNS (vec) == 1 && VECTOR_CST_DUPLICATE_P (vec))\n+\treturn VECTOR_CST_ENCODED_ELT (vec, 0);\n+      return NULL_TREE;\n     }\n \n   else if (TREE_CODE (vec) == CONSTRUCTOR)"}, {"sha": "3a53fb00e2b5e8aaf84fcdf4890432f1cb68eebb", "filename": "gcc/varasm.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63570af0b58a3c354723bc78b75d76dbb0750f47/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=63570af0b58a3c354723bc78b75d76dbb0750f47", "patch": "@@ -3007,13 +3007,11 @@ const_hash_1 (const tree exp)\n \n     case VECTOR_CST:\n       {\n-\tunsigned i;\n-\n-\thi = 7 + VECTOR_CST_NELTS (exp);\n-\n-\tfor (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n-\t  hi = hi * 563 + const_hash_1 (VECTOR_CST_ELT (exp, i));\n-\n+\thi = 7 + VECTOR_CST_NPATTERNS (exp);\n+\thi = hi * 563 + VECTOR_CST_NELTS_PER_PATTERN (exp);\n+\tunsigned int count = vector_cst_encoded_nelts (exp);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  hi = hi * 563 + const_hash_1 (VECTOR_CST_ENCODED_ELT (exp, i));\n \treturn hi;\n       }\n \n@@ -3151,14 +3149,18 @@ compare_constant (const tree t1, const tree t2)\n \n     case VECTOR_CST:\n       {\n-\tunsigned i;\n+\tif (VECTOR_CST_NPATTERNS (t1)\n+\t    != VECTOR_CST_NPATTERNS (t2))\n+\t  return 0;\n \n-        if (VECTOR_CST_NELTS (t1) != VECTOR_CST_NELTS (t2))\n+\tif (VECTOR_CST_NELTS_PER_PATTERN (t1)\n+\t    != VECTOR_CST_NELTS_PER_PATTERN (t2))\n \t  return 0;\n \n-\tfor (i = 0; i < VECTOR_CST_NELTS (t1); ++i)\n-\t  if (!compare_constant (VECTOR_CST_ELT (t1, i),\n-\t\t\t\t VECTOR_CST_ELT (t2, i)))\n+\tunsigned int count = vector_cst_encoded_nelts (t1);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  if (!compare_constant (VECTOR_CST_ENCODED_ELT (t1, i),\n+\t\t\t\t VECTOR_CST_ENCODED_ELT (t2, i)))\n \t    return 0;\n \n \treturn 1;"}]}