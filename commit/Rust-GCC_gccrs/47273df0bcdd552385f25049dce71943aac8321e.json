{"sha": "47273df0bcdd552385f25049dce71943aac8321e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcyNzNkZjBiY2RkNTUyMzg1ZjI1MDQ5ZGNlNzE5NDNhYWM4MzIxZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-22T10:29:19Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-05-22T10:30:14Z"}, "message": "Simplify streaming of SCC components\n\nthis patch saves few bytes from SCC streaming.  First we stream end markers\nthat are fully ignored at stream in.\nSecond I missed streaming of emtry_len in the previous change so it is\npointlessly streamed for LTO_trees. Moreover entry_len is almost always 1\n(always during gcc bootstrap) and thus it makes sense to avoid stremaing it\nin majority of cases.\n\ngcc/ChangeLog:\n\n2020-05-21  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-streamer-in.c (lto_read_tree): Do not stream end markers.\n\t(lto_input_scc): Optimize streaming of entry lengths.\n\t* lto-streamer-out.c (lto_write_tree): Do not stream end markers\n\t(DFS::DFS): Optimize stremaing of entry lengths", "tree": {"sha": "20f5b2a2605f1215f1256d9635f44a0a7eb86c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20f5b2a2605f1215f1256d9635f44a0a7eb86c15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47273df0bcdd552385f25049dce71943aac8321e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47273df0bcdd552385f25049dce71943aac8321e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47273df0bcdd552385f25049dce71943aac8321e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47273df0bcdd552385f25049dce71943aac8321e/comments", "author": null, "committer": null, "parents": [{"sha": "ab7eca92926fdc1da880120c116a1832fce56a29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab7eca92926fdc1da880120c116a1832fce56a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab7eca92926fdc1da880120c116a1832fce56a29"}], "stats": {"total": 43, "additions": 23, "deletions": 20}, "files": [{"sha": "820240fc8274635f254337232ce3186ba52883b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47273df0bcdd552385f25049dce71943aac8321e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47273df0bcdd552385f25049dce71943aac8321e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47273df0bcdd552385f25049dce71943aac8321e", "patch": "@@ -1,3 +1,10 @@\n+2020-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-streamer-in.c (lto_read_tree): Do not stream end markers.\n+\t(lto_input_scc): Optimize streaming of entry lengths.\n+\t* lto-streamer-out.c (lto_write_tree): Do not stream end markers\n+\t(DFS::DFS): Optimize stremaing of entry lengths\n+\n 2020-05-22  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/95190"}, {"sha": "d0532c5ac51ab61c87f95ca2a14f825b8d90ee75", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47273df0bcdd552385f25049dce71943aac8321e/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47273df0bcdd552385f25049dce71943aac8321e/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=47273df0bcdd552385f25049dce71943aac8321e", "patch": "@@ -1417,8 +1417,6 @@ lto_read_tree (class lto_input_block *ib, class data_in *data_in,\n \n   lto_read_tree_1 (ib, data_in, result);\n \n-  /* end_marker = */ streamer_read_uchar (ib);\n-\n   return result;\n }\n \n@@ -1431,12 +1429,18 @@ hashval_t\n lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n \t       unsigned *len, unsigned *entry_len, bool shared_scc)\n {\n-  /* A blob of unnamed tree nodes, fill the cache from it and\n-     recurse.  */\n   unsigned size = streamer_read_uhwi (ib);\n-  hashval_t scc_hash = shared_scc ? streamer_read_uhwi (ib) : 0;\n+  hashval_t scc_hash = 0;\n   unsigned scc_entry_len = 1;\n \n+  if (shared_scc)\n+    {\n+      if (size & 1)\n+\tscc_entry_len = streamer_read_uhwi (ib);\n+      size /= 2;\n+      scc_hash = streamer_read_uhwi (ib);\n+    }\n+\n   if (size == 1)\n     {\n       enum LTO_tags tag = streamer_read_record_start (ib);\n@@ -1447,8 +1451,6 @@ lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n       unsigned int first = data_in->reader_cache->nodes.length ();\n       tree result;\n \n-      scc_entry_len = streamer_read_uhwi (ib);\n-\n       /* Materialize size trees by reading their headers.  */\n       for (unsigned i = 0; i < size; ++i)\n \t{\n@@ -1471,7 +1473,6 @@ lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n \t  result = streamer_tree_cache_get_tree (data_in->reader_cache,\n \t\t\t\t\t\t first + i);\n \t  lto_read_tree_1 (ib, data_in, result);\n-\t  /* end_marker = */ streamer_read_uchar (ib);\n \t}\n     }\n "}, {"sha": "09a2e827f8ef380fdf4832afb3d613ec55aaff8b", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47273df0bcdd552385f25049dce71943aac8321e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47273df0bcdd552385f25049dce71943aac8321e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=47273df0bcdd552385f25049dce71943aac8321e", "patch": "@@ -473,9 +473,6 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n   streamer_write_tree_header (ob, expr);\n \n   lto_write_tree_1 (ob, expr, ref_p);\n-\n-  /* Mark the end of EXPR.  */\n-  streamer_write_zero (ob);\n }\n \n /* Emit the physical representation of tree node EXPR to output block OB,\n@@ -764,7 +761,12 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t    {\n \t      gcc_checking_assert (ob->section_type == LTO_section_decls);\n \t      streamer_write_record_start (ob, LTO_tree_scc);\n-\t      streamer_write_uhwi (ob, size);\n+\t      /* In wast majority of cases scc_entry_len is 1 and size is small\n+\t\t integer.  Use extra bit of size to stream info about\n+\t\t exceptions.  */\n+\t      streamer_write_uhwi (ob, size * 2 + (scc_entry_len != 1));\n+\t      if (scc_entry_len != 1)\n+\t\tstreamer_write_uhwi (ob, scc_entry_len);\n \t      streamer_write_uhwi (ob, scc_hash);\n \t    }\n \t  /* Non-trivial SCCs must be packed to trees blocks so forward\n@@ -783,8 +785,6 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t    lto_output_tree_1 (ob, expr, scc_hash, ref_p, this_ref_p);\n \t  else\n \t    {\n-\t      /* Write the size of the SCC entry candidates.  */\n-\t      streamer_write_uhwi (ob, scc_entry_len);\n \n \t      /* Write all headers and populate the streamer cache.  */\n \t      for (unsigned i = 0; i < size; ++i)\n@@ -807,12 +807,7 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \n \t      /* Write the bitpacks and tree references.  */\n \t      for (unsigned i = 0; i < size; ++i)\n-\t\t{\n-\t\t  lto_write_tree_1 (ob, sccstack[first+i].t, ref_p);\n-\n-\t\t  /* Mark the end of the tree.  */\n-\t\t  streamer_write_zero (ob);\n-\t\t}\n+\t\tlto_write_tree_1 (ob, sccstack[first+i].t, ref_p);\n \t    }\n \n \t  /* Finally truncate the vector.  */"}]}