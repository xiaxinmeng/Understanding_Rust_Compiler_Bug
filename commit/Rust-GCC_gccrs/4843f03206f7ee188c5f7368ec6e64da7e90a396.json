{"sha": "4843f03206f7ee188c5f7368ec6e64da7e90a396", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg0M2YwMzIwNmY3ZWUxODhjNWY3MzY4ZWM2ZTY0ZGE3ZTkwYTM5Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-31T13:44:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-31T13:44:46Z"}, "message": "cgraph.c (cgraph_get_body): Update call of lto_input_function_body.\n\n\n\t* cgraph.c (cgraph_get_body): Update call of lto_input_function_body.\n\t* gimple-streamer-in.c (input_gimple_stmt): Move sanity check to ...\n\t* ipa-utils.c: Include lto-streamer.h, ipa-inline.h\n\t(ipa_merge_profiles): New function.\n\t* lto-streamer-in.c (lto_read_body): Take node instead of fn_decl.\n\t(lto_input_function_body): Likewise.\n\nFrom-SVN: r202130", "tree": {"sha": "d06573f8980bf9312721db9d6677d8f26547ca5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d06573f8980bf9312721db9d6677d8f26547ca5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4843f03206f7ee188c5f7368ec6e64da7e90a396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4843f03206f7ee188c5f7368ec6e64da7e90a396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4843f03206f7ee188c5f7368ec6e64da7e90a396", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4843f03206f7ee188c5f7368ec6e64da7e90a396/comments", "author": null, "committer": null, "parents": [{"sha": "57292ce9bd9df2ff43d3cb13f3761b6eb5cf6334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57292ce9bd9df2ff43d3cb13f3761b6eb5cf6334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57292ce9bd9df2ff43d3cb13f3761b6eb5cf6334"}], "stats": {"total": 199, "additions": 189, "deletions": 10}, "files": [{"sha": "a5824be71ad6a06337112d54349aecc346f02e84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4843f03206f7ee188c5f7368ec6e64da7e90a396", "patch": "@@ -1,3 +1,12 @@\n+2013-08-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_get_body): Update call of lto_input_function_body.\n+\t* gimple-streamer-in.c (input_gimple_stmt): Move sanity check to ...\n+\t* ipa-utils.c: Include lto-streamer.h, ipa-inline.h\n+\t(ipa_merge_profiles): New function.\n+\t* lto-streamer-in.c (lto_read_body): Take node instead of fn_decl.\n+\t(lto_input_function_body): Likewise.\n+\n 2013-08-31  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_speculative_call_info): Fix ref lookup"}, {"sha": "a240bfc49ac08c9f6ab226301e4f8611b751e321", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4843f03206f7ee188c5f7368ec6e64da7e90a396", "patch": "@@ -3111,7 +3111,7 @@ cgraph_get_body (struct cgraph_node *node)\n \n   gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n \n-  lto_input_function_body (file_data, node->symbol.decl, data);\n+  lto_input_function_body (file_data, node, data);\n   lto_stats.num_function_bodies++;\n   lto_free_section_data (file_data, LTO_section_function_body, name,\n \t\t\t data, len);"}, {"sha": "4abf9cd739e0a3873f0112de97c816a8f0ade3bd", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=4843f03206f7ee188c5f7368ec6e64da7e90a396", "patch": "@@ -282,9 +282,6 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n       if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \tSSA_NAME_DEF_STMT (lhs) = stmt;\n     }\n-  else if (code == GIMPLE_LABEL)\n-    gcc_assert (emit_label_in_global_context_p (gimple_label_label (stmt))\n-\t        || DECL_CONTEXT (gimple_label_label (stmt)) == fn->decl);\n   else if (code == GIMPLE_ASM)\n     {\n       unsigned i;"}, {"sha": "0ea02eab8cc96ff94a9210630886d389dd2dc4ca", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=4843f03206f7ee188c5f7368ec6e64da7e90a396", "patch": "@@ -37,6 +37,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n+#include \"lto-streamer.h\"\n+#include \"ipa-inline.h\"\n \n /* Debugging function for postorder and inorder code. NOTE is a string\n    that is printed before the nodes are printed.  ORDER is an array of\n@@ -618,3 +620,174 @@ debug_varpool_node_set (varpool_node_set set)\n {\n   dump_varpool_node_set (stderr, set);\n }\n+\n+\n+/* SRC and DST are going to be merged.  Take SRC's profile and merge it into\n+   DST so it is not going to be lost.  Destroy SRC's body on the way.  */\n+\n+void\n+ipa_merge_profiles (struct cgraph_node *dst,\n+\t\t    struct cgraph_node *src)\n+{\n+  tree oldsrcdecl = src->symbol.decl;\n+  struct function *srccfun, *dstcfun;\n+  bool match = true;\n+\n+  if (!src->symbol.definition\n+      || !dst->symbol.definition)\n+    return;\n+  if (src->frequency < dst->frequency)\n+    src->frequency = dst->frequency;\n+  if (!dst->count)\n+    return;\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n+\t       xstrdup (cgraph_node_name (src)), src->symbol.order,\n+\t       xstrdup (cgraph_node_name (dst)), dst->symbol.order);\n+    }\n+  dst->count += src->count;\n+\n+  /* This is ugly.  We need to get both function bodies into memory.\n+     If declaration is merged, we need to duplicate it to be able\n+     to load body that is being replaced.  This makes symbol table\n+     temporarily inconsistent.  */\n+  if (src->symbol.decl == dst->symbol.decl)\n+    {\n+      void **slot;\n+      struct lto_in_decl_state temp;\n+      struct lto_in_decl_state *state;\n+\n+      /* We are going to move the decl, we want to remove its file decl data.\n+\t and link these with the new decl. */\n+      temp.fn_decl = src->symbol.decl;\n+      slot = htab_find_slot (src->symbol.lto_file_data->function_decl_states,\n+\t\t\t     &temp, NO_INSERT);\n+      state = (lto_in_decl_state *)*slot;\n+      htab_clear_slot (src->symbol.lto_file_data->function_decl_states, slot);\n+      gcc_assert (state);\n+\n+      /* Duplicate the decl and be sure it does not link into body of DST.  */\n+      src->symbol.decl = copy_node (src->symbol.decl);\n+      DECL_STRUCT_FUNCTION (src->symbol.decl) = NULL;\n+      DECL_ARGUMENTS (src->symbol.decl) = NULL;\n+      DECL_INITIAL (src->symbol.decl) = NULL;\n+      DECL_RESULT (src->symbol.decl) = NULL;\n+\n+      /* Associate the decl state with new declaration, so LTO streamer\n+ \t can look it up.  */\n+      state->fn_decl = src->symbol.decl;\n+      slot = htab_find_slot (src->symbol.lto_file_data->function_decl_states,\n+\t\t\t     state, INSERT);\n+      gcc_assert (!*slot);\n+      *slot = state;\n+    }\n+  cgraph_get_body (src);\n+  cgraph_get_body (dst);\n+  srccfun = DECL_STRUCT_FUNCTION (src->symbol.decl);\n+  dstcfun = DECL_STRUCT_FUNCTION (dst->symbol.decl);\n+  if (n_basic_blocks_for_function (srccfun)\n+      != n_basic_blocks_for_function (dstcfun))\n+    {\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t \"Giving up; number of basic block mismatch.\\n\");\n+      match = false;\n+    }\n+  else if (last_basic_block_for_function (srccfun)\n+\t   != last_basic_block_for_function (dstcfun))\n+    {\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file,\n+\t\t \"Giving up; last block mismatch.\\n\");\n+      match = false;\n+    }\n+  else \n+    {\n+      basic_block srcbb, dstbb;\n+\n+      FOR_ALL_BB_FN (srcbb, srccfun)\n+\t{\n+\t  unsigned int i;\n+\n+\t  dstbb = BASIC_BLOCK_FOR_FUNCTION (dstcfun, srcbb->index);\n+\t  if (dstbb == NULL)\n+\t    {\n+\t      if (cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file,\n+\t\t\t \"No matching block for bb %i.\\n\",\n+\t\t\t srcbb->index);\n+\t      match = false;\n+\t      break;\n+\t    }\n+\t  if (EDGE_COUNT (srcbb->succs) != EDGE_COUNT (dstbb->succs))\n+\t    {\n+\t      if (cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file,\n+\t\t\t \"Edge count mistmatch for bb %i.\\n\",\n+\t\t\t srcbb->index);\n+\t      match = false;\n+\t      break;\n+\t    }\n+\t  for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n+\t    {\n+\t      edge srce = EDGE_SUCC (srcbb, i);\n+\t      edge dste = EDGE_SUCC (dstbb, i);\n+\t      if (srce->dest->index != dste->dest->index)\n+\t\t{\n+\t\t  if (cgraph_dump_file)\n+\t\t    fprintf (cgraph_dump_file,\n+\t\t\t     \"Succ edge mistmatch for bb %i.\\n\",\n+\t\t\t     srce->dest->index);\n+\t\t  match = false;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (match)\n+    {\n+      struct cgraph_edge *e;\n+      basic_block srcbb, dstbb;\n+\n+      /* TODO: merge also statement histograms.  */\n+      FOR_ALL_BB_FN (srcbb, srccfun)\n+\t{\n+\t  unsigned int i;\n+\n+\t  dstbb = BASIC_BLOCK_FOR_FUNCTION (dstcfun, srcbb->index);\n+\t  dstbb->count += srcbb->count;\n+\t  for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n+\t    {\n+\t      edge srce = EDGE_SUCC (srcbb, i);\n+\t      edge dste = EDGE_SUCC (dstbb, i);\n+\t      dste->count += srce->count;\n+\t    }\n+\t}\n+      push_cfun (dstcfun);\n+      counts_to_freqs ();\n+      compute_function_frequency ();\n+      pop_cfun ();\n+      for (e = dst->callees; e; e = e->next_callee)\n+\t{\n+\t  gcc_assert (!e->speculative);\n+\t  e->count = gimple_bb (e->call_stmt)->count;\n+\t  e->frequency = compute_call_stmt_bb_frequency\n+\t\t\t     (dst->symbol.decl,\n+\t\t\t      gimple_bb (e->call_stmt));\n+\t}\n+      for (e = dst->indirect_calls; e; e = e->next_callee)\n+\t{\n+\t  gcc_assert (!e->speculative);\n+\t  e->count = gimple_bb (e->call_stmt)->count;\n+\t  e->frequency = compute_call_stmt_bb_frequency\n+\t\t\t     (dst->symbol.decl,\n+\t\t\t      gimple_bb (e->call_stmt));\n+\t}\n+      cgraph_release_function_body (src);\n+      inline_update_overall_summary (dst);\n+    }\n+  /* TODO: if there is no match, we can scale up.  */\n+  src->symbol.decl = oldsrcdecl;\n+}\n+"}, {"sha": "f1d5935c42760bd4524301f1abb6aad2a3b527a4", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4843f03206f7ee188c5f7368ec6e64da7e90a396/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=4843f03206f7ee188c5f7368ec6e64da7e90a396", "patch": "@@ -1001,14 +1001,14 @@ input_function (tree fn_decl, struct data_in *data_in,\n }\n \n \n-/* Read the body from DATA for function FN_DECL and fill it in.\n+/* Read the body from DATA for function NODE and fill it in.\n    FILE_DATA are the global decls and types.  SECTION_TYPE is either\n    LTO_section_function_body or LTO_section_static_initializer.  If\n    section type is LTO_section_function_body, FN must be the decl for\n    that function.  */\n \n static void\n-lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n+lto_read_body (struct lto_file_decl_data *file_data, struct cgraph_node *node,\n \t       const char *data, enum lto_section_type section_type)\n {\n   const struct lto_function_header *header;\n@@ -1018,6 +1018,7 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n   int string_offset;\n   struct lto_input_block ib_cfg;\n   struct lto_input_block ib_main;\n+  tree fn_decl = node->symbol.decl;\n \n   header = (const struct lto_function_header *) data;\n   cfg_offset = sizeof (struct lto_function_header);\n@@ -1044,7 +1045,6 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n   if (section_type == LTO_section_function_body)\n     {\n       struct lto_in_decl_state *decl_state;\n-      struct cgraph_node *node = cgraph_get_node (fn_decl);\n       unsigned from;\n \n       gcc_checking_assert (node);\n@@ -1094,14 +1094,14 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n }\n \n \n-/* Read the body of FN_DECL using DATA.  FILE_DATA holds the global\n+/* Read the body of NODE using DATA.  FILE_DATA holds the global\n    decls and types.  */\n \n void\n lto_input_function_body (struct lto_file_decl_data *file_data,\n-\t\t\t tree fn_decl, const char *data)\n+\t\t\t struct cgraph_node *node, const char *data)\n {\n-  lto_read_body (file_data, fn_decl, data, LTO_section_function_body);\n+  lto_read_body (file_data, node, data, LTO_section_function_body);\n }\n \n "}]}