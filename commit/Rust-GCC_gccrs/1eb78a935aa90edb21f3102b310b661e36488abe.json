{"sha": "1eb78a935aa90edb21f3102b310b661e36488abe", "node_id": "C_kwDOANBUbNoAKDFlYjc4YTkzNWFhOTBlZGIyMWYzMTAyYjMxMGI2NjFlMzY0ODhhYmU", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-02-09T10:40:29Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-02-09T10:42:21Z"}, "message": "OpenMP: Parse align clause in allocate directive in C/C++\n\ngcc/c/ChangeLog:\n\n\t* c-parser.cc (c_parser_omp_allocate): Parse align\n\tclause and check for restrictions.\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_parser_omp_allocate): Parse align\n\tclause and check for restrictions.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/allocate-5.c: Extend for align clause.", "tree": {"sha": "2d0be675cb35393eaeea9f1e769c15fff7d9bf79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d0be675cb35393eaeea9f1e769c15fff7d9bf79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb78a935aa90edb21f3102b310b661e36488abe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb78a935aa90edb21f3102b310b661e36488abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb78a935aa90edb21f3102b310b661e36488abe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb78a935aa90edb21f3102b310b661e36488abe/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae091a44f6a477fbcf463e80fd604540cad3b37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae091a44f6a477fbcf463e80fd604540cad3b37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae091a44f6a477fbcf463e80fd604540cad3b37f"}], "stats": {"total": 221, "additions": 181, "deletions": 40}, "files": [{"sha": "43427886ad41dfbc3075ebdbdfb8f0ad5e8c9453", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb78a935aa90edb21f3102b310b661e36488abe/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb78a935aa90edb21f3102b310b661e36488abe/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=1eb78a935aa90edb21f3102b310b661e36488abe", "patch": "@@ -18814,32 +18814,71 @@ c_parser_oacc_wait (location_t loc, c_parser *parser, char *p_name)\n   return stmt;\n }\n \n-/* OpenMP 5.0:\n-   # pragma omp allocate (list)  [allocator(allocator)]  */\n+/* OpenMP 5.x:\n+   # pragma omp allocate (list)  clauses\n+\n+   OpenMP 5.0 clause:\n+   allocator (omp_allocator_handle_t expression)\n+\n+   OpenMP 5.1 additional clause:\n+   align (constant-expression)]  */\n \n static void\n c_parser_omp_allocate (location_t loc, c_parser *parser)\n {\n+  tree alignment = NULL_TREE;\n   tree allocator = NULL_TREE;\n   tree nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n-  if (c_parser_next_token_is (parser, CPP_COMMA)\n-      && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n-    c_parser_consume_token (parser);\n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  do\n     {\n+      if (c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+      if (!c_parser_next_token_is (parser, CPP_NAME))\n+\tbreak;\n       matching_parens parens;\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       c_parser_consume_token (parser);\n-      if (strcmp (\"allocator\", p) != 0)\n-\terror_at (c_parser_peek_token (parser)->location,\n-\t\t  \"expected %<allocator%>\");\n-      else if (parens.require_open (parser))\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      if (strcmp (\"align\", p) != 0 && strcmp (\"allocator\", p) != 0)\n \t{\n-\t  location_t expr_loc = c_parser_peek_token (parser)->location;\n-\t  c_expr expr = c_parser_expr_no_commas (parser, NULL);\n-\t  expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n-\t  allocator = expr.value;\n-\t  allocator = c_fully_fold (allocator, false, NULL);\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"expected %<allocator%> or %<align%>\");\n+\t  break;\n+\t}\n+      if (!parens.require_open (parser))\n+\tbreak;\n+\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      expr_loc = c_parser_peek_token (parser)->location;\n+      if (p[2] == 'i' && alignment)\n+\t{\n+\t  error_at (expr_loc, \"too many %qs clauses\", \"align\");\n+\t  break;\n+\t}\n+      else if (p[2] == 'i')\n+\t{\n+\t  alignment = c_fully_fold (expr.value, false, NULL);\n+\t  if (TREE_CODE (alignment) != INTEGER_CST\n+\t      || !INTEGRAL_TYPE_P (TREE_TYPE (alignment))\n+\t      || tree_int_cst_sgn (alignment) != 1\n+\t      || !integer_pow2p (alignment))\n+\t    {\n+\t      error_at (expr_loc, \"%<align%> clause argument needs to be \"\n+\t\t\t\t  \"positive constant power of two integer \"\n+\t\t\t\t  \"expression\");\n+\t      alignment = NULL_TREE;\n+\t    }\n+\t}\n+      else if (allocator)\n+\t{\n+\t  error_at (expr_loc, \"too many %qs clauses\", \"allocator\");\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  allocator = c_fully_fold (expr.value, false, NULL);\n \t  tree orig_type\n \t    = expr.original_type ? expr.original_type : TREE_TYPE (allocator);\n \t  orig_type = TYPE_MAIN_VARIANT (orig_type);\n@@ -18848,20 +18887,23 @@ c_parser_omp_allocate (location_t loc, c_parser *parser)\n \t      || TYPE_NAME (orig_type)\n \t\t != get_identifier (\"omp_allocator_handle_t\"))\n \t    {\n-\t      error_at (expr_loc, \"%<allocator%> clause allocator expression \"\n-\t\t\t\t\"has type %qT rather than \"\n-\t\t\t\t\"%<omp_allocator_handle_t%>\",\n-\t\t\t\tTREE_TYPE (allocator));\n+\t      error_at (expr_loc,\n+\t\t\t\"%<allocator%> clause allocator expression has type \"\n+\t\t\t\"%qT rather than %<omp_allocator_handle_t%>\",\n+\t\t\tTREE_TYPE (allocator));\n \t      allocator = NULL_TREE;\n \t    }\n-\t  parens.skip_until_found_close (parser);\n \t}\n-    }\n+      parens.skip_until_found_close (parser);\n+    } while (true);\n   c_parser_skip_to_pragma_eol (parser);\n \n-  if (allocator)\n+  if (allocator || alignment)\n     for (tree c = nl; c != NULL_TREE; c = OMP_CLAUSE_CHAIN (c))\n-      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+      {\n+\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\tOMP_CLAUSE_ALLOCATE_ALIGN (c) = alignment;\n+      }\n \n   sorry_at (loc, \"%<#pragma omp allocate%> not yet supported\");\n }"}, {"sha": "1a124f5395e018f3c4b2f9f36fcd42159d0b868f", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 80, "deletions": 17, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb78a935aa90edb21f3102b310b661e36488abe/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb78a935aa90edb21f3102b310b661e36488abe/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=1eb78a935aa90edb21f3102b310b661e36488abe", "patch": "@@ -41483,43 +41483,106 @@ cp_parser_omp_structured_block (cp_parser *parser, bool *if_p)\n   return finish_omp_structured_block (stmt);\n }\n \n-/* OpenMP 5.0:\n-   # pragma omp allocate (list)  [allocator(allocator)]  */\n+/* OpenMP 5.x:\n+   # pragma omp allocate (list)  clauses\n+\n+   OpenMP 5.0 clause:\n+   allocator (omp_allocator_handle_t expression)\n+\n+   OpenMP 5.1 additional clause:\n+   align (constant-expression)]  */\n \n static void\n cp_parser_omp_allocate (cp_parser *parser, cp_token *pragma_tok)\n {\n   tree allocator = NULL_TREE;\n+  tree alignment = NULL_TREE;\n   location_t loc = pragma_tok->location;\n   tree nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_ALLOCATE, NULL_TREE);\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n-      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n-    cp_lexer_consume_token (parser->lexer);\n-\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  do\n     {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tbreak;\n       matching_parens parens;\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n       location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n       cp_lexer_consume_token (parser->lexer);\n-      if (strcmp (p, \"allocator\") != 0)\n-\terror_at (cloc, \"expected %<allocator%>\");\n-      else if (parens.require_open (parser))\n+      if (strcmp (p, \"allocator\") != 0 && strcmp (p, \"align\") != 0)\n \t{\n-\t  allocator = cp_parser_assignment_expression (parser);\n-\t  if (allocator == error_mark_node)\n-\t    allocator = NULL_TREE;\n-\t  parens.require_close (parser);\n+\t  error_at (cloc, \"expected %<allocator%> or %<align%>\");\n+\t  break;\n \t}\n-    }\n+      if (!parens.require_open (parser))\n+\tbreak;\n+      tree expr = cp_parser_assignment_expression (parser);\n+      if (p[2] == 'i' && alignment)\n+\t{\n+\t  error_at (cloc, \"too many %qs clauses\", \"align\");\n+\t  break;\n+\t}\n+      else if (p[2] == 'i')\n+\t{\n+\t  if (expr != error_mark_node)\n+\t    alignment = expr;\n+\t  /* FIXME: Remove when adding check to semantics.cc; cf FIXME below. */\n+\t  if (alignment\n+\t      && !type_dependent_expression_p (alignment)\n+\t      && !INTEGRAL_TYPE_P (TREE_TYPE (alignment)))\n+\t    {\n+\t      error_at (cloc, \"%<align%> clause argument needs to be \"\n+\t\t\t      \"positive constant power of two integer \"\n+\t\t\t      \"expression\");\n+\t      alignment = NULL_TREE;\n+\t    }\n+\t  else if (alignment)\n+\t    {\n+\t      alignment = mark_rvalue_use (alignment);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  alignment = maybe_constant_value (alignment);\n+\t\t  if (TREE_CODE (alignment) != INTEGER_CST\n+\t\t      || !tree_fits_uhwi_p (alignment)\n+\t\t      || !integer_pow2p (alignment))\n+\t\t    {\n+\t\t      error_at (cloc, \"%<align%> clause argument needs to be \"\n+\t\t\t\t      \"positive constant power of two integer \"\n+\t\t\t\t      \"expression\");\n+\t\t      alignment = NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (allocator)\n+\t{\n+\t  error_at (cloc, \"too many %qs clauses\", \"allocator\");\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  if (expr != error_mark_node)\n+\t    allocator = expr;\n+\t}\n+      parens.require_close (parser);\n+    } while (true);\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n-  if (allocator)\n+  if (allocator || alignment)\n     for (tree c = nl; c != NULL_TREE; c = OMP_CLAUSE_CHAIN (c))\n-      OMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+      {\n+\tOMP_CLAUSE_ALLOCATE_ALLOCATOR (c) = allocator;\n+\tOMP_CLAUSE_ALLOCATE_ALIGN (c) = alignment;\n+      }\n \n+  /* FIXME: When implementing properly, delete the align/allocate expr error\n+     check above and add one in semantics.cc (to properly handle templates).\n+     Base this on the allocator/align modifiers check for the 'allocate' clause\n+     in semantics.cc's finish_omp_clauses.  */\n   sorry_at (loc, \"%<#pragma omp allocate%> not yet supported\");\n }\n "}, {"sha": "8a9181205f711a41eacd441aa6ae468537d588d0", "filename": "gcc/testsuite/c-c++-common/gomp/allocate-5.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb78a935aa90edb21f3102b310b661e36488abe/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb78a935aa90edb21f3102b310b661e36488abe/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fallocate-5.c?ref=1eb78a935aa90edb21f3102b310b661e36488abe", "patch": "@@ -39,3 +39,39 @@ bar ()\n #pragma omp allocate(a) allocator(b)  /* { dg-error \"'allocator' clause allocator expression has type 'int' rather than 'omp_allocator_handle_t'\" \"todo: cp/semantics.c\" { xfail c++ } } */\n   /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n }\n+\n+\n+void\n+align_test ()\n+{\n+  int i;\n+  #pragma omp allocate(i) allocator(omp_default_mem_alloc), align(32)\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp allocate(i) align ( 32 ),allocator(omp_default_mem_alloc)\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp allocate(i),allocator(omp_default_mem_alloc) align(32)\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp allocate(i) align ( 32 ) allocator(omp_default_mem_alloc)\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+\n+  #pragma omp allocate(i) allocator ( omp_high_bw_mem_alloc ), align ( 32 ) allocator(omp_default_mem_alloc)\n+  /* { dg-error \"too many 'allocator' clauses\" \"\" { target *-*-* } .-1 } */\n+  /* { dg-error \"expected end of line before '\\\\)' token\" \"\" { target *-*-* } .-2 } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-3 } */\n+  #pragma omp allocate(i) align ( 32 ), align(32) allocator(omp_default_mem_alloc)\n+  /* { dg-error \"too many 'align' clauses\" \"\" { target *-*-* } .-1 } */\n+  /* { dg-error \"expected end of line before '\\\\)' token\" \"\" { target *-*-* } .-2 } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-3 } */\n+}\n+\n+void\n+align_test2 ()\n+{\n+  int i;\n+  #pragma omp allocate(i) align (32.0)  /* { dg-error \"'align' clause argument needs to be positive constant power of two integer expression\" } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp allocate(i) align ( 31 )  /* { dg-error \"'align' clause argument needs to be positive constant power of two integer expression\" } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp allocate(i) align ( -32 )  /* { dg-error \"'align' clause argument needs to be positive constant power of two integer expression\" } */\n+  /* { dg-message \"sorry, unimplemented: '#pragma omp allocate' not yet supported\" \"\" { target *-*-* } .-1 } */\n+}"}]}