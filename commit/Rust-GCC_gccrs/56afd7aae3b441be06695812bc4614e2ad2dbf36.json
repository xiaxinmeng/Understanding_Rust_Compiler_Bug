{"sha": "56afd7aae3b441be06695812bc4614e2ad2dbf36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZhZmQ3YWFlM2I0NDFiZTA2Njk1ODEyYmM0NjE0ZTJhZDJkYmYzNg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2005-02-11T22:34:57Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2005-02-11T22:34:57Z"}, "message": "target-supports.exp (check_effective_target_broken_cplxf_arg): New.\n\n\t* lib/target-supports.exp (check_effective_target_broken_cplxf_arg):\n\tNew.\n\nFrom-SVN: r94900", "tree": {"sha": "7f4366499c32a699510ea6394cef44cd4f188082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f4366499c32a699510ea6394cef44cd4f188082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56afd7aae3b441be06695812bc4614e2ad2dbf36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56afd7aae3b441be06695812bc4614e2ad2dbf36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56afd7aae3b441be06695812bc4614e2ad2dbf36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56afd7aae3b441be06695812bc4614e2ad2dbf36/comments", "author": null, "committer": null, "parents": [{"sha": "6027770b6e14079e637d8628b4e98ed00e7a9ddb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6027770b6e14079e637d8628b4e98ed00e7a9ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6027770b6e14079e637d8628b4e98ed00e7a9ddb"}], "stats": {"total": 91, "additions": 91, "deletions": 0}, "files": [{"sha": "40c87e2f7c21cbf9b4ff5d8f95f03ba583349003", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56afd7aae3b441be06695812bc4614e2ad2dbf36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56afd7aae3b441be06695812bc4614e2ad2dbf36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56afd7aae3b441be06695812bc4614e2ad2dbf36", "patch": "@@ -1,3 +1,8 @@\n+2005-02-11  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_broken_cplxf_arg):\n+\tNew.\n+\n 2005-02-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/19666"}, {"sha": "f2577c1810639533f49e7787f0a4e304cda374c9", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56afd7aae3b441be06695812bc4614e2ad2dbf36/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56afd7aae3b441be06695812bc4614e2ad2dbf36/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=56afd7aae3b441be06695812bc4614e2ad2dbf36", "patch": "@@ -386,6 +386,92 @@ proc check_vmx_hw_available { } {\n     return $vmx_hw_available_saved\n }\n \n+# GCC 3.4.0 for powerpc64-*-linux* included an ABI fix for passing\n+# complex float arguments.  This affects gfortran tests that call cabsf\n+# in libm built by an earlier compiler.  Return 1 if libm uses the same\n+# argument passing as the compiler under test, 0 otherwise.\n+#\n+# When the target name changes, replace the cached result.\n+\n+proc check_effective_target_broken_cplxf_arg { } {\n+    global et_broken_cplxf_arg_saved\n+    global et_broken_cplxf_arg_target_name\n+    global tool\n+\n+    # Skip the work for targets known not to be affected.\n+    if { ![istarget powerpc64-*-linux*] } {\n+\treturn 0\n+    } elseif { [is-effective-target ilp32] } {\n+\treturn 0\n+    }\n+\n+    if { ![info exists et_broken_cplxf_arg_target_name] } {\n+\tset et_broken_cplxf_arg_target_name \"\"\n+    }\n+\n+    # If the target has changed since we set the cached value, clear it.\n+    set current_target [current_target_name]\n+    if { $current_target != $et_broken_cplxf_arg_target_name } {\n+\tverbose \"check_effective_target_broken_cplxf_arg: `$et_broken_cplxf_arg_target_name'\" 2\n+\tset et_broken_cplxf_arg_target_name $current_target\n+\tif [info exists et_broken_cplxf_arg_saved] {\n+\t    verbose \"check_effective_target_broken_cplxf_arg: removing cached result\" 2\n+\t    unset et_broken_cplxf_arg_saved\n+\t}\n+    }\n+\n+    if [info exists et_broken_cplxf_arg_saved] {\n+\tverbose \"check_effective_target_broken_cplxf_arg: using cached result\" 2\n+    } else {\n+\tset et_broken_cplxf_arg_saved 0\n+\t# This is only known to affect one target.\n+\tif { ![istarget powerpc64-*-linux*] || ![is-effective-target lp64] } {\n+\t    set et_broken_cplxf_arg_saved 0\n+\t    verbose \"check_effective_target_broken_cplxf_arg: caching 0\" 2\n+\t    return $et_broken_cplxf_arg_saved\n+\t}\n+\n+\t# Set up, compile, and execute a C test program that calls cabsf.\n+\tset src cabsf[pid].c\n+\tset exe cabsf[pid].x\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include <complex.h>\"\n+\tputs $f \"extern void abort (void);\"\n+\tputs $f \"float fabsf (float);\"\n+\tputs $f \"float cabsf (_Complex float);\"\n+\tputs $f \"int main ()\"\n+\tputs $f \"{\"\n+\tputs $f \"  _Complex float cf;\"\n+\tputs $f \"  float f;\"\n+\tputs $f \"  cf = 3 + 4.0fi;\"\n+\tputs $f \"  f = cabsf (cf);\"\n+\tputs $f \"  if (fabsf (f - 5.0) > 0.0001) abort ();\"\n+\tputs $f \"  return 0;\"\n+\tputs $f \"}\"\n+\tclose $f\n+\n+\tset lines [${tool}_target_compile $src $exe executable \"-lm\"]\n+\tfile delete $src\n+\n+\tif [string match \"\" $lines] {\n+\t    # No error message, compilation succeeded.\n+\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n+\t    set status [lindex $result 0]\n+\t    remote_file build delete $exe\n+\n+\t    verbose \"check_effective_target_broken_cplxf_arg: status is <$status>\" 2\n+\n+\t    if { $status != \"pass\" } {\n+\t\tset et_broken_cplxf_arg_saved 1\n+\t    }\n+\t} else {\n+\t    verbose \"check_effective_target_broken_cplxf_arg: compilation failed\" 2\n+\t}\n+    }\n+    return $et_broken_cplxf_arg_saved\n+}\n+\n proc check_alpha_max_hw_available { } {\n     global alpha_max_hw_available_saved\n     global tool"}]}