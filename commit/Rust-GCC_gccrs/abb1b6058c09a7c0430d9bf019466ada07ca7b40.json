{"sha": "abb1b6058c09a7c0430d9bf019466ada07ca7b40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJiMWI2MDU4YzA5YTdjMDQzMGQ5YmYwMTk0NjZhZGEwN2NhN2I0MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-01-06T20:44:27Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-01-06T20:44:27Z"}, "message": "PR c++/95768 - pretty-printer ICE on -Wuninitialized with allocated storage\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/95768\n\t* c-pretty-print.c (c_pretty_printer::primary_expression): For\n\tSSA_NAMEs print VLA names and GIMPLE defining statements.\n\t(print_mem_ref): New function.\n\t(c_pretty_printer::unary_expression): Call it.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95768\n\t* error.c (dump_expr): Call c_pretty_printer::unary_expression.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95768\n\t* g++.dg/pr95768.C: New test.\n\t* g++.dg/warn/Wuninitialized-12.C: New test.\n\t* gcc.dg/uninit-38.c: New test.", "tree": {"sha": "e50447a0a440d9d001da20594941715368a26c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e50447a0a440d9d001da20594941715368a26c36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abb1b6058c09a7c0430d9bf019466ada07ca7b40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb1b6058c09a7c0430d9bf019466ada07ca7b40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abb1b6058c09a7c0430d9bf019466ada07ca7b40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb1b6058c09a7c0430d9bf019466ada07ca7b40/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd64f348a6b40621dc2bcc743f5fdfb31ed0894c"}], "stats": {"total": 374, "additions": 324, "deletions": 50}, "files": [{"sha": "e963cf53091628fa27cebfb43e0eda865d58c61e", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 163, "deletions": 24, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=abb1b6058c09a7c0430d9bf019466ada07ca7b40", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"c-pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n #include \"diagnostic.h\"\n #include \"stor-layout.h\"\n #include \"stringpool.h\"\n@@ -1334,6 +1335,34 @@ c_pretty_printer::primary_expression (tree e)\n       pp_c_right_paren (this);\n       break;\n \n+    case SSA_NAME:\n+      if (SSA_NAME_VAR (e))\n+\t{\n+\t  tree var = SSA_NAME_VAR (e);\n+\t  const char *name = IDENTIFIER_POINTER (SSA_NAME_IDENTIFIER (e));\n+\t  const char *dot;\n+\t  if (DECL_ARTIFICIAL (var) && (dot = strchr (name, '.')))\n+\t    {\n+\t      /* Print the name without the . suffix (such as in VLAs).\n+\t\t Use pp_c_identifier so that it can be converted into\n+\t\t the appropriate encoding.  */\n+\t      size_t size = dot - name;\n+\t      char *ident = XALLOCAVEC (char, size + 1);\n+\t      memcpy (ident, name, size);\n+\t      ident[size] = '\\0';\n+\t      pp_c_identifier (this, ident);\n+\t    }\n+\t  else\n+\t    primary_expression (var);\n+\t}\n+      else\n+\t{\n+\t  /* Print only the right side of the GIMPLE assignment.  */\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (e);\n+\t  pp_gimple_stmt_1 (this, def_stmt, 0, TDF_RHS_ONLY);\n+\t}\n+      break;\n+\n     default:\n       /* FIXME:  Make sure we won't get into an infinite loop.  */\n       if (location_wrapper_p (e))\n@@ -1780,6 +1809,139 @@ pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n   pp_c_right_paren (pp);\n }\n \n+/* Print the MEM_REF expression REF, including its type and offset.\n+   Apply casts as necessary if the type of the access is different\n+   from the type of the accessed object.  Produce compact output\n+   designed to include both the element index as well as any\n+   misalignment by preferring\n+     ((int*)((char*)p + 1))[2]\n+   over\n+     *(int*)((char*)p + 9)\n+   The former is more verbose but makes it clearer that the access\n+   to the third element of the array is misaligned by one byte.  */\n+\n+static void\n+print_mem_ref (c_pretty_printer *pp, tree e)\n+{\n+  tree arg = TREE_OPERAND (e, 0);\n+\n+  /* The byte offset.  Initially equal to the MEM_REF offset, then\n+     adjusted to the remainder of the division by the byte size of\n+     the access.  */\n+  offset_int byte_off = wi::to_offset (TREE_OPERAND (e, 1));\n+  /* The result of dividing BYTE_OFF by the size of the access.  */\n+  offset_int elt_idx = 0;\n+  /* True to include a cast to char* (for a nonzero final BYTE_OFF).  */\n+  bool char_cast = false;\n+  const bool addr = TREE_CODE (arg) == ADDR_EXPR;\n+  if (addr)\n+    {\n+      arg = TREE_OPERAND (arg, 0);\n+      if (byte_off == 0)\n+\t{\n+\t  pp->expression (arg);\n+\t  return;\n+\t}\n+    }\n+\n+  const tree access_type = TREE_TYPE (e);\n+  tree arg_type = TREE_TYPE (TREE_TYPE (arg));\n+  if (TREE_CODE (arg_type) == ARRAY_TYPE)\n+    arg_type = TREE_TYPE (arg_type);\n+\n+  if (tree access_size = TYPE_SIZE_UNIT (access_type))\n+    {\n+      /* For naturally aligned accesses print the nonzero offset\n+\t in units of the accessed type, in the form of an index.\n+\t For unaligned accesses also print the residual byte offset.  */\n+      offset_int asize = wi::to_offset (access_size);\n+      offset_int szlg2 = wi::floor_log2 (asize);\n+\n+      elt_idx = byte_off >> szlg2;\n+      byte_off = byte_off - (elt_idx << szlg2);\n+    }\n+\n+  /* True to include a cast to the accessed type.  */\n+  const bool access_cast = VOID_TYPE_P (arg_type)\n+    || !gimple_canonical_types_compatible_p (access_type, arg_type);\n+\n+  if (byte_off != 0)\n+    {\n+      /* When printing the byte offset for a pointer to a type of\n+\t a different size than char, include a cast to char* first,\n+\t before printing the cast to a pointer to the accessed type.  */\n+      tree arg_type = TREE_TYPE (TREE_TYPE (arg));\n+      if (TREE_CODE (arg_type) == ARRAY_TYPE)\n+\targ_type = TREE_TYPE (arg_type);\n+      offset_int arg_size = 0;\n+      if (tree size = TYPE_SIZE (arg_type))\n+\targ_size = wi::to_offset (size);\n+      if (arg_size != BITS_PER_UNIT)\n+\tchar_cast = true;\n+    }\n+\n+  if (elt_idx == 0)\n+    {\n+      if (!addr)\n+\tpp_c_star (pp);\n+    }\n+  else if (access_cast || char_cast)\n+    pp_c_left_paren (pp);\n+\n+  if (access_cast)\n+    {\n+      /* Include a cast to the accessed type if it isn't compatible\n+\t with the type of the referenced object (or if the object\n+\t is typeless).  */\n+      pp_c_left_paren (pp);\n+      pp->type_id (access_type);\n+      pp_c_star (pp);\n+      pp_c_right_paren (pp);\n+    }\n+\n+  if (byte_off != 0)\n+    pp_c_left_paren (pp);\n+\n+  if (char_cast)\n+    {\n+      /* Include a cast to char*.  */\n+      pp_c_left_paren (pp);\n+      pp->type_id (char_type_node);\n+      pp_c_star (pp);\n+      pp_c_right_paren (pp);\n+    }\n+\n+  pp->unary_expression (arg);\n+\n+  if (byte_off != 0)\n+    {\n+      pp_space (pp);\n+      pp_plus (pp);\n+      pp_space (pp);\n+      tree off = wide_int_to_tree (ssizetype, byte_off);\n+      pp->constant (off);\n+      pp_c_right_paren (pp);\n+    }\n+  if (elt_idx != 0)\n+    {\n+      if (byte_off == 0 && char_cast)\n+\tpp_c_right_paren (pp);\n+      pp_c_right_paren (pp);\n+      if (addr)\n+\t{\n+\t  pp_space (pp);\n+\t  pp_plus (pp);\n+\t  pp_space (pp);\n+\t}\n+      else\n+\tpp_c_left_bracket (pp);\n+      tree idx = wide_int_to_tree (ssizetype, elt_idx);\n+      pp->constant (idx);\n+      if (!addr)\n+\tpp_c_right_bracket (pp);\n+    }\n+}\n+\n /* unary-expression:\n       postfix-expression\n       ++ cast-expression\n@@ -1837,30 +1999,7 @@ c_pretty_printer::unary_expression (tree e)\n       break;\n \n     case MEM_REF:\n-      if (TREE_CODE (TREE_OPERAND (e, 0)) == ADDR_EXPR\n-\t  && integer_zerop (TREE_OPERAND (e, 1)))\n-\texpression (TREE_OPERAND (TREE_OPERAND (e, 0), 0));\n-      else\n-\t{\n-\t  pp_c_star (this);\n-\t  if (!integer_zerop (TREE_OPERAND (e, 1)))\n-\t    {\n-\t      pp_c_left_paren (this);\n-\t      tree type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (e, 0)));\n-\t      if (TYPE_SIZE_UNIT (type) == NULL_TREE\n-\t\t  || !integer_onep (TYPE_SIZE_UNIT (type)))\n-\t\tpp_c_type_cast (this, ptr_type_node);\n-\t    }\n-\t  pp_c_cast_expression (this, TREE_OPERAND (e, 0));\n-\t  if (!integer_zerop (TREE_OPERAND (e, 1)))\n-\t    {\n-\t      pp_plus (this);\n-\t      pp_c_integer_constant (this,\n-\t\t\t\t     fold_convert (ssizetype,\n-\t\t\t\t\t\t   TREE_OPERAND (e, 1)));\n-\t      pp_c_right_paren (this);\n-\t    }\n-\t}\n+      print_mem_ref (this, e);\n       break;\n \n     case TARGET_MEM_REF:"}, {"sha": "60f4fd691f33030e900c81511291e38da6a728c1", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=abb1b6058c09a7c0430d9bf019466ada07ca7b40", "patch": "@@ -2417,32 +2417,8 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       break;\n \n     case MEM_REF:\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n-\t  && integer_zerop (TREE_OPERAND (t, 1)))\n-\tdump_expr (pp, TREE_OPERAND (TREE_OPERAND (t, 0), 0), flags);\n-      else\n-\t{\n-\t  pp_cxx_star (pp);\n-\t  if (!integer_zerop (TREE_OPERAND (t, 1)))\n-\t    {\n-\t      pp_cxx_left_paren (pp);\n-\t      if (!integer_onep (TYPE_SIZE_UNIT\n-\t\t\t\t (TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 0))))))\n-\t\t{\n-\t\t  pp_cxx_left_paren (pp);\n-\t\t  dump_type (pp, ptr_type_node, flags);\n-\t\t  pp_cxx_right_paren (pp);\n-\t\t}\n-\t    }\n-\t  dump_expr (pp, TREE_OPERAND (t, 0), flags);\n-\t  if (!integer_zerop (TREE_OPERAND (t, 1)))\n-\t    {\n-\t      pp_cxx_ws_string (pp, \"+\");\n-\t      dump_expr (pp, fold_convert (ssizetype, TREE_OPERAND (t, 1)),\n-                         flags);\n-\t      pp_cxx_right_paren (pp);\n-\t    }\n-\t}\n+      /* Delegate to the base \"C\" pretty printer.  */\n+      pp->c_pretty_printer::unary_expression (t);\n       break;\n \n     case TARGET_MEM_REF:"}, {"sha": "5e2c8c44ad00f0bdf21d56bb15a5a21fdc4e91fe", "filename": "gcc/testsuite/g++.dg/pr95768.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr95768.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr95768.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr95768.C?ref=abb1b6058c09a7c0430d9bf019466ada07ca7b40", "patch": "@@ -0,0 +1,32 @@\n+/* PR c++/95768 - pretty-printer ICE on -Wuninitialized with allocated storage\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+extern \"C\" void *malloc (__SIZE_TYPE__);\n+\n+struct f\n+{\n+  int i;\n+  static int e (int);\n+  void operator= (int) { e (i); }\n+};\n+\n+struct m {\n+  int i;\n+  f length;\n+};\n+\n+struct n {\n+  m *o() { return (m *)this; }\n+};\n+\n+struct p {\n+  n *header;\n+  p () {\n+    header = (n *)malloc (0);\n+    m b = *header->o();       // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+    b.length = 0;\n+  }\n+};\n+\n+void detach2() { p(); }"}, {"sha": "d06aaac71b8db732bb627631c1257f4828c77c45", "filename": "gcc/testsuite/g++.dg/warn/Wuninitialized-12.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuninitialized-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuninitialized-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuninitialized-12.C?ref=abb1b6058c09a7c0430d9bf019466ada07ca7b40", "patch": "@@ -0,0 +1,40 @@\n+/* Verify that -Wuninitialized warnings about accesses to objects via\n+   pointers and offsets mention valid expressions.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+\n+void sink (int);\n+\n+/* Verify properly aligned accesses at offsets that are multiples of\n+   the access size.  */\n+\n+void test_aligned (void)\n+{\n+  char *p1 = (char*)__builtin_malloc (32);\n+  p1 += sizeof (int32_t);\n+\n+  int16_t *p2 = (int16_t*)p1;\n+  sink (p2[1]);               // { dg-warning \"'\\\\(\\\\(int16_t\\\\*\\\\)p1\\\\)\\\\\\[3]' is used uninitialized\" }\n+\n+  int32_t *p4 = (int32_t*)p1;\n+  sink (p4[1]);               // { dg-warning \"'\\\\(\\\\(int32_t\\\\*\\\\)p1\\\\)\\\\\\[2]' is used uninitialized\" }\n+}\n+\n+\n+/* Verify misaligned accesses at offsets that aren't multiples of\n+   the access size.  */\n+\n+void test_misaligned (void)\n+{\n+  char *p1 = (char*)__builtin_malloc (32);\n+  p1 += 1;\n+\n+  int16_t *p2 = (int16_t*)p1;\n+  sink (p2[1]);               // { dg-warning \"'\\\\(\\\\(int16_t\\\\*\\\\)\\\\(p1 \\\\+ 1\\\\)\\\\)\\\\\\[1]' is used uninitialized\" }\n+\n+  int32_t *p4 = (int32_t*)p1;\n+  sink (p4[1]);               // { dg-warning \"'\\\\(\\\\(int32_t\\\\*\\\\)\\\\(p1 \\\\+ 1\\\\)\\\\)\\\\\\[1]' is used uninitialized\" }\n+}"}, {"sha": "ebf11174af091626990fe32198a443b41de6d135", "filename": "gcc/testsuite/gcc.dg/uninit-38.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abb1b6058c09a7c0430d9bf019466ada07ca7b40/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c?ref=abb1b6058c09a7c0430d9bf019466ada07ca7b40", "patch": "@@ -0,0 +1,87 @@\n+/* Verify that dereferencing uninitialized allocated objects and VLAs\n+   correctly reflects offsets into the objects.\n+   The test's main purpose is to exercise the formatting of MEM_REFs.\n+   If -Wuninitialized gets smarter and detects uninitialized accesses\n+   before they're turned into MEM_REFs the test will likely need to\n+   be adjusted.  Ditto if -Wuninitialized output changes for some\n+   other reason.\n+   { dg-do compile { target { { lp64 || ilp32 } || llp64 } } }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#define CONCAT(x, y)   x ## y\n+#define CAT(x, y)      CONCAT(x, y)\n+#define UNIQ(name)     CAT (name, __LINE__)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* malloc (size_t);\n+\n+void sink (void*, ...);\n+\n+#undef T\n+#define T(Type, idx, off)\t\t\t\\\n+  __attribute__ ((noipa))\t\t\t\\\n+  void UNIQ (test_)(int n)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    void *p = malloc (n);\t\t\t\\\n+    Type *q = (Type*)((char*)p + off);\t\t\\\n+    sink (p, q[idx]);\t\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+  typedef void dummy_type\n+\n+T (int, 0, 0);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)p' is used uninitialized\" }\n+T (int, 0, 1);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)'\" }\n+T (int, 0, 2);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)'\" }\n+T (int, 0, 3);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)'\" }\n+T (int, 0, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[1]'\" }\n+T (int, 0, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[2]'\" }\n+T (int, 0, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+\n+\n+T (int, 1, 0);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[1]' is used uninitialized\" }\n+T (int, 1, 1);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 2);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 3);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[2]'\" }\n+T (int, 1, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[3]'\" }\n+T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[3]'\" }\n+\n+#undef T\n+#define T(Type, idx, off)\t\t\t\\\n+  __attribute__ ((noipa))\t\t\t\\\n+  void UNIQ (test_)(int n)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    char a[n], *p = a;\t\t\t\t\\\n+    Type *q = (Type*)((char*)p + off);\t\t\\\n+    sink (p, q[idx]);\t\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+  typedef void dummy_type\n+\n+T (int, 0, 0);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)a' is used uninitialized\" }\n+T (int, 0, 1);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)'\" }\n+T (int, 0, 2);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)'\" }\n+T (int, 0, 3);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)'\" }\n+T (int, 0, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[1]'\" }\n+T (int, 0, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[2]'\" }\n+T (int, 0, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+\n+\n+T (int, 1, 0);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[1]' is used uninitialized\" }\n+T (int, 1, 1);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 2);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 3);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[2]'\" }\n+T (int, 1, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[3]'\" }\n+T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[3]'\" }"}]}