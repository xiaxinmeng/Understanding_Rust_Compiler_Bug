{"sha": "9436b221f28cf1907d35e5b7e03ef8a527379f5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQzNmIyMjFmMjhjZjE5MDdkMzVlNWI3ZTAzZWY4YTUyNzM3OWY1ZQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-02-12T15:46:14Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-02-12T15:46:14Z"}, "message": "re PR fortran/50981 ([OOP] Wrong-code for scalarizing ELEMENTAL call with absent OPTIONAL argument)\n\ngcc/fortran/\n\tPR fortran/50981\n\t* trans-stmt.c (gfc_get_proc_ifc_for_call): New function.\n\t(gfc_trans_call): Use gfc_get_proc_ifc_for_call.\n\ngcc/testsuite/\n\tPR fortran/50981\n\t* gfortran.dg/elemental_optional_args_5.f03: New test.\n\nFrom-SVN: r184142", "tree": {"sha": "c1cb93e2a76a420c680b028bbe93cbcd49005b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1cb93e2a76a420c680b028bbe93cbcd49005b9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9436b221f28cf1907d35e5b7e03ef8a527379f5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9436b221f28cf1907d35e5b7e03ef8a527379f5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9436b221f28cf1907d35e5b7e03ef8a527379f5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9436b221f28cf1907d35e5b7e03ef8a527379f5e/comments", "author": null, "committer": null, "parents": [{"sha": "dec131b6add752c0d71cb6720de4ab154bf72411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec131b6add752c0d71cb6720de4ab154bf72411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec131b6add752c0d71cb6720de4ab154bf72411"}], "stats": {"total": 122, "additions": 120, "deletions": 2}, "files": [{"sha": "defca3f3512b1009d540d692a3a6425c3073255b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9436b221f28cf1907d35e5b7e03ef8a527379f5e", "patch": "@@ -1,3 +1,9 @@\n+2012-02-12  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/50981\n+\t* trans-stmt.c (gfc_get_proc_ifc_for_call): New function.\n+\t(gfc_trans_call): Use gfc_get_proc_ifc_for_call.\n+\n 2012-02-12  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (gfc_walk_elemental_function_args,"}, {"sha": "bb3a89084e03ae6f6ae045540d4fad50326b2946", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=9436b221f28cf1907d35e5b7e03ef8a527379f5e", "patch": "@@ -348,6 +348,27 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n }\n \n \n+/* Get the interface symbol for the procedure corresponding to the given call.\n+   We can't get the procedure symbol directly as we have to handle the case\n+   of (deferred) type-bound procedures.  */\n+\n+static gfc_symbol *\n+get_proc_ifc_for_call (gfc_code *c)\n+{\n+  gfc_symbol *sym;\n+\n+  gcc_assert (c->op == EXEC_ASSIGN_CALL || c->op == EXEC_CALL);\n+\n+  sym = gfc_get_proc_ifc_for_expr (c->expr1);\n+\n+  /* Fall back/last resort try.  */\n+  if (sym == NULL)\n+    sym = c->resolved_sym;\n+\n+  return sym;\n+}\n+\n+\n /* Translate the CALL statement.  Builds a call to an F95 subroutine.  */\n \n tree\n@@ -372,7 +393,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n   ss = gfc_ss_terminator;\n   if (code->resolved_sym->attr.elemental)\n     ss = gfc_walk_elemental_function_args (ss, code->ext.actual,\n-\t\t\t\t\t   gfc_get_proc_ifc_for_expr (code->expr1),\n+\t\t\t\t\t   get_proc_ifc_for_call (code),\n \t\t\t\t\t   GFC_SS_REFERENCE);\n \n   /* Is not an elemental subroutine call with array valued arguments.  */"}, {"sha": "66abdd03564b2cc079441d17b0677f8a03a8e64a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9436b221f28cf1907d35e5b7e03ef8a527379f5e", "patch": "@@ -1,4 +1,9 @@\n-2012-02012 Iain Sandoe  <iains@gcc.gnu.org>\n+2012-02-12  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/50981\n+\t* gfortran.dg/elemental_optional_args_5.f03: New test.\n+\n+2012-02-12 Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR testsuite/50076\n \t* c-c++-common/cxxbitfields-3.c: Adjust scan assembler for nonpic"}, {"sha": "70a27d80cdee139ae8d8b43698e97b3ea4dd1f26", "filename": "gcc/testsuite/gfortran.dg/elemental_optional_args_5.f03", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9436b221f28cf1907d35e5b7e03ef8a527379f5e/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03?ref=9436b221f28cf1907d35e5b7e03ef8a527379f5e", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+!\n+! PR fortran/50981\n+! Test the handling of optional, polymorphic and non-polymorphic arguments\n+! to elemental procedures. \n+!\n+! Original testcase by Tobias Burnus <burnus@net-b.de>\n+\n+implicit none\n+type t\n+  integer :: a\n+end type t\n+\n+type t2\n+  integer, allocatable :: a\n+  integer, allocatable :: a2(:)\n+  integer, pointer :: p => null()\n+  integer, pointer :: p2(:) => null()\n+end type t2\n+\n+type(t), allocatable :: ta, taa(:)\n+type(t), pointer :: tp, tpa(:)\n+class(t), allocatable :: ca, caa(:)\n+class(t), pointer :: cp, cpa(:)\n+\n+type(t2) :: x\n+\n+integer :: s, v(2)\n+\n+tp => null()\n+tpa => null()\n+cp => null()\n+cpa => null()\n+\n+! =============== sub1 ==================\n+! SCALAR COMPONENTS: Non alloc/assoc\n+\n+s = 3\n+v = [9, 33]\n+\n+call sub1 (s, x%a, .false.)\n+call sub1 (v, x%a, .false.)\n+!print *, s, v\n+if (s /= 3) call abort()\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub1 (s, x%p, .false.)\n+call sub1 (v, x%p, .false.)\n+!print *, s, v\n+if (s /= 3) call abort()\n+if (any (v /= [9, 33])) call abort()\n+\n+\n+! SCALAR COMPONENTS: alloc/assoc\n+\n+allocate (x%a, x%p)\n+x%a = 4\n+x%p = 5\n+call sub1 (s, x%a, .true.)\n+call sub1 (v, x%a, .true.)\n+!print *, s, v\n+if (s /= 4*2) call abort()\n+if (any (v /= [4*2, 4*2])) call abort()\n+\n+call sub1 (s, x%p, .true.)\n+call sub1 (v, x%p, .true.)\n+!print *, s, v\n+if (s /= 5*2) call abort()\n+if (any (v /= [5*2, 5*2])) call abort()\n+\n+\n+\n+contains\n+\n+  elemental subroutine sub1 (x, y, alloc)\n+    integer, intent(inout) :: x\n+    integer, intent(in), optional :: y\n+    logical, intent(in) :: alloc\n+    if (alloc .neqv. present (y)) &\n+      x = -99\n+    if (present(y)) &\n+      x = y*2\n+  end subroutine sub1\n+\n+end\n+"}]}