{"sha": "fb2660307dc8c9417390e2c6810cf2ed3a13635c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIyNjYwMzA3ZGM4Yzk0MTczOTBlMmM2ODEwY2YyZWQzYTEzNjM1Yw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-12-08T13:34:05Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-12-08T13:34:05Z"}, "message": "(temp_names): New variable.\n\n\t(do_spec_1): Rewrite MKTEMP_EACH_FILE for %g/%u/%U.\n\t(choose_temp_base): Abort if mktemp yields a null string.\n\nFrom-SVN: r2847", "tree": {"sha": "75c8cee72e0144f1c58a18d2f678753f74721209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75c8cee72e0144f1c58a18d2f678753f74721209"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb2660307dc8c9417390e2c6810cf2ed3a13635c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2660307dc8c9417390e2c6810cf2ed3a13635c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb2660307dc8c9417390e2c6810cf2ed3a13635c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2660307dc8c9417390e2c6810cf2ed3a13635c/comments", "author": null, "committer": null, "parents": [{"sha": "164c8956a0bc23d8bfc8532baa32b9a8b1adc08e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164c8956a0bc23d8bfc8532baa32b9a8b1adc08e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/164c8956a0bc23d8bfc8532baa32b9a8b1adc08e"}], "stats": {"total": 56, "additions": 48, "deletions": 8}, "files": [{"sha": "80d3eddc2a36b7afcb04d824be8fd6d5afd77831", "filename": "gcc/gcc.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb2660307dc8c9417390e2c6810cf2ed3a13635c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb2660307dc8c9417390e2c6810cf2ed3a13635c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=fb2660307dc8c9417390e2c6810cf2ed3a13635c", "patch": "@@ -836,6 +836,18 @@ static int argbuf_length;\n \n static int argbuf_index;\n \n+/* This is the list of suffixes and codes (%g/%u/%U) and the associated\n+   temp file.  Used only if MKTEMP_EACH_FILE.  */\n+\n+static struct temp_name {\n+  char *suffix;\t\t/* suffix associated with the code.  */\n+  int length;\t\t/* strlen (suffix).  */\n+  int unique;\t\t/* Indicates whether %g or %u/%U was used.  */\n+  char *filename;\t/* associated filename.  */\n+  int filename_length;\t/* strlen (filename).  */\n+  struct temp_name *next;\n+} *temp_names;\n+\n /* Number of commands executed so far.  */\n \n static int execution_count;\n@@ -1130,6 +1142,8 @@ choose_temp_base ()\n \n   mktemp (temp_filename);\n   temp_filename_length = strlen (temp_filename);\n+  if (temp_filename_length == 0)\n+    abort ();\n }\n \f\n \n@@ -2545,16 +2559,42 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      obstack_grow (&obstack, input_basename, basename_length);\n \t    else\n \t      {\n-#ifdef MKTEMP_EACH_FILE /* ??? This has a problem: the total number of\n-\t\t\t   values mktemp can return is limited.\n-\t\t\t   That matters for the names of object files.\n-\t\t\t   In 2.4, do something about that.  */\n-\t\t/* Choose a new temp_filename, but get rid of the\n-\t\t   suffix that the spec wants to add to it.  */\n-\t\tchoose_temp_base ();\n+#ifdef MKTEMP_EACH_FILE\n+\t\t/* ??? This has a problem: the total number of\n+\t\t   values mktemp can return is limited.\n+\t\t   That matters for the names of object files.\n+\t\t   In 2.4, do something about that.  */\n+\t\tstruct temp_name *t;\n+\t\tchar *suffix = p;\n \t\twhile (*p == '.' || isalpha (*p))\n \t\t  p++;\n-\t\tobstack_grow (&obstack, temp_filename, temp_filename_length);\n+\n+\t\t/* See if we already have an association of %g/%u/%U and\n+\t\t   suffix.  */\n+\t\tfor (t = temp_names; t; t = t->next)\n+\t\t  if (t->length == p - suffix\n+\t\t      && strncmp (t->suffix, suffix, p - suffix) == 0\n+\t\t      && t->unique == (c != 'g'))\n+\t\t    break;\n+\n+\t\t/* Make a new association if needed.  %u requires one.  */\n+\t\tif (t == 0 || c == 'u')\n+\t\t  {\n+\t\t    if (t == 0)\n+\t\t      {\n+\t\t\tt = (struct temp_name *) xmalloc (sizeof (struct temp_name));\n+\t\t\tt->next = temp_names;\n+\t\t\ttemp_names = t;\n+\t\t      }\n+\t\t    t->length = p - suffix;\n+\t\t    t->suffix = save_string (suffix, p - suffix);\n+\t\t    t->unique = (c != 'g');\n+\t\t    choose_temp_base ();\n+\t\t    t->filename = temp_filename;\n+\t\t    t->filename_length = temp_filename_length;\n+\t\t  }\n+\n+\t\tobstack_grow (&obstack, t->filename, t->filename_length);\n \t\tdelete_this_arg = 1;\n #else\n \t\tobstack_grow (&obstack, temp_filename, temp_filename_length);"}]}