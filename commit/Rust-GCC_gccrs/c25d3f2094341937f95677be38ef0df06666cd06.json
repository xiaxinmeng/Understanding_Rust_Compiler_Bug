{"sha": "c25d3f2094341937f95677be38ef0df06666cd06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1ZDNmMjA5NDM0MTkzN2Y5NTY3N2JlMzhlZjBkZjA2NjY2Y2QwNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-10-20T20:14:46Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-10-20T20:14:46Z"}, "message": "(VARARGS_STDARG_FUNCTION): New macro.\n\n(i960_function_name_declare, output_function_profiler,\ni960_function_epilogue, i960_output_call_insn,  i960_output_ret_insn,\ni960_reg_parm_stack_space): Use it.\n(compute_frame_size): Don't use current_function_pretend_args_size.\n(i960_function_arg_advance, i960_function_arg): Don't use parameter\nnamed.\n(i960_setup_incoming_varargs): No need to adjust first_reg_offset\nafter setting it.  Don't save last named argument to stack.\nDon't set pretend_size.\n\nFrom-SVN: r8322", "tree": {"sha": "174a5d25762bab679ed9c67bfd8604a82e4057a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/174a5d25762bab679ed9c67bfd8604a82e4057a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c25d3f2094341937f95677be38ef0df06666cd06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25d3f2094341937f95677be38ef0df06666cd06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25d3f2094341937f95677be38ef0df06666cd06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25d3f2094341937f95677be38ef0df06666cd06/comments", "author": null, "committer": null, "parents": [{"sha": "0f1d97b8f6692d3e798f9f52759c7e8a3fe40c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1d97b8f6692d3e798f9f52759c7e8a3fe40c01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1d97b8f6692d3e798f9f52759c7e8a3fe40c01"}], "stats": {"total": 70, "additions": 45, "deletions": 25}, "files": [{"sha": "a0ac218edf238a6c2414988c7bc471ade12af773", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25d3f2094341937f95677be38ef0df06666cd06/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25d3f2094341937f95677be38ef0df06666cd06/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=c25d3f2094341937f95677be38ef0df06666cd06", "patch": "@@ -75,6 +75,14 @@ char epilogue_string[1000];\n \n static int ret_label = 0;\n \n+/* This is true if FNDECL is either a varargs or a stdarg function.\n+   This is used to help identify functions that use an argument block.  */\n+\n+#define VARARGS_STDARG_FUNCTION(FNDECL)\t\\\n+((TYPE_ARG_TYPES (TREE_TYPE (FNDECL)) != 0\t\t\t\t\t\t      \\\n+  && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (FNDECL)))) != void_type_node))    \\\n+ || current_function_varargs)\n+\n #if 0\n /* Handle pragmas for compatibility with Intel's compilers.  */\n \n@@ -823,7 +831,7 @@ i960_function_name_declare (file, name, fndecl)\n   /* Even if nobody uses extra parms, can't have leafroc or tail calls if\n      argblock, because argblock uses g14 implicitly.  */\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))\n     {\n       tail_call_ok = 0;\n       leaf_proc_ok = 0;\n@@ -960,8 +968,7 @@ compute_frame_size (size)\n      int size;\n {\n   int actual_fsize;\n-  int outgoing_args_size\n-    = current_function_outgoing_args_size + current_function_pretend_args_size;\n+  int outgoing_args_size = current_function_outgoing_args_size;\n \n   /* The STARTING_FRAME_OFFSET is totally hidden to us as far\n      as size is concerned.  */\n@@ -1158,6 +1165,8 @@ output_function_profiler (file, labelno)\n   /* The last used parameter register.  */\n   int last_parm_reg;\n   int i, j, increment;\n+  int varargs_stdarg_function\n+    = VARARGS_STDARG_FUNCTION (current_function_decl);\n \n   /* Figure out the last used parameter register.  The proper thing to do\n      is to walk incoming args of the function.  A function might have live\n@@ -1194,7 +1203,7 @@ output_function_profiler (file, labelno)\n   /* If this function uses the arg pointer, then save it in r3 and then\n      set it to zero.  */\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0 || varargs_stdarg_function)\n     fprintf (file, \"\\tmov\tg14,r3\\n\\tmov\t0,g14\\n\");\n \n   /* Load location address into g0 and call mcount.  */\n@@ -1203,7 +1212,7 @@ output_function_profiler (file, labelno)\n \n   /* If this function uses the arg pointer, restore it.  */\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0 || varargs_stdarg_function)\n     fprintf (file, \"\\tmov\tr3,g14\\n\");\n \n   /* Restore parameter registers.  */\n@@ -1280,7 +1289,8 @@ i960_function_epilogue (file, size)\n \n   /* Must clear g14 on return.  */\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0\n+      || VARARGS_STDARG_FUNCTION (current_function_decl))\n     fprintf (file, \"\\tmov\t0,g14\\n\");\n \n   fprintf (file, \"\\tret\\n\");\n@@ -1296,16 +1306,18 @@ i960_output_call_insn (target, argsize_rtx, arg_pointer, insn)\n   int argsize = INTVAL (argsize_rtx);\n   rtx nexti = next_real_insn (insn);\n   rtx operands[2];\n+  int varargs_stdarg_function\n+    = VARARGS_STDARG_FUNCTION (current_function_decl);\n \n   operands[0] = target;\n   operands[1] = arg_pointer;\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0 || varargs_stdarg_function)\n     output_asm_insn (\"mov\tg14,r3\", operands);\n \n   if (argsize > 48)\n     output_asm_insn (\"lda\t%a1,g14\", operands);\n-  else if (current_function_args_size != 0)\n+  else if (current_function_args_size != 0 || varargs_stdarg_function)\n     output_asm_insn (\"mov\t0,g14\", operands);\n \n   /* The code used to assume that calls to SYMBOL_REFs could not be more\n@@ -1326,7 +1338,7 @@ i960_output_call_insn (target, argsize_rtx, arg_pointer, insn)\n \n   output_asm_insn (\"callx\t%0\", operands);\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0 || varargs_stdarg_function)\n     output_asm_insn (\"mov\tr3,g14\", operands);\n \n   return \"\";\n@@ -1349,7 +1361,8 @@ i960_output_ret_insn (insn)\n       return lbuf;\n     }\n \n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0\n+      || VARARGS_STDARG_FUNCTION (current_function_decl))\n     output_asm_insn (\"mov\t0,g14\", 0);\n \n   if (i960_leaf_ret_reg >= 0)\n@@ -2045,7 +2058,7 @@ i960_function_arg_advance (cum, mode, type, named)\n \n   i960_arg_size_and_align (mode, type, &size, &align);\n \n-  if (named == 0 || size > 4 || cum->ca_nstackparms != 0\n+  if (size > 4 || cum->ca_nstackparms != 0\n       || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n       || MUST_PASS_IN_STACK (mode, type))\n     cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align) + size;\n@@ -2068,7 +2081,7 @@ i960_function_arg (cum, mode, type, named)\n \n   i960_arg_size_and_align (mode, type, &size, &align);\n \n-  if (named == 0 || size > 4 || cum->ca_nstackparms != 0\n+  if (size > 4 || cum->ca_nstackparms != 0\n       || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n       || MUST_PASS_IN_STACK (mode, type))\n     {\n@@ -2184,14 +2197,17 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n     {\n       int first_reg_offset = cum->ca_nregparms;\n \n-      if (first_reg_offset > NPARM_REGS)\n-\tfirst_reg_offset = NPARM_REGS;\n-\n-      if (! (no_rtl) && first_reg_offset != NPARM_REGS)\n+      if (! (no_rtl))\n \t{\n \t  rtx label = gen_label_rtx ();\n \t  rtx regblock;\n \n+\t  /* If arg_pointer_rtx == 0, no arguments were passed on the stack\n+\t     and we need to allocate a chunk to save the registers (if any\n+\t     arguments were passed on the stack the caller would allocate the\n+\t     48 bytes as well).  We must allocate all 48 bytes (12*4) because\n+\t     arg_pointer_rtx is saved at the front, the anonymous args are\n+\t     saved at the end.  */\n \t  emit_insn (gen_cmpsi (arg_pointer_rtx, const0_rtx));\n \t  emit_jump_insn (gen_bne (label));\n \t  emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n@@ -2202,15 +2218,19 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \t\t\t\t\t\t\t     48))));\n \t  emit_label (label);\n \n-\t  regblock = gen_rtx (MEM, BLKmode,\n-\t\t\t      plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t     first_reg_offset * 4));\n-\t  move_block_from_reg (first_reg_offset, regblock,\n-\t\t\t       NPARM_REGS - first_reg_offset,\n-\t\t\t       ((NPARM_REGS - first_reg_offset)\n-\t\t\t\t* UNITS_PER_WORD));\n+\t  /* Any anonymous args passed in regs?  */\n+\t  if (first_reg_offset + 1 < NPARM_REGS)\n+\t    {\n+\t      rtx regblock;\n+\t      regblock = gen_rtx (MEM, BLKmode,\n+\t\t\t\t  plus_constant (arg_pointer_rtx,\n+\t\t\t\t\t\t (first_reg_offset + 1) * 4));\n+\t      move_block_from_reg (first_reg_offset + 1, regblock,\n+\t\t\t\t   NPARM_REGS - first_reg_offset - 1,\n+\t\t\t\t   ((NPARM_REGS - first_reg_offset - 1)\n+\t\t\t\t    * UNITS_PER_WORD));\n+\t    }\n \t}\n-      *pretend_size = (NPARM_REGS - first_reg_offset) * UNITS_PER_WORD;\n     }\n }\n \n@@ -2247,7 +2267,7 @@ i960_reg_parm_stack_space (fndecl)\n \n   /* Otherwise, we have an arg block if the current function has more than\n      48 bytes of parameters.  */\n-  if (current_function_args_size != 0)\n+  if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))\n     return 48;\n   else\n     return 0;"}]}