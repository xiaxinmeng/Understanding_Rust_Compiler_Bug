{"sha": "ab49538861468caa8bb7d1cd6df050e614ffab1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI0OTUzODg2MTQ2OGNhYThiYjdkMWNkNmRmMDUwZTYxNGZmYWIxYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-07T19:46:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-07T19:46:10Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1503", "tree": {"sha": "376ec1ecb36fc0062c8af01345bec0a9d96854f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/376ec1ecb36fc0062c8af01345bec0a9d96854f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab49538861468caa8bb7d1cd6df050e614ffab1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab49538861468caa8bb7d1cd6df050e614ffab1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab49538861468caa8bb7d1cd6df050e614ffab1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab49538861468caa8bb7d1cd6df050e614ffab1c/comments", "author": null, "committer": null, "parents": [{"sha": "1814cfd91d7e9c41488b4c91fcae825eca391729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1814cfd91d7e9c41488b4c91fcae825eca391729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1814cfd91d7e9c41488b4c91fcae825eca391729"}], "stats": {"total": 467, "additions": 288, "deletions": 179}, "files": [{"sha": "8e9ed05875bf00883bff879e8d8582b7ca017496", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 288, "deletions": 179, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab49538861468caa8bb7d1cd6df050e614ffab1c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab49538861468caa8bb7d1cd6df050e614ffab1c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=ab49538861468caa8bb7d1cd6df050e614ffab1c", "patch": "@@ -38,215 +38,239 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef abort\n #endif\n \n-/* Need to undef this because LONG_TYPE_SIZE may rely upon GCC's\n-   internal `target_flags' variable.  */\n-#undef LONG_TYPE_SIZE\n-\n-#define LONG_TYPE_SIZE (sizeof (long) * BITS_PER_UNIT)\n-\n-#ifndef SItype\n-#define SItype long int\n-#endif\n-\n-/* long long ints are pairs of long ints in the order determined by\n+/* In the first part of this file, we are interfacing to calls generated\n+   by the compiler itself.  These calls pass values into these routines\n+   which have very specific modes (rather than very specific types), and\n+   these compiler-generated calls also expect any return values to have\n+   very specific modes (rather than very specific types).  Thus, we need\n+   to avoid using regular C language type names in this part of the file\n+   because the sizes for those types can be configured to be anything.\n+   Instead we use the following special type names.  */\n+\n+typedef unsigned int UQItype\t__attribute__ ((mode (QI)));\n+typedef \t int SItype\t__attribute__ ((mode (SI)));\n+typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n+typedef\t\t int DItype\t__attribute__ ((mode (DI)));\n+typedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n+typedef \tfloat SFtype\t__attribute__ ((mode (SF)));\n+typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n+typedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n+typedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n+\n+/* Make sure that we don't accidentaly use any normal C language built-in\n+   type names in the first part of this file.  Instead we want to use *only*\n+   the type names defined above.  The following macro definitions insure\n+   that if we *do* accidently use soem normal C language built-in type name,\n+   we will get a syntax error.  */\n+\n+#define char bogus_type\n+#define short bogus_type\n+#define int bogus_type\n+#define long bogus_type\n+#define unsigned bogus_type\n+#define float bogus_type\n+#define double bogus_type\n+\n+#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+\n+/* DIstructs are pairs of SItype values in the order determined by\n    WORDS_BIG_ENDIAN.  */\n \n #if WORDS_BIG_ENDIAN\n-  struct longlong {long high, low;};\n+  struct DIstruct {SItype high, low;};\n #else\n-  struct longlong {long low, high;};\n+  struct DIstruct {SItype low, high;};\n #endif\n \n-/* We need this union to unpack/pack longlongs, since we don't have\n-   any arithmetic yet.  Incoming long long parameters are stored\n-   into the `ll' field, and the unpacked result is read from the struct\n-   longlong.  */\n+/* We need this union to unpack/pack DImode values, since we don't have\n+   any arithmetic yet.  Incoming DImode parameters are stored into the\n+   `ll' field, and the unpacked result is read from the struct `s'.  */\n \n typedef union\n {\n-  struct longlong s;\n-  long long ll;\n-} long_long;\n+  struct DIstruct s;\n+  DItype ll;\n+} DIunion;\n \n #if defined (L_udivmoddi4) || defined (L_muldi3)\n \n #include \"longlong.h\"\n \n #endif /* udiv or mul */\n \n-extern long long __fixunssfdi (float a);\n-extern long long __fixunsdfdi (double a);\n+extern DItype __fixunssfdi (SFtype a);\n+extern DItype __fixunsdfdi (DFtype a);\n \f\n #if defined (L_negdi2) || defined (L_divdi3) || defined (L_moddi3)\n #if defined (L_divdi3) || defined (L_moddi3)\n static inline\n #endif\n-long long\n+DItype\n __negdi2 (u)\n-     long long u;\n+     DItype u;\n {\n-  long_long w;\n-  long_long uu;\n+  DIunion w;\n+  DIunion uu;\n \n   uu.ll = u;\n \n   w.s.low = -uu.s.low;\n-  w.s.high = -uu.s.high - ((unsigned long) w.s.low > 0);\n+  w.s.high = -uu.s.high - ((USItype) w.s.low > 0);\n \n   return w.ll;\n }\n #endif\n \f\n #ifdef L_lshldi3\n-long long\n+DItype\n __lshldi3 (u, b)\n-     long long u;\n-     int b;\n+     DItype u;\n+     SItype b;\n {\n-  long_long w;\n-  long bm;\n-  long_long uu;\n+  DIunion w;\n+  SItype bm;\n+  DIunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.low = 0;\n-      w.s.high = (unsigned long)uu.s.low << -bm;\n+      w.s.high = (USItype)uu.s.low << -bm;\n     }\n   else\n     {\n-      unsigned long carries = (unsigned long)uu.s.low >> bm;\n-      w.s.low = (unsigned long)uu.s.low << b;\n-      w.s.high = ((unsigned long)uu.s.high << b) | carries;\n+      USItype carries = (USItype)uu.s.low >> bm;\n+      w.s.low = (USItype)uu.s.low << b;\n+      w.s.high = ((USItype)uu.s.high << b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \n #ifdef L_lshrdi3\n-long long\n+DItype\n __lshrdi3 (u, b)\n-     long long u;\n-     int b;\n+     DItype u;\n+     SItype b;\n {\n-  long_long w;\n-  long bm;\n-  long_long uu;\n+  DIunion w;\n+  SItype bm;\n+  DIunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.high = 0;\n-      w.s.low = (unsigned long)uu.s.high >> -bm;\n+      w.s.low = (USItype)uu.s.high >> -bm;\n     }\n   else\n     {\n-      unsigned long carries = (unsigned long)uu.s.high << bm;\n-      w.s.high = (unsigned long)uu.s.high >> b;\n-      w.s.low = ((unsigned long)uu.s.low >> b) | carries;\n+      USItype carries = (USItype)uu.s.high << bm;\n+      w.s.high = (USItype)uu.s.high >> b;\n+      w.s.low = ((USItype)uu.s.low >> b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \n #ifdef L_ashldi3\n-long long\n+DItype\n __ashldi3 (u, b)\n-     long long u;\n-     int b;\n+     DItype u;\n+     SItype b;\n {\n-  long_long w;\n-  long bm;\n-  long_long uu;\n+  DIunion w;\n+  SItype bm;\n+  DIunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       w.s.low = 0;\n-      w.s.high = (unsigned long)uu.s.low << -bm;\n+      w.s.high = (USItype)uu.s.low << -bm;\n     }\n   else\n     {\n-      unsigned long carries = (unsigned long)uu.s.low >> bm;\n-      w.s.low = (unsigned long)uu.s.low << b;\n-      w.s.high = ((unsigned long)uu.s.high << b) | carries;\n+      USItype carries = (USItype)uu.s.low >> bm;\n+      w.s.low = (USItype)uu.s.low << b;\n+      w.s.high = ((USItype)uu.s.high << b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \n #ifdef L_ashrdi3\n-long long\n+DItype\n __ashrdi3 (u, b)\n-     long long u;\n-     int b;\n+     DItype u;\n+     SItype b;\n {\n-  long_long w;\n-  long bm;\n-  long_long uu;\n+  DIunion w;\n+  SItype bm;\n+  DIunion uu;\n \n   if (b == 0)\n     return u;\n \n   uu.ll = u;\n \n-  bm = (sizeof (long) * BITS_PER_UNIT) - b;\n+  bm = (sizeof (SItype) * BITS_PER_UNIT) - b;\n   if (bm <= 0)\n     {\n       /* w.s.high = 1..1 or 0..0 */\n-      w.s.high = uu.s.high >> (sizeof (long) * BITS_PER_UNIT - 1);\n+      w.s.high = uu.s.high >> (sizeof (SItype) * BITS_PER_UNIT - 1);\n       w.s.low = uu.s.high >> -bm;\n     }\n   else\n     {\n-      unsigned long carries = (unsigned long)uu.s.high << bm;\n+      USItype carries = (USItype)uu.s.high << bm;\n       w.s.high = uu.s.high >> b;\n-      w.s.low = ((unsigned long)uu.s.low >> b) | carries;\n+      w.s.low = ((USItype)uu.s.low >> b) | carries;\n     }\n \n   return w.ll;\n }\n #endif\n \f\n #ifdef L_muldi3\n-long long\n+DItype\n __muldi3 (u, v)\n-     long long u, v;\n+     DItype u, v;\n {\n-  long_long w;\n-  long_long uu, vv;\n+  DIunion w;\n+  DIunion uu, vv;\n \n   uu.ll = u,\n   vv.ll = v;\n \n   w.ll = __umulsidi3 (uu.s.low, vv.s.low);\n-  w.s.high += ((unsigned long) uu.s.low * (unsigned long) vv.s.high\n-\t       + (unsigned long) uu.s.high * (unsigned long) vv.s.low);\n+  w.s.high += ((USItype) uu.s.low * (USItype) vv.s.high\n+\t       + (USItype) uu.s.high * (USItype) vv.s.low);\n \n   return w.ll;\n }\n #endif\n \f\n #ifdef L_udivmoddi4\n-static const unsigned char __clz_tab[] =\n+static const UQItype __clz_tab[] =\n {\n   0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n   6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n@@ -258,17 +282,17 @@ static const unsigned char __clz_tab[] =\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n };\n \n-unsigned long long\n+UDItype\n __udivmoddi4 (n, d, rp)\n-     unsigned long long n, d;\n-     unsigned long long int *rp;\n+     UDItype n, d;\n+     UDItype *rp;\n {\n-  long_long ww;\n-  long_long nn, dd;\n-  long_long rr;\n-  unsigned long d0, d1, n0, n1, n2;\n-  unsigned long q0, q1;\n-  unsigned b, bm;\n+  DIunion ww;\n+  DIunion nn, dd;\n+  DIunion rr;\n+  USItype d0, d1, n0, n1, n2;\n+  USItype q0, q1;\n+  USItype b, bm;\n \n   nn.ll = n;\n   dd.ll = d;\n@@ -327,7 +351,7 @@ __udivmoddi4 (n, d, rp)\n \t\t denominator set.  */\n \n \t      d0 = d0 << bm;\n-\t      n1 = (n1 << bm) | (n0 >> (LONG_TYPE_SIZE - bm));\n+\t      n1 = (n1 << bm) | (n0 >> (SI_TYPE_SIZE - bm));\n \t      n0 = n0 << bm;\n \t    }\n \n@@ -352,7 +376,7 @@ __udivmoddi4 (n, d, rp)\n \t\t leading quotient digit q1 = 1).\n \n \t\t This special case is necessary, not an optimization.\n-\t\t (Shifts counts of LONG_TYPE_SIZE are undefined.)  */\n+\t\t (Shifts counts of SI_TYPE_SIZE are undefined.)  */\n \n \t      n1 -= d0;\n \t      q1 = 1;\n@@ -361,7 +385,7 @@ __udivmoddi4 (n, d, rp)\n \t    {\n \t      /* Normalize.  */\n \n-\t      b = LONG_TYPE_SIZE - bm;\n+\t      b = SI_TYPE_SIZE - bm;\n \n \t      d0 = d0 << bm;\n \t      n2 = n1 >> b;\n@@ -438,10 +462,10 @@ __udivmoddi4 (n, d, rp)\n \t    }\n \t  else\n \t    {\n-\t      unsigned long m1, m0;\n+\t      USItype m1, m0;\n \t      /* Normalize.  */\n \n-\t      b = LONG_TYPE_SIZE - bm;\n+\t      b = SI_TYPE_SIZE - bm;\n \n \t      d1 = (d1 << bm) | (d0 >> b);\n \t      d0 = d0 << bm;\n@@ -479,14 +503,14 @@ __udivmoddi4 (n, d, rp)\n #endif\n \n #ifdef L_divdi3\n-unsigned long long __udivmoddi4 ();\n-long long\n+UDItype __udivmoddi4 ();\n+DItype\n __divdi3 (u, v)\n-     long long u, v;\n+     DItype u, v;\n {\n-  int c = 0;\n-  long_long uu, vv;\n-  long long w;\n+  SItype c = 0;\n+  DIunion uu, vv;\n+  DItype w;\n \n   uu.ll = u;\n   vv.ll = v;\n@@ -498,7 +522,7 @@ __divdi3 (u, v)\n     c = ~c,\n     vv.ll = __negdi2 (vv.ll);\n \n-  w = __udivmoddi4 (uu.ll, vv.ll, (unsigned long long *) 0);\n+  w = __udivmoddi4 (uu.ll, vv.ll, (UDItype *) 0);\n   if (c)\n     w = __negdi2 (w);\n \n@@ -507,14 +531,14 @@ __divdi3 (u, v)\n #endif\n \n #ifdef L_moddi3\n-unsigned long long __udivmoddi4 ();\n-long long\n+UDItype __udivmoddi4 ();\n+DItype\n __moddi3 (u, v)\n-     long long u, v;\n+     DItype u, v;\n {\n-  int c = 0;\n-  long_long uu, vv;\n-  long long w;\n+  SItype c = 0;\n+  DIunion uu, vv;\n+  DItype w;\n \n   uu.ll = u;\n   vv.ll = v;\n@@ -534,12 +558,12 @@ __moddi3 (u, v)\n #endif\n \n #ifdef L_umoddi3\n-unsigned long long __udivmoddi4 ();\n-unsigned long long\n+UDItype __udivmoddi4 ();\n+UDItype\n __umoddi3 (u, v)\n-     unsigned long long u, v;\n+     UDItype u, v;\n {\n-  long long w;\n+  DItype w;\n \n   (void) __udivmoddi4 (u, v, &w);\n \n@@ -548,31 +572,31 @@ __umoddi3 (u, v)\n #endif\n \n #ifdef L_udivdi3\n-unsigned long long __udivmoddi4 ();\n-unsigned long long\n+UDItype __udivmoddi4 ();\n+UDItype\n __udivdi3 (n, d)\n-     unsigned long long n, d;\n+     UDItype n, d;\n {\n-  return __udivmoddi4 (n, d, (unsigned long long *) 0);\n+  return __udivmoddi4 (n, d, (UDItype *) 0);\n }\n #endif\n \f\n #ifdef L_cmpdi2\n SItype\n __cmpdi2 (a, b)\n-     long long a, b;\n+     DItype a, b;\n {\n-  long_long au, bu;\n+  DIunion au, bu;\n \n   au.ll = a, bu.ll = b;\n \n   if (au.s.high < bu.s.high)\n     return 0;\n   else if (au.s.high > bu.s.high)\n     return 2;\n-  if ((unsigned long) au.s.low < (unsigned long) bu.s.low)\n+  if ((USItype) au.s.low < (USItype) bu.s.low)\n     return 0;\n-  else if ((unsigned long) au.s.low > (unsigned long) bu.s.low)\n+  else if ((USItype) au.s.low > (USItype) bu.s.low)\n     return 2;\n   return 1;\n }\n@@ -581,61 +605,105 @@ __cmpdi2 (a, b)\n #ifdef L_ucmpdi2\n SItype\n __ucmpdi2 (a, b)\n-     long long a, b;\n+     DItype a, b;\n {\n-  long_long au, bu;\n+  DIunion au, bu;\n \n   au.ll = a, bu.ll = b;\n \n-  if ((unsigned long) au.s.high < (unsigned long) bu.s.high)\n+  if ((USItype) au.s.high < (USItype) bu.s.high)\n     return 0;\n-  else if ((unsigned long) au.s.high > (unsigned long) bu.s.high)\n+  else if ((USItype) au.s.high > (USItype) bu.s.high)\n     return 2;\n-  if ((unsigned long) au.s.low < (unsigned long) bu.s.low)\n+  if ((USItype) au.s.low < (USItype) bu.s.low)\n     return 0;\n-  else if ((unsigned long) au.s.low > (unsigned long) bu.s.low)\n+  else if ((USItype) au.s.low > (USItype) bu.s.low)\n     return 2;\n   return 1;\n }\n #endif\n \f\n+#if defined(L_fixunstfdi) && (LONG_DOUBLE_TYPE_SIZE == 128)\n+#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+\n+DItype\n+__fixunstfdi (a)\n+     TFtype a;\n+{\n+  TFtype b;\n+  UDItype v;\n+\n+  if (a < 0)\n+    return 0;\n+\n+  /* Compute high word of result, as a flonum.  */\n+  b = (a / HIGH_WORD_COEFF);\n+  /* Convert that to fixed (but not to DItype!),\n+     and shift it into the high word.  */\n+  v = (USItype) b;\n+  v <<= WORD_SIZE;\n+  /* Remove high part from the TFtype, leaving the low part as flonum.  */\n+  a -= (TFtype)v;\n+  /* Convert that to fixed (but not to DItype!) and add it in.\n+     Sometimes A comes out negative.  This is significant, since\n+     A has more bits than a long int does.  */\n+  if (a < 0)\n+    v -= (USItype) (- a);\n+  else\n+    v += (USItype) a;\n+  return v;\n+}\n+#endif\n+\n+#if defined(L_fixtfdi) && (LONG_DOUBLE_TYPE_SIZE == 128)\n+DItype\n+__fixtfdi (a)\n+     TFtype a;\n+{\n+  if (a < 0)\n+    return - __fixunstfdi (-a);\n+  return __fixunstfdi (a);\n+}\n+#endif\n+\n #ifdef L_fixunsdfdi\n-#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n \n-long long\n+DItype\n __fixunsdfdi (a)\n-     double a;\n+     DFtype a;\n {\n-  double b;\n-  unsigned long long v;\n+  DFtype b;\n+  UDItype v;\n \n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n   b = (a / HIGH_WORD_COEFF);\n-  /* Convert that to fixed (but not to long long!),\n+  /* Convert that to fixed (but not to DItype!),\n      and shift it into the high word.  */\n-  v = (unsigned long int) b;\n+  v = (USItype) b;\n   v <<= WORD_SIZE;\n-  /* Remove high part from the double, leaving the low part as flonum.  */\n-  a -= (double)v;\n-  /* Convert that to fixed (but not to long long!) and add it in.\n+  /* Remove high part from the DFtype, leaving the low part as flonum.  */\n+  a -= (DFtype)v;\n+  /* Convert that to fixed (but not to DItype!) and add it in.\n      Sometimes A comes out negative.  This is significant, since\n      A has more bits than a long int does.  */\n   if (a < 0)\n-    v -= (unsigned long int) (- a);\n+    v -= (USItype) (- a);\n   else\n-    v += (unsigned long int) a;\n+    v += (USItype) a;\n   return v;\n }\n #endif\n \n #ifdef L_fixdfdi\n-long long\n+DItype\n __fixdfdi (a)\n-     double a;\n+     DFtype a;\n {\n   if (a < 0)\n     return - __fixunsdfdi (-a);\n@@ -644,94 +712,118 @@ __fixdfdi (a)\n #endif\n \n #ifdef L_fixunssfdi\n-#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n \n-long long\n-__fixunssfdi (float original_a)\n+DItype\n+__fixunssfdi (SFtype original_a)\n {\n-  /* Convert the float to a double, because that is surely not going\n+  /* Convert the SFtype to a DFtype, because that is surely not going\n      to lose any bits.  Some day someone else can write a faster version\n-     that avoids converting to double, and verify it really works right.  */\n-  double a = original_a;\n-  double b;\n-  unsigned long long v;\n+     that avoids converting to DFtype, and verify it really works right.  */\n+  DFtype a = original_a;\n+  DFtype b;\n+  UDItype v;\n \n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n   b = (a / HIGH_WORD_COEFF);\n-  /* Convert that to fixed (but not to long long!),\n+  /* Convert that to fixed (but not to DItype!),\n      and shift it into the high word.  */\n-  v = (unsigned long int) b;\n+  v = (USItype) b;\n   v <<= WORD_SIZE;\n-  /* Remove high part from the double, leaving the low part as flonum.  */\n-  a -= (double)v;\n-  /* Convert that to fixed (but not to long long!) and add it in.\n+  /* Remove high part from the DFtype, leaving the low part as flonum.  */\n+  a -= (DFtype)v;\n+  /* Convert that to fixed (but not to DItype!) and add it in.\n      Sometimes A comes out negative.  This is significant, since\n      A has more bits than a long int does.  */\n   if (a < 0)\n-    v -= (unsigned long int) (- a);\n+    v -= (USItype) (- a);\n   else\n-    v += (unsigned long int) a;\n+    v += (USItype) a;\n   return v;\n }\n #endif\n \n #ifdef L_fixsfdi\n-long long\n-__fixsfdi (float a)\n+DItype\n+__fixsfdi (SFtype a)\n {\n   if (a < 0)\n     return - __fixunssfdi (-a);\n   return __fixunssfdi (a);\n }\n #endif\n \n+#if defined(L_floatditf) && (LONG_DOUBLE_TYPE_SIZE == 128)\n+#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+\n+TFtype\n+__floatditf (u)\n+     DItype u;\n+{\n+  TFtype d;\n+  SItype negate = 0;\n+\n+  if (u < 0)\n+    u = -u, negate = 1;\n+\n+  d = (USItype) (u >> WORD_SIZE);\n+  d *= HIGH_HALFWORD_COEFF;\n+  d *= HIGH_HALFWORD_COEFF;\n+  d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n+\n+  return (negate ? -d : d);\n+}\n+#endif\n+\n #ifdef L_floatdidf\n-#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((long long) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n \n-double\n+DFtype\n __floatdidf (u)\n-     long long u;\n+     DItype u;\n {\n-  double d;\n-  int negate = 0;\n+  DFtype d;\n+  SItype negate = 0;\n \n   if (u < 0)\n     u = -u, negate = 1;\n \n-  d = (unsigned int) (u >> WORD_SIZE);\n+  d = (USItype) (u >> WORD_SIZE);\n   d *= HIGH_HALFWORD_COEFF;\n   d *= HIGH_HALFWORD_COEFF;\n-  d += (unsigned int) (u & (HIGH_WORD_COEFF - 1));\n+  d += (USItype) (u & (HIGH_WORD_COEFF - 1));\n \n   return (negate ? -d : d);\n }\n #endif\n \n #ifdef L_floatdisf\n-#define WORD_SIZE (sizeof (long) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((long long) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((long long) 1) << WORD_SIZE)\n+#define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n+#define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n \n-float\n+SFtype\n __floatdisf (u)\n-     long long u;\n+     DItype u;\n {\n-  float f;\n-  int negate = 0;\n+  SFtype f;\n+  SItype negate = 0;\n \n   if (u < 0)\n     u = -u, negate = 1;\n \n-  f = (unsigned int) (u >> WORD_SIZE);\n+  f = (USItype) (u >> WORD_SIZE);\n   f *= HIGH_HALFWORD_COEFF;\n   f *= HIGH_HALFWORD_COEFF;\n-  f += (unsigned int) (u & (HIGH_WORD_COEFF - 1));\n+  f += (USItype) (u & (HIGH_WORD_COEFF - 1));\n \n   return (negate ? -f : f);\n }\n@@ -740,11 +832,11 @@ __floatdisf (u)\n #ifdef L_fixunsdfsi\n #include \"limits.h\"\n \n-unsigned SItype\n+USItype\n __fixunsdfsi (a)\n-     double a;\n+     DFtype a;\n {\n-  if (a >= - (double) LONG_MIN)\n+  if (a >= - (DFtype) LONG_MIN)\n     return (SItype) (a + LONG_MIN) - LONG_MIN;\n   return (SItype) a;\n }\n@@ -753,15 +845,32 @@ __fixunsdfsi (a)\n #ifdef L_fixunssfsi\n #include \"limits.h\"\n \n-unsigned SItype\n-__fixunssfsi (float a)\n+USItype\n+__fixunssfsi (SFtype a)\n {\n-  if (a >= - (float) LONG_MIN)\n+  if (a >= - (SFtype) LONG_MIN)\n     return (SItype) (a + LONG_MIN) - LONG_MIN;\n   return (SItype) a;\n }\n #endif\n \f\n+/* From here on down, the routines use normal data types.  */\n+\n+#define SItype bogus_type\n+#define USItype bogus_type\n+#define DItype bogus_type\n+#define UDItype bogus_type\n+#define SFtype bogus_type\n+#define DFtype bogus_type\n+\n+#undef char\n+#undef short\n+#undef int\n+#undef long\n+#undef unsigned\n+#undef float\n+#undef double\n+\n #ifdef L_varargs\n #ifdef __i860__\n #if defined(__svr4__) || defined(__alliant__)"}]}