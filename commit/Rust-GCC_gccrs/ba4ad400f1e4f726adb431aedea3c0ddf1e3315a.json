{"sha": "ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0YWQ0MDBmMWU0ZjcyNmFkYjQzMWFlZGVhM2MwZGRmMWUzMzE1YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-05-13T13:58:18Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-05-13T13:58:18Z"}, "message": "libcpp/input.c: Add a way to visualize the linemaps (-fdump-internal-locations)\n\ngcc/ChangeLog:\n\t* common.opt (fdump-internal-locations): New option.\n\t* input.c: Include diagnostic-core.h.\n\t(get_end_location): New function.\n\t(write_digit): New function.\n\t(write_digit_row): New function.\n\t(dump_location_range): New function.\n\t(dump_labelled_location_range): New function.\n\t(dump_location_info): New function.\n\t* input.h (dump_location_info): New prototype.\n\t* toplev.c (compile_file): Handle flag_dump_locations.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (source_location): Add a reference to\n\tlocation-example.txt to the descriptive comment.\n\t* location-example.txt: New file.\n\nFrom-SVN: r223163", "tree": {"sha": "263b351fcddaa726d296fc21e6f1f001c2221d5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/263b351fcddaa726d296fc21e6f1f001c2221d5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "49d50b6b8f727b681410a1865aadd915a14df2a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d50b6b8f727b681410a1865aadd915a14df2a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d50b6b8f727b681410a1865aadd915a14df2a5"}], "stats": {"total": 472, "additions": 471, "deletions": 1}, "files": [{"sha": "ada1757d34af086ff0573b729a71e470383278c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -1,3 +1,16 @@\n+2015-05-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* common.opt (fdump-internal-locations): New option.\n+\t* input.c: Include diagnostic-core.h.\n+\t(get_end_location): New function.\n+\t(write_digit): New function.\n+\t(write_digit_row): New function.\n+\t(dump_location_range): New function.\n+\t(dump_labelled_location_range): New function.\n+\t(dump_location_info): New function.\n+\t* input.h (dump_location_info): New prototype.\n+\t* toplev.c (compile_file): Handle flag_dump_locations.\n+\n 2015-05-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimple-expr.h (is_gimple_constant): Reorder."}, {"sha": "859488f7a1c0dcf225c8722371d3a3cc5d30a887", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -1166,6 +1166,10 @@ Common Driver Var(flag_report_bug)\n Collect and dump debug information into temporary file if ICE in C/C++\n compiler occured.\n \n+fdump-internal-locations\n+Common Var(flag_dump_locations) Init(0)\n+Dump detailed information on GCC's internal representation of source code locations\n+\n fdump-passes\n Common Var(flag_dump_passes) Init(0)\n Dump optimization passes"}, {"sha": "d633b762d756cfc6ac51d8ef61c66e0a47f1e1f1", "filename": "gcc/input.c", "status": "modified", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"input.h\"\n #include \"vec.h\"\n+#include \"diagnostic-core.h\"\n \n /* This is a cache used by get_next_line to store the content of a\n    file to be searched for file lines.  */\n@@ -869,3 +870,226 @@ dump_line_table_statistics (void)\n            STAT_LABEL (total_used_map_size));\n   fprintf (stderr, \"\\n\");\n }\n+\n+/* Get location one beyond the final location in ordinary map IDX.  */\n+\n+static source_location\n+get_end_location (struct line_maps *set, unsigned int idx)\n+{\n+  if (idx == LINEMAPS_ORDINARY_USED (set) - 1)\n+    return set->highest_location;\n+\n+  struct line_map *next_map = LINEMAPS_ORDINARY_MAP_AT (set, idx + 1);\n+  return MAP_START_LOCATION (next_map);\n+}\n+\n+/* Helper function for write_digit_row.  */\n+\n+static void\n+write_digit (FILE *stream, int digit)\n+{\n+  fputc ('0' + (digit % 10), stream);\n+}\n+\n+/* Helper function for dump_location_info.\n+   Write a row of numbers to STREAM, numbering a source line,\n+   giving the units, tens, hundreds etc of the column number.  */\n+\n+static void\n+write_digit_row (FILE *stream, int indent,\n+\t\t source_location loc, int max_col, int divisor)\n+{\n+  fprintf (stream, \"%*c\", indent, ' ');\n+  fprintf (stream, \"|\");\n+  for (int column = 1; column < max_col; column++)\n+    {\n+      source_location column_loc = loc + column;\n+      write_digit (stream, column_loc / divisor);\n+    }\n+  fprintf (stream, \"\\n\");\n+}\n+\n+/* Write a half-closed (START) / half-open (END) interval of\n+   source_location to STREAM.  */\n+\n+static void\n+dump_location_range (FILE *stream,\n+\t\t     source_location start, source_location end)\n+{\n+  fprintf (stream,\n+\t   \"  source_location interval: %u <= loc < %u\\n\",\n+\t   start, end);\n+}\n+\n+/* Write a labelled description of a half-closed (START) / half-open (END)\n+   interval of source_location to STREAM.  */\n+\n+static void\n+dump_labelled_location_range (FILE *stream,\n+\t\t\t      const char *name,\n+\t\t\t      source_location start, source_location end)\n+{\n+  fprintf (stream, \"%s\\n\", name);\n+  dump_location_range (stream, start, end);\n+  fprintf (stream, \"\\n\");\n+}\n+\n+/* Write a visualization of the locations in the line_table to STREAM.  */\n+\n+void\n+dump_location_info (FILE *stream)\n+{\n+  /* Visualize the reserved locations.  */\n+  dump_labelled_location_range (stream, \"RESERVED LOCATIONS\",\n+\t\t\t\t0, RESERVED_LOCATION_COUNT);\n+\n+  /* Visualize the ordinary line_map instances, rendering the sources. */\n+  for (unsigned int idx = 0; idx < LINEMAPS_ORDINARY_USED (line_table); idx++)\n+    {\n+      source_location end_location = get_end_location (line_table, idx);\n+      /* half-closed: doesn't include this one. */\n+\n+      struct line_map *map = LINEMAPS_ORDINARY_MAP_AT (line_table, idx);\n+      fprintf (stream, \"ORDINARY MAP: %i\\n\", idx);\n+      dump_location_range (stream,\n+\t\t\t   MAP_START_LOCATION (map), end_location);\n+      fprintf (stream, \"  file: %s\\n\", ORDINARY_MAP_FILE_NAME (map));\n+      fprintf (stream, \"  starting at line: %i\\n\",\n+\t       ORDINARY_MAP_STARTING_LINE_NUMBER (map));\n+      fprintf (stream, \"  column bits: %i\\n\",\n+\t       ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map));\n+\n+      /* Render the span of source lines that this \"map\" covers.  */\n+      for (source_location loc = MAP_START_LOCATION (map);\n+\t   loc < end_location;\n+\t   loc++)\n+\t{\n+\t  expanded_location exploc\n+\t    = linemap_expand_location (line_table, map, loc);\n+\n+\t  if (0 == exploc.column)\n+\t    {\n+\t      /* Beginning of a new source line: draw the line.  */\n+\n+\t      int line_size;\n+\t      const char *line_text = location_get_source_line (exploc, &line_size);\n+\t      if (!line_text)\n+\t\tbreak;\n+\t      fprintf (stream,\n+\t\t       \"%s:%3i|loc:%5i|%.*s\\n\",\n+\t\t       exploc.file, exploc.line,\n+\t\t       loc,\n+\t\t       line_size, line_text);\n+\n+\t      /* \"loc\" is at column 0, which means \"the whole line\".\n+\t\t Render the locations *within* the line, by underlining\n+\t\t it, showing the source_location numeric values\n+\t\t at each column.  */\n+\t      int max_col\n+\t\t= (1 << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map)) - 1;\n+\t      if (max_col > line_size)\n+\t\tmax_col = line_size + 1;\n+\n+\t      int indent = 14 + strlen (exploc.file);\n+\n+\t      /* Thousands.  */\n+\t      if (end_location > 999)\n+\t\twrite_digit_row (stream, indent, loc, max_col, 1000);\n+\n+\t      /* Hundreds.  */\n+\t      if (end_location > 99)\n+\t\twrite_digit_row (stream, indent, loc, max_col, 100);\n+\n+\t      /* Tens.  */\n+\t      write_digit_row (stream, indent, loc, max_col, 10);\n+\n+\t      /* Units.  */\n+\t      write_digit_row (stream, indent, loc, max_col, 1);\n+\t    }\n+\t}\n+      fprintf (stream, \"\\n\");\n+    }\n+\n+  /* Visualize unallocated values.  */\n+  dump_labelled_location_range (stream, \"UNALLOCATED LOCATIONS\",\n+\t\t\t\tline_table->highest_location,\n+\t\t\t\tLINEMAPS_MACRO_LOWEST_LOCATION (line_table));\n+\n+  /* Visualize the macro line_map instances, rendering the sources. */\n+  for (unsigned int i = 0; i < LINEMAPS_MACRO_USED (line_table); i++)\n+    {\n+      /* Each macro map that is allocated owns source_location values\n+\t that are *lower* that the one before them.\n+\t Hence it's meaningful to view them either in order of ascending\n+\t source locations, or in order of ascending macro map index.  */\n+      const bool ascending_source_locations = true;\n+      unsigned int idx = (ascending_source_locations\n+\t\t\t  ? (LINEMAPS_MACRO_USED (line_table) - (i + 1))\n+\t\t\t  : i);\n+      struct line_map *map = LINEMAPS_MACRO_MAP_AT (line_table, idx);\n+      fprintf (stream, \"MACRO %i: %s (%u tokens)\\n\",\n+\t       idx,\n+\t       linemap_map_get_macro_name (map),\n+\t       MACRO_MAP_NUM_MACRO_TOKENS (map));\n+      dump_location_range (stream,\n+\t\t\t   map->start_location,\n+\t\t\t   (map->start_location\n+\t\t\t    + MACRO_MAP_NUM_MACRO_TOKENS (map)));\n+      inform (MACRO_MAP_EXPANSION_POINT_LOCATION (map),\n+\t      \"expansion point is location %i\",\n+\t      MACRO_MAP_EXPANSION_POINT_LOCATION (map));\n+      fprintf (stream, \"  map->start_location: %u\\n\",\n+\t       map->start_location);\n+\n+      fprintf (stream, \"  macro_locations:\\n\");\n+      for (unsigned int i = 0; i < MACRO_MAP_NUM_MACRO_TOKENS (map); i++)\n+\t{\n+\t  source_location x = MACRO_MAP_LOCATIONS (map)[2 * i];\n+\t  source_location y = MACRO_MAP_LOCATIONS (map)[(2 * i) + 1];\n+\n+\t  /* linemap_add_macro_token encodes token numbers in an expansion\n+\t     by putting them after MAP_START_LOCATION. */\n+\n+\t  /* I'm typically seeing 4 uninitialized entries at the end of\n+\t     0xafafafaf.\n+\t     This appears to be due to macro.c:replace_args\n+\t     adding 2 extra args for padding tokens; presumably there may\n+\t     be a leading and/or trailing padding token injected,\n+\t     each for 2 more location slots.\n+\t     This would explain there being up to 4 source_locations slots\n+\t     that may be uninitialized.  */\n+\n+\t  fprintf (stream, \"    %u: %u, %u\\n\",\n+\t\t   i,\n+\t\t   x,\n+\t\t   y);\n+\t  if (x == y)\n+\t    {\n+\t      if (x < MAP_START_LOCATION (map))\n+\t\tinform (x, \"token %u has x-location == y-location == %u\", i, x);\n+\t      else\n+\t\tfprintf (stream,\n+\t\t\t \"x-location == y-location == %u encodes token # %u\\n\",\n+\t\t\t x, x - MAP_START_LOCATION (map));\n+\t\t}\n+\t  else\n+\t    {\n+\t      inform (x, \"token %u has x-location == %u\", i, x);\n+\t      inform (x, \"token %u has y-location == %u\", i, y);\n+\t    }\n+\t}\n+      fprintf (stream, \"\\n\");\n+    }\n+\n+  /* It appears that MAX_SOURCE_LOCATION itself is never assigned to a\n+     macro map, presumably due to an off-by-one error somewhere\n+     between the logic in linemap_enter_macro and\n+     LINEMAPS_MACRO_LOWEST_LOCATION.  */\n+  dump_labelled_location_range (stream, \"MAX_SOURCE_LOCATION\",\n+\t\t\t\tMAX_SOURCE_LOCATION,\n+\t\t\t\tMAX_SOURCE_LOCATION + 1);\n+\n+  /* Visualize ad-hoc values.  */\n+  dump_labelled_location_range (stream, \"AD-HOC LOCATIONS\",\n+\t\t\t\tMAX_SOURCE_LOCATION + 1, UINT_MAX);\n+}"}, {"sha": "5ba4d3b46f53f6ec8ec513ceecb0606aa8bae1e9", "filename": "gcc/input.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -77,6 +77,8 @@ extern location_t input_location;\n \n void dump_line_table_statistics (void);\n \n+void dump_location_info (FILE *stream);\n+\n void diagnostics_file_cache_fini (void);\n \n #endif"}, {"sha": "3c1ba38d9c2f23574dd24202bcae7198f2274948", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -593,6 +593,9 @@ compile_file (void)\n   timevar_pop (TV_PARSE_GLOBAL);\n   timevar_stop (TV_PHASE_PARSING);\n \n+  if (flag_dump_locations)\n+    dump_location_info (stderr);\n+\n   /* Compilation is now finished except for writing\n      what's left of the symbol table output.  */\n "}, {"sha": "32582ddeada8346ad3c8df13df89f41b6744d94c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -1,3 +1,9 @@\n+2015-05-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (source_location): Add a reference to\n+\tlocation-example.txt to the descriptive comment.\n+\t* location-example.txt: New file.\n+\n 2015-05-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (MAX_SOURCE_LOCATION): Convert from a macro"}, {"sha": "27aa094c99776fa2a3e2be3f6bfec0360f8c06ae", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -113,7 +113,9 @@ typedef unsigned int linenum_type;\n   ...        |                               |\n   0xffffffff | UINT_MAX                      |\n   -----------+-------------------------------+-------------------------------\n-  .  */\n+\n+  To see how this works in practice, see the worked example in\n+  libcpp/location-example.txt.  */\n typedef unsigned int source_location;\n \n /* Memory allocation function typedef.  Works like xrealloc.  */"}, {"sha": "a5f95b2baf8dd1f4c3eea24396aaaebd8501af3e", "filename": "libcpp/location-example.txt", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/libcpp%2Flocation-example.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4ad400f1e4f726adb431aedea3c0ddf1e3315a/libcpp%2Flocation-example.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flocation-example.txt?ref=ba4ad400f1e4f726adb431aedea3c0ddf1e3315a", "patch": "@@ -0,0 +1,216 @@\n+Consider compiling test.c, with this content:\n+VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n+#include \"test.h\"\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int a = PLUS (1,2);\n+  int b = PLUS (3,4);\n+  return 0;\n+}\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+...where test.h has this content:\n+VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n+extern int foo ();\n+\n+#define PLUS(A, B) A + B\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+\n+The undocumented -fdump-internal-locations option outputs this information\n+to stderr, showing what each source_location value means.  Source code\n+lines are quoted, showing both per-line source_location values and\n+per-line&column source_location values (written vertically under the\n+corresponding character of source code).\n+\n+VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n+RESERVED LOCATIONS\n+  source_location interval: 0 <= loc < 2\n+\n+ORDINARY MAP: 0\n+  source_location interval: 2 <= loc < 3\n+  file: test.c\n+  starting at line: 1\n+  column bits: 7\n+test.c:  1|loc:    2|#include \"test.h\"\n+                    |00000001111111111\n+                    |34567890123456789\n+\n+ORDINARY MAP: 1\n+  source_location interval: 3 <= loc < 4\n+  file: <built-in>\n+  starting at line: 0\n+  column bits: 0\n+\n+ORDINARY MAP: 2\n+  source_location interval: 4 <= loc < 5\n+  file: <command-line>\n+  starting at line: 0\n+  column bits: 0\n+\n+ORDINARY MAP: 3\n+  source_location interval: 5 <= loc < 5005\n+  file: /usr/include/stdc-predef.h\n+  starting at line: 1\n+  column bits: 7\n+(contents of /usr/include/stdc-predef.h snipped for brevity)\n+\n+ORDINARY MAP: 4\n+  source_location interval: 5005 <= loc < 5006\n+  file: <command-line>\n+  starting at line: 1\n+  column bits: 7\n+\n+ORDINARY MAP: 5\n+  source_location interval: 5006 <= loc < 5134\n+  file: test.c\n+  starting at line: 1\n+  column bits: 7\n+test.c:  1|loc: 5006|#include \"test.h\"\n+                    |55555555555555555\n+                    |00000000000000000\n+                    |00011111111112222\n+                    |78901234567890123\n+\n+ORDINARY MAP: 6\n+  source_location interval: 5134 <= loc < 5416\n+  file: test.h\n+  starting at line: 1\n+  column bits: 7\n+test.h:  1|loc: 5134|extern int foo ();\n+                    |555555555555555555\n+                    |111111111111111111\n+                    |333334444444444555\n+                    |567890123456789012\n+test.h:  2|loc: 5262|\n+                    |\n+                    |\n+                    |\n+                    |\n+test.h:  3|loc: 5390|#define PLUS(A, B) A + B\n+                    |555555555555555555555555\n+                    |333333333444444444444444\n+                    |999999999000000000011111\n+                    |123456789012345678901234\n+\n+ORDINARY MAP: 7\n+  source_location interval: 5416 <= loc < 6314\n+  file: test.c\n+  starting at line: 2\n+  column bits: 7\n+test.c:  2|loc: 5416|\n+                    |\n+                    |\n+                    |\n+                    |\n+test.c:  3|loc: 5544|int\n+                    |555\n+                    |555\n+                    |444\n+                    |567\n+test.c:  4|loc: 5672|main (int argc, char **argv)\n+                    |5555555555555555555555555555\n+                    |6666666666666666666666666667\n+                    |7777777888888888899999999990\n+                    |3456789012345678901234567890\n+test.c:  5|loc: 5800|{\n+                    |5\n+                    |8\n+                    |0\n+                    |1\n+test.c:  6|loc: 5928|  int a = PLUS (1,2);\n+                    |555555555555555555555\n+                    |999999999999999999999\n+                    |233333333334444444444\n+                    |901234567890123456789\n+test.c:  7|loc: 6056|  int b = PLUS (3,4);\n+                    |666666666666666666666\n+                    |000000000000000000000\n+                    |555666666666677777777\n+                    |789012345678901234567\n+test.c:  8|loc: 6184|  return 0;\n+                    |66666666666\n+                    |11111111111\n+                    |88888999999\n+                    |56789012345\n+test.c:  9|loc: 6312|}\n+                    |6\n+                    |3\n+                    |1\n+                    |3\n+\n+UNALLOCATED LOCATIONS\n+  source_location interval: 6314 <= loc < 2147483633\n+\n+MACRO 1: PLUS (7 tokens)\n+  source_location interval: 2147483633 <= loc < 2147483640\n+test.c:7:11: note: expansion point is location 6067\n+   int b = PLUS (3,4);\n+           ^\n+  map->start_location: 2147483633\n+  macro_locations:\n+    0: 6073, 5410\n+test.c:7:17: note: token 0 has x-location == 6073\n+   int b = PLUS (3,4);\n+                 ^\n+test.c:7:17: note: token 0 has y-location == 5410\n+    1: 5412, 5412\n+In file included from test.c:1:0:\n+test.h:3:22: note: token 1 has x-location == y-location == 5412\n+ #define PLUS(A, B) A + B\n+                      ^\n+    2: 6075, 5414\n+test.c:7:19: note: token 2 has x-location == 6075\n+   int b = PLUS (3,4);\n+                   ^\n+test.c:7:19: note: token 2 has y-location == 5414\n+    3: 0, 2947526575\n+cc1: note: token 3 has x-location == 0\n+cc1: note: token 3 has y-location == 2947526575\n+    4: 2947526575, 2947526575\n+x-location == y-location == 2947526575 encodes token # 800042942\n+    5: 2947526575, 2947526575\n+x-location == y-location == 2947526575 encodes token # 800042942\n+    6: 2947526575, 2947526575\n+x-location == y-location == 2947526575 encodes token # 800042942\n+\n+MACRO 0: PLUS (7 tokens)\n+  source_location interval: 2147483640 <= loc < 2147483647\n+test.c:6:11: note: expansion point is location 5939\n+   int a = PLUS (1,2);\n+           ^\n+  map->start_location: 2147483640\n+  macro_locations:\n+    0: 5945, 5410\n+test.c:6:17: note: token 0 has x-location == 5945\n+   int a = PLUS (1,2);\n+                 ^\n+test.c:6:17: note: token 0 has y-location == 5410\n+    1: 5412, 5412\n+In file included from test.c:1:0:\n+test.h:3:22: note: token 1 has x-location == y-location == 5412\n+ #define PLUS(A, B) A + B\n+                      ^\n+    2: 5947, 5414\n+test.c:6:19: note: token 2 has x-location == 5947\n+   int a = PLUS (1,2);\n+                   ^\n+test.c:6:19: note: token 2 has y-location == 5414\n+    3: 0, 2947526575\n+cc1: note: token 3 has x-location == 0\n+cc1: note: token 3 has y-location == 2947526575\n+    4: 2947526575, 2947526575\n+x-location == y-location == 2947526575 encodes token # 800042935\n+    5: 2947526575, 2947526575\n+x-location == y-location == 2947526575 encodes token # 800042935\n+    6: 2947526575, 2947526575\n+x-location == y-location == 2947526575 encodes token # 800042935\n+\n+MAX_SOURCE_LOCATION\n+  source_location interval: 2147483647 <= loc < 2147483648\n+\n+AD-HOC LOCATIONS\n+  source_location interval: 2147483648 <= loc < 4294967295\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}]}