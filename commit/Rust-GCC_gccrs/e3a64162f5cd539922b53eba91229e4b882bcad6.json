{"sha": "e3a64162f5cd539922b53eba91229e4b882bcad6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNhNjQxNjJmNWNkNTM5OTIyYjUzZWJhOTEyMjllNGI4ODJiY2FkNg==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2004-07-25T17:57:24Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2004-07-25T17:57:24Z"}, "message": "c-common.c: Rename all identifiers named `class' to `cl'.\n\n\t* c-common.c: Rename all identifiers named `class' to `cl'.\n\t* c-decl.c: Likewise.\n\t* c-common.h: Likewise.\n\t* c-parse.in: Likewise.\n\t* c-typeck.c: Likewise.\n\t* genmodes.c: Likewise.\n\t* real.c: Likewise.\n\t* real.h: Likewise.\n\t* recog.c: Likewise.\n\t* recog.h: Likewise.\n\t* regrename.c: Likewise.\n\t* tree.h: Likewise.\n\nFrom-SVN: r85153", "tree": {"sha": "6f26ca609f256828ce2146879b8488b97aa20f40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f26ca609f256828ce2146879b8488b97aa20f40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3a64162f5cd539922b53eba91229e4b882bcad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a64162f5cd539922b53eba91229e4b882bcad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a64162f5cd539922b53eba91229e4b882bcad6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a64162f5cd539922b53eba91229e4b882bcad6/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "381166d48e97ccf1bbc9c747bd11e61b7b0c8155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381166d48e97ccf1bbc9c747bd11e61b7b0c8155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/381166d48e97ccf1bbc9c747bd11e61b7b0c8155"}], "stats": {"total": 478, "additions": 249, "deletions": 229}, "files": [{"sha": "e1aa4b81c8d337bdd58be8fc5132767a4bbe41e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -1,3 +1,17 @@\n+2004-07-25  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* c-common.c: Rename all identifiers named `class' to `cl'.\n+\t* c-common.h: Likewise.\n+\t* c-parse.in: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* genmodes.c: Likewise.\n+\t* real.c: Likewise.\n+\t* real.h: Likewise.\n+\t* recog.c: Likewise.\n+\t* recog.h: Likewise.\n+\t* regrename.c: Likewise.\n+\t* tree.h: Likewise.\n+\n 2004-07-25  Daniel Jacobowitz  <dan@debian.org>\n \n \t* regmove.c (optimize_reg_copy_1): Don't try to replace call-used"}, {"sha": "37e10e751993bd0178391c6115981ab63dcf4522", "filename": "gcc/c-common.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -1196,7 +1196,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n {\n   struct tlist *tmp_before, *tmp_nosp, *tmp_list2, *tmp_list3;\n   enum tree_code code;\n-  char class;\n+  char cl;\n \n   /* X may be NULL if it is the operand of an empty statement expression\n      ({ }).  */\n@@ -1205,7 +1205,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n \n  restart:\n   code = TREE_CODE (x);\n-  class = TREE_CODE_CLASS (code);\n+  cl = TREE_CODE_CLASS (code);\n \n   if (warning_candidate_p (x))\n     {\n@@ -1349,7 +1349,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n       break;\n     }\n \n-  if (class == '1')\n+  if (cl == '1')\n     {\n       if (first_rtl_op (code) == 0)\n \treturn;\n@@ -1358,7 +1358,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n       goto restart;\n     }\n \n-  switch (class)\n+  switch (cl)\n     {\n     case 'r':\n     case '<':\n@@ -2460,9 +2460,12 @@ c_common_truthvalue_conversion (tree expr)\n   return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n }\n \f\n-static tree builtin_function_2 (const char *, const char *, tree, tree,\n-\t\t\t\tint, enum built_in_class, int, int,\n-\t\t\t\ttree);\n+static tree builtin_function_2 (const char *builtin_name, const char *name,\n+\t\t\t\ttree builtin_type, tree type,\n+\t\t\t\tenum built_in_function function_code,\n+\t\t\t\tenum built_in_class cl, int library_name_p,\n+\t\t\t\tbool nonansi_p,\n+\t\t\t\ttree attrs);\n \n /* Make a variant type in the proper way for C/C++, propagating qualifiers\n    down to the element type of an array.  */\n@@ -3269,32 +3272,33 @@ builtin_function_disabled_p (const char *name)\n    BUILTIN_TYPE is the type of the __builtin_-prefixed function;\n    TYPE is the type of the function with the ordinary name.  These\n    may differ if the ordinary name is declared with a looser type to avoid\n-   conflicts with headers.  FUNCTION_CODE and CLASS are as for\n+   conflicts with headers.  FUNCTION_CODE and CL are as for\n    builtin_function.  If LIBRARY_NAME_P is nonzero, NAME is passed as\n    the LIBRARY_NAME parameter to builtin_function when declaring BUILTIN_NAME.\n-   If NONANSI_P is nonzero, the name NAME is treated as a non-ANSI name;\n+   If NONANSI_P is true, the name NAME is treated as a non-ANSI name;\n    ATTRS is the tree list representing the builtin's function attributes.\n    Returns the declaration of BUILTIN_NAME, if any, otherwise\n    the declaration of NAME.  Does not declare NAME if flag_no_builtin,\n    or if NONANSI_P and flag_no_nonansi_builtin.  */\n \n static tree\n builtin_function_2 (const char *builtin_name, const char *name,\n-\t\t    tree builtin_type, tree type, int function_code,\n-\t\t    enum built_in_class class, int library_name_p,\n-\t\t    int nonansi_p, tree attrs)\n+\t\t    tree builtin_type, tree type,\n+\t\t    enum built_in_function function_code,\n+\t\t    enum built_in_class cl, int library_name_p,\n+\t\t    bool nonansi_p, tree attrs)\n {\n   tree bdecl = NULL_TREE;\n   tree decl = NULL_TREE;\n \n   if (builtin_name != 0)\n     bdecl = lang_hooks.builtin_function (builtin_name, builtin_type,\n-\t\t\t\t\t function_code, class,\n+\t\t\t\t\t function_code, cl,\n \t\t\t\t\t library_name_p ? name : NULL, attrs);\n \n   if (name != 0 && !flag_no_builtin && !builtin_function_disabled_p (name)\n       && !(nonansi_p && flag_no_nonansi_builtin))\n-    decl = lang_hooks.builtin_function (name, type, function_code, class,\n+    decl = lang_hooks.builtin_function (name, type, function_code, cl,\n \t\t\t\t\tNULL, attrs);\n \n   return (bdecl != 0 ? bdecl : decl);"}, {"sha": "e5e1ee242c3dc478dfc2a7666944ca41720737ca", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -2475,15 +2475,15 @@ c_make_fname_decl (tree id, int type_dep)\n \n tree\n builtin_function (const char *name, tree type, int function_code,\n-\t\t  enum built_in_class class, const char *library_name,\n+\t\t  enum built_in_class cl, const char *library_name,\n \t\t  tree attrs)\n {\n   tree id = get_identifier (name);\n   tree decl = build_decl (FUNCTION_DECL, id, type);\n   TREE_PUBLIC (decl) = 1;\n   DECL_EXTERNAL (decl) = 1;\n-  DECL_LANG_SPECIFIC (decl) = ggc_alloc_cleared (sizeof (struct lang_decl));\n-  DECL_BUILT_IN_CLASS (decl) = class;\n+  DECL_LANG_SPECIFIC (decl) = GGC_CNEW (struct lang_decl);\n+  DECL_BUILT_IN_CLASS (decl) = cl;\n   DECL_FUNCTION_CODE (decl) = function_code;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));"}, {"sha": "50ac48dee5ddfd4758426cbc57da4ea0ff39fd93", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -1975,7 +1975,7 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n \t\t differ from the default conversions.  */\n \t      if (warn_conversion || warn_traditional)\n \t\t{\n-\t\t  int formal_prec = TYPE_PRECISION (type);\n+\t\t  unsigned int formal_prec = TYPE_PRECISION (type);\n \n \t\t  if (INTEGRAL_TYPE_P (type)\n \t\t      && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)"}, {"sha": "fb2bb46d56df88d2c54263c566eb3b73e65a5acd", "filename": "gcc/genmodes.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -55,7 +55,7 @@ struct mode_data\n   struct mode_data *next;\t/* next this class - arbitrary order */\n \n   const char *name;\t\t/* printable mode name -- SI, not SImode */\n-  enum mode_class class;\t/* this mode class */\n+  enum mode_class cl;\t\t/* this mode class */\n   unsigned int precision;\t/* size in bits, equiv to TYPE_PRECISION */\n   unsigned int bytesize;\t/* storage size in addressable units */\n   unsigned int ncomponents;\t/* number of subunits */\n@@ -79,7 +79,7 @@ static struct mode_data *void_mode;\n \n static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n-  -1, -1, -1, -1,\n+  -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0,\n   \"<unknown>\", 0\n };\n@@ -105,27 +105,27 @@ static struct mode_adjust *adj_format;\n \n /* Mode class operations.  */\n static enum mode_class\n-complex_class (enum mode_class class)\n+complex_class (enum mode_class c)\n {\n-  switch (class)\n+  switch (c)\n     {\n     case MODE_INT: return MODE_COMPLEX_INT;\n     case MODE_FLOAT: return MODE_COMPLEX_FLOAT;\n     default:\n-      error (\"no complex class for class %s\", mode_class_names[class]);\n+      error (\"no complex class for class %s\", mode_class_names[c]);\n       return MODE_RANDOM;\n     }\n }\n \n static enum mode_class\n-vector_class (enum mode_class class)\n+vector_class (enum mode_class cl)\n {\n-  switch (class)\n+  switch (cl)\n     {\n     case MODE_INT: return MODE_VECTOR_INT;\n     case MODE_FLOAT: return MODE_VECTOR_FLOAT;\n     default:\n-      error (\"no vector class for class %s\", mode_class_names[class]);\n+      error (\"no vector class for class %s\", mode_class_names[cl]);\n       return MODE_RANDOM;\n     }\n }\n@@ -137,11 +137,11 @@ find_mode (const char *name)\n   struct mode_data key;\n \n   key.name = name;\n-  return htab_find (modes_by_name, &key);\n+  return (struct mode_data *) htab_find (modes_by_name, &key);\n }\n \n static struct mode_data *\n-new_mode (enum mode_class class, const char *name,\n+new_mode (enum mode_class cl, const char *name,\n \t  const char *file, unsigned int line)\n {\n   struct mode_data *m;\n@@ -155,17 +155,17 @@ new_mode (enum mode_class class, const char *name,\n       return m;\n     }\n \n-  m = xmalloc (sizeof (struct mode_data));\n+  m = XNEW (struct mode_data);\n   memcpy (m, &blank_mode, sizeof (struct mode_data));\n-  m->class = class;\n+  m->cl = cl;\n   m->name = name;\n   if (file)\n     m->file = trim_filename (file);\n   m->line = line;\n \n-  m->next = modes[class];\n-  modes[class] = m;\n-  n_modes[class]++;\n+  m->next = modes[cl];\n+  modes[cl] = m;\n+  n_modes[cl]++;\n \n   *htab_find_slot (modes_by_name, m, INSERT) = m;\n   \n@@ -210,7 +210,7 @@ new_adjust (const char *name,\n       return;\n     }\n \n-  if (required_class != MODE_RANDOM && mode->class != required_class)\n+  if (required_class != MODE_RANDOM && mode->cl != required_class)\n     {\n       error (\"%s:%d: mode \\\"%s\\\" is not class %s\",\n \t     file, line, name, mode_class_names[required_class] + 5);\n@@ -289,13 +289,13 @@ complete_mode (struct mode_data *m)\n       error (\"%s:%d: mode with no name\", m->file, m->line);\n       return;\n     }\n-  if (m->class == MAX_MODE_CLASS)\n+  if (m->cl == MAX_MODE_CLASS)\n     {\n       error (\"%s:%d: %smode has no mode class\", m->file, m->line, m->name);\n       return;\n     }\n \n-  switch (m->class)\n+  switch (m->cl)\n     {\n     case MODE_RANDOM:\n       /* Nothing more need be said.  */\n@@ -326,7 +326,7 @@ complete_mode (struct mode_data *m)\n \t and must not have components.   A float mode must have a\n          format.  */\n       validate_mode (m, OPTIONAL, SET, UNSET, UNSET,\n-\t\t     m->class == MODE_FLOAT ? SET : UNSET);\n+\t\t     m->cl == MODE_FLOAT ? SET : UNSET);\n \n       m->ncomponents = 1;\n       m->component = 0;\n@@ -370,7 +370,7 @@ complete_mode (struct mode_data *m)\n   /* If not already specified, the mode alignment defaults to the largest\n      power of two that divides the size of the object.  Complex types are\n      not more aligned than their contents.  */\n-  if (m->class == MODE_COMPLEX_INT || m->class == MODE_COMPLEX_FLOAT)\n+  if (m->cl == MODE_COMPLEX_INT || m->cl == MODE_COMPLEX_FLOAT)\n     alignment = m->component->bytesize;\n   else\n     alignment = m->bytesize;\n@@ -390,27 +390,27 @@ static void\n complete_all_modes (void)\n {\n   struct mode_data *m;\n-  enum mode_class c;\n-  \n-  for_all_modes (c, m)\n+  int cl;\n+\n+  for_all_modes (cl, m)\n     complete_mode (m);\n }\n \n /* For each mode in class CLASS, construct a corresponding complex mode.  */\n #define COMPLEX_MODES(C) make_complex_modes(MODE_##C, __FILE__, __LINE__)\n static void\n-make_complex_modes (enum mode_class class,\n+make_complex_modes (enum mode_class cl,\n \t\t    const char *file, unsigned int line)\n {\n   struct mode_data *m;\n   struct mode_data *c;\n   char buf[8];\n-  enum mode_class cclass = complex_class (class);\n+  enum mode_class cclass = complex_class (cl);\n \n   if (cclass == MODE_RANDOM)\n     return;\n-    \n-  for (m = modes[class]; m; m = m->next)\n+\n+  for (m = modes[cl]; m; m = m->next)\n     {\n       /* Skip BImode.  FIXME: BImode probably shouldn't be MODE_INT.  */\n       if (m->precision == 1)\n@@ -426,7 +426,7 @@ make_complex_modes (enum mode_class class,\n       /* Float complex modes are named SCmode, etc.\n \t Int complex modes are named CSImode, etc.\n          This inconsistency should be eliminated.  */\n-      if (class == MODE_FLOAT)\n+      if (cl == MODE_FLOAT)\n \t{\n \t  char *p;\n \t  strncpy (buf, m->name, sizeof buf);\n@@ -448,23 +448,23 @@ make_complex_modes (enum mode_class class,\n     }\n }\n \n-/* For all modes in class CLASS, construct vector modes of width\n+/* For all modes in class CL, construct vector modes of width\n    WIDTH, having as many components as necessary.  */\n #define VECTOR_MODES(C, W) make_vector_modes(MODE_##C, W, __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n-make_vector_modes (enum mode_class class, unsigned int width,\n+make_vector_modes (enum mode_class cl, unsigned int width,\n \t\t   const char *file, unsigned int line)\n {\n   struct mode_data *m;\n   struct mode_data *v;\n   char buf[8];\n   unsigned int ncomponents;\n-  enum mode_class vclass = vector_class (class);\n+  enum mode_class vclass = vector_class (cl);\n \n   if (vclass == MODE_RANDOM)\n     return;\n \n-  for (m = modes[class]; m; m = m->next)\n+  for (m = modes[cl]; m; m = m->next)\n     {\n       /* Do not construct vector modes with only one element, or\n \t vector modes where the element size doesn't divide the full\n@@ -477,9 +477,9 @@ make_vector_modes (enum mode_class class, unsigned int width,\n \n       /* Skip QFmode and BImode.  FIXME: this special case should\n \t not be necessary.  */\n-      if (class == MODE_FLOAT && m->bytesize == 1)\n+      if (cl == MODE_FLOAT && m->bytesize == 1)\n \tcontinue;\n-      if (class == MODE_INT && m->precision == 1)\n+      if (cl == MODE_INT && m->precision == 1)\n \tcontinue;\n \n       if ((size_t)snprintf (buf, sizeof buf, \"V%u%s\", ncomponents, m->name)\n@@ -503,13 +503,13 @@ make_vector_modes (enum mode_class class, unsigned int width,\n #define CC_MODE(N) _SPECIAL_MODE (CC, N)\n \n static void\n-make_special_mode (enum mode_class class, const char *name,\n+make_special_mode (enum mode_class cl, const char *name,\n \t\t   const char *file, unsigned int line)\n {\n-  new_mode (class, name, file, line);\n+  new_mode (cl, name, file, line);\n }\n \n-#define INT_MODE(N, Y) FRACTIONAL_INT_MODE (N, -1, Y)\n+#define INT_MODE(N, Y) FRACTIONAL_INT_MODE (N, -1U, Y)\n #define FRACTIONAL_INT_MODE(N, B, Y) \\\n   make_int_mode (#N, B, Y, __FILE__, __LINE__)\n \n@@ -523,7 +523,7 @@ make_int_mode (const char *name,\n   m->precision = precision;\n }\n \n-#define FLOAT_MODE(N, Y, F)             FRACTIONAL_FLOAT_MODE (N, -1, Y, F)\n+#define FLOAT_MODE(N, Y, F)             FRACTIONAL_FLOAT_MODE (N, -1U, Y, F)\n #define FRACTIONAL_FLOAT_MODE(N, B, Y, F) \\\n   make_float_mode (#N, B, Y, #F, __FILE__, __LINE__)\n \n@@ -551,7 +551,7 @@ reset_float_format (const char *name, const char *format,\n       error (\"%s:%d: no mode \\\"%s\\\"\", file, line, name);\n       return;\n     }\n-  if (m->class != MODE_FLOAT)\n+  if (m->cl != MODE_FLOAT)\n     {\n       error (\"%s:%d: mode \\\"%s\\\" is not class FLOAT\", file, line, name);\n       return;\n@@ -562,7 +562,7 @@ reset_float_format (const char *name, const char *format,\n /* Partial integer modes are specified by relation to a full integer mode.\n    For now, we do not attempt to narrow down their bit sizes.  */\n #define PARTIAL_INT_MODE(M) \\\n-  make_partial_integer_mode (#M, \"P\" #M, -1, __FILE__, __LINE__)\n+  make_partial_integer_mode (#M, \"P\" #M, -1U, __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n make_partial_integer_mode (const char *base, const char *name,\n \t\t\t   unsigned int precision,\n@@ -575,12 +575,12 @@ make_partial_integer_mode (const char *base, const char *name,\n       error (\"%s:%d: no mode \\\"%s\\\"\", file, line, name);\n       return;\n     }\n-  if (component->class != MODE_INT)\n+  if (component->cl != MODE_INT)\n     {\n       error (\"%s:%d: mode \\\"%s\\\" is not class INT\", file, line, name);\n       return;\n     }\n-  \n+\n   m = new_mode (MODE_PARTIAL_INT, name, file, line);\n   m->precision = precision;\n   m->component = component;\n@@ -608,7 +608,7 @@ make_vector_mode (enum mode_class bclass,\n       error (\"%s:%d: no mode \\\"%s\\\"\", file, line, base);\n       return;\n     }\n-  if (component->class != bclass)\n+  if (component->cl != bclass)\n     {\n       error (\"%s:%d: mode \\\"%s\\\" is not class %s\",\n \t     file, line, base, mode_class_names[bclass] + 5);\n@@ -692,7 +692,7 @@ cmp_modes (const void *a, const void *b)\n static void\n calc_wider_mode (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n   struct mode_data **sortbuf;\n   unsigned int max_n_modes = 0;\n@@ -765,7 +765,7 @@ calc_wider_mode (void)\n static void\n emit_insn_modes_h (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m, *first, *last;\n \n   printf (\"/* Generated automatically from machmode.def%s%s\\n\",\n@@ -866,7 +866,7 @@ emit_min_insn_modes_c_header (void)\n static void\n emit_mode_name (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"char *const\", \"mode_name\", \"NUM_MACHINE_MODES\");\n@@ -880,21 +880,21 @@ emit_mode_name (void)\n static void\n emit_mode_class (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"unsigned char\", \"mode_class\", \"NUM_MACHINE_MODES\");\n \n   for_all_modes (c, m)\n-    tagged_printf (\"%s\", mode_class_names[m->class], m->name);\n+    tagged_printf (\"%s\", mode_class_names[m->cl], m->name);\n \n   print_closer ();\n }\n \n static void\n emit_mode_precision (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"unsigned short\", \"mode_precision\", \"NUM_MACHINE_MODES\");\n@@ -911,7 +911,7 @@ emit_mode_precision (void)\n static void\n emit_mode_size (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_maybe_const_decl (\"%sunsigned char\", \"mode_size\",\n@@ -926,7 +926,7 @@ emit_mode_size (void)\n static void\n emit_mode_nunits (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"unsigned char\", \"mode_nunits\", \"NUM_MACHINE_MODES\");\n@@ -940,7 +940,7 @@ emit_mode_nunits (void)\n static void\n emit_mode_wider (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"unsigned char\", \"mode_wider\", \"NUM_MACHINE_MODES\");\n@@ -956,7 +956,7 @@ emit_mode_wider (void)\n static void\n emit_mode_mask (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"unsigned HOST_WIDE_INT\", \"mode_mask_array\",\n@@ -980,7 +980,7 @@ emit_mode_mask (void)\n static void\n emit_mode_inner (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_decl (\"unsigned char\", \"mode_inner\", \"NUM_MACHINE_MODES\");\n@@ -996,7 +996,7 @@ emit_mode_inner (void)\n static void\n emit_mode_base_align (void)\n {\n-  enum mode_class c;\n+  int c;\n   struct mode_data *m;\n \n   print_maybe_const_decl (\"%sunsigned char\",\n@@ -1012,7 +1012,7 @@ emit_mode_base_align (void)\n static void\n emit_class_narrowest_mode (void)\n {\n-  enum mode_class c;\n+  int c;\n \n   print_decl (\"unsigned char\", \"class_narrowest_mode\", \"MAX_MODE_CLASS\");\n \n@@ -1084,7 +1084,7 @@ emit_mode_adjustments (void)\n \n       for (m = a->mode->contained; m; m = m->next_cont)\n \t{\n-\t  switch (m->class)\n+\t  switch (m->cl)\n \t    {\n \t    case MODE_COMPLEX_INT:\n \t    case MODE_COMPLEX_FLOAT:\n@@ -1120,7 +1120,7 @@ emit_mode_adjustments (void)\n \n       for (m = a->mode->contained; m; m = m->next_cont)\n \t{\n-\t  switch (m->class)\n+\t  switch (m->cl)\n \t    {\n \t    case MODE_COMPLEX_INT:\n \t    case MODE_COMPLEX_FLOAT:"}, {"sha": "2eb2019399f7454e2f608bc8ede3da29ee6d09ee", "filename": "gcc/real.c", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -138,7 +138,7 @@ static inline void\n get_canonical_qnan (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n-  r->class = rvc_nan;\n+  r->cl = rvc_nan;\n   r->sign = sign;\n   r->canonical = 1;\n }\n@@ -147,7 +147,7 @@ static inline void\n get_canonical_snan (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n-  r->class = rvc_nan;\n+  r->cl = rvc_nan;\n   r->sign = sign;\n   r->signalling = 1;\n   r->canonical = 1;\n@@ -157,7 +157,7 @@ static inline void\n get_inf (REAL_VALUE_TYPE *r, int sign)\n {\n   memset (r, 0, sizeof (*r));\n-  r->class = rvc_inf;\n+  r->cl = rvc_inf;\n   r->sign = sign;\n }\n \n@@ -490,7 +490,7 @@ normalize (REAL_VALUE_TYPE *r)\n   /* Zero significand flushes to zero.  */\n   if (i < 0)\n     {\n-      r->class = rvc_zero;\n+      r->cl = rvc_zero;\n       SET_REAL_EXP (r, 0);\n       return;\n     }\n@@ -531,7 +531,7 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n   sign = a->sign;\n   subtract_p = (sign ^ b->sign) ^ subtract_p;\n \n-  switch (CLASS2 (a->class, b->class))\n+  switch (CLASS2 (a->cl, b->cl))\n     {\n     case CLASS2 (rvc_zero, rvc_zero):\n       /* -0 + -0 = -0, -0 - +0 = -0; all other cases yield +0.  */\n@@ -637,7 +637,7 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \t}\n     }\n \n-  r->class = rvc_normal;\n+  r->cl = rvc_normal;\n   r->sign = sign;\n   SET_REAL_EXP (r, exp);\n \n@@ -646,7 +646,7 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \n   /* Special case: if the subtraction results in zero, the result\n      is positive.  */\n-  if (r->class == rvc_zero)\n+  if (r->cl == rvc_zero)\n     r->sign = 0;\n   else\n     r->sig[0] |= inexact;\n@@ -665,7 +665,7 @@ do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n   int sign = a->sign ^ b->sign;\n   bool inexact = false;\n \n-  switch (CLASS2 (a->class, b->class))\n+  switch (CLASS2 (a->cl, b->cl))\n     {\n     case CLASS2 (rvc_zero, rvc_zero):\n     case CLASS2 (rvc_zero, rvc_normal):\n@@ -764,7 +764,7 @@ do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \t    }\n \n \t  memset (&u, 0, sizeof (u));\n-\t  u.class = rvc_normal;\n+\t  u.cl = rvc_normal;\n \t  SET_REAL_EXP (&u, exp);\n \n \t  for (k = j; k < SIGSZ * 2; k += 2)\n@@ -800,7 +800,7 @@ do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n   REAL_VALUE_TYPE t, *rr;\n   bool inexact;\n \n-  switch (CLASS2 (a->class, b->class))\n+  switch (CLASS2 (a->cl, b->cl))\n     {\n     case CLASS2 (rvc_zero, rvc_zero):\n       /* 0 / 0 = NaN.  */\n@@ -860,7 +860,7 @@ do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n \n   /* Make sure all fields in the result are initialized.  */\n   get_zero (rr, 0);\n-  rr->class = rvc_normal;\n+  rr->cl = rvc_normal;\n   rr->sign = sign;\n \n   exp = REAL_EXP (a) - REAL_EXP (b) + 1;\n@@ -897,7 +897,7 @@ do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n {\n   int ret;\n \n-  switch (CLASS2 (a->class, b->class))\n+  switch (CLASS2 (a->cl, b->cl))\n     {\n     case CLASS2 (rvc_zero, rvc_zero):\n       /* Sign of zero doesn't matter for compares.  */\n@@ -952,7 +952,7 @@ do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n {\n   *r = *a;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n     case rvc_inf:\n@@ -999,7 +999,7 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n       break;\n \n     case MIN_EXPR:\n-      if (op1->class == rvc_nan)\n+      if (op1->cl == rvc_nan)\n \t*r = *op1;\n       else if (do_compare (op0, op1, -1) < 0)\n \t*r = *op0;\n@@ -1008,7 +1008,7 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n       break;\n \n     case MAX_EXPR:\n-      if (op1->class == rvc_nan)\n+      if (op1->cl == rvc_nan)\n \t*r = *op1;\n       else if (do_compare (op0, op1, 1) < 0)\n \t*r = *op1;\n@@ -1067,9 +1067,9 @@ real_compare (int icode, const REAL_VALUE_TYPE *op0,\n     case NE_EXPR:\n       return do_compare (op0, op1, -1) != 0;\n     case UNORDERED_EXPR:\n-      return op0->class == rvc_nan || op1->class == rvc_nan;\n+      return op0->cl == rvc_nan || op1->cl == rvc_nan;\n     case ORDERED_EXPR:\n-      return op0->class != rvc_nan && op1->class != rvc_nan;\n+      return op0->cl != rvc_nan && op1->cl != rvc_nan;\n     case UNLT_EXPR:\n       return do_compare (op0, op1, -1) < 0;\n     case UNLE_EXPR:\n@@ -1093,7 +1093,7 @@ real_compare (int icode, const REAL_VALUE_TYPE *op0,\n int\n real_exponent (const REAL_VALUE_TYPE *r)\n {\n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       return 0;\n@@ -1113,7 +1113,7 @@ void\n real_ldexp (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0, int exp)\n {\n   *r = *op0;\n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n     case rvc_inf:\n@@ -1140,15 +1140,15 @@ real_ldexp (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0, int exp)\n bool\n real_isinf (const REAL_VALUE_TYPE *r)\n {\n-  return (r->class == rvc_inf);\n+  return (r->cl == rvc_inf);\n }\n \n /* Determine whether a floating-point value X is a NaN.  */\n \n bool\n real_isnan (const REAL_VALUE_TYPE *r)\n {\n-  return (r->class == rvc_nan);\n+  return (r->cl == rvc_nan);\n }\n \n /* Determine whether a floating-point value X is negative.  */\n@@ -1164,7 +1164,7 @@ real_isneg (const REAL_VALUE_TYPE *r)\n bool\n real_isnegzero (const REAL_VALUE_TYPE *r)\n {\n-  return r->sign && r->class == rvc_zero;\n+  return r->sign && r->cl == rvc_zero;\n }\n \n /* Compare two floating-point objects for bitwise identity.  */\n@@ -1174,12 +1174,12 @@ real_identical (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n {\n   int i;\n \n-  if (a->class != b->class)\n+  if (a->cl != b->cl)\n     return false;\n   if (a->sign != b->sign)\n     return false;\n \n-  switch (a->class)\n+  switch (a->cl)\n     {\n     case rvc_zero:\n     case rvc_inf:\n@@ -1219,7 +1219,7 @@ exact_real_inverse (enum machine_mode mode, REAL_VALUE_TYPE *r)\n   REAL_VALUE_TYPE u;\n   int i;\n \n-  if (r->class != rvc_normal)\n+  if (r->cl != rvc_normal)\n     return false;\n \n   /* Check for a power of two: all significand bits zero except the MSB.  */\n@@ -1234,7 +1234,7 @@ exact_real_inverse (enum machine_mode mode, REAL_VALUE_TYPE *r)\n   real_convert (&u, mode, &u);\n \n   /* The rounding may have overflowed.  */\n-  if (u.class != rvc_normal)\n+  if (u.cl != rvc_normal)\n     return false;\n   for (i = 0; i < SIGSZ-1; ++i)\n     if (u.sig[i] != 0)\n@@ -1253,7 +1253,7 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n {\n   unsigned HOST_WIDE_INT i;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n     underflow:\n@@ -1309,7 +1309,7 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n   HOST_WIDE_INT low, high;\n   int exp;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n     underflow:\n@@ -1431,7 +1431,7 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n   bool sign;\n \n   r = *r_orig;\n-  switch (r.class)\n+  switch (r.cl)\n     {\n     case rvc_zero:\n       strcpy (str, (r.sign ? \"-0.0\" : \"0.0\"));\n@@ -1698,7 +1698,7 @@ real_to_hexadecimal (char *str, const REAL_VALUE_TYPE *r, size_t buf_size,\n   char exp_buf[16];\n   size_t max_digits;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       exp = 0;\n@@ -1851,7 +1851,7 @@ real_from_string (REAL_VALUE_TYPE *r, const char *str)\n \t  exp += d;\n \t}\n \n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       SET_REAL_EXP (r, exp);\n \n       normalize (r);\n@@ -1874,7 +1874,7 @@ real_from_string (REAL_VALUE_TYPE *r, const char *str)\n       if (*str == '.')\n \t{\n \t  str++;\n-\t  if (r->class == rvc_zero)\n+\t  if (r->cl == rvc_zero)\n \t    {\n \t      while (*str == '0')\n \t\tstr++, exp--;\n@@ -1963,7 +1963,7 @@ real_from_integer (REAL_VALUE_TYPE *r, enum machine_mode mode,\n     get_zero (r, 0);\n   else\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = high < 0 && !unsigned_p;\n       SET_REAL_EXP (r, 2 * HOST_BITS_PER_WIDE_INT);\n \n@@ -2011,7 +2011,7 @@ ten_to_ptwo (int n)\n   if (n < 0 || n >= EXP_BITS)\n     abort ();\n \n-  if (tens[n].class == rvc_zero)\n+  if (tens[n].cl == rvc_zero)\n     {\n       if (n < (HOST_BITS_PER_WIDE_INT == 64 ? 5 : 4))\n \t{\n@@ -2043,7 +2043,7 @@ ten_to_mptwo (int n)\n   if (n < 0 || n >= EXP_BITS)\n     abort ();\n \n-  if (tens[n].class == rvc_zero)\n+  if (tens[n].cl == rvc_zero)\n     do_divide (&tens[n], real_digit (1), ten_to_ptwo (n));\n \n   return &tens[n];\n@@ -2059,7 +2059,7 @@ real_digit (int n)\n   if (n < 0 || n > 9)\n     abort ();\n \n-  if (n > 0 && num[n].class == rvc_zero)\n+  if (n > 0 && num[n].cl == rvc_zero)\n     real_from_integer (&num[n], VOIDmode, n, 0, 1);\n \n   return &num[n];\n@@ -2127,7 +2127,7 @@ real_nan (REAL_VALUE_TYPE *r, const char *str, int quiet,\n       bool neg = false;\n \n       memset (r, 0, sizeof (*r));\n-      r->class = rvc_nan;\n+      r->cl = rvc_nan;\n \n       /* Parse akin to strtol into the significand of R.  */\n \n@@ -2204,7 +2204,7 @@ real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n   if (fmt == NULL)\n     abort ();\n \n-  r->class = rvc_normal;\n+  r->cl = rvc_normal;\n   r->sign = sign;\n   r->signalling = 0;\n   r->canonical = 0;\n@@ -2224,12 +2224,12 @@ real_2expN (REAL_VALUE_TYPE *r, int n)\n \n   n++;\n   if (n > MAX_EXP)\n-    r->class = rvc_inf;\n+    r->cl = rvc_inf;\n   else if (n < -MAX_EXP)\n     ;\n   else\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       SET_REAL_EXP (r, n);\n       r->sig[SIGSZ-1] = SIG_MSB;\n     }\n@@ -2249,7 +2249,7 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n   emax2 = fmt->emax * fmt->log2_b;\n \n   np2 = SIGNIFICAND_BITS - p2;\n-  switch (r->class)\n+  switch (r->cl)\n     {\n     underflow:\n       get_zero (r, r->sign);\n@@ -2382,7 +2382,7 @@ real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode,\n   round_for_format (fmt, r);\n \n   /* round_for_format de-normalizes denormals.  Undo just that part.  */\n-  if (r->class == rvc_normal)\n+  if (r->cl == rvc_normal)\n     normalize (r);\n }\n \n@@ -2493,8 +2493,8 @@ real_hash (const REAL_VALUE_TYPE *r)\n   unsigned int h;\n   size_t i;\n \n-  h = r->class | (r->sign << 2);\n-  switch (r->class)\n+  h = r->cl | (r->sign << 2);\n+  switch (r->cl)\n     {\n     case rvc_zero:\n     case rvc_inf:\n@@ -2546,7 +2546,7 @@ encode_ieee_single (const struct real_format *fmt, long *buf,\n   image = sign << 31;\n   sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 24)) & 0x7fffff;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       break;\n@@ -2618,7 +2618,7 @@ decode_ieee_single (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if (image && fmt->has_denorm)\n \t{\n-\t  r->class = rvc_normal;\n+\t  r->cl = rvc_normal;\n \t  r->sign = sign;\n \t  SET_REAL_EXP (r, -126);\n \t  r->sig[SIGSZ-1] = image << 1;\n@@ -2631,21 +2631,21 @@ decode_ieee_single (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if (image)\n \t{\n-\t  r->class = rvc_nan;\n+\t  r->cl = rvc_nan;\n \t  r->sign = sign;\n \t  r->signalling = (((image >> (HOST_BITS_PER_LONG - 2)) & 1)\n \t\t\t   ^ fmt->qnan_msb_set);\n \t  r->sig[SIGSZ-1] = image;\n \t}\n       else\n \t{\n-\t  r->class = rvc_inf;\n+\t  r->cl = rvc_inf;\n \t  r->sign = sign;\n \t}\n     }\n   else\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = sign;\n       SET_REAL_EXP (r, exp - 127 + 1);\n       r->sig[SIGSZ-1] = image | SIG_MSB;\n@@ -2720,7 +2720,7 @@ encode_ieee_double (const struct real_format *fmt, long *buf,\n       sig_hi = (sig_hi >> 11) & 0xfffff;\n     }\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       break;\n@@ -2819,7 +2819,7 @@ decode_ieee_double (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if ((image_hi || image_lo) && fmt->has_denorm)\n \t{\n-\t  r->class = rvc_normal;\n+\t  r->cl = rvc_normal;\n \t  r->sign = sign;\n \t  SET_REAL_EXP (r, -1022);\n \t  if (HOST_BITS_PER_LONG == 32)\n@@ -2843,7 +2843,7 @@ decode_ieee_double (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if (image_hi || image_lo)\n \t{\n-\t  r->class = rvc_nan;\n+\t  r->cl = rvc_nan;\n \t  r->sign = sign;\n \t  r->signalling = ((image_hi >> 30) & 1) ^ fmt->qnan_msb_set;\n \t  if (HOST_BITS_PER_LONG == 32)\n@@ -2856,13 +2856,13 @@ decode_ieee_double (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t}\n       else\n \t{\n-\t  r->class = rvc_inf;\n+\t  r->cl = rvc_inf;\n \t  r->sign = sign;\n \t}\n     }\n   else\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = sign;\n       SET_REAL_EXP (r, exp - 1023 + 1);\n       if (HOST_BITS_PER_LONG == 32)\n@@ -2930,7 +2930,7 @@ encode_ieee_extended (const struct real_format *fmt, long *buf,\n   image_hi = r->sign << 15;\n   sig_hi = sig_lo = 0;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       break;\n@@ -3108,7 +3108,7 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if ((sig_hi || sig_lo) && fmt->has_denorm)\n \t{\n-\t  r->class = rvc_normal;\n+\t  r->cl = rvc_normal;\n \t  r->sign = sign;\n \n \t  /* When the IEEE format contains a hidden bit, we know that\n@@ -3139,7 +3139,7 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \n       if (sig_hi || sig_lo)\n \t{\n-\t  r->class = rvc_nan;\n+\t  r->cl = rvc_nan;\n \t  r->sign = sign;\n \t  r->signalling = ((sig_hi >> 30) & 1) ^ fmt->qnan_msb_set;\n \t  if (HOST_BITS_PER_LONG == 32)\n@@ -3152,13 +3152,13 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t}\n       else\n \t{\n-\t  r->class = rvc_inf;\n+\t  r->cl = rvc_inf;\n \t  r->sign = sign;\n \t}\n     }\n   else\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = sign;\n       SET_REAL_EXP (r, exp - 16383 + 1);\n       if (HOST_BITS_PER_LONG == 32)\n@@ -3322,15 +3322,15 @@ encode_ibm_extended (const struct real_format *fmt, long *buf,\n \n   /* Renormlize R before doing any arithmetic on it.  */\n   normr = *r;\n-  if (normr.class == rvc_normal)\n+  if (normr.cl == rvc_normal)\n     normalize (&normr);\n \n   /* u = IEEE double precision portion of significand.  */\n   u = normr;\n   round_for_format (base_fmt, &u);\n   encode_ieee_double (base_fmt, &buf[0], &u);\n \n-  if (u.class == rvc_normal)\n+  if (u.cl == rvc_normal)\n     {\n       do_add (&v, &normr, &u, 1);\n       /* Call round_for_format since we might need to denormalize.  */\n@@ -3356,7 +3356,7 @@ decode_ibm_extended (const struct real_format *fmt ATTRIBUTE_UNUSED, REAL_VALUE_\n   base_fmt = fmt->qnan_msb_set ? &ieee_double_format : &mips_double_format;\n   decode_ieee_double (base_fmt, &u, &buf[0]);\n \n-  if (u.class != rvc_zero && u.class != rvc_inf && u.class != rvc_nan)\n+  if (u.cl != rvc_zero && u.cl != rvc_inf && u.cl != rvc_nan)\n     {\n       decode_ieee_double (base_fmt, &v, &buf[2]);\n       do_add (r, &u, &v, 0);\n@@ -3424,7 +3424,7 @@ encode_ieee_quad (const struct real_format *fmt, long *buf,\n \n   rshift_significand (&u, r, SIGNIFICAND_BITS - 113);\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       break;\n@@ -3576,7 +3576,7 @@ decode_ieee_quad (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if ((image3 | image2 | image1 | image0) && fmt->has_denorm)\n \t{\n-\t  r->class = rvc_normal;\n+\t  r->cl = rvc_normal;\n \t  r->sign = sign;\n \n \t  SET_REAL_EXP (r, -16382 + (SIGNIFICAND_BITS - 112));\n@@ -3602,7 +3602,7 @@ decode_ieee_quad (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     {\n       if (image3 | image2 | image1 | image0)\n \t{\n-\t  r->class = rvc_nan;\n+\t  r->cl = rvc_nan;\n \t  r->sign = sign;\n \t  r->signalling = ((image3 >> 15) & 1) ^ fmt->qnan_msb_set;\n \n@@ -3622,13 +3622,13 @@ decode_ieee_quad (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t}\n       else\n \t{\n-\t  r->class = rvc_inf;\n+\t  r->cl = rvc_inf;\n \t  r->sign = sign;\n \t}\n     }\n   else\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = sign;\n       SET_REAL_EXP (r, exp - 16383 + 1);\n \n@@ -3716,7 +3716,7 @@ encode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n \n   sign = r->sign << 15;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       image = 0;\n@@ -3755,7 +3755,7 @@ decode_vax_f (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp != 0)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = (image >> 15) & 1;\n       SET_REAL_EXP (r, exp - 128);\n \n@@ -3770,7 +3770,7 @@ encode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n {\n   unsigned long image0, image1, sign = r->sign << 15;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       image0 = image1 = 0;\n@@ -3838,7 +3838,7 @@ decode_vax_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp != 0)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = (image0 >> 15) & 1;\n       SET_REAL_EXP (r, exp - 128);\n \n@@ -3870,7 +3870,7 @@ encode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n {\n   unsigned long image0, image1, sign = r->sign << 15;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       image0 = image1 = 0;\n@@ -3938,7 +3938,7 @@ decode_vax_g (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp != 0)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = (image0 >> 15) & 1;\n       SET_REAL_EXP (r, exp - 1024);\n \n@@ -4042,7 +4042,7 @@ encode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   sign = r->sign << 31;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       image = 0;\n@@ -4081,7 +4081,7 @@ decode_i370_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp || sig)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = sign;\n       SET_REAL_EXP (r, (exp - 64) * 4);\n       r->sig[SIGSZ-1] = sig << (HOST_BITS_PER_LONG - 24);\n@@ -4097,7 +4097,7 @@ encode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   sign = r->sign << 31;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       image_hi = image_lo = 0;\n@@ -4159,7 +4159,7 @@ decode_i370_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp || image_hi || image_lo)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n       r->sign = sign;\n       SET_REAL_EXP (r, (exp - 64) * 4 + (SIGNIFICAND_BITS - 56));\n \n@@ -4245,7 +4245,7 @@ encode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n {\n   unsigned long image, exp, sig;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       exp = -128;\n@@ -4294,7 +4294,7 @@ decode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp != -128)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n \n       sig = sf & 0x7fffff;\n       if (sf < 0)\n@@ -4318,7 +4318,7 @@ encode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n {\n   unsigned long exp, sig;\n \n-  switch (r->class)\n+  switch (r->cl)\n     {\n     case rvc_zero:\n       exp = -128;\n@@ -4381,7 +4381,7 @@ decode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \n   if (exp != -128)\n     {\n-      r->class = rvc_normal;\n+      r->cl = rvc_normal;\n \n       sig = sf & 0x7fffffff;\n       if (sf < 0)"}, {"sha": "c477be11b62e971fc35ed98778b1c8443dfe6b3b", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -45,7 +45,7 @@ struct real_value GTY(())\n   /* Use the same underlying type for all bit-fields, so as to make\n      sure they're packed together, otherwise REAL_VALUE_TYPE_SIZE will\n      be miscomputed.  */\n-  unsigned int /* ENUM_BITFIELD (real_value_class) */ class : 2;\n+  unsigned int /* ENUM_BITFIELD (real_value_class) */ cl : 2;\n   unsigned int sign : 1;\n   unsigned int signalling : 1;\n   unsigned int canonical : 1;"}, {"sha": "82fb12ec429e74be56ca9ce4b627662033908657", "filename": "gcc/recog.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -2096,7 +2096,7 @@ preprocess_constraints (void)\n \n       for (j = 0; j < recog_data.n_alternatives; j++)\n \t{\n-\t  op_alt[j].class = NO_REGS;\n+\t  op_alt[j].cl = NO_REGS;\n \t  op_alt[j].constraint = p;\n \t  op_alt[j].matches = -1;\n \t  op_alt[j].matched = -1;\n@@ -2171,12 +2171,14 @@ preprocess_constraints (void)\n \n \t\tcase 'p':\n \t\t  op_alt[j].is_address = 1;\n-\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class]\n+\t\t  op_alt[j].cl = reg_class_subunion[(int) op_alt[j].cl]\n \t\t    [(int) MODE_BASE_REG_CLASS (VOIDmode)];\n \t\t  break;\n \n-\t\tcase 'g': case 'r':\n-\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) GENERAL_REGS];\n+\t\tcase 'g':\n+\t\tcase 'r':\n+\t\t  op_alt[j].cl =\n+\t\t   reg_class_subunion[(int) op_alt[j].cl][(int) GENERAL_REGS];\n \t\t  break;\n \n \t\tdefault:\n@@ -2188,16 +2190,16 @@ preprocess_constraints (void)\n \t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    {\n \t\t      op_alt[j].is_address = 1;\n-\t\t      op_alt[j].class\n+\t\t      op_alt[j].cl\n \t\t\t= (reg_class_subunion\n-\t\t\t   [(int) op_alt[j].class]\n+\t\t\t   [(int) op_alt[j].cl]\n \t\t\t   [(int) MODE_BASE_REG_CLASS (VOIDmode)]);\n \t\t      break;\n \t\t    }\n \n-\t\t  op_alt[j].class\n+\t\t  op_alt[j].cl\n \t\t    = (reg_class_subunion\n-\t\t       [(int) op_alt[j].class]\n+\t\t       [(int) op_alt[j].cl]\n \t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n \t\t  break;\n \t\t}\n@@ -2518,19 +2520,19 @@ constrain_operands (int strict)\n \n \t      default:\n \t\t{\n-\t\t  enum reg_class class;\n+\t\t  enum reg_class cl;\n \n-\t\t  class = (c == 'r'\n+\t\t  cl = (c == 'r'\n \t\t\t   ? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, p));\n-\t\t  if (class != NO_REGS)\n+\t\t  if (cl != NO_REGS)\n \t\t    {\n \t\t      if (strict < 0\n \t\t\t  || (strict == 0\n \t\t\t      && REG_P (op)\n \t\t\t      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t\t  || (strict == 0 && GET_CODE (op) == SCRATCH)\n \t\t\t  || (REG_P (op)\n-\t\t\t      && reg_fits_class_p (op, class, offset, mode)))\n+\t\t\t      && reg_fits_class_p (op, cl, offset, mode)))\n \t\t        win = 1;\n \t\t    }\n #ifdef EXTRA_CONSTRAINT_STR\n@@ -2623,19 +2625,19 @@ constrain_operands (int strict)\n    If REG occupies multiple hard regs, all of them must be in CLASS.  */\n \n int\n-reg_fits_class_p (rtx operand, enum reg_class class, int offset,\n+reg_fits_class_p (rtx operand, enum reg_class cl, int offset,\n \t\t  enum machine_mode mode)\n {\n   int regno = REGNO (operand);\n   if (regno < FIRST_PSEUDO_REGISTER\n-      && TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+      && TEST_HARD_REG_BIT (reg_class_contents[(int) cl],\n \t\t\t    regno + offset))\n     {\n       int sr;\n       regno += offset;\n       for (sr = hard_regno_nregs[regno][mode] - 1;\n \t   sr > 0; sr--)\n-\tif (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\tif (! TEST_HARD_REG_BIT (reg_class_contents[(int) cl],\n \t\t\t\t regno + sr))\n \t  break;\n       return sr == 0;\n@@ -2898,7 +2900,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n \t\t\t  enum machine_mode mode, HARD_REG_SET *reg_set)\n {\n   static int search_ofs;\n-  enum reg_class class;\n+  enum reg_class cl;\n   HARD_REG_SET live;\n   int i;\n \n@@ -2928,7 +2930,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n       IOR_HARD_REG_SET (live, this_live);\n     }\n \n-  class = (class_str[0] == 'r' ? GENERAL_REGS\n+  cl = (class_str[0] == 'r' ? GENERAL_REGS\n \t   : REG_CLASS_FROM_CONSTRAINT (class_str[0], class_str));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -2949,7 +2951,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n       if (fixed_regs[regno])\n \tcontinue;\n       /* Make sure the register is of the right class.  */\n-      if (! TEST_HARD_REG_BIT (reg_class_contents[class], regno))\n+      if (! TEST_HARD_REG_BIT (reg_class_contents[cl], regno))\n \tcontinue;\n       /* And can support the mode we need.  */\n       if (! HARD_REGNO_MODE_OK (regno, mode))"}, {"sha": "28db9aa07f4c6c6b0bfb9b8e7d6afadab748f89f", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -38,7 +38,7 @@ struct operand_alternative\n   const char *constraint;\n \n   /* The register class valid for this alternative (possibly NO_REGS).  */\n-  enum reg_class class;\n+  enum reg_class cl;\n \n   /* \"Badness\" of this alternative, computed from number of '?' and '!'\n      characters in the constraint string.  */"}, {"sha": "e21f11bbcc420b42f25ff25b89564d9b19835b73", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -667,7 +667,7 @@ check_asm_stack_operands (rtx insn)\n   for (i = 0; i < n_outputs; i++)\n     if (STACK_REG_P (recog_data.operand[i]))\n       {\n-\tif (reg_class_size[(int) recog_op_alt[i][alt].class] != 1)\n+\tif (reg_class_size[(int) recog_op_alt[i][alt].cl] != 1)\n \t  {\n \t    error_for_asm (insn, \"output constraint %d must specify a single register\", i);\n \t    malformed_asm = 1;\n@@ -2147,9 +2147,9 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n     if (STACK_REG_P (recog_data.operand[i])\n-\t&& reg_class_subset_p (recog_op_alt[i][alt].class,\n+\t&& reg_class_subset_p (recog_op_alt[i][alt].cl,\n \t\t\t       FLOAT_REGS)\n-\t&& recog_op_alt[i][alt].class != FLOAT_REGS)\n+\t&& recog_op_alt[i][alt].cl != FLOAT_REGS)\n       {\n \t/* If an operand needs to be in a particular reg in\n \t   FLOAT_REGS, the constraint was either 't' or 'u'.  Since"}, {"sha": "7168d4c9bc66dbc3e363d660c351c2d854778009", "filename": "gcc/regrename.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -51,7 +51,7 @@ struct du_chain\n \n   rtx insn;\n   rtx *loc;\n-  ENUM_BITFIELD(reg_class) class : 16;\n+  ENUM_BITFIELD(reg_class) cl : 16;\n   unsigned int need_caller_save_reg:1;\n   unsigned int earlyclobber:1;\n };\n@@ -270,13 +270,13 @@ regrename_optimize (void)\n \t    {\n \t      n_uses++;\n \t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n-\t\t\t\t      reg_class_contents[last->class]);\n+\t\t\t\t      reg_class_contents[last->cl]);\n \t    }\n \t  if (n_uses < 1)\n \t    continue;\n \n \t  IOR_COMPL_HARD_REG_SET (this_unavailable,\n-\t\t\t\t  reg_class_contents[last->class]);\n+\t\t\t\t  reg_class_contents[last->cl]);\n \n \t  if (this->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n@@ -385,7 +385,7 @@ static struct du_chain *open_chains;\n static struct du_chain *closed_chains;\n \n static void\n-scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n+scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t      enum scan_actions action, enum op_type type, int earlyclobber)\n {\n   struct du_chain **p;\n@@ -404,7 +404,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n \t  this->next_chain = open_chains;\n \t  this->loc = loc;\n \t  this->insn = insn;\n-\t  this->class = class;\n+\t  this->cl = cl;\n \t  this->need_caller_save_reg = 0;\n \t  this->earlyclobber = earlyclobber;\n \t  open_chains = this;\n@@ -451,14 +451,14 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n \t\t EXTRA_CONSTRAINTS to match registers.  Which is arguably\n \t\t wrong, but there we are.  Since we know not what this may\n \t\t be replaced with, terminate the chain.  */\n-\t      if (class != NO_REGS)\n+\t      if (cl != NO_REGS)\n \t\t{\n \t\t  this = obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n \t\t  this->next_use = 0;\n \t\t  this->next_chain = (*p)->next_chain;\n \t\t  this->loc = loc;\n \t\t  this->insn = insn;\n-\t\t  this->class = class;\n+\t\t  this->cl = cl;\n \t\t  this->need_caller_save_reg = 0;\n \t\t  while (*p)\n \t\t    p = &(*p)->next_use;\n@@ -502,11 +502,11 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n     }\n }\n \n-/* Adapted from find_reloads_address_1.  CLASS is INDEX_REG_CLASS or\n+/* Adapted from find_reloads_address_1.  CL is INDEX_REG_CLASS or\n    BASE_REG_CLASS depending on how the register is being considered.  */\n \n static void\n-scan_rtx_address (rtx insn, rtx *loc, enum reg_class class,\n+scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \t\t  enum scan_actions action, enum machine_mode mode)\n {\n   rtx x = *loc;\n@@ -620,7 +620,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class class,\n       return;\n \n     case REG:\n-      scan_rtx_reg (insn, loc, class, action, OP_IN, 0);\n+      scan_rtx_reg (insn, loc, cl, action, OP_IN, 0);\n       return;\n \n     default:\n@@ -631,15 +631,15 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class class,\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tscan_rtx_address (insn, &XEXP (x, i), class, action, mode);\n+\tscan_rtx_address (insn, &XEXP (x, i), cl, action, mode);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  scan_rtx_address (insn, &XVECEXP (x, i, j), class, action, mode);\n+\t  scan_rtx_address (insn, &XVECEXP (x, i, j), cl, action, mode);\n     }\n }\n \n static void\n-scan_rtx (rtx insn, rtx *loc, enum reg_class class,\n+scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n \t  enum scan_actions action, enum op_type type, int earlyclobber)\n {\n   const char *fmt;\n@@ -661,7 +661,7 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class class,\n       return;\n \n     case REG:\n-      scan_rtx_reg (insn, loc, class, action, type, earlyclobber);\n+      scan_rtx_reg (insn, loc, cl, action, type, earlyclobber);\n       return;\n \n     case MEM:\n@@ -671,20 +671,20 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class class,\n       return;\n \n     case SET:\n-      scan_rtx (insn, &SET_SRC (x), class, action, OP_IN, 0);\n-      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT, 0);\n+      scan_rtx (insn, &SET_SRC (x), cl, action, OP_IN, 0);\n+      scan_rtx (insn, &SET_DEST (x), cl, action, OP_OUT, 0);\n       return;\n \n     case STRICT_LOW_PART:\n-      scan_rtx (insn, &XEXP (x, 0), class, action, OP_INOUT, earlyclobber);\n+      scan_rtx (insn, &XEXP (x, 0), cl, action, OP_INOUT, earlyclobber);\n       return;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n-      scan_rtx (insn, &XEXP (x, 0), class, action,\n+      scan_rtx (insn, &XEXP (x, 0), cl, action,\n \t\ttype == OP_IN ? OP_IN : OP_INOUT, earlyclobber);\n-      scan_rtx (insn, &XEXP (x, 1), class, action, OP_IN, 0);\n-      scan_rtx (insn, &XEXP (x, 2), class, action, OP_IN, 0);\n+      scan_rtx (insn, &XEXP (x, 1), cl, action, OP_IN, 0);\n+      scan_rtx (insn, &XEXP (x, 2), cl, action, OP_IN, 0);\n       return;\n \n     case POST_INC:\n@@ -697,13 +697,13 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class class,\n       abort ();\n \n     case CLOBBER:\n-      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT, 1);\n+      scan_rtx (insn, &SET_DEST (x), cl, action, OP_OUT, 1);\n       return;\n \n     case EXPR_LIST:\n-      scan_rtx (insn, &XEXP (x, 0), class, action, type, 0);\n+      scan_rtx (insn, &XEXP (x, 0), cl, action, type, 0);\n       if (XEXP (x, 1))\n-\tscan_rtx (insn, &XEXP (x, 1), class, action, type, 0);\n+\tscan_rtx (insn, &XEXP (x, 1), cl, action, type, 0);\n       return;\n \n     default:\n@@ -714,10 +714,10 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class class,\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tscan_rtx (insn, &XEXP (x, i), class, action, type, 0);\n+\tscan_rtx (insn, &XEXP (x, i), cl, action, type, 0);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  scan_rtx (insn, &XVECEXP (x, i, j), class, action, type, 0);\n+\t  scan_rtx (insn, &XVECEXP (x, i, j), cl, action, type, 0);\n     }\n }\n \n@@ -775,7 +775,7 @@ build_def_use (basic_block bb)\n \t    {\n \t      int matches = recog_op_alt[i][alt].matches;\n \t      if (matches >= 0)\n-\t\trecog_op_alt[i][alt].class = recog_op_alt[matches][alt].class;\n+\t\trecog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n \t      if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n \t          || (predicated && recog_data.operand_type[i] == OP_OUT))\n \t\trecog_data.operand_type[i] = OP_INOUT;\n@@ -850,7 +850,7 @@ build_def_use (basic_block bb)\n \t      rtx *loc = (i < n_ops\n \t\t\t  ? recog_data.operand_loc[opn]\n \t\t\t  : recog_data.dup_loc[i - n_ops]);\n-\t      enum reg_class class = recog_op_alt[opn][alt].class;\n+\t      enum reg_class cl = recog_op_alt[opn][alt].cl;\n \t      enum op_type type = recog_data.operand_type[opn];\n \n \t      /* Don't scan match_operand here, since we've no reg class\n@@ -860,9 +860,9 @@ build_def_use (basic_block bb)\n \t\tcontinue;\n \n \t      if (recog_op_alt[opn][alt].is_address)\n-\t\tscan_rtx_address (insn, loc, class, mark_read, VOIDmode);\n+\t\tscan_rtx_address (insn, loc, cl, mark_read, VOIDmode);\n \t      else\n-\t\tscan_rtx (insn, loc, class, mark_read, type, 0);\n+\t\tscan_rtx (insn, loc, cl, mark_read, type, 0);\n \t    }\n \n \t  /* Step 4: Close chains for registers that die here.\n@@ -924,13 +924,13 @@ build_def_use (basic_block bb)\n \t\t  {\n \t\t    rtx *loc = recog_data.operand_loc[i];\n \t\t    rtx op = *loc;\n-\t\t    enum reg_class class = recog_op_alt[i][alt].class;\n+\t\t    enum reg_class cl = recog_op_alt[i][alt].cl;\n \n \t\t    if (REG_P (op)\n \t\t\t&& REGNO (op) == ORIGINAL_REGNO (op))\n \t\t      continue;\n \n-\t\t    scan_rtx (insn, loc, class, mark_write, OP_OUT,\n+\t\t    scan_rtx (insn, loc, cl, mark_write, OP_OUT,\n \t\t\t      recog_op_alt[i][alt].earlyclobber);\n \t\t  }\n \t    }\n@@ -941,10 +941,10 @@ build_def_use (basic_block bb)\n \t\trtx *loc = (i < n_ops\n \t\t\t    ? recog_data.operand_loc[opn]\n \t\t\t    : recog_data.dup_loc[i - n_ops]);\n-\t\tenum reg_class class = recog_op_alt[opn][alt].class;\n+\t\tenum reg_class cl = recog_op_alt[opn][alt].cl;\n \n \t\tif (recog_data.operand_type[opn] == OP_OUT)\n-\t\t  scan_rtx (insn, loc, class, mark_write, OP_OUT,\n+\t\t  scan_rtx (insn, loc, cl, mark_write, OP_OUT,\n \t\t\t    recog_op_alt[opn][alt].earlyclobber);\n \t      }\n \n@@ -979,7 +979,7 @@ dump_def_use_chain (struct du_chain *chains)\n       while (this)\n \t{\n \t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this->insn),\n-\t\t   reg_class_names[this->class]);\n+\t\t   reg_class_names[this->cl]);\n \t  this = this->next_use;\n \t}\n       fprintf (dump_file, \"\\n\");\n@@ -1312,11 +1312,11 @@ maybe_mode_change (enum machine_mode orig_mode, enum machine_mode copy_mode,\n }\n \n /* Find the oldest copy of the value contained in REGNO that is in\n-   register class CLASS and has mode MODE.  If found, return an rtx\n+   register class CL and has mode MODE.  If found, return an rtx\n    of that oldest register, otherwise return NULL.  */\n \n static rtx\n-find_oldest_value_reg (enum reg_class class, rtx reg, struct value_data *vd)\n+find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n {\n   unsigned int regno = REGNO (reg);\n   enum machine_mode mode = GET_MODE (reg);\n@@ -1343,7 +1343,7 @@ find_oldest_value_reg (enum reg_class class, rtx reg, struct value_data *vd)\n       unsigned int last;\n \n       for (last = i; last < i + hard_regno_nregs[i][mode]; last++)\n-\tif (!TEST_HARD_REG_BIT (reg_class_contents[class], last))\n+\tif (!TEST_HARD_REG_BIT (reg_class_contents[cl], last))\n \t  return NULL_RTX;\n \n       new = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i, regno);\n@@ -1359,13 +1359,13 @@ find_oldest_value_reg (enum reg_class class, rtx reg, struct value_data *vd)\n }\n \n /* If possible, replace the register at *LOC with the oldest register\n-   in register class CLASS.  Return true if successfully replaced.  */\n+   in register class CL.  Return true if successfully replaced.  */\n \n static bool\n-replace_oldest_value_reg (rtx *loc, enum reg_class class, rtx insn,\n+replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx insn,\n \t\t\t  struct value_data *vd)\n {\n-  rtx new = find_oldest_value_reg (class, *loc, vd);\n+  rtx new = find_oldest_value_reg (cl, *loc, vd);\n   if (new)\n     {\n       if (dump_file)\n@@ -1379,11 +1379,11 @@ replace_oldest_value_reg (rtx *loc, enum reg_class class, rtx insn,\n }\n \n /* Similar to replace_oldest_value_reg, but *LOC contains an address.\n-   Adapted from find_reloads_address_1.  CLASS is INDEX_REG_CLASS or\n+   Adapted from find_reloads_address_1.  CL is INDEX_REG_CLASS or\n    BASE_REG_CLASS depending on how the register is being considered.  */\n \n static bool\n-replace_oldest_value_addr (rtx *loc, enum reg_class class,\n+replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \t\t\t   enum machine_mode mode, rtx insn,\n \t\t\t   struct value_data *vd)\n {\n@@ -1491,7 +1491,7 @@ replace_oldest_value_addr (rtx *loc, enum reg_class class,\n       return replace_oldest_value_mem (x, insn, vd);\n \n     case REG:\n-      return replace_oldest_value_reg (loc, class, insn, vd);\n+      return replace_oldest_value_reg (loc, cl, insn, vd);\n \n     default:\n       break;\n@@ -1501,11 +1501,11 @@ replace_oldest_value_addr (rtx *loc, enum reg_class class,\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tchanged |= replace_oldest_value_addr (&XEXP (x, i), class, mode,\n+\tchanged |= replace_oldest_value_addr (&XEXP (x, i), cl, mode,\n \t\t\t\t\t      insn, vd);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), class,\n+\t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), cl,\n \t\t\t\t\t\tmode, insn, vd);\n     }\n \n@@ -1562,7 +1562,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t{\n \t  int matches = recog_op_alt[i][alt].matches;\n \t  if (matches >= 0)\n-\t    recog_op_alt[i][alt].class = recog_op_alt[matches][alt].class;\n+\t    recog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n \t  if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n \t      || (predicated && recog_data.operand_type[i] == OP_OUT))\n \t    recog_data.operand_type[i] = OP_INOUT;\n@@ -1669,12 +1669,12 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t      if (recog_op_alt[i][alt].is_address)\n \t\treplaced\n \t\t  = replace_oldest_value_addr (recog_data.operand_loc[i],\n-\t\t\t\t\t       recog_op_alt[i][alt].class,\n+\t\t\t\t\t       recog_op_alt[i][alt].cl,\n \t\t\t\t\t       VOIDmode, insn, vd);\n \t      else if (REG_P (recog_data.operand[i]))\n \t\treplaced\n \t\t  = replace_oldest_value_reg (recog_data.operand_loc[i],\n-\t\t\t\t\t      recog_op_alt[i][alt].class,\n+\t\t\t\t\t      recog_op_alt[i][alt].cl,\n \t\t\t\t\t      insn, vd);\n \t      else if (MEM_P (recog_data.operand[i]))\n \t\treplaced = replace_oldest_value_mem (recog_data.operand[i],"}, {"sha": "f9567c33b73dd1e7582051d5c0e607b0d05b6bc8", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3a64162f5cd539922b53eba91229e4b882bcad6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e3a64162f5cd539922b53eba91229e4b882bcad6", "patch": "@@ -3140,7 +3140,7 @@ extern int integer_pow2p (tree);\n \n extern int integer_nonzerop (tree);\n \n-/* staticp (tree x) is nonzero if X is a reference to data allocated\n+/* staticp (tree x) is true if X is a reference to data allocated\n    at a fixed address in memory.  */\n \n extern bool staticp (tree);"}]}