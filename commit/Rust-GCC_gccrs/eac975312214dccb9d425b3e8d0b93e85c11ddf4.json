{"sha": "eac975312214dccb9d425b3e8d0b93e85c11ddf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFjOTc1MzEyMjE0ZGNjYjlkNDI1YjNlOGQwYjkzZTg1YzExZGRmNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-10-31T11:14:23Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-10-31T11:14:23Z"}, "message": "backport: All source files: Merge from upstream 345033.\n\nMerge from upstream 345033.\n\n2018-10-31  Martin Liska  <mliska@suse.cz>\n\n\t* All source files: Merge from upstream 345033.\n\nFrom-SVN: r265665", "tree": {"sha": "431086825b095506e32d4c0b0e479c62254e2b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/431086825b095506e32d4c0b0e479c62254e2b69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eac975312214dccb9d425b3e8d0b93e85c11ddf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac975312214dccb9d425b3e8d0b93e85c11ddf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eac975312214dccb9d425b3e8d0b93e85c11ddf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac975312214dccb9d425b3e8d0b93e85c11ddf4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95fba530b6f68f336090abb5699ae9f24d1e22e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95fba530b6f68f336090abb5699ae9f24d1e22e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95fba530b6f68f336090abb5699ae9f24d1e22e6"}], "stats": {"total": 28432, "additions": 25041, "deletions": 3391}, "files": [{"sha": "b8f0bfddc73cce4119c91e845360de91f91522aa", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -1,3 +1,7 @@\n+2018-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* All source files: Merge from upstream 345033.\n+\n 2018-10-31  Martin Liska  <mliska@suse.cz>\n \n \t* HOWTO_MERGE: Enhance documentation."}, {"sha": "8f02e2306496080eaf370b9fbeaeb4502b0fd375", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -1,4 +1,4 @@\n-315899\n+345033\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "6f69f700c063c531e1f64b54ed7ae5d92679d235", "filename": "libsanitizer/asan/asan_activation.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_activation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_activation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -14,8 +14,10 @@\n #include \"asan_allocator.h\"\n #include \"asan_flags.h\"\n #include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n \n namespace __asan {\n@@ -108,8 +110,9 @@ void AsanDeactivate() {\n   AllocatorOptions disabled = asan_deactivated_flags.allocator_options;\n   disabled.quarantine_size_mb = 0;\n   disabled.thread_local_quarantine_size_kb = 0;\n-  disabled.min_redzone = 16;  // Redzone must be at least 16 bytes long.\n-  disabled.max_redzone = 16;\n+  // Redzone must be at least Max(16, granularity) bytes long.\n+  disabled.min_redzone = Max(16, (int)SHADOW_GRANULARITY);\n+  disabled.max_redzone = disabled.min_redzone;\n   disabled.alloc_dealloc_mismatch = false;\n   disabled.may_return_null = true;\n   ReInitializeAllocator(disabled);"}, {"sha": "c2b31a543e751351a4524145e06281e97e131757", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "modified", "additions": 125, "deletions": 41, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -82,7 +82,10 @@ struct ChunkHeader {\n   // This field is used for small sizes. For large sizes it is equal to\n   // SizeClassMap::kMaxSize and the actual size is stored in the\n   // SecondaryAllocator's metadata.\n-  u32 user_requested_size;\n+  u32 user_requested_size : 29;\n+  // align < 8 -> 0\n+  // else      -> log2(min(align, 512)) - 2\n+  u32 user_requested_alignment_log : 3;\n   u32 alloc_context_id;\n };\n \n@@ -129,8 +132,9 @@ struct AsanChunk: ChunkBase {\n };\n \n struct QuarantineCallback {\n-  explicit QuarantineCallback(AllocatorCache *cache)\n-      : cache_(cache) {\n+  QuarantineCallback(AllocatorCache *cache, BufferedStackTrace *stack)\n+      : cache_(cache),\n+        stack_(stack) {\n   }\n \n   void Recycle(AsanChunk *m) {\n@@ -163,15 +167,17 @@ struct QuarantineCallback {\n     void *res = get_allocator().Allocate(cache_, size, 1);\n     // TODO(alekseys): Consider making quarantine OOM-friendly.\n     if (UNLIKELY(!res))\n-      return DieOnFailure::OnOOM();\n+      ReportOutOfMemory(size, stack_);\n     return res;\n   }\n \n   void Deallocate(void *p) {\n     get_allocator().Deallocate(cache_, p);\n   }\n \n-  AllocatorCache *cache_;\n+ private:\n+  AllocatorCache* const cache_;\n+  BufferedStackTrace* const stack_;\n };\n \n typedef Quarantine<QuarantineCallback, AsanChunk> AsanQuarantine;\n@@ -269,9 +275,9 @@ struct Allocator {\n     atomic_store(&max_redzone, options.max_redzone, memory_order_release);\n   }\n \n-  void Initialize(const AllocatorOptions &options) {\n+  void InitLinkerInitialized(const AllocatorOptions &options) {\n     SetAllocatorMayReturnNull(options.may_return_null);\n-    allocator.Init(options.release_to_os_interval_ms);\n+    allocator.InitLinkerInitialized(options.release_to_os_interval_ms);\n     SharedInitCode(options);\n   }\n \n@@ -349,6 +355,20 @@ struct Allocator {\n     return Min(Max(rz_log, RZSize2Log(min_rz)), RZSize2Log(max_rz));\n   }\n \n+  static uptr ComputeUserRequestedAlignmentLog(uptr user_requested_alignment) {\n+    if (user_requested_alignment < 8)\n+      return 0;\n+    if (user_requested_alignment > 512)\n+      user_requested_alignment = 512;\n+    return Log2(user_requested_alignment) - 2;\n+  }\n+\n+  static uptr ComputeUserAlignment(uptr user_requested_alignment_log) {\n+    if (user_requested_alignment_log == 0)\n+      return 0;\n+    return 1LL << (user_requested_alignment_log + 2);\n+  }\n+\n   // We have an address between two chunks, and we want to report just one.\n   AsanChunk *ChooseChunk(uptr addr, AsanChunk *left_chunk,\n                          AsanChunk *right_chunk) {\n@@ -378,11 +398,16 @@ struct Allocator {\n                  AllocType alloc_type, bool can_fill) {\n     if (UNLIKELY(!asan_inited))\n       AsanInitFromRtl();\n-    if (RssLimitExceeded())\n-      return AsanAllocator::FailureHandler::OnOOM();\n+    if (RssLimitExceeded()) {\n+      if (AllocatorMayReturnNull())\n+        return nullptr;\n+      ReportRssLimitExceeded(stack);\n+    }\n     Flags &fl = *flags();\n     CHECK(stack);\n     const uptr min_alignment = SHADOW_GRANULARITY;\n+    const uptr user_requested_alignment_log =\n+        ComputeUserRequestedAlignmentLog(alignment);\n     if (alignment < min_alignment)\n       alignment = min_alignment;\n     if (size == 0) {\n@@ -410,9 +435,13 @@ struct Allocator {\n     }\n     CHECK(IsAligned(needed_size, min_alignment));\n     if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n-      Report(\"WARNING: AddressSanitizer failed to allocate 0x%zx bytes\\n\",\n-             (void*)size);\n-      return AsanAllocator::FailureHandler::OnBadRequest();\n+      if (AllocatorMayReturnNull()) {\n+        Report(\"WARNING: AddressSanitizer failed to allocate 0x%zx bytes\\n\",\n+               (void*)size);\n+        return nullptr;\n+      }\n+      ReportAllocationSizeTooBig(size, needed_size, kMaxAllowedMallocSize,\n+                                 stack);\n     }\n \n     AsanThread *t = GetCurrentThread();\n@@ -425,8 +454,12 @@ struct Allocator {\n       AllocatorCache *cache = &fallback_allocator_cache;\n       allocated = allocator.Allocate(cache, needed_size, 8);\n     }\n-    if (!allocated)\n-      return nullptr;\n+    if (UNLIKELY(!allocated)) {\n+      SetAllocatorOutOfMemory();\n+      if (AllocatorMayReturnNull())\n+        return nullptr;\n+      ReportOutOfMemory(size, stack);\n+    }\n \n     if (*(u8 *)MEM_TO_SHADOW((uptr)allocated) == 0 && CanPoisonMemory()) {\n       // Heap poisoning is enabled, but the allocator provides an unpoisoned\n@@ -470,6 +503,7 @@ struct Allocator {\n       meta[0] = size;\n       meta[1] = chunk_beg;\n     }\n+    m->user_requested_alignment_log = user_requested_alignment_log;\n \n     m->alloc_context_id = StackDepotPut(*stack);\n \n@@ -561,18 +595,18 @@ struct Allocator {\n     if (t) {\n       AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n       AllocatorCache *ac = GetAllocatorCache(ms);\n-      quarantine.Put(GetQuarantineCache(ms), QuarantineCallback(ac), m,\n-                           m->UsedSize());\n+      quarantine.Put(GetQuarantineCache(ms), QuarantineCallback(ac, stack), m,\n+                     m->UsedSize());\n     } else {\n       SpinMutexLock l(&fallback_mutex);\n       AllocatorCache *ac = &fallback_allocator_cache;\n-      quarantine.Put(&fallback_quarantine_cache, QuarantineCallback(ac), m,\n-                           m->UsedSize());\n+      quarantine.Put(&fallback_quarantine_cache, QuarantineCallback(ac, stack),\n+                     m, m->UsedSize());\n     }\n   }\n \n-  void Deallocate(void *ptr, uptr delete_size, BufferedStackTrace *stack,\n-                  AllocType alloc_type) {\n+  void Deallocate(void *ptr, uptr delete_size, uptr delete_alignment,\n+                  BufferedStackTrace *stack, AllocType alloc_type) {\n     uptr p = reinterpret_cast<uptr>(ptr);\n     if (p == 0) return;\n \n@@ -599,11 +633,14 @@ struct Allocator {\n         ReportAllocTypeMismatch((uptr)ptr, stack, (AllocType)m->alloc_type,\n                                 (AllocType)alloc_type);\n       }\n-    }\n-\n-    if (delete_size && flags()->new_delete_type_mismatch &&\n-        delete_size != m->UsedSize()) {\n-      ReportNewDeleteSizeMismatch(p, delete_size, stack);\n+    } else {\n+      if (flags()->new_delete_type_mismatch &&\n+          (alloc_type == FROM_NEW || alloc_type == FROM_NEW_BR) &&\n+          ((delete_size && delete_size != m->UsedSize()) ||\n+           ComputeUserRequestedAlignmentLog(delete_alignment) !=\n+               m->user_requested_alignment_log)) {\n+        ReportNewDeleteTypeMismatch(p, delete_size, delete_alignment, stack);\n+      }\n     }\n \n     QuarantineChunk(m, ptr, stack);\n@@ -629,14 +666,17 @@ struct Allocator {\n       // If realloc() races with free(), we may start copying freed memory.\n       // However, we will report racy double-free later anyway.\n       REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n-      Deallocate(old_ptr, 0, stack, FROM_MALLOC);\n+      Deallocate(old_ptr, 0, 0, stack, FROM_MALLOC);\n     }\n     return new_ptr;\n   }\n \n   void *Calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n-    if (CheckForCallocOverflow(size, nmemb))\n-      return AsanAllocator::FailureHandler::OnBadRequest();\n+    if (UNLIKELY(CheckForCallocOverflow(size, nmemb))) {\n+      if (AllocatorMayReturnNull())\n+        return nullptr;\n+      ReportCallocOverflow(nmemb, size, stack);\n+    }\n     void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n     // If the memory comes from the secondary allocator no need to clear it\n     // as it comes directly from mmap.\n@@ -652,9 +692,9 @@ struct Allocator {\n       ReportFreeNotMalloced((uptr)ptr, stack);\n   }\n \n-  void CommitBack(AsanThreadLocalMallocStorage *ms) {\n+  void CommitBack(AsanThreadLocalMallocStorage *ms, BufferedStackTrace *stack) {\n     AllocatorCache *ac = GetAllocatorCache(ms);\n-    quarantine.Drain(GetQuarantineCache(ms), QuarantineCallback(ac));\n+    quarantine.Drain(GetQuarantineCache(ms), QuarantineCallback(ac, stack));\n     allocator.SwallowCache(ac);\n   }\n \n@@ -714,6 +754,24 @@ struct Allocator {\n     return AsanChunkView(m1);\n   }\n \n+  void Purge(BufferedStackTrace *stack) {\n+    AsanThread *t = GetCurrentThread();\n+    if (t) {\n+      AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n+      quarantine.DrainAndRecycle(GetQuarantineCache(ms),\n+                                 QuarantineCallback(GetAllocatorCache(ms),\n+                                                    stack));\n+    }\n+    {\n+      SpinMutexLock l(&fallback_mutex);\n+      quarantine.DrainAndRecycle(&fallback_quarantine_cache,\n+                                 QuarantineCallback(&fallback_allocator_cache,\n+                                                    stack));\n+    }\n+\n+    allocator.ForceReleaseToOS();\n+  }\n+\n   void PrintStats() {\n     allocator.PrintStats();\n     quarantine.PrintStats();\n@@ -748,6 +806,9 @@ bool AsanChunkView::IsQuarantined() const {\n uptr AsanChunkView::Beg() const { return chunk_->Beg(); }\n uptr AsanChunkView::End() const { return Beg() + UsedSize(); }\n uptr AsanChunkView::UsedSize() const { return chunk_->UsedSize(); }\n+u32 AsanChunkView::UserRequestedAlignment() const {\n+  return Allocator::ComputeUserAlignment(chunk_->user_requested_alignment_log);\n+}\n uptr AsanChunkView::AllocTid() const { return chunk_->alloc_tid; }\n uptr AsanChunkView::FreeTid() const { return chunk_->free_tid; }\n AllocType AsanChunkView::GetAllocType() const {\n@@ -773,7 +834,7 @@ StackTrace AsanChunkView::GetFreeStack() const {\n }\n \n void InitializeAllocator(const AllocatorOptions &options) {\n-  instance.Initialize(options);\n+  instance.InitLinkerInitialized(options);\n }\n \n void ReInitializeAllocator(const AllocatorOptions &options) {\n@@ -792,20 +853,21 @@ AsanChunkView FindHeapChunkByAllocBeg(uptr addr) {\n }\n \n void AsanThreadLocalMallocStorage::CommitBack() {\n-  instance.CommitBack(this);\n+  GET_STACK_TRACE_MALLOC;\n+  instance.CommitBack(this, &stack);\n }\n \n void PrintInternalAllocatorStats() {\n   instance.PrintStats();\n }\n \n void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type) {\n-  instance.Deallocate(ptr, 0, stack, alloc_type);\n+  instance.Deallocate(ptr, 0, 0, stack, alloc_type);\n }\n \n-void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n-                     AllocType alloc_type) {\n-  instance.Deallocate(ptr, size, stack, alloc_type);\n+void asan_delete(void *ptr, uptr size, uptr alignment,\n+                 BufferedStackTrace *stack, AllocType alloc_type) {\n+  instance.Deallocate(ptr, size, alignment, stack, alloc_type);\n }\n \n void *asan_malloc(uptr size, BufferedStackTrace *stack) {\n@@ -821,7 +883,7 @@ void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack) {\n     return SetErrnoOnNull(instance.Allocate(size, 8, stack, FROM_MALLOC, true));\n   if (size == 0) {\n     if (flags()->allocator_frees_and_returns_null_on_realloc_zero) {\n-      instance.Deallocate(p, 0, stack, FROM_MALLOC);\n+      instance.Deallocate(p, 0, 0, stack, FROM_MALLOC);\n       return nullptr;\n     }\n     // Allocate a size of 1 if we shouldn't free() on Realloc to 0\n@@ -839,7 +901,9 @@ void *asan_pvalloc(uptr size, BufferedStackTrace *stack) {\n   uptr PageSize = GetPageSizeCached();\n   if (UNLIKELY(CheckForPvallocOverflow(size, PageSize))) {\n     errno = errno_ENOMEM;\n-    return AsanAllocator::FailureHandler::OnBadRequest();\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportPvallocOverflow(size, stack);\n   }\n   // pvalloc(0) should allocate one page.\n   size = size ? RoundUpTo(size, PageSize) : PageSize;\n@@ -851,20 +915,35 @@ void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n                     AllocType alloc_type) {\n   if (UNLIKELY(!IsPowerOfTwo(alignment))) {\n     errno = errno_EINVAL;\n-    return AsanAllocator::FailureHandler::OnBadRequest();\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportInvalidAllocationAlignment(alignment, stack);\n   }\n   return SetErrnoOnNull(\n       instance.Allocate(size, alignment, stack, alloc_type, true));\n }\n \n+void *asan_aligned_alloc(uptr alignment, uptr size, BufferedStackTrace *stack) {\n+  if (UNLIKELY(!CheckAlignedAllocAlignmentAndSize(alignment, size))) {\n+    errno = errno_EINVAL;\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportInvalidAlignedAllocAlignment(size, alignment, stack);\n+  }\n+  return SetErrnoOnNull(\n+      instance.Allocate(size, alignment, stack, FROM_MALLOC, true));\n+}\n+\n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                         BufferedStackTrace *stack) {\n   if (UNLIKELY(!CheckPosixMemalignAlignment(alignment))) {\n-    AsanAllocator::FailureHandler::OnBadRequest();\n-    return errno_EINVAL;\n+    if (AllocatorMayReturnNull())\n+      return errno_EINVAL;\n+    ReportInvalidPosixMemalignAlignment(alignment, stack);\n   }\n   void *ptr = instance.Allocate(size, alignment, stack, FROM_MALLOC, true);\n   if (UNLIKELY(!ptr))\n+    // OOM error is already taken care of by Allocate.\n     return errno_ENOMEM;\n   CHECK(IsAligned((uptr)ptr, alignment));\n   *memptr = ptr;\n@@ -1009,6 +1088,11 @@ uptr __sanitizer_get_allocated_size(const void *p) {\n   return allocated_size;\n }\n \n+void __sanitizer_purge_allocator() {\n+  GET_STACK_TRACE_MALLOC;\n+  instance.Purge(&stack);\n+}\n+\n #if !SANITIZER_SUPPORTS_WEAK_HOOKS\n // Provide default (no-op) implementation of malloc hooks.\n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_malloc_hook,"}, {"sha": "c49bd811181833450eb5fbd17d810fe4fcc976c1", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -56,6 +56,7 @@ class AsanChunkView {\n   uptr Beg() const;            // First byte of user memory.\n   uptr End() const;            // Last byte of user memory.\n   uptr UsedSize() const;       // Size requested by the user.\n+  u32 UserRequestedAlignment() const;  // Originally requested alignment.\n   uptr AllocTid() const;\n   uptr FreeTid() const;\n   bool Eq(const AsanChunkView &c) const { return chunk_ == c.chunk_; }\n@@ -126,7 +127,8 @@ const uptr kAllocatorSpace = ~(uptr)0;\n const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n typedef DefaultSizeClassMap SizeClassMap;\n # elif defined(__aarch64__) && SANITIZER_ANDROID\n-const uptr kAllocatorSpace =  0x3000000000ULL;\n+// Android needs to support 39, 42 and 48 bit VMA.\n+const uptr kAllocatorSpace =  ~(uptr)0;\n const uptr kAllocatorSize  =  0x2000000000ULL;  // 128G.\n typedef VeryCompactSizeClassMap SizeClassMap;\n # elif defined(__aarch64__)\n@@ -195,15 +197,16 @@ struct AsanThreadLocalMallocStorage {\n void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n                     AllocType alloc_type);\n void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type);\n-void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n-                     AllocType alloc_type);\n+void asan_delete(void *ptr, uptr size, uptr alignment,\n+                 BufferedStackTrace *stack, AllocType alloc_type);\n \n void *asan_malloc(uptr size, BufferedStackTrace *stack);\n void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack);\n void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack);\n void *asan_valloc(uptr size, BufferedStackTrace *stack);\n void *asan_pvalloc(uptr size, BufferedStackTrace *stack);\n \n+void *asan_aligned_alloc(uptr alignment, uptr size, BufferedStackTrace *stack);\n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                         BufferedStackTrace *stack);\n uptr asan_malloc_usable_size(const void *ptr, uptr pc, uptr bp);"}, {"sha": "075af3375cda4068dc27d7473fc4676c79de18f8", "filename": "libsanitizer/asan/asan_debugging.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -25,7 +25,8 @@ using namespace __asan;\n static void FindInfoForStackVar(uptr addr, const char *frame_descr, uptr offset,\n                                 char *name, uptr name_size,\n                                 uptr &region_address, uptr &region_size) {\n-  InternalMmapVector<StackVarDescr> vars(16);\n+  InternalMmapVector<StackVarDescr> vars;\n+  vars.reserve(16);\n   if (!ParseFrameDescription(frame_descr, &vars)) {\n     return;\n   }"}, {"sha": "99f226da8994cb502297e53311e4765978854cd6", "filename": "libsanitizer/asan/asan_descriptions.cc", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_descriptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_descriptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -18,23 +18,25 @@\n \n namespace __asan {\n \n-// Return \" (thread_name) \" or an empty string if the name is empty.\n-const char *ThreadNameWithParenthesis(AsanThreadContext *t, char buff[],\n-                                      uptr buff_len) {\n-  const char *name = t->name;\n-  if (name[0] == '\\0') return \"\";\n-  buff[0] = 0;\n-  internal_strncat(buff, \" (\", 3);\n-  internal_strncat(buff, name, buff_len - 4);\n-  internal_strncat(buff, \")\", 2);\n-  return buff;\n+AsanThreadIdAndName::AsanThreadIdAndName(AsanThreadContext *t) {\n+  Init(t->tid, t->name);\n }\n \n-const char *ThreadNameWithParenthesis(u32 tid, char buff[], uptr buff_len) {\n-  if (tid == kInvalidTid) return \"\";\n-  asanThreadRegistry().CheckLocked();\n-  AsanThreadContext *t = GetThreadContextByTidLocked(tid);\n-  return ThreadNameWithParenthesis(t, buff, buff_len);\n+AsanThreadIdAndName::AsanThreadIdAndName(u32 tid) {\n+  if (tid == kInvalidTid) {\n+    Init(tid, \"\");\n+  } else {\n+    asanThreadRegistry().CheckLocked();\n+    AsanThreadContext *t = GetThreadContextByTidLocked(tid);\n+    Init(tid, t->name);\n+  }\n+}\n+\n+void AsanThreadIdAndName::Init(u32 tid, const char *tname) {\n+  int len = internal_snprintf(name, sizeof(name), \"T%d\", tid);\n+  CHECK(((unsigned int)len) < sizeof(name));\n+  if (tname[0] != '\\0')\n+    internal_snprintf(&name[len], sizeof(name) - len, \" (%s)\", tname);\n }\n \n void DescribeThread(AsanThreadContext *context) {\n@@ -45,18 +47,15 @@ void DescribeThread(AsanThreadContext *context) {\n     return;\n   }\n   context->announced = true;\n-  char tname[128];\n   InternalScopedString str(1024);\n-  str.append(\"Thread T%d%s\", context->tid,\n-             ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n+  str.append(\"Thread %s\", AsanThreadIdAndName(context).c_str());\n   if (context->parent_tid == kInvalidTid) {\n     str.append(\" created by unknown thread\\n\");\n     Printf(\"%s\", str.data());\n     return;\n   }\n-  str.append(\n-      \" created by T%d%s here:\\n\", context->parent_tid,\n-      ThreadNameWithParenthesis(context->parent_tid, tname, sizeof(tname)));\n+  str.append(\" created by %s here:\\n\",\n+             AsanThreadIdAndName(context->parent_tid).c_str());\n   Printf(\"%s\", str.data());\n   StackDepotGet(context->stack_id).Print();\n   // Recursively described parent thread if needed.\n@@ -120,6 +119,7 @@ static void GetAccessToHeapChunkInformation(ChunkAccess *descr,\n   }\n   descr->chunk_begin = chunk.Beg();\n   descr->chunk_size = chunk.UsedSize();\n+  descr->user_requested_alignment = chunk.UserRequestedAlignment();\n   descr->alloc_type = chunk.GetAllocType();\n }\n \n@@ -355,10 +355,9 @@ bool GlobalAddressDescription::PointsInsideTheSameVariable(\n \n void StackAddressDescription::Print() const {\n   Decorator d;\n-  char tname[128];\n   Printf(\"%s\", d.Location());\n-  Printf(\"Address %p is located in stack of thread T%d%s\", addr, tid,\n-         ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+  Printf(\"Address %p is located in stack of thread %s\", addr,\n+         AsanThreadIdAndName(tid).c_str());\n \n   if (!frame_descr) {\n     Printf(\"%s\\n\", d.Default());\n@@ -377,7 +376,8 @@ void StackAddressDescription::Print() const {\n   StackTrace alloca_stack(&frame_pc, 1);\n   alloca_stack.Print();\n \n-  InternalMmapVector<StackVarDescr> vars(16);\n+  InternalMmapVector<StackVarDescr> vars;\n+  vars.reserve(16);\n   if (!ParseFrameDescription(frame_descr, &vars)) {\n     Printf(\n         \"AddressSanitizer can't parse the stack frame \"\n@@ -399,7 +399,7 @@ void StackAddressDescription::Print() const {\n   }\n   Printf(\n       \"HINT: this may be a false positive if your program uses \"\n-      \"some custom stack unwind mechanism or swapcontext\\n\");\n+      \"some custom stack unwind mechanism, swapcontext or vfork\\n\");\n   if (SANITIZER_WINDOWS)\n     Printf(\"      (longjmp, SEH and C++ exceptions *are* supported)\\n\");\n   else\n@@ -415,26 +415,19 @@ void HeapAddressDescription::Print() const {\n   AsanThreadContext *alloc_thread = GetThreadContextByTidLocked(alloc_tid);\n   StackTrace alloc_stack = GetStackTraceFromId(alloc_stack_id);\n \n-  char tname[128];\n   Decorator d;\n   AsanThreadContext *free_thread = nullptr;\n   if (free_tid != kInvalidTid) {\n     free_thread = GetThreadContextByTidLocked(free_tid);\n-    Printf(\"%sfreed by thread T%d%s here:%s\\n\", d.Allocation(),\n-           free_thread->tid,\n-           ThreadNameWithParenthesis(free_thread, tname, sizeof(tname)),\n-           d.Default());\n+    Printf(\"%sfreed by thread %s here:%s\\n\", d.Allocation(),\n+           AsanThreadIdAndName(free_thread).c_str(), d.Default());\n     StackTrace free_stack = GetStackTraceFromId(free_stack_id);\n     free_stack.Print();\n-    Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\", d.Allocation(),\n-           alloc_thread->tid,\n-           ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n-           d.Default());\n+    Printf(\"%spreviously allocated by thread %s here:%s\\n\", d.Allocation(),\n+           AsanThreadIdAndName(alloc_thread).c_str(), d.Default());\n   } else {\n-    Printf(\"%sallocated by thread T%d%s here:%s\\n\", d.Allocation(),\n-           alloc_thread->tid,\n-           ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n-           d.Default());\n+    Printf(\"%sallocated by thread %s here:%s\\n\", d.Allocation(),\n+           AsanThreadIdAndName(alloc_thread).c_str(), d.Default());\n   }\n   alloc_stack.Print();\n   DescribeThread(GetCurrentThread());"}, {"sha": "43d0cbfeff3c1158b0b9f3d13f641cc36cae360d", "filename": "libsanitizer/asan/asan_descriptions.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_descriptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_descriptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -24,9 +24,20 @@ void DescribeThread(AsanThreadContext *context);\n static inline void DescribeThread(AsanThread *t) {\n   if (t) DescribeThread(t->context());\n }\n-const char *ThreadNameWithParenthesis(AsanThreadContext *t, char buff[],\n-                                      uptr buff_len);\n-const char *ThreadNameWithParenthesis(u32 tid, char buff[], uptr buff_len);\n+\n+class AsanThreadIdAndName {\n+ public:\n+  explicit AsanThreadIdAndName(AsanThreadContext *t);\n+  explicit AsanThreadIdAndName(u32 tid);\n+\n+  // Contains \"T%tid (%name)\" or \"T%tid\" if the name is empty.\n+  const char *c_str() const { return &name[0]; }\n+\n+ private:\n+  void Init(u32 tid, const char *tname);\n+\n+  char name[128];\n+};\n \n class Decorator : public __sanitizer::SanitizerCommonDecorator {\n  public:\n@@ -100,6 +111,7 @@ struct ChunkAccess {\n   sptr offset;\n   uptr chunk_begin;\n   uptr chunk_size;\n+  u32 user_requested_alignment : 12;\n   u32 access_type : 2;\n   u32 alloc_type : 2;\n };"}, {"sha": "b9d02a74a0dbc66965b9844105ae8d7ac34402b6", "filename": "libsanitizer/asan/asan_errors.cc", "status": "modified", "additions": 165, "deletions": 39, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_errors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_errors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -11,7 +11,6 @@\n //===----------------------------------------------------------------------===//\n \n #include \"asan_errors.h\"\n-#include <signal.h>\n #include \"asan_descriptions.h\"\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n@@ -35,8 +34,7 @@ static void OnStackUnwind(const SignalContext &sig,\n   // corresponding code in the sanitizer_common and we use this callback to\n   // print it.\n   static_cast<const ScarinessScoreBase *>(callback_context)->Print();\n-  GetStackTraceWithPcBpAndContext(stack, kStackTraceMax, sig.pc, sig.bp,\n-                                  sig.context, fast);\n+  GetStackTrace(stack, kStackTraceMax, sig.pc, sig.bp, sig.context, fast);\n }\n \n void ErrorDeadlySignal::Print() {\n@@ -45,13 +43,11 @@ void ErrorDeadlySignal::Print() {\n \n void ErrorDoubleFree::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  char tname[128];\n+  Printf(\"%s\", d.Error());\n   Report(\n-      \"ERROR: AddressSanitizer: attempting %s on %p in \"\n-      \"thread T%d%s:\\n\",\n-      scariness.GetDescription(), addr_description.addr, tid,\n-      ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+      \"ERROR: AddressSanitizer: attempting %s on %p in thread %s:\\n\",\n+      scariness.GetDescription(), addr_description.addr,\n+      AsanThreadIdAndName(tid).c_str());\n   Printf(\"%s\", d.Default());\n   scariness.Print();\n   GET_STACK_TRACE_FATAL(second_free_stack->trace[0],\n@@ -61,20 +57,36 @@ void ErrorDoubleFree::Print() {\n   ReportErrorSummary(scariness.GetDescription(), &stack);\n }\n \n-void ErrorNewDeleteSizeMismatch::Print() {\n+void ErrorNewDeleteTypeMismatch::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  char tname[128];\n+  Printf(\"%s\", d.Error());\n   Report(\n-      \"ERROR: AddressSanitizer: %s on %p in thread \"\n-      \"T%d%s:\\n\",\n-      scariness.GetDescription(), addr_description.addr, tid,\n-      ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+      \"ERROR: AddressSanitizer: %s on %p in thread %s:\\n\",\n+      scariness.GetDescription(), addr_description.addr,\n+      AsanThreadIdAndName(tid).c_str());\n   Printf(\"%s  object passed to delete has wrong type:\\n\", d.Default());\n-  Printf(\n-      \"  size of the allocated type:   %zd bytes;\\n\"\n-      \"  size of the deallocated type: %zd bytes.\\n\",\n-      addr_description.chunk_access.chunk_size, delete_size);\n+  if (delete_size != 0) {\n+    Printf(\n+        \"  size of the allocated type:   %zd bytes;\\n\"\n+        \"  size of the deallocated type: %zd bytes.\\n\",\n+        addr_description.chunk_access.chunk_size, delete_size);\n+  }\n+  const uptr user_alignment =\n+      addr_description.chunk_access.user_requested_alignment;\n+  if (delete_alignment != user_alignment) {\n+    char user_alignment_str[32];\n+    char delete_alignment_str[32];\n+    internal_snprintf(user_alignment_str, sizeof(user_alignment_str),\n+                      \"%zd bytes\", user_alignment);\n+    internal_snprintf(delete_alignment_str, sizeof(delete_alignment_str),\n+                      \"%zd bytes\", delete_alignment);\n+    static const char *kDefaultAlignment = \"default-aligned\";\n+    Printf(\n+        \"  alignment of the allocated type:   %s;\\n\"\n+        \"  alignment of the deallocated type: %s.\\n\",\n+        user_alignment > 0 ? user_alignment_str : kDefaultAlignment,\n+        delete_alignment > 0 ? delete_alignment_str : kDefaultAlignment);\n+  }\n   CHECK_GT(free_stack->size, 0);\n   scariness.Print();\n   GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n@@ -88,13 +100,11 @@ void ErrorNewDeleteSizeMismatch::Print() {\n \n void ErrorFreeNotMalloced::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  char tname[128];\n+  Printf(\"%s\", d.Error());\n   Report(\n       \"ERROR: AddressSanitizer: attempting free on address \"\n-      \"which was not malloc()-ed: %p in thread T%d%s\\n\",\n-      addr_description.Address(), tid,\n-      ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+      \"which was not malloc()-ed: %p in thread %s\\n\",\n+      addr_description.Address(), AsanThreadIdAndName(tid).c_str());\n   Printf(\"%s\", d.Default());\n   CHECK_GT(free_stack->size, 0);\n   scariness.Print();\n@@ -111,7 +121,7 @@ void ErrorAllocTypeMismatch::Print() {\n                                         \"operator delete []\"};\n   CHECK_NE(alloc_type, dealloc_type);\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\"ERROR: AddressSanitizer: %s (%s vs %s) on %p\\n\",\n          scariness.GetDescription(),\n          alloc_names[alloc_type], dealloc_names[dealloc_type],\n@@ -130,7 +140,7 @@ void ErrorAllocTypeMismatch::Print() {\n \n void ErrorMallocUsableSizeNotOwned::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\n       \"ERROR: AddressSanitizer: attempting to call malloc_usable_size() for \"\n       \"pointer which is not owned: %p\\n\",\n@@ -143,7 +153,7 @@ void ErrorMallocUsableSizeNotOwned::Print() {\n \n void ErrorSanitizerGetAllocatedSizeNotOwned::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\n       \"ERROR: AddressSanitizer: attempting to call \"\n       \"__sanitizer_get_allocated_size() for pointer which is not owned: %p\\n\",\n@@ -154,11 +164,123 @@ void ErrorSanitizerGetAllocatedSizeNotOwned::Print() {\n   ReportErrorSummary(scariness.GetDescription(), stack);\n }\n \n+void ErrorCallocOverflow::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: calloc parameters overflow: count * size \"\n+      \"(%zd * %zd) cannot be represented in type size_t (thread %s)\\n\",\n+      count, size, AsanThreadIdAndName(tid).c_str());\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorPvallocOverflow::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: pvalloc parameters overflow: size 0x%zx \"\n+      \"rounded up to system page size 0x%zx cannot be represented in type \"\n+      \"size_t (thread %s)\\n\",\n+      size, GetPageSizeCached(), AsanThreadIdAndName(tid).c_str());\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorInvalidAllocationAlignment::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: invalid allocation alignment: %zd, \"\n+      \"alignment must be a power of two (thread %s)\\n\",\n+      alignment, AsanThreadIdAndName(tid).c_str());\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorInvalidAlignedAllocAlignment::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+#if SANITIZER_POSIX\n+  Report(\"ERROR: AddressSanitizer: invalid alignment requested in \"\n+         \"aligned_alloc: %zd, alignment must be a power of two and the \"\n+         \"requested size 0x%zx must be a multiple of alignment \"\n+         \"(thread %s)\\n\", alignment, size, AsanThreadIdAndName(tid).c_str());\n+#else\n+  Report(\"ERROR: AddressSanitizer: invalid alignment requested in \"\n+         \"aligned_alloc: %zd, the requested size 0x%zx must be a multiple of \"\n+         \"alignment (thread %s)\\n\", alignment, size,\n+         AsanThreadIdAndName(tid).c_str());\n+#endif\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorInvalidPosixMemalignAlignment::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: invalid alignment requested in posix_memalign: \"\n+      \"%zd, alignment must be a power of two and a multiple of sizeof(void*) \"\n+      \"== %zd (thread %s)\\n\",\n+      alignment, sizeof(void*), AsanThreadIdAndName(tid).c_str());  // NOLINT\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorAllocationSizeTooBig::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: requested allocation size 0x%zx (0x%zx after \"\n+      \"adjustments for alignment, red zones etc.) exceeds maximum supported \"\n+      \"size of 0x%zx (thread %s)\\n\",\n+      user_size, total_size, max_size, AsanThreadIdAndName(tid).c_str());\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorRssLimitExceeded::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: specified RSS limit exceeded, currently set to \"\n+      \"soft_rss_limit_mb=%zd\\n\", common_flags()->soft_rss_limit_mb);\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n+void ErrorOutOfMemory::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: allocator is out of memory trying to allocate \"\n+      \"0x%zx bytes\\n\", requested_size);\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n void ErrorStringFunctionMemoryRangesOverlap::Print() {\n   Decorator d;\n   char bug_type[100];\n   internal_snprintf(bug_type, sizeof(bug_type), \"%s-param-overlap\", function);\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\n       \"ERROR: AddressSanitizer: %s: memory ranges [%p,%p) and [%p, %p) \"\n       \"overlap\\n\",\n@@ -175,7 +297,7 @@ void ErrorStringFunctionMemoryRangesOverlap::Print() {\n \n void ErrorStringFunctionSizeOverflow::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\",\n          scariness.GetDescription(), size);\n   Printf(\"%s\", d.Default());\n@@ -203,7 +325,7 @@ void ErrorBadParamsToAnnotateContiguousContainer::Print() {\n \n void ErrorODRViolation::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\"ERROR: AddressSanitizer: %s (%p):\\n\", scariness.GetDescription(),\n          global1.beg);\n   Printf(\"%s\", d.Default());\n@@ -232,7 +354,7 @@ void ErrorODRViolation::Print() {\n \n void ErrorInvalidPointerPair::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   Report(\"ERROR: AddressSanitizer: %s: %p %p\\n\", scariness.GetDescription(),\n          addr1_description.Address(), addr2_description.Address());\n   Printf(\"%s\", d.Default());\n@@ -396,6 +518,7 @@ static void PrintLegend(InternalScopedString *str) {\n   PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n   PrintShadowByte(str, \"  Left alloca redzone:     \", kAsanAllocaLeftMagic);\n   PrintShadowByte(str, \"  Right alloca redzone:    \", kAsanAllocaRightMagic);\n+  PrintShadowByte(str, \"  Shadow gap:              \", kAsanShadowGap);\n }\n \n static void PrintShadowBytes(InternalScopedString *str, const char *before,\n@@ -420,27 +543,30 @@ static void PrintShadowMemoryForAddress(uptr addr) {\n   InternalScopedString str(4096 * 8);\n   str.append(\"Shadow bytes around the buggy address:\\n\");\n   for (int i = -5; i <= 5; i++) {\n+    uptr row_shadow_addr = aligned_shadow + i * n_bytes_per_row;\n+    // Skip rows that would be outside the shadow range. This can happen when\n+    // the user address is near the bottom, top, or shadow gap of the address\n+    // space.\n+    if (!AddrIsInShadow(row_shadow_addr)) continue;\n     const char *prefix = (i == 0) ? \"=>\" : \"  \";\n-    PrintShadowBytes(&str, prefix, (u8 *)(aligned_shadow + i * n_bytes_per_row),\n-                     (u8 *)shadow_addr, n_bytes_per_row);\n+    PrintShadowBytes(&str, prefix, (u8 *)row_shadow_addr, (u8 *)shadow_addr,\n+                     n_bytes_per_row);\n   }\n   if (flags()->print_legend) PrintLegend(&str);\n   Printf(\"%s\", str.data());\n }\n \n void ErrorGeneric::Print() {\n   Decorator d;\n-  Printf(\"%s\", d.Warning());\n+  Printf(\"%s\", d.Error());\n   uptr addr = addr_description.Address();\n   Report(\"ERROR: AddressSanitizer: %s on address %p at pc %p bp %p sp %p\\n\",\n          bug_descr, (void *)addr, pc, bp, sp);\n   Printf(\"%s\", d.Default());\n \n-  char tname[128];\n-  Printf(\"%s%s of size %zu at %p thread T%d%s%s\\n\", d.Access(),\n+  Printf(\"%s%s of size %zu at %p thread %s%s\\n\", d.Access(),\n          access_size ? (is_write ? \"WRITE\" : \"READ\") : \"ACCESS\", access_size,\n-         (void *)addr, tid,\n-         ThreadNameWithParenthesis(tid, tname, sizeof(tname)), d.Default());\n+         (void *)addr, AsanThreadIdAndName(tid).c_str(), d.Default());\n \n   scariness.Print();\n   GET_STACK_TRACE_FATAL(pc, bp);"}, {"sha": "5ed15dc9817b4ca26a0e0cf9501bf59d1c721900", "filename": "libsanitizer/asan/asan_errors.h", "status": "modified", "additions": 182, "deletions": 99, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -18,20 +18,30 @@\n \n namespace __asan {\n \n+// (*) VS2013 does not implement unrestricted unions, so we need a trivial\n+// default constructor explicitly defined for each particular error.\n+\n+// None of the error classes own the stack traces mentioned in them.\n+\n struct ErrorBase {\n-  ErrorBase() = default;\n-  explicit ErrorBase(u32 tid_) : tid(tid_) {}\n   ScarinessScoreBase scariness;\n   u32 tid;\n+\n+  ErrorBase() = default;  // (*)\n+  explicit ErrorBase(u32 tid_) : tid(tid_) {}\n+  ErrorBase(u32 tid_, int initial_score, const char *reason) : tid(tid_) {\n+    scariness.Clear();\n+    scariness.Scare(initial_score, reason);\n+  }\n };\n \n struct ErrorDeadlySignal : ErrorBase {\n   SignalContext signal;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorDeadlySignal() = default;\n+\n+  ErrorDeadlySignal() = default;  // (*)\n   ErrorDeadlySignal(u32 tid, const SignalContext &sig)\n-      : ErrorBase(tid), signal(sig) {\n+      : ErrorBase(tid),\n+        signal(sig) {\n     scariness.Clear();\n     if (signal.IsStackOverflow()) {\n       scariness.Scare(10, \"stack-overflow\");\n@@ -53,123 +63,206 @@ struct ErrorDeadlySignal : ErrorBase {\n };\n \n struct ErrorDoubleFree : ErrorBase {\n-  // ErrorDoubleFree doesn't own the stack trace.\n   const BufferedStackTrace *second_free_stack;\n   HeapAddressDescription addr_description;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorDoubleFree() = default;\n+\n+  ErrorDoubleFree() = default;  // (*)\n   ErrorDoubleFree(u32 tid, BufferedStackTrace *stack, uptr addr)\n-      : ErrorBase(tid), second_free_stack(stack) {\n+      : ErrorBase(tid, 42, \"double-free\"),\n+        second_free_stack(stack) {\n     CHECK_GT(second_free_stack->size, 0);\n     GetHeapAddressInformation(addr, 1, &addr_description);\n-    scariness.Clear();\n-    scariness.Scare(42, \"double-free\");\n   }\n   void Print();\n };\n \n-struct ErrorNewDeleteSizeMismatch : ErrorBase {\n-  // ErrorNewDeleteSizeMismatch doesn't own the stack trace.\n+struct ErrorNewDeleteTypeMismatch : ErrorBase {\n   const BufferedStackTrace *free_stack;\n   HeapAddressDescription addr_description;\n   uptr delete_size;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorNewDeleteSizeMismatch() = default;\n-  ErrorNewDeleteSizeMismatch(u32 tid, BufferedStackTrace *stack, uptr addr,\n-                             uptr delete_size_)\n-      : ErrorBase(tid), free_stack(stack), delete_size(delete_size_) {\n+  uptr delete_alignment;\n+\n+  ErrorNewDeleteTypeMismatch() = default;  // (*)\n+  ErrorNewDeleteTypeMismatch(u32 tid, BufferedStackTrace *stack, uptr addr,\n+                             uptr delete_size_, uptr delete_alignment_)\n+      : ErrorBase(tid, 10, \"new-delete-type-mismatch\"),\n+        free_stack(stack),\n+        delete_size(delete_size_),\n+        delete_alignment(delete_alignment_) {\n     GetHeapAddressInformation(addr, 1, &addr_description);\n-    scariness.Clear();\n-    scariness.Scare(10, \"new-delete-type-mismatch\");\n   }\n   void Print();\n };\n \n struct ErrorFreeNotMalloced : ErrorBase {\n-  // ErrorFreeNotMalloced doesn't own the stack trace.\n   const BufferedStackTrace *free_stack;\n   AddressDescription addr_description;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorFreeNotMalloced() = default;\n+\n+  ErrorFreeNotMalloced() = default;  // (*)\n   ErrorFreeNotMalloced(u32 tid, BufferedStackTrace *stack, uptr addr)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 40, \"bad-free\"),\n         free_stack(stack),\n-        addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n-    scariness.Clear();\n-    scariness.Scare(40, \"bad-free\");\n-  }\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false) {}\n   void Print();\n };\n \n struct ErrorAllocTypeMismatch : ErrorBase {\n-  // ErrorAllocTypeMismatch doesn't own the stack trace.\n   const BufferedStackTrace *dealloc_stack;\n   HeapAddressDescription addr_description;\n   AllocType alloc_type, dealloc_type;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorAllocTypeMismatch() = default;\n+\n+  ErrorAllocTypeMismatch() = default;  // (*)\n   ErrorAllocTypeMismatch(u32 tid, BufferedStackTrace *stack, uptr addr,\n                          AllocType alloc_type_, AllocType dealloc_type_)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"alloc-dealloc-mismatch\"),\n         dealloc_stack(stack),\n         alloc_type(alloc_type_),\n         dealloc_type(dealloc_type_) {\n     GetHeapAddressInformation(addr, 1, &addr_description);\n-    scariness.Clear();\n-    scariness.Scare(10, \"alloc-dealloc-mismatch\");\n   };\n   void Print();\n };\n \n struct ErrorMallocUsableSizeNotOwned : ErrorBase {\n-  // ErrorMallocUsableSizeNotOwned doesn't own the stack trace.\n   const BufferedStackTrace *stack;\n   AddressDescription addr_description;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorMallocUsableSizeNotOwned() = default;\n+\n+  ErrorMallocUsableSizeNotOwned() = default;  // (*)\n   ErrorMallocUsableSizeNotOwned(u32 tid, BufferedStackTrace *stack_, uptr addr)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"bad-malloc_usable_size\"),\n         stack(stack_),\n-        addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n-    scariness.Clear();\n-    scariness.Scare(10, \"bad-malloc_usable_size\");\n-  }\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false) {}\n   void Print();\n };\n \n struct ErrorSanitizerGetAllocatedSizeNotOwned : ErrorBase {\n-  // ErrorSanitizerGetAllocatedSizeNotOwned doesn't own the stack trace.\n   const BufferedStackTrace *stack;\n   AddressDescription addr_description;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorSanitizerGetAllocatedSizeNotOwned() = default;\n+\n+  ErrorSanitizerGetAllocatedSizeNotOwned() = default;  // (*)\n   ErrorSanitizerGetAllocatedSizeNotOwned(u32 tid, BufferedStackTrace *stack_,\n                                          uptr addr)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"bad-__sanitizer_get_allocated_size\"),\n         stack(stack_),\n-        addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n-    scariness.Clear();\n-    scariness.Scare(10, \"bad-__sanitizer_get_allocated_size\");\n-  }\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false) {}\n+  void Print();\n+};\n+\n+struct ErrorCallocOverflow : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr count;\n+  uptr size;\n+\n+  ErrorCallocOverflow() = default;  // (*)\n+  ErrorCallocOverflow(u32 tid, BufferedStackTrace *stack_, uptr count_,\n+                      uptr size_)\n+      : ErrorBase(tid, 10, \"calloc-overflow\"),\n+        stack(stack_),\n+        count(count_),\n+        size(size_) {}\n+  void Print();\n+};\n+\n+struct ErrorPvallocOverflow : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr size;\n+\n+  ErrorPvallocOverflow() = default;  // (*)\n+  ErrorPvallocOverflow(u32 tid, BufferedStackTrace *stack_, uptr size_)\n+      : ErrorBase(tid, 10, \"pvalloc-overflow\"),\n+        stack(stack_),\n+        size(size_) {}\n+  void Print();\n+};\n+\n+struct ErrorInvalidAllocationAlignment : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr alignment;\n+\n+  ErrorInvalidAllocationAlignment() = default;  // (*)\n+  ErrorInvalidAllocationAlignment(u32 tid, BufferedStackTrace *stack_,\n+                                  uptr alignment_)\n+      : ErrorBase(tid, 10, \"invalid-allocation-alignment\"),\n+        stack(stack_),\n+        alignment(alignment_) {}\n+  void Print();\n+};\n+\n+struct ErrorInvalidAlignedAllocAlignment : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr size;\n+  uptr alignment;\n+\n+  ErrorInvalidAlignedAllocAlignment() = default;  // (*)\n+  ErrorInvalidAlignedAllocAlignment(u32 tid, BufferedStackTrace *stack_,\n+                                    uptr size_, uptr alignment_)\n+      : ErrorBase(tid, 10, \"invalid-aligned-alloc-alignment\"),\n+        stack(stack_),\n+        size(size_),\n+        alignment(alignment_) {}\n+  void Print();\n+};\n+\n+struct ErrorInvalidPosixMemalignAlignment : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr alignment;\n+\n+  ErrorInvalidPosixMemalignAlignment() = default;  // (*)\n+  ErrorInvalidPosixMemalignAlignment(u32 tid, BufferedStackTrace *stack_,\n+                                     uptr alignment_)\n+      : ErrorBase(tid, 10, \"invalid-posix-memalign-alignment\"),\n+        stack(stack_),\n+        alignment(alignment_) {}\n+  void Print();\n+};\n+\n+struct ErrorAllocationSizeTooBig : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr user_size;\n+  uptr total_size;\n+  uptr max_size;\n+\n+  ErrorAllocationSizeTooBig() = default;  // (*)\n+  ErrorAllocationSizeTooBig(u32 tid, BufferedStackTrace *stack_,\n+                            uptr user_size_, uptr total_size_, uptr max_size_)\n+      : ErrorBase(tid, 10, \"allocation-size-too-big\"),\n+        stack(stack_),\n+        user_size(user_size_),\n+        total_size(total_size_),\n+        max_size(max_size_) {}\n+  void Print();\n+};\n+\n+struct ErrorRssLimitExceeded : ErrorBase {\n+  const BufferedStackTrace *stack;\n+\n+  ErrorRssLimitExceeded() = default;  // (*)\n+  ErrorRssLimitExceeded(u32 tid, BufferedStackTrace *stack_)\n+      : ErrorBase(tid, 10, \"rss-limit-exceeded\"),\n+        stack(stack_) {}\n+  void Print();\n+};\n+\n+struct ErrorOutOfMemory : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr requested_size;\n+\n+  ErrorOutOfMemory() = default;  // (*)\n+  ErrorOutOfMemory(u32 tid, BufferedStackTrace *stack_, uptr requested_size_)\n+      : ErrorBase(tid, 10, \"out-of-memory\"),\n+        stack(stack_),\n+        requested_size(requested_size_) {}\n   void Print();\n };\n \n struct ErrorStringFunctionMemoryRangesOverlap : ErrorBase {\n-  // ErrorStringFunctionMemoryRangesOverlap doesn't own the stack trace.\n   const BufferedStackTrace *stack;\n   uptr length1, length2;\n   AddressDescription addr1_description;\n   AddressDescription addr2_description;\n   const char *function;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorStringFunctionMemoryRangesOverlap() = default;\n+\n+  ErrorStringFunctionMemoryRangesOverlap() = default;  // (*)\n   ErrorStringFunctionMemoryRangesOverlap(u32 tid, BufferedStackTrace *stack_,\n                                          uptr addr1, uptr length1_, uptr addr2,\n                                          uptr length2_, const char *function_)\n@@ -189,86 +282,68 @@ struct ErrorStringFunctionMemoryRangesOverlap : ErrorBase {\n };\n \n struct ErrorStringFunctionSizeOverflow : ErrorBase {\n-  // ErrorStringFunctionSizeOverflow doesn't own the stack trace.\n   const BufferedStackTrace *stack;\n   AddressDescription addr_description;\n   uptr size;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorStringFunctionSizeOverflow() = default;\n+\n+  ErrorStringFunctionSizeOverflow() = default;  // (*)\n   ErrorStringFunctionSizeOverflow(u32 tid, BufferedStackTrace *stack_,\n                                   uptr addr, uptr size_)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"negative-size-param\"),\n         stack(stack_),\n         addr_description(addr, /*shouldLockThreadRegistry=*/false),\n-        size(size_) {\n-    scariness.Clear();\n-    scariness.Scare(10, \"negative-size-param\");\n-  }\n+        size(size_) {}\n   void Print();\n };\n \n struct ErrorBadParamsToAnnotateContiguousContainer : ErrorBase {\n-  // ErrorBadParamsToAnnotateContiguousContainer doesn't own the stack trace.\n   const BufferedStackTrace *stack;\n   uptr beg, end, old_mid, new_mid;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorBadParamsToAnnotateContiguousContainer() = default;\n+\n+  ErrorBadParamsToAnnotateContiguousContainer() = default;  // (*)\n   // PS4: Do we want an AddressDescription for beg?\n   ErrorBadParamsToAnnotateContiguousContainer(u32 tid,\n                                               BufferedStackTrace *stack_,\n                                               uptr beg_, uptr end_,\n                                               uptr old_mid_, uptr new_mid_)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"bad-__sanitizer_annotate_contiguous_container\"),\n         stack(stack_),\n         beg(beg_),\n         end(end_),\n         old_mid(old_mid_),\n-        new_mid(new_mid_) {\n-    scariness.Clear();\n-    scariness.Scare(10, \"bad-__sanitizer_annotate_contiguous_container\");\n-  }\n+        new_mid(new_mid_) {}\n   void Print();\n };\n \n struct ErrorODRViolation : ErrorBase {\n   __asan_global global1, global2;\n   u32 stack_id1, stack_id2;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorODRViolation() = default;\n+\n+  ErrorODRViolation() = default;  // (*)\n   ErrorODRViolation(u32 tid, const __asan_global *g1, u32 stack_id1_,\n                     const __asan_global *g2, u32 stack_id2_)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"odr-violation\"),\n         global1(*g1),\n         global2(*g2),\n         stack_id1(stack_id1_),\n-        stack_id2(stack_id2_) {\n-    scariness.Clear();\n-    scariness.Scare(10, \"odr-violation\");\n-  }\n+        stack_id2(stack_id2_) {}\n   void Print();\n };\n \n struct ErrorInvalidPointerPair : ErrorBase {\n   uptr pc, bp, sp;\n   AddressDescription addr1_description;\n   AddressDescription addr2_description;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorInvalidPointerPair() = default;\n+\n+  ErrorInvalidPointerPair() = default;  // (*)\n   ErrorInvalidPointerPair(u32 tid, uptr pc_, uptr bp_, uptr sp_, uptr p1,\n                           uptr p2)\n-      : ErrorBase(tid),\n+      : ErrorBase(tid, 10, \"invalid-pointer-pair\"),\n         pc(pc_),\n         bp(bp_),\n         sp(sp_),\n         addr1_description(p1, 1, /*shouldLockThreadRegistry=*/false),\n-        addr2_description(p2, 1, /*shouldLockThreadRegistry=*/false)  {\n-    scariness.Clear();\n-    scariness.Scare(10, \"invalid-pointer-pair\");\n-  }\n+        addr2_description(p2, 1, /*shouldLockThreadRegistry=*/false) {}\n   void Print();\n };\n \n@@ -279,9 +354,8 @@ struct ErrorGeneric : ErrorBase {\n   const char *bug_descr;\n   bool is_write;\n   u8 shadow_val;\n-  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n-  // constructor\n-  ErrorGeneric() = default;\n+\n+  ErrorGeneric() = default;  // (*)\n   ErrorGeneric(u32 tid, uptr addr, uptr pc_, uptr bp_, uptr sp_, bool is_write_,\n                uptr access_size_);\n   void Print();\n@@ -291,11 +365,19 @@ struct ErrorGeneric : ErrorBase {\n #define ASAN_FOR_EACH_ERROR_KIND(macro)         \\\n   macro(DeadlySignal)                           \\\n   macro(DoubleFree)                             \\\n-  macro(NewDeleteSizeMismatch)                  \\\n+  macro(NewDeleteTypeMismatch)                  \\\n   macro(FreeNotMalloced)                        \\\n   macro(AllocTypeMismatch)                      \\\n   macro(MallocUsableSizeNotOwned)               \\\n   macro(SanitizerGetAllocatedSizeNotOwned)      \\\n+  macro(CallocOverflow)                         \\\n+  macro(PvallocOverflow)                        \\\n+  macro(InvalidAllocationAlignment)             \\\n+  macro(InvalidAlignedAllocAlignment)           \\\n+  macro(InvalidPosixMemalignAlignment)          \\\n+  macro(AllocationSizeTooBig)                   \\\n+  macro(RssLimitExceeded)                       \\\n+  macro(OutOfMemory)                            \\\n   macro(StringFunctionMemoryRangesOverlap)      \\\n   macro(StringFunctionSizeOverflow)             \\\n   macro(BadParamsToAnnotateContiguousContainer) \\\n@@ -330,6 +412,7 @@ struct ErrorDescription {\n   };\n \n   ErrorDescription() { internal_memset(this, 0, sizeof(*this)); }\n+  explicit ErrorDescription(LinkerInitialized) {}\n   ASAN_FOR_EACH_ERROR_KIND(ASAN_ERROR_DESCRIPTION_CONSTRUCTOR)\n \n   bool IsValid() { return kind != kErrorKindInvalid; }"}, {"sha": "f4a5bb75c28aa3ee71fd3533907a5950978fc306", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -26,9 +26,9 @@ static const u64 kAllocaRedzoneMask = 31UL;\n \n // For small size classes inline PoisonShadow for better performance.\n ALWAYS_INLINE void SetShadow(uptr ptr, uptr size, uptr class_id, u64 magic) {\n-  CHECK_EQ(SHADOW_SCALE, 3);  // This code expects SHADOW_SCALE=3.\n   u64 *shadow = reinterpret_cast<u64*>(MemToShadow(ptr));\n-  if (class_id <= 6) {\n+  if (SHADOW_SCALE == 3 && class_id <= 6) {\n+    // This code expects SHADOW_SCALE=3.\n     for (uptr i = 0; i < (((uptr)1) << class_id); i++) {\n       shadow[i] = magic;\n       // Make sure this does not become memset."}, {"sha": "522fce30f052f93983023477e6ad71c4fd7705e6", "filename": "libsanitizer/asan/asan_flags.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -31,10 +31,7 @@ static const char *MaybeCallAsanDefaultOptions() {\n \n static const char *MaybeUseAsanDefaultOptionsCompileDefinition() {\n #ifdef ASAN_DEFAULT_OPTIONS\n-// Stringize the macro value.\n-# define ASAN_STRINGIZE(x) #x\n-# define ASAN_STRINGIZE_OPTIONS(options) ASAN_STRINGIZE(options)\n-  return ASAN_STRINGIZE_OPTIONS(ASAN_DEFAULT_OPTIONS);\n+  return SANITIZER_STRINGIFY(ASAN_DEFAULT_OPTIONS);\n #else\n   return \"\";\n #endif\n@@ -146,6 +143,9 @@ void InitializeFlags() {\n            SanitizerToolName);\n     Die();\n   }\n+  // Ensure that redzone is at least SHADOW_GRANULARITY.\n+  if (f->redzone < (int)SHADOW_GRANULARITY)\n+    f->redzone = SHADOW_GRANULARITY;\n   // Make \"strict_init_order\" imply \"check_initialization_order\".\n   // TODO(samsonov): Use a single runtime flag for an init-order checker.\n   if (f->strict_init_order) {\n@@ -158,6 +158,10 @@ void InitializeFlags() {\n   CHECK_LE(f->max_redzone, 2048);\n   CHECK(IsPowerOfTwo(f->redzone));\n   CHECK(IsPowerOfTwo(f->max_redzone));\n+  if (SANITIZER_RTEMS) {\n+    CHECK(!f->unmap_shadow_on_exit);\n+    CHECK(!f->protect_shadow_gap);\n+  }\n \n   // quarantine_size is deprecated but we still honor it.\n   // quarantine_size can not be used together with quarantine_size_mb."}, {"sha": "9cd1f60db605267efc0cd195ed5e2ef429b7a801", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -86,7 +86,8 @@ ASAN_FLAG(bool, check_malloc_usable_size, true,\n           \"295.*.\")\n ASAN_FLAG(bool, unmap_shadow_on_exit, false,\n           \"If set, explicitly unmaps the (huge) shadow at exit.\")\n-ASAN_FLAG(bool, protect_shadow_gap, true, \"If set, mprotect the shadow gap\")\n+ASAN_FLAG(bool, protect_shadow_gap, !SANITIZER_RTEMS,\n+          \"If set, mprotect the shadow gap\")\n ASAN_FLAG(bool, print_stats, false,\n           \"Print various statistics after printing an error message or if \"\n           \"atexit=1.\")"}, {"sha": "f8207ecccd13425a7ab6b837ff41978532c0d22f", "filename": "libsanitizer/asan/asan_fuchsia.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fuchsia.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -26,7 +26,7 @@\n namespace __asan {\n \n // The system already set up the shadow memory for us.\n-// __sanitizer::GetMaxVirtualAddress has already been called by\n+// __sanitizer::GetMaxUserVirtualAddress has already been called by\n // AsanInitInternal->InitializeHighMemEnd (asan_rtl.cc).\n // Just do some additional sanity checks here.\n void InitializeShadowMemory() {"}, {"sha": "34963156346224d0442517fe1f4abe0b8aa053ab", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -147,6 +147,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -194,6 +211,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);\n@@ -203,8 +222,9 @@ static void RegisterGlobal(const Global *g) {\n   list_of_all_globals = l;\n   if (g->has_dynamic_init) {\n     if (!dynamic_init_globals) {\n-      dynamic_init_globals = new(allocator_for_globals)\n-          VectorOfGlobals(kDynamicInitGlobalsInitialCapacity);\n+      dynamic_init_globals =\n+          new (allocator_for_globals) VectorOfGlobals;  // NOLINT\n+      dynamic_init_globals->reserve(kDynamicInitGlobalsInitialCapacity);\n     }\n     DynInitGlobal dyn_global = { *g, false };\n     dynamic_init_globals->push_back(dyn_global);\n@@ -337,9 +357,11 @@ void __asan_register_globals(__asan_global *globals, uptr n) {\n   GET_STACK_TRACE_MALLOC;\n   u32 stack_id = StackDepotPut(stack);\n   BlockingMutexLock lock(&mu_for_globals);\n-  if (!global_registration_site_vector)\n+  if (!global_registration_site_vector) {\n     global_registration_site_vector =\n-        new(allocator_for_globals) GlobalRegistrationSiteVector(128);\n+        new (allocator_for_globals) GlobalRegistrationSiteVector;  // NOLINT\n+    global_registration_site_vector->reserve(128);\n+  }\n   GlobalRegistrationSite site = {stack_id, &globals[0], &globals[n - 1]};\n   global_registration_site_vector->push_back(site);\n   if (flags()->report_globals >= 2) {"}, {"sha": "a78bc878f9c53f61892f279316dcb521b9e84ee2", "filename": "libsanitizer/asan/asan_globals_win.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_globals_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_globals_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -17,17 +17,17 @@ namespace __asan {\n #pragma section(\".ASAN$GA\", read, write)  // NOLINT\n #pragma section(\".ASAN$GZ\", read, write)  // NOLINT\n extern \"C\" __declspec(allocate(\".ASAN$GA\"))\n-__asan_global __asan_globals_start = {};\n+    ALIGNED(sizeof(__asan_global)) __asan_global __asan_globals_start = {};\n extern \"C\" __declspec(allocate(\".ASAN$GZ\"))\n-__asan_global __asan_globals_end = {};\n+    ALIGNED(sizeof(__asan_global)) __asan_global __asan_globals_end = {};\n #pragma comment(linker, \"/merge:.ASAN=.data\")\n \n static void call_on_globals(void (*hook)(__asan_global *, uptr)) {\n   __asan_global *start = &__asan_globals_start + 1;\n   __asan_global *end = &__asan_globals_end;\n   uptr bytediff = (uptr)end - (uptr)start;\n   if (bytediff % sizeof(__asan_global) != 0) {\n-#ifdef SANITIZER_DLL_THUNK\n+#if defined(SANITIZER_DLL_THUNK) || defined(SANITIZER_DYNAMIC_RUNTIME_THUNK)\n     __debugbreak();\n #else\n     CHECK(\"corrupt asan global array\");"}, {"sha": "7833133938d693a5899ecd143f688e82f1dbc0c0", "filename": "libsanitizer/asan/asan_init_version.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_init_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_init_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_init_version.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -13,6 +13,8 @@\n #ifndef ASAN_INIT_VERSION_H\n #define ASAN_INIT_VERSION_H\n \n+#include \"sanitizer_common/sanitizer_platform.h\"\n+\n extern \"C\" {\n   // Every time the ASan ABI changes we also change the version number in the\n   // __asan_init function name.  Objects built with incompatible ASan ABI\n@@ -30,7 +32,12 @@ extern \"C\" {\n   // v6=>v7: added 'odr_indicator' to __asan_global\n   // v7=>v8: added '__asan_(un)register_image_globals' functions for dead\n   //         stripping support on Mach-O platforms\n+#if SANITIZER_WORDSIZE == 32 && SANITIZER_ANDROID\n+  // v8=>v9: 32-bit Android switched to dynamic shadow\n+  #define __asan_version_mismatch_check __asan_version_mismatch_check_v9\n+#else\n   #define __asan_version_mismatch_check __asan_version_mismatch_check_v8\n+#endif\n }\n \n #endif  // ASAN_INIT_VERSION_H"}, {"sha": "fc9818bee8a22718a9844a4a07cfe0e9ccb5fcc8", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -22,15 +22,20 @@\n #include \"lsan/lsan_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n-// There is no general interception at all on Fuchsia.\n+// There is no general interception at all on Fuchsia and RTEMS.\n // Only the functions in asan_interceptors_memintrinsics.cc are\n // really defined to replace libc functions.\n-#if !SANITIZER_FUCHSIA\n+#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n #if SANITIZER_POSIX\n #include \"sanitizer_common/sanitizer_posix.h\"\n #endif\n \n+#if ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION || \\\n+    ASAN_INTERCEPT__SJLJ_UNWIND_RAISEEXCEPTION\n+#include <unwind.h>\n+#endif\n+\n #if defined(__i386) && SANITIZER_LINUX\n #define ASAN_PTHREAD_CREATE_VERSION \"GLIBC_2.1\"\n #elif defined(__mips__) && SANITIZER_LINUX\n@@ -176,6 +181,7 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n     (void)(s);                                \\\n   } while (false)\n #include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n+#include \"sanitizer_common/sanitizer_syscalls_netbsd.inc\"\n \n struct ThreadStartParam {\n   atomic_uintptr_t t;\n@@ -324,6 +330,32 @@ INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n }\n #endif\n \n+#if ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION\n+INTERCEPTOR(void, __cxa_rethrow_primary_exception, void *a) {\n+  CHECK(REAL(__cxa_rethrow_primary_exception));\n+  __asan_handle_no_return();\n+  REAL(__cxa_rethrow_primary_exception)(a);\n+}\n+#endif\n+\n+#if ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION\n+INTERCEPTOR(_Unwind_Reason_Code, _Unwind_RaiseException,\n+            _Unwind_Exception *object) {\n+  CHECK(REAL(_Unwind_RaiseException));\n+  __asan_handle_no_return();\n+  return REAL(_Unwind_RaiseException)(object);\n+}\n+#endif\n+\n+#if ASAN_INTERCEPT__SJLJ_UNWIND_RAISEEXCEPTION\n+INTERCEPTOR(_Unwind_Reason_Code, _Unwind_SjLj_RaiseException,\n+            _Unwind_Exception *object) {\n+  CHECK(REAL(_Unwind_SjLj_RaiseException));\n+  __asan_handle_no_return();\n+  return REAL(_Unwind_SjLj_RaiseException)(object);\n+}\n+#endif\n+\n #if ASAN_INTERCEPT_INDEX\n # if ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n INTERCEPTOR(char*, index, const char *string, int c)\n@@ -546,14 +578,6 @@ INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n }\n #endif  // ASAN_INTERCEPT___CXA_ATEXIT\n \n-#if ASAN_INTERCEPT_FORK\n-INTERCEPTOR(int, fork, void) {\n-  ENSURE_ASAN_INITED();\n-  int pid = REAL(fork)();\n-  return pid;\n-}\n-#endif  // ASAN_INTERCEPT_FORK\n-\n // ---------------------- InitializeAsanInterceptors ---------------- {{{1\n namespace __asan {\n void InitializeAsanInterceptors() {\n@@ -604,6 +628,17 @@ void InitializeAsanInterceptors() {\n #if ASAN_INTERCEPT___CXA_THROW\n   ASAN_INTERCEPT_FUNC(__cxa_throw);\n #endif\n+#if ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION\n+  ASAN_INTERCEPT_FUNC(__cxa_rethrow_primary_exception);\n+#endif\n+  // Indirectly intercept std::rethrow_exception.\n+#if ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION\n+  INTERCEPT_FUNCTION(_Unwind_RaiseException);\n+#endif\n+  // Indirectly intercept std::rethrow_exception.\n+#if ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION\n+  INTERCEPT_FUNCTION(_Unwind_SjLj_RaiseException);\n+#endif\n \n   // Intercept threading-related functions\n #if ASAN_INTERCEPT_PTHREAD_CREATE\n@@ -620,10 +655,6 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(__cxa_atexit);\n #endif\n \n-#if ASAN_INTERCEPT_FORK\n-  ASAN_INTERCEPT_FUNC(fork);\n-#endif\n-\n   InitializePlatformInterceptors();\n \n   VReport(1, \"AddressSanitizer: libc interceptors initialized\\n\");"}, {"sha": "b599ebb0ba91b5c3800f35ed753aabb3563c375a", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -32,10 +32,10 @@ void InitializePlatformInterceptors();\n \n }  // namespace __asan\n \n-// There is no general interception at all on Fuchsia.\n+// There is no general interception at all on Fuchsia and RTEMS.\n // Only the functions in asan_interceptors_memintrinsics.h are\n // really defined to replace libc functions.\n-#if !SANITIZER_FUCHSIA\n+#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n // Use macro to describe if specific function should be\n // intercepted on a given platform.\n@@ -44,22 +44,21 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT__LONGJMP 1\n # define ASAN_INTERCEPT_INDEX 1\n # define ASAN_INTERCEPT_PTHREAD_CREATE 1\n-# define ASAN_INTERCEPT_FORK 1\n #else\n # define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n # define ASAN_INTERCEPT__LONGJMP 0\n # define ASAN_INTERCEPT_INDEX 0\n # define ASAN_INTERCEPT_PTHREAD_CREATE 0\n-# define ASAN_INTERCEPT_FORK 0\n #endif\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD || \\\n+    SANITIZER_SOLARIS\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n #else\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_SOLARIS\n # define ASAN_INTERCEPT_SWAPCONTEXT 1\n #else\n # define ASAN_INTERCEPT_SWAPCONTEXT 0\n@@ -77,12 +76,20 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT___LONGJMP_CHK 0\n #endif\n \n-// Android bug: https://code.google.com/p/android/issues/detail?id=61799\n-#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && \\\n-    !(SANITIZER_ANDROID && defined(__i386))\n+#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n+    !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n+# if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n+#  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n+# else\n+#  define ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION 1\n+# endif\n #else\n # define ASAN_INTERCEPT___CXA_THROW 0\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n+# define ASAN_INTERCEPT__UNWIND_RAISEEXCEPTION 0\n+# define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 0\n #endif\n \n #if !SANITIZER_WINDOWS\n@@ -103,9 +110,6 @@ DECLARE_REAL(SIZE_T, strlen, const char *s)\n DECLARE_REAL(char*, strncpy, char *to, const char *from, uptr size)\n DECLARE_REAL(uptr, strnlen, const char *s, uptr maxlen)\n DECLARE_REAL(char*, strstr, const char *s1, const char *s2)\n-struct sigaction;\n-DECLARE_REAL(int, sigaction, int signum, const struct sigaction *act,\n-                             struct sigaction *oldact)\n \n #if !SANITIZER_MAC\n #define ASAN_INTERCEPT_FUNC(name)                                        \\"}, {"sha": "b0c06a04caca4f4789345cb5fa15e62243826c7b", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -29,14 +29,14 @@ void *__asan_memmove(void *to, const void *from, uptr size) {\n   ASAN_MEMMOVE_IMPL(nullptr, to, from, size);\n }\n \n-#if SANITIZER_FUCHSIA\n+#if SANITIZER_FUCHSIA || SANITIZER_RTEMS\n \n-// Fuchsia doesn't use sanitizer_common_interceptors.inc, but the only\n-// things there it wants are these three.  Just define them as aliases\n-// here rather than repeating the contents.\n+// Fuchsia and RTEMS don't use sanitizer_common_interceptors.inc, but\n+// the only things there it wants are these three.  Just define them\n+// as aliases here rather than repeating the contents.\n \n-decltype(memcpy) memcpy[[gnu::alias(\"__asan_memcpy\")]];\n-decltype(memmove) memmove[[gnu::alias(\"__asan_memmove\")]];\n-decltype(memset) memset[[gnu::alias(\"__asan_memset\")]];\n+extern \"C\" decltype(__asan_memcpy) memcpy[[gnu::alias(\"__asan_memcpy\")]];\n+extern \"C\" decltype(__asan_memmove) memmove[[gnu::alias(\"__asan_memmove\")]];\n+extern \"C\" decltype(__asan_memset) memset[[gnu::alias(\"__asan_memset\")]];\n \n-#endif  // SANITIZER_FUCHSIA\n+#endif  // SANITIZER_FUCHSIA || SANITIZER_RTEMS"}, {"sha": "faf8119c9373059679fdac009e71b1d8a1333289", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -131,15 +131,22 @@ static inline bool RangesOverlap(const char *offset1, uptr length1,\n                                  const char *offset2, uptr length2) {\n   return !((offset1 + length1 <= offset2) || (offset2 + length2 <= offset1));\n }\n-#define CHECK_RANGES_OVERLAP(name, _offset1, length1, _offset2, length2) do { \\\n-  const char *offset1 = (const char*)_offset1; \\\n-  const char *offset2 = (const char*)_offset2; \\\n-  if (RangesOverlap(offset1, length1, offset2, length2)) { \\\n-    GET_STACK_TRACE_FATAL_HERE; \\\n-    ReportStringFunctionMemoryRangesOverlap(name, offset1, length1, \\\n-                                            offset2, length2, &stack); \\\n-  } \\\n-} while (0)\n+#define CHECK_RANGES_OVERLAP(name, _offset1, length1, _offset2, length2)   \\\n+  do {                                                                     \\\n+    const char *offset1 = (const char *)_offset1;                          \\\n+    const char *offset2 = (const char *)_offset2;                          \\\n+    if (RangesOverlap(offset1, length1, offset2, length2)) {               \\\n+      GET_STACK_TRACE_FATAL_HERE;                                          \\\n+      bool suppressed = IsInterceptorSuppressed(name);                     \\\n+      if (!suppressed && HaveStackTraceBasedSuppressions()) {              \\\n+        suppressed = IsStackTraceSuppressed(&stack);                       \\\n+      }                                                                    \\\n+      if (!suppressed) {                                                   \\\n+        ReportStringFunctionMemoryRangesOverlap(name, offset1, length1,    \\\n+                                                offset2, length2, &stack); \\\n+      }                                                                    \\\n+    }                                                                      \\\n+  } while (0)\n \n }  // namespace __asan\n "}, {"sha": "7c239895e39f472a7ef2fee6093e440a0154bf38", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -34,7 +34,7 @@\n // If set, values like allocator chunk size, as well as defaults for some flags\n // will be changed towards less memory overhead.\n #ifndef ASAN_LOW_MEMORY\n-# if SANITIZER_IOS || SANITIZER_ANDROID\n+# if SANITIZER_IOS || SANITIZER_ANDROID || SANITIZER_RTEMS\n #  define ASAN_LOW_MEMORY 1\n # else\n #  define ASAN_LOW_MEMORY 0\n@@ -76,7 +76,7 @@ void InitializeShadowMemory();\n // asan_malloc_linux.cc / asan_malloc_mac.cc\n void ReplaceSystemMalloc();\n \n-// asan_linux.cc / asan_mac.cc / asan_win.cc\n+// asan_linux.cc / asan_mac.cc / asan_rtems.cc / asan_win.cc\n uptr FindDynamicShadowStart();\n void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n@@ -145,6 +145,9 @@ const int kAsanArrayCookieMagic = 0xac;\n const int kAsanIntraObjectRedzone = 0xbb;\n const int kAsanAllocaLeftMagic = 0xca;\n const int kAsanAllocaRightMagic = 0xcb;\n+// Used to populate the shadow gap for systems without memory\n+// protection there (i.e. Myriad).\n+const int kAsanShadowGap = 0xcc;\n \n static const uptr kCurrentStackFrameMagic = 0x41B58AB3;\n static const uptr kRetiredStackFrameMagic = 0x45E0360E;"}, {"sha": "d92d0596b7cce2009504ba45f2562d7de7f85752", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -11,10 +11,12 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD || \\\n+    SANITIZER_SOLARIS\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n+#include \"asan_premap_shadow.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_freebsd.h\"\n@@ -28,6 +30,7 @@\n #include <sys/types.h>\n #include <dlfcn.h>\n #include <fcntl.h>\n+#include <limits.h>\n #include <pthread.h>\n #include <stdio.h>\n #include <unistd.h>\n@@ -37,7 +40,11 @@\n #include <sys/link_elf.h>\n #endif\n \n-#if SANITIZER_ANDROID || SANITIZER_FREEBSD\n+#if SANITIZER_SOLARIS\n+#include <link.h>\n+#endif\n+\n+#if SANITIZER_ANDROID || SANITIZER_FREEBSD || SANITIZER_SOLARIS\n #include <ucontext.h>\n extern \"C\" void* _DYNAMIC;\n #elif SANITIZER_NETBSD\n@@ -79,9 +86,51 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return &_DYNAMIC;  // defined in link.h\n }\n \n+static void UnmapFromTo(uptr from, uptr to) {\n+  CHECK(to >= from);\n+  if (to == from) return;\n+  uptr res = internal_munmap(reinterpret_cast<void *>(from), to - from);\n+  if (UNLIKELY(internal_iserror(res))) {\n+    Report(\n+        \"ERROR: AddresSanitizer failed to unmap 0x%zx (%zd) bytes at address \"\n+        \"%p\\n\",\n+        to - from, to - from, from);\n+    CHECK(\"unable to unmap\" && 0);\n+  }\n+}\n+\n+#if ASAN_PREMAP_SHADOW\n+uptr FindPremappedShadowStart() {\n+  uptr granularity = GetMmapGranularity();\n+  uptr shadow_start = reinterpret_cast<uptr>(&__asan_shadow);\n+  uptr premap_shadow_size = PremapShadowSize();\n+  uptr shadow_size = RoundUpTo(kHighShadowEnd, granularity);\n+  // We may have mapped too much. Release extra memory.\n+  UnmapFromTo(shadow_start + shadow_size, shadow_start + premap_shadow_size);\n+  return shadow_start;\n+}\n+#endif\n+\n uptr FindDynamicShadowStart() {\n-  UNREACHABLE(\"FindDynamicShadowStart is not available\");\n-  return 0;\n+#if ASAN_PREMAP_SHADOW\n+  if (!PremapShadowFailed())\n+    return FindPremappedShadowStart();\n+#endif\n+\n+  uptr granularity = GetMmapGranularity();\n+  uptr alignment = granularity * 8;\n+  uptr left_padding = granularity;\n+  uptr shadow_size = RoundUpTo(kHighShadowEnd, granularity);\n+  uptr map_size = shadow_size + left_padding + alignment;\n+\n+  uptr map_start = (uptr)MmapNoAccess(map_size);\n+  CHECK_NE(map_start, ~(uptr)0);\n+\n+  uptr shadow_start = RoundUpTo(map_start + left_padding, alignment);\n+  UnmapFromTo(map_start, shadow_start - left_padding);\n+  UnmapFromTo(shadow_start + shadow_size, map_start + map_size);\n+\n+  return shadow_start;\n }\n \n void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n@@ -95,6 +144,9 @@ void AsanCheckIncompatibleRT() {}\n #else\n static int FindFirstDSOCallback(struct dl_phdr_info *info, size_t size,\n                                 void *data) {\n+  VReport(2, \"info->dlpi_name = %s\\tinfo->dlpi_addr = %p\\n\",\n+          info->dlpi_name, info->dlpi_addr);\n+\n   // Continue until the first dynamic library is found\n   if (!info->dlpi_name || info->dlpi_name[0] == 0)\n     return 0;\n@@ -103,7 +155,7 @@ static int FindFirstDSOCallback(struct dl_phdr_info *info, size_t size,\n   if (internal_strncmp(info->dlpi_name, \"linux-\", sizeof(\"linux-\") - 1) == 0)\n     return 0;\n \n-#if SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n   // Ignore first entry (the main program)\n   char **p = (char **)data;\n   if (!(*p)) {\n@@ -112,6 +164,12 @@ static int FindFirstDSOCallback(struct dl_phdr_info *info, size_t size,\n   }\n #endif\n \n+#if SANITIZER_SOLARIS\n+  // Ignore executable on Solaris\n+  if (info->dlpi_addr == 0)\n+    return 0;\n+#endif\n+\n   *(const char **)data = info->dlpi_name;\n   return 1;\n }\n@@ -155,7 +213,7 @@ void AsanCheckIncompatibleRT() {\n       // the functions in dynamic ASan runtime instead of the functions in\n       // system libraries, causing crashes later in ASan initialization.\n       MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n-      char filename[128];\n+      char filename[PATH_MAX];\n       MemoryMappedSegment segment(filename, sizeof(filename));\n       while (proc_maps.Next(&segment)) {\n         if (IsDynamicRTName(segment.filename)) {\n@@ -190,4 +248,5 @@ void *AsanDlSymNext(const char *sym) {\n \n } // namespace __asan\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD ||\n+        // SANITIZER_SOLARIS"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libsanitizer/asan/asan_lock.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_lock.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -1 +0,0 @@\n-"}, {"sha": "89a3db4c2fb33e91454d98af18c8900d14b67f44", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -60,16 +60,36 @@ uptr FindDynamicShadowStart() {\n   uptr space_size = kHighShadowEnd + left_padding;\n \n   uptr largest_gap_found = 0;\n-  uptr shadow_start = FindAvailableMemoryRange(space_size, alignment,\n-                                               granularity, &largest_gap_found);\n+  uptr max_occupied_addr = 0;\n+  VReport(2, \"FindDynamicShadowStart, space_size = %p\\n\", space_size);\n+  uptr shadow_start =\n+      FindAvailableMemoryRange(space_size, alignment, granularity,\n+                               &largest_gap_found, &max_occupied_addr);\n   // If the shadow doesn't fit, restrict the address space to make it fit.\n   if (shadow_start == 0) {\n+    VReport(\n+        2,\n+        \"Shadow doesn't fit, largest_gap_found = %p, max_occupied_addr = %p\\n\",\n+        largest_gap_found, max_occupied_addr);\n     uptr new_max_vm = RoundDownTo(largest_gap_found << SHADOW_SCALE, alignment);\n+    if (new_max_vm < max_occupied_addr) {\n+      Report(\"Unable to find a memory range for dynamic shadow.\\n\");\n+      Report(\n+          \"space_size = %p, largest_gap_found = %p, max_occupied_addr = %p, \"\n+          \"new_max_vm = %p\\n\",\n+          space_size, largest_gap_found, max_occupied_addr, new_max_vm);\n+      CHECK(0 && \"cannot place shadow\");\n+    }\n     RestrictMemoryToMaxAddress(new_max_vm);\n     kHighMemEnd = new_max_vm - 1;\n     space_size = kHighShadowEnd + left_padding;\n-    shadow_start =\n-        FindAvailableMemoryRange(space_size, alignment, granularity, nullptr);\n+    VReport(2, \"FindDynamicShadowStart, space_size = %p\\n\", space_size);\n+    shadow_start = FindAvailableMemoryRange(space_size, alignment, granularity,\n+                                            nullptr, nullptr);\n+    if (shadow_start == 0) {\n+      Report(\"Unable to find a memory range after restricting VM.\\n\");\n+      CHECK(0 && \"cannot place shadow after restricting vm\");\n+    }\n   }\n   CHECK_NE((uptr)0, shadow_start);\n   CHECK(IsAligned(shadow_start, alignment));"}, {"sha": "a6e692759ce921848c9c70f14c85db80628ca304", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 71, "deletions": 10, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -14,19 +14,23 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_FREEBSD || SANITIZER_FUCHSIA || SANITIZER_LINUX || \\\n-    SANITIZER_NETBSD\n+    SANITIZER_NETBSD || SANITIZER_RTEMS || SANITIZER_SOLARIS\n \n+#include \"sanitizer_common/sanitizer_allocator_checks.h\"\n+#include \"sanitizer_common/sanitizer_errno.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n+#include \"asan_malloc_local.h\"\n #include \"asan_stack.h\"\n \n // ---------------------- Replacement functions ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n static uptr allocated_for_dlsym;\n-static const uptr kDlsymAllocPoolSize = 1024;\n+static uptr last_dlsym_alloc_size_in_words;\n+static const uptr kDlsymAllocPoolSize = SANITIZER_RTEMS ? 4096 : 1024;\n static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n \n static INLINE bool IsInDlsymAllocPool(const void *ptr) {\n@@ -37,21 +41,73 @@ static INLINE bool IsInDlsymAllocPool(const void *ptr) {\n static void *AllocateFromLocalPool(uptr size_in_bytes) {\n   uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;\n   void *mem = (void*)&alloc_memory_for_dlsym[allocated_for_dlsym];\n+  last_dlsym_alloc_size_in_words = size_in_words;\n   allocated_for_dlsym += size_in_words;\n   CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);\n   return mem;\n }\n \n+static void DeallocateFromLocalPool(const void *ptr) {\n+  // Hack: since glibc 2.27 dlsym no longer uses stack-allocated memory to store\n+  // error messages and instead uses malloc followed by free. To avoid pool\n+  // exhaustion due to long object filenames, handle that special case here.\n+  uptr prev_offset = allocated_for_dlsym - last_dlsym_alloc_size_in_words;\n+  void *prev_mem = (void*)&alloc_memory_for_dlsym[prev_offset];\n+  if (prev_mem == ptr) {\n+    REAL(memset)(prev_mem, 0, last_dlsym_alloc_size_in_words * kWordSize);\n+    allocated_for_dlsym = prev_offset;\n+    last_dlsym_alloc_size_in_words = 0;\n+  }\n+}\n+\n+static int PosixMemalignFromLocalPool(void **memptr, uptr alignment,\n+                                      uptr size_in_bytes) {\n+  if (UNLIKELY(!CheckPosixMemalignAlignment(alignment)))\n+    return errno_EINVAL;\n+\n+  CHECK(alignment >= kWordSize);\n+\n+  uptr addr = (uptr)&alloc_memory_for_dlsym[allocated_for_dlsym];\n+  uptr aligned_addr = RoundUpTo(addr, alignment);\n+  uptr aligned_size = RoundUpTo(size_in_bytes, kWordSize);\n+\n+  uptr *end_mem = (uptr*)(aligned_addr + aligned_size);\n+  uptr allocated = end_mem - alloc_memory_for_dlsym;\n+  if (allocated >= kDlsymAllocPoolSize)\n+    return errno_ENOMEM;\n+\n+  allocated_for_dlsym = allocated;\n+  *memptr = (void*)aligned_addr;\n+  return 0;\n+}\n+\n+#if SANITIZER_RTEMS\n+void* MemalignFromLocalPool(uptr alignment, uptr size) {\n+  void *ptr = nullptr;\n+  alignment = Max(alignment, kWordSize);\n+  PosixMemalignFromLocalPool(&ptr, alignment, size);\n+  return ptr;\n+}\n+\n+bool IsFromLocalPool(const void *ptr) {\n+  return IsInDlsymAllocPool(ptr);\n+}\n+#endif\n+\n static INLINE bool MaybeInDlsym() {\n   // Fuchsia doesn't use dlsym-based interceptors.\n   return !SANITIZER_FUCHSIA && asan_init_is_running;\n }\n \n+static INLINE bool UseLocalPool() {\n+  return EarlyMalloc() || MaybeInDlsym();\n+}\n+\n static void *ReallocFromLocalPool(void *ptr, uptr size) {\n   const uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n   const uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n   void *new_ptr;\n-  if (UNLIKELY(MaybeInDlsym())) {\n+  if (UNLIKELY(UseLocalPool())) {\n     new_ptr = AllocateFromLocalPool(size);\n   } else {\n     ENSURE_ASAN_INITED();\n@@ -64,8 +120,10 @@ static void *ReallocFromLocalPool(void *ptr, uptr size) {\n \n INTERCEPTOR(void, free, void *ptr) {\n   GET_STACK_TRACE_FREE;\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n+  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n+    DeallocateFromLocalPool(ptr);\n     return;\n+  }\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n@@ -79,7 +137,7 @@ INTERCEPTOR(void, cfree, void *ptr) {\n #endif // SANITIZER_INTERCEPT_CFREE\n \n INTERCEPTOR(void*, malloc, uptr size) {\n-  if (UNLIKELY(MaybeInDlsym()))\n+  if (UNLIKELY(UseLocalPool()))\n     // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n     return AllocateFromLocalPool(size);\n   ENSURE_ASAN_INITED();\n@@ -88,7 +146,7 @@ INTERCEPTOR(void*, malloc, uptr size) {\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n-  if (UNLIKELY(MaybeInDlsym()))\n+  if (UNLIKELY(UseLocalPool()))\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n     return AllocateFromLocalPool(nmemb * size);\n   ENSURE_ASAN_INITED();\n@@ -99,7 +157,7 @@ INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n INTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n   if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n     return ReallocFromLocalPool(ptr, size);\n-  if (UNLIKELY(MaybeInDlsym()))\n+  if (UNLIKELY(UseLocalPool()))\n     return AllocateFromLocalPool(size);\n   ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n@@ -120,10 +178,12 @@ INTERCEPTOR(void*, __libc_memalign, uptr boundary, uptr size) {\n }\n #endif // SANITIZER_INTERCEPT_MEMALIGN\n \n+#if SANITIZER_INTERCEPT_ALIGNED_ALLOC\n INTERCEPTOR(void*, aligned_alloc, uptr boundary, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n-  return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n+  return asan_aligned_alloc(boundary, size, &stack);\n }\n+#endif // SANITIZER_INTERCEPT_ALIGNED_ALLOC\n \n INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n   GET_CURRENT_PC_BP_SP;\n@@ -152,8 +212,9 @@ INTERCEPTOR(int, mallopt, int cmd, int value) {\n #endif // SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n \n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n+  if (UNLIKELY(UseLocalPool()))\n+    return PosixMemalignFromLocalPool(memptr, alignment, size);\n   GET_STACK_TRACE_MALLOC;\n-  // Printf(\"posix_memalign: %zx %zu\\n\", alignment, size);\n   return asan_posix_memalign(memptr, alignment, size, &stack);\n }\n \n@@ -234,4 +295,4 @@ void ReplaceSystemMalloc() {\n #endif  // SANITIZER_ANDROID\n \n #endif  // SANITIZER_FREEBSD || SANITIZER_FUCHSIA || SANITIZER_LINUX ||\n-        // SANITIZER_NETBSD\n+        // SANITIZER_NETBSD || SANITIZER_SOLARIS"}, {"sha": "354189315fb9047b6b5db1bb31005762c906f286", "filename": "libsanitizer/asan/asan_malloc_local.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_local.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_local.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_local.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,42 @@\n+//===-- asan_malloc_local.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Provide interfaces to check for and handle local pool memory allocation.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_MALLOC_LOCAL_H\n+#define ASAN_MALLOC_LOCAL_H\n+\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"asan_internal.h\"\n+\n+// On RTEMS, we use the local pool to handle memory allocation when the ASan\n+// run-time is not up.\n+static INLINE bool EarlyMalloc() {\n+  return SANITIZER_RTEMS && (!__asan::asan_inited ||\n+                             __asan::asan_init_is_running);\n+}\n+\n+void* MemalignFromLocalPool(uptr alignment, uptr size);\n+\n+#if SANITIZER_RTEMS\n+\n+bool IsFromLocalPool(const void *ptr);\n+\n+#define ALLOCATE_FROM_LOCAL_POOL UNLIKELY(EarlyMalloc())\n+#define IS_FROM_LOCAL_POOL(ptr) UNLIKELY(IsFromLocalPool(ptr))\n+\n+#else  // SANITIZER_RTEMS\n+\n+#define ALLOCATE_FROM_LOCAL_POOL 0\n+#define IS_FROM_LOCAL_POOL(ptr) 0\n+\n+#endif  // SANITIZER_RTEMS\n+\n+#endif  // ASAN_MALLOC_LOCAL_H"}, {"sha": "e34884be85b20d06357b13b273e1b8babccf983a", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -36,6 +36,9 @@ using namespace __asan;\n #define COMMON_MALLOC_CALLOC(count, size) \\\n   GET_STACK_TRACE_MALLOC; \\\n   void *p = asan_calloc(count, size, &stack);\n+#define COMMON_MALLOC_POSIX_MEMALIGN(memptr, alignment, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  int res = asan_posix_memalign(memptr, alignment, size, &stack);\n #define COMMON_MALLOC_VALLOC(size) \\\n   GET_STACK_TRACE_MALLOC; \\\n   void *p = asan_memalign(GetPageSizeCached(), size, &stack, FROM_MALLOC);"}, {"sha": "245186037921d0e5ebd37ed3e2533dfb04ddea79", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,8 +12,17 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n-#define WIN32_LEAN_AND_MEAN\n-#include <windows.h>\n+// Intentionally not including windows.h here, to avoid the risk of\n+// pulling in conflicting declarations of these functions. (With mingw-w64,\n+// there's a risk of windows.h pulling in stdint.h.)\n+typedef int BOOL;\n+typedef void *HANDLE;\n+typedef const void *LPCVOID;\n+typedef void *LPVOID;\n+\n+#define HEAP_ZERO_MEMORY           0x00000008\n+#define HEAP_REALLOC_IN_PLACE_ONLY 0x00000010\n+\n \n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n@@ -123,7 +132,7 @@ void *_recalloc_base(void *p, size_t n, size_t elem_size) {\n }\n \n ALLOCATION_FUNCTION_ATTRIBUTE\n-size_t _msize(const void *ptr) {\n+size_t _msize(void *ptr) {\n   GET_CURRENT_PC_BP_SP;\n   (void)sp;\n   return asan_malloc_usable_size(ptr, pc, bp);"}, {"sha": "3f35a191a9276b85de699f9d3a77a5ff08d9a478", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 98, "deletions": 44, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -120,6 +120,13 @@\n // || `[0x400000000000, 0x47ffffffffff]` || LowShadow  ||\n // || `[0x000000000000, 0x3fffffffffff]` || LowMem     ||\n //\n+// Shadow mapping on NetBSD/i386 with SHADOW_OFFSET == 0x40000000:\n+// || `[0x60000000, 0xfffff000]` || HighMem    ||\n+// || `[0x4c000000, 0x5fffffff]` || HighShadow ||\n+// || `[0x48000000, 0x4bffffff]` || ShadowGap  ||\n+// || `[0x40000000, 0x47ffffff]` || LowShadow  ||\n+// || `[0x00000000, 0x3fffffff]` || LowMem     ||\n+//\n // Default Windows/i386 mapping:\n // (the exact location of HighShadow/HighMem may vary depending\n //  on WoW64, /LARGEADDRESSAWARE, etc).\n@@ -128,37 +135,60 @@\n // || `[0x36000000, 0x39ffffff]` || ShadowGap  ||\n // || `[0x30000000, 0x35ffffff]` || LowShadow  ||\n // || `[0x00000000, 0x2fffffff]` || LowMem     ||\n-\n-static const u64 kDefaultShadowScale = 3;\n+//\n+// Shadow mapping on Myriad2 (for shadow scale 5):\n+// || `[0x9ff80000, 0x9fffffff]` || ShadowGap  ||\n+// || `[0x9f000000, 0x9ff7ffff]` || LowShadow  ||\n+// || `[0x80000000, 0x9effffff]` || LowMem     ||\n+// || `[0x00000000, 0x7fffffff]` || Ignored    ||\n+\n+#if defined(ASAN_SHADOW_SCALE)\n+static const u64 kDefaultShadowScale = ASAN_SHADOW_SCALE;\n+#else\n+static const u64 kDefaultShadowScale = SANITIZER_MYRIAD2 ? 5 : 3;\n+#endif\n static const u64 kDefaultShadowSentinel = ~(uptr)0;\n static const u64 kDefaultShadowOffset32 = 1ULL << 29;  // 0x20000000\n static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n-static const u64 kDefaultShort64bitShadowOffset = 0x7FFF8000;  // < 2G.\n+static const u64 kDefaultShort64bitShadowOffset =\n+    0x7FFFFFFF & (~0xFFFULL << kDefaultShadowScale);  // < 2G.\n static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kIosShadowOffset64 = 0x120200000;\n static const u64 kIosSimShadowOffset32 = 1ULL << 30;\n static const u64 kIosSimShadowOffset64 = kDefaultShadowOffset64;\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n+static const u64 kNetBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kNetBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n \n+static const u64 kMyriadMemoryOffset32 = 0x80000000ULL;\n+static const u64 kMyriadMemorySize32 = 0x20000000ULL;\n+static const u64 kMyriadMemoryEnd32 =\n+    kMyriadMemoryOffset32 + kMyriadMemorySize32 - 1;\n+static const u64 kMyriadShadowOffset32 =\n+    (kMyriadMemoryOffset32 + kMyriadMemorySize32 -\n+     (kMyriadMemorySize32 >> kDefaultShadowScale));\n+static const u64 kMyriadCacheBitMask32 = 0x40000000ULL;\n+\n #define SHADOW_SCALE kDefaultShadowScale\n \n #if SANITIZER_FUCHSIA\n #  define SHADOW_OFFSET (0)\n #elif SANITIZER_WORDSIZE == 32\n #  if SANITIZER_ANDROID\n-#    define SHADOW_OFFSET (0)\n+#    define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n #  elif defined(__mips__)\n #    define SHADOW_OFFSET kMIPS32_ShadowOffset32\n #  elif SANITIZER_FREEBSD\n #    define SHADOW_OFFSET kFreeBSD_ShadowOffset32\n+#  elif SANITIZER_NETBSD\n+#    define SHADOW_OFFSET kNetBSD_ShadowOffset32\n #  elif SANITIZER_WINDOWS\n #    define SHADOW_OFFSET kWindowsShadowOffset32\n #  elif SANITIZER_IOS\n@@ -167,6 +197,8 @@ static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n #    else\n #      define SHADOW_OFFSET kIosShadowOffset32\n #    endif\n+#  elif SANITIZER_MYRIAD2\n+#    define SHADOW_OFFSET kMyriadShadowOffset32\n #  else\n #    define SHADOW_OFFSET kDefaultShadowOffset32\n #  endif\n@@ -198,7 +230,46 @@ static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n #  endif\n #endif\n \n+#if SANITIZER_ANDROID && defined(__arm__)\n+# define ASAN_PREMAP_SHADOW 1\n+#else\n+# define ASAN_PREMAP_SHADOW 0\n+#endif\n+\n #define SHADOW_GRANULARITY (1ULL << SHADOW_SCALE)\n+\n+#define DO_ASAN_MAPPING_PROFILE 0  // Set to 1 to profile the functions below.\n+\n+#if DO_ASAN_MAPPING_PROFILE\n+# define PROFILE_ASAN_MAPPING() AsanMappingProfile[__LINE__]++;\n+#else\n+# define PROFILE_ASAN_MAPPING()\n+#endif\n+\n+// If 1, all shadow boundaries are constants.\n+// Don't set to 1 other than for testing.\n+#define ASAN_FIXED_MAPPING 0\n+\n+namespace __asan {\n+\n+extern uptr AsanMappingProfile[];\n+\n+#if ASAN_FIXED_MAPPING\n+// Fixed mapping for 64-bit Linux. Mostly used for performance comparison\n+// with non-fixed mapping. As of r175253 (Feb 2013) the performance\n+// difference between fixed and non-fixed mapping is below the noise level.\n+static uptr kHighMemEnd = 0x7fffffffffffULL;\n+static uptr kMidMemBeg =    0x3000000000ULL;\n+static uptr kMidMemEnd =    0x4fffffffffULL;\n+#else\n+extern uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;  // Initialized in __asan_init.\n+#endif\n+\n+}  // namespace __asan\n+\n+#if SANITIZER_MYRIAD2\n+#include \"asan_mapping_myriad.h\"\n+#else\n #define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) + (SHADOW_OFFSET))\n \n #define kLowMemBeg      0\n@@ -230,51 +301,36 @@ static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n #define kShadowGap3Beg (kMidMemBeg ? kMidMemEnd + 1 : 0)\n #define kShadowGap3End (kMidMemBeg ? kHighShadowBeg - 1 : 0)\n \n-#define DO_ASAN_MAPPING_PROFILE 0  // Set to 1 to profile the functions below.\n-\n-#if DO_ASAN_MAPPING_PROFILE\n-# define PROFILE_ASAN_MAPPING() AsanMappingProfile[__LINE__]++;\n-#else\n-# define PROFILE_ASAN_MAPPING()\n-#endif\n-\n-// If 1, all shadow boundaries are constants.\n-// Don't set to 1 other than for testing.\n-#define ASAN_FIXED_MAPPING 0\n-\n namespace __asan {\n \n-extern uptr AsanMappingProfile[];\n-\n-#if ASAN_FIXED_MAPPING\n-// Fixed mapping for 64-bit Linux. Mostly used for performance comparison\n-// with non-fixed mapping. As of r175253 (Feb 2013) the performance\n-// difference between fixed and non-fixed mapping is below the noise level.\n-static uptr kHighMemEnd = 0x7fffffffffffULL;\n-static uptr kMidMemBeg =    0x3000000000ULL;\n-static uptr kMidMemEnd =    0x4fffffffffULL;\n-#else\n-extern uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;  // Initialized in __asan_init.\n-#endif\n-\n static inline bool AddrIsInLowMem(uptr a) {\n   PROFILE_ASAN_MAPPING();\n-  return a < kLowMemEnd;\n+  return a <= kLowMemEnd;\n }\n \n static inline bool AddrIsInLowShadow(uptr a) {\n   PROFILE_ASAN_MAPPING();\n   return a >= kLowShadowBeg && a <= kLowShadowEnd;\n }\n \n+static inline bool AddrIsInMidMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return kMidMemBeg && a >= kMidMemBeg && a <= kMidMemEnd;\n+}\n+\n+static inline bool AddrIsInMidShadow(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return kMidMemBeg && a >= kMidShadowBeg && a <= kMidShadowEnd;\n+}\n+\n static inline bool AddrIsInHighMem(uptr a) {\n   PROFILE_ASAN_MAPPING();\n-  return a >= kHighMemBeg && a <= kHighMemEnd;\n+  return kHighMemBeg && a >= kHighMemBeg && a <= kHighMemEnd;\n }\n \n-static inline bool AddrIsInMidMem(uptr a) {\n+static inline bool AddrIsInHighShadow(uptr a) {\n   PROFILE_ASAN_MAPPING();\n-  return kMidMemBeg && a >= kMidMemBeg && a <= kMidMemEnd;\n+  return kHighMemBeg && a >= kHighShadowBeg && a <= kHighShadowEnd;\n }\n \n static inline bool AddrIsInShadowGap(uptr a) {\n@@ -292,6 +348,12 @@ static inline bool AddrIsInShadowGap(uptr a) {\n   return a >= kShadowGapBeg && a <= kShadowGapEnd;\n }\n \n+}  // namespace __asan\n+\n+#endif  // SANITIZER_MYRIAD2\n+\n+namespace __asan {\n+\n static inline bool AddrIsInMem(uptr a) {\n   PROFILE_ASAN_MAPPING();\n   return AddrIsInLowMem(a) || AddrIsInMidMem(a) || AddrIsInHighMem(a) ||\n@@ -304,16 +366,6 @@ static inline uptr MemToShadow(uptr p) {\n   return MEM_TO_SHADOW(p);\n }\n \n-static inline bool AddrIsInHighShadow(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  return a >= kHighShadowBeg && a <= kHighMemEnd;\n-}\n-\n-static inline bool AddrIsInMidShadow(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  return kMidMemBeg && a >= kMidShadowBeg && a <= kMidMemEnd;\n-}\n-\n static inline bool AddrIsInShadow(uptr a) {\n   PROFILE_ASAN_MAPPING();\n   return AddrIsInLowShadow(a) || AddrIsInMidShadow(a) || AddrIsInHighShadow(a);\n@@ -326,6 +378,8 @@ static inline bool AddrIsAlignedByGranularity(uptr a) {\n \n static inline bool AddressIsPoisoned(uptr a) {\n   PROFILE_ASAN_MAPPING();\n+  if (SANITIZER_MYRIAD2 && !AddrIsInMem(a) && !AddrIsInShadow(a))\n+    return false;\n   const uptr kAccessSize = 1;\n   u8 *shadow_address = (u8*)MEM_TO_SHADOW(a);\n   s8 shadow_value = *shadow_address;"}, {"sha": "fa8d4fe02709bec2d563e0aa40d089cf78a92afe", "filename": "libsanitizer/asan/asan_mapping_myriad.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_mapping_myriad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_mapping_myriad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping_myriad.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,84 @@\n+//===-- asan_mapping_myriad.h -----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Myriad-specific definitions for ASan memory mapping.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_MAPPING_MYRIAD_H\n+#define ASAN_MAPPING_MYRIAD_H\n+\n+#define RAW_ADDR(mem) ((mem) & ~kMyriadCacheBitMask32)\n+#define MEM_TO_SHADOW(mem) \\\n+  (((RAW_ADDR(mem) - kLowMemBeg) >> SHADOW_SCALE) + (SHADOW_OFFSET))\n+\n+#define kLowMemBeg     kMyriadMemoryOffset32\n+#define kLowMemEnd     (SHADOW_OFFSET - 1)\n+\n+#define kLowShadowBeg  SHADOW_OFFSET\n+#define kLowShadowEnd  MEM_TO_SHADOW(kLowMemEnd)\n+\n+#define kHighMemBeg    0\n+\n+#define kHighShadowBeg 0\n+#define kHighShadowEnd 0\n+\n+#define kMidShadowBeg  0\n+#define kMidShadowEnd  0\n+\n+#define kShadowGapBeg  (kLowShadowEnd + 1)\n+#define kShadowGapEnd  kMyriadMemoryEnd32\n+\n+#define kShadowGap2Beg 0\n+#define kShadowGap2End 0\n+\n+#define kShadowGap3Beg 0\n+#define kShadowGap3End 0\n+\n+namespace __asan {\n+\n+static inline bool AddrIsInLowMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  a = RAW_ADDR(a);\n+  return a >= kLowMemBeg && a <= kLowMemEnd;\n+}\n+\n+static inline bool AddrIsInLowShadow(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  a = RAW_ADDR(a);\n+  return a >= kLowShadowBeg && a <= kLowShadowEnd;\n+}\n+\n+static inline bool AddrIsInMidMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return false;\n+}\n+\n+static inline bool AddrIsInMidShadow(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return false;\n+}\n+\n+static inline bool AddrIsInHighMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return false;\n+}\n+\n+static inline bool AddrIsInHighShadow(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return false;\n+}\n+\n+static inline bool AddrIsInShadowGap(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  a = RAW_ADDR(a);\n+  return a >= kShadowGapBeg && a <= kShadowGapEnd;\n+}\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_MAPPING_MYRIAD_H"}, {"sha": "23183bda79bf6b129cb52dcbe6e397f9c5a2752f", "filename": "libsanitizer/asan/asan_memory_profile.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_memory_profile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_memory_profile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_memory_profile.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -29,9 +29,9 @@ struct AllocationSite {\n \n class HeapProfile {\n  public:\n-  HeapProfile() : allocations_(1024) {}\n+  HeapProfile() { allocations_.reserve(1024); }\n \n-  void ProcessChunk(const AsanChunkView& cv) {\n+  void ProcessChunk(const AsanChunkView &cv) {\n     if (cv.IsAllocated()) {\n       total_allocated_user_size_ += cv.UsedSize();\n       total_allocated_count_++;\n@@ -47,10 +47,10 @@ class HeapProfile {\n   }\n \n   void Print(uptr top_percent, uptr max_number_of_contexts) {\n-    InternalSort(&allocations_, allocations_.size(),\n-                 [](const AllocationSite &a, const AllocationSite &b) {\n-                   return a.total_size > b.total_size;\n-                 });\n+    Sort(allocations_.data(), allocations_.size(),\n+         [](const AllocationSite &a, const AllocationSite &b) {\n+           return a.total_size > b.total_size;\n+         });\n     CHECK(total_allocated_user_size_);\n     uptr total_shown = 0;\n     Printf(\"Live Heap Allocations: %zd bytes in %zd chunks; quarantined: \""}, {"sha": "7e194e2229c8af5116940b1199b44db3330d33d7", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,6 +12,8 @@\n \n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n+#include \"asan_malloc_local.h\"\n+#include \"asan_report.h\"\n #include \"asan_stack.h\"\n \n #include \"interception/interception.h\"\n@@ -22,7 +24,7 @@\n // anyway by passing extra -export flags to the linker, which is exactly that\n // dllexport would normally do. We need to export them in order to make the\n // VS2015 dynamic CRT (MD) work.\n-#if SANITIZER_WINDOWS\n+#if SANITIZER_WINDOWS && defined(_MSC_VER)\n #define CXX_OPERATOR_ATTRIBUTE\n #define COMMENT_EXPORT(sym) __pragma(comment(linker, \"/export:\" sym))\n #ifdef _WIN64\n@@ -65,16 +67,28 @@ struct nothrow_t {};\n enum class align_val_t: size_t {};\n }  // namespace std\n \n-// TODO(alekseys): throw std::bad_alloc instead of dying on OOM.\n+// TODO(alekseyshl): throw std::bad_alloc instead of dying on OOM.\n+// For local pool allocation, align to SHADOW_GRANULARITY to match asan\n+// allocator behavior.\n #define OPERATOR_NEW_BODY(type, nothrow) \\\n+  if (ALLOCATE_FROM_LOCAL_POOL) {\\\n+    void *res = MemalignFromLocalPool(SHADOW_GRANULARITY, size);\\\n+    if (!nothrow) CHECK(res);\\\n+    return res;\\\n+  }\\\n   GET_STACK_TRACE_MALLOC;\\\n   void *res = asan_memalign(0, size, &stack, type);\\\n-  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();\\\n+  if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n   return res;\n #define OPERATOR_NEW_BODY_ALIGN(type, nothrow) \\\n+  if (ALLOCATE_FROM_LOCAL_POOL) {\\\n+    void *res = MemalignFromLocalPool((uptr)align, size);\\\n+    if (!nothrow) CHECK(res);\\\n+    return res;\\\n+  }\\\n   GET_STACK_TRACE_MALLOC;\\\n   void *res = asan_memalign((uptr)align, size, &stack, type);\\\n-  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();\\\n+  if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n   return res;\n \n // On OS X it's not enough to just provide our own 'operator new' and\n@@ -123,77 +137,73 @@ INTERCEPTOR(void *, _ZnwmRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n   OPERATOR_NEW_BODY(FROM_NEW_BR, true /*nothrow*/);\n }\n-#endif\n+#endif  // !SANITIZER_MAC\n \n #define OPERATOR_DELETE_BODY(type) \\\n+  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n+  GET_STACK_TRACE_FREE;\\\n+  asan_delete(ptr, 0, 0, &stack, type);\n+\n+#define OPERATOR_DELETE_BODY_SIZE(type) \\\n+  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n+  GET_STACK_TRACE_FREE;\\\n+  asan_delete(ptr, size, 0, &stack, type);\n+\n+#define OPERATOR_DELETE_BODY_ALIGN(type) \\\n+  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n+  GET_STACK_TRACE_FREE;\\\n+  asan_delete(ptr, 0, static_cast<uptr>(align), &stack, type);\n+\n+#define OPERATOR_DELETE_BODY_SIZE_ALIGN(type) \\\n+  if (IS_FROM_LOCAL_POOL(ptr)) return;\\\n   GET_STACK_TRACE_FREE;\\\n-  asan_free(ptr, &stack, type);\n+  asan_delete(ptr, size, static_cast<uptr>(align), &stack, type);\n \n #if !SANITIZER_MAC\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr) NOEXCEPT {\n-  OPERATOR_DELETE_BODY(FROM_NEW);\n-}\n+void operator delete(void *ptr) NOEXCEPT\n+{ OPERATOR_DELETE_BODY(FROM_NEW); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr) NOEXCEPT {\n-  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n-}\n+void operator delete[](void *ptr) NOEXCEPT\n+{ OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY(FROM_NEW);\n-}\n+void operator delete(void *ptr, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY(FROM_NEW); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n-}\n+void operator delete[](void *ptr, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr, size_t size) NOEXCEPT {\n-  GET_STACK_TRACE_FREE;\n-  asan_sized_free(ptr, size, &stack, FROM_NEW);\n-}\n+void operator delete(void *ptr, size_t size) NOEXCEPT\n+{ OPERATOR_DELETE_BODY_SIZE(FROM_NEW); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr, size_t size) NOEXCEPT {\n-  GET_STACK_TRACE_FREE;\n-  asan_sized_free(ptr, size, &stack, FROM_NEW_BR);\n-}\n+void operator delete[](void *ptr, size_t size) NOEXCEPT\n+{ OPERATOR_DELETE_BODY_SIZE(FROM_NEW_BR); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr, std::align_val_t) NOEXCEPT {\n-  OPERATOR_DELETE_BODY(FROM_NEW);\n-}\n+void operator delete(void *ptr, std::align_val_t align) NOEXCEPT\n+{ OPERATOR_DELETE_BODY_ALIGN(FROM_NEW); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr, std::align_val_t) NOEXCEPT {\n-  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n-}\n+void operator delete[](void *ptr, std::align_val_t align) NOEXCEPT\n+{ OPERATOR_DELETE_BODY_ALIGN(FROM_NEW_BR); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr, std::align_val_t, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY(FROM_NEW);\n-}\n+void operator delete(void *ptr, std::align_val_t align, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY_ALIGN(FROM_NEW); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr, std::align_val_t, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n-}\n+void operator delete[](void *ptr, std::align_val_t align, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY_ALIGN(FROM_NEW_BR); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete(void *ptr, size_t size, std::align_val_t) NOEXCEPT {\n-  GET_STACK_TRACE_FREE;\n-  asan_sized_free(ptr, size, &stack, FROM_NEW);\n-}\n+void operator delete(void *ptr, size_t size, std::align_val_t align) NOEXCEPT\n+{ OPERATOR_DELETE_BODY_SIZE_ALIGN(FROM_NEW); }\n CXX_OPERATOR_ATTRIBUTE\n-void operator delete[](void *ptr, size_t size, std::align_val_t) NOEXCEPT {\n-  GET_STACK_TRACE_FREE;\n-  asan_sized_free(ptr, size, &stack, FROM_NEW_BR);\n-}\n+void operator delete[](void *ptr, size_t size, std::align_val_t align) NOEXCEPT\n+{ OPERATOR_DELETE_BODY_SIZE_ALIGN(FROM_NEW_BR); }\n \n #else  // SANITIZER_MAC\n-INTERCEPTOR(void, _ZdlPv, void *ptr) {\n-  OPERATOR_DELETE_BODY(FROM_NEW);\n-}\n-INTERCEPTOR(void, _ZdaPv, void *ptr) {\n-  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n-}\n-INTERCEPTOR(void, _ZdlPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY(FROM_NEW);\n-}\n-INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&) {\n-  OPERATOR_DELETE_BODY(FROM_NEW_BR);\n-}\n-#endif\n+INTERCEPTOR(void, _ZdlPv, void *ptr)\n+{ OPERATOR_DELETE_BODY(FROM_NEW); }\n+INTERCEPTOR(void, _ZdaPv, void *ptr)\n+{ OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n+INTERCEPTOR(void, _ZdlPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY(FROM_NEW); }\n+INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n+{ OPERATOR_DELETE_BODY(FROM_NEW_BR); }\n+#endif  // !SANITIZER_MAC"}, {"sha": "35409baf612d113dd855a35b526cf6b95a5c474b", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -30,7 +30,7 @@ bool CanPoisonMemory() {\n }\n \n void PoisonShadow(uptr addr, uptr size, u8 value) {\n-  if (!CanPoisonMemory()) return;\n+  if (value && !CanPoisonMemory()) return;\n   CHECK(AddrIsAlignedByGranularity(addr));\n   CHECK(AddrIsInMem(addr));\n   CHECK(AddrIsAlignedByGranularity(addr + size));\n@@ -180,8 +180,15 @@ int __asan_address_is_poisoned(void const volatile *addr) {\n uptr __asan_region_is_poisoned(uptr beg, uptr size) {\n   if (!size) return 0;\n   uptr end = beg + size;\n-  if (!AddrIsInMem(beg)) return beg;\n-  if (!AddrIsInMem(end)) return end;\n+  if (SANITIZER_MYRIAD2) {\n+    // On Myriad, address not in DRAM range need to be treated as\n+    // unpoisoned.\n+    if (!AddrIsInMem(beg) && !AddrIsInShadow(beg)) return 0;\n+    if (!AddrIsInMem(end) && !AddrIsInShadow(end)) return 0;\n+  } else {\n+    if (!AddrIsInMem(beg)) return beg;\n+    if (!AddrIsInMem(end)) return end;\n+  }\n   CHECK_LT(beg, end);\n   uptr aligned_b = RoundUpTo(beg, SHADOW_GRANULARITY);\n   uptr aligned_e = RoundDownTo(end, SHADOW_GRANULARITY);"}, {"sha": "7e8c58868319fffe7c7be594cc0306f12ae12371", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -36,7 +36,7 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n // performance-critical code with care.\n ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n                                     u8 value) {\n-  DCHECK(CanPoisonMemory());\n+  DCHECK(!value || CanPoisonMemory());\n   uptr shadow_beg = MEM_TO_SHADOW(aligned_beg);\n   uptr shadow_end = MEM_TO_SHADOW(\n       aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;\n@@ -49,6 +49,9 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n       // changed at all.  It doesn't currently have an efficient means\n       // to zero a bunch of pages, but maybe we should add one.\n       SANITIZER_FUCHSIA == 1 ||\n+      // RTEMS doesn't have have pages, let alone a fast way to zero\n+      // them, so default to memset.\n+      SANITIZER_RTEMS == 1 ||\n       shadow_end - shadow_beg < common_flags()->clear_shadow_mmap_threshold) {\n     REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n   } else {"}, {"sha": "d765dc79c5182d09f51164759c95098aab7ca30c", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -23,7 +23,6 @@\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n #include <pthread.h>\n-#include <signal.h>\n #include <stdlib.h>\n #include <sys/time.h>\n #include <sys/resource.h>"}, {"sha": "4273ae5e3890cba0e07340c0491763b91dc54c46", "filename": "libsanitizer/asan/asan_premap_shadow.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_premap_shadow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_premap_shadow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_premap_shadow.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,77 @@\n+//===-- asan_premap_shadow.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Reserve shadow memory with an ifunc resolver.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_mapping.h\"\n+\n+#if ASAN_PREMAP_SHADOW\n+\n+#include \"asan_premap_shadow.h\"\n+#include \"sanitizer_common/sanitizer_posix.h\"\n+\n+namespace __asan {\n+\n+// The code in this file needs to run in an unrelocated binary. It may not\n+// access any external symbol, including its own non-hidden globals.\n+\n+// Conservative upper limit.\n+uptr PremapShadowSize() {\n+  uptr granularity = GetMmapGranularity();\n+  return RoundUpTo(GetMaxVirtualAddress() >> SHADOW_SCALE, granularity);\n+}\n+\n+// Returns an address aligned to 8 pages, such that one page on the left and\n+// PremapShadowSize() bytes on the right of it are mapped r/o.\n+uptr PremapShadow() {\n+  uptr granularity = GetMmapGranularity();\n+  uptr alignment = granularity * 8;\n+  uptr left_padding = granularity;\n+  uptr shadow_size = PremapShadowSize();\n+  uptr map_size = shadow_size + left_padding + alignment;\n+\n+  uptr map_start = (uptr)MmapNoAccess(map_size);\n+  CHECK_NE(map_start, ~(uptr)0);\n+\n+  uptr shadow_start = RoundUpTo(map_start + left_padding, alignment);\n+  uptr shadow_end = shadow_start + shadow_size;\n+  internal_munmap(reinterpret_cast<void *>(map_start),\n+                  shadow_start - left_padding - map_start);\n+  internal_munmap(reinterpret_cast<void *>(shadow_end),\n+                  map_start + map_size - shadow_end);\n+  return shadow_start;\n+}\n+\n+bool PremapShadowFailed() {\n+  uptr shadow = reinterpret_cast<uptr>(&__asan_shadow);\n+  uptr resolver = reinterpret_cast<uptr>(&__asan_premap_shadow);\n+  // shadow == resolver is how Android KitKat and older handles ifunc.\n+  // shadow == 0 just in case.\n+  if (shadow == 0 || shadow == resolver)\n+    return true;\n+  return false;\n+}\n+} // namespace __asan\n+\n+extern \"C\" {\n+decltype(__asan_shadow)* __asan_premap_shadow() {\n+  // The resolver may be called multiple times. Map the shadow just once.\n+  static uptr premapped_shadow = 0;\n+  if (!premapped_shadow) premapped_shadow = __asan::PremapShadow();\n+  return reinterpret_cast<decltype(__asan_shadow)*>(premapped_shadow);\n+}\n+\n+// __asan_shadow is a \"function\" that has the same address as the first byte of\n+// the shadow mapping.\n+INTERFACE_ATTRIBUTE __attribute__((ifunc(\"__asan_premap_shadow\"))) void\n+__asan_shadow();\n+}\n+\n+#endif // ASAN_PREMAP_SHADOW"}, {"sha": "345b56ea6a676f62831a35b0b8df018848157fdc", "filename": "libsanitizer/asan/asan_premap_shadow.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_premap_shadow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_premap_shadow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_premap_shadow.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,28 @@\n+//===-- asan_mapping.h ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Premap shadow range with an ifunc resolver.\n+//===----------------------------------------------------------------------===//\n+\n+\n+#ifndef ASAN_PREMAP_SHADOW_H\n+#define ASAN_PREMAP_SHADOW_H\n+\n+#if ASAN_PREMAP_SHADOW\n+namespace __asan {\n+// Conservative upper limit.\n+uptr PremapShadowSize();\n+bool PremapShadowFailed();\n+}\n+#endif\n+\n+extern \"C\" INTERFACE_ATTRIBUTE void __asan_shadow();\n+extern \"C\" decltype(__asan_shadow)* __asan_premap_shadow();\n+\n+#endif // ASAN_PREMAP_SHADOW_H"}, {"sha": "787b6890a34bcdfa1b8355332dc2c617cee3f17b", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -82,7 +82,7 @@ static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n bool ParseFrameDescription(const char *frame_descr,\n                            InternalMmapVector<StackVarDescr> *vars) {\n   CHECK(frame_descr);\n-  char *p;\n+  const char *p;\n   // This string is created by the compiler and has the following form:\n   // \"n alloc_1 alloc_2 ... alloc_n\"\n   // where alloc_i looks like \"offset size len ObjectName\"\n@@ -132,6 +132,10 @@ class ScopedInErrorReport {\n   }\n \n   ~ScopedInErrorReport() {\n+    if (halt_on_error_ && !__sanitizer_acquire_crash_state()) {\n+      asanThreadRegistry().Unlock();\n+      return;\n+    }\n     ASAN_ON_ERROR();\n     if (current_error_.IsValid()) current_error_.Print();\n \n@@ -150,7 +154,7 @@ class ScopedInErrorReport {\n \n     // Copy the message buffer so that we could start logging without holding a\n     // lock that gets aquired during printing.\n-    InternalScopedBuffer<char> buffer_copy(kErrorMessageBufferSize);\n+    InternalMmapVector<char> buffer_copy(kErrorMessageBufferSize);\n     {\n       BlockingMutexLock l(&error_message_buf_mutex);\n       internal_memcpy(buffer_copy.data(),\n@@ -200,7 +204,7 @@ class ScopedInErrorReport {\n   bool halt_on_error_;\n };\n \n-ErrorDescription ScopedInErrorReport::current_error_;\n+ErrorDescription ScopedInErrorReport::current_error_(LINKER_INITIALIZED);\n \n void ReportDeadlySignal(const SignalContext &sig) {\n   ScopedInErrorReport in_report(/*fatal*/ true);\n@@ -214,11 +218,12 @@ void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack) {\n   in_report.ReportError(error);\n }\n \n-void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n+void ReportNewDeleteTypeMismatch(uptr addr, uptr delete_size,\n+                                 uptr delete_alignment,\n                                  BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n-  ErrorNewDeleteSizeMismatch error(GetCurrentTidOrInvalid(), free_stack, addr,\n-                                   delete_size);\n+  ErrorNewDeleteTypeMismatch error(GetCurrentTidOrInvalid(), free_stack, addr,\n+                                   delete_size, delete_alignment);\n   in_report.ReportError(error);\n }\n \n@@ -251,6 +256,62 @@ void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n   in_report.ReportError(error);\n }\n \n+void ReportCallocOverflow(uptr count, uptr size, BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorCallocOverflow error(GetCurrentTidOrInvalid(), stack, count, size);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportPvallocOverflow(uptr size, BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorPvallocOverflow error(GetCurrentTidOrInvalid(), stack, size);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportInvalidAllocationAlignment(uptr alignment,\n+                                      BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorInvalidAllocationAlignment error(GetCurrentTidOrInvalid(), stack,\n+                                        alignment);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportInvalidAlignedAllocAlignment(uptr size, uptr alignment,\n+                                        BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorInvalidAlignedAllocAlignment error(GetCurrentTidOrInvalid(), stack,\n+                                          size, alignment);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportInvalidPosixMemalignAlignment(uptr alignment,\n+                                         BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorInvalidPosixMemalignAlignment error(GetCurrentTidOrInvalid(), stack,\n+                                           alignment);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportAllocationSizeTooBig(uptr user_size, uptr total_size, uptr max_size,\n+                                BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorAllocationSizeTooBig error(GetCurrentTidOrInvalid(), stack, user_size,\n+                                  total_size, max_size);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportRssLimitExceeded(BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorRssLimitExceeded error(GetCurrentTidOrInvalid(), stack);\n+  in_report.ReportError(error);\n+}\n+\n+void ReportOutOfMemory(uptr requested_size, BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorOutOfMemory error(GetCurrentTidOrInvalid(), stack, requested_size);\n+  in_report.ReportError(error);\n+}\n+\n void ReportStringFunctionMemoryRangesOverlap(const char *function,\n                                              const char *offset1, uptr length1,\n                                              const char *offset2, uptr length2,"}, {"sha": "b48605da41e7f865b144dca5b48ff08930465a42", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,6 +10,9 @@\n // ASan-private header for error reporting functions.\n //===----------------------------------------------------------------------===//\n \n+#ifndef ASAN_REPORT_H\n+#define ASAN_REPORT_H\n+\n #include \"asan_allocator.h\"\n #include \"asan_internal.h\"\n #include \"asan_thread.h\"\n@@ -45,7 +48,8 @@ bool ParseFrameDescription(const char *frame_descr,\n void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n                         uptr access_size, u32 exp, bool fatal);\n void ReportDeadlySignal(const SignalContext &sig);\n-void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n+void ReportNewDeleteTypeMismatch(uptr addr, uptr delete_size,\n+                                 uptr delete_alignment,\n                                  BufferedStackTrace *free_stack);\n void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);\n void ReportFreeNotMalloced(uptr addr, BufferedStackTrace *free_stack);\n@@ -55,6 +59,18 @@ void ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n void ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack);\n void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n                                              BufferedStackTrace *stack);\n+void ReportCallocOverflow(uptr count, uptr size, BufferedStackTrace *stack);\n+void ReportPvallocOverflow(uptr size, BufferedStackTrace *stack);\n+void ReportInvalidAllocationAlignment(uptr alignment,\n+                                      BufferedStackTrace *stack);\n+void ReportInvalidAlignedAllocAlignment(uptr size, uptr alignment,\n+                                        BufferedStackTrace *stack);\n+void ReportInvalidPosixMemalignAlignment(uptr alignment,\n+                                         BufferedStackTrace *stack);\n+void ReportAllocationSizeTooBig(uptr user_size, uptr total_size, uptr max_size,\n+                                BufferedStackTrace *stack);\n+void ReportRssLimitExceeded(BufferedStackTrace *stack);\n+void ReportOutOfMemory(uptr requested_size, BufferedStackTrace *stack);\n void ReportStringFunctionMemoryRangesOverlap(const char *function,\n                                              const char *offset1, uptr length1,\n                                              const char *offset2, uptr length2,\n@@ -77,3 +93,4 @@ void ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr,\n                                BufferedStackTrace *stack);\n \n }  // namespace __asan\n+#endif  // ASAN_REPORT_H"}, {"sha": "fa68373e63ab6df7988fccf85e2a657a4289ca72", "filename": "libsanitizer/asan/asan_rtems.cc", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_rtems.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_rtems.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtems.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,251 @@\n+//===-- asan_rtems.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// RTEMS-specific details.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_rtems.h\"\n+#if SANITIZER_RTEMS\n+\n+#include \"asan_internal.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+#include <pthread.h>\n+#include <stdlib.h>\n+\n+namespace __asan {\n+\n+static void ResetShadowMemory() {\n+  uptr shadow_start = SHADOW_OFFSET;\n+  uptr shadow_end = MEM_TO_SHADOW(kMyriadMemoryEnd32);\n+  uptr gap_start = MEM_TO_SHADOW(shadow_start);\n+  uptr gap_end = MEM_TO_SHADOW(shadow_end);\n+\n+  REAL(memset)((void *)shadow_start, 0, shadow_end - shadow_start);\n+  REAL(memset)((void *)gap_start, kAsanShadowGap, gap_end - gap_start);\n+}\n+\n+void InitializeShadowMemory() {\n+  kHighMemEnd = 0;\n+  kMidMemBeg =  0;\n+  kMidMemEnd =  0;\n+\n+  ResetShadowMemory();\n+}\n+\n+void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n+  UNIMPLEMENTED();\n+}\n+\n+void AsanCheckDynamicRTPrereqs() {}\n+void AsanCheckIncompatibleRT() {}\n+void InitializeAsanInterceptors() {}\n+void InitializePlatformInterceptors() {}\n+void InitializePlatformExceptionHandlers() {}\n+\n+// RTEMS only support static linking; it sufficies to return with no\n+// error.\n+void *AsanDoesNotSupportStaticLinkage() { return nullptr; }\n+\n+void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n+  UNIMPLEMENTED();\n+}\n+\n+void EarlyInit() {\n+  // Provide early initialization of shadow memory so that\n+  // instrumented code running before full initialzation will not\n+  // report spurious errors.\n+  ResetShadowMemory();\n+}\n+\n+// We can use a plain thread_local variable for TSD.\n+static thread_local void *per_thread;\n+\n+void *AsanTSDGet() { return per_thread; }\n+\n+void AsanTSDSet(void *tsd) { per_thread = tsd; }\n+\n+// There's no initialization needed, and the passed-in destructor\n+// will never be called.  Instead, our own thread destruction hook\n+// (below) will call AsanThread::TSDDtor directly.\n+void AsanTSDInit(void (*destructor)(void *tsd)) {\n+  DCHECK(destructor == &PlatformTSDDtor);\n+}\n+\n+void PlatformTSDDtor(void *tsd) { UNREACHABLE(__func__); }\n+\n+//\n+// Thread registration.  We provide an API similar to the Fushia port.\n+//\n+\n+struct AsanThread::InitOptions {\n+  uptr stack_bottom, stack_size, tls_bottom, tls_size;\n+};\n+\n+// Shared setup between thread creation and startup for the initial thread.\n+static AsanThread *CreateAsanThread(StackTrace *stack, u32 parent_tid,\n+                                    uptr user_id, bool detached,\n+                                    uptr stack_bottom, uptr stack_size,\n+                                    uptr tls_bottom, uptr tls_size) {\n+  // In lieu of AsanThread::Create.\n+  AsanThread *thread = (AsanThread *)MmapOrDie(sizeof(AsanThread), __func__);\n+  AsanThreadContext::CreateThreadContextArgs args = {thread, stack};\n+  asanThreadRegistry().CreateThread(user_id, detached, parent_tid, &args);\n+\n+  // On other systems, AsanThread::Init() is called from the new\n+  // thread itself.  But on RTEMS we already know the stack address\n+  // range beforehand, so we can do most of the setup right now.\n+  const AsanThread::InitOptions options = {stack_bottom, stack_size,\n+                                           tls_bottom, tls_size};\n+  thread->Init(&options);\n+  return thread;\n+}\n+\n+// This gets the same arguments passed to Init by CreateAsanThread, above.\n+// We're in the creator thread before the new thread is actually started, but\n+// its stack and tls address range are already known.\n+void AsanThread::SetThreadStackAndTls(const AsanThread::InitOptions *options) {\n+  DCHECK_NE(GetCurrentThread(), this);\n+  DCHECK_NE(GetCurrentThread(), nullptr);\n+  CHECK_NE(options->stack_bottom, 0);\n+  CHECK_NE(options->stack_size, 0);\n+  stack_bottom_ = options->stack_bottom;\n+  stack_top_ = options->stack_bottom + options->stack_size;\n+  tls_begin_ = options->tls_bottom;\n+  tls_end_ = options->tls_bottom + options->tls_size;\n+}\n+\n+// Called by __asan::AsanInitInternal (asan_rtl.c).  Unlike other ports, the\n+// main thread on RTEMS does not require special treatment; its AsanThread is\n+// already created by the provided hooks.  This function simply looks up and\n+// returns the created thread.\n+AsanThread *CreateMainThread() {\n+  return GetThreadContextByTidLocked(0)->thread;\n+}\n+\n+// This is called before each thread creation is attempted.  So, in\n+// its first call, the calling thread is the initial and sole thread.\n+static void *BeforeThreadCreateHook(uptr user_id, bool detached,\n+                                    uptr stack_bottom, uptr stack_size,\n+                                    uptr tls_bottom, uptr tls_size) {\n+  EnsureMainThreadIDIsCorrect();\n+  // Strict init-order checking is thread-hostile.\n+  if (flags()->strict_init_order) StopInitOrderChecking();\n+\n+  GET_STACK_TRACE_THREAD;\n+  u32 parent_tid = GetCurrentTidOrInvalid();\n+\n+  return CreateAsanThread(&stack, parent_tid, user_id, detached,\n+                          stack_bottom, stack_size, tls_bottom, tls_size);\n+}\n+\n+// This is called after creating a new thread (in the creating thread),\n+// with the pointer returned by BeforeThreadCreateHook (above).\n+static void ThreadCreateHook(void *hook, bool aborted) {\n+  AsanThread *thread = static_cast<AsanThread *>(hook);\n+  if (!aborted) {\n+    // The thread was created successfully.\n+    // ThreadStartHook is already running in the new thread.\n+  } else {\n+    // The thread wasn't created after all.\n+    // Clean up everything we set up in BeforeThreadCreateHook.\n+    asanThreadRegistry().FinishThread(thread->tid());\n+    UnmapOrDie(thread, sizeof(AsanThread));\n+  }\n+}\n+\n+// This is called (1) in the newly-created thread before it runs anything else,\n+// with the pointer returned by BeforeThreadCreateHook (above).  (2) before a\n+// thread restart.\n+static void ThreadStartHook(void *hook, uptr os_id) {\n+  if (!hook)\n+    return;\n+\n+  AsanThread *thread = static_cast<AsanThread *>(hook);\n+  SetCurrentThread(thread);\n+\n+  ThreadStatus status =\n+      asanThreadRegistry().GetThreadLocked(thread->tid())->status;\n+  DCHECK(status == ThreadStatusCreated || status == ThreadStatusRunning);\n+  // Determine whether we are starting or restarting the thread.\n+  if (status == ThreadStatusCreated)\n+    // In lieu of AsanThread::ThreadStart.\n+    asanThreadRegistry().StartThread(thread->tid(), os_id,\n+                                     /*workerthread*/ false, nullptr);\n+  else {\n+    // In a thread restart, a thread may resume execution at an\n+    // arbitrary function entry point, with its stack and TLS state\n+    // reset.  We unpoison the stack in that case.\n+    PoisonShadow(thread->stack_bottom(), thread->stack_size(), 0);\n+  }\n+}\n+\n+// Each thread runs this just before it exits,\n+// with the pointer returned by BeforeThreadCreateHook (above).\n+// All per-thread destructors have already been called.\n+static void ThreadExitHook(void *hook, uptr os_id) {\n+  AsanThread *thread = static_cast<AsanThread *>(hook);\n+  if (thread)\n+    AsanThread::TSDDtor(thread->context());\n+}\n+\n+static void HandleExit() {\n+  // Disable ASan by setting it to uninitialized.  Also reset the\n+  // shadow memory to avoid reporting errors after the run-time has\n+  // been desroyed.\n+  if (asan_inited) {\n+    asan_inited = false;\n+    ResetShadowMemory();\n+  }\n+}\n+\n+}  // namespace __asan\n+\n+// These are declared (in extern \"C\") by <some_path/sanitizer.h>.\n+// The system runtime will call our definitions directly.\n+\n+extern \"C\" {\n+void __sanitizer_early_init() {\n+  __asan::EarlyInit();\n+}\n+\n+void *__sanitizer_before_thread_create_hook(uptr thread, bool detached,\n+                                            const char *name,\n+                                            void *stack_base, size_t stack_size,\n+                                            void *tls_base, size_t tls_size) {\n+  return __asan::BeforeThreadCreateHook(\n+      thread, detached,\n+      reinterpret_cast<uptr>(stack_base), stack_size,\n+      reinterpret_cast<uptr>(tls_base), tls_size);\n+}\n+\n+void __sanitizer_thread_create_hook(void *handle, uptr thread, int status) {\n+  __asan::ThreadCreateHook(handle, status != 0);\n+}\n+\n+void __sanitizer_thread_start_hook(void *handle, uptr self) {\n+  __asan::ThreadStartHook(handle, self);\n+}\n+\n+void __sanitizer_thread_exit_hook(void *handle, uptr self) {\n+  __asan::ThreadExitHook(handle, self);\n+}\n+\n+void __sanitizer_exit() {\n+  __asan::HandleExit();\n+}\n+}  // \"C\"\n+\n+#endif  // SANITIZER_RTEMS"}, {"sha": "ba3acf2c5d2036c77422206b0e05697ffaf25a38", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -54,7 +54,8 @@ static void AsanDie() {\n       UnmapOrDie((void*)kLowShadowBeg, kMidMemBeg - kLowShadowBeg);\n       UnmapOrDie((void*)kMidMemEnd, kHighShadowEnd - kMidMemEnd);\n     } else {\n-      UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n+      if (kHighShadowEnd)\n+        UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n     }\n   }\n }\n@@ -63,8 +64,14 @@ static void AsanCheckFailed(const char *file, int line, const char *cond,\n                             u64 v1, u64 v2) {\n   Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\", file,\n          line, cond, (uptr)v1, (uptr)v2);\n-  // FIXME: check for infinite recursion without a thread-local counter here.\n-  PRINT_CURRENT_STACK_CHECK();\n+\n+  // Print a stack trace the first time we come here. Otherwise, we probably\n+  // failed a CHECK during symbolization.\n+  static atomic_uint32_t num_calls;\n+  if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) == 0) {\n+    PRINT_CURRENT_STACK_CHECK();\n+  }\n+\n   Die();\n }\n \n@@ -138,6 +145,8 @@ ASAN_REPORT_ERROR_N(load, false)\n ASAN_REPORT_ERROR_N(store, true)\n \n #define ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp_arg, fatal) \\\n+    if (SANITIZER_MYRIAD2 && !AddrIsInMem(addr) && !AddrIsInShadow(addr))      \\\n+      return;                                                                  \\\n     uptr sp = MEM_TO_SHADOW(addr);                                             \\\n     uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)          \\\n                                         : *reinterpret_cast<u16 *>(sp);        \\\n@@ -304,20 +313,24 @@ static void asan_atexit() {\n }\n \n static void InitializeHighMemEnd() {\n+#if !SANITIZER_MYRIAD2\n #if !ASAN_FIXED_MAPPING\n-  kHighMemEnd = GetMaxVirtualAddress();\n+  kHighMemEnd = GetMaxUserVirtualAddress();\n   // Increase kHighMemEnd to make sure it's properly\n   // aligned together with kHighMemBeg:\n   kHighMemEnd |= SHADOW_GRANULARITY * GetMmapGranularity() - 1;\n #endif  // !ASAN_FIXED_MAPPING\n   CHECK_EQ((kHighMemBeg % GetMmapGranularity()), 0);\n+#endif  // !SANITIZER_MYRIAD2\n }\n \n void PrintAddressSpaceLayout() {\n-  Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n-         (void*)kHighMemBeg, (void*)kHighMemEnd);\n-  Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n-         (void*)kHighShadowBeg, (void*)kHighShadowEnd);\n+  if (kHighMemBeg) {\n+    Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n+           (void*)kHighMemBeg, (void*)kHighMemEnd);\n+    Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n+           (void*)kHighShadowBeg, (void*)kHighShadowEnd);\n+  }\n   if (kMidMemBeg) {\n     Printf(\"|| `[%p, %p]` || ShadowGap3 ||\\n\",\n            (void*)kShadowGap3Beg, (void*)kShadowGap3End);\n@@ -336,11 +349,14 @@ void PrintAddressSpaceLayout() {\n     Printf(\"|| `[%p, %p]` || LowMem     ||\\n\",\n            (void*)kLowMemBeg, (void*)kLowMemEnd);\n   }\n-  Printf(\"MemToShadow(shadow): %p %p %p %p\",\n+  Printf(\"MemToShadow(shadow): %p %p\",\n          (void*)MEM_TO_SHADOW(kLowShadowBeg),\n-         (void*)MEM_TO_SHADOW(kLowShadowEnd),\n-         (void*)MEM_TO_SHADOW(kHighShadowBeg),\n-         (void*)MEM_TO_SHADOW(kHighShadowEnd));\n+         (void*)MEM_TO_SHADOW(kLowShadowEnd));\n+  if (kHighMemBeg) {\n+    Printf(\" %p %p\",\n+           (void*)MEM_TO_SHADOW(kHighShadowBeg),\n+           (void*)MEM_TO_SHADOW(kHighShadowEnd));\n+  }\n   if (kMidMemBeg) {\n     Printf(\" %p %p\",\n            (void*)MEM_TO_SHADOW(kMidShadowBeg),\n@@ -372,6 +388,7 @@ static void AsanInitInternal() {\n   asan_init_is_running = true;\n \n   CacheBinaryName();\n+  CheckASLR();\n \n   // Initialize flags. This must be done early, because most of the\n   // initialization steps look at flags().\n@@ -405,6 +422,7 @@ static void AsanInitInternal() {\n   MaybeReexec();\n \n   // Setup internal allocator callback.\n+  SetLowLevelAllocateMinAlignment(SHADOW_GRANULARITY);\n   SetLowLevelAllocateCallback(OnLowLevelAllocate);\n \n   InitializeAsanInterceptors();\n@@ -523,6 +541,9 @@ void NOINLINE __asan_handle_no_return() {\n   if (curr_thread) {\n     top = curr_thread->stack_top();\n     bottom = ((uptr)&local_stack - PageSize) & ~(PageSize - 1);\n+  } else if (SANITIZER_RTEMS) {\n+    // Give up On RTEMS.\n+    return;\n   } else {\n     CHECK(!SANITIZER_FUCHSIA);\n     // If we haven't seen this thread, try asking the OS for stack bounds."}, {"sha": "823187bf5f13b698185878c590060561596d97a8", "filename": "libsanitizer/asan/asan_shadow_setup.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_shadow_setup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_shadow_setup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_shadow_setup.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,8 +12,9 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n \n-// asan_fuchsia.cc has its own InitializeShadowMemory implementation.\n-#if !SANITIZER_FUCHSIA\n+// asan_fuchsia.cc and asan_rtems.cc have their own\n+// InitializeShadowMemory implementation.\n+#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n@@ -28,8 +29,7 @@ void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n   CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n   uptr size = end - beg + 1;\n   DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n-  void *res = MmapFixedNoReserve(beg, size, name);\n-  if (res != (void *)beg) {\n+  if (!MmapFixedNoReserve(beg, size, name)) {\n     Report(\n         \"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n         \"Perhaps you're using ulimit -v\\n\",\n@@ -97,17 +97,21 @@ void InitializeShadowMemory() {\n   // when necessary. When dynamic address is used, the macro |kLowShadowBeg|\n   // expands to |__asan_shadow_memory_dynamic_address| which is\n   // |kDefaultShadowSentinel|.\n+  bool full_shadow_is_available = false;\n   if (shadow_start == kDefaultShadowSentinel) {\n     __asan_shadow_memory_dynamic_address = 0;\n     CHECK_EQ(0, kLowShadowBeg);\n     shadow_start = FindDynamicShadowStart();\n+    if (SANITIZER_LINUX) full_shadow_is_available = true;\n   }\n   // Update the shadow memory address (potentially) used by instrumentation.\n   __asan_shadow_memory_dynamic_address = shadow_start;\n \n   if (kLowShadowBeg) shadow_start -= GetMmapGranularity();\n-  bool full_shadow_is_available =\n-      MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n+\n+  if (!full_shadow_is_available)\n+    full_shadow_is_available =\n+        MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n \n #if SANITIZER_LINUX && defined(__x86_64__) && defined(_LP64) && \\\n     !ASAN_FIXED_MAPPING\n@@ -156,4 +160,4 @@ void InitializeShadowMemory() {\n \n }  // namespace __asan\n \n-#endif  // !SANITIZER_FUCHSIA\n+#endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS"}, {"sha": "5775e9d325c4de8133b4e2219fff57f710a2bc6a", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -29,9 +29,8 @@ u32 GetMallocContextSize();\n // The pc will be in the position 0 of the resulting stack trace.\n // The bp may refer to the current frame or to the caller's frame.\n ALWAYS_INLINE\n-void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n-                                     uptr pc, uptr bp, void *context,\n-                                     bool fast) {\n+void GetStackTrace(BufferedStackTrace *stack, uptr max_depth, uptr pc, uptr bp,\n+                   void *context, bool fast) {\n #if SANITIZER_WINDOWS\n   stack->Unwind(max_depth, pc, bp, context, 0, 0, fast);\n #else\n@@ -60,32 +59,29 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n // as early as possible (in functions exposed to the user), as we generally\n // don't want stack trace to contain functions from ASan internals.\n \n-#define GET_STACK_TRACE(max_size, fast)                                        \\\n-  BufferedStackTrace stack;                                                    \\\n-  if (max_size <= 2) {                                                         \\\n-    stack.size = max_size;                                                     \\\n-    if (max_size > 0) {                                                        \\\n-      stack.top_frame_bp = GET_CURRENT_FRAME();                                \\\n-      stack.trace_buffer[0] = StackTrace::GetCurrentPc();                      \\\n-      if (max_size > 1)                                                        \\\n-        stack.trace_buffer[1] = GET_CALLER_PC();                               \\\n-    }                                                                          \\\n-  } else {                                                                     \\\n-    GetStackTraceWithPcBpAndContext(&stack, max_size,                          \\\n-                                    StackTrace::GetCurrentPc(),                \\\n-                                    GET_CURRENT_FRAME(), 0, fast);             \\\n+#define GET_STACK_TRACE(max_size, fast)                          \\\n+  BufferedStackTrace stack;                                      \\\n+  if (max_size <= 2) {                                           \\\n+    stack.size = max_size;                                       \\\n+    if (max_size > 0) {                                          \\\n+      stack.top_frame_bp = GET_CURRENT_FRAME();                  \\\n+      stack.trace_buffer[0] = StackTrace::GetCurrentPc();        \\\n+      if (max_size > 1) stack.trace_buffer[1] = GET_CALLER_PC(); \\\n+    }                                                            \\\n+  } else {                                                       \\\n+    GetStackTrace(&stack, max_size, StackTrace::GetCurrentPc(),  \\\n+                  GET_CURRENT_FRAME(), 0, fast);                 \\\n   }\n \n-#define GET_STACK_TRACE_FATAL(pc, bp)                                          \\\n-  BufferedStackTrace stack;                                                    \\\n-  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, 0,           \\\n-                                  common_flags()->fast_unwind_on_fatal)\n+#define GET_STACK_TRACE_FATAL(pc, bp)              \\\n+  BufferedStackTrace stack;                        \\\n+  GetStackTrace(&stack, kStackTraceMax, pc, bp, 0, \\\n+                common_flags()->fast_unwind_on_fatal)\n \n-#define GET_STACK_TRACE_SIGNAL(sig)                                            \\\n-  BufferedStackTrace stack;                                                    \\\n-  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax,                      \\\n-                                  (sig).pc, (sig).bp, (sig).context,           \\\n-                                  common_flags()->fast_unwind_on_fatal)\n+#define GET_STACK_TRACE_SIGNAL(sig)                                        \\\n+  BufferedStackTrace stack;                                                \\\n+  GetStackTrace(&stack, kStackTraceMax, (sig).pc, (sig).bp, (sig).context, \\\n+                common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_FATAL_HERE                                \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)"}, {"sha": "82da9a28e8248b0bf18c6af6240fd05d03fd7faa", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -219,22 +219,25 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n void AsanThread::Init(const InitOptions *options) {\n   next_stack_top_ = next_stack_bottom_ = 0;\n   atomic_store(&stack_switching_, false, memory_order_release);\n-  fake_stack_ = nullptr;  // Will be initialized lazily if needed.\n   CHECK_EQ(this->stack_size(), 0U);\n   SetThreadStackAndTls(options);\n   CHECK_GT(this->stack_size(), 0U);\n   CHECK(AddrIsInMem(stack_bottom_));\n   CHECK(AddrIsInMem(stack_top_ - 1));\n   ClearShadowForThreadStackAndTLS();\n+  fake_stack_ = nullptr;\n+  if (__asan_option_detect_stack_use_after_return)\n+    AsyncSignalSafeLazyInitFakeStack();\n   int local = 0;\n   VReport(1, \"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\", tid(),\n           (void *)stack_bottom_, (void *)stack_top_, stack_top_ - stack_bottom_,\n           &local);\n }\n \n-// Fuchsia doesn't use ThreadStart.\n-// asan_fuchsia.c defines CreateMainThread and SetThreadStackAndTls.\n-#if !SANITIZER_FUCHSIA\n+// Fuchsia and RTEMS don't use ThreadStart.\n+// asan_fuchsia.c/asan_rtems.c define CreateMainThread and\n+// SetThreadStackAndTls.\n+#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n thread_return_t AsanThread::ThreadStart(\n     tid_t os_id, atomic_uintptr_t *signal_thread_is_registered) {\n@@ -294,12 +297,17 @@ void AsanThread::SetThreadStackAndTls(const InitOptions *options) {\n   CHECK(AddrIsInStack((uptr)&local));\n }\n \n-#endif  // !SANITIZER_FUCHSIA\n+#endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n void AsanThread::ClearShadowForThreadStackAndTLS() {\n   PoisonShadow(stack_bottom_, stack_top_ - stack_bottom_, 0);\n-  if (tls_begin_ != tls_end_)\n-    PoisonShadow(tls_begin_, tls_end_ - tls_begin_, 0);\n+  if (tls_begin_ != tls_end_) {\n+    uptr tls_begin_aligned = RoundDownTo(tls_begin_, SHADOW_GRANULARITY);\n+    uptr tls_end_aligned = RoundUpTo(tls_end_, SHADOW_GRANULARITY);\n+    FastPoisonShadowPartialRightRedzone(tls_begin_aligned,\n+                                        tls_end_ - tls_begin_aligned,\n+                                        tls_end_aligned - tls_end_, 0);\n+  }\n }\n \n bool AsanThread::GetStackFrameAccessByAddr(uptr addr,\n@@ -384,6 +392,9 @@ static bool ThreadStackContainsAddress(ThreadContextBase *tctx_base,\n }\n \n AsanThread *GetCurrentThread() {\n+  if (SANITIZER_RTEMS && !asan_inited)\n+    return nullptr;\n+\n   AsanThreadContext *context =\n       reinterpret_cast<AsanThreadContext *>(AsanTSDGet());\n   if (!context) {\n@@ -475,6 +486,11 @@ void UnlockThreadRegistry() {\n   __asan::asanThreadRegistry().Unlock();\n }\n \n+ThreadRegistry *GetThreadRegistryLocked() {\n+  __asan::asanThreadRegistry().CheckLocked();\n+  return &__asan::asanThreadRegistry();\n+}\n+\n void EnsureMainThreadIDIsCorrect() {\n   __asan::EnsureMainThreadIDIsCorrect();\n }"}, {"sha": "8473f59c78aeb5667912eb013be84048ae1155d6", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -157,6 +157,14 @@ INTERCEPTOR_WINAPI(DWORD, CreateThread,\n namespace __asan {\n \n void InitializePlatformInterceptors() {\n+  // The interceptors were not designed to be removable, so we have to keep this\n+  // module alive for the life of the process.\n+  HMODULE pinned;\n+  CHECK(GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n+                           GET_MODULE_HANDLE_EX_FLAG_PIN,\n+                           (LPCWSTR)&InitializePlatformInterceptors,\n+                           &pinned));\n+\n   ASAN_INTERCEPT_FUNC(CreateThread);\n   ASAN_INTERCEPT_FUNC(SetUnhandledExceptionFilter);\n \n@@ -220,8 +228,8 @@ uptr FindDynamicShadowStart() {\n   uptr alignment = 8 * granularity;\n   uptr left_padding = granularity;\n   uptr space_size = kHighShadowEnd + left_padding;\n-  uptr shadow_start =\n-      FindAvailableMemoryRange(space_size, alignment, granularity, nullptr);\n+  uptr shadow_start = FindAvailableMemoryRange(space_size, alignment,\n+                                               granularity, nullptr, nullptr);\n   CHECK_NE((uptr)0, shadow_start);\n   CHECK(IsAligned(shadow_start, alignment));\n   return shadow_start;\n@@ -263,11 +271,6 @@ ShadowExceptionHandler(PEXCEPTION_POINTERS exception_pointers) {\n   // Determine the address of the page that is being accessed.\n   uptr page = RoundDownTo(addr, page_size);\n \n-  // Query the existing page.\n-  MEMORY_BASIC_INFORMATION mem_info = {};\n-  if (::VirtualQuery((LPVOID)page, &mem_info, sizeof(mem_info)) == 0)\n-    return EXCEPTION_CONTINUE_SEARCH;\n-\n   // Commit the page.\n   uptr result =\n       (uptr)::VirtualAlloc((LPVOID)page, page_size, MEM_COMMIT, PAGE_READWRITE);"}, {"sha": "8df7ab2b177ed12d1b4a308db123c14ba33661d6", "filename": "libsanitizer/asan/asan_win_dll_thunk.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -97,7 +97,7 @@ INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n }\n #endif\n \n-// Window specific functions not included in asan_interface.inc.\n+// Windows specific functions not included in asan_interface.inc.\n INTERCEPT_WRAP_W_V(__asan_should_detect_stack_use_after_return)\n INTERCEPT_WRAP_W_V(__asan_get_shadow_memory_dynamic_address)\n INTERCEPT_WRAP_W_W(__asan_unhandled_exception_filter)"}, {"sha": "e125ad21d3112166dabbffed82c6f8e63ad8fa17", "filename": "libsanitizer/include/sanitizer/allocator_interface.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -30,25 +30,25 @@ extern \"C\" {\n   size_t __sanitizer_get_allocated_size(const volatile void *p);\n \n   /* Number of bytes, allocated and not yet freed by the application. */\n-  size_t __sanitizer_get_current_allocated_bytes();\n+  size_t __sanitizer_get_current_allocated_bytes(void);\n \n   /* Number of bytes, mmaped by the allocator to fulfill allocation requests.\n      Generally, for request of X bytes, allocator can reserve and add to free\n      lists a large number of chunks of size X to use them for future requests.\n      All these chunks count toward the heap size. Currently, allocator never\n      releases memory to OS (instead, it just puts freed chunks to free\n      lists). */\n-  size_t __sanitizer_get_heap_size();\n+  size_t __sanitizer_get_heap_size(void);\n \n   /* Number of bytes, mmaped by the allocator, which can be used to fulfill\n      allocation requests. When a user program frees memory chunk, it can first\n      fall into quarantine and will count toward __sanitizer_get_free_bytes()\n      later. */\n-  size_t __sanitizer_get_free_bytes();\n+  size_t __sanitizer_get_free_bytes(void);\n \n   /* Number of bytes in unmapped pages, that are released to OS. Currently,\n      always returns 0. */\n-  size_t __sanitizer_get_unmapped_bytes();\n+  size_t __sanitizer_get_unmapped_bytes(void);\n \n   /* Malloc hooks that may be optionally provided by user.\n      __sanitizer_malloc_hook(ptr, size) is called immediately after\n@@ -74,6 +74,12 @@ extern \"C\" {\n       void (*malloc_hook)(const volatile void *, size_t),\n       void (*free_hook)(const volatile void *));\n \n+  /* Drains allocator quarantines (calling thread's and global ones), returns\n+     freed memory back to OS and releases other non-essential internal allocator\n+     resources in attempt to reduce process RSS.\n+     Currently available with ASan only.\n+  */\n+  void __sanitizer_purge_allocator(void);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "6e8fe256a950fecfbf364c307eb51a393e665a46", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -62,19 +62,19 @@ extern \"C\" {\n \n   // Useful for calling from a debugger to get information about an ASan error.\n   // Returns 1 if an error has been (or is being) reported, otherwise returns 0.\n-  int __asan_report_present();\n+  int __asan_report_present(void);\n \n   // Useful for calling from a debugger to get information about an ASan error.\n   // If an error has been (or is being) reported, the following functions return\n   // the pc, bp, sp, address, access type (0 = read, 1 = write), access size and\n   // bug description (e.g. \"heap-use-after-free\"). Otherwise they return 0.\n-  void *__asan_get_report_pc();\n-  void *__asan_get_report_bp();\n-  void *__asan_get_report_sp();\n-  void *__asan_get_report_address();\n-  int __asan_get_report_access_type();\n-  size_t __asan_get_report_access_size();\n-  const char *__asan_get_report_description();\n+  void *__asan_get_report_pc(void);\n+  void *__asan_get_report_bp(void);\n+  void *__asan_get_report_sp(void);\n+  void *__asan_get_report_address(void);\n+  int __asan_get_report_access_type(void);\n+  size_t __asan_get_report_access_size(void);\n+  const char *__asan_get_report_description(void);\n \n   // Useful for calling from the debugger to get information about a pointer.\n   // Returns the category of the given pointer as a constant string.\n@@ -116,21 +116,21 @@ extern \"C\" {\n   // User may provide function that would be called right when ASan detects\n   // an error. This can be used to notice cases when ASan detects an error, but\n   // the program crashes before ASan report is printed.\n-  void __asan_on_error();\n+  void __asan_on_error(void);\n \n   // Prints accumulated stats to stderr. Used for debugging.\n-  void __asan_print_accumulated_stats();\n+  void __asan_print_accumulated_stats(void);\n \n   // This function may be optionally provided by user and should return\n   // a string containing ASan runtime options. See asan_flags.h for details.\n-  const char* __asan_default_options();\n+  const char* __asan_default_options(void);\n \n   // The following 2 functions facilitate garbage collection in presence of\n   // asan's fake stack.\n \n   // Returns an opaque handler to be used later in __asan_addr_is_in_fake_stack.\n   // Returns NULL if the current thread does not have a fake stack.\n-  void *__asan_get_current_fake_stack();\n+  void *__asan_get_current_fake_stack(void);\n \n   // If fake_stack is non-NULL and addr belongs to a fake frame in\n   // fake_stack, returns the address on real stack that corresponds to"}, {"sha": "b8ae094ac5f4b25044f165664be230e17dddf8e6", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -63,6 +63,11 @@ extern \"C\" {\n   void __sanitizer_unaligned_store32(void *p, uint32_t x);\n   void __sanitizer_unaligned_store64(void *p, uint64_t x);\n \n+  // Returns 1 on the first call, then returns 0 thereafter.  Called by the tool\n+  // to ensure only one report is printed when multiple errors occur\n+  // simultaneously.\n+  int __sanitizer_acquire_crash_state();\n+\n   // Annotate the current state of a contiguous container, such as\n   // std::vector, std::string or similar.\n   // A contiguous container is a container that keeps all of its elements\n@@ -113,10 +118,16 @@ extern \"C\" {\n       const void *beg, const void *mid, const void *end);\n \n   // Print the stack trace leading to this call. Useful for debugging user code.\n-  void __sanitizer_print_stack_trace();\n+  void __sanitizer_print_stack_trace(void);\n \n   // Symbolizes the supplied 'pc' using the format string 'fmt'.\n   // Outputs at most 'out_buf_size' bytes into 'out_buf'.\n+  // If 'out_buf' is not empty then output is zero or more non empty C strings\n+  // followed by single empty C string. Multiple strings can be returned if PC\n+  // corresponds to inlined function. Inlined frames are printed in the order\n+  // from \"most-inlined\" to the \"least-inlined\", so the last frame should be the\n+  // not inlined function.\n+  // Inlined frames can be removed with 'symbolize_inline_frames=0'.\n   // The format syntax is described in\n   // lib/sanitizer_common/sanitizer_stacktrace_printer.h.\n   void __sanitizer_symbolize_pc(void *pc, const char *fmt, char *out_buf,"}, {"sha": "2f3613583da30f1a1ee8a6e2d6b020a9be3d85c7", "filename": "libsanitizer/include/sanitizer/coverage_interface.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -18,10 +18,10 @@ extern \"C\" {\n #endif\n \n   // Record and dump coverage info.\n-  void __sanitizer_cov_dump();\n+  void __sanitizer_cov_dump(void);\n \n   // Clear collected coverage info.\n-  void __sanitizer_cov_reset();\n+  void __sanitizer_cov_reset(void);\n \n   // Dump collected coverage info. Sorts pcs by module into individual .sancov\n   // files."}, {"sha": "e22b6a8f4d7bc09f1387c193706d231ce305162e", "filename": "libsanitizer/include/sanitizer/esan_interface.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -35,11 +35,11 @@ extern \"C\" {\n // This function can be called mid-run (or at the end of a run for\n // a server process that doesn't shut down normally) to request that\n // data for that point in the run be reported from the tool.\n-void COMPILER_RT_WEAK __esan_report();\n+void COMPILER_RT_WEAK __esan_report(void);\n \n // This function returns the number of samples that the esan tool has collected\n // to this point.  This is useful for testing.\n-unsigned int COMPILER_RT_WEAK __esan_get_sample_count();\n+unsigned int COMPILER_RT_WEAK __esan_get_sample_count(void);\n \n #ifdef __cplusplus\n } // extern \"C\""}, {"sha": "938e9ac464a0ee058049b3a212d41a180fdabaf7", "filename": "libsanitizer/include/sanitizer/hwasan_interface.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,82 @@\n+//===-- sanitizer/asan_interface.h ------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of HWAddressSanitizer.\n+//\n+// Public interface header.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_HWASAN_INTERFACE_H\n+#define SANITIZER_HWASAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  // Initialize shadow but not the rest of the runtime.\n+  // Does not call libc unless there is an error.\n+  // Can be called multiple times, or not at all (in which case shadow will\n+  // be initialized in compiler-inserted __hwasan_init() call).\n+  void __hwasan_shadow_init(void);\n+\n+  // This function may be optionally provided by user and should return\n+  // a string containing HWASan runtime options. See asan_flags.h for details.\n+  const char* __hwasan_default_options(void);\n+\n+  void __hwasan_enable_allocator_tagging(void);\n+  void __hwasan_disable_allocator_tagging(void);\n+\n+  // Mark region of memory with the given tag. Both address and size need to be\n+  // 16-byte aligned.\n+  void __hwasan_tag_memory(const volatile void *p, unsigned char tag,\n+                           size_t size);\n+\n+  /// Set pointer tag. Previous tag is lost.\n+  void *__hwasan_tag_pointer(const volatile void *p, unsigned char tag);\n+\n+  // Set memory tag from the current SP address to the given address to zero.\n+  // This is meant to annotate longjmp and other non-local jumps.\n+  // This function needs to know the (almost) exact destination frame address;\n+  // clearing shadow for the entire thread stack like __asan_handle_no_return\n+  // does would cause false reports.\n+  void __hwasan_handle_longjmp(const void *sp_dst);\n+\n+  // Libc hook for thread creation. Should be called in the child thread before\n+  // any instrumented code.\n+  void __hwasan_thread_enter();\n+\n+  // Libc hook for thread destruction. No instrumented code should run after\n+  // this call.\n+  void __hwasan_thread_exit();\n+\n+  // Print shadow and origin for the memory range to stderr in a human-readable\n+  // format.\n+  void __hwasan_print_shadow(const volatile void *x, size_t size);\n+\n+  // Print one-line report about the memory usage of the current process.\n+  void __hwasan_print_memory_usage();\n+\n+  int __sanitizer_posix_memalign(void **memptr, size_t alignment, size_t size);\n+  void * __sanitizer_memalign(size_t alignment, size_t size);\n+  void * __sanitizer_aligned_alloc(size_t alignment, size_t size);\n+  void * __sanitizer___libc_memalign(size_t alignment, size_t size);\n+  void * __sanitizer_valloc(size_t size);\n+  void * __sanitizer_pvalloc(size_t size);\n+  void __sanitizer_free(void *ptr);\n+  void __sanitizer_cfree(void *ptr);\n+  size_t __sanitizer_malloc_usable_size(const void *ptr);\n+  struct mallinfo __sanitizer_mallinfo();\n+  int __sanitizer_mallopt(int cmd, int value);\n+  void __sanitizer_malloc_stats(void);\n+  void * __sanitizer_calloc(size_t nmemb, size_t size);\n+  void * __sanitizer_realloc(void *ptr, size_t size);\n+  void * __sanitizer_malloc(size_t size);\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // SANITIZER_HWASAN_INTERFACE_H"}, {"sha": "93b2e9ca3f18f09e5ef47da799b60920ea79f8f9", "filename": "libsanitizer/include/sanitizer/lsan_interface.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -19,8 +19,8 @@ extern \"C\" {\n #endif\n   // Allocations made between calls to __lsan_disable() and __lsan_enable() will\n   // be treated as non-leaks. Disable/enable pairs may be nested.\n-  void __lsan_disable();\n-  void __lsan_enable();\n+  void __lsan_disable(void);\n+  void __lsan_enable(void);\n \n   // The heap object into which p points will be treated as a non-leak.\n   void __lsan_ignore_object(const void *p);\n@@ -47,7 +47,7 @@ extern \"C\" {\n   // the time of first invocation of this function.\n   // By calling this function early during process shutdown, you can instruct\n   // LSan to ignore shutdown-only leaks which happen later on.\n-  void __lsan_do_leak_check();\n+  void __lsan_do_leak_check(void);\n \n   // Check for leaks now. Returns zero if no leaks have been found or if leak\n   // detection is disabled, non-zero otherwise.\n@@ -56,23 +56,23 @@ extern \"C\" {\n   // terminate the process. It does not affect the behavior of\n   // __lsan_do_leak_check() or the end-of-process leak check, and is not\n   // affected by them.\n-  int __lsan_do_recoverable_leak_check();\n+  int __lsan_do_recoverable_leak_check(void);\n \n   // The user may optionally provide this function to disallow leak checking\n   // for the program it is linked into (if the return value is non-zero). This\n   // function must be defined as returning a constant value; any behavior beyond\n   // that is unsupported.\n   // To avoid dead stripping, you may need to define this function with\n   // __attribute__((used))\n-  int __lsan_is_turned_off();\n+  int __lsan_is_turned_off(void);\n \n   // This function may be optionally provided by user and should return\n   // a string containing LSan runtime options. See lsan_flags.inc for details.\n-  const char *__lsan_default_options();\n+  const char *__lsan_default_options(void);\n \n   // This function may be optionally provided by the user and should return\n   // a string containing LSan suppressions.\n-  const char *__lsan_default_suppressions();\n+  const char *__lsan_default_suppressions(void);\n #ifdef __cplusplus\n }  // extern \"C\"\n "}, {"sha": "4dfae604f7a2b96c3ab3911073283dc20cabf7eb", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -29,10 +29,10 @@ extern \"C\" {\n   int __msan_origin_is_descendant_or_same(uint32_t this_id, uint32_t prev_id);\n \n   /* Returns non-zero if tracking origins. */\n-  int __msan_get_track_origins();\n+  int __msan_get_track_origins(void);\n \n   /* Returns the origin id of the latest UMR in the calling thread. */\n-  uint32_t __msan_get_umr_origin();\n+  uint32_t __msan_get_umr_origin(void);\n \n   /* Make memory region fully initialized (without changing its contents). */\n   void __msan_unpoison(const volatile void *a, size_t size);\n@@ -80,7 +80,7 @@ extern \"C\" {\n   void __msan_dump_shadow(const volatile void *x, size_t size);\n \n   /* Returns true if running under a dynamic tool (DynamoRio-based). */\n-  int  __msan_has_dynamic_component();\n+  int  __msan_has_dynamic_component(void);\n \n   /* Tell MSan about newly allocated memory (ex.: custom allocator).\n      Memory will be marked uninitialized, with origin at the call site. */\n@@ -91,7 +91,7 @@ extern \"C\" {\n \n   /* This function may be optionally provided by user and should return\n      a string containing Msan runtime options. See msan_flags.h for details. */\n-  const char* __msan_default_options();\n+  const char* __msan_default_options(void);\n \n   /* Deprecated. Call __sanitizer_set_death_callback instead. */\n   void __msan_set_death_callback(void (*callback)(void));\n@@ -102,6 +102,14 @@ extern \"C\" {\n      copy. Source and destination regions can overlap. */\n   void __msan_copy_shadow(const volatile void *dst, const volatile void *src,\n                           size_t size);\n+\n+  /* Disables uninitialized memory checks in interceptors. */\n+  void __msan_scoped_disable_interceptor_checks(void);\n+\n+  /* Re-enables uninitialized memory checks in interceptors after a previous\n+     call to __msan_scoped_disable_interceptor_checks. */\n+  void __msan_scoped_enable_interceptor_checks(void);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "8cf5121726e6da54ec6b1de77ccf134c10723bd4", "filename": "libsanitizer/include/sanitizer/netbsd_syscall_hooks.h", "status": "added", "additions": 4732, "deletions": 0, "changes": 4732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "ca9a6f1fcb7acbbd57402f8324971943db689643", "filename": "libsanitizer/include/sanitizer/scudo_interface.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fscudo_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Fscudo_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fscudo_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,37 @@\n+//===-- sanitizer/scudo_interface.h -----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+/// Public Scudo interface header.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_SCUDO_INTERFACE_H_\n+#define SANITIZER_SCUDO_INTERFACE_H_\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  // This function may be optionally provided by a user and should return\n+  // a string containing Scudo runtime options. See scudo_flags.h for details.\n+  const char* __scudo_default_options(void);\n+\n+  // This function allows to set the RSS limit at runtime. This can be either\n+  // the hard limit (HardLimit=1) or the soft limit (HardLimit=0). The limit\n+  // can be removed by setting LimitMb to 0. This function's parameters should\n+  // be fully trusted to avoid security mishaps.\n+  void __scudo_set_rss_limit(size_t LimitMb, int HardLimit);\n+\n+  // This function outputs various allocator statistics for both the Primary\n+  // and Secondary allocators, including memory usage, number of allocations\n+  // and deallocations.\n+  void __scudo_print_stats(void);\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // SANITIZER_SCUDO_INTERFACE_H_"}, {"sha": "b86062bb119670587e288ca72d8b55fb82fe6bde", "filename": "libsanitizer/include/sanitizer/tsan_interface.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -42,6 +42,11 @@ const unsigned __tsan_mutex_linker_init      = 1 << 0;\n const unsigned __tsan_mutex_write_reentrant  = 1 << 1;\n // Mutex is read reentrant.\n const unsigned __tsan_mutex_read_reentrant   = 1 << 2;\n+// Mutex does not have static storage duration, and must not be used after\n+// its destructor runs.  The opposite of __tsan_mutex_linker_init.\n+// If this flag is passed to __tsan_mutex_destroy, then the destruction\n+// is ignored unless this flag was previously set on the mutex.\n+const unsigned __tsan_mutex_not_static       = 1 << 8;\n \n // Mutex operation flags:\n \n@@ -68,6 +73,7 @@ void __tsan_mutex_create(void *addr, unsigned flags);\n // Annotate destruction of a mutex.\n // Supported flags:\n //   - __tsan_mutex_linker_init\n+//   - __tsan_mutex_not_static\n void __tsan_mutex_destroy(void *addr, unsigned flags);\n \n // Annotate start of lock operation."}, {"sha": "3d43df804f34b6d2094b77f3d562d2a9b76f94cf", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -13,19 +13,21 @@\n #ifndef INTERCEPTION_H\n #define INTERCEPTION_H\n \n-#if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__APPLE__) && \\\n-    !defined(__NetBSD__) && !defined(_WIN32) && !defined(__Fuchsia__)\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+\n+#if !SANITIZER_LINUX && !SANITIZER_FREEBSD && !SANITIZER_MAC && \\\n+    !SANITIZER_NETBSD && !SANITIZER_OPENBSD && !SANITIZER_WINDOWS && \\\n+    !SANITIZER_FUCHSIA && !SANITIZER_RTEMS && !SANITIZER_SOLARIS\n # error \"Interception doesn't work on this operating system.\"\n #endif\n \n-#include \"sanitizer_common/sanitizer_internal_defs.h\"\n-\n // These typedefs should be used only in the interceptor definitions to replace\n // the standard system types (e.g. SSIZE_T instead of ssize_t)\n typedef __sanitizer::uptr    SIZE_T;\n typedef __sanitizer::sptr    SSIZE_T;\n typedef __sanitizer::sptr    PTRDIFF_T;\n typedef __sanitizer::s64     INTMAX_T;\n+typedef __sanitizer::u64     UINTMAX_T;\n typedef __sanitizer::OFF_T   OFF_T;\n typedef __sanitizer::OFF64_T OFF64_T;\n \n@@ -85,7 +87,7 @@ typedef __sanitizer::OFF64_T OFF64_T;\n // As it's decided at compile time which functions are to be intercepted on Mac,\n // INTERCEPT_FUNCTION() is effectively a no-op on this system.\n \n-#if defined(__APPLE__)\n+#if SANITIZER_MAC\n #include <sys/cdefs.h>  // For __DARWIN_ALIAS_C().\n \n // Just a pair of pointers.\n@@ -119,15 +121,20 @@ const interpose_substitution substitution_##func_name[] \\\n # define INTERCEPTOR_ATTRIBUTE\n # define DECLARE_WRAPPER(ret_type, func, ...)\n \n-#elif defined(_WIN32)\n+#elif SANITIZER_WINDOWS\n # define WRAP(x) __asan_wrap_##x\n # define WRAPPER_NAME(x) \"__asan_wrap_\"#x\n # define INTERCEPTOR_ATTRIBUTE __declspec(dllexport)\n # define DECLARE_WRAPPER(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n # define DECLARE_WRAPPER_WINAPI(ret_type, func, ...) \\\n     extern \"C\" __declspec(dllimport) ret_type __stdcall func(__VA_ARGS__);\n-#elif defined(__FreeBSD__) || defined(__NetBSD__)\n+#elif SANITIZER_RTEMS\n+# define WRAP(x) x\n+# define WRAPPER_NAME(x) #x\n+# define INTERCEPTOR_ATTRIBUTE\n+# define DECLARE_WRAPPER(ret_type, func, ...)\n+#elif SANITIZER_FREEBSD || SANITIZER_NETBSD\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n@@ -137,7 +144,7 @@ const interpose_substitution substitution_##func_name[] \\\n # define DECLARE_WRAPPER(ret_type, func, ...) \\\n      extern \"C\" ret_type func(__VA_ARGS__) \\\n      __attribute__((alias(\"__interceptor_\" #func), visibility(\"default\")));\n-#elif !defined(__Fuchsia__)\n+#elif !SANITIZER_FUCHSIA\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n@@ -146,33 +153,37 @@ const interpose_substitution substitution_##func_name[] \\\n     __attribute__((weak, alias(\"__interceptor_\" #func), visibility(\"default\")));\n #endif\n \n-#if defined(__Fuchsia__)\n+#if SANITIZER_FUCHSIA\n // There is no general interception at all on Fuchsia.\n // Sanitizer runtimes just define functions directly to preempt them,\n // and have bespoke ways to access the underlying libc functions.\n # include <zircon/sanitizer.h>\n # define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n # define REAL(x) __unsanitized_##x\n # define DECLARE_REAL(ret_type, func, ...)\n-#elif !defined(__APPLE__)\n+#elif SANITIZER_RTEMS\n+# define REAL(x) __real_ ## x\n+# define DECLARE_REAL(ret_type, func, ...) \\\n+    extern \"C\" ret_type REAL(func)(__VA_ARGS__);\n+#elif !SANITIZER_MAC\n # define PTR_TO_REAL(x) real_##x\n # define REAL(x) __interception::PTR_TO_REAL(x)\n-# define FUNC_TYPE(x) x##_f\n+# define FUNC_TYPE(x) x##_type\n \n # define DECLARE_REAL(ret_type, func, ...) \\\n     typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception { \\\n       extern FUNC_TYPE(func) PTR_TO_REAL(func); \\\n     }\n # define ASSIGN_REAL(dst, src) REAL(dst) = REAL(src)\n-#else  // __APPLE__\n+#else  // SANITIZER_MAC\n # define REAL(x) x\n # define DECLARE_REAL(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n # define ASSIGN_REAL(x, y)\n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC\n \n-#if !defined(__Fuchsia__)\n+#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n #define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n   DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n   extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n@@ -184,7 +195,7 @@ const interpose_substitution substitution_##func_name[] \\\n // macros does its job. In exceptional cases you may need to call REAL(foo)\n // without defining INTERCEPTOR(..., foo, ...). For example, if you override\n // foo with an interceptor for other function.\n-#if !defined(__APPLE__) && !defined(__Fuchsia__)\n+#if !SANITIZER_MAC && !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n # define DEFINE_REAL(ret_type, func, ...) \\\n     typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception { \\\n@@ -194,7 +205,7 @@ const interpose_substitution substitution_##func_name[] \\\n # define DEFINE_REAL(ret_type, func, ...)\n #endif\n \n-#if defined(__Fuchsia__)\n+#if SANITIZER_FUCHSIA\n \n // We need to define the __interceptor_func name just to get\n // sanitizer_common/scripts/gen_dynamic_list.py to export func.\n@@ -204,7 +215,7 @@ const interpose_substitution substitution_##func_name[] \\\n       __interceptor_##func(__VA_ARGS__);                                \\\n   extern \"C\" INTERCEPTOR_ATTRIBUTE ret_type func(__VA_ARGS__)\n \n-#elif !defined(__APPLE__)\n+#elif !SANITIZER_MAC\n \n #define INTERCEPTOR(ret_type, func, ...) \\\n   DEFINE_REAL(ret_type, func, __VA_ARGS__) \\\n@@ -217,7 +228,7 @@ const interpose_substitution substitution_##func_name[] \\\n #define INTERCEPTOR_WITH_SUFFIX(ret_type, func, ...) \\\n   INTERCEPTOR(ret_type, func, __VA_ARGS__)\n \n-#else  // __APPLE__\n+#else  // SANITIZER_MAC\n \n #define INTERCEPTOR_ZZZ(suffix, ret_type, func, ...) \\\n   extern \"C\" ret_type func(__VA_ARGS__) suffix; \\\n@@ -236,7 +247,7 @@ const interpose_substitution substitution_##func_name[] \\\n   INTERPOSER_2(overridee, WRAP(overrider))\n #endif\n \n-#if defined(_WIN32)\n+#if SANITIZER_WINDOWS\n # define INTERCEPTOR_WINAPI(ret_type, func, ...) \\\n     typedef ret_type (__stdcall *FUNC_TYPE(func))(__VA_ARGS__); \\\n     namespace __interception { \\\n@@ -262,17 +273,19 @@ typedef unsigned long uptr;  // NOLINT\n \n #define INCLUDED_FROM_INTERCEPTION_LIB\n \n-#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n+\n # include \"interception_linux.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\\n     INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver)\n-#elif defined(__APPLE__)\n+#elif SANITIZER_MAC\n # include \"interception_mac.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\\n     INTERCEPT_FUNCTION_VER_MAC(func, symver)\n-#elif defined(_WIN32)\n+#elif SANITIZER_WINDOWS\n # include \"interception_win.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_WIN(func)\n # define INTERCEPT_FUNCTION_VER(func, symver) \\"}, {"sha": "781b77e46fd1a751928cd7cc9dbeec7d76a29008", "filename": "libsanitizer/interception/interception_linux.cc", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,32 +10,44 @@\n // Linux-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n #include \"interception.h\"\n \n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n+\n #include <dlfcn.h>   // for dlsym() and dlvsym()\n \n-#ifdef __NetBSD__\n+#if SANITIZER_NETBSD\n #include \"sanitizer_common/sanitizer_libc.h\"\n #endif\n \n namespace __interception {\n bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n     uptr real, uptr wrapper) {\n-#ifdef __NetBSD__\n+#if SANITIZER_NETBSD\n   // XXX: Find a better way to handle renames\n   if (internal_strcmp(func_name, \"sigaction\") == 0) func_name = \"__sigaction14\";\n #endif\n   *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);\n+  if (!*func_addr) {\n+    // If the lookup using RTLD_NEXT failed, the sanitizer runtime library is\n+    // later in the library search order than the DSO that we are trying to\n+    // intercept, which means that we cannot intercept this function. We still\n+    // want the address of the real definition, though, so look it up using\n+    // RTLD_DEFAULT.\n+    *func_addr = (uptr)dlsym(RTLD_DEFAULT, func_name);\n+  }\n   return real == wrapper;\n }\n \n-#if !defined(__ANDROID__)  // android does not have dlvsym\n+// Android and Solaris do not have dlvsym\n+#if !SANITIZER_ANDROID && !SANITIZER_SOLARIS && !SANITIZER_OPENBSD\n void *GetFuncAddrVer(const char *func_name, const char *ver) {\n   return dlvsym(RTLD_NEXT, func_name, ver);\n }\n-#endif  // !defined(__ANDROID__)\n+#endif  // !SANITIZER_ANDROID\n \n }  // namespace __interception\n \n-#endif  // __linux__ || __FreeBSD__ || __NetBSD__\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n+        // SANITIZER_OPENBSD || SANITIZER_SOLARIS"}, {"sha": "37e6386df5b435cd716256a083be30eb5c6659e9", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,7 +10,8 @@\n // Linux-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n \n #if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n # error \"interception_linux.h should be included from interception library only\"\n@@ -32,14 +33,16 @@ void *GetFuncAddrVer(const char *func_name, const char *ver);\n       (::__interception::uptr) & (func),                                   \\\n       (::__interception::uptr) & WRAP(func))\n \n-#if !defined(__ANDROID__)  // android does not have dlvsym\n+// Android,  Solaris and OpenBSD do not have dlvsym\n+#if !SANITIZER_ANDROID && !SANITIZER_SOLARIS && !SANITIZER_OPENBSD\n #define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n-  (::__interception::real_##func = (func##_f)(                \\\n+  (::__interception::real_##func = (func##_type)(                \\\n        unsigned long)::__interception::GetFuncAddrVer(#func, symver))\n #else\n #define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n   INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n-#endif  // !defined(__ANDROID__)\n+#endif  // !SANITIZER_ANDROID && !SANITIZER_SOLARIS\n \n #endif  // INTERCEPTION_LINUX_H\n-#endif  // __linux__ || __FreeBSD__ || __NetBSD__\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n+        // SANITIZER_OPENBSD || SANITIZER_SOLARIS"}, {"sha": "1ffc1af9d55ac0b34f7b7156315a6095842c4e00", "filename": "libsanitizer/interception/interception_mac.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,9 +10,8 @@\n // Mac-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __APPLE__\n-\n #include \"interception.h\"\n \n+#if SANITIZER_MAC\n \n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC"}, {"sha": "c3a3eace53d5360f5e64b5bf56db607754e0dbc6", "filename": "libsanitizer/interception/interception_mac.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,7 +10,7 @@\n // Mac-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#ifdef __APPLE__\n+#if SANITIZER_MAC\n \n #if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n # error \"interception_mac.h should be included from interception.h only\"\n@@ -23,4 +23,4 @@\n #define INTERCEPT_FUNCTION_VER_MAC(func, symver)\n \n #endif  // INTERCEPTION_MAC_H\n-#endif  // __APPLE__\n+#endif  // SANITIZER_MAC"}, {"sha": "726cc7b71b204b84f3bce76001e31863b1bc85b3", "filename": "libsanitizer/interception/interception_type_test.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_type_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_type_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_type_test.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,9 +10,10 @@\n // Compile-time tests of the internal type definitions.\n //===----------------------------------------------------------------------===//\n \n-#if defined(__linux__) || defined(__APPLE__)\n-\n #include \"interception.h\"\n+\n+#if SANITIZER_LINUX || SANITIZER_MAC\n+\n #include <sys/types.h>\n #include <stddef.h>\n #include <stdint.h>\n@@ -22,14 +23,14 @@ COMPILER_CHECK(sizeof(::SSIZE_T) == sizeof(ssize_t));\n COMPILER_CHECK(sizeof(::PTRDIFF_T) == sizeof(ptrdiff_t));\n COMPILER_CHECK(sizeof(::INTMAX_T) == sizeof(intmax_t));\n \n-#ifndef __APPLE__\n+#if !SANITIZER_MAC\n COMPILER_CHECK(sizeof(::OFF64_T) == sizeof(off64_t));\n #endif\n \n // The following are the cases when pread (and friends) is used instead of\n // pread64. In those cases we need OFF_T to match off_t. We don't care about the\n // rest (they depend on _FILE_OFFSET_BITS setting when building an application).\n-# if defined(__ANDROID__) || !defined _FILE_OFFSET_BITS || \\\n+# if SANITIZER_ANDROID || !defined _FILE_OFFSET_BITS || \\\n   _FILE_OFFSET_BITS != 64\n COMPILER_CHECK(sizeof(::OFF_T) == sizeof(off_t));\n # endif"}, {"sha": "74f444d8f4a98eb51313212b90e948da5adb95ee", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -123,9 +123,9 @@\n //                                      addr2:  .bytes <body>\n //===----------------------------------------------------------------------===//\n \n-#ifdef _WIN32\n-\n #include \"interception.h\"\n+\n+#if SANITIZER_WINDOWS\n #include \"sanitizer_common/sanitizer_platform.h\"\n #define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n@@ -221,8 +221,8 @@ static bool IsMemoryPadding(uptr address, uptr size) {\n   return true;\n }\n \n-static const u8 kHintNop9Bytes[] = {\n-  0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00\n+static const u8 kHintNop8Bytes[] = {\n+  0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00\n };\n \n template<class T>\n@@ -237,8 +237,8 @@ static bool FunctionHasPrefix(uptr address, const T &pattern) {\n static bool FunctionHasPadding(uptr address, uptr size) {\n   if (IsMemoryPadding(address - size, size))\n     return true;\n-  if (size <= sizeof(kHintNop9Bytes) &&\n-      FunctionHasPrefix(address, kHintNop9Bytes))\n+  if (size <= sizeof(kHintNop8Bytes) &&\n+      FunctionHasPrefix(address, kHintNop8Bytes))\n     return true;\n   return false;\n }\n@@ -451,6 +451,7 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n   }\n \n   switch (*(u16*)(address)) {\n+    case 0x018A:  // 8A 01 : mov al, byte ptr [ecx]\n     case 0xFF8B:  // 8B FF : mov edi, edi\n     case 0xEC8B:  // 8B EC : mov ebp, esp\n     case 0xc889:  // 89 C8 : mov eax, ecx\n@@ -551,7 +552,10 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n     case 0x246c8948:  // 48 89 6C 24 XX : mov QWORD ptr [rsp + XX], rbp\n     case 0x245c8948:  // 48 89 5c 24 XX : mov QWORD PTR [rsp + XX], rbx\n     case 0x24748948:  // 48 89 74 24 XX : mov QWORD PTR [rsp + XX], rsi\n+    case 0x244C8948:  // 48 89 4C 24 XX : mov QWORD PTR [rsp + XX], rcx\n       return 5;\n+    case 0x24648348:  // 48 83 64 24 XX : and QWORD PTR [rsp + XX], YY\n+      return 6;\n   }\n \n #else\n@@ -830,6 +834,7 @@ bool OverrideFunction(\n static void **InterestingDLLsAvailable() {\n   static const char *InterestingDLLs[] = {\n       \"kernel32.dll\",\n+      \"msvcr100.dll\",      // VS2010\n       \"msvcr110.dll\",      // VS2012\n       \"msvcr120.dll\",      // VS2013\n       \"vcruntime140.dll\",  // VS2015\n@@ -1007,4 +1012,4 @@ bool OverrideImportedFunction(const char *module_to_patch,\n \n }  // namespace __interception\n \n-#endif  // _WIN32\n+#endif  // SANITIZER_MAC"}, {"sha": "3202a0e37b635f6f297298ce1843f1d81c12f160", "filename": "libsanitizer/interception/interception_win.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,7 +10,7 @@\n // Windows-specific interception methods.\n //===----------------------------------------------------------------------===//\n \n-#ifdef _WIN32\n+#if SANITIZER_WINDOWS\n \n #if !defined(INCLUDED_FROM_INTERCEPTION_LIB)\n # error \"interception_win.h should be included from interception library only\"\n@@ -79,4 +79,4 @@ void TestOnlyReleaseTrampolineRegions();\n       (::__interception::uptr *)&REAL(func))\n \n #endif  // INTERCEPTION_WIN_H\n-#endif  // _WIN32\n+#endif  // SANITIZER_WINDOWS"}, {"sha": "e9261109c9ea0072a5ebe51382139f76536c08eb", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -64,16 +64,17 @@ static void InitializeFlags() {\n   if (Verbosity()) ReportUnrecognizedFlags();\n \n   if (common_flags()->help) parser.PrintFlagDescriptions();\n+\n+  __sanitizer_set_report_path(common_flags()->log_path);\n }\n \n static void OnStackUnwind(const SignalContext &sig, const void *,\n                           BufferedStackTrace *stack) {\n-  GetStackTraceWithPcBpAndContext(stack, kStackTraceMax, sig.pc, sig.bp,\n-                                  sig.context,\n-                                  common_flags()->fast_unwind_on_fatal);\n+  GetStackTrace(stack, kStackTraceMax, sig.pc, sig.bp, sig.context,\n+                common_flags()->fast_unwind_on_fatal);\n }\n \n-void LsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n+static void LsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   HandleDeadlySignal(siginfo, context, GetCurrentThread(), &OnStackUnwind,\n                      nullptr);\n }"}, {"sha": "a40493c88793478510ee3c1c2e9b2472e82d37d2", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -16,9 +16,8 @@\n \n #define GET_STACK_TRACE(max_size, fast)                       \\\n   __sanitizer::BufferedStackTrace stack;                      \\\n-  GetStackTraceWithPcBpAndContext(&stack, max_size,           \\\n-                                  StackTrace::GetCurrentPc(), \\\n-                                  GET_CURRENT_FRAME(), nullptr, fast);\n+  GetStackTrace(&stack, max_size, StackTrace::GetCurrentPc(), \\\n+                GET_CURRENT_FRAME(), nullptr, fast);\n \n #define GET_STACK_TRACE_FATAL \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n@@ -44,10 +43,9 @@ void ReplaceSystemMalloc();\n // The pc will be in the position 0 of the resulting stack trace.\n // The bp may refer to the current frame or to the caller's frame.\n ALWAYS_INLINE\n-void GetStackTraceWithPcBpAndContext(__sanitizer::BufferedStackTrace *stack,\n-                                     __sanitizer::uptr max_depth,\n-                                     __sanitizer::uptr pc, __sanitizer::uptr bp,\n-                                     void *context, bool fast) {\n+void GetStackTrace(__sanitizer::BufferedStackTrace *stack,\n+                   __sanitizer::uptr max_depth, __sanitizer::uptr pc,\n+                   __sanitizer::uptr bp, void *context, bool fast) {\n   uptr stack_top = 0, stack_bottom = 0;\n   ThreadContext *t;\n   if (fast && (t = CurrentThreadContext())) {"}, {"sha": "6b57c5070a926f5a8538b2d4d8552ef03fb6012a", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -15,6 +15,7 @@\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_allocator_checks.h\"\n #include \"sanitizer_common/sanitizer_allocator_interface.h\"\n+#include \"sanitizer_common/sanitizer_allocator_report.h\"\n #include \"sanitizer_common/sanitizer_errno.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n@@ -68,15 +69,27 @@ static void RegisterDeallocation(void *p) {\n   atomic_store(reinterpret_cast<atomic_uint8_t *>(m), 0, memory_order_relaxed);\n }\n \n+static void *ReportAllocationSizeTooBig(uptr size, const StackTrace &stack) {\n+  if (AllocatorMayReturnNull()) {\n+    Report(\"WARNING: LeakSanitizer failed to allocate 0x%zx bytes\\n\", size);\n+    return nullptr;\n+  }\n+  ReportAllocationSizeTooBig(size, kMaxAllowedMallocSize, &stack);\n+}\n+\n void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n                bool cleared) {\n   if (size == 0)\n     size = 1;\n-  if (size > kMaxAllowedMallocSize) {\n-    Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", size);\n-    return Allocator::FailureHandler::OnBadRequest();\n-  }\n+  if (size > kMaxAllowedMallocSize)\n+    return ReportAllocationSizeTooBig(size, stack);\n   void *p = allocator.Allocate(GetAllocatorCache(), size, alignment);\n+  if (UNLIKELY(!p)) {\n+    SetAllocatorOutOfMemory();\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportOutOfMemory(size, &stack);\n+  }\n   // Do not rely on the allocator to clear the memory (it's slow).\n   if (cleared && allocator.FromPrimary(p))\n     memset(p, 0, size);\n@@ -87,8 +100,11 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n }\n \n static void *Calloc(uptr nmemb, uptr size, const StackTrace &stack) {\n-  if (UNLIKELY(CheckForCallocOverflow(size, nmemb)))\n-    return Allocator::FailureHandler::OnBadRequest();\n+  if (UNLIKELY(CheckForCallocOverflow(size, nmemb))) {\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportCallocOverflow(nmemb, size, &stack);\n+  }\n   size *= nmemb;\n   return Allocate(stack, size, 1, true);\n }\n@@ -104,9 +120,8 @@ void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n                  uptr alignment) {\n   RegisterDeallocation(p);\n   if (new_size > kMaxAllowedMallocSize) {\n-    Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", new_size);\n     allocator.Deallocate(GetAllocatorCache(), p);\n-    return Allocator::FailureHandler::OnBadRequest();\n+    return ReportAllocationSizeTooBig(new_size, stack);\n   }\n   p = allocator.Reallocate(GetAllocatorCache(), p, new_size, alignment);\n   RegisterAllocation(stack, p, new_size);\n@@ -124,10 +139,38 @@ uptr GetMallocUsableSize(const void *p) {\n   return m->requested_size;\n }\n \n+int lsan_posix_memalign(void **memptr, uptr alignment, uptr size,\n+                        const StackTrace &stack) {\n+  if (UNLIKELY(!CheckPosixMemalignAlignment(alignment))) {\n+    if (AllocatorMayReturnNull())\n+      return errno_EINVAL;\n+    ReportInvalidPosixMemalignAlignment(alignment, &stack);\n+  }\n+  void *ptr = Allocate(stack, size, alignment, kAlwaysClearMemory);\n+  if (UNLIKELY(!ptr))\n+    // OOM error is already taken care of by Allocate.\n+    return errno_ENOMEM;\n+  CHECK(IsAligned((uptr)ptr, alignment));\n+  *memptr = ptr;\n+  return 0;\n+}\n+\n+void *lsan_aligned_alloc(uptr alignment, uptr size, const StackTrace &stack) {\n+  if (UNLIKELY(!CheckAlignedAllocAlignmentAndSize(alignment, size))) {\n+    errno = errno_EINVAL;\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportInvalidAlignedAllocAlignment(size, alignment, &stack);\n+  }\n+  return SetErrnoOnNull(Allocate(stack, size, alignment, kAlwaysClearMemory));\n+}\n+\n void *lsan_memalign(uptr alignment, uptr size, const StackTrace &stack) {\n   if (UNLIKELY(!IsPowerOfTwo(alignment))) {\n     errno = errno_EINVAL;\n-    return Allocator::FailureHandler::OnBadRequest();\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportInvalidAllocationAlignment(alignment, &stack);\n   }\n   return SetErrnoOnNull(Allocate(stack, size, alignment, kAlwaysClearMemory));\n }\n@@ -153,6 +196,19 @@ void *lsan_valloc(uptr size, const StackTrace &stack) {\n       Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory));\n }\n \n+void *lsan_pvalloc(uptr size, const StackTrace &stack) {\n+  uptr PageSize = GetPageSizeCached();\n+  if (UNLIKELY(CheckForPvallocOverflow(size, PageSize))) {\n+    errno = errno_ENOMEM;\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportPvallocOverflow(size, &stack);\n+  }\n+  // pvalloc(0) should allocate one page.\n+  size = size ? RoundUpTo(size, PageSize) : PageSize;\n+  return SetErrnoOnNull(Allocate(stack, size, PageSize, kAlwaysClearMemory));\n+}\n+\n uptr lsan_mz_size(const void *p) {\n   return GetMallocUsableSize(p);\n }"}, {"sha": "37260c0b5aede7ab3510c79584765cc9628cfb12", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -66,9 +66,16 @@ struct AP32 {\n };\n typedef SizeClassAllocator32<AP32> PrimaryAllocator;\n #elif defined(__x86_64__) || defined(__powerpc64__)\n+# if defined(__powerpc64__)\n+const uptr kAllocatorSpace = 0xa0000000000ULL;\n+const uptr kAllocatorSize  = 0x20000000000ULL;  // 2T.\n+# else\n+const uptr kAllocatorSpace = 0x600000000000ULL;\n+const uptr kAllocatorSize  = 0x40000000000ULL;  // 4T.\n+# endif\n struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n-  static const uptr kSpaceBeg = 0x600000000000ULL;\n-  static const uptr kSpaceSize =  0x40000000000ULL; // 4T.\n+  static const uptr kSpaceBeg = kAllocatorSpace;\n+  static const uptr kSpaceSize = kAllocatorSize;\n   static const uptr kMetadataSize = sizeof(ChunkMetadata);\n   typedef DefaultSizeClassMap SizeClassMap;\n   typedef NoOpMapUnmapCallback MapUnmapCallback;\n@@ -81,12 +88,16 @@ typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n \n AllocatorCache *GetAllocatorCache();\n \n+int lsan_posix_memalign(void **memptr, uptr alignment, uptr size,\n+                        const StackTrace &stack);\n+void *lsan_aligned_alloc(uptr alignment, uptr size, const StackTrace &stack);\n void *lsan_memalign(uptr alignment, uptr size, const StackTrace &stack);\n void *lsan_malloc(uptr size, const StackTrace &stack);\n void lsan_free(void *p);\n void *lsan_realloc(void *p, uptr size, const StackTrace &stack);\n void *lsan_calloc(uptr nmemb, uptr size, const StackTrace &stack);\n void *lsan_valloc(uptr size, const StackTrace &stack);\n+void *lsan_pvalloc(uptr size, const StackTrace &stack);\n uptr lsan_mz_size(const void *p);\n \n }  // namespace __lsan"}, {"sha": "a4424a8871af087ba8fea9548b9447251e0b2001", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -13,14 +13,15 @@\n #include \"lsan_common.h\"\n \n #include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_flag_parser.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n+#include \"sanitizer_common/sanitizer_report_decorator.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_suppressions.h\"\n-#include \"sanitizer_common/sanitizer_report_decorator.h\"\n+#include \"sanitizer_common/sanitizer_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n #if CAN_SANITIZE_LEAKS\n@@ -102,7 +103,7 @@ InternalMmapVector<RootRegion> const *GetRootRegions() { return root_regions; }\n void InitializeRootRegions() {\n   CHECK(!root_regions);\n   ALIGNED(64) static char placeholder[sizeof(InternalMmapVector<RootRegion>)];\n-  root_regions = new(placeholder) InternalMmapVector<RootRegion>(1);\n+  root_regions = new (placeholder) InternalMmapVector<RootRegion>();  // NOLINT\n }\n \n const char *MaybeCallLsanDefaultOptions() {\n@@ -212,9 +213,10 @@ void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg) {\n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            Frontier *frontier) {\n-  InternalScopedBuffer<uptr> registers(suspended_threads.RegisterCount());\n+  InternalMmapVector<uptr> registers(suspended_threads.RegisterCount());\n   uptr registers_begin = reinterpret_cast<uptr>(registers.data());\n-  uptr registers_end = registers_begin + registers.size();\n+  uptr registers_end =\n+      reinterpret_cast<uptr>(registers.data() + registers.size());\n   for (uptr i = 0; i < suspended_threads.ThreadCount(); i++) {\n     tid_t os_id = static_cast<tid_t>(suspended_threads.GetThreadID(i));\n     LOG_THREADS(\"Processing thread %d.\\n\", os_id);\n@@ -409,8 +411,9 @@ static void MarkInvalidPCCb(uptr chunk, void *arg) {\n   }\n }\n \n-// On Linux, handles dynamically allocated TLS blocks by treating all chunks\n-// allocated from ld-linux.so as reachable.\n+// On Linux, treats all chunks allocated from ld-linux.so as reachable, which\n+// covers dynamically allocated TLS blocks, internal dynamic loader's loaded\n+// modules accounting etc.\n // Dynamic TLS blocks contain the TLS variables of dynamically loaded modules.\n // They are allocated with a __libc_memalign() call in allocate_and_init()\n // (elf/dl-tls.c). Glibc won't tell us the address ranges occupied by those\n@@ -441,7 +444,7 @@ void ProcessPC(Frontier *frontier) {\n // Sets the appropriate tag on each chunk.\n static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n   // Holds the flood fill frontier.\n-  Frontier frontier(1);\n+  Frontier frontier;\n \n   ForEachChunk(CollectIgnoredCb, &frontier);\n   ProcessGlobalRegions(&frontier);\n@@ -503,7 +506,7 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n }\n \n static void PrintMatchedSuppressions() {\n-  InternalMmapVector<Suppression *> matched(1);\n+  InternalMmapVector<Suppression *> matched;\n   GetSuppressionContext()->GetMatched(&matched);\n   if (!matched.size())\n     return;\n@@ -522,11 +525,36 @@ struct CheckForLeaksParam {\n   LeakReport leak_report;\n };\n \n+static void ReportIfNotSuspended(ThreadContextBase *tctx, void *arg) {\n+  const InternalMmapVector<tid_t> &suspended_threads =\n+      *(const InternalMmapVector<tid_t> *)arg;\n+  if (tctx->status == ThreadStatusRunning) {\n+    uptr i = InternalLowerBound(suspended_threads, 0, suspended_threads.size(),\n+                                tctx->os_id, CompareLess<int>());\n+    if (i >= suspended_threads.size() || suspended_threads[i] != tctx->os_id)\n+      Report(\"Running thread %d was not suspended. False leaks are possible.\\n\",\n+             tctx->os_id);\n+  };\n+}\n+\n+static void ReportUnsuspendedThreads(\n+    const SuspendedThreadsList &suspended_threads) {\n+  InternalMmapVector<tid_t> threads(suspended_threads.ThreadCount());\n+  for (uptr i = 0; i < suspended_threads.ThreadCount(); ++i)\n+    threads[i] = suspended_threads.GetThreadID(i);\n+\n+  Sort(threads.data(), threads.size());\n+\n+  GetThreadRegistryLocked()->RunCallbackForEachThreadLocked(\n+      &ReportIfNotSuspended, &threads);\n+}\n+\n static void CheckForLeaksCallback(const SuspendedThreadsList &suspended_threads,\n                                   void *arg) {\n   CheckForLeaksParam *param = reinterpret_cast<CheckForLeaksParam *>(arg);\n   CHECK(param);\n   CHECK(!param->success);\n+  ReportUnsuspendedThreads(suspended_threads);\n   ClassifyAllChunks(suspended_threads);\n   ForEachChunk(CollectLeaksCb, &param->leak_report);\n   // Clean up for subsequent leak checks. This assumes we did not overwrite any\n@@ -681,7 +709,7 @@ void LeakReport::ReportTopLeaks(uptr num_leaks_to_report) {\n   uptr unsuppressed_count = UnsuppressedLeakCount();\n   if (num_leaks_to_report > 0 && num_leaks_to_report < unsuppressed_count)\n     Printf(\"The %zu top leak(s):\\n\", num_leaks_to_report);\n-  InternalSort(&leaks_, leaks_.size(), LeakComparator);\n+  Sort(leaks_.data(), leaks_.size(), &LeakComparator);\n   uptr leaks_reported = 0;\n   for (uptr i = 0; i < leaks_.size(); i++) {\n     if (leaks_[i].is_suppressed) continue;"}, {"sha": "b82474a51c9507a1f80e4268ac5d317f357336a9", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -25,9 +25,9 @@\n // because of \"small\" (4 bytes) pointer size that leads to high false negative\n // ratio on large leaks. But we still want to have it for some 32 bit arches\n // (e.g. x86), see https://github.com/google/sanitizers/issues/403.\n-// To enable LeakSanitizer on new architecture, one need to implement\n-// internal_clone function as well as (probably) adjust TLS machinery for\n-// new architecture inside sanitizer library.\n+// To enable LeakSanitizer on a new architecture, one needs to implement the\n+// internal_clone function as well as (probably) adjust the TLS machinery for\n+// the new architecture inside the sanitizer library.\n #if (SANITIZER_LINUX && !SANITIZER_ANDROID || SANITIZER_MAC) && \\\n     (SANITIZER_WORDSIZE == 64) &&                               \\\n     (defined(__x86_64__) || defined(__mips64) || defined(__aarch64__) || \\\n@@ -45,6 +45,7 @@\n \n namespace __sanitizer {\n class FlagParser;\n+class ThreadRegistry;\n struct DTLS;\n }\n \n@@ -93,20 +94,19 @@ struct LeakedObject {\n // Aggregates leaks by stack trace prefix.\n class LeakReport {\n  public:\n-  LeakReport() : next_id_(0), leaks_(1), leaked_objects_(1) {}\n+  LeakReport() {}\n   void AddLeakedChunk(uptr chunk, u32 stack_trace_id, uptr leaked_size,\n                       ChunkTag tag);\n   void ReportTopLeaks(uptr max_leaks);\n   void PrintSummary();\n   void ApplySuppressions();\n   uptr UnsuppressedLeakCount();\n \n-\n  private:\n   void PrintReportForLeak(uptr index);\n   void PrintLeakedObjectsForLeak(uptr index);\n \n-  u32 next_id_;\n+  u32 next_id_ = 0;\n   InternalMmapVector<Leak> leaks_;\n   InternalMmapVector<LeakedObject> leaked_objects_;\n };\n@@ -203,6 +203,7 @@ bool WordIsPoisoned(uptr addr);\n // Wrappers for ThreadRegistry access.\n void LockThreadRegistry();\n void UnlockThreadRegistry();\n+ThreadRegistry *GetThreadRegistryLocked();\n bool GetThreadRangesLocked(tid_t os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n                            uptr *cache_end, DTLS **dtls);"}, {"sha": "cffbfc9f8b17e94376d96724e5d4a0dbdf701f7f", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -18,6 +18,7 @@\n \n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_getauxval.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n@@ -28,8 +29,12 @@ static const char kLinkerName[] = \"ld\";\n static char linker_placeholder[sizeof(LoadedModule)] ALIGNED(64);\n static LoadedModule *linker = nullptr;\n \n-static bool IsLinker(const char* full_name) {\n-  return LibraryNameIs(full_name, kLinkerName);\n+static bool IsLinker(const LoadedModule& module) {\n+#if SANITIZER_USE_GETAUXVAL\n+  return module.base_address() == getauxval(AT_BASE);\n+#else\n+  return LibraryNameIs(module.full_name(), kLinkerName);\n+#endif  // SANITIZER_USE_GETAUXVAL\n }\n \n __attribute__((tls_model(\"initial-exec\")))\n@@ -47,22 +52,25 @@ void InitializePlatformSpecificModules() {\n   ListOfModules modules;\n   modules.init();\n   for (LoadedModule &module : modules) {\n-    if (!IsLinker(module.full_name())) continue;\n+    if (!IsLinker(module))\n+      continue;\n     if (linker == nullptr) {\n       linker = reinterpret_cast<LoadedModule *>(linker_placeholder);\n       *linker = module;\n       module = LoadedModule();\n     } else {\n       VReport(1, \"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n-              \"TLS will not be handled correctly.\\n\", kLinkerName);\n+              \"TLS and other allocations originating from linker might be \"\n+              \"falsely reported as leaks.\\n\", kLinkerName);\n       linker->clear();\n       linker = nullptr;\n       return;\n     }\n   }\n   if (linker == nullptr) {\n-    VReport(1, \"LeakSanitizer: Dynamic linker not found. \"\n-               \"TLS will not be handled correctly.\\n\");\n+    VReport(1, \"LeakSanitizer: Dynamic linker not found. TLS and other \"\n+               \"allocations originating from linker might be falsely reported \"\n+                \"as leaks.\\n\");\n   }\n }\n "}, {"sha": "8337cd2116f6ee3baf0875ffdec867232083d10a", "filename": "libsanitizer/lsan/lsan_common_mac.cc", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_common_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -117,7 +117,8 @@ void ProcessGlobalRegions(Frontier *frontier) {\n   for (auto name : kSkippedSecNames) CHECK(ARRAY_SIZE(name) < kMaxSegName);\n \n   MemoryMappingLayout memory_mapping(false);\n-  InternalMmapVector<LoadedModule> modules(/*initial_capacity*/ 128);\n+  InternalMmapVector<LoadedModule> modules;\n+  modules.reserve(128);\n   memory_mapping.DumpListOfModules(&modules);\n   for (uptr i = 0; i < modules.size(); ++i) {\n     // Even when global scanning is disabled, we still need to scan\n@@ -139,12 +140,6 @@ void ProcessGlobalRegions(Frontier *frontier) {\n }\n \n void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n-  mach_port_name_t port;\n-  if (task_for_pid(mach_task_self(), internal_getpid(), &port)\n-      != KERN_SUCCESS) {\n-    return;\n-  }\n-\n   unsigned depth = 1;\n   vm_size_t size = 0;\n   vm_address_t address = 0;\n@@ -155,7 +150,7 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n \n   while (err == KERN_SUCCESS) {\n     struct vm_region_submap_info_64 info;\n-    err = vm_region_recurse_64(port, &address, &size, &depth,\n+    err = vm_region_recurse_64(mach_task_self(), &address, &size, &depth,\n                                (vm_region_info_t)&info, &count);\n \n     uptr end_address = address + size;"}, {"sha": "7c594e5ed1745260122de5620f0003c7047049ce", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,6 +12,7 @@\n \n #include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_allocator_report.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n@@ -84,9 +85,7 @@ INTERCEPTOR(void*, realloc, void *q, uptr size) {\n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  *memptr = lsan_memalign(alignment, size, stack);\n-  // FIXME: Return ENOMEM if user requested more than max alloc size.\n-  return 0;\n+  return lsan_posix_memalign(memptr, alignment, size, stack);\n }\n \n INTERCEPTOR(void*, valloc, uptr size) {\n@@ -121,7 +120,7 @@ INTERCEPTOR(void *, __libc_memalign, uptr alignment, uptr size) {\n INTERCEPTOR(void*, aligned_alloc, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  return lsan_memalign(alignment, size, stack);\n+  return lsan_aligned_alloc(alignment, size, stack);\n }\n #define LSAN_MAYBE_INTERCEPT_ALIGNED_ALLOC INTERCEPT_FUNCTION(aligned_alloc)\n #else\n@@ -164,13 +163,7 @@ INTERCEPTOR(int, mallopt, int cmd, int value) {\n INTERCEPTOR(void*, pvalloc, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  uptr PageSize = GetPageSizeCached();\n-  size = RoundUpTo(size, PageSize);\n-  if (size == 0) {\n-    // pvalloc(0) should allocate one page.\n-    size = PageSize;\n-  }\n-  return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n+  return lsan_pvalloc(size, stack);\n }\n #define LSAN_MAYBE_INTERCEPT_PVALLOC INTERCEPT_FUNCTION(pvalloc)\n #else\n@@ -200,21 +193,21 @@ INTERCEPTOR(int, mprobe, void *ptr) {\n \n \n // TODO(alekseys): throw std::bad_alloc instead of dying on OOM.\n-#define OPERATOR_NEW_BODY(nothrow)                         \\\n-  ENSURE_LSAN_INITED;                                      \\\n-  GET_STACK_TRACE_MALLOC;                                  \\\n-  void *res = lsan_malloc(size, stack);                    \\\n-  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();   \\\n+#define OPERATOR_NEW_BODY(nothrow)\\\n+  ENSURE_LSAN_INITED;\\\n+  GET_STACK_TRACE_MALLOC;\\\n+  void *res = lsan_malloc(size, stack);\\\n+  if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n   return res;\n-#define OPERATOR_NEW_BODY_ALIGN(nothrow)                   \\\n-  ENSURE_LSAN_INITED;                                      \\\n-  GET_STACK_TRACE_MALLOC;                                  \\\n-  void *res = lsan_memalign((uptr)align, size, stack);     \\\n-  if (!nothrow && UNLIKELY(!res)) DieOnFailure::OnOOM();   \\\n+#define OPERATOR_NEW_BODY_ALIGN(nothrow)\\\n+  ENSURE_LSAN_INITED;\\\n+  GET_STACK_TRACE_MALLOC;\\\n+  void *res = lsan_memalign((uptr)align, size, stack);\\\n+  if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n   return res;\n \n-#define OPERATOR_DELETE_BODY \\\n-  ENSURE_LSAN_INITED;        \\\n+#define OPERATOR_DELETE_BODY\\\n+  ENSURE_LSAN_INITED;\\\n   lsan_free(ptr);\n \n // On OS X it's not enough to just provide our own 'operator new' and\n@@ -307,6 +300,7 @@ INTERCEPTOR(void, _ZdaPvRKSt9nothrow_t, void *ptr, std::nothrow_t const&)\n \n ///// Thread initialization and finalization. /////\n \n+#if !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n static unsigned g_thread_finalize_key;\n \n static void thread_finalize(void *v) {\n@@ -320,6 +314,29 @@ static void thread_finalize(void *v) {\n   }\n   ThreadFinish();\n }\n+#endif\n+\n+#if SANITIZER_NETBSD\n+INTERCEPTOR(void, _lwp_exit) {\n+  ENSURE_LSAN_INITED;\n+  ThreadFinish();\n+  REAL(_lwp_exit)();\n+}\n+#define LSAN_MAYBE_INTERCEPT__LWP_EXIT INTERCEPT_FUNCTION(_lwp_exit)\n+#else\n+#define LSAN_MAYBE_INTERCEPT__LWP_EXIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_THR_EXIT\n+INTERCEPTOR(void, thr_exit, tid_t *state) {\n+  ENSURE_LSAN_INITED;\n+  ThreadFinish();\n+  REAL(thr_exit)(state);\n+}\n+#define LSAN_MAYBE_INTERCEPT_THR_EXIT INTERCEPT_FUNCTION(thr_exit)\n+#else\n+#define LSAN_MAYBE_INTERCEPT_THR_EXIT\n+#endif\n \n struct ThreadParam {\n   void *(*callback)(void *arg);\n@@ -333,11 +350,13 @@ extern \"C\" void *__lsan_thread_start_func(void *arg) {\n   void *param = p->param;\n   // Wait until the last iteration to maximize the chance that we are the last\n   // destructor to run.\n+#if !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n   if (pthread_setspecific(g_thread_finalize_key,\n                           (void*)GetPthreadDestructorIterations())) {\n     Report(\"LeakSanitizer: failed to set thread key.\\n\");\n     Die();\n   }\n+#endif\n   int tid = 0;\n   while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n     internal_sched_yield();\n@@ -425,10 +444,15 @@ void InitializeInterceptors() {\n   INTERCEPT_FUNCTION(pthread_join);\n   INTERCEPT_FUNCTION(_exit);\n \n+  LSAN_MAYBE_INTERCEPT__LWP_EXIT;\n+  LSAN_MAYBE_INTERCEPT_THR_EXIT;\n+\n+#if !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n   if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n     Report(\"LeakSanitizer: failed to create thread key.\\n\");\n     Die();\n   }\n+#endif\n }\n \n } // namespace __lsan"}, {"sha": "2458b50892f1b76b02b55db404b1631efa271d85", "filename": "libsanitizer/lsan/lsan_malloc_mac.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_malloc_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -35,6 +35,9 @@ using namespace __lsan;\n #define COMMON_MALLOC_CALLOC(count, size) \\\n   GET_STACK_TRACE_MALLOC; \\\n   void *p = lsan_calloc(count, size, stack)\n+#define COMMON_MALLOC_POSIX_MEMALIGN(memptr, alignment, size) \\\n+  GET_STACK_TRACE_MALLOC; \\\n+  int res = lsan_posix_memalign(memptr, alignment, size, stack)\n #define COMMON_MALLOC_VALLOC(size) \\\n   GET_STACK_TRACE_MALLOC; \\\n   void *p = lsan_valloc(size, stack)"}, {"sha": "388990bf5fd71b273db95071f5d07868b8765fd7", "filename": "libsanitizer/lsan/lsan_thread.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Flsan%2Flsan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -153,4 +153,9 @@ void UnlockThreadRegistry() {\n   thread_registry->Unlock();\n }\n \n+ThreadRegistry *GetThreadRegistryLocked() {\n+  thread_registry->CheckLocked();\n+  return thread_registry;\n+}\n+\n } // namespace __lsan"}, {"sha": "c8ad0a0bcb5c5d8740bb8071b64c704a3651c246", "filename": "libsanitizer/sanitizer_common/sancov_begin.S", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsancov_begin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsancov_begin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_begin.S?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,5 @@\n+\t.type\t\t__start___sancov_guards,@object\n+\t.globl\t\t__start___sancov_guards\n+        .section        __sancov_guards,\"aw\",@progbits\n+        .p2align        2\n+__start___sancov_guards:"}, {"sha": "31117b1c0b56105c3778ebf26d79f5928aecb66d", "filename": "libsanitizer/sanitizer_common/sancov_end.S", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsancov_end.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsancov_end.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_end.S?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,5 @@\n+\t.type\t\t__stop___sancov_guards,@object\n+\t.globl\t\t__stop___sancov_guards\n+        .section        __sancov_guards,\"aw\",@progbits\n+        .p2align        2\n+__stop___sancov_guards:"}, {"sha": "2fd6e8a424868583c6399aaeb67b72cd0940ca1a", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -19,6 +19,10 @@\n \n namespace __sanitizer {\n \n+// Default allocator names.\n+const char *PrimaryAllocatorName = \"SizeClassAllocator\";\n+const char *SecondaryAllocatorName = \"LargeMmapAllocator\";\n+\n // ThreadSanitizer for Go uses libc malloc/free.\n #if SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n # if SANITIZER_LINUX && !SANITIZER_ANDROID\n@@ -134,12 +138,19 @@ static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n \n const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n \n+static void NORETURN ReportInternalAllocatorOutOfMemory(uptr requested_size) {\n+  SetAllocatorOutOfMemory();\n+  Report(\"FATAL: %s: internal allocator is out of memory trying to allocate \"\n+         \"0x%zx bytes\\n\", SanitizerToolName, requested_size);\n+  Die();\n+}\n+\n void *InternalAlloc(uptr size, InternalAllocatorCache *cache, uptr alignment) {\n   if (size + sizeof(u64) < size)\n     return nullptr;\n   void *p = RawInternalAlloc(size + sizeof(u64), cache, alignment);\n-  if (!p)\n-    return nullptr;\n+  if (UNLIKELY(!p))\n+    ReportInternalAllocatorOutOfMemory(size + sizeof(u64));\n   ((u64*)p)[0] = kBlockMagic;\n   return (char*)p + sizeof(u64);\n }\n@@ -153,16 +164,21 @@ void *InternalRealloc(void *addr, uptr size, InternalAllocatorCache *cache) {\n   size = size + sizeof(u64);\n   CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);\n   void *p = RawInternalRealloc(addr, size, cache);\n-  if (!p)\n-    return nullptr;\n+  if (UNLIKELY(!p))\n+    ReportInternalAllocatorOutOfMemory(size);\n   return (char*)p + sizeof(u64);\n }\n \n void *InternalCalloc(uptr count, uptr size, InternalAllocatorCache *cache) {\n-  if (UNLIKELY(CheckForCallocOverflow(count, size)))\n-    return InternalAllocator::FailureHandler::OnBadRequest();\n+  if (UNLIKELY(CheckForCallocOverflow(count, size))) {\n+    Report(\"FATAL: %s: calloc parameters overflow: count * size (%zd * %zd) \"\n+           \"cannot be represented in type size_t\\n\", SanitizerToolName, count,\n+           size);\n+    Die();\n+  }\n   void *p = InternalAlloc(count * size, cache);\n-  if (p) internal_memset(p, 0, count * size);\n+  if (LIKELY(p))\n+    internal_memset(p, 0, count * size);\n   return p;\n }\n \n@@ -176,11 +192,13 @@ void InternalFree(void *addr, InternalAllocatorCache *cache) {\n }\n \n // LowLevelAllocator\n+constexpr uptr kLowLevelAllocatorDefaultAlignment = 8;\n+static uptr low_level_alloc_min_alignment = kLowLevelAllocatorDefaultAlignment;\n static LowLevelAllocateCallback low_level_alloc_callback;\n \n void *LowLevelAllocator::Allocate(uptr size) {\n   // Align allocation size.\n-  size = RoundUpTo(size, 8);\n+  size = RoundUpTo(size, low_level_alloc_min_alignment);\n   if (allocated_end_ - allocated_current_ < (sptr)size) {\n     uptr size_to_allocate = Max(size, GetPageSizeCached());\n     allocated_current_ =\n@@ -197,24 +215,26 @@ void *LowLevelAllocator::Allocate(uptr size) {\n   return res;\n }\n \n+void SetLowLevelAllocateMinAlignment(uptr alignment) {\n+  CHECK(IsPowerOfTwo(alignment));\n+  low_level_alloc_min_alignment = Max(alignment, low_level_alloc_min_alignment);\n+}\n+\n void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback) {\n   low_level_alloc_callback = callback;\n }\n \n+// Allocator's OOM and other errors handling support.\n+\n static atomic_uint8_t allocator_out_of_memory = {0};\n static atomic_uint8_t allocator_may_return_null = {0};\n \n bool IsAllocatorOutOfMemory() {\n   return atomic_load_relaxed(&allocator_out_of_memory);\n }\n \n-// Prints error message and kills the program.\n-void NORETURN ReportAllocatorCannotReturnNull() {\n-  Report(\"%s's allocator is terminating the process instead of returning 0\\n\",\n-         SanitizerToolName);\n-  Report(\"If you don't like this behavior set allocator_may_return_null=1\\n\");\n-  CHECK(0);\n-  Die();\n+void SetAllocatorOutOfMemory() {\n+  atomic_store_relaxed(&allocator_out_of_memory, 1);\n }\n \n bool AllocatorMayReturnNull() {\n@@ -226,26 +246,9 @@ void SetAllocatorMayReturnNull(bool may_return_null) {\n                memory_order_relaxed);\n }\n \n-void *ReturnNullOrDieOnFailure::OnBadRequest() {\n-  if (AllocatorMayReturnNull())\n-    return nullptr;\n-  ReportAllocatorCannotReturnNull();\n-}\n-\n-void *ReturnNullOrDieOnFailure::OnOOM() {\n-  atomic_store_relaxed(&allocator_out_of_memory, 1);\n-  if (AllocatorMayReturnNull())\n-    return nullptr;\n-  ReportAllocatorCannotReturnNull();\n-}\n-\n-void NORETURN *DieOnFailure::OnBadRequest() {\n-  ReportAllocatorCannotReturnNull();\n-}\n-\n-void NORETURN *DieOnFailure::OnOOM() {\n-  atomic_store_relaxed(&allocator_out_of_memory, 1);\n-  ReportAllocatorCannotReturnNull();\n+void PrintHintAllocatorCannotReturnNull() {\n+  Report(\"HINT: if you don't care about these errors you may set \"\n+         \"allocator_may_return_null=1\\n\");\n }\n \n } // namespace __sanitizer"}, {"sha": "7dbb9f72017f582d726c86358a3add9a214632a5", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -22,28 +22,23 @@\n \n namespace __sanitizer {\n \n+// Allows the tools to name their allocations appropriately.\n+extern const char *PrimaryAllocatorName;\n+extern const char *SecondaryAllocatorName;\n+\n // Since flags are immutable and allocator behavior can be changed at runtime\n // (unit tests or ASan on Android are some examples), allocator_may_return_null\n // flag value is cached here and can be altered later.\n bool AllocatorMayReturnNull();\n void SetAllocatorMayReturnNull(bool may_return_null);\n \n-// Allocator failure handling policies:\n-// Implements AllocatorMayReturnNull policy, returns null when the flag is set,\n-// dies otherwise.\n-struct ReturnNullOrDieOnFailure {\n-  static void *OnBadRequest();\n-  static void *OnOOM();\n-};\n-// Always dies on the failure.\n-struct DieOnFailure {\n-  static void NORETURN *OnBadRequest();\n-  static void NORETURN *OnOOM();\n-};\n-\n // Returns true if allocator detected OOM condition. Can be used to avoid memory\n-// hungry operations. Set when AllocatorReturnNullOrDieOnOOM() is called.\n+// hungry operations.\n bool IsAllocatorOutOfMemory();\n+// Should be called by a particular allocator when OOM is detected.\n+void SetAllocatorOutOfMemory();\n+\n+void PrintHintAllocatorCannotReturnNull();\n \n // Allocators call these callbacks on mmap/munmap.\n struct NoOpMapUnmapCallback {\n@@ -54,6 +49,21 @@ struct NoOpMapUnmapCallback {\n // Callback type for iterating over chunks.\n typedef void (*ForEachChunkCallback)(uptr chunk, void *arg);\n \n+INLINE u32 Rand(u32 *state) {  // ANSI C linear congruential PRNG.\n+  return (*state = *state * 1103515245 + 12345) >> 16;\n+}\n+\n+INLINE u32 RandN(u32 *state, u32 n) { return Rand(state) % n; }  // [0, n)\n+\n+template<typename T>\n+INLINE void RandomShuffle(T *a, u32 n, u32 *rand_state) {\n+  if (n <= 1) return;\n+  u32 state = *rand_state;\n+  for (u32 i = n - 1; i > 0; i--)\n+    Swap(a[i], a[RandN(&state, i + 1)]);\n+  *rand_state = state;\n+}\n+\n #include \"sanitizer_allocator_size_class_map.h\"\n #include \"sanitizer_allocator_stats.h\"\n #include \"sanitizer_allocator_primary64.h\""}, {"sha": "3a3f22266f7f1235aff438bcc94f72d6d4b1a6a9", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_bytemap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -16,7 +16,7 @@\n template<u64 kSize>\n class FlatByteMap {\n  public:\n-  void TestOnlyInit() {\n+  void Init() {\n     internal_memset(map_, 0, sizeof(map_));\n   }\n \n@@ -42,7 +42,7 @@ class FlatByteMap {\n template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>\n class TwoLevelByteMap {\n  public:\n-  void TestOnlyInit() {\n+  void Init() {\n     internal_memset(map1_, 0, sizeof(map1_));\n     mu_.Init();\n   }"}, {"sha": "9056ed5798754817c085e1441e129c9eadb5fd44", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -42,16 +42,18 @@ INLINE void *SetErrnoOnNull(void *ptr) {\n // of alignment.\n INLINE bool CheckAlignedAllocAlignmentAndSize(uptr alignment, uptr size) {\n #if SANITIZER_POSIX\n-  return IsPowerOfTwo(alignment) && (size & (alignment - 1)) == 0;\n+  return alignment != 0 && IsPowerOfTwo(alignment) &&\n+         (size & (alignment - 1)) == 0;\n #else\n-  return size % alignment == 0;\n+  return alignment != 0 && size % alignment == 0;\n #endif\n }\n \n // Checks posix_memalign() parameters, verifies that alignment is a power of two\n // and a multiple of sizeof(void *).\n INLINE bool CheckPosixMemalignAlignment(uptr alignment) {\n-  return IsPowerOfTwo(alignment) && (alignment % sizeof(void *)) == 0; // NOLINT\n+  return alignment != 0 && IsPowerOfTwo(alignment) &&\n+         (alignment % sizeof(void *)) == 0; // NOLINT\n }\n \n // Returns true if calloc(size, n) call overflows on size*n calculation."}, {"sha": "ec6c0da8538c569a25f22d0a87df63cac3f7a57c", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -22,8 +22,6 @@ template <class PrimaryAllocator, class AllocatorCache,\n           class SecondaryAllocator>  // NOLINT\n class CombinedAllocator {\n  public:\n-  typedef typename SecondaryAllocator::FailureHandler FailureHandler;\n-\n   void InitLinkerInitialized(s32 release_to_os_interval_ms) {\n     primary_.Init(release_to_os_interval_ms);\n     secondary_.InitLinkerInitialized();\n@@ -40,8 +38,12 @@ class CombinedAllocator {\n     // Returning 0 on malloc(0) may break a lot of code.\n     if (size == 0)\n       size = 1;\n-    if (size + alignment < size)\n-      return FailureHandler::OnBadRequest();\n+    if (size + alignment < size) {\n+      Report(\"WARNING: %s: CombinedAllocator allocation overflow: \"\n+             \"0x%zx bytes with 0x%zx alignment requested\\n\",\n+             SanitizerToolName, size, alignment);\n+      return nullptr;\n+    }\n     uptr original_size = size;\n     // If alignment requirements are to be fulfilled by the frontend allocator\n     // rather than by the primary or secondary, passing an alignment lower than\n@@ -60,8 +62,6 @@ class CombinedAllocator {\n       res = cache->Allocate(&primary_, primary_.ClassID(size));\n     else\n       res = secondary_.Allocate(&stats_, original_size, alignment);\n-    if (!res)\n-      return FailureHandler::OnOOM();\n     if (alignment > 8)\n       CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n     return res;\n@@ -75,6 +75,10 @@ class CombinedAllocator {\n     primary_.SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n   }\n \n+  void ForceReleaseToOS() {\n+    primary_.ForceReleaseToOS();\n+  }\n+\n   void Deallocate(AllocatorCache *cache, void *p) {\n     if (!p) return;\n     if (primary_.PointerIsMine(p))"}, {"sha": "35213c74c0042a902a255a5bf055b88cbc9c860b", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_interface.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -36,6 +36,9 @@ SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n     void __sanitizer_free_hook(void *ptr);\n \n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n+__sanitizer_purge_allocator();\n+\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n __sanitizer_print_memory_profile(uptr top_percent, uptr max_number_of_contexts);\n }  // extern \"C\""}, {"sha": "05aed0ecfe04aa44a0cef7cc024b5812a32696ac", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -44,9 +44,12 @@ typedef SizeClassAllocator32<AP32> PrimaryInternalAllocator;\n typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n     InternalAllocatorCache;\n \n+typedef LargeMmapAllocator<NoOpMapUnmapCallback,\n+                           LargeMmapAllocatorPtrArrayStatic>\n+    SecondaryInternalAllocator;\n+\n typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n-                          LargeMmapAllocator<NoOpMapUnmapCallback, DieOnFailure>\n-                         > InternalAllocator;\n+                          SecondaryInternalAllocator> InternalAllocator;\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache = nullptr,\n                     uptr alignment = 0);\n@@ -57,15 +60,6 @@ void *InternalCalloc(uptr countr, uptr size,\n void InternalFree(void *p, InternalAllocatorCache *cache = nullptr);\n InternalAllocator *internal_allocator();\n \n-enum InternalAllocEnum {\n-  INTERNAL_ALLOC\n-};\n-\n } // namespace __sanitizer\n \n-inline void *operator new(__sanitizer::operator_new_size_type size,\n-                          __sanitizer::InternalAllocEnum) {\n-  return __sanitizer::InternalAlloc(size);\n-}\n-\n #endif // SANITIZER_ALLOCATOR_INTERNAL_H"}, {"sha": "d23c59aa05c3fa761534eae28f051003c9032a4b", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_local_cache.h", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -17,8 +17,7 @@\n // object per thread in TLS, is has to be POD.\n template<class SizeClassAllocator>\n struct SizeClassAllocatorLocalCache\n-    : SizeClassAllocator::AllocatorCache {\n-};\n+    : SizeClassAllocator::AllocatorCache {};\n \n // Cache used by SizeClassAllocator64.\n template <class SizeClassAllocator>\n@@ -44,34 +43,32 @@ struct SizeClassAllocator64LocalCache {\n     if (UNLIKELY(c->count == 0)) {\n       if (UNLIKELY(!Refill(c, allocator, class_id)))\n         return nullptr;\n+      DCHECK_GT(c->count, 0);\n     }\n-    stats_.Add(AllocatorStatAllocated, c->class_size);\n-    CHECK_GT(c->count, 0);\n     CompactPtrT chunk = c->chunks[--c->count];\n-    void *res = reinterpret_cast<void *>(allocator->CompactPtrToPointer(\n+    stats_.Add(AllocatorStatAllocated, c->class_size);\n+    return reinterpret_cast<void *>(allocator->CompactPtrToPointer(\n         allocator->GetRegionBeginBySizeClass(class_id), chunk));\n-    return res;\n   }\n \n   void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n     // If the first allocator call on a new thread is a deallocation, then\n     // max_count will be zero, leading to check failure.\n-    InitCache();\n     PerClass *c = &per_class_[class_id];\n-    stats_.Sub(AllocatorStatAllocated, c->class_size);\n-    CHECK_NE(c->max_count, 0UL);\n+    InitCache(c);\n     if (UNLIKELY(c->count == c->max_count))\n       Drain(c, allocator, class_id, c->max_count / 2);\n     CompactPtrT chunk = allocator->PointerToCompactPtr(\n         allocator->GetRegionBeginBySizeClass(class_id),\n         reinterpret_cast<uptr>(p));\n     c->chunks[c->count++] = chunk;\n+    stats_.Sub(AllocatorStatAllocated, c->class_size);\n   }\n \n   void Drain(SizeClassAllocator *allocator) {\n-    for (uptr i = 0; i < kNumClasses; i++) {\n+    for (uptr i = 1; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n       while (c->count > 0)\n         Drain(c, allocator, i, c->count);\n@@ -92,20 +89,22 @@ struct SizeClassAllocator64LocalCache {\n   PerClass per_class_[kNumClasses];\n   AllocatorStats stats_;\n \n-  void InitCache() {\n-    if (LIKELY(per_class_[1].max_count))\n+  void InitCache(PerClass *c) {\n+    if (LIKELY(c->max_count))\n       return;\n-    for (uptr i = 0; i < kNumClasses; i++) {\n+    for (uptr i = 1; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n-      c->max_count = 2 * SizeClassMap::MaxCachedHint(i);\n-      c->class_size = Allocator::ClassIdToSize(i);\n+      const uptr size = Allocator::ClassIdToSize(i);\n+      c->max_count = 2 * SizeClassMap::MaxCachedHint(size);\n+      c->class_size = size;\n     }\n+    DCHECK_NE(c->max_count, 0UL);\n   }\n \n   NOINLINE bool Refill(PerClass *c, SizeClassAllocator *allocator,\n                        uptr class_id) {\n-    InitCache();\n-    uptr num_requested_chunks = c->max_count / 2;\n+    InitCache(c);\n+    const uptr num_requested_chunks = c->max_count / 2;\n     if (UNLIKELY(!allocator->GetFromAllocator(&stats_, class_id, c->chunks,\n                                               num_requested_chunks)))\n       return false;\n@@ -115,9 +114,8 @@ struct SizeClassAllocator64LocalCache {\n \n   NOINLINE void Drain(PerClass *c, SizeClassAllocator *allocator, uptr class_id,\n                       uptr count) {\n-    InitCache();\n     CHECK_GE(c->count, count);\n-    uptr first_idx_to_drain = c->count - count;\n+    const uptr first_idx_to_drain = c->count - count;\n     c->count -= count;\n     allocator->ReturnToAllocator(&stats_, class_id,\n                                  &c->chunks[first_idx_to_drain], count);\n@@ -162,12 +160,13 @@ struct SizeClassAllocator32LocalCache {\n     CHECK_LT(class_id, kNumClasses);\n     PerClass *c = &per_class_[class_id];\n     if (UNLIKELY(c->count == 0)) {\n-      if (UNLIKELY(!Refill(allocator, class_id)))\n+      if (UNLIKELY(!Refill(c, allocator, class_id)))\n         return nullptr;\n+      DCHECK_GT(c->count, 0);\n     }\n-    stats_.Add(AllocatorStatAllocated, c->class_size);\n     void *res = c->batch[--c->count];\n     PREFETCH(c->batch[c->count - 1]);\n+    stats_.Add(AllocatorStatAllocated, c->class_size);\n     return res;\n   }\n \n@@ -176,20 +175,19 @@ struct SizeClassAllocator32LocalCache {\n     CHECK_LT(class_id, kNumClasses);\n     // If the first allocator call on a new thread is a deallocation, then\n     // max_count will be zero, leading to check failure.\n-    InitCache();\n     PerClass *c = &per_class_[class_id];\n-    stats_.Sub(AllocatorStatAllocated, c->class_size);\n-    CHECK_NE(c->max_count, 0UL);\n+    InitCache(c);\n     if (UNLIKELY(c->count == c->max_count))\n-      Drain(allocator, class_id);\n+      Drain(c, allocator, class_id);\n     c->batch[c->count++] = p;\n+    stats_.Sub(AllocatorStatAllocated, c->class_size);\n   }\n \n   void Drain(SizeClassAllocator *allocator) {\n-    for (uptr i = 0; i < kNumClasses; i++) {\n+    for (uptr i = 1; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n       while (c->count > 0)\n-        Drain(allocator, i);\n+        Drain(c, allocator, i);\n     }\n   }\n \n@@ -214,32 +212,34 @@ struct SizeClassAllocator32LocalCache {\n   PerClass per_class_[kNumClasses];\n   AllocatorStats stats_;\n \n-  void InitCache() {\n-    if (LIKELY(per_class_[1].max_count))\n+  void InitCache(PerClass *c) {\n+    if (LIKELY(c->max_count))\n       return;\n     const uptr batch_class_id = SizeClassMap::ClassID(sizeof(TransferBatch));\n-    for (uptr i = 0; i < kNumClasses; i++) {\n+    for (uptr i = 1; i < kNumClasses; i++) {\n       PerClass *c = &per_class_[i];\n-      uptr max_cached = TransferBatch::MaxCached(i);\n+      const uptr size = Allocator::ClassIdToSize(i);\n+      const uptr max_cached = TransferBatch::MaxCached(size);\n       c->max_count = 2 * max_cached;\n-      c->class_size = Allocator::ClassIdToSize(i);\n+      c->class_size = size;\n       // Precompute the class id to use to store batches for the current class\n       // id. 0 means the class size is large enough to store a batch within one\n       // of the chunks. If using a separate size class, it will always be\n       // kBatchClassID, except for kBatchClassID itself.\n       if (kUseSeparateSizeClassForBatch) {\n         c->batch_class_id = (i == kBatchClassID) ? 0 : kBatchClassID;\n       } else {\n-        c->batch_class_id = (c->class_size <\n+        c->batch_class_id = (size <\n           TransferBatch::AllocationSizeRequiredForNElements(max_cached)) ?\n               batch_class_id : 0;\n       }\n     }\n+    DCHECK_NE(c->max_count, 0UL);\n   }\n \n-  NOINLINE bool Refill(SizeClassAllocator *allocator, uptr class_id) {\n-    InitCache();\n-    PerClass *c = &per_class_[class_id];\n+  NOINLINE bool Refill(PerClass *c, SizeClassAllocator *allocator,\n+                       uptr class_id) {\n+    InitCache(c);\n     TransferBatch *b = allocator->AllocateBatch(&stats_, this, class_id);\n     if (UNLIKELY(!b))\n       return false;\n@@ -250,20 +250,21 @@ struct SizeClassAllocator32LocalCache {\n     return true;\n   }\n \n-  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {\n-    InitCache();\n-    PerClass *c = &per_class_[class_id];\n-    uptr cnt = Min(c->max_count / 2, c->count);\n-    uptr first_idx_to_drain = c->count - cnt;\n+  NOINLINE void Drain(PerClass *c, SizeClassAllocator *allocator,\n+                      uptr class_id) {\n+    const uptr count = Min(c->max_count / 2, c->count);\n+    const uptr first_idx_to_drain = c->count - count;\n     TransferBatch *b = CreateBatch(\n         class_id, allocator, (TransferBatch *)c->batch[first_idx_to_drain]);\n     // Failure to allocate a batch while releasing memory is non recoverable.\n     // TODO(alekseys): Figure out how to do it without allocating a new batch.\n-    if (UNLIKELY(!b))\n-      DieOnFailure::OnOOM();\n-    b->SetFromArray(allocator->GetRegionBeginBySizeClass(class_id),\n-                    &c->batch[first_idx_to_drain], cnt);\n-    c->count -= cnt;\n+    if (UNLIKELY(!b)) {\n+      Report(\"FATAL: Internal error: %s's allocator failed to allocate a \"\n+             \"transfer batch.\\n\", SanitizerToolName);\n+      Die();\n+    }\n+    b->SetFromArray(&c->batch[first_idx_to_drain], count);\n+    c->count -= count;\n     allocator->DeallocateBatch(&stats_, class_id, b);\n   }\n };"}, {"sha": "bdea498fb5ecc3d40ea54b266d7edecd7349831d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 76, "deletions": 44, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -61,19 +61,19 @@ class SizeClassAllocator32 {\n \n   struct TransferBatch {\n     static const uptr kMaxNumCached = SizeClassMap::kMaxNumCachedHint - 2;\n-    void SetFromArray(uptr region_beg_unused, void *batch[], uptr count) {\n+    void SetFromArray(void *batch[], uptr count) {\n+      DCHECK_LE(count, kMaxNumCached);\n       count_ = count;\n-      CHECK_LE(count_, kMaxNumCached);\n       for (uptr i = 0; i < count; i++)\n         batch_[i] = batch[i];\n     }\n     uptr Count() const { return count_; }\n     void Clear() { count_ = 0; }\n     void Add(void *ptr) {\n       batch_[count_++] = ptr;\n-      CHECK_LE(count_, kMaxNumCached);\n+      DCHECK_LE(count_, kMaxNumCached);\n     }\n-    void CopyToArray(void *to_batch[]) {\n+    void CopyToArray(void *to_batch[]) const {\n       for (uptr i = 0, n = Count(); i < n; i++)\n         to_batch[i] = batch_[i];\n     }\n@@ -82,8 +82,8 @@ class SizeClassAllocator32 {\n     static uptr AllocationSizeRequiredForNElements(uptr n) {\n       return sizeof(uptr) * 2 + sizeof(void *) * n;\n     }\n-    static uptr MaxCached(uptr class_id) {\n-      return Min(kMaxNumCached, SizeClassMap::MaxCachedHint(class_id));\n+    static uptr MaxCached(uptr size) {\n+      return Min(kMaxNumCached, SizeClassMap::MaxCachedHint(size));\n     }\n \n     TransferBatch *next;\n@@ -106,7 +106,7 @@ class SizeClassAllocator32 {\n   typedef SizeClassAllocator32LocalCache<ThisT> AllocatorCache;\n \n   void Init(s32 release_to_os_interval_ms) {\n-    possible_regions.TestOnlyInit();\n+    possible_regions.Init();\n     internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));\n   }\n \n@@ -118,8 +118,12 @@ class SizeClassAllocator32 {\n     // This is empty here. Currently only implemented in 64-bit allocator.\n   }\n \n+  void ForceReleaseToOS() {\n+    // Currently implemented in 64-bit allocator only.\n+  }\n+\n   void *MapWithCallback(uptr size) {\n-    void *res = MmapOrDie(size, \"SizeClassAllocator32\");\n+    void *res = MmapOrDie(size, PrimaryAllocatorName);\n     MapUnmapCallback().OnMap((uptr)res, size);\n     return res;\n   }\n@@ -147,29 +151,28 @@ class SizeClassAllocator32 {\n \n   NOINLINE TransferBatch *AllocateBatch(AllocatorStats *stat, AllocatorCache *c,\n                                         uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n+    DCHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n-    if (sci->free_list.empty() &&\n-        UNLIKELY(!PopulateFreeList(stat, c, sci, class_id)))\n-      return nullptr;\n-    CHECK(!sci->free_list.empty());\n+    if (sci->free_list.empty()) {\n+      if (UNLIKELY(!PopulateFreeList(stat, c, sci, class_id)))\n+        return nullptr;\n+      DCHECK(!sci->free_list.empty());\n+    }\n     TransferBatch *b = sci->free_list.front();\n     sci->free_list.pop_front();\n     return b;\n   }\n \n   NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id,\n                                 TransferBatch *b) {\n-    CHECK_LT(class_id, kNumClasses);\n+    DCHECK_LT(class_id, kNumClasses);\n     CHECK_GT(b->Count(), 0);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n     sci->free_list.push_front(b);\n   }\n \n-  uptr GetRegionBeginBySizeClass(uptr class_id) { return 0; }\n-\n   bool PointerIsMine(const void *p) {\n     uptr mem = reinterpret_cast<uptr>(p);\n     if (mem < kSpaceBeg || mem >= kSpaceBeg + kSpaceSize)\n@@ -245,12 +248,9 @@ class SizeClassAllocator32 {\n       }\n   }\n \n-  void PrintStats() {\n-  }\n+  void PrintStats() {}\n \n-  static uptr AdditionalSize() {\n-    return 0;\n-  }\n+  static uptr AdditionalSize() { return 0; }\n \n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n@@ -259,16 +259,15 @@ class SizeClassAllocator32 {\n   static const uptr kRegionSize = 1 << kRegionSizeLog;\n   static const uptr kNumPossibleRegions = kSpaceSize / kRegionSize;\n \n-  struct SizeClassInfo {\n-    SpinMutex mutex;\n+  struct ALIGNED(SANITIZER_CACHE_LINE_SIZE) SizeClassInfo {\n+    StaticSpinMutex mutex;\n     IntrusiveList<TransferBatch> free_list;\n-    char padding[kCacheLineSize - sizeof(uptr) -\n-                 sizeof(IntrusiveList<TransferBatch>)];\n+    u32 rand_state;\n   };\n-  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);\n+  COMPILER_CHECK(sizeof(SizeClassInfo) % kCacheLineSize == 0);\n \n   uptr ComputeRegionId(uptr mem) {\n-    uptr res = mem >> kRegionSizeLog;\n+    const uptr res = mem >> kRegionSizeLog;\n     CHECK_LT(res, kNumPossibleRegions);\n     return res;\n   }\n@@ -278,9 +277,9 @@ class SizeClassAllocator32 {\n   }\n \n   uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDieOnFatalError(\n-        kRegionSize, kRegionSize, \"SizeClassAllocator32\"));\n+    DCHECK_LT(class_id, kNumClasses);\n+    const uptr res = reinterpret_cast<uptr>(MmapAlignedOrDieOnFatalError(\n+        kRegionSize, kRegionSize, PrimaryAllocatorName));\n     if (UNLIKELY(!res))\n       return 0;\n     MapUnmapCallback().OnMap(res, kRegionSize);\n@@ -291,33 +290,66 @@ class SizeClassAllocator32 {\n   }\n \n   SizeClassInfo *GetSizeClassInfo(uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n+    DCHECK_LT(class_id, kNumClasses);\n     return &size_class_info_array[class_id];\n   }\n \n-  bool PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n-                        SizeClassInfo *sci, uptr class_id) {\n-    uptr size = ClassIdToSize(class_id);\n-    uptr reg = AllocateRegion(stat, class_id);\n-    if (UNLIKELY(!reg))\n-      return false;\n-    uptr n_chunks = kRegionSize / (size + kMetadataSize);\n-    uptr max_count = TransferBatch::MaxCached(class_id);\n-    CHECK_GT(max_count, 0);\n-    TransferBatch *b = nullptr;\n-    for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n+  bool PopulateBatches(AllocatorCache *c, SizeClassInfo *sci, uptr class_id,\n+                       TransferBatch **current_batch, uptr max_count,\n+                       uptr *pointers_array, uptr count) {\n+    // If using a separate class for batches, we do not need to shuffle it.\n+    if (kRandomShuffleChunks && (!kUseSeparateSizeClassForBatch ||\n+        class_id != SizeClassMap::kBatchClassID))\n+      RandomShuffle(pointers_array, count, &sci->rand_state);\n+    TransferBatch *b = *current_batch;\n+    for (uptr i = 0; i < count; i++) {\n       if (!b) {\n-        b = c->CreateBatch(class_id, this, (TransferBatch*)i);\n+        b = c->CreateBatch(class_id, this, (TransferBatch*)pointers_array[i]);\n         if (UNLIKELY(!b))\n           return false;\n         b->Clear();\n       }\n-      b->Add((void*)i);\n+      b->Add((void*)pointers_array[i]);\n       if (b->Count() == max_count) {\n         sci->free_list.push_back(b);\n         b = nullptr;\n       }\n     }\n+    *current_batch = b;\n+    return true;\n+  }\n+\n+  bool PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n+                        SizeClassInfo *sci, uptr class_id) {\n+    const uptr region = AllocateRegion(stat, class_id);\n+    if (UNLIKELY(!region))\n+      return false;\n+    if (kRandomShuffleChunks)\n+      if (UNLIKELY(sci->rand_state == 0))\n+        // The random state is initialized from ASLR (PIE) and time.\n+        sci->rand_state = reinterpret_cast<uptr>(sci) ^ NanoTime();\n+    const uptr size = ClassIdToSize(class_id);\n+    const uptr n_chunks = kRegionSize / (size + kMetadataSize);\n+    const uptr max_count = TransferBatch::MaxCached(size);\n+    DCHECK_GT(max_count, 0);\n+    TransferBatch *b = nullptr;\n+    constexpr uptr kShuffleArraySize = 48;\n+    uptr shuffle_array[kShuffleArraySize];\n+    uptr count = 0;\n+    for (uptr i = region; i < region + n_chunks * size; i += size) {\n+      shuffle_array[count++] = i;\n+      if (count == kShuffleArraySize) {\n+        if (UNLIKELY(!PopulateBatches(c, sci, class_id, &b, max_count,\n+                                      shuffle_array, count)))\n+          return false;\n+        count = 0;\n+      }\n+    }\n+    if (count) {\n+      if (UNLIKELY(!PopulateBatches(c, sci, class_id, &b, max_count,\n+                                    shuffle_array, count)))\n+        return false;\n+    }\n     if (b) {\n       CHECK_GT(b->Count(), 0);\n       sci->free_list.push_back(b);"}, {"sha": "119443b3ebe3348b55073f936dc9fee3803db486", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 114, "deletions": 83, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -70,15 +70,17 @@ class SizeClassAllocator64 {\n   void Init(s32 release_to_os_interval_ms) {\n     uptr TotalSpaceSize = kSpaceSize + AdditionalSize();\n     if (kUsingConstantSpaceBeg) {\n-      CHECK_EQ(kSpaceBeg, reinterpret_cast<uptr>(\n-                              MmapFixedNoAccess(kSpaceBeg, TotalSpaceSize)));\n+      CHECK_EQ(kSpaceBeg, address_range.Init(TotalSpaceSize,\n+                                             PrimaryAllocatorName, kSpaceBeg));\n     } else {\n-      NonConstSpaceBeg =\n-          reinterpret_cast<uptr>(MmapNoAccess(TotalSpaceSize));\n+      NonConstSpaceBeg = address_range.Init(TotalSpaceSize,\n+                                            PrimaryAllocatorName);\n       CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n     }\n     SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n     MapWithCallbackOrDie(SpaceEnd(), AdditionalSize());\n+    // Check that the RegionInfo array is aligned on the CacheLine size.\n+    DCHECK_EQ(SpaceEnd() % kCacheLineSize, 0);\n   }\n \n   s32 ReleaseToOSIntervalMs() const {\n@@ -90,6 +92,13 @@ class SizeClassAllocator64 {\n                  memory_order_relaxed);\n   }\n \n+  void ForceReleaseToOS() {\n+    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n+      BlockingMutexLock l(&GetRegionInfo(class_id)->mutex);\n+      MaybeReleaseToOS(class_id, true /*force*/);\n+    }\n+  }\n+\n   static bool CanAllocate(uptr size, uptr alignment) {\n     return size <= SizeClassMap::kMaxSize &&\n       alignment <= SizeClassMap::kMaxSize;\n@@ -107,14 +116,18 @@ class SizeClassAllocator64 {\n     // Failure to allocate free array space while releasing memory is non\n     // recoverable.\n     if (UNLIKELY(!EnsureFreeArraySpace(region, region_beg,\n-                                       new_num_freed_chunks)))\n-      DieOnFailure::OnOOM();\n+                                       new_num_freed_chunks))) {\n+      Report(\"FATAL: Internal error: %s's allocator exhausted the free list \"\n+             \"space for size class %zd (%zd bytes).\\n\", SanitizerToolName,\n+             class_id, ClassIdToSize(class_id));\n+      Die();\n+    }\n     for (uptr i = 0; i < n_chunks; i++)\n       free_array[old_num_chunks + i] = chunks[i];\n     region->num_freed_chunks = new_num_freed_chunks;\n     region->stats.n_freed += n_chunks;\n \n-    MaybeReleaseToOS(class_id);\n+    MaybeReleaseToOS(class_id, false /*force*/);\n   }\n \n   NOINLINE bool GetFromAllocator(AllocatorStats *stat, uptr class_id,\n@@ -232,22 +245,28 @@ class SizeClassAllocator64 {\n   }\n \n   void PrintStats() {\n+    uptr rss_stats[kNumClasses];\n+    for (uptr class_id = 0; class_id < kNumClasses; class_id++)\n+      rss_stats[class_id] = SpaceBeg() + kRegionSize * class_id;\n+    GetMemoryProfile(FillMemoryProfile, rss_stats, kNumClasses);\n+\n     uptr total_mapped = 0;\n+    uptr total_rss = 0;\n     uptr n_allocated = 0;\n     uptr n_freed = 0;\n     for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n       RegionInfo *region = GetRegionInfo(class_id);\n-      total_mapped += region->mapped_user;\n+      if (region->mapped_user != 0) {\n+        total_mapped += region->mapped_user;\n+        total_rss += rss_stats[class_id];\n+      }\n       n_allocated += region->stats.n_allocated;\n       n_freed += region->stats.n_freed;\n     }\n-    Printf(\"Stats: SizeClassAllocator64: %zdM mapped in %zd allocations; \"\n-           \"remains %zd\\n\",\n-           total_mapped >> 20, n_allocated, n_allocated - n_freed);\n-    uptr rss_stats[kNumClasses];\n-    for (uptr class_id = 0; class_id < kNumClasses; class_id++)\n-      rss_stats[class_id] = SpaceBeg() + kRegionSize * class_id;\n-    GetMemoryProfile(FillMemoryProfile, rss_stats, kNumClasses);\n+\n+    Printf(\"Stats: SizeClassAllocator64: %zdM mapped (%zdM rss) in \"\n+           \"%zd allocations; remains %zd\\n\", total_mapped >> 20,\n+           total_rss >> 20, n_allocated, n_allocated - n_freed);\n     for (uptr class_id = 1; class_id < kNumClasses; class_id++)\n       PrintStats(class_id, rss_stats[class_id]);\n   }\n@@ -529,6 +548,8 @@ class SizeClassAllocator64 {\n  private:\n   friend class MemoryMapper;\n \n+  ReservedAddressRange address_range;\n+\n   static const uptr kRegionSize = kSpaceSize / kNumClassesRounded;\n   // FreeArray is the array of free-d chunks (stored as 4-byte offsets).\n   // In the worst case it may reguire kRegionSize/SizeClassMap::kMinSize\n@@ -567,7 +588,7 @@ class SizeClassAllocator64 {\n     u64 last_released_bytes;\n   };\n \n-  struct RegionInfo {\n+  struct ALIGNED(SANITIZER_CACHE_LINE_SIZE) RegionInfo {\n     BlockingMutex mutex;\n     uptr num_freed_chunks;  // Number of elements in the freearray.\n     uptr mapped_free_array;  // Bytes mapped for freearray.\n@@ -580,24 +601,11 @@ class SizeClassAllocator64 {\n     Stats stats;\n     ReleaseToOsInfo rtoi;\n   };\n-  COMPILER_CHECK(sizeof(RegionInfo) >= kCacheLineSize);\n-\n-  u32 Rand(u32 *state) {  // ANSI C linear congruential PRNG.\n-    return (*state = *state * 1103515245 + 12345) >> 16;\n-  }\n-\n-  u32 RandN(u32 *state, u32 n) { return Rand(state) % n; }  // [0, n)\n-\n-  void RandomShuffle(u32 *a, u32 n, u32 *rand_state) {\n-    if (n <= 1) return;\n-    for (u32 i = n - 1; i > 0; i--)\n-      Swap(a[i], a[RandN(rand_state, i + 1)]);\n-  }\n+  COMPILER_CHECK(sizeof(RegionInfo) % kCacheLineSize == 0);\n \n   RegionInfo *GetRegionInfo(uptr class_id) const {\n-    CHECK_LT(class_id, kNumClasses);\n-    RegionInfo *regions =\n-        reinterpret_cast<RegionInfo *>(SpaceBeg() + kSpaceSize);\n+    DCHECK_LT(class_id, kNumClasses);\n+    RegionInfo *regions = reinterpret_cast<RegionInfo *>(SpaceEnd());\n     return &regions[class_id];\n   }\n \n@@ -622,7 +630,7 @@ class SizeClassAllocator64 {\n   }\n \n   bool MapWithCallback(uptr beg, uptr size) {\n-    uptr mapped = reinterpret_cast<uptr>(MmapFixedOrDieOnFatalError(beg, size));\n+    uptr mapped = address_range.Map(beg, size);\n     if (UNLIKELY(!mapped))\n       return false;\n     CHECK_EQ(beg, mapped);\n@@ -631,13 +639,13 @@ class SizeClassAllocator64 {\n   }\n \n   void MapWithCallbackOrDie(uptr beg, uptr size) {\n-    CHECK_EQ(beg, reinterpret_cast<uptr>(MmapFixedOrDie(beg, size)));\n+    CHECK_EQ(beg, address_range.MapOrDie(beg, size));\n     MapUnmapCallback().OnMap(beg, size);\n   }\n \n   void UnmapWithCallbackOrDie(uptr beg, uptr size) {\n     MapUnmapCallback().OnUnmap(beg, size);\n-    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n+    address_range.Unmap(beg, size);\n   }\n \n   bool EnsureFreeArraySpace(RegionInfo *region, uptr region_beg,\n@@ -656,55 +664,74 @@ class SizeClassAllocator64 {\n     return true;\n   }\n \n+  // Check whether this size class is exhausted.\n+  bool IsRegionExhausted(RegionInfo *region, uptr class_id,\n+                         uptr additional_map_size) {\n+    if (LIKELY(region->mapped_user + region->mapped_meta +\n+               additional_map_size <= kRegionSize - kFreeArraySize))\n+      return false;\n+    if (!region->exhausted) {\n+      region->exhausted = true;\n+      Printf(\"%s: Out of memory. \", SanitizerToolName);\n+      Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n+             kRegionSize >> 20, ClassIdToSize(class_id));\n+    }\n+    return true;\n+  }\n+\n   NOINLINE bool PopulateFreeArray(AllocatorStats *stat, uptr class_id,\n                                   RegionInfo *region, uptr requested_count) {\n     // region->mutex is held.\n-    const uptr size = ClassIdToSize(class_id);\n-    const uptr new_space_beg = region->allocated_user;\n-    const uptr new_space_end = new_space_beg + requested_count * size;\n     const uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+    const uptr size = ClassIdToSize(class_id);\n \n+    const uptr total_user_bytes =\n+        region->allocated_user + requested_count * size;\n     // Map more space for chunks, if necessary.\n-    if (new_space_end > region->mapped_user) {\n-      if (!kUsingConstantSpaceBeg && region->mapped_user == 0)\n-        region->rand_state = static_cast<u32>(region_beg >> 12);  // From ASLR.\n+    if (LIKELY(total_user_bytes > region->mapped_user)) {\n+      if (UNLIKELY(region->mapped_user == 0)) {\n+        if (!kUsingConstantSpaceBeg && kRandomShuffleChunks)\n+          // The random state is initialized from ASLR.\n+          region->rand_state = static_cast<u32>(region_beg >> 12);\n+        // Postpone the first release to OS attempt for ReleaseToOSIntervalMs,\n+        // preventing just allocated memory from being released sooner than\n+        // necessary and also preventing extraneous ReleaseMemoryPagesToOS calls\n+        // for short lived processes.\n+        // Do it only when the feature is turned on, to avoid a potentially\n+        // extraneous syscall.\n+        if (ReleaseToOSIntervalMs() >= 0)\n+          region->rtoi.last_release_at_ns = MonotonicNanoTime();\n+      }\n       // Do the mmap for the user memory.\n-      uptr map_size = kUserMapSize;\n-      while (new_space_end > region->mapped_user + map_size)\n-        map_size += kUserMapSize;\n-      CHECK_GE(region->mapped_user + map_size, new_space_end);\n+      const uptr user_map_size =\n+          RoundUpTo(total_user_bytes - region->mapped_user, kUserMapSize);\n+      if (UNLIKELY(IsRegionExhausted(region, class_id, user_map_size)))\n+        return false;\n       if (UNLIKELY(!MapWithCallback(region_beg + region->mapped_user,\n-                                    map_size)))\n+                                    user_map_size)))\n         return false;\n-      stat->Add(AllocatorStatMapped, map_size);\n-      region->mapped_user += map_size;\n-    }\n-    const uptr new_chunks_count = (region->mapped_user - new_space_beg) / size;\n-\n-    // Calculate the required space for metadata.\n-    const uptr requested_allocated_meta =\n-        region->allocated_meta + new_chunks_count * kMetadataSize;\n-    uptr requested_mapped_meta = region->mapped_meta;\n-    while (requested_allocated_meta > requested_mapped_meta)\n-      requested_mapped_meta += kMetaMapSize;\n-    // Check whether this size class is exhausted.\n-    if (region->mapped_user + requested_mapped_meta >\n-        kRegionSize - kFreeArraySize) {\n-      if (!region->exhausted) {\n-        region->exhausted = true;\n-        Printf(\"%s: Out of memory. \", SanitizerToolName);\n-        Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n-               kRegionSize >> 20, size);\n-      }\n-      return false;\n+      stat->Add(AllocatorStatMapped, user_map_size);\n+      region->mapped_user += user_map_size;\n     }\n-    // Map more space for metadata, if necessary.\n-    if (requested_mapped_meta > region->mapped_meta) {\n-      if (UNLIKELY(!MapWithCallback(\n-              GetMetadataEnd(region_beg) - requested_mapped_meta,\n-              requested_mapped_meta - region->mapped_meta)))\n-        return false;\n-      region->mapped_meta = requested_mapped_meta;\n+    const uptr new_chunks_count =\n+        (region->mapped_user - region->allocated_user) / size;\n+\n+    if (kMetadataSize) {\n+      // Calculate the required space for metadata.\n+      const uptr total_meta_bytes =\n+          region->allocated_meta + new_chunks_count * kMetadataSize;\n+      const uptr meta_map_size = (total_meta_bytes > region->mapped_meta) ?\n+          RoundUpTo(total_meta_bytes - region->mapped_meta, kMetaMapSize) : 0;\n+      // Map more space for metadata, if necessary.\n+      if (meta_map_size) {\n+        if (UNLIKELY(IsRegionExhausted(region, class_id, meta_map_size)))\n+          return false;\n+        if (UNLIKELY(!MapWithCallback(\n+            GetMetadataEnd(region_beg) - region->mapped_meta - meta_map_size,\n+            meta_map_size)))\n+          return false;\n+        region->mapped_meta += meta_map_size;\n+      }\n     }\n \n     // If necessary, allocate more space for the free array and populate it with\n@@ -713,7 +740,7 @@ class SizeClassAllocator64 {\n     if (UNLIKELY(!EnsureFreeArraySpace(region, region_beg, total_freed_chunks)))\n       return false;\n     CompactPtrT *free_array = GetFreeArray(region_beg);\n-    for (uptr i = 0, chunk = new_space_beg; i < new_chunks_count;\n+    for (uptr i = 0, chunk = region->allocated_user; i < new_chunks_count;\n          i++, chunk += size)\n       free_array[total_freed_chunks - 1 - i] = PointerToCompactPtr(0, chunk);\n     if (kRandomShuffleChunks)\n@@ -725,7 +752,7 @@ class SizeClassAllocator64 {\n     region->num_freed_chunks += new_chunks_count;\n     region->allocated_user += new_chunks_count * size;\n     CHECK_LE(region->allocated_user, region->mapped_user);\n-    region->allocated_meta = requested_allocated_meta;\n+    region->allocated_meta += new_chunks_count * kMetadataSize;\n     CHECK_LE(region->allocated_meta, region->mapped_meta);\n     region->exhausted = false;\n \n@@ -784,7 +811,7 @@ class SizeClassAllocator64 {\n \n   // Attempts to release RAM occupied by freed chunks back to OS. The region is\n   // expected to be locked.\n-  void MaybeReleaseToOS(uptr class_id) {\n+  void MaybeReleaseToOS(uptr class_id, bool force) {\n     RegionInfo *region = GetRegionInfo(class_id);\n     const uptr chunk_size = ClassIdToSize(class_id);\n     const uptr page_size = GetPageSizeCached();\n@@ -797,12 +824,16 @@ class SizeClassAllocator64 {\n       return;  // Nothing new to release.\n     }\n \n-    s32 interval_ms = ReleaseToOSIntervalMs();\n-    if (interval_ms < 0)\n-      return;\n+    if (!force) {\n+      s32 interval_ms = ReleaseToOSIntervalMs();\n+      if (interval_ms < 0)\n+        return;\n \n-    if (region->rtoi.last_release_at_ns + interval_ms * 1000000ULL > NanoTime())\n-      return;  // Memory was returned recently.\n+      if (region->rtoi.last_release_at_ns + interval_ms * 1000000ULL >\n+          MonotonicNanoTime()) {\n+        return;  // Memory was returned recently.\n+      }\n+    }\n \n     MemoryMapper memory_mapper(*this, class_id);\n \n@@ -816,6 +847,6 @@ class SizeClassAllocator64 {\n       region->rtoi.num_releases += memory_mapper.GetReleasedRangesCount();\n       region->rtoi.last_released_bytes = memory_mapper.GetReleasedBytes();\n     }\n-    region->rtoi.last_release_at_ns = NanoTime();\n+    region->rtoi.last_release_at_ns = MonotonicNanoTime();\n   }\n };"}, {"sha": "a09fb91e6b1b7cf00e181cb6cfc04933c39c39c0", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,123 @@\n+//===-- sanitizer_allocator_report.cc ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+///\n+/// \\file\n+/// Shared allocator error reporting for ThreadSanitizer, MemorySanitizer, etc.\n+///\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_allocator.h\"\n+#include \"sanitizer_allocator_report.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_report_decorator.h\"\n+\n+namespace __sanitizer {\n+\n+class ScopedAllocatorErrorReport {\n+ public:\n+  ScopedAllocatorErrorReport(const char *error_summary_,\n+                             const StackTrace *stack_)\n+      : error_summary(error_summary_),\n+        stack(stack_) {\n+    Printf(\"%s\", d.Error());\n+  }\n+  ~ScopedAllocatorErrorReport() {\n+    Printf(\"%s\", d.Default());\n+    stack->Print();\n+    PrintHintAllocatorCannotReturnNull();\n+    ReportErrorSummary(error_summary, stack);\n+  }\n+\n+ private:\n+  ScopedErrorReportLock lock;\n+  const char *error_summary;\n+  const StackTrace* const stack;\n+  const SanitizerCommonDecorator d;\n+};\n+\n+void NORETURN ReportCallocOverflow(uptr count, uptr size,\n+                                   const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"calloc-overflow\", stack);\n+    Report(\"ERROR: %s: calloc parameters overflow: count * size (%zd * %zd) \"\n+           \"cannot be represented in type size_t\\n\", SanitizerToolName, count,\n+           size);\n+  }\n+  Die();\n+}\n+\n+void NORETURN ReportPvallocOverflow(uptr size, const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"pvalloc-overflow\", stack);\n+    Report(\"ERROR: %s: pvalloc parameters overflow: size 0x%zx rounded up to \"\n+           \"system page size 0x%zx cannot be represented in type size_t\\n\",\n+           SanitizerToolName, size, GetPageSizeCached());\n+  }\n+  Die();\n+}\n+\n+void NORETURN ReportInvalidAllocationAlignment(uptr alignment,\n+                                               const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"invalid-allocation-alignment\", stack);\n+    Report(\"ERROR: %s: invalid allocation alignment: %zd, alignment must be a \"\n+           \"power of two\\n\", SanitizerToolName, alignment);\n+  }\n+  Die();\n+}\n+\n+void NORETURN ReportInvalidAlignedAllocAlignment(uptr size, uptr alignment,\n+                                                 const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"invalid-aligned-alloc-alignment\", stack);\n+#if SANITIZER_POSIX\n+    Report(\"ERROR: %s: invalid alignment requested in \"\n+           \"aligned_alloc: %zd, alignment must be a power of two and the \"\n+           \"requested size 0x%zx must be a multiple of alignment\\n\",\n+           SanitizerToolName, alignment, size);\n+#else\n+    Report(\"ERROR: %s: invalid alignment requested in aligned_alloc: %zd, \"\n+           \"the requested size 0x%zx must be a multiple of alignment\\n\",\n+           SanitizerToolName, alignment, size);\n+#endif\n+  }\n+  Die();\n+}\n+\n+void NORETURN ReportInvalidPosixMemalignAlignment(uptr alignment,\n+                                                  const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"invalid-posix-memalign-alignment\",\n+                                      stack);\n+    Report(\"ERROR: %s: invalid alignment requested in \"\n+           \"posix_memalign: %zd, alignment must be a power of two and a \"\n+           \"multiple of sizeof(void*) == %zd\\n\", SanitizerToolName, alignment,\n+           sizeof(void*));  // NOLINT\n+  }\n+  Die();\n+}\n+\n+void NORETURN ReportAllocationSizeTooBig(uptr user_size, uptr max_size,\n+                                         const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"allocation-size-too-big\", stack);\n+    Report(\"ERROR: %s: requested allocation size 0x%zx exceeds maximum \"\n+           \"supported size of 0x%zx\\n\", SanitizerToolName, user_size, max_size);\n+  }\n+  Die();\n+}\n+\n+void NORETURN ReportOutOfMemory(uptr requested_size, const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"out-of-memory\", stack);\n+    Report(\"ERROR: %s: allocator is out of memory trying to allocate 0x%zx \"\n+           \"bytes\\n\", SanitizerToolName, requested_size);\n+  }\n+  Die();\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "892f7ffb7f8f3a966f7b27965f5c68d89a556b52", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,36 @@\n+//===-- sanitizer_allocator_report.h ----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+///\n+/// \\file\n+/// Shared allocator error reporting for ThreadSanitizer, MemorySanitizer, etc.\n+///\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ALLOCATOR_REPORT_H\n+#define SANITIZER_ALLOCATOR_REPORT_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_stacktrace.h\"\n+\n+namespace __sanitizer {\n+\n+void NORETURN ReportCallocOverflow(uptr count, uptr size,\n+                                   const StackTrace *stack);\n+void NORETURN ReportPvallocOverflow(uptr size, const StackTrace *stack);\n+void NORETURN ReportInvalidAllocationAlignment(uptr alignment,\n+                                               const StackTrace *stack);\n+void NORETURN ReportInvalidAlignedAllocAlignment(uptr size, uptr alignment,\n+                                                 const StackTrace *stack);\n+void NORETURN ReportInvalidPosixMemalignAlignment(uptr alignment,\n+                                                  const StackTrace *stack);\n+void NORETURN ReportAllocationSizeTooBig(uptr user_size, uptr max_size,\n+                                         const StackTrace *stack);\n+void NORETURN ReportOutOfMemory(uptr requested_size, const StackTrace *stack);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ALLOCATOR_REPORT_H"}, {"sha": "1dbca60b823ca4bf5209892daf1069ffee71778a", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,17 +12,66 @@\n #error This file must be included inside sanitizer_allocator.h\n #endif\n \n+// Fixed array to store LargeMmapAllocator chunks list, limited to 32K total\n+// allocated chunks. To be used in memory constrained or not memory hungry cases\n+// (currently, 32 bits and internal allocator).\n+class LargeMmapAllocatorPtrArrayStatic {\n+ public:\n+  INLINE void *Init() { return &p_[0]; }\n+  INLINE void EnsureSpace(uptr n) { CHECK_LT(n, kMaxNumChunks); }\n+ private:\n+  static const int kMaxNumChunks = 1 << 15;\n+  uptr p_[kMaxNumChunks];\n+};\n+\n+// Much less restricted LargeMmapAllocator chunks list (comparing to\n+// PtrArrayStatic). Backed by mmaped memory region and can hold up to 1M chunks.\n+// ReservedAddressRange was used instead of just MAP_NORESERVE to achieve the\n+// same functionality in Fuchsia case, which does not support MAP_NORESERVE.\n+class LargeMmapAllocatorPtrArrayDynamic {\n+ public:\n+  INLINE void *Init() {\n+    uptr p = address_range_.Init(kMaxNumChunks * sizeof(uptr),\n+                                 SecondaryAllocatorName);\n+    CHECK(p);\n+    return reinterpret_cast<void*>(p);\n+  }\n+\n+  INLINE void EnsureSpace(uptr n) {\n+    CHECK_LT(n, kMaxNumChunks);\n+    DCHECK(n <= n_reserved_);\n+    if (UNLIKELY(n == n_reserved_)) {\n+      address_range_.MapOrDie(\n+          reinterpret_cast<uptr>(address_range_.base()) +\n+              n_reserved_ * sizeof(uptr),\n+          kChunksBlockCount * sizeof(uptr));\n+      n_reserved_ += kChunksBlockCount;\n+    }\n+  }\n+\n+ private:\n+  static const int kMaxNumChunks = 1 << 20;\n+  static const int kChunksBlockCount = 1 << 14;\n+  ReservedAddressRange address_range_;\n+  uptr n_reserved_;\n+};\n+\n+#if SANITIZER_WORDSIZE == 32\n+typedef LargeMmapAllocatorPtrArrayStatic DefaultLargeMmapAllocatorPtrArray;\n+#else\n+typedef LargeMmapAllocatorPtrArrayDynamic DefaultLargeMmapAllocatorPtrArray;\n+#endif\n+\n // This class can (de)allocate only large chunks of memory using mmap/unmap.\n // The main purpose of this allocator is to cover large and rare allocation\n // sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).\n template <class MapUnmapCallback = NoOpMapUnmapCallback,\n-          class FailureHandlerT = ReturnNullOrDieOnFailure>\n+          class PtrArrayT = DefaultLargeMmapAllocatorPtrArray>\n class LargeMmapAllocator {\n  public:\n-  typedef FailureHandlerT FailureHandler;\n-\n   void InitLinkerInitialized() {\n     page_size_ = GetPageSizeCached();\n+    chunks_ = reinterpret_cast<Header**>(ptr_array_.Init());\n   }\n \n   void Init() {\n@@ -36,12 +85,16 @@ class LargeMmapAllocator {\n     if (alignment > page_size_)\n       map_size += alignment;\n     // Overflow.\n-    if (map_size < size)\n-      return FailureHandler::OnBadRequest();\n+    if (map_size < size) {\n+      Report(\"WARNING: %s: LargeMmapAllocator allocation overflow: \"\n+             \"0x%zx bytes with 0x%zx alignment requested\\n\",\n+             SanitizerToolName, map_size, alignment);\n+      return nullptr;\n+    }\n     uptr map_beg = reinterpret_cast<uptr>(\n-        MmapOrDieOnFatalError(map_size, \"LargeMmapAllocator\"));\n+        MmapOrDieOnFatalError(map_size, SecondaryAllocatorName));\n     if (!map_beg)\n-      return FailureHandler::OnOOM();\n+      return nullptr;\n     CHECK(IsAligned(map_beg, page_size_));\n     MapUnmapCallback().OnMap(map_beg, map_size);\n     uptr map_end = map_beg + map_size;\n@@ -60,11 +113,11 @@ class LargeMmapAllocator {\n     CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));\n     {\n       SpinMutexLock l(&mutex_);\n+      ptr_array_.EnsureSpace(n_chunks_);\n       uptr idx = n_chunks_++;\n-      chunks_sorted_ = false;\n-      CHECK_LT(idx, kMaxNumChunks);\n       h->chunk_idx = idx;\n       chunks_[idx] = h;\n+      chunks_sorted_ = false;\n       stats.n_allocs++;\n       stats.currently_allocated += map_size;\n       stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);\n@@ -82,9 +135,8 @@ class LargeMmapAllocator {\n       uptr idx = h->chunk_idx;\n       CHECK_EQ(chunks_[idx], h);\n       CHECK_LT(idx, n_chunks_);\n-      chunks_[idx] = chunks_[n_chunks_ - 1];\n+      chunks_[idx] = chunks_[--n_chunks_];\n       chunks_[idx]->chunk_idx = idx;\n-      n_chunks_--;\n       chunks_sorted_ = false;\n       stats.n_frees++;\n       stats.currently_allocated -= h->map_size;\n@@ -148,7 +200,7 @@ class LargeMmapAllocator {\n \n   void EnsureSortedChunks() {\n     if (chunks_sorted_) return;\n-    SortArray(reinterpret_cast<uptr*>(chunks_), n_chunks_);\n+    Sort(reinterpret_cast<uptr *>(chunks_), n_chunks_);\n     for (uptr i = 0; i < n_chunks_; i++)\n       chunks_[i]->chunk_idx = i;\n     chunks_sorted_ = true;\n@@ -220,15 +272,14 @@ class LargeMmapAllocator {\n     EnsureSortedChunks();  // Avoid doing the sort while iterating.\n     for (uptr i = 0; i < n_chunks_; i++) {\n       auto t = chunks_[i];\n-      callback(reinterpret_cast<uptr>(GetUser(chunks_[i])), arg);\n+      callback(reinterpret_cast<uptr>(GetUser(t)), arg);\n       // Consistency check: verify that the array did not change.\n       CHECK_EQ(chunks_[i], t);\n       CHECK_EQ(chunks_[i]->chunk_idx, i);\n     }\n   }\n \n  private:\n-  static const int kMaxNumChunks = 1 << FIRST_32_SECOND_64(15, 18);\n   struct Header {\n     uptr map_beg;\n     uptr map_size;\n@@ -254,11 +305,12 @@ class LargeMmapAllocator {\n   }\n \n   uptr page_size_;\n-  Header *chunks_[kMaxNumChunks];\n+  Header **chunks_;\n+  PtrArrayT ptr_array_;\n   uptr n_chunks_;\n   bool chunks_sorted_;\n   struct Stats {\n     uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n   } stats;\n-  SpinMutex mutex_;\n+  StaticSpinMutex mutex_;\n };"}, {"sha": "cfe6299fdeca93ee8da2c9bc6fb1f52944f00851", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_size_class_map.h", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -159,23 +159,24 @@ class SizeClassMap {\n       return 0;\n     if (size <= kMidSize)\n       return (size + kMinSize - 1) >> kMinSizeLog;\n-    uptr l = MostSignificantSetBitIndex(size);\n-    uptr hbits = (size >> (l - S)) & M;\n-    uptr lbits = size & ((1 << (l - S)) - 1);\n-    uptr l1 = l - kMidSizeLog;\n+    const uptr l = MostSignificantSetBitIndex(size);\n+    const uptr hbits = (size >> (l - S)) & M;\n+    const uptr lbits = size & ((1U << (l - S)) - 1);\n+    const uptr l1 = l - kMidSizeLog;\n     return kMidClass + (l1 << S) + hbits + (lbits > 0);\n   }\n \n-  static uptr MaxCachedHint(uptr class_id) {\n-    // Estimate the result for kBatchClassID because this class does not know\n-    // the exact size of TransferBatch. We need to cache fewer batches than user\n-    // chunks, so this number can be small.\n-    if (UNLIKELY(class_id == kBatchClassID))\n-      return 16;\n-    if (UNLIKELY(class_id == 0))\n+  static uptr MaxCachedHint(uptr size) {\n+    DCHECK_LE(size, kMaxSize);\n+    if (UNLIKELY(size == 0))\n       return 0;\n-    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);\n-    return Max<uptr>(1, Min(kMaxNumCachedHint, n));\n+    uptr n;\n+    // Force a 32-bit division if the template parameters allow for it.\n+    if (kMaxBytesCachedLog > 31 || kMaxSizeLog > 31)\n+      n = (1UL << kMaxBytesCachedLog) / size;\n+    else\n+      n = (1U << kMaxBytesCachedLog) / static_cast<u32>(size);\n+    return Max<uptr>(1U, Min(kMaxNumCachedHint, n));\n   }\n \n   static void Print() {\n@@ -188,12 +189,12 @@ class SizeClassMap {\n       uptr d = s - prev_s;\n       uptr p = prev_s ? (d * 100 / prev_s) : 0;\n       uptr l = s ? MostSignificantSetBitIndex(s) : 0;\n-      uptr cached = MaxCachedHint(i) * s;\n+      uptr cached = MaxCachedHint(s) * s;\n       if (i == kBatchClassID)\n         d = p = l = 0;\n       Printf(\"c%02zd => s: %zd diff: +%zd %02zd%% l %zd \"\n              \"cached: %zd %zd; id %zd\\n\",\n-             i, Size(i), d, p, l, MaxCachedHint(i), cached, ClassID(s));\n+             i, Size(i), d, p, l, MaxCachedHint(s), cached, ClassID(s));\n       total_cached += cached;\n       prev_s = s;\n     }\n@@ -229,3 +230,8 @@ class SizeClassMap {\n typedef SizeClassMap<3, 4, 8, 17, 128, 16> DefaultSizeClassMap;\n typedef SizeClassMap<3, 4, 8, 17, 64, 14> CompactSizeClassMap;\n typedef SizeClassMap<2, 5, 9, 16, 64, 14> VeryCompactSizeClassMap;\n+\n+// The following SizeClassMap only holds a way small number of cached entries,\n+// allowing for denser per-class arrays, smaller memory footprint and usually\n+// better performances in threaded environments.\n+typedef SizeClassMap<3, 4, 8, 17, 8, 10> DenseSizeClassMap;"}, {"sha": "93360919fee4bff2250795c9a4cac0f6cf69d341", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_stats.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -99,5 +99,5 @@ class AllocatorGlobalStats : public AllocatorStats {\n   }\n \n  private:\n-  mutable SpinMutex mu_;\n+  mutable StaticSpinMutex mu_;\n };"}, {"sha": "4c75b4132686844f95e68e5d5cc447d31aa0c857", "filename": "libsanitizer/sanitizer_common/sanitizer_asm.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -45,12 +45,12 @@\n # define ASM_HIDDEN(symbol) .hidden symbol\n # define ASM_TYPE_FUNCTION(symbol) .type symbol, @function\n # define ASM_SIZE(symbol) .size symbol, .-symbol\n-# define ASM_TSAN_SYMBOL(symbol) symbol\n-# define ASM_TSAN_SYMBOL_INTERCEPTOR(symbol) symbol\n+# define ASM_SYMBOL(symbol) symbol\n+# define ASM_SYMBOL_INTERCEPTOR(symbol) symbol\n #else\n # define ASM_HIDDEN(symbol)\n # define ASM_TYPE_FUNCTION(symbol)\n # define ASM_SIZE(symbol)\n-# define ASM_TSAN_SYMBOL(symbol) _##symbol\n-# define ASM_TSAN_SYMBOL_INTERCEPTOR(symbol) _wrap_##symbol\n+# define ASM_SYMBOL(symbol) _##symbol\n+# define ASM_SYMBOL_INTERCEPTOR(symbol) _wrap_##symbol\n #endif"}, {"sha": "89fb748e758de0691a5466e019726021a2d16147", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -76,17 +76,7 @@ INLINE bool atomic_compare_exchange_strong(volatile T *a, typename T::Type *cmp,\n   typedef typename T::Type Type;\n   Type cmpv = *cmp;\n   Type prev;\n-#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n-  if (sizeof(*a) == 8) {\n-    Type volatile *val_ptr = const_cast<Type volatile *>(&a->val_dont_use);\n-    prev = __mips_sync_val_compare_and_swap<u64>(\n-        reinterpret_cast<u64 volatile *>(val_ptr), (u64)cmpv, (u64)xchg);\n-  } else {\n-    prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n-  }\n-#else\n   prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n-#endif\n   if (prev == cmpv) return true;\n   *cmp = prev;\n   return false;\n@@ -102,6 +92,13 @@ INLINE bool atomic_compare_exchange_weak(volatile T *a,\n \n }  // namespace __sanitizer\n \n+// This include provides explicit template instantiations for atomic_uint64_t\n+// on MIPS32, which does not directly support 8 byte atomics. It has to\n+// proceed the template definitions above.\n+#if defined(_MIPS_SIM) && defined(_ABIO32)\n+  #include \"sanitizer_atomic_clang_mips.h\"\n+#endif\n+\n #undef ATOMIC_ORDER\n \n #endif  // SANITIZER_ATOMIC_CLANG_H"}, {"sha": "41e58dcae4db101ff312b2151a602588954dcc78", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_mips.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,115 @@\n+//===-- sanitizer_atomic_clang_mips.h ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n+// Not intended for direct inclusion. Include sanitizer_atomic.h.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ATOMIC_CLANG_MIPS_H\n+#define SANITIZER_ATOMIC_CLANG_MIPS_H\n+\n+namespace __sanitizer {\n+\n+// MIPS32 does not support atomics > 4 bytes. To address this lack of\n+// functionality, the sanitizer library provides helper methods which use an\n+// internal spin lock mechanism to emulate atomic oprations when the size is\n+// 8 bytes.\n+static void __spin_lock(volatile int *lock) {\n+  while (__sync_lock_test_and_set(lock, 1))\n+    while (*lock) {\n+    }\n+}\n+\n+static void __spin_unlock(volatile int *lock) { __sync_lock_release(lock); }\n+\n+// Make sure the lock is on its own cache line to prevent false sharing.\n+// Put it inside a struct that is aligned and padded to the typical MIPS\n+// cacheline which is 32 bytes.\n+static struct {\n+  int lock;\n+  char pad[32 - sizeof(int)];\n+} __attribute__((aligned(32))) lock = {0, {0}};\n+\n+template <>\n+INLINE atomic_uint64_t::Type atomic_fetch_add(volatile atomic_uint64_t *ptr,\n+                                              atomic_uint64_t::Type val,\n+                                              memory_order mo) {\n+  DCHECK(mo &\n+         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+  DCHECK(!((uptr)ptr % sizeof(*ptr)));\n+\n+  atomic_uint64_t::Type ret;\n+\n+  __spin_lock(&lock.lock);\n+  ret = *(const_cast<atomic_uint64_t::Type volatile *>(&ptr->val_dont_use));\n+  ptr->val_dont_use = ret + val;\n+  __spin_unlock(&lock.lock);\n+\n+  return ret;\n+}\n+\n+template <>\n+INLINE atomic_uint64_t::Type atomic_fetch_sub(volatile atomic_uint64_t *ptr,\n+                                              atomic_uint64_t::Type val,\n+                                              memory_order mo) {\n+  return atomic_fetch_add(ptr, -val, mo);\n+}\n+\n+template <>\n+INLINE bool atomic_compare_exchange_strong(volatile atomic_uint64_t *ptr,\n+                                           atomic_uint64_t::Type *cmp,\n+                                           atomic_uint64_t::Type xchg,\n+                                           memory_order mo) {\n+  DCHECK(mo &\n+         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+  DCHECK(!((uptr)ptr % sizeof(*ptr)));\n+\n+  typedef atomic_uint64_t::Type Type;\n+  Type cmpv = *cmp;\n+  Type prev;\n+  bool ret = false;\n+\n+  __spin_lock(&lock.lock);\n+  prev = *(const_cast<Type volatile *>(&ptr->val_dont_use));\n+  if (prev == cmpv) {\n+    ret = true;\n+    ptr->val_dont_use = xchg;\n+  }\n+  __spin_unlock(&lock.lock);\n+\n+  return ret;\n+}\n+\n+template <>\n+INLINE atomic_uint64_t::Type atomic_load(const volatile atomic_uint64_t *ptr,\n+                                         memory_order mo) {\n+  DCHECK(mo &\n+         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+  DCHECK(!((uptr)ptr % sizeof(*ptr)));\n+\n+  atomic_uint64_t::Type zero = 0;\n+  volatile atomic_uint64_t *Newptr =\n+      const_cast<volatile atomic_uint64_t *>(ptr);\n+  return atomic_fetch_add(Newptr, zero, mo);\n+}\n+\n+template <>\n+INLINE void atomic_store(volatile atomic_uint64_t *ptr, atomic_uint64_t::Type v,\n+                         memory_order mo) {\n+  DCHECK(mo &\n+         (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n+  DCHECK(!((uptr)ptr % sizeof(*ptr)));\n+\n+  __spin_lock(&lock.lock);\n+  ptr->val_dont_use = v;\n+  __spin_unlock(&lock.lock);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ATOMIC_CLANG_MIPS_H"}, {"sha": "b11efccc91b19df5ebbc6063728a7b695f1f7090", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_other.h", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -15,55 +15,6 @@\n \n namespace __sanitizer {\n \n-// MIPS32 does not support atomic > 4 bytes. To address this lack of\n-// functionality, the sanitizer library provides helper methods which use an\n-// internal spin lock mechanism to emulate atomic oprations when the size is\n-// 8 bytes.\n-#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n-static void __spin_lock(volatile int *lock) {\n-  while (__sync_lock_test_and_set(lock, 1))\n-    while (*lock) {\n-    }\n-}\n-\n-static void __spin_unlock(volatile int *lock) { __sync_lock_release(lock); }\n-\n-\n-// Make sure the lock is on its own cache line to prevent false sharing.\n-// Put it inside a struct that is aligned and padded to the typical MIPS\n-// cacheline which is 32 bytes.\n-static struct {\n-  int lock;\n-  char pad[32 - sizeof(int)];\n-} __attribute__((aligned(32))) lock = {0, {0}};\n-\n-template <class T>\n-T __mips_sync_fetch_and_add(volatile T *ptr, T val) {\n-  T ret;\n-\n-  __spin_lock(&lock.lock);\n-\n-  ret = *ptr;\n-  *ptr = ret + val;\n-\n-  __spin_unlock(&lock.lock);\n-\n-  return ret;\n-}\n-\n-template <class T>\n-T __mips_sync_val_compare_and_swap(volatile T *ptr, T oldval, T newval) {\n-  T ret;\n-  __spin_lock(&lock.lock);\n-\n-  ret = *ptr;\n-  if (ret == oldval) *ptr = newval;\n-\n-  __spin_unlock(&lock.lock);\n-\n-  return ret;\n-}\n-#endif\n \n INLINE void proc_yield(int cnt) {\n   __asm__ __volatile__(\"\" ::: \"memory\");\n@@ -101,15 +52,8 @@ INLINE typename T::Type atomic_load(\n     // 64-bit load on 32-bit platform.\n     // Gross, but simple and reliable.\n     // Assume that it is not in read-only memory.\n-#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n-    typename T::Type volatile *val_ptr =\n-        const_cast<typename T::Type volatile *>(&a->val_dont_use);\n-    v = __mips_sync_fetch_and_add<u64>(\n-        reinterpret_cast<u64 volatile *>(val_ptr), 0);\n-#else\n     v = __sync_fetch_and_add(\n         const_cast<typename T::Type volatile *>(&a->val_dont_use), 0);\n-#endif\n   }\n   return v;\n }\n@@ -139,15 +83,8 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n     typename T::Type cmp = a->val_dont_use;\n     typename T::Type cur;\n     for (;;) {\n-#if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n-      typename T::Type volatile *val_ptr =\n-          const_cast<typename T::Type volatile *>(&a->val_dont_use);\n-      cur = __mips_sync_val_compare_and_swap<u64>(\n-          reinterpret_cast<u64 volatile *>(val_ptr), (u64)cmp, (u64)v);\n-#else\n       cur = __sync_val_compare_and_swap(&a->val_dont_use, cmp, v);\n-#endif\n-      if (cmp == v)\n+      if (cur == cmp || cur == v)\n         break;\n       cmp = cur;\n     }"}, {"sha": "aab9935676fcb9443db223804dd7879d007c303c", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_x86.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -59,8 +59,7 @@ INLINE typename T::Type atomic_load(\n         \"emms;\"            // Empty mmx state/Reset FP regs\n         : \"=m\" (v)\n         : \"m\" (a->val_dont_use)\n-        : // mark the FP stack and mmx registers as clobbered\n-          \"st\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\",\n+        : // mark the mmx registers as clobbered\n #ifdef __MMX__\n           \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\n #endif  // #ifdef __MMX__\n@@ -98,8 +97,7 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n         \"emms;\"            // Empty mmx state/Reset FP regs\n         : \"=m\" (a->val_dont_use)\n         : \"m\" (v)\n-        : // mark the FP stack and mmx registers as clobbered\n-          \"st\", \"st(1)\", \"st(2)\", \"st(3)\", \"st(4)\", \"st(5)\", \"st(6)\", \"st(7)\",\n+        : // mark the mmx registers as clobbered\n #ifdef __MMX__\n           \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\n #endif  // #ifdef __MMX__"}, {"sha": "6ecac8188453a69d0f61cf665abc2e766302b035", "filename": "libsanitizer/sanitizer_common/sanitizer_bitvector.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -20,7 +20,7 @@ namespace __sanitizer {\n template <class basic_int_t = uptr>\n class BasicBitVector {\n  public:\n-  enum SizeEnum { kSize = sizeof(basic_int_t) * 8 };\n+  enum SizeEnum : uptr { kSize = sizeof(basic_int_t) * 8 };\n \n   uptr size() const { return kSize; }\n   // No CTOR.\n@@ -113,7 +113,7 @@ class TwoLevelBitVector {\n   // This structure allows O(kLevel1Size) time for clear() and empty(),\n   // as well fast handling of sparse BVs.\n  public:\n-  enum SizeEnum { kSize = BV::kSize * BV::kSize * kLevel1Size };\n+  enum SizeEnum : uptr { kSize = BV::kSize * BV::kSize * kLevel1Size };\n   // No CTOR.\n \n   uptr size() const { return kSize; }"}, {"sha": "a7f76bf585f8c095611de13d01a437068b2e169a", "filename": "libsanitizer/sanitizer_common/sanitizer_bvgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -23,7 +23,7 @@ namespace __sanitizer {\n template<class BV>\n class BVGraph {\n  public:\n-  enum SizeEnum { kSize = BV::kSize };\n+  enum SizeEnum : uptr { kSize = BV::kSize };\n   uptr size() const { return kSize; }\n   // No CTOR.\n   void clear() {"}, {"sha": "7f0f47c005dc3f175eb635bdfd971fc47828ae42", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,18 +12,18 @@\n #include \"sanitizer_common.h\"\n #include \"sanitizer_allocator_interface.h\"\n #include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_placement_new.h\"\n-#include \"sanitizer_stacktrace_printer.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n const char *SanitizerToolName = \"SanitizerTool\";\n \n atomic_uint32_t current_verbosity;\n uptr PageSizeCached;\n+u32 NumberOfCPUsCached;\n \n // PID of the tracer task in StopTheWorld. It shares the address space with the\n // main process, but has a different PID and thus requires special handling.\n@@ -32,15 +32,14 @@ uptr stoptheworld_tracer_pid = 0;\n // writing to the same log file.\n uptr stoptheworld_tracer_ppid = 0;\n \n-StaticSpinMutex CommonSanitizerReportMutex;\n-\n void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                       const char *mmap_type, error_t err,\n                                       bool raw_report) {\n   static int recursion_count;\n-  if (raw_report || recursion_count) {\n-    // If raw report is requested or we went into recursion, just die.\n-    // The Report() and CHECK calls below may call mmap recursively and fail.\n+  if (SANITIZER_RTEMS || raw_report || recursion_count) {\n+    // If we are on RTEMS or raw report is requested or we went into recursion,\n+    // just die.  The Report() and CHECK calls below may call mmap recursively\n+    // and fail.\n     RawWrite(\"ERROR: Failed to mmap\\n\");\n     Die();\n   }\n@@ -57,19 +56,6 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);\n typedef bool U32ComparisonFunction(const u32 &a, const u32 &b);\n \n-template<class T>\n-static inline bool CompareLess(const T &a, const T &b) {\n-  return a < b;\n-}\n-\n-void SortArray(uptr *array, uptr size) {\n-  InternalSort<uptr*, UptrComparisonFunction>(&array, size, CompareLess);\n-}\n-\n-void SortArray(u32 *array, uptr size) {\n-  InternalSort<u32*, U32ComparisonFunction>(&array, size, CompareLess);\n-}\n-\n const char *StripPathPrefix(const char *filepath,\n                             const char *strip_path_prefix) {\n   if (!filepath) return nullptr;\n@@ -106,18 +92,6 @@ void ReportErrorSummary(const char *error_message, const char *alt_tool_name) {\n   __sanitizer_report_error_summary(buff.data());\n }\n \n-#if !SANITIZER_GO\n-void ReportErrorSummary(const char *error_type, const AddressInfo &info,\n-                        const char *alt_tool_name) {\n-  if (!common_flags()->print_summary) return;\n-  InternalScopedString buff(kMaxSummaryLength);\n-  buff.append(\"%s \", error_type);\n-  RenderFrame(&buff, \"%L %F\", 0, info, common_flags()->symbolize_vs_style,\n-              common_flags()->strip_path_prefix);\n-  ReportErrorSummary(buff.data(), alt_tool_name);\n-}\n-#endif\n-\n // Removes the ANSI escape sequences from the input string (in-place).\n void RemoveANSIEscapeSequencesFromString(char *str) {\n   if (!str)\n@@ -357,8 +331,9 @@ SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_report_error_summary,\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_set_death_callback(void (*callback)(void)) {\n-  SetUserDieCallback(callback);\n+int __sanitizer_acquire_crash_state() {\n+  static atomic_uint8_t in_crash_state = {};\n+  return !atomic_exchange(&in_crash_state, 1, memory_order_relaxed);\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "603d922b9693aa3c5bd778858c17ba142120fe13", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 140, "deletions": 108, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -37,11 +37,7 @@ struct StackTrace;\n const uptr kWordSize = SANITIZER_WORDSIZE / 8;\n const uptr kWordSizeInBits = 8 * kWordSize;\n \n-#if defined(__powerpc__) || defined(__powerpc64__)\n-  const uptr kCacheLineSize = 128;\n-#else\n-  const uptr kCacheLineSize = 64;\n-#endif\n+const uptr kCacheLineSize = SANITIZER_CACHE_LINE_SIZE;\n \n const uptr kMaxPathLength = 4096;\n \n@@ -50,7 +46,7 @@ const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n static const uptr kErrorMessageBufferSize = 1 << 16;\n \n // Denotes fake PC values that come from JIT/JAVA/etc.\n-// For such PC values __tsan_symbolize_external() will be called.\n+// For such PC values __tsan_symbolize_external_ex() will be called.\n const u64 kExternalPCBit = 1ULL << 60;\n \n extern const char *SanitizerToolName;  // Can be changed by the tool.\n@@ -72,8 +68,10 @@ INLINE uptr GetPageSizeCached() {\n }\n uptr GetMmapGranularity();\n uptr GetMaxVirtualAddress();\n+uptr GetMaxUserVirtualAddress();\n // Threads\n tid_t GetTid();\n+int TgKill(pid_t pid, tid_t tid, int sig);\n uptr GetThreadSelf();\n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                 uptr *stack_bottom);\n@@ -89,8 +87,8 @@ void UnmapOrDie(void *addr, uptr size);\n // Behaves just like MmapOrDie, but tolerates out of memory condition, in that\n // case returns nullptr.\n void *MmapOrDieOnFatalError(uptr size, const char *mem_type);\n-void *MmapFixedNoReserve(uptr fixed_addr, uptr size,\n-                         const char *name = nullptr);\n+bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name = nullptr)\n+     WARN_UNUSED_RESULT;\n void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n void *MmapFixedOrDie(uptr fixed_addr, uptr size);\n // Behaves just like MmapFixedOrDie, but tolerates out of memory condition, in\n@@ -107,9 +105,11 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n bool MprotectNoAccess(uptr addr, uptr size);\n bool MprotectReadOnly(uptr addr, uptr size);\n \n+void MprotectMallocZones(void *addr, int prot);\n+\n // Find an available address space.\n uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n-                              uptr *largest_gap_found);\n+                              uptr *largest_gap_found, uptr *max_occupied_addr);\n \n // Used to check if we can map shadow memory to a fixed location.\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n@@ -119,13 +119,29 @@ void ReleaseMemoryPagesToOS(uptr beg, uptr end);\n void IncreaseTotalMmap(uptr size);\n void DecreaseTotalMmap(uptr size);\n uptr GetRSS();\n-void NoHugePagesInRegion(uptr addr, uptr length);\n-void DontDumpShadowMemory(uptr addr, uptr length);\n+bool NoHugePagesInRegion(uptr addr, uptr length);\n+bool DontDumpShadowMemory(uptr addr, uptr length);\n // Check if the built VMA size matches the runtime one.\n void CheckVMASize();\n void RunMallocHooks(const void *ptr, uptr size);\n void RunFreeHooks(const void *ptr);\n \n+class ReservedAddressRange {\n+ public:\n+  uptr Init(uptr size, const char *name = nullptr, uptr fixed_addr = 0);\n+  uptr Map(uptr fixed_addr, uptr size);\n+  uptr MapOrDie(uptr fixed_addr, uptr size);\n+  void Unmap(uptr addr, uptr size);\n+  void *base() const { return base_; }\n+  uptr size() const { return size_; }\n+\n+ private:\n+  void* base_;\n+  uptr size_;\n+  const char* name_;\n+  uptr os_handle_;\n+};\n+\n typedef void (*fill_profile_f)(uptr start, uptr rss, bool file,\n                                /*out*/uptr *stats, uptr stats_size);\n \n@@ -134,49 +150,6 @@ typedef void (*fill_profile_f)(uptr start, uptr rss, bool file,\n // |stats_size| elements.\n void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size);\n \n-// InternalScopedBuffer can be used instead of large stack arrays to\n-// keep frame size low.\n-// FIXME: use InternalAlloc instead of MmapOrDie once\n-// InternalAlloc is made libc-free.\n-template <typename T>\n-class InternalScopedBuffer {\n- public:\n-  explicit InternalScopedBuffer(uptr cnt) {\n-    cnt_ = cnt;\n-    ptr_ = (T *)MmapOrDie(cnt * sizeof(T), \"InternalScopedBuffer\");\n-  }\n-  ~InternalScopedBuffer() { UnmapOrDie(ptr_, cnt_ * sizeof(T)); }\n-  T &operator[](uptr i) { return ptr_[i]; }\n-  T *data() { return ptr_; }\n-  uptr size() { return cnt_ * sizeof(T); }\n-\n- private:\n-  T *ptr_;\n-  uptr cnt_;\n-  // Disallow copies and moves.\n-  InternalScopedBuffer(const InternalScopedBuffer &) = delete;\n-  InternalScopedBuffer &operator=(const InternalScopedBuffer &) = delete;\n-  InternalScopedBuffer(InternalScopedBuffer &&) = delete;\n-  InternalScopedBuffer &operator=(InternalScopedBuffer &&) = delete;\n-};\n-\n-class InternalScopedString : public InternalScopedBuffer<char> {\n- public:\n-  explicit InternalScopedString(uptr max_length)\n-      : InternalScopedBuffer<char>(max_length), length_(0) {\n-    (*this)[0] = '\\0';\n-  }\n-  uptr length() { return length_; }\n-  void clear() {\n-    (*this)[0] = '\\0';\n-    length_ = 0;\n-  }\n-  void append(const char *format, ...);\n-\n- private:\n-  uptr length_;\n-};\n-\n // Simple low-level (mmap-based) allocator for internal use. Doesn't have\n // constructor, so all instances of LowLevelAllocator should be\n // linker initialized.\n@@ -188,6 +161,8 @@ class LowLevelAllocator {\n   char *allocated_end_;\n   char *allocated_current_;\n };\n+// Set the min alignment of LowLevelAllocator to at least alignment.\n+void SetLowLevelAllocateMinAlignment(uptr alignment);\n typedef void (*LowLevelAllocateCallback)(uptr ptr, uptr size);\n // Allows to register tool-specific callbacks for LowLevelAllocator.\n // Passing NULL removes the callback.\n@@ -210,10 +185,6 @@ void SetPrintfAndReportCallback(void (*callback)(const char *));\n     if ((uptr)Verbosity() >= (level)) Printf(__VA_ARGS__); \\\n   } while (0)\n \n-// Can be used to prevent mixing error reports from different sanitizers.\n-// FIXME: Replace with ScopedErrorReportLock and hide.\n-extern StaticSpinMutex CommonSanitizerReportMutex;\n-\n // Lock sanitizer error reporting and protects against nested errors.\n class ScopedErrorReportLock {\n  public:\n@@ -226,15 +197,6 @@ class ScopedErrorReportLock {\n extern uptr stoptheworld_tracer_pid;\n extern uptr stoptheworld_tracer_ppid;\n \n-// Opens the file 'file_name\" and reads up to 'max_len' bytes.\n-// The resulting buffer is mmaped and stored in '*buff'.\n-// The size of the mmaped region is stored in '*buff_size'.\n-// The total number of read bytes is stored in '*read_len'.\n-// Returns true if file was successfully opened and read.\n-bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n-                      uptr *read_len, uptr max_len = 1 << 26,\n-                      error_t *errno_p = nullptr);\n-\n bool IsAccessibleMemoryRange(uptr beg, uptr size);\n \n // Error report formatting.\n@@ -258,6 +220,7 @@ bool SetEnv(const char *name, const char *value);\n \n u32 GetUid();\n void ReExec();\n+void CheckASLR();\n char **GetArgv();\n void PrintCmdline();\n bool StackSizeIsUnlimited();\n@@ -266,7 +229,7 @@ void SetStackSizeLimitInBytes(uptr limit);\n bool AddressSpaceIsUnlimited();\n void SetAddressSpaceUnlimited();\n void AdjustStackSize(void *attr);\n-void PrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n+void PlatformPrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n void SetSandboxingCallback(void (*f)());\n \n void InitializeCoverage(bool enabled, const char *coverage_dir);\n@@ -278,9 +241,8 @@ uptr GetTlsSize();\n void SleepForSeconds(int seconds);\n void SleepForMillis(int millis);\n u64 NanoTime();\n+u64 MonotonicNanoTime();\n int Atexit(void (*function)(void));\n-void SortArray(uptr *array, uptr size);\n-void SortArray(u32 *array, uptr size);\n bool TemplateMatch(const char *templ, const char *str);\n \n // Exit\n@@ -292,13 +254,6 @@ void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                       const char *mmap_type, error_t err,\n                                       bool raw_report = false);\n \n-// Set the name of the current thread to 'name', return true on succees.\n-// The name may be truncated to a system-dependent limit.\n-bool SanitizerSetThreadName(const char *name);\n-// Get the name of the current thread (no more than max_len bytes),\n-// return true on succees. name should have space for at least max_len+1 bytes.\n-bool SanitizerGetThreadName(char *name, int max_len);\n-\n // Specific tools may override behavior of \"Die\" and \"CheckFailed\" functions\n // to do tool-specific job.\n typedef void (*DieCallbackType)(void);\n@@ -364,6 +319,8 @@ void ReportErrorSummary(const char *error_type, const AddressInfo &info,\n void ReportErrorSummary(const char *error_type, const StackTrace *trace,\n                         const char *alt_tool_name = nullptr);\n \n+void ReportMmapWriteExec(int prot);\n+\n // Math\n #if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\n extern \"C\" {\n@@ -471,13 +428,12 @@ template<typename T>\n class InternalMmapVectorNoCtor {\n  public:\n   void Initialize(uptr initial_capacity) {\n-    capacity_ = Max(initial_capacity, (uptr)1);\n+    capacity_bytes_ = 0;\n     size_ = 0;\n-    data_ = (T *)MmapOrDie(capacity_ * sizeof(T), \"InternalMmapVectorNoCtor\");\n-  }\n-  void Destroy() {\n-    UnmapOrDie(data_, capacity_ * sizeof(T));\n+    data_ = 0;\n+    reserve(initial_capacity);\n   }\n+  void Destroy() { UnmapOrDie(data_, capacity_bytes_); }\n   T &operator[](uptr i) {\n     CHECK_LT(i, size_);\n     return data_[i];\n@@ -487,10 +443,10 @@ class InternalMmapVectorNoCtor {\n     return data_[i];\n   }\n   void push_back(const T &element) {\n-    CHECK_LE(size_, capacity_);\n-    if (size_ == capacity_) {\n+    CHECK_LE(size_, capacity());\n+    if (size_ == capacity()) {\n       uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);\n-      Resize(new_capacity);\n+      Realloc(new_capacity);\n     }\n     internal_memcpy(&data_[size_++], &element, sizeof(T));\n   }\n@@ -511,12 +467,15 @@ class InternalMmapVectorNoCtor {\n   T *data() {\n     return data_;\n   }\n-  uptr capacity() const {\n-    return capacity_;\n+  uptr capacity() const { return capacity_bytes_ / sizeof(T); }\n+  void reserve(uptr new_size) {\n+    // Never downsize internal buffer.\n+    if (new_size > capacity())\n+      Realloc(new_size);\n   }\n   void resize(uptr new_size) {\n-    Resize(new_size);\n     if (new_size > size_) {\n+      reserve(new_size);\n       internal_memset(&data_[size_], 0, sizeof(T) * (new_size - size_));\n     }\n     size_ = new_size;\n@@ -538,67 +497,112 @@ class InternalMmapVectorNoCtor {\n     return data() + size();\n   }\n \n+  void swap(InternalMmapVectorNoCtor &other) {\n+    Swap(data_, other.data_);\n+    Swap(capacity_bytes_, other.capacity_bytes_);\n+    Swap(size_, other.size_);\n+  }\n+\n  private:\n-  void Resize(uptr new_capacity) {\n+  void Realloc(uptr new_capacity) {\n     CHECK_GT(new_capacity, 0);\n     CHECK_LE(size_, new_capacity);\n-    T *new_data = (T *)MmapOrDie(new_capacity * sizeof(T),\n-                                 \"InternalMmapVector\");\n+    uptr new_capacity_bytes =\n+        RoundUpTo(new_capacity * sizeof(T), GetPageSizeCached());\n+    T *new_data = (T *)MmapOrDie(new_capacity_bytes, \"InternalMmapVector\");\n     internal_memcpy(new_data, data_, size_ * sizeof(T));\n-    T *old_data = data_;\n+    UnmapOrDie(data_, capacity_bytes_);\n     data_ = new_data;\n-    UnmapOrDie(old_data, capacity_ * sizeof(T));\n-    capacity_ = new_capacity;\n+    capacity_bytes_ = new_capacity_bytes;\n   }\n \n   T *data_;\n-  uptr capacity_;\n+  uptr capacity_bytes_;\n   uptr size_;\n };\n \n+template <typename T>\n+bool operator==(const InternalMmapVectorNoCtor<T> &lhs,\n+                const InternalMmapVectorNoCtor<T> &rhs) {\n+  if (lhs.size() != rhs.size()) return false;\n+  return internal_memcmp(lhs.data(), rhs.data(), lhs.size() * sizeof(T)) == 0;\n+}\n+\n+template <typename T>\n+bool operator!=(const InternalMmapVectorNoCtor<T> &lhs,\n+                const InternalMmapVectorNoCtor<T> &rhs) {\n+  return !(lhs == rhs);\n+}\n+\n template<typename T>\n class InternalMmapVector : public InternalMmapVectorNoCtor<T> {\n  public:\n-  explicit InternalMmapVector(uptr initial_capacity) {\n-    InternalMmapVectorNoCtor<T>::Initialize(initial_capacity);\n+  InternalMmapVector() { InternalMmapVectorNoCtor<T>::Initialize(1); }\n+  explicit InternalMmapVector(uptr cnt) {\n+    InternalMmapVectorNoCtor<T>::Initialize(cnt);\n+    this->resize(cnt);\n   }\n   ~InternalMmapVector() { InternalMmapVectorNoCtor<T>::Destroy(); }\n-  // Disallow evil constructors.\n-  InternalMmapVector(const InternalMmapVector&);\n-  void operator=(const InternalMmapVector&);\n+  // Disallow copies and moves.\n+  InternalMmapVector(const InternalMmapVector &) = delete;\n+  InternalMmapVector &operator=(const InternalMmapVector &) = delete;\n+  InternalMmapVector(InternalMmapVector &&) = delete;\n+  InternalMmapVector &operator=(InternalMmapVector &&) = delete;\n+};\n+\n+class InternalScopedString : public InternalMmapVector<char> {\n+ public:\n+  explicit InternalScopedString(uptr max_length)\n+      : InternalMmapVector<char>(max_length), length_(0) {\n+    (*this)[0] = '\\0';\n+  }\n+  uptr length() { return length_; }\n+  void clear() {\n+    (*this)[0] = '\\0';\n+    length_ = 0;\n+  }\n+  void append(const char *format, ...);\n+\n+ private:\n+  uptr length_;\n+};\n+\n+template <class T>\n+struct CompareLess {\n+  bool operator()(const T &a, const T &b) const { return a < b; }\n };\n \n // HeapSort for arrays and InternalMmapVector.\n-template<class Container, class Compare>\n-void InternalSort(Container *v, uptr size, Compare comp) {\n+template <class T, class Compare = CompareLess<T>>\n+void Sort(T *v, uptr size, Compare comp = {}) {\n   if (size < 2)\n     return;\n   // Stage 1: insert elements to the heap.\n   for (uptr i = 1; i < size; i++) {\n     uptr j, p;\n     for (j = i; j > 0; j = p) {\n       p = (j - 1) / 2;\n-      if (comp((*v)[p], (*v)[j]))\n-        Swap((*v)[j], (*v)[p]);\n+      if (comp(v[p], v[j]))\n+        Swap(v[j], v[p]);\n       else\n         break;\n     }\n   }\n   // Stage 2: swap largest element with the last one,\n   // and sink the new top.\n   for (uptr i = size - 1; i > 0; i--) {\n-    Swap((*v)[0], (*v)[i]);\n+    Swap(v[0], v[i]);\n     uptr j, max_ind;\n     for (j = 0; j < i; j = max_ind) {\n       uptr left = 2 * j + 1;\n       uptr right = 2 * j + 2;\n       max_ind = j;\n-      if (left < i && comp((*v)[max_ind], (*v)[left]))\n+      if (left < i && comp(v[max_ind], v[left]))\n         max_ind = left;\n-      if (right < i && comp((*v)[max_ind], (*v)[right]))\n+      if (right < i && comp(v[max_ind], v[right]))\n         max_ind = right;\n       if (max_ind != j)\n-        Swap((*v)[j], (*v)[max_ind]);\n+        Swap(v[j], v[max_ind]);\n       else\n         break;\n     }\n@@ -632,6 +636,25 @@ enum ModuleArch {\n   kModuleArchARM64\n };\n \n+// Opens the file 'file_name\" and reads up to 'max_len' bytes.\n+// The resulting buffer is mmaped and stored in '*buff'.\n+// Returns true if file was successfully opened and read.\n+bool ReadFileToVector(const char *file_name,\n+                      InternalMmapVectorNoCtor<char> *buff,\n+                      uptr max_len = 1 << 26, error_t *errno_p = nullptr);\n+\n+// Opens the file 'file_name\" and reads up to 'max_len' bytes.\n+// This function is less I/O efficient than ReadFileToVector as it may reread\n+// file multiple times to avoid mmap during read attempts. It's used to read\n+// procmap, so short reads with mmap in between can produce inconsistent result.\n+// The resulting buffer is mmaped and stored in '*buff'.\n+// The size of the mmaped region is stored in '*buff_size'.\n+// The total number of read bytes is stored in '*read_len'.\n+// Returns true if file was successfully opened and read.\n+bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n+                      uptr *read_len, uptr max_len = 1 << 26,\n+                      error_t *errno_p = nullptr);\n+\n // When adding a new architecture, don't forget to also update\n // script/asan_symbolize.py and sanitizer_symbolizer_libcdep.cc.\n inline const char *ModuleArchToString(ModuleArch arch) {\n@@ -916,6 +939,15 @@ void CheckNoDeepBind(const char *filename, int flag);\n // be used to seed a PRNG. Defaults to blocking like the underlying syscall.\n bool GetRandom(void *buffer, uptr length, bool blocking = true);\n \n+// Returns the number of logical processors on the system.\n+u32 GetNumberOfCPUs();\n+extern u32 NumberOfCPUsCached;\n+INLINE u32 GetNumberOfCPUsCached() {\n+  if (!NumberOfCPUsCached)\n+    NumberOfCPUsCached = GetNumberOfCPUs();\n+  return NumberOfCPUsCached;\n+}\n+\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,"}, {"sha": "c810e65f0ad501c583f1c21a3c24c740bcc04a50", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 1056, "deletions": 30, "changes": 1086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -32,6 +32,7 @@\n //   COMMON_INTERCEPTOR_MEMSET_IMPL\n //   COMMON_INTERCEPTOR_MEMMOVE_IMPL\n //   COMMON_INTERCEPTOR_MEMCPY_IMPL\n+//   COMMON_INTERCEPTOR_MMAP_IMPL\n //   COMMON_INTERCEPTOR_COPY_STRING\n //   COMMON_INTERCEPTOR_STRNDUP_IMPL\n //===----------------------------------------------------------------------===//\n@@ -67,6 +68,52 @@\n #define iconv __bsd_iconv\n #endif\n \n+#if SANITIZER_NETBSD\n+#define clock_getres __clock_getres50\n+#define clock_gettime __clock_gettime50\n+#define clock_settime __clock_settime50\n+#define ctime __ctime50\n+#define ctime_r __ctime_r50\n+#define devname __devname50\n+#define getitimer __getitimer50\n+#define getpwent __getpwent50\n+#define getpwnam __getpwnam50\n+#define getpwnam_r __getpwnam_r50\n+#define getpwuid __getpwuid50\n+#define getpwuid_r __getpwuid_r50\n+#define getutent __getutent50\n+#define getutxent __getutxent50\n+#define getutxid __getutxid50\n+#define getutxline __getutxline50\n+#define glob __glob30\n+#define gmtime __gmtime50\n+#define gmtime_r __gmtime_r50\n+#define localtime __locatime50\n+#define localtime_r __localtime_r50\n+#define mktime __mktime50\n+#define lstat __lstat50\n+#define opendir __opendir30\n+#define readdir __readdir30\n+#define readdir_r __readdir_r30\n+#define scandir __scandir30\n+#define setitimer __setitimer50\n+#define setlocale __setlocale50\n+#define shmctl __shmctl50\n+#define sigemptyset __sigemptyset14\n+#define sigfillset __sigfillset14\n+#define sigpending __sigpending14\n+#define sigprocmask __sigprocmask14\n+#define sigtimedwait __sigtimedwait50\n+#define stat __stat50\n+#define time __time50\n+#define times __times13\n+#define wait3 __wait350\n+#define wait4 __wait450\n+extern const unsigned short *_ctype_tab_;\n+extern const short *_toupper_tab_;\n+extern const short *_tolower_tab_;\n+#endif\n+\n // Platform-specific options.\n #if SANITIZER_MAC\n namespace __sanitizer {\n@@ -219,6 +266,12 @@ bool PlatformHasDifferentMemcpyAndMemmove();\n   }\n #endif\n \n+#ifndef COMMON_INTERCEPTOR_MMAP_IMPL\n+#define COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap, addr, sz, prot, flags, fd, \\\n+                                     off)                                  \\\n+  { return REAL(mmap)(addr, sz, prot, flags, fd, off); }\n+#endif\n+\n #ifndef COMMON_INTERCEPTOR_COPY_STRING\n #define COMMON_INTERCEPTOR_COPY_STRING(ctx, to, from, size) {}\n #endif\n@@ -271,7 +324,7 @@ UNUSED static const FileMetadata *GetInterceptorMetadata(\n   MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr,\n                             /* remove */ false,\n                             /* create */ false);\n-  if (h.exists()) {\n+  if (addr && h.exists()) {\n     CHECK(!h.created());\n     CHECK(h->type == CommonInterceptorMetadata::CIMT_FILE);\n     return &h->file;\n@@ -1134,6 +1187,50 @@ INTERCEPTOR(SSIZE_T, pwritev64, int fd, __sanitizer_iovec *iov, int iovcnt,\n #define INIT_PWRITEV64\n #endif\n \n+#if SANITIZER_INTERCEPT_FGETS\n+INTERCEPTOR(char *, fgets, char *s, SIZE_T size, void *file) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgets, s, size, file);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://github.com/google/sanitizers/issues/321.\n+  char *res = REAL(fgets)(s, size, file);\n+  if (res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+  return res;\n+}\n+#define INIT_FGETS COMMON_INTERCEPT_FUNCTION(fgets)\n+#else\n+#define INIT_FGETS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FPUTS\n+INTERCEPTOR_WITH_SUFFIX(int, fputs, char *s, void *file) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fputs, s, file);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+  return REAL(fputs)(s, file);\n+}\n+#define INIT_FPUTS COMMON_INTERCEPT_FUNCTION(fputs)\n+#else\n+#define INIT_FPUTS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PUTS\n+INTERCEPTOR(int, puts, char *s) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, puts, s);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+  return REAL(puts)(s);\n+}\n+#define INIT_PUTS COMMON_INTERCEPT_FUNCTION(puts)\n+#else\n+#define INIT_PUTS\n+#endif\n+\n #if SANITIZER_INTERCEPT_PRCTL\n INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n             unsigned long arg3,                        // NOLINT\n@@ -1175,12 +1272,14 @@ INTERCEPTOR(unsigned long, time, unsigned long *t) {\n #if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n static void unpoison_tm(void *ctx, __sanitizer_tm *tm) {\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n+#if !SANITIZER_SOLARIS\n   if (tm->tm_zone) {\n     // Can not use COMMON_INTERCEPTOR_WRITE_RANGE here, because tm->tm_zone\n     // can point to shared memory and tsan would report a data race.\n     COMMON_INTERCEPTOR_INITIALIZE_RANGE(tm->tm_zone,\n                                         REAL(strlen(tm->tm_zone)) + 1);\n   }\n+#endif\n }\n INTERCEPTOR(__sanitizer_tm *, localtime, unsigned long *timep) {\n   void *ctx;\n@@ -1508,6 +1607,12 @@ INTERCEPTOR(int, vsnprintf, char *str, SIZE_T size, const char *format,\n             va_list ap)\n VSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n \n+#if SANITIZER_INTERCEPT___PRINTF_CHK\n+INTERCEPTOR(int, __vsnprintf_chk, char *str, SIZE_T size, int flag,\n+            SIZE_T size_to, const char *format, va_list ap)\n+VSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n+#endif\n+\n #if SANITIZER_INTERCEPT_PRINTF_L\n INTERCEPTOR(int, vsnprintf_l, char *str, SIZE_T size, void *loc,\n             const char *format, va_list ap)\n@@ -1521,6 +1626,12 @@ FORMAT_INTERCEPTOR_IMPL(snprintf_l, vsnprintf_l, str, size, loc, format)\n INTERCEPTOR(int, vsprintf, char *str, const char *format, va_list ap)\n VSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n \n+#if SANITIZER_INTERCEPT___PRINTF_CHK\n+INTERCEPTOR(int, __vsprintf_chk, char *str, int flag, SIZE_T size_to,\n+            const char *format, va_list ap)\n+VSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n+#endif\n+\n INTERCEPTOR(int, vasprintf, char **strp, const char *format, va_list ap)\n VASPRINTF_INTERCEPTOR_IMPL(vasprintf, strp, format, ap)\n \n@@ -1549,12 +1660,30 @@ FORMAT_INTERCEPTOR_IMPL(printf, vprintf, format)\n INTERCEPTOR(int, fprintf, __sanitizer_FILE *stream, const char *format, ...)\n FORMAT_INTERCEPTOR_IMPL(fprintf, vfprintf, stream, format)\n \n+#if SANITIZER_INTERCEPT___PRINTF_CHK\n+INTERCEPTOR(int, __fprintf_chk, __sanitizer_FILE *stream, SIZE_T size,\n+            const char *format, ...)\n+FORMAT_INTERCEPTOR_IMPL(__fprintf_chk, vfprintf, stream, format)\n+#endif\n+\n INTERCEPTOR(int, sprintf, char *str, const char *format, ...) // NOLINT\n FORMAT_INTERCEPTOR_IMPL(sprintf, vsprintf, str, format) // NOLINT\n \n+#if SANITIZER_INTERCEPT___PRINTF_CHK\n+INTERCEPTOR(int, __sprintf_chk, char *str, int flag, SIZE_T size_to,\n+            const char *format, ...) // NOLINT\n+FORMAT_INTERCEPTOR_IMPL(__sprintf_chk, vsprintf, str, format) // NOLINT\n+#endif\n+\n INTERCEPTOR(int, snprintf, char *str, SIZE_T size, const char *format, ...)\n FORMAT_INTERCEPTOR_IMPL(snprintf, vsnprintf, str, size, format)\n \n+#if SANITIZER_INTERCEPT___PRINTF_CHK\n+INTERCEPTOR(int, __snprintf_chk, char *str, SIZE_T size, int flag,\n+            SIZE_T size_to, const char *format, ...) // NOLINT\n+FORMAT_INTERCEPTOR_IMPL(__snprintf_chk, vsnprintf, str, size, format) // NOLINT\n+#endif\n+\n INTERCEPTOR(int, asprintf, char **strp, const char *format, ...)\n FORMAT_INTERCEPTOR_IMPL(asprintf, vasprintf, strp, format)\n \n@@ -1594,6 +1723,17 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n #define INIT_PRINTF\n #endif\n \n+#if SANITIZER_INTERCEPT___PRINTF_CHK\n+#define INIT___PRINTF_CHK                     \\\n+  COMMON_INTERCEPT_FUNCTION(__sprintf_chk);   \\\n+  COMMON_INTERCEPT_FUNCTION(__snprintf_chk);  \\\n+  COMMON_INTERCEPT_FUNCTION(__vsprintf_chk);  \\\n+  COMMON_INTERCEPT_FUNCTION(__vsnprintf_chk); \\\n+  COMMON_INTERCEPT_FUNCTION(__fprintf_chk);\n+#else\n+#define INIT___PRINTF_CHK\n+#endif\n+\n #if SANITIZER_INTERCEPT_PRINTF_L\n #define INIT_PRINTF_L                     \\\n   COMMON_INTERCEPT_FUNCTION(snprintf_l);  \\\n@@ -1618,6 +1758,7 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n \n #if SANITIZER_INTERCEPT_IOCTL\n #include \"sanitizer_common_interceptors_ioctl.inc\"\n+#include \"sanitizer_interceptors_ioctl_netbsd.inc\"\n INTERCEPTOR(int, ioctl, int d, unsigned long request, ...) {\n   // We need a frame pointer, because we call into ioctl_common_[pre|post] which\n   // can trigger a report and we need to be able to unwind through this\n@@ -1722,7 +1863,8 @@ static void unpoison_group(void *ctx, __sanitizer_group *grp) {\n INTERCEPTOR(__sanitizer_passwd *, getpwnam, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n-  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   __sanitizer_passwd *res = REAL(getpwnam)(name);\n   if (res) unpoison_passwd(ctx, res);\n   return res;\n@@ -2002,6 +2144,13 @@ INTERCEPTOR(int, clock_gettime, u32 clk_id, void *tp) {\n   }\n   return res;\n }\n+namespace __sanitizer {\n+extern \"C\" {\n+int real_clock_gettime(u32 clk_id, void *tp) {\n+  return REAL(clock_gettime)(clk_id, tp);\n+}\n+}  // extern \"C\"\n+}  // namespace __sanitizer\n INTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, clock_settime, clk_id, tp);\n@@ -2032,8 +2181,19 @@ INTERCEPTOR(int, getitimer, int which, void *curr_value) {\n INTERCEPTOR(int, setitimer, int which, const void *new_value, void *old_value) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, setitimer, which, new_value, old_value);\n-  if (new_value)\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerval_sz);\n+  if (new_value) {\n+    // itimerval can contain padding that may be legitimately uninitialized\n+    const struct __sanitizer_itimerval *nv =\n+        (const struct __sanitizer_itimerval *)new_value;\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_interval.tv_sec,\n+                                  sizeof(__sanitizer_time_t));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_interval.tv_usec,\n+                                  sizeof(__sanitizer_suseconds_t));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_value.tv_sec,\n+                                  sizeof(__sanitizer_time_t));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_value.tv_usec,\n+                                  sizeof(__sanitizer_suseconds_t));\n+  }\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n@@ -2063,6 +2223,18 @@ static void unpoison_glob_t(void *ctx, __sanitizer_glob_t *pglob) {\n   }\n }\n \n+#if SANITIZER_SOLARIS\n+INTERCEPTOR(int, glob, const char *pattern, int flags,\n+            int (*errfunc)(const char *epath, int eerrno),\n+            __sanitizer_glob_t *pglob) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n+  int res = REAL(glob)(pattern, flags, errfunc, pglob);\n+  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n+  return res;\n+}\n+#else\n static THREADLOCAL __sanitizer_glob_t *pglob_copy;\n \n static void wrapped_gl_closedir(void *dir) {\n@@ -2126,7 +2298,14 @@ INTERCEPTOR(int, glob, const char *pattern, int flags,\n   if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n   return res;\n }\n+#endif  // SANITIZER_SOLARIS\n+#define INIT_GLOB                  \\\n+  COMMON_INTERCEPT_FUNCTION(glob);\n+#else  // SANITIZER_INTERCEPT_GLOB\n+#define INIT_GLOB\n+#endif  // SANITIZER_INTERCEPT_GLOB\n \n+#if SANITIZER_INTERCEPT_GLOB64\n INTERCEPTOR(int, glob64, const char *pattern, int flags,\n             int (*errfunc)(const char *epath, int eerrno),\n             __sanitizer_glob_t *pglob) {\n@@ -2155,12 +2334,11 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n   if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n   return res;\n }\n-#define INIT_GLOB                  \\\n-  COMMON_INTERCEPT_FUNCTION(glob); \\\n+#define INIT_GLOB64                \\\n   COMMON_INTERCEPT_FUNCTION(glob64);\n-#else  // SANITIZER_INTERCEPT_GLOB\n-#define INIT_GLOB\n-#endif  // SANITIZER_INTERCEPT_GLOB\n+#else  // SANITIZER_INTERCEPT_GLOB64\n+#define INIT_GLOB64\n+#endif  // SANITIZER_INTERCEPT_GLOB64\n \n #if SANITIZER_INTERCEPT_WAIT\n // According to sys/wait.h, wait(), waitid(), waitpid() may have symbol version\n@@ -2465,22 +2643,26 @@ INTERCEPTOR(struct __sanitizer_hostent *, gethostent, int fake) {\n   if (res) write_hostent(ctx, res);\n   return res;\n }\n+#define INIT_GETHOSTBYNAME                  \\\n+  COMMON_INTERCEPT_FUNCTION(gethostent);    \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyaddr); \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyname);\n+#else\n+#define INIT_GETHOSTBYNAME\n+#endif  // SANITIZER_INTERCEPT_GETHOSTBYNAME\n \n+#if SANITIZER_INTERCEPT_GETHOSTBYNAME2\n INTERCEPTOR(struct __sanitizer_hostent *, gethostbyname2, char *name, int af) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2, name, af);\n   struct __sanitizer_hostent *res = REAL(gethostbyname2)(name, af);\n   if (res) write_hostent(ctx, res);\n   return res;\n }\n-#define INIT_GETHOSTBYNAME                  \\\n-  COMMON_INTERCEPT_FUNCTION(gethostent);    \\\n-  COMMON_INTERCEPT_FUNCTION(gethostbyaddr); \\\n-  COMMON_INTERCEPT_FUNCTION(gethostbyname); \\\n-  COMMON_INTERCEPT_FUNCTION(gethostbyname2);\n+#define INIT_GETHOSTBYNAME2 COMMON_INTERCEPT_FUNCTION(gethostbyname2);\n #else\n-#define INIT_GETHOSTBYNAME\n-#endif\n+#define INIT_GETHOSTBYNAME2\n+#endif  // SANITIZER_INTERCEPT_GETHOSTBYNAME2\n \n #if SANITIZER_INTERCEPT_GETHOSTBYNAME_R\n INTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n@@ -2650,6 +2832,30 @@ INTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n #define INIT_ACCEPT4\n #endif\n \n+#if SANITIZER_INTERCEPT_PACCEPT\n+INTERCEPTOR(int, paccept, int fd, void *addr, unsigned *addrlen,\n+            __sanitizer_sigset_t *set, int f) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, paccept, fd, addr, addrlen, set, f);\n+  unsigned addrlen0 = 0;\n+  if (addrlen) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n+    addrlen0 = *addrlen;\n+  }\n+  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n+  int fd2 = REAL(paccept)(fd, addr, addrlen, set, f);\n+  if (fd2 >= 0) {\n+    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n+    if (addr && addrlen)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n+  }\n+  return fd2;\n+}\n+#define INIT_PACCEPT COMMON_INTERCEPT_FUNCTION(paccept);\n+#else\n+#define INIT_PACCEPT\n+#endif\n+\n #if SANITIZER_INTERCEPT_MODF\n INTERCEPTOR(double, modf, double x, double *iptr) {\n   void *ctx;\n@@ -2695,7 +2901,7 @@ INTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n #define INIT_MODF\n #endif\n \n-#if SANITIZER_INTERCEPT_RECVMSG\n+#if SANITIZER_INTERCEPT_RECVMSG || SANITIZER_INTERCEPT_RECVMMSG\n static void write_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n                          SSIZE_T maxlen) {\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg, sizeof(*msg));\n@@ -2708,7 +2914,9 @@ static void write_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n   if (msg->msg_control && msg->msg_controllen)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_control, msg->msg_controllen);\n }\n+#endif\n \n+#if SANITIZER_INTERCEPT_RECVMSG\n INTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n             int flags) {\n   void *ctx;\n@@ -2731,7 +2939,30 @@ INTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n #define INIT_RECVMSG\n #endif\n \n-#if SANITIZER_INTERCEPT_SENDMSG\n+#if SANITIZER_INTERCEPT_RECVMMSG\n+INTERCEPTOR(int, recvmmsg, int fd, struct __sanitizer_mmsghdr *msgvec,\n+            unsigned int vlen, int flags, void *timeout) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, recvmmsg, fd, msgvec, vlen, flags, timeout);\n+  if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n+  int res = REAL(recvmmsg)(fd, msgvec, vlen, flags, timeout);\n+  if (res >= 0) {\n+    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+    for (int i = 0; i < res; ++i) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &msgvec[i].msg_len,\n+                                     sizeof(msgvec[i].msg_len));\n+      write_msghdr(ctx, &msgvec[i].msg_hdr, msgvec[i].msg_len);\n+      COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, &msgvec[i].msg_hdr);\n+    }\n+  }\n+  return res;\n+}\n+#define INIT_RECVMMSG COMMON_INTERCEPT_FUNCTION(recvmmsg);\n+#else\n+#define INIT_RECVMMSG\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SENDMSG || SANITIZER_INTERCEPT_SENDMMSG\n static void read_msghdr_control(void *ctx, void *control, uptr controllen) {\n   const unsigned kCmsgDataOffset =\n       RoundUpTo(sizeof(__sanitizer_cmsghdr), sizeof(uptr));\n@@ -2781,7 +3012,9 @@ static void read_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n   if (msg->msg_control && msg->msg_controllen)\n     read_msghdr_control(ctx, msg->msg_control, msg->msg_controllen);\n }\n+#endif\n \n+#if SANITIZER_INTERCEPT_SENDMSG\n INTERCEPTOR(SSIZE_T, sendmsg, int fd, struct __sanitizer_msghdr *msg,\n             int flags) {\n   void *ctx;\n@@ -2800,6 +3033,30 @@ INTERCEPTOR(SSIZE_T, sendmsg, int fd, struct __sanitizer_msghdr *msg,\n #define INIT_SENDMSG\n #endif\n \n+#if SANITIZER_INTERCEPT_SENDMMSG\n+INTERCEPTOR(int, sendmmsg, int fd, struct __sanitizer_mmsghdr *msgvec,\n+            unsigned vlen, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sendmmsg, fd, msgvec, vlen, flags);\n+  if (fd >= 0) {\n+    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  }\n+  int res = REAL(sendmmsg)(fd, msgvec, vlen, flags);\n+  if (res >= 0 && msgvec)\n+    for (int i = 0; i < res; ++i) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &msgvec[i].msg_len,\n+                                     sizeof(msgvec[i].msg_len));\n+      if (common_flags()->intercept_send)\n+        read_msghdr(ctx, &msgvec[i].msg_hdr, msgvec[i].msg_len);\n+    }\n+  return res;\n+}\n+#define INIT_SENDMMSG COMMON_INTERCEPT_FUNCTION(sendmmsg);\n+#else\n+#define INIT_SENDMMSG\n+#endif\n+\n #if SANITIZER_INTERCEPT_GETPEERNAME\n INTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n   void *ctx;\n@@ -2981,13 +3238,25 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n #endif\n \n #if SANITIZER_INTERCEPT_SETLOCALE\n+static void unpoison_ctype_arrays(void *ctx) {\n+#if SANITIZER_NETBSD\n+  // These arrays contain 256 regular elements in unsigned char range + 1 EOF\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, _ctype_tab_, 257 * sizeof(short));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, _toupper_tab_, 257 * sizeof(short));\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, _tolower_tab_, 257 * sizeof(short));\n+#endif\n+}\n+\n INTERCEPTOR(char *, setlocale, int category, char *locale) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, setlocale, category, locale);\n   if (locale)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, locale, REAL(strlen)(locale) + 1);\n   char *res = REAL(setlocale)(category, locale);\n-  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+    unpoison_ctype_arrays(ctx);\n+  }\n   return res;\n }\n \n@@ -3074,14 +3343,14 @@ INTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n   return res;\n }\n \n-INTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n+INTERCEPTOR(UINTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strtoumax, nptr, endptr, base);\n   // FIXME: under ASan the call below may write to freed memory and corrupt\n   // its metadata. See\n   // https://github.com/google/sanitizers/issues/321.\n   char *real_endptr;\n-  INTMAX_T res = REAL(strtoumax)(nptr, &real_endptr, base);\n+  UINTMAX_T res = REAL(strtoumax)(nptr, &real_endptr, base);\n   StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n   return res;\n }\n@@ -3370,7 +3639,8 @@ INTERCEPTOR(char *, strerror, int errnum) {\n //  * GNU version returns message pointer, which points to either buf or some\n //    static storage.\n #if ((_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE) || \\\n-    SANITIZER_MAC || SANITIZER_ANDROID\n+    SANITIZER_MAC || SANITIZER_ANDROID || SANITIZER_NETBSD ||                 \\\n+    SANITIZER_FREEBSD || SANITIZER_OPENBSD\n // POSIX version. Spec is not clear on whether buf is NULL-terminated.\n // At least on OSX, buf contents are valid even when the call fails.\n INTERCEPTOR(int, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n@@ -3793,7 +4063,7 @@ INTERCEPTOR(void, _exit, int status) {\n #define INIT__EXIT\n #endif\n \n-#if SANITIZER_INTERCEPT_PHTREAD_MUTEX\n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEX\n INTERCEPTOR(int, pthread_mutex_lock, void *m) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_lock, m);\n@@ -3826,6 +4096,44 @@ INTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n #define INIT_PTHREAD_MUTEX_UNLOCK\n #endif\n \n+#if SANITIZER_INTERCEPT___PTHREAD_MUTEX\n+INTERCEPTOR(int, __pthread_mutex_lock, void *m) {\n+  return WRAP(pthread_mutex_lock)(m);\n+}\n+\n+INTERCEPTOR(int, __pthread_mutex_unlock, void *m) {\n+  return WRAP(pthread_mutex_unlock)(m);\n+}\n+\n+#define INIT___PTHREAD_MUTEX_LOCK \\\n+  COMMON_INTERCEPT_FUNCTION(__pthread_mutex_lock)\n+#define INIT___PTHREAD_MUTEX_UNLOCK \\\n+  COMMON_INTERCEPT_FUNCTION(__pthread_mutex_unlock)\n+#else\n+#define INIT___PTHREAD_MUTEX_LOCK\n+#define INIT___PTHREAD_MUTEX_UNLOCK\n+#endif\n+\n+#if SANITIZER_INTERCEPT___LIBC_MUTEX\n+INTERCEPTOR(int, __libc_mutex_lock, void *m)\n+ALIAS(WRAPPER_NAME(pthread_mutex_lock));\n+\n+INTERCEPTOR(int, __libc_mutex_unlock, void *m)\n+ALIAS(WRAPPER_NAME(pthread_mutex_unlock));\n+\n+INTERCEPTOR(int, __libc_thr_setcancelstate, int state, int *oldstate)\n+ALIAS(WRAPPER_NAME(pthread_setcancelstate));\n+\n+#define INIT___LIBC_MUTEX_LOCK COMMON_INTERCEPT_FUNCTION(__libc_mutex_lock)\n+#define INIT___LIBC_MUTEX_UNLOCK COMMON_INTERCEPT_FUNCTION(__libc_mutex_unlock)\n+#define INIT___LIBC_THR_SETCANCELSTATE \\\n+  COMMON_INTERCEPT_FUNCTION(__libc_thr_setcancelstate)\n+#else\n+#define INIT___LIBC_MUTEX_LOCK\n+#define INIT___LIBC_MUTEX_UNLOCK\n+#define INIT___LIBC_THR_SETCANCELSTATE\n+#endif\n+\n #if SANITIZER_INTERCEPT_GETMNTENT || SANITIZER_INTERCEPT_GETMNTENT_R\n static void write_mntent(void *ctx, __sanitizer_mntent *mnt) {\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt, sizeof(*mnt));\n@@ -4150,6 +4458,7 @@ INTERCEPTOR(int, random_r, void *buf, u32 *result) {\n // its metadata. See\n // https://github.com/google/sanitizers/issues/321.\n #if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET ||              \\\n+    SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED ||        \\\n     SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSSCHED || \\\n     SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GET ||         \\\n     SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GET ||        \\\n@@ -4178,8 +4487,6 @@ INTERCEPTOR(int, random_r, void *buf, u32 *result) {\n #if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET\n INTERCEPTOR_PTHREAD_ATTR_GET(detachstate, sizeof(int))\n INTERCEPTOR_PTHREAD_ATTR_GET(guardsize, sizeof(SIZE_T))\n-INTERCEPTOR_PTHREAD_ATTR_GET(schedparam, struct_sched_param_sz)\n-INTERCEPTOR_PTHREAD_ATTR_GET(schedpolicy, sizeof(int))\n INTERCEPTOR_PTHREAD_ATTR_GET(scope, sizeof(int))\n INTERCEPTOR_PTHREAD_ATTR_GET(stacksize, sizeof(SIZE_T))\n INTERCEPTOR(int, pthread_attr_getstack, void *attr, void **addr, SIZE_T *size) {\n@@ -4210,15 +4517,24 @@ int real_pthread_attr_getstack(void *attr, void **addr, SIZE_T *size) {\n #define INIT_PTHREAD_ATTR_GET                             \\\n   COMMON_INTERCEPT_FUNCTION(pthread_attr_getdetachstate); \\\n   COMMON_INTERCEPT_FUNCTION(pthread_attr_getguardsize);   \\\n-  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedparam);  \\\n-  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedpolicy); \\\n   COMMON_INTERCEPT_FUNCTION(pthread_attr_getscope);       \\\n   COMMON_INTERCEPT_FUNCTION(pthread_attr_getstacksize);   \\\n   COMMON_INTERCEPT_FUNCTION(pthread_attr_getstack);\n #else\n #define INIT_PTHREAD_ATTR_GET\n #endif\n \n+#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED\n+INTERCEPTOR_PTHREAD_ATTR_GET(schedparam, struct_sched_param_sz)\n+INTERCEPTOR_PTHREAD_ATTR_GET(schedpolicy, sizeof(int))\n+\n+#define INIT_PTHREAD_ATTR_GET_SCHED                      \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedparam); \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedpolicy);\n+#else\n+#define INIT_PTHREAD_ATTR_GET_SCHED\n+#endif\n+\n #if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED\n INTERCEPTOR_PTHREAD_ATTR_GET(inheritsched, sizeof(int))\n \n@@ -4403,7 +4719,7 @@ INTERCEPTOR(char *, tempnam, char *dir, char *pfx) {\n #define INIT_TEMPNAM\n #endif\n \n-#if SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP\n+#if SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP && !SANITIZER_NETBSD\n INTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name);\n@@ -4412,10 +4728,35 @@ INTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n   return REAL(pthread_setname_np)(thread, name);\n }\n #define INIT_PTHREAD_SETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_setname_np);\n+#elif SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP && SANITIZER_NETBSD\n+INTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name, void *arg) {\n+  void *ctx;\n+  char newname[32]; // PTHREAD_MAX_NAMELEN_NP=32\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name, arg);\n+  COMMON_INTERCEPTOR_READ_STRING(ctx, name, 0);\n+  internal_snprintf(newname, sizeof(newname), name, arg);\n+  COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, newname);\n+  return REAL(pthread_setname_np)(thread, name, arg);\n+}\n+#define INIT_PTHREAD_SETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_setname_np);\n #else\n #define INIT_PTHREAD_SETNAME_NP\n #endif\n \n+#if SANITIZER_INTERCEPT_PTHREAD_GETNAME_NP\n+INTERCEPTOR(int, pthread_getname_np, uptr thread, char *name, SIZE_T len) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_getname_np, thread, name, len);\n+  int res = REAL(pthread_getname_np)(thread, name, len);\n+  if (!res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, internal_strnlen(name, len) + 1);\n+  return res;\n+}\n+#define INIT_PTHREAD_GETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_getname_np);\n+#else\n+#define INIT_PTHREAD_GETNAME_NP\n+#endif\n+\n #if SANITIZER_INTERCEPT_SINCOS\n INTERCEPTOR(void, sincos, double x, double *sin, double *cos) {\n   void *ctx;\n@@ -5822,7 +6163,7 @@ INTERCEPTOR(int, pthread_setcancelstate, int state, int *oldstate) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcancelstate, state, oldstate);\n   int res = REAL(pthread_setcancelstate)(state, oldstate);\n-  if (res == 0)\n+  if (res == 0 && oldstate != nullptr)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldstate, sizeof(*oldstate));\n   return res;\n }\n@@ -5831,7 +6172,7 @@ INTERCEPTOR(int, pthread_setcanceltype, int type, int *oldtype) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcanceltype, type, oldtype);\n   int res = REAL(pthread_setcanceltype)(type, oldtype);\n-  if (res == 0)\n+  if (res == 0 && oldtype != nullptr)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldtype, sizeof(*oldtype));\n   return res;\n }\n@@ -6040,6 +6381,22 @@ INTERCEPTOR(int, stat, const char *path, void *buf) {\n #define INIT_STAT\n #endif\n \n+#if SANITIZER_INTERCEPT_LSTAT\n+INTERCEPTOR(int, lstat, const char *path, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lstat, path, buf);\n+  if (common_flags()->intercept_stat)\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n+  int res = REAL(lstat)(path, buf);\n+  if (!res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n+  return res;\n+}\n+#define INIT_LSTAT COMMON_INTERCEPT_FUNCTION(lstat)\n+#else\n+#define INIT_LSTAT\n+#endif\n+\n #if SANITIZER_INTERCEPT___XSTAT\n INTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n   void *ctx;\n@@ -6252,10 +6609,636 @@ INTERCEPTOR(wchar_t *, wcsncat, wchar_t *dst, const wchar_t *src, SIZE_T n) {\n #define INIT_WCSCAT\n #endif\n \n+#if SANITIZER_INTERCEPT_STRXFRM\n+static SIZE_T RealStrLen(const char *str) { return REAL(strlen)(str); }\n+\n+static SIZE_T RealStrLen(const wchar_t *str) { return REAL(wcslen)(str); }\n+\n+#define STRXFRM_INTERCEPTOR_IMPL(strxfrm, dest, src, len, ...)             \\\n+  {                                                                        \\\n+    void *ctx;                                                             \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, strxfrm, dest, src, len, ##__VA_ARGS__); \\\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src,                                \\\n+                                  sizeof(*src) * (RealStrLen(src) + 1));   \\\n+    SIZE_T res = REAL(strxfrm)(dest, src, len, ##__VA_ARGS__);             \\\n+    if (res < len)                                                         \\\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, sizeof(*src) * (res + 1)); \\\n+    return res;                                                            \\\n+  }\n+\n+INTERCEPTOR(SIZE_T, strxfrm, char *dest, const char *src, SIZE_T len) {\n+  STRXFRM_INTERCEPTOR_IMPL(strxfrm, dest, src, len);\n+}\n+\n+INTERCEPTOR(SIZE_T, strxfrm_l, char *dest, const char *src, SIZE_T len,\n+            void *locale) {\n+  STRXFRM_INTERCEPTOR_IMPL(strxfrm_l, dest, src, len, locale);\n+}\n+\n+#define INIT_STRXFRM                  \\\n+  COMMON_INTERCEPT_FUNCTION(strxfrm); \\\n+  COMMON_INTERCEPT_FUNCTION(strxfrm_l);\n+#else\n+#define INIT_STRXFRM\n+#endif\n+\n+#if SANITIZER_INTERCEPT___STRXFRM_L\n+INTERCEPTOR(SIZE_T, __strxfrm_l, char *dest, const char *src, SIZE_T len,\n+            void *locale) {\n+  STRXFRM_INTERCEPTOR_IMPL(__strxfrm_l, dest, src, len, locale);\n+}\n+\n+#define INIT___STRXFRM_L COMMON_INTERCEPT_FUNCTION(__strxfrm_l);\n+#else\n+#define INIT___STRXFRM_L\n+#endif\n+\n+#if SANITIZER_INTERCEPT_WCSXFRM\n+INTERCEPTOR(SIZE_T, wcsxfrm, wchar_t *dest, const wchar_t *src, SIZE_T len) {\n+  STRXFRM_INTERCEPTOR_IMPL(wcsxfrm, dest, src, len);\n+}\n+\n+INTERCEPTOR(SIZE_T, wcsxfrm_l, wchar_t *dest, const wchar_t *src, SIZE_T len,\n+            void *locale) {\n+  STRXFRM_INTERCEPTOR_IMPL(wcsxfrm_l, dest, src, len, locale);\n+}\n+\n+#define INIT_WCSXFRM                  \\\n+  COMMON_INTERCEPT_FUNCTION(wcsxfrm); \\\n+  COMMON_INTERCEPT_FUNCTION(wcsxfrm_l);\n+#else\n+#define INIT_WCSXFRM\n+#endif\n+\n+#if SANITIZER_INTERCEPT___WCSXFRM_L\n+INTERCEPTOR(SIZE_T, __wcsxfrm_l, wchar_t *dest, const wchar_t *src, SIZE_T len,\n+            void *locale) {\n+  STRXFRM_INTERCEPTOR_IMPL(__wcsxfrm_l, dest, src, len, locale);\n+}\n+\n+#define INIT___WCSXFRM_L COMMON_INTERCEPT_FUNCTION(__wcsxfrm_l);\n+#else\n+#define INIT___WCSXFRM_L\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ACCT\n+INTERCEPTOR(int, acct, const char *file) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, acct, file);\n+  if (file)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, file, REAL(strlen)(file) + 1);\n+  return REAL(acct)(file);\n+}\n+#define INIT_ACCT COMMON_INTERCEPT_FUNCTION(acct)\n+#else\n+#define INIT_ACCT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_USER_FROM_UID\n+INTERCEPTOR(const char *, user_from_uid, u32 uid, int nouser) {\n+  void *ctx;\n+  const char *user;\n+  COMMON_INTERCEPTOR_ENTER(ctx, user_from_uid, uid, nouser);\n+  user = REAL(user_from_uid)(uid, nouser);\n+  if (user)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, user, REAL(strlen)(user) + 1);\n+  return user;\n+}\n+#define INIT_USER_FROM_UID COMMON_INTERCEPT_FUNCTION(user_from_uid)\n+#else\n+#define INIT_USER_FROM_UID\n+#endif\n+\n+#if SANITIZER_INTERCEPT_UID_FROM_USER\n+INTERCEPTOR(int, uid_from_user, const char *name, u32 *uid) {\n+  void *ctx;\n+  int res;\n+  COMMON_INTERCEPTOR_ENTER(ctx, uid_from_user, name, uid);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  res = REAL(uid_from_user)(name, uid);\n+  if (uid)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, uid, sizeof(*uid));\n+  return res;\n+}\n+#define INIT_UID_FROM_USER COMMON_INTERCEPT_FUNCTION(uid_from_user)\n+#else\n+#define INIT_UID_FROM_USER\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GROUP_FROM_GID\n+INTERCEPTOR(const char *, group_from_gid, u32 gid, int nogroup) {\n+  void *ctx;\n+  const char *group;\n+  COMMON_INTERCEPTOR_ENTER(ctx, group_from_gid, gid, nogroup);\n+  group = REAL(group_from_gid)(gid, nogroup);\n+  if (group)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, group, REAL(strlen)(group) + 1);\n+  return group;\n+}\n+#define INIT_GROUP_FROM_GID COMMON_INTERCEPT_FUNCTION(group_from_gid)\n+#else\n+#define INIT_GROUP_FROM_GID\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GID_FROM_GROUP\n+INTERCEPTOR(int, gid_from_group, const char *group, u32 *gid) {\n+  void *ctx;\n+  int res;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gid_from_group, group, gid);\n+  if (group)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, group, REAL(strlen)(group) + 1);\n+  res = REAL(gid_from_group)(group, gid);\n+  if (gid)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, gid, sizeof(*gid));\n+  return res;\n+}\n+#define INIT_GID_FROM_GROUP COMMON_INTERCEPT_FUNCTION(gid_from_group)\n+#else\n+#define INIT_GID_FROM_GROUP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ACCESS\n+INTERCEPTOR(int, access, const char *path, int mode) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, access, path, mode);\n+  if (path)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  return REAL(access)(path, mode);\n+}\n+#define INIT_ACCESS COMMON_INTERCEPT_FUNCTION(access)\n+#else\n+#define INIT_ACCESS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FACCESSAT\n+INTERCEPTOR(int, faccessat, int fd, const char *path, int mode, int flags) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, faccessat, fd, path, mode, flags);\n+  if (path)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  return REAL(faccessat)(fd, path, mode, flags);\n+}\n+#define INIT_FACCESSAT COMMON_INTERCEPT_FUNCTION(faccessat)\n+#else\n+#define INIT_FACCESSAT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETGROUPLIST\n+INTERCEPTOR(int, getgrouplist, const char *name, u32 basegid, u32 *groups,\n+            int *ngroups) {\n+  void *ctx;\n+  int res;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgrouplist, name, basegid, groups, ngroups);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  if (ngroups)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, ngroups, sizeof(*ngroups));\n+  res = REAL(getgrouplist)(name, basegid, groups, ngroups);\n+  if (!res && groups && ngroups) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, groups, sizeof(*groups) * (*ngroups));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ngroups, sizeof(*ngroups));\n+  }\n+  return res;\n+}\n+\n+#define INIT_GETGROUPLIST COMMON_INTERCEPT_FUNCTION(getgrouplist);\n+#else\n+#define INIT_GETGROUPLIST\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETGROUPMEMBERSHIP\n+INTERCEPTOR(int, getgroupmembership, const char *name, u32 basegid, u32 *groups,\n+            int maxgrp, int *ngroups) {\n+  void *ctx;\n+  int res;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getgroupmembership, name, basegid, groups,\n+                           maxgrp, ngroups);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  res = REAL(getgroupmembership)(name, basegid, groups, maxgrp, ngroups);\n+  if (!res && groups && ngroups) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, groups, sizeof(*groups) * (*ngroups));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ngroups, sizeof(*ngroups));\n+  }\n+  return res;\n+}\n+\n+#define INIT_GETGROUPMEMBERSHIP COMMON_INTERCEPT_FUNCTION(getgroupmembership);\n+#else\n+#define INIT_GETGROUPMEMBERSHIP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_READLINK\n+INTERCEPTOR(SSIZE_T, readlink, const char *path, char *buf, SIZE_T bufsiz) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readlink, path, buf, bufsiz);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  SSIZE_T res = REAL(readlink)(path, buf, bufsiz);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res);\n+  return res;\n+}\n+\n+#define INIT_READLINK COMMON_INTERCEPT_FUNCTION(readlink)\n+#else\n+#define INIT_READLINK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_READLINKAT\n+INTERCEPTOR(SSIZE_T, readlinkat, int dirfd, const char *path, char *buf,\n+            SIZE_T bufsiz) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, readlinkat, dirfd, path, buf, bufsiz);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  SSIZE_T res = REAL(readlinkat)(dirfd, path, buf, bufsiz);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res);\n+  return res;\n+}\n+\n+#define INIT_READLINKAT COMMON_INTERCEPT_FUNCTION(readlinkat)\n+#else\n+#define INIT_READLINKAT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_NAME_TO_HANDLE_AT\n+INTERCEPTOR(int, name_to_handle_at, int dirfd, const char *pathname,\n+            struct file_handle *handle, int *mount_id, int flags) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, name_to_handle_at, dirfd, pathname, handle,\n+                           mount_id, flags);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, pathname, REAL(strlen)(pathname) + 1);\n+\n+  __sanitizer_file_handle *sanitizer_handle =\n+      reinterpret_cast<__sanitizer_file_handle*>(handle);\n+  COMMON_INTERCEPTOR_READ_RANGE(\n+      ctx, &sanitizer_handle->handle_bytes,\n+      sizeof(sanitizer_handle->handle_bytes));\n+\n+  int res = REAL(name_to_handle_at)(dirfd, pathname, handle, mount_id, flags);\n+  if (!res) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(\n+        ctx, &sanitizer_handle->handle_bytes,\n+        sizeof(sanitizer_handle->handle_bytes));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(\n+        ctx, &sanitizer_handle->handle_type,\n+        sizeof(sanitizer_handle->handle_type));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(\n+        ctx, &sanitizer_handle->f_handle, sanitizer_handle->handle_bytes);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mount_id, sizeof(*mount_id));\n+  }\n+  return res;\n+}\n+\n+#define INIT_NAME_TO_HANDLE_AT COMMON_INTERCEPT_FUNCTION(name_to_handle_at)\n+#else\n+#define INIT_NAME_TO_HANDLE_AT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_OPEN_BY_HANDLE_AT\n+INTERCEPTOR(int, open_by_handle_at, int mount_fd, struct file_handle* handle,\n+            int flags) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, open_by_handle_at, mount_fd, handle, flags);\n+\n+  __sanitizer_file_handle *sanitizer_handle =\n+      reinterpret_cast<__sanitizer_file_handle*>(handle);\n+  COMMON_INTERCEPTOR_READ_RANGE(\n+      ctx, &sanitizer_handle->handle_bytes,\n+      sizeof(sanitizer_handle->handle_bytes));\n+  COMMON_INTERCEPTOR_READ_RANGE(\n+      ctx, &sanitizer_handle->handle_type,\n+      sizeof(sanitizer_handle->handle_type));\n+  COMMON_INTERCEPTOR_READ_RANGE(\n+      ctx, &sanitizer_handle->f_handle, sanitizer_handle->handle_bytes);\n+\n+  return REAL(open_by_handle_at)(mount_fd, handle, flags);\n+}\n+\n+#define INIT_OPEN_BY_HANDLE_AT COMMON_INTERCEPT_FUNCTION(open_by_handle_at)\n+#else\n+#define INIT_OPEN_BY_HANDLE_AT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRLCPY\n+INTERCEPTOR(SIZE_T, strlcpy, char *dst, char *src, SIZE_T size) {\n+  void *ctx;\n+  SIZE_T res;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strlcpy, dst, src, size);\n+  if (src) {\n+    // Keep strnlen as macro argument, as macro may ignore it.\n+    COMMON_INTERCEPTOR_READ_STRING(\n+        ctx, src, Min(internal_strnlen(src, size), size - 1) + 1);\n+  }\n+  res = REAL(strlcpy)(dst, src, size);\n+  COMMON_INTERCEPTOR_COPY_STRING(ctx, dst, src, REAL(strlen)(dst) + 1);\n+  return res;\n+}\n+\n+INTERCEPTOR(SIZE_T, strlcat, char *dst, char *src, SIZE_T size) {\n+  void *ctx;\n+  SIZE_T len = 0;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strlcat, dst, src, size);\n+  // src is checked in the strlcpy() interceptor\n+  if (dst) {\n+    len = internal_strnlen(dst, size);\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, dst, Min(len, size - 1) + 1);\n+  }\n+  // Reuse the rest of the code in the strlcpy() interceptor\n+  return WRAP(strlcpy)(dst + len, src, size - len) + len;\n+}\n+#define INIT_STRLCPY \\\n+  COMMON_INTERCEPT_FUNCTION(strlcpy); \\\n+  COMMON_INTERCEPT_FUNCTION(strlcat);\n+#else\n+#define INIT_STRLCPY\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MMAP\n+INTERCEPTOR(void *, mmap, void *addr, SIZE_T sz, int prot, int flags, int fd,\n+            OFF_T off) {\n+  void *ctx;\n+  if (common_flags()->detect_write_exec)\n+    ReportMmapWriteExec(prot);\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return (void *)internal_mmap(addr, sz, prot, flags, fd, off);\n+  COMMON_INTERCEPTOR_ENTER(ctx, mmap, addr, sz, prot, flags, fd, off);\n+  COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap, addr, sz, prot, flags, fd, off);\n+}\n+\n+INTERCEPTOR(int, mprotect, void *addr, SIZE_T sz, int prot) {\n+  void *ctx;\n+  if (common_flags()->detect_write_exec)\n+    ReportMmapWriteExec(prot);\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return (int)internal_mprotect(addr, sz, prot);\n+  COMMON_INTERCEPTOR_ENTER(ctx, mprotect, addr, sz, prot);\n+  MprotectMallocZones(addr, prot);\n+  return REAL(mprotect)(addr, sz, prot);\n+}\n+#define INIT_MMAP                                                              \\\n+  COMMON_INTERCEPT_FUNCTION(mmap);                                             \\\n+  COMMON_INTERCEPT_FUNCTION(mprotect);\n+#else\n+#define INIT_MMAP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MMAP64\n+INTERCEPTOR(void *, mmap64, void *addr, SIZE_T sz, int prot, int flags, int fd,\n+            OFF64_T off) {\n+  void *ctx;\n+  if (common_flags()->detect_write_exec)\n+    ReportMmapWriteExec(prot);\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return (void *)internal_mmap(addr, sz, prot, flags, fd, off);\n+  COMMON_INTERCEPTOR_ENTER(ctx, mmap64, addr, sz, prot, flags, fd, off);\n+  COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap64, addr, sz, prot, flags, fd, off);\n+}\n+#define INIT_MMAP64 COMMON_INTERCEPT_FUNCTION(mmap64);\n+#else\n+#define INIT_MMAP64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_DEVNAME\n+INTERCEPTOR(char *, devname, u64 dev, u32 type) {\n+  void *ctx;\n+  char *name;\n+  COMMON_INTERCEPTOR_ENTER(ctx, devname, dev, type);\n+  name = REAL(devname)(dev, type);\n+  if (name)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  return name;\n+}\n+#define INIT_DEVNAME COMMON_INTERCEPT_FUNCTION(devname);\n+#else\n+#define INIT_DEVNAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_DEVNAME_R\n+INTERCEPTOR(int, devname_r, u64 dev, u32 type, char *path, uptr len) {\n+  void *ctx;\n+  int res;\n+  COMMON_INTERCEPTOR_ENTER(ctx, devname_r, dev, type, path, len);\n+  res = REAL(devname_r)(dev, type, path, len);\n+  if (!res)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  return res;\n+}\n+#define INIT_DEVNAME_R COMMON_INTERCEPT_FUNCTION(devname_r);\n+#else\n+#define INIT_DEVNAME_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_FGETLN\n+INTERCEPTOR(char *, fgetln, __sanitizer_FILE *stream, SIZE_T *len) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fgetln, stream, len);\n+  char *str = REAL(fgetln)(stream, len);\n+  if (str && len) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, len, sizeof(*len));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, *len);\n+  }\n+  return str;\n+}\n+#define INIT_FGETLN COMMON_INTERCEPT_FUNCTION(fgetln)\n+#else\n+#define INIT_FGETLN\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STRMODE\n+INTERCEPTOR(void, strmode, u32 mode, char *bp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strmode, mode, bp);\n+  REAL(strmode)(mode, bp);\n+  if (bp)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, bp, REAL(strlen)(bp) + 1);\n+}\n+#define INIT_STRMODE COMMON_INTERCEPT_FUNCTION(strmode)\n+#else\n+#define INIT_STRMODE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_TTYENT\n+INTERCEPTOR(struct __sanitizer_ttyent *, getttyent, void) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getttyent);\n+  struct __sanitizer_ttyent *ttyent = REAL(getttyent)();\n+  if (ttyent)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ttyent, struct_ttyent_sz);\n+  return ttyent;\n+}\n+INTERCEPTOR(struct __sanitizer_ttyent *, getttynam, char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getttynam, name);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  struct __sanitizer_ttyent *ttyent = REAL(getttynam)(name);\n+  if (ttyent)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ttyent, struct_ttyent_sz);\n+  return ttyent;\n+}\n+INTERCEPTOR(int, setttyentpath, char *path) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, setttyentpath, path);\n+  if (path)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  return REAL(setttyentpath)(path);\n+}\n+#define INIT_TTYENT \\\n+  COMMON_INTERCEPT_FUNCTION(getttyent); \\\n+  COMMON_INTERCEPT_FUNCTION(getttynam); \\\n+  COMMON_INTERCEPT_FUNCTION(setttyentpath)\n+#else\n+#define INIT_TTYENT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PROTOENT\n+INTERCEPTOR(struct __sanitizer_protoent *, getprotoent) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotoent);\n+  struct __sanitizer_protoent *p = REAL(getprotoent)();\n+  if (p) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n+\n+    SIZE_T pp_size = 1; // One handles the trailing \\0\n+\n+    for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n+       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n+                                   pp_size * sizeof(char **));\n+  }\n+  return p;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_protoent *, getprotobyname, const char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotobyname, name);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  struct __sanitizer_protoent *p = REAL(getprotobyname)(name);\n+  if (p) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n+\n+    SIZE_T pp_size = 1; // One handles the trailing \\0\n+\n+    for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n+       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n+                                   pp_size * sizeof(char **));\n+  }\n+  return p;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_protoent *, getprotobynumber, int proto) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotobynumber, proto);\n+  struct __sanitizer_protoent *p = REAL(getprotobynumber)(proto);\n+  if (p) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n+\n+    SIZE_T pp_size = 1; // One handles the trailing \\0\n+\n+    for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n+       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n+                                   pp_size * sizeof(char **));\n+  }\n+  return p;\n+}\n+#define INIT_PROTOENT \\\n+  COMMON_INTERCEPT_FUNCTION(getprotoent); \\\n+  COMMON_INTERCEPT_FUNCTION(getprotobyname); \\\n+  COMMON_INTERCEPT_FUNCTION(getprotobynumber)\n+#else\n+#define INIT_PROTOENT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_NETENT\n+INTERCEPTOR(struct __sanitizer_netent *, getnetent) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getnetent);\n+  struct __sanitizer_netent *n = REAL(getnetent)();\n+  if (n) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_name, REAL(strlen)(n->n_name) + 1);\n+\n+    SIZE_T nn_size = 1; // One handles the trailing \\0\n+\n+    for (char **nn = n->n_aliases; *nn; ++nn, ++nn_size)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *nn, REAL(strlen)(*nn) + 1);\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_aliases,\n+                                   nn_size * sizeof(char **));\n+  }\n+  return n;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_netent *, getnetbyname, const char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getnetbyname, name);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  struct __sanitizer_netent *n = REAL(getnetbyname)(name);\n+  if (n) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_name, REAL(strlen)(n->n_name) + 1);\n+\n+    SIZE_T nn_size = 1; // One handles the trailing \\0\n+\n+    for (char **nn = n->n_aliases; *nn; ++nn, ++nn_size)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *nn, REAL(strlen)(*nn) + 1);\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_aliases,\n+                                   nn_size * sizeof(char **));\n+  }\n+  return n;\n+}\n+\n+INTERCEPTOR(struct __sanitizer_netent *, getnetbyaddr, u32 net, int type) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getnetbyaddr, net, type);\n+  struct __sanitizer_netent *n = REAL(getnetbyaddr)(net, type);\n+  if (n) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_name, REAL(strlen)(n->n_name) + 1);\n+\n+    SIZE_T nn_size = 1; // One handles the trailing \\0\n+\n+    for (char **nn = n->n_aliases; *nn; ++nn, ++nn_size)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *nn, REAL(strlen)(*nn) + 1);\n+\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_aliases,\n+                                   nn_size * sizeof(char **));\n+  }\n+  return n;\n+}\n+#define INIT_NETENT \\\n+  COMMON_INTERCEPT_FUNCTION(getnetent); \\\n+  COMMON_INTERCEPT_FUNCTION(getnetbyname); \\\n+  COMMON_INTERCEPT_FUNCTION(getnetbyaddr)\n+#else\n+#define INIT_NETENT\n+#endif\n+\n static void InitializeCommonInterceptors() {\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n   interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n \n+  INIT_MMAP;\n+  INIT_MMAP64;\n   INIT_TEXTDOMAIN;\n   INIT_STRLEN;\n   INIT_STRNLEN;\n@@ -6273,6 +7256,8 @@ static void InitializeCommonInterceptors() {\n   INIT_STRSPN;\n   INIT_STRTOK;\n   INIT_STRPBRK;\n+  INIT_STRXFRM;\n+  INIT___STRXFRM_L;\n   INIT_MEMSET;\n   INIT_MEMMOVE;\n   INIT_MEMCPY;\n@@ -6294,6 +7279,9 @@ static void InitializeCommonInterceptors() {\n   INIT_WRITEV;\n   INIT_PWRITEV;\n   INIT_PWRITEV64;\n+  INIT_FGETS;\n+  INIT_FPUTS;\n+  INIT_PUTS;\n   INIT_PRCTL;\n   INIT_LOCALTIME_AND_FRIENDS;\n   INIT_STRPTIME;\n@@ -6314,6 +7302,7 @@ static void InitializeCommonInterceptors() {\n   INIT_GETITIMER;\n   INIT_TIME;\n   INIT_GLOB;\n+  INIT_GLOB64;\n   INIT_WAIT;\n   INIT_WAIT4;\n   INIT_INET;\n@@ -6322,16 +7311,20 @@ static void InitializeCommonInterceptors() {\n   INIT_GETNAMEINFO;\n   INIT_GETSOCKNAME;\n   INIT_GETHOSTBYNAME;\n+  INIT_GETHOSTBYNAME2;\n   INIT_GETHOSTBYNAME_R;\n   INIT_GETHOSTBYNAME2_R;\n   INIT_GETHOSTBYADDR_R;\n   INIT_GETHOSTENT_R;\n   INIT_GETSOCKOPT;\n   INIT_ACCEPT;\n   INIT_ACCEPT4;\n+  INIT_PACCEPT;\n   INIT_MODF;\n   INIT_RECVMSG;\n   INIT_SENDMSG;\n+  INIT_RECVMMSG;\n+  INIT_SENDMMSG;\n   INIT_GETPEERNAME;\n   INIT_IOCTL;\n   INIT_INET_ATON;\n@@ -6373,6 +7366,11 @@ static void InitializeCommonInterceptors() {\n   INIT__EXIT;\n   INIT_PTHREAD_MUTEX_LOCK;\n   INIT_PTHREAD_MUTEX_UNLOCK;\n+  INIT___PTHREAD_MUTEX_LOCK;\n+  INIT___PTHREAD_MUTEX_UNLOCK;\n+  INIT___LIBC_MUTEX_LOCK;\n+  INIT___LIBC_MUTEX_UNLOCK;\n+  INIT___LIBC_THR_SETCANCELSTATE;\n   INIT_GETMNTENT;\n   INIT_GETMNTENT_R;\n   INIT_STATFS;\n@@ -6386,6 +7384,7 @@ static void InitializeCommonInterceptors() {\n   INIT_SHMCTL;\n   INIT_RANDOM_R;\n   INIT_PTHREAD_ATTR_GET;\n+  INIT_PTHREAD_ATTR_GET_SCHED;\n   INIT_PTHREAD_ATTR_GETINHERITSCHED;\n   INIT_PTHREAD_ATTR_GETAFFINITY_NP;\n   INIT_PTHREAD_MUTEXATTR_GETPSHARED;\n@@ -6404,6 +7403,7 @@ static void InitializeCommonInterceptors() {\n   INIT_TTYNAME_R;\n   INIT_TEMPNAM;\n   INIT_PTHREAD_SETNAME_NP;\n+  INIT_PTHREAD_GETNAME_NP;\n   INIT_SINCOS;\n   INIT_REMQUO;\n   INIT_LGAMMA;\n@@ -6448,6 +7448,7 @@ static void InitializeCommonInterceptors() {\n   INIT_SEND_SENDTO;\n   INIT_STAT;\n   INIT_EVENTFD_READ_WRITE;\n+  INIT_LSTAT;\n   INIT___XSTAT;\n   INIT___XSTAT64;\n   INIT___LXSTAT;\n@@ -6458,4 +7459,29 @@ static void InitializeCommonInterceptors() {\n   INIT_GETLOADAVG;\n   INIT_WCSLEN;\n   INIT_WCSCAT;\n+  INIT_WCSXFRM;\n+  INIT___WCSXFRM_L;\n+  INIT_ACCT;\n+  INIT_USER_FROM_UID;\n+  INIT_UID_FROM_USER;\n+  INIT_GROUP_FROM_GID;\n+  INIT_GID_FROM_GROUP;\n+  INIT_ACCESS;\n+  INIT_FACCESSAT;\n+  INIT_GETGROUPLIST;\n+  INIT_GETGROUPMEMBERSHIP;\n+  INIT_READLINK;\n+  INIT_READLINKAT;\n+  INIT_NAME_TO_HANDLE_AT;\n+  INIT_OPEN_BY_HANDLE_AT;\n+  INIT_STRLCPY;\n+  INIT_DEVNAME;\n+  INIT_DEVNAME_R;\n+  INIT_FGETLN;\n+  INIT_STRMODE;\n+  INIT_TTYENT;\n+  INIT_PROTOENT;\n+  INIT_NETENT;\n+\n+  INIT___PRINTF_CHK;\n }"}, {"sha": "5408ea17c595c76d25bf0d04aa3946daaef1e1aa", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -8,6 +8,8 @@\n // Ioctl handling in common sanitizer interceptors.\n //===----------------------------------------------------------------------===//\n \n+#if !SANITIZER_NETBSD\n+\n #include \"sanitizer_flags.h\"\n \n struct ioctl_desc {\n@@ -55,7 +57,9 @@ static void ioctl_table_fill() {\n   _(SIOCGIFCONF, CUSTOM, 0);\n   _(SIOCGPGRP, WRITE, sizeof(int));\n   _(SIOCSPGRP, READ, sizeof(int));\n+#if !SANITIZER_SOLARIS\n   _(TIOCCONS, NONE, 0);\n+#endif\n   _(TIOCEXCL, NONE, 0);\n   _(TIOCGETD, WRITE, sizeof(int));\n   _(TIOCGPGRP, WRITE, pid_t_sz);\n@@ -474,7 +478,7 @@ struct ioctl_desc_compare {\n \n static void ioctl_init() {\n   ioctl_table_fill();\n-  InternalSort(&ioctl_table, ioctl_table_size, ioctl_desc_compare());\n+  Sort(ioctl_table, ioctl_table_size, ioctl_desc_compare());\n \n   bool bad = false;\n   for (unsigned i = 0; i < ioctl_table_size - 1; ++i) {\n@@ -600,3 +604,5 @@ static void ioctl_common_post(void *ctx, const ioctl_desc *desc, int res, int d,\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifc->ifc_ifcu.ifcu_req, ifc->ifc_len);\n   }\n }\n+\n+#endif"}, {"sha": "89d47bda7df2d36e4c13495831fb066d14484ab0", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -6,6 +6,7 @@\n //===----------------------------------------------------------------------===//\n // Sanitizer Common interface list.\n //===----------------------------------------------------------------------===//\n+INTERFACE_FUNCTION(__sanitizer_acquire_crash_state)\n INTERFACE_FUNCTION(__sanitizer_annotate_contiguous_container)\n INTERFACE_FUNCTION(__sanitizer_contiguous_container_find_bad_address)\n INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n@@ -32,6 +33,7 @@ INTERFACE_FUNCTION(__sanitizer_get_heap_size)\n INTERFACE_FUNCTION(__sanitizer_get_ownership)\n INTERFACE_FUNCTION(__sanitizer_get_unmapped_bytes)\n INTERFACE_FUNCTION(__sanitizer_install_malloc_and_free_hooks)\n+INTERFACE_FUNCTION(__sanitizer_purge_allocator)\n INTERFACE_FUNCTION(__sanitizer_print_memory_profile)\n INTERFACE_WEAK_FUNCTION(__sanitizer_free_hook)\n INTERFACE_WEAK_FUNCTION(__sanitizer_malloc_hook)"}, {"sha": "6a63650c81b87ea76275e1782cebabf0b4a9f4fe", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "modified", "additions": 33, "deletions": 241, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -9,94 +9,37 @@\n // run-time libraries.\n //===----------------------------------------------------------------------===//\n \n-#include \"sanitizer_common.h\"\n-\n #include \"sanitizer_allocator_interface.h\"\n-#include \"sanitizer_file.h\"\n+#include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_procmaps.h\"\n-#include \"sanitizer_report_decorator.h\"\n-#include \"sanitizer_stackdepot.h\"\n-#include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n-#if SANITIZER_POSIX\n-#include \"sanitizer_posix.h\"\n-#endif\n \n namespace __sanitizer {\n \n-#if !SANITIZER_FUCHSIA\n-\n-bool ReportFile::SupportsColors() {\n-  SpinMutexLock l(mu);\n-  ReopenIfNecessary();\n-  return SupportsColoredOutput(fd);\n-}\n-\n-static INLINE bool ReportSupportsColors() {\n-  return report_file.SupportsColors();\n-}\n-\n-#else  // SANITIZER_FUCHSIA\n-\n-// Fuchsia's logs always go through post-processing that handles colorization.\n-static INLINE bool ReportSupportsColors() { return true; }\n-\n-#endif  // !SANITIZER_FUCHSIA\n-\n-bool ColorizeReports() {\n-  // FIXME: Add proper Windows support to AnsiColorDecorator and re-enable color\n-  // printing on Windows.\n-  if (SANITIZER_WINDOWS)\n-    return false;\n-\n-  const char *flag = common_flags()->color;\n-  return internal_strcmp(flag, \"always\") == 0 ||\n-         (internal_strcmp(flag, \"auto\") == 0 && ReportSupportsColors());\n-}\n-\n-static void (*sandboxing_callback)();\n-void SetSandboxingCallback(void (*f)()) {\n-  sandboxing_callback = f;\n-}\n-\n-void ReportErrorSummary(const char *error_type, const StackTrace *stack,\n-                        const char *alt_tool_name) {\n-#if !SANITIZER_GO\n-  if (!common_flags()->print_summary)\n-    return;\n-  if (stack->size == 0) {\n-    ReportErrorSummary(error_type);\n-    return;\n-  }\n-  // Currently, we include the first stack frame into the report summary.\n-  // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n-  uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n-  SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n-  ReportErrorSummary(error_type, frame->info, alt_tool_name);\n-  frame->ClearAll();\n-#endif\n-}\n-\n static void (*SoftRssLimitExceededCallback)(bool exceeded);\n void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded)) {\n   CHECK_EQ(SoftRssLimitExceededCallback, nullptr);\n   SoftRssLimitExceededCallback = Callback;\n }\n \n #if SANITIZER_LINUX && !SANITIZER_GO\n+// Weak default implementation for when sanitizer_stackdepot is not linked in.\n+SANITIZER_WEAK_ATTRIBUTE StackDepotStats *StackDepotGetStats() {\n+  return nullptr;\n+}\n+\n void BackgroundThread(void *arg) {\n-  uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n-  uptr soft_rss_limit_mb = common_flags()->soft_rss_limit_mb;\n-  bool heap_profile = common_flags()->heap_profile;\n+  const uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n+  const uptr soft_rss_limit_mb = common_flags()->soft_rss_limit_mb;\n+  const bool heap_profile = common_flags()->heap_profile;\n   uptr prev_reported_rss = 0;\n   uptr prev_reported_stack_depot_size = 0;\n   bool reached_soft_rss_limit = false;\n   uptr rss_during_last_reported_profile = 0;\n   while (true) {\n     SleepForMillis(100);\n-    uptr current_rss_mb = GetRSS() >> 20;\n+    const uptr current_rss_mb = GetRSS() >> 20;\n     if (Verbosity()) {\n       // If RSS has grown 10% since last time, print some information.\n       if (prev_reported_rss * 11 / 10 < current_rss_mb) {\n@@ -105,13 +48,15 @@ void BackgroundThread(void *arg) {\n       }\n       // If stack depot has grown 10% since last time, print it too.\n       StackDepotStats *stack_depot_stats = StackDepotGetStats();\n-      if (prev_reported_stack_depot_size * 11 / 10 <\n-          stack_depot_stats->allocated) {\n-        Printf(\"%s: StackDepot: %zd ids; %zdM allocated\\n\",\n-               SanitizerToolName,\n-               stack_depot_stats->n_uniq_ids,\n-               stack_depot_stats->allocated >> 20);\n-        prev_reported_stack_depot_size = stack_depot_stats->allocated;\n+      if (stack_depot_stats) {\n+        if (prev_reported_stack_depot_size * 11 / 10 <\n+            stack_depot_stats->allocated) {\n+          Printf(\"%s: StackDepot: %zd ids; %zdM allocated\\n\",\n+                 SanitizerToolName,\n+                 stack_depot_stats->n_uniq_ids,\n+                 stack_depot_stats->allocated >> 20);\n+          prev_reported_stack_depot_size = stack_depot_stats->allocated;\n+        }\n       }\n     }\n     // Check RSS against the limit.\n@@ -145,127 +90,6 @@ void BackgroundThread(void *arg) {\n }\n #endif\n \n-#if !SANITIZER_FUCHSIA && !SANITIZER_GO\n-void StartReportDeadlySignal() {\n-  // Write the first message using fd=2, just in case.\n-  // It may actually fail to write in case stderr is closed.\n-  CatastrophicErrorWrite(SanitizerToolName, internal_strlen(SanitizerToolName));\n-  static const char kDeadlySignal[] = \":DEADLYSIGNAL\\n\";\n-  CatastrophicErrorWrite(kDeadlySignal, sizeof(kDeadlySignal) - 1);\n-}\n-\n-static void MaybeReportNonExecRegion(uptr pc) {\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/ true);\n-  MemoryMappedSegment segment;\n-  while (proc_maps.Next(&segment)) {\n-    if (pc >= segment.start && pc < segment.end && !segment.IsExecutable())\n-      Report(\"Hint: PC is at a non-executable region. Maybe a wild jump?\\n\");\n-  }\n-#endif\n-}\n-\n-static void PrintMemoryByte(InternalScopedString *str, const char *before,\n-                            u8 byte) {\n-  SanitizerCommonDecorator d;\n-  str->append(\"%s%s%x%x%s \", before, d.MemoryByte(), byte >> 4, byte & 15,\n-              d.Default());\n-}\n-\n-static void MaybeDumpInstructionBytes(uptr pc) {\n-  if (!common_flags()->dump_instruction_bytes || (pc < GetPageSizeCached()))\n-    return;\n-  InternalScopedString str(1024);\n-  str.append(\"First 16 instruction bytes at pc: \");\n-  if (IsAccessibleMemoryRange(pc, 16)) {\n-    for (int i = 0; i < 16; ++i) {\n-      PrintMemoryByte(&str, \"\", ((u8 *)pc)[i]);\n-    }\n-    str.append(\"\\n\");\n-  } else {\n-    str.append(\"unaccessible\\n\");\n-  }\n-  Report(\"%s\", str.data());\n-}\n-\n-static void MaybeDumpRegisters(void *context) {\n-  if (!common_flags()->dump_registers) return;\n-  SignalContext::DumpAllRegisters(context);\n-}\n-\n-static void ReportStackOverflowImpl(const SignalContext &sig, u32 tid,\n-                                    UnwindSignalStackCallbackType unwind,\n-                                    const void *unwind_context) {\n-  SanitizerCommonDecorator d;\n-  Printf(\"%s\", d.Warning());\n-  static const char kDescription[] = \"stack-overflow\";\n-  Report(\"ERROR: %s: %s on address %p (pc %p bp %p sp %p T%d)\\n\",\n-         SanitizerToolName, kDescription, (void *)sig.addr, (void *)sig.pc,\n-         (void *)sig.bp, (void *)sig.sp, tid);\n-  Printf(\"%s\", d.Default());\n-  InternalScopedBuffer<BufferedStackTrace> stack_buffer(1);\n-  BufferedStackTrace *stack = stack_buffer.data();\n-  stack->Reset();\n-  unwind(sig, unwind_context, stack);\n-  stack->Print();\n-  ReportErrorSummary(kDescription, stack);\n-}\n-\n-static void ReportDeadlySignalImpl(const SignalContext &sig, u32 tid,\n-                                   UnwindSignalStackCallbackType unwind,\n-                                   const void *unwind_context) {\n-  SanitizerCommonDecorator d;\n-  Printf(\"%s\", d.Warning());\n-  const char *description = sig.Describe();\n-  Report(\"ERROR: %s: %s on unknown address %p (pc %p bp %p sp %p T%d)\\n\",\n-         SanitizerToolName, description, (void *)sig.addr, (void *)sig.pc,\n-         (void *)sig.bp, (void *)sig.sp, tid);\n-  Printf(\"%s\", d.Default());\n-  if (sig.pc < GetPageSizeCached())\n-    Report(\"Hint: pc points to the zero page.\\n\");\n-  if (sig.is_memory_access) {\n-    const char *access_type =\n-        sig.write_flag == SignalContext::WRITE\n-            ? \"WRITE\"\n-            : (sig.write_flag == SignalContext::READ ? \"READ\" : \"UNKNOWN\");\n-    Report(\"The signal is caused by a %s memory access.\\n\", access_type);\n-    if (sig.addr < GetPageSizeCached())\n-      Report(\"Hint: address points to the zero page.\\n\");\n-  }\n-  MaybeReportNonExecRegion(sig.pc);\n-  InternalScopedBuffer<BufferedStackTrace> stack_buffer(1);\n-  BufferedStackTrace *stack = stack_buffer.data();\n-  stack->Reset();\n-  unwind(sig, unwind_context, stack);\n-  stack->Print();\n-  MaybeDumpInstructionBytes(sig.pc);\n-  MaybeDumpRegisters(sig.context);\n-  Printf(\"%s can not provide additional info.\\n\", SanitizerToolName);\n-  ReportErrorSummary(description, stack);\n-}\n-\n-void ReportDeadlySignal(const SignalContext &sig, u32 tid,\n-                        UnwindSignalStackCallbackType unwind,\n-                        const void *unwind_context) {\n-  if (sig.IsStackOverflow())\n-    ReportStackOverflowImpl(sig, tid, unwind, unwind_context);\n-  else\n-    ReportDeadlySignalImpl(sig, tid, unwind, unwind_context);\n-}\n-\n-void HandleDeadlySignal(void *siginfo, void *context, u32 tid,\n-                        UnwindSignalStackCallbackType unwind,\n-                        const void *unwind_context) {\n-  StartReportDeadlySignal();\n-  ScopedErrorReportLock rl;\n-  SignalContext sig(siginfo, context);\n-  ReportDeadlySignal(sig, tid, unwind, unwind_context);\n-  Report(\"ABORTING\\n\");\n-  Die();\n-}\n-\n-#endif  // !SANITIZER_FUCHSIA && !SANITIZER_GO\n-\n void WriteToSyslog(const char *msg) {\n   InternalScopedString msg_copy(kErrorMessageBufferSize);\n   msg_copy.append(\"%s\", msg);\n@@ -274,14 +98,17 @@ void WriteToSyslog(const char *msg) {\n \n   // Print one line at a time.\n   // syslog, at least on Android, has an implicit message length limit.\n-  do {\n-    q = internal_strchr(p, '\\n');\n-    if (q)\n-      *q = '\\0';\n+  while ((q = internal_strchr(p, '\\n'))) {\n+    *q = '\\0';\n+    WriteOneLineToSyslog(p);\n+    p = q + 1;\n+  }\n+  // Print remaining characters, if there are any.\n+  // Note that this will add an extra newline at the end.\n+  // FIXME: buffer extra output. This would need a thread-local buffer, which\n+  // on Android requires plugging into the tools (ex. ASan's) Thread class.\n+  if (*p)\n     WriteOneLineToSyslog(p);\n-    if (q)\n-      p = q + 1;\n-  } while (q);\n }\n \n void MaybeStartBackgroudThread() {\n@@ -296,51 +123,16 @@ void MaybeStartBackgroudThread() {\n #endif\n }\n \n-static atomic_uintptr_t reporting_thread = {0};\n-\n-ScopedErrorReportLock::ScopedErrorReportLock() {\n-  uptr current = GetThreadSelf();\n-  for (;;) {\n-    uptr expected = 0;\n-    if (atomic_compare_exchange_strong(&reporting_thread, &expected, current,\n-                                       memory_order_relaxed)) {\n-      // We've claimed reporting_thread so proceed.\n-      CommonSanitizerReportMutex.Lock();\n-      return;\n-    }\n-\n-    if (expected == current) {\n-      // This is either asynch signal or nested error during error reporting.\n-      // Fail simple to avoid deadlocks in Report().\n-\n-      // Can't use Report() here because of potential deadlocks in nested\n-      // signal handlers.\n-      CatastrophicErrorWrite(SanitizerToolName,\n-                             internal_strlen(SanitizerToolName));\n-      static const char msg[] = \": nested bug in the same thread, aborting.\\n\";\n-      CatastrophicErrorWrite(msg, sizeof(msg) - 1);\n-\n-      internal__exit(common_flags()->exitcode);\n-    }\n-\n-    internal_sched_yield();\n-  }\n-}\n-\n-ScopedErrorReportLock::~ScopedErrorReportLock() {\n-  CommonSanitizerReportMutex.Unlock();\n-  atomic_store_relaxed(&reporting_thread, 0);\n-}\n-\n-void ScopedErrorReportLock::CheckLocked() {\n-  CommonSanitizerReportMutex.CheckLocked();\n+static void (*sandboxing_callback)();\n+void SetSandboxingCallback(void (*f)()) {\n+  sandboxing_callback = f;\n }\n \n }  // namespace __sanitizer\n \n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_sandbox_on_notify,\n                              __sanitizer_sandbox_arguments *args) {\n-  __sanitizer::PrepareForSandboxing(args);\n+  __sanitizer::PlatformPrepareForSandboxing(args);\n   if (__sanitizer::sandboxing_callback)\n     __sanitizer::sandboxing_callback();\n }"}, {"sha": "7f92bdcec244ce64cb3dc464e5aae6541532f533", "filename": "libsanitizer/sanitizer_common/sanitizer_common_nolibc.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -19,7 +19,6 @@ namespace __sanitizer {\n // bypassing libc.\n #if !SANITIZER_WINDOWS\n #if SANITIZER_LINUX\n-bool ShouldLogAfterPrintf() { return false; }\n void LogMessageOnPrintf(const char *str) {}\n #endif\n void WriteToSyslog(const char *buffer) {}"}, {"sha": "8426aad432a0af279ae5215ba938715bb5fc4b90", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_fuchsia.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -1,9 +1,9 @@\n-//===-- sanitizer_coverage_fuchsia.cc ------------------------------------===//\n+//===-- sanitizer_coverage_fuchsia.cc -------------------------------------===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n-//===---------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===//\n //\n // Sanitizer Coverage Controller for Trace PC Guard, Fuchsia-specific version.\n //\n@@ -47,7 +47,7 @@ constexpr const char kSancovSinkName[] = \"sancov\";\n \n // Collects trace-pc guard coverage.\n // This class relies on zero-initialization.\n-class TracePcGuardController {\n+class TracePcGuardController final {\n  public:\n   // For each PC location being tracked, there is a u32 reserved in global\n   // data called the \"guard\".  At startup, we assign each guard slot a\n@@ -111,11 +111,11 @@ class TracePcGuardController {\n   // We can always spare the 32G of address space.\n   static constexpr size_t MappingSize = sizeof(uptr) << 32;\n \n-  BlockingMutex setup_lock_;\n-  uptr *array_;\n-  u32 next_index_;\n-  zx_handle_t vmo_;\n-  char vmo_name_[ZX_MAX_NAME_LEN];\n+  BlockingMutex setup_lock_ = BlockingMutex(LINKER_INITIALIZED);\n+  uptr *array_ = nullptr;\n+  u32 next_index_ = 0;\n+  zx_handle_t vmo_ = {};\n+  char vmo_name_[ZX_MAX_NAME_LEN] = {};\n \n   size_t DataSize() const { return next_index_ * sizeof(uintptr_t); }\n \n@@ -145,8 +145,8 @@ class TracePcGuardController {\n       // any multi-thread synchronization issues with that.\n       uintptr_t mapping;\n       status =\n-          _zx_vmar_map(_zx_vmar_root_self(), 0, vmo_, 0, MappingSize,\n-                       ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE, &mapping);\n+          _zx_vmar_map(_zx_vmar_root_self(), ZX_VM_PERM_READ | ZX_VM_PERM_WRITE,\n+                       0, vmo_, 0, MappingSize, &mapping);\n       CHECK_EQ(status, ZX_OK);\n \n       // Hereafter other threads are free to start storing into"}, {"sha": "84db6474ab5a944c5dfed6d72b59f6c82cee7a2f", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -14,7 +14,6 @@\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n #include \"sanitizer_file.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n using namespace __sanitizer;\n \n@@ -62,7 +61,7 @@ static void SanitizerDumpCoverage(const uptr* unsorted_pcs, uptr len) {\n   uptr* pcs = static_cast<uptr*>(InternalAlloc(len * sizeof(uptr)));\n \n   internal_memcpy(pcs, unsorted_pcs, len * sizeof(uptr));\n-  SortArray(pcs, len);\n+  Sort(pcs, len);\n \n   bool module_found = false;\n   uptr last_base = 0;"}, {"sha": "12832fcc90e62c21972622d7a354547b9f232843", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_sections.cc", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -5,16 +5,57 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file defines delimiters for Sanitizer Coverage's section.\n+// This file defines delimiters for Sanitizer Coverage's section. It contains\n+// Windows specific tricks to coax the linker into giving us the start and stop\n+// addresses of a section, as ELF linkers can do, to get the size of certain\n+// arrays. According to https://msdn.microsoft.com/en-us/library/7977wcck.aspx\n+// sections with the same name before \"$\" are sorted alphabetically by the\n+// string that comes after \"$\" and merged into one section. We take advantage\n+// of this by putting data we want the size of into the middle (M) of a section,\n+// by using the letter \"M\" after \"$\". We get the start of this data (ie:\n+// __start_section_name) by making the start variable come at the start of the\n+// section (using the letter A after \"$\"). We do the same to get the end of the\n+// data by using the letter \"Z\" after \"$\" to make the end variable come after\n+// the data. Note that because of our technique the address of the start\n+// variable is actually the address of data that comes before our middle\n+// section. We also need to prevent the linker from adding any padding. Each\n+// technique we use for this is explained in the comments below.\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n #include <stdint.h>\n-#pragma section(\".SCOV$A\", read, write)  // NOLINT\n-#pragma section(\".SCOV$Z\", read, write)  // NOLINT\n extern \"C\" {\n-__declspec(allocate(\".SCOV$A\")) uint32_t __start___sancov_guards = 0;\n-__declspec(allocate(\".SCOV$Z\")) uint32_t __stop___sancov_guards = 0;\n+// The Guard array and counter array should both be merged into the .data\n+// section to reduce the number of PE sections However, because PCTable is\n+// constant it should be merged with the .rdata section.\n+#pragma section(\".SCOV$GA\", read, write)  // NOLINT\n+// Use align(1) to avoid adding any padding that will mess up clients trying to\n+// determine the start and end of the array.\n+__declspec(allocate(\".SCOV$GA\")) __declspec(align(1)) uint64_t\n+    __start___sancov_guards = 0;\n+#pragma section(\".SCOV$GZ\", read, write)  // NOLINT\n+__declspec(allocate(\".SCOV$GZ\")) __declspec(align(1)) uint64_t\n+    __stop___sancov_guards = 0;\n+\n+#pragma section(\".SCOV$CA\", read, write)  // NOLINT\n+__declspec(allocate(\".SCOV$CA\")) __declspec(align(1)) uint64_t\n+    __start___sancov_cntrs = 0;\n+#pragma section(\".SCOV$CZ\", read, write)  // NOLINT\n+__declspec(allocate(\".SCOV$CZ\")) __declspec(align(1)) uint64_t\n+    __stop___sancov_cntrs = 0;\n+\n+#pragma comment(linker, \"/MERGE:.SCOV=.data\")\n+\n+// Use uint64_t so there won't be any issues if the linker tries to word align\n+// the pc array.\n+#pragma section(\".SCOVP$A\", read)  // NOLINT\n+__declspec(allocate(\".SCOVP$A\")) __declspec(align(1)) uint64_t\n+    __start___sancov_pcs = 0;\n+#pragma section(\".SCOVP$Z\", read)  // NOLINT\n+__declspec(allocate(\".SCOVP$Z\")) __declspec(align(1)) uint64_t\n+    __stop___sancov_pcs = 0;\n+\n+#pragma comment(linker, \"/MERGE:.SCOVP=.rdata\")\n }\n-#endif // SANITIZER_WINDOWS\n+#endif  // SANITIZER_WINDOWS"}, {"sha": "fb4785317f0adb7e71b83b3c879c90cecb5a0889", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector2.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -109,7 +109,7 @@ struct DD : public DDetector {\n \n   SpinMutex mtx;\n   InternalMmapVector<u32> free_id;\n-  int id_gen;\n+  int id_gen = 0;\n };\n \n DDetector *DDetector::Create(const DDFlags *flags) {\n@@ -118,11 +118,7 @@ DDetector *DDetector::Create(const DDFlags *flags) {\n   return new(mem) DD(flags);\n }\n \n-DD::DD(const DDFlags *flags)\n-    : flags(*flags)\n-    , free_id(1024) {\n-  id_gen = 0;\n-}\n+DD::DD(const DDFlags *flags) : flags(*flags) { free_id.reserve(1024); }\n \n DDPhysicalThread* DD::CreatePhysicalThread() {\n   DDPhysicalThread *pt = (DDPhysicalThread*)MmapOrDie(sizeof(DDPhysicalThread),"}, {"sha": "d67cc24da1a98741a615574305d49477d7cd84f9", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -22,8 +22,11 @@\n \n #if SANITIZER_FREEBSD || SANITIZER_MAC\n #  define __errno_location __error\n-#elif SANITIZER_ANDROID || SANITIZER_NETBSD\n+#elif SANITIZER_ANDROID || SANITIZER_NETBSD || SANITIZER_OPENBSD || \\\n+  SANITIZER_RTEMS\n #  define __errno_location __errno\n+#elif SANITIZER_SOLARIS\n+#  define __errno_location ___errno\n #elif SANITIZER_WINDOWS\n #  define __errno_location _errno\n #endif"}, {"sha": "61fcc9f90d776f8ad0eee0f41af0f77c20ca6143", "filename": "libsanitizer/sanitizer_common/sanitizer_file.cc", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -93,32 +93,40 @@ void ReportFile::SetReportPath(const char *path) {\n \n bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n                       uptr *read_len, uptr max_len, error_t *errno_p) {\n-  uptr PageSize = GetPageSizeCached();\n-  uptr kMinFileLen = PageSize;\n   *buff = nullptr;\n   *buff_size = 0;\n   *read_len = 0;\n+  if (!max_len)\n+    return true;\n+  uptr PageSize = GetPageSizeCached();\n+  uptr kMinFileLen = Min(PageSize, max_len);\n+\n   // The files we usually open are not seekable, so try different buffer sizes.\n-  for (uptr size = kMinFileLen; size <= max_len; size *= 2) {\n-    fd_t fd = OpenFile(file_name, RdOnly, errno_p);\n-    if (fd == kInvalidFd) return false;\n+  for (uptr size = kMinFileLen;; size = Min(size * 2, max_len)) {\n     UnmapOrDie(*buff, *buff_size);\n     *buff = (char*)MmapOrDie(size, __func__);\n     *buff_size = size;\n+    fd_t fd = OpenFile(file_name, RdOnly, errno_p);\n+    if (fd == kInvalidFd) {\n+      UnmapOrDie(*buff, *buff_size);\n+      return false;\n+    }\n     *read_len = 0;\n     // Read up to one page at a time.\n     bool reached_eof = false;\n-    while (*read_len + PageSize <= size) {\n+    while (*read_len < size) {\n       uptr just_read;\n-      if (!ReadFromFile(fd, *buff + *read_len, PageSize, &just_read, errno_p)) {\n+      if (!ReadFromFile(fd, *buff + *read_len, size - *read_len, &just_read,\n+                        errno_p)) {\n         UnmapOrDie(*buff, *buff_size);\n+        CloseFile(fd);\n         return false;\n       }\n-      if (just_read == 0) {\n+      *read_len += just_read;\n+      if (just_read == 0 || *read_len == max_len) {\n         reached_eof = true;\n         break;\n       }\n-      *read_len += just_read;\n     }\n     CloseFile(fd);\n     if (reached_eof)  // We've read the whole file.\n@@ -127,6 +135,37 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n   return true;\n }\n \n+bool ReadFileToVector(const char *file_name,\n+                      InternalMmapVectorNoCtor<char> *buff, uptr max_len,\n+                      error_t *errno_p) {\n+  buff->clear();\n+  if (!max_len)\n+    return true;\n+  uptr PageSize = GetPageSizeCached();\n+  fd_t fd = OpenFile(file_name, RdOnly, errno_p);\n+  if (fd == kInvalidFd)\n+    return false;\n+  uptr read_len = 0;\n+  while (read_len < max_len) {\n+    if (read_len >= buff->size())\n+      buff->resize(Min(Max(PageSize, read_len * 2), max_len));\n+    CHECK_LT(read_len, buff->size());\n+    CHECK_LE(buff->size(), max_len);\n+    uptr just_read;\n+    if (!ReadFromFile(fd, buff->data() + read_len, buff->size() - read_len,\n+                      &just_read, errno_p)) {\n+      CloseFile(fd);\n+      return false;\n+    }\n+    read_len += just_read;\n+    if (!just_read)\n+      break;\n+  }\n+  CloseFile(fd);\n+  buff->resize(read_len);\n+  return true;\n+}\n+\n static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';\n \n char *FindPathToBinary(const char *name) {\n@@ -138,7 +177,7 @@ char *FindPathToBinary(const char *name) {\n   if (!path)\n     return nullptr;\n   uptr name_len = internal_strlen(name);\n-  InternalScopedBuffer<char> buffer(kMaxPathLength);\n+  InternalMmapVector<char> buffer(kMaxPathLength);\n   const char *beg = path;\n   while (true) {\n     const char *end = internal_strchrnul(beg, kPathSeparator);"}, {"sha": "6bf3fedf2fd61550348d7bd6683587621b7372a0", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -79,7 +79,7 @@ inline bool FlagHandler<const char *>::Parse(const char *value) {\n \n template <>\n inline bool FlagHandler<int>::Parse(const char *value) {\n-  char *value_end;\n+  const char *value_end;\n   *t_ = internal_simple_strtoll(value, &value_end, 10);\n   bool ok = *value_end == 0;\n   if (!ok) Printf(\"ERROR: Invalid value for int option: '%s'\\n\", value);\n@@ -88,7 +88,7 @@ inline bool FlagHandler<int>::Parse(const char *value) {\n \n template <>\n inline bool FlagHandler<uptr>::Parse(const char *value) {\n-  char *value_end;\n+  const char *value_end;\n   *t_ = internal_simple_strtoll(value, &value_end, 10);\n   bool ok = *value_end == 0;\n   if (!ok) Printf(\"ERROR: Invalid value for uptr option: '%s'\\n\", value);"}, {"sha": "cbd00026c1bc953a4b375186429b20a369d809b6", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -20,14 +20,6 @@ namespace __sanitizer {\n \n CommonFlags common_flags_dont_use;\n \n-struct FlagDescription {\n-  const char *name;\n-  const char *description;\n-  FlagDescription *next;\n-};\n-\n-IntrusiveList<FlagDescription> flag_descriptions;\n-\n void CommonFlags::SetDefaults() {\n #define COMMON_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n #include \"sanitizer_flags.inc\""}, {"sha": "a62dbebb575cb37bffe5626d8fd5c9fb9ec1be81", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -54,12 +54,15 @@ COMMON_FLAG(\n     \"Mention name of executable when reporting error and \"\n     \"append executable name to logs (as in \\\"log_path.exe_name.pid\\\").\")\n COMMON_FLAG(\n-    bool, log_to_syslog, SANITIZER_ANDROID || SANITIZER_MAC,\n+    bool, log_to_syslog, (bool)SANITIZER_ANDROID || (bool)SANITIZER_MAC,\n     \"Write all sanitizer output to syslog in addition to other means of \"\n     \"logging.\")\n COMMON_FLAG(\n     int, verbosity, 0,\n     \"Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\")\n+COMMON_FLAG(bool, strip_env, 1,\n+            \"Whether to remove the sanitizer from DYLD_INSERT_LIBRARIES to \"\n+            \"avoid passing it to children. Default is true.\")\n COMMON_FLAG(bool, detect_leaks, !SANITIZER_MAC, \"Enable memory leak detection.\")\n COMMON_FLAG(\n     bool, leak_check_at_exit, true,\n@@ -88,6 +91,8 @@ COMMON_FLAG(HandleSignalMode, handle_abort, kHandleSignalNo,\n             COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGABRT))\n COMMON_FLAG(HandleSignalMode, handle_sigill, kHandleSignalNo,\n             COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGILL))\n+COMMON_FLAG(HandleSignalMode, handle_sigtrap, kHandleSignalNo,\n+            COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGTRAP))\n COMMON_FLAG(HandleSignalMode, handle_sigfpe, kHandleSignalYes,\n             COMMON_FLAG_HANDLE_SIGNAL_HELP(SIGFPE))\n #undef COMMON_FLAG_HANDLE_SIGNAL_HELP\n@@ -127,11 +132,12 @@ COMMON_FLAG(uptr, soft_rss_limit_mb, 0,\n             \" This limit does not affect memory allocations other than\"\n             \" malloc/new.\")\n COMMON_FLAG(bool, heap_profile, false, \"Experimental heap profiler, asan-only\")\n-COMMON_FLAG(s32, allocator_release_to_os_interval_ms, kReleaseToOSIntervalNever,\n-            \"Experimental. Only affects a 64-bit allocator. If set, tries to \"\n-            \"release unused memory to the OS, but not more often than this \"\n-            \"interval (in milliseconds). Negative values mean do not attempt \"\n-            \"to release memory to the OS.\\n\")\n+COMMON_FLAG(s32, allocator_release_to_os_interval_ms,\n+            ((bool)SANITIZER_FUCHSIA || (bool)SANITIZER_WINDOWS) ? -1 : 5000,\n+            \"Only affects a 64-bit allocator. If set, tries to release unused \"\n+            \"memory to the OS, but not more often than this interval (in \"\n+            \"milliseconds). Negative values mean do not attempt to release \"\n+            \"memory to the OS.\\n\")\n COMMON_FLAG(bool, can_use_proc_maps_statm, true,\n             \"If false, do not attempt to read /proc/maps/statm.\"\n             \" Mostly useful for testing sanitizers.\")\n@@ -217,7 +223,7 @@ COMMON_FLAG(bool, decorate_proc_maps, false, \"If set, decorate sanitizer \"\n COMMON_FLAG(int, exitcode, 1, \"Override the program exit status if the tool \"\n                               \"found an error\")\n COMMON_FLAG(\n-    bool, abort_on_error, SANITIZER_ANDROID || SANITIZER_MAC,\n+    bool, abort_on_error, (bool)SANITIZER_ANDROID || (bool)SANITIZER_MAC,\n     \"If set, the tool calls abort() instead of _exit() after printing the \"\n     \"error report.\")\n COMMON_FLAG(bool, suppress_equal_pcs, true,\n@@ -232,3 +238,6 @@ COMMON_FLAG(bool, dump_instruction_bytes, false,\n COMMON_FLAG(bool, dump_registers, true,\n           \"If true, dump values of CPU registers when SEGV happens. Only \"\n           \"available on OS X for now.\")\n+COMMON_FLAG(bool, detect_write_exec, false,\n+          \"If true, triggers warning when writable-executable pages requests \"\n+          \"are being made\")"}, {"sha": "6602f97b40bac7e5c87e7ef4c5ec39d64470ec4a", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cc", "status": "modified", "additions": 137, "deletions": 139, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -1,28 +1,26 @@\n-//===-- sanitizer_fuchsia.cc ---------------------------------------------===//\n+//===-- sanitizer_fuchsia.cc ----------------------------------------------===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n-//===---------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===//\n //\n // This file is shared between AddressSanitizer and other sanitizer\n // run-time libraries and implements Fuchsia-specific functions from\n // sanitizer_common.h.\n-//===---------------------------------------------------------------------===//\n+//===----------------------------------------------------------------------===//\n \n #include \"sanitizer_fuchsia.h\"\n #if SANITIZER_FUCHSIA\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_mutex.h\"\n-#include \"sanitizer_stacktrace.h\"\n \n #include <limits.h>\n #include <pthread.h>\n #include <stdlib.h>\n #include <unistd.h>\n-#include <unwind.h>\n #include <zircon/errors.h>\n #include <zircon/process.h>\n #include <zircon/syscalls.h>\n@@ -47,7 +45,9 @@ unsigned int internal_sleep(unsigned int seconds) {\n   return 0;\n }\n \n-u64 NanoTime() { return _zx_time_get(ZX_CLOCK_UTC); }\n+u64 NanoTime() { return _zx_clock_get(ZX_CLOCK_UTC); }\n+\n+u64 MonotonicNanoTime() { return _zx_clock_get(ZX_CLOCK_MONOTONIC); }\n \n uptr internal_getpid() {\n   zx_info_handle_basic_t info;\n@@ -62,7 +62,7 @@ uptr internal_getpid() {\n \n uptr GetThreadSelf() { return reinterpret_cast<uptr>(thrd_current()); }\n \n-uptr GetTid() { return GetThreadSelf(); }\n+tid_t GetTid() { return GetThreadSelf(); }\n \n void Abort() { abort(); }\n \n@@ -85,13 +85,10 @@ void GetThreadStackTopAndBottom(bool, uptr *stack_top, uptr *stack_bottom) {\n }\n \n void MaybeReexec() {}\n-void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {}\n+void CheckASLR() {}\n+void PlatformPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {}\n void DisableCoreDumperIfNecessary() {}\n void InstallDeadlySignalHandlers(SignalHandlerType handler) {}\n-void StartReportDeadlySignal() {}\n-void ReportDeadlySignal(const SignalContext &sig, u32 tid,\n-                        UnwindSignalStackCallbackType unwind,\n-                        const void *unwind_context) {}\n void SetAlternateSignalStack() {}\n void UnsetAlternateSignalStack() {}\n void InitTlsSize() {}\n@@ -102,42 +99,6 @@ bool SignalContext::IsStackOverflow() const { return false; }\n void SignalContext::DumpAllRegisters(void *context) { UNIMPLEMENTED(); }\n const char *SignalContext::Describe() const { UNIMPLEMENTED(); }\n \n-struct UnwindTraceArg {\n-  BufferedStackTrace *stack;\n-  u32 max_depth;\n-};\n-\n-_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n-  UnwindTraceArg *arg = static_cast<UnwindTraceArg *>(param);\n-  CHECK_LT(arg->stack->size, arg->max_depth);\n-  uptr pc = _Unwind_GetIP(ctx);\n-  if (pc < PAGE_SIZE) return _URC_NORMAL_STOP;\n-  arg->stack->trace_buffer[arg->stack->size++] = pc;\n-  return (arg->stack->size == arg->max_depth ? _URC_NORMAL_STOP\n-                                             : _URC_NO_REASON);\n-}\n-\n-void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n-  CHECK_GE(max_depth, 2);\n-  size = 0;\n-  UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n-  _Unwind_Backtrace(Unwind_Trace, &arg);\n-  CHECK_GT(size, 0);\n-  // We need to pop a few frames so that pc is on top.\n-  uptr to_pop = LocatePcInTrace(pc);\n-  // trace_buffer[0] belongs to the current function so we always pop it,\n-  // unless there is only 1 frame in the stack trace (1 frame is always better\n-  // than 0!).\n-  PopStackFrames(Min(to_pop, static_cast<uptr>(1)));\n-  trace_buffer[0] = pc;\n-}\n-\n-void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-                                                    u32 max_depth) {\n-  CHECK_NE(context, nullptr);\n-  UNREACHABLE(\"signal context doesn't exist\");\n-}\n-\n enum MutexState : int { MtxUnlocked = 0, MtxLocked = 1, MtxSleeping = 2 };\n \n BlockingMutex::BlockingMutex() {\n@@ -184,11 +145,13 @@ uptr GetMmapGranularity() { return PAGE_SIZE; }\n \n sanitizer_shadow_bounds_t ShadowBounds;\n \n-uptr GetMaxVirtualAddress() {\n+uptr GetMaxUserVirtualAddress() {\n   ShadowBounds = __sanitizer_shadow_bounds();\n   return ShadowBounds.memory_limit - 1;\n }\n \n+uptr GetMaxVirtualAddress() { return GetMaxUserVirtualAddress(); }\n+\n static void *DoAnonymousMmapOrDie(uptr size, const char *mem_type,\n                                   bool raw_report, bool die_for_nomem) {\n   size = RoundUpTo(size, PAGE_SIZE);\n@@ -206,8 +169,9 @@ static void *DoAnonymousMmapOrDie(uptr size, const char *mem_type,\n \n   // TODO(mcgrathr): Maybe allocate a VMAR for all sanitizer heap and use that?\n   uintptr_t addr;\n-  status = _zx_vmar_map(_zx_vmar_root_self(), 0, vmo, 0, size,\n-                        ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE, &addr);\n+  status =\n+      _zx_vmar_map(_zx_vmar_root_self(), ZX_VM_PERM_READ | ZX_VM_PERM_WRITE, 0,\n+                   vmo, 0, size, &addr);\n   _zx_handle_close(vmo);\n \n   if (status != ZX_OK) {\n@@ -234,76 +198,99 @@ void *MmapOrDieOnFatalError(uptr size, const char *mem_type) {\n   return DoAnonymousMmapOrDie(size, mem_type, false, false);\n }\n \n-// MmapNoAccess and MmapFixedOrDie are used only by sanitizer_allocator.\n-// Instead of doing exactly what they say, we make MmapNoAccess actually\n-// just allocate a VMAR to reserve the address space.  Then MmapFixedOrDie\n-// uses that VMAR instead of the root.\n-\n-zx_handle_t allocator_vmar = ZX_HANDLE_INVALID;\n-uintptr_t allocator_vmar_base;\n-size_t allocator_vmar_size;\n-\n-void *MmapNoAccess(uptr size) {\n-  size = RoundUpTo(size, PAGE_SIZE);\n-  CHECK_EQ(allocator_vmar, ZX_HANDLE_INVALID);\n+uptr ReservedAddressRange::Init(uptr init_size, const char *name,\n+                                uptr fixed_addr) {\n+  init_size = RoundUpTo(init_size, PAGE_SIZE);\n+  DCHECK_EQ(os_handle_, ZX_HANDLE_INVALID);\n   uintptr_t base;\n+  zx_handle_t vmar;\n   zx_status_t status =\n-      _zx_vmar_allocate(_zx_vmar_root_self(), 0, size,\n-                        ZX_VM_FLAG_CAN_MAP_READ | ZX_VM_FLAG_CAN_MAP_WRITE |\n-                            ZX_VM_FLAG_CAN_MAP_SPECIFIC,\n-                        &allocator_vmar, &base);\n+      _zx_vmar_allocate_old(_zx_vmar_root_self(), 0, init_size,\n+                            ZX_VM_FLAG_CAN_MAP_READ | ZX_VM_FLAG_CAN_MAP_WRITE |\n+                                ZX_VM_FLAG_CAN_MAP_SPECIFIC,\n+                            &vmar, &base);\n   if (status != ZX_OK)\n-    ReportMmapFailureAndDie(size, \"sanitizer allocator address space\",\n-                            \"zx_vmar_allocate\", status);\n+    ReportMmapFailureAndDie(init_size, name, \"zx_vmar_allocate\", status);\n+  base_ = reinterpret_cast<void *>(base);\n+  size_ = init_size;\n+  name_ = name;\n+  os_handle_ = vmar;\n \n-  allocator_vmar_base = base;\n-  allocator_vmar_size = size;\n-  return reinterpret_cast<void *>(base);\n+  return reinterpret_cast<uptr>(base_);\n }\n \n-constexpr const char kAllocatorVmoName[] = \"sanitizer_allocator\";\n-\n-static void *DoMmapFixedOrDie(uptr fixed_addr, uptr size, bool die_for_nomem) {\n-  size = RoundUpTo(size, PAGE_SIZE);\n-\n+static uptr DoMmapFixedOrDie(zx_handle_t vmar, uptr fixed_addr, uptr map_size,\n+                             void *base, const char *name, bool die_for_nomem) {\n+  uptr offset = fixed_addr - reinterpret_cast<uptr>(base);\n+  map_size = RoundUpTo(map_size, PAGE_SIZE);\n   zx_handle_t vmo;\n-  zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n+  zx_status_t status = _zx_vmo_create(map_size, 0, &vmo);\n   if (status != ZX_OK) {\n     if (status != ZX_ERR_NO_MEMORY || die_for_nomem)\n-      ReportMmapFailureAndDie(size, kAllocatorVmoName, \"zx_vmo_create\", status);\n-    return nullptr;\n+      ReportMmapFailureAndDie(map_size, name, \"zx_vmo_create\", status);\n+    return 0;\n   }\n-  _zx_object_set_property(vmo, ZX_PROP_NAME, kAllocatorVmoName,\n-                          sizeof(kAllocatorVmoName) - 1);\n-\n-  DCHECK_GE(fixed_addr, allocator_vmar_base);\n-  uintptr_t offset = fixed_addr - allocator_vmar_base;\n-  DCHECK_LE(size, allocator_vmar_size);\n-  DCHECK_GE(allocator_vmar_size - offset, size);\n-\n+  _zx_object_set_property(vmo, ZX_PROP_NAME, name, internal_strlen(name));\n+  DCHECK_GE(base + size_, map_size + offset);\n   uintptr_t addr;\n-  status = _zx_vmar_map(\n-      allocator_vmar, offset, vmo, 0, size,\n-      ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE | ZX_VM_FLAG_SPECIFIC,\n-      &addr);\n+\n+  status =\n+      _zx_vmar_map(vmar, ZX_VM_PERM_READ | ZX_VM_PERM_WRITE | ZX_VM_SPECIFIC,\n+                   offset, vmo, 0, map_size, &addr);\n   _zx_handle_close(vmo);\n   if (status != ZX_OK) {\n-    if (status != ZX_ERR_NO_MEMORY || die_for_nomem)\n-      ReportMmapFailureAndDie(size, kAllocatorVmoName, \"zx_vmar_map\", status);\n-    return nullptr;\n+    if (status != ZX_ERR_NO_MEMORY || die_for_nomem) {\n+      ReportMmapFailureAndDie(map_size, name, \"zx_vmar_map\", status);\n+    }\n+    return 0;\n   }\n+  IncreaseTotalMmap(map_size);\n+  return addr;\n+}\n \n-  IncreaseTotalMmap(size);\n+uptr ReservedAddressRange::Map(uptr fixed_addr, uptr map_size) {\n+  return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_,\n+                          name_, false);\n+}\n \n-  return reinterpret_cast<void *>(addr);\n+uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr map_size) {\n+  return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_,\n+                          name_, true);\n }\n \n-void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n-  return DoMmapFixedOrDie(fixed_addr, size, true);\n+void UnmapOrDieVmar(void *addr, uptr size, zx_handle_t target_vmar) {\n+  if (!addr || !size) return;\n+  size = RoundUpTo(size, PAGE_SIZE);\n+\n+  zx_status_t status =\n+      _zx_vmar_unmap(target_vmar, reinterpret_cast<uintptr_t>(addr), size);\n+  if (status != ZX_OK) {\n+    Report(\"ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n+           SanitizerToolName, size, size, addr);\n+    CHECK(\"unable to unmap\" && 0);\n+  }\n+\n+  DecreaseTotalMmap(size);\n }\n \n-void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size) {\n-  return DoMmapFixedOrDie(fixed_addr, size, false);\n+void ReservedAddressRange::Unmap(uptr addr, uptr size) {\n+  CHECK_LE(size, size_);\n+  const zx_handle_t vmar = static_cast<zx_handle_t>(os_handle_);\n+  if (addr == reinterpret_cast<uptr>(base_)) {\n+    if (size == size_) {\n+      // Destroying the vmar effectively unmaps the whole mapping.\n+      _zx_vmar_destroy(vmar);\n+      _zx_handle_close(vmar);\n+      os_handle_ = static_cast<uptr>(ZX_HANDLE_INVALID);\n+      DecreaseTotalMmap(size);\n+      return;\n+    }\n+  } else {\n+    CHECK_EQ(addr + size, reinterpret_cast<uptr>(base_) + size_);\n+  }\n+  // Partial unmapping does not affect the fact that the initial range is still\n+  // reserved, and the resulting unmapped memory can't be reused.\n+  UnmapOrDieVmar(reinterpret_cast<void *>(addr), size, vmar);\n }\n \n // This should never be called.\n@@ -335,8 +322,9 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n   // beginning of the VMO, and unmap the excess before and after.\n   size_t map_size = size + alignment;\n   uintptr_t addr;\n-  status = _zx_vmar_map(_zx_vmar_root_self(), 0, vmo, 0, map_size,\n-                        ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE, &addr);\n+  status =\n+      _zx_vmar_map(_zx_vmar_root_self(), ZX_VM_PERM_READ | ZX_VM_PERM_WRITE, 0,\n+                   vmo, 0, map_size, &addr);\n   if (status == ZX_OK) {\n     uintptr_t map_addr = addr;\n     uintptr_t map_end = map_addr + map_size;\n@@ -348,11 +336,10 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n                                    sizeof(info), NULL, NULL);\n       if (status == ZX_OK) {\n         uintptr_t new_addr;\n-        status =\n-            _zx_vmar_map(_zx_vmar_root_self(), addr - info.base, vmo, 0, size,\n-                         ZX_VM_FLAG_PERM_READ | ZX_VM_FLAG_PERM_WRITE |\n-                             ZX_VM_FLAG_SPECIFIC_OVERWRITE,\n-                         &new_addr);\n+        status = _zx_vmar_map(\n+            _zx_vmar_root_self(),\n+            ZX_VM_PERM_READ | ZX_VM_PERM_WRITE | ZX_VM_SPECIFIC_OVERWRITE,\n+            addr - info.base, vmo, 0, size, &new_addr);\n         if (status == ZX_OK) CHECK_EQ(new_addr, addr);\n       }\n     }\n@@ -375,43 +362,24 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n }\n \n void UnmapOrDie(void *addr, uptr size) {\n-  if (!addr || !size) return;\n-  size = RoundUpTo(size, PAGE_SIZE);\n-\n-  zx_status_t status = _zx_vmar_unmap(_zx_vmar_root_self(),\n-                                      reinterpret_cast<uintptr_t>(addr), size);\n-  if (status != ZX_OK) {\n-    Report(\"ERROR: %s failed to deallocate 0x%zx (%zd) bytes at address %p\\n\",\n-           SanitizerToolName, size, size, addr);\n-    CHECK(\"unable to unmap\" && 0);\n-  }\n-\n-  DecreaseTotalMmap(size);\n+  UnmapOrDieVmar(addr, size, _zx_vmar_root_self());\n }\n \n // This is used on the shadow mapping, which cannot be changed.\n // Zircon doesn't have anything like MADV_DONTNEED.\n void ReleaseMemoryPagesToOS(uptr beg, uptr end) {}\n \n void DumpProcessMap() {\n-  UNIMPLEMENTED();  // TODO(mcgrathr): write it\n+  // TODO(mcgrathr): write it\n+  return;\n }\n \n bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n   // TODO(mcgrathr): Figure out a better way.\n   zx_handle_t vmo;\n   zx_status_t status = _zx_vmo_create(size, 0, &vmo);\n   if (status == ZX_OK) {\n-    while (size > 0) {\n-      size_t wrote;\n-      status = _zx_vmo_write(vmo, reinterpret_cast<const void *>(beg), 0, size,\n-                             &wrote);\n-      if (status != ZX_OK) break;\n-      CHECK_GT(wrote, 0);\n-      CHECK_LE(wrote, size);\n-      beg += wrote;\n-      size -= wrote;\n-    }\n+    status = _zx_vmo_write(vmo, reinterpret_cast<const void *>(beg), 0, size);\n     _zx_handle_close(vmo);\n   }\n   return status == ZX_OK;\n@@ -431,8 +399,8 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n       if (vmo_size < max_len) max_len = vmo_size;\n       size_t map_size = RoundUpTo(max_len, PAGE_SIZE);\n       uintptr_t addr;\n-      status = _zx_vmar_map(_zx_vmar_root_self(), 0, vmo, 0, map_size,\n-                            ZX_VM_FLAG_PERM_READ, &addr);\n+      status = _zx_vmar_map(_zx_vmar_root_self(), ZX_VM_PERM_READ, 0, vmo, 0,\n+                            map_size, &addr);\n       if (status == ZX_OK) {\n         *buff = reinterpret_cast<char *>(addr);\n         *buff_size = map_size;\n@@ -446,7 +414,31 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n }\n \n void RawWrite(const char *buffer) {\n-  __sanitizer_log_write(buffer, internal_strlen(buffer));\n+  constexpr size_t size = 128;\n+  static _Thread_local char line[size];\n+  static _Thread_local size_t lastLineEnd = 0;\n+  static _Thread_local size_t cur = 0;\n+\n+  while (*buffer) {\n+    if (cur >= size) {\n+      if (lastLineEnd == 0)\n+        lastLineEnd = size;\n+      __sanitizer_log_write(line, lastLineEnd);\n+      internal_memmove(line, line + lastLineEnd, cur - lastLineEnd);\n+      cur = cur - lastLineEnd;\n+      lastLineEnd = 0;\n+    }\n+    if (*buffer == '\\n')\n+      lastLineEnd = cur + 1;\n+    line[cur++] = *buffer++;\n+  }\n+  // Flush all complete lines before returning.\n+  if (lastLineEnd != 0) {\n+    __sanitizer_log_write(line, lastLineEnd);\n+    internal_memmove(line, line + lastLineEnd, cur - lastLineEnd);\n+    cur = cur - lastLineEnd;\n+    lastLineEnd = 0;\n+  }\n }\n \n void CatastrophicErrorWrite(const char *buffer, uptr length) {\n@@ -470,8 +462,10 @@ const char *GetEnv(const char *name) {\n }\n \n uptr ReadBinaryName(/*out*/ char *buf, uptr buf_len) {\n-  const char *argv0 = StoredArgv[0];\n-  if (!argv0) argv0 = \"<UNKNOWN>\";\n+  const char *argv0 = \"<UNKNOWN>\";\n+  if (StoredArgv && StoredArgv[0]) {\n+    argv0 = StoredArgv[0];\n+  }\n   internal_strncpy(buf, argv0, buf_len);\n   return internal_strlen(buf);\n }\n@@ -484,12 +478,16 @@ uptr MainThreadStackBase, MainThreadStackSize;\n \n bool GetRandom(void *buffer, uptr length, bool blocking) {\n   CHECK_LE(length, ZX_CPRNG_DRAW_MAX_LEN);\n-  size_t size;\n-  CHECK_EQ(_zx_cprng_draw(buffer, length, &size), ZX_OK);\n-  CHECK_EQ(size, length);\n+  _zx_cprng_draw(buffer, length);\n   return true;\n }\n \n+u32 GetNumberOfCPUs() {\n+  return zx_system_get_num_cpus();\n+}\n+\n+uptr GetRSS() { UNIMPLEMENTED(); }\n+\n }  // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT"}, {"sha": "a2868614cfca6beee3ccf5c74b484d4a1901a9b0", "filename": "libsanitizer/sanitizer_common/sanitizer_getauxval.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,46 @@\n+//===-- sanitizer_getauxval.h -----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Common getauxval() guards and definitions.\n+// getauxval() is not defined until glibc version 2.16, or until API level 21\n+// for Android.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_GETAUXVAL_H\n+#define SANITIZER_GETAUXVAL_H\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_LINUX || SANITIZER_FUCHSIA\n+\n+# include <features.h>\n+\n+# ifndef __GLIBC_PREREQ\n+#  define __GLIBC_PREREQ(x, y) 0\n+# endif\n+\n+# if __GLIBC_PREREQ(2, 16) || (SANITIZER_ANDROID && __ANDROID_API__ >= 21) || \\\n+     SANITIZER_FUCHSIA\n+#  define SANITIZER_USE_GETAUXVAL 1\n+# else\n+#  define SANITIZER_USE_GETAUXVAL 0\n+# endif\n+\n+# if SANITIZER_USE_GETAUXVAL\n+#  include <sys/auxv.h>\n+# else\n+// The weak getauxval definition allows to check for the function at runtime.\n+// This is useful for Android, when compiled at a lower API level yet running\n+// on a more recent platform that offers the function.\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n+unsigned long getauxval(unsigned long type);  // NOLINT\n+# endif\n+\n+#endif // SANITIZER_LINUX || SANITIZER_FUCHSIA\n+\n+#endif // SANITIZER_GETAUXVAL_H"}, {"sha": "b42e6314434bdac345d2e4cc9fca90421df4278c", "filename": "libsanitizer/sanitizer_common/sanitizer_interceptors_ioctl_netbsd.inc", "status": "added", "additions": 1487, "deletions": 0, "changes": 1487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,1487 @@\n+//===-- sanitizer_interceptors_ioctl_netbsd.inc -----------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Ioctl handling in common sanitizer interceptors.\n+//===----------------------------------------------------------------------===//\n+\n+#if SANITIZER_NETBSD\n+\n+#include \"sanitizer_flags.h\"\n+\n+struct ioctl_desc {\n+  unsigned req;\n+  // FIXME: support read+write arguments. Currently READWRITE and WRITE do the\n+  // same thing.\n+  // XXX: The declarations below may use WRITE instead of READWRITE, unless\n+  // explicitly noted.\n+  enum { NONE, READ, WRITE, READWRITE, CUSTOM } type : 3;\n+  unsigned size : 29;\n+  const char *name;\n+};\n+\n+const unsigned ioctl_table_max = 1198;\n+static ioctl_desc ioctl_table[ioctl_table_max];\n+static unsigned ioctl_table_size = 0;\n+\n+// This can not be declared as a global, because references to struct_*_sz\n+// require a global initializer. And this table must be available before global\n+// initializers are run.\n+static void ioctl_table_fill() {\n+#define _(rq, tp, sz)                                                          \\\n+  if (IOCTL_##rq != IOCTL_NOT_PRESENT) {                                       \\\n+    CHECK(ioctl_table_size < ioctl_table_max);                                 \\\n+    ioctl_table[ioctl_table_size].req = IOCTL_##rq;                            \\\n+    ioctl_table[ioctl_table_size].type = ioctl_desc::tp;                       \\\n+    ioctl_table[ioctl_table_size].size = sz;                                   \\\n+    ioctl_table[ioctl_table_size].name = #rq;                                  \\\n+    ++ioctl_table_size;                                                        \\\n+  }\n+\n+  /* Entries from file: altq/altq_afmap.h */\n+  _(AFM_ADDFMAP, READWRITE, struct_atm_flowmap_sz);\n+  _(AFM_DELFMAP, READWRITE, struct_atm_flowmap_sz);\n+  _(AFM_CLEANFMAP, READWRITE, struct_atm_flowmap_sz);\n+  _(AFM_GETFMAP, READWRITE, struct_atm_flowmap_sz);\n+  /* Entries from file: altq/altq.h */\n+  _(ALTQGTYPE, READWRITE, struct_altqreq_sz);\n+  _(ALTQTBRSET, READ, struct_tbrreq_sz);\n+  _(ALTQTBRGET, READWRITE, struct_tbrreq_sz);\n+  /* Entries from file: altq/altq_blue.h */\n+  _(BLUE_IF_ATTACH, READ, struct_blue_interface_sz);\n+  _(BLUE_DISABLE, READ, struct_blue_interface_sz);\n+  _(BLUE_CONFIG, READWRITE, struct_blue_conf_sz);\n+  _(BLUE_GETSTATS, READWRITE, struct_blue_stats_sz);\n+  /* Entries from file: altq/altq_cbq.h */\n+  _(CBQ_ENABLE, READ, struct_cbq_interface_sz);\n+  _(CBQ_ADD_CLASS, READWRITE, struct_cbq_add_class_sz);\n+  _(CBQ_DEL_CLASS, READ, struct_cbq_delete_class_sz);\n+  _(CBQ_MODIFY_CLASS, READWRITE, struct_cbq_modify_class_sz);\n+  _(CBQ_DEL_FILTER, READ, struct_cbq_delete_filter_sz);\n+  _(CBQ_GETSTATS, READWRITE, struct_cbq_getstats_sz);\n+  /* Entries from file: altq/altq_cdnr.h */\n+  _(CDNR_IF_DETACH, READ, struct_cdnr_interface_sz);\n+  _(CDNR_ADD_FILTER, READWRITE, struct_cdnr_add_filter_sz);\n+  _(CDNR_GETSTATS, READWRITE, struct_cdnr_get_stats_sz);\n+  _(CDNR_ADD_ELEM, READWRITE, struct_cdnr_add_element_sz);\n+  _(CDNR_DEL_ELEM, READ, struct_cdnr_delete_element_sz);\n+  _(CDNR_ADD_TBM, READWRITE, struct_cdnr_add_tbmeter_sz);\n+  _(CDNR_MOD_TBM, READ, struct_cdnr_modify_tbmeter_sz);\n+  _(CDNR_TBM_STATS, READWRITE, struct_cdnr_tbmeter_stats_sz);\n+  _(CDNR_ADD_TCM, READWRITE, struct_cdnr_add_trtcm_sz);\n+  _(CDNR_MOD_TCM, READWRITE, struct_cdnr_modify_trtcm_sz);\n+  _(CDNR_TCM_STATS, READWRITE, struct_cdnr_tcm_stats_sz);\n+  _(CDNR_ADD_TSW, READWRITE, struct_cdnr_add_tswtcm_sz);\n+  _(CDNR_MOD_TSW, READWRITE, struct_cdnr_modify_tswtcm_sz);\n+  /* Entries from file: altq/altq_fifoq.h */\n+  _(FIFOQ_CONFIG, READWRITE, struct_fifoq_conf_sz);\n+  _(FIFOQ_GETSTATS, READWRITE, struct_fifoq_getstats_sz);\n+  /* Entries from file: altq/altq_hfsc.h */\n+  _(HFSC_CLEAR_HIERARCHY, READ, struct_hfsc_interface_sz);\n+  _(HFSC_ADD_CLASS, READWRITE, struct_hfsc_add_class_sz);\n+  _(HFSC_GETSTATS, READWRITE, struct_hfsc_class_stats_sz);\n+  /* Entries from file: altq/altq_jobs.h */\n+  _(JOBS_IF_ATTACH, READ, struct_jobs_attach_sz);\n+  _(JOBS_IF_DETACH, READ, struct_jobs_interface_sz);\n+  _(JOBS_ENABLE, READ, struct_jobs_interface_sz);\n+  _(JOBS_DISABLE, READ, struct_jobs_interface_sz);\n+  _(JOBS_CLEAR, READ, struct_jobs_interface_sz);\n+  _(JOBS_ADD_CLASS, READWRITE, struct_jobs_add_class_sz);\n+  _(JOBS_MOD_CLASS, READ, struct_jobs_modify_class_sz);\n+  /* Entries from file: altq/altq_priq.h */\n+  _(PRIQ_IF_ATTACH, READ, struct_priq_interface_sz);\n+  _(PRIQ_CLEAR, READ, struct_priq_interface_sz);\n+  _(PRIQ_ADD_CLASS, READWRITE, struct_priq_add_class_sz);\n+  _(PRIQ_DEL_CLASS, READ, struct_priq_delete_class_sz);\n+  _(PRIQ_MOD_CLASS, READ, struct_priq_modify_class_sz);\n+  _(PRIQ_ADD_FILTER, READWRITE, struct_priq_add_filter_sz);\n+  _(PRIQ_DEL_FILTER, READ, struct_priq_delete_filter_sz);\n+  _(PRIQ_GETSTATS, READWRITE, struct_priq_class_stats_sz);\n+  /* Entries from file: altq/altq_red.h */\n+  _(RED_CONFIG, READWRITE, struct_red_conf_sz);\n+  _(RED_GETSTATS, READWRITE, struct_red_stats_sz);\n+  _(RED_SETDEFAULTS, READ, struct_redparams_sz);\n+  /* Entries from file: altq/altq_rio.h */\n+  _(RIO_CONFIG, READWRITE, struct_rio_conf_sz);\n+  _(RIO_GETSTATS, READWRITE, struct_rio_stats_sz);\n+  _(RIO_SETDEFAULTS, READ, struct_redparams_sz);\n+  /* Entries from file: altq/altq_wfq.h */\n+  _(WFQ_CONFIG, READWRITE, struct_wfq_conf_sz);\n+  _(WFQ_GET_QID, READWRITE, struct_wfq_getqid_sz);\n+  _(WFQ_SET_WEIGHT, READWRITE, struct_wfq_setweight_sz);\n+  /* Entries from file: crypto/cryptodev.h */\n+  _(CRIOGET, READWRITE, sizeof(u32));\n+  _(CIOCFSESSION, READ, sizeof(u32));\n+  _(CIOCKEY, READWRITE, struct_crypt_kop_sz);\n+  _(CIOCNFKEYM, READWRITE, struct_crypt_mkop_sz);\n+  _(CIOCNFSESSION, READ, struct_crypt_sfop_sz);\n+  _(CIOCNCRYPTRETM, READWRITE, struct_cryptret_sz);\n+  _(CIOCNCRYPTRET, READWRITE, struct_crypt_result_sz);\n+  _(CIOCGSESSION, READWRITE, struct_session_op_sz);\n+  _(CIOCNGSESSION, READWRITE, struct_crypt_sgop_sz);\n+  _(CIOCCRYPT, READWRITE, struct_crypt_op_sz);\n+  _(CIOCNCRYPTM, READWRITE, struct_crypt_mop_sz);\n+  _(CIOCASYMFEAT, WRITE, sizeof(u32));\n+  /* Entries from file: dev/apm/apmio.h */\n+  _(APM_IOC_REJECT, READ, struct_apm_event_info_sz);\n+  _(OAPM_IOC_GETPOWER, WRITE, struct_apm_power_info_sz);\n+  _(APM_IOC_GETPOWER, READWRITE, struct_apm_power_info_sz);\n+  _(APM_IOC_NEXTEVENT, WRITE, struct_apm_event_info_sz);\n+  _(APM_IOC_DEV_CTL, READ, struct_apm_ctl_sz);\n+  /* Entries from file: dev/dm/netbsd-dm.h */\n+  _(NETBSD_DM_IOCTL, READWRITE, struct_plistref_sz);\n+  /* Entries from file: dev/dmover/dmover_io.h */\n+  _(DMIO_SETFUNC, READ, struct_dmio_setfunc_sz);\n+  /* Entries from file: dev/dtv/dtvio_demux.h */\n+  _(DMX_START, NONE, 0);\n+  _(DMX_STOP, NONE, 0);\n+  _(DMX_SET_FILTER, READ, struct_dmx_sct_filter_params_sz);\n+  _(DMX_SET_PES_FILTER, READ, struct_dmx_pes_filter_params_sz);\n+  _(DMX_SET_BUFFER_SIZE, NONE, 0);\n+  _(DMX_GET_STC, READWRITE, struct_dmx_stc_sz);\n+  _(DMX_ADD_PID, READ, sizeof(u16));\n+  _(DMX_REMOVE_PID, READ, sizeof(u16));\n+  _(DMX_GET_CAPS, WRITE, struct_dmx_caps_sz);\n+  _(DMX_SET_SOURCE, READ, enum_dmx_source_sz);\n+  /* Entries from file: dev/dtv/dtvio_frontend.h */\n+  _(FE_READ_STATUS, WRITE, enum_fe_status_sz);\n+  _(FE_READ_BER, WRITE, sizeof(u32));\n+  _(FE_READ_SNR, WRITE, sizeof(u16));\n+  _(FE_READ_SIGNAL_STRENGTH, WRITE, sizeof(u16));\n+  _(FE_READ_UNCORRECTED_BLOCKS, WRITE, sizeof(u32));\n+  _(FE_SET_FRONTEND, READWRITE, struct_dvb_frontend_parameters_sz);\n+  _(FE_GET_FRONTEND, WRITE, struct_dvb_frontend_parameters_sz);\n+  _(FE_GET_EVENT, WRITE, struct_dvb_frontend_event_sz);\n+  _(FE_GET_INFO, WRITE, struct_dvb_frontend_info_sz);\n+  _(FE_DISEQC_RESET_OVERLOAD, NONE, 0);\n+  _(FE_DISEQC_SEND_MASTER_CMD, READ, struct_dvb_diseqc_master_cmd_sz);\n+  _(FE_DISEQC_RECV_SLAVE_REPLY, WRITE, struct_dvb_diseqc_slave_reply_sz);\n+  _(FE_DISEQC_SEND_BURST, READ, enum_fe_sec_mini_cmd_sz);\n+  _(FE_SET_TONE, READ, enum_fe_sec_tone_mode_sz);\n+  _(FE_SET_VOLTAGE, READ, enum_fe_sec_voltage_sz);\n+  _(FE_ENABLE_HIGH_LNB_VOLTAGE, READ, sizeof(int));\n+  _(FE_SET_FRONTEND_TUNE_MODE, READ, sizeof(unsigned int));\n+  _(FE_DISHNETWORK_SEND_LEGACY_CMD, READ, sizeof(unsigned long));\n+  /* Entries from file: dev/filemon/filemon.h */\n+  _(FILEMON_SET_FD, READWRITE, sizeof(int));\n+  _(FILEMON_SET_PID, READWRITE, sizeof(int));\n+  /* Entries from file: dev/hdaudio/hdaudioio.h */\n+  _(HDAUDIO_FGRP_INFO, READWRITE, struct_plistref_sz);\n+  _(HDAUDIO_FGRP_GETCONFIG, READWRITE, struct_plistref_sz);\n+  _(HDAUDIO_FGRP_SETCONFIG, READWRITE, struct_plistref_sz);\n+  _(HDAUDIO_FGRP_WIDGET_INFO, READWRITE, struct_plistref_sz);\n+  _(HDAUDIO_FGRP_CODEC_INFO, READWRITE, struct_plistref_sz);\n+  _(HDAUDIO_AFG_WIDGET_INFO, READWRITE, struct_plistref_sz);\n+  _(HDAUDIO_AFG_CODEC_INFO, READWRITE, struct_plistref_sz);\n+  /* Entries from file: dev/hdmicec/hdmicecio.h */\n+  _(CEC_GET_PHYS_ADDR, WRITE, sizeof(u16));\n+  _(CEC_GET_LOG_ADDRS, WRITE, sizeof(u16));\n+  _(CEC_SET_LOG_ADDRS, READ, sizeof(u16));\n+  _(CEC_GET_VENDOR_ID, WRITE, sizeof(u32));\n+  /* Entries from file: dev/hpc/hpcfbio.h */\n+  _(HPCFBIO_GCONF, READWRITE, struct_hpcfb_fbconf_sz);\n+  _(HPCFBIO_SCONF, READ, struct_hpcfb_fbconf_sz);\n+  _(HPCFBIO_GDSPCONF, READWRITE, struct_hpcfb_dspconf_sz);\n+  _(HPCFBIO_SDSPCONF, READ, struct_hpcfb_dspconf_sz);\n+  _(HPCFBIO_GOP, WRITE, struct_hpcfb_dsp_op_sz);\n+  _(HPCFBIO_SOP, READWRITE, struct_hpcfb_dsp_op_sz);\n+  /* Entries from file: dev/i2o/iopio.h */\n+  _(IOPIOCPT, READWRITE, struct_ioppt_sz);\n+  _(IOPIOCGLCT, READWRITE, struct_iovec_sz);\n+  _(IOPIOCGSTATUS, READWRITE, struct_iovec_sz);\n+  _(IOPIOCRECONFIG, NONE, 0);\n+  _(IOPIOCGTIDMAP, READWRITE, struct_iovec_sz);\n+  /* Entries from file: dev/ic/athioctl.h */\n+  _(SIOCGATHSTATS, READWRITE, struct_ifreq_sz);\n+  _(SIOCGATHDIAG, READWRITE, struct_ath_diag_sz);\n+  /* Entries from file: dev/ic/bt8xx.h */\n+  _(METEORCAPTUR, READ, sizeof(int));\n+  _(METEORCAPFRM, READ, struct_meteor_capframe_sz);\n+  _(METEORSETGEO, READ, struct_meteor_geomet_sz);\n+  _(METEORGETGEO, WRITE, struct_meteor_geomet_sz);\n+  _(METEORSTATUS, WRITE, sizeof(unsigned short));\n+  _(METEORSHUE, READ, sizeof(signed char));\n+  _(METEORGHUE, WRITE, sizeof(signed char));\n+  _(METEORSFMT, READ, sizeof(unsigned int));\n+  _(METEORGFMT, WRITE, sizeof(unsigned int));\n+  _(METEORSINPUT, READ, sizeof(unsigned int));\n+  _(METEORGINPUT, WRITE, sizeof(unsigned int));\n+  _(METEORSCHCV, READ, sizeof(unsigned char));\n+  _(METEORGCHCV, WRITE, sizeof(unsigned char));\n+  _(METEORSCOUNT, READ, struct_meteor_counts_sz);\n+  _(METEORGCOUNT, WRITE, struct_meteor_counts_sz);\n+  _(METEORSFPS, READ, sizeof(unsigned short));\n+  _(METEORGFPS, WRITE, sizeof(unsigned short));\n+  _(METEORSSIGNAL, READ, sizeof(unsigned int));\n+  _(METEORGSIGNAL, WRITE, sizeof(unsigned int));\n+  _(METEORSVIDEO, READ, struct_meteor_video_sz);\n+  _(METEORGVIDEO, WRITE, struct_meteor_video_sz);\n+  _(METEORSBRIG, READ, sizeof(unsigned char));\n+  _(METEORGBRIG, WRITE, sizeof(unsigned char));\n+  _(METEORSCSAT, READ, sizeof(unsigned char));\n+  _(METEORGCSAT, WRITE, sizeof(unsigned char));\n+  _(METEORSCONT, READ, sizeof(unsigned char));\n+  _(METEORGCONT, WRITE, sizeof(unsigned char));\n+  _(METEORSHWS, READ, sizeof(unsigned char));\n+  _(METEORGHWS, WRITE, sizeof(unsigned char));\n+  _(METEORSVWS, READ, sizeof(unsigned char));\n+  _(METEORGVWS, WRITE, sizeof(unsigned char));\n+  _(METEORSTS, READ, sizeof(unsigned char));\n+  _(METEORGTS, WRITE, sizeof(unsigned char));\n+  _(TVTUNER_SETCHNL, READ, sizeof(unsigned int));\n+  _(TVTUNER_GETCHNL, WRITE, sizeof(unsigned int));\n+  _(TVTUNER_SETTYPE, READ, sizeof(unsigned int));\n+  _(TVTUNER_GETTYPE, WRITE, sizeof(unsigned int));\n+  _(TVTUNER_GETSTATUS, WRITE, sizeof(unsigned int));\n+  _(TVTUNER_SETFREQ, READ, sizeof(unsigned int));\n+  _(TVTUNER_GETFREQ, WRITE, sizeof(unsigned int));\n+  _(TVTUNER_SETAFC, READ, sizeof(int));\n+  _(TVTUNER_GETAFC, WRITE, sizeof(int));\n+  _(RADIO_SETMODE, READ, sizeof(unsigned int));\n+  _(RADIO_GETMODE, WRITE, sizeof(unsigned char));\n+  _(RADIO_SETFREQ, READ, sizeof(unsigned int));\n+  _(RADIO_GETFREQ, WRITE, sizeof(unsigned int));\n+  _(METEORSACTPIXFMT, READ, sizeof(int));\n+  _(METEORGACTPIXFMT, WRITE, sizeof(int));\n+  _(METEORGSUPPIXFMT, READWRITE, struct_meteor_pixfmt_sz);\n+  _(TVTUNER_GETCHNLSET, READWRITE, struct_bktr_chnlset_sz);\n+  _(REMOTE_GETKEY, WRITE, struct_bktr_remote_sz);\n+  /* Entries from file: dev/ic/icp_ioctl.h */\n+  _(GDT_IOCTL_GENERAL, READWRITE, struct_gdt_ucmd_sz);\n+  _(GDT_IOCTL_DRVERS, WRITE, sizeof(int));\n+  _(GDT_IOCTL_CTRTYPE, READWRITE, struct_gdt_ctrt_sz);\n+  _(GDT_IOCTL_OSVERS, WRITE, struct_gdt_osv_sz);\n+  _(GDT_IOCTL_CTRCNT, WRITE, sizeof(int));\n+  _(GDT_IOCTL_EVENT, READWRITE, struct_gdt_event_sz);\n+  _(GDT_IOCTL_STATIST, WRITE, struct_gdt_statist_sz);\n+  _(GDT_IOCTL_RESCAN, READWRITE, struct_gdt_rescan_sz);\n+  /* Entries from file: dev/ic/isp_ioctl.h */\n+  _(ISP_SDBLEV, READWRITE, sizeof(int));\n+  _(ISP_RESETHBA, NONE, 0);\n+  _(ISP_RESCAN, NONE, 0);\n+  _(ISP_SETROLE, READWRITE, sizeof(int));\n+  _(ISP_GETROLE, WRITE, sizeof(int));\n+  _(ISP_GET_STATS, WRITE, struct_isp_stats_sz);\n+  _(ISP_CLR_STATS, NONE, 0);\n+  _(ISP_FC_LIP, NONE, 0);\n+  _(ISP_FC_GETDINFO, READWRITE, struct_isp_fc_device_sz);\n+  _(ISP_GET_FW_CRASH_DUMP, NONE, 0);\n+  _(ISP_FORCE_CRASH_DUMP, NONE, 0);\n+  _(ISP_FC_GETHINFO, READWRITE, struct_isp_hba_device_sz);\n+  _(ISP_TSK_MGMT, READWRITE, struct_isp_fc_tsk_mgmt_sz);\n+  _(ISP_FC_GETDLIST, NONE, 0);\n+  /* Entries from file: dev/ic/mlxio.h */\n+  _(MLXD_STATUS, WRITE, sizeof(int));\n+  _(MLXD_CHECKASYNC, WRITE, sizeof(int));\n+  _(MLXD_DETACH, READ, sizeof(int));\n+  _(MLX_RESCAN_DRIVES, NONE, 0);\n+  _(MLX_PAUSE_CHANNEL, READ, struct_mlx_pause_sz);\n+  _(MLX_COMMAND, READWRITE, struct_mlx_usercommand_sz);\n+  _(MLX_REBUILDASYNC, READWRITE, struct_mlx_rebuild_request_sz);\n+  _(MLX_REBUILDSTAT, WRITE, struct_mlx_rebuild_status_sz);\n+  _(MLX_GET_SYSDRIVE, READWRITE, sizeof(int));\n+  _(MLX_GET_CINFO, WRITE, struct_mlx_cinfo_sz);\n+  /* Entries from file: dev/ic/nvmeio.h */\n+  _(NVME_PASSTHROUGH_CMD, READWRITE, struct_nvme_pt_command_sz);\n+  /* Entries from file: dev/ir/irdaio.h */\n+  _(IRDA_RESET_PARAMS, NONE, 0);\n+  _(IRDA_SET_PARAMS, READ, struct_irda_params_sz);\n+  _(IRDA_GET_SPEEDMASK, WRITE, sizeof(unsigned int));\n+  _(IRDA_GET_TURNAROUNDMASK, WRITE, sizeof(unsigned int));\n+  _(IRFRAMETTY_GET_DEVICE, WRITE, sizeof(unsigned int));\n+  _(IRFRAMETTY_GET_DONGLE, WRITE, sizeof(unsigned int));\n+  _(IRFRAMETTY_SET_DONGLE, READ, sizeof(unsigned int));\n+  /* Entries from file: dev/isa/satlinkio.h */\n+  _(SATIORESET, NONE, 0);\n+  _(SATIOGID, WRITE, struct_satlink_id_sz);\n+  /* Entries from file: dev/isa/isvio.h */\n+  _(ISV_CMD, READWRITE, struct_isv_cmd_sz);\n+  /* Entries from file: dev/isa/wtreg.h */\n+  _(WTQICMD, NONE, 0);\n+  /* Entries from file: dev/iscsi/iscsi_ioctl.h */\n+  _(ISCSI_GET_VERSION, READWRITE, struct_iscsi_get_version_parameters_sz);\n+  _(ISCSI_LOGIN, READWRITE, struct_iscsi_login_parameters_sz);\n+  _(ISCSI_LOGOUT, READWRITE, struct_iscsi_logout_parameters_sz);\n+  _(ISCSI_ADD_CONNECTION, READWRITE, struct_iscsi_login_parameters_sz);\n+  _(ISCSI_RESTORE_CONNECTION, READWRITE, struct_iscsi_login_parameters_sz);\n+  _(ISCSI_REMOVE_CONNECTION, READWRITE, struct_iscsi_remove_parameters_sz);\n+  _(ISCSI_CONNECTION_STATUS, READWRITE, struct_iscsi_conn_status_parameters_sz);\n+  _(ISCSI_SEND_TARGETS, READWRITE, struct_iscsi_send_targets_parameters_sz);\n+  _(ISCSI_SET_NODE_NAME, READWRITE, struct_iscsi_set_node_name_parameters_sz);\n+  _(ISCSI_IO_COMMAND, READWRITE, struct_iscsi_iocommand_parameters_sz);\n+  _(ISCSI_REGISTER_EVENT, READWRITE, struct_iscsi_register_event_parameters_sz);\n+  _(ISCSI_DEREGISTER_EVENT, READWRITE,\n+    struct_iscsi_register_event_parameters_sz);\n+  _(ISCSI_WAIT_EVENT, READWRITE, struct_iscsi_wait_event_parameters_sz);\n+  _(ISCSI_POLL_EVENT, READWRITE, struct_iscsi_wait_event_parameters_sz);\n+  /* Entries from file: dev/ofw/openfirmio.h */\n+  _(OFIOCGET, READWRITE, struct_ofiocdesc_sz);\n+  _(OFIOCSET, READ, struct_ofiocdesc_sz);\n+  _(OFIOCNEXTPROP, READWRITE, struct_ofiocdesc_sz);\n+  _(OFIOCGETOPTNODE, WRITE, sizeof(int));\n+  _(OFIOCGETNEXT, READWRITE, sizeof(int));\n+  _(OFIOCGETCHILD, READWRITE, sizeof(int));\n+  _(OFIOCFINDDEVICE, READWRITE, struct_ofiocdesc_sz);\n+  /* Entries from file: dev/pci/amrio.h */\n+  _(AMR_IO_VERSION, WRITE, sizeof(int));\n+  _(AMR_IO_COMMAND, READWRITE, struct_amr_user_ioctl_sz);\n+  /* Entries from file: dev/pci/mlyio.h */\n+  _(MLYIO_COMMAND, READWRITE, struct_mly_user_command_sz);\n+  _(MLYIO_HEALTH, READ, struct_mly_user_health_sz);\n+  /* Entries from file: dev/pci/pciio.h */\n+  _(PCI_IOC_CFGREAD, READWRITE, struct_pciio_cfgreg_sz);\n+  _(PCI_IOC_CFGWRITE, READ, struct_pciio_cfgreg_sz);\n+  _(PCI_IOC_BDF_CFGREAD, READWRITE, struct_pciio_bdf_cfgreg_sz);\n+  _(PCI_IOC_BDF_CFGWRITE, READ, struct_pciio_bdf_cfgreg_sz);\n+  _(PCI_IOC_BUSINFO, WRITE, struct_pciio_businfo_sz);\n+  _(PCI_IOC_DRVNAME, READWRITE, struct_pciio_drvname_sz);\n+  _(PCI_IOC_DRVNAMEONBUS, READWRITE, struct_pciio_drvnameonbus_sz);\n+  /* Entries from file: dev/pci/tweio.h */\n+  _(TWEIO_COMMAND, READWRITE, struct_twe_usercommand_sz);\n+  _(TWEIO_STATS, READWRITE, union_twe_statrequest_sz);\n+  _(TWEIO_AEN_POLL, WRITE, sizeof(int));\n+  _(TWEIO_AEN_WAIT, WRITE, sizeof(int));\n+  _(TWEIO_SET_PARAM, READ, struct_twe_paramcommand_sz);\n+  _(TWEIO_GET_PARAM, READ, struct_twe_paramcommand_sz);\n+  _(TWEIO_RESET, NONE, 0);\n+  _(TWEIO_ADD_UNIT, READ, struct_twe_drivecommand_sz);\n+  _(TWEIO_DEL_UNIT, READ, struct_twe_drivecommand_sz);\n+  /* Entries from file: dev/pcmcia/if_cnwioctl.h */\n+  _(SIOCSCNWDOMAIN, READ, struct_ifreq_sz);\n+  _(SIOCGCNWDOMAIN, READWRITE, struct_ifreq_sz);\n+  _(SIOCSCNWKEY, READWRITE, struct_ifreq_sz);\n+  _(SIOCGCNWSTATUS, READWRITE, struct_cnwstatus_sz);\n+  _(SIOCGCNWSTATS, READWRITE, struct_cnwistats_sz);\n+  _(SIOCGCNWTRAIL, READWRITE, struct_cnwitrail_sz);\n+  /* Entries from file: dev/pcmcia/if_rayreg.h */\n+  _(SIOCGRAYSIGLEV, READWRITE, struct_ifreq_sz);\n+  /* Entries from file: dev/raidframe/raidframeio.h */\n+  _(RAIDFRAME_SHUTDOWN, NONE, 0);\n+  _(RAIDFRAME_TUR, READ, sizeof(u64));\n+  _(RAIDFRAME_FAIL_DISK, READ, struct_rf_recon_req_sz);\n+  _(RAIDFRAME_CHECK_RECON_STATUS, READWRITE, sizeof(int));\n+  _(RAIDFRAME_REWRITEPARITY, NONE, 0);\n+  _(RAIDFRAME_COPYBACK, NONE, 0);\n+  _(RAIDFRAME_SPARET_WAIT, WRITE, struct_RF_SparetWait_sz);\n+  _(RAIDFRAME_SEND_SPARET, READ, sizeof(uptr));\n+  _(RAIDFRAME_ABORT_SPARET_WAIT, NONE, 0);\n+  _(RAIDFRAME_START_ATRACE, NONE, 0);\n+  _(RAIDFRAME_STOP_ATRACE, NONE, 0);\n+  _(RAIDFRAME_GET_SIZE, WRITE, sizeof(int));\n+  _(RAIDFRAME_RESET_ACCTOTALS, NONE, 0);\n+  _(RAIDFRAME_KEEP_ACCTOTALS, READ, sizeof(int));\n+  _(RAIDFRAME_GET_COMPONENT_LABEL, READWRITE, struct_RF_ComponentLabel_sz);\n+  _(RAIDFRAME_SET_COMPONENT_LABEL, READ, struct_RF_ComponentLabel_sz);\n+  _(RAIDFRAME_INIT_LABELS, READ, struct_RF_ComponentLabel_sz);\n+  _(RAIDFRAME_ADD_HOT_SPARE, READ, struct_RF_SingleComponent_sz);\n+  _(RAIDFRAME_REMOVE_HOT_SPARE, READ, struct_RF_SingleComponent_sz);\n+  _(RAIDFRAME_REBUILD_IN_PLACE, READ, struct_RF_SingleComponent_sz);\n+  _(RAIDFRAME_CHECK_PARITY, READWRITE, sizeof(int));\n+  _(RAIDFRAME_CHECK_PARITYREWRITE_STATUS, READWRITE, sizeof(int));\n+  _(RAIDFRAME_CHECK_COPYBACK_STATUS, READWRITE, sizeof(int));\n+  _(RAIDFRAME_SET_AUTOCONFIG, READWRITE, sizeof(int));\n+  _(RAIDFRAME_SET_ROOT, READWRITE, sizeof(int));\n+  _(RAIDFRAME_DELETE_COMPONENT, READ, struct_RF_SingleComponent_sz);\n+  _(RAIDFRAME_INCORPORATE_HOT_SPARE, READ, struct_RF_SingleComponent_sz);\n+  _(RAIDFRAME_CHECK_RECON_STATUS_EXT, READWRITE, struct_RF_ProgressInfo_sz);\n+  _(RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT, READWRITE,\n+    struct_RF_ProgressInfo_sz);\n+  _(RAIDFRAME_CHECK_COPYBACK_STATUS_EXT, READWRITE, struct_RF_ProgressInfo_sz);\n+  _(RAIDFRAME_PARITYMAP_STATUS, WRITE, struct_rf_pmstat_sz);\n+  _(RAIDFRAME_PARITYMAP_GET_DISABLE, WRITE, sizeof(int));\n+  _(RAIDFRAME_PARITYMAP_SET_DISABLE, READ, sizeof(int));\n+  _(RAIDFRAME_PARITYMAP_SET_PARAMS, READ, struct_rf_pmparams_sz);\n+  _(RAIDFRAME_SET_LAST_UNIT, READ, sizeof(int));\n+  _(RAIDFRAME_GET_INFO, READWRITE, sizeof(uptr));\n+  _(RAIDFRAME_CONFIGURE, READ, sizeof(uptr));\n+  /* Entries from file: dev/sbus/mbppio.h */\n+  _(MBPPIOCSPARAM, READ, struct_mbpp_param_sz);\n+  _(MBPPIOCGPARAM, WRITE, struct_mbpp_param_sz);\n+  _(MBPPIOCGSTAT, WRITE, sizeof(int));\n+  /* Entries from file: dev/scsipi/ses.h */\n+  _(SESIOC_GETNOBJ, NONE, 0);\n+  _(SESIOC_GETOBJMAP, NONE, 0);\n+  _(SESIOC_GETENCSTAT, NONE, 0);\n+  _(SESIOC_SETENCSTAT, NONE, 0);\n+  _(SESIOC_GETOBJSTAT, NONE, 0);\n+  _(SESIOC_SETOBJSTAT, NONE, 0);\n+  _(SESIOC_GETTEXT, NONE, 0);\n+  _(SESIOC_INIT, NONE, 0);\n+  /* Entries from file: dev/sun/disklabel.h */\n+  _(SUN_DKIOCGGEOM, WRITE, struct_sun_dkgeom_sz);\n+  _(SUN_DKIOCINFO, WRITE, struct_sun_dkctlr_sz);\n+  _(SUN_DKIOCGPART, WRITE, struct_sun_dkpart_sz);\n+  /* Entries from file: dev/sun/fbio.h */\n+  _(FBIOGTYPE, WRITE, struct_fbtype_sz);\n+  _(FBIOPUTCMAP, READ, struct_fbcmap_sz);\n+  _(FBIOGETCMAP, READ, struct_fbcmap_sz);\n+  _(FBIOGATTR, WRITE, struct_fbgattr_sz);\n+  _(FBIOSVIDEO, READ, sizeof(int));\n+  _(FBIOGVIDEO, WRITE, sizeof(int));\n+  _(FBIOSCURSOR, READ, struct_fbcursor_sz);\n+  _(FBIOGCURSOR, READWRITE, struct_fbcursor_sz);\n+  _(FBIOSCURPOS, READ, struct_fbcurpos_sz);\n+  _(FBIOGCURPOS, READ, struct_fbcurpos_sz);\n+  _(FBIOGCURMAX, WRITE, struct_fbcurpos_sz);\n+  /* Entries from file: dev/sun/kbio.h */\n+  _(KIOCTRANS, READ, sizeof(int));\n+  _(KIOCSETKEY, READWRITE, struct_okiockey_sz);\n+  _(KIOCGETKEY, READWRITE, struct_okiockey_sz);\n+  _(KIOCGTRANS, WRITE, sizeof(int));\n+  _(KIOCCMD, READ, sizeof(int));\n+  _(KIOCTYPE, WRITE, sizeof(int));\n+  _(KIOCSDIRECT, READ, sizeof(int));\n+  _(KIOCSKEY, READ, struct_kiockeymap_sz);\n+  _(KIOCGKEY, READWRITE, struct_kiockeymap_sz);\n+  _(KIOCSLED, READ, sizeof(char));\n+  _(KIOCGLED, WRITE, sizeof(char));\n+  _(KIOCLAYOUT, WRITE, sizeof(int));\n+  /* Entries from file: dev/sun/vuid_event.h */\n+  _(VUIDSFORMAT, READ, sizeof(int));\n+  _(VUIDGFORMAT, WRITE, sizeof(int));\n+  /* Entries from file: dev/tc/sticio.h */\n+  _(STICIO_GXINFO, WRITE, struct_stic_xinfo_sz);\n+  _(STICIO_RESET, NONE, 0);\n+  _(STICIO_STARTQ, NONE, 0);\n+  _(STICIO_STOPQ, NONE, 0);\n+  /* Entries from file: dev/usb/ukyopon.h */\n+  _(UKYOPON_IDENTIFY, WRITE, struct_ukyopon_identify_sz);\n+  /* Entries from file: dev/usb/urio.h */\n+  _(URIO_SEND_COMMAND, READWRITE, struct_urio_command_sz);\n+  _(URIO_RECV_COMMAND, READWRITE, struct_urio_command_sz);\n+  /* Entries from file: dev/usb/usb.h */\n+  _(USB_REQUEST, READWRITE, struct_usb_ctl_request_sz);\n+  _(USB_SETDEBUG, READ, sizeof(int));\n+  _(USB_DISCOVER, NONE, 0);\n+  _(USB_DEVICEINFO, READWRITE, struct_usb_device_info_sz);\n+  _(USB_DEVICEINFO_OLD, READWRITE, struct_usb_device_info_old_sz);\n+  _(USB_DEVICESTATS, WRITE, struct_usb_device_stats_sz);\n+  _(USB_GET_REPORT_DESC, WRITE, struct_usb_ctl_report_desc_sz);\n+  _(USB_SET_IMMED, READ, sizeof(int));\n+  _(USB_GET_REPORT, READWRITE, struct_usb_ctl_report_sz);\n+  _(USB_SET_REPORT, READ, struct_usb_ctl_report_sz);\n+  _(USB_GET_REPORT_ID, WRITE, sizeof(int));\n+  _(USB_GET_CONFIG, WRITE, sizeof(int));\n+  _(USB_SET_CONFIG, READ, sizeof(int));\n+  _(USB_GET_ALTINTERFACE, READWRITE, struct_usb_alt_interface_sz);\n+  _(USB_SET_ALTINTERFACE, READWRITE, struct_usb_alt_interface_sz);\n+  _(USB_GET_NO_ALT, READWRITE, struct_usb_alt_interface_sz);\n+  _(USB_GET_DEVICE_DESC, WRITE, struct_usb_device_descriptor_sz);\n+  _(USB_GET_CONFIG_DESC, READWRITE, struct_usb_config_desc_sz);\n+  _(USB_GET_INTERFACE_DESC, READWRITE, struct_usb_interface_desc_sz);\n+  _(USB_GET_ENDPOINT_DESC, READWRITE, struct_usb_endpoint_desc_sz);\n+  _(USB_GET_FULL_DESC, READWRITE, struct_usb_full_desc_sz);\n+  _(USB_GET_STRING_DESC, READWRITE, struct_usb_string_desc_sz);\n+  _(USB_DO_REQUEST, READWRITE, struct_usb_ctl_request_sz);\n+  _(USB_GET_DEVICEINFO, WRITE, struct_usb_device_info_sz);\n+  _(USB_GET_DEVICEINFO_OLD, WRITE, struct_usb_device_info_old_sz);\n+  _(USB_SET_SHORT_XFER, READ, sizeof(int));\n+  _(USB_SET_TIMEOUT, READ, sizeof(int));\n+  _(USB_SET_BULK_RA, READ, sizeof(int));\n+  _(USB_SET_BULK_WB, READ, sizeof(int));\n+  _(USB_SET_BULK_RA_OPT, READ, struct_usb_bulk_ra_wb_opt_sz);\n+  _(USB_SET_BULK_WB_OPT, READ, struct_usb_bulk_ra_wb_opt_sz);\n+  _(USB_GET_CM_OVER_DATA, WRITE, sizeof(int));\n+  _(USB_SET_CM_OVER_DATA, READ, sizeof(int));\n+  /* Entries from file: dev/usb/utoppy.h */\n+  _(UTOPPYIOTURBO, READ, sizeof(int));\n+  _(UTOPPYIOREBOOT, NONE, 0);\n+  _(UTOPPYIOSTATS, WRITE, struct_utoppy_stats_sz);\n+  _(UTOPPYIORENAME, READ, struct_utoppy_rename_sz);\n+  _(UTOPPYIOMKDIR, READ, sizeof(uptr));\n+  _(UTOPPYIODELETE, READ, sizeof(uptr));\n+  _(UTOPPYIOREADDIR, READ, sizeof(uptr));\n+  _(UTOPPYIOREADFILE, READ, struct_utoppy_readfile_sz);\n+  _(UTOPPYIOWRITEFILE, READ, struct_utoppy_writefile_sz);\n+  /* Entries from file: dev/vme/xio.h */\n+  _(DIOSXDCMD, READWRITE, struct_xd_iocmd_sz);\n+  /* Entries from file: dev/wscons/wsdisplay_usl_io.h */\n+  _(VT_OPENQRY, WRITE, sizeof(int));\n+  _(VT_SETMODE, READ, struct_vt_mode_sz);\n+  _(VT_GETMODE, WRITE, struct_vt_mode_sz);\n+  _(VT_RELDISP, NONE, 0);\n+  _(VT_ACTIVATE, NONE, 0);\n+  _(VT_WAITACTIVE, NONE, 0);\n+  _(VT_GETACTIVE, WRITE, sizeof(int));\n+  _(VT_GETSTATE, WRITE, struct_vt_stat_sz);\n+  _(KDGETKBENT, READWRITE, struct_kbentry_sz);\n+  _(KDGKBMODE, WRITE, sizeof(int));\n+  _(KDSKBMODE, NONE, 0);\n+  _(KDMKTONE, NONE, 0);\n+  _(KDSETMODE, NONE, 0);\n+  _(KDENABIO, NONE, 0);\n+  _(KDDISABIO, NONE, 0);\n+  _(KDGKBTYPE, WRITE, sizeof(char));\n+  _(KDGETLED, WRITE, sizeof(int));\n+  _(KDSETLED, NONE, 0);\n+  _(KDSETRAD, NONE, 0);\n+  _(VGAPCVTID, READWRITE, struct_pcvtid_sz);\n+  _(CONS_GETVERS, WRITE, sizeof(int));\n+  /* Entries from file: dev/wscons/wsconsio.h */\n+  _(WSKBDIO_GTYPE, WRITE, sizeof(unsigned int));\n+  _(WSKBDIO_BELL, NONE, 0);\n+  _(WSKBDIO_COMPLEXBELL, READ, struct_wskbd_bell_data_sz);\n+  _(WSKBDIO_SETBELL, READ, struct_wskbd_bell_data_sz);\n+  _(WSKBDIO_GETBELL, WRITE, struct_wskbd_bell_data_sz);\n+  _(WSKBDIO_SETDEFAULTBELL, READ, struct_wskbd_bell_data_sz);\n+  _(WSKBDIO_GETDEFAULTBELL, WRITE, struct_wskbd_bell_data_sz);\n+  _(WSKBDIO_SETKEYREPEAT, READ, struct_wskbd_keyrepeat_data_sz);\n+  _(WSKBDIO_GETKEYREPEAT, WRITE, struct_wskbd_keyrepeat_data_sz);\n+  _(WSKBDIO_SETDEFAULTKEYREPEAT, READ, struct_wskbd_keyrepeat_data_sz);\n+  _(WSKBDIO_GETDEFAULTKEYREPEAT, WRITE, struct_wskbd_keyrepeat_data_sz);\n+  _(WSKBDIO_SETLEDS, READ, sizeof(int));\n+  _(WSKBDIO_GETLEDS, WRITE, sizeof(int));\n+  _(WSKBDIO_GETMAP, READWRITE, struct_wskbd_map_data_sz);\n+  _(WSKBDIO_SETMAP, READ, struct_wskbd_map_data_sz);\n+  _(WSKBDIO_GETENCODING, WRITE, sizeof(int));\n+  _(WSKBDIO_SETENCODING, READ, sizeof(int));\n+  _(WSKBDIO_SETMODE, READ, sizeof(int));\n+  _(WSKBDIO_GETMODE, WRITE, sizeof(int));\n+  _(WSKBDIO_SETKEYCLICK, READ, sizeof(int));\n+  _(WSKBDIO_GETKEYCLICK, WRITE, sizeof(int));\n+  _(WSKBDIO_GETSCROLL, WRITE, struct_wskbd_scroll_data_sz);\n+  _(WSKBDIO_SETSCROLL, READ, struct_wskbd_scroll_data_sz);\n+  _(WSKBDIO_SETVERSION, READ, sizeof(int));\n+  _(WSMOUSEIO_GTYPE, WRITE, sizeof(unsigned int));\n+  _(WSMOUSEIO_SRES, READ, sizeof(unsigned int));\n+  _(WSMOUSEIO_SSCALE, READ, sizeof(unsigned int));\n+  _(WSMOUSEIO_SRATE, READ, sizeof(unsigned int));\n+  _(WSMOUSEIO_SCALIBCOORDS, READ, struct_wsmouse_calibcoords_sz);\n+  _(WSMOUSEIO_GCALIBCOORDS, WRITE, struct_wsmouse_calibcoords_sz);\n+  _(WSMOUSEIO_GETID, READWRITE, struct_wsmouse_id_sz);\n+  _(WSMOUSEIO_GETREPEAT, WRITE, struct_wsmouse_repeat_sz);\n+  _(WSMOUSEIO_SETREPEAT, READ, struct_wsmouse_repeat_sz);\n+  _(WSMOUSEIO_SETVERSION, READ, sizeof(int));\n+  _(WSDISPLAYIO_GTYPE, WRITE, sizeof(unsigned int));\n+  _(WSDISPLAYIO_GINFO, WRITE, struct_wsdisplay_fbinfo_sz);\n+  _(WSDISPLAYIO_GETCMAP, READ, struct_wsdisplay_cmap_sz);\n+  _(WSDISPLAYIO_PUTCMAP, READ, struct_wsdisplay_cmap_sz);\n+  _(WSDISPLAYIO_GVIDEO, WRITE, sizeof(unsigned int));\n+  _(WSDISPLAYIO_SVIDEO, READ, sizeof(unsigned int));\n+  _(WSDISPLAYIO_GCURPOS, WRITE, struct_wsdisplay_curpos_sz);\n+  _(WSDISPLAYIO_SCURPOS, READ, struct_wsdisplay_curpos_sz);\n+  _(WSDISPLAYIO_GCURMAX, WRITE, struct_wsdisplay_curpos_sz);\n+  _(WSDISPLAYIO_GCURSOR, READWRITE, struct_wsdisplay_cursor_sz);\n+  _(WSDISPLAYIO_SCURSOR, READ, struct_wsdisplay_cursor_sz);\n+  _(WSDISPLAYIO_GMODE, WRITE, sizeof(unsigned int));\n+  _(WSDISPLAYIO_SMODE, READ, sizeof(unsigned int));\n+  _(WSDISPLAYIO_LDFONT, READ, struct_wsdisplay_font_sz);\n+  _(WSDISPLAYIO_ADDSCREEN, READ, struct_wsdisplay_addscreendata_sz);\n+  _(WSDISPLAYIO_DELSCREEN, READ, struct_wsdisplay_delscreendata_sz);\n+  _(WSDISPLAYIO_SFONT, READ, struct_wsdisplay_usefontdata_sz);\n+  _(_O_WSDISPLAYIO_SETKEYBOARD, READWRITE, struct_wsdisplay_kbddata_sz);\n+  _(WSDISPLAYIO_GETPARAM, READWRITE, struct_wsdisplay_param_sz);\n+  _(WSDISPLAYIO_SETPARAM, READWRITE, struct_wsdisplay_param_sz);\n+  _(WSDISPLAYIO_GETACTIVESCREEN, WRITE, sizeof(int));\n+  _(WSDISPLAYIO_GETWSCHAR, READWRITE, struct_wsdisplay_char_sz);\n+  _(WSDISPLAYIO_PUTWSCHAR, READWRITE, struct_wsdisplay_char_sz);\n+  _(WSDISPLAYIO_DGSCROLL, WRITE, struct_wsdisplay_scroll_data_sz);\n+  _(WSDISPLAYIO_DSSCROLL, READ, struct_wsdisplay_scroll_data_sz);\n+  _(WSDISPLAYIO_GMSGATTRS, WRITE, struct_wsdisplay_msgattrs_sz);\n+  _(WSDISPLAYIO_SMSGATTRS, READ, struct_wsdisplay_msgattrs_sz);\n+  _(WSDISPLAYIO_GBORDER, WRITE, sizeof(int));\n+  _(WSDISPLAYIO_SBORDER, READ, sizeof(int));\n+  _(WSDISPLAYIO_SSPLASH, READ, sizeof(int));\n+  _(WSDISPLAYIO_SPROGRESS, READ, sizeof(int));\n+  _(WSDISPLAYIO_LINEBYTES, WRITE, sizeof(unsigned int));\n+  _(WSDISPLAYIO_SETVERSION, READ, sizeof(int));\n+  _(WSMUXIO_ADD_DEVICE, READ, struct_wsmux_device_sz);\n+  _(WSMUXIO_REMOVE_DEVICE, READ, struct_wsmux_device_sz);\n+  _(WSMUXIO_LIST_DEVICES, READWRITE, struct_wsmux_device_list_sz);\n+  _(WSMUXIO_INJECTEVENT, READ, struct_wscons_event_sz);\n+  _(WSDISPLAYIO_GET_BUSID, WRITE, struct_wsdisplayio_bus_id_sz);\n+  _(WSDISPLAYIO_GET_EDID, READWRITE, struct_wsdisplayio_edid_info_sz);\n+  _(WSDISPLAYIO_SET_POLLING, READ, sizeof(int));\n+  _(WSDISPLAYIO_GET_FBINFO, READWRITE, struct_wsdisplayio_fbinfo_sz);\n+  _(WSDISPLAYIO_DOBLIT, READWRITE, struct_wsdisplayio_blit_sz);\n+  _(WSDISPLAYIO_WAITBLIT, READWRITE, struct_wsdisplayio_blit_sz);\n+  /* Entries from file: dev/biovar.h */\n+  _(BIOCLOCATE, READWRITE, struct_bio_locate_sz);\n+  _(BIOCINQ, READWRITE, struct_bioc_inq_sz);\n+  _(BIOCDISK_NOVOL, READWRITE, struct_bioc_disk_sz);\n+  _(BIOCDISK, READWRITE, struct_bioc_disk_sz);\n+  _(BIOCVOL, READWRITE, struct_bioc_vol_sz);\n+  _(BIOCALARM, READWRITE, struct_bioc_alarm_sz);\n+  _(BIOCBLINK, READWRITE, struct_bioc_blink_sz);\n+  _(BIOCSETSTATE, READWRITE, struct_bioc_setstate_sz);\n+  _(BIOCVOLOPS, READWRITE, struct_bioc_volops_sz);\n+  /* Entries from file: dev/md.h */\n+  _(MD_GETCONF, WRITE, struct_md_conf_sz);\n+  _(MD_SETCONF, READ, struct_md_conf_sz);\n+  /* Entries from file: dev/ccdvar.h */\n+  _(CCDIOCSET, READWRITE, struct_ccd_ioctl_sz);\n+  _(CCDIOCCLR, READ, struct_ccd_ioctl_sz);\n+  /* Entries from file: dev/cgdvar.h */\n+  _(CGDIOCSET, READWRITE, struct_cgd_ioctl_sz);\n+  _(CGDIOCCLR, READ, struct_cgd_ioctl_sz);\n+  _(CGDIOCGET, READWRITE, struct_cgd_user_sz);\n+  /* Entries from file: dev/fssvar.h */\n+  _(FSSIOCSET, READ, struct_fss_set_sz);\n+  _(FSSIOCGET, WRITE, struct_fss_get_sz);\n+  _(FSSIOCCLR, NONE, 0);\n+  _(FSSIOFSET, READ, sizeof(int));\n+  _(FSSIOFGET, WRITE, sizeof(int));\n+  /* Entries from file: dev/bluetooth/btdev.h */\n+  _(BTDEV_ATTACH, READ, struct_plistref_sz);\n+  _(BTDEV_DETACH, READ, struct_plistref_sz);\n+  /* Entries from file: dev/bluetooth/btsco.h */\n+  _(BTSCO_GETINFO, WRITE, struct_btsco_info_sz);\n+  /* Entries from file: dev/kttcpio.h */\n+  _(KTTCP_IO_SEND, READWRITE, struct_kttcp_io_args_sz);\n+  _(KTTCP_IO_RECV, READWRITE, struct_kttcp_io_args_sz);\n+  /* Entries from file: dev/lockstat.h */\n+  _(IOC_LOCKSTAT_GVERSION, WRITE, sizeof(int));\n+  _(IOC_LOCKSTAT_ENABLE, READ, struct_lsenable_sz);\n+  _(IOC_LOCKSTAT_DISABLE, WRITE, struct_lsdisable_sz);\n+  /* Entries from file: dev/vndvar.h */\n+  _(VNDIOCSET, READWRITE, struct_vnd_ioctl_sz);\n+  _(VNDIOCCLR, READ, struct_vnd_ioctl_sz);\n+  _(VNDIOCGET, READWRITE, struct_vnd_user_sz);\n+  /* Entries from file: dev/spkrio.h */\n+  _(SPKRTONE, READ, struct_tone_sz);\n+  _(SPKRTUNE, NONE, 0);\n+  _(SPKRGETVOL, WRITE, sizeof(unsigned int));\n+  _(SPKRSETVOL, READ, sizeof(unsigned int));\n+  /* Entries from file: net/bpf.h */\n+  _(BIOCGBLEN, WRITE, sizeof(unsigned int));\n+  _(BIOCSBLEN, READWRITE, sizeof(unsigned int));\n+  _(BIOCSETF, READ, struct_bpf_program_sz);\n+  _(BIOCFLUSH, NONE, 0);\n+  _(BIOCPROMISC, NONE, 0);\n+  _(BIOCGDLT, WRITE, sizeof(unsigned int));\n+  _(BIOCGETIF, WRITE, struct_ifreq_sz);\n+  _(BIOCSETIF, READ, struct_ifreq_sz);\n+  _(BIOCGSTATS, WRITE, struct_bpf_stat_sz);\n+  _(BIOCGSTATSOLD, WRITE, struct_bpf_stat_old_sz);\n+  _(BIOCIMMEDIATE, READ, sizeof(unsigned int));\n+  _(BIOCVERSION, WRITE, struct_bpf_version_sz);\n+  _(BIOCSTCPF, READ, struct_bpf_program_sz);\n+  _(BIOCSUDPF, READ, struct_bpf_program_sz);\n+  _(BIOCGHDRCMPLT, WRITE, sizeof(unsigned int));\n+  _(BIOCSHDRCMPLT, READ, sizeof(unsigned int));\n+  _(BIOCSDLT, READ, sizeof(unsigned int));\n+  _(BIOCGDLTLIST, READWRITE, struct_bpf_dltlist_sz);\n+  _(BIOCGSEESENT, WRITE, sizeof(unsigned int));\n+  _(BIOCSSEESENT, READ, sizeof(unsigned int));\n+  _(BIOCSRTIMEOUT, READ, struct_timeval_sz);\n+  _(BIOCGRTIMEOUT, WRITE, struct_timeval_sz);\n+  _(BIOCGFEEDBACK, WRITE, sizeof(unsigned int));\n+  _(BIOCSFEEDBACK, READ, sizeof(unsigned int));\n+  /* Entries from file: net/if_atm.h */\n+  _(SIOCRAWATM, READWRITE, sizeof(int));\n+  _(SIOCATMENA, READWRITE, struct_atm_pseudoioctl_sz);\n+  _(SIOCATMDIS, READWRITE, struct_atm_pseudoioctl_sz);\n+  _(SIOCSPVCTX, READWRITE, struct_pvctxreq_sz);\n+  _(SIOCGPVCTX, READWRITE, struct_pvctxreq_sz);\n+  _(SIOCSPVCSIF, READWRITE, struct_ifreq_sz);\n+  _(SIOCGPVCSIF, READWRITE, struct_ifreq_sz);\n+  /* Entries from file: net/if_gre.h */\n+  _(GRESADDRS, READ, struct_ifreq_sz);\n+  _(GRESADDRD, READ, struct_ifreq_sz);\n+  _(GREGADDRS, READWRITE, struct_ifreq_sz);\n+  _(GREGADDRD, READWRITE, struct_ifreq_sz);\n+  _(GRESPROTO, READ, struct_ifreq_sz);\n+  _(GREGPROTO, READWRITE, struct_ifreq_sz);\n+  _(GRESSOCK, READ, struct_ifreq_sz);\n+  _(GREDSOCK, READ, struct_ifreq_sz);\n+  /* Entries from file: net/if_ppp.h */\n+  _(PPPIOCGRAWIN, WRITE, struct_ppp_rawin_sz);\n+  _(PPPIOCGFLAGS, WRITE, sizeof(int));\n+  _(PPPIOCSFLAGS, READ, sizeof(int));\n+  _(PPPIOCGASYNCMAP, WRITE, sizeof(int));\n+  _(PPPIOCSASYNCMAP, READ, sizeof(int));\n+  _(PPPIOCGUNIT, WRITE, sizeof(int));\n+  _(PPPIOCGRASYNCMAP, WRITE, sizeof(int));\n+  _(PPPIOCSRASYNCMAP, READ, sizeof(int));\n+  _(PPPIOCGMRU, WRITE, sizeof(int));\n+  _(PPPIOCSMRU, READ, sizeof(int));\n+  _(PPPIOCSMAXCID, READ, sizeof(int));\n+  _(PPPIOCGXASYNCMAP, WRITE, (8 * sizeof(u32)));\n+  _(PPPIOCSXASYNCMAP, READ, (8 * sizeof(u32)));\n+  _(PPPIOCXFERUNIT, NONE, 0);\n+  _(PPPIOCSCOMPRESS, READ, struct_ppp_option_data_sz);\n+  _(PPPIOCGNPMODE, READWRITE, struct_npioctl_sz);\n+  _(PPPIOCSNPMODE, READ, struct_npioctl_sz);\n+  _(PPPIOCGIDLE, WRITE, struct_ppp_idle_sz);\n+  _(PPPIOCGMTU, WRITE, sizeof(int));\n+  _(PPPIOCSMTU, READ, sizeof(int));\n+  _(SIOCGPPPSTATS, READWRITE, struct_ifpppstatsreq_sz);\n+  _(SIOCGPPPCSTATS, READWRITE, struct_ifpppcstatsreq_sz);\n+  /* Entries from file: net/npf.h */\n+  _(IOC_NPF_VERSION, WRITE, sizeof(int));\n+  _(IOC_NPF_SWITCH, READ, sizeof(int));\n+  _(IOC_NPF_LOAD, READWRITE, struct_plistref_sz);\n+  _(IOC_NPF_TABLE, READ, struct_npf_ioctl_table_sz);\n+  _(IOC_NPF_STATS, READ, sizeof(uptr));\n+  _(IOC_NPF_SAVE, WRITE, struct_plistref_sz);\n+  _(IOC_NPF_RULE, READWRITE, struct_plistref_sz);\n+  _(IOC_NPF_CONN_LOOKUP, READWRITE, struct_plistref_sz);\n+  /* Entries from file: net/if_pppoe.h */\n+  _(PPPOESETPARMS, READ, struct_pppoediscparms_sz);\n+  _(PPPOEGETPARMS, READWRITE, struct_pppoediscparms_sz);\n+  _(PPPOEGETSESSION, READWRITE, struct_pppoeconnectionstate_sz);\n+  /* Entries from file: net/if_sppp.h */\n+  _(SPPPGETAUTHCFG, READWRITE, struct_spppauthcfg_sz);\n+  _(SPPPSETAUTHCFG, READ, struct_spppauthcfg_sz);\n+  _(SPPPGETLCPCFG, READWRITE, struct_sppplcpcfg_sz);\n+  _(SPPPSETLCPCFG, READ, struct_sppplcpcfg_sz);\n+  _(SPPPGETSTATUS, READWRITE, struct_spppstatus_sz);\n+  _(SPPPGETSTATUSNCP, READWRITE, struct_spppstatusncp_sz);\n+  _(SPPPGETIDLETO, READWRITE, struct_spppidletimeout_sz);\n+  _(SPPPSETIDLETO, READ, struct_spppidletimeout_sz);\n+  _(SPPPGETAUTHFAILURES, READWRITE, struct_spppauthfailurestats_sz);\n+  _(SPPPSETAUTHFAILURE, READ, struct_spppauthfailuresettings_sz);\n+  _(SPPPSETDNSOPTS, READ, struct_spppdnssettings_sz);\n+  _(SPPPGETDNSOPTS, READWRITE, struct_spppdnssettings_sz);\n+  _(SPPPGETDNSADDRS, READWRITE, struct_spppdnsaddrs_sz);\n+  _(SPPPSETKEEPALIVE, READ, struct_spppkeepalivesettings_sz);\n+  _(SPPPGETKEEPALIVE, READWRITE, struct_spppkeepalivesettings_sz);\n+  /* Entries from file: net/if_srt.h */\n+  _(SRT_GETNRT, WRITE, sizeof(unsigned int));\n+  _(SRT_GETRT, READWRITE, struct_srt_rt_sz);\n+  _(SRT_SETRT, READ, struct_srt_rt_sz);\n+  _(SRT_DELRT, READ, sizeof(unsigned int));\n+  _(SRT_SFLAGS, READ, sizeof(unsigned int));\n+  _(SRT_GFLAGS, WRITE, sizeof(unsigned int));\n+  _(SRT_SGFLAGS, READWRITE, sizeof(unsigned int));\n+  _(SRT_DEBUG, READ, sizeof(uptr));\n+  /* Entries from file: net/if_tap.h */\n+  _(TAPGIFNAME, WRITE, struct_ifreq_sz);\n+  /* Entries from file: net/if_tun.h */\n+  _(TUNSDEBUG, READ, sizeof(int));\n+  _(TUNGDEBUG, WRITE, sizeof(int));\n+  _(TUNSIFMODE, READ, sizeof(int));\n+  _(TUNSIFHEAD, READ, sizeof(int));\n+  _(TUNGIFHEAD, WRITE, sizeof(int));\n+  /* Entries from file: net/pfvar.h */\n+  _(DIOCSTART, NONE, 0);\n+  _(DIOCSTOP, NONE, 0);\n+  _(DIOCADDRULE, READWRITE, struct_pfioc_rule_sz);\n+  _(DIOCGETRULES, READWRITE, struct_pfioc_rule_sz);\n+  _(DIOCGETRULE, READWRITE, struct_pfioc_rule_sz);\n+  _(DIOCSETLCK, READWRITE, sizeof(u32));\n+  _(DIOCCLRSTATES, READWRITE, struct_pfioc_state_kill_sz);\n+  _(DIOCGETSTATE, READWRITE, struct_pfioc_state_sz);\n+  _(DIOCSETSTATUSIF, READWRITE, struct_pfioc_if_sz);\n+  _(DIOCGETSTATUS, READWRITE, struct_pf_status_sz);\n+  _(DIOCCLRSTATUS, NONE, 0);\n+  _(DIOCNATLOOK, READWRITE, struct_pfioc_natlook_sz);\n+  _(DIOCSETDEBUG, READWRITE, sizeof(u32));\n+  _(DIOCGETSTATES, READWRITE, struct_pfioc_states_sz);\n+  _(DIOCCHANGERULE, READWRITE, struct_pfioc_rule_sz);\n+  _(DIOCSETTIMEOUT, READWRITE, struct_pfioc_tm_sz);\n+  _(DIOCGETTIMEOUT, READWRITE, struct_pfioc_tm_sz);\n+  _(DIOCADDSTATE, READWRITE, struct_pfioc_state_sz);\n+  _(DIOCCLRRULECTRS, NONE, 0);\n+  _(DIOCGETLIMIT, READWRITE, struct_pfioc_limit_sz);\n+  _(DIOCSETLIMIT, READWRITE, struct_pfioc_limit_sz);\n+  _(DIOCKILLSTATES, READWRITE, struct_pfioc_state_kill_sz);\n+  _(DIOCSTARTALTQ, NONE, 0);\n+  _(DIOCSTOPALTQ, NONE, 0);\n+  _(DIOCADDALTQ, READWRITE, struct_pfioc_altq_sz);\n+  _(DIOCGETALTQS, READWRITE, struct_pfioc_altq_sz);\n+  _(DIOCGETALTQ, READWRITE, struct_pfioc_altq_sz);\n+  _(DIOCCHANGEALTQ, READWRITE, struct_pfioc_altq_sz);\n+  _(DIOCGETQSTATS, READWRITE, struct_pfioc_qstats_sz);\n+  _(DIOCBEGINADDRS, READWRITE, struct_pfioc_pooladdr_sz);\n+  _(DIOCADDADDR, READWRITE, struct_pfioc_pooladdr_sz);\n+  _(DIOCGETADDRS, READWRITE, struct_pfioc_pooladdr_sz);\n+  _(DIOCGETADDR, READWRITE, struct_pfioc_pooladdr_sz);\n+  _(DIOCCHANGEADDR, READWRITE, struct_pfioc_pooladdr_sz);\n+  _(DIOCADDSTATES, READWRITE, struct_pfioc_states_sz);\n+  _(DIOCGETRULESETS, READWRITE, struct_pfioc_ruleset_sz);\n+  _(DIOCGETRULESET, READWRITE, struct_pfioc_ruleset_sz);\n+  _(DIOCRCLRTABLES, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRADDTABLES, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRDELTABLES, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRGETTABLES, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRGETTSTATS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRCLRTSTATS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRCLRADDRS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRADDADDRS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRDELADDRS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRSETADDRS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRGETADDRS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRGETASTATS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRCLRASTATS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRTSTADDRS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRSETTFLAGS, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCRINADEFINE, READWRITE, struct_pfioc_table_sz);\n+  _(DIOCOSFPFLUSH, NONE, 0);\n+  _(DIOCOSFPADD, READWRITE, struct_pf_osfp_ioctl_sz);\n+  _(DIOCOSFPGET, READWRITE, struct_pf_osfp_ioctl_sz);\n+  _(DIOCXBEGIN, READWRITE, struct_pfioc_trans_sz);\n+  _(DIOCXCOMMIT, READWRITE, struct_pfioc_trans_sz);\n+  _(DIOCXROLLBACK, READWRITE, struct_pfioc_trans_sz);\n+  _(DIOCGETSRCNODES, READWRITE, struct_pfioc_src_nodes_sz);\n+  _(DIOCCLRSRCNODES, NONE, 0);\n+  _(DIOCSETHOSTID, READWRITE, sizeof(u32));\n+  _(DIOCIGETIFACES, READWRITE, struct_pfioc_iface_sz);\n+  _(DIOCSETIFFLAG, READWRITE, struct_pfioc_iface_sz);\n+  _(DIOCCLRIFFLAG, READWRITE, struct_pfioc_iface_sz);\n+  _(DIOCKILLSRCNODES, READWRITE, struct_pfioc_src_node_kill_sz);\n+  /* Entries from file: netbt/hci.h */\n+  _(SIOCGBTINFO, READWRITE, struct_btreq_sz);\n+  _(SIOCGBTINFOA, READWRITE, struct_btreq_sz);\n+  _(SIOCNBTINFO, READWRITE, struct_btreq_sz);\n+  _(SIOCSBTFLAGS, READWRITE, struct_btreq_sz);\n+  _(SIOCSBTPOLICY, READWRITE, struct_btreq_sz);\n+  _(SIOCSBTPTYPE, READWRITE, struct_btreq_sz);\n+  _(SIOCGBTSTATS, READWRITE, struct_btreq_sz);\n+  _(SIOCZBTSTATS, READWRITE, struct_btreq_sz);\n+  _(SIOCBTDUMP, READ, struct_btreq_sz);\n+  _(SIOCSBTSCOMTU, READWRITE, struct_btreq_sz);\n+  _(SIOCGBTFEAT, READWRITE, struct_btreq_sz);\n+  /* Entries from file: netinet/ip_nat.h */\n+  _(SIOCADNAT, READ, struct_ipfobj_sz);\n+  _(SIOCRMNAT, READ, struct_ipfobj_sz);\n+  _(SIOCGNATS, READWRITE, struct_ipfobj_sz);\n+  _(SIOCGNATL, READWRITE, struct_ipfobj_sz);\n+  _(SIOCPURGENAT, READWRITE, struct_ipfobj_sz);\n+  /* Entries from file: netinet6/in6_var.h */\n+  _(SIOCSIFINFO_FLAGS, READWRITE, struct_in6_ndireq_sz);\n+  _(SIOCAADDRCTL_POLICY, READ, struct_in6_addrpolicy_sz);\n+  _(SIOCDADDRCTL_POLICY, READ, struct_in6_addrpolicy_sz);\n+  /* Entries from file: netsmb/smb_dev.h */\n+  _(SMBIOC_OPENSESSION, READ, struct_smbioc_ossn_sz);\n+  _(SMBIOC_OPENSHARE, READ, struct_smbioc_oshare_sz);\n+  _(SMBIOC_REQUEST, READWRITE, struct_smbioc_rq_sz);\n+  _(SMBIOC_SETFLAGS, READ, struct_smbioc_flags_sz);\n+  _(SMBIOC_LOOKUP, READ, struct_smbioc_lookup_sz);\n+  _(SMBIOC_READ, READWRITE, struct_smbioc_rw_sz);\n+  _(SMBIOC_WRITE, READWRITE, struct_smbioc_rw_sz);\n+  /* Entries from file: sys/agpio.h */\n+  _(AGPIOC_INFO, WRITE, struct__agp_info_sz);\n+  _(AGPIOC_ACQUIRE, NONE, 0);\n+  _(AGPIOC_RELEASE, NONE, 0);\n+  _(AGPIOC_SETUP, READ, struct__agp_setup_sz);\n+  _(AGPIOC_ALLOCATE, READWRITE, struct__agp_allocate_sz);\n+  _(AGPIOC_DEALLOCATE, READ, sizeof(int));\n+  _(AGPIOC_BIND, READ, struct__agp_bind_sz);\n+  _(AGPIOC_UNBIND, READ, struct__agp_unbind_sz);\n+  /* Entries from file: sys/audioio.h */\n+  _(AUDIO_GETINFO, WRITE, struct_audio_info_sz);\n+  _(AUDIO_SETINFO, READWRITE, struct_audio_info_sz);\n+  _(AUDIO_DRAIN, NONE, 0);\n+  _(AUDIO_FLUSH, NONE, 0);\n+  _(AUDIO_WSEEK, WRITE, sizeof(unsigned long));\n+  _(AUDIO_RERROR, WRITE, sizeof(int));\n+  _(AUDIO_GETDEV, WRITE, struct_audio_device_sz);\n+  _(AUDIO_GETENC, READWRITE, struct_audio_encoding_sz);\n+  _(AUDIO_GETFD, WRITE, sizeof(int));\n+  _(AUDIO_SETFD, READWRITE, sizeof(int));\n+  _(AUDIO_PERROR, WRITE, sizeof(int));\n+  _(AUDIO_GETIOFFS, WRITE, struct_audio_offset_sz);\n+  _(AUDIO_GETOOFFS, WRITE, struct_audio_offset_sz);\n+  _(AUDIO_GETPROPS, WRITE, sizeof(int));\n+  _(AUDIO_GETBUFINFO, WRITE, struct_audio_info_sz);\n+  _(AUDIO_SETCHAN, READ, sizeof(int));\n+  _(AUDIO_GETCHAN, WRITE, sizeof(int));\n+  _(AUDIO_MIXER_READ, READWRITE, struct_mixer_ctrl_sz);\n+  _(AUDIO_MIXER_WRITE, READWRITE, struct_mixer_ctrl_sz);\n+  _(AUDIO_MIXER_DEVINFO, READWRITE, struct_mixer_devinfo_sz);\n+  /* Entries from file: sys/ataio.h */\n+  _(ATAIOCCOMMAND, READWRITE, struct_atareq_sz);\n+  _(ATABUSIOSCAN, READ, struct_atabusioscan_args_sz);\n+  _(ATABUSIORESET, NONE, 0);\n+  _(ATABUSIODETACH, READ, struct_atabusiodetach_args_sz);\n+  /* Entries from file: sys/cdio.h */\n+  _(CDIOCPLAYTRACKS, READ, struct_ioc_play_track_sz);\n+  _(CDIOCPLAYBLOCKS, READ, struct_ioc_play_blocks_sz);\n+  _(CDIOCREADSUBCHANNEL, READWRITE, struct_ioc_read_subchannel_sz);\n+  _(CDIOREADTOCHEADER, WRITE, struct_ioc_toc_header_sz);\n+  _(CDIOREADTOCENTRIES, READWRITE, struct_ioc_read_toc_entry_sz);\n+  _(CDIOREADMSADDR, READWRITE, sizeof(int));\n+  _(CDIOCSETPATCH, READ, struct_ioc_patch_sz);\n+  _(CDIOCGETVOL, WRITE, struct_ioc_vol_sz);\n+  _(CDIOCSETVOL, READ, struct_ioc_vol_sz);\n+  _(CDIOCSETMONO, NONE, 0);\n+  _(CDIOCSETSTEREO, NONE, 0);\n+  _(CDIOCSETMUTE, NONE, 0);\n+  _(CDIOCSETLEFT, NONE, 0);\n+  _(CDIOCSETRIGHT, NONE, 0);\n+  _(CDIOCSETDEBUG, NONE, 0);\n+  _(CDIOCCLRDEBUG, NONE, 0);\n+  _(CDIOCPAUSE, NONE, 0);\n+  _(CDIOCRESUME, NONE, 0);\n+  _(CDIOCRESET, NONE, 0);\n+  _(CDIOCSTART, NONE, 0);\n+  _(CDIOCSTOP, NONE, 0);\n+  _(CDIOCEJECT, NONE, 0);\n+  _(CDIOCALLOW, NONE, 0);\n+  _(CDIOCPREVENT, NONE, 0);\n+  _(CDIOCCLOSE, NONE, 0);\n+  _(CDIOCPLAYMSF, READ, struct_ioc_play_msf_sz);\n+  _(CDIOCLOADUNLOAD, READ, struct_ioc_load_unload_sz);\n+  /* Entries from file: sys/chio.h */\n+  _(CHIOMOVE, READ, struct_changer_move_request_sz);\n+  _(CHIOEXCHANGE, READ, struct_changer_exchange_request_sz);\n+  _(CHIOPOSITION, READ, struct_changer_position_request_sz);\n+  _(CHIOSPICKER, READ, sizeof(int));\n+  _(CHIOGPARAMS, WRITE, struct_changer_params_sz);\n+  _(CHIOIELEM, NONE, 0);\n+  _(OCHIOGSTATUS, READ, struct_ochanger_element_status_request_sz);\n+  _(CHIOGSTATUS, READ, struct_changer_element_status_request_sz);\n+  _(CHIOSVOLTAG, READ, struct_changer_set_voltag_request_sz);\n+  /* Entries from file: sys/clockctl.h */\n+  _(CLOCKCTL_SETTIMEOFDAY, READ, struct_clockctl_settimeofday_sz);\n+  _(CLOCKCTL_ADJTIME, READWRITE, struct_clockctl_adjtime_sz);\n+  _(CLOCKCTL_CLOCK_SETTIME, READ, struct_clockctl_clock_settime_sz);\n+  _(CLOCKCTL_NTP_ADJTIME, READWRITE, struct_clockctl_ntp_adjtime_sz);\n+  /* Entries from file: sys/cpuio.h */\n+  _(IOC_CPU_SETSTATE, READ, struct_cpustate_sz);\n+  _(IOC_CPU_GETSTATE, READWRITE, struct_cpustate_sz);\n+  _(IOC_CPU_GETCOUNT, WRITE, sizeof(int));\n+  _(IOC_CPU_MAPID, READWRITE, sizeof(int));\n+  _(IOC_CPU_UCODE_GET_VERSION, READWRITE, struct_cpu_ucode_version_sz);\n+  _(IOC_CPU_UCODE_APPLY, READ, struct_cpu_ucode_sz);\n+  /* Entries from file: sys/dkio.h */\n+  _(DIOCGDINFO, WRITE, struct_disklabel_sz);\n+  _(DIOCSDINFO, READ, struct_disklabel_sz);\n+  _(DIOCWDINFO, READ, 0);\n+  _(DIOCRFORMAT, READWRITE, struct_format_op_sz);\n+  _(DIOCWFORMAT, READWRITE, struct_format_op_sz);\n+  _(DIOCSSTEP, READ, sizeof(int));\n+  _(DIOCSRETRIES, READ, sizeof(int));\n+  _(DIOCKLABEL, READ, sizeof(int));\n+  _(DIOCWLABEL, READ, sizeof(int));\n+  _(DIOCSBAD, READ, struct_dkbad_sz);\n+  _(DIOCEJECT, READ, sizeof(int));\n+  _(ODIOCEJECT, NONE, 0);\n+  _(DIOCLOCK, READ, sizeof(int));\n+  _(DIOCGDEFLABEL, WRITE, struct_disklabel_sz);\n+  _(DIOCCLRLABEL, NONE, 0);\n+  _(DIOCGCACHE, WRITE, sizeof(int));\n+  _(DIOCSCACHE, READ, sizeof(int));\n+  _(DIOCCACHESYNC, READ, sizeof(int));\n+  _(DIOCBSLIST, READWRITE, struct_disk_badsecinfo_sz);\n+  _(DIOCBSFLUSH, NONE, 0);\n+  _(DIOCAWEDGE, READWRITE, struct_dkwedge_info_sz);\n+  _(DIOCGWEDGEINFO, WRITE, struct_dkwedge_info_sz);\n+  _(DIOCDWEDGE, READ, struct_dkwedge_info_sz);\n+  _(DIOCLWEDGES, READWRITE, struct_dkwedge_list_sz);\n+  _(DIOCGSTRATEGY, WRITE, struct_disk_strategy_sz);\n+  _(DIOCSSTRATEGY, READ, struct_disk_strategy_sz);\n+  _(DIOCGDISKINFO, WRITE, struct_plistref_sz);\n+  _(DIOCTUR, WRITE, sizeof(int));\n+  _(DIOCMWEDGES, WRITE, sizeof(int));\n+  _(DIOCGSECTORSIZE, WRITE, sizeof(unsigned int));\n+  _(DIOCGMEDIASIZE, WRITE, sizeof(uptr));\n+  /* Entries from file: sys/drvctlio.h */\n+  _(DRVDETACHDEV, READ, struct_devdetachargs_sz);\n+  _(DRVRESCANBUS, READ, struct_devrescanargs_sz);\n+  _(DRVCTLCOMMAND, READWRITE, struct_plistref_sz);\n+  _(DRVRESUMEDEV, READ, struct_devpmargs_sz);\n+  _(DRVLISTDEV, READWRITE, struct_devlistargs_sz);\n+  _(DRVGETEVENT, WRITE, struct_plistref_sz);\n+  _(DRVSUSPENDDEV, READ, struct_devpmargs_sz);\n+  /* Entries from file: sys/dvdio.h */\n+  _(DVD_READ_STRUCT, READWRITE, union_dvd_struct_sz);\n+  _(DVD_WRITE_STRUCT, READWRITE, union_dvd_struct_sz);\n+  _(DVD_AUTH, READWRITE, union_dvd_authinfo_sz);\n+  /* Entries from file: sys/envsys.h */\n+  _(ENVSYS_GETDICTIONARY, READWRITE, struct_plistref_sz);\n+  _(ENVSYS_SETDICTIONARY, READWRITE, struct_plistref_sz);\n+  _(ENVSYS_REMOVEPROPS, READWRITE, struct_plistref_sz);\n+  _(ENVSYS_GTREDATA, READWRITE, struct_envsys_tre_data_sz);\n+  _(ENVSYS_GTREINFO, READWRITE, struct_envsys_basic_info_sz);\n+  /* Entries from file: sys/event.h */\n+  _(KFILTER_BYFILTER, READWRITE, struct_kfilter_mapping_sz);\n+  _(KFILTER_BYNAME, READWRITE, struct_kfilter_mapping_sz);\n+  /* Entries from file: sys/fdio.h */\n+  _(FDIOCGETOPTS, WRITE, 0);\n+  _(FDIOCSETOPTS, READ, sizeof(int));\n+  _(FDIOCSETFORMAT, READ, struct_fdformat_parms_sz);\n+  _(FDIOCGETFORMAT, WRITE, struct_fdformat_parms_sz);\n+  _(FDIOCFORMAT_TRACK, READ, struct_fdformat_cmd_sz);\n+  /* Entries from file: sys/filio.h */\n+  _(FIOCLEX, NONE, 0);\n+  _(FIONCLEX, NONE, 0);\n+  _(FIONREAD, WRITE, sizeof(int));\n+  _(FIONBIO, READ, sizeof(int));\n+  _(FIOASYNC, READ, sizeof(int));\n+  _(FIOSETOWN, READ, sizeof(int));\n+  _(FIOGETOWN, WRITE, sizeof(int));\n+  _(OFIOGETBMAP, READWRITE, sizeof(u32));\n+  _(FIOGETBMAP, READWRITE, sizeof(u64));\n+  _(FIONWRITE, WRITE, sizeof(int));\n+  _(FIONSPACE, WRITE, sizeof(int));\n+  /* Entries from file: sys/gpio.h */\n+  _(GPIOINFO, WRITE, struct_gpio_info_sz);\n+  _(GPIOSET, READWRITE, struct_gpio_set_sz);\n+  _(GPIOUNSET, READWRITE, struct_gpio_set_sz);\n+  _(GPIOREAD, READWRITE, struct_gpio_req_sz);\n+  _(GPIOWRITE, READWRITE, struct_gpio_req_sz);\n+  _(GPIOTOGGLE, READWRITE, struct_gpio_req_sz);\n+  _(GPIOATTACH, READWRITE, struct_gpio_attach_sz);\n+  /* Entries from file: sys/ioctl.h */\n+  _(PTIOCNETBSD, READ, struct_ioctl_pt_sz);\n+  _(PTIOCSUNOS, READ, struct_ioctl_pt_sz);\n+  _(PTIOCLINUX, READ, struct_ioctl_pt_sz);\n+  _(PTIOCFREEBSD, READ, struct_ioctl_pt_sz);\n+  _(PTIOCULTRIX, READ, struct_ioctl_pt_sz);\n+  /* Entries from file: sys/ioctl_compat.h */\n+  _(TIOCHPCL, NONE, 0);\n+  _(TIOCGETP, WRITE, struct_sgttyb_sz);\n+  _(TIOCSETP, READ, struct_sgttyb_sz);\n+  _(TIOCSETN, READ, 0);\n+  _(TIOCSETC, READ, struct_tchars_sz);\n+  _(TIOCGETC, WRITE, struct_tchars_sz);\n+  _(TIOCLBIS, READ, sizeof(int));\n+  _(TIOCLBIC, READ, sizeof(int));\n+  _(TIOCLSET, READ, sizeof(int));\n+  _(TIOCLGET, WRITE, sizeof(int));\n+  _(TIOCSLTC, READ, struct_ltchars_sz);\n+  _(TIOCGLTC, WRITE, struct_ltchars_sz);\n+  _(OTIOCCONS, NONE, 0);\n+  /* Entries from file: sys/joystick.h */\n+  _(JOY_SETTIMEOUT, READ, sizeof(int));\n+  _(JOY_GETTIMEOUT, WRITE, sizeof(int));\n+  _(JOY_SET_X_OFFSET, READ, sizeof(int));\n+  _(JOY_SET_Y_OFFSET, READ, sizeof(int));\n+  _(JOY_GET_Y_OFFSET, WRITE, sizeof(int));\n+  /* Entries from file: sys/ksyms.h */\n+  _(OKIOCGSYMBOL, READ, struct_ksyms_ogsymbol_sz);\n+  _(OKIOCGVALUE, READ, struct_ksyms_ogsymbol_sz);\n+  _(KIOCGSIZE, WRITE, sizeof(int));\n+  _(KIOCGVALUE, READWRITE, struct_ksyms_gvalue_sz);\n+  _(KIOCGSYMBOL, READWRITE, struct_ksyms_gsymbol_sz);\n+  /* Entries from file: sys/lua.h */\n+  _(LUAINFO, READWRITE, struct_lua_info_sz);\n+  _(LUACREATE, READWRITE, struct_lua_create_sz);\n+  _(LUADESTROY, READWRITE, struct_lua_create_sz);\n+  _(LUAREQUIRE, READWRITE, struct_lua_require_sz);\n+  _(LUALOAD, READWRITE, struct_lua_load_sz);\n+  /* Entries from file: sys/midiio.h */\n+  _(MIDI_PRETIME, READWRITE, sizeof(int));\n+  _(MIDI_MPUMODE, READWRITE, sizeof(int));\n+  _(MIDI_MPUCMD, READWRITE, struct_mpu_command_rec_sz);\n+  _(SEQUENCER_RESET, NONE, 0);\n+  _(SEQUENCER_SYNC, NONE, 0);\n+  _(SEQUENCER_INFO, READWRITE, struct_synth_info_sz);\n+  _(SEQUENCER_CTRLRATE, READWRITE, sizeof(int));\n+  _(SEQUENCER_GETOUTCOUNT, WRITE, sizeof(int));\n+  _(SEQUENCER_GETINCOUNT, WRITE, sizeof(int));\n+  _(SEQUENCER_RESETSAMPLES, READ, sizeof(int));\n+  _(SEQUENCER_NRSYNTHS, WRITE, sizeof(int));\n+  _(SEQUENCER_NRMIDIS, WRITE, sizeof(int));\n+  _(SEQUENCER_THRESHOLD, READ, sizeof(int));\n+  _(SEQUENCER_MEMAVL, READWRITE, sizeof(int));\n+  _(SEQUENCER_PANIC, NONE, 0);\n+  _(SEQUENCER_OUTOFBAND, READ, struct_seq_event_rec_sz);\n+  _(SEQUENCER_GETTIME, WRITE, sizeof(int));\n+  _(SEQUENCER_TMR_TIMEBASE, READWRITE, sizeof(int));\n+  _(SEQUENCER_TMR_START, NONE, 0);\n+  _(SEQUENCER_TMR_STOP, NONE, 0);\n+  _(SEQUENCER_TMR_CONTINUE, NONE, 0);\n+  _(SEQUENCER_TMR_TEMPO, READWRITE, sizeof(int));\n+  _(SEQUENCER_TMR_SOURCE, READWRITE, sizeof(int));\n+  _(SEQUENCER_TMR_METRONOME, READ, sizeof(int));\n+  _(SEQUENCER_TMR_SELECT, READ, sizeof(int));\n+  /* Entries from file: sys/mtio.h */\n+  _(MTIOCTOP, READ, struct_mtop_sz);\n+  _(MTIOCGET, WRITE, struct_mtget_sz);\n+  _(MTIOCIEOT, NONE, 0);\n+  _(MTIOCEEOT, NONE, 0);\n+  _(MTIOCRDSPOS, WRITE, sizeof(u32));\n+  _(MTIOCRDHPOS, WRITE, sizeof(u32));\n+  _(MTIOCSLOCATE, READ, sizeof(u32));\n+  _(MTIOCHLOCATE, READ, sizeof(u32));\n+  /* Entries from file: sys/power.h */\n+  _(POWER_EVENT_RECVDICT, READWRITE, struct_plistref_sz);\n+  _(POWER_IOC_GET_TYPE, WRITE, struct_power_type_sz);\n+  _(POWER_IOC_GET_TYPE_WITH_LOSSAGE, WRITE, sizeof(uptr));\n+  /* Entries from file: sys/radioio.h */\n+  _(RIOCGINFO, WRITE, struct_radio_info_sz);\n+  _(RIOCSINFO, READWRITE, struct_radio_info_sz);\n+  _(RIOCSSRCH, READ, sizeof(int));\n+  /* Entries from file: sys/rndio.h */\n+  _(RNDGETENTCNT, WRITE, sizeof(u32));\n+  _(RNDGETSRCNUM, READWRITE, struct_rndstat_sz);\n+  _(RNDGETSRCNAME, READWRITE, struct_rndstat_name_sz);\n+  _(RNDCTL, READ, struct_rndctl_sz);\n+  _(RNDADDDATA, READ, struct_rnddata_sz);\n+  _(RNDGETPOOLSTAT, WRITE, struct_rndpoolstat_sz);\n+  _(RNDGETESTNUM, READWRITE, struct_rndstat_est_sz);\n+  _(RNDGETESTNAME, READWRITE, struct_rndstat_est_name_sz);\n+  /* Entries from file: sys/scanio.h */\n+  _(SCIOCGET, WRITE, struct_scan_io_sz);\n+  _(SCIOCSET, READ, struct_scan_io_sz);\n+  _(SCIOCRESTART, NONE, 0);\n+  /* Entries from file: sys/scsiio.h */\n+  _(SCIOCCOMMAND, READWRITE, struct_scsireq_sz);\n+  _(SCIOCDEBUG, READ, sizeof(int));\n+  _(SCIOCIDENTIFY, WRITE, struct_scsi_addr_sz);\n+  _(OSCIOCIDENTIFY, WRITE, struct_oscsi_addr_sz);\n+  _(SCIOCDECONFIG, NONE, 0);\n+  _(SCIOCRECONFIG, NONE, 0);\n+  _(SCIOCRESET, NONE, 0);\n+  _(SCBUSIOSCAN, READ, struct_scbusioscan_args_sz);\n+  _(SCBUSIORESET, NONE, 0);\n+  _(SCBUSIODETACH, READ, struct_scbusiodetach_args_sz);\n+  _(SCBUSACCEL, READ, struct_scbusaccel_args_sz);\n+  /* Entries from file: sys/sockio.h */\n+  _(SIOCSHIWAT, READ, sizeof(int));\n+  _(SIOCGHIWAT, WRITE, sizeof(int));\n+  _(SIOCSLOWAT, READ, sizeof(int));\n+  _(SIOCGLOWAT, WRITE, sizeof(int));\n+  _(SIOCATMARK, WRITE, sizeof(int));\n+  _(SIOCSPGRP, READ, sizeof(int));\n+  _(SIOCGPGRP, WRITE, sizeof(int));\n+  _(SIOCADDRT, READ, struct_ortentry_sz);\n+  _(SIOCDELRT, READ, struct_ortentry_sz);\n+  _(SIOCSIFADDR, READ, struct_ifreq_sz);\n+  _(SIOCGIFADDR, READWRITE, struct_ifreq_sz);\n+  _(SIOCSIFDSTADDR, READ, struct_ifreq_sz);\n+  _(SIOCGIFDSTADDR, READWRITE, struct_ifreq_sz);\n+  _(SIOCSIFFLAGS, READ, struct_ifreq_sz);\n+  _(SIOCGIFFLAGS, READWRITE, struct_ifreq_sz);\n+  _(SIOCGIFBRDADDR, READWRITE, struct_ifreq_sz);\n+  _(SIOCSIFBRDADDR, READ, struct_ifreq_sz);\n+  _(SIOCGIFCONF, READWRITE, struct_ifconf_sz);\n+  _(SIOCGIFNETMASK, READWRITE, struct_ifreq_sz);\n+  _(SIOCSIFNETMASK, READ, struct_ifreq_sz);\n+  _(SIOCGIFMETRIC, READWRITE, struct_ifreq_sz);\n+  _(SIOCSIFMETRIC, READ, struct_ifreq_sz);\n+  _(SIOCDIFADDR, READ, struct_ifreq_sz);\n+  _(SIOCAIFADDR, READ, struct_ifaliasreq_sz);\n+  _(SIOCGIFALIAS, READWRITE, struct_ifaliasreq_sz);\n+  _(SIOCGIFAFLAG_IN, READWRITE, struct_ifreq_sz);\n+  _(SIOCALIFADDR, READ, struct_if_laddrreq_sz);\n+  _(SIOCGLIFADDR, READWRITE, struct_if_laddrreq_sz);\n+  _(SIOCDLIFADDR, READ, struct_if_laddrreq_sz);\n+  _(SIOCSIFADDRPREF, READ, struct_if_addrprefreq_sz);\n+  _(SIOCGIFADDRPREF, READWRITE, struct_if_addrprefreq_sz);\n+  _(SIOCADDMULTI, READ, struct_ifreq_sz);\n+  _(SIOCDELMULTI, READ, struct_ifreq_sz);\n+  _(SIOCGETVIFCNT, READWRITE, struct_sioc_vif_req_sz);\n+  _(SIOCGETSGCNT, READWRITE, struct_sioc_sg_req_sz);\n+  _(SIOCSIFMEDIA, READWRITE, struct_ifreq_sz);\n+  _(SIOCGIFMEDIA, READWRITE, struct_ifmediareq_sz);\n+  _(SIOCSIFGENERIC, READ, struct_ifreq_sz);\n+  _(SIOCGIFGENERIC, READWRITE, struct_ifreq_sz);\n+  _(SIOCSIFPHYADDR, READ, struct_ifaliasreq_sz);\n+  _(SIOCGIFPSRCADDR, READWRITE, struct_ifreq_sz);\n+  _(SIOCGIFPDSTADDR, READWRITE, struct_ifreq_sz);\n+  _(SIOCDIFPHYADDR, READ, struct_ifreq_sz);\n+  _(SIOCSLIFPHYADDR, READ, struct_if_laddrreq_sz);\n+  _(SIOCGLIFPHYADDR, READWRITE, struct_if_laddrreq_sz);\n+  _(SIOCSIFMTU, READ, struct_ifreq_sz);\n+  _(SIOCGIFMTU, READWRITE, struct_ifreq_sz);\n+  _(SIOCSDRVSPEC, READ, struct_ifdrv_sz);\n+  _(SIOCGDRVSPEC, READWRITE, struct_ifdrv_sz);\n+  _(SIOCIFCREATE, READ, struct_ifreq_sz);\n+  _(SIOCIFDESTROY, READ, struct_ifreq_sz);\n+  _(SIOCIFGCLONERS, READWRITE, struct_if_clonereq_sz);\n+  _(SIOCGIFDLT, READWRITE, struct_ifreq_sz);\n+  _(SIOCGIFCAP, READWRITE, struct_ifcapreq_sz);\n+  _(SIOCSIFCAP, READ, struct_ifcapreq_sz);\n+  _(SIOCSVH, READWRITE, struct_ifreq_sz);\n+  _(SIOCGVH, READWRITE, struct_ifreq_sz);\n+  _(SIOCINITIFADDR, READWRITE, struct_ifaddr_sz);\n+  _(SIOCGIFDATA, READWRITE, struct_ifdatareq_sz);\n+  _(SIOCZIFDATA, READWRITE, struct_ifdatareq_sz);\n+  _(SIOCGLINKSTR, READWRITE, struct_ifdrv_sz);\n+  _(SIOCSLINKSTR, READ, struct_ifdrv_sz);\n+  _(SIOCGETHERCAP, READWRITE, struct_eccapreq_sz);\n+  _(SIOCGIFINDEX, READWRITE, struct_ifreq_sz);\n+  _(SIOCSETPFSYNC, READ, struct_ifreq_sz);\n+  _(SIOCGETPFSYNC, READWRITE, struct_ifreq_sz);\n+  /* Entries from file: sys/timepps.h */\n+  _(PPS_IOC_CREATE, NONE, 0);\n+  _(PPS_IOC_DESTROY, NONE, 0);\n+  _(PPS_IOC_SETPARAMS, READ, struct_pps_params_sz);\n+  _(PPS_IOC_GETPARAMS, WRITE, struct_pps_params_sz);\n+  _(PPS_IOC_GETCAP, WRITE, sizeof(int));\n+  _(PPS_IOC_FETCH, READWRITE, struct_pps_info_sz);\n+  _(PPS_IOC_KCBIND, READ, sizeof(int));\n+  /* Entries from file: sys/ttycom.h */\n+  _(TIOCEXCL, NONE, 0);\n+  _(TIOCNXCL, NONE, 0);\n+  _(TIOCFLUSH, READ, sizeof(int));\n+  _(TIOCGETA, WRITE, struct_termios_sz);\n+  _(TIOCSETA, READ, struct_termios_sz);\n+  _(TIOCSETAW, READ, 0);\n+  _(TIOCSETAF, READ, 0);\n+  _(TIOCGETD, WRITE, sizeof(int));\n+  _(TIOCSETD, READ, sizeof(int));\n+  _(TIOCGLINED, WRITE, (32 * sizeof(char)));\n+  _(TIOCSLINED, READ, (32 * sizeof(char)));\n+  _(TIOCSBRK, NONE, 0);\n+  _(TIOCCBRK, NONE, 0);\n+  _(TIOCSDTR, NONE, 0);\n+  _(TIOCCDTR, NONE, 0);\n+  _(TIOCGPGRP, WRITE, sizeof(int));\n+  _(TIOCSPGRP, READ, sizeof(int));\n+  _(TIOCOUTQ, WRITE, sizeof(int));\n+  _(TIOCSTI, READ, sizeof(char));\n+  _(TIOCNOTTY, NONE, 0);\n+  _(TIOCPKT, READ, sizeof(int));\n+  _(TIOCSTOP, NONE, 0);\n+  _(TIOCSTART, NONE, 0);\n+  _(TIOCMSET, READ, sizeof(int));\n+  _(TIOCMBIS, READ, sizeof(int));\n+  _(TIOCMBIC, READ, sizeof(int));\n+  _(TIOCMGET, WRITE, sizeof(int));\n+  _(TIOCREMOTE, READ, sizeof(int));\n+  _(TIOCGWINSZ, WRITE, struct_winsize_sz);\n+  _(TIOCSWINSZ, READ, struct_winsize_sz);\n+  _(TIOCUCNTL, READ, sizeof(int));\n+  _(TIOCSTAT, READ, sizeof(int));\n+  _(TIOCGSID, WRITE, sizeof(int));\n+  _(TIOCCONS, READ, sizeof(int));\n+  _(TIOCSCTTY, NONE, 0);\n+  _(TIOCEXT, READ, sizeof(int));\n+  _(TIOCSIG, NONE, 0);\n+  _(TIOCDRAIN, NONE, 0);\n+  _(TIOCGFLAGS, WRITE, sizeof(int));\n+  _(TIOCSFLAGS, READ, sizeof(int));\n+  _(TIOCDCDTIMESTAMP, WRITE, struct_timeval_sz);\n+  _(TIOCRCVFRAME, READ, sizeof(uptr));\n+  _(TIOCXMTFRAME, READ, sizeof(uptr));\n+  _(TIOCPTMGET, WRITE, struct_ptmget_sz);\n+  _(TIOCGRANTPT, NONE, 0);\n+  _(TIOCPTSNAME, WRITE, struct_ptmget_sz);\n+  _(TIOCSQSIZE, READ, sizeof(int));\n+  _(TIOCGQSIZE, WRITE, sizeof(int));\n+  /* Entries from file: sys/verified_exec.h */\n+  _(VERIEXEC_LOAD, READ, struct_plistref_sz);\n+  _(VERIEXEC_TABLESIZE, READ, struct_plistref_sz);\n+  _(VERIEXEC_DELETE, READ, struct_plistref_sz);\n+  _(VERIEXEC_QUERY, READWRITE, struct_plistref_sz);\n+  _(VERIEXEC_DUMP, WRITE, struct_plistref_sz);\n+  _(VERIEXEC_FLUSH, NONE, 0);\n+  /* Entries from file: sys/videoio.h */\n+  _(VIDIOC_QUERYCAP, WRITE, struct_v4l2_capability_sz);\n+  _(VIDIOC_RESERVED, NONE, 0);\n+  _(VIDIOC_ENUM_FMT, READWRITE, struct_v4l2_fmtdesc_sz);\n+  _(VIDIOC_G_FMT, READWRITE, struct_v4l2_format_sz);\n+  _(VIDIOC_S_FMT, READWRITE, struct_v4l2_format_sz);\n+  _(VIDIOC_REQBUFS, READWRITE, struct_v4l2_requestbuffers_sz);\n+  _(VIDIOC_QUERYBUF, READWRITE, struct_v4l2_buffer_sz);\n+  _(VIDIOC_G_FBUF, WRITE, struct_v4l2_framebuffer_sz);\n+  _(VIDIOC_S_FBUF, READ, struct_v4l2_framebuffer_sz);\n+  _(VIDIOC_OVERLAY, READ, sizeof(int));\n+  _(VIDIOC_QBUF, READWRITE, struct_v4l2_buffer_sz);\n+  _(VIDIOC_DQBUF, READWRITE, struct_v4l2_buffer_sz);\n+  _(VIDIOC_STREAMON, READ, sizeof(int));\n+  _(VIDIOC_STREAMOFF, READ, sizeof(int));\n+  _(VIDIOC_G_PARM, READWRITE, struct_v4l2_streamparm_sz);\n+  _(VIDIOC_S_PARM, READWRITE, struct_v4l2_streamparm_sz);\n+  _(VIDIOC_G_STD, WRITE, sizeof(u64));\n+  _(VIDIOC_S_STD, READ, sizeof(u64));\n+  _(VIDIOC_ENUMSTD, READWRITE, struct_v4l2_standard_sz);\n+  _(VIDIOC_ENUMINPUT, READWRITE, struct_v4l2_input_sz);\n+  _(VIDIOC_G_CTRL, READWRITE, struct_v4l2_control_sz);\n+  _(VIDIOC_S_CTRL, READWRITE, struct_v4l2_control_sz);\n+  _(VIDIOC_G_TUNER, READWRITE, struct_v4l2_tuner_sz);\n+  _(VIDIOC_S_TUNER, READ, struct_v4l2_tuner_sz);\n+  _(VIDIOC_G_AUDIO, WRITE, struct_v4l2_audio_sz);\n+  _(VIDIOC_S_AUDIO, READ, struct_v4l2_audio_sz);\n+  _(VIDIOC_QUERYCTRL, READWRITE, struct_v4l2_queryctrl_sz);\n+  _(VIDIOC_QUERYMENU, READWRITE, struct_v4l2_querymenu_sz);\n+  _(VIDIOC_G_INPUT, WRITE, sizeof(int));\n+  _(VIDIOC_S_INPUT, READWRITE, sizeof(int));\n+  _(VIDIOC_G_OUTPUT, WRITE, sizeof(int));\n+  _(VIDIOC_S_OUTPUT, READWRITE, sizeof(int));\n+  _(VIDIOC_ENUMOUTPUT, READWRITE, struct_v4l2_output_sz);\n+  _(VIDIOC_G_AUDOUT, WRITE, struct_v4l2_audioout_sz);\n+  _(VIDIOC_S_AUDOUT, READ, struct_v4l2_audioout_sz);\n+  _(VIDIOC_G_MODULATOR, READWRITE, struct_v4l2_modulator_sz);\n+  _(VIDIOC_S_MODULATOR, READ, struct_v4l2_modulator_sz);\n+  _(VIDIOC_G_FREQUENCY, READWRITE, struct_v4l2_frequency_sz);\n+  _(VIDIOC_S_FREQUENCY, READ, struct_v4l2_frequency_sz);\n+  _(VIDIOC_CROPCAP, READWRITE, struct_v4l2_cropcap_sz);\n+  _(VIDIOC_G_CROP, READWRITE, struct_v4l2_crop_sz);\n+  _(VIDIOC_S_CROP, READ, struct_v4l2_crop_sz);\n+  _(VIDIOC_G_JPEGCOMP, WRITE, struct_v4l2_jpegcompression_sz);\n+  _(VIDIOC_S_JPEGCOMP, READ, struct_v4l2_jpegcompression_sz);\n+  _(VIDIOC_QUERYSTD, WRITE, sizeof(u64));\n+  _(VIDIOC_TRY_FMT, READWRITE, struct_v4l2_format_sz);\n+  _(VIDIOC_ENUMAUDIO, READWRITE, struct_v4l2_audio_sz);\n+  _(VIDIOC_ENUMAUDOUT, READWRITE, struct_v4l2_audioout_sz);\n+  _(VIDIOC_G_PRIORITY, WRITE, enum_v4l2_priority_sz);\n+  _(VIDIOC_S_PRIORITY, READ, enum_v4l2_priority_sz);\n+  _(VIDIOC_ENUM_FRAMESIZES, READWRITE, struct_v4l2_frmsizeenum_sz);\n+  _(VIDIOC_ENUM_FRAMEINTERVALS, READWRITE, struct_v4l2_frmivalenum_sz);\n+  /* Entries from file: sys/wdog.h */\n+  _(WDOGIOC_GMODE, READWRITE, struct_wdog_mode_sz);\n+  _(WDOGIOC_SMODE, READ, struct_wdog_mode_sz);\n+  _(WDOGIOC_WHICH, WRITE, struct_wdog_mode_sz);\n+  _(WDOGIOC_TICKLE, NONE, 0);\n+  _(WDOGIOC_GTICKLER, WRITE, sizeof(int));\n+  _(WDOGIOC_GWDOGS, READWRITE, struct_wdog_conf_sz);\n+  /* Entries from file: soundcard.h */\n+  _(SNDCTL_DSP_RESET, NONE, 0);\n+  _(SNDCTL_DSP_SYNC, NONE, 0);\n+  _(SNDCTL_DSP_SPEED, READWRITE, sizeof(int));\n+  _(SOUND_PCM_READ_RATE, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_STEREO, READWRITE, sizeof(int));\n+  _(SNDCTL_DSP_GETBLKSIZE, READWRITE, sizeof(int));\n+  _(SNDCTL_DSP_SETFMT, READWRITE, sizeof(int));\n+  _(SOUND_PCM_READ_BITS, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_CHANNELS, READWRITE, sizeof(int));\n+  _(SOUND_PCM_READ_CHANNELS, WRITE, sizeof(int));\n+  _(SOUND_PCM_WRITE_FILTER, READWRITE, sizeof(int));\n+  _(SOUND_PCM_READ_FILTER, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_POST, NONE, 0);\n+  _(SNDCTL_DSP_SUBDIVIDE, READWRITE, sizeof(int));\n+  _(SNDCTL_DSP_SETFRAGMENT, READWRITE, sizeof(int));\n+  _(SNDCTL_DSP_GETFMTS, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_GETOSPACE, WRITE, struct_audio_buf_info_sz);\n+  _(SNDCTL_DSP_GETISPACE, WRITE, struct_audio_buf_info_sz);\n+  _(SNDCTL_DSP_NONBLOCK, NONE, 0);\n+  _(SNDCTL_DSP_GETCAPS, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_GETTRIGGER, WRITE, sizeof(int));\n+  _(SNDCTL_DSP_SETTRIGGER, READ, sizeof(int));\n+  _(SNDCTL_DSP_GETIPTR, WRITE, struct_count_info_sz);\n+  _(SNDCTL_DSP_GETOPTR, WRITE, struct_count_info_sz);\n+  _(SNDCTL_DSP_MAPINBUF, WRITE, struct_buffmem_desc_sz);\n+  _(SNDCTL_DSP_MAPOUTBUF, WRITE, struct_buffmem_desc_sz);\n+  _(SNDCTL_DSP_SETSYNCRO, NONE, 0);\n+  _(SNDCTL_DSP_SETDUPLEX, NONE, 0);\n+  _(SNDCTL_DSP_PROFILE, READ, sizeof(int));\n+  _(SNDCTL_DSP_GETODELAY, WRITE, sizeof(int));\n+  _(SOUND_MIXER_INFO, WRITE, struct_mixer_info_sz);\n+  _(SOUND_OLD_MIXER_INFO, WRITE, struct__old_mixer_info_sz);\n+  _(OSS_GETVERSION, WRITE, sizeof(int));\n+  _(SNDCTL_SYSINFO, WRITE, struct_oss_sysinfo_sz);\n+  _(SNDCTL_AUDIOINFO, READWRITE, struct_oss_audioinfo_sz);\n+  _(SNDCTL_ENGINEINFO, READWRITE, struct_oss_audioinfo_sz);\n+  _(SNDCTL_DSP_GETPLAYVOL, WRITE, sizeof(unsigned int));\n+  _(SNDCTL_DSP_SETPLAYVOL, READ, sizeof(unsigned int));\n+  _(SNDCTL_DSP_GETRECVOL, WRITE, sizeof(unsigned int));\n+  _(SNDCTL_DSP_SETRECVOL, READ, sizeof(unsigned int));\n+  _(SNDCTL_DSP_SKIP, NONE, 0);\n+  _(SNDCTL_DSP_SILENCE, NONE, 0);\n+#undef _\n+}\n+\n+static bool ioctl_initialized = false;\n+\n+struct ioctl_desc_compare {\n+  bool operator()(const ioctl_desc &left, const ioctl_desc &right) const {\n+    return left.req < right.req;\n+  }\n+};\n+\n+static void ioctl_init() {\n+  ioctl_table_fill();\n+  Sort(ioctl_table, ioctl_table_size, ioctl_desc_compare());\n+\n+  bool bad = false;\n+  for (unsigned i = 0; i < ioctl_table_size - 1; ++i) {\n+    if (ioctl_table[i].req >= ioctl_table[i + 1].req) {\n+      Printf(\"Duplicate or unsorted ioctl request id %x >= %x (%s vs %s)\\n\",\n+             ioctl_table[i].req, ioctl_table[i + 1].req, ioctl_table[i].name,\n+             ioctl_table[i + 1].name);\n+      bad = true;\n+    }\n+  }\n+\n+  if (bad)\n+    Die();\n+\n+  ioctl_initialized = true;\n+}\n+\n+static const ioctl_desc *ioctl_table_lookup(unsigned req) {\n+  int left = 0;\n+  int right = ioctl_table_size;\n+  while (left < right) {\n+    int mid = (left + right) / 2;\n+    if (ioctl_table[mid].req < req)\n+      left = mid + 1;\n+    else\n+      right = mid;\n+  }\n+  if (left == right && ioctl_table[left].req == req)\n+    return ioctl_table + left;\n+  else\n+    return nullptr;\n+}\n+\n+static bool ioctl_decode(unsigned req, ioctl_desc *desc) {\n+  CHECK(desc);\n+  desc->req = req;\n+  desc->name = \"<DECODED_IOCTL>\";\n+  desc->size = IOC_SIZE(req);\n+  // Sanity check.\n+  if (desc->size > 0xFFFF)\n+    return false;\n+  unsigned dir = IOC_DIR(req);\n+  switch (dir) {\n+  case IOC_NONE:\n+    desc->type = ioctl_desc::NONE;\n+    break;\n+  case IOC_READ | IOC_WRITE:\n+    desc->type = ioctl_desc::READWRITE;\n+    break;\n+  case IOC_READ:\n+    desc->type = ioctl_desc::WRITE;\n+    break;\n+  case IOC_WRITE:\n+    desc->type = ioctl_desc::READ;\n+    break;\n+  default:\n+    return false;\n+  }\n+  // Size can be 0 iff type is NONE.\n+  if ((desc->type == IOC_NONE) != (desc->size == 0))\n+    return false;\n+  // Sanity check.\n+  if (IOC_TYPE(req) == 0)\n+    return false;\n+  return true;\n+}\n+\n+static const ioctl_desc *ioctl_lookup(unsigned req) {\n+  const ioctl_desc *desc = ioctl_table_lookup(req);\n+  if (desc)\n+    return desc;\n+\n+  // Try stripping access size from the request id.\n+  desc = ioctl_table_lookup(req & ~(IOC_SIZEMASK << IOC_SIZESHIFT));\n+  // Sanity check: requests that encode access size are either read or write and\n+  // have size of 0 in the table.\n+  if (desc && desc->size == 0 &&\n+      (desc->type == ioctl_desc::READWRITE || desc->type == ioctl_desc::WRITE ||\n+       desc->type == ioctl_desc::READ))\n+    return desc;\n+  return nullptr;\n+}\n+\n+static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n+                             unsigned request, void *arg) {\n+  if (desc->type == ioctl_desc::READ || desc->type == ioctl_desc::READWRITE) {\n+    unsigned size = desc->size ? desc->size : IOC_SIZE(request);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, arg, size);\n+  }\n+  if (desc->type != ioctl_desc::CUSTOM)\n+    return;\n+  if (request == IOCTL_SIOCGIFCONF) {\n+    struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, (char *)&ifc->ifc_len,\n+                                  sizeof(ifc->ifc_len));\n+  }\n+}\n+\n+static void ioctl_common_post(void *ctx, const ioctl_desc *desc, int res, int d,\n+                              unsigned request, void *arg) {\n+  if (desc->type == ioctl_desc::WRITE || desc->type == ioctl_desc::READWRITE) {\n+    // FIXME: add verbose output\n+    unsigned size = desc->size ? desc->size : IOC_SIZE(request);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, arg, size);\n+  }\n+  if (desc->type != ioctl_desc::CUSTOM)\n+    return;\n+  if (request == IOCTL_SIOCGIFCONF) {\n+    struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifc->ifc_ifcu.ifcu_req, ifc->ifc_len);\n+  }\n+}\n+\n+#endif // SANITIZER_NETBSD"}, {"sha": "6597efa2def9ff87c755b6a0ca7a7f453a476cf2", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -50,6 +50,12 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_trace_pc_guard_coverage();\n \n   SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(__sanitizer::u32 *guard);\n+\n+  // Returns 1 on the first call, then returns 0 thereafter.  Called by the tool\n+  // to ensure only one report is printed when multiple errors occur\n+  // simultaneously.\n+  SANITIZER_INTERFACE_ATTRIBUTE int __sanitizer_acquire_crash_state();\n+\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_annotate_contiguous_container(const void *beg,\n                                                  const void *end,"}, {"sha": "8bd1bcacac107fc7cc3743d21dbb7a87c7c0f144", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -17,6 +17,9 @@\n # define SANITIZER_DEBUG 0\n #endif\n \n+#define SANITIZER_STRINGIFY_(S) #S\n+#define SANITIZER_STRINGIFY(S) SANITIZER_STRINGIFY_(S)\n+\n // Only use SANITIZER_*ATTRIBUTE* before the function return type!\n #if SANITIZER_WINDOWS\n #if SANITIZER_IMPORT_INTERFACE\n@@ -34,7 +37,8 @@\n #endif\n \n // TLS is handled differently on different platforms\n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_NETBSD || \\\n+  SANITIZER_FREEBSD || SANITIZER_OPENBSD\n # define SANITIZER_TLS_INITIAL_EXEC_ATTRIBUTE \\\n     __attribute__((tls_model(\"initial-exec\"))) thread_local\n #else\n@@ -63,7 +67,7 @@\n // SANITIZER_SUPPORTS_WEAK_HOOKS means that we support real weak functions that\n // will evaluate to a null pointer when not defined.\n #ifndef SANITIZER_SUPPORTS_WEAK_HOOKS\n-#if SANITIZER_LINUX && !SANITIZER_GO\n+#if (SANITIZER_LINUX || SANITIZER_SOLARIS) && !SANITIZER_GO\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n // Before Xcode 4.5, the Darwin linker doesn't reliably support undefined\n // weak symbols.  Mac OS X 10.9/Darwin 13 is the first release only supported\n@@ -92,12 +96,24 @@\n \n // We can use .preinit_array section on Linux to call sanitizer initialization\n // functions very early in the process startup (unless PIC macro is defined).\n+//\n+// On FreeBSD, .preinit_array functions are called with rtld_bind_lock writer\n+// lock held. It will lead to dead lock if unresolved PLT functions (which helds\n+// rtld_bind_lock reader lock) are called inside .preinit_array functions.\n+//\n // FIXME: do we have anything like this on Mac?\n-#if SANITIZER_LINUX && !SANITIZER_ANDROID && !defined(PIC)\n+#ifndef SANITIZER_CAN_USE_PREINIT_ARRAY\n+#if ((SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_OPENBSD || \\\n+     SANITIZER_FUCHSIA) && !defined(PIC)\n+#define SANITIZER_CAN_USE_PREINIT_ARRAY 1\n+// Before Solaris 11.4, .preinit_array is fully supported only with GNU ld.\n+// FIXME: Check for those conditions.\n+#elif SANITIZER_SOLARIS && !defined(PIC)\n # define SANITIZER_CAN_USE_PREINIT_ARRAY 1\n #else\n # define SANITIZER_CAN_USE_PREINIT_ARRAY 0\n #endif\n+#endif  // SANITIZER_CAN_USE_PREINIT_ARRAY\n \n // GCC does not understand __has_feature\n #if !defined(__has_feature)\n@@ -146,9 +162,14 @@ typedef unsigned error_t;\n typedef int fd_t;\n typedef int error_t;\n #endif\n+#if SANITIZER_SOLARIS && !defined(_LP64)\n+typedef long pid_t;\n+#else\n typedef int pid_t;\n+#endif\n \n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_MAC || \\\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_MAC || \\\n     (SANITIZER_LINUX && defined(__x86_64__))\n typedef u64 OFF_T;\n #else\n@@ -159,20 +180,15 @@ typedef u64  OFF64_T;\n #if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\n typedef uptr operator_new_size_type;\n #else\n-# if defined(__s390__) && !defined(__s390x__)\n+# if SANITIZER_OPENBSD || defined(__s390__) && !defined(__s390x__)\n // Special case: 31-bit s390 has unsigned long as size_t.\n typedef unsigned long operator_new_size_type;\n # else\n typedef u32 operator_new_size_type;\n # endif\n #endif\n \n-#if SANITIZER_MAC\n-// On Darwin, thread IDs are 64-bit even on 32-bit systems.\n typedef u64 tid_t;\n-#else\n-typedef uptr tid_t;\n-#endif\n \n // ----------- ATTENTION -------------\n // This header should NOT include any other headers to avoid portability issues.\n@@ -198,6 +214,7 @@ typedef uptr tid_t;\n # define LIKELY(x) (x)\n # define UNLIKELY(x) (x)\n # define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */ (void)0\n+# define WARN_UNUSED_RESULT\n #else  // _MSC_VER\n # define ALWAYS_INLINE inline __attribute__((always_inline))\n # define ALIAS(x) __attribute__((alias(x)))\n@@ -216,6 +233,7 @@ typedef uptr tid_t;\n # else\n #  define PREFETCH(x) __builtin_prefetch(x)\n # endif\n+# define WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n #endif  // _MSC_VER\n \n #if !defined(_MSC_VER) || defined(__clang__)\n@@ -255,8 +273,6 @@ typedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n // NOTE: Functions below must be defined in each run-time.\n void NORETURN Die();\n \n-// FIXME: No, this shouldn't be in the sanitizer interface.\n-SANITIZER_INTERFACE_ATTRIBUTE\n void NORETURN CheckFailed(const char *file, int line, const char *cond,\n                           u64 v1, u64 v2);\n \n@@ -344,6 +360,12 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n #define INT64_MAX              (__INT64_C(9223372036854775807))\n #undef UINT64_MAX\n #define UINT64_MAX             (__UINT64_C(18446744073709551615))\n+#undef UINTPTR_MAX\n+#if SANITIZER_WORDSIZE == 64\n+# define UINTPTR_MAX           (18446744073709551615UL)\n+#else\n+# define UINTPTR_MAX           (4294967295U)\n+#endif  // SANITIZER_WORDSIZE == 64\n \n enum LinkerInitialized { LINKER_INITIALIZED = 0 };\n \n@@ -399,11 +421,13 @@ namespace __dfsan { using namespace __sanitizer; }  // NOLINT\n namespace __esan  { using namespace __sanitizer; }  // NOLINT\n namespace __lsan  { using namespace __sanitizer; }  // NOLINT\n namespace __msan  { using namespace __sanitizer; }  // NOLINT\n+namespace __hwasan  { using namespace __sanitizer; }  // NOLINT\n namespace __tsan  { using namespace __sanitizer; }  // NOLINT\n namespace __scudo { using namespace __sanitizer; }  // NOLINT\n namespace __ubsan { using namespace __sanitizer; }  // NOLINT\n namespace __xray  { using namespace __sanitizer; }  // NOLINT\n namespace __interception  { using namespace __sanitizer; }  // NOLINT\n+namespace __hwasan  { using namespace __sanitizer; }  // NOLINT\n \n \n #endif  // SANITIZER_DEFS_H"}, {"sha": "94fa69b6a2da260b13f5ef3f1fbe1ec8c354649d", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -70,18 +70,19 @@ void *internal_memmove(void *dest, const void *src, uptr n) {\n   return dest;\n }\n \n-// Semi-fast bzero for 16-aligned data. Still far from peak performance.\n-void internal_bzero_aligned16(void *s, uptr n) {\n-  struct ALIGNED(16) S16 { u64 a, b; };\n-  CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);\n-  for (S16 *p = reinterpret_cast<S16*>(s), *end = p + n / 16; p < end; p++) {\n-    p->a = p->b = 0;\n-    // Make sure this does not become memset.\n-    SanitizerBreakOptimization(nullptr);\n-  }\n-}\n-\n void *internal_memset(void* s, int c, uptr n) {\n+  // Optimize for the most performance-critical case:\n+  if ((reinterpret_cast<uptr>(s) % 16) == 0 && (n % 16) == 0) {\n+    u64 *p = reinterpret_cast<u64*>(s);\n+    u64 *e = p + n / 8;\n+    u64 v = c;\n+    v |= v << 8;\n+    v |= v << 16;\n+    v |= v << 32;\n+    for (; p < e; p += 2)\n+      p[0] = p[1] = v;\n+    return s;\n+  }\n   // The next line prevents Clang from making a call to memset() instead of the\n   // loop below.\n   // FIXME: building the runtime with -ffreestanding is a better idea. However\n@@ -110,14 +111,6 @@ char* internal_strdup(const char *s) {\n   return s2;\n }\n \n-char* internal_strndup(const char *s, uptr n) {\n-  uptr len = internal_strnlen(s, n);\n-  char *s2 = (char*)InternalAlloc(len + 1);\n-  internal_memcpy(s2, s, len);\n-  s2[len] = 0;\n-  return s2;\n-}\n-\n int internal_strcmp(const char *s1, const char *s2) {\n   while (true) {\n     unsigned c1 = *s1;\n@@ -232,13 +225,7 @@ char *internal_strstr(const char *haystack, const char *needle) {\n   return nullptr;\n }\n \n-uptr internal_wcslen(const wchar_t *s) {\n-  uptr i = 0;\n-  while (s[i]) i++;\n-  return i;\n-}\n-\n-s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n+s64 internal_simple_strtoll(const char *nptr, const char **endptr, int base) {\n   CHECK_EQ(base, 10);\n   while (IsSpace(*nptr)) nptr++;\n   int sgn = 1;"}, {"sha": "4bc6791be5620d87f7067ccf2d8fbe6fd102f9fe", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -30,16 +30,13 @@ void *internal_memrchr(const void *s, int c, uptr n);\n int internal_memcmp(const void* s1, const void* s2, uptr n);\n void *internal_memcpy(void *dest, const void *src, uptr n);\n void *internal_memmove(void *dest, const void *src, uptr n);\n-// Set [s, s + n) to 0. Both s and n should be 16-aligned.\n-void internal_bzero_aligned16(void *s, uptr n);\n // Should not be used in performance-critical places.\n void *internal_memset(void *s, int c, uptr n);\n char* internal_strchr(const char *s, int c);\n char *internal_strchrnul(const char *s, int c);\n int internal_strcmp(const char *s1, const char *s2);\n uptr internal_strcspn(const char *s, const char *reject);\n char *internal_strdup(const char *s);\n-char *internal_strndup(const char *s, uptr n);\n uptr internal_strlen(const char *s);\n uptr internal_strlcat(char *dst, const char *src, uptr maxlen);\n char *internal_strncat(char *dst, const char *src, uptr n);\n@@ -48,11 +45,9 @@ uptr internal_strlcpy(char *dst, const char *src, uptr maxlen);\n char *internal_strncpy(char *dst, const char *src, uptr n);\n uptr internal_strnlen(const char *s, uptr maxlen);\n char *internal_strrchr(const char *s, int c);\n-// This is O(N^2), but we are not using it in hot places.\n-uptr internal_wcslen(const wchar_t *s);\n char *internal_strstr(const char *haystack, const char *needle);\n // Works only for base=10 and doesn't set errno.\n-s64 internal_simple_strtoll(const char *nptr, char **endptr, int base);\n+s64 internal_simple_strtoll(const char *nptr, const char **endptr, int base);\n int internal_snprintf(char *buffer, uptr length, const char *format, ...);\n \n // Return true if all bytes in [mem, mem+size) are zero."}, {"sha": "0a551490b7f9038140c182233257d27c1abcf810", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -7,7 +7,8 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || \\\n+    SANITIZER_NETBSD || SANITIZER_OPENBSD\n \n #include \"sanitizer_libignore.h\"\n #include \"sanitizer_flags.h\"\n@@ -78,7 +79,7 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n         lib->name = internal_strdup(mod.full_name());\n         const uptr idx =\n             atomic_load(&ignored_ranges_count_, memory_order_relaxed);\n-        CHECK_LT(idx, kMaxLibs);\n+        CHECK_LT(idx, ARRAY_SIZE(ignored_code_ranges_));\n         ignored_code_ranges_[idx].begin = range.beg;\n         ignored_code_ranges_[idx].end = range.end;\n         atomic_store(&ignored_ranges_count_, idx + 1, memory_order_release);\n@@ -107,7 +108,7 @@ void LibIgnore::OnLibraryLoaded(const char *name) {\n                 range.beg, range.end, mod.full_name());\n         const uptr idx =\n             atomic_load(&instrumented_ranges_count_, memory_order_relaxed);\n-        CHECK_LT(idx, kMaxLibs);\n+        CHECK_LT(idx, ARRAY_SIZE(instrumented_code_ranges_));\n         instrumented_code_ranges_[idx].begin = range.beg;\n         instrumented_code_ranges_[idx].end = range.end;\n         atomic_store(&instrumented_ranges_count_, idx + 1,"}, {"sha": "b2884fa3c91feefac5812ffdb7e278622bdecf4c", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -64,14 +64,16 @@ class LibIgnore {\n     return (pc >= range.begin && pc < range.end);\n   }\n \n-  static const uptr kMaxLibs = 128;\n+  static const uptr kMaxIgnoredRanges = 128;\n+  static const uptr kMaxInstrumentedRanges = 1024;\n+  static const uptr kMaxLibs = 1024;\n \n   // Hot part:\n   atomic_uintptr_t ignored_ranges_count_;\n-  LibCodeRange ignored_code_ranges_[kMaxLibs];\n+  LibCodeRange ignored_code_ranges_[kMaxIgnoredRanges];\n \n   atomic_uintptr_t instrumented_ranges_count_;\n-  LibCodeRange instrumented_code_ranges_[kMaxLibs];\n+  LibCodeRange instrumented_code_ranges_[kMaxInstrumentedRanges];\n \n   // Cold part:\n   BlockingMutex mutex_;"}, {"sha": "f1f70ec57fc96dc9a42f6f20d4e4f04484f4f26f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 462, "deletions": 222, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,27 +12,23 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n+#include \"sanitizer_getauxval.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_mutex.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n-#include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n #if SANITIZER_LINUX\n #include <asm/param.h>\n #endif\n \n-#if SANITIZER_NETBSD\n-#include <lwp.h>\n-#endif\n-\n // For mips64, syscall(__NR_stat) fills the buffer in the 'struct kernel_stat'\n // format. Struct kernel_stat is defined as 'struct stat' in asm/stat.h. To\n // access stat from asm/stat.h, without conflicting with definition in\n@@ -51,14 +47,24 @@\n #include <link.h>\n #include <pthread.h>\n #include <sched.h>\n+#include <signal.h>\n #include <sys/mman.h>\n+#include <sys/param.h>\n+#if !SANITIZER_SOLARIS\n #include <sys/ptrace.h>\n+#endif\n #include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/syscall.h>\n #include <sys/time.h>\n #include <sys/types.h>\n+#if !SANITIZER_OPENBSD\n #include <ucontext.h>\n+#endif\n+#if SANITIZER_OPENBSD\n+#include <sys/futex.h>\n+#include <sys/sysctl.h>\n+#endif\n #include <unistd.h>\n \n #if SANITIZER_LINUX\n@@ -78,32 +84,23 @@ extern \"C\" {\n // FreeBSD 9.2 and 10.0.\n #include <sys/umtx.h>\n }\n-extern char **environ;  // provided by crt1\n+#include <sys/thr.h>\n #endif  // SANITIZER_FREEBSD\n \n #if SANITIZER_NETBSD\n #include <limits.h>  // For NAME_MAX\n #include <sys/sysctl.h>\n-extern char **environ;  // provided by crt1\n-#endif                  // SANITIZER_NETBSD\n-\n-#if !SANITIZER_ANDROID\n-#include <sys/signal.h>\n-#endif\n-\n-#ifndef __GLIBC_PREREQ\n-#define __GLIBC_PREREQ(x, y) 0\n-#endif\n+#include <sys/exec.h>\n+extern struct ps_strings *__ps_strings;\n+#endif  // SANITIZER_NETBSD\n \n-#if SANITIZER_LINUX && __GLIBC_PREREQ(2, 16)\n-# define SANITIZER_USE_GETAUXVAL 1\n-#else\n-# define SANITIZER_USE_GETAUXVAL 0\n+#if SANITIZER_SOLARIS\n+#include <stdlib.h>\n+#include <thread.h>\n+#define environ _environ\n #endif\n \n-#if SANITIZER_USE_GETAUXVAL\n-#include <sys/auxv.h>\n-#endif\n+extern char **environ;\n \n #if SANITIZER_LINUX\n // <linux/time.h>\n@@ -115,13 +112,16 @@ struct kernel_timeval {\n // <linux/futex.h> is broken on some linux distributions.\n const int FUTEX_WAIT = 0;\n const int FUTEX_WAKE = 1;\n+const int FUTEX_PRIVATE_FLAG = 128;\n+const int FUTEX_WAIT_PRIVATE = FUTEX_WAIT | FUTEX_PRIVATE_FLAG;\n+const int FUTEX_WAKE_PRIVATE = FUTEX_WAKE | FUTEX_PRIVATE_FLAG;\n #endif  // SANITIZER_LINUX\n \n // Are we using 32-bit or 64-bit Linux syscalls?\n // x32 (which defines __x86_64__) has SANITIZER_WORDSIZE == 32\n // but it still needs to use 64-bit syscalls.\n-#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__powerpc64__) || \\\n-    SANITIZER_WORDSIZE == 64)\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__powerpc64__) ||       \\\n+                        SANITIZER_WORDSIZE == 64)\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 1\n #else\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 0\n@@ -133,6 +133,9 @@ extern void internal_sigreturn();\n }\n #endif\n \n+// Note : FreeBSD had implemented both\n+// Linux and OpenBSD apis, available from\n+// future 12.x version most likely\n #if SANITIZER_LINUX && defined(__NR_getrandom)\n # if !defined(GRND_NONBLOCK)\n #  define GRND_NONBLOCK 1\n@@ -142,24 +145,34 @@ extern void internal_sigreturn();\n # define SANITIZER_USE_GETRANDOM 0\n #endif  // SANITIZER_LINUX && defined(__NR_getrandom)\n \n+#if SANITIZER_OPENBSD\n+# define SANITIZER_USE_GETENTROPY 1\n+#else\n+# if SANITIZER_FREEBSD && __FreeBSD_version >= 1200000\n+#   define SANITIZER_USE_GETENTROPY 1\n+# else\n+#   define SANITIZER_USE_GETENTROPY 0\n+# endif\n+#endif // SANITIZER_USE_GETENTROPY\n+\n namespace __sanitizer {\n \n #if SANITIZER_LINUX && defined(__x86_64__)\n #include \"sanitizer_syscall_linux_x86_64.inc\"\n #elif SANITIZER_LINUX && defined(__aarch64__)\n #include \"sanitizer_syscall_linux_aarch64.inc\"\n+#elif SANITIZER_LINUX && defined(__arm__)\n+#include \"sanitizer_syscall_linux_arm.inc\"\n #else\n #include \"sanitizer_syscall_generic.inc\"\n #endif\n \n // --------------- sanitizer_libc.h\n-#if !SANITIZER_S390\n+#if !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n+#if !SANITIZER_S390 && !SANITIZER_OPENBSD\n uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n                    OFF_T offset) {\n-#if SANITIZER_NETBSD\n-  return internal_syscall_ptr(SYSCALL(mmap), addr, length, prot, flags, fd,\n-                              (long)0, offset);\n-#elif SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n   return internal_syscall(SYSCALL(mmap), (uptr)addr, length, prot, flags, fd,\n                           offset);\n #else\n@@ -169,15 +182,17 @@ uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n                           offset / 4096);\n #endif\n }\n-#endif // !SANITIZER_S390\n+#endif // !SANITIZER_S390 && !SANITIZER_OPENBSD\n \n+#if !SANITIZER_OPENBSD\n uptr internal_munmap(void *addr, uptr length) {\n   return internal_syscall(SYSCALL(munmap), (uptr)addr, length);\n }\n \n int internal_mprotect(void *addr, uptr length, int prot) {\n   return internal_syscall(SYSCALL(mprotect), (uptr)addr, length, prot);\n }\n+#endif\n \n uptr internal_close(fd_t fd) {\n   return internal_syscall(SYSCALL(close), fd);\n@@ -202,34 +217,22 @@ uptr internal_open(const char *filename, int flags, u32 mode) {\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   sptr res;\n-#if SANITIZER_NETBSD\n-  HANDLE_EINTR(res, internal_syscall_ptr(SYSCALL(read), fd, buf, count));\n-#else\n-  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(read), fd, (uptr)buf,\n-               count));\n-#endif\n+  HANDLE_EINTR(res,\n+               (sptr)internal_syscall(SYSCALL(read), fd, (uptr)buf, count));\n   return res;\n }\n \n uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   sptr res;\n-#if SANITIZER_NETBSD\n-  HANDLE_EINTR(res, internal_syscall_ptr(SYSCALL(write), fd, buf, count));\n-#else\n-  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(write), fd, (uptr)buf,\n-               count));\n-#endif\n+  HANDLE_EINTR(res,\n+               (sptr)internal_syscall(SYSCALL(write), fd, (uptr)buf, count));\n   return res;\n }\n \n uptr internal_ftruncate(fd_t fd, uptr size) {\n   sptr res;\n-#if SANITIZER_NETBSD\n-  HANDLE_EINTR(res, internal_syscall(SYSCALL(ftruncate), fd, 0, (s64)size));\n-#else\n   HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(ftruncate), fd,\n                (OFF_T)size));\n-#endif\n   return res;\n }\n \n@@ -301,12 +304,11 @@ static void kernel_stat_to_stat(struct kernel_stat *in, struct stat *out) {\n #endif\n \n uptr internal_stat(const char *path, void *buf) {\n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n-  return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path,\n-                          (uptr)buf, 0);\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n+  return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path, (uptr)buf, 0);\n #elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n-  return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n-                          (uptr)buf, 0);\n+  return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path, (uptr)buf,\n+                          0);\n #elif SANITIZER_LINUX_USES_64BIT_SYSCALLS\n # if defined(__mips64)\n   // For mips64, stat syscall fills buffer in the format of kernel_stat\n@@ -326,14 +328,12 @@ uptr internal_stat(const char *path, void *buf) {\n }\n \n uptr internal_lstat(const char *path, void *buf) {\n-#if SANITIZER_NETBSD\n-  return internal_syscall(SYSCALL(lstat), path, buf);\n-#elif SANITIZER_FREEBSD\n-  return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path,\n-                          (uptr)buf, AT_SYMLINK_NOFOLLOW);\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n+  return internal_syscall(SYSCALL(fstatat), AT_FDCWD, (uptr)path, (uptr)buf,\n+                          AT_SYMLINK_NOFOLLOW);\n #elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n-  return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n-                         (uptr)buf, AT_SYMLINK_NOFOLLOW);\n+  return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path, (uptr)buf,\n+                          AT_SYMLINK_NOFOLLOW);\n #elif SANITIZER_LINUX_USES_64BIT_SYSCALLS\n # if SANITIZER_MIPS64\n   // For mips64, lstat syscall fills buffer in the format of kernel_stat\n@@ -353,8 +353,9 @@ uptr internal_lstat(const char *path, void *buf) {\n }\n \n uptr internal_fstat(fd_t fd, void *buf) {\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS || SANITIZER_NETBSD\n-# if SANITIZER_MIPS64\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD || \\\n+    SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+#if SANITIZER_MIPS64 && !SANITIZER_OPENBSD\n   // For mips64, fstat syscall fills buffer in the format of kernel_stat\n   struct kernel_stat kbuf;\n   int res = internal_syscall(SYSCALL(fstat), fd, &kbuf);\n@@ -387,26 +388,27 @@ uptr internal_dup2(int oldfd, int newfd) {\n }\n \n uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n-#if SANITIZER_NETBSD\n-  return internal_syscall_ptr(SYSCALL(readlink), path, buf, bufsize);\n-#elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n-  return internal_syscall(SYSCALL(readlinkat), AT_FDCWD,\n-                          (uptr)path, (uptr)buf, bufsize);\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(readlinkat), AT_FDCWD, (uptr)path, (uptr)buf,\n+                          bufsize);\n+#elif SANITIZER_OPENBSD\n+  return internal_syscall(SYSCALL(readlinkat), AT_FDCWD, (uptr)path, (uptr)buf,\n+                          bufsize);\n #else\n-  return internal_syscall(SYSCALL(readlink), (uptr)path, (uptr)buf, bufsize);\n+  return internal_syscall(SYSCALL(readlink), path, buf, bufsize);\n #endif\n }\n \n uptr internal_unlink(const char *path) {\n-#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS || SANITIZER_OPENBSD\n   return internal_syscall(SYSCALL(unlinkat), AT_FDCWD, (uptr)path, 0);\n #else\n   return internal_syscall(SYSCALL(unlink), (uptr)path);\n #endif\n }\n \n uptr internal_rename(const char *oldpath, const char *newpath) {\n-#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS || SANITIZER_OPENBSD\n   return internal_syscall(SYSCALL(renameat), AT_FDCWD, (uptr)oldpath, AT_FDCWD,\n                           (uptr)newpath);\n #else\n@@ -419,7 +421,7 @@ uptr internal_sched_yield() {\n }\n \n void internal__exit(int exitcode) {\n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n   internal_syscall(SYSCALL(exit), exitcode);\n #else\n   internal_syscall(SYSCALL(exit_group), exitcode);\n@@ -441,6 +443,7 @@ uptr internal_execve(const char *filename, char *const argv[],\n   return internal_syscall(SYSCALL(execve), (uptr)filename, (uptr)argv,\n                           (uptr)envp);\n }\n+#endif  // !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n \n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n@@ -455,36 +458,59 @@ bool FileExists(const char *filename) {\n   return S_ISREG(st.st_mode);\n }\n \n+#if !SANITIZER_NETBSD\n tid_t GetTid() {\n #if SANITIZER_FREEBSD\n-  return (uptr)pthread_self();\n-#elif SANITIZER_NETBSD\n-  return _lwp_self();\n+  long Tid;\n+  thr_self(&Tid);\n+  return Tid;\n+#elif SANITIZER_OPENBSD\n+  return internal_syscall(SYSCALL(getthrid));\n+#elif SANITIZER_SOLARIS\n+  return thr_self();\n #else\n   return internal_syscall(SYSCALL(gettid));\n #endif\n }\n \n+int TgKill(pid_t pid, tid_t tid, int sig) {\n+#if SANITIZER_LINUX\n+  return internal_syscall(SYSCALL(tgkill), pid, tid, sig);\n+#elif SANITIZER_FREEBSD\n+  return internal_syscall(SYSCALL(thr_kill2), pid, tid, sig);\n+#elif SANITIZER_OPENBSD\n+  (void)pid;\n+  return internal_syscall(SYSCALL(thrkill), tid, sig, nullptr);\n+#elif SANITIZER_SOLARIS\n+  (void)pid;\n+  return thr_kill(tid, sig);\n+#endif\n+}\n+#endif\n+\n+#if !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n u64 NanoTime() {\n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n   timeval tv;\n #else\n   kernel_timeval tv;\n #endif\n   internal_memset(&tv, 0, sizeof(tv));\n-#if SANITIZER_NETBSD\n-  internal_syscall_ptr(SYSCALL(gettimeofday), &tv, NULL);\n-#else\n-  internal_syscall(SYSCALL(gettimeofday), (uptr)&tv, 0);\n-#endif\n+  internal_syscall(SYSCALL(gettimeofday), &tv, 0);\n   return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n }\n \n+uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp) {\n+  return internal_syscall(SYSCALL(clock_gettime), clk_id, tp);\n+}\n+#endif  // !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n+\n // Like getenv, but reads env directly from /proc (on Linux) or parses the\n-// 'environ' array (on FreeBSD) and does not use libc. This function should be\n-// called first inside __asan_init.\n+// 'environ' array (on some others) and does not use libc. This function\n+// should be called first inside __asan_init.\n const char *GetEnv(const char *name) {\n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_OPENBSD || \\\n+    SANITIZER_SOLARIS\n   if (::environ != 0) {\n     uptr NameLen = internal_strlen(name);\n     for (char **Env = ::environ; *Env != 0; Env++) {\n@@ -522,13 +548,14 @@ const char *GetEnv(const char *name) {\n #endif\n }\n \n-#if !SANITIZER_FREEBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_NETBSD && !SANITIZER_OPENBSD\n extern \"C\" {\n-  SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;\n+SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;\n }\n #endif\n \n-#if !SANITIZER_GO && !SANITIZER_FREEBSD\n+#if !SANITIZER_GO && !SANITIZER_FREEBSD && !SANITIZER_NETBSD &&                \\\n+    !SANITIZER_OPENBSD\n static void ReadNullSepFileToArray(const char *path, char ***arr,\n                                    int arr_size) {\n   char *buff;\n@@ -553,11 +580,27 @@ static void ReadNullSepFileToArray(const char *path, char ***arr,\n }\n #endif\n \n+#if !SANITIZER_OPENBSD\n static void GetArgsAndEnv(char ***argv, char ***envp) {\n-#if !SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD\n+  // On FreeBSD, retrieving the argument and environment arrays is done via the\n+  // kern.ps_strings sysctl, which returns a pointer to a structure containing\n+  // this information. See also <sys/exec.h>.\n+  ps_strings *pss;\n+  uptr sz = sizeof(pss);\n+  if (internal_sysctlbyname(\"kern.ps_strings\", &pss, &sz, NULL, 0) == -1) {\n+    Printf(\"sysctl kern.ps_strings failed\\n\");\n+    Die();\n+  }\n+  *argv = pss->ps_argvstr;\n+  *envp = pss->ps_envstr;\n+#elif SANITIZER_NETBSD\n+  *argv = __ps_strings->ps_argvstr;\n+  *envp = __ps_strings->ps_envstr;\n+#else // SANITIZER_FREEBSD\n #if !SANITIZER_GO\n   if (&__libc_stack_end) {\n-#endif\n+#endif // !SANITIZER_GO\n     uptr* stack_end = (uptr*)__libc_stack_end;\n     int argc = *stack_end;\n     *argv = (char**)(stack_end + 1);\n@@ -568,20 +611,8 @@ static void GetArgsAndEnv(char ***argv, char ***envp) {\n     ReadNullSepFileToArray(\"/proc/self/cmdline\", argv, kMaxArgv);\n     ReadNullSepFileToArray(\"/proc/self/environ\", envp, kMaxEnvp);\n   }\n-#endif\n-#else\n-  // On FreeBSD, retrieving the argument and environment arrays is done via the\n-  // kern.ps_strings sysctl, which returns a pointer to a structure containing\n-  // this information. See also <sys/exec.h>.\n-  ps_strings *pss;\n-  size_t sz = sizeof(pss);\n-  if (sysctlbyname(\"kern.ps_strings\", &pss, &sz, NULL, 0) == -1) {\n-    Printf(\"sysctl kern.ps_strings failed\\n\");\n-    Die();\n-  }\n-  *argv = pss->ps_argvstr;\n-  *envp = pss->ps_envstr;\n-#endif\n+#endif // !SANITIZER_GO\n+#endif // SANITIZER_FREEBSD\n }\n \n char **GetArgv() {\n@@ -592,14 +623,33 @@ char **GetArgv() {\n \n void ReExec() {\n   char **argv, **envp;\n+  const char *pathname = \"/proc/self/exe\";\n+\n+#if SANITIZER_NETBSD\n+  static const int name[] = {\n+    CTL_KERN, KERN_PROC_ARGS, -1, KERN_PROC_PATHNAME,\n+  };\n+  char path[400];\n+  uptr len;\n+\n+  len = sizeof(path);\n+  if (internal_sysctl(name, ARRAY_SIZE(name), path, &len, NULL, 0) != -1)\n+    pathname = path;\n+#elif SANITIZER_SOLARIS\n+  pathname = getexecname();\n+  CHECK_NE(pathname, NULL);\n+#endif\n+\n   GetArgsAndEnv(&argv, &envp);\n-  uptr rv = internal_execve(\"/proc/self/exe\", argv, envp);\n+  uptr rv = internal_execve(pathname, argv, envp);\n   int rverrno;\n   CHECK_EQ(internal_iserror(rv, &rverrno), true);\n   Printf(\"execve failed, errno %d\\n\", rverrno);\n   Die();\n }\n+#endif\n \n+#if !SANITIZER_SOLARIS\n enum MutexState {\n   MtxUnlocked = 0,\n   MtxLocked = 1,\n@@ -619,9 +669,10 @@ void BlockingMutex::Lock() {\n #if SANITIZER_FREEBSD\n     _umtx_op(m, UMTX_OP_WAIT_UINT, MtxSleeping, 0, 0);\n #elif SANITIZER_NETBSD\n-    sched_yield(); /* No userspace futex-like synchromization */\n+    sched_yield(); /* No userspace futex-like synchronization */\n #else\n-    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n+    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAIT_PRIVATE, MtxSleeping,\n+                     0, 0, 0);\n #endif\n   }\n }\n@@ -634,9 +685,9 @@ void BlockingMutex::Unlock() {\n #if SANITIZER_FREEBSD\n     _umtx_op(m, UMTX_OP_WAKE, 1, 0, 0);\n #elif SANITIZER_NETBSD\n-                   /* No userspace futex-like synchromization */\n+                   /* No userspace futex-like synchronization */\n #else\n-    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAKE, 1, 0, 0, 0);\n+    internal_syscall(SYSCALL(futex), (uptr)m, FUTEX_WAKE_PRIVATE, 1, 0, 0, 0);\n #endif\n   }\n }\n@@ -645,12 +696,15 @@ void BlockingMutex::CheckLocked() {\n   atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n   CHECK_NE(MtxUnlocked, atomic_load(m, memory_order_relaxed));\n }\n+#endif // !SANITIZER_SOLARIS\n \n // ----------------- sanitizer_linux.h\n // The actual size of this structure is specified by d_reclen.\n // Note that getdents64 uses a different structure format. We only provide the\n // 32-bit syscall here.\n #if SANITIZER_NETBSD\n+// Not used\n+#elif SANITIZER_OPENBSD\n // struct dirent is different for Linux and us. At this moment, we use only\n // d_fileno (Linux call this d_ino), d_reclen, and d_name.\n struct linux_dirent {\n@@ -677,32 +731,16 @@ struct linux_dirent {\n };\n #endif\n \n+#if !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n // Syscall wrappers.\n uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n-#if SANITIZER_NETBSD\n-  // XXX We need additional work for ptrace:\n-  //   - for request, we use PT_FOO whereas Linux uses PTRACE_FOO\n-  //   - data is int for us, but void * for Linux\n-  //   - Linux sometimes uses data in the case where we use addr instead\n-  // At this moment, this function is used only within\n-  // \"#if SANITIZER_LINUX && defined(__x86_64__)\" block in\n-  // sanitizer_stoptheworld_linux_libcdep.cc.\n-  return internal_syscall_ptr(SYSCALL(ptrace), request, pid, (uptr)addr,\n-                              (uptr)data);\n-#else\n   return internal_syscall(SYSCALL(ptrace), request, pid, (uptr)addr,\n                           (uptr)data);\n-#endif\n }\n \n uptr internal_waitpid(int pid, int *status, int options) {\n-#if SANITIZER_NETBSD\n-  return internal_syscall(SYSCALL(wait4), pid, status, options,\n-                          NULL /* rusage */);\n-#else\n   return internal_syscall(SYSCALL(wait4), pid, (uptr)status, options,\n                           0 /* rusage */);\n-#endif\n }\n \n uptr internal_getpid() {\n@@ -714,9 +752,7 @@ uptr internal_getppid() {\n }\n \n uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count) {\n-#if SANITIZER_NETBSD\n-  return internal_syscall(SYSCALL(getdents), fd, dirp, (uptr)count);\n-#elif SANITIZER_FREEBSD\n+#if SANITIZER_FREEBSD\n   return internal_syscall(SYSCALL(getdirentries), fd, (uptr)dirp, count, NULL);\n #elif SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(getdents64), fd, (uptr)dirp, count);\n@@ -726,11 +762,7 @@ uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count) {\n }\n \n uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {\n-#if SANITIZER_NETBSD\n-  return internal_syscall64(SYSCALL(lseek), fd, 0, offset, whence);\n-#else\n   return internal_syscall(SYSCALL(lseek), fd, offset, whence);\n-#endif\n }\n \n #if SANITIZER_LINUX\n@@ -751,6 +783,25 @@ int internal_fork() {\n #endif\n }\n \n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n+int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n+                    uptr *oldlenp, const void *newp, uptr newlen) {\n+#if SANITIZER_OPENBSD\n+  return sysctl(name, namelen, oldp, (size_t *)oldlenp, (void *)newp,\n+                (size_t)newlen);\n+#else\n+  return sysctl(name, namelen, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n+#endif\n+}\n+\n+#if SANITIZER_FREEBSD\n+int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n+                          const void *newp, uptr newlen) {\n+  return sysctlbyname(sname, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n+}\n+#endif\n+#endif\n+\n #if SANITIZER_LINUX\n #define SA_RESTORER 0x04000000\n // Doesn't set sa_restorer if the caller did not set it, so use with caution\n@@ -809,19 +860,18 @@ int internal_sigaction_syscall(int signum, const void *act, void *oldact) {\n   __sanitizer_sigaction u_adjust;\n   internal_memcpy(&u_adjust, act, sizeof(u_adjust));\n #if !SANITIZER_ANDROID || !SANITIZER_MIPS32\n-    if (u_adjust.sa_restorer == nullptr) {\n-      u_adjust.sa_restorer = internal_sigreturn;\n-    }\n+  if (u_adjust.sa_restorer == nullptr) {\n+    u_adjust.sa_restorer = internal_sigreturn;\n+  }\n #endif\n-    return internal_sigaction_norestorer(signum, (const void *)&u_adjust,\n-                                         oldact);\n+  return internal_sigaction_norestorer(signum, (const void *)&u_adjust, oldact);\n }\n-#endif // defined(__x86_64__) && !SANITIZER_GO\n+#endif  // defined(__x86_64__) && !SANITIZER_GO\n #endif  // SANITIZER_LINUX\n \n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n-    __sanitizer_sigset_t *oldset) {\n-#if SANITIZER_FREEBSD || SANITIZER_NETBSD\n+                          __sanitizer_sigset_t *oldset) {\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n   return internal_syscall(SYSCALL(sigprocmask), how, set, oldset);\n #else\n   __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n@@ -860,75 +910,107 @@ bool internal_sigismember(__sanitizer_sigset_t *set, int signum) {\n   const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);\n   return k_set->sig[idx] & (1 << bit);\n }\n-#endif  // SANITIZER_LINUX\n+#elif SANITIZER_FREEBSD\n+void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {\n+  sigset_t *rset = reinterpret_cast<sigset_t *>(set);\n+  sigdelset(rset, signum);\n+}\n+\n+bool internal_sigismember(__sanitizer_sigset_t *set, int signum) {\n+  sigset_t *rset = reinterpret_cast<sigset_t *>(set);\n+  return sigismember(rset, signum);\n+}\n+#endif\n+#endif // !SANITIZER_SOLARIS\n \n+#if !SANITIZER_NETBSD\n // ThreadLister implementation.\n-ThreadLister::ThreadLister(int pid)\n-  : pid_(pid),\n-    descriptor_(-1),\n-    buffer_(4096),\n-    error_(true),\n-    entry_((struct linux_dirent *)buffer_.data()),\n-    bytes_read_(0) {\n+ThreadLister::ThreadLister(pid_t pid) : pid_(pid), buffer_(4096) {\n   char task_directory_path[80];\n   internal_snprintf(task_directory_path, sizeof(task_directory_path),\n                     \"/proc/%d/task/\", pid);\n-  uptr openrv = internal_open(task_directory_path, O_RDONLY | O_DIRECTORY);\n-  if (internal_iserror(openrv)) {\n-    error_ = true;\n+  descriptor_ = internal_open(task_directory_path, O_RDONLY | O_DIRECTORY);\n+  if (internal_iserror(descriptor_)) {\n     Report(\"Can't open /proc/%d/task for reading.\\n\", pid);\n-  } else {\n-    error_ = false;\n-    descriptor_ = openrv;\n   }\n }\n \n-int ThreadLister::GetNextTID() {\n-  int tid = -1;\n-  do {\n-    if (error_)\n-      return -1;\n-    if ((char *)entry_ >= &buffer_[bytes_read_] && !GetDirectoryEntries())\n-      return -1;\n-    if (entry_->d_ino != 0 && entry_->d_name[0] >= '0' &&\n-        entry_->d_name[0] <= '9') {\n-      // Found a valid tid.\n-      tid = (int)internal_atoll(entry_->d_name);\n+ThreadLister::Result ThreadLister::ListThreads(\n+    InternalMmapVector<tid_t> *threads) {\n+  if (internal_iserror(descriptor_))\n+    return Error;\n+  internal_lseek(descriptor_, 0, SEEK_SET);\n+  threads->clear();\n+\n+  Result result = Ok;\n+  for (bool first_read = true;; first_read = false) {\n+    // Resize to max capacity if it was downsized by IsAlive.\n+    buffer_.resize(buffer_.capacity());\n+    CHECK_GE(buffer_.size(), 4096);\n+    uptr read = internal_getdents(\n+        descriptor_, (struct linux_dirent *)buffer_.data(), buffer_.size());\n+    if (!read)\n+      return result;\n+    if (internal_iserror(read)) {\n+      Report(\"Can't read directory entries from /proc/%d/task.\\n\", pid_);\n+      return Error;\n     }\n-    entry_ = (struct linux_dirent *)(((char *)entry_) + entry_->d_reclen);\n-  } while (tid < 0);\n-  return tid;\n-}\n \n-void ThreadLister::Reset() {\n-  if (error_ || descriptor_ < 0)\n-    return;\n-  internal_lseek(descriptor_, 0, SEEK_SET);\n-}\n+    for (uptr begin = (uptr)buffer_.data(), end = begin + read; begin < end;) {\n+      struct linux_dirent *entry = (struct linux_dirent *)begin;\n+      begin += entry->d_reclen;\n+      if (entry->d_ino == 1) {\n+        // Inode 1 is for bad blocks and also can be a reason for early return.\n+        // Should be emitted if kernel tried to output terminating thread.\n+        // See proc_task_readdir implementation in Linux.\n+        result = Incomplete;\n+      }\n+      if (entry->d_ino && *entry->d_name >= '0' && *entry->d_name <= '9')\n+        threads->push_back(internal_atoll(entry->d_name));\n+    }\n \n-ThreadLister::~ThreadLister() {\n-  if (descriptor_ >= 0)\n-    internal_close(descriptor_);\n+    // Now we are going to detect short-read or early EOF. In such cases Linux\n+    // can return inconsistent list with missing alive threads.\n+    // Code will just remember that the list can be incomplete but it will\n+    // continue reads to return as much as possible.\n+    if (!first_read) {\n+      // The first one was a short-read by definition.\n+      result = Incomplete;\n+    } else if (read > buffer_.size() - 1024) {\n+      // Read was close to the buffer size. So double the size and assume the\n+      // worst.\n+      buffer_.resize(buffer_.size() * 2);\n+      result = Incomplete;\n+    } else if (!threads->empty() && !IsAlive(threads->back())) {\n+      // Maybe Linux early returned from read on terminated thread (!pid_alive)\n+      // and failed to restore read position.\n+      // See next_tid and proc_task_instantiate in Linux.\n+      result = Incomplete;\n+    }\n+  }\n }\n \n-bool ThreadLister::error() { return error_; }\n-\n-bool ThreadLister::GetDirectoryEntries() {\n-  CHECK_GE(descriptor_, 0);\n-  CHECK_NE(error_, true);\n-  bytes_read_ = internal_getdents(descriptor_,\n-                                  (struct linux_dirent *)buffer_.data(),\n-                                  buffer_.size());\n-  if (internal_iserror(bytes_read_)) {\n-    Report(\"Can't read directory entries from /proc/%d/task.\\n\", pid_);\n-    error_ = true;\n+bool ThreadLister::IsAlive(int tid) {\n+  // /proc/%d/task/%d/status uses same call to detect alive threads as\n+  // proc_task_readdir. See task_state implementation in Linux.\n+  char path[80];\n+  internal_snprintf(path, sizeof(path), \"/proc/%d/task/%d/status\", pid_, tid);\n+  if (!ReadFileToVector(path, &buffer_) || buffer_.empty())\n     return false;\n-  } else if (bytes_read_ == 0) {\n+  buffer_.push_back(0);\n+  static const char kPrefix[] = \"\\nPPid:\";\n+  const char *field = internal_strstr(buffer_.data(), kPrefix);\n+  if (!field)\n     return false;\n-  }\n-  entry_ = (struct linux_dirent *)buffer_.data();\n-  return true;\n+  field += internal_strlen(kPrefix);\n+  return (int)internal_atoll(field) != 0;\n+}\n+\n+ThreadLister::~ThreadLister() {\n+  if (!internal_iserror(descriptor_))\n+    internal_close(descriptor_);\n }\n+#endif\n \n #if SANITIZER_WORDSIZE == 32\n // Take care of unusable kernel area in top gigabyte.\n@@ -966,7 +1048,7 @@ static uptr GetKernelAreaSize() {\n #endif  // SANITIZER_WORDSIZE == 32\n \n uptr GetMaxVirtualAddress() {\n-#if SANITIZER_NETBSD && defined(__x86_64__)\n+#if (SANITIZER_NETBSD || SANITIZER_OPENBSD) && defined(__x86_64__)\n   return 0x7f7ffffff000ULL;  // (0x00007f8000000000 - PAGE_SIZE)\n #elif SANITIZER_WORDSIZE == 64\n # if defined(__powerpc64__) || defined(__aarch64__)\n@@ -989,15 +1071,21 @@ uptr GetMaxVirtualAddress() {\n # if defined(__s390__)\n   return (1ULL << 31) - 1;  // 0x7fffffff;\n # else\n-  uptr res = (1ULL << 32) - 1;  // 0xffffffff;\n-  if (!common_flags()->full_address_space)\n-    res -= GetKernelAreaSize();\n-  CHECK_LT(reinterpret_cast<uptr>(&res), res);\n-  return res;\n+  return (1ULL << 32) - 1;  // 0xffffffff;\n # endif\n #endif  // SANITIZER_WORDSIZE\n }\n \n+uptr GetMaxUserVirtualAddress() {\n+  uptr addr = GetMaxVirtualAddress();\n+#if SANITIZER_WORDSIZE == 32 && !defined(__s390__)\n+  if (!common_flags()->full_address_space)\n+    addr -= GetKernelAreaSize();\n+  CHECK_LT(reinterpret_cast<uptr>(&addr), addr);\n+#endif\n+  return addr;\n+}\n+\n uptr GetPageSize() {\n // Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n #if SANITIZER_ANDROID\n@@ -1011,16 +1099,23 @@ uptr GetPageSize() {\n #endif\n }\n \n+#if !SANITIZER_OPENBSD\n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n+#if SANITIZER_SOLARIS\n+  const char *default_module_name = getexecname();\n+  CHECK_NE(default_module_name, NULL);\n+  return internal_snprintf(buf, buf_len, \"%s\", default_module_name);\n+#else\n #if SANITIZER_FREEBSD || SANITIZER_NETBSD\n #if SANITIZER_FREEBSD\n   const int Mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};\n #else\n   const int Mib[4] = {CTL_KERN, KERN_PROC_ARGS, -1, KERN_PROC_PATHNAME};\n #endif\n   const char *default_module_name = \"kern.proc.pathname\";\n-  size_t Size = buf_len;\n-  bool IsErr = (sysctl(Mib, ARRAY_SIZE(Mib), buf, &Size, NULL, 0) != 0);\n+  uptr Size = buf_len;\n+  bool IsErr =\n+      (internal_sysctl(Mib, ARRAY_SIZE(Mib), buf, &Size, NULL, 0) != 0);\n   int readlink_error = IsErr ? errno : 0;\n   uptr module_name_len = Size;\n #else\n@@ -1029,7 +1124,7 @@ uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n       default_module_name, buf, buf_len);\n   int readlink_error;\n   bool IsErr = internal_iserror(module_name_len, &readlink_error);\n-#endif\n+#endif  // SANITIZER_SOLARIS\n   if (IsErr) {\n     // We can't read binary name for some reason, assume it's unknown.\n     Report(\"WARNING: reading executable name failed with errno %d, \"\n@@ -1039,7 +1134,9 @@ uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n     CHECK_LT(module_name_len, buf_len);\n   }\n   return module_name_len;\n+#endif\n }\n+#endif // !SANITIZER_OPENBSD\n \n uptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len) {\n #if SANITIZER_LINUX\n@@ -1072,10 +1169,10 @@ bool LibraryNameIs(const char *full_name, const char *base_name) {\n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr)) {\n   CHECK_NE(map, nullptr);\n-#if !SANITIZER_FREEBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n   typedef ElfW(Phdr) Elf_Phdr;\n   typedef ElfW(Ehdr) Elf_Ehdr;\n-#endif  // !SANITIZER_FREEBSD\n+#endif // !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n   char *base = (char *)map->l_addr;\n   Elf_Ehdr *ehdr = (Elf_Ehdr *)base;\n   char *phdrs = base + ehdr->e_phoff;\n@@ -1168,7 +1265,7 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                          \"d\"(parent_tidptr),\n                          \"r\"(r8),\n                          \"r\"(r10)\n-                       : \"rsp\", \"memory\", \"r11\", \"rcx\");\n+                       : \"memory\", \"r11\", \"rcx\");\n   return res;\n }\n #elif defined(__mips__)\n@@ -1560,6 +1657,16 @@ static int dl_iterate_phdr_test_cb(struct dl_phdr_info *info, size_t size,\n \n static atomic_uint32_t android_api_level;\n \n+static AndroidApiLevel AndroidDetectApiLevelStatic() {\n+#if __ANDROID_API__ <= 19\n+  return ANDROID_KITKAT;\n+#elif __ANDROID_API__ <= 22\n+  return ANDROID_LOLLIPOP_MR1;\n+#else\n+  return ANDROID_POST_LOLLIPOP;\n+#endif\n+}\n+\n static AndroidApiLevel AndroidDetectApiLevel() {\n   if (!&dl_iterate_phdr)\n     return ANDROID_KITKAT; // K or lower\n@@ -1572,11 +1679,14 @@ static AndroidApiLevel AndroidDetectApiLevel() {\n   // interesting to detect.\n }\n \n+extern \"C\" __attribute__((weak)) void* _DYNAMIC;\n+\n AndroidApiLevel AndroidGetApiLevel() {\n   AndroidApiLevel level =\n       (AndroidApiLevel)atomic_load(&android_api_level, memory_order_relaxed);\n   if (level) return level;\n-  level = AndroidDetectApiLevel();\n+  level = &_DYNAMIC == nullptr ? AndroidDetectApiLevelStatic()\n+                               : AndroidDetectApiLevel();\n   atomic_store(&android_api_level, level, memory_order_relaxed);\n   return level;\n }\n@@ -1589,6 +1699,8 @@ static HandleSignalMode GetHandleSignalModeImpl(int signum) {\n       return common_flags()->handle_abort;\n     case SIGILL:\n       return common_flags()->handle_sigill;\n+    case SIGTRAP:\n+      return common_flags()->handle_sigtrap;\n     case SIGFPE:\n       return common_flags()->handle_sigfpe;\n     case SIGSEGV:\n@@ -1655,18 +1767,78 @@ static bool Aarch64GetESR(ucontext_t *ucontext, u64 *esr) {\n }\n #endif\n \n+#if SANITIZER_OPENBSD\n+using Context = sigcontext;\n+#else\n+using Context = ucontext_t;\n+#endif\n+\n SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n-  ucontext_t *ucontext = (ucontext_t *)context;\n+  Context *ucontext = (Context *)context;\n #if defined(__x86_64__) || defined(__i386__)\n   static const uptr PF_WRITE = 1U << 1;\n #if SANITIZER_FREEBSD\n   uptr err = ucontext->uc_mcontext.mc_err;\n #elif SANITIZER_NETBSD\n   uptr err = ucontext->uc_mcontext.__gregs[_REG_ERR];\n+#elif SANITIZER_OPENBSD\n+  uptr err = ucontext->sc_err;\n+#elif SANITIZER_SOLARIS && defined(__i386__)\n+  const int Err = 13;\n+  uptr err = ucontext->uc_mcontext.gregs[Err];\n #else\n   uptr err = ucontext->uc_mcontext.gregs[REG_ERR];\n-#endif\n+#endif // SANITIZER_FREEBSD\n   return err & PF_WRITE ? WRITE : READ;\n+#elif defined(__mips__)\n+  uint32_t *exception_source;\n+  uint32_t faulty_instruction;\n+  uint32_t op_code;\n+\n+  exception_source = (uint32_t *)ucontext->uc_mcontext.pc;\n+  faulty_instruction = (uint32_t)(*exception_source);\n+\n+  op_code = (faulty_instruction >> 26) & 0x3f;\n+\n+  // FIXME: Add support for FPU, microMIPS, DSP, MSA memory instructions.\n+  switch (op_code) {\n+    case 0x28:  // sb\n+    case 0x29:  // sh\n+    case 0x2b:  // sw\n+    case 0x3f:  // sd\n+#if __mips_isa_rev < 6\n+    case 0x2c:  // sdl\n+    case 0x2d:  // sdr\n+    case 0x2a:  // swl\n+    case 0x2e:  // swr\n+#endif\n+      return SignalContext::WRITE;\n+\n+    case 0x20:  // lb\n+    case 0x24:  // lbu\n+    case 0x21:  // lh\n+    case 0x25:  // lhu\n+    case 0x23:  // lw\n+    case 0x27:  // lwu\n+    case 0x37:  // ld\n+#if __mips_isa_rev < 6\n+    case 0x1a:  // ldl\n+    case 0x1b:  // ldr\n+    case 0x22:  // lwl\n+    case 0x26:  // lwr\n+#endif\n+      return SignalContext::READ;\n+#if __mips_isa_rev == 6\n+    case 0x3b:  // pcrel\n+      op_code = (faulty_instruction >> 19) & 0x3;\n+      switch (op_code) {\n+        case 0x1:  // lwpc\n+        case 0x2:  // lwupc\n+          return SignalContext::READ;\n+      }\n+#endif\n+  }\n+  return SignalContext::UNKNOWN;\n #elif defined(__arm__)\n   static const uptr FSR_WRITE = 1U << 11;\n   uptr fsr = ucontext->uc_mcontext.error_code;\n@@ -1676,6 +1848,12 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n   u64 esr;\n   if (!Aarch64GetESR(ucontext, &esr)) return UNKNOWN;\n   return esr & ESR_ELx_WNR ? WRITE : READ;\n+#elif SANITIZER_SOLARIS && defined(__sparc__)\n+  // Decode the instruction to determine the access type.\n+  // From OpenSolaris $SRC/uts/sun4/os/trap.c (get_accesstype).\n+  uptr pc = ucontext->uc_mcontext.gregs[REG_PC];\n+  u32 instr = *(u32 *)pc;\n+  return (instr >> 21) & 1 ? WRITE: READ;\n #else\n   (void)ucontext;\n   return UNKNOWN;  // FIXME: Implement.\n@@ -1687,7 +1865,13 @@ void SignalContext::DumpAllRegisters(void *context) {\n }\n \n static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n-#if defined(__arm__)\n+#if SANITIZER_NETBSD\n+  // This covers all NetBSD architectures\n+  ucontext_t *ucontext = (ucontext_t *)context;\n+  *pc = _UC_MACHINE_PC(ucontext);\n+  *bp = _UC_MACHINE_FP(ucontext);\n+  *sp = _UC_MACHINE_SP(ucontext);\n+#elif defined(__arm__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.arm_pc;\n   *bp = ucontext->uc_mcontext.arm_fp;\n@@ -1709,11 +1893,11 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.mc_rip;\n   *bp = ucontext->uc_mcontext.mc_rbp;\n   *sp = ucontext->uc_mcontext.mc_rsp;\n-#elif SANITIZER_NETBSD\n-  ucontext_t *ucontext = (ucontext_t *)context;\n-  *pc = ucontext->uc_mcontext.__gregs[_REG_RIP];\n-  *bp = ucontext->uc_mcontext.__gregs[_REG_RBP];\n-  *sp = ucontext->uc_mcontext.__gregs[_REG_RSP];\n+#elif SANITIZER_OPENBSD\n+  sigcontext *ucontext = (sigcontext *)context;\n+  *pc = ucontext->sc_rip;\n+  *bp = ucontext->sc_rbp;\n+  *sp = ucontext->sc_rsp;\n # else\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_RIP];\n@@ -1726,13 +1910,26 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.mc_eip;\n   *bp = ucontext->uc_mcontext.mc_ebp;\n   *sp = ucontext->uc_mcontext.mc_esp;\n-#elif SANITIZER_NETBSD\n-  ucontext_t *ucontext = (ucontext_t *)context;\n-  *pc = ucontext->uc_mcontext.__gregs[_REG_EIP];\n-  *bp = ucontext->uc_mcontext.__gregs[_REG_EBP];\n-  *sp = ucontext->uc_mcontext.__gregs[_REG_ESP];\n+#elif SANITIZER_OPENBSD\n+  sigcontext *ucontext = (sigcontext *)context;\n+  *pc = ucontext->sc_eip;\n+  *bp = ucontext->sc_ebp;\n+  *sp = ucontext->sc_esp;\n # else\n   ucontext_t *ucontext = (ucontext_t*)context;\n+# if SANITIZER_SOLARIS\n+  /* Use the numeric values: the symbolic ones are undefined by llvm\n+     include/llvm/Support/Solaris.h.  */\n+# ifndef REG_EIP\n+#  define REG_EIP 14 // REG_PC\n+# endif\n+# ifndef REG_EBP\n+#  define REG_EBP  6 // REG_FP\n+# endif\n+# ifndef REG_ESP\n+#  define REG_ESP 17 // REG_SP\n+# endif\n+# endif\n   *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n   *bp = ucontext->uc_mcontext.gregs[REG_EBP];\n   *sp = ucontext->uc_mcontext.gregs[REG_ESP];\n@@ -1747,7 +1944,16 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n #elif defined(__sparc__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   uptr *stk_ptr;\n-# if defined (__arch64__)\n+# if defined (__sparcv9)\n+# ifndef MC_PC\n+#  define MC_PC REG_PC\n+# endif\n+# ifndef MC_O6\n+#  define MC_O6 REG_O6\n+# endif\n+# ifdef SANITIZER_SOLARIS\n+#  define mc_gregs gregs\n+# endif\n   *pc = ucontext->uc_mcontext.mc_gregs[MC_PC];\n   *sp = ucontext->uc_mcontext.mc_gregs[MC_O6];\n   stk_ptr = (uptr *) (*sp + 2047);\n@@ -1783,6 +1989,30 @@ void MaybeReexec() {\n   // No need to re-exec on Linux.\n }\n \n+void CheckASLR() {\n+#if SANITIZER_NETBSD\n+  int mib[3];\n+  int paxflags;\n+  uptr len = sizeof(paxflags);\n+\n+  mib[0] = CTL_PROC;\n+  mib[1] = internal_getpid();\n+  mib[2] = PROC_PID_PAXFLAGS;\n+\n+  if (UNLIKELY(internal_sysctl(mib, 3, &paxflags, &len, NULL, 0) == -1)) {\n+    Printf(\"sysctl failed\\n\");\n+    Die();\n+  }\n+\n+  if (UNLIKELY(paxflags & CTL_PROC_PAXFLAGS_ASLR)) {\n+    Printf(\"This sanitizer is not compatible with enabled ASLR\\n\");\n+    Die();\n+  }\n+#else\n+  // Do nothing\n+#endif\n+}\n+\n void PrintModuleMap() { }\n \n void CheckNoDeepBind(const char *filename, int flag) {\n@@ -1801,14 +2031,24 @@ void CheckNoDeepBind(const char *filename, int flag) {\n }\n \n uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n-                              uptr *largest_gap_found) {\n+                              uptr *largest_gap_found,\n+                              uptr *max_occupied_addr) {\n   UNREACHABLE(\"FindAvailableMemoryRange is not available\");\n   return 0;\n }\n \n bool GetRandom(void *buffer, uptr length, bool blocking) {\n   if (!buffer || !length || length > 256)\n     return false;\n+#if SANITIZER_USE_GETENTROPY\n+  uptr rnd = getentropy(buffer, length);\n+  int rverrno = 0;\n+  if (internal_iserror(rnd, &rverrno) && rverrno == EFAULT)\n+    return false;\n+  else if (rnd == 0)\n+    return true;\n+#endif // SANITIZER_USE_GETENTROPY\n+\n #if SANITIZER_USE_GETRANDOM\n   static atomic_uint8_t skip_getrandom_syscall;\n   if (!atomic_load_relaxed(&skip_getrandom_syscall)) {\n@@ -1821,7 +2061,7 @@ bool GetRandom(void *buffer, uptr length, bool blocking) {\n     else if (res == length)\n       return true;\n   }\n-#endif  // SANITIZER_USE_GETRANDOM\n+#endif // SANITIZER_USE_GETRANDOM\n   // Up to 256 bytes, a read off /dev/urandom will not be interrupted.\n   // blocking is moot here, O_NONBLOCK has no effect when opening /dev/urandom.\n   uptr fd = internal_open(\"/dev/urandom\", O_RDONLY);\n@@ -1836,4 +2076,4 @@ bool GetRandom(void *buffer, uptr length, bool blocking) {\n \n } // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#endif"}, {"sha": "e1f606fd5f637c1ae24492de1fe0203e6a82583f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,11 +12,14 @@\n #define SANITIZER_LINUX_H\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD ||                \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform_limits_netbsd.h\"\n+#include \"sanitizer_platform_limits_openbsd.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_platform_limits_solaris.h\"\n #include \"sanitizer_posix.h\"\n \n struct link_map;  // Opaque type returned by dlopen().\n@@ -44,6 +47,7 @@ uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n uptr internal_sigaltstack(const void* ss, void* oss);\n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n     __sanitizer_sigset_t *oldset);\n+uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp);\n \n // Linux-only syscalls.\n #if SANITIZER_LINUX\n@@ -63,28 +67,28 @@ void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif\n+#elif SANITIZER_FREEBSD\n+void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n #endif  // SANITIZER_LINUX\n \n // This class reads thread IDs from /proc/<pid>/task using only syscalls.\n class ThreadLister {\n  public:\n-  explicit ThreadLister(int pid);\n+  explicit ThreadLister(pid_t pid);\n   ~ThreadLister();\n-  // GetNextTID returns -1 if the list of threads is exhausted, or if there has\n-  // been an error.\n-  int GetNextTID();\n-  void Reset();\n-  bool error();\n+  enum Result {\n+    Error,\n+    Incomplete,\n+    Ok,\n+  };\n+  Result ListThreads(InternalMmapVector<tid_t> *threads);\n \n  private:\n-  bool GetDirectoryEntries();\n-\n-  int pid_;\n-  int descriptor_;\n-  InternalScopedBuffer<char> buffer_;\n-  bool error_;\n-  struct linux_dirent* entry_;\n-  int bytes_read_;\n+  bool IsAlive(int tid);\n+\n+  pid_t pid_;\n+  int descriptor_ = -1;\n+  InternalMmapVector<char> buffer_;\n };\n \n // Exposed for testing.\n@@ -140,5 +144,5 @@ ALWAYS_INLINE uptr *get_android_tls_ptr() {\n \n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#endif\n #endif  // SANITIZER_LINUX_H"}, {"sha": "32f335eaf23dabcb0dd632054cdfa31f85a0dbab", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 348, "deletions": 141, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,7 +12,8 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD ||                \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n \n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_atomic.h\"\n@@ -23,7 +24,6 @@\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n-#include \"sanitizer_stacktrace.h\"\n \n #include <dlfcn.h>  // for dlsym()\n #include <link.h>\n@@ -35,19 +35,36 @@\n #if SANITIZER_FREEBSD\n #include <pthread_np.h>\n #include <osreldate.h>\n+#include <sys/sysctl.h>\n #define pthread_getattr_np pthread_attr_get_np\n #endif\n \n-#if SANITIZER_LINUX\n-#include <sys/prctl.h>\n+#if SANITIZER_OPENBSD\n+#include <pthread_np.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+#if SANITIZER_NETBSD\n+#include <sys/sysctl.h>\n+#include <sys/tls.h>\n+#endif\n+\n+#if SANITIZER_SOLARIS\n+#include <thread.h>\n #endif\n \n #if SANITIZER_ANDROID\n #include <android/api-level.h>\n+#if !defined(CPU_COUNT) && !defined(__aarch64__)\n+#include <dirent.h>\n+#include <fcntl.h>\n+struct __sanitizer::linux_dirent {\n+  long           d_ino;\n+  off_t          d_off;\n+  unsigned short d_reclen;\n+  char           d_name[];\n+};\n #endif\n-\n-#if SANITIZER_ANDROID && __ANDROID_API__ < 21\n-#include <android/log.h>\n #endif\n \n #if !SANITIZER_ANDROID\n@@ -101,13 +118,25 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n     *stack_bottom = segment.end - stacksize;\n     return;\n   }\n+  uptr stacksize = 0;\n+  void *stackaddr = nullptr;\n+#if SANITIZER_SOLARIS\n+  stack_t ss;\n+  CHECK_EQ(thr_stksegment(&ss), 0);\n+  stacksize = ss.ss_size;\n+  stackaddr = (char *)ss.ss_sp - stacksize;\n+#elif SANITIZER_OPENBSD\n+  stack_t sattr;\n+  CHECK_EQ(pthread_stackseg_np(pthread_self(), &sattr), 0);\n+  stackaddr = sattr.ss_sp;\n+  stacksize = sattr.ss_size;\n+#else  // !SANITIZER_SOLARIS\n   pthread_attr_t attr;\n   pthread_attr_init(&attr);\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n-  uptr stacksize = 0;\n-  void *stackaddr = nullptr;\n   my_pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n   pthread_attr_destroy(&attr);\n+#endif // SANITIZER_SOLARIS\n \n   *stack_top = (uptr)stackaddr + stacksize;\n   *stack_bottom = (uptr)stackaddr;\n@@ -126,145 +155,160 @@ bool SetEnv(const char *name, const char *value) {\n }\n #endif\n \n-bool SanitizerSetThreadName(const char *name) {\n-#ifdef PR_SET_NAME\n-  return 0 == prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);  // NOLINT\n+__attribute__((unused)) static bool GetLibcVersion(int *major, int *minor,\n+                                                   int *patch) {\n+#ifdef _CS_GNU_LIBC_VERSION\n+  char buf[64];\n+  uptr len = confstr(_CS_GNU_LIBC_VERSION, buf, sizeof(buf));\n+  if (len >= sizeof(buf))\n+    return false;\n+  buf[len] = 0;\n+  static const char kGLibC[] = \"glibc \";\n+  if (internal_strncmp(buf, kGLibC, sizeof(kGLibC) - 1) != 0)\n+    return false;\n+  const char *p = buf + sizeof(kGLibC) - 1;\n+  *major = internal_simple_strtoll(p, &p, 10);\n+  *minor = (*p == '.') ? internal_simple_strtoll(p + 1, &p, 10) : 0;\n+  *patch = (*p == '.') ? internal_simple_strtoll(p + 1, &p, 10) : 0;\n+  return true;\n #else\n   return false;\n #endif\n }\n \n-bool SanitizerGetThreadName(char *name, int max_len) {\n-#ifdef PR_GET_NAME\n-  char buff[17];\n-  if (prctl(PR_GET_NAME, (unsigned long)buff, 0, 0, 0))  // NOLINT\n-    return false;\n-  internal_strncpy(name, buff, max_len);\n-  name[max_len] = 0;\n-  return true;\n+#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO &&               \\\n+    !SANITIZER_NETBSD && !SANITIZER_OPENBSD && !SANITIZER_SOLARIS\n+static uptr g_tls_size;\n+\n+#ifdef __i386__\n+# ifndef __GLIBC_PREREQ\n+#  define CHECK_GET_TLS_STATIC_INFO_VERSION 1\n+# else\n+#  define CHECK_GET_TLS_STATIC_INFO_VERSION (!__GLIBC_PREREQ(2, 27))\n+# endif\n #else\n-  return false;\n+# define CHECK_GET_TLS_STATIC_INFO_VERSION 0\n #endif\n-}\n \n-#ifndef __GLIBC_PREREQ\n-#define __GLIBC_PREREQ(x, y) 0\n+#if CHECK_GET_TLS_STATIC_INFO_VERSION\n+# define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n+#else\n+# define DL_INTERNAL_FUNCTION\n #endif\n \n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO && \\\n-    !SANITIZER_NETBSD\n-static uptr g_tls_size;\n+namespace {\n+struct GetTlsStaticInfoCall {\n+  typedef void (*get_tls_func)(size_t*, size_t*);\n+};\n+struct GetTlsStaticInfoRegparmCall {\n+  typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;\n+};\n+\n+template <typename T>\n+void CallGetTls(void* ptr, size_t* size, size_t* align) {\n+  typename T::get_tls_func get_tls;\n+  CHECK_EQ(sizeof(get_tls), sizeof(ptr));\n+  internal_memcpy(&get_tls, &ptr, sizeof(ptr));\n+  CHECK_NE(get_tls, 0);\n+  get_tls(size, align);\n+}\n+\n+bool CmpLibcVersion(int major, int minor, int patch) {\n+  int ma;\n+  int mi;\n+  int pa;\n+  if (!GetLibcVersion(&ma, &mi, &pa))\n+    return false;\n+  if (ma > major)\n+    return true;\n+  if (ma < major)\n+    return false;\n+  if (mi > minor)\n+    return true;\n+  if (mi < minor)\n+    return false;\n+  return pa >= patch;\n+}\n+\n+}  // namespace\n \n void InitTlsSize() {\n-// all current supported platforms have 16 bytes stack alignment\n+  // all current supported platforms have 16 bytes stack alignment\n   const size_t kStackAlign = 16;\n+  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n   size_t tls_size = 0;\n   size_t tls_align = 0;\n-  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n-#if defined(__i386__) && !__GLIBC_PREREQ(2, 27)\n-  /* On i?86, _dl_get_tls_static_info used to be internal_function, i.e.\n-     __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal\n-     function in 2.27 and later.  */\n-  if (!dlvsym(RTLD_NEXT, \"glob\", \"GLIBC_2.27\")) {\n-    typedef void (*get_tls_func)(size_t*, size_t*)\n-      __attribute__((regparm(3), stdcall));\n-    get_tls_func get_tls;\n-    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));\n-    internal_memcpy(&get_tls, &get_tls_static_info_ptr,\n-                    sizeof(get_tls_static_info_ptr));\n-    CHECK_NE(get_tls, 0);\n-    get_tls(&tls_size, &tls_align);\n-  } else\n-#endif\n-  {\n-    typedef void (*get_tls_func)(size_t*, size_t*);\n-    get_tls_func get_tls;\n-    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));\n-    internal_memcpy(&get_tls, &get_tls_static_info_ptr,\n-                    sizeof(get_tls_static_info_ptr));\n-    CHECK_NE(get_tls, 0);\n-    get_tls(&tls_size, &tls_align);\n-  }\n+  // On i?86, _dl_get_tls_static_info used to be internal_function, i.e.\n+  // __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal\n+  // function in 2.27 and later.\n+  if (CHECK_GET_TLS_STATIC_INFO_VERSION && !CmpLibcVersion(2, 27, 0))\n+    CallGetTls<GetTlsStaticInfoRegparmCall>(get_tls_static_info_ptr,\n+                                            &tls_size, &tls_align);\n+  else\n+    CallGetTls<GetTlsStaticInfoCall>(get_tls_static_info_ptr,\n+                                     &tls_size, &tls_align);\n   if (tls_align < kStackAlign)\n     tls_align = kStackAlign;\n   g_tls_size = RoundUpTo(tls_size, tls_align);\n }\n #else\n void InitTlsSize() { }\n #endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO &&\n-        // !SANITIZER_NETBSD\n+        // !SANITIZER_NETBSD && !SANITIZER_SOLARIS\n \n-#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) \\\n-    || defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__) \\\n-    || defined(__arm__)) && SANITIZER_LINUX && !SANITIZER_ANDROID\n+#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) ||          \\\n+     defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__) ||    \\\n+     defined(__arm__)) &&                                                      \\\n+    SANITIZER_LINUX && !SANITIZER_ANDROID\n // sizeof(struct pthread) from glibc.\n-static atomic_uintptr_t kThreadDescriptorSize;\n+static atomic_uintptr_t thread_descriptor_size;\n \n uptr ThreadDescriptorSize() {\n-  uptr val = atomic_load(&kThreadDescriptorSize, memory_order_relaxed);\n+  uptr val = atomic_load_relaxed(&thread_descriptor_size);\n   if (val)\n     return val;\n #if defined(__x86_64__) || defined(__i386__) || defined(__arm__)\n-#ifdef _CS_GNU_LIBC_VERSION\n-  char buf[64];\n-  uptr len = confstr(_CS_GNU_LIBC_VERSION, buf, sizeof(buf));\n-  if (len < sizeof(buf) && internal_strncmp(buf, \"glibc 2.\", 8) == 0) {\n-    char *end;\n-    int minor = internal_simple_strtoll(buf + 8, &end, 10);\n-    if (end != buf + 8 && (*end == '\\0' || *end == '.' || *end == '-')) {\n-      int patch = 0;\n-      if (*end == '.')\n-        // strtoll will return 0 if no valid conversion could be performed\n-        patch = internal_simple_strtoll(end + 1, nullptr, 10);\n-\n-      /* sizeof(struct pthread) values from various glibc versions.  */\n-      if (SANITIZER_X32)\n-        val = 1728;  // Assume only one particular version for x32.\n-      // For ARM sizeof(struct pthread) changed in Glibc 2.23.\n-      else if (SANITIZER_ARM)\n-        val = minor <= 22 ? 1120 : 1216;\n-      else if (minor <= 3)\n-        val = FIRST_32_SECOND_64(1104, 1696);\n-      else if (minor == 4)\n-        val = FIRST_32_SECOND_64(1120, 1728);\n-      else if (minor == 5)\n-        val = FIRST_32_SECOND_64(1136, 1728);\n-      else if (minor <= 9)\n-        val = FIRST_32_SECOND_64(1136, 1712);\n-      else if (minor == 10)\n-        val = FIRST_32_SECOND_64(1168, 1776);\n-      else if (minor == 11 || (minor == 12 && patch == 1))\n-        val = FIRST_32_SECOND_64(1168, 2288);\n-      else if (minor <= 14)\n-        val = FIRST_32_SECOND_64(1168, 2304);\n-      else\n-        val = FIRST_32_SECOND_64(1216, 2304);\n-    }\n-    if (val)\n-      atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n-    return val;\n+  int major;\n+  int minor;\n+  int patch;\n+  if (GetLibcVersion(&major, &minor, &patch) && major == 2) {\n+    /* sizeof(struct pthread) values from various glibc versions.  */\n+    if (SANITIZER_X32)\n+      val = 1728; // Assume only one particular version for x32.\n+    // For ARM sizeof(struct pthread) changed in Glibc 2.23.\n+    else if (SANITIZER_ARM)\n+      val = minor <= 22 ? 1120 : 1216;\n+    else if (minor <= 3)\n+      val = FIRST_32_SECOND_64(1104, 1696);\n+    else if (minor == 4)\n+      val = FIRST_32_SECOND_64(1120, 1728);\n+    else if (minor == 5)\n+      val = FIRST_32_SECOND_64(1136, 1728);\n+    else if (minor <= 9)\n+      val = FIRST_32_SECOND_64(1136, 1712);\n+    else if (minor == 10)\n+      val = FIRST_32_SECOND_64(1168, 1776);\n+    else if (minor == 11 || (minor == 12 && patch == 1))\n+      val = FIRST_32_SECOND_64(1168, 2288);\n+    else if (minor <= 14)\n+      val = FIRST_32_SECOND_64(1168, 2304);\n+    else\n+      val = FIRST_32_SECOND_64(1216, 2304);\n   }\n-#endif\n #elif defined(__mips__)\n   // TODO(sagarthakur): add more values as per different glibc versions.\n   val = FIRST_32_SECOND_64(1152, 1776);\n-  if (val)\n-    atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n-  return val;\n #elif defined(__aarch64__)\n   // The sizeof (struct pthread) is the same from GLIBC 2.17 to 2.22.\n   val = 1776;\n-  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n-  return val;\n #elif defined(__powerpc64__)\n   val = 1776; // from glibc.ppc64le 2.20-8.fc21\n-  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n-  return val;\n #elif defined(__s390__)\n   val = FIRST_32_SECOND_64(1152, 1776); // valid for glibc 2.22\n-  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n #endif\n-  return 0;\n+  if (val)\n+    atomic_store_relaxed(&thread_descriptor_size, val);\n+  return val;\n }\n \n // The offset at which pointer to self is located in the thread descriptor.\n@@ -339,16 +383,43 @@ static void **ThreadSelfSegbase() {\n   // sysarch(AMD64_GET_FSBASE, segbase);\n   __asm __volatile(\"movq %%fs:0, %0\" : \"=r\" (segbase));\n # else\n-#  error \"unsupported CPU arch for FreeBSD platform\"\n+#  error \"unsupported CPU arch\"\n # endif\n   return segbase;\n }\n \n uptr ThreadSelf() {\n   return (uptr)ThreadSelfSegbase()[2];\n }\n-#elif SANITIZER_NETBSD\n-uptr ThreadSelf() { return (uptr)pthread_self(); }\n+#endif  // SANITIZER_FREEBSD\n+\n+#if SANITIZER_NETBSD\n+static struct tls_tcb * ThreadSelfTlsTcb() {\n+  struct tls_tcb * tcb;\n+# ifdef __HAVE___LWP_GETTCB_FAST\n+  tcb = (struct tls_tcb *)__lwp_gettcb_fast();\n+# elif defined(__HAVE___LWP_GETPRIVATE_FAST)\n+  tcb = (struct tls_tcb *)__lwp_getprivate_fast();\n+# endif\n+  return tcb;\n+}\n+\n+uptr ThreadSelf() {\n+  return (uptr)ThreadSelfTlsTcb()->tcb_pthread;\n+}\n+\n+int GetSizeFromHdr(struct dl_phdr_info *info, size_t size, void *data) {\n+  const Elf_Phdr *hdr = info->dlpi_phdr;\n+  const Elf_Phdr *last_hdr = hdr + info->dlpi_phnum;\n+\n+  for (; hdr != last_hdr; ++hdr) {\n+    if (hdr->p_type == PT_TLS && info->dlpi_tls_modid == 1) {\n+      *(uptr*)data = hdr->p_memsz;\n+      break;\n+    }\n+  }\n+  return 0;\n+}\n #endif  // SANITIZER_NETBSD\n \n #if !SANITIZER_GO\n@@ -380,7 +451,28 @@ static void GetTls(uptr *addr, uptr *size) {\n     *addr = (uptr) dtv[2];\n     *size = (*addr == 0) ? 0 : ((uptr) segbase[0] - (uptr) dtv[2]);\n   }\n-#elif SANITIZER_ANDROID || SANITIZER_NETBSD\n+#elif SANITIZER_NETBSD\n+  struct tls_tcb * const tcb = ThreadSelfTlsTcb();\n+  *addr = 0;\n+  *size = 0;\n+  if (tcb != 0) {\n+    // Find size (p_memsz) of dlpi_tls_modid 1 (TLS block of the main program).\n+    // ld.elf_so hardcodes the index 1.\n+    dl_iterate_phdr(GetSizeFromHdr, size);\n+\n+    if (*size != 0) {\n+      // The block has been found and tcb_dtv[1] contains the base address\n+      *addr = (uptr)tcb->tcb_dtv[1];\n+    }\n+  }\n+#elif SANITIZER_OPENBSD\n+  *addr = 0;\n+  *size = 0;\n+#elif SANITIZER_ANDROID\n+  *addr = 0;\n+  *size = 0;\n+#elif SANITIZER_SOLARIS\n+  // FIXME\n   *addr = 0;\n   *size = 0;\n #else\n@@ -391,7 +483,8 @@ static void GetTls(uptr *addr, uptr *size) {\n \n #if !SANITIZER_GO\n uptr GetTlsSize() {\n-#if SANITIZER_FREEBSD || SANITIZER_ANDROID || SANITIZER_NETBSD\n+#if SANITIZER_FREEBSD || SANITIZER_ANDROID || SANITIZER_NETBSD ||              \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n   uptr addr, size;\n   GetTls(&addr, &size);\n   return size;\n@@ -428,13 +521,13 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n #endif\n }\n \n-# if !SANITIZER_FREEBSD\n+#if !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n typedef ElfW(Phdr) Elf_Phdr;\n-# elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001  // v9.2\n-#  define Elf_Phdr XElf32_Phdr\n-#  define dl_phdr_info xdl_phdr_info\n-#  define dl_iterate_phdr(c, b) xdl_iterate_phdr((c), (b))\n-# endif\n+#elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001 // v9.2\n+#define Elf_Phdr XElf32_Phdr\n+#define dl_phdr_info xdl_phdr_info\n+#define dl_iterate_phdr(c, b) xdl_iterate_phdr((c), (b))\n+#endif // !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n \n struct DlIteratePhdrData {\n   InternalMmapVectorNoCtor<LoadedModule> *modules;\n@@ -455,7 +548,7 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n     return 0;\n   LoadedModule cur_module;\n   cur_module.set(module_name.data(), info->dlpi_addr);\n-  for (int i = 0; i < info->dlpi_phnum; i++) {\n+  for (int i = 0; i < (int)info->dlpi_phnum; i++) {\n     const Elf_Phdr *phdr = &info->dlpi_phdr[i];\n     if (phdr->p_type == PT_LOAD) {\n       uptr cur_beg = info->dlpi_addr + phdr->p_vaddr;\n@@ -551,12 +644,65 @@ uptr GetRSS() {\n   return rss * GetPageSizeCached();\n }\n \n-// 64-bit Android targets don't provide the deprecated __android_log_write.\n-// Starting with the L release, syslog() works and is preferable to\n-// __android_log_write.\n+// sysconf(_SC_NPROCESSORS_{CONF,ONLN}) cannot be used on most platforms as\n+// they allocate memory.\n+u32 GetNumberOfCPUs() {\n+#if SANITIZER_FREEBSD || SANITIZER_NETBSD || SANITIZER_OPENBSD\n+  u32 ncpu;\n+  int req[2];\n+  uptr len = sizeof(ncpu);\n+  req[0] = CTL_HW;\n+  req[1] = HW_NCPU;\n+  CHECK_EQ(internal_sysctl(req, 2, &ncpu, &len, NULL, 0), 0);\n+  return ncpu;\n+#elif SANITIZER_ANDROID && !defined(CPU_COUNT) && !defined(__aarch64__)\n+  // Fall back to /sys/devices/system/cpu on Android when cpu_set_t doesn't\n+  // exist in sched.h. That is the case for toolchains generated with older\n+  // NDKs.\n+  // This code doesn't work on AArch64 because internal_getdents makes use of\n+  // the 64bit getdents syscall, but cpu_set_t seems to always exist on AArch64.\n+  uptr fd = internal_open(\"/sys/devices/system/cpu\", O_RDONLY | O_DIRECTORY);\n+  if (internal_iserror(fd))\n+    return 0;\n+  InternalMmapVector<u8> buffer(4096);\n+  uptr bytes_read = buffer.size();\n+  uptr n_cpus = 0;\n+  u8 *d_type;\n+  struct linux_dirent *entry = (struct linux_dirent *)&buffer[bytes_read];\n+  while (true) {\n+    if ((u8 *)entry >= &buffer[bytes_read]) {\n+      bytes_read = internal_getdents(fd, (struct linux_dirent *)buffer.data(),\n+                                     buffer.size());\n+      if (internal_iserror(bytes_read) || !bytes_read)\n+        break;\n+      entry = (struct linux_dirent *)buffer.data();\n+    }\n+    d_type = (u8 *)entry + entry->d_reclen - 1;\n+    if (d_type >= &buffer[bytes_read] ||\n+        (u8 *)&entry->d_name[3] >= &buffer[bytes_read])\n+      break;\n+    if (entry->d_ino != 0 && *d_type == DT_DIR) {\n+      if (entry->d_name[0] == 'c' && entry->d_name[1] == 'p' &&\n+          entry->d_name[2] == 'u' &&\n+          entry->d_name[3] >= '0' && entry->d_name[3] <= '9')\n+        n_cpus++;\n+    }\n+    entry = (struct linux_dirent *)(((u8 *)entry) + entry->d_reclen);\n+  }\n+  internal_close(fd);\n+  return n_cpus;\n+#elif SANITIZER_SOLARIS\n+  return sysconf(_SC_NPROCESSORS_ONLN);\n+#else\n+  cpu_set_t CPUs;\n+  CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n+  return CPU_COUNT(&CPUs);\n+#endif\n+}\n+\n #if SANITIZER_LINUX\n \n-#if SANITIZER_ANDROID\n+# if SANITIZER_ANDROID\n static atomic_uint8_t android_log_initialized;\n \n void AndroidLogInit() {\n@@ -567,36 +713,97 @@ void AndroidLogInit() {\n static bool ShouldLogAfterPrintf() {\n   return atomic_load(&android_log_initialized, memory_order_acquire);\n }\n-#else\n-void AndroidLogInit() {}\n \n-static bool ShouldLogAfterPrintf() { return true; }\n-#endif  // SANITIZER_ANDROID\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n+int async_safe_write_log(int pri, const char* tag, const char* msg);\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n+int __android_log_write(int prio, const char* tag, const char* msg);\n \n+// ANDROID_LOG_INFO is 4, but can't be resolved at runtime.\n+#define SANITIZER_ANDROID_LOG_INFO 4\n+\n+// async_safe_write_log is a new public version of __libc_write_log that is\n+// used behind syslog. It is preferable to syslog as it will not do any dynamic\n+// memory allocation or formatting.\n+// If the function is not available, syslog is preferred for L+ (it was broken\n+// pre-L) as __android_log_write triggers a racey behavior with the strncpy\n+// interceptor. Fallback to __android_log_write pre-L.\n void WriteOneLineToSyslog(const char *s) {\n-#if SANITIZER_ANDROID &&__ANDROID_API__ < 21\n-  __android_log_write(ANDROID_LOG_INFO, NULL, s);\n-#else\n-  syslog(LOG_INFO, \"%s\", s);\n-#endif\n+  if (&async_safe_write_log) {\n+    async_safe_write_log(SANITIZER_ANDROID_LOG_INFO, GetProcessName(), s);\n+  } else if (AndroidGetApiLevel() > ANDROID_KITKAT) {\n+    syslog(LOG_INFO, \"%s\", s);\n+  } else {\n+    CHECK(&__android_log_write);\n+    __android_log_write(SANITIZER_ANDROID_LOG_INFO, nullptr, s);\n+  }\n }\n \n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n+void android_set_abort_message(const char *);\n+\n+void SetAbortMessage(const char *str) {\n+  if (&android_set_abort_message)\n+    android_set_abort_message(str);\n+}\n+# else\n+void AndroidLogInit() {}\n+\n+static bool ShouldLogAfterPrintf() { return true; }\n+\n+void WriteOneLineToSyslog(const char *s) { syslog(LOG_INFO, \"%s\", s); }\n+\n+void SetAbortMessage(const char *str) {}\n+# endif  // SANITIZER_ANDROID\n+\n void LogMessageOnPrintf(const char *str) {\n   if (common_flags()->log_to_syslog && ShouldLogAfterPrintf())\n     WriteToSyslog(str);\n }\n \n-#if SANITIZER_ANDROID\n-extern \"C\" __attribute__((weak)) void android_set_abort_message(const char *);\n-void SetAbortMessage(const char *str) {\n-  if (&android_set_abort_message) android_set_abort_message(str);\n+#endif  // SANITIZER_LINUX\n+\n+#if SANITIZER_LINUX && !SANITIZER_GO\n+// glibc crashes when using clock_gettime from a preinit_array function as the\n+// vDSO function pointers haven't been initialized yet. __progname is\n+// initialized after the vDSO function pointers, so if it exists, is not null\n+// and is not empty, we can use clock_gettime.\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE char *__progname;\n+INLINE bool CanUseVDSO() {\n+  // Bionic is safe, it checks for the vDSO function pointers to be initialized.\n+  if (SANITIZER_ANDROID)\n+    return true;\n+  if (&__progname && __progname && *__progname)\n+    return true;\n+  return false;\n }\n-#else\n-void SetAbortMessage(const char *str) {}\n-#endif\n \n-#endif // SANITIZER_LINUX\n+// MonotonicNanoTime is a timing function that can leverage the vDSO by calling\n+// clock_gettime. real_clock_gettime only exists if clock_gettime is\n+// intercepted, so define it weakly and use it if available.\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n+int real_clock_gettime(u32 clk_id, void *tp);\n+u64 MonotonicNanoTime() {\n+  timespec ts;\n+  if (CanUseVDSO()) {\n+    if (&real_clock_gettime)\n+      real_clock_gettime(CLOCK_MONOTONIC, &ts);\n+    else\n+      clock_gettime(CLOCK_MONOTONIC, &ts);\n+  } else {\n+    internal_clock_gettime(CLOCK_MONOTONIC, &ts);\n+  }\n+  return (u64)ts.tv_sec * (1000ULL * 1000 * 1000) + ts.tv_nsec;\n+}\n+#else\n+// Non-Linux & Go always use the syscall.\n+u64 MonotonicNanoTime() {\n+  timespec ts;\n+  internal_clock_gettime(CLOCK_MONOTONIC, &ts);\n+  return (u64)ts.tv_sec * (1000ULL * 1000 * 1000) + ts.tv_nsec;\n+}\n+#endif  // SANITIZER_LINUX && !SANITIZER_GO\n \n } // namespace __sanitizer\n \n-#endif // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif"}, {"sha": "e55ffe00cfb022c93a690815a0fa13c609baa468", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_s390.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -124,7 +124,7 @@ static bool FixedCVE_2016_2143() {\n   // This should never fail, but just in case...\n   if (uname(&buf))\n     return false;\n-  char *ptr = buf.release;\n+  const char *ptr = buf.release;\n   major = internal_simple_strtoll(ptr, &ptr, 10);\n   // At least first 2 should be matched.\n   if (ptr[0] != '.')"}, {"sha": "8ff909542b681cb79bd40d2e3b08c75e8f8e1a2f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_x86_64.S", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -10,14 +10,12 @@\n #if defined(__linux__) && defined(__x86_64__)\n \n #include \"../builtins/assembly.h\"\n-#include \"cet.h\"\n \n // If the \"naked\" function attribute were supported for x86 we could\n // do this via inline asm.\n .text\n .balign 4\n DEFINE_COMPILERRT_FUNCTION(internal_sigreturn)\n-\t_CET_ENDBR\n         mov           $0xf,             %eax    // 0xf == SYS_rt_sigreturn\n         mov           %rcx,             %r10\n         syscall"}, {"sha": "df7a897e45a09ca7052c8680aef6fa1c36c75730", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 106, "deletions": 18, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -35,7 +35,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -57,7 +57,9 @@ extern \"C\" {\n #include <libkern/OSAtomic.h>\n #include <mach-o/dyld.h>\n #include <mach/mach.h>\n+#include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n+#include <malloc/malloc.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n@@ -98,9 +100,15 @@ extern \"C\" void *__mmap(void *addr, size_t len, int prot, int flags, int fildes,\n extern \"C\" int __munmap(void *, size_t) SANITIZER_WEAK_ATTRIBUTE;\n \n // ---------------------- sanitizer_libc.h\n+\n+// From <mach/vm_statistics.h>, but not on older OSs.\n+#ifndef VM_MEMORY_SANITIZER\n+#define VM_MEMORY_SANITIZER 99\n+#endif\n+\n uptr internal_mmap(void *addr, size_t length, int prot, int flags,\n                    int fd, u64 offset) {\n-  if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_ANALYSIS_TOOL);\n+  if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_SANITIZER);\n   if (&__mmap) return (uptr)__mmap(addr, length, prot, flags, fd, offset);\n   return (uptr)mmap(addr, length, prot, flags, fd, offset);\n }\n@@ -183,7 +191,7 @@ uptr internal_getpid() {\n \n int internal_sigaction(int signum, const void *act, void *oldact) {\n   return sigaction(signum,\n-                   (struct sigaction *)act, (struct sigaction *)oldact);\n+                   (const struct sigaction *)act, (struct sigaction *)oldact);\n }\n \n void internal_sigfillset(__sanitizer_sigset_t *set) { sigfillset(set); }\n@@ -203,6 +211,18 @@ int internal_fork() {\n   return fork();\n }\n \n+int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n+                    uptr *oldlenp, const void *newp, uptr newlen) {\n+  return sysctl(const_cast<int *>(name), namelen, oldp, (size_t *)oldlenp,\n+                const_cast<void *>(newp), (size_t)newlen);\n+}\n+\n+int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n+                          const void *newp, uptr newlen) {\n+  return sysctlbyname(sname, oldp, (size_t *)oldlenp, const_cast<void *>(newp),\n+                      (size_t)newlen);\n+}\n+\n int internal_forkpty(int *amaster) {\n   int master, slave;\n   if (openpty(&master, &slave, nullptr, nullptr, nullptr) == -1) return -1;\n@@ -336,10 +356,37 @@ void ReExec() {\n   UNIMPLEMENTED();\n }\n \n+void CheckASLR() {\n+  // Do nothing\n+}\n+\n uptr GetPageSize() {\n   return sysconf(_SC_PAGESIZE);\n }\n \n+extern \"C\" unsigned malloc_num_zones;\n+extern \"C\" malloc_zone_t **malloc_zones;\n+malloc_zone_t sanitizer_zone;\n+\n+// We need to make sure that sanitizer_zone is registered as malloc_zones[0]. If\n+// libmalloc tries to set up a different zone as malloc_zones[0], it will call\n+// mprotect(malloc_zones, ..., PROT_READ).  This interceptor will catch that and\n+// make sure we are still the first (default) zone.\n+void MprotectMallocZones(void *addr, int prot) {\n+  if (addr == malloc_zones && prot == PROT_READ) {\n+    if (malloc_num_zones > 1 && malloc_zones[0] != &sanitizer_zone) {\n+      for (unsigned i = 1; i < malloc_num_zones; i++) {\n+        if (malloc_zones[i] == &sanitizer_zone) {\n+          // Swap malloc_zones[0] and malloc_zones[i].\n+          malloc_zones[i] = malloc_zones[0];\n+          malloc_zones[0] = &sanitizer_zone;\n+          break;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n BlockingMutex::BlockingMutex() {\n   internal_memset(this, 0, sizeof(*this));\n }\n@@ -360,7 +407,17 @@ void BlockingMutex::CheckLocked() {\n }\n \n u64 NanoTime() {\n-  return 0;\n+  timeval tv;\n+  internal_memset(&tv, 0, sizeof(tv));\n+  gettimeofday(&tv, 0);\n+  return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n+}\n+\n+// This needs to be called during initialization to avoid being racy.\n+u64 MonotonicNanoTime() {\n+  static mach_timebase_info_data_t timebase_info;\n+  if (timebase_info.denom == 0) mach_timebase_info(&timebase_info);\n+  return (mach_absolute_time() * timebase_info.numer) / timebase_info.denom;\n }\n \n uptr GetTlsSize() {\n@@ -422,6 +479,8 @@ static HandleSignalMode GetHandleSignalModeImpl(int signum) {\n       return common_flags()->handle_abort;\n     case SIGILL:\n       return common_flags()->handle_sigill;\n+    case SIGTRAP:\n+      return common_flags()->handle_sigtrap;\n     case SIGFPE:\n       return common_flags()->handle_sigfpe;\n     case SIGSEGV:\n@@ -450,9 +509,9 @@ MacosVersion GetMacosVersionInternal() {\n   uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n   for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n   // Get the version length.\n-  CHECK_NE(sysctl(mib, 2, 0, &len, 0, 0), -1);\n+  CHECK_NE(internal_sysctl(mib, 2, 0, &len, 0, 0), -1);\n   CHECK_LT(len, maxlen);\n-  CHECK_NE(sysctl(mib, 2, version, &len, 0, 0), -1);\n+  CHECK_NE(internal_sysctl(mib, 2, version, &len, 0, 0), -1);\n   switch (version[0]) {\n     case '9': return MACOS_VERSION_LEOPARD;\n     case '1': {\n@@ -462,6 +521,10 @@ MacosVersion GetMacosVersionInternal() {\n         case '2': return MACOS_VERSION_MOUNTAIN_LION;\n         case '3': return MACOS_VERSION_MAVERICKS;\n         case '4': return MACOS_VERSION_YOSEMITE;\n+        case '5': return MACOS_VERSION_EL_CAPITAN;\n+        case '6': return MACOS_VERSION_SIERRA;\n+        case '7': return MACOS_VERSION_HIGH_SIERRA;\n+        case '8': return MACOS_VERSION_MOJAVE;\n         default:\n           if (IsDigit(version[1]))\n             return MACOS_VERSION_UNKNOWN_NEWER;\n@@ -667,6 +730,9 @@ bool DyldNeedsEnvVariable() {\n }\n \n void MaybeReexec() {\n+  // FIXME: This should really live in some \"InitializePlatform\" method.\n+  MonotonicNanoTime();\n+\n   if (ReexecDisabled()) return;\n \n   // Make sure the dynamic runtime library is preloaded so that the\n@@ -739,6 +805,9 @@ void MaybeReexec() {\n   if (!lib_is_in_env)\n     return;\n \n+  if (!common_flags()->strip_env)\n+    return;\n+\n   // DYLD_INSERT_LIBRARIES is set and contains the runtime library. Let's remove\n   // the dylib from the environment variable, because interceptors are installed\n   // and we don't want our children to inherit the variable.\n@@ -835,10 +904,10 @@ struct __sanitizer_task_vm_info {\n     (sizeof(__sanitizer_task_vm_info) / sizeof(natural_t)))\n \n uptr GetTaskInfoMaxAddress() {\n-  __sanitizer_task_vm_info vm_info = {};\n+  __sanitizer_task_vm_info vm_info = {} /* zero initialize */;\n   mach_msg_type_number_t count = __SANITIZER_TASK_VM_INFO_COUNT;\n   int err = task_info(mach_task_self(), TASK_VM_INFO, (int *)&vm_info, &count);\n-  if (err == 0) {\n+  if (err == 0 && vm_info.max_address != 0) {\n     return vm_info.max_address - 1;\n   } else {\n     // xnu cannot provide vm address limit\n@@ -847,7 +916,7 @@ uptr GetTaskInfoMaxAddress() {\n }\n #endif\n \n-uptr GetMaxVirtualAddress() {\n+uptr GetMaxUserVirtualAddress() {\n #if SANITIZER_WORDSIZE == 64\n # if defined(__aarch64__) && SANITIZER_IOS && !SANITIZER_IOSSIM\n   // Get the maximum VM address\n@@ -862,10 +931,13 @@ uptr GetMaxVirtualAddress() {\n #endif  // SANITIZER_WORDSIZE\n }\n \n-uptr FindAvailableMemoryRange(uptr shadow_size,\n-                              uptr alignment,\n-                              uptr left_padding,\n-                              uptr *largest_gap_found) {\n+uptr GetMaxVirtualAddress() {\n+  return GetMaxUserVirtualAddress();\n+}\n+\n+uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n+                              uptr *largest_gap_found,\n+                              uptr *max_occupied_addr) {\n   typedef vm_region_submap_short_info_data_64_t RegionInfo;\n   enum { kRegionInfoSize = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 };\n   // Start searching for available memory region past PAGEZERO, which is\n@@ -877,19 +949,27 @@ uptr FindAvailableMemoryRange(uptr shadow_size,\n   mach_vm_address_t free_begin = start_address;\n   kern_return_t kr = KERN_SUCCESS;\n   if (largest_gap_found) *largest_gap_found = 0;\n+  if (max_occupied_addr) *max_occupied_addr = 0;\n   while (kr == KERN_SUCCESS) {\n     mach_vm_size_t vmsize = 0;\n     natural_t depth = 0;\n     RegionInfo vminfo;\n     mach_msg_type_number_t count = kRegionInfoSize;\n     kr = mach_vm_region_recurse(mach_task_self(), &address, &vmsize, &depth,\n                                 (vm_region_info_t)&vminfo, &count);\n+    if (kr == KERN_INVALID_ADDRESS) {\n+      // No more regions beyond \"address\", consider the gap at the end of VM.\n+      address = GetMaxVirtualAddress() + 1;\n+      vmsize = 0;\n+    } else {\n+      if (max_occupied_addr) *max_occupied_addr = address + vmsize;\n+    }\n     if (free_begin != address) {\n       // We found a free region [free_begin..address-1].\n       uptr gap_start = RoundUpTo((uptr)free_begin + left_padding, alignment);\n       uptr gap_end = RoundDownTo((uptr)address, alignment);\n       uptr gap_size = gap_end > gap_start ? gap_end - gap_start : 0;\n-      if (shadow_size < gap_size) {\n+      if (size < gap_size) {\n         return gap_start;\n       }\n \n@@ -976,9 +1056,10 @@ void FormatUUID(char *out, uptr size, const u8 *uuid) {\n void PrintModuleMap() {\n   Printf(\"Process module map:\\n\");\n   MemoryMappingLayout memory_mapping(false);\n-  InternalMmapVector<LoadedModule> modules(/*initial_capacity*/ 128);\n+  InternalMmapVector<LoadedModule> modules;\n+  modules.reserve(128);\n   memory_mapping.DumpListOfModules(&modules);\n-  InternalSort(&modules, modules.size(), CompareBaseAddress);\n+  Sort(modules.data(), modules.size(), CompareBaseAddress);\n   for (uptr i = 0; i < modules.size(); ++i) {\n     char uuid_str[128];\n     FormatUUID(uuid_str, sizeof(uuid_str), modules[i].uuid());\n@@ -993,9 +1074,16 @@ void CheckNoDeepBind(const char *filename, int flag) {\n   // Do nothing.\n }\n \n-// FIXME: implement on this platform.\n bool GetRandom(void *buffer, uptr length, bool blocking) {\n-  UNIMPLEMENTED();\n+  if (!buffer || !length || length > 256)\n+    return false;\n+  // arc4random never fails.\n+  arc4random_buf(buffer, length);\n+  return true;\n+}\n+\n+u32 GetNumberOfCPUs() {\n+  return (u32)sysconf(_SC_NPROCESSORS_ONLN);\n }\n \n }  // namespace __sanitizer"}, {"sha": "8e7a4a24525cc33c98df8e6875bb8acada7a4e09", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -25,7 +25,7 @@ struct MemoryMappingLayoutData {\n   ModuleArch current_arch;\n   u8 current_uuid[kModuleUUIDSize];\n   int current_load_cmd_count;\n-  char *current_load_cmd_addr;\n+  const char *current_load_cmd_addr;\n   bool current_instrumented;\n };\n \n@@ -38,6 +38,10 @@ enum MacosVersion {\n   MACOS_VERSION_MOUNTAIN_LION,\n   MACOS_VERSION_MAVERICKS,\n   MACOS_VERSION_YOSEMITE,\n+  MACOS_VERSION_EL_CAPITAN,\n+  MACOS_VERSION_SIERRA,\n+  MACOS_VERSION_HIGH_SIERRA,\n+  MACOS_VERSION_MOJAVE,\n   MACOS_VERSION_UNKNOWN_NEWER\n };\n "}, {"sha": "a0d5c3f8f551dc3ac42d598f5687e5cb213f5e82", "filename": "libsanitizer/sanitizer_common/sanitizer_mac_libcdep.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -18,7 +18,7 @@\n namespace __sanitizer {\n \n void RestrictMemoryToMaxAddress(uptr max_address) {\n-  uptr size_to_mmap = GetMaxVirtualAddress() + 1 - max_address;\n+  uptr size_to_mmap = GetMaxUserVirtualAddress() + 1 - max_address;\n   void *res = MmapFixedNoAccess(max_address, size_to_mmap, \"high gap\");\n   CHECK(res != MAP_FAILED);\n }"}, {"sha": "8887f5d5ca4d9446de34783b8f4d2b616556d7ff", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -27,7 +27,9 @@\n // Similar code is used in Google Perftools,\n // https://github.com/gperftools/gperftools.\n \n-static malloc_zone_t sanitizer_zone;\n+namespace __sanitizer {\n+extern malloc_zone_t sanitizer_zone;\n+}\n \n INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n                              vm_size_t start_size, unsigned zone_flags) {\n@@ -63,29 +65,6 @@ INTERCEPTOR(void, malloc_destroy_zone, malloc_zone_t *zone) {\n   COMMON_MALLOC_FREE(zone);\n }\n \n-extern unsigned malloc_num_zones;\n-extern malloc_zone_t **malloc_zones;\n-\n-// We need to make sure that sanitizer_zone is registered as malloc_zones[0]. If\n-// libmalloc tries to set up a different zone as malloc_zones[0], it will call\n-// mprotect(malloc_zones, ..., PROT_READ).  This interceptor will catch that and\n-// make sure we are still the first (default) zone.\n-INTERCEPTOR(int, mprotect, void *addr, size_t len, int prot) {\n-  if (addr == malloc_zones && prot == PROT_READ) {\n-    if (malloc_num_zones > 1 && malloc_zones[0] != &sanitizer_zone) {\n-      for (unsigned i = 1; i < malloc_num_zones; i++) {\n-        if (malloc_zones[i] == &sanitizer_zone) {\n-          // Swap malloc_zones[0] and malloc_zones[i].\n-          malloc_zones[i] = malloc_zones[0];\n-          malloc_zones[0] = &sanitizer_zone;\n-          break;\n-        }\n-      }\n-    }\n-  }\n-  return REAL(mprotect)(addr, len, prot);\n-}\n-\n INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n   COMMON_MALLOC_ENTER();\n   return &sanitizer_zone;\n@@ -168,12 +147,8 @@ INTERCEPTOR(size_t, malloc_good_size, size_t size) {\n INTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n   COMMON_MALLOC_ENTER();\n   CHECK(memptr);\n-  COMMON_MALLOC_MEMALIGN(alignment, size);\n-  if (p) {\n-    *memptr = p;\n-    return 0;\n-  }\n-  return -1;\n+  COMMON_MALLOC_POSIX_MEMALIGN(memptr, alignment, size);\n+  return res;\n }\n \n namespace {"}, {"sha": "2b7f7d24f2ecafc6f204fd8a6f4dad6b52951836", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -71,13 +71,8 @@ class SpinMutex : public StaticSpinMutex {\n \n class BlockingMutex {\n  public:\n-#if SANITIZER_WINDOWS\n-  // Windows does not currently support LinkerInitialized\n-  explicit BlockingMutex(LinkerInitialized);\n-#else\n   explicit constexpr BlockingMutex(LinkerInitialized)\n-      : opaque_storage_ {0, }, owner_(0) {}\n-#endif\n+      : opaque_storage_ {0, }, owner_ {0} {}\n   BlockingMutex();\n   void Lock();\n   void Unlock();\n@@ -90,8 +85,10 @@ class BlockingMutex {\n   // checks that the mutex is owned, and assumes callers to be generally\n   // well-behaved.\n   void CheckLocked();\n+\n  private:\n-  uptr opaque_storage_[10];\n+  // Solaris mutex_t has a member that requires 64-bit alignment.\n+  ALIGNED(8) uptr opaque_storage_[10];\n   uptr owner_;  // for debugging\n };\n "}, {"sha": "d0df94d1f950737bb82569bc015365d0d9931d5d", "filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cc", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,328 @@\n+//===-- sanitizer_netbsd.cc -----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between Sanitizer run-time libraries and implements\n+// NetBSD-specific functions from sanitizer_libc.h.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_NETBSD\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_getauxval.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_linux.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <sys/param.h>\n+#include <sys/types.h>\n+\n+#include <sys/exec.h>\n+#include <sys/mman.h>\n+#include <sys/ptrace.h>\n+#include <sys/resource.h>\n+#include <sys/stat.h>\n+#include <sys/syscall.h>\n+#include <sys/sysctl.h>\n+#include <sys/time.h>\n+\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <link.h>\n+#include <lwp.h>\n+#include <pthread.h>\n+#include <sched.h>\n+#include <signal.h>\n+#include <ucontext.h>\n+#include <unistd.h>\n+\n+extern \"C\" void *__mmap(void *, size_t, int, int, int, int,\n+                        off_t) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int __sysctl(const int *, unsigned int, void *, size_t *,\n+                        const void *, size_t) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys_close(int) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys_open(const char *, int, ...) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" ssize_t _sys_read(int, void *, size_t) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" ssize_t _sys_write(int, const void *,\n+                              size_t) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int __ftruncate(int, int, off_t) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" ssize_t _sys_readlink(const char *, char *,\n+                                 size_t) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys_sched_yield() SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys___nanosleep50(const void *,\n+                                  void *) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys_execve(const char *, char *const[],\n+                           char *const[]) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" off_t __lseek(int, int, off_t, int) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int __fork() SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys___sigprocmask14(int, const void *,\n+                                    void *) SANITIZER_WEAK_ATTRIBUTE;\n+extern \"C\" int _sys___wait450(int wpid, int *, int,\n+                              void *) SANITIZER_WEAK_ATTRIBUTE;\n+\n+namespace __sanitizer {\n+\n+static void *GetRealLibcAddress(const char *symbol) {\n+  void *real = dlsym(RTLD_NEXT, symbol);\n+  if (!real)\n+    real = dlsym(RTLD_DEFAULT, symbol);\n+  if (!real) {\n+    Printf(\"GetRealLibcAddress failed for symbol=%s\", symbol);\n+    Die();\n+  }\n+  return real;\n+}\n+\n+#define _REAL(func, ...) real##_##func(__VA_ARGS__)\n+#define DEFINE__REAL(ret_type, func, ...)                              \\\n+  static ret_type (*real_##func)(__VA_ARGS__) = NULL;                  \\\n+  if (!real_##func) {                                                  \\\n+    real_##func = (ret_type(*)(__VA_ARGS__))GetRealLibcAddress(#func); \\\n+  }                                                                    \\\n+  CHECK(real_##func);\n+\n+// --------------- sanitizer_libc.h\n+uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n+                   OFF_T offset) {\n+  CHECK(&__mmap);\n+  return (uptr)__mmap(addr, length, prot, flags, fd, 0, offset);\n+}\n+\n+uptr internal_munmap(void *addr, uptr length) {\n+  DEFINE__REAL(int, munmap, void *a, uptr b);\n+  return _REAL(munmap, addr, length);\n+}\n+\n+int internal_mprotect(void *addr, uptr length, int prot) {\n+  DEFINE__REAL(int, mprotect, void *a, uptr b, int c);\n+  return _REAL(mprotect, addr, length, prot);\n+}\n+\n+uptr internal_close(fd_t fd) {\n+  CHECK(&_sys_close);\n+  return _sys_close(fd);\n+}\n+\n+uptr internal_open(const char *filename, int flags) {\n+  CHECK(&_sys_open);\n+  return _sys_open(filename, flags);\n+}\n+\n+uptr internal_open(const char *filename, int flags, u32 mode) {\n+  CHECK(&_sys_open);\n+  return _sys_open(filename, flags, mode);\n+}\n+\n+uptr internal_read(fd_t fd, void *buf, uptr count) {\n+  sptr res;\n+  CHECK(&_sys_read);\n+  HANDLE_EINTR(res, (sptr)_sys_read(fd, buf, (size_t)count));\n+  return res;\n+}\n+\n+uptr internal_write(fd_t fd, const void *buf, uptr count) {\n+  sptr res;\n+  CHECK(&_sys_write);\n+  HANDLE_EINTR(res, (sptr)_sys_write(fd, buf, count));\n+  return res;\n+}\n+\n+uptr internal_ftruncate(fd_t fd, uptr size) {\n+  sptr res;\n+  CHECK(&__ftruncate);\n+  HANDLE_EINTR(res, __ftruncate(fd, 0, (s64)size));\n+  return res;\n+}\n+\n+uptr internal_stat(const char *path, void *buf) {\n+  DEFINE__REAL(int, __stat50, const char *a, void *b);\n+  return _REAL(__stat50, path, buf);\n+}\n+\n+uptr internal_lstat(const char *path, void *buf) {\n+  DEFINE__REAL(int, __lstat50, const char *a, void *b);\n+  return _REAL(__lstat50, path, buf);\n+}\n+\n+uptr internal_fstat(fd_t fd, void *buf) {\n+  DEFINE__REAL(int, __fstat50, int a, void *b);\n+  return _REAL(__fstat50, fd, buf);\n+}\n+\n+uptr internal_filesize(fd_t fd) {\n+  struct stat st;\n+  if (internal_fstat(fd, &st))\n+    return -1;\n+  return (uptr)st.st_size;\n+}\n+\n+uptr internal_dup2(int oldfd, int newfd) {\n+  DEFINE__REAL(int, dup2, int a, int b);\n+  return _REAL(dup2, oldfd, newfd);\n+}\n+\n+uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n+  CHECK(&_sys_readlink);\n+  return (uptr)_sys_readlink(path, buf, bufsize);\n+}\n+\n+uptr internal_unlink(const char *path) {\n+  DEFINE__REAL(int, unlink, const char *a);\n+  return _REAL(unlink, path);\n+}\n+\n+uptr internal_rename(const char *oldpath, const char *newpath) {\n+  DEFINE__REAL(int, rename, const char *a, const char *b);\n+  return _REAL(rename, oldpath, newpath);\n+}\n+\n+uptr internal_sched_yield() {\n+  CHECK(&_sys_sched_yield);\n+  return _sys_sched_yield();\n+}\n+\n+void internal__exit(int exitcode) {\n+  DEFINE__REAL(void, _exit, int a);\n+  _REAL(_exit, exitcode);\n+  Die();  // Unreachable.\n+}\n+\n+unsigned int internal_sleep(unsigned int seconds) {\n+  struct timespec ts;\n+  ts.tv_sec = 1;\n+  ts.tv_nsec = 0;\n+  CHECK(&_sys___nanosleep50);\n+  int res = _sys___nanosleep50(&ts, &ts);\n+  if (res)\n+    return ts.tv_sec;\n+  return 0;\n+}\n+\n+uptr internal_execve(const char *filename, char *const argv[],\n+                     char *const envp[]) {\n+  CHECK(&_sys_execve);\n+  return _sys_execve(filename, argv, envp);\n+}\n+\n+tid_t GetTid() {\n+  DEFINE__REAL(int, _lwp_self);\n+  return _REAL(_lwp_self);\n+}\n+\n+int TgKill(pid_t pid, tid_t tid, int sig) {\n+  DEFINE__REAL(int, _lwp_kill, int a, int b);\n+  (void)pid;\n+  return _REAL(_lwp_kill, tid, sig);\n+}\n+\n+u64 NanoTime() {\n+  timeval tv;\n+  DEFINE__REAL(int, __gettimeofday50, void *a, void *b);\n+  internal_memset(&tv, 0, sizeof(tv));\n+  _REAL(__gettimeofday50, &tv, 0);\n+  return (u64)tv.tv_sec * 1000 * 1000 * 1000 + tv.tv_usec * 1000;\n+}\n+\n+uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp) {\n+  DEFINE__REAL(int, __clock_gettime50, __sanitizer_clockid_t a, void *b);\n+  return _REAL(__clock_gettime50, clk_id, tp);\n+}\n+\n+uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n+  Printf(\"internal_ptrace not implemented for NetBSD\");\n+  Die();\n+  return 0;\n+}\n+\n+uptr internal_waitpid(int pid, int *status, int options) {\n+  CHECK(&_sys___wait450);\n+  return _sys___wait450(pid, status, options, 0 /* rusage */);\n+}\n+\n+uptr internal_getpid() {\n+  DEFINE__REAL(int, getpid);\n+  return _REAL(getpid);\n+}\n+\n+uptr internal_getppid() {\n+  DEFINE__REAL(int, getppid);\n+  return _REAL(getppid);\n+}\n+\n+uptr internal_getdents(fd_t fd, void *dirp, unsigned int count) {\n+  DEFINE__REAL(int, __getdents30, int a, void *b, size_t c);\n+  return _REAL(__getdents30, fd, dirp, count);\n+}\n+\n+uptr internal_lseek(fd_t fd, OFF_T offset, int whence) {\n+  CHECK(&__lseek);\n+  return __lseek(fd, 0, offset, whence);\n+}\n+\n+uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5) {\n+  Printf(\"internal_prctl not implemented for NetBSD\");\n+  Die();\n+  return 0;\n+}\n+\n+uptr internal_sigaltstack(const void *ss, void *oss) {\n+  DEFINE__REAL(int, __sigaltstack14, const void *a, void *b);\n+  return _REAL(__sigaltstack14, ss, oss);\n+}\n+\n+int internal_fork() {\n+  CHECK(&__fork);\n+  return __fork();\n+}\n+\n+int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n+                    uptr *oldlenp, const void *newp, uptr newlen) {\n+  CHECK(&__sysctl);\n+  return __sysctl(name, namelen, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n+}\n+\n+int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n+                          const void *newp, uptr newlen) {\n+  DEFINE__REAL(int, sysctlbyname, const char *a, void *b, size_t *c,\n+               const void *d, size_t e);\n+  return _REAL(sysctlbyname, sname, oldp, (size_t *)oldlenp, newp,\n+               (size_t)newlen);\n+}\n+\n+uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n+                          __sanitizer_sigset_t *oldset) {\n+  CHECK(&_sys___sigprocmask14);\n+  return _sys___sigprocmask14(how, set, oldset);\n+}\n+\n+void internal_sigfillset(__sanitizer_sigset_t *set) {\n+  DEFINE__REAL(int, __sigfillset14, const void *a);\n+  (void)_REAL(__sigfillset14, set);\n+}\n+\n+void internal_sigemptyset(__sanitizer_sigset_t *set) {\n+  DEFINE__REAL(int, __sigemptyset14, const void *a);\n+  (void)_REAL(__sigemptyset14, set);\n+}\n+\n+uptr intrnal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                   int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  Printf(\"internal_clone not implemented for NetBSD\");\n+  Die();\n+  return 0;\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif"}, {"sha": "6ff8b0d10a9ce2a603f597ca20f7770c4aefa9b9", "filename": "libsanitizer/sanitizer_common/sanitizer_openbsd.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,108 @@\n+//===-- sanitizer_openbsd.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between various sanitizers' runtime libraries and\n+// implements Solaris-specific functions.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_OPENBSD\n+\n+#include <stdio.h>\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <pthread.h>\n+#include <sched.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys/mman.h>\n+#include <sys/shm.h>\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+extern char **environ;\n+\n+namespace __sanitizer {\n+\n+uptr internal_mmap(void *addr, size_t length, int prot, int flags, int fd,\n+                   u64 offset) {\n+  return (uptr)mmap(addr, length, prot, flags, fd, offset);\n+}\n+\n+uptr internal_munmap(void *addr, uptr length) { return munmap(addr, length); }\n+\n+int internal_mprotect(void *addr, uptr length, int prot) {\n+  return mprotect(addr, length, prot);\n+}\n+\n+int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n+                          const void *newp, uptr newlen) {\n+  Printf(\"internal_sysctlbyname not implemented for OpenBSD\");\n+  Die();\n+  return 0;\n+}\n+\n+uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n+  // On OpenBSD we cannot get the full path\n+  struct kinfo_proc kp;\n+  uptr kl;\n+  const int Mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()};\n+  if (internal_sysctl(Mib, ARRAY_SIZE(Mib), &kp, &kl, NULL, 0) != -1)\n+    return internal_snprintf(buf,\n+                             (KI_MAXCOMLEN < buf_len ? KI_MAXCOMLEN : buf_len),\n+                             \"%s\", kp.p_comm);\n+  return (uptr)0;\n+}\n+\n+static void GetArgsAndEnv(char ***argv, char ***envp) {\n+  uptr nargv;\n+  uptr nenv;\n+  int argvmib[4] = {CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_ARGV};\n+  int envmib[4] = {CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_ENV};\n+  if (internal_sysctl(argvmib, 4, NULL, &nargv, NULL, 0) == -1) {\n+    Printf(\"sysctl KERN_PROC_NARGV failed\\n\");\n+    Die();\n+  }\n+  if (internal_sysctl(envmib, 4, NULL, &nenv, NULL, 0) == -1) {\n+    Printf(\"sysctl KERN_PROC_NENV failed\\n\");\n+    Die();\n+  }\n+  if (internal_sysctl(argvmib, 4, &argv, &nargv, NULL, 0) == -1) {\n+    Printf(\"sysctl KERN_PROC_ARGV failed\\n\");\n+    Die();\n+  }\n+  if (internal_sysctl(envmib, 4, &envp, &nenv, NULL, 0) == -1) {\n+    Printf(\"sysctl KERN_PROC_ENV failed\\n\");\n+    Die();\n+  }\n+}\n+\n+char **GetArgv() {\n+  char **argv, **envp;\n+  GetArgsAndEnv(&argv, &envp);\n+  return argv;\n+}\n+\n+void ReExec() {\n+  UNIMPLEMENTED();\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_OPENBSD"}, {"sha": "352b374e177069e4d4867e71f2284687acabdae8", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -12,7 +12,9 @@\n #define SANITIZER_PLATFORM_H\n \n #if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && \\\n-  !defined(__APPLE__) && !defined(_WIN32) && !defined(__Fuchsia__)\n+  !defined(__OpenBSD__) && !defined(__APPLE__) && !defined(_WIN32) && \\\n+  !defined(__Fuchsia__) && !defined(__rtems__) && \\\n+  !(defined(__sun__) && defined(__svr4__))\n # error \"This operating system is not supported\"\n #endif\n \n@@ -34,6 +36,18 @@\n # define SANITIZER_NETBSD 0\n #endif\n \n+#if defined(__OpenBSD__)\n+# define SANITIZER_OPENBSD 1\n+#else\n+# define SANITIZER_OPENBSD 0\n+#endif\n+\n+#if defined(__sun__) && defined(__svr4__)\n+# define SANITIZER_SOLARIS 1\n+#else\n+# define SANITIZER_SOLARIS 0\n+#endif\n+\n #if defined(__APPLE__)\n # define SANITIZER_MAC     1\n # include <TargetConditionals.h>\n@@ -42,7 +56,7 @@\n # else\n #  define SANITIZER_IOS    0\n # endif\n-# if TARGET_IPHONE_SIMULATOR\n+# if TARGET_OS_SIMULATOR\n #  define SANITIZER_IOSSIM 1\n # else\n #  define SANITIZER_IOSSIM 0\n@@ -89,8 +103,15 @@\n # define SANITIZER_FUCHSIA 0\n #endif\n \n+#if defined(__rtems__)\n+# define SANITIZER_RTEMS 1\n+#else\n+# define SANITIZER_RTEMS 0\n+#endif\n+\n #define SANITIZER_POSIX \\\n-  (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || SANITIZER_NETBSD)\n+  (SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC || \\\n+    SANITIZER_NETBSD || SANITIZER_OPENBSD || SANITIZER_SOLARIS)\n \n #if __LP64__ || defined(_WIN64)\n #  define SANITIZER_WORDSIZE 64\n@@ -179,6 +200,18 @@\n # define SANITIZER_ARM 0\n #endif\n \n+#if SANITIZER_SOLARIS && SANITIZER_WORDSIZE == 32\n+# define SANITIZER_SOLARIS32 1\n+#else\n+# define SANITIZER_SOLARIS32 0\n+#endif\n+\n+#if defined(__myriad2__)\n+# define SANITIZER_MYRIAD2 1\n+#else\n+# define SANITIZER_MYRIAD2 0\n+#endif\n+\n // By default we allow to use SizeClassAllocator64 on 64-bit platform.\n // But in some cases (e.g. AArch64's 39-bit address space) SizeClassAllocator64\n // does not work well and we need to fallback to SizeClassAllocator32.\n@@ -200,7 +233,12 @@\n #if defined(__mips__)\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 40)\n #elif defined(__aarch64__)\n-# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 48)\n+# if SANITIZER_MAC\n+// Darwin iOS/ARM64 has a 36-bit VMA, 64GiB VM\n+#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 36)\n+# else\n+#  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 48)\n+# endif\n #else\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n #endif\n@@ -280,5 +318,26 @@\n # define SANITIZER_SUPPRESS_LEAK_ON_PTHREAD_EXIT 0\n #endif\n \n+#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_NETBSD || \\\n+  SANITIZER_OPENBSD || SANITIZER_SOLARIS\n+# define SANITIZER_MADVISE_DONTNEED MADV_FREE\n+#else\n+# define SANITIZER_MADVISE_DONTNEED MADV_DONTNEED\n+#endif\n+\n+// Older gcc have issues aligning to a constexpr, and require an integer.\n+// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56859 among others.\n+#if defined(__powerpc__) || defined(__powerpc64__)\n+# define SANITIZER_CACHE_LINE_SIZE 128\n+#else\n+# define SANITIZER_CACHE_LINE_SIZE 64\n+#endif\n+\n+// Enable offline markup symbolizer for Fuchsia and RTEMS.\n+#if SANITIZER_FUCHSIA || SANITIZER_RTEMS\n+#define SANITIZER_SYMBOLIZER_MARKUP 1\n+#else\n+#define SANITIZER_SYMBOLIZER_MARKUP 0\n+#endif\n \n #endif // SANITIZER_PLATFORM_H"}, {"sha": "d6fc2b9ce239a1d8d3865e3395c173c828edf854", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 213, "deletions": 94, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -26,13 +26,15 @@\n # define SI_WINDOWS 1\n #endif\n \n-#if (SI_POSIX != 0) == (SI_WINDOWS != 0) && !SANITIZER_FUCHSIA\n+#if SI_WINDOWS && SI_POSIX\n # error \"Windows is not POSIX!\"\n #endif\n \n #if SI_POSIX\n # include \"sanitizer_platform_limits_netbsd.h\"\n+#include \"sanitizer_platform_limits_openbsd.h\"\n # include \"sanitizer_platform_limits_posix.h\"\n+# include \"sanitizer_platform_limits_solaris.h\"\n #endif\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n@@ -59,6 +61,12 @@\n # define SI_NETBSD 0\n #endif\n \n+#if SANITIZER_OPENBSD\n+#define SI_OPENBSD 1\n+#else\n+#define SI_OPENBSD 0\n+#endif\n+\n #if SANITIZER_LINUX\n # define SI_LINUX 1\n #else\n@@ -85,6 +93,24 @@\n # define SI_NOT_FUCHSIA 1\n #endif\n \n+#if SANITIZER_RTEMS\n+# define SI_NOT_RTEMS 0\n+#else\n+# define SI_NOT_RTEMS 1\n+#endif\n+\n+#if SANITIZER_SOLARIS\n+# define SI_SOLARIS 1\n+#else\n+# define SI_SOLARIS 0\n+#endif\n+\n+#if SANITIZER_SOLARIS32\n+# define SI_SOLARIS32 1\n+#else\n+# define SI_SOLARIS32 0\n+#endif\n+\n #if SANITIZER_POSIX && !SANITIZER_MAC\n # define SI_POSIX_NOT_MAC 1\n #else\n@@ -108,7 +134,7 @@\n #define SANITIZER_INTERCEPT_STRRCHR SI_NOT_FUCHSIA\n #define SANITIZER_INTERCEPT_STRSPN SI_NOT_FUCHSIA\n #define SANITIZER_INTERCEPT_STRPBRK SI_NOT_FUCHSIA\n-#define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_STRCASECMP SI_POSIX\n #define SANITIZER_INTERCEPT_MEMSET 1\n #define SANITIZER_INTERCEPT_MEMMOVE 1\n@@ -126,7 +152,8 @@\n // FIXME: enable memmem on Windows.\n #define SANITIZER_INTERCEPT_MEMMEM (SI_POSIX && !SI_MAC_DEPLOYMENT_BELOW_10_7)\n #define SANITIZER_INTERCEPT_MEMCHR SI_NOT_FUCHSIA\n-#define SANITIZER_INTERCEPT_MEMRCHR (SI_FREEBSD || SI_LINUX || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_MEMRCHR \\\n+  (SI_FREEBSD || SI_LINUX || SI_NETBSD || SI_OPENBSD)\n \n #define SANITIZER_INTERCEPT_READ SI_POSIX\n #define SANITIZER_INTERCEPT_PREAD SI_POSIX\n@@ -135,15 +162,18 @@\n \n #define SANITIZER_INTERCEPT_FREAD SI_POSIX\n #define SANITIZER_INTERCEPT_FWRITE SI_POSIX\n+#define SANITIZER_INTERCEPT_FGETS SI_POSIX\n+#define SANITIZER_INTERCEPT_FPUTS SI_POSIX\n+#define SANITIZER_INTERCEPT_PUTS SI_POSIX\n \n-#define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n+#define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n \n #define SANITIZER_INTERCEPT_READV SI_POSIX\n #define SANITIZER_INTERCEPT_WRITEV SI_POSIX\n \n #define SANITIZER_INTERCEPT_PREADV \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_PWRITEV SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PREADV64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PWRITEV64 SI_LINUX_NOT_ANDROID\n@@ -162,46 +192,62 @@\n # define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX_NOT_ANDROID\n #endif\n \n+#define SANITIZER_INTERCEPT___PRINTF_CHK \\\n+  (SANITIZER_INTERCEPT_PRINTF && SI_LINUX_NOT_ANDROID)\n+\n #define SANITIZER_INTERCEPT_FREXP SI_NOT_FUCHSIA\n #define SANITIZER_INTERCEPT_FREXPF_FREXPL SI_POSIX\n \n #define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_POSIX\n-#define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_GETPWENT \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS                            \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_GETPWENT                                          \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_GETPWENT_R \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_SETPWENT (SI_MAC || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_CLOCK_GETTIME (SI_FREEBSD || SI_NETBSD || SI_LINUX)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_SETPWENT \\\n+  (SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_CLOCK_GETTIME \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETITIMER SI_POSIX\n #define SANITIZER_INTERCEPT_TIME SI_POSIX\n-#define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID || SI_SOLARIS\n+#define SANITIZER_INTERCEPT_GLOB64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WAIT SI_POSIX\n #define SANITIZER_INTERCEPT_INET SI_POSIX\n-#define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM (SI_POSIX && !SI_OPENBSD)\n #define SANITIZER_INTERCEPT_GETADDRINFO SI_POSIX\n #define SANITIZER_INTERCEPT_GETNAMEINFO SI_POSIX\n #define SANITIZER_INTERCEPT_GETSOCKNAME SI_POSIX\n #define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_POSIX\n-#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R (SI_FREEBSD || SI_LINUX)\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME2 SI_POSIX && !SI_SOLARIS\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME_R \\\n+  (SI_FREEBSD || SI_LINUX || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETHOSTBYNAME2_R \\\n   (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_GETHOSTENT_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R \\\n+  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_GETHOSTENT_R \\\n+  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETSOCKOPT SI_POSIX\n #define SANITIZER_INTERCEPT_ACCEPT SI_POSIX\n-#define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_ACCEPT4 \\\n+  (SI_LINUX_NOT_ANDROID || SI_NETBSD || SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_PACCEPT SI_NETBSD\n #define SANITIZER_INTERCEPT_MODF SI_POSIX\n #define SANITIZER_INTERCEPT_RECVMSG SI_POSIX\n #define SANITIZER_INTERCEPT_SENDMSG SI_POSIX\n+#define SANITIZER_INTERCEPT_RECVMMSG SI_LINUX\n+#define SANITIZER_INTERCEPT_SENDMMSG SI_LINUX\n #define SANITIZER_INTERCEPT_GETPEERNAME SI_POSIX\n #define SANITIZER_INTERCEPT_IOCTL SI_POSIX\n #define SANITIZER_INTERCEPT_INET_ATON SI_POSIX\n #define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n #define SANITIZER_INTERCEPT_READDIR SI_POSIX\n-#define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n #if SI_LINUX_NOT_ANDROID && \\\n   (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n     defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n@@ -215,179 +261,252 @@\n #define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STRTOIMAX SI_POSIX\n #define SANITIZER_INTERCEPT_MBSTOWCS SI_POSIX\n-#define SANITIZER_INTERCEPT_MBSNRTOWCS (SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_MBSNRTOWCS \\\n+  (SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_WCSTOMBS SI_POSIX\n-#define SANITIZER_INTERCEPT_WCSNRTOMBS \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_WCRTOMB \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_STRXFRM SI_POSIX\n+#define SANITIZER_INTERCEPT___STRXFRM_L SI_LINUX\n+#define SANITIZER_INTERCEPT_WCSXFRM SI_POSIX\n+#define SANITIZER_INTERCEPT___WCSXFRM_L SI_LINUX\n+#define SANITIZER_INTERCEPT_WCSNRTOMBS                                        \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_WCRTOMB                                           \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_REALPATH SI_POSIX\n-#define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_CONFSTR \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME \\\n+  (SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_CONFSTR                                           \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SCHED_GETPARAM SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SCHED_GETPARAM SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_STRERROR SI_POSIX\n #define SANITIZER_INTERCEPT_STRERROR_R SI_POSIX\n #define SANITIZER_INTERCEPT_XPG_STRERROR_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SCANDIR \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n #define SANITIZER_INTERCEPT_GETGROUPS SI_POSIX\n #define SANITIZER_INTERCEPT_POLL SI_POSIX\n-#define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PPOLL SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_WORDEXP \\\n-  (SI_FREEBSD || SI_NETBSD || (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID || \\\n+    SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SIGWAIT SI_POSIX\n-#define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID || SI_SOLARIS\n+#define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_SIGSETOPS \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SIGPENDING SI_POSIX\n #define SANITIZER_INTERCEPT_SIGPROCMASK SI_POSIX\n #define SANITIZER_INTERCEPT_BACKTRACE \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n #define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATFS \\\n-  (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_STATFS64 \\\n   ((SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATVFS \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_INITGROUPS SI_POSIX\n-#define SANITIZER_INTERCEPT_ETHER_NTOA_ATON SI_POSIX\n+#define SANITIZER_INTERCEPT_ETHER_NTOA_ATON (SI_POSIX && !SI_OPENBSD)\n #define SANITIZER_INTERCEPT_ETHER_HOST \\\n   (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_ETHER_R (SI_FREEBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_SHMCTL                       \\\n-  (SI_NETBSD || ((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && \\\n-                 SANITIZER_WORDSIZE == 64))  // NOLINT\n+#define SANITIZER_INTERCEPT_SHMCTL          \\\n+  (SI_NETBSD || SI_OPENBSD || SI_SOLARIS || \\\n+  ((SI_FREEBSD || SI_LINUX_NOT_ANDROID) && \\\n+    SANITIZER_WORDSIZE == 64))  // NOLINT\n #define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED SI_POSIX\n-#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED (SI_POSIX && !SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED \\\n+  (SI_POSIX && !SI_NETBSD && !SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE (SI_POSIX && !SI_OPENBSD)\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPROTOCOL \\\n-  (SI_MAC || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_MAC || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPRIOCEILING \\\n-  (SI_MAC || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n-#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST SI_LINUX_NOT_ANDROID\n+  (SI_MAC || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST \\\n+  (SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED \\\n+  (SI_POSIX && !SI_NETBSD && !SI_OPENBSD)\n #define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED SI_POSIX\n-#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED \\\n+  (SI_POSIX && !SI_NETBSD && !SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK \\\n+  (SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED \\\n+  (SI_LINUX_NOT_ANDROID && !SI_NETBSD && !SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_THR_EXIT SI_FREEBSD\n #define SANITIZER_INTERCEPT_TMPNAM SI_POSIX\n-#define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_TTYNAME_R SI_POSIX\n #define SANITIZER_INTERCEPT_TEMPNAM SI_POSIX\n-#define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n+#define SANITIZER_INTERCEPT_SINCOS SI_LINUX || SI_SOLARIS\n #define SANITIZER_INTERCEPT_REMQUO SI_POSIX\n #define SANITIZER_INTERCEPT_LGAMMA SI_POSIX\n-#define SANITIZER_INTERCEPT_LGAMMA_R (SI_FREEBSD || SI_LINUX)\n-#define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_LGAMMA_R (SI_FREEBSD || SI_LINUX || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_RAND_R \\\n-  (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID)\n+#define SANITIZER_INTERCEPT_RAND_R                                            \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n #define SANITIZER_INTERCEPT_ICONV \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_TIMES SI_POSIX\n \n // FIXME: getline seems to be available on OSX 10.7\n #define SANITIZER_INTERCEPT_GETLINE \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPT__EXIT \\\n-  (SI_LINUX || SI_FREEBSD || SI_NETBSD || SI_MAC)\n+  (SI_LINUX || SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_SOLARIS)\n \n-#define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEX SI_POSIX\n+#define SANITIZER_INTERCEPT___PTHREAD_MUTEX SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT___LIBC_MUTEX SI_NETBSD\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_PTHREAD_GETNAME_NP \\\n+  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPT_TLS_GET_ADDR \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID)\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPT_LISTXATTR SI_LINUX\n #define SANITIZER_INTERCEPT_GETXATTR SI_LINUX\n #define SANITIZER_INTERCEPT_GETRESID SI_LINUX\n-#define SANITIZER_INTERCEPT_GETIFADDRS \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_MAC)\n-#define SANITIZER_INTERCEPT_IF_INDEXTONAME \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_MAC)\n+#define SANITIZER_INTERCEPT_GETIFADDRS                                        \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_MAC || \\\n+  SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_IF_INDEXTONAME                                    \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_MAC || \\\n+  SI_SOLARIS)\n #define SANITIZER_INTERCEPT_CAPGET SI_LINUX_NOT_ANDROID\n #if SI_LINUX && defined(__arm__)\n #define SANITIZER_INTERCEPT_AEABI_MEM 1\n #else\n #define SANITIZER_INTERCEPT_AEABI_MEM 0\n #endif\n #define SANITIZER_INTERCEPT___BZERO SI_MAC\n-#define SANITIZER_INTERCEPT_FTIME (!SI_FREEBSD && !SI_NETBSD && SI_POSIX)\n-#define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_FTIME \\\n+  (!SI_FREEBSD && !SI_NETBSD && !SI_OPENBSD && SI_POSIX)\n+#define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_TSEARCH \\\n-  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD)\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD || SI_OPENBSD || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FOPEN SI_POSIX\n-#define SANITIZER_INTERCEPT_FOPEN64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_OPEN_MEMSTREAM (SI_LINUX_NOT_ANDROID || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_FOPEN64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n+#define SANITIZER_INTERCEPT_OPEN_MEMSTREAM \\\n+  (SI_LINUX_NOT_ANDROID || SI_NETBSD || SI_OPENBSD || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FFLUSH SI_POSIX\n #define SANITIZER_INTERCEPT_FCLOSE SI_POSIX\n \n #ifndef SANITIZER_INTERCEPT_DLOPEN_DLCLOSE\n-#define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE \\\n-  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_MAC)\n+#define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE                                    \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_MAC || \\\n+  SI_SOLARIS)\n #endif\n \n #define SANITIZER_INTERCEPT_GETPASS \\\n-  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD)\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD || SI_OPENBSD)\n #define SANITIZER_INTERCEPT_TIMERFD SI_LINUX_NOT_ANDROID\n \n #define SANITIZER_INTERCEPT_MLOCKX SI_POSIX\n #define SANITIZER_INTERCEPT_FOPENCOOKIE SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SEM (SI_LINUX || SI_FREEBSD || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_SEM \\\n+  (SI_LINUX || SI_FREEBSD || SI_NETBSD || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_SETCANCEL SI_POSIX\n-#define SANITIZER_INTERCEPT_MINCORE (SI_LINUX || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_MINCORE \\\n+  (SI_LINUX || SI_NETBSD || SI_OPENBSD || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PROCESS_VM_READV SI_LINUX\n #define SANITIZER_INTERCEPT_CTERMID \\\n-  (SI_LINUX || SI_MAC || SI_FREEBSD || SI_NETBSD)\n-#define SANITIZER_INTERCEPT_CTERMID_R (SI_MAC || SI_FREEBSD)\n+  (SI_LINUX || SI_MAC || SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_CTERMID_R (SI_MAC || SI_FREEBSD || SI_SOLARIS)\n \n-#define SANITIZER_INTERCEPTOR_HOOKS (SI_LINUX || SI_MAC || SI_WINDOWS)\n+#define SANITIZER_INTERCEPTOR_HOOKS \\\n+  (SI_LINUX || SI_MAC || SI_WINDOWS || SI_NETBSD)\n #define SANITIZER_INTERCEPT_RECV_RECVFROM SI_POSIX\n #define SANITIZER_INTERCEPT_SEND_SENDTO SI_POSIX\n #define SANITIZER_INTERCEPT_EVENTFD_READ_WRITE SI_LINUX\n \n #define SANITIZER_INTERCEPT_STAT \\\n-  (SI_FREEBSD || SI_MAC || SI_ANDROID || SI_NETBSD)\n+  (SI_FREEBSD || SI_MAC || SI_ANDROID || SI_NETBSD || SI_OPENBSD || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_LSTAT (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT___XSTAT (!SANITIZER_INTERCEPT_STAT && SI_POSIX)\n #define SANITIZER_INTERCEPT___XSTAT64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT___LXSTAT SANITIZER_INTERCEPT___XSTAT\n #define SANITIZER_INTERCEPT___LXSTAT64 SI_LINUX_NOT_ANDROID\n \n-#define SANITIZER_INTERCEPT_UTMP (SI_POSIX && !SI_MAC && !SI_FREEBSD)\n-#define SANITIZER_INTERCEPT_UTMPX (SI_LINUX_NOT_ANDROID || SI_MAC || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_UTMP \\\n+  (SI_POSIX && !SI_MAC && !SI_FREEBSD && !SI_NETBSD)\n+#define SANITIZER_INTERCEPT_UTMPX \\\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_FREEBSD || SI_NETBSD)\n \n #define SANITIZER_INTERCEPT_GETLOADAVG \\\n-  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_FREEBSD || SI_NETBSD)\n+  (SI_LINUX_NOT_ANDROID || SI_MAC || SI_FREEBSD || SI_NETBSD || SI_OPENBSD)\n \n+#define SANITIZER_INTERCEPT_MMAP SI_POSIX\n+#define SANITIZER_INTERCEPT_MMAP64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA)\n-#define SANITIZER_INTERCEPT_MEMALIGN (!SI_FREEBSD && !SI_MAC && !SI_NETBSD)\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n+  SI_NOT_RTEMS)\n+#define SANITIZER_INTERCEPT_MEMALIGN \\\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_RTEMS)\n #define SANITIZER_INTERCEPT_PVALLOC \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA)\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n+  SI_NOT_RTEMS)\n #define SANITIZER_INTERCEPT_CFREE \\\n-  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && SI_NOT_FUCHSIA)\n-#define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC)\n-#define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC)\n+  (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n+  SI_NOT_RTEMS)\n+#define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC && SI_NOT_RTEMS)\n+#define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC && !SI_OPENBSD)\n #define SANITIZER_INTERCEPT_MCHECK_MPROBE SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WCSCAT SI_POSIX\n #define SANITIZER_INTERCEPT_SIGNAL_AND_SIGACTION (!SI_WINDOWS && SI_NOT_FUCHSIA)\n #define SANITIZER_INTERCEPT_BSD_SIGNAL SI_ANDROID\n \n+#define SANITIZER_INTERCEPT_ACCT (SI_NETBSD || SI_OPENBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_USER_FROM_UID SI_NETBSD\n+#define SANITIZER_INTERCEPT_UID_FROM_USER SI_NETBSD\n+#define SANITIZER_INTERCEPT_GROUP_FROM_GID SI_NETBSD\n+#define SANITIZER_INTERCEPT_GID_FROM_GROUP SI_NETBSD\n+#define SANITIZER_INTERCEPT_ACCESS (SI_NETBSD || SI_OPENBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_FACCESSAT (SI_NETBSD || SI_OPENBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_GETGROUPLIST (SI_NETBSD || SI_OPENBSD)\n+#define SANITIZER_INTERCEPT_STRLCPY                                            \\\n+  (SI_NETBSD || SI_FREEBSD || SI_OPENBSD || SI_MAC || SI_ANDROID)\n+\n+#define SANITIZER_INTERCEPT_NAME_TO_HANDLE_AT SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_OPEN_BY_HANDLE_AT SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT_READLINK SI_POSIX\n+#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \\\n+    __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 101000\n+# define SI_MAC_DEPLOYMENT_BELOW_10_10 1\n+#else\n+# define SI_MAC_DEPLOYMENT_BELOW_10_10 0\n+#endif\n+#define SANITIZER_INTERCEPT_READLINKAT \\\n+  (SI_POSIX && !SI_MAC_DEPLOYMENT_BELOW_10_10)\n+\n+#define SANITIZER_INTERCEPT_DEVNAME (SI_NETBSD || SI_OPENBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_DEVNAME_R (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_FGETLN (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_STRMODE (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_TTYENT SI_NETBSD\n+#define SANITIZER_INTERCEPT_PROTOENT SI_NETBSD\n+#define SANITIZER_INTERCEPT_NETENT SI_NETBSD\n+\n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "23a014823c4fcca46e86dccc5bb57a2679df43f4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -25,12 +25,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t"}, {"sha": "8e74727c9990c5103d4aa9b1c70231b470b2ddb9", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.cc", "status": "modified", "additions": 1910, "deletions": 42, "changes": 1952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -13,7 +13,53 @@\n #include \"sanitizer_platform.h\"\n \n #if SANITIZER_NETBSD\n+#include <sys/param.h>\n+#include <sys/types.h>\n+\n+#include <altq/altq.h>\n+#include <altq/altq_afmap.h>\n+#include <altq/altq_blue.h>\n+#include <altq/altq_cbq.h>\n+#include <altq/altq_cdnr.h>\n+#include <altq/altq_fifoq.h>\n+#include <altq/altq_hfsc.h>\n+#include <altq/altq_jobs.h>\n+#include <altq/altq_priq.h>\n+#include <altq/altq_red.h>\n+#include <altq/altq_rio.h>\n+#include <altq/altq_wfq.h>\n #include <arpa/inet.h>\n+#include <crypto/cryptodev.h>\n+#include <dev/apm/apmio.h>\n+#include <dev/dm/netbsd-dm.h>\n+#include <dev/dmover/dmover_io.h>\n+#include <dev/dtv/dtvio_demux.h>\n+#include <dev/dtv/dtvio_frontend.h>\n+#include <dev/filemon/filemon.h>\n+#include <dev/hdaudio/hdaudioio.h>\n+#include <dev/hdmicec/hdmicecio.h>\n+#include <dev/hpc/hpcfbio.h>\n+#include <dev/i2o/iopio.h>\n+#include <dev/ic/athioctl.h>\n+#include <dev/ic/bt8xx.h>\n+#include <dev/ic/icp_ioctl.h>\n+#include <dev/ic/isp_ioctl.h>\n+#include <dev/ic/mlxio.h>\n+#include <dev/ic/nvmeio.h>\n+#include <dev/ir/irdaio.h>\n+#include <dev/isa/isvio.h>\n+#include <dev/isa/satlinkio.h>\n+#include <dev/isa/wtreg.h>\n+#include <dev/iscsi/iscsi_ioctl.h>\n+#include <dev/ofw/openfirmio.h>\n+#include <dev/pci/amrio.h>\n+\n+#include <dev/pci/mlyreg.h>\n+#include <dev/pci/mlyio.h>\n+\n+#include <dev/pci/pciio.h>\n+#include <dev/pci/tweio.h>\n+#include <dev/pcmcia/if_cnwioctl.h>\n #include <dirent.h>\n #include <glob.h>\n #include <grp.h>\n@@ -26,13 +72,102 @@\n #include <net/route.h>\n #include <netdb.h>\n #include <netinet/in.h>\n+#include <netinet/ip_compat.h>\n+#include <netinet/ip_fil.h>\n #include <netinet/ip_mroute.h>\n #include <poll.h>\n #include <pthread.h>\n #include <pwd.h>\n #include <semaphore.h>\n #include <signal.h>\n #include <stddef.h>\n+#include <stdio.h>\n+#include <sys/disk.h>\n+#include <sys/disklabel.h>\n+#include <sys/mount.h>\n+#define RAY_DO_SIGLEV\n+#include <dev/biovar.h>\n+#include <dev/bluetooth/btdev.h>\n+#include <dev/bluetooth/btsco.h>\n+#include <dev/ccdvar.h>\n+#include <dev/cgdvar.h>\n+#include <dev/fssvar.h>\n+#include <dev/kttcpio.h>\n+#include <dev/lockstat.h>\n+#include <dev/md.h>\n+#include <dev/pcmcia/if_rayreg.h>\n+#include <dev/raidframe/raidframeio.h>\n+#include <dev/sbus/mbppio.h>\n+#include <dev/scsipi/ses.h>\n+#include <dev/spkrio.h>\n+#include <dev/sun/disklabel.h>\n+#include <dev/sun/fbio.h>\n+#include <dev/sun/kbio.h>\n+#include <dev/sun/vuid_event.h>\n+#include <dev/tc/sticio.h>\n+#include <dev/usb/ukyopon.h>\n+#include <dev/usb/urio.h>\n+#include <dev/usb/usb.h>\n+#include <dev/usb/utoppy.h>\n+#include <dev/vme/xio.h>\n+#include <dev/vndvar.h>\n+#include <dev/wscons/wsconsio.h>\n+#include <dev/wscons/wsdisplay_usl_io.h>\n+#include <net/bpf.h>\n+#include <net/if_atm.h>\n+#include <net/if_gre.h>\n+#include <net/if_ppp.h>\n+#include <net/if_pppoe.h>\n+#include <net/if_sppp.h>\n+#include <net/if_srt.h>\n+#include <net/if_tap.h>\n+#include <net/if_tun.h>\n+#include <net/npf.h>\n+#include <net/pfvar.h>\n+#include <net/slip.h>\n+#include <netbt/hci.h>\n+#include <netinet/ip_nat.h>\n+#include <netinet/ip_proxy.h>\n+#include <netinet6/in6_var.h>\n+#include <netinet6/nd6.h>\n+#include <netnatm/natm.h>\n+#include <netsmb/smb_dev.h>\n+#include <soundcard.h>\n+#include <sys/agpio.h>\n+#include <sys/ataio.h>\n+#include <sys/audioio.h>\n+#include <sys/cdio.h>\n+#include <sys/chio.h>\n+#include <sys/clockctl.h>\n+#include <sys/cpuio.h>\n+#include <sys/dkio.h>\n+#include <sys/drvctlio.h>\n+#include <sys/dvdio.h>\n+#include <sys/envsys.h>\n+#include <sys/event.h>\n+#include <sys/fdio.h>\n+#include <sys/filio.h>\n+#include <sys/gpio.h>\n+#include <sys/ioctl.h>\n+#include <sys/ioctl_compat.h>\n+#include <sys/joystick.h>\n+#include <sys/ksyms.h>\n+#include <sys/lua.h>\n+#include <sys/midiio.h>\n+#include <sys/mtio.h>\n+#include <sys/power.h>\n+#include <sys/radioio.h>\n+#include <sys/rndio.h>\n+#include <sys/scanio.h>\n+#include <sys/scsiio.h>\n+#include <sys/sockio.h>\n+#include <sys/timepps.h>\n+#include <sys/ttycom.h>\n+#include <sys/verified_exec.h>\n+#include <sys/videoio.h>\n+#include <sys/wdog.h>\n+//#include <xen/xenio.h>\n+#include <sys/event.h>\n #include <sys/filio.h>\n #include <sys/ipc.h>\n #include <sys/mman.h>\n@@ -42,6 +177,7 @@\n #include <sys/mtio.h>\n #include <sys/ptrace.h>\n #include <sys/resource.h>\n+#include <sys/sem.h>\n #include <sys/shm.h>\n #include <sys/signal.h>\n #include <sys/socket.h>\n@@ -60,6 +196,7 @@\n #include <term.h>\n #include <termios.h>\n #include <time.h>\n+#include <ttyent.h>\n #include <utime.h>\n #include <utmp.h>\n #include <utmpx.h>\n@@ -81,6 +218,7 @@ unsigned siginfo_t_sz = sizeof(siginfo_t);\n unsigned struct_sigaction_sz = sizeof(struct sigaction);\n unsigned struct_itimerval_sz = sizeof(struct itimerval);\n unsigned pthread_t_sz = sizeof(pthread_t);\n+unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);\n unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n unsigned pid_t_sz = sizeof(pid_t);\n unsigned timeval_sz = sizeof(timeval);\n@@ -96,16 +234,80 @@ unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n unsigned ucontext_t_sz = sizeof(ucontext_t);\n unsigned struct_rlimit_sz = sizeof(struct rlimit);\n unsigned struct_timespec_sz = sizeof(struct timespec);\n+unsigned struct_sembuf_sz = sizeof(struct sembuf);\n+unsigned struct_kevent_sz = sizeof(struct kevent);\n unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n unsigned struct_timex_sz = sizeof(struct timex);\n unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n unsigned struct_statvfs_sz = sizeof(struct statvfs);\n+unsigned struct_sigaltstack_sz = sizeof(stack_t);\n+\n+const uptr sig_ign = (uptr)SIG_IGN;\n+const uptr sig_dfl = (uptr)SIG_DFL;\n+const uptr sig_err = (uptr)SIG_ERR;\n+const uptr sa_siginfo = (uptr)SA_SIGINFO;\n+\n+int ptrace_pt_io = PT_IO;\n+int ptrace_pt_lwpinfo = PT_LWPINFO;\n+int ptrace_pt_set_event_mask = PT_SET_EVENT_MASK;\n+int ptrace_pt_get_event_mask = PT_GET_EVENT_MASK;\n+int ptrace_pt_get_process_state = PT_GET_PROCESS_STATE;\n+int ptrace_pt_set_siginfo = PT_SET_SIGINFO;\n+int ptrace_pt_get_siginfo = PT_GET_SIGINFO;\n+int ptrace_piod_read_d = PIOD_READ_D;\n+int ptrace_piod_write_d = PIOD_WRITE_D;\n+int ptrace_piod_read_i = PIOD_READ_I;\n+int ptrace_piod_write_i = PIOD_WRITE_I;\n+int ptrace_piod_read_auxv = PIOD_READ_AUXV;\n+\n+#if defined(PT_SETREGS) && defined(PT_GETREGS)\n+int ptrace_pt_setregs = PT_SETREGS;\n+int ptrace_pt_getregs = PT_GETREGS;\n+#else\n+int ptrace_pt_setregs = -1;\n+int ptrace_pt_getregs = -1;\n+#endif\n+\n+#if defined(PT_SETFPREGS) && defined(PT_GETFPREGS)\n+int ptrace_pt_setfpregs = PT_SETFPREGS;\n+int ptrace_pt_getfpregs = PT_GETFPREGS;\n+#else\n+int ptrace_pt_setfpregs = -1;\n+int ptrace_pt_getfpregs = -1;\n+#endif\n+\n+#if defined(PT_SETDBREGS) && defined(PT_GETDBREGS)\n+int ptrace_pt_setdbregs = PT_SETDBREGS;\n+int ptrace_pt_getdbregs = PT_GETDBREGS;\n+#else\n+int ptrace_pt_setdbregs = -1;\n+int ptrace_pt_getdbregs = -1;\n+#endif\n+\n+unsigned struct_ptrace_ptrace_io_desc_struct_sz = sizeof(struct ptrace_io_desc);\n+unsigned struct_ptrace_ptrace_lwpinfo_struct_sz = sizeof(struct ptrace_lwpinfo);\n+unsigned struct_ptrace_ptrace_event_struct_sz = sizeof(ptrace_event_t);\n+unsigned struct_ptrace_ptrace_siginfo_struct_sz = sizeof(ptrace_siginfo_t);\n \n-uptr sig_ign = (uptr)SIG_IGN;\n-uptr sig_dfl = (uptr)SIG_DFL;\n-uptr sa_siginfo = (uptr)SA_SIGINFO;\n+#if defined(PT_SETREGS)\n+unsigned struct_ptrace_reg_struct_sz = sizeof(struct reg);\n+#else\n+unsigned struct_ptrace_reg_struct_sz = -1;\n+#endif\n+\n+#if defined(PT_SETFPREGS)\n+unsigned struct_ptrace_fpreg_struct_sz = sizeof(struct fpreg);\n+#else\n+unsigned struct_ptrace_fpreg_struct_sz = -1;\n+#endif\n+\n+#if defined(PT_SETDBREGS)\n+unsigned struct_ptrace_dbreg_struct_sz = sizeof(struct dbreg);\n+#else\n+unsigned struct_ptrace_dbreg_struct_sz = -1;\n+#endif\n \n int shmctl_ipc_stat = (int)IPC_STAT;\n \n@@ -126,70 +328,1736 @@ uptr __sanitizer_in_addr_sz(int af) {\n     return 0;\n }\n \n+unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n+\n int glob_nomatch = GLOB_NOMATCH;\n int glob_altdirfunc = GLOB_ALTDIRFUNC;\n \n unsigned path_max = PATH_MAX;\n \n+int struct_ttyent_sz = sizeof(struct ttyent);\n+\n // ioctl arguments\n-unsigned struct_ifreq_sz = sizeof(struct ifreq);\n-unsigned struct_termios_sz = sizeof(struct termios);\n-unsigned struct_winsize_sz = sizeof(struct winsize);\n-unsigned struct_mtget_sz = sizeof(struct mtget);\n-unsigned struct_mtop_sz = sizeof(struct mtop);\n-unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n-unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n-unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n-unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n+unsigned struct_altqreq_sz = sizeof(altqreq);\n+unsigned struct_amr_user_ioctl_sz = sizeof(amr_user_ioctl);\n+unsigned struct_ap_control_sz = sizeof(ap_control);\n+unsigned struct_apm_ctl_sz = sizeof(apm_ctl);\n+unsigned struct_apm_event_info_sz = sizeof(apm_event_info);\n+unsigned struct_apm_power_info_sz = sizeof(apm_power_info);\n+unsigned struct_atabusiodetach_args_sz = sizeof(atabusiodetach_args);\n+unsigned struct_atabusioscan_args_sz = sizeof(atabusioscan_args);\n+unsigned struct_ath_diag_sz = sizeof(ath_diag);\n+unsigned struct_atm_flowmap_sz = sizeof(atm_flowmap);\n+unsigned struct_atm_pseudoioctl_sz = sizeof(atm_pseudoioctl);\n+unsigned struct_audio_buf_info_sz = sizeof(audio_buf_info);\n+unsigned struct_audio_device_sz = sizeof(audio_device);\n+unsigned struct_audio_encoding_sz = sizeof(audio_encoding);\n+unsigned struct_audio_info_sz = sizeof(audio_info);\n+unsigned struct_audio_offset_sz = sizeof(audio_offset);\n+unsigned struct_bio_locate_sz = sizeof(bio_locate);\n+unsigned struct_bioc_alarm_sz = sizeof(bioc_alarm);\n+unsigned struct_bioc_blink_sz = sizeof(bioc_blink);\n+unsigned struct_bioc_disk_sz = sizeof(bioc_disk);\n+unsigned struct_bioc_inq_sz = sizeof(bioc_inq);\n+unsigned struct_bioc_setstate_sz = sizeof(bioc_setstate);\n+unsigned struct_bioc_vol_sz = sizeof(bioc_vol);\n+unsigned struct_bioc_volops_sz = sizeof(bioc_volops);\n+unsigned struct_bktr_chnlset_sz = sizeof(bktr_chnlset);\n+unsigned struct_bktr_remote_sz = sizeof(bktr_remote);\n+unsigned struct_blue_conf_sz = sizeof(blue_conf);\n+unsigned struct_blue_interface_sz = sizeof(blue_interface);\n+unsigned struct_blue_stats_sz = sizeof(blue_stats);\n+unsigned struct_bpf_dltlist_sz = sizeof(bpf_dltlist);\n+unsigned struct_bpf_program_sz = sizeof(bpf_program);\n+unsigned struct_bpf_stat_old_sz = sizeof(bpf_stat_old);\n+unsigned struct_bpf_stat_sz = sizeof(bpf_stat);\n+unsigned struct_bpf_version_sz = sizeof(bpf_version);\n+unsigned struct_btreq_sz = sizeof(btreq);\n+unsigned struct_btsco_info_sz = sizeof(btsco_info);\n+unsigned struct_buffmem_desc_sz = sizeof(buffmem_desc);\n+unsigned struct_cbq_add_class_sz = sizeof(cbq_add_class);\n+unsigned struct_cbq_add_filter_sz = sizeof(cbq_add_filter);\n+unsigned struct_cbq_delete_class_sz = sizeof(cbq_delete_class);\n+unsigned struct_cbq_delete_filter_sz = sizeof(cbq_delete_filter);\n+unsigned struct_cbq_getstats_sz = sizeof(cbq_getstats);\n+unsigned struct_cbq_interface_sz = sizeof(cbq_interface);\n+unsigned struct_cbq_modify_class_sz = sizeof(cbq_modify_class);\n+unsigned struct_ccd_ioctl_sz = sizeof(ccd_ioctl);\n+unsigned struct_cdnr_add_element_sz = sizeof(cdnr_add_element);\n+unsigned struct_cdnr_add_filter_sz = sizeof(cdnr_add_filter);\n+unsigned struct_cdnr_add_tbmeter_sz = sizeof(cdnr_add_tbmeter);\n+unsigned struct_cdnr_add_trtcm_sz = sizeof(cdnr_add_trtcm);\n+unsigned struct_cdnr_add_tswtcm_sz = sizeof(cdnr_add_tswtcm);\n+unsigned struct_cdnr_delete_element_sz = sizeof(cdnr_delete_element);\n+unsigned struct_cdnr_delete_filter_sz = sizeof(cdnr_delete_filter);\n+unsigned struct_cdnr_get_stats_sz = sizeof(cdnr_get_stats);\n+unsigned struct_cdnr_interface_sz = sizeof(cdnr_interface);\n+unsigned struct_cdnr_modify_tbmeter_sz = sizeof(cdnr_modify_tbmeter);\n+unsigned struct_cdnr_modify_trtcm_sz = sizeof(cdnr_modify_trtcm);\n+unsigned struct_cdnr_modify_tswtcm_sz = sizeof(cdnr_modify_tswtcm);\n+unsigned struct_cdnr_tbmeter_stats_sz = sizeof(cdnr_tbmeter_stats);\n+unsigned struct_cdnr_tcm_stats_sz = sizeof(cdnr_tcm_stats);\n+unsigned struct_cgd_ioctl_sz = sizeof(cgd_ioctl);\n+unsigned struct_cgd_user_sz = sizeof(cgd_user);\n+unsigned struct_changer_element_status_request_sz =\n+    sizeof(changer_element_status_request);\n+unsigned struct_changer_exchange_request_sz = sizeof(changer_exchange_request);\n+unsigned struct_changer_move_request_sz = sizeof(changer_move_request);\n+unsigned struct_changer_params_sz = sizeof(changer_params);\n+unsigned struct_changer_position_request_sz = sizeof(changer_position_request);\n+unsigned struct_changer_set_voltag_request_sz =\n+    sizeof(changer_set_voltag_request);\n+unsigned struct_clockctl_adjtime_sz = sizeof(clockctl_adjtime);\n+unsigned struct_clockctl_clock_settime_sz = sizeof(clockctl_clock_settime);\n+unsigned struct_clockctl_ntp_adjtime_sz = sizeof(clockctl_ntp_adjtime);\n+unsigned struct_clockctl_settimeofday_sz = sizeof(clockctl_settimeofday);\n+unsigned struct_cnwistats_sz = sizeof(cnwistats);\n+unsigned struct_cnwitrail_sz = sizeof(cnwitrail);\n+unsigned struct_cnwstatus_sz = sizeof(cnwstatus);\n+unsigned struct_count_info_sz = sizeof(count_info);\n+unsigned struct_cpu_ucode_sz = sizeof(cpu_ucode);\n+unsigned struct_cpu_ucode_version_sz = sizeof(cpu_ucode_version);\n+unsigned struct_crypt_kop_sz = sizeof(crypt_kop);\n+unsigned struct_crypt_mkop_sz = sizeof(crypt_mkop);\n+unsigned struct_crypt_mop_sz = sizeof(crypt_mop);\n+unsigned struct_crypt_op_sz = sizeof(crypt_op);\n+unsigned struct_crypt_result_sz = sizeof(crypt_result);\n+unsigned struct_crypt_sfop_sz = sizeof(crypt_sfop);\n+unsigned struct_crypt_sgop_sz = sizeof(crypt_sgop);\n+unsigned struct_cryptret_sz = sizeof(cryptret);\n+unsigned struct_devdetachargs_sz = sizeof(devdetachargs);\n+unsigned struct_devlistargs_sz = sizeof(devlistargs);\n+unsigned struct_devpmargs_sz = sizeof(devpmargs);\n+unsigned struct_devrescanargs_sz = sizeof(devrescanargs);\n+unsigned struct_disk_badsecinfo_sz = sizeof(disk_badsecinfo);\n+unsigned struct_disk_strategy_sz = sizeof(disk_strategy);\n+unsigned struct_disklabel_sz = sizeof(disklabel);\n+unsigned struct_dkbad_sz = sizeof(dkbad);\n+unsigned struct_dkwedge_info_sz = sizeof(dkwedge_info);\n+unsigned struct_dkwedge_list_sz = sizeof(dkwedge_list);\n+unsigned struct_dmio_setfunc_sz = sizeof(dmio_setfunc);\n+unsigned struct_dmx_pes_filter_params_sz = sizeof(dmx_pes_filter_params);\n+unsigned struct_dmx_sct_filter_params_sz = sizeof(dmx_sct_filter_params);\n+unsigned struct_dmx_stc_sz = sizeof(dmx_stc);\n+unsigned struct_dvb_diseqc_master_cmd_sz = sizeof(dvb_diseqc_master_cmd);\n+unsigned struct_dvb_diseqc_slave_reply_sz = sizeof(dvb_diseqc_slave_reply);\n+unsigned struct_dvb_frontend_event_sz = sizeof(dvb_frontend_event);\n+unsigned struct_dvb_frontend_info_sz = sizeof(dvb_frontend_info);\n+unsigned struct_dvb_frontend_parameters_sz = sizeof(dvb_frontend_parameters);\n+unsigned struct_eccapreq_sz = sizeof(eccapreq);\n+unsigned struct_fbcmap_sz = sizeof(fbcmap);\n+unsigned struct_fbcurpos_sz = sizeof(fbcurpos);\n+unsigned struct_fbcursor_sz = sizeof(fbcursor);\n+unsigned struct_fbgattr_sz = sizeof(fbgattr);\n+unsigned struct_fbsattr_sz = sizeof(fbsattr);\n+unsigned struct_fbtype_sz = sizeof(fbtype);\n+unsigned struct_fdformat_cmd_sz = sizeof(fdformat_cmd);\n+unsigned struct_fdformat_parms_sz = sizeof(fdformat_parms);\n+unsigned struct_fifoq_conf_sz = sizeof(fifoq_conf);\n+unsigned struct_fifoq_getstats_sz = sizeof(fifoq_getstats);\n+unsigned struct_fifoq_interface_sz = sizeof(fifoq_interface);\n+unsigned struct_format_op_sz = sizeof(format_op);\n+unsigned struct_fss_get_sz = sizeof(fss_get);\n+unsigned struct_fss_set_sz = sizeof(fss_set);\n+unsigned struct_gpio_attach_sz = sizeof(gpio_attach);\n+unsigned struct_gpio_info_sz = sizeof(gpio_info);\n+unsigned struct_gpio_req_sz = sizeof(gpio_req);\n+unsigned struct_gpio_set_sz = sizeof(gpio_set);\n+unsigned struct_hfsc_add_class_sz = sizeof(hfsc_add_class);\n+unsigned struct_hfsc_add_filter_sz = sizeof(hfsc_add_filter);\n+unsigned struct_hfsc_attach_sz = sizeof(hfsc_attach);\n+unsigned struct_hfsc_class_stats_sz = sizeof(hfsc_class_stats);\n+unsigned struct_hfsc_delete_class_sz = sizeof(hfsc_delete_class);\n+unsigned struct_hfsc_delete_filter_sz = sizeof(hfsc_delete_filter);\n+unsigned struct_hfsc_interface_sz = sizeof(hfsc_interface);\n+unsigned struct_hfsc_modify_class_sz = sizeof(hfsc_modify_class);\n+unsigned struct_hpcfb_dsp_op_sz = sizeof(hpcfb_dsp_op);\n+unsigned struct_hpcfb_dspconf_sz = sizeof(hpcfb_dspconf);\n+unsigned struct_hpcfb_fbconf_sz = sizeof(hpcfb_fbconf);\n+unsigned struct_if_addrprefreq_sz = sizeof(if_addrprefreq);\n+unsigned struct_if_clonereq_sz = sizeof(if_clonereq);\n+unsigned struct_if_laddrreq_sz = sizeof(if_laddrreq);\n+unsigned struct_ifaddr_sz = sizeof(ifaddr);\n+unsigned struct_ifaliasreq_sz = sizeof(ifaliasreq);\n+unsigned struct_ifcapreq_sz = sizeof(ifcapreq);\n+unsigned struct_ifconf_sz = sizeof(ifconf);\n+unsigned struct_ifdatareq_sz = sizeof(ifdatareq);\n+unsigned struct_ifdrv_sz = sizeof(ifdrv);\n+unsigned struct_ifmediareq_sz = sizeof(ifmediareq);\n+unsigned struct_ifpppcstatsreq_sz = sizeof(ifpppcstatsreq);\n+unsigned struct_ifpppstatsreq_sz = sizeof(ifpppstatsreq);\n+unsigned struct_ifreq_sz = sizeof(ifreq);\n+unsigned struct_in6_addrpolicy_sz = sizeof(in6_addrpolicy);\n+unsigned struct_in6_ndireq_sz = sizeof(in6_ndireq);\n+unsigned struct_ioc_load_unload_sz = sizeof(ioc_load_unload);\n+unsigned struct_ioc_patch_sz = sizeof(ioc_patch);\n+unsigned struct_ioc_play_blocks_sz = sizeof(ioc_play_blocks);\n+unsigned struct_ioc_play_msf_sz = sizeof(ioc_play_msf);\n+unsigned struct_ioc_play_track_sz = sizeof(ioc_play_track);\n+unsigned struct_ioc_read_subchannel_sz = sizeof(ioc_read_subchannel);\n+unsigned struct_ioc_read_toc_entry_sz = sizeof(ioc_read_toc_entry);\n+unsigned struct_ioc_toc_header_sz = sizeof(ioc_toc_header);\n+unsigned struct_ioc_vol_sz = sizeof(ioc_vol);\n+unsigned struct_ioctl_pt_sz = sizeof(ioctl_pt);\n+unsigned struct_ioppt_sz = sizeof(ioppt);\n+unsigned struct_iovec_sz = sizeof(iovec);\n+unsigned struct_ipfobj_sz = sizeof(ipfobj);\n+unsigned struct_irda_params_sz = sizeof(irda_params);\n+unsigned struct_isp_fc_device_sz = sizeof(isp_fc_device);\n+unsigned struct_isp_fc_tsk_mgmt_sz = sizeof(isp_fc_tsk_mgmt);\n+unsigned struct_isp_hba_device_sz = sizeof(isp_hba_device);\n+unsigned struct_isv_cmd_sz = sizeof(isv_cmd);\n+unsigned struct_jobs_add_class_sz = sizeof(jobs_add_class);\n+unsigned struct_jobs_add_filter_sz = sizeof(jobs_add_filter);\n+unsigned struct_jobs_attach_sz = sizeof(jobs_attach);\n+unsigned struct_jobs_class_stats_sz = sizeof(jobs_class_stats);\n+unsigned struct_jobs_delete_class_sz = sizeof(jobs_delete_class);\n+unsigned struct_jobs_delete_filter_sz = sizeof(jobs_delete_filter);\n+unsigned struct_jobs_interface_sz = sizeof(jobs_interface);\n+unsigned struct_jobs_modify_class_sz = sizeof(jobs_modify_class);\n+unsigned struct_kbentry_sz = sizeof(kbentry);\n+unsigned struct_kfilter_mapping_sz = sizeof(kfilter_mapping);\n+unsigned struct_kiockeymap_sz = sizeof(kiockeymap);\n+unsigned struct_ksyms_gsymbol_sz = sizeof(ksyms_gsymbol);\n+unsigned struct_ksyms_gvalue_sz = sizeof(ksyms_gvalue);\n+unsigned struct_ksyms_ogsymbol_sz = sizeof(ksyms_ogsymbol);\n+unsigned struct_kttcp_io_args_sz = sizeof(kttcp_io_args);\n+unsigned struct_ltchars_sz = sizeof(ltchars);\n+unsigned struct_lua_create_sz = sizeof(struct lua_create);\n+unsigned struct_lua_info_sz = sizeof(struct lua_info);\n+unsigned struct_lua_load_sz = sizeof(struct lua_load);\n+unsigned struct_lua_require_sz = sizeof(lua_require);\n+unsigned struct_mbpp_param_sz = sizeof(mbpp_param);\n+unsigned struct_md_conf_sz = sizeof(md_conf);\n+unsigned struct_meteor_capframe_sz = sizeof(meteor_capframe);\n+unsigned struct_meteor_counts_sz = sizeof(meteor_counts);\n+unsigned struct_meteor_geomet_sz = sizeof(meteor_geomet);\n+unsigned struct_meteor_pixfmt_sz = sizeof(meteor_pixfmt);\n+unsigned struct_meteor_video_sz = sizeof(meteor_video);\n+unsigned struct_mlx_cinfo_sz = sizeof(mlx_cinfo);\n+unsigned struct_mlx_pause_sz = sizeof(mlx_pause);\n+unsigned struct_mlx_rebuild_request_sz = sizeof(mlx_rebuild_request);\n+unsigned struct_mlx_rebuild_status_sz = sizeof(mlx_rebuild_status);\n+unsigned struct_mlx_usercommand_sz = sizeof(mlx_usercommand);\n+unsigned struct_mly_user_command_sz = sizeof(mly_user_command);\n+unsigned struct_mly_user_health_sz = sizeof(mly_user_health);\n+unsigned struct_mtget_sz = sizeof(mtget);\n+unsigned struct_mtop_sz = sizeof(mtop);\n+unsigned struct_npf_ioctl_table_sz = sizeof(npf_ioctl_table);\n+unsigned struct_npioctl_sz = sizeof(npioctl);\n+unsigned struct_nvme_pt_command_sz = sizeof(nvme_pt_command);\n+unsigned struct_ochanger_element_status_request_sz =\n+    sizeof(ochanger_element_status_request);\n+unsigned struct_ofiocdesc_sz = sizeof(ofiocdesc);\n+unsigned struct_okiockey_sz = sizeof(okiockey);\n+unsigned struct_ortentry_sz = sizeof(ortentry);\n+unsigned struct_oscsi_addr_sz = sizeof(oscsi_addr);\n+unsigned struct_oss_audioinfo_sz = sizeof(oss_audioinfo);\n+unsigned struct_oss_sysinfo_sz = sizeof(oss_sysinfo);\n+unsigned struct_pciio_bdf_cfgreg_sz = sizeof(pciio_bdf_cfgreg);\n+unsigned struct_pciio_businfo_sz = sizeof(pciio_businfo);\n+unsigned struct_pciio_cfgreg_sz = sizeof(pciio_cfgreg);\n+unsigned struct_pciio_drvname_sz = sizeof(pciio_drvname);\n+unsigned struct_pciio_drvnameonbus_sz = sizeof(pciio_drvnameonbus);\n+unsigned struct_pcvtid_sz = sizeof(pcvtid);\n+unsigned struct_pf_osfp_ioctl_sz = sizeof(pf_osfp_ioctl);\n+unsigned struct_pf_status_sz = sizeof(pf_status);\n+unsigned struct_pfioc_altq_sz = sizeof(pfioc_altq);\n+unsigned struct_pfioc_if_sz = sizeof(pfioc_if);\n+unsigned struct_pfioc_iface_sz = sizeof(pfioc_iface);\n+unsigned struct_pfioc_limit_sz = sizeof(pfioc_limit);\n+unsigned struct_pfioc_natlook_sz = sizeof(pfioc_natlook);\n+unsigned struct_pfioc_pooladdr_sz = sizeof(pfioc_pooladdr);\n+unsigned struct_pfioc_qstats_sz = sizeof(pfioc_qstats);\n+unsigned struct_pfioc_rule_sz = sizeof(pfioc_rule);\n+unsigned struct_pfioc_ruleset_sz = sizeof(pfioc_ruleset);\n+unsigned struct_pfioc_src_node_kill_sz = sizeof(pfioc_src_node_kill);\n+unsigned struct_pfioc_src_nodes_sz = sizeof(pfioc_src_nodes);\n+unsigned struct_pfioc_state_kill_sz = sizeof(pfioc_state_kill);\n+unsigned struct_pfioc_state_sz = sizeof(pfioc_state);\n+unsigned struct_pfioc_states_sz = sizeof(pfioc_states);\n+unsigned struct_pfioc_table_sz = sizeof(pfioc_table);\n+unsigned struct_pfioc_tm_sz = sizeof(pfioc_tm);\n+unsigned struct_pfioc_trans_sz = sizeof(pfioc_trans);\n+unsigned struct_plistref_sz = sizeof(plistref);\n+unsigned struct_power_type_sz = sizeof(power_type);\n+unsigned struct_ppp_idle_sz = sizeof(ppp_idle);\n+unsigned struct_ppp_option_data_sz = sizeof(ppp_option_data);\n+unsigned struct_ppp_rawin_sz = sizeof(ppp_rawin);\n+unsigned struct_pppoeconnectionstate_sz = sizeof(pppoeconnectionstate);\n+unsigned struct_pppoediscparms_sz = sizeof(pppoediscparms);\n+unsigned struct_priq_add_class_sz = sizeof(priq_add_class);\n+unsigned struct_priq_add_filter_sz = sizeof(priq_add_filter);\n+unsigned struct_priq_class_stats_sz = sizeof(priq_class_stats);\n+unsigned struct_priq_delete_class_sz = sizeof(priq_delete_class);\n+unsigned struct_priq_delete_filter_sz = sizeof(priq_delete_filter);\n+unsigned struct_priq_interface_sz = sizeof(priq_interface);\n+unsigned struct_priq_modify_class_sz = sizeof(priq_modify_class);\n+unsigned struct_ptmget_sz = sizeof(ptmget);\n+unsigned struct_pvctxreq_sz = sizeof(pvctxreq);\n+unsigned struct_radio_info_sz = sizeof(radio_info);\n+unsigned struct_red_conf_sz = sizeof(red_conf);\n+unsigned struct_red_interface_sz = sizeof(red_interface);\n+unsigned struct_red_stats_sz = sizeof(red_stats);\n+unsigned struct_redparams_sz = sizeof(redparams);\n+unsigned struct_rf_pmparams_sz = sizeof(rf_pmparams);\n+unsigned struct_rf_pmstat_sz = sizeof(rf_pmstat);\n+unsigned struct_rf_recon_req_sz = sizeof(rf_recon_req);\n+unsigned struct_rio_conf_sz = sizeof(rio_conf);\n+unsigned struct_rio_interface_sz = sizeof(rio_interface);\n+unsigned struct_rio_stats_sz = sizeof(rio_stats);\n+unsigned struct_satlink_id_sz = sizeof(satlink_id);\n+unsigned struct_scan_io_sz = sizeof(scan_io);\n+unsigned struct_scbusaccel_args_sz = sizeof(scbusaccel_args);\n+unsigned struct_scbusiodetach_args_sz = sizeof(scbusiodetach_args);\n+unsigned struct_scbusioscan_args_sz = sizeof(scbusioscan_args);\n+unsigned struct_scsi_addr_sz = sizeof(scsi_addr);\n+unsigned struct_seq_event_rec_sz = sizeof(seq_event_rec);\n+unsigned struct_session_op_sz = sizeof(session_op);\n+unsigned struct_sgttyb_sz = sizeof(sgttyb);\n+unsigned struct_sioc_sg_req_sz = sizeof(sioc_sg_req);\n+unsigned struct_sioc_vif_req_sz = sizeof(sioc_vif_req);\n+unsigned struct_smbioc_flags_sz = sizeof(smbioc_flags);\n+unsigned struct_smbioc_lookup_sz = sizeof(smbioc_lookup);\n+unsigned struct_smbioc_oshare_sz = sizeof(smbioc_oshare);\n+unsigned struct_smbioc_ossn_sz = sizeof(smbioc_ossn);\n+unsigned struct_smbioc_rq_sz = sizeof(smbioc_rq);\n+unsigned struct_smbioc_rw_sz = sizeof(smbioc_rw);\n+unsigned struct_spppauthcfg_sz = sizeof(spppauthcfg);\n+unsigned struct_spppauthfailuresettings_sz = sizeof(spppauthfailuresettings);\n+unsigned struct_spppauthfailurestats_sz = sizeof(spppauthfailurestats);\n+unsigned struct_spppdnsaddrs_sz = sizeof(spppdnsaddrs);\n+unsigned struct_spppdnssettings_sz = sizeof(spppdnssettings);\n+unsigned struct_spppidletimeout_sz = sizeof(spppidletimeout);\n+unsigned struct_spppkeepalivesettings_sz = sizeof(spppkeepalivesettings);\n+unsigned struct_sppplcpcfg_sz = sizeof(sppplcpcfg);\n+unsigned struct_spppstatus_sz = sizeof(spppstatus);\n+unsigned struct_spppstatusncp_sz = sizeof(spppstatusncp);\n+unsigned struct_srt_rt_sz = sizeof(srt_rt);\n+unsigned struct_stic_xinfo_sz = sizeof(stic_xinfo);\n+unsigned struct_sun_dkctlr_sz = sizeof(sun_dkctlr);\n+unsigned struct_sun_dkgeom_sz = sizeof(sun_dkgeom);\n+unsigned struct_sun_dkpart_sz = sizeof(sun_dkpart);\n+unsigned struct_synth_info_sz = sizeof(synth_info);\n+unsigned struct_tbrreq_sz = sizeof(tbrreq);\n+unsigned struct_tchars_sz = sizeof(tchars);\n+unsigned struct_termios_sz = sizeof(termios);\n+unsigned struct_timeval_sz = sizeof(timeval);\n+unsigned struct_twe_drivecommand_sz = sizeof(twe_drivecommand);\n+unsigned struct_twe_paramcommand_sz = sizeof(twe_paramcommand);\n+unsigned struct_twe_usercommand_sz = sizeof(twe_usercommand);\n+unsigned struct_ukyopon_identify_sz = sizeof(ukyopon_identify);\n+unsigned struct_urio_command_sz = sizeof(urio_command);\n+unsigned struct_usb_alt_interface_sz = sizeof(usb_alt_interface);\n+unsigned struct_usb_bulk_ra_wb_opt_sz = sizeof(usb_bulk_ra_wb_opt);\n+unsigned struct_usb_config_desc_sz = sizeof(usb_config_desc);\n+unsigned struct_usb_ctl_report_desc_sz = sizeof(usb_ctl_report_desc);\n+unsigned struct_usb_ctl_report_sz = sizeof(usb_ctl_report);\n+unsigned struct_usb_ctl_request_sz = sizeof(usb_ctl_request);\n+unsigned struct_usb_device_info_old_sz = sizeof(usb_device_info_old);\n+unsigned struct_usb_device_info_sz = sizeof(usb_device_info);\n+unsigned struct_usb_device_stats_sz = sizeof(usb_device_stats);\n+unsigned struct_usb_endpoint_desc_sz = sizeof(usb_endpoint_desc);\n+unsigned struct_usb_full_desc_sz = sizeof(usb_full_desc);\n+unsigned struct_usb_interface_desc_sz = sizeof(usb_interface_desc);\n+unsigned struct_usb_string_desc_sz = sizeof(usb_string_desc);\n+unsigned struct_utoppy_readfile_sz = sizeof(utoppy_readfile);\n+unsigned struct_utoppy_rename_sz = sizeof(utoppy_rename);\n+unsigned struct_utoppy_stats_sz = sizeof(utoppy_stats);\n+unsigned struct_utoppy_writefile_sz = sizeof(utoppy_writefile);\n+unsigned struct_v4l2_audio_sz = sizeof(v4l2_audio);\n+unsigned struct_v4l2_audioout_sz = sizeof(v4l2_audioout);\n+unsigned struct_v4l2_buffer_sz = sizeof(v4l2_buffer);\n+unsigned struct_v4l2_capability_sz = sizeof(v4l2_capability);\n+unsigned struct_v4l2_control_sz = sizeof(v4l2_control);\n+unsigned struct_v4l2_crop_sz = sizeof(v4l2_crop);\n+unsigned struct_v4l2_cropcap_sz = sizeof(v4l2_cropcap);\n+unsigned struct_v4l2_fmtdesc_sz = sizeof(v4l2_fmtdesc);\n+unsigned struct_v4l2_format_sz = sizeof(v4l2_format);\n+unsigned struct_v4l2_framebuffer_sz = sizeof(v4l2_framebuffer);\n+unsigned struct_v4l2_frequency_sz = sizeof(v4l2_frequency);\n+unsigned struct_v4l2_frmivalenum_sz = sizeof(v4l2_frmivalenum);\n+unsigned struct_v4l2_frmsizeenum_sz = sizeof(v4l2_frmsizeenum);\n+unsigned struct_v4l2_input_sz = sizeof(v4l2_input);\n+unsigned struct_v4l2_jpegcompression_sz = sizeof(v4l2_jpegcompression);\n+unsigned struct_v4l2_modulator_sz = sizeof(v4l2_modulator);\n+unsigned struct_v4l2_output_sz = sizeof(v4l2_output);\n+unsigned struct_v4l2_queryctrl_sz = sizeof(v4l2_queryctrl);\n+unsigned struct_v4l2_querymenu_sz = sizeof(v4l2_querymenu);\n+unsigned struct_v4l2_requestbuffers_sz = sizeof(v4l2_requestbuffers);\n+unsigned struct_v4l2_standard_sz = sizeof(v4l2_standard);\n+unsigned struct_v4l2_streamparm_sz = sizeof(v4l2_streamparm);\n+unsigned struct_v4l2_tuner_sz = sizeof(v4l2_tuner);\n+unsigned struct_vnd_ioctl_sz = sizeof(vnd_ioctl);\n+unsigned struct_vnd_user_sz = sizeof(vnd_user);\n+unsigned struct_vt_stat_sz = sizeof(vt_stat);\n+unsigned struct_wdog_conf_sz = sizeof(wdog_conf);\n+unsigned struct_wdog_mode_sz = sizeof(wdog_mode);\n+unsigned struct_wfq_conf_sz = sizeof(wfq_conf);\n+unsigned struct_wfq_getqid_sz = sizeof(wfq_getqid);\n+unsigned struct_wfq_getstats_sz = sizeof(wfq_getstats);\n+unsigned struct_wfq_interface_sz = sizeof(wfq_interface);\n+unsigned struct_wfq_setweight_sz = sizeof(wfq_setweight);\n+unsigned struct_winsize_sz = sizeof(winsize);\n+unsigned struct_wscons_event_sz = sizeof(wscons_event);\n+unsigned struct_wsdisplay_addscreendata_sz = sizeof(wsdisplay_addscreendata);\n+unsigned struct_wsdisplay_char_sz = sizeof(wsdisplay_char);\n+unsigned struct_wsdisplay_cmap_sz = sizeof(wsdisplay_cmap);\n+unsigned struct_wsdisplay_curpos_sz = sizeof(wsdisplay_curpos);\n+unsigned struct_wsdisplay_cursor_sz = sizeof(wsdisplay_cursor);\n+unsigned struct_wsdisplay_delscreendata_sz = sizeof(wsdisplay_delscreendata);\n+unsigned struct_wsdisplay_fbinfo_sz = sizeof(wsdisplay_fbinfo);\n+unsigned struct_wsdisplay_font_sz = sizeof(wsdisplay_font);\n+unsigned struct_wsdisplay_kbddata_sz = sizeof(wsdisplay_kbddata);\n+unsigned struct_wsdisplay_msgattrs_sz = sizeof(wsdisplay_msgattrs);\n+unsigned struct_wsdisplay_param_sz = sizeof(wsdisplay_param);\n+unsigned struct_wsdisplay_scroll_data_sz = sizeof(wsdisplay_scroll_data);\n+unsigned struct_wsdisplay_usefontdata_sz = sizeof(wsdisplay_usefontdata);\n+unsigned struct_wsdisplayio_blit_sz = sizeof(wsdisplayio_blit);\n+unsigned struct_wsdisplayio_bus_id_sz = sizeof(wsdisplayio_bus_id);\n+unsigned struct_wsdisplayio_edid_info_sz = sizeof(wsdisplayio_edid_info);\n+unsigned struct_wsdisplayio_fbinfo_sz = sizeof(wsdisplayio_fbinfo);\n+unsigned struct_wskbd_bell_data_sz = sizeof(wskbd_bell_data);\n+unsigned struct_wskbd_keyrepeat_data_sz = sizeof(wskbd_keyrepeat_data);\n+unsigned struct_wskbd_map_data_sz = sizeof(wskbd_map_data);\n+unsigned struct_wskbd_scroll_data_sz = sizeof(wskbd_scroll_data);\n+unsigned struct_wsmouse_calibcoords_sz = sizeof(wsmouse_calibcoords);\n+unsigned struct_wsmouse_id_sz = sizeof(wsmouse_id);\n+unsigned struct_wsmouse_repeat_sz = sizeof(wsmouse_repeat);\n+unsigned struct_wsmux_device_list_sz = sizeof(wsmux_device_list);\n+unsigned struct_wsmux_device_sz = sizeof(wsmux_device);\n+unsigned struct_xd_iocmd_sz = sizeof(xd_iocmd);\n+\n+unsigned struct_scsireq_sz = sizeof(struct scsireq);\n+unsigned struct_tone_sz = sizeof(tone_t);\n+unsigned union_twe_statrequest_sz = sizeof(union twe_statrequest);\n+unsigned struct_usb_device_descriptor_sz = sizeof(usb_device_descriptor_t);\n+unsigned struct_vt_mode_sz = sizeof(struct vt_mode);\n+unsigned struct__old_mixer_info_sz = sizeof(struct _old_mixer_info);\n+unsigned struct__agp_allocate_sz = sizeof(struct _agp_allocate);\n+unsigned struct__agp_bind_sz = sizeof(struct _agp_bind);\n+unsigned struct__agp_info_sz = sizeof(struct _agp_info);\n+unsigned struct__agp_setup_sz = sizeof(struct _agp_setup);\n+unsigned struct__agp_unbind_sz = sizeof(struct _agp_unbind);\n+unsigned struct_atareq_sz = sizeof(struct atareq);\n+unsigned struct_cpustate_sz = sizeof(struct cpustate);\n+unsigned struct_dmx_caps_sz = sizeof(struct dmx_caps);\n+unsigned enum_dmx_source_sz = sizeof(dmx_source_t);\n+unsigned union_dvd_authinfo_sz = sizeof(dvd_authinfo);\n+unsigned union_dvd_struct_sz = sizeof(dvd_struct);\n+unsigned enum_v4l2_priority_sz = sizeof(enum v4l2_priority);\n+unsigned struct_envsys_basic_info_sz = sizeof(struct envsys_basic_info);\n+unsigned struct_envsys_tre_data_sz = sizeof(struct envsys_tre_data);\n+unsigned enum_fe_sec_mini_cmd_sz = sizeof(enum fe_sec_mini_cmd);\n+unsigned enum_fe_sec_tone_mode_sz = sizeof(enum fe_sec_tone_mode);\n+unsigned enum_fe_sec_voltage_sz = sizeof(enum fe_sec_voltage);\n+unsigned enum_fe_status_sz = sizeof(enum fe_status);\n+unsigned struct_gdt_ctrt_sz = sizeof(struct gdt_ctrt);\n+unsigned struct_gdt_event_sz = sizeof(struct gdt_event);\n+unsigned struct_gdt_osv_sz = sizeof(struct gdt_osv);\n+unsigned struct_gdt_rescan_sz = sizeof(struct gdt_rescan);\n+unsigned struct_gdt_statist_sz = sizeof(struct gdt_statist);\n+unsigned struct_gdt_ucmd_sz = sizeof(struct gdt_ucmd);\n+unsigned struct_iscsi_conn_status_parameters_sz =\n+    sizeof(iscsi_conn_status_parameters_t);\n+unsigned struct_iscsi_get_version_parameters_sz =\n+    sizeof(iscsi_get_version_parameters_t);\n+unsigned struct_iscsi_iocommand_parameters_sz =\n+    sizeof(iscsi_iocommand_parameters_t);\n+unsigned struct_iscsi_login_parameters_sz = sizeof(iscsi_login_parameters_t);\n+unsigned struct_iscsi_logout_parameters_sz = sizeof(iscsi_logout_parameters_t);\n+unsigned struct_iscsi_register_event_parameters_sz =\n+    sizeof(iscsi_register_event_parameters_t);\n+unsigned struct_iscsi_remove_parameters_sz = sizeof(iscsi_remove_parameters_t);\n+unsigned struct_iscsi_send_targets_parameters_sz =\n+    sizeof(iscsi_send_targets_parameters_t);\n+unsigned struct_iscsi_set_node_name_parameters_sz =\n+    sizeof(iscsi_set_node_name_parameters_t);\n+unsigned struct_iscsi_wait_event_parameters_sz =\n+    sizeof(iscsi_wait_event_parameters_t);\n+unsigned struct_isp_stats_sz = sizeof(isp_stats_t);\n+unsigned struct_lsenable_sz = sizeof(struct lsenable);\n+unsigned struct_lsdisable_sz = sizeof(struct lsdisable);\n+unsigned struct_mixer_ctrl_sz = sizeof(struct mixer_ctrl);\n+unsigned struct_mixer_devinfo_sz = sizeof(struct mixer_devinfo);\n+unsigned struct_mpu_command_rec_sz = sizeof(mpu_command_rec);\n+unsigned struct_rndstat_sz = sizeof(rndstat_t);\n+unsigned struct_rndstat_name_sz = sizeof(rndstat_name_t);\n+unsigned struct_rndctl_sz = sizeof(rndctl_t);\n+unsigned struct_rnddata_sz = sizeof(rnddata_t);\n+unsigned struct_rndpoolstat_sz = sizeof(rndpoolstat_t);\n+unsigned struct_rndstat_est_sz = sizeof(rndstat_est_t);\n+unsigned struct_rndstat_est_name_sz = sizeof(rndstat_est_name_t);\n+unsigned struct_pps_params_sz = sizeof(pps_params_t);\n+unsigned struct_pps_info_sz = sizeof(pps_info_t);\n+unsigned struct_mixer_info_sz = sizeof(struct mixer_info);\n+unsigned struct_RF_SparetWait_sz = sizeof(RF_SparetWait_t);\n+unsigned struct_RF_ComponentLabel_sz = sizeof(RF_ComponentLabel_t);\n+unsigned struct_RF_SingleComponent_sz = sizeof(RF_SingleComponent_t);\n+unsigned struct_RF_ProgressInfo_sz = sizeof(RF_ProgressInfo_t);\n \n const unsigned IOCTL_NOT_PRESENT = 0;\n \n-unsigned IOCTL_FIOASYNC = FIOASYNC;\n+unsigned IOCTL_AFM_ADDFMAP = AFM_ADDFMAP;\n+unsigned IOCTL_AFM_DELFMAP = AFM_DELFMAP;\n+unsigned IOCTL_AFM_CLEANFMAP = AFM_CLEANFMAP;\n+unsigned IOCTL_AFM_GETFMAP = AFM_GETFMAP;\n+unsigned IOCTL_ALTQGTYPE = ALTQGTYPE;\n+unsigned IOCTL_ALTQTBRSET = ALTQTBRSET;\n+unsigned IOCTL_ALTQTBRGET = ALTQTBRGET;\n+unsigned IOCTL_BLUE_IF_ATTACH = BLUE_IF_ATTACH;\n+unsigned IOCTL_BLUE_IF_DETACH = BLUE_IF_DETACH;\n+unsigned IOCTL_BLUE_ENABLE = BLUE_ENABLE;\n+unsigned IOCTL_BLUE_DISABLE = BLUE_DISABLE;\n+unsigned IOCTL_BLUE_CONFIG = BLUE_CONFIG;\n+unsigned IOCTL_BLUE_GETSTATS = BLUE_GETSTATS;\n+unsigned IOCTL_CBQ_IF_ATTACH = CBQ_IF_ATTACH;\n+unsigned IOCTL_CBQ_IF_DETACH = CBQ_IF_DETACH;\n+unsigned IOCTL_CBQ_ENABLE = CBQ_ENABLE;\n+unsigned IOCTL_CBQ_DISABLE = CBQ_DISABLE;\n+unsigned IOCTL_CBQ_CLEAR_HIERARCHY = CBQ_CLEAR_HIERARCHY;\n+unsigned IOCTL_CBQ_ADD_CLASS = CBQ_ADD_CLASS;\n+unsigned IOCTL_CBQ_DEL_CLASS = CBQ_DEL_CLASS;\n+unsigned IOCTL_CBQ_MODIFY_CLASS = CBQ_MODIFY_CLASS;\n+unsigned IOCTL_CBQ_ADD_FILTER = CBQ_ADD_FILTER;\n+unsigned IOCTL_CBQ_DEL_FILTER = CBQ_DEL_FILTER;\n+unsigned IOCTL_CBQ_GETSTATS = CBQ_GETSTATS;\n+unsigned IOCTL_CDNR_IF_ATTACH = CDNR_IF_ATTACH;\n+unsigned IOCTL_CDNR_IF_DETACH = CDNR_IF_DETACH;\n+unsigned IOCTL_CDNR_ENABLE = CDNR_ENABLE;\n+unsigned IOCTL_CDNR_DISABLE = CDNR_DISABLE;\n+unsigned IOCTL_CDNR_ADD_FILTER = CDNR_ADD_FILTER;\n+unsigned IOCTL_CDNR_DEL_FILTER = CDNR_DEL_FILTER;\n+unsigned IOCTL_CDNR_GETSTATS = CDNR_GETSTATS;\n+unsigned IOCTL_CDNR_ADD_ELEM = CDNR_ADD_ELEM;\n+unsigned IOCTL_CDNR_DEL_ELEM = CDNR_DEL_ELEM;\n+unsigned IOCTL_CDNR_ADD_TBM = CDNR_ADD_TBM;\n+unsigned IOCTL_CDNR_MOD_TBM = CDNR_MOD_TBM;\n+unsigned IOCTL_CDNR_TBM_STATS = CDNR_TBM_STATS;\n+unsigned IOCTL_CDNR_ADD_TCM = CDNR_ADD_TCM;\n+unsigned IOCTL_CDNR_MOD_TCM = CDNR_MOD_TCM;\n+unsigned IOCTL_CDNR_TCM_STATS = CDNR_TCM_STATS;\n+unsigned IOCTL_CDNR_ADD_TSW = CDNR_ADD_TSW;\n+unsigned IOCTL_CDNR_MOD_TSW = CDNR_MOD_TSW;\n+unsigned IOCTL_FIFOQ_IF_ATTACH = FIFOQ_IF_ATTACH;\n+unsigned IOCTL_FIFOQ_IF_DETACH = FIFOQ_IF_DETACH;\n+unsigned IOCTL_FIFOQ_ENABLE = FIFOQ_ENABLE;\n+unsigned IOCTL_FIFOQ_DISABLE = FIFOQ_DISABLE;\n+unsigned IOCTL_FIFOQ_CONFIG = FIFOQ_CONFIG;\n+unsigned IOCTL_FIFOQ_GETSTATS = FIFOQ_GETSTATS;\n+unsigned IOCTL_HFSC_IF_ATTACH = HFSC_IF_ATTACH;\n+unsigned IOCTL_HFSC_IF_DETACH = HFSC_IF_DETACH;\n+unsigned IOCTL_HFSC_ENABLE = HFSC_ENABLE;\n+unsigned IOCTL_HFSC_DISABLE = HFSC_DISABLE;\n+unsigned IOCTL_HFSC_CLEAR_HIERARCHY = HFSC_CLEAR_HIERARCHY;\n+unsigned IOCTL_HFSC_ADD_CLASS = HFSC_ADD_CLASS;\n+unsigned IOCTL_HFSC_DEL_CLASS = HFSC_DEL_CLASS;\n+unsigned IOCTL_HFSC_MOD_CLASS = HFSC_MOD_CLASS;\n+unsigned IOCTL_HFSC_ADD_FILTER = HFSC_ADD_FILTER;\n+unsigned IOCTL_HFSC_DEL_FILTER = HFSC_DEL_FILTER;\n+unsigned IOCTL_HFSC_GETSTATS = HFSC_GETSTATS;\n+unsigned IOCTL_JOBS_IF_ATTACH = JOBS_IF_ATTACH;\n+unsigned IOCTL_JOBS_IF_DETACH = JOBS_IF_DETACH;\n+unsigned IOCTL_JOBS_ENABLE = JOBS_ENABLE;\n+unsigned IOCTL_JOBS_DISABLE = JOBS_DISABLE;\n+unsigned IOCTL_JOBS_CLEAR = JOBS_CLEAR;\n+unsigned IOCTL_JOBS_ADD_CLASS = JOBS_ADD_CLASS;\n+unsigned IOCTL_JOBS_DEL_CLASS = JOBS_DEL_CLASS;\n+unsigned IOCTL_JOBS_MOD_CLASS = JOBS_MOD_CLASS;\n+unsigned IOCTL_JOBS_ADD_FILTER = JOBS_ADD_FILTER;\n+unsigned IOCTL_JOBS_DEL_FILTER = JOBS_DEL_FILTER;\n+unsigned IOCTL_JOBS_GETSTATS = JOBS_GETSTATS;\n+unsigned IOCTL_PRIQ_IF_ATTACH = PRIQ_IF_ATTACH;\n+unsigned IOCTL_PRIQ_IF_DETACH = PRIQ_IF_DETACH;\n+unsigned IOCTL_PRIQ_ENABLE = PRIQ_ENABLE;\n+unsigned IOCTL_PRIQ_DISABLE = PRIQ_DISABLE;\n+unsigned IOCTL_PRIQ_CLEAR = PRIQ_CLEAR;\n+unsigned IOCTL_PRIQ_ADD_CLASS = PRIQ_ADD_CLASS;\n+unsigned IOCTL_PRIQ_DEL_CLASS = PRIQ_DEL_CLASS;\n+unsigned IOCTL_PRIQ_MOD_CLASS = PRIQ_MOD_CLASS;\n+unsigned IOCTL_PRIQ_ADD_FILTER = PRIQ_ADD_FILTER;\n+unsigned IOCTL_PRIQ_DEL_FILTER = PRIQ_DEL_FILTER;\n+unsigned IOCTL_PRIQ_GETSTATS = PRIQ_GETSTATS;\n+unsigned IOCTL_RED_IF_ATTACH = RED_IF_ATTACH;\n+unsigned IOCTL_RED_IF_DETACH = RED_IF_DETACH;\n+unsigned IOCTL_RED_ENABLE = RED_ENABLE;\n+unsigned IOCTL_RED_DISABLE = RED_DISABLE;\n+unsigned IOCTL_RED_CONFIG = RED_CONFIG;\n+unsigned IOCTL_RED_GETSTATS = RED_GETSTATS;\n+unsigned IOCTL_RED_SETDEFAULTS = RED_SETDEFAULTS;\n+unsigned IOCTL_RIO_IF_ATTACH = RIO_IF_ATTACH;\n+unsigned IOCTL_RIO_IF_DETACH = RIO_IF_DETACH;\n+unsigned IOCTL_RIO_ENABLE = RIO_ENABLE;\n+unsigned IOCTL_RIO_DISABLE = RIO_DISABLE;\n+unsigned IOCTL_RIO_CONFIG = RIO_CONFIG;\n+unsigned IOCTL_RIO_GETSTATS = RIO_GETSTATS;\n+unsigned IOCTL_RIO_SETDEFAULTS = RIO_SETDEFAULTS;\n+unsigned IOCTL_WFQ_IF_ATTACH = WFQ_IF_ATTACH;\n+unsigned IOCTL_WFQ_IF_DETACH = WFQ_IF_DETACH;\n+unsigned IOCTL_WFQ_ENABLE = WFQ_ENABLE;\n+unsigned IOCTL_WFQ_DISABLE = WFQ_DISABLE;\n+unsigned IOCTL_WFQ_CONFIG = WFQ_CONFIG;\n+unsigned IOCTL_WFQ_GET_STATS = WFQ_GET_STATS;\n+unsigned IOCTL_WFQ_GET_QID = WFQ_GET_QID;\n+unsigned IOCTL_WFQ_SET_WEIGHT = WFQ_SET_WEIGHT;\n+unsigned IOCTL_CRIOGET = CRIOGET;\n+unsigned IOCTL_CIOCFSESSION = CIOCFSESSION;\n+unsigned IOCTL_CIOCKEY = CIOCKEY;\n+unsigned IOCTL_CIOCNFKEYM = CIOCNFKEYM;\n+unsigned IOCTL_CIOCNFSESSION = CIOCNFSESSION;\n+unsigned IOCTL_CIOCNCRYPTRETM = CIOCNCRYPTRETM;\n+unsigned IOCTL_CIOCNCRYPTRET = CIOCNCRYPTRET;\n+unsigned IOCTL_CIOCGSESSION = CIOCGSESSION;\n+unsigned IOCTL_CIOCNGSESSION = CIOCNGSESSION;\n+unsigned IOCTL_CIOCCRYPT = CIOCCRYPT;\n+unsigned IOCTL_CIOCNCRYPTM = CIOCNCRYPTM;\n+unsigned IOCTL_CIOCASYMFEAT = CIOCASYMFEAT;\n+unsigned IOCTL_APM_IOC_REJECT = APM_IOC_REJECT;\n+unsigned IOCTL_APM_IOC_STANDBY = APM_IOC_STANDBY;\n+unsigned IOCTL_APM_IOC_SUSPEND = APM_IOC_SUSPEND;\n+unsigned IOCTL_OAPM_IOC_GETPOWER = OAPM_IOC_GETPOWER;\n+unsigned IOCTL_APM_IOC_GETPOWER = APM_IOC_GETPOWER;\n+unsigned IOCTL_APM_IOC_NEXTEVENT = APM_IOC_NEXTEVENT;\n+unsigned IOCTL_APM_IOC_DEV_CTL = APM_IOC_DEV_CTL;\n+unsigned IOCTL_NETBSD_DM_IOCTL = NETBSD_DM_IOCTL;\n+unsigned IOCTL_DMIO_SETFUNC = DMIO_SETFUNC;\n+unsigned IOCTL_DMX_START = DMX_START;\n+unsigned IOCTL_DMX_STOP = DMX_STOP;\n+unsigned IOCTL_DMX_SET_FILTER = DMX_SET_FILTER;\n+unsigned IOCTL_DMX_SET_PES_FILTER = DMX_SET_PES_FILTER;\n+unsigned IOCTL_DMX_SET_BUFFER_SIZE = DMX_SET_BUFFER_SIZE;\n+unsigned IOCTL_DMX_GET_STC = DMX_GET_STC;\n+unsigned IOCTL_DMX_ADD_PID = DMX_ADD_PID;\n+unsigned IOCTL_DMX_REMOVE_PID = DMX_REMOVE_PID;\n+unsigned IOCTL_DMX_GET_CAPS = DMX_GET_CAPS;\n+unsigned IOCTL_DMX_SET_SOURCE = DMX_SET_SOURCE;\n+unsigned IOCTL_FE_READ_STATUS = FE_READ_STATUS;\n+unsigned IOCTL_FE_READ_BER = FE_READ_BER;\n+unsigned IOCTL_FE_READ_SNR = FE_READ_SNR;\n+unsigned IOCTL_FE_READ_SIGNAL_STRENGTH = FE_READ_SIGNAL_STRENGTH;\n+unsigned IOCTL_FE_READ_UNCORRECTED_BLOCKS = FE_READ_UNCORRECTED_BLOCKS;\n+unsigned IOCTL_FE_SET_FRONTEND = FE_SET_FRONTEND;\n+unsigned IOCTL_FE_GET_FRONTEND = FE_GET_FRONTEND;\n+unsigned IOCTL_FE_GET_EVENT = FE_GET_EVENT;\n+unsigned IOCTL_FE_GET_INFO = FE_GET_INFO;\n+unsigned IOCTL_FE_DISEQC_RESET_OVERLOAD = FE_DISEQC_RESET_OVERLOAD;\n+unsigned IOCTL_FE_DISEQC_SEND_MASTER_CMD = FE_DISEQC_SEND_MASTER_CMD;\n+unsigned IOCTL_FE_DISEQC_RECV_SLAVE_REPLY = FE_DISEQC_RECV_SLAVE_REPLY;\n+unsigned IOCTL_FE_DISEQC_SEND_BURST = FE_DISEQC_SEND_BURST;\n+unsigned IOCTL_FE_SET_TONE = FE_SET_TONE;\n+unsigned IOCTL_FE_SET_VOLTAGE = FE_SET_VOLTAGE;\n+unsigned IOCTL_FE_ENABLE_HIGH_LNB_VOLTAGE = FE_ENABLE_HIGH_LNB_VOLTAGE;\n+unsigned IOCTL_FE_SET_FRONTEND_TUNE_MODE = FE_SET_FRONTEND_TUNE_MODE;\n+unsigned IOCTL_FE_DISHNETWORK_SEND_LEGACY_CMD = FE_DISHNETWORK_SEND_LEGACY_CMD;\n+unsigned IOCTL_FILEMON_SET_FD = FILEMON_SET_FD;\n+unsigned IOCTL_FILEMON_SET_PID = FILEMON_SET_PID;\n+unsigned IOCTL_HDAUDIO_FGRP_INFO = HDAUDIO_FGRP_INFO;\n+unsigned IOCTL_HDAUDIO_FGRP_GETCONFIG = HDAUDIO_FGRP_GETCONFIG;\n+unsigned IOCTL_HDAUDIO_FGRP_SETCONFIG = HDAUDIO_FGRP_SETCONFIG;\n+unsigned IOCTL_HDAUDIO_FGRP_WIDGET_INFO = HDAUDIO_FGRP_WIDGET_INFO;\n+unsigned IOCTL_HDAUDIO_FGRP_CODEC_INFO = HDAUDIO_FGRP_CODEC_INFO;\n+unsigned IOCTL_HDAUDIO_AFG_WIDGET_INFO = HDAUDIO_AFG_WIDGET_INFO;\n+unsigned IOCTL_HDAUDIO_AFG_CODEC_INFO = HDAUDIO_AFG_CODEC_INFO;\n+unsigned IOCTL_CEC_GET_PHYS_ADDR = CEC_GET_PHYS_ADDR;\n+unsigned IOCTL_CEC_GET_LOG_ADDRS = CEC_GET_LOG_ADDRS;\n+unsigned IOCTL_CEC_SET_LOG_ADDRS = CEC_SET_LOG_ADDRS;\n+unsigned IOCTL_CEC_GET_VENDOR_ID = CEC_GET_VENDOR_ID;\n+unsigned IOCTL_HPCFBIO_GCONF = HPCFBIO_GCONF;\n+unsigned IOCTL_HPCFBIO_SCONF = HPCFBIO_SCONF;\n+unsigned IOCTL_HPCFBIO_GDSPCONF = HPCFBIO_GDSPCONF;\n+unsigned IOCTL_HPCFBIO_SDSPCONF = HPCFBIO_SDSPCONF;\n+unsigned IOCTL_HPCFBIO_GOP = HPCFBIO_GOP;\n+unsigned IOCTL_HPCFBIO_SOP = HPCFBIO_SOP;\n+unsigned IOCTL_IOPIOCPT = IOPIOCPT;\n+unsigned IOCTL_IOPIOCGLCT = IOPIOCGLCT;\n+unsigned IOCTL_IOPIOCGSTATUS = IOPIOCGSTATUS;\n+unsigned IOCTL_IOPIOCRECONFIG = IOPIOCRECONFIG;\n+unsigned IOCTL_IOPIOCGTIDMAP = IOPIOCGTIDMAP;\n+unsigned IOCTL_SIOCGATHSTATS = SIOCGATHSTATS;\n+unsigned IOCTL_SIOCGATHDIAG = SIOCGATHDIAG;\n+unsigned IOCTL_METEORCAPTUR = METEORCAPTUR;\n+unsigned IOCTL_METEORCAPFRM = METEORCAPFRM;\n+unsigned IOCTL_METEORSETGEO = METEORSETGEO;\n+unsigned IOCTL_METEORGETGEO = METEORGETGEO;\n+unsigned IOCTL_METEORSTATUS = METEORSTATUS;\n+unsigned IOCTL_METEORSHUE = METEORSHUE;\n+unsigned IOCTL_METEORGHUE = METEORGHUE;\n+unsigned IOCTL_METEORSFMT = METEORSFMT;\n+unsigned IOCTL_METEORGFMT = METEORGFMT;\n+unsigned IOCTL_METEORSINPUT = METEORSINPUT;\n+unsigned IOCTL_METEORGINPUT = METEORGINPUT;\n+unsigned IOCTL_METEORSCHCV = METEORSCHCV;\n+unsigned IOCTL_METEORGCHCV = METEORGCHCV;\n+unsigned IOCTL_METEORSCOUNT = METEORSCOUNT;\n+unsigned IOCTL_METEORGCOUNT = METEORGCOUNT;\n+unsigned IOCTL_METEORSFPS = METEORSFPS;\n+unsigned IOCTL_METEORGFPS = METEORGFPS;\n+unsigned IOCTL_METEORSSIGNAL = METEORSSIGNAL;\n+unsigned IOCTL_METEORGSIGNAL = METEORGSIGNAL;\n+unsigned IOCTL_METEORSVIDEO = METEORSVIDEO;\n+unsigned IOCTL_METEORGVIDEO = METEORGVIDEO;\n+unsigned IOCTL_METEORSBRIG = METEORSBRIG;\n+unsigned IOCTL_METEORGBRIG = METEORGBRIG;\n+unsigned IOCTL_METEORSCSAT = METEORSCSAT;\n+unsigned IOCTL_METEORGCSAT = METEORGCSAT;\n+unsigned IOCTL_METEORSCONT = METEORSCONT;\n+unsigned IOCTL_METEORGCONT = METEORGCONT;\n+unsigned IOCTL_METEORSHWS = METEORSHWS;\n+unsigned IOCTL_METEORGHWS = METEORGHWS;\n+unsigned IOCTL_METEORSVWS = METEORSVWS;\n+unsigned IOCTL_METEORGVWS = METEORGVWS;\n+unsigned IOCTL_METEORSTS = METEORSTS;\n+unsigned IOCTL_METEORGTS = METEORGTS;\n+unsigned IOCTL_TVTUNER_SETCHNL = TVTUNER_SETCHNL;\n+unsigned IOCTL_TVTUNER_GETCHNL = TVTUNER_GETCHNL;\n+unsigned IOCTL_TVTUNER_SETTYPE = TVTUNER_SETTYPE;\n+unsigned IOCTL_TVTUNER_GETTYPE = TVTUNER_GETTYPE;\n+unsigned IOCTL_TVTUNER_GETSTATUS = TVTUNER_GETSTATUS;\n+unsigned IOCTL_TVTUNER_SETFREQ = TVTUNER_SETFREQ;\n+unsigned IOCTL_TVTUNER_GETFREQ = TVTUNER_GETFREQ;\n+unsigned IOCTL_TVTUNER_SETAFC = TVTUNER_SETAFC;\n+unsigned IOCTL_TVTUNER_GETAFC = TVTUNER_GETAFC;\n+unsigned IOCTL_RADIO_SETMODE = RADIO_SETMODE;\n+unsigned IOCTL_RADIO_GETMODE = RADIO_GETMODE;\n+unsigned IOCTL_RADIO_SETFREQ = RADIO_SETFREQ;\n+unsigned IOCTL_RADIO_GETFREQ = RADIO_GETFREQ;\n+unsigned IOCTL_METEORSACTPIXFMT = METEORSACTPIXFMT;\n+unsigned IOCTL_METEORGACTPIXFMT = METEORGACTPIXFMT;\n+unsigned IOCTL_METEORGSUPPIXFMT = METEORGSUPPIXFMT;\n+unsigned IOCTL_TVTUNER_GETCHNLSET = TVTUNER_GETCHNLSET;\n+unsigned IOCTL_REMOTE_GETKEY = REMOTE_GETKEY;\n+unsigned IOCTL_GDT_IOCTL_GENERAL = GDT_IOCTL_GENERAL;\n+unsigned IOCTL_GDT_IOCTL_DRVERS = GDT_IOCTL_DRVERS;\n+unsigned IOCTL_GDT_IOCTL_CTRTYPE = GDT_IOCTL_CTRTYPE;\n+unsigned IOCTL_GDT_IOCTL_OSVERS = GDT_IOCTL_OSVERS;\n+unsigned IOCTL_GDT_IOCTL_CTRCNT = GDT_IOCTL_CTRCNT;\n+unsigned IOCTL_GDT_IOCTL_EVENT = GDT_IOCTL_EVENT;\n+unsigned IOCTL_GDT_IOCTL_STATIST = GDT_IOCTL_STATIST;\n+unsigned IOCTL_GDT_IOCTL_RESCAN = GDT_IOCTL_RESCAN;\n+unsigned IOCTL_ISP_SDBLEV = ISP_SDBLEV;\n+unsigned IOCTL_ISP_RESETHBA = ISP_RESETHBA;\n+unsigned IOCTL_ISP_RESCAN = ISP_RESCAN;\n+unsigned IOCTL_ISP_SETROLE = ISP_SETROLE;\n+unsigned IOCTL_ISP_GETROLE = ISP_GETROLE;\n+unsigned IOCTL_ISP_GET_STATS = ISP_GET_STATS;\n+unsigned IOCTL_ISP_CLR_STATS = ISP_CLR_STATS;\n+unsigned IOCTL_ISP_FC_LIP = ISP_FC_LIP;\n+unsigned IOCTL_ISP_FC_GETDINFO = ISP_FC_GETDINFO;\n+unsigned IOCTL_ISP_GET_FW_CRASH_DUMP = ISP_GET_FW_CRASH_DUMP;\n+unsigned IOCTL_ISP_FORCE_CRASH_DUMP = ISP_FORCE_CRASH_DUMP;\n+unsigned IOCTL_ISP_FC_GETHINFO = ISP_FC_GETHINFO;\n+unsigned IOCTL_ISP_TSK_MGMT = ISP_TSK_MGMT;\n+unsigned IOCTL_ISP_FC_GETDLIST = ISP_FC_GETDLIST;\n+unsigned IOCTL_MLXD_STATUS = MLXD_STATUS;\n+unsigned IOCTL_MLXD_CHECKASYNC = MLXD_CHECKASYNC;\n+unsigned IOCTL_MLXD_DETACH = MLXD_DETACH;\n+unsigned IOCTL_MLX_RESCAN_DRIVES = MLX_RESCAN_DRIVES;\n+unsigned IOCTL_MLX_PAUSE_CHANNEL = MLX_PAUSE_CHANNEL;\n+unsigned IOCTL_MLX_COMMAND = MLX_COMMAND;\n+unsigned IOCTL_MLX_REBUILDASYNC = MLX_REBUILDASYNC;\n+unsigned IOCTL_MLX_REBUILDSTAT = MLX_REBUILDSTAT;\n+unsigned IOCTL_MLX_GET_SYSDRIVE = MLX_GET_SYSDRIVE;\n+unsigned IOCTL_MLX_GET_CINFO = MLX_GET_CINFO;\n+unsigned IOCTL_NVME_PASSTHROUGH_CMD = NVME_PASSTHROUGH_CMD;\n+unsigned IOCTL_IRDA_RESET_PARAMS = IRDA_RESET_PARAMS;\n+unsigned IOCTL_IRDA_SET_PARAMS = IRDA_SET_PARAMS;\n+unsigned IOCTL_IRDA_GET_SPEEDMASK = IRDA_GET_SPEEDMASK;\n+unsigned IOCTL_IRDA_GET_TURNAROUNDMASK = IRDA_GET_TURNAROUNDMASK;\n+unsigned IOCTL_IRFRAMETTY_GET_DEVICE = IRFRAMETTY_GET_DEVICE;\n+unsigned IOCTL_IRFRAMETTY_GET_DONGLE = IRFRAMETTY_GET_DONGLE;\n+unsigned IOCTL_IRFRAMETTY_SET_DONGLE = IRFRAMETTY_SET_DONGLE;\n+unsigned IOCTL_SATIORESET = SATIORESET;\n+unsigned IOCTL_SATIOGID = SATIOGID;\n+unsigned IOCTL_SATIOSBUFSIZE = SATIOSBUFSIZE;\n+unsigned IOCTL_ISV_CMD = ISV_CMD;\n+unsigned IOCTL_WTQICMD = WTQICMD;\n+unsigned IOCTL_ISCSI_GET_VERSION = ISCSI_GET_VERSION;\n+unsigned IOCTL_ISCSI_LOGIN = ISCSI_LOGIN;\n+unsigned IOCTL_ISCSI_LOGOUT = ISCSI_LOGOUT;\n+unsigned IOCTL_ISCSI_ADD_CONNECTION = ISCSI_ADD_CONNECTION;\n+unsigned IOCTL_ISCSI_RESTORE_CONNECTION = ISCSI_RESTORE_CONNECTION;\n+unsigned IOCTL_ISCSI_REMOVE_CONNECTION = ISCSI_REMOVE_CONNECTION;\n+unsigned IOCTL_ISCSI_CONNECTION_STATUS = ISCSI_CONNECTION_STATUS;\n+unsigned IOCTL_ISCSI_SEND_TARGETS = ISCSI_SEND_TARGETS;\n+unsigned IOCTL_ISCSI_SET_NODE_NAME = ISCSI_SET_NODE_NAME;\n+unsigned IOCTL_ISCSI_IO_COMMAND = ISCSI_IO_COMMAND;\n+unsigned IOCTL_ISCSI_REGISTER_EVENT = ISCSI_REGISTER_EVENT;\n+unsigned IOCTL_ISCSI_DEREGISTER_EVENT = ISCSI_DEREGISTER_EVENT;\n+unsigned IOCTL_ISCSI_WAIT_EVENT = ISCSI_WAIT_EVENT;\n+unsigned IOCTL_ISCSI_POLL_EVENT = ISCSI_POLL_EVENT;\n+unsigned IOCTL_OFIOCGET = OFIOCGET;\n+unsigned IOCTL_OFIOCSET = OFIOCSET;\n+unsigned IOCTL_OFIOCNEXTPROP = OFIOCNEXTPROP;\n+unsigned IOCTL_OFIOCGETOPTNODE = OFIOCGETOPTNODE;\n+unsigned IOCTL_OFIOCGETNEXT = OFIOCGETNEXT;\n+unsigned IOCTL_OFIOCGETCHILD = OFIOCGETCHILD;\n+unsigned IOCTL_OFIOCFINDDEVICE = OFIOCFINDDEVICE;\n+unsigned IOCTL_AMR_IO_VERSION = AMR_IO_VERSION;\n+unsigned IOCTL_AMR_IO_COMMAND = AMR_IO_COMMAND;\n+unsigned IOCTL_MLYIO_COMMAND = MLYIO_COMMAND;\n+unsigned IOCTL_MLYIO_HEALTH = MLYIO_HEALTH;\n+unsigned IOCTL_PCI_IOC_CFGREAD = PCI_IOC_CFGREAD;\n+unsigned IOCTL_PCI_IOC_CFGWRITE = PCI_IOC_CFGWRITE;\n+unsigned IOCTL_PCI_IOC_BDF_CFGREAD = PCI_IOC_BDF_CFGREAD;\n+unsigned IOCTL_PCI_IOC_BDF_CFGWRITE = PCI_IOC_BDF_CFGWRITE;\n+unsigned IOCTL_PCI_IOC_BUSINFO = PCI_IOC_BUSINFO;\n+unsigned IOCTL_PCI_IOC_DRVNAME = PCI_IOC_DRVNAME;\n+unsigned IOCTL_PCI_IOC_DRVNAMEONBUS = PCI_IOC_DRVNAMEONBUS;\n+unsigned IOCTL_TWEIO_COMMAND = TWEIO_COMMAND;\n+unsigned IOCTL_TWEIO_STATS = TWEIO_STATS;\n+unsigned IOCTL_TWEIO_AEN_POLL = TWEIO_AEN_POLL;\n+unsigned IOCTL_TWEIO_AEN_WAIT = TWEIO_AEN_WAIT;\n+unsigned IOCTL_TWEIO_SET_PARAM = TWEIO_SET_PARAM;\n+unsigned IOCTL_TWEIO_GET_PARAM = TWEIO_GET_PARAM;\n+unsigned IOCTL_TWEIO_RESET = TWEIO_RESET;\n+unsigned IOCTL_TWEIO_ADD_UNIT = TWEIO_ADD_UNIT;\n+unsigned IOCTL_TWEIO_DEL_UNIT = TWEIO_DEL_UNIT;\n+unsigned IOCTL_SIOCSCNWDOMAIN = SIOCSCNWDOMAIN;\n+unsigned IOCTL_SIOCGCNWDOMAIN = SIOCGCNWDOMAIN;\n+unsigned IOCTL_SIOCSCNWKEY = SIOCSCNWKEY;\n+unsigned IOCTL_SIOCGCNWSTATUS = SIOCGCNWSTATUS;\n+unsigned IOCTL_SIOCGCNWSTATS = SIOCGCNWSTATS;\n+unsigned IOCTL_SIOCGCNWTRAIL = SIOCGCNWTRAIL;\n+unsigned IOCTL_SIOCGRAYSIGLEV = SIOCGRAYSIGLEV;\n+unsigned IOCTL_RAIDFRAME_SHUTDOWN = RAIDFRAME_SHUTDOWN;\n+unsigned IOCTL_RAIDFRAME_TUR = RAIDFRAME_TUR;\n+unsigned IOCTL_RAIDFRAME_FAIL_DISK = RAIDFRAME_FAIL_DISK;\n+unsigned IOCTL_RAIDFRAME_CHECK_RECON_STATUS = RAIDFRAME_CHECK_RECON_STATUS;\n+unsigned IOCTL_RAIDFRAME_REWRITEPARITY = RAIDFRAME_REWRITEPARITY;\n+unsigned IOCTL_RAIDFRAME_COPYBACK = RAIDFRAME_COPYBACK;\n+unsigned IOCTL_RAIDFRAME_SPARET_WAIT = RAIDFRAME_SPARET_WAIT;\n+unsigned IOCTL_RAIDFRAME_SEND_SPARET = RAIDFRAME_SEND_SPARET;\n+unsigned IOCTL_RAIDFRAME_ABORT_SPARET_WAIT = RAIDFRAME_ABORT_SPARET_WAIT;\n+unsigned IOCTL_RAIDFRAME_START_ATRACE = RAIDFRAME_START_ATRACE;\n+unsigned IOCTL_RAIDFRAME_STOP_ATRACE = RAIDFRAME_STOP_ATRACE;\n+unsigned IOCTL_RAIDFRAME_GET_SIZE = RAIDFRAME_GET_SIZE;\n+unsigned IOCTL_RAIDFRAME_RESET_ACCTOTALS = RAIDFRAME_RESET_ACCTOTALS;\n+unsigned IOCTL_RAIDFRAME_KEEP_ACCTOTALS = RAIDFRAME_KEEP_ACCTOTALS;\n+unsigned IOCTL_RAIDFRAME_GET_COMPONENT_LABEL = RAIDFRAME_GET_COMPONENT_LABEL;\n+unsigned IOCTL_RAIDFRAME_SET_COMPONENT_LABEL = RAIDFRAME_SET_COMPONENT_LABEL;\n+unsigned IOCTL_RAIDFRAME_INIT_LABELS = RAIDFRAME_INIT_LABELS;\n+unsigned IOCTL_RAIDFRAME_ADD_HOT_SPARE = RAIDFRAME_ADD_HOT_SPARE;\n+unsigned IOCTL_RAIDFRAME_REMOVE_HOT_SPARE = RAIDFRAME_REMOVE_HOT_SPARE;\n+unsigned IOCTL_RAIDFRAME_REBUILD_IN_PLACE = RAIDFRAME_REBUILD_IN_PLACE;\n+unsigned IOCTL_RAIDFRAME_CHECK_PARITY = RAIDFRAME_CHECK_PARITY;\n+unsigned IOCTL_RAIDFRAME_CHECK_PARITYREWRITE_STATUS =\n+    RAIDFRAME_CHECK_PARITYREWRITE_STATUS;\n+unsigned IOCTL_RAIDFRAME_CHECK_COPYBACK_STATUS =\n+    RAIDFRAME_CHECK_COPYBACK_STATUS;\n+unsigned IOCTL_RAIDFRAME_SET_AUTOCONFIG = RAIDFRAME_SET_AUTOCONFIG;\n+unsigned IOCTL_RAIDFRAME_SET_ROOT = RAIDFRAME_SET_ROOT;\n+unsigned IOCTL_RAIDFRAME_DELETE_COMPONENT = RAIDFRAME_DELETE_COMPONENT;\n+unsigned IOCTL_RAIDFRAME_INCORPORATE_HOT_SPARE =\n+    RAIDFRAME_INCORPORATE_HOT_SPARE;\n+unsigned IOCTL_RAIDFRAME_CHECK_RECON_STATUS_EXT =\n+    RAIDFRAME_CHECK_RECON_STATUS_EXT;\n+unsigned IOCTL_RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT =\n+    RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT;\n+unsigned IOCTL_RAIDFRAME_CHECK_COPYBACK_STATUS_EXT =\n+    RAIDFRAME_CHECK_COPYBACK_STATUS_EXT;\n+unsigned IOCTL_RAIDFRAME_CONFIGURE = RAIDFRAME_CONFIGURE;\n+unsigned IOCTL_RAIDFRAME_GET_INFO = RAIDFRAME_GET_INFO;\n+unsigned IOCTL_RAIDFRAME_PARITYMAP_STATUS = RAIDFRAME_PARITYMAP_STATUS;\n+unsigned IOCTL_RAIDFRAME_PARITYMAP_GET_DISABLE =\n+    RAIDFRAME_PARITYMAP_GET_DISABLE;\n+unsigned IOCTL_RAIDFRAME_PARITYMAP_SET_DISABLE =\n+    RAIDFRAME_PARITYMAP_SET_DISABLE;\n+unsigned IOCTL_RAIDFRAME_PARITYMAP_SET_PARAMS = RAIDFRAME_PARITYMAP_SET_PARAMS;\n+unsigned IOCTL_RAIDFRAME_SET_LAST_UNIT = RAIDFRAME_SET_LAST_UNIT;\n+unsigned IOCTL_MBPPIOCSPARAM = MBPPIOCSPARAM;\n+unsigned IOCTL_MBPPIOCGPARAM = MBPPIOCGPARAM;\n+unsigned IOCTL_MBPPIOCGSTAT = MBPPIOCGSTAT;\n+unsigned IOCTL_SESIOC_GETNOBJ = SESIOC_GETNOBJ;\n+unsigned IOCTL_SESIOC_GETOBJMAP = SESIOC_GETOBJMAP;\n+unsigned IOCTL_SESIOC_GETENCSTAT = SESIOC_GETENCSTAT;\n+unsigned IOCTL_SESIOC_SETENCSTAT = SESIOC_SETENCSTAT;\n+unsigned IOCTL_SESIOC_GETOBJSTAT = SESIOC_GETOBJSTAT;\n+unsigned IOCTL_SESIOC_SETOBJSTAT = SESIOC_SETOBJSTAT;\n+unsigned IOCTL_SESIOC_GETTEXT = SESIOC_GETTEXT;\n+unsigned IOCTL_SESIOC_INIT = SESIOC_INIT;\n+unsigned IOCTL_SUN_DKIOCGGEOM = SUN_DKIOCGGEOM;\n+unsigned IOCTL_SUN_DKIOCINFO = SUN_DKIOCINFO;\n+unsigned IOCTL_SUN_DKIOCGPART = SUN_DKIOCGPART;\n+unsigned IOCTL_FBIOGTYPE = FBIOGTYPE;\n+unsigned IOCTL_FBIOPUTCMAP = FBIOPUTCMAP;\n+unsigned IOCTL_FBIOGETCMAP = FBIOGETCMAP;\n+unsigned IOCTL_FBIOGATTR = FBIOGATTR;\n+unsigned IOCTL_FBIOSVIDEO = FBIOSVIDEO;\n+unsigned IOCTL_FBIOGVIDEO = FBIOGVIDEO;\n+unsigned IOCTL_FBIOSCURSOR = FBIOSCURSOR;\n+unsigned IOCTL_FBIOGCURSOR = FBIOGCURSOR;\n+unsigned IOCTL_FBIOSCURPOS = FBIOSCURPOS;\n+unsigned IOCTL_FBIOGCURPOS = FBIOGCURPOS;\n+unsigned IOCTL_FBIOGCURMAX = FBIOGCURMAX;\n+unsigned IOCTL_KIOCTRANS = KIOCTRANS;\n+unsigned IOCTL_KIOCSETKEY = KIOCSETKEY;\n+unsigned IOCTL_KIOCGETKEY = KIOCGETKEY;\n+unsigned IOCTL_KIOCGTRANS = KIOCGTRANS;\n+unsigned IOCTL_KIOCCMD = KIOCCMD;\n+unsigned IOCTL_KIOCTYPE = KIOCTYPE;\n+unsigned IOCTL_KIOCSDIRECT = KIOCSDIRECT;\n+unsigned IOCTL_KIOCSKEY = KIOCSKEY;\n+unsigned IOCTL_KIOCGKEY = KIOCGKEY;\n+unsigned IOCTL_KIOCSLED = KIOCSLED;\n+unsigned IOCTL_KIOCGLED = KIOCGLED;\n+unsigned IOCTL_KIOCLAYOUT = KIOCLAYOUT;\n+unsigned IOCTL_VUIDSFORMAT = VUIDSFORMAT;\n+unsigned IOCTL_VUIDGFORMAT = VUIDGFORMAT;\n+unsigned IOCTL_STICIO_GXINFO = STICIO_GXINFO;\n+unsigned IOCTL_STICIO_RESET = STICIO_RESET;\n+unsigned IOCTL_STICIO_STARTQ = STICIO_STARTQ;\n+unsigned IOCTL_STICIO_STOPQ = STICIO_STOPQ;\n+unsigned IOCTL_UKYOPON_IDENTIFY = UKYOPON_IDENTIFY;\n+unsigned IOCTL_URIO_SEND_COMMAND = URIO_SEND_COMMAND;\n+unsigned IOCTL_URIO_RECV_COMMAND = URIO_RECV_COMMAND;\n+unsigned IOCTL_USB_REQUEST = USB_REQUEST;\n+unsigned IOCTL_USB_SETDEBUG = USB_SETDEBUG;\n+unsigned IOCTL_USB_DISCOVER = USB_DISCOVER;\n+unsigned IOCTL_USB_DEVICEINFO = USB_DEVICEINFO;\n+unsigned IOCTL_USB_DEVICEINFO_OLD = USB_DEVICEINFO_OLD;\n+unsigned IOCTL_USB_DEVICESTATS = USB_DEVICESTATS;\n+unsigned IOCTL_USB_GET_REPORT_DESC = USB_GET_REPORT_DESC;\n+unsigned IOCTL_USB_SET_IMMED = USB_SET_IMMED;\n+unsigned IOCTL_USB_GET_REPORT = USB_GET_REPORT;\n+unsigned IOCTL_USB_SET_REPORT = USB_SET_REPORT;\n+unsigned IOCTL_USB_GET_REPORT_ID = USB_GET_REPORT_ID;\n+unsigned IOCTL_USB_GET_CONFIG = USB_GET_CONFIG;\n+unsigned IOCTL_USB_SET_CONFIG = USB_SET_CONFIG;\n+unsigned IOCTL_USB_GET_ALTINTERFACE = USB_GET_ALTINTERFACE;\n+unsigned IOCTL_USB_SET_ALTINTERFACE = USB_SET_ALTINTERFACE;\n+unsigned IOCTL_USB_GET_NO_ALT = USB_GET_NO_ALT;\n+unsigned IOCTL_USB_GET_DEVICE_DESC = USB_GET_DEVICE_DESC;\n+unsigned IOCTL_USB_GET_CONFIG_DESC = USB_GET_CONFIG_DESC;\n+unsigned IOCTL_USB_GET_INTERFACE_DESC = USB_GET_INTERFACE_DESC;\n+unsigned IOCTL_USB_GET_ENDPOINT_DESC = USB_GET_ENDPOINT_DESC;\n+unsigned IOCTL_USB_GET_FULL_DESC = USB_GET_FULL_DESC;\n+unsigned IOCTL_USB_GET_STRING_DESC = USB_GET_STRING_DESC;\n+unsigned IOCTL_USB_DO_REQUEST = USB_DO_REQUEST;\n+unsigned IOCTL_USB_GET_DEVICEINFO = USB_GET_DEVICEINFO;\n+unsigned IOCTL_USB_GET_DEVICEINFO_OLD = USB_GET_DEVICEINFO_OLD;\n+unsigned IOCTL_USB_SET_SHORT_XFER = USB_SET_SHORT_XFER;\n+unsigned IOCTL_USB_SET_TIMEOUT = USB_SET_TIMEOUT;\n+unsigned IOCTL_USB_SET_BULK_RA = USB_SET_BULK_RA;\n+unsigned IOCTL_USB_SET_BULK_WB = USB_SET_BULK_WB;\n+unsigned IOCTL_USB_SET_BULK_RA_OPT = USB_SET_BULK_RA_OPT;\n+unsigned IOCTL_USB_SET_BULK_WB_OPT = USB_SET_BULK_WB_OPT;\n+unsigned IOCTL_USB_GET_CM_OVER_DATA = USB_GET_CM_OVER_DATA;\n+unsigned IOCTL_USB_SET_CM_OVER_DATA = USB_SET_CM_OVER_DATA;\n+unsigned IOCTL_UTOPPYIOTURBO = UTOPPYIOTURBO;\n+unsigned IOCTL_UTOPPYIOCANCEL = UTOPPYIOCANCEL;\n+unsigned IOCTL_UTOPPYIOREBOOT = UTOPPYIOREBOOT;\n+unsigned IOCTL_UTOPPYIOSTATS = UTOPPYIOSTATS;\n+unsigned IOCTL_UTOPPYIORENAME = UTOPPYIORENAME;\n+unsigned IOCTL_UTOPPYIOMKDIR = UTOPPYIOMKDIR;\n+unsigned IOCTL_UTOPPYIODELETE = UTOPPYIODELETE;\n+unsigned IOCTL_UTOPPYIOREADDIR = UTOPPYIOREADDIR;\n+unsigned IOCTL_UTOPPYIOREADFILE = UTOPPYIOREADFILE;\n+unsigned IOCTL_UTOPPYIOWRITEFILE = UTOPPYIOWRITEFILE;\n+unsigned IOCTL_DIOSXDCMD = DIOSXDCMD;\n+unsigned IOCTL_VT_OPENQRY = VT_OPENQRY;\n+unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n+unsigned IOCTL_VT_GETMODE = VT_GETMODE;\n+unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n+unsigned IOCTL_VT_ACTIVATE = VT_ACTIVATE;\n+unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n+unsigned IOCTL_VT_GETACTIVE = VT_GETACTIVE;\n+unsigned IOCTL_VT_GETSTATE = VT_GETSTATE;\n+unsigned IOCTL_KDGETKBENT = KDGETKBENT;\n+unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n+unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n+unsigned IOCTL_KDMKTONE = KDMKTONE;\n+unsigned IOCTL_KDSETMODE = KDSETMODE;\n+unsigned IOCTL_KDENABIO = KDENABIO;\n+unsigned IOCTL_KDDISABIO = KDDISABIO;\n+unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n+unsigned IOCTL_KDGETLED = KDGETLED;\n+unsigned IOCTL_KDSETLED = KDSETLED;\n+unsigned IOCTL_KDSETRAD = KDSETRAD;\n+unsigned IOCTL_VGAPCVTID = VGAPCVTID;\n+unsigned IOCTL_CONS_GETVERS = CONS_GETVERS;\n+unsigned IOCTL_WSKBDIO_GTYPE = WSKBDIO_GTYPE;\n+unsigned IOCTL_WSKBDIO_BELL = WSKBDIO_BELL;\n+unsigned IOCTL_WSKBDIO_COMPLEXBELL = WSKBDIO_COMPLEXBELL;\n+unsigned IOCTL_WSKBDIO_SETBELL = WSKBDIO_SETBELL;\n+unsigned IOCTL_WSKBDIO_GETBELL = WSKBDIO_GETBELL;\n+unsigned IOCTL_WSKBDIO_SETDEFAULTBELL = WSKBDIO_SETDEFAULTBELL;\n+unsigned IOCTL_WSKBDIO_GETDEFAULTBELL = WSKBDIO_GETDEFAULTBELL;\n+unsigned IOCTL_WSKBDIO_SETKEYREPEAT = WSKBDIO_SETKEYREPEAT;\n+unsigned IOCTL_WSKBDIO_GETKEYREPEAT = WSKBDIO_GETKEYREPEAT;\n+unsigned IOCTL_WSKBDIO_SETDEFAULTKEYREPEAT = WSKBDIO_SETDEFAULTKEYREPEAT;\n+unsigned IOCTL_WSKBDIO_GETDEFAULTKEYREPEAT = WSKBDIO_GETDEFAULTKEYREPEAT;\n+unsigned IOCTL_WSKBDIO_SETLEDS = WSKBDIO_SETLEDS;\n+unsigned IOCTL_WSKBDIO_GETLEDS = WSKBDIO_GETLEDS;\n+unsigned IOCTL_WSKBDIO_GETMAP = WSKBDIO_GETMAP;\n+unsigned IOCTL_WSKBDIO_SETMAP = WSKBDIO_SETMAP;\n+unsigned IOCTL_WSKBDIO_GETENCODING = WSKBDIO_GETENCODING;\n+unsigned IOCTL_WSKBDIO_SETENCODING = WSKBDIO_SETENCODING;\n+unsigned IOCTL_WSKBDIO_SETMODE = WSKBDIO_SETMODE;\n+unsigned IOCTL_WSKBDIO_GETMODE = WSKBDIO_GETMODE;\n+unsigned IOCTL_WSKBDIO_SETKEYCLICK = WSKBDIO_SETKEYCLICK;\n+unsigned IOCTL_WSKBDIO_GETKEYCLICK = WSKBDIO_GETKEYCLICK;\n+unsigned IOCTL_WSKBDIO_GETSCROLL = WSKBDIO_GETSCROLL;\n+unsigned IOCTL_WSKBDIO_SETSCROLL = WSKBDIO_SETSCROLL;\n+unsigned IOCTL_WSKBDIO_SETVERSION = WSKBDIO_SETVERSION;\n+unsigned IOCTL_WSMOUSEIO_GTYPE = WSMOUSEIO_GTYPE;\n+unsigned IOCTL_WSMOUSEIO_SRES = WSMOUSEIO_SRES;\n+unsigned IOCTL_WSMOUSEIO_SSCALE = WSMOUSEIO_SSCALE;\n+unsigned IOCTL_WSMOUSEIO_SRATE = WSMOUSEIO_SRATE;\n+unsigned IOCTL_WSMOUSEIO_SCALIBCOORDS = WSMOUSEIO_SCALIBCOORDS;\n+unsigned IOCTL_WSMOUSEIO_GCALIBCOORDS = WSMOUSEIO_GCALIBCOORDS;\n+unsigned IOCTL_WSMOUSEIO_GETID = WSMOUSEIO_GETID;\n+unsigned IOCTL_WSMOUSEIO_GETREPEAT = WSMOUSEIO_GETREPEAT;\n+unsigned IOCTL_WSMOUSEIO_SETREPEAT = WSMOUSEIO_SETREPEAT;\n+unsigned IOCTL_WSMOUSEIO_SETVERSION = WSMOUSEIO_SETVERSION;\n+unsigned IOCTL_WSDISPLAYIO_GTYPE = WSDISPLAYIO_GTYPE;\n+unsigned IOCTL_WSDISPLAYIO_GINFO = WSDISPLAYIO_GINFO;\n+unsigned IOCTL_WSDISPLAYIO_GETCMAP = WSDISPLAYIO_GETCMAP;\n+unsigned IOCTL_WSDISPLAYIO_PUTCMAP = WSDISPLAYIO_PUTCMAP;\n+unsigned IOCTL_WSDISPLAYIO_GVIDEO = WSDISPLAYIO_GVIDEO;\n+unsigned IOCTL_WSDISPLAYIO_SVIDEO = WSDISPLAYIO_SVIDEO;\n+unsigned IOCTL_WSDISPLAYIO_GCURPOS = WSDISPLAYIO_GCURPOS;\n+unsigned IOCTL_WSDISPLAYIO_SCURPOS = WSDISPLAYIO_SCURPOS;\n+unsigned IOCTL_WSDISPLAYIO_GCURMAX = WSDISPLAYIO_GCURMAX;\n+unsigned IOCTL_WSDISPLAYIO_GCURSOR = WSDISPLAYIO_GCURSOR;\n+unsigned IOCTL_WSDISPLAYIO_SCURSOR = WSDISPLAYIO_SCURSOR;\n+unsigned IOCTL_WSDISPLAYIO_GMODE = WSDISPLAYIO_GMODE;\n+unsigned IOCTL_WSDISPLAYIO_SMODE = WSDISPLAYIO_SMODE;\n+unsigned IOCTL_WSDISPLAYIO_LDFONT = WSDISPLAYIO_LDFONT;\n+unsigned IOCTL_WSDISPLAYIO_ADDSCREEN = WSDISPLAYIO_ADDSCREEN;\n+unsigned IOCTL_WSDISPLAYIO_DELSCREEN = WSDISPLAYIO_DELSCREEN;\n+unsigned IOCTL_WSDISPLAYIO_SFONT = WSDISPLAYIO_SFONT;\n+unsigned IOCTL__O_WSDISPLAYIO_SETKEYBOARD = _O_WSDISPLAYIO_SETKEYBOARD;\n+unsigned IOCTL_WSDISPLAYIO_GETPARAM = WSDISPLAYIO_GETPARAM;\n+unsigned IOCTL_WSDISPLAYIO_SETPARAM = WSDISPLAYIO_SETPARAM;\n+unsigned IOCTL_WSDISPLAYIO_GETACTIVESCREEN = WSDISPLAYIO_GETACTIVESCREEN;\n+unsigned IOCTL_WSDISPLAYIO_GETWSCHAR = WSDISPLAYIO_GETWSCHAR;\n+unsigned IOCTL_WSDISPLAYIO_PUTWSCHAR = WSDISPLAYIO_PUTWSCHAR;\n+unsigned IOCTL_WSDISPLAYIO_DGSCROLL = WSDISPLAYIO_DGSCROLL;\n+unsigned IOCTL_WSDISPLAYIO_DSSCROLL = WSDISPLAYIO_DSSCROLL;\n+unsigned IOCTL_WSDISPLAYIO_GMSGATTRS = WSDISPLAYIO_GMSGATTRS;\n+unsigned IOCTL_WSDISPLAYIO_SMSGATTRS = WSDISPLAYIO_SMSGATTRS;\n+unsigned IOCTL_WSDISPLAYIO_GBORDER = WSDISPLAYIO_GBORDER;\n+unsigned IOCTL_WSDISPLAYIO_SBORDER = WSDISPLAYIO_SBORDER;\n+unsigned IOCTL_WSDISPLAYIO_SSPLASH = WSDISPLAYIO_SSPLASH;\n+unsigned IOCTL_WSDISPLAYIO_SPROGRESS = WSDISPLAYIO_SPROGRESS;\n+unsigned IOCTL_WSDISPLAYIO_LINEBYTES = WSDISPLAYIO_LINEBYTES;\n+unsigned IOCTL_WSDISPLAYIO_SETVERSION = WSDISPLAYIO_SETVERSION;\n+unsigned IOCTL_WSMUXIO_ADD_DEVICE = WSMUXIO_ADD_DEVICE;\n+unsigned IOCTL_WSMUXIO_REMOVE_DEVICE = WSMUXIO_REMOVE_DEVICE;\n+unsigned IOCTL_WSMUXIO_LIST_DEVICES = WSMUXIO_LIST_DEVICES;\n+unsigned IOCTL_WSMUXIO_INJECTEVENT = WSMUXIO_INJECTEVENT;\n+unsigned IOCTL_WSDISPLAYIO_GET_BUSID = WSDISPLAYIO_GET_BUSID;\n+unsigned IOCTL_WSDISPLAYIO_GET_EDID = WSDISPLAYIO_GET_EDID;\n+unsigned IOCTL_WSDISPLAYIO_SET_POLLING = WSDISPLAYIO_SET_POLLING;\n+unsigned IOCTL_WSDISPLAYIO_GET_FBINFO = WSDISPLAYIO_GET_FBINFO;\n+unsigned IOCTL_WSDISPLAYIO_DOBLIT = WSDISPLAYIO_DOBLIT;\n+unsigned IOCTL_WSDISPLAYIO_WAITBLIT = WSDISPLAYIO_WAITBLIT;\n+unsigned IOCTL_BIOCLOCATE = BIOCLOCATE;\n+unsigned IOCTL_BIOCINQ = BIOCINQ;\n+unsigned IOCTL_BIOCDISK_NOVOL = BIOCDISK_NOVOL;\n+unsigned IOCTL_BIOCDISK = BIOCDISK;\n+unsigned IOCTL_BIOCVOL = BIOCVOL;\n+unsigned IOCTL_BIOCALARM = BIOCALARM;\n+unsigned IOCTL_BIOCBLINK = BIOCBLINK;\n+unsigned IOCTL_BIOCSETSTATE = BIOCSETSTATE;\n+unsigned IOCTL_BIOCVOLOPS = BIOCVOLOPS;\n+unsigned IOCTL_MD_GETCONF = MD_GETCONF;\n+unsigned IOCTL_MD_SETCONF = MD_SETCONF;\n+unsigned IOCTL_CCDIOCSET = CCDIOCSET;\n+unsigned IOCTL_CCDIOCCLR = CCDIOCCLR;\n+unsigned IOCTL_CGDIOCSET = CGDIOCSET;\n+unsigned IOCTL_CGDIOCCLR = CGDIOCCLR;\n+unsigned IOCTL_CGDIOCGET = CGDIOCGET;\n+unsigned IOCTL_FSSIOCSET = FSSIOCSET;\n+unsigned IOCTL_FSSIOCGET = FSSIOCGET;\n+unsigned IOCTL_FSSIOCCLR = FSSIOCCLR;\n+unsigned IOCTL_FSSIOFSET = FSSIOFSET;\n+unsigned IOCTL_FSSIOFGET = FSSIOFGET;\n+unsigned IOCTL_BTDEV_ATTACH = BTDEV_ATTACH;\n+unsigned IOCTL_BTDEV_DETACH = BTDEV_DETACH;\n+unsigned IOCTL_BTSCO_GETINFO = BTSCO_GETINFO;\n+unsigned IOCTL_KTTCP_IO_SEND = KTTCP_IO_SEND;\n+unsigned IOCTL_KTTCP_IO_RECV = KTTCP_IO_RECV;\n+unsigned IOCTL_IOC_LOCKSTAT_GVERSION = IOC_LOCKSTAT_GVERSION;\n+unsigned IOCTL_IOC_LOCKSTAT_ENABLE = IOC_LOCKSTAT_ENABLE;\n+unsigned IOCTL_IOC_LOCKSTAT_DISABLE = IOC_LOCKSTAT_DISABLE;\n+unsigned IOCTL_VNDIOCSET = VNDIOCSET;\n+unsigned IOCTL_VNDIOCCLR = VNDIOCCLR;\n+unsigned IOCTL_VNDIOCGET = VNDIOCGET;\n+unsigned IOCTL_SPKRTONE = SPKRTONE;\n+unsigned IOCTL_SPKRTUNE = SPKRTUNE;\n+unsigned IOCTL_SPKRGETVOL = SPKRGETVOL;\n+unsigned IOCTL_SPKRSETVOL = SPKRSETVOL;\n+unsigned IOCTL_BIOCGBLEN = BIOCGBLEN;\n+unsigned IOCTL_BIOCSBLEN = BIOCSBLEN;\n+unsigned IOCTL_BIOCSETF = BIOCSETF;\n+unsigned IOCTL_BIOCFLUSH = BIOCFLUSH;\n+unsigned IOCTL_BIOCPROMISC = BIOCPROMISC;\n+unsigned IOCTL_BIOCGDLT = BIOCGDLT;\n+unsigned IOCTL_BIOCGETIF = BIOCGETIF;\n+unsigned IOCTL_BIOCSETIF = BIOCSETIF;\n+unsigned IOCTL_BIOCGSTATS = BIOCGSTATS;\n+unsigned IOCTL_BIOCGSTATSOLD = BIOCGSTATSOLD;\n+unsigned IOCTL_BIOCIMMEDIATE = BIOCIMMEDIATE;\n+unsigned IOCTL_BIOCVERSION = BIOCVERSION;\n+unsigned IOCTL_BIOCSTCPF = BIOCSTCPF;\n+unsigned IOCTL_BIOCSUDPF = BIOCSUDPF;\n+unsigned IOCTL_BIOCGHDRCMPLT = BIOCGHDRCMPLT;\n+unsigned IOCTL_BIOCSHDRCMPLT = BIOCSHDRCMPLT;\n+unsigned IOCTL_BIOCSDLT = BIOCSDLT;\n+unsigned IOCTL_BIOCGDLTLIST = BIOCGDLTLIST;\n+unsigned IOCTL_BIOCGSEESENT = BIOCGSEESENT;\n+unsigned IOCTL_BIOCSSEESENT = BIOCSSEESENT;\n+unsigned IOCTL_BIOCSRTIMEOUT = BIOCSRTIMEOUT;\n+unsigned IOCTL_BIOCGRTIMEOUT = BIOCGRTIMEOUT;\n+unsigned IOCTL_BIOCGFEEDBACK = BIOCGFEEDBACK;\n+unsigned IOCTL_BIOCSFEEDBACK = BIOCSFEEDBACK;\n+unsigned IOCTL_SIOCRAWATM = SIOCRAWATM;\n+unsigned IOCTL_SIOCATMENA = SIOCATMENA;\n+unsigned IOCTL_SIOCATMDIS = SIOCATMDIS;\n+unsigned IOCTL_SIOCSPVCTX = SIOCSPVCTX;\n+unsigned IOCTL_SIOCGPVCTX = SIOCGPVCTX;\n+unsigned IOCTL_SIOCSPVCSIF = SIOCSPVCSIF;\n+unsigned IOCTL_SIOCGPVCSIF = SIOCGPVCSIF;\n+unsigned IOCTL_GRESADDRS = GRESADDRS;\n+unsigned IOCTL_GRESADDRD = GRESADDRD;\n+unsigned IOCTL_GREGADDRS = GREGADDRS;\n+unsigned IOCTL_GREGADDRD = GREGADDRD;\n+unsigned IOCTL_GRESPROTO = GRESPROTO;\n+unsigned IOCTL_GREGPROTO = GREGPROTO;\n+unsigned IOCTL_GRESSOCK = GRESSOCK;\n+unsigned IOCTL_GREDSOCK = GREDSOCK;\n+unsigned IOCTL_PPPIOCGRAWIN = PPPIOCGRAWIN;\n+unsigned IOCTL_PPPIOCGFLAGS = PPPIOCGFLAGS;\n+unsigned IOCTL_PPPIOCSFLAGS = PPPIOCSFLAGS;\n+unsigned IOCTL_PPPIOCGASYNCMAP = PPPIOCGASYNCMAP;\n+unsigned IOCTL_PPPIOCSASYNCMAP = PPPIOCSASYNCMAP;\n+unsigned IOCTL_PPPIOCGUNIT = PPPIOCGUNIT;\n+unsigned IOCTL_PPPIOCGRASYNCMAP = PPPIOCGRASYNCMAP;\n+unsigned IOCTL_PPPIOCSRASYNCMAP = PPPIOCSRASYNCMAP;\n+unsigned IOCTL_PPPIOCGMRU = PPPIOCGMRU;\n+unsigned IOCTL_PPPIOCSMRU = PPPIOCSMRU;\n+unsigned IOCTL_PPPIOCSMAXCID = PPPIOCSMAXCID;\n+unsigned IOCTL_PPPIOCGXASYNCMAP = PPPIOCGXASYNCMAP;\n+unsigned IOCTL_PPPIOCSXASYNCMAP = PPPIOCSXASYNCMAP;\n+unsigned IOCTL_PPPIOCXFERUNIT = PPPIOCXFERUNIT;\n+unsigned IOCTL_PPPIOCSCOMPRESS = PPPIOCSCOMPRESS;\n+unsigned IOCTL_PPPIOCGNPMODE = PPPIOCGNPMODE;\n+unsigned IOCTL_PPPIOCSNPMODE = PPPIOCSNPMODE;\n+unsigned IOCTL_PPPIOCGIDLE = PPPIOCGIDLE;\n+unsigned IOCTL_PPPIOCGMTU = PPPIOCGMTU;\n+unsigned IOCTL_PPPIOCSMTU = PPPIOCSMTU;\n+unsigned IOCTL_SIOCGPPPSTATS = SIOCGPPPSTATS;\n+unsigned IOCTL_SIOCGPPPCSTATS = SIOCGPPPCSTATS;\n+unsigned IOCTL_IOC_NPF_VERSION = IOC_NPF_VERSION;\n+unsigned IOCTL_IOC_NPF_SWITCH = IOC_NPF_SWITCH;\n+unsigned IOCTL_IOC_NPF_LOAD = IOC_NPF_LOAD;\n+unsigned IOCTL_IOC_NPF_TABLE = IOC_NPF_TABLE;\n+unsigned IOCTL_IOC_NPF_STATS = IOC_NPF_STATS;\n+unsigned IOCTL_IOC_NPF_SAVE = IOC_NPF_SAVE;\n+unsigned IOCTL_IOC_NPF_RULE = IOC_NPF_RULE;\n+unsigned IOCTL_IOC_NPF_CONN_LOOKUP = IOC_NPF_CONN_LOOKUP;\n+unsigned IOCTL_PPPOESETPARMS = PPPOESETPARMS;\n+unsigned IOCTL_PPPOEGETPARMS = PPPOEGETPARMS;\n+unsigned IOCTL_PPPOEGETSESSION = PPPOEGETSESSION;\n+unsigned IOCTL_SPPPGETAUTHCFG = SPPPGETAUTHCFG;\n+unsigned IOCTL_SPPPSETAUTHCFG = SPPPSETAUTHCFG;\n+unsigned IOCTL_SPPPGETLCPCFG = SPPPGETLCPCFG;\n+unsigned IOCTL_SPPPSETLCPCFG = SPPPSETLCPCFG;\n+unsigned IOCTL_SPPPGETSTATUS = SPPPGETSTATUS;\n+unsigned IOCTL_SPPPGETSTATUSNCP = SPPPGETSTATUSNCP;\n+unsigned IOCTL_SPPPGETIDLETO = SPPPGETIDLETO;\n+unsigned IOCTL_SPPPSETIDLETO = SPPPSETIDLETO;\n+unsigned IOCTL_SPPPGETAUTHFAILURES = SPPPGETAUTHFAILURES;\n+unsigned IOCTL_SPPPSETAUTHFAILURE = SPPPSETAUTHFAILURE;\n+unsigned IOCTL_SPPPSETDNSOPTS = SPPPSETDNSOPTS;\n+unsigned IOCTL_SPPPGETDNSOPTS = SPPPGETDNSOPTS;\n+unsigned IOCTL_SPPPGETDNSADDRS = SPPPGETDNSADDRS;\n+unsigned IOCTL_SPPPSETKEEPALIVE = SPPPSETKEEPALIVE;\n+unsigned IOCTL_SPPPGETKEEPALIVE = SPPPGETKEEPALIVE;\n+unsigned IOCTL_SRT_GETNRT = SRT_GETNRT;\n+unsigned IOCTL_SRT_GETRT = SRT_GETRT;\n+unsigned IOCTL_SRT_SETRT = SRT_SETRT;\n+unsigned IOCTL_SRT_DELRT = SRT_DELRT;\n+unsigned IOCTL_SRT_SFLAGS = SRT_SFLAGS;\n+unsigned IOCTL_SRT_GFLAGS = SRT_GFLAGS;\n+unsigned IOCTL_SRT_SGFLAGS = SRT_SGFLAGS;\n+unsigned IOCTL_SRT_DEBUG = SRT_DEBUG;\n+unsigned IOCTL_TAPGIFNAME = TAPGIFNAME;\n+unsigned IOCTL_TUNSDEBUG = TUNSDEBUG;\n+unsigned IOCTL_TUNGDEBUG = TUNGDEBUG;\n+unsigned IOCTL_TUNSIFMODE = TUNSIFMODE;\n+unsigned IOCTL_TUNSLMODE = TUNSLMODE;\n+unsigned IOCTL_TUNSIFHEAD = TUNSIFHEAD;\n+unsigned IOCTL_TUNGIFHEAD = TUNGIFHEAD;\n+unsigned IOCTL_DIOCSTART = DIOCSTART;\n+unsigned IOCTL_DIOCSTOP = DIOCSTOP;\n+unsigned IOCTL_DIOCADDRULE = DIOCADDRULE;\n+unsigned IOCTL_DIOCGETRULES = DIOCGETRULES;\n+unsigned IOCTL_DIOCGETRULE = DIOCGETRULE;\n+unsigned IOCTL_DIOCSETLCK = DIOCSETLCK;\n+unsigned IOCTL_DIOCCLRSTATES = DIOCCLRSTATES;\n+unsigned IOCTL_DIOCGETSTATE = DIOCGETSTATE;\n+unsigned IOCTL_DIOCSETSTATUSIF = DIOCSETSTATUSIF;\n+unsigned IOCTL_DIOCGETSTATUS = DIOCGETSTATUS;\n+unsigned IOCTL_DIOCCLRSTATUS = DIOCCLRSTATUS;\n+unsigned IOCTL_DIOCNATLOOK = DIOCNATLOOK;\n+unsigned IOCTL_DIOCSETDEBUG = DIOCSETDEBUG;\n+unsigned IOCTL_DIOCGETSTATES = DIOCGETSTATES;\n+unsigned IOCTL_DIOCCHANGERULE = DIOCCHANGERULE;\n+unsigned IOCTL_DIOCSETTIMEOUT = DIOCSETTIMEOUT;\n+unsigned IOCTL_DIOCGETTIMEOUT = DIOCGETTIMEOUT;\n+unsigned IOCTL_DIOCADDSTATE = DIOCADDSTATE;\n+unsigned IOCTL_DIOCCLRRULECTRS = DIOCCLRRULECTRS;\n+unsigned IOCTL_DIOCGETLIMIT = DIOCGETLIMIT;\n+unsigned IOCTL_DIOCSETLIMIT = DIOCSETLIMIT;\n+unsigned IOCTL_DIOCKILLSTATES = DIOCKILLSTATES;\n+unsigned IOCTL_DIOCSTARTALTQ = DIOCSTARTALTQ;\n+unsigned IOCTL_DIOCSTOPALTQ = DIOCSTOPALTQ;\n+unsigned IOCTL_DIOCADDALTQ = DIOCADDALTQ;\n+unsigned IOCTL_DIOCGETALTQS = DIOCGETALTQS;\n+unsigned IOCTL_DIOCGETALTQ = DIOCGETALTQ;\n+unsigned IOCTL_DIOCCHANGEALTQ = DIOCCHANGEALTQ;\n+unsigned IOCTL_DIOCGETQSTATS = DIOCGETQSTATS;\n+unsigned IOCTL_DIOCBEGINADDRS = DIOCBEGINADDRS;\n+unsigned IOCTL_DIOCADDADDR = DIOCADDADDR;\n+unsigned IOCTL_DIOCGETADDRS = DIOCGETADDRS;\n+unsigned IOCTL_DIOCGETADDR = DIOCGETADDR;\n+unsigned IOCTL_DIOCCHANGEADDR = DIOCCHANGEADDR;\n+unsigned IOCTL_DIOCADDSTATES = DIOCADDSTATES;\n+unsigned IOCTL_DIOCGETRULESETS = DIOCGETRULESETS;\n+unsigned IOCTL_DIOCGETRULESET = DIOCGETRULESET;\n+unsigned IOCTL_DIOCRCLRTABLES = DIOCRCLRTABLES;\n+unsigned IOCTL_DIOCRADDTABLES = DIOCRADDTABLES;\n+unsigned IOCTL_DIOCRDELTABLES = DIOCRDELTABLES;\n+unsigned IOCTL_DIOCRGETTABLES = DIOCRGETTABLES;\n+unsigned IOCTL_DIOCRGETTSTATS = DIOCRGETTSTATS;\n+unsigned IOCTL_DIOCRCLRTSTATS = DIOCRCLRTSTATS;\n+unsigned IOCTL_DIOCRCLRADDRS = DIOCRCLRADDRS;\n+unsigned IOCTL_DIOCRADDADDRS = DIOCRADDADDRS;\n+unsigned IOCTL_DIOCRDELADDRS = DIOCRDELADDRS;\n+unsigned IOCTL_DIOCRSETADDRS = DIOCRSETADDRS;\n+unsigned IOCTL_DIOCRGETADDRS = DIOCRGETADDRS;\n+unsigned IOCTL_DIOCRGETASTATS = DIOCRGETASTATS;\n+unsigned IOCTL_DIOCRCLRASTATS = DIOCRCLRASTATS;\n+unsigned IOCTL_DIOCRTSTADDRS = DIOCRTSTADDRS;\n+unsigned IOCTL_DIOCRSETTFLAGS = DIOCRSETTFLAGS;\n+unsigned IOCTL_DIOCRINADEFINE = DIOCRINADEFINE;\n+unsigned IOCTL_DIOCOSFPFLUSH = DIOCOSFPFLUSH;\n+unsigned IOCTL_DIOCOSFPADD = DIOCOSFPADD;\n+unsigned IOCTL_DIOCOSFPGET = DIOCOSFPGET;\n+unsigned IOCTL_DIOCXBEGIN = DIOCXBEGIN;\n+unsigned IOCTL_DIOCXCOMMIT = DIOCXCOMMIT;\n+unsigned IOCTL_DIOCXROLLBACK = DIOCXROLLBACK;\n+unsigned IOCTL_DIOCGETSRCNODES = DIOCGETSRCNODES;\n+unsigned IOCTL_DIOCCLRSRCNODES = DIOCCLRSRCNODES;\n+unsigned IOCTL_DIOCSETHOSTID = DIOCSETHOSTID;\n+unsigned IOCTL_DIOCIGETIFACES = DIOCIGETIFACES;\n+unsigned IOCTL_DIOCSETIFFLAG = DIOCSETIFFLAG;\n+unsigned IOCTL_DIOCCLRIFFLAG = DIOCCLRIFFLAG;\n+unsigned IOCTL_DIOCKILLSRCNODES = DIOCKILLSRCNODES;\n+unsigned IOCTL_SLIOCGUNIT = SLIOCGUNIT;\n+unsigned IOCTL_SIOCGBTINFO = SIOCGBTINFO;\n+unsigned IOCTL_SIOCGBTINFOA = SIOCGBTINFOA;\n+unsigned IOCTL_SIOCNBTINFO = SIOCNBTINFO;\n+unsigned IOCTL_SIOCSBTFLAGS = SIOCSBTFLAGS;\n+unsigned IOCTL_SIOCSBTPOLICY = SIOCSBTPOLICY;\n+unsigned IOCTL_SIOCSBTPTYPE = SIOCSBTPTYPE;\n+unsigned IOCTL_SIOCGBTSTATS = SIOCGBTSTATS;\n+unsigned IOCTL_SIOCZBTSTATS = SIOCZBTSTATS;\n+unsigned IOCTL_SIOCBTDUMP = SIOCBTDUMP;\n+unsigned IOCTL_SIOCSBTSCOMTU = SIOCSBTSCOMTU;\n+unsigned IOCTL_SIOCGBTFEAT = SIOCGBTFEAT;\n+unsigned IOCTL_SIOCADNAT = SIOCADNAT;\n+unsigned IOCTL_SIOCRMNAT = SIOCRMNAT;\n+unsigned IOCTL_SIOCGNATS = SIOCGNATS;\n+unsigned IOCTL_SIOCGNATL = SIOCGNATL;\n+unsigned IOCTL_SIOCPURGENAT = SIOCPURGENAT;\n+unsigned IOCTL_SIOCSIFINFO_FLAGS = SIOCSIFINFO_FLAGS;\n+unsigned IOCTL_SIOCAADDRCTL_POLICY = SIOCAADDRCTL_POLICY;\n+unsigned IOCTL_SIOCDADDRCTL_POLICY = SIOCDADDRCTL_POLICY;\n+unsigned IOCTL_SMBIOC_OPENSESSION = SMBIOC_OPENSESSION;\n+unsigned IOCTL_SMBIOC_OPENSHARE = SMBIOC_OPENSHARE;\n+unsigned IOCTL_SMBIOC_REQUEST = SMBIOC_REQUEST;\n+unsigned IOCTL_SMBIOC_SETFLAGS = SMBIOC_SETFLAGS;\n+unsigned IOCTL_SMBIOC_LOOKUP = SMBIOC_LOOKUP;\n+unsigned IOCTL_SMBIOC_READ = SMBIOC_READ;\n+unsigned IOCTL_SMBIOC_WRITE = SMBIOC_WRITE;\n+unsigned IOCTL_AGPIOC_INFO = AGPIOC_INFO;\n+unsigned IOCTL_AGPIOC_ACQUIRE = AGPIOC_ACQUIRE;\n+unsigned IOCTL_AGPIOC_RELEASE = AGPIOC_RELEASE;\n+unsigned IOCTL_AGPIOC_SETUP = AGPIOC_SETUP;\n+unsigned IOCTL_AGPIOC_ALLOCATE = AGPIOC_ALLOCATE;\n+unsigned IOCTL_AGPIOC_DEALLOCATE = AGPIOC_DEALLOCATE;\n+unsigned IOCTL_AGPIOC_BIND = AGPIOC_BIND;\n+unsigned IOCTL_AGPIOC_UNBIND = AGPIOC_UNBIND;\n+unsigned IOCTL_AUDIO_GETINFO = AUDIO_GETINFO;\n+unsigned IOCTL_AUDIO_SETINFO = AUDIO_SETINFO;\n+unsigned IOCTL_AUDIO_DRAIN = AUDIO_DRAIN;\n+unsigned IOCTL_AUDIO_FLUSH = AUDIO_FLUSH;\n+unsigned IOCTL_AUDIO_WSEEK = AUDIO_WSEEK;\n+unsigned IOCTL_AUDIO_RERROR = AUDIO_RERROR;\n+unsigned IOCTL_AUDIO_GETDEV = AUDIO_GETDEV;\n+unsigned IOCTL_AUDIO_GETENC = AUDIO_GETENC;\n+unsigned IOCTL_AUDIO_GETFD = AUDIO_GETFD;\n+unsigned IOCTL_AUDIO_SETFD = AUDIO_SETFD;\n+unsigned IOCTL_AUDIO_PERROR = AUDIO_PERROR;\n+unsigned IOCTL_AUDIO_GETIOFFS = AUDIO_GETIOFFS;\n+unsigned IOCTL_AUDIO_GETOOFFS = AUDIO_GETOOFFS;\n+unsigned IOCTL_AUDIO_GETPROPS = AUDIO_GETPROPS;\n+unsigned IOCTL_AUDIO_GETBUFINFO = AUDIO_GETBUFINFO;\n+unsigned IOCTL_AUDIO_SETCHAN = AUDIO_SETCHAN;\n+unsigned IOCTL_AUDIO_GETCHAN = AUDIO_GETCHAN;\n+unsigned IOCTL_AUDIO_MIXER_READ = AUDIO_MIXER_READ;\n+unsigned IOCTL_AUDIO_MIXER_WRITE = AUDIO_MIXER_WRITE;\n+unsigned IOCTL_AUDIO_MIXER_DEVINFO = AUDIO_MIXER_DEVINFO;\n+unsigned IOCTL_ATAIOCCOMMAND = ATAIOCCOMMAND;\n+unsigned IOCTL_ATABUSIOSCAN = ATABUSIOSCAN;\n+unsigned IOCTL_ATABUSIORESET = ATABUSIORESET;\n+unsigned IOCTL_ATABUSIODETACH = ATABUSIODETACH;\n+unsigned IOCTL_CDIOCPLAYTRACKS = CDIOCPLAYTRACKS;\n+unsigned IOCTL_CDIOCPLAYBLOCKS = CDIOCPLAYBLOCKS;\n+unsigned IOCTL_CDIOCREADSUBCHANNEL = CDIOCREADSUBCHANNEL;\n+unsigned IOCTL_CDIOREADTOCHEADER = CDIOREADTOCHEADER;\n+unsigned IOCTL_CDIOREADTOCENTRIES = CDIOREADTOCENTRIES;\n+unsigned IOCTL_CDIOREADMSADDR = CDIOREADMSADDR;\n+unsigned IOCTL_CDIOCSETPATCH = CDIOCSETPATCH;\n+unsigned IOCTL_CDIOCGETVOL = CDIOCGETVOL;\n+unsigned IOCTL_CDIOCSETVOL = CDIOCSETVOL;\n+unsigned IOCTL_CDIOCSETMONO = CDIOCSETMONO;\n+unsigned IOCTL_CDIOCSETSTEREO = CDIOCSETSTEREO;\n+unsigned IOCTL_CDIOCSETMUTE = CDIOCSETMUTE;\n+unsigned IOCTL_CDIOCSETLEFT = CDIOCSETLEFT;\n+unsigned IOCTL_CDIOCSETRIGHT = CDIOCSETRIGHT;\n+unsigned IOCTL_CDIOCSETDEBUG = CDIOCSETDEBUG;\n+unsigned IOCTL_CDIOCCLRDEBUG = CDIOCCLRDEBUG;\n+unsigned IOCTL_CDIOCPAUSE = CDIOCPAUSE;\n+unsigned IOCTL_CDIOCRESUME = CDIOCRESUME;\n+unsigned IOCTL_CDIOCRESET = CDIOCRESET;\n+unsigned IOCTL_CDIOCSTART = CDIOCSTART;\n+unsigned IOCTL_CDIOCSTOP = CDIOCSTOP;\n+unsigned IOCTL_CDIOCEJECT = CDIOCEJECT;\n+unsigned IOCTL_CDIOCALLOW = CDIOCALLOW;\n+unsigned IOCTL_CDIOCPREVENT = CDIOCPREVENT;\n+unsigned IOCTL_CDIOCCLOSE = CDIOCCLOSE;\n+unsigned IOCTL_CDIOCPLAYMSF = CDIOCPLAYMSF;\n+unsigned IOCTL_CDIOCLOADUNLOAD = CDIOCLOADUNLOAD;\n+unsigned IOCTL_CHIOMOVE = CHIOMOVE;\n+unsigned IOCTL_CHIOEXCHANGE = CHIOEXCHANGE;\n+unsigned IOCTL_CHIOPOSITION = CHIOPOSITION;\n+unsigned IOCTL_CHIOGPICKER = CHIOGPICKER;\n+unsigned IOCTL_CHIOSPICKER = CHIOSPICKER;\n+unsigned IOCTL_CHIOGPARAMS = CHIOGPARAMS;\n+unsigned IOCTL_CHIOIELEM = CHIOIELEM;\n+unsigned IOCTL_OCHIOGSTATUS = OCHIOGSTATUS;\n+unsigned IOCTL_CHIOGSTATUS = CHIOGSTATUS;\n+unsigned IOCTL_CHIOSVOLTAG = CHIOSVOLTAG;\n+unsigned IOCTL_CLOCKCTL_SETTIMEOFDAY = CLOCKCTL_SETTIMEOFDAY;\n+unsigned IOCTL_CLOCKCTL_ADJTIME = CLOCKCTL_ADJTIME;\n+unsigned IOCTL_CLOCKCTL_CLOCK_SETTIME = CLOCKCTL_CLOCK_SETTIME;\n+unsigned IOCTL_CLOCKCTL_NTP_ADJTIME = CLOCKCTL_NTP_ADJTIME;\n+unsigned IOCTL_IOC_CPU_SETSTATE = IOC_CPU_SETSTATE;\n+unsigned IOCTL_IOC_CPU_GETSTATE = IOC_CPU_GETSTATE;\n+unsigned IOCTL_IOC_CPU_GETCOUNT = IOC_CPU_GETCOUNT;\n+unsigned IOCTL_IOC_CPU_MAPID = IOC_CPU_MAPID;\n+unsigned IOCTL_IOC_CPU_UCODE_GET_VERSION = IOC_CPU_UCODE_GET_VERSION;\n+unsigned IOCTL_IOC_CPU_UCODE_APPLY = IOC_CPU_UCODE_APPLY;\n+unsigned IOCTL_DIOCGDINFO = DIOCGDINFO;\n+unsigned IOCTL_DIOCSDINFO = DIOCSDINFO;\n+unsigned IOCTL_DIOCWDINFO = DIOCWDINFO;\n+unsigned IOCTL_DIOCRFORMAT = DIOCRFORMAT;\n+unsigned IOCTL_DIOCWFORMAT = DIOCWFORMAT;\n+unsigned IOCTL_DIOCSSTEP = DIOCSSTEP;\n+unsigned IOCTL_DIOCSRETRIES = DIOCSRETRIES;\n+unsigned IOCTL_DIOCKLABEL = DIOCKLABEL;\n+unsigned IOCTL_DIOCWLABEL = DIOCWLABEL;\n+unsigned IOCTL_DIOCSBAD = DIOCSBAD;\n+unsigned IOCTL_DIOCEJECT = DIOCEJECT;\n+unsigned IOCTL_ODIOCEJECT = ODIOCEJECT;\n+unsigned IOCTL_DIOCLOCK = DIOCLOCK;\n+unsigned IOCTL_DIOCGDEFLABEL = DIOCGDEFLABEL;\n+unsigned IOCTL_DIOCCLRLABEL = DIOCCLRLABEL;\n+unsigned IOCTL_DIOCGCACHE = DIOCGCACHE;\n+unsigned IOCTL_DIOCSCACHE = DIOCSCACHE;\n+unsigned IOCTL_DIOCCACHESYNC = DIOCCACHESYNC;\n+unsigned IOCTL_DIOCBSLIST = DIOCBSLIST;\n+unsigned IOCTL_DIOCBSFLUSH = DIOCBSFLUSH;\n+unsigned IOCTL_DIOCAWEDGE = DIOCAWEDGE;\n+unsigned IOCTL_DIOCGWEDGEINFO = DIOCGWEDGEINFO;\n+unsigned IOCTL_DIOCDWEDGE = DIOCDWEDGE;\n+unsigned IOCTL_DIOCLWEDGES = DIOCLWEDGES;\n+unsigned IOCTL_DIOCGSTRATEGY = DIOCGSTRATEGY;\n+unsigned IOCTL_DIOCSSTRATEGY = DIOCSSTRATEGY;\n+unsigned IOCTL_DIOCGDISKINFO = DIOCGDISKINFO;\n+unsigned IOCTL_DIOCTUR = DIOCTUR;\n+unsigned IOCTL_DIOCMWEDGES = DIOCMWEDGES;\n+unsigned IOCTL_DIOCGSECTORSIZE = DIOCGSECTORSIZE;\n+unsigned IOCTL_DIOCGMEDIASIZE = DIOCGMEDIASIZE;\n+unsigned IOCTL_DRVDETACHDEV = DRVDETACHDEV;\n+unsigned IOCTL_DRVRESCANBUS = DRVRESCANBUS;\n+unsigned IOCTL_DRVCTLCOMMAND = DRVCTLCOMMAND;\n+unsigned IOCTL_DRVRESUMEDEV = DRVRESUMEDEV;\n+unsigned IOCTL_DRVLISTDEV = DRVLISTDEV;\n+unsigned IOCTL_DRVGETEVENT = DRVGETEVENT;\n+unsigned IOCTL_DRVSUSPENDDEV = DRVSUSPENDDEV;\n+unsigned IOCTL_DVD_READ_STRUCT = DVD_READ_STRUCT;\n+unsigned IOCTL_DVD_WRITE_STRUCT = DVD_WRITE_STRUCT;\n+unsigned IOCTL_DVD_AUTH = DVD_AUTH;\n+unsigned IOCTL_ENVSYS_GETDICTIONARY = ENVSYS_GETDICTIONARY;\n+unsigned IOCTL_ENVSYS_SETDICTIONARY = ENVSYS_SETDICTIONARY;\n+unsigned IOCTL_ENVSYS_REMOVEPROPS = ENVSYS_REMOVEPROPS;\n+unsigned IOCTL_ENVSYS_GTREDATA = ENVSYS_GTREDATA;\n+unsigned IOCTL_ENVSYS_GTREINFO = ENVSYS_GTREINFO;\n+unsigned IOCTL_KFILTER_BYFILTER = KFILTER_BYFILTER;\n+unsigned IOCTL_KFILTER_BYNAME = KFILTER_BYNAME;\n+unsigned IOCTL_FDIOCGETOPTS = FDIOCGETOPTS;\n+unsigned IOCTL_FDIOCSETOPTS = FDIOCSETOPTS;\n+unsigned IOCTL_FDIOCSETFORMAT = FDIOCSETFORMAT;\n+unsigned IOCTL_FDIOCGETFORMAT = FDIOCGETFORMAT;\n+unsigned IOCTL_FDIOCFORMAT_TRACK = FDIOCFORMAT_TRACK;\n unsigned IOCTL_FIOCLEX = FIOCLEX;\n-unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n-unsigned IOCTL_FIONBIO = FIONBIO;\n unsigned IOCTL_FIONCLEX = FIONCLEX;\n+unsigned IOCTL_FIONREAD = FIONREAD;\n+unsigned IOCTL_FIONBIO = FIONBIO;\n+unsigned IOCTL_FIOASYNC = FIOASYNC;\n unsigned IOCTL_FIOSETOWN = FIOSETOWN;\n-unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n+unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n+unsigned IOCTL_OFIOGETBMAP = OFIOGETBMAP;\n+unsigned IOCTL_FIOGETBMAP = FIOGETBMAP;\n+unsigned IOCTL_FIONWRITE = FIONWRITE;\n+unsigned IOCTL_FIONSPACE = FIONSPACE;\n+unsigned IOCTL_GPIOINFO = GPIOINFO;\n+unsigned IOCTL_GPIOSET = GPIOSET;\n+unsigned IOCTL_GPIOUNSET = GPIOUNSET;\n+unsigned IOCTL_GPIOREAD = GPIOREAD;\n+unsigned IOCTL_GPIOWRITE = GPIOWRITE;\n+unsigned IOCTL_GPIOTOGGLE = GPIOTOGGLE;\n+unsigned IOCTL_GPIOATTACH = GPIOATTACH;\n+unsigned IOCTL_PTIOCNETBSD = PTIOCNETBSD;\n+unsigned IOCTL_PTIOCSUNOS = PTIOCSUNOS;\n+unsigned IOCTL_PTIOCLINUX = PTIOCLINUX;\n+unsigned IOCTL_PTIOCFREEBSD = PTIOCFREEBSD;\n+unsigned IOCTL_PTIOCULTRIX = PTIOCULTRIX;\n+unsigned IOCTL_TIOCHPCL = TIOCHPCL;\n+unsigned IOCTL_TIOCGETP = TIOCGETP;\n+unsigned IOCTL_TIOCSETP = TIOCSETP;\n+unsigned IOCTL_TIOCSETN = TIOCSETN;\n+unsigned IOCTL_TIOCSETC = TIOCSETC;\n+unsigned IOCTL_TIOCGETC = TIOCGETC;\n+unsigned IOCTL_TIOCLBIS = TIOCLBIS;\n+unsigned IOCTL_TIOCLBIC = TIOCLBIC;\n+unsigned IOCTL_TIOCLSET = TIOCLSET;\n+unsigned IOCTL_TIOCLGET = TIOCLGET;\n+unsigned IOCTL_TIOCSLTC = TIOCSLTC;\n+unsigned IOCTL_TIOCGLTC = TIOCGLTC;\n+unsigned IOCTL_OTIOCCONS = OTIOCCONS;\n+unsigned IOCTL_JOY_SETTIMEOUT = JOY_SETTIMEOUT;\n+unsigned IOCTL_JOY_GETTIMEOUT = JOY_GETTIMEOUT;\n+unsigned IOCTL_JOY_SET_X_OFFSET = JOY_SET_X_OFFSET;\n+unsigned IOCTL_JOY_SET_Y_OFFSET = JOY_SET_Y_OFFSET;\n+unsigned IOCTL_JOY_GET_X_OFFSET = JOY_GET_X_OFFSET;\n+unsigned IOCTL_JOY_GET_Y_OFFSET = JOY_GET_Y_OFFSET;\n+unsigned IOCTL_OKIOCGSYMBOL = OKIOCGSYMBOL;\n+unsigned IOCTL_OKIOCGVALUE = OKIOCGVALUE;\n+unsigned IOCTL_KIOCGSIZE = KIOCGSIZE;\n+unsigned IOCTL_KIOCGVALUE = KIOCGVALUE;\n+unsigned IOCTL_KIOCGSYMBOL = KIOCGSYMBOL;\n+unsigned IOCTL_LUAINFO = LUAINFO;\n+unsigned IOCTL_LUACREATE = LUACREATE;\n+unsigned IOCTL_LUADESTROY = LUADESTROY;\n+unsigned IOCTL_LUAREQUIRE = LUAREQUIRE;\n+unsigned IOCTL_LUALOAD = LUALOAD;\n+unsigned IOCTL_MIDI_PRETIME = MIDI_PRETIME;\n+unsigned IOCTL_MIDI_MPUMODE = MIDI_MPUMODE;\n+unsigned IOCTL_MIDI_MPUCMD = MIDI_MPUCMD;\n+unsigned IOCTL_SEQUENCER_RESET = SEQUENCER_RESET;\n+unsigned IOCTL_SEQUENCER_SYNC = SEQUENCER_SYNC;\n+unsigned IOCTL_SEQUENCER_INFO = SEQUENCER_INFO;\n+unsigned IOCTL_SEQUENCER_CTRLRATE = SEQUENCER_CTRLRATE;\n+unsigned IOCTL_SEQUENCER_GETOUTCOUNT = SEQUENCER_GETOUTCOUNT;\n+unsigned IOCTL_SEQUENCER_GETINCOUNT = SEQUENCER_GETINCOUNT;\n+unsigned IOCTL_SEQUENCER_RESETSAMPLES = SEQUENCER_RESETSAMPLES;\n+unsigned IOCTL_SEQUENCER_NRSYNTHS = SEQUENCER_NRSYNTHS;\n+unsigned IOCTL_SEQUENCER_NRMIDIS = SEQUENCER_NRMIDIS;\n+unsigned IOCTL_SEQUENCER_THRESHOLD = SEQUENCER_THRESHOLD;\n+unsigned IOCTL_SEQUENCER_MEMAVL = SEQUENCER_MEMAVL;\n+unsigned IOCTL_SEQUENCER_PANIC = SEQUENCER_PANIC;\n+unsigned IOCTL_SEQUENCER_OUTOFBAND = SEQUENCER_OUTOFBAND;\n+unsigned IOCTL_SEQUENCER_GETTIME = SEQUENCER_GETTIME;\n+unsigned IOCTL_SEQUENCER_TMR_TIMEBASE = SEQUENCER_TMR_TIMEBASE;\n+unsigned IOCTL_SEQUENCER_TMR_START = SEQUENCER_TMR_START;\n+unsigned IOCTL_SEQUENCER_TMR_STOP = SEQUENCER_TMR_STOP;\n+unsigned IOCTL_SEQUENCER_TMR_CONTINUE = SEQUENCER_TMR_CONTINUE;\n+unsigned IOCTL_SEQUENCER_TMR_TEMPO = SEQUENCER_TMR_TEMPO;\n+unsigned IOCTL_SEQUENCER_TMR_SOURCE = SEQUENCER_TMR_SOURCE;\n+unsigned IOCTL_SEQUENCER_TMR_METRONOME = SEQUENCER_TMR_METRONOME;\n+unsigned IOCTL_SEQUENCER_TMR_SELECT = SEQUENCER_TMR_SELECT;\n+unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n+unsigned IOCTL_MTIOCGET = MTIOCGET;\n+unsigned IOCTL_MTIOCIEOT = MTIOCIEOT;\n+unsigned IOCTL_MTIOCEEOT = MTIOCEEOT;\n+unsigned IOCTL_MTIOCRDSPOS = MTIOCRDSPOS;\n+unsigned IOCTL_MTIOCRDHPOS = MTIOCRDHPOS;\n+unsigned IOCTL_MTIOCSLOCATE = MTIOCSLOCATE;\n+unsigned IOCTL_MTIOCHLOCATE = MTIOCHLOCATE;\n+unsigned IOCTL_POWER_EVENT_RECVDICT = POWER_EVENT_RECVDICT;\n+unsigned IOCTL_POWER_IOC_GET_TYPE = POWER_IOC_GET_TYPE;\n+unsigned IOCTL_POWER_IOC_GET_TYPE_WITH_LOSSAGE =\n+    POWER_IOC_GET_TYPE_WITH_LOSSAGE;\n+unsigned IOCTL_RIOCGINFO = RIOCGINFO;\n+unsigned IOCTL_RIOCSINFO = RIOCSINFO;\n+unsigned IOCTL_RIOCSSRCH = RIOCSSRCH;\n+unsigned IOCTL_RNDGETENTCNT = RNDGETENTCNT;\n+unsigned IOCTL_RNDGETSRCNUM = RNDGETSRCNUM;\n+unsigned IOCTL_RNDGETSRCNAME = RNDGETSRCNAME;\n+unsigned IOCTL_RNDCTL = RNDCTL;\n+unsigned IOCTL_RNDADDDATA = RNDADDDATA;\n+unsigned IOCTL_RNDGETPOOLSTAT = RNDGETPOOLSTAT;\n+unsigned IOCTL_RNDGETESTNUM = RNDGETESTNUM;\n+unsigned IOCTL_RNDGETESTNAME = RNDGETESTNAME;\n+unsigned IOCTL_SCIOCGET = SCIOCGET;\n+unsigned IOCTL_SCIOCSET = SCIOCSET;\n+unsigned IOCTL_SCIOCRESTART = SCIOCRESTART;\n+unsigned IOCTL_SCIOC_USE_ADF = SCIOC_USE_ADF;\n+unsigned IOCTL_SCIOCCOMMAND = SCIOCCOMMAND;\n+unsigned IOCTL_SCIOCDEBUG = SCIOCDEBUG;\n+unsigned IOCTL_SCIOCIDENTIFY = SCIOCIDENTIFY;\n+unsigned IOCTL_OSCIOCIDENTIFY = OSCIOCIDENTIFY;\n+unsigned IOCTL_SCIOCDECONFIG = SCIOCDECONFIG;\n+unsigned IOCTL_SCIOCRECONFIG = SCIOCRECONFIG;\n+unsigned IOCTL_SCIOCRESET = SCIOCRESET;\n+unsigned IOCTL_SCBUSIOSCAN = SCBUSIOSCAN;\n+unsigned IOCTL_SCBUSIORESET = SCBUSIORESET;\n+unsigned IOCTL_SCBUSIODETACH = SCBUSIODETACH;\n+unsigned IOCTL_SCBUSACCEL = SCBUSACCEL;\n+unsigned IOCTL_SCBUSIOLLSCAN = SCBUSIOLLSCAN;\n+unsigned IOCTL_SIOCSHIWAT = SIOCSHIWAT;\n+unsigned IOCTL_SIOCGHIWAT = SIOCGHIWAT;\n+unsigned IOCTL_SIOCSLOWAT = SIOCSLOWAT;\n+unsigned IOCTL_SIOCGLOWAT = SIOCGLOWAT;\n unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n-unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n-unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n-unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n-unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n-unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n-unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n-unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n-unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n-unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n+unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n+unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n+unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n-unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n+unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n unsigned IOCTL_SIOCSIFDSTADDR = SIOCSIFDSTADDR;\n+unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n unsigned IOCTL_SIOCSIFFLAGS = SIOCSIFFLAGS;\n+unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n+unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n+unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n+unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n+unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n+unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n+unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n unsigned IOCTL_SIOCSIFMETRIC = SIOCSIFMETRIC;\n+unsigned IOCTL_SIOCDIFADDR = SIOCDIFADDR;\n+unsigned IOCTL_SIOCAIFADDR = SIOCAIFADDR;\n+unsigned IOCTL_SIOCGIFALIAS = SIOCGIFALIAS;\n+unsigned IOCTL_SIOCGIFAFLAG_IN = SIOCGIFAFLAG_IN;\n+unsigned IOCTL_SIOCALIFADDR = SIOCALIFADDR;\n+unsigned IOCTL_SIOCGLIFADDR = SIOCGLIFADDR;\n+unsigned IOCTL_SIOCDLIFADDR = SIOCDLIFADDR;\n+unsigned IOCTL_SIOCSIFADDRPREF = SIOCSIFADDRPREF;\n+unsigned IOCTL_SIOCGIFADDRPREF = SIOCGIFADDRPREF;\n+unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n+unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n+unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n+unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n+unsigned IOCTL_SIOCSIFMEDIA = SIOCSIFMEDIA;\n+unsigned IOCTL_SIOCGIFMEDIA = SIOCGIFMEDIA;\n+unsigned IOCTL_SIOCSIFGENERIC = SIOCSIFGENERIC;\n+unsigned IOCTL_SIOCGIFGENERIC = SIOCGIFGENERIC;\n+unsigned IOCTL_SIOCSIFPHYADDR = SIOCSIFPHYADDR;\n+unsigned IOCTL_SIOCGIFPSRCADDR = SIOCGIFPSRCADDR;\n+unsigned IOCTL_SIOCGIFPDSTADDR = SIOCGIFPDSTADDR;\n+unsigned IOCTL_SIOCDIFPHYADDR = SIOCDIFPHYADDR;\n+unsigned IOCTL_SIOCSLIFPHYADDR = SIOCSLIFPHYADDR;\n+unsigned IOCTL_SIOCGLIFPHYADDR = SIOCGLIFPHYADDR;\n unsigned IOCTL_SIOCSIFMTU = SIOCSIFMTU;\n-unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n-unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n-unsigned IOCTL_TIOCCONS = TIOCCONS;\n+unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n+unsigned IOCTL_SIOCSDRVSPEC = SIOCSDRVSPEC;\n+unsigned IOCTL_SIOCGDRVSPEC = SIOCGDRVSPEC;\n+unsigned IOCTL_SIOCIFCREATE = SIOCIFCREATE;\n+unsigned IOCTL_SIOCIFDESTROY = SIOCIFDESTROY;\n+unsigned IOCTL_SIOCIFGCLONERS = SIOCIFGCLONERS;\n+unsigned IOCTL_SIOCGIFDLT = SIOCGIFDLT;\n+unsigned IOCTL_SIOCGIFCAP = SIOCGIFCAP;\n+unsigned IOCTL_SIOCSIFCAP = SIOCSIFCAP;\n+unsigned IOCTL_SIOCSVH = SIOCSVH;\n+unsigned IOCTL_SIOCGVH = SIOCGVH;\n+unsigned IOCTL_SIOCINITIFADDR = SIOCINITIFADDR;\n+unsigned IOCTL_SIOCGIFDATA = SIOCGIFDATA;\n+unsigned IOCTL_SIOCZIFDATA = SIOCZIFDATA;\n+unsigned IOCTL_SIOCGLINKSTR = SIOCGLINKSTR;\n+unsigned IOCTL_SIOCSLINKSTR = SIOCSLINKSTR;\n+unsigned IOCTL_SIOCGETHERCAP = SIOCGETHERCAP;\n+unsigned IOCTL_SIOCGIFINDEX = SIOCGIFINDEX;\n+unsigned IOCTL_SIOCSETPFSYNC = SIOCSETPFSYNC;\n+unsigned IOCTL_SIOCGETPFSYNC = SIOCGETPFSYNC;\n+unsigned IOCTL_PPS_IOC_CREATE = PPS_IOC_CREATE;\n+unsigned IOCTL_PPS_IOC_DESTROY = PPS_IOC_DESTROY;\n+unsigned IOCTL_PPS_IOC_SETPARAMS = PPS_IOC_SETPARAMS;\n+unsigned IOCTL_PPS_IOC_GETPARAMS = PPS_IOC_GETPARAMS;\n+unsigned IOCTL_PPS_IOC_GETCAP = PPS_IOC_GETCAP;\n+unsigned IOCTL_PPS_IOC_FETCH = PPS_IOC_FETCH;\n+unsigned IOCTL_PPS_IOC_KCBIND = PPS_IOC_KCBIND;\n unsigned IOCTL_TIOCEXCL = TIOCEXCL;\n-unsigned IOCTL_TIOCGETD = TIOCGETD;\n-unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n-unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n-unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n-unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n-unsigned IOCTL_TIOCMGET = TIOCMGET;\n-unsigned IOCTL_TIOCMSET = TIOCMSET;\n-unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n unsigned IOCTL_TIOCNXCL = TIOCNXCL;\n-unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n-unsigned IOCTL_TIOCPKT = TIOCPKT;\n-unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n+unsigned IOCTL_TIOCFLUSH = TIOCFLUSH;\n+unsigned IOCTL_TIOCGETA = TIOCGETA;\n+unsigned IOCTL_TIOCSETA = TIOCSETA;\n+unsigned IOCTL_TIOCSETAW = TIOCSETAW;\n+unsigned IOCTL_TIOCSETAF = TIOCSETAF;\n+unsigned IOCTL_TIOCGETD = TIOCGETD;\n unsigned IOCTL_TIOCSETD = TIOCSETD;\n+unsigned IOCTL_TIOCGLINED = TIOCGLINED;\n+unsigned IOCTL_TIOCSLINED = TIOCSLINED;\n+unsigned IOCTL_TIOCSBRK = TIOCSBRK;\n+unsigned IOCTL_TIOCCBRK = TIOCCBRK;\n+unsigned IOCTL_TIOCSDTR = TIOCSDTR;\n+unsigned IOCTL_TIOCCDTR = TIOCCDTR;\n+unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n+unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n unsigned IOCTL_TIOCSTI = TIOCSTI;\n+unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n+unsigned IOCTL_TIOCPKT = TIOCPKT;\n+unsigned IOCTL_TIOCSTOP = TIOCSTOP;\n+unsigned IOCTL_TIOCSTART = TIOCSTART;\n+unsigned IOCTL_TIOCMSET = TIOCMSET;\n+unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n+unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n+unsigned IOCTL_TIOCMGET = TIOCMGET;\n+unsigned IOCTL_TIOCREMOTE = TIOCREMOTE;\n+unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n-unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n-unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n+unsigned IOCTL_TIOCUCNTL = TIOCUCNTL;\n+unsigned IOCTL_TIOCSTAT = TIOCSTAT;\n+unsigned IOCTL_TIOCGSID = TIOCGSID;\n+unsigned IOCTL_TIOCCONS = TIOCCONS;\n+unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n+unsigned IOCTL_TIOCEXT = TIOCEXT;\n+unsigned IOCTL_TIOCSIG = TIOCSIG;\n+unsigned IOCTL_TIOCDRAIN = TIOCDRAIN;\n+unsigned IOCTL_TIOCGFLAGS = TIOCGFLAGS;\n+unsigned IOCTL_TIOCSFLAGS = TIOCSFLAGS;\n+unsigned IOCTL_TIOCDCDTIMESTAMP = TIOCDCDTIMESTAMP;\n+unsigned IOCTL_TIOCRCVFRAME = TIOCRCVFRAME;\n+unsigned IOCTL_TIOCXMTFRAME = TIOCXMTFRAME;\n+unsigned IOCTL_TIOCPTMGET = TIOCPTMGET;\n+unsigned IOCTL_TIOCGRANTPT = TIOCGRANTPT;\n+unsigned IOCTL_TIOCPTSNAME = TIOCPTSNAME;\n+unsigned IOCTL_TIOCSQSIZE = TIOCSQSIZE;\n+unsigned IOCTL_TIOCGQSIZE = TIOCGQSIZE;\n+unsigned IOCTL_VERIEXEC_LOAD = VERIEXEC_LOAD;\n+unsigned IOCTL_VERIEXEC_TABLESIZE = VERIEXEC_TABLESIZE;\n+unsigned IOCTL_VERIEXEC_DELETE = VERIEXEC_DELETE;\n+unsigned IOCTL_VERIEXEC_QUERY = VERIEXEC_QUERY;\n+unsigned IOCTL_VERIEXEC_DUMP = VERIEXEC_DUMP;\n+unsigned IOCTL_VERIEXEC_FLUSH = VERIEXEC_FLUSH;\n+unsigned IOCTL_VIDIOC_QUERYCAP = VIDIOC_QUERYCAP;\n+unsigned IOCTL_VIDIOC_RESERVED = VIDIOC_RESERVED;\n+unsigned IOCTL_VIDIOC_ENUM_FMT = VIDIOC_ENUM_FMT;\n+unsigned IOCTL_VIDIOC_G_FMT = VIDIOC_G_FMT;\n+unsigned IOCTL_VIDIOC_S_FMT = VIDIOC_S_FMT;\n+unsigned IOCTL_VIDIOC_REQBUFS = VIDIOC_REQBUFS;\n+unsigned IOCTL_VIDIOC_QUERYBUF = VIDIOC_QUERYBUF;\n+unsigned IOCTL_VIDIOC_G_FBUF = VIDIOC_G_FBUF;\n+unsigned IOCTL_VIDIOC_S_FBUF = VIDIOC_S_FBUF;\n+unsigned IOCTL_VIDIOC_OVERLAY = VIDIOC_OVERLAY;\n+unsigned IOCTL_VIDIOC_QBUF = VIDIOC_QBUF;\n+unsigned IOCTL_VIDIOC_DQBUF = VIDIOC_DQBUF;\n+unsigned IOCTL_VIDIOC_STREAMON = VIDIOC_STREAMON;\n+unsigned IOCTL_VIDIOC_STREAMOFF = VIDIOC_STREAMOFF;\n+unsigned IOCTL_VIDIOC_G_PARM = VIDIOC_G_PARM;\n+unsigned IOCTL_VIDIOC_S_PARM = VIDIOC_S_PARM;\n+unsigned IOCTL_VIDIOC_G_STD = VIDIOC_G_STD;\n+unsigned IOCTL_VIDIOC_S_STD = VIDIOC_S_STD;\n+unsigned IOCTL_VIDIOC_ENUMSTD = VIDIOC_ENUMSTD;\n+unsigned IOCTL_VIDIOC_ENUMINPUT = VIDIOC_ENUMINPUT;\n+unsigned IOCTL_VIDIOC_G_CTRL = VIDIOC_G_CTRL;\n+unsigned IOCTL_VIDIOC_S_CTRL = VIDIOC_S_CTRL;\n+unsigned IOCTL_VIDIOC_G_TUNER = VIDIOC_G_TUNER;\n+unsigned IOCTL_VIDIOC_S_TUNER = VIDIOC_S_TUNER;\n+unsigned IOCTL_VIDIOC_G_AUDIO = VIDIOC_G_AUDIO;\n+unsigned IOCTL_VIDIOC_S_AUDIO = VIDIOC_S_AUDIO;\n+unsigned IOCTL_VIDIOC_QUERYCTRL = VIDIOC_QUERYCTRL;\n+unsigned IOCTL_VIDIOC_QUERYMENU = VIDIOC_QUERYMENU;\n+unsigned IOCTL_VIDIOC_G_INPUT = VIDIOC_G_INPUT;\n+unsigned IOCTL_VIDIOC_S_INPUT = VIDIOC_S_INPUT;\n+unsigned IOCTL_VIDIOC_G_OUTPUT = VIDIOC_G_OUTPUT;\n+unsigned IOCTL_VIDIOC_S_OUTPUT = VIDIOC_S_OUTPUT;\n+unsigned IOCTL_VIDIOC_ENUMOUTPUT = VIDIOC_ENUMOUTPUT;\n+unsigned IOCTL_VIDIOC_G_AUDOUT = VIDIOC_G_AUDOUT;\n+unsigned IOCTL_VIDIOC_S_AUDOUT = VIDIOC_S_AUDOUT;\n+unsigned IOCTL_VIDIOC_G_MODULATOR = VIDIOC_G_MODULATOR;\n+unsigned IOCTL_VIDIOC_S_MODULATOR = VIDIOC_S_MODULATOR;\n+unsigned IOCTL_VIDIOC_G_FREQUENCY = VIDIOC_G_FREQUENCY;\n+unsigned IOCTL_VIDIOC_S_FREQUENCY = VIDIOC_S_FREQUENCY;\n+unsigned IOCTL_VIDIOC_CROPCAP = VIDIOC_CROPCAP;\n+unsigned IOCTL_VIDIOC_G_CROP = VIDIOC_G_CROP;\n+unsigned IOCTL_VIDIOC_S_CROP = VIDIOC_S_CROP;\n+unsigned IOCTL_VIDIOC_G_JPEGCOMP = VIDIOC_G_JPEGCOMP;\n+unsigned IOCTL_VIDIOC_S_JPEGCOMP = VIDIOC_S_JPEGCOMP;\n+unsigned IOCTL_VIDIOC_QUERYSTD = VIDIOC_QUERYSTD;\n+unsigned IOCTL_VIDIOC_TRY_FMT = VIDIOC_TRY_FMT;\n+unsigned IOCTL_VIDIOC_ENUMAUDIO = VIDIOC_ENUMAUDIO;\n+unsigned IOCTL_VIDIOC_ENUMAUDOUT = VIDIOC_ENUMAUDOUT;\n+unsigned IOCTL_VIDIOC_G_PRIORITY = VIDIOC_G_PRIORITY;\n+unsigned IOCTL_VIDIOC_S_PRIORITY = VIDIOC_S_PRIORITY;\n+unsigned IOCTL_VIDIOC_ENUM_FRAMESIZES = VIDIOC_ENUM_FRAMESIZES;\n+unsigned IOCTL_VIDIOC_ENUM_FRAMEINTERVALS = VIDIOC_ENUM_FRAMEINTERVALS;\n+unsigned IOCTL_WDOGIOC_GMODE = WDOGIOC_GMODE;\n+unsigned IOCTL_WDOGIOC_SMODE = WDOGIOC_SMODE;\n+unsigned IOCTL_WDOGIOC_WHICH = WDOGIOC_WHICH;\n+unsigned IOCTL_WDOGIOC_TICKLE = WDOGIOC_TICKLE;\n+unsigned IOCTL_WDOGIOC_GTICKLER = WDOGIOC_GTICKLER;\n+unsigned IOCTL_WDOGIOC_GWDOGS = WDOGIOC_GWDOGS;\n+unsigned IOCTL_SNDCTL_DSP_RESET = SNDCTL_DSP_RESET;\n+unsigned IOCTL_SNDCTL_DSP_SYNC = SNDCTL_DSP_SYNC;\n+unsigned IOCTL_SNDCTL_DSP_SPEED = SNDCTL_DSP_SPEED;\n+unsigned IOCTL_SOUND_PCM_READ_RATE = SOUND_PCM_READ_RATE;\n+unsigned IOCTL_SNDCTL_DSP_STEREO = SNDCTL_DSP_STEREO;\n+unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n+unsigned IOCTL_SNDCTL_DSP_SETFMT = SNDCTL_DSP_SETFMT;\n+unsigned IOCTL_SOUND_PCM_READ_BITS = SOUND_PCM_READ_BITS;\n+unsigned IOCTL_SNDCTL_DSP_CHANNELS = SNDCTL_DSP_CHANNELS;\n+unsigned IOCTL_SOUND_PCM_READ_CHANNELS = SOUND_PCM_READ_CHANNELS;\n+unsigned IOCTL_SOUND_PCM_WRITE_FILTER = SOUND_PCM_WRITE_FILTER;\n+unsigned IOCTL_SOUND_PCM_READ_FILTER = SOUND_PCM_READ_FILTER;\n+unsigned IOCTL_SNDCTL_DSP_POST = SNDCTL_DSP_POST;\n+unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE = SNDCTL_DSP_SUBDIVIDE;\n+unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT = SNDCTL_DSP_SETFRAGMENT;\n+unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n+unsigned IOCTL_SNDCTL_DSP_GETOSPACE = SNDCTL_DSP_GETOSPACE;\n+unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n+unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;\n+unsigned IOCTL_SNDCTL_DSP_GETCAPS = SNDCTL_DSP_GETCAPS;\n+unsigned IOCTL_SNDCTL_DSP_GETTRIGGER = SNDCTL_DSP_GETTRIGGER;\n+unsigned IOCTL_SNDCTL_DSP_SETTRIGGER = SNDCTL_DSP_SETTRIGGER;\n+unsigned IOCTL_SNDCTL_DSP_GETIPTR = SNDCTL_DSP_GETIPTR;\n+unsigned IOCTL_SNDCTL_DSP_GETOPTR = SNDCTL_DSP_GETOPTR;\n+unsigned IOCTL_SNDCTL_DSP_MAPINBUF = SNDCTL_DSP_MAPINBUF;\n+unsigned IOCTL_SNDCTL_DSP_MAPOUTBUF = SNDCTL_DSP_MAPOUTBUF;\n+unsigned IOCTL_SNDCTL_DSP_SETSYNCRO = SNDCTL_DSP_SETSYNCRO;\n+unsigned IOCTL_SNDCTL_DSP_SETDUPLEX = SNDCTL_DSP_SETDUPLEX;\n+unsigned IOCTL_SNDCTL_DSP_PROFILE = SNDCTL_DSP_PROFILE;\n+unsigned IOCTL_SNDCTL_DSP_GETODELAY = SNDCTL_DSP_GETODELAY;\n+unsigned IOCTL_SOUND_MIXER_INFO = SOUND_MIXER_INFO;\n+unsigned IOCTL_SOUND_OLD_MIXER_INFO = SOUND_OLD_MIXER_INFO;\n+unsigned IOCTL_OSS_GETVERSION = OSS_GETVERSION;\n+unsigned IOCTL_SNDCTL_SYSINFO = SNDCTL_SYSINFO;\n+unsigned IOCTL_SNDCTL_AUDIOINFO = SNDCTL_AUDIOINFO;\n+unsigned IOCTL_SNDCTL_ENGINEINFO = SNDCTL_ENGINEINFO;\n+unsigned IOCTL_SNDCTL_DSP_GETPLAYVOL = SNDCTL_DSP_GETPLAYVOL;\n+unsigned IOCTL_SNDCTL_DSP_SETPLAYVOL = SNDCTL_DSP_SETPLAYVOL;\n+unsigned IOCTL_SNDCTL_DSP_GETRECVOL = SNDCTL_DSP_GETRECVOL;\n+unsigned IOCTL_SNDCTL_DSP_SETRECVOL = SNDCTL_DSP_SETRECVOL;\n+unsigned IOCTL_SNDCTL_DSP_SKIP = SNDCTL_DSP_SKIP;\n+unsigned IOCTL_SNDCTL_DSP_SILENCE = SNDCTL_DSP_SILENCE;\n \n const int si_SEGV_MAPERR = SEGV_MAPERR;\n const int si_SEGV_ACCERR = SEGV_ACCERR;"}, {"sha": "eddfc124f0751069c4814bd75285337c2b410154", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.h", "status": "modified", "additions": 1826, "deletions": 174, "changes": 2000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -23,10 +23,10 @@\n \n #if defined(__x86_64__)\n #define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 608)\n+  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 312)\n #elif defined(__i386__)\n #define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 324)\n+  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 164)\n #endif\n \n namespace __sanitizer {\n@@ -36,6 +36,7 @@ extern unsigned struct_rusage_sz;\n extern unsigned siginfo_t_sz;\n extern unsigned struct_itimerval_sz;\n extern unsigned pthread_t_sz;\n+extern unsigned pthread_mutex_t_sz;\n extern unsigned pthread_cond_t_sz;\n extern unsigned pid_t_sz;\n extern unsigned timeval_sz;\n@@ -54,33 +55,36 @@ extern unsigned ucontext_t_sz;\n extern unsigned struct_rlimit_sz;\n extern unsigned struct_utimbuf_sz;\n extern unsigned struct_timespec_sz;\n+extern unsigned struct_sembuf_sz;\n \n-struct __sanitizer_iocb {\n+extern unsigned struct_kevent_sz;\n+\n+union __sanitizer_sigval {\n+  int sival_int;\n+  uptr sival_ptr;\n+};\n+\n+struct __sanitizer_sigevent {\n+  int sigev_notify;\n+  int sigev_signo;\n+  union __sanitizer_sigval sigev_value;\n+  uptr sigev_notify_function;\n+  uptr sigev_notify_attributes;\n+};\n+\n+struct __sanitizer_aiocb {\n   u64 aio_offset;\n   uptr aio_buf;\n-  long aio_nbytes;\n-  u32 aio_fildes;\n-  u32 aio_lio_opcode;\n-  long aio_reqprio;\n-#if SANITIZER_WORDSIZE == 64\n-  u8 aio_sigevent[32];\n-#else\n-  u8 aio_sigevent[20];\n-#endif\n-  u32 _state;\n-  u32 _errno;\n+  uptr aio_nbytes;\n+  int aio_fildes;\n+  int aio_lio_opcode;\n+  int aio_reqprio;\n+  struct __sanitizer_sigevent aio_sigevent;\n+  int _state;\n+  int _errno;\n   long _retval;\n };\n \n-struct __sanitizer___sysctl_args {\n-  int *name;\n-  int nlen;\n-  void *oldval;\n-  uptr *oldlenp;\n-  void *newval;\n-  uptr newlen;\n-};\n-\n struct __sanitizer_sem_t {\n   uptr data[5];\n };\n@@ -107,6 +111,19 @@ struct __sanitizer_shmid_ds {\n   void *_shm_internal;\n };\n \n+struct __sanitizer_protoent {\n+  char *p_name;\n+  char **p_aliases;\n+  int p_proto;\n+};\n+\n+struct __sanitizer_netent {\n+  char *n_name;\n+  char **n_aliases;\n+  int n_addrtype;\n+  u32 n_net;\n+};\n+\n extern unsigned struct_msqid_ds_sz;\n extern unsigned struct_mq_attr_sz;\n extern unsigned struct_timex_sz;\n@@ -128,9 +145,27 @@ struct __sanitizer_ifaddrs {\n   unsigned int ifa_addrflags;\n };\n \n+typedef unsigned int __sanitizer_socklen_t;\n+\n typedef unsigned __sanitizer_pthread_key_t;\n \n typedef long long __sanitizer_time_t;\n+typedef int __sanitizer_suseconds_t;\n+\n+struct __sanitizer_timeval {\n+  __sanitizer_time_t tv_sec;\n+  __sanitizer_suseconds_t tv_usec;\n+};\n+\n+struct __sanitizer_itimerval {\n+  struct __sanitizer_timeval it_interval;\n+  struct __sanitizer_timeval it_value;\n+};\n+\n+struct __sanitizer_timespec {\n+  __sanitizer_time_t tv_sec;\n+  long tv_nsec;\n+};\n \n struct __sanitizer_passwd {\n   char *pw_name;\n@@ -186,6 +221,12 @@ struct __sanitizer_msghdr {\n   unsigned msg_controllen;\n   int msg_flags;\n };\n+\n+struct __sanitizer_mmsghdr {\n+  struct __sanitizer_msghdr msg_hdr;\n+  unsigned int msg_len;\n+};\n+\n struct __sanitizer_cmsghdr {\n   unsigned cmsg_len;\n   int cmsg_level;\n@@ -219,15 +260,41 @@ struct __sanitizer_sigset_t {\n   unsigned int __bits[4];\n };\n \n+struct __sanitizer_siginfo {\n+  // The size is determined by looking at sizeof of real siginfo_t on linux.\n+  u64 opaque[128 / sizeof(u64)];\n+};\n+\n+using __sanitizer_sighandler_ptr = void (*)(int sig);\n+using __sanitizer_sigactionhandler_ptr = void (*)(int sig,\n+                                                  __sanitizer_siginfo *siginfo,\n+                                                  void *uctx);\n+\n struct __sanitizer_sigaction {\n   union {\n-    void (*handler)(int sig);\n-    void (*sigaction)(int sig, void *siginfo, void *uctx);\n+    __sanitizer_sighandler_ptr handler;\n+    __sanitizer_sigactionhandler_ptr sigaction;\n   };\n   __sanitizer_sigset_t sa_mask;\n   int sa_flags;\n };\n \n+extern unsigned struct_sigaltstack_sz;\n+\n+typedef unsigned int __sanitizer_sigset13_t;\n+\n+struct __sanitizer_sigaction13 {\n+  __sanitizer_sighandler_ptr osa_handler;\n+  __sanitizer_sigset13_t osa_mask;\n+  int osa_flags;\n+};\n+\n+struct __sanitizer_sigaltstack {\n+  void *ss_sp;\n+  uptr ss_size;\n+  int ss_flags;\n+};\n+\n typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n \n struct __sanitizer_kernel_sigaction_t {\n@@ -240,9 +307,10 @@ struct __sanitizer_kernel_sigaction_t {\n   __sanitizer_kernel_sigset_t sa_mask;\n };\n \n-extern uptr sig_ign;\n-extern uptr sig_dfl;\n-extern uptr sa_siginfo;\n+extern const uptr sig_ign;\n+extern const uptr sig_dfl;\n+extern const uptr sig_err;\n+extern const uptr sa_siginfo;\n \n extern int af_inet;\n extern int af_inet6;\n@@ -284,6 +352,8 @@ struct __sanitizer_pollfd {\n \n typedef unsigned __sanitizer_nfds_t;\n \n+typedef int __sanitizer_lwpid_t;\n+\n struct __sanitizer_glob_t {\n   uptr gl_pathc;\n   uptr gl_matchc;\n@@ -303,6 +373,48 @@ extern int glob_altdirfunc;\n \n extern unsigned path_max;\n \n+extern int struct_ttyent_sz;\n+\n+extern int ptrace_pt_io;\n+extern int ptrace_pt_lwpinfo;\n+extern int ptrace_pt_set_event_mask;\n+extern int ptrace_pt_get_event_mask;\n+extern int ptrace_pt_get_process_state;\n+extern int ptrace_pt_set_siginfo;\n+extern int ptrace_pt_get_siginfo;\n+extern int ptrace_piod_read_d;\n+extern int ptrace_piod_write_d;\n+extern int ptrace_piod_read_i;\n+extern int ptrace_piod_write_i;\n+extern int ptrace_piod_read_auxv;\n+extern int ptrace_pt_setregs;\n+extern int ptrace_pt_getregs;\n+extern int ptrace_pt_setfpregs;\n+extern int ptrace_pt_getfpregs;\n+extern int ptrace_pt_setdbregs;\n+extern int ptrace_pt_getdbregs;\n+\n+struct __sanitizer_ptrace_io_desc {\n+  int piod_op;\n+  void *piod_offs;\n+  void *piod_addr;\n+  uptr piod_len;\n+};\n+\n+struct __sanitizer_ptrace_lwpinfo {\n+  __sanitizer_lwpid_t pl_lwpid;\n+  int pl_event;\n+};\n+\n+extern unsigned struct_ptrace_ptrace_io_desc_struct_sz;\n+extern unsigned struct_ptrace_ptrace_lwpinfo_struct_sz;\n+extern unsigned struct_ptrace_ptrace_event_struct_sz;\n+extern unsigned struct_ptrace_ptrace_siginfo_struct_sz;\n+\n+extern unsigned struct_ptrace_reg_struct_sz;\n+extern unsigned struct_ptrace_fpreg_struct_sz;\n+extern unsigned struct_ptrace_dbreg_struct_sz;\n+\n struct __sanitizer_wordexp_t {\n   uptr we_wordc;\n   char **we_wordv;\n@@ -311,7 +423,7 @@ struct __sanitizer_wordexp_t {\n   uptr we_nbytes;\n };\n \n-typedef void __sanitizer_FILE;\n+typedef char __sanitizer_FILE;\n #define SANITIZER_HAS_STRUCT_FILE 0\n \n extern int shmctl_ipc_stat;\n@@ -336,6 +448,16 @@ struct __sanitizer_ifconf {\n   } ifc_ifcu;\n };\n \n+struct __sanitizer_ttyent {\n+  char *ty_name;\n+  char *ty_getty;\n+  char *ty_type;\n+  int ty_status;\n+  char *ty_window;\n+  char *ty_comment;\n+  char *ty_class;\n+};\n+\n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n #define IOC_SIZEBITS 14\n@@ -360,185 +482,1713 @@ struct __sanitizer_ifconf {\n #define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n \n-extern unsigned struct_ifreq_sz;\n-extern unsigned struct_termios_sz;\n-extern unsigned struct_winsize_sz;\n-\n-extern unsigned struct_arpreq_sz;\n+// ioctl request identifiers\n \n+extern unsigned struct_altqreq_sz;\n+extern unsigned struct_amr_user_ioctl_sz;\n+extern unsigned struct_ap_control_sz;\n+extern unsigned struct_apm_ctl_sz;\n+extern unsigned struct_apm_event_info_sz;\n+extern unsigned struct_apm_power_info_sz;\n+extern unsigned struct_atabusiodetach_args_sz;\n+extern unsigned struct_atabusioscan_args_sz;\n+extern unsigned struct_ath_diag_sz;\n+extern unsigned struct_atm_flowmap_sz;\n+extern unsigned struct_atm_pseudoioctl_sz;\n+extern unsigned struct_audio_buf_info_sz;\n+extern unsigned struct_audio_device_sz;\n+extern unsigned struct_audio_encoding_sz;\n+extern unsigned struct_audio_info_sz;\n+extern unsigned struct_audio_offset_sz;\n+extern unsigned struct_bio_locate_sz;\n+extern unsigned struct_bioc_alarm_sz;\n+extern unsigned struct_bioc_blink_sz;\n+extern unsigned struct_bioc_disk_sz;\n+extern unsigned struct_bioc_inq_sz;\n+extern unsigned struct_bioc_setstate_sz;\n+extern unsigned struct_bioc_vol_sz;\n+extern unsigned struct_bioc_volops_sz;\n+extern unsigned struct_bktr_chnlset_sz;\n+extern unsigned struct_bktr_remote_sz;\n+extern unsigned struct_blue_conf_sz;\n+extern unsigned struct_blue_interface_sz;\n+extern unsigned struct_blue_stats_sz;\n+extern unsigned struct_bpf_dltlist_sz;\n+extern unsigned struct_bpf_program_sz;\n+extern unsigned struct_bpf_stat_old_sz;\n+extern unsigned struct_bpf_stat_sz;\n+extern unsigned struct_bpf_version_sz;\n+extern unsigned struct_btreq_sz;\n+extern unsigned struct_btsco_info_sz;\n+extern unsigned struct_buffmem_desc_sz;\n+extern unsigned struct_cbq_add_class_sz;\n+extern unsigned struct_cbq_add_filter_sz;\n+extern unsigned struct_cbq_delete_class_sz;\n+extern unsigned struct_cbq_delete_filter_sz;\n+extern unsigned struct_cbq_getstats_sz;\n+extern unsigned struct_cbq_interface_sz;\n+extern unsigned struct_cbq_modify_class_sz;\n+extern unsigned struct_ccd_ioctl_sz;\n+extern unsigned struct_cdnr_add_element_sz;\n+extern unsigned struct_cdnr_add_filter_sz;\n+extern unsigned struct_cdnr_add_tbmeter_sz;\n+extern unsigned struct_cdnr_add_trtcm_sz;\n+extern unsigned struct_cdnr_add_tswtcm_sz;\n+extern unsigned struct_cdnr_delete_element_sz;\n+extern unsigned struct_cdnr_delete_filter_sz;\n+extern unsigned struct_cdnr_get_stats_sz;\n+extern unsigned struct_cdnr_interface_sz;\n+extern unsigned struct_cdnr_modify_tbmeter_sz;\n+extern unsigned struct_cdnr_modify_trtcm_sz;\n+extern unsigned struct_cdnr_modify_tswtcm_sz;\n+extern unsigned struct_cdnr_tbmeter_stats_sz;\n+extern unsigned struct_cdnr_tcm_stats_sz;\n+extern unsigned struct_cgd_ioctl_sz;\n+extern unsigned struct_cgd_user_sz;\n+extern unsigned struct_changer_element_status_request_sz;\n+extern unsigned struct_changer_exchange_request_sz;\n+extern unsigned struct_changer_move_request_sz;\n+extern unsigned struct_changer_params_sz;\n+extern unsigned struct_changer_position_request_sz;\n+extern unsigned struct_changer_set_voltag_request_sz;\n+extern unsigned struct_clockctl_adjtime_sz;\n+extern unsigned struct_clockctl_clock_settime_sz;\n+extern unsigned struct_clockctl_ntp_adjtime_sz;\n+extern unsigned struct_clockctl_settimeofday_sz;\n+extern unsigned struct_cnwistats_sz;\n+extern unsigned struct_cnwitrail_sz;\n+extern unsigned struct_cnwstatus_sz;\n+extern unsigned struct_count_info_sz;\n+extern unsigned struct_cpu_ucode_sz;\n+extern unsigned struct_cpu_ucode_version_sz;\n+extern unsigned struct_crypt_kop_sz;\n+extern unsigned struct_crypt_mkop_sz;\n+extern unsigned struct_crypt_mop_sz;\n+extern unsigned struct_crypt_op_sz;\n+extern unsigned struct_crypt_result_sz;\n+extern unsigned struct_crypt_sfop_sz;\n+extern unsigned struct_crypt_sgop_sz;\n+extern unsigned struct_cryptret_sz;\n+extern unsigned struct_devdetachargs_sz;\n+extern unsigned struct_devlistargs_sz;\n+extern unsigned struct_devpmargs_sz;\n+extern unsigned struct_devrescanargs_sz;\n+extern unsigned struct_disk_badsecinfo_sz;\n+extern unsigned struct_disk_strategy_sz;\n+extern unsigned struct_disklabel_sz;\n+extern unsigned struct_dkbad_sz;\n+extern unsigned struct_dkwedge_info_sz;\n+extern unsigned struct_dkwedge_list_sz;\n+extern unsigned struct_dmio_setfunc_sz;\n+extern unsigned struct_dmx_pes_filter_params_sz;\n+extern unsigned struct_dmx_sct_filter_params_sz;\n+extern unsigned struct_dmx_stc_sz;\n+extern unsigned struct_dvb_diseqc_master_cmd_sz;\n+extern unsigned struct_dvb_diseqc_slave_reply_sz;\n+extern unsigned struct_dvb_frontend_event_sz;\n+extern unsigned struct_dvb_frontend_info_sz;\n+extern unsigned struct_dvb_frontend_parameters_sz;\n+extern unsigned struct_eccapreq_sz;\n+extern unsigned struct_fbcmap_sz;\n+extern unsigned struct_fbcurpos_sz;\n+extern unsigned struct_fbcursor_sz;\n+extern unsigned struct_fbgattr_sz;\n+extern unsigned struct_fbsattr_sz;\n+extern unsigned struct_fbtype_sz;\n+extern unsigned struct_fdformat_cmd_sz;\n+extern unsigned struct_fdformat_parms_sz;\n+extern unsigned struct_fifoq_conf_sz;\n+extern unsigned struct_fifoq_getstats_sz;\n+extern unsigned struct_fifoq_interface_sz;\n+extern unsigned struct_format_op_sz;\n+extern unsigned struct_fss_get_sz;\n+extern unsigned struct_fss_set_sz;\n+extern unsigned struct_gpio_attach_sz;\n+extern unsigned struct_gpio_info_sz;\n+extern unsigned struct_gpio_req_sz;\n+extern unsigned struct_gpio_set_sz;\n+extern unsigned struct_hfsc_add_class_sz;\n+extern unsigned struct_hfsc_add_filter_sz;\n+extern unsigned struct_hfsc_attach_sz;\n+extern unsigned struct_hfsc_class_stats_sz;\n+extern unsigned struct_hfsc_delete_class_sz;\n+extern unsigned struct_hfsc_delete_filter_sz;\n+extern unsigned struct_hfsc_interface_sz;\n+extern unsigned struct_hfsc_modify_class_sz;\n+extern unsigned struct_hpcfb_dsp_op_sz;\n+extern unsigned struct_hpcfb_dspconf_sz;\n+extern unsigned struct_hpcfb_fbconf_sz;\n+extern unsigned struct_if_addrprefreq_sz;\n+extern unsigned struct_if_clonereq_sz;\n+extern unsigned struct_if_laddrreq_sz;\n+extern unsigned struct_ifaddr_sz;\n+extern unsigned struct_ifaliasreq_sz;\n+extern unsigned struct_ifcapreq_sz;\n+extern unsigned struct_ifconf_sz;\n+extern unsigned struct_ifdatareq_sz;\n+extern unsigned struct_ifdrv_sz;\n+extern unsigned struct_ifmediareq_sz;\n+extern unsigned struct_ifpppcstatsreq_sz;\n+extern unsigned struct_ifpppstatsreq_sz;\n+extern unsigned struct_ifreq_sz;\n+extern unsigned struct_in6_addrpolicy_sz;\n+extern unsigned struct_in6_ndireq_sz;\n+extern unsigned struct_ioc_load_unload_sz;\n+extern unsigned struct_ioc_patch_sz;\n+extern unsigned struct_ioc_play_blocks_sz;\n+extern unsigned struct_ioc_play_msf_sz;\n+extern unsigned struct_ioc_play_track_sz;\n+extern unsigned struct_ioc_read_subchannel_sz;\n+extern unsigned struct_ioc_read_toc_entry_sz;\n+extern unsigned struct_ioc_toc_header_sz;\n+extern unsigned struct_ioc_vol_sz;\n+extern unsigned struct_ioctl_pt_sz;\n+extern unsigned struct_ioppt_sz;\n+extern unsigned struct_iovec_sz;\n+extern unsigned struct_ipfobj_sz;\n+extern unsigned struct_irda_params_sz;\n+extern unsigned struct_isp_fc_device_sz;\n+extern unsigned struct_isp_fc_tsk_mgmt_sz;\n+extern unsigned struct_isp_hba_device_sz;\n+extern unsigned struct_isv_cmd_sz;\n+extern unsigned struct_jobs_add_class_sz;\n+extern unsigned struct_jobs_add_filter_sz;\n+extern unsigned struct_jobs_attach_sz;\n+extern unsigned struct_jobs_class_stats_sz;\n+extern unsigned struct_jobs_delete_class_sz;\n+extern unsigned struct_jobs_delete_filter_sz;\n+extern unsigned struct_jobs_interface_sz;\n+extern unsigned struct_jobs_modify_class_sz;\n+extern unsigned struct_kbentry_sz;\n+extern unsigned struct_kfilter_mapping_sz;\n+extern unsigned struct_kiockeymap_sz;\n+extern unsigned struct_ksyms_gsymbol_sz;\n+extern unsigned struct_ksyms_gvalue_sz;\n+extern unsigned struct_ksyms_ogsymbol_sz;\n+extern unsigned struct_kttcp_io_args_sz;\n+extern unsigned struct_ltchars_sz;\n+extern unsigned struct_lua_create_sz;\n+extern unsigned struct_lua_info_sz;\n+extern unsigned struct_lua_load_sz;\n+extern unsigned struct_lua_require_sz;\n+extern unsigned struct_mbpp_param_sz;\n+extern unsigned struct_md_conf_sz;\n+extern unsigned struct_meteor_capframe_sz;\n+extern unsigned struct_meteor_counts_sz;\n+extern unsigned struct_meteor_geomet_sz;\n+extern unsigned struct_meteor_pixfmt_sz;\n+extern unsigned struct_meteor_video_sz;\n+extern unsigned struct_mlx_cinfo_sz;\n+extern unsigned struct_mlx_pause_sz;\n+extern unsigned struct_mlx_rebuild_request_sz;\n+extern unsigned struct_mlx_rebuild_status_sz;\n+extern unsigned struct_mlx_usercommand_sz;\n+extern unsigned struct_mly_user_command_sz;\n+extern unsigned struct_mly_user_health_sz;\n extern unsigned struct_mtget_sz;\n extern unsigned struct_mtop_sz;\n-extern unsigned struct_rtentry_sz;\n-extern unsigned struct_sbi_instrument_sz;\n+extern unsigned struct_npf_ioctl_table_sz;\n+extern unsigned struct_npioctl_sz;\n+extern unsigned struct_nvme_pt_command_sz;\n+extern unsigned struct_ochanger_element_status_request_sz;\n+extern unsigned struct_ofiocdesc_sz;\n+extern unsigned struct_okiockey_sz;\n+extern unsigned struct_ortentry_sz;\n+extern unsigned struct_oscsi_addr_sz;\n+extern unsigned struct_oss_audioinfo_sz;\n+extern unsigned struct_oss_sysinfo_sz;\n+extern unsigned struct_pciio_bdf_cfgreg_sz;\n+extern unsigned struct_pciio_businfo_sz;\n+extern unsigned struct_pciio_cfgreg_sz;\n+extern unsigned struct_pciio_drvname_sz;\n+extern unsigned struct_pciio_drvnameonbus_sz;\n+extern unsigned struct_pcvtid_sz;\n+extern unsigned struct_pf_osfp_ioctl_sz;\n+extern unsigned struct_pf_status_sz;\n+extern unsigned struct_pfioc_altq_sz;\n+extern unsigned struct_pfioc_if_sz;\n+extern unsigned struct_pfioc_iface_sz;\n+extern unsigned struct_pfioc_limit_sz;\n+extern unsigned struct_pfioc_natlook_sz;\n+extern unsigned struct_pfioc_pooladdr_sz;\n+extern unsigned struct_pfioc_qstats_sz;\n+extern unsigned struct_pfioc_rule_sz;\n+extern unsigned struct_pfioc_ruleset_sz;\n+extern unsigned struct_pfioc_src_node_kill_sz;\n+extern unsigned struct_pfioc_src_nodes_sz;\n+extern unsigned struct_pfioc_state_kill_sz;\n+extern unsigned struct_pfioc_state_sz;\n+extern unsigned struct_pfioc_states_sz;\n+extern unsigned struct_pfioc_table_sz;\n+extern unsigned struct_pfioc_tm_sz;\n+extern unsigned struct_pfioc_trans_sz;\n+extern unsigned struct_plistref_sz;\n+extern unsigned struct_power_type_sz;\n+extern unsigned struct_ppp_idle_sz;\n+extern unsigned struct_ppp_option_data_sz;\n+extern unsigned struct_ppp_rawin_sz;\n+extern unsigned struct_pppoeconnectionstate_sz;\n+extern unsigned struct_pppoediscparms_sz;\n+extern unsigned struct_priq_add_class_sz;\n+extern unsigned struct_priq_add_filter_sz;\n+extern unsigned struct_priq_class_stats_sz;\n+extern unsigned struct_priq_delete_class_sz;\n+extern unsigned struct_priq_delete_filter_sz;\n+extern unsigned struct_priq_interface_sz;\n+extern unsigned struct_priq_modify_class_sz;\n+extern unsigned struct_ptmget_sz;\n+extern unsigned struct_pvctxreq_sz;\n+extern unsigned struct_radio_info_sz;\n+extern unsigned struct_red_conf_sz;\n+extern unsigned struct_red_interface_sz;\n+extern unsigned struct_red_stats_sz;\n+extern unsigned struct_redparams_sz;\n+extern unsigned struct_rf_pmparams_sz;\n+extern unsigned struct_rf_pmstat_sz;\n+extern unsigned struct_rf_recon_req_sz;\n+extern unsigned struct_rio_conf_sz;\n+extern unsigned struct_rio_interface_sz;\n+extern unsigned struct_rio_stats_sz;\n+extern unsigned struct_satlink_id_sz;\n+extern unsigned struct_scan_io_sz;\n+extern unsigned struct_scbusaccel_args_sz;\n+extern unsigned struct_scbusiodetach_args_sz;\n+extern unsigned struct_scbusioscan_args_sz;\n+extern unsigned struct_scsi_addr_sz;\n extern unsigned struct_seq_event_rec_sz;\n-extern unsigned struct_synth_info_sz;\n-extern unsigned struct_vt_mode_sz;\n-extern unsigned struct_audio_buf_info_sz;\n-extern unsigned struct_ppp_stats_sz;\n+extern unsigned struct_session_op_sz;\n+extern unsigned struct_sgttyb_sz;\n extern unsigned struct_sioc_sg_req_sz;\n extern unsigned struct_sioc_vif_req_sz;\n+extern unsigned struct_smbioc_flags_sz;\n+extern unsigned struct_smbioc_lookup_sz;\n+extern unsigned struct_smbioc_oshare_sz;\n+extern unsigned struct_smbioc_ossn_sz;\n+extern unsigned struct_smbioc_rq_sz;\n+extern unsigned struct_smbioc_rw_sz;\n+extern unsigned struct_spppauthcfg_sz;\n+extern unsigned struct_spppauthfailuresettings_sz;\n+extern unsigned struct_spppauthfailurestats_sz;\n+extern unsigned struct_spppdnsaddrs_sz;\n+extern unsigned struct_spppdnssettings_sz;\n+extern unsigned struct_spppidletimeout_sz;\n+extern unsigned struct_spppkeepalivesettings_sz;\n+extern unsigned struct_sppplcpcfg_sz;\n+extern unsigned struct_spppstatus_sz;\n+extern unsigned struct_spppstatusncp_sz;\n+extern unsigned struct_srt_rt_sz;\n+extern unsigned struct_stic_xinfo_sz;\n+extern unsigned struct_sun_dkctlr_sz;\n+extern unsigned struct_sun_dkgeom_sz;\n+extern unsigned struct_sun_dkpart_sz;\n+extern unsigned struct_synth_info_sz;\n+extern unsigned struct_tbrreq_sz;\n+extern unsigned struct_tchars_sz;\n+extern unsigned struct_termios_sz;\n+extern unsigned struct_timeval_sz;\n+extern unsigned struct_twe_drivecommand_sz;\n+extern unsigned struct_twe_paramcommand_sz;\n+extern unsigned struct_twe_usercommand_sz;\n+extern unsigned struct_ukyopon_identify_sz;\n+extern unsigned struct_urio_command_sz;\n+extern unsigned struct_usb_alt_interface_sz;\n+extern unsigned struct_usb_bulk_ra_wb_opt_sz;\n+extern unsigned struct_usb_config_desc_sz;\n+extern unsigned struct_usb_ctl_report_desc_sz;\n+extern unsigned struct_usb_ctl_report_sz;\n+extern unsigned struct_usb_ctl_request_sz;\n+extern unsigned struct_usb_device_info_old_sz;\n+extern unsigned struct_usb_device_info_sz;\n+extern unsigned struct_usb_device_stats_sz;\n+extern unsigned struct_usb_endpoint_desc_sz;\n+extern unsigned struct_usb_full_desc_sz;\n+extern unsigned struct_usb_interface_desc_sz;\n+extern unsigned struct_usb_string_desc_sz;\n+extern unsigned struct_utoppy_readfile_sz;\n+extern unsigned struct_utoppy_rename_sz;\n+extern unsigned struct_utoppy_stats_sz;\n+extern unsigned struct_utoppy_writefile_sz;\n+extern unsigned struct_v4l2_audio_sz;\n+extern unsigned struct_v4l2_audioout_sz;\n+extern unsigned struct_v4l2_buffer_sz;\n+extern unsigned struct_v4l2_capability_sz;\n+extern unsigned struct_v4l2_control_sz;\n+extern unsigned struct_v4l2_crop_sz;\n+extern unsigned struct_v4l2_cropcap_sz;\n+extern unsigned struct_v4l2_fmtdesc_sz;\n+extern unsigned struct_v4l2_format_sz;\n+extern unsigned struct_v4l2_framebuffer_sz;\n+extern unsigned struct_v4l2_frequency_sz;\n+extern unsigned struct_v4l2_frmivalenum_sz;\n+extern unsigned struct_v4l2_frmsizeenum_sz;\n+extern unsigned struct_v4l2_input_sz;\n+extern unsigned struct_v4l2_jpegcompression_sz;\n+extern unsigned struct_v4l2_modulator_sz;\n+extern unsigned struct_v4l2_output_sz;\n+extern unsigned struct_v4l2_queryctrl_sz;\n+extern unsigned struct_v4l2_querymenu_sz;\n+extern unsigned struct_v4l2_requestbuffers_sz;\n+extern unsigned struct_v4l2_standard_sz;\n+extern unsigned struct_v4l2_streamparm_sz;\n+extern unsigned struct_v4l2_tuner_sz;\n+extern unsigned struct_vnd_ioctl_sz;\n+extern unsigned struct_vnd_user_sz;\n+extern unsigned struct_vt_stat_sz;\n+extern unsigned struct_wdog_conf_sz;\n+extern unsigned struct_wdog_mode_sz;\n+extern unsigned struct_wfq_conf_sz;\n+extern unsigned struct_wfq_getqid_sz;\n+extern unsigned struct_wfq_getstats_sz;\n+extern unsigned struct_wfq_interface_sz;\n+extern unsigned struct_wfq_setweight_sz;\n+extern unsigned struct_winsize_sz;\n+extern unsigned struct_wscons_event_sz;\n+extern unsigned struct_wsdisplay_addscreendata_sz;\n+extern unsigned struct_wsdisplay_char_sz;\n+extern unsigned struct_wsdisplay_cmap_sz;\n+extern unsigned struct_wsdisplay_curpos_sz;\n+extern unsigned struct_wsdisplay_cursor_sz;\n+extern unsigned struct_wsdisplay_delscreendata_sz;\n+extern unsigned struct_wsdisplay_fbinfo_sz;\n+extern unsigned struct_wsdisplay_font_sz;\n+extern unsigned struct_wsdisplay_kbddata_sz;\n+extern unsigned struct_wsdisplay_msgattrs_sz;\n+extern unsigned struct_wsdisplay_param_sz;\n+extern unsigned struct_wsdisplay_scroll_data_sz;\n+extern unsigned struct_wsdisplay_usefontdata_sz;\n+extern unsigned struct_wsdisplayio_blit_sz;\n+extern unsigned struct_wsdisplayio_bus_id_sz;\n+extern unsigned struct_wsdisplayio_edid_info_sz;\n+extern unsigned struct_wsdisplayio_fbinfo_sz;\n+extern unsigned struct_wskbd_bell_data_sz;\n+extern unsigned struct_wskbd_keyrepeat_data_sz;\n+extern unsigned struct_wskbd_map_data_sz;\n+extern unsigned struct_wskbd_scroll_data_sz;\n+extern unsigned struct_wsmouse_calibcoords_sz;\n+extern unsigned struct_wsmouse_id_sz;\n+extern unsigned struct_wsmouse_repeat_sz;\n+extern unsigned struct_wsmux_device_list_sz;\n+extern unsigned struct_wsmux_device_sz;\n+extern unsigned struct_xd_iocmd_sz;\n+\n+extern unsigned struct_scsireq_sz;\n+extern unsigned struct_tone_sz;\n+extern unsigned union_twe_statrequest_sz;\n+extern unsigned struct_usb_device_descriptor_sz;\n+extern unsigned struct_vt_mode_sz;\n+extern unsigned struct__old_mixer_info_sz;\n+extern unsigned struct__agp_allocate_sz;\n+extern unsigned struct__agp_bind_sz;\n+extern unsigned struct__agp_info_sz;\n+extern unsigned struct__agp_setup_sz;\n+extern unsigned struct__agp_unbind_sz;\n+extern unsigned struct_atareq_sz;\n+extern unsigned struct_cpustate_sz;\n+extern unsigned struct_dmx_caps_sz;\n+extern unsigned enum_dmx_source_sz;\n+extern unsigned union_dvd_authinfo_sz;\n+extern unsigned union_dvd_struct_sz;\n+extern unsigned enum_v4l2_priority_sz;\n+extern unsigned struct_envsys_basic_info_sz;\n+extern unsigned struct_envsys_tre_data_sz;\n+extern unsigned enum_fe_sec_mini_cmd_sz;\n+extern unsigned enum_fe_sec_tone_mode_sz;\n+extern unsigned enum_fe_sec_voltage_sz;\n+extern unsigned enum_fe_status_sz;\n+extern unsigned struct_gdt_ctrt_sz;\n+extern unsigned struct_gdt_event_sz;\n+extern unsigned struct_gdt_osv_sz;\n+extern unsigned struct_gdt_rescan_sz;\n+extern unsigned struct_gdt_statist_sz;\n+extern unsigned struct_gdt_ucmd_sz;\n+extern unsigned struct_iscsi_conn_status_parameters_sz;\n+extern unsigned struct_iscsi_get_version_parameters_sz;\n+extern unsigned struct_iscsi_iocommand_parameters_sz;\n+extern unsigned struct_iscsi_login_parameters_sz;\n+extern unsigned struct_iscsi_logout_parameters_sz;\n+extern unsigned struct_iscsi_register_event_parameters_sz;\n+extern unsigned struct_iscsi_remove_parameters_sz;\n+extern unsigned struct_iscsi_send_targets_parameters_sz;\n+extern unsigned struct_iscsi_set_node_name_parameters_sz;\n+extern unsigned struct_iscsi_wait_event_parameters_sz;\n+extern unsigned struct_isp_stats_sz;\n+extern unsigned struct_lsenable_sz;\n+extern unsigned struct_lsdisable_sz;\n+extern unsigned struct_mixer_ctrl_sz;\n+extern unsigned struct_mixer_devinfo_sz;\n+extern unsigned struct_mpu_command_rec_sz;\n+extern unsigned struct_rndstat_sz;\n+extern unsigned struct_rndstat_name_sz;\n+extern unsigned struct_rndctl_sz;\n+extern unsigned struct_rnddata_sz;\n+extern unsigned struct_rndpoolstat_sz;\n+extern unsigned struct_rndstat_est_sz;\n+extern unsigned struct_rndstat_est_name_sz;\n+extern unsigned struct_pps_params_sz;\n+extern unsigned struct_pps_info_sz;\n+extern unsigned struct_mixer_info_sz;\n+extern unsigned struct_RF_SparetWait_sz;\n+extern unsigned struct_RF_ComponentLabel_sz;\n+extern unsigned struct_RF_SingleComponent_sz;\n+extern unsigned struct_RF_ProgressInfo_sz;\n \n-// ioctl request identifiers\n \n // A special value to mark ioctls that are not present on the target platform,\n // when it can not be determined without including any system headers.\n extern const unsigned IOCTL_NOT_PRESENT;\n \n-extern unsigned IOCTL_FIOASYNC;\n+\n+extern unsigned IOCTL_AFM_ADDFMAP;\n+extern unsigned IOCTL_AFM_DELFMAP;\n+extern unsigned IOCTL_AFM_CLEANFMAP;\n+extern unsigned IOCTL_AFM_GETFMAP;\n+extern unsigned IOCTL_ALTQGTYPE;\n+extern unsigned IOCTL_ALTQTBRSET;\n+extern unsigned IOCTL_ALTQTBRGET;\n+extern unsigned IOCTL_BLUE_IF_ATTACH;\n+extern unsigned IOCTL_BLUE_IF_DETACH;\n+extern unsigned IOCTL_BLUE_ENABLE;\n+extern unsigned IOCTL_BLUE_DISABLE;\n+extern unsigned IOCTL_BLUE_CONFIG;\n+extern unsigned IOCTL_BLUE_GETSTATS;\n+extern unsigned IOCTL_CBQ_IF_ATTACH;\n+extern unsigned IOCTL_CBQ_IF_DETACH;\n+extern unsigned IOCTL_CBQ_ENABLE;\n+extern unsigned IOCTL_CBQ_DISABLE;\n+extern unsigned IOCTL_CBQ_CLEAR_HIERARCHY;\n+extern unsigned IOCTL_CBQ_ADD_CLASS;\n+extern unsigned IOCTL_CBQ_DEL_CLASS;\n+extern unsigned IOCTL_CBQ_MODIFY_CLASS;\n+extern unsigned IOCTL_CBQ_ADD_FILTER;\n+extern unsigned IOCTL_CBQ_DEL_FILTER;\n+extern unsigned IOCTL_CBQ_GETSTATS;\n+extern unsigned IOCTL_CDNR_IF_ATTACH;\n+extern unsigned IOCTL_CDNR_IF_DETACH;\n+extern unsigned IOCTL_CDNR_ENABLE;\n+extern unsigned IOCTL_CDNR_DISABLE;\n+extern unsigned IOCTL_CDNR_ADD_FILTER;\n+extern unsigned IOCTL_CDNR_DEL_FILTER;\n+extern unsigned IOCTL_CDNR_GETSTATS;\n+extern unsigned IOCTL_CDNR_ADD_ELEM;\n+extern unsigned IOCTL_CDNR_DEL_ELEM;\n+extern unsigned IOCTL_CDNR_ADD_TBM;\n+extern unsigned IOCTL_CDNR_MOD_TBM;\n+extern unsigned IOCTL_CDNR_TBM_STATS;\n+extern unsigned IOCTL_CDNR_ADD_TCM;\n+extern unsigned IOCTL_CDNR_MOD_TCM;\n+extern unsigned IOCTL_CDNR_TCM_STATS;\n+extern unsigned IOCTL_CDNR_ADD_TSW;\n+extern unsigned IOCTL_CDNR_MOD_TSW;\n+extern unsigned IOCTL_FIFOQ_IF_ATTACH;\n+extern unsigned IOCTL_FIFOQ_IF_DETACH;\n+extern unsigned IOCTL_FIFOQ_ENABLE;\n+extern unsigned IOCTL_FIFOQ_DISABLE;\n+extern unsigned IOCTL_FIFOQ_CONFIG;\n+extern unsigned IOCTL_FIFOQ_GETSTATS;\n+extern unsigned IOCTL_HFSC_IF_ATTACH;\n+extern unsigned IOCTL_HFSC_IF_DETACH;\n+extern unsigned IOCTL_HFSC_ENABLE;\n+extern unsigned IOCTL_HFSC_DISABLE;\n+extern unsigned IOCTL_HFSC_CLEAR_HIERARCHY;\n+extern unsigned IOCTL_HFSC_ADD_CLASS;\n+extern unsigned IOCTL_HFSC_DEL_CLASS;\n+extern unsigned IOCTL_HFSC_MOD_CLASS;\n+extern unsigned IOCTL_HFSC_ADD_FILTER;\n+extern unsigned IOCTL_HFSC_DEL_FILTER;\n+extern unsigned IOCTL_HFSC_GETSTATS;\n+extern unsigned IOCTL_JOBS_IF_ATTACH;\n+extern unsigned IOCTL_JOBS_IF_DETACH;\n+extern unsigned IOCTL_JOBS_ENABLE;\n+extern unsigned IOCTL_JOBS_DISABLE;\n+extern unsigned IOCTL_JOBS_CLEAR;\n+extern unsigned IOCTL_JOBS_ADD_CLASS;\n+extern unsigned IOCTL_JOBS_DEL_CLASS;\n+extern unsigned IOCTL_JOBS_MOD_CLASS;\n+extern unsigned IOCTL_JOBS_ADD_FILTER;\n+extern unsigned IOCTL_JOBS_DEL_FILTER;\n+extern unsigned IOCTL_JOBS_GETSTATS;\n+extern unsigned IOCTL_PRIQ_IF_ATTACH;\n+extern unsigned IOCTL_PRIQ_IF_DETACH;\n+extern unsigned IOCTL_PRIQ_ENABLE;\n+extern unsigned IOCTL_PRIQ_DISABLE;\n+extern unsigned IOCTL_PRIQ_CLEAR;\n+extern unsigned IOCTL_PRIQ_ADD_CLASS;\n+extern unsigned IOCTL_PRIQ_DEL_CLASS;\n+extern unsigned IOCTL_PRIQ_MOD_CLASS;\n+extern unsigned IOCTL_PRIQ_ADD_FILTER;\n+extern unsigned IOCTL_PRIQ_DEL_FILTER;\n+extern unsigned IOCTL_PRIQ_GETSTATS;\n+extern unsigned IOCTL_RED_IF_ATTACH;\n+extern unsigned IOCTL_RED_IF_DETACH;\n+extern unsigned IOCTL_RED_ENABLE;\n+extern unsigned IOCTL_RED_DISABLE;\n+extern unsigned IOCTL_RED_CONFIG;\n+extern unsigned IOCTL_RED_GETSTATS;\n+extern unsigned IOCTL_RED_SETDEFAULTS;\n+extern unsigned IOCTL_RIO_IF_ATTACH;\n+extern unsigned IOCTL_RIO_IF_DETACH;\n+extern unsigned IOCTL_RIO_ENABLE;\n+extern unsigned IOCTL_RIO_DISABLE;\n+extern unsigned IOCTL_RIO_CONFIG;\n+extern unsigned IOCTL_RIO_GETSTATS;\n+extern unsigned IOCTL_RIO_SETDEFAULTS;\n+extern unsigned IOCTL_WFQ_IF_ATTACH;\n+extern unsigned IOCTL_WFQ_IF_DETACH;\n+extern unsigned IOCTL_WFQ_ENABLE;\n+extern unsigned IOCTL_WFQ_DISABLE;\n+extern unsigned IOCTL_WFQ_CONFIG;\n+extern unsigned IOCTL_WFQ_GET_STATS;\n+extern unsigned IOCTL_WFQ_GET_QID;\n+extern unsigned IOCTL_WFQ_SET_WEIGHT;\n+extern unsigned IOCTL_CRIOGET;\n+extern unsigned IOCTL_CIOCFSESSION;\n+extern unsigned IOCTL_CIOCKEY;\n+extern unsigned IOCTL_CIOCNFKEYM;\n+extern unsigned IOCTL_CIOCNFSESSION;\n+extern unsigned IOCTL_CIOCNCRYPTRETM;\n+extern unsigned IOCTL_CIOCNCRYPTRET;\n+extern unsigned IOCTL_CIOCGSESSION;\n+extern unsigned IOCTL_CIOCNGSESSION;\n+extern unsigned IOCTL_CIOCCRYPT;\n+extern unsigned IOCTL_CIOCNCRYPTM;\n+extern unsigned IOCTL_CIOCASYMFEAT;\n+extern unsigned IOCTL_APM_IOC_REJECT;\n+extern unsigned IOCTL_APM_IOC_STANDBY;\n+extern unsigned IOCTL_APM_IOC_SUSPEND;\n+extern unsigned IOCTL_OAPM_IOC_GETPOWER;\n+extern unsigned IOCTL_APM_IOC_GETPOWER;\n+extern unsigned IOCTL_APM_IOC_NEXTEVENT;\n+extern unsigned IOCTL_APM_IOC_DEV_CTL;\n+extern unsigned IOCTL_NETBSD_DM_IOCTL;\n+extern unsigned IOCTL_DMIO_SETFUNC;\n+extern unsigned IOCTL_DMX_START;\n+extern unsigned IOCTL_DMX_STOP;\n+extern unsigned IOCTL_DMX_SET_FILTER;\n+extern unsigned IOCTL_DMX_SET_PES_FILTER;\n+extern unsigned IOCTL_DMX_SET_BUFFER_SIZE;\n+extern unsigned IOCTL_DMX_GET_STC;\n+extern unsigned IOCTL_DMX_ADD_PID;\n+extern unsigned IOCTL_DMX_REMOVE_PID;\n+extern unsigned IOCTL_DMX_GET_CAPS;\n+extern unsigned IOCTL_DMX_SET_SOURCE;\n+extern unsigned IOCTL_FE_READ_STATUS;\n+extern unsigned IOCTL_FE_READ_BER;\n+extern unsigned IOCTL_FE_READ_SNR;\n+extern unsigned IOCTL_FE_READ_SIGNAL_STRENGTH;\n+extern unsigned IOCTL_FE_READ_UNCORRECTED_BLOCKS;\n+extern unsigned IOCTL_FE_SET_FRONTEND;\n+extern unsigned IOCTL_FE_GET_FRONTEND;\n+extern unsigned IOCTL_FE_GET_EVENT;\n+extern unsigned IOCTL_FE_GET_INFO;\n+extern unsigned IOCTL_FE_DISEQC_RESET_OVERLOAD;\n+extern unsigned IOCTL_FE_DISEQC_SEND_MASTER_CMD;\n+extern unsigned IOCTL_FE_DISEQC_RECV_SLAVE_REPLY;\n+extern unsigned IOCTL_FE_DISEQC_SEND_BURST;\n+extern unsigned IOCTL_FE_SET_TONE;\n+extern unsigned IOCTL_FE_SET_VOLTAGE;\n+extern unsigned IOCTL_FE_ENABLE_HIGH_LNB_VOLTAGE;\n+extern unsigned IOCTL_FE_SET_FRONTEND_TUNE_MODE;\n+extern unsigned IOCTL_FE_DISHNETWORK_SEND_LEGACY_CMD;\n+extern unsigned IOCTL_FILEMON_SET_FD;\n+extern unsigned IOCTL_FILEMON_SET_PID;\n+extern unsigned IOCTL_HDAUDIO_FGRP_INFO;\n+extern unsigned IOCTL_HDAUDIO_FGRP_GETCONFIG;\n+extern unsigned IOCTL_HDAUDIO_FGRP_SETCONFIG;\n+extern unsigned IOCTL_HDAUDIO_FGRP_WIDGET_INFO;\n+extern unsigned IOCTL_HDAUDIO_FGRP_CODEC_INFO;\n+extern unsigned IOCTL_HDAUDIO_AFG_WIDGET_INFO;\n+extern unsigned IOCTL_HDAUDIO_AFG_CODEC_INFO;\n+extern unsigned IOCTL_CEC_GET_PHYS_ADDR;\n+extern unsigned IOCTL_CEC_GET_LOG_ADDRS;\n+extern unsigned IOCTL_CEC_SET_LOG_ADDRS;\n+extern unsigned IOCTL_CEC_GET_VENDOR_ID;\n+extern unsigned IOCTL_HPCFBIO_GCONF;\n+extern unsigned IOCTL_HPCFBIO_SCONF;\n+extern unsigned IOCTL_HPCFBIO_GDSPCONF;\n+extern unsigned IOCTL_HPCFBIO_SDSPCONF;\n+extern unsigned IOCTL_HPCFBIO_GOP;\n+extern unsigned IOCTL_HPCFBIO_SOP;\n+extern unsigned IOCTL_IOPIOCPT;\n+extern unsigned IOCTL_IOPIOCGLCT;\n+extern unsigned IOCTL_IOPIOCGSTATUS;\n+extern unsigned IOCTL_IOPIOCRECONFIG;\n+extern unsigned IOCTL_IOPIOCGTIDMAP;\n+extern unsigned IOCTL_SIOCGATHSTATS;\n+extern unsigned IOCTL_SIOCGATHDIAG;\n+extern unsigned IOCTL_METEORCAPTUR;\n+extern unsigned IOCTL_METEORCAPFRM;\n+extern unsigned IOCTL_METEORSETGEO;\n+extern unsigned IOCTL_METEORGETGEO;\n+extern unsigned IOCTL_METEORSTATUS;\n+extern unsigned IOCTL_METEORSHUE;\n+extern unsigned IOCTL_METEORGHUE;\n+extern unsigned IOCTL_METEORSFMT;\n+extern unsigned IOCTL_METEORGFMT;\n+extern unsigned IOCTL_METEORSINPUT;\n+extern unsigned IOCTL_METEORGINPUT;\n+extern unsigned IOCTL_METEORSCHCV;\n+extern unsigned IOCTL_METEORGCHCV;\n+extern unsigned IOCTL_METEORSCOUNT;\n+extern unsigned IOCTL_METEORGCOUNT;\n+extern unsigned IOCTL_METEORSFPS;\n+extern unsigned IOCTL_METEORGFPS;\n+extern unsigned IOCTL_METEORSSIGNAL;\n+extern unsigned IOCTL_METEORGSIGNAL;\n+extern unsigned IOCTL_METEORSVIDEO;\n+extern unsigned IOCTL_METEORGVIDEO;\n+extern unsigned IOCTL_METEORSBRIG;\n+extern unsigned IOCTL_METEORGBRIG;\n+extern unsigned IOCTL_METEORSCSAT;\n+extern unsigned IOCTL_METEORGCSAT;\n+extern unsigned IOCTL_METEORSCONT;\n+extern unsigned IOCTL_METEORGCONT;\n+extern unsigned IOCTL_METEORSHWS;\n+extern unsigned IOCTL_METEORGHWS;\n+extern unsigned IOCTL_METEORSVWS;\n+extern unsigned IOCTL_METEORGVWS;\n+extern unsigned IOCTL_METEORSTS;\n+extern unsigned IOCTL_METEORGTS;\n+extern unsigned IOCTL_TVTUNER_SETCHNL;\n+extern unsigned IOCTL_TVTUNER_GETCHNL;\n+extern unsigned IOCTL_TVTUNER_SETTYPE;\n+extern unsigned IOCTL_TVTUNER_GETTYPE;\n+extern unsigned IOCTL_TVTUNER_GETSTATUS;\n+extern unsigned IOCTL_TVTUNER_SETFREQ;\n+extern unsigned IOCTL_TVTUNER_GETFREQ;\n+extern unsigned IOCTL_TVTUNER_SETAFC;\n+extern unsigned IOCTL_TVTUNER_GETAFC;\n+extern unsigned IOCTL_RADIO_SETMODE;\n+extern unsigned IOCTL_RADIO_GETMODE;\n+extern unsigned IOCTL_RADIO_SETFREQ;\n+extern unsigned IOCTL_RADIO_GETFREQ;\n+extern unsigned IOCTL_METEORSACTPIXFMT;\n+extern unsigned IOCTL_METEORGACTPIXFMT;\n+extern unsigned IOCTL_METEORGSUPPIXFMT;\n+extern unsigned IOCTL_TVTUNER_GETCHNLSET;\n+extern unsigned IOCTL_REMOTE_GETKEY;\n+extern unsigned IOCTL_GDT_IOCTL_GENERAL;\n+extern unsigned IOCTL_GDT_IOCTL_DRVERS;\n+extern unsigned IOCTL_GDT_IOCTL_CTRTYPE;\n+extern unsigned IOCTL_GDT_IOCTL_OSVERS;\n+extern unsigned IOCTL_GDT_IOCTL_CTRCNT;\n+extern unsigned IOCTL_GDT_IOCTL_EVENT;\n+extern unsigned IOCTL_GDT_IOCTL_STATIST;\n+extern unsigned IOCTL_GDT_IOCTL_RESCAN;\n+extern unsigned IOCTL_ISP_SDBLEV;\n+extern unsigned IOCTL_ISP_RESETHBA;\n+extern unsigned IOCTL_ISP_RESCAN;\n+extern unsigned IOCTL_ISP_SETROLE;\n+extern unsigned IOCTL_ISP_GETROLE;\n+extern unsigned IOCTL_ISP_GET_STATS;\n+extern unsigned IOCTL_ISP_CLR_STATS;\n+extern unsigned IOCTL_ISP_FC_LIP;\n+extern unsigned IOCTL_ISP_FC_GETDINFO;\n+extern unsigned IOCTL_ISP_GET_FW_CRASH_DUMP;\n+extern unsigned IOCTL_ISP_FORCE_CRASH_DUMP;\n+extern unsigned IOCTL_ISP_FC_GETHINFO;\n+extern unsigned IOCTL_ISP_TSK_MGMT;\n+extern unsigned IOCTL_ISP_FC_GETDLIST;\n+extern unsigned IOCTL_MLXD_STATUS;\n+extern unsigned IOCTL_MLXD_CHECKASYNC;\n+extern unsigned IOCTL_MLXD_DETACH;\n+extern unsigned IOCTL_MLX_RESCAN_DRIVES;\n+extern unsigned IOCTL_MLX_PAUSE_CHANNEL;\n+extern unsigned IOCTL_MLX_COMMAND;\n+extern unsigned IOCTL_MLX_REBUILDASYNC;\n+extern unsigned IOCTL_MLX_REBUILDSTAT;\n+extern unsigned IOCTL_MLX_GET_SYSDRIVE;\n+extern unsigned IOCTL_MLX_GET_CINFO;\n+extern unsigned IOCTL_NVME_PASSTHROUGH_CMD;\n+extern unsigned IOCTL_IRDA_RESET_PARAMS;\n+extern unsigned IOCTL_IRDA_SET_PARAMS;\n+extern unsigned IOCTL_IRDA_GET_SPEEDMASK;\n+extern unsigned IOCTL_IRDA_GET_TURNAROUNDMASK;\n+extern unsigned IOCTL_IRFRAMETTY_GET_DEVICE;\n+extern unsigned IOCTL_IRFRAMETTY_GET_DONGLE;\n+extern unsigned IOCTL_IRFRAMETTY_SET_DONGLE;\n+extern unsigned IOCTL_SATIORESET;\n+extern unsigned IOCTL_SATIOGID;\n+extern unsigned IOCTL_SATIOSBUFSIZE;\n+extern unsigned IOCTL_ISV_CMD;\n+extern unsigned IOCTL_WTQICMD;\n+extern unsigned IOCTL_ISCSI_GET_VERSION;\n+extern unsigned IOCTL_ISCSI_LOGIN;\n+extern unsigned IOCTL_ISCSI_LOGOUT;\n+extern unsigned IOCTL_ISCSI_ADD_CONNECTION;\n+extern unsigned IOCTL_ISCSI_RESTORE_CONNECTION;\n+extern unsigned IOCTL_ISCSI_REMOVE_CONNECTION;\n+extern unsigned IOCTL_ISCSI_CONNECTION_STATUS;\n+extern unsigned IOCTL_ISCSI_SEND_TARGETS;\n+extern unsigned IOCTL_ISCSI_SET_NODE_NAME;\n+extern unsigned IOCTL_ISCSI_IO_COMMAND;\n+extern unsigned IOCTL_ISCSI_REGISTER_EVENT;\n+extern unsigned IOCTL_ISCSI_DEREGISTER_EVENT;\n+extern unsigned IOCTL_ISCSI_WAIT_EVENT;\n+extern unsigned IOCTL_ISCSI_POLL_EVENT;\n+extern unsigned IOCTL_OFIOCGET;\n+extern unsigned IOCTL_OFIOCSET;\n+extern unsigned IOCTL_OFIOCNEXTPROP;\n+extern unsigned IOCTL_OFIOCGETOPTNODE;\n+extern unsigned IOCTL_OFIOCGETNEXT;\n+extern unsigned IOCTL_OFIOCGETCHILD;\n+extern unsigned IOCTL_OFIOCFINDDEVICE;\n+extern unsigned IOCTL_AMR_IO_VERSION;\n+extern unsigned IOCTL_AMR_IO_COMMAND;\n+extern unsigned IOCTL_MLYIO_COMMAND;\n+extern unsigned IOCTL_MLYIO_HEALTH;\n+extern unsigned IOCTL_PCI_IOC_CFGREAD;\n+extern unsigned IOCTL_PCI_IOC_CFGWRITE;\n+extern unsigned IOCTL_PCI_IOC_BDF_CFGREAD;\n+extern unsigned IOCTL_PCI_IOC_BDF_CFGWRITE;\n+extern unsigned IOCTL_PCI_IOC_BUSINFO;\n+extern unsigned IOCTL_PCI_IOC_DRVNAME;\n+extern unsigned IOCTL_PCI_IOC_DRVNAMEONBUS;\n+extern unsigned IOCTL_TWEIO_COMMAND;\n+extern unsigned IOCTL_TWEIO_STATS;\n+extern unsigned IOCTL_TWEIO_AEN_POLL;\n+extern unsigned IOCTL_TWEIO_AEN_WAIT;\n+extern unsigned IOCTL_TWEIO_SET_PARAM;\n+extern unsigned IOCTL_TWEIO_GET_PARAM;\n+extern unsigned IOCTL_TWEIO_RESET;\n+extern unsigned IOCTL_TWEIO_ADD_UNIT;\n+extern unsigned IOCTL_TWEIO_DEL_UNIT;\n+extern unsigned IOCTL_SIOCSCNWDOMAIN;\n+extern unsigned IOCTL_SIOCGCNWDOMAIN;\n+extern unsigned IOCTL_SIOCSCNWKEY;\n+extern unsigned IOCTL_SIOCGCNWSTATUS;\n+extern unsigned IOCTL_SIOCGCNWSTATS;\n+extern unsigned IOCTL_SIOCGCNWTRAIL;\n+extern unsigned IOCTL_SIOCGRAYSIGLEV;\n+extern unsigned IOCTL_RAIDFRAME_SHUTDOWN;\n+extern unsigned IOCTL_RAIDFRAME_TUR;\n+extern unsigned IOCTL_RAIDFRAME_FAIL_DISK;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_RECON_STATUS;\n+extern unsigned IOCTL_RAIDFRAME_REWRITEPARITY;\n+extern unsigned IOCTL_RAIDFRAME_COPYBACK;\n+extern unsigned IOCTL_RAIDFRAME_SPARET_WAIT;\n+extern unsigned IOCTL_RAIDFRAME_SEND_SPARET;\n+extern unsigned IOCTL_RAIDFRAME_ABORT_SPARET_WAIT;\n+extern unsigned IOCTL_RAIDFRAME_START_ATRACE;\n+extern unsigned IOCTL_RAIDFRAME_STOP_ATRACE;\n+extern unsigned IOCTL_RAIDFRAME_GET_SIZE;\n+extern unsigned IOCTL_RAIDFRAME_RESET_ACCTOTALS;\n+extern unsigned IOCTL_RAIDFRAME_KEEP_ACCTOTALS;\n+extern unsigned IOCTL_RAIDFRAME_GET_COMPONENT_LABEL;\n+extern unsigned IOCTL_RAIDFRAME_SET_COMPONENT_LABEL;\n+extern unsigned IOCTL_RAIDFRAME_INIT_LABELS;\n+extern unsigned IOCTL_RAIDFRAME_ADD_HOT_SPARE;\n+extern unsigned IOCTL_RAIDFRAME_REMOVE_HOT_SPARE;\n+extern unsigned IOCTL_RAIDFRAME_REBUILD_IN_PLACE;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_PARITY;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_PARITYREWRITE_STATUS;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_COPYBACK_STATUS;\n+extern unsigned IOCTL_RAIDFRAME_SET_AUTOCONFIG;\n+extern unsigned IOCTL_RAIDFRAME_SET_ROOT;\n+extern unsigned IOCTL_RAIDFRAME_DELETE_COMPONENT;\n+extern unsigned IOCTL_RAIDFRAME_INCORPORATE_HOT_SPARE;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_RECON_STATUS_EXT;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT;\n+extern unsigned IOCTL_RAIDFRAME_CHECK_COPYBACK_STATUS_EXT;\n+extern unsigned IOCTL_RAIDFRAME_CONFIGURE;\n+extern unsigned IOCTL_RAIDFRAME_GET_INFO;\n+extern unsigned IOCTL_RAIDFRAME_PARITYMAP_STATUS;\n+extern unsigned IOCTL_RAIDFRAME_PARITYMAP_GET_DISABLE;\n+extern unsigned IOCTL_RAIDFRAME_PARITYMAP_SET_DISABLE;\n+extern unsigned IOCTL_RAIDFRAME_PARITYMAP_SET_PARAMS;\n+extern unsigned IOCTL_RAIDFRAME_SET_LAST_UNIT;\n+extern unsigned IOCTL_MBPPIOCSPARAM;\n+extern unsigned IOCTL_MBPPIOCGPARAM;\n+extern unsigned IOCTL_MBPPIOCGSTAT;\n+extern unsigned IOCTL_SESIOC_GETNOBJ;\n+extern unsigned IOCTL_SESIOC_GETOBJMAP;\n+extern unsigned IOCTL_SESIOC_GETENCSTAT;\n+extern unsigned IOCTL_SESIOC_SETENCSTAT;\n+extern unsigned IOCTL_SESIOC_GETOBJSTAT;\n+extern unsigned IOCTL_SESIOC_SETOBJSTAT;\n+extern unsigned IOCTL_SESIOC_GETTEXT;\n+extern unsigned IOCTL_SESIOC_INIT;\n+extern unsigned IOCTL_SUN_DKIOCGGEOM;\n+extern unsigned IOCTL_SUN_DKIOCINFO;\n+extern unsigned IOCTL_SUN_DKIOCGPART;\n+extern unsigned IOCTL_FBIOGTYPE;\n+extern unsigned IOCTL_FBIOPUTCMAP;\n+extern unsigned IOCTL_FBIOGETCMAP;\n+extern unsigned IOCTL_FBIOGATTR;\n+extern unsigned IOCTL_FBIOSVIDEO;\n+extern unsigned IOCTL_FBIOGVIDEO;\n+extern unsigned IOCTL_FBIOSCURSOR;\n+extern unsigned IOCTL_FBIOGCURSOR;\n+extern unsigned IOCTL_FBIOSCURPOS;\n+extern unsigned IOCTL_FBIOGCURPOS;\n+extern unsigned IOCTL_FBIOGCURMAX;\n+extern unsigned IOCTL_KIOCTRANS;\n+extern unsigned IOCTL_KIOCSETKEY;\n+extern unsigned IOCTL_KIOCGETKEY;\n+extern unsigned IOCTL_KIOCGTRANS;\n+extern unsigned IOCTL_KIOCCMD;\n+extern unsigned IOCTL_KIOCTYPE;\n+extern unsigned IOCTL_KIOCSDIRECT;\n+extern unsigned IOCTL_KIOCSKEY;\n+extern unsigned IOCTL_KIOCGKEY;\n+extern unsigned IOCTL_KIOCSLED;\n+extern unsigned IOCTL_KIOCGLED;\n+extern unsigned IOCTL_KIOCLAYOUT;\n+extern unsigned IOCTL_VUIDSFORMAT;\n+extern unsigned IOCTL_VUIDGFORMAT;\n+extern unsigned IOCTL_STICIO_GXINFO;\n+extern unsigned IOCTL_STICIO_RESET;\n+extern unsigned IOCTL_STICIO_STARTQ;\n+extern unsigned IOCTL_STICIO_STOPQ;\n+extern unsigned IOCTL_UKYOPON_IDENTIFY;\n+extern unsigned IOCTL_URIO_SEND_COMMAND;\n+extern unsigned IOCTL_URIO_RECV_COMMAND;\n+extern unsigned IOCTL_USB_REQUEST;\n+extern unsigned IOCTL_USB_SETDEBUG;\n+extern unsigned IOCTL_USB_DISCOVER;\n+extern unsigned IOCTL_USB_DEVICEINFO;\n+extern unsigned IOCTL_USB_DEVICEINFO_OLD;\n+extern unsigned IOCTL_USB_DEVICESTATS;\n+extern unsigned IOCTL_USB_GET_REPORT_DESC;\n+extern unsigned IOCTL_USB_SET_IMMED;\n+extern unsigned IOCTL_USB_GET_REPORT;\n+extern unsigned IOCTL_USB_SET_REPORT;\n+extern unsigned IOCTL_USB_GET_REPORT_ID;\n+extern unsigned IOCTL_USB_GET_CONFIG;\n+extern unsigned IOCTL_USB_SET_CONFIG;\n+extern unsigned IOCTL_USB_GET_ALTINTERFACE;\n+extern unsigned IOCTL_USB_SET_ALTINTERFACE;\n+extern unsigned IOCTL_USB_GET_NO_ALT;\n+extern unsigned IOCTL_USB_GET_DEVICE_DESC;\n+extern unsigned IOCTL_USB_GET_CONFIG_DESC;\n+extern unsigned IOCTL_USB_GET_INTERFACE_DESC;\n+extern unsigned IOCTL_USB_GET_ENDPOINT_DESC;\n+extern unsigned IOCTL_USB_GET_FULL_DESC;\n+extern unsigned IOCTL_USB_GET_STRING_DESC;\n+extern unsigned IOCTL_USB_DO_REQUEST;\n+extern unsigned IOCTL_USB_GET_DEVICEINFO;\n+extern unsigned IOCTL_USB_GET_DEVICEINFO_OLD;\n+extern unsigned IOCTL_USB_SET_SHORT_XFER;\n+extern unsigned IOCTL_USB_SET_TIMEOUT;\n+extern unsigned IOCTL_USB_SET_BULK_RA;\n+extern unsigned IOCTL_USB_SET_BULK_WB;\n+extern unsigned IOCTL_USB_SET_BULK_RA_OPT;\n+extern unsigned IOCTL_USB_SET_BULK_WB_OPT;\n+extern unsigned IOCTL_USB_GET_CM_OVER_DATA;\n+extern unsigned IOCTL_USB_SET_CM_OVER_DATA;\n+extern unsigned IOCTL_UTOPPYIOTURBO;\n+extern unsigned IOCTL_UTOPPYIOCANCEL;\n+extern unsigned IOCTL_UTOPPYIOREBOOT;\n+extern unsigned IOCTL_UTOPPYIOSTATS;\n+extern unsigned IOCTL_UTOPPYIORENAME;\n+extern unsigned IOCTL_UTOPPYIOMKDIR;\n+extern unsigned IOCTL_UTOPPYIODELETE;\n+extern unsigned IOCTL_UTOPPYIOREADDIR;\n+extern unsigned IOCTL_UTOPPYIOREADFILE;\n+extern unsigned IOCTL_UTOPPYIOWRITEFILE;\n+extern unsigned IOCTL_DIOSXDCMD;\n+extern unsigned IOCTL_VT_OPENQRY;\n+extern unsigned IOCTL_VT_SETMODE;\n+extern unsigned IOCTL_VT_GETMODE;\n+extern unsigned IOCTL_VT_RELDISP;\n+extern unsigned IOCTL_VT_ACTIVATE;\n+extern unsigned IOCTL_VT_WAITACTIVE;\n+extern unsigned IOCTL_VT_GETACTIVE;\n+extern unsigned IOCTL_VT_GETSTATE;\n+extern unsigned IOCTL_KDGETKBENT;\n+extern unsigned IOCTL_KDGKBMODE;\n+extern unsigned IOCTL_KDSKBMODE;\n+extern unsigned IOCTL_KDMKTONE;\n+extern unsigned IOCTL_KDSETMODE;\n+extern unsigned IOCTL_KDENABIO;\n+extern unsigned IOCTL_KDDISABIO;\n+extern unsigned IOCTL_KDGKBTYPE;\n+extern unsigned IOCTL_KDGETLED;\n+extern unsigned IOCTL_KDSETLED;\n+extern unsigned IOCTL_KDSETRAD;\n+extern unsigned IOCTL_VGAPCVTID;\n+extern unsigned IOCTL_CONS_GETVERS;\n+extern unsigned IOCTL_WSKBDIO_GTYPE;\n+extern unsigned IOCTL_WSKBDIO_BELL;\n+extern unsigned IOCTL_WSKBDIO_COMPLEXBELL;\n+extern unsigned IOCTL_WSKBDIO_SETBELL;\n+extern unsigned IOCTL_WSKBDIO_GETBELL;\n+extern unsigned IOCTL_WSKBDIO_SETDEFAULTBELL;\n+extern unsigned IOCTL_WSKBDIO_GETDEFAULTBELL;\n+extern unsigned IOCTL_WSKBDIO_SETKEYREPEAT;\n+extern unsigned IOCTL_WSKBDIO_GETKEYREPEAT;\n+extern unsigned IOCTL_WSKBDIO_SETDEFAULTKEYREPEAT;\n+extern unsigned IOCTL_WSKBDIO_GETDEFAULTKEYREPEAT;\n+extern unsigned IOCTL_WSKBDIO_SETLEDS;\n+extern unsigned IOCTL_WSKBDIO_GETLEDS;\n+extern unsigned IOCTL_WSKBDIO_GETMAP;\n+extern unsigned IOCTL_WSKBDIO_SETMAP;\n+extern unsigned IOCTL_WSKBDIO_GETENCODING;\n+extern unsigned IOCTL_WSKBDIO_SETENCODING;\n+extern unsigned IOCTL_WSKBDIO_SETMODE;\n+extern unsigned IOCTL_WSKBDIO_GETMODE;\n+extern unsigned IOCTL_WSKBDIO_SETKEYCLICK;\n+extern unsigned IOCTL_WSKBDIO_GETKEYCLICK;\n+extern unsigned IOCTL_WSKBDIO_GETSCROLL;\n+extern unsigned IOCTL_WSKBDIO_SETSCROLL;\n+extern unsigned IOCTL_WSKBDIO_SETVERSION;\n+extern unsigned IOCTL_WSMOUSEIO_GTYPE;\n+extern unsigned IOCTL_WSMOUSEIO_SRES;\n+extern unsigned IOCTL_WSMOUSEIO_SSCALE;\n+extern unsigned IOCTL_WSMOUSEIO_SRATE;\n+extern unsigned IOCTL_WSMOUSEIO_SCALIBCOORDS;\n+extern unsigned IOCTL_WSMOUSEIO_GCALIBCOORDS;\n+extern unsigned IOCTL_WSMOUSEIO_GETID;\n+extern unsigned IOCTL_WSMOUSEIO_GETREPEAT;\n+extern unsigned IOCTL_WSMOUSEIO_SETREPEAT;\n+extern unsigned IOCTL_WSMOUSEIO_SETVERSION;\n+extern unsigned IOCTL_WSDISPLAYIO_GTYPE;\n+extern unsigned IOCTL_WSDISPLAYIO_GINFO;\n+extern unsigned IOCTL_WSDISPLAYIO_GETCMAP;\n+extern unsigned IOCTL_WSDISPLAYIO_PUTCMAP;\n+extern unsigned IOCTL_WSDISPLAYIO_GVIDEO;\n+extern unsigned IOCTL_WSDISPLAYIO_SVIDEO;\n+extern unsigned IOCTL_WSDISPLAYIO_GCURPOS;\n+extern unsigned IOCTL_WSDISPLAYIO_SCURPOS;\n+extern unsigned IOCTL_WSDISPLAYIO_GCURMAX;\n+extern unsigned IOCTL_WSDISPLAYIO_GCURSOR;\n+extern unsigned IOCTL_WSDISPLAYIO_SCURSOR;\n+extern unsigned IOCTL_WSDISPLAYIO_GMODE;\n+extern unsigned IOCTL_WSDISPLAYIO_SMODE;\n+extern unsigned IOCTL_WSDISPLAYIO_LDFONT;\n+extern unsigned IOCTL_WSDISPLAYIO_ADDSCREEN;\n+extern unsigned IOCTL_WSDISPLAYIO_DELSCREEN;\n+extern unsigned IOCTL_WSDISPLAYIO_SFONT;\n+extern unsigned IOCTL__O_WSDISPLAYIO_SETKEYBOARD;\n+extern unsigned IOCTL_WSDISPLAYIO_GETPARAM;\n+extern unsigned IOCTL_WSDISPLAYIO_SETPARAM;\n+extern unsigned IOCTL_WSDISPLAYIO_GETACTIVESCREEN;\n+extern unsigned IOCTL_WSDISPLAYIO_GETWSCHAR;\n+extern unsigned IOCTL_WSDISPLAYIO_PUTWSCHAR;\n+extern unsigned IOCTL_WSDISPLAYIO_DGSCROLL;\n+extern unsigned IOCTL_WSDISPLAYIO_DSSCROLL;\n+extern unsigned IOCTL_WSDISPLAYIO_GMSGATTRS;\n+extern unsigned IOCTL_WSDISPLAYIO_SMSGATTRS;\n+extern unsigned IOCTL_WSDISPLAYIO_GBORDER;\n+extern unsigned IOCTL_WSDISPLAYIO_SBORDER;\n+extern unsigned IOCTL_WSDISPLAYIO_SSPLASH;\n+extern unsigned IOCTL_WSDISPLAYIO_SPROGRESS;\n+extern unsigned IOCTL_WSDISPLAYIO_LINEBYTES;\n+extern unsigned IOCTL_WSDISPLAYIO_SETVERSION;\n+extern unsigned IOCTL_WSMUXIO_ADD_DEVICE;\n+extern unsigned IOCTL_WSMUXIO_REMOVE_DEVICE;\n+extern unsigned IOCTL_WSMUXIO_LIST_DEVICES;\n+extern unsigned IOCTL_WSMUXIO_INJECTEVENT;\n+extern unsigned IOCTL_WSDISPLAYIO_GET_BUSID;\n+extern unsigned IOCTL_WSDISPLAYIO_GET_EDID;\n+extern unsigned IOCTL_WSDISPLAYIO_SET_POLLING;\n+extern unsigned IOCTL_WSDISPLAYIO_GET_FBINFO;\n+extern unsigned IOCTL_WSDISPLAYIO_DOBLIT;\n+extern unsigned IOCTL_WSDISPLAYIO_WAITBLIT;\n+extern unsigned IOCTL_BIOCLOCATE;\n+extern unsigned IOCTL_BIOCINQ;\n+extern unsigned IOCTL_BIOCDISK_NOVOL;\n+extern unsigned IOCTL_BIOCDISK;\n+extern unsigned IOCTL_BIOCVOL;\n+extern unsigned IOCTL_BIOCALARM;\n+extern unsigned IOCTL_BIOCBLINK;\n+extern unsigned IOCTL_BIOCSETSTATE;\n+extern unsigned IOCTL_BIOCVOLOPS;\n+extern unsigned IOCTL_MD_GETCONF;\n+extern unsigned IOCTL_MD_SETCONF;\n+extern unsigned IOCTL_CCDIOCSET;\n+extern unsigned IOCTL_CCDIOCCLR;\n+extern unsigned IOCTL_CGDIOCSET;\n+extern unsigned IOCTL_CGDIOCCLR;\n+extern unsigned IOCTL_CGDIOCGET;\n+extern unsigned IOCTL_FSSIOCSET;\n+extern unsigned IOCTL_FSSIOCGET;\n+extern unsigned IOCTL_FSSIOCCLR;\n+extern unsigned IOCTL_FSSIOFSET;\n+extern unsigned IOCTL_FSSIOFGET;\n+extern unsigned IOCTL_BTDEV_ATTACH;\n+extern unsigned IOCTL_BTDEV_DETACH;\n+extern unsigned IOCTL_BTSCO_GETINFO;\n+extern unsigned IOCTL_KTTCP_IO_SEND;\n+extern unsigned IOCTL_KTTCP_IO_RECV;\n+extern unsigned IOCTL_IOC_LOCKSTAT_GVERSION;\n+extern unsigned IOCTL_IOC_LOCKSTAT_ENABLE;\n+extern unsigned IOCTL_IOC_LOCKSTAT_DISABLE;\n+extern unsigned IOCTL_VNDIOCSET;\n+extern unsigned IOCTL_VNDIOCCLR;\n+extern unsigned IOCTL_VNDIOCGET;\n+extern unsigned IOCTL_SPKRTONE;\n+extern unsigned IOCTL_SPKRTUNE;\n+extern unsigned IOCTL_SPKRGETVOL;\n+extern unsigned IOCTL_SPKRSETVOL;\n+extern unsigned IOCTL_BIOCGBLEN;\n+extern unsigned IOCTL_BIOCSBLEN;\n+extern unsigned IOCTL_BIOCSETF;\n+extern unsigned IOCTL_BIOCFLUSH;\n+extern unsigned IOCTL_BIOCPROMISC;\n+extern unsigned IOCTL_BIOCGDLT;\n+extern unsigned IOCTL_BIOCGETIF;\n+extern unsigned IOCTL_BIOCSETIF;\n+extern unsigned IOCTL_BIOCGSTATS;\n+extern unsigned IOCTL_BIOCGSTATSOLD;\n+extern unsigned IOCTL_BIOCIMMEDIATE;\n+extern unsigned IOCTL_BIOCVERSION;\n+extern unsigned IOCTL_BIOCSTCPF;\n+extern unsigned IOCTL_BIOCSUDPF;\n+extern unsigned IOCTL_BIOCGHDRCMPLT;\n+extern unsigned IOCTL_BIOCSHDRCMPLT;\n+extern unsigned IOCTL_BIOCSDLT;\n+extern unsigned IOCTL_BIOCGDLTLIST;\n+extern unsigned IOCTL_BIOCGSEESENT;\n+extern unsigned IOCTL_BIOCSSEESENT;\n+extern unsigned IOCTL_BIOCSRTIMEOUT;\n+extern unsigned IOCTL_BIOCGRTIMEOUT;\n+extern unsigned IOCTL_BIOCGFEEDBACK;\n+extern unsigned IOCTL_BIOCSFEEDBACK;\n+extern unsigned IOCTL_SIOCRAWATM;\n+extern unsigned IOCTL_SIOCATMENA;\n+extern unsigned IOCTL_SIOCATMDIS;\n+extern unsigned IOCTL_SIOCSPVCTX;\n+extern unsigned IOCTL_SIOCGPVCTX;\n+extern unsigned IOCTL_SIOCSPVCSIF;\n+extern unsigned IOCTL_SIOCGPVCSIF;\n+extern unsigned IOCTL_GRESADDRS;\n+extern unsigned IOCTL_GRESADDRD;\n+extern unsigned IOCTL_GREGADDRS;\n+extern unsigned IOCTL_GREGADDRD;\n+extern unsigned IOCTL_GRESPROTO;\n+extern unsigned IOCTL_GREGPROTO;\n+extern unsigned IOCTL_GRESSOCK;\n+extern unsigned IOCTL_GREDSOCK;\n+extern unsigned IOCTL_PPPIOCGRAWIN;\n+extern unsigned IOCTL_PPPIOCGFLAGS;\n+extern unsigned IOCTL_PPPIOCSFLAGS;\n+extern unsigned IOCTL_PPPIOCGASYNCMAP;\n+extern unsigned IOCTL_PPPIOCSASYNCMAP;\n+extern unsigned IOCTL_PPPIOCGUNIT;\n+extern unsigned IOCTL_PPPIOCGRASYNCMAP;\n+extern unsigned IOCTL_PPPIOCSRASYNCMAP;\n+extern unsigned IOCTL_PPPIOCGMRU;\n+extern unsigned IOCTL_PPPIOCSMRU;\n+extern unsigned IOCTL_PPPIOCSMAXCID;\n+extern unsigned IOCTL_PPPIOCGXASYNCMAP;\n+extern unsigned IOCTL_PPPIOCSXASYNCMAP;\n+extern unsigned IOCTL_PPPIOCXFERUNIT;\n+extern unsigned IOCTL_PPPIOCSCOMPRESS;\n+extern unsigned IOCTL_PPPIOCGNPMODE;\n+extern unsigned IOCTL_PPPIOCSNPMODE;\n+extern unsigned IOCTL_PPPIOCGIDLE;\n+extern unsigned IOCTL_PPPIOCGMTU;\n+extern unsigned IOCTL_PPPIOCSMTU;\n+extern unsigned IOCTL_SIOCGPPPSTATS;\n+extern unsigned IOCTL_SIOCGPPPCSTATS;\n+extern unsigned IOCTL_IOC_NPF_VERSION;\n+extern unsigned IOCTL_IOC_NPF_SWITCH;\n+extern unsigned IOCTL_IOC_NPF_LOAD;\n+extern unsigned IOCTL_IOC_NPF_TABLE;\n+extern unsigned IOCTL_IOC_NPF_STATS;\n+extern unsigned IOCTL_IOC_NPF_SAVE;\n+extern unsigned IOCTL_IOC_NPF_RULE;\n+extern unsigned IOCTL_IOC_NPF_CONN_LOOKUP;\n+extern unsigned IOCTL_PPPOESETPARMS;\n+extern unsigned IOCTL_PPPOEGETPARMS;\n+extern unsigned IOCTL_PPPOEGETSESSION;\n+extern unsigned IOCTL_SPPPGETAUTHCFG;\n+extern unsigned IOCTL_SPPPSETAUTHCFG;\n+extern unsigned IOCTL_SPPPGETLCPCFG;\n+extern unsigned IOCTL_SPPPSETLCPCFG;\n+extern unsigned IOCTL_SPPPGETSTATUS;\n+extern unsigned IOCTL_SPPPGETSTATUSNCP;\n+extern unsigned IOCTL_SPPPGETIDLETO;\n+extern unsigned IOCTL_SPPPSETIDLETO;\n+extern unsigned IOCTL_SPPPGETAUTHFAILURES;\n+extern unsigned IOCTL_SPPPSETAUTHFAILURE;\n+extern unsigned IOCTL_SPPPSETDNSOPTS;\n+extern unsigned IOCTL_SPPPGETDNSOPTS;\n+extern unsigned IOCTL_SPPPGETDNSADDRS;\n+extern unsigned IOCTL_SPPPSETKEEPALIVE;\n+extern unsigned IOCTL_SPPPGETKEEPALIVE;\n+extern unsigned IOCTL_SRT_GETNRT;\n+extern unsigned IOCTL_SRT_GETRT;\n+extern unsigned IOCTL_SRT_SETRT;\n+extern unsigned IOCTL_SRT_DELRT;\n+extern unsigned IOCTL_SRT_SFLAGS;\n+extern unsigned IOCTL_SRT_GFLAGS;\n+extern unsigned IOCTL_SRT_SGFLAGS;\n+extern unsigned IOCTL_SRT_DEBUG;\n+extern unsigned IOCTL_TAPGIFNAME;\n+extern unsigned IOCTL_TUNSDEBUG;\n+extern unsigned IOCTL_TUNGDEBUG;\n+extern unsigned IOCTL_TUNSIFMODE;\n+extern unsigned IOCTL_TUNSLMODE;\n+extern unsigned IOCTL_TUNSIFHEAD;\n+extern unsigned IOCTL_TUNGIFHEAD;\n+extern unsigned IOCTL_DIOCSTART;\n+extern unsigned IOCTL_DIOCSTOP;\n+extern unsigned IOCTL_DIOCADDRULE;\n+extern unsigned IOCTL_DIOCGETRULES;\n+extern unsigned IOCTL_DIOCGETRULE;\n+extern unsigned IOCTL_DIOCSETLCK;\n+extern unsigned IOCTL_DIOCCLRSTATES;\n+extern unsigned IOCTL_DIOCGETSTATE;\n+extern unsigned IOCTL_DIOCSETSTATUSIF;\n+extern unsigned IOCTL_DIOCGETSTATUS;\n+extern unsigned IOCTL_DIOCCLRSTATUS;\n+extern unsigned IOCTL_DIOCNATLOOK;\n+extern unsigned IOCTL_DIOCSETDEBUG;\n+extern unsigned IOCTL_DIOCGETSTATES;\n+extern unsigned IOCTL_DIOCCHANGERULE;\n+extern unsigned IOCTL_DIOCSETTIMEOUT;\n+extern unsigned IOCTL_DIOCGETTIMEOUT;\n+extern unsigned IOCTL_DIOCADDSTATE;\n+extern unsigned IOCTL_DIOCCLRRULECTRS;\n+extern unsigned IOCTL_DIOCGETLIMIT;\n+extern unsigned IOCTL_DIOCSETLIMIT;\n+extern unsigned IOCTL_DIOCKILLSTATES;\n+extern unsigned IOCTL_DIOCSTARTALTQ;\n+extern unsigned IOCTL_DIOCSTOPALTQ;\n+extern unsigned IOCTL_DIOCADDALTQ;\n+extern unsigned IOCTL_DIOCGETALTQS;\n+extern unsigned IOCTL_DIOCGETALTQ;\n+extern unsigned IOCTL_DIOCCHANGEALTQ;\n+extern unsigned IOCTL_DIOCGETQSTATS;\n+extern unsigned IOCTL_DIOCBEGINADDRS;\n+extern unsigned IOCTL_DIOCADDADDR;\n+extern unsigned IOCTL_DIOCGETADDRS;\n+extern unsigned IOCTL_DIOCGETADDR;\n+extern unsigned IOCTL_DIOCCHANGEADDR;\n+extern unsigned IOCTL_DIOCADDSTATES;\n+extern unsigned IOCTL_DIOCGETRULESETS;\n+extern unsigned IOCTL_DIOCGETRULESET;\n+extern unsigned IOCTL_DIOCRCLRTABLES;\n+extern unsigned IOCTL_DIOCRADDTABLES;\n+extern unsigned IOCTL_DIOCRDELTABLES;\n+extern unsigned IOCTL_DIOCRGETTABLES;\n+extern unsigned IOCTL_DIOCRGETTSTATS;\n+extern unsigned IOCTL_DIOCRCLRTSTATS;\n+extern unsigned IOCTL_DIOCRCLRADDRS;\n+extern unsigned IOCTL_DIOCRADDADDRS;\n+extern unsigned IOCTL_DIOCRDELADDRS;\n+extern unsigned IOCTL_DIOCRSETADDRS;\n+extern unsigned IOCTL_DIOCRGETADDRS;\n+extern unsigned IOCTL_DIOCRGETASTATS;\n+extern unsigned IOCTL_DIOCRCLRASTATS;\n+extern unsigned IOCTL_DIOCRTSTADDRS;\n+extern unsigned IOCTL_DIOCRSETTFLAGS;\n+extern unsigned IOCTL_DIOCRINADEFINE;\n+extern unsigned IOCTL_DIOCOSFPFLUSH;\n+extern unsigned IOCTL_DIOCOSFPADD;\n+extern unsigned IOCTL_DIOCOSFPGET;\n+extern unsigned IOCTL_DIOCXBEGIN;\n+extern unsigned IOCTL_DIOCXCOMMIT;\n+extern unsigned IOCTL_DIOCXROLLBACK;\n+extern unsigned IOCTL_DIOCGETSRCNODES;\n+extern unsigned IOCTL_DIOCCLRSRCNODES;\n+extern unsigned IOCTL_DIOCSETHOSTID;\n+extern unsigned IOCTL_DIOCIGETIFACES;\n+extern unsigned IOCTL_DIOCSETIFFLAG;\n+extern unsigned IOCTL_DIOCCLRIFFLAG;\n+extern unsigned IOCTL_DIOCKILLSRCNODES;\n+extern unsigned IOCTL_SLIOCGUNIT;\n+extern unsigned IOCTL_SIOCGBTINFO;\n+extern unsigned IOCTL_SIOCGBTINFOA;\n+extern unsigned IOCTL_SIOCNBTINFO;\n+extern unsigned IOCTL_SIOCSBTFLAGS;\n+extern unsigned IOCTL_SIOCSBTPOLICY;\n+extern unsigned IOCTL_SIOCSBTPTYPE;\n+extern unsigned IOCTL_SIOCGBTSTATS;\n+extern unsigned IOCTL_SIOCZBTSTATS;\n+extern unsigned IOCTL_SIOCBTDUMP;\n+extern unsigned IOCTL_SIOCSBTSCOMTU;\n+extern unsigned IOCTL_SIOCGBTFEAT;\n+extern unsigned IOCTL_SIOCADNAT;\n+extern unsigned IOCTL_SIOCRMNAT;\n+extern unsigned IOCTL_SIOCGNATS;\n+extern unsigned IOCTL_SIOCGNATL;\n+extern unsigned IOCTL_SIOCPURGENAT;\n+extern unsigned IOCTL_SIOCSIFINFO_FLAGS;\n+extern unsigned IOCTL_SIOCAADDRCTL_POLICY;\n+extern unsigned IOCTL_SIOCDADDRCTL_POLICY;\n+extern unsigned IOCTL_SMBIOC_OPENSESSION;\n+extern unsigned IOCTL_SMBIOC_OPENSHARE;\n+extern unsigned IOCTL_SMBIOC_REQUEST;\n+extern unsigned IOCTL_SMBIOC_SETFLAGS;\n+extern unsigned IOCTL_SMBIOC_LOOKUP;\n+extern unsigned IOCTL_SMBIOC_READ;\n+extern unsigned IOCTL_SMBIOC_WRITE;\n+extern unsigned IOCTL_AGPIOC_INFO;\n+extern unsigned IOCTL_AGPIOC_ACQUIRE;\n+extern unsigned IOCTL_AGPIOC_RELEASE;\n+extern unsigned IOCTL_AGPIOC_SETUP;\n+extern unsigned IOCTL_AGPIOC_ALLOCATE;\n+extern unsigned IOCTL_AGPIOC_DEALLOCATE;\n+extern unsigned IOCTL_AGPIOC_BIND;\n+extern unsigned IOCTL_AGPIOC_UNBIND;\n+extern unsigned IOCTL_AUDIO_GETINFO;\n+extern unsigned IOCTL_AUDIO_SETINFO;\n+extern unsigned IOCTL_AUDIO_DRAIN;\n+extern unsigned IOCTL_AUDIO_FLUSH;\n+extern unsigned IOCTL_AUDIO_WSEEK;\n+extern unsigned IOCTL_AUDIO_RERROR;\n+extern unsigned IOCTL_AUDIO_GETDEV;\n+extern unsigned IOCTL_AUDIO_GETENC;\n+extern unsigned IOCTL_AUDIO_GETFD;\n+extern unsigned IOCTL_AUDIO_SETFD;\n+extern unsigned IOCTL_AUDIO_PERROR;\n+extern unsigned IOCTL_AUDIO_GETIOFFS;\n+extern unsigned IOCTL_AUDIO_GETOOFFS;\n+extern unsigned IOCTL_AUDIO_GETPROPS;\n+extern unsigned IOCTL_AUDIO_GETBUFINFO;\n+extern unsigned IOCTL_AUDIO_SETCHAN;\n+extern unsigned IOCTL_AUDIO_GETCHAN;\n+extern unsigned IOCTL_AUDIO_MIXER_READ;\n+extern unsigned IOCTL_AUDIO_MIXER_WRITE;\n+extern unsigned IOCTL_AUDIO_MIXER_DEVINFO;\n+extern unsigned IOCTL_ATAIOCCOMMAND;\n+extern unsigned IOCTL_ATABUSIOSCAN;\n+extern unsigned IOCTL_ATABUSIORESET;\n+extern unsigned IOCTL_ATABUSIODETACH;\n+extern unsigned IOCTL_CDIOCPLAYTRACKS;\n+extern unsigned IOCTL_CDIOCPLAYBLOCKS;\n+extern unsigned IOCTL_CDIOCREADSUBCHANNEL;\n+extern unsigned IOCTL_CDIOREADTOCHEADER;\n+extern unsigned IOCTL_CDIOREADTOCENTRIES;\n+extern unsigned IOCTL_CDIOREADMSADDR;\n+extern unsigned IOCTL_CDIOCSETPATCH;\n+extern unsigned IOCTL_CDIOCGETVOL;\n+extern unsigned IOCTL_CDIOCSETVOL;\n+extern unsigned IOCTL_CDIOCSETMONO;\n+extern unsigned IOCTL_CDIOCSETSTEREO;\n+extern unsigned IOCTL_CDIOCSETMUTE;\n+extern unsigned IOCTL_CDIOCSETLEFT;\n+extern unsigned IOCTL_CDIOCSETRIGHT;\n+extern unsigned IOCTL_CDIOCSETDEBUG;\n+extern unsigned IOCTL_CDIOCCLRDEBUG;\n+extern unsigned IOCTL_CDIOCPAUSE;\n+extern unsigned IOCTL_CDIOCRESUME;\n+extern unsigned IOCTL_CDIOCRESET;\n+extern unsigned IOCTL_CDIOCSTART;\n+extern unsigned IOCTL_CDIOCSTOP;\n+extern unsigned IOCTL_CDIOCEJECT;\n+extern unsigned IOCTL_CDIOCALLOW;\n+extern unsigned IOCTL_CDIOCPREVENT;\n+extern unsigned IOCTL_CDIOCCLOSE;\n+extern unsigned IOCTL_CDIOCPLAYMSF;\n+extern unsigned IOCTL_CDIOCLOADUNLOAD;\n+extern unsigned IOCTL_CHIOMOVE;\n+extern unsigned IOCTL_CHIOEXCHANGE;\n+extern unsigned IOCTL_CHIOPOSITION;\n+extern unsigned IOCTL_CHIOGPICKER;\n+extern unsigned IOCTL_CHIOSPICKER;\n+extern unsigned IOCTL_CHIOGPARAMS;\n+extern unsigned IOCTL_CHIOIELEM;\n+extern unsigned IOCTL_OCHIOGSTATUS;\n+extern unsigned IOCTL_CHIOGSTATUS;\n+extern unsigned IOCTL_CHIOSVOLTAG;\n+extern unsigned IOCTL_CLOCKCTL_SETTIMEOFDAY;\n+extern unsigned IOCTL_CLOCKCTL_ADJTIME;\n+extern unsigned IOCTL_CLOCKCTL_CLOCK_SETTIME;\n+extern unsigned IOCTL_CLOCKCTL_NTP_ADJTIME;\n+extern unsigned IOCTL_IOC_CPU_SETSTATE;\n+extern unsigned IOCTL_IOC_CPU_GETSTATE;\n+extern unsigned IOCTL_IOC_CPU_GETCOUNT;\n+extern unsigned IOCTL_IOC_CPU_MAPID;\n+extern unsigned IOCTL_IOC_CPU_UCODE_GET_VERSION;\n+extern unsigned IOCTL_IOC_CPU_UCODE_APPLY;\n+extern unsigned IOCTL_DIOCGDINFO;\n+extern unsigned IOCTL_DIOCSDINFO;\n+extern unsigned IOCTL_DIOCWDINFO;\n+extern unsigned IOCTL_DIOCRFORMAT;\n+extern unsigned IOCTL_DIOCWFORMAT;\n+extern unsigned IOCTL_DIOCSSTEP;\n+extern unsigned IOCTL_DIOCSRETRIES;\n+extern unsigned IOCTL_DIOCKLABEL;\n+extern unsigned IOCTL_DIOCWLABEL;\n+extern unsigned IOCTL_DIOCSBAD;\n+extern unsigned IOCTL_DIOCEJECT;\n+extern unsigned IOCTL_ODIOCEJECT;\n+extern unsigned IOCTL_DIOCLOCK;\n+extern unsigned IOCTL_DIOCGDEFLABEL;\n+extern unsigned IOCTL_DIOCCLRLABEL;\n+extern unsigned IOCTL_DIOCGCACHE;\n+extern unsigned IOCTL_DIOCSCACHE;\n+extern unsigned IOCTL_DIOCCACHESYNC;\n+extern unsigned IOCTL_DIOCBSLIST;\n+extern unsigned IOCTL_DIOCBSFLUSH;\n+extern unsigned IOCTL_DIOCAWEDGE;\n+extern unsigned IOCTL_DIOCGWEDGEINFO;\n+extern unsigned IOCTL_DIOCDWEDGE;\n+extern unsigned IOCTL_DIOCLWEDGES;\n+extern unsigned IOCTL_DIOCGSTRATEGY;\n+extern unsigned IOCTL_DIOCSSTRATEGY;\n+extern unsigned IOCTL_DIOCGDISKINFO;\n+extern unsigned IOCTL_DIOCTUR;\n+extern unsigned IOCTL_DIOCMWEDGES;\n+extern unsigned IOCTL_DIOCGSECTORSIZE;\n+extern unsigned IOCTL_DIOCGMEDIASIZE;\n+extern unsigned IOCTL_DRVDETACHDEV;\n+extern unsigned IOCTL_DRVRESCANBUS;\n+extern unsigned IOCTL_DRVCTLCOMMAND;\n+extern unsigned IOCTL_DRVRESUMEDEV;\n+extern unsigned IOCTL_DRVLISTDEV;\n+extern unsigned IOCTL_DRVGETEVENT;\n+extern unsigned IOCTL_DRVSUSPENDDEV;\n+extern unsigned IOCTL_DVD_READ_STRUCT;\n+extern unsigned IOCTL_DVD_WRITE_STRUCT;\n+extern unsigned IOCTL_DVD_AUTH;\n+extern unsigned IOCTL_ENVSYS_GETDICTIONARY;\n+extern unsigned IOCTL_ENVSYS_SETDICTIONARY;\n+extern unsigned IOCTL_ENVSYS_REMOVEPROPS;\n+extern unsigned IOCTL_ENVSYS_GTREDATA;\n+extern unsigned IOCTL_ENVSYS_GTREINFO;\n+extern unsigned IOCTL_KFILTER_BYFILTER;\n+extern unsigned IOCTL_KFILTER_BYNAME;\n+extern unsigned IOCTL_FDIOCGETOPTS;\n+extern unsigned IOCTL_FDIOCSETOPTS;\n+extern unsigned IOCTL_FDIOCSETFORMAT;\n+extern unsigned IOCTL_FDIOCGETFORMAT;\n+extern unsigned IOCTL_FDIOCFORMAT_TRACK;\n extern unsigned IOCTL_FIOCLEX;\n-extern unsigned IOCTL_FIOGETOWN;\n-extern unsigned IOCTL_FIONBIO;\n extern unsigned IOCTL_FIONCLEX;\n+extern unsigned IOCTL_FIONREAD;\n+extern unsigned IOCTL_FIONBIO;\n+extern unsigned IOCTL_FIOASYNC;\n extern unsigned IOCTL_FIOSETOWN;\n-extern unsigned IOCTL_SIOCADDMULTI;\n+extern unsigned IOCTL_FIOGETOWN;\n+extern unsigned IOCTL_OFIOGETBMAP;\n+extern unsigned IOCTL_FIOGETBMAP;\n+extern unsigned IOCTL_FIONWRITE;\n+extern unsigned IOCTL_FIONSPACE;\n+extern unsigned IOCTL_GPIOINFO;\n+extern unsigned IOCTL_GPIOSET;\n+extern unsigned IOCTL_GPIOUNSET;\n+extern unsigned IOCTL_GPIOREAD;\n+extern unsigned IOCTL_GPIOWRITE;\n+extern unsigned IOCTL_GPIOTOGGLE;\n+extern unsigned IOCTL_GPIOATTACH;\n+extern unsigned IOCTL_PTIOCNETBSD;\n+extern unsigned IOCTL_PTIOCSUNOS;\n+extern unsigned IOCTL_PTIOCLINUX;\n+extern unsigned IOCTL_PTIOCFREEBSD;\n+extern unsigned IOCTL_PTIOCULTRIX;\n+extern unsigned IOCTL_TIOCHPCL;\n+extern unsigned IOCTL_TIOCGETP;\n+extern unsigned IOCTL_TIOCSETP;\n+extern unsigned IOCTL_TIOCSETN;\n+extern unsigned IOCTL_TIOCSETC;\n+extern unsigned IOCTL_TIOCGETC;\n+extern unsigned IOCTL_TIOCLBIS;\n+extern unsigned IOCTL_TIOCLBIC;\n+extern unsigned IOCTL_TIOCLSET;\n+extern unsigned IOCTL_TIOCLGET;\n+extern unsigned IOCTL_TIOCSLTC;\n+extern unsigned IOCTL_TIOCGLTC;\n+extern unsigned IOCTL_OTIOCCONS;\n+extern unsigned IOCTL_JOY_SETTIMEOUT;\n+extern unsigned IOCTL_JOY_GETTIMEOUT;\n+extern unsigned IOCTL_JOY_SET_X_OFFSET;\n+extern unsigned IOCTL_JOY_SET_Y_OFFSET;\n+extern unsigned IOCTL_JOY_GET_X_OFFSET;\n+extern unsigned IOCTL_JOY_GET_Y_OFFSET;\n+extern unsigned IOCTL_OKIOCGSYMBOL;\n+extern unsigned IOCTL_OKIOCGVALUE;\n+extern unsigned IOCTL_KIOCGSIZE;\n+extern unsigned IOCTL_KIOCGVALUE;\n+extern unsigned IOCTL_KIOCGSYMBOL;\n+extern unsigned IOCTL_LUAINFO;\n+extern unsigned IOCTL_LUACREATE;\n+extern unsigned IOCTL_LUADESTROY;\n+extern unsigned IOCTL_LUAREQUIRE;\n+extern unsigned IOCTL_LUALOAD;\n+extern unsigned IOCTL_MIDI_PRETIME;\n+extern unsigned IOCTL_MIDI_MPUMODE;\n+extern unsigned IOCTL_MIDI_MPUCMD;\n+extern unsigned IOCTL_SEQUENCER_RESET;\n+extern unsigned IOCTL_SEQUENCER_SYNC;\n+extern unsigned IOCTL_SEQUENCER_INFO;\n+extern unsigned IOCTL_SEQUENCER_CTRLRATE;\n+extern unsigned IOCTL_SEQUENCER_GETOUTCOUNT;\n+extern unsigned IOCTL_SEQUENCER_GETINCOUNT;\n+extern unsigned IOCTL_SEQUENCER_RESETSAMPLES;\n+extern unsigned IOCTL_SEQUENCER_NRSYNTHS;\n+extern unsigned IOCTL_SEQUENCER_NRMIDIS;\n+extern unsigned IOCTL_SEQUENCER_THRESHOLD;\n+extern unsigned IOCTL_SEQUENCER_MEMAVL;\n+extern unsigned IOCTL_SEQUENCER_PANIC;\n+extern unsigned IOCTL_SEQUENCER_OUTOFBAND;\n+extern unsigned IOCTL_SEQUENCER_GETTIME;\n+extern unsigned IOCTL_SEQUENCER_TMR_TIMEBASE;\n+extern unsigned IOCTL_SEQUENCER_TMR_START;\n+extern unsigned IOCTL_SEQUENCER_TMR_STOP;\n+extern unsigned IOCTL_SEQUENCER_TMR_CONTINUE;\n+extern unsigned IOCTL_SEQUENCER_TMR_TEMPO;\n+extern unsigned IOCTL_SEQUENCER_TMR_SOURCE;\n+extern unsigned IOCTL_SEQUENCER_TMR_METRONOME;\n+extern unsigned IOCTL_SEQUENCER_TMR_SELECT;\n+extern unsigned IOCTL_MTIOCTOP;\n+extern unsigned IOCTL_MTIOCGET;\n+extern unsigned IOCTL_MTIOCIEOT;\n+extern unsigned IOCTL_MTIOCEEOT;\n+extern unsigned IOCTL_MTIOCRDSPOS;\n+extern unsigned IOCTL_MTIOCRDHPOS;\n+extern unsigned IOCTL_MTIOCSLOCATE;\n+extern unsigned IOCTL_MTIOCHLOCATE;\n+extern unsigned IOCTL_POWER_EVENT_RECVDICT;\n+extern unsigned IOCTL_POWER_IOC_GET_TYPE;\n+extern unsigned IOCTL_POWER_IOC_GET_TYPE_WITH_LOSSAGE;\n+extern unsigned IOCTL_RIOCGINFO;\n+extern unsigned IOCTL_RIOCSINFO;\n+extern unsigned IOCTL_RIOCSSRCH;\n+extern unsigned IOCTL_RNDGETENTCNT;\n+extern unsigned IOCTL_RNDGETSRCNUM;\n+extern unsigned IOCTL_RNDGETSRCNAME;\n+extern unsigned IOCTL_RNDCTL;\n+extern unsigned IOCTL_RNDADDDATA;\n+extern unsigned IOCTL_RNDGETPOOLSTAT;\n+extern unsigned IOCTL_RNDGETESTNUM;\n+extern unsigned IOCTL_RNDGETESTNAME;\n+extern unsigned IOCTL_SCIOCGET;\n+extern unsigned IOCTL_SCIOCSET;\n+extern unsigned IOCTL_SCIOCRESTART;\n+extern unsigned IOCTL_SCIOC_USE_ADF;\n+extern unsigned IOCTL_SCIOCCOMMAND;\n+extern unsigned IOCTL_SCIOCDEBUG;\n+extern unsigned IOCTL_SCIOCIDENTIFY;\n+extern unsigned IOCTL_OSCIOCIDENTIFY;\n+extern unsigned IOCTL_SCIOCDECONFIG;\n+extern unsigned IOCTL_SCIOCRECONFIG;\n+extern unsigned IOCTL_SCIOCRESET;\n+extern unsigned IOCTL_SCBUSIOSCAN;\n+extern unsigned IOCTL_SCBUSIORESET;\n+extern unsigned IOCTL_SCBUSIODETACH;\n+extern unsigned IOCTL_SCBUSACCEL;\n+extern unsigned IOCTL_SCBUSIOLLSCAN;\n+extern unsigned IOCTL_SIOCSHIWAT;\n+extern unsigned IOCTL_SIOCGHIWAT;\n+extern unsigned IOCTL_SIOCSLOWAT;\n+extern unsigned IOCTL_SIOCGLOWAT;\n extern unsigned IOCTL_SIOCATMARK;\n-extern unsigned IOCTL_SIOCDELMULTI;\n-extern unsigned IOCTL_SIOCGIFADDR;\n-extern unsigned IOCTL_SIOCGIFBRDADDR;\n-extern unsigned IOCTL_SIOCGIFCONF;\n-extern unsigned IOCTL_SIOCGIFDSTADDR;\n-extern unsigned IOCTL_SIOCGIFFLAGS;\n-extern unsigned IOCTL_SIOCGIFMETRIC;\n-extern unsigned IOCTL_SIOCGIFMTU;\n-extern unsigned IOCTL_SIOCGIFNETMASK;\n+extern unsigned IOCTL_SIOCSPGRP;\n extern unsigned IOCTL_SIOCGPGRP;\n+extern unsigned IOCTL_SIOCADDRT;\n+extern unsigned IOCTL_SIOCDELRT;\n extern unsigned IOCTL_SIOCSIFADDR;\n-extern unsigned IOCTL_SIOCSIFBRDADDR;\n+extern unsigned IOCTL_SIOCGIFADDR;\n extern unsigned IOCTL_SIOCSIFDSTADDR;\n+extern unsigned IOCTL_SIOCGIFDSTADDR;\n extern unsigned IOCTL_SIOCSIFFLAGS;\n+extern unsigned IOCTL_SIOCGIFFLAGS;\n+extern unsigned IOCTL_SIOCGIFBRDADDR;\n+extern unsigned IOCTL_SIOCSIFBRDADDR;\n+extern unsigned IOCTL_SIOCGIFCONF;\n+extern unsigned IOCTL_SIOCGIFNETMASK;\n+extern unsigned IOCTL_SIOCSIFNETMASK;\n+extern unsigned IOCTL_SIOCGIFMETRIC;\n extern unsigned IOCTL_SIOCSIFMETRIC;\n+extern unsigned IOCTL_SIOCDIFADDR;\n+extern unsigned IOCTL_SIOCAIFADDR;\n+extern unsigned IOCTL_SIOCGIFALIAS;\n+extern unsigned IOCTL_SIOCGIFAFLAG_IN;\n+extern unsigned IOCTL_SIOCALIFADDR;\n+extern unsigned IOCTL_SIOCGLIFADDR;\n+extern unsigned IOCTL_SIOCDLIFADDR;\n+extern unsigned IOCTL_SIOCSIFADDRPREF;\n+extern unsigned IOCTL_SIOCGIFADDRPREF;\n+extern unsigned IOCTL_SIOCADDMULTI;\n+extern unsigned IOCTL_SIOCDELMULTI;\n+extern unsigned IOCTL_SIOCGETVIFCNT;\n+extern unsigned IOCTL_SIOCGETSGCNT;\n+extern unsigned IOCTL_SIOCSIFMEDIA;\n+extern unsigned IOCTL_SIOCGIFMEDIA;\n+extern unsigned IOCTL_SIOCSIFGENERIC;\n+extern unsigned IOCTL_SIOCGIFGENERIC;\n+extern unsigned IOCTL_SIOCSIFPHYADDR;\n+extern unsigned IOCTL_SIOCGIFPSRCADDR;\n+extern unsigned IOCTL_SIOCGIFPDSTADDR;\n+extern unsigned IOCTL_SIOCDIFPHYADDR;\n+extern unsigned IOCTL_SIOCSLIFPHYADDR;\n+extern unsigned IOCTL_SIOCGLIFPHYADDR;\n extern unsigned IOCTL_SIOCSIFMTU;\n-extern unsigned IOCTL_SIOCSIFNETMASK;\n-extern unsigned IOCTL_SIOCSPGRP;\n-extern unsigned IOCTL_TIOCCONS;\n+extern unsigned IOCTL_SIOCGIFMTU;\n+extern unsigned IOCTL_SIOCSDRVSPEC;\n+extern unsigned IOCTL_SIOCGDRVSPEC;\n+extern unsigned IOCTL_SIOCIFCREATE;\n+extern unsigned IOCTL_SIOCIFDESTROY;\n+extern unsigned IOCTL_SIOCIFGCLONERS;\n+extern unsigned IOCTL_SIOCGIFDLT;\n+extern unsigned IOCTL_SIOCGIFCAP;\n+extern unsigned IOCTL_SIOCSIFCAP;\n+extern unsigned IOCTL_SIOCSVH;\n+extern unsigned IOCTL_SIOCGVH;\n+extern unsigned IOCTL_SIOCINITIFADDR;\n+extern unsigned IOCTL_SIOCGIFDATA;\n+extern unsigned IOCTL_SIOCZIFDATA;\n+extern unsigned IOCTL_SIOCGLINKSTR;\n+extern unsigned IOCTL_SIOCSLINKSTR;\n+extern unsigned IOCTL_SIOCGETHERCAP;\n+extern unsigned IOCTL_SIOCGIFINDEX;\n+extern unsigned IOCTL_SIOCSETPFSYNC;\n+extern unsigned IOCTL_SIOCGETPFSYNC;\n+extern unsigned IOCTL_PPS_IOC_CREATE;\n+extern unsigned IOCTL_PPS_IOC_DESTROY;\n+extern unsigned IOCTL_PPS_IOC_SETPARAMS;\n+extern unsigned IOCTL_PPS_IOC_GETPARAMS;\n+extern unsigned IOCTL_PPS_IOC_GETCAP;\n+extern unsigned IOCTL_PPS_IOC_FETCH;\n+extern unsigned IOCTL_PPS_IOC_KCBIND;\n extern unsigned IOCTL_TIOCEXCL;\n-extern unsigned IOCTL_TIOCGETD;\n-extern unsigned IOCTL_TIOCGPGRP;\n-extern unsigned IOCTL_TIOCGWINSZ;\n-extern unsigned IOCTL_TIOCMBIC;\n-extern unsigned IOCTL_TIOCMBIS;\n-extern unsigned IOCTL_TIOCMGET;\n-extern unsigned IOCTL_TIOCMSET;\n-extern unsigned IOCTL_TIOCNOTTY;\n extern unsigned IOCTL_TIOCNXCL;\n-extern unsigned IOCTL_TIOCOUTQ;\n-extern unsigned IOCTL_TIOCPKT;\n-extern unsigned IOCTL_TIOCSCTTY;\n+extern unsigned IOCTL_TIOCFLUSH;\n+extern unsigned IOCTL_TIOCGETA;\n+extern unsigned IOCTL_TIOCSETA;\n+extern unsigned IOCTL_TIOCSETAW;\n+extern unsigned IOCTL_TIOCSETAF;\n+extern unsigned IOCTL_TIOCGETD;\n extern unsigned IOCTL_TIOCSETD;\n+extern unsigned IOCTL_TIOCGLINED;\n+extern unsigned IOCTL_TIOCSLINED;\n+extern unsigned IOCTL_TIOCSBRK;\n+extern unsigned IOCTL_TIOCCBRK;\n+extern unsigned IOCTL_TIOCSDTR;\n+extern unsigned IOCTL_TIOCCDTR;\n+extern unsigned IOCTL_TIOCGPGRP;\n extern unsigned IOCTL_TIOCSPGRP;\n+extern unsigned IOCTL_TIOCOUTQ;\n extern unsigned IOCTL_TIOCSTI;\n+extern unsigned IOCTL_TIOCNOTTY;\n+extern unsigned IOCTL_TIOCPKT;\n+extern unsigned IOCTL_TIOCSTOP;\n+extern unsigned IOCTL_TIOCSTART;\n+extern unsigned IOCTL_TIOCMSET;\n+extern unsigned IOCTL_TIOCMBIS;\n+extern unsigned IOCTL_TIOCMBIC;\n+extern unsigned IOCTL_TIOCMGET;\n+extern unsigned IOCTL_TIOCREMOTE;\n+extern unsigned IOCTL_TIOCGWINSZ;\n extern unsigned IOCTL_TIOCSWINSZ;\n-extern unsigned IOCTL_SIOCGETSGCNT;\n-extern unsigned IOCTL_SIOCGETVIFCNT;\n-extern unsigned IOCTL_MTIOCGET;\n-extern unsigned IOCTL_MTIOCTOP;\n-extern unsigned IOCTL_SIOCADDRT;\n-extern unsigned IOCTL_SIOCDELRT;\n-extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n-extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n-extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n-extern unsigned IOCTL_SNDCTL_DSP_POST;\n+extern unsigned IOCTL_TIOCUCNTL;\n+extern unsigned IOCTL_TIOCSTAT;\n+extern unsigned IOCTL_TIOCGSID;\n+extern unsigned IOCTL_TIOCCONS;\n+extern unsigned IOCTL_TIOCSCTTY;\n+extern unsigned IOCTL_TIOCEXT;\n+extern unsigned IOCTL_TIOCSIG;\n+extern unsigned IOCTL_TIOCDRAIN;\n+extern unsigned IOCTL_TIOCGFLAGS;\n+extern unsigned IOCTL_TIOCSFLAGS;\n+extern unsigned IOCTL_TIOCDCDTIMESTAMP;\n+extern unsigned IOCTL_TIOCRCVFRAME;\n+extern unsigned IOCTL_TIOCXMTFRAME;\n+extern unsigned IOCTL_TIOCPTMGET;\n+extern unsigned IOCTL_TIOCGRANTPT;\n+extern unsigned IOCTL_TIOCPTSNAME;\n+extern unsigned IOCTL_TIOCSQSIZE;\n+extern unsigned IOCTL_TIOCGQSIZE;\n+extern unsigned IOCTL_VERIEXEC_LOAD;\n+extern unsigned IOCTL_VERIEXEC_TABLESIZE;\n+extern unsigned IOCTL_VERIEXEC_DELETE;\n+extern unsigned IOCTL_VERIEXEC_QUERY;\n+extern unsigned IOCTL_VERIEXEC_DUMP;\n+extern unsigned IOCTL_VERIEXEC_FLUSH;\n+extern unsigned IOCTL_VIDIOC_QUERYCAP;\n+extern unsigned IOCTL_VIDIOC_RESERVED;\n+extern unsigned IOCTL_VIDIOC_ENUM_FMT;\n+extern unsigned IOCTL_VIDIOC_G_FMT;\n+extern unsigned IOCTL_VIDIOC_S_FMT;\n+extern unsigned IOCTL_VIDIOC_REQBUFS;\n+extern unsigned IOCTL_VIDIOC_QUERYBUF;\n+extern unsigned IOCTL_VIDIOC_G_FBUF;\n+extern unsigned IOCTL_VIDIOC_S_FBUF;\n+extern unsigned IOCTL_VIDIOC_OVERLAY;\n+extern unsigned IOCTL_VIDIOC_QBUF;\n+extern unsigned IOCTL_VIDIOC_DQBUF;\n+extern unsigned IOCTL_VIDIOC_STREAMON;\n+extern unsigned IOCTL_VIDIOC_STREAMOFF;\n+extern unsigned IOCTL_VIDIOC_G_PARM;\n+extern unsigned IOCTL_VIDIOC_S_PARM;\n+extern unsigned IOCTL_VIDIOC_G_STD;\n+extern unsigned IOCTL_VIDIOC_S_STD;\n+extern unsigned IOCTL_VIDIOC_ENUMSTD;\n+extern unsigned IOCTL_VIDIOC_ENUMINPUT;\n+extern unsigned IOCTL_VIDIOC_G_CTRL;\n+extern unsigned IOCTL_VIDIOC_S_CTRL;\n+extern unsigned IOCTL_VIDIOC_G_TUNER;\n+extern unsigned IOCTL_VIDIOC_S_TUNER;\n+extern unsigned IOCTL_VIDIOC_G_AUDIO;\n+extern unsigned IOCTL_VIDIOC_S_AUDIO;\n+extern unsigned IOCTL_VIDIOC_QUERYCTRL;\n+extern unsigned IOCTL_VIDIOC_QUERYMENU;\n+extern unsigned IOCTL_VIDIOC_G_INPUT;\n+extern unsigned IOCTL_VIDIOC_S_INPUT;\n+extern unsigned IOCTL_VIDIOC_G_OUTPUT;\n+extern unsigned IOCTL_VIDIOC_S_OUTPUT;\n+extern unsigned IOCTL_VIDIOC_ENUMOUTPUT;\n+extern unsigned IOCTL_VIDIOC_G_AUDOUT;\n+extern unsigned IOCTL_VIDIOC_S_AUDOUT;\n+extern unsigned IOCTL_VIDIOC_G_MODULATOR;\n+extern unsigned IOCTL_VIDIOC_S_MODULATOR;\n+extern unsigned IOCTL_VIDIOC_G_FREQUENCY;\n+extern unsigned IOCTL_VIDIOC_S_FREQUENCY;\n+extern unsigned IOCTL_VIDIOC_CROPCAP;\n+extern unsigned IOCTL_VIDIOC_G_CROP;\n+extern unsigned IOCTL_VIDIOC_S_CROP;\n+extern unsigned IOCTL_VIDIOC_G_JPEGCOMP;\n+extern unsigned IOCTL_VIDIOC_S_JPEGCOMP;\n+extern unsigned IOCTL_VIDIOC_QUERYSTD;\n+extern unsigned IOCTL_VIDIOC_TRY_FMT;\n+extern unsigned IOCTL_VIDIOC_ENUMAUDIO;\n+extern unsigned IOCTL_VIDIOC_ENUMAUDOUT;\n+extern unsigned IOCTL_VIDIOC_G_PRIORITY;\n+extern unsigned IOCTL_VIDIOC_S_PRIORITY;\n+extern unsigned IOCTL_VIDIOC_ENUM_FRAMESIZES;\n+extern unsigned IOCTL_VIDIOC_ENUM_FRAMEINTERVALS;\n+extern unsigned IOCTL_WDOGIOC_GMODE;\n+extern unsigned IOCTL_WDOGIOC_SMODE;\n+extern unsigned IOCTL_WDOGIOC_WHICH;\n+extern unsigned IOCTL_WDOGIOC_TICKLE;\n+extern unsigned IOCTL_WDOGIOC_GTICKLER;\n+extern unsigned IOCTL_WDOGIOC_GWDOGS;\n extern unsigned IOCTL_SNDCTL_DSP_RESET;\n-extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n-extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n+extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n+extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n-extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n-extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n-extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n-extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n-extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n-extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n-extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n-extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n-extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n-extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n-extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n-extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n-extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n-extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n-extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n-extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n-extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n-extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n-extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n-extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n-extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n-extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n-extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n-extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n-extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n-extern unsigned IOCTL_SNDCTL_TMR_START;\n-extern unsigned IOCTL_SNDCTL_TMR_STOP;\n-extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n-extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n-extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n-extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n-extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n-extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n-extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n-extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n-extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n-extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n-extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n-extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n-extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n-extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n-extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n-extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n-extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n-extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n-extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n-extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n-extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n-extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n-extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n-extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n-extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n-extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n-extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n-extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n+extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n+extern unsigned IOCTL_SNDCTL_DSP_CHANNELS;\n extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n-extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n-extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n-extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n-extern unsigned IOCTL_VT_ACTIVATE;\n-extern unsigned IOCTL_VT_GETMODE;\n-extern unsigned IOCTL_VT_OPENQRY;\n-extern unsigned IOCTL_VT_RELDISP;\n-extern unsigned IOCTL_VT_SETMODE;\n-extern unsigned IOCTL_VT_WAITACTIVE;\n-extern unsigned IOCTL_KDDISABIO;\n-extern unsigned IOCTL_KDENABIO;\n-extern unsigned IOCTL_KDGETLED;\n-extern unsigned IOCTL_KDGKBMODE;\n-extern unsigned IOCTL_KDGKBTYPE;\n-extern unsigned IOCTL_KDMKTONE;\n-extern unsigned IOCTL_KDSETLED;\n-extern unsigned IOCTL_KDSETMODE;\n-extern unsigned IOCTL_KDSKBMODE;\n+extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n+extern unsigned IOCTL_SNDCTL_DSP_POST;\n+extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n+extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n+extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n+extern unsigned IOCTL_SNDCTL_DSP_GETOSPACE;\n+extern unsigned IOCTL_SNDCTL_DSP_GETISPACE;\n+extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n+extern unsigned IOCTL_SNDCTL_DSP_GETCAPS;\n+extern unsigned IOCTL_SNDCTL_DSP_GETTRIGGER;\n+extern unsigned IOCTL_SNDCTL_DSP_SETTRIGGER;\n+extern unsigned IOCTL_SNDCTL_DSP_GETIPTR;\n+extern unsigned IOCTL_SNDCTL_DSP_GETOPTR;\n+extern unsigned IOCTL_SNDCTL_DSP_MAPINBUF;\n+extern unsigned IOCTL_SNDCTL_DSP_MAPOUTBUF;\n+extern unsigned IOCTL_SNDCTL_DSP_SETSYNCRO;\n+extern unsigned IOCTL_SNDCTL_DSP_SETDUPLEX;\n+extern unsigned IOCTL_SNDCTL_DSP_PROFILE;\n+extern unsigned IOCTL_SNDCTL_DSP_GETODELAY;\n+extern unsigned IOCTL_SOUND_MIXER_INFO;\n+extern unsigned IOCTL_SOUND_OLD_MIXER_INFO;\n+extern unsigned IOCTL_OSS_GETVERSION;\n+extern unsigned IOCTL_SNDCTL_SYSINFO;\n+extern unsigned IOCTL_SNDCTL_AUDIOINFO;\n+extern unsigned IOCTL_SNDCTL_ENGINEINFO;\n+extern unsigned IOCTL_SNDCTL_DSP_GETPLAYVOL;\n+extern unsigned IOCTL_SNDCTL_DSP_SETPLAYVOL;\n+extern unsigned IOCTL_SNDCTL_DSP_GETRECVOL;\n+extern unsigned IOCTL_SNDCTL_DSP_SETRECVOL;\n+extern unsigned IOCTL_SNDCTL_DSP_SKIP;\n+extern unsigned IOCTL_SNDCTL_DSP_SILENCE;\n \n extern const int si_SEGV_MAPERR;\n extern const int si_SEGV_ACCERR;\n@@ -561,6 +2211,8 @@ extern const int si_SEGV_ACCERR;\n   COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n                  offsetof(struct CLASS, MEMBER))\n \n+#define SIGACTION_SYMNAME __sigaction14\n+\n #endif  // SANITIZER_NETBSD\n \n #endif"}, {"sha": "e114ff42f700468b05e15272e5a4265492618b91", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.cc", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "patch": "@@ -0,0 +1,277 @@\n+//===-- sanitizer_platform_limits_openbsd.cc ------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific NetBSD data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_OPENBSD\n+#include <arpa/inet.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <grp.h>\n+#include <ifaddrs.h>\n+#include <limits.h>\n+#include <link_elf.h>\n+#include <sys/socket.h>\n+#include <net/if.h>\n+#include <net/ppp_defs.h>\n+#include <net/route.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/ip_mroute.h>\n+#include <poll.h>\n+#include <pthread.h>\n+#include <pwd.h>\n+#include <semaphore.h>\n+#include <signal.h>\n+#include <soundcard.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <sys/filio.h>\n+#include <sys/ipc.h>\n+#include <sys/mman.h>\n+#include <sys/mount.h>\n+#include <sys/msg.h>\n+#include <sys/mtio.h>\n+#include <sys/ptrace.h>\n+#include <sys/resource.h>\n+#include <sys/shm.h>\n+#include <sys/signal.h>\n+#include <sys/sockio.h>\n+#include <sys/stat.h>\n+#include <sys/statvfs.h>\n+#include <sys/time.h>\n+#include <sys/times.h>\n+#include <sys/types.h>\n+#include <sys/utsname.h>\n+#include <term.h>\n+#include <time.h>\n+#include <utime.h>\n+#include <utmp.h>\n+#include <wchar.h>\n+\n+// Include these after system headers to avoid name clashes and ambiguities.\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_openbsd.h\"\n+\n+namespace __sanitizer {\n+unsigned struct_utsname_sz = sizeof(struct utsname);\n+unsigned struct_stat_sz = sizeof(struct stat);\n+unsigned struct_rusage_sz = sizeof(struct rusage);\n+unsigned struct_tm_sz = sizeof(struct tm);\n+unsigned struct_passwd_sz = sizeof(struct passwd);\n+unsigned struct_group_sz = sizeof(struct group);\n+unsigned siginfo_t_sz = sizeof(siginfo_t);\n+unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+unsigned struct_itimerval_sz = sizeof(struct itimerval);\n+unsigned pthread_t_sz = sizeof(pthread_t);\n+unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);\n+unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n+unsigned pid_t_sz = sizeof(pid_t);\n+unsigned timeval_sz = sizeof(timeval);\n+unsigned uid_t_sz = sizeof(uid_t);\n+unsigned gid_t_sz = sizeof(gid_t);\n+unsigned mbstate_t_sz = sizeof(mbstate_t);\n+unsigned sigset_t_sz = sizeof(sigset_t);\n+unsigned struct_timezone_sz = sizeof(struct timezone);\n+unsigned struct_tms_sz = sizeof(struct tms);\n+unsigned struct_sched_param_sz = sizeof(struct sched_param);\n+unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n+unsigned struct_rlimit_sz = sizeof(struct rlimit);\n+unsigned struct_timespec_sz = sizeof(struct timespec);\n+unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n+unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n+unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n+unsigned struct_statvfs_sz = sizeof(struct statvfs);\n+\n+const uptr sig_ign = (uptr)SIG_IGN;\n+const uptr sig_dfl = (uptr)SIG_DFL;\n+const uptr sig_err = (uptr)SIG_ERR;\n+const uptr sa_siginfo = (uptr)SA_SIGINFO;\n+\n+int shmctl_ipc_stat = (int)IPC_STAT;\n+\n+unsigned struct_utmp_sz = sizeof(struct utmp);\n+\n+int map_fixed = MAP_FIXED;\n+\n+int af_inet = (int)AF_INET;\n+int af_inet6 = (int)AF_INET6;\n+\n+uptr __sanitizer_in_addr_sz(int af) {\n+  if (af == AF_INET)\n+    return sizeof(struct in_addr);\n+  else if (af == AF_INET6)\n+    return sizeof(struct in6_addr);\n+  else\n+    return 0;\n+}\n+\n+unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n+\n+int glob_nomatch = GLOB_NOMATCH;\n+int glob_altdirfunc = GLOB_ALTDIRFUNC;\n+\n+unsigned path_max = PATH_MAX;\n+\n+const int si_SEGV_MAPERR = SEGV_MAPERR;\n+const int si_SEGV_ACCERR = SEGV_ACCERR;\n+}  // namespace __sanitizer\n+\n+using namespace __sanitizer;\n+\n+COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n+\n+COMPILER_CHECK(sizeof(socklen_t) == sizeof(unsigned));\n+CHECK_TYPE_SIZE(pthread_key_t);\n+\n+CHECK_TYPE_SIZE(dl_phdr_info);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_addr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n+\n+CHECK_TYPE_SIZE(glob_t);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_offs);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_flags);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_closedir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_readdir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_opendir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_lstat);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_stat);\n+\n+CHECK_TYPE_SIZE(addrinfo);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_flags);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_family);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_socktype);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addrlen);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addr);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_canonname);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_next);\n+\n+CHECK_TYPE_SIZE(hostent);\n+CHECK_SIZE_AND_OFFSET(hostent, h_name);\n+CHECK_SIZE_AND_OFFSET(hostent, h_aliases);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addrtype);\n+CHECK_SIZE_AND_OFFSET(hostent, h_length);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addr_list);\n+\n+CHECK_TYPE_SIZE(iovec);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_base);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_len);\n+\n+CHECK_TYPE_SIZE(msghdr);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_name);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_namelen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iov);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iovlen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_control);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_controllen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_flags);\n+\n+CHECK_TYPE_SIZE(cmsghdr);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_len);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_level);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_type);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_dirent) <= sizeof(dirent));\n+CHECK_SIZE_AND_OFFSET(dirent, d_fileno);\n+CHECK_SIZE_AND_OFFSET(dirent, d_off);\n+CHECK_SIZE_AND_OFFSET(dirent, d_reclen);\n+\n+CHECK_TYPE_SIZE(ifconf);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_len);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_ifcu);\n+\n+CHECK_TYPE_SIZE(pollfd);\n+CHECK_SIZE_AND_OFFSET(pollfd, fd);\n+CHECK_SIZE_AND_OFFSET(pollfd, events);\n+CHECK_SIZE_AND_OFFSET(pollfd, revents);\n+\n+CHECK_TYPE_SIZE(nfds_t);\n+\n+CHECK_TYPE_SIZE(sigset_t);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_sigaction) == sizeof(struct sigaction));\n+// Can't write checks for sa_handler and sa_sigaction due to them being\n+// preprocessor macros.\n+CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_mask);\n+\n+CHECK_TYPE_SIZE(tm);\n+CHECK_SIZE_AND_OFFSET(tm, tm_sec);\n+CHECK_SIZE_AND_OFFSET(tm, tm_min);\n+CHECK_SIZE_AND_OFFSET(tm, tm_hour);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mon);\n+CHECK_SIZE_AND_OFFSET(tm, tm_year);\n+CHECK_SIZE_AND_OFFSET(tm, tm_wday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_yday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_isdst);\n+CHECK_SIZE_AND_OFFSET(tm, tm_gmtoff);\n+CHECK_SIZE_AND_OFFSET(tm, tm_zone);\n+\n+CHECK_TYPE_SIZE(ipc_perm);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, uid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, gid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, mode);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, seq);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, key);\n+\n+CHECK_TYPE_SIZE(shmid_ds);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_perm);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_segsz);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_atime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, __shm_atimensec);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_dtime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, __shm_dtimensec);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_ctime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, __shm_ctimensec);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_cpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_lpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_nattch);\n+\n+CHECK_TYPE_SIZE(clock_t);\n+\n+CHECK_TYPE_SIZE(ifaddrs);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_next);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_name);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_addr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_netmask);\n+// Compare against the union, because we can't reach into the union in a\n+// compliant way.\n+#ifdef ifa_dstaddr\n+#undef ifa_dstaddr\n+#endif\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n+\n+CHECK_TYPE_SIZE(passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_name);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_uid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_dir);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_shell);\n+\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gecos);\n+\n+CHECK_TYPE_SIZE(group);\n+CHECK_SIZE_AND_OFFSET(group, gr_name);\n+CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n+CHECK_SIZE_AND_OFFSET(group, gr_gid);\n+CHECK_SIZE_AND_OFFSET(group, gr_mem);\n+\n+#endif  // SANITIZER_OPENBSD"}, {"sha": "8f21de7522883f05fc267c2d62d247f03541cb57", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "6cd4a5bac8b0a2d78eb641cb2165c5b46ab6400f", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "91f38918f35c55cb5cc210721abcfc9eff196b41", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "00b0ffcff598cf9b265af5c1ad718900b6ac78cf", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.cc", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "0bd3de88562385c64a37d2c9111d10c902ba13fb", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.h", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "71994bac840915be82df5f0a2c037931fab90dec", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "a013f354eec0daa5aea0d0fdbc12e160e272f3a8", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "a0e96fac223e6043699ea75174d29b6ef3f741df", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "5da8c5f189d2b2d48f0ccd0ebc0957d27782d0b6", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "606b29214434194e4668bd0d617110805684b0ca", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "b7887d9e4d3629df99439ef27c46ded5c7972f83", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_bsd.cc", "status": "renamed", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_bsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_bsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_bsd.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_freebsd.cc"}, {"sha": "24cf9f8b00d2ccdeb6a6ecdd9e7e78856212b53f", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cc", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "f9092f4832e6e3580978d757fd335d5d7c680687", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "b0e68fde7626c827dafb373c407f73a802a67aca", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "bfe83170f4e2add18bf4990dadaa3570b9e18bb4", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_solaris.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "0ebe97d1e40e750fc377ca98781a3745bea38cfb", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "b46a02844dfbeb690593c7f058071fc631cebbef", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "39ee6315a708abd471cf2de8c5dd8678ec458225", "filename": "libsanitizer/sanitizer_common/sanitizer_ring_buffer.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_ring_buffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_ring_buffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_ring_buffer.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "2792c59da60d4866797d20d401ac5216e123faf6", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "dc64bbc00dfe69aacfb692e9fbfbfe7735dbdc3d", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "7ec63396d7953c55a453dd820178b937709d4809", "filename": "libsanitizer/sanitizer_common/sanitizer_signal_interceptors.inc", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "a5db22994e0ab5b93c830b0bf40b90e0fcb08cdc", "filename": "libsanitizer/sanitizer_common/sanitizer_solaris.cc", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "d48f7d2768942bd7c3302ca6bf7f28b25e2e4056", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "db51f5926d20f9bdef09449a225e5a6dd71d2590", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "fa457d5bfb41ab68223242248b7bf23bb3a011e9", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "ff085519e52c681b8419de9fd1df135c2ad16621", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "7e21c4b883fac367f332f800690e456975a14c39", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cc", "status": "modified", "additions": 82, "deletions": 5, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "623fba25ed572125370282ebae9eb8ea31963f93", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_sparc.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "635c5732d841dfd18356ddb35f1efb619e94cbba", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "6c682a1fb62f5280f40b12d926b70ac9c9bb61e2", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "ef2fb4a0af3fdeb07aa7d25a06cc92f5d357d4c8", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "2f68075225534f02e13f16c9ea0823df3df60fd7", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_fuchsia.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "9e57bb624858e5f6706b3278d4cc7fc16c819a5e", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "3897aab0b9a2278c6c5e420f3ceccdc7c22eb835", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cc", "status": "renamed", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_fuchsia.cc"}, {"sha": "750e89e2960a9d743144bb9740b0b0aadf75b27e", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "1157724125e3b8ef6213dd83a14244460b5f2884", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "2afd01ed9f7a4e323874d557c520ec12f96e7eaf", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_rtems.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "3b455125c7a1896c00df6849e0f7c7b9b28d298b", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "0c3b7f970457f8e3e2b9e7c271cb3755590e014e", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "71ac0d52d0c431a998b4f70e023c70ee567640c7", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_arm.inc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_arm.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_arm.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_arm.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "4fd4d06a0d129fa006733a1f30da86d209c691a1", "filename": "libsanitizer/sanitizer_common/sanitizer_syscalls_netbsd.inc", "status": "added", "additions": 3784, "deletions": 0, "changes": 3784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "79754fa1dbffcf49168a5af632dbed14cc5664e9", "filename": "libsanitizer/sanitizer_common/sanitizer_termination.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "0ab1ec360ee2cd4598ce002a16b305630c1f5d49", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "7dba28c388f1578747601916b8c5b0a58343be3a", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "f1482c2a53b238b39861fa15324d4bd0b1a098d5", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "460c000b79f8bb59d8f452f6fc3fa6b9ac07884e", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "8ea62faee5208a3d9834273311c9fac5703c3578", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_win.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "ad6510bbe46db881635406dc1dcf63c40ebf41d3", "filename": "libsanitizer/sanitizer_common/sanitizer_vector.h", "status": "renamed", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4", "previous_filename": "libsanitizer/tsan/tsan_vector.h"}, {"sha": "ebc6c503036412354eb1475123201f74c929121d", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 85, "deletions": 93, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "1b1a86c4719ccad642f73522dc499734736e1aba", "filename": "libsanitizer/sanitizer_common/sanitizer_win_defs.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "3ee428b47236b2bfbaac706cb4e3a3679cae213c", "filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "722b6c1b470b54cb12db366b8357c146675296b1", "filename": "libsanitizer/tsan/tsan_debugging.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_debugging.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "069df5951d801b4c27f500d007b59560da285ff4", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 376, "deletions": 229, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "959a39465e33d2a5c294c8ea43140c8900f76781", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "1df6ac27f49a04c05b6b56e51a09c6acfd7ba8d8", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cc", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "bb097b9554bb8a9f40f3d24a4837be1fe015530b", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "3e2b7c83c3a4d10beaa8e32042a12c11c89a648d", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "f7e08d46fbbddfa5b2b43752aa1b5082bd59180d", "filename": "libsanitizer/tsan/tsan_libdispatch_mac.cc", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "618fa2d6702af16c4424c01fec04a7265bbbd1b8", "filename": "libsanitizer/tsan/tsan_malloc_mac.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "76d12a43b2736cec6fe0a376caed9fa4248bf801", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "1346aa7a4e6e332b38fcacacbf33451608772c7e", "filename": "libsanitizer/tsan/tsan_new_delete.cc", "status": "modified", "additions": 106, "deletions": 1, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_new_delete.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "871df468b65bb1558504ade9733136467bc61076", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 143, "deletions": 28, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "9b4dea206594c4b50df23936b9ba37021c8a8b77", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "14395ba614a4b4b6071d87e14b655291347a05fe", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "df9b6d4182866d5f0b25589921c8aeef468454ed", "filename": "libsanitizer/tsan/tsan_platform_posix.cc", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "4dffc342a92ab2d00332f6ed7895e3c8d70a8415", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "8e96e975804870d6b0498f9b2222794739970321", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "bd0892d0de56fb11fdc1aaa95e33debf4da608c1", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "f97b583c48b9d8b84f61ad4d4f0ba66a0c7275c0", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "3d02bf22f8a550cc7ccccacb0804b417c12fbe74", "filename": "libsanitizer/tsan/tsan_rtl_aarch64.S", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "34ef51c2a725704815630699073263c97aaf8d83", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "modified", "additions": 70, "deletions": 44, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "6981f98dcb93f86ec6b0f7cb786e8cfe34ab323e", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "18b6cf7fd50ce1d11e50f7b5fee2db4389fc0bdd", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "7a731c4006acd01dac5fb568b0fe25a648c58962", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "4ddec965f32381a446e40aafce57192257cce15e", "filename": "libsanitizer/tsan/tsan_stack_trace.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "bc4468f4405ea0bf2693668b5a80562456b69716", "filename": "libsanitizer/tsan/tsan_stack_trace.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_stack_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_stack_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "d48148fed5c09a3ea752f4e922e0cd5ff29efa60", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "074006be70d1c438ebe2892376991716f3908290", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "10ae446e58b4925c697bf38b65c8b37ce0c8e0d2", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "a4409fe49ae3a2a93775df1160e6e12b141ca3b2", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "dbe5550a9e4c488cb99aa78cfb5c74bccc0d2634", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "cdf15b70e26d097e4c6ef11fe3ac0d65b2d0b71a", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "429a9ecd69d339a31a6b5e7ba6f81deba63553d2", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "a7ecc755e4693c175cfbdaabc110487d69fba759", "filename": "libsanitizer/ubsan/ubsan_flags.cc", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "438ea0b81bef106c72c9974266216f0df5a71a36", "filename": "libsanitizer/ubsan/ubsan_flags.inc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "927ad4c95312627268506933d0c3ab9295c725c8", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 139, "deletions": 46, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "56e664c751be16186dda84f660acf8e01a55addf", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "912617010a8eb7e8f863f54bc43520b553e4e868", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cc", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "fd26b49e4e711709f320d2a35247ff411f76f103", "filename": "libsanitizer/ubsan/ubsan_init_standalone_preinit.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_init_standalone_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_init_standalone_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init_standalone_preinit.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "ef0842d9339461bd9ad425e7b9c2dd909633bbf9", "filename": "libsanitizer/ubsan/ubsan_interface.inc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_interface.inc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "81180a63917c273e6180fa6fc07819f95eef987b", "filename": "libsanitizer/ubsan/ubsan_monitor.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_monitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_monitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_monitor.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "632bd256e7e2ac051f9a1d6272519a21a6d0ccda", "filename": "libsanitizer/ubsan/ubsan_monitor.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_monitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_monitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_monitor.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "75d06646ce893c9b4fafee714c96cd6c42847a8e", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "5e77c60b1dbb53e0d8c1d954f99bc54182941b3b", "filename": "libsanitizer/ubsan/ubsan_signals_standalone.cc", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_signals_standalone.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "b29c29482ec8071c160120e817b4ff0a0d25b3b0", "filename": "libsanitizer/ubsan/ubsan_signals_standalone.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_signals_standalone.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_signals_standalone.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_signals_standalone.h?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}, {"sha": "9f0a8f1d38a0a3a3d947d119a7f4780fda18a474", "filename": "libsanitizer/ubsan/ubsan_win_weak_interception.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_win_weak_interception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac975312214dccb9d425b3e8d0b93e85c11ddf4/libsanitizer%2Fubsan%2Fubsan_win_weak_interception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_win_weak_interception.cc?ref=eac975312214dccb9d425b3e8d0b93e85c11ddf4"}]}