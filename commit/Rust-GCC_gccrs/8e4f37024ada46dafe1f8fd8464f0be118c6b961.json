{"sha": "8e4f37024ada46dafe1f8fd8464f0be118c6b961", "node_id": "C_kwDOANBUbNoAKDhlNGYzNzAyNGFkYTQ2ZGFmZTFmOGZkODQ2NGYwYmUxMThjNmI5NjE", "commit": {"author": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-03-18T09:32:41Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-18T08:41:03Z"}, "message": "[Ada] Rework optimization skipping pragma check in object declaration\n\nWhen an object declaration is initialized with a type conversion:\n\n Var : Typ := Typ (Value);\n\nwe skip the check for Typ's predicate as it is already checked\nduring the type conversion.\n\nThis is not correct when Var's subtype and the target subtype of the\nconversion do not statically match:\n\n Var : Typ := OtherTyp (Value);\n\nIn such case, we can't skip the check of Typ's predicate.\n\nFix minor typos in comment.\n\ngcc/ada/\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): Skip predicate check\n\tfor type conversion if object's subtype and expression's subtype\n\tstatically match.\n\t* exp_prag.adb (Expand_Pragma_Check): Typo fix in comment.", "tree": {"sha": "16d16460a7c85eca57c218cf6757b5eb959592e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16d16460a7c85eca57c218cf6757b5eb959592e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e4f37024ada46dafe1f8fd8464f0be118c6b961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4f37024ada46dafe1f8fd8464f0be118c6b961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4f37024ada46dafe1f8fd8464f0be118c6b961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4f37024ada46dafe1f8fd8464f0be118c6b961/comments", "author": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de02cb5d72cfbac5a7a5537c5bf85c11f716f806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de02cb5d72cfbac5a7a5537c5bf85c11f716f806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de02cb5d72cfbac5a7a5537c5bf85c11f716f806"}], "stats": {"total": 12, "additions": 8, "deletions": 4}, "files": [{"sha": "5f1308777e8256f25c476ba2b5d825f7b6a5b738", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4f37024ada46dafe1f8fd8464f0be118c6b961/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4f37024ada46dafe1f8fd8464f0be118c6b961/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=8e4f37024ada46dafe1f8fd8464f0be118c6b961", "patch": "@@ -285,7 +285,7 @@ package body Exp_Prag is\n       --  expression is not usually the best choice here, because it points to\n       --  the location of the topmost tree node, which may be an operator in\n       --  the middle of the source text of the expression. For example, it gets\n-      --  located on the last AND keyword in a chain of boolean expressiond\n+      --  located on the last AND keyword in a chain of boolean expressions\n       --  AND'ed together. It is best to put the message on the first character\n       --  of the condition, which is the effect of the First_Node call here.\n       --  This source location is used to build the default exception message,"}, {"sha": "34dac1df6246c2a6f66a83c439b61c0c1d7a6344", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4f37024ada46dafe1f8fd8464f0be118c6b961/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4f37024ada46dafe1f8fd8464f0be118c6b961/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8e4f37024ada46dafe1f8fd8464f0be118c6b961", "patch": "@@ -4572,11 +4572,15 @@ package body Sem_Ch3 is\n             null;\n \n          --  Do not generate a predicate check if the initialization expression\n-         --  is a type conversion because the conversion has been subjected to\n-         --  the same check. This is a small optimization which avoid redundant\n+         --  is a type conversion whose target subtype statically matches the\n+         --  object's subtype because the conversion has been subjected to the\n+         --  same check. This is a small optimization which avoids redundant\n          --  checks.\n \n-         elsif Present (E) and then Nkind (E) = N_Type_Conversion then\n+         elsif Present (E)\n+           and then Nkind (E) in N_Type_Conversion\n+           and then Subtypes_Statically_Match (Etype (Subtype_Mark (E)), T)\n+         then\n             null;\n \n          else"}]}