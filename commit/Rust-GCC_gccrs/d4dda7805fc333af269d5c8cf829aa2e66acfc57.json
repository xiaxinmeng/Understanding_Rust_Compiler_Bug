{"sha": "d4dda7805fc333af269d5c8cf829aa2e66acfc57", "node_id": "C_kwDOANBUbNoAKGQ0ZGRhNzgwNWZjMzMzYWYyNjlkNWM4Y2Y4MjlhYTJlNjZhY2ZjNTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-07T13:54:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-07T13:54:53Z"}, "message": "Merge #1363\n\n1363: Refactor Lexer to support an abstract InputSource class r=philberty a=philberty\n\nThis patch allows us to remove the fmemopen lex_string hack to support\r\nparsing buffers. This will allow us to support mutliple sources such as\r\nmetadata imports etc. The patch here updates the parser to hold onto a\r\nreference to the lexer rather than 'owning' the lexer which allows us to\r\ndecouple the move semantics here.\r\n\r\nFixes #1203 \r\nFixes #1000\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "1603981f6e786c1914d11ad610cd10d2658473ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1603981f6e786c1914d11ad610cd10d2658473ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4dda7805fc333af269d5c8cf829aa2e66acfc57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixuWtCRBK7hj4Ov3rIwAAk+EIAKV4Ww9DrK1kAk9PoBnqSbXM\n7VqO9NHLUP7FakRLkSPIdeoH1TgxHWXOJoHhD7BtKyj1E/5RYN6WLsomHMzTUH95\nTSeeTWTVAMFbsZNQWo1ZuuRfNeyxCVedvAPZpd3tRqpqjoVdc4HhLzaPnxU0r2PO\nCqRPHJGNhwFU3zFOfGVAM3CK9CNU8c1wodkkpFUylCHa649D8zMFa6D+YRt1YXf9\nSVMvrBlGfr2CAj7Fc8kV0lEj3ZuDRdA+TRg9ZxImaC/MWPrzN+m8FJMg2naPEzBw\naZhhCF0vx/IGS8kRigh3z/lE5BIMkHkQNbh/3k79IFenyPX+ghMMMrtMcIVZycQ=\n=r1C7\n-----END PGP SIGNATURE-----\n", "payload": "tree 1603981f6e786c1914d11ad610cd10d2658473ef\nparent 98b3f9bca253d1ecfae6fb94d255d8e991e4b92c\nparent ec5da37dbfbcc55183f7ea4658c8856b9335ad61\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657202093 +0000\ncommitter GitHub <noreply@github.com> 1657202093 +0000\n\nMerge #1363\n\n1363: Refactor Lexer to support an abstract InputSource class r=philberty a=philberty\n\nThis patch allows us to remove the fmemopen lex_string hack to support\r\nparsing buffers. This will allow us to support mutliple sources such as\r\nmetadata imports etc. The patch here updates the parser to hold onto a\r\nreference to the lexer rather than 'owning' the lexer which allows us to\r\ndecouple the move semantics here.\r\n\r\nFixes #1203 \r\nFixes #1000\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dda7805fc333af269d5c8cf829aa2e66acfc57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4dda7805fc333af269d5c8cf829aa2e66acfc57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dda7805fc333af269d5c8cf829aa2e66acfc57/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98b3f9bca253d1ecfae6fb94d255d8e991e4b92c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b3f9bca253d1ecfae6fb94d255d8e991e4b92c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98b3f9bca253d1ecfae6fb94d255d8e991e4b92c"}, {"sha": "ec5da37dbfbcc55183f7ea4658c8856b9335ad61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5da37dbfbcc55183f7ea4658c8856b9335ad61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5da37dbfbcc55183f7ea4658c8856b9335ad61"}], "stats": {"total": 144, "additions": 75, "deletions": 69}, "files": [{"sha": "25ec6db755625b83f6c64b0160035e3574537486", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -4044,8 +4044,7 @@ Module::load_items ()\n \n   RAIIFile file_wrap (module_file.c_str ());\n   Linemap *linemap = Session::get_instance ().linemap;\n-\n-  if (file_wrap.get_raw () == nullptr)\n+  if (!file_wrap.ok ())\n     {\n       rust_error_at (get_locus (), \"cannot open module file %s: %m\",\n \t\t     module_file.c_str ());\n@@ -4055,10 +4054,9 @@ Module::load_items ()\n   rust_debug (\"Attempting to parse file %s\", module_file.c_str ());\n \n   Lexer lex (module_file.c_str (), std::move (file_wrap), linemap);\n-  Parser<Lexer> parser (std::move (lex));\n+  Parser<Lexer> parser (lex);\n \n   auto parsed_items = parser.parse_items ();\n-\n   for (const auto &error : parser.get_errors ())\n     error.emit_error ();\n "}, {"sha": "5eace13d1974337a0cf56cdb9d8e1b7d9d3067e8", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -70,7 +70,7 @@ parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n \t\t\t     Location invoc_locus)\n {\n   MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n+  Parser<MacroInvocLexer> parser (lex);\n \n   auto last_token_id = macro_end_token (invoc_token_tree, parser);\n \n@@ -270,7 +270,8 @@ MacroBuiltin::concat (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto invoc_token_tree = invoc.get_delim_tok_tree ();\n   MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n+  Parser<MacroInvocLexer> parser (lex);\n+\n   auto str = std::string ();\n   bool has_error = false;\n \n@@ -313,7 +314,7 @@ MacroBuiltin::env (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   auto invoc_token_tree = invoc.get_delim_tok_tree ();\n   MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n+  Parser<MacroInvocLexer> parser (lex);\n \n   auto last_token_id = macro_end_token (invoc_token_tree, parser);\n \n@@ -432,7 +433,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n   RAIIFile target_file (target_filename);\n   Linemap *linemap = Session::get_instance ().linemap;\n \n-  if (target_file.get_raw () == nullptr)\n+  if (!target_file.ok ())\n     {\n       rust_error_at (lit_expr->get_locus (),\n \t\t     \"cannot open included file %qs: %m\", target_filename);\n@@ -442,7 +443,7 @@ MacroBuiltin::include (Location invoc_locus, AST::MacroInvocData &invoc)\n   rust_debug (\"Attempting to parse included file %s\", target_filename);\n \n   Lexer lex (target_filename, std::move (target_file), linemap);\n-  Parser<Lexer> parser (std::move (lex));\n+  Parser<Lexer> parser (lex);\n \n   auto parsed_items = parser.parse_items ();\n   bool has_error = !parser.get_errors ().empty ();"}, {"sha": "d8684c830466083c119d66d961f0e9c7f91d0d44", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -375,7 +375,7 @@ MacroExpander::try_match_rule (AST::MacroRule &match_rule,\n \t\t\t       AST::DelimTokenTree &invoc_token_tree)\n {\n   MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n+  Parser<MacroInvocLexer> parser (lex);\n \n   AST::MacroMatcher &matcher = match_rule.get_matcher ();\n \n@@ -975,7 +975,7 @@ MacroExpander::transcribe_rule (\n \n   // parse it to an ASTFragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n+  Parser<MacroInvocLexer> parser (lex);\n \n   auto last_token_id = TokenId::RIGHT_CURLY;\n "}, {"sha": "93d96d33dd61b410adaed3afd4c7dbe1a6ecb4a0", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -116,14 +116,17 @@ is_non_decimal_int_literal_separator (char character)\n   return character == 'x' || character == 'o' || character == 'b';\n }\n \n-// this compiles fine, so any intellisense saying otherwise is fake news\n+Lexer::Lexer (const std::string &input)\n+  : input (RAIIFile::create_error ()), current_line (1), current_column (1),\n+    line_map (nullptr), raw_input_source (new BufferInputSource (input, 0)),\n+    input_queue{*raw_input_source}, token_queue (TokenSource (this))\n+{}\n+\n Lexer::Lexer (const char *filename, RAIIFile file_input, Linemap *linemap)\n   : input (std::move (file_input)), current_line (1), current_column (1),\n     line_map (linemap),\n-    /*input_source (input.get_raw ()), */\n-    input_queue{InputSource (input.get_raw ())},\n-    /*token_source (this),*/\n-    token_queue (TokenSource (this))\n+    raw_input_source (new FileInputSource (input.get_raw ())),\n+    input_queue{*raw_input_source}, token_queue (TokenSource (this))\n {\n   // inform line_table that file is being entered and is in line 1\n   if (linemap)\n@@ -138,6 +141,7 @@ Lexer::~Lexer ()\n    * mentioned in GCC docs as being useful for \"just leaving an included header\"\n    * and stuff like that, so this line mapping functionality may need fixing.\n    * FIXME: find out whether this occurs. */\n+\n   // line_map->stop();\n }\n "}, {"sha": "d5a6c53719ff24b82d728da88132d8f4e5429e80", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -72,10 +72,14 @@ struct RAIIFile\n     return *this;\n   }\n \n+  static RAIIFile create_error () { return RAIIFile (nullptr, nullptr); }\n+\n   ~RAIIFile () { close (); }\n \n   FILE *get_raw () { return file; }\n   const char *get_filename () { return filename; }\n+\n+  bool ok () const { return file; }\n };\n \n class Lexer\n@@ -136,43 +140,12 @@ class Lexer\n public:\n   // Construct lexer with input file and filename provided\n   Lexer (const char *filename, RAIIFile input, Linemap *linemap);\n-  ~Lexer ();\n \n-  /**\n-   * Lex the contents of a string instead of a file\n-   */\n-  // FIXME: This is unsafe!\n-  // Since we are taking a reference to the string's internal buffer, we must\n-  // ensure that the lexer does not outlive the string, which might not always\n-  // be the case.\n-  //\n-  // We could have a fix, which would include using fmemopen() to allocate a\n-  // buffer and copy the string inside it.\n-  // ```\n-  // // There will be an extra nul-terminator byte written on fclose(), so\n-  // // account for that\n-  // auto string_file = fmemopen(NULL, input.length() + 1, \"wr\");\n-  // fwrite(input.c_str(), sizeof(char), input.length(), string_file);\n-  // auto wrapper = RAIIFile(string_file);\n-  // ```\n-  // But sadly our RAIIFile does not support moving really well... And the\n-  // destructor, which calls fclose(), gets called, triggering a lack of a\n-  // buffer to parse :)\n-  //\n-  // We need to look into fixing the RAIIFile so that it supports this\n-  // behaviour. I'm assuming this will be something like fixing one of the copy\n-  // or move constructors, but is outside of the scope of this fix. For now,\n-  // make sure your lexers don't live longer than the strings they're trying\n-  // to lex\n-  static Lexer lex_string (std::string &input)\n-  {\n-    // We can perform this ugly cast to a non-const char* since we're only\n-    // *reading* the string. This would not be valid if we were doing any\n-    // modification to it.\n-    auto string_file = fmemopen (&input[0], input.length (), \"r\");\n+  // Lex the contents of a string instead of a file\n+  Lexer (const std::string &input);\n \n-    return Lexer (nullptr, RAIIFile (string_file), nullptr);\n-  }\n+  // dtor\n+  ~Lexer ();\n \n   // don't allow copy semantics (for now, at least)\n   Lexer (const Lexer &other) = delete;\n@@ -225,22 +198,54 @@ class Lexer\n   static const int max_column_hint = 80;\n \n   // Input source wrapper thing.\n-  struct InputSource\n+  class InputSource\n   {\n+  public:\n+    virtual ~InputSource () {}\n+\n+    // Overload operator () to return next char from input stream.\n+    virtual int next () = 0;\n+  };\n+\n+  class FileInputSource : public InputSource\n+  {\n+  private:\n     // Input source file.\n     FILE *input;\n \n+  public:\n     // Create new input source from file.\n-    InputSource (FILE *input) : input (input) {}\n+    FileInputSource (FILE *input) : input (input) {}\n \n-    // Overload operator () to return next char from input stream.\n-    int operator() () { return fgetc (input); }\n+    int next () override { return fgetc (input); }\n+  };\n+\n+  class BufferInputSource : public InputSource\n+  {\n+  private:\n+    const std::string &buffer;\n+    size_t offs;\n+\n+  public:\n+    // Create new input source from file.\n+    BufferInputSource (const std::string &b, size_t offset)\n+      : buffer (b), offs (offset)\n+    {}\n+\n+    int next () override\n+    {\n+      if (offs >= buffer.size ())\n+\treturn EOF;\n+\n+      return buffer.at (offs++);\n+    }\n   };\n \n   // The input source for the lexer.\n   // InputSource input_source;\n   // Input file queue.\n-  buffered_queue<int, InputSource> input_queue;\n+  std::unique_ptr<InputSource> raw_input_source;\n+  buffered_queue<int, InputSource &> input_queue;\n \n   // Token source wrapper thing.\n   struct TokenSource\n@@ -252,7 +257,7 @@ class Lexer\n     TokenSource (Lexer *parLexer) : lexer (parLexer) {}\n \n     // Overload operator () to build token in lexer.\n-    TokenPtr operator() () { return lexer->build_token (); }\n+    TokenPtr next () { return lexer->build_token (); }\n   };\n \n   // The token source for the lexer."}, {"sha": "00693c4cc758926610e4a5bb5cbdb47a95f3bed0", "filename": "gcc/rust/parse/rust-cfg-parser.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -11,8 +11,8 @@ parse_cfg_option (std::string &input, std::string &key, std::string &value)\n   key.clear ();\n   value.clear ();\n \n-  auto lexer = Lexer::lex_string (input);\n-  auto parser = Parser<Lexer> (std::move (lexer));\n+  auto lexer = Lexer (input);\n+  auto parser = Parser<Lexer> (lexer);\n \n   auto token = parser.peek_current_token ();\n   if (token->get_id () != IDENTIFIER)"}, {"sha": "c8faf499f59ef5f0fd103c1821ab6e8e833879f4", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -662,7 +662,7 @@ template <typename ManagedTokenSource> class Parser\n \n public:\n   // Construct parser with specified \"managed\" token source.\n-  Parser (ManagedTokenSource tokenSource) : lexer (std::move (tokenSource)) {}\n+  Parser (ManagedTokenSource &tokenSource) : lexer (tokenSource) {}\n \n   // Parse items without parsing an entire crate. This function is the main\n   // parsing loop of AST::Crate::parse_crate().\n@@ -689,7 +689,7 @@ template <typename ManagedTokenSource> class Parser\n \n private:\n   // The token source (usually lexer) associated with the parser.\n-  ManagedTokenSource lexer;\n+  ManagedTokenSource &lexer;\n   // The error list.\n   std::vector<Error> error_table;\n   // The names of inline modules while parsing."}, {"sha": "afcc4670cac75925be8beeb2662cb7312305dd08", "filename": "gcc/rust/rust-buffered-queue.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-buffered-queue.h?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -28,9 +28,7 @@ template <typename T, typename Source> class buffered_queue\n {\n public:\n   // Construct empty queue from Source src.\n-  buffered_queue (Source src)\n-    : source (std::move (src)), start (0), end (0), buffer ()\n-  {}\n+  buffered_queue (Source src) : source (src), start (0), end (0), buffer () {}\n \n   /* disable copying (since source is probably non-copyable)\n    * TODO is this actually a good idea? If source is non-copyable, it would\n@@ -104,7 +102,7 @@ template <typename T, typename Source> class buffered_queue\n \t/* iterate through buffer and invoke operator () on source on values\n \t * past original end */\n \tfor (int i = 0; i < num_items_to_read; i++)\n-\t  buffer[end + i] = source ();\n+\t  buffer[end + i] = source.next ();\n \n \t// move end based on additional items added\n \tend += num_items_to_read;"}, {"sha": "11076089de384064c2d89a189f9500d8f4b3f163", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dda7805fc333af269d5c8cf829aa2e66acfc57/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=d4dda7805fc333af269d5c8cf829aa2e66acfc57", "patch": "@@ -643,17 +643,17 @@ void\n Session::parse_file (const char *filename)\n {\n   RAIIFile file_wrap (filename);\n-\n-  if (file_wrap.get_raw () == nullptr)\n+  if (!file_wrap.ok ())\n     {\n-      rust_fatal_error (Location (), \"cannot open filename %s: %m\", filename);\n+      rust_error_at (Location (), \"cannot open filename %s: %m\", filename);\n+      return;\n     }\n \n   // parse file here\n   /* create lexer and parser - these are file-specific and so aren't instance\n    * variables */\n   Lexer lex (filename, std::move (file_wrap), linemap);\n-  Parser<Lexer> parser (std::move (lex));\n+  Parser<Lexer> parser (lex);\n \n   // generate crate from parser\n   auto parsed_crate = parser.parse_crate ();"}]}