{"sha": "65f4b8759bda30d63404acb381b24a2ec960e667", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVmNGI4NzU5YmRhMzBkNjM0MDRhY2IzODFiMjRhMmVjOTYwZTY2Nw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-12-12T02:15:30Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-12-12T02:15:30Z"}, "message": "[SFN] not-quite-boilerplate changes in preparation to introduce nonbind markers\n\nThis patch adjusts numerous parts of the compiler that would\nmalfunction should they find debug markers at points where they may be\nintroduced.  The changes purport to allow the compiler to pass\nbootstrap-debug-lean (-fcompare-debug in stage3) at various\noptimization levels, as well as bootstrap-debug-lib (-fcompare-debug\nfor target libraries), even after the compiler is changed so that\ndebug markers are introduced in code streams at spots where earlier\ndebug stmts, insns and notes wouldn't normally appear.\n\nThis patch depends on an earlier SFN boilerplate patch, and on another\nSFN patch that introduces new RTL insn-walking functions.\n\nfor  gcc/ChangeLog\n\n\t* cfgcleanup.c (delete_unreachable_blocks): Use alternate\n\tblock removal order if MAY_HAVE_DEBUG_BIND_INSNS.\n\t* cfgexpand.c (label_rtx_for_bb): Skip debug insns.\n\t* cfgrtl.c (try_redirect_by_replacing_jump): Skip debug insns.\n\t(rtl_tidy_fallthru_edge): Likewise.\n\t(rtl_verify_fallthru): Likewise.\n\t(rtl_verify_bb_layout): Likewise.\n\t(skip_insns_after_block): Likewise.\n\t(duplicate_insn_chain): Use DEBUG_BIND_INSN_P.\n\t* dwarf2out.c: Include print-rtl.h.\n\t(dwarf2out_next_real_insn): New.\n\t(dwarf2out_var_location): Call it.  Disregard begin stmt markers.\n\tDump debug binds in asm comments.\n\t* gimple-iterator.c (gimple_find_edge_insert_loc): Skip debug stmts.\n\t* gimple-iterator.h (gsi_start_bb_nondebug): Remove; adjust\n\tcallers to use gsi_start_nondebug_bb instead.\n\t(gsi_after_labels): Skip gimple debug stmts.\n\t(gsi_start_nondebug): New.\n\t* gimple-loop-interchange.c (find_deps_in_bb_for_stmt): Adjust.\n\t(proper_loop_form_for_interchange): Adjust.\n\t* gimple-low.c (gimple_seq_may_fallthru): Take last nondebug stmt.\n\t* gimple.h (gimple_seq_last_nondebug_stmt): New.\n\t* gimplify.c (last_stmt_in_scope): Skip debug stmts.\n\t(collect_fallthrough_labels): Likewise.\n\t(should_warn_for_implicit_fallthrough): Likewise.\n\t(warn_implicit_fallthrough_r): Likewise.\n\t(expand_FALLTHROUGH_r): Likewise.\n\t* graphite-isl-ast-to-gimple.c (gsi_insert_earliest): Adjust.\n\t(graphite_copy_stmts_from_block): Skip nonbind markers.\n\t* haifa-sched.c (sched_extend_bb): Skip debug insns.\n\t* ipa-icf-gimple.c (func_checker::compare_bb): Adjust.\n\t* jump.c (clean_barriers): Skip debug insns.\n\t* omp-expand.c (expand_parallel_call): Skip debug insns.\n\t(expand_task_call): Likewise.\n\t(remove_exit_barrier): Likewise.\n\t(expand_omp_taskreg): Likewise.\n\t(expand_omp_for_init_counts): Likewise.\n\t(expand_omp_for_generic): Likewise.\n\t(expand_omp_for_static_nochunk): Likewise.\n\t(expand_omp_for_static_chunk): Likewise.\n\t(expand_omp_simd): Likewise.\n\t(expand_omp_taskloop_for_outer): Likewise.\n\t(expand_omp_taskloop_for_inner): Likewise.\n\t(expand_oacc_for): Likewise.\n\t(expand_omp_sections): Likewise.\n\t(expand_omp_single): Likewise.\n\t(expand_omp_synch): Likewise.\n\t(expand_omp_atomic_load): Likewise.\n\t(expand_omp_atomic_store): Likewise.\n\t(expand_omp_atomic_fetch_op): Likewise.\n\t(expand_omp_atomic_pipeline): Likewise.\n\t(expand_omp_atomic_mutex): Likewise.\n\t(expand_omp_target): Likewise.\n\t(grid_expand_omp_for_loop): Likewise.\n\t(grid_expand_target_grid_body): Likewise.\n\t(build_omp_regions_1): Likewise.\n\t* omp-low.c (check_combined_parallel): Skip debug stmts.\n\t* postreload.c (fixup_debug_insns): Skip nonbind debug insns.\n\t* regcprop.c (find_oldest_value_reg): Ensure REGNO is not a pseudo.\n\t* sese.c (sese_trivially_empty_bb_p): Call is_gimple_debug in\n\ttest.\n\t* tree-cfg.c (make_blobs_1): Skip debug stmts.\n\t(make_edges): Likewise.\n\t(cleanup_dead_labels): Likewise.\n\t(gimple_can_merge_blocks_p): Likewise.\n\t(stmt_starts_bb_p): Likewise.\n\t(gimple_block_label): Likewise.\n\t(gimple_redirect_edge_and_branch): Likewise.\n\t* tree-cfgcleanup.c (remove_forwarder_block): Rearrange skipping\n\tof debug stmts.\n\t(execute_cleanup_cfg_post_optimizing): Dump enumerated decls with\n\tTDF_SLIM.\n\t* tree-pretty-print (print_declaration): Omit initializer in slim\n\tdumps.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Mark begin stmt\n\tmarkers.\n\t(eliminate_unnecessary_stmts): Stabilize block removal order.\n\t* tree-ssa-tail-merge.c (find_duplicate): Skip debug stmts.\n\t* var-tracking.c (get_first_insn): New.\n\t(vt_emit_notes): Call it.\n\t(vt_initialize): Walk any insns before the first BB.\n\t(delete_debug_insns): Likewise.\n\nFrom-SVN: r255566", "tree": {"sha": "c93804c181ab43d09f05acc90198b1f0fdd213e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c93804c181ab43d09f05acc90198b1f0fdd213e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65f4b8759bda30d63404acb381b24a2ec960e667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f4b8759bda30d63404acb381b24a2ec960e667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f4b8759bda30d63404acb381b24a2ec960e667", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f4b8759bda30d63404acb381b24a2ec960e667/comments", "author": null, "committer": null, "parents": [{"sha": "36f52e8f0812546e6cb533b384b29f56570624ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f52e8f0812546e6cb533b384b29f56570624ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f52e8f0812546e6cb533b384b29f56570624ff"}], "stats": {"total": 619, "additions": 447, "deletions": 172}, "files": [{"sha": "03ad41c3e27acc1fba16df9a5f8d45b3ada5e3aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -1,5 +1,88 @@\n 2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n \n+\t* cfgcleanup.c (delete_unreachable_blocks): Use alternate\n+\tblock removal order if MAY_HAVE_DEBUG_BIND_INSNS.\n+\t* cfgexpand.c (label_rtx_for_bb): Skip debug insns.\n+\t* cfgrtl.c (try_redirect_by_replacing_jump): Skip debug insns.\n+\t(rtl_tidy_fallthru_edge): Likewise.\n+\t(rtl_verify_fallthru): Likewise.\n+\t(rtl_verify_bb_layout): Likewise.\n+\t(skip_insns_after_block): Likewise.\n+\t(duplicate_insn_chain): Use DEBUG_BIND_INSN_P.\n+\t* dwarf2out.c: Include print-rtl.h.\n+\t(dwarf2out_next_real_insn): New.\n+\t(dwarf2out_var_location): Call it.  Disregard begin stmt markers.\n+\tDump debug binds in asm comments.\n+\t* gimple-iterator.c (gimple_find_edge_insert_loc): Skip debug stmts.\n+\t* gimple-iterator.h (gsi_start_bb_nondebug): Remove; adjust\n+\tcallers to use gsi_start_nondebug_bb instead.\n+\t(gsi_after_labels): Skip gimple debug stmts.\n+\t(gsi_start_nondebug): New.\n+\t* gimple-loop-interchange.c (find_deps_in_bb_for_stmt): Adjust.\n+\t(proper_loop_form_for_interchange): Adjust.\n+\t* gimple-low.c (gimple_seq_may_fallthru): Take last nondebug stmt.\n+\t* gimple.h (gimple_seq_last_nondebug_stmt): New.\n+\t* gimplify.c (last_stmt_in_scope): Skip debug stmts.\n+\t(collect_fallthrough_labels): Likewise.\n+\t(should_warn_for_implicit_fallthrough): Likewise.\n+\t(warn_implicit_fallthrough_r): Likewise.\n+\t(expand_FALLTHROUGH_r): Likewise.\n+\t* graphite-isl-ast-to-gimple.c (gsi_insert_earliest): Adjust.\n+\t(graphite_copy_stmts_from_block): Skip nonbind markers.\n+\t* haifa-sched.c (sched_extend_bb): Skip debug insns.\n+\t* ipa-icf-gimple.c (func_checker::compare_bb): Adjust.\n+\t* jump.c (clean_barriers): Skip debug insns.\n+\t* omp-expand.c (expand_parallel_call): Skip debug insns.\n+\t(expand_task_call): Likewise.\n+\t(remove_exit_barrier): Likewise.\n+\t(expand_omp_taskreg): Likewise.\n+\t(expand_omp_for_init_counts): Likewise.\n+\t(expand_omp_for_generic): Likewise.\n+\t(expand_omp_for_static_nochunk): Likewise.\n+\t(expand_omp_for_static_chunk): Likewise.\n+\t(expand_omp_simd): Likewise.\n+\t(expand_omp_taskloop_for_outer): Likewise.\n+\t(expand_omp_taskloop_for_inner): Likewise.\n+\t(expand_oacc_for): Likewise.\n+\t(expand_omp_sections): Likewise.\n+\t(expand_omp_single): Likewise.\n+\t(expand_omp_synch): Likewise.\n+\t(expand_omp_atomic_load): Likewise.\n+\t(expand_omp_atomic_store): Likewise.\n+\t(expand_omp_atomic_fetch_op): Likewise.\n+\t(expand_omp_atomic_pipeline): Likewise.\n+\t(expand_omp_atomic_mutex): Likewise.\n+\t(expand_omp_target): Likewise.\n+\t(grid_expand_omp_for_loop): Likewise.\n+\t(grid_expand_target_grid_body): Likewise.\n+\t(build_omp_regions_1): Likewise.\n+\t* omp-low.c (check_combined_parallel): Skip debug stmts.\n+\t* postreload.c (fixup_debug_insns): Skip nonbind debug insns.\n+\t* regcprop.c (find_oldest_value_reg): Ensure REGNO is not a pseudo.\n+\t* sese.c (sese_trivially_empty_bb_p): Call is_gimple_debug in\n+\ttest.\n+\t* tree-cfg.c (make_blobs_1): Skip debug stmts.\n+\t(make_edges): Likewise.\n+\t(cleanup_dead_labels): Likewise.\n+\t(gimple_can_merge_blocks_p): Likewise.\n+\t(stmt_starts_bb_p): Likewise.\n+\t(gimple_block_label): Likewise.\n+\t(gimple_redirect_edge_and_branch): Likewise.\n+\t* tree-cfgcleanup.c (remove_forwarder_block): Rearrange skipping\n+\tof debug stmts.\n+\t(execute_cleanup_cfg_post_optimizing): Dump enumerated decls with\n+\tTDF_SLIM.\n+\t* tree-pretty-print (print_declaration): Omit initializer in slim\n+\tdumps.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Mark begin stmt\n+\tmarkers.\n+\t(eliminate_unnecessary_stmts): Stabilize block removal order.\n+\t* tree-ssa-tail-merge.c (find_duplicate): Skip debug stmts.\n+\t* var-tracking.c (get_first_insn): New.\n+\t(vt_emit_notes): Call it.\n+\t(vt_initialize): Walk any insns before the first BB.\n+\t(delete_debug_insns): Likewise.\n+\n \t* gimple.h (enum gimple_debug_subcode): Add\n \tGIMPLE_DEBUG_BEGIN_STMT.\n \t(gimple_debug_begin_stmt_p): New."}, {"sha": "8fa15fec45e47d92853ed605f93295a5b7cdbb51", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -475,6 +475,7 @@ find_bb_boundaries (basic_block bb)\n \t  if (debug_insn && code != CODE_LABEL && code != BARRIER)\n \t    prev = PREV_INSN (debug_insn);\n \t  fallthru = split_block (bb, prev);\n+\n \t  if (flow_transfer_insn)\n \t    {\n \t      BB_END (bb) = flow_transfer_insn;"}, {"sha": "754e52fe799a1fa59eb992491a73cd9921850b8f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -3037,13 +3037,13 @@ delete_unreachable_blocks (void)\n \n   find_unreachable_blocks ();\n \n-  /* When we're in GIMPLE mode and there may be debug insns, we should\n-     delete blocks in reverse dominator order, so as to get a chance\n-     to substitute all released DEFs into debug stmts.  If we don't\n-     have dominators information, walking blocks backward gets us a\n-     better chance of retaining most debug information than\n+  /* When we're in GIMPLE mode and there may be debug bind insns, we\n+     should delete blocks in reverse dominator order, so as to get a\n+     chance to substitute all released DEFs into debug bind stmts.  If\n+     we don't have dominators information, walking blocks backward\n+     gets us a better chance of retaining most debug information than\n      otherwise.  */\n-  if (MAY_HAVE_DEBUG_INSNS && current_ir_type () == IR_GIMPLE\n+  if (MAY_HAVE_DEBUG_BIND_INSNS && current_ir_type () == IR_GIMPLE\n       && dom_info_available_p (CDI_DOMINATORS))\n     {\n       for (b = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;"}, {"sha": "3ee242df6b98614230da65f924b885504f42116b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -2327,6 +2327,9 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n     {\n       glabel *lab_stmt;\n \n+      if (is_gimple_debug (gsi_stmt (gsi)))\n+\tcontinue;\n+\n       lab_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n       if (!lab_stmt)\n \tbreak;\n@@ -5454,7 +5457,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n   gimple *stmt = NULL;\n-  rtx_note *note;\n+  rtx_note *note = NULL;\n   rtx_insn *last;\n   edge e;\n   edge_iterator ei;\n@@ -5495,18 +5498,26 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t}\n     }\n \n-  gsi = gsi_start (stmts);\n+  gsi = gsi_start_nondebug (stmts);\n   if (!gsi_end_p (gsi))\n     {\n       stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) != GIMPLE_LABEL)\n \tstmt = NULL;\n     }\n+  gsi = gsi_start (stmts);\n \n+  gimple *label_stmt = stmt;\n   rtx_code_label **elt = lab_rtx_for_bb->get (bb);\n \n-  if (stmt || elt)\n+  if (stmt)\n+    /* We'll get to it in the loop below, and get back to\n+       emit_label_and_note then.  */\n+    ;\n+  else if (stmt || elt)\n     {\n+    emit_label_and_note:\n+      gcc_checking_assert (!note);\n       last = get_last_insn ();\n \n       if (stmt)\n@@ -5521,21 +5532,26 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n       BB_HEAD (bb) = NEXT_INSN (last);\n       if (NOTE_P (BB_HEAD (bb)))\n \tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n+      gcc_assert (LABEL_P (BB_HEAD (bb)));\n       note = emit_note_after (NOTE_INSN_BASIC_BLOCK, BB_HEAD (bb));\n \n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n     }\n   else\n     BB_HEAD (bb) = note = emit_note (NOTE_INSN_BASIC_BLOCK);\n \n-  NOTE_BASIC_BLOCK (note) = bb;\n+  if (note)\n+    NOTE_BASIC_BLOCK (note) = bb;\n \n   for (; !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       basic_block new_bb;\n \n       stmt = gsi_stmt (gsi);\n \n+      if (stmt == label_stmt)\n+\tgoto emit_label_and_note;\n+\n       /* If this statement is a non-debug one, and we generate debug\n \t insns, then this one might be the last real use of a TERed\n \t SSA_NAME, but where there are still some debug uses further"}, {"sha": "b127ea1a0b38671b2ceb9c2ad92642c86719abc8", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -1117,7 +1117,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       if (tablejump_p (insn, &label, &table))\n \tdelete_insn_chain (label, table, false);\n \n-      barrier = next_nonnote_insn (BB_END (src));\n+      barrier = next_nonnote_nondebug_insn (BB_END (src));\n       if (!barrier || !BARRIER_P (barrier))\n \temit_barrier_after (BB_END (src));\n       else\n@@ -1750,7 +1750,7 @@ rtl_tidy_fallthru_edge (edge e)\n      the head of block C and assert that we really do fall through.  */\n \n   for (q = NEXT_INSN (BB_END (b)); q != BB_HEAD (c); q = NEXT_INSN (q))\n-    if (INSN_P (q))\n+    if (NONDEBUG_INSN_P (q))\n       return;\n \n   /* Remove what will soon cease being the jump insn from the source block.\n@@ -2905,7 +2905,7 @@ rtl_verify_fallthru (void)\n \t  else\n \t    for (insn = NEXT_INSN (BB_END (e->src)); insn != BB_HEAD (e->dest);\n \t\t insn = NEXT_INSN (insn))\n-\t      if (BARRIER_P (insn) || INSN_P (insn))\n+\t      if (BARRIER_P (insn) || NONDEBUG_INSN_P (insn))\n \t\t{\n \t\t  error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n \t\t\t e->src->index, e->dest->index);\n@@ -2927,7 +2927,7 @@ rtl_verify_bb_layout (void)\n {\n   basic_block bb;\n   int err = 0;\n-  rtx_insn *x;\n+  rtx_insn *x, *y;\n   int num_bb_notes;\n   rtx_insn * const rtx_first = get_insns ();\n   basic_block last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun), curr_bb = NULL;\n@@ -2954,6 +2954,7 @@ rtl_verify_bb_layout (void)\n \t    {\n \t    case BARRIER:\n \t    case NOTE:\n+\t    case DEBUG_INSN:\n \t      break;\n \n \t    case CODE_LABEL:\n@@ -2972,7 +2973,8 @@ rtl_verify_bb_layout (void)\n \n       if (JUMP_P (x)\n \t  && returnjump_p (x) && ! condjump_p (x)\n-\t  && ! (next_nonnote_insn (x) && BARRIER_P (next_nonnote_insn (x))))\n+\t  && ! ((y = next_nonnote_nondebug_insn (x))\n+\t\t&& BARRIER_P (y)))\n \t    fatal_insn (\"return not followed by barrier\", x);\n \n       if (curr_bb && x == BB_END (curr_bb))\n@@ -3389,6 +3391,9 @@ skip_insns_after_block (basic_block bb)\n \t  last_insn = insn;\n \t  continue;\n \n+\tcase DEBUG_INSN:\n+\t  continue;\n+\n \tcase NOTE:\n \t  switch (NOTE_KIND (insn))\n \t    {\n@@ -4141,7 +4146,8 @@ duplicate_insn_chain (rtx_insn *from, rtx_insn *to)\n \t{\n \tcase DEBUG_INSN:\n \t  /* Don't duplicate label debug insns.  */\n-\t  if (TREE_CODE (INSN_VAR_LOCATION_DECL (insn)) == LABEL_DECL)\n+\t  if (DEBUG_BIND_INSN_P (insn)\n+\t      && TREE_CODE (INSN_VAR_LOCATION_DECL (insn)) == LABEL_DECL)\n \t    break;\n \t  /* FALLTHRU */\n \tcase INSN:"}, {"sha": "82c9ccfa7c25cdd959bccf6bea05ea510ca55558", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -83,6 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"md5.h\"\n #include \"tree-pretty-print.h\"\n+#include \"print-rtl.h\"\n #include \"debug.h\"\n #include \"common/common-target.h\"\n #include \"langhooks.h\"\n@@ -26210,6 +26211,22 @@ static bool maybe_at_text_label_p = true;\n /* One above highest N where .LVLN label might be equal to .Ltext0 label.  */\n static unsigned int first_loclabel_num_not_at_text_label;\n \n+/* Look ahead for a real insn, or for a begin stmt marker.  */\n+\n+static rtx_insn *\n+dwarf2out_next_real_insn (rtx_insn *loc_note)\n+{\n+  rtx_insn *next_real = NEXT_INSN (loc_note);\n+\n+  while (next_real)\n+    if (INSN_P (next_real))\n+      break;\n+    else\n+      next_real = NEXT_INSN (next_real);\n+\n+  return next_real;\n+}\n+\n /* Called by the final INSN scan whenever we see a var location.  We\n    use it to drop labels in the right places, and throw the location in\n    our lookup table.  */\n@@ -26258,7 +26275,7 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t\t  loc_note = NULL;\n \t\t  var_loc_p = false;\n \n-\t\t  next_real = next_real_insn (call_insn);\n+\t\t  next_real = dwarf2out_next_real_insn (call_insn);\n \t\t  next_note = NULL;\n \t\t  cached_next_real_insn = NULL;\n \t\t  goto create_label;\n@@ -26288,11 +26305,12 @@ dwarf2out_var_location (rtx_insn *loc_note)\n       || next_note->deleted ()\n       || ! NOTE_P (next_note)\n       || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION\n+\t  && NOTE_KIND (next_note) != NOTE_INSN_BEGIN_STMT\n \t  && NOTE_KIND (next_note) != NOTE_INSN_CALL_ARG_LOCATION))\n     next_note = NULL;\n \n   if (! next_real)\n-    next_real = next_real_insn (loc_note);\n+    next_real = dwarf2out_next_real_insn (loc_note);\n \n   if (next_note)\n     {\n@@ -26451,6 +26469,22 @@ dwarf2out_var_location (rtx_insn *loc_note)\n       newloc->label = last_postcall_label;\n     }\n \n+  if (var_loc_p && flag_debug_asm)\n+    {\n+      const char *name = NULL, *sep = \" => \", *patstr = NULL;\n+      if (decl && DECL_NAME (decl))\n+\tname = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      if (NOTE_VAR_LOCATION_LOC (loc_note))\n+\tpatstr = str_pattern_slim (NOTE_VAR_LOCATION_LOC (loc_note));\n+      else\n+\t{\n+\t  sep = \" \";\n+\t  patstr = \"RESET\";\n+\t}\n+      fprintf (asm_out_file, \"\\t%s DEBUG %s%s%s\\n\", ASM_COMMENT_START,\n+\t       name, sep, patstr);\n+    }\n+\n   last_var_location_insn = next_real;\n   last_in_cold_section_p = in_cold_section_p;\n }"}, {"sha": "1e87825a20f8830010f6be4622f5355e3d8f237c", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -739,9 +739,13 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n       if (gsi_end_p (*gsi))\n \treturn true;\n \n-      /* Make sure we insert after any leading labels.  */\n+      /* Make sure we insert after any leading labels.  We have to\n+\t skip debug stmts before or among them, though.  We didn't\n+\t have to skip debug stmts after the last label, but it\n+\t shouldn't hurt if we do.  */\n       tmp = gsi_stmt (*gsi);\n-      while (gimple_code (tmp) == GIMPLE_LABEL)\n+      while (gimple_code (tmp) == GIMPLE_LABEL\n+\t     || is_gimple_debug (tmp))\n \t{\n \t  gsi_next (gsi);\n \t  if (gsi_end_p (*gsi))\n@@ -776,7 +780,21 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n \treturn true;\n \n       tmp = gsi_stmt (*gsi);\n-      if (!stmt_ends_bb_p (tmp))\n+      if (is_gimple_debug (tmp))\n+\t{\n+\t  gimple_stmt_iterator si = *gsi;\n+\t  gsi_prev_nondebug (&si);\n+\t  if (!gsi_end_p (si))\n+\t    tmp = gsi_stmt (si);\n+\t  /* If we don't have a BB-ending nondebug stmt, we want to\n+\t     insert after the trailing debug stmts.  Otherwise, we may\n+\t     insert before the BB-ending nondebug stmt, or split the\n+\t     edge.  */\n+\t  if (!stmt_ends_bb_p (tmp))\n+\t    return true;\n+\t  *gsi = si;\n+\t}\n+      else if (!stmt_ends_bb_p (tmp))\n \treturn true;\n \n       switch (gimple_code (tmp))"}, {"sha": "167edc18db5b1bed00a5a71c69f77bd720db76a8", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -212,29 +212,28 @@ gsi_stmt (gimple_stmt_iterator i)\n   return i.ptr;\n }\n \n-/* Return a new iterator pointing to the first non-debug statement\n-   in basic block BB.  */\n-\n-static inline gimple_stmt_iterator\n-gsi_start_bb_nondebug (basic_block bb)\n-{\n-  gimple_stmt_iterator gsi = gsi_start_bb (bb);\n-  while (!gsi_end_p (gsi) && is_gimple_debug (gsi_stmt (gsi)))\n-    gsi_next (&gsi);\n-\n-  return gsi;\n-}\n-\n-/* Return a block statement iterator that points to the first non-label\n-   statement in block BB.  */\n+/* Return a block statement iterator that points to the first\n+   non-label statement in block BB.  Skip debug stmts only if they\n+   precede labels.  */\n \n static inline gimple_stmt_iterator\n gsi_after_labels (basic_block bb)\n {\n   gimple_stmt_iterator gsi = gsi_start_bb (bb);\n \n-  while (!gsi_end_p (gsi) && gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n-    gsi_next (&gsi);\n+  for (gimple_stmt_iterator gskip = gsi;\n+       !gsi_end_p (gskip); )\n+    {\n+      if (is_gimple_debug (gsi_stmt (gskip)))\n+\tgsi_next (&gskip);\n+      else if (gimple_code (gsi_stmt (gskip)) == GIMPLE_LABEL)\n+\t{\n+\t  gsi_next (&gskip);\n+\t  gsi = gskip;\n+\t}\n+      else\n+\tbreak;\n+    }\n \n   return gsi;\n }\n@@ -263,6 +262,19 @@ gsi_prev_nondebug (gimple_stmt_iterator *i)\n   while (!gsi_end_p (*i) && is_gimple_debug (gsi_stmt (*i)));\n }\n \n+/* Return a new iterator pointing to the first non-debug statement in\n+   SEQ.  */\n+\n+static inline gimple_stmt_iterator\n+gsi_start_nondebug (gimple_seq seq)\n+{\n+  gimple_stmt_iterator gsi = gsi_start (seq);\n+  if (!gsi_end_p (gsi) && is_gimple_debug (gsi_stmt (gsi)))\n+    gsi_next_nondebug (&gsi);\n+\n+  return gsi;\n+}\n+\n /* Return a new iterator pointing to the first non-debug statement in\n    basic block BB.  */\n "}, {"sha": "1d1cf96c81236943cee5cc04bf3ca515916be1dc", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -827,7 +827,7 @@ find_deps_in_bb_for_stmt (gimple_seq *stmts, basic_block bb, gimple *consumer)\n \t}\n       gimple_set_plf (stmt, GF_PLF_1, true);\n     }\n-  for (gsi = gsi_start_bb_nondebug (bb);\n+  for (gsi = gsi_start_nondebug_bb (bb);\n        !gsi_end_p (gsi) && (stmt = gsi_stmt (gsi)) != consumer;)\n     {\n       /* Move dep stmts to sequence STMTS.  */\n@@ -1749,7 +1749,7 @@ proper_loop_form_for_interchange (struct loop *loop, struct loop **min_outer)\n \t  || dominated_by_p (CDI_DOMINATORS, exit->src, bb))\n \tcontinue;\n \n-      for (gimple_stmt_iterator gsi = gsi_start_bb_nondebug (bb);\n+      for (gimple_stmt_iterator gsi = gsi_start_nondebug_bb (bb);\n \t   !gsi_end_p (gsi); gsi_next_nondebug (&gsi))\n \tif (gimple_vuse (gsi_stmt (gsi)))\n \t  {"}, {"sha": "22db61bbd48af41097fc5dac82ebad2931f8700b", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -645,7 +645,7 @@ gimple_stmt_may_fallthru (gimple *stmt)\n bool\n gimple_seq_may_fallthru (gimple_seq seq)\n {\n-  return gimple_stmt_may_fallthru (gimple_seq_last_stmt (seq));\n+  return gimple_stmt_may_fallthru (gimple_seq_last_nondebug_stmt (seq));\n }\n \n "}, {"sha": "26fed1d4ecb68d8602359a78368fc021566bd598", "filename": "gcc/gimple.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -4600,6 +4600,22 @@ is_gimple_debug (const gimple *gs)\n   return gimple_code (gs) == GIMPLE_DEBUG;\n }\n \n+\n+/* Return the last nondebug statement in GIMPLE sequence S.  */\n+\n+static inline gimple *\n+gimple_seq_last_nondebug_stmt (gimple_seq s)\n+{\n+  gimple_seq_node n;\n+  for (n = gimple_seq_last (s);\n+       n && is_gimple_debug (n);\n+       n = n->prev)\n+    if (n->prev == s)\n+      return NULL;\n+  return n;\n+}\n+\n+\n /* Return true if S is a GIMPLE_DEBUG BIND statement.  */\n \n static inline bool"}, {"sha": "6a15daf45b583d8f4165da25499863528e06f607", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -1847,7 +1847,7 @@ case_label_p (const vec<tree> *cases, tree label)\n   return false;\n }\n \n-/* Find the last statement in a scope STMT.  */\n+/* Find the last nondebug statement in a scope STMT.  */\n \n static gimple *\n last_stmt_in_scope (gimple *stmt)\n@@ -1860,27 +1860,30 @@ last_stmt_in_scope (gimple *stmt)\n     case GIMPLE_BIND:\n       {\n \tgbind *bind = as_a <gbind *> (stmt);\n-\tstmt = gimple_seq_last_stmt (gimple_bind_body (bind));\n+\tstmt = gimple_seq_last_nondebug_stmt (gimple_bind_body (bind));\n \treturn last_stmt_in_scope (stmt);\n       }\n \n     case GIMPLE_TRY:\n       {\n \tgtry *try_stmt = as_a <gtry *> (stmt);\n-\tstmt = gimple_seq_last_stmt (gimple_try_eval (try_stmt));\n+\tstmt = gimple_seq_last_nondebug_stmt (gimple_try_eval (try_stmt));\n \tgimple *last_eval = last_stmt_in_scope (stmt);\n \tif (gimple_stmt_may_fallthru (last_eval)\n \t    && (last_eval == NULL\n \t\t|| !gimple_call_internal_p (last_eval, IFN_FALLTHROUGH))\n \t    && gimple_try_kind (try_stmt) == GIMPLE_TRY_FINALLY)\n \t  {\n-\t    stmt = gimple_seq_last_stmt (gimple_try_cleanup (try_stmt));\n+\t    stmt = gimple_seq_last_nondebug_stmt (gimple_try_cleanup (try_stmt));\n \t    return last_stmt_in_scope (stmt);\n \t  }\n \telse\n \t  return last_eval;\n       }\n \n+    case GIMPLE_DEBUG:\n+      gcc_unreachable ();\n+\n     default:\n       return stmt;\n     }\n@@ -2005,7 +2008,7 @@ collect_fallthrough_labels (gimple_stmt_iterator *gsi_p,\n \t}\n       else if (gimple_call_internal_p (gsi_stmt (*gsi_p), IFN_ASAN_MARK))\n \t;\n-      else\n+      else if (!is_gimple_debug (gsi_stmt (*gsi_p)))\n \tprev = gsi_stmt (*gsi_p);\n       gsi_next (gsi_p);\n     }\n@@ -2042,7 +2045,7 @@ should_warn_for_implicit_fallthrough (gimple_stmt_iterator *gsi_p, tree label)\n \t     && gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL\n \t     && (l = gimple_label_label (as_a <glabel *> (gsi_stmt (gsi))))\n \t     && !case_label_p (&gimplify_ctxp->case_labels, l))\n-\tgsi_next (&gsi);\n+\tgsi_next_nondebug (&gsi);\n       if (gsi_end_p (gsi) || gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n \treturn false;\n     }\n@@ -2055,7 +2058,7 @@ should_warn_for_implicit_fallthrough (gimple_stmt_iterator *gsi_p, tree label)\n   while (!gsi_end_p (gsi)\n \t && (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL\n \t     || gimple_code (gsi_stmt (gsi)) == GIMPLE_PREDICT))\n-    gsi_next (&gsi);\n+    gsi_next_nondebug (&gsi);\n \n   /* { ... something; default:; } */\n   if (gsi_end_p (gsi)\n@@ -2102,7 +2105,7 @@ warn_implicit_fallthrough_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t/* Found a label.  Skip all immediately following labels.  */\n \twhile (!gsi_end_p (*gsi_p)\n \t       && gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_LABEL)\n-\t  gsi_next (gsi_p);\n+\t  gsi_next_nondebug (gsi_p);\n \n \t/* There might be no more statements.  */\n \tif (gsi_end_p (*gsi_p))\n@@ -2245,8 +2248,8 @@ expand_FALLTHROUGH_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \t\t}\n \t      else if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n \t\t;\n-\t      else\n-\t\t/* Something other is not expected.  */\n+\t      else if (!is_gimple_debug (stmt))\n+\t\t/* Anything else is not expected.  */\n \t\tbreak;\n \t      gsi_next (&gsi2);\n \t    }"}, {"sha": "848bfe9dfc29e2a3791ee35c068d69733939e8d4", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -1033,7 +1033,7 @@ gsi_insert_earliest (gimple_seq seq)\n   FOR_EACH_VEC_ELT (stmts, i, use_stmt)\n     {\n       gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n-      gimple_stmt_iterator gsi_def_stmt = gsi_start_bb_nondebug (begin_bb);\n+      gimple_stmt_iterator gsi_def_stmt = gsi_start_nondebug_bb (begin_bb);\n \n       use_operand_p use_p;\n       ssa_op_iter op_iter;\n@@ -1065,7 +1065,7 @@ gsi_insert_earliest (gimple_seq seq)\n       else if (gimple_code (gsi_stmt (gsi_def_stmt)) == GIMPLE_PHI)\n \t{\n \t  gimple_stmt_iterator bsi\n-\t    = gsi_start_bb_nondebug (gsi_bb (gsi_def_stmt));\n+\t    = gsi_start_nondebug_bb (gsi_bb (gsi_def_stmt));\n \t  /* Insert right after the PHI statements.  */\n \t  gsi_insert_before (&bsi, use_stmt, GSI_NEW_STMT);\n \t}\n@@ -1174,7 +1174,8 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n \t{\n \t  if (gimple_debug_bind_p (copy))\n \t    gimple_debug_bind_reset_value (copy);\n-\t  else if (gimple_debug_source_bind_p (copy))\n+\t  else if (gimple_debug_source_bind_p (copy)\n+\t\t   || gimple_debug_nonbind_marker_p (copy))\n \t    ;\n \t  else\n \t    gcc_unreachable ();"}, {"sha": "cf44422d8219c26a08decb5f02d3ba4e637fa198", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -8086,7 +8086,7 @@ sched_extend_bb (void)\n       || (!NOTE_P (insn)\n \t  && !LABEL_P (insn)\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n-\t  && !BARRIER_P (NEXT_INSN (end))))\n+\t  && !BARRIER_P (next_nondebug_insn (end))))\n     {\n       rtx_note *note = emit_note_after (NOTE_INSN_DELETED, end);\n       /* Make note appear outside BB.  */"}, {"sha": "be8c7091269827bd1609703a6b9f16b0a6d2d563", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -640,8 +640,8 @@ func_checker::compare_bb (sem_bb *bb1, sem_bb *bb2)\n   gimple_stmt_iterator gsi1, gsi2;\n   gimple *s1, *s2;\n \n-  gsi1 = gsi_start_bb_nondebug (bb1->bb);\n-  gsi2 = gsi_start_bb_nondebug (bb2->bb);\n+  gsi1 = gsi_start_nondebug_bb (bb1->bb);\n+  gsi2 = gsi_start_nondebug_bb (bb2->bb);\n \n   while (!gsi_end_p (gsi1))\n     {"}, {"sha": "e60a6c6f8e6663bf9e080300c31c8aeee5cfef17", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -123,7 +123,7 @@ cleanup_barriers (void)\n     {\n       if (BARRIER_P (insn))\n \t{\n-\t  rtx_insn *prev = prev_nonnote_insn (insn);\n+\t  rtx_insn *prev = prev_nonnote_nondebug_insn (insn);\n \t  if (!prev)\n \t    continue;\n "}, {"sha": "02488339b401eb8145081d63ab819d5eadbf5afe", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -694,7 +694,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t\t\t\t      false, GSI_CONTINUE_LINKING);\n     }\n \n-  gsi = gsi_last_bb (bb);\n+  gsi = gsi_last_nondebug_bb (bb);\n   t = gimple_omp_parallel_data_arg (entry_stmt);\n   if (t == NULL)\n     t1 = null_pointer_node;\n@@ -834,7 +834,7 @@ expand_task_call (struct omp_region *region, basic_block bb,\n   else\n     priority = integer_zero_node;\n \n-  gsi = gsi_last_bb (bb);\n+  gsi = gsi_last_nondebug_bb (bb);\n   tree t = gimple_omp_task_data_arg (entry_stmt);\n   if (t == NULL)\n     t2 = null_pointer_node;\n@@ -911,15 +911,15 @@ remove_exit_barrier (struct omp_region *region)\n      statements that can appear in between are extremely limited -- no\n      memory operations at all.  Here, we allow nothing at all, so the\n      only thing we allow to precede this GIMPLE_OMP_RETURN is a label.  */\n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n-  gsi_prev (&gsi);\n+  gsi_prev_nondebug (&gsi);\n   if (!gsi_end_p (gsi) && gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n     return;\n \n   FOR_EACH_EDGE (e, ei, exit_bb->preds)\n     {\n-      gsi = gsi_last_bb (e->src);\n+      gsi = gsi_last_nondebug_bb (e->src);\n       if (gsi_end_p (gsi))\n \tcontinue;\n       stmt = gsi_stmt (gsi);\n@@ -1135,7 +1135,7 @@ expand_omp_taskreg (struct omp_region *region)\n \n       entry_succ_e = single_succ_edge (entry_bb);\n \n-      gsi = gsi_last_bb (entry_bb);\n+      gsi = gsi_last_nondebug_bb (entry_bb);\n       gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_PARALLEL\n \t\t  || gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_TASK);\n       gsi_remove (&gsi, true);\n@@ -1248,7 +1248,7 @@ expand_omp_taskreg (struct omp_region *region)\n \n       /* Split ENTRY_BB at GIMPLE_OMP_PARALLEL or GIMPLE_OMP_TASK,\n \t so that it can be moved to the child function.  */\n-      gsi = gsi_last_bb (entry_bb);\n+      gsi = gsi_last_nondebug_bb (entry_bb);\n       stmt = gsi_stmt (gsi);\n       gcc_assert (stmt && (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n \t\t\t   || gimple_code (stmt) == GIMPLE_OMP_TASK));\n@@ -1264,7 +1264,7 @@ expand_omp_taskreg (struct omp_region *region)\n \t  gcc_assert (e2->dest == region->exit);\n \t  remove_edge (BRANCH_EDGE (entry_bb));\n \t  set_immediate_dominator (CDI_DOMINATORS, e2->dest, e->src);\n-\t  gsi = gsi_last_bb (region->exit);\n+\t  gsi = gsi_last_nondebug_bb (region->exit);\n \t  gcc_assert (!gsi_end_p (gsi)\n \t\t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n \t  gsi_remove (&gsi, true);\n@@ -1273,7 +1273,7 @@ expand_omp_taskreg (struct omp_region *region)\n       /* Convert GIMPLE_OMP_{RETURN,CONTINUE} into a RETURN_EXPR.  */\n       if (exit_bb)\n \t{\n-\t  gsi = gsi_last_bb (exit_bb);\n+\t  gsi = gsi_last_nondebug_bb (exit_bb);\n \t  gcc_assert (!gsi_end_p (gsi)\n \t\t      && (gimple_code (gsi_stmt (gsi))\n \t\t\t  == (e2 ? GIMPLE_OMP_CONTINUE : GIMPLE_OMP_RETURN)));\n@@ -1732,7 +1732,7 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t  if (l2_dom_bb == NULL)\n \t    l2_dom_bb = entry_bb;\n \t  entry_bb = e->dest;\n-\t  *gsi = gsi_last_bb (entry_bb);\n+\t  *gsi = gsi_last_nondebug_bb (entry_bb);\n \t}\n \n       if (POINTER_TYPE_P (itype))\n@@ -2537,7 +2537,7 @@ expand_omp_for_generic (struct omp_region *region,\n   l3_bb = BRANCH_EDGE (entry_bb)->dest;\n   exit_bb = region->exit;\n \n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n \n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n   if (fd->ordered\n@@ -2567,7 +2567,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t  e = split_block (entry_bb, gsi_stmt (gsi));\n \t  entry_bb = e->dest;\n \t  make_edge (zero_iter1_bb, entry_bb, EDGE_FALLTHRU);\n-\t  gsi = gsi_last_bb (entry_bb);\n+\t  gsi = gsi_last_nondebug_bb (entry_bb);\n \t  set_immediate_dominator (CDI_DOMINATORS, entry_bb,\n \t\t\t\t   get_immediate_dominator (CDI_DOMINATORS,\n \t\t\t\t\t\t\t    zero_iter1_bb));\n@@ -2588,7 +2588,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t      e = split_block (entry_bb, gsi_stmt (gsi));\n \t      entry_bb = e->dest;\n \t      make_edge (zero_iter2_bb, entry_bb, EDGE_FALLTHRU);\n-\t      gsi = gsi_last_bb (entry_bb);\n+\t      gsi = gsi_last_nondebug_bb (entry_bb);\n \t      set_immediate_dominator (CDI_DOMINATORS, entry_bb,\n \t\t\t\t       get_immediate_dominator\n \t\t\t\t\t (CDI_DOMINATORS, zero_iter2_bb));\n@@ -3006,7 +3006,7 @@ expand_omp_for_generic (struct omp_region *region,\n     {\n       /* Code to control the increment and predicate for the sequential\n \t loop goes in the CONT_BB.  */\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n       gcc_assert (gimple_code (cont_stmt) == GIMPLE_OMP_CONTINUE);\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n@@ -3072,7 +3072,7 @@ expand_omp_for_generic (struct omp_region *region,\n     }\n \n   /* Add the loop cleanup function.  */\n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   if (gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END_NOWAIT);\n   else if (gimple_omp_return_lhs (gsi_stmt (gsi)))\n@@ -3292,7 +3292,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   exit_bb = region->exit;\n \n   /* Iteration space partitioning goes in ENTRY_BB.  */\n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   if (fd->collapse > 1)\n@@ -3424,7 +3424,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n \n   second_bb = split_block (entry_bb, cond_stmt)->dest;\n-  gsi = gsi_last_bb (second_bb);\n+  gsi = gsi_last_nondebug_bb (second_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   gsi_insert_before (&gsi, gimple_build_assign (tt, build_int_cst (itype, 0)),\n@@ -3434,7 +3434,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n   third_bb = split_block (second_bb, assign_stmt)->dest;\n-  gsi = gsi_last_bb (third_bb);\n+  gsi = gsi_last_nondebug_bb (third_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   t = build2 (MULT_EXPR, itype, q, threadid);\n@@ -3576,7 +3576,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n     {\n       /* The code controlling the sequential loop replaces the\n \t GIMPLE_OMP_CONTINUE.  */\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n       gcc_assert (gimple_code (cont_stmt) == GIMPLE_OMP_CONTINUE);\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n@@ -3609,7 +3609,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n     }\n \n   /* Replace the GIMPLE_OMP_RETURN with a barrier, or nothing.  */\n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n@@ -3776,7 +3776,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   exit_bb = region->exit;\n \n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   if (fd->collapse > 1)\n@@ -4082,7 +4082,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n     {\n       /* The code controlling the sequential loop goes in CONT_BB,\n \t replacing the GIMPLE_OMP_CONTINUE.  */\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n       vback = gimple_omp_continue_control_def (cont_stmt);\n@@ -4126,7 +4126,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n     }\n \n   /* Replace the GIMPLE_OMP_RETURN with a barrier, or nothing.  */\n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n@@ -4399,7 +4399,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   exit_bb = region->exit;\n   l2_dom_bb = NULL;\n \n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n \n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n   /* Not needed in SSA form right now.  */\n@@ -4494,7 +4494,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   if (!broken_loop)\n     {\n       /* Code to control the increment goes in the CONT_BB.  */\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       stmt = gsi_stmt (gsi);\n       gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n \n@@ -4592,7 +4592,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n     }\n \n   /* Remove GIMPLE_OMP_RETURN.  */\n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   gsi_remove (&gsi, true);\n \n   /* Connect the new blocks.  */\n@@ -4718,7 +4718,7 @@ expand_omp_taskloop_for_outer (struct omp_region *region,\n   gcc_assert (BRANCH_EDGE (entry_bb)->dest == FALLTHRU_EDGE (cont_bb)->dest);\n   exit_bb = region->exit;\n \n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n   gimple *for_stmt = gsi_stmt (gsi);\n   gcc_assert (gimple_code (for_stmt) == GIMPLE_OMP_FOR);\n   if (fd->collapse > 1)\n@@ -4819,10 +4819,10 @@ expand_omp_taskloop_for_outer (struct omp_region *region,\n   gsi = gsi_for_stmt (for_stmt);\n   gsi_remove (&gsi, true);\n \n-  gsi = gsi_last_bb (cont_bb);\n+  gsi = gsi_last_nondebug_bb (cont_bb);\n   gsi_remove (&gsi, true);\n \n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   gsi_remove (&gsi, true);\n \n   FALLTHRU_EDGE (entry_bb)->probability = profile_probability::always ();\n@@ -4896,7 +4896,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n   exit_bb = region->exit;\n \n   /* Iteration space partitioning goes in ENTRY_BB.  */\n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   if (fd->collapse > 1)\n@@ -4975,7 +4975,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n     {\n       /* The code controlling the sequential loop replaces the\n \t GIMPLE_OMP_CONTINUE.  */\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n       gcc_assert (gimple_code (cont_stmt) == GIMPLE_OMP_CONTINUE);\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n@@ -5012,7 +5012,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n   gsi_remove (&gsi, true);\n \n   /* Remove the GIMPLE_OMP_RETURN statement.  */\n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   gsi_remove (&gsi, true);\n \n   FALLTHRU_EDGE (entry_bb)->probability = profile_probability::always ();\n@@ -5195,7 +5195,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n   entry_bb = split->src;\n \n   /* Chunk setup goes at end of entry_bb, replacing the omp_for.  */\n-  gsi = gsi_last_bb (entry_bb);\n+  gsi = gsi_last_nondebug_bb (entry_bb);\n   gomp_for *for_stmt = as_a <gomp_for *> (gsi_stmt (gsi));\n   loc = gimple_location (for_stmt);\n \n@@ -5322,7 +5322,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \n   if (gimple_in_ssa_p (cfun))\n     {\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n \n       offset = gimple_omp_continue_control_use (cont_stmt);\n@@ -5446,7 +5446,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n      occur, especially when noreturn routines are involved.  */\n   if (cont_bb)\n     {\n-      gsi = gsi_last_bb (cont_bb);\n+      gsi = gsi_last_nondebug_bb (cont_bb);\n       gomp_continue *cont_stmt = as_a <gomp_continue *> (gsi_stmt (gsi));\n       loc = gimple_location (cont_stmt);\n \n@@ -5535,7 +5535,7 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \t}\n     }\n \n-  gsi = gsi_last_bb (exit_bb);\n+  gsi = gsi_last_nondebug_bb (exit_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n   loc = gimple_location (gsi_stmt (gsi));\n \n@@ -5760,15 +5760,15 @@ expand_omp_sections (struct omp_region *region)\n       len = EDGE_COUNT (l0_bb->succs);\n       gcc_assert (len > 0);\n       e = EDGE_SUCC (l0_bb, len - 1);\n-      si = gsi_last_bb (e->dest);\n+      si = gsi_last_nondebug_bb (e->dest);\n       l2 = NULL_TREE;\n       if (gsi_end_p (si)\n \t  || gimple_code (gsi_stmt (si)) != GIMPLE_OMP_SECTION)\n \tl2 = gimple_block_label (e->dest);\n       else\n \tFOR_EACH_EDGE (e, ei, l0_bb->succs)\n \t  {\n-\t    si = gsi_last_bb (e->dest);\n+\t    si = gsi_last_nondebug_bb (e->dest);\n \t    if (gsi_end_p (si)\n \t\t|| gimple_code (gsi_stmt (si)) != GIMPLE_OMP_SECTION)\n \t      {\n@@ -5793,7 +5793,7 @@ expand_omp_sections (struct omp_region *region)\n \n   /* The call to GOMP_sections_start goes in ENTRY_BB, replacing the\n      GIMPLE_OMP_SECTIONS statement.  */\n-  si = gsi_last_bb (entry_bb);\n+  si = gsi_last_nondebug_bb (entry_bb);\n   sections_stmt = as_a <gomp_sections *> (gsi_stmt (si));\n   gcc_assert (gimple_code (sections_stmt) == GIMPLE_OMP_SECTIONS);\n   vin = gimple_omp_sections_control (sections_stmt);\n@@ -5817,7 +5817,7 @@ expand_omp_sections (struct omp_region *region)\n \n   /* The switch() statement replacing GIMPLE_OMP_SECTIONS_SWITCH goes in\n      L0_BB.  */\n-  switch_si = gsi_last_bb (l0_bb);\n+  switch_si = gsi_last_nondebug_bb (l0_bb);\n   gcc_assert (gimple_code (gsi_stmt (switch_si)) == GIMPLE_OMP_SECTIONS_SWITCH);\n   if (exit_reachable)\n     {\n@@ -5859,7 +5859,7 @@ expand_omp_sections (struct omp_region *region)\n       u = build_case_label (u, NULL, t);\n       label_vec.quick_push (u);\n \n-      si = gsi_last_bb (s_entry_bb);\n+      si = gsi_last_nondebug_bb (s_entry_bb);\n       gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_SECTION);\n       gcc_assert (i < len || gimple_omp_section_last_p (gsi_stmt (si)));\n       gsi_remove (&si, true);\n@@ -5868,7 +5868,7 @@ expand_omp_sections (struct omp_region *region)\n       if (s_exit_bb == NULL)\n \tcontinue;\n \n-      si = gsi_last_bb (s_exit_bb);\n+      si = gsi_last_nondebug_bb (s_exit_bb);\n       gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_RETURN);\n       gsi_remove (&si, true);\n \n@@ -5894,7 +5894,7 @@ expand_omp_sections (struct omp_region *region)\n       tree bfn_decl;\n \n       /* Code to get the next section goes in L1_BB.  */\n-      si = gsi_last_bb (l1_bb);\n+      si = gsi_last_nondebug_bb (l1_bb);\n       gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_CONTINUE);\n \n       bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);\n@@ -5907,7 +5907,7 @@ expand_omp_sections (struct omp_region *region)\n     }\n \n   /* Cleanup function replaces GIMPLE_OMP_RETURN in EXIT_BB.  */\n-  si = gsi_last_bb (l2_bb);\n+  si = gsi_last_nondebug_bb (l2_bb);\n   if (gimple_omp_return_nowait_p (gsi_stmt (si)))\n     t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END_NOWAIT);\n   else if (gimple_omp_return_lhs (gsi_stmt (si)))\n@@ -5935,12 +5935,12 @@ expand_omp_single (struct omp_region *region)\n   entry_bb = region->entry;\n   exit_bb = region->exit;\n \n-  si = gsi_last_bb (entry_bb);\n+  si = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_SINGLE);\n   gsi_remove (&si, true);\n   single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n \n-  si = gsi_last_bb (exit_bb);\n+  si = gsi_last_nondebug_bb (exit_bb);\n   if (!gimple_omp_return_nowait_p (gsi_stmt (si)))\n     {\n       tree t = gimple_omp_return_lhs (gsi_stmt (si));\n@@ -5963,7 +5963,7 @@ expand_omp_synch (struct omp_region *region)\n   entry_bb = region->entry;\n   exit_bb = region->exit;\n \n-  si = gsi_last_bb (entry_bb);\n+  si = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_SINGLE\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_MASTER\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_TASKGROUP\n@@ -5975,7 +5975,7 @@ expand_omp_synch (struct omp_region *region)\n \n   if (exit_bb)\n     {\n-      si = gsi_last_bb (exit_bb);\n+      si = gsi_last_nondebug_bb (exit_bb);\n       gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_RETURN);\n       gsi_remove (&si, true);\n       single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n@@ -5996,7 +5996,7 @@ expand_omp_atomic_load (basic_block load_bb, tree addr,\n   gimple *stmt;\n   tree decl, call, type, itype;\n \n-  gsi = gsi_last_bb (load_bb);\n+  gsi = gsi_last_nondebug_bb (load_bb);\n   stmt = gsi_stmt (gsi);\n   gcc_assert (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD);\n   loc = gimple_location (stmt);\n@@ -6026,7 +6026,7 @@ expand_omp_atomic_load (basic_block load_bb, tree addr,\n   gsi_remove (&gsi, true);\n \n   store_bb = single_succ (load_bb);\n-  gsi = gsi_last_bb (store_bb);\n+  gsi = gsi_last_nondebug_bb (store_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_STORE);\n   gsi_remove (&gsi, true);\n \n@@ -6052,14 +6052,14 @@ expand_omp_atomic_store (basic_block load_bb, tree addr,\n   machine_mode imode;\n   bool exchange;\n \n-  gsi = gsi_last_bb (load_bb);\n+  gsi = gsi_last_nondebug_bb (load_bb);\n   stmt = gsi_stmt (gsi);\n   gcc_assert (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD);\n \n   /* If the load value is needed, then this isn't a store but an exchange.  */\n   exchange = gimple_omp_atomic_need_value_p (stmt);\n \n-  gsi = gsi_last_bb (store_bb);\n+  gsi = gsi_last_nondebug_bb (store_bb);\n   stmt = gsi_stmt (gsi);\n   gcc_assert (gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE);\n   loc = gimple_location (stmt);\n@@ -6104,7 +6104,7 @@ expand_omp_atomic_store (basic_block load_bb, tree addr,\n   gsi_remove (&gsi, true);\n \n   /* Remove the GIMPLE_OMP_ATOMIC_LOAD that we verified above.  */\n-  gsi = gsi_last_bb (load_bb);\n+  gsi = gsi_last_nondebug_bb (load_bb);\n   gsi_remove (&gsi, true);\n \n   if (gimple_in_ssa_p (cfun))\n@@ -6151,10 +6151,17 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n \n   gsi = gsi_after_labels (store_bb);\n   stmt = gsi_stmt (gsi);\n+  if (is_gimple_debug (stmt))\n+    {\n+      gsi_next_nondebug (&gsi);\n+      if (gsi_end_p (gsi))\n+\treturn false;\n+      stmt = gsi_stmt (gsi);\n+    }\n   loc = gimple_location (stmt);\n   if (!is_gimple_assign (stmt))\n     return false;\n-  gsi_next (&gsi);\n+  gsi_next_nondebug (&gsi);\n   if (gimple_code (gsi_stmt (gsi)) != GIMPLE_OMP_ATOMIC_STORE)\n     return false;\n   need_new = gimple_omp_atomic_need_value_p (gsi_stmt (gsi));\n@@ -6218,7 +6225,7 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   if (!can_compare_and_swap_p (imode, true) || !can_atomic_load_p (imode))\n     return false;\n \n-  gsi = gsi_last_bb (load_bb);\n+  gsi = gsi_last_nondebug_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_LOAD);\n \n   /* OpenMP does not imply any barrier-like semantics on its atomic ops.\n@@ -6241,10 +6248,10 @@ expand_omp_atomic_fetch_op (basic_block load_bb,\n   force_gimple_operand_gsi (&gsi, call, true, NULL_TREE, true, GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n \n-  gsi = gsi_last_bb (store_bb);\n+  gsi = gsi_last_nondebug_bb (store_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_ATOMIC_STORE);\n   gsi_remove (&gsi, true);\n-  gsi = gsi_last_bb (store_bb);\n+  gsi = gsi_last_nondebug_bb (store_bb);\n   stmt = gsi_stmt (gsi);\n   gsi_remove (&gsi, true);\n \n@@ -6297,7 +6304,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n     return false;\n \n   /* Load the initial value, replacing the GIMPLE_OMP_ATOMIC_LOAD.  */\n-  si = gsi_last_bb (load_bb);\n+  si = gsi_last_nondebug_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_LOAD);\n \n   /* For floating-point values, we'll need to view-convert them to integers\n@@ -6377,7 +6384,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n     }\n   gsi_remove (&si, true);\n \n-  si = gsi_last_bb (store_bb);\n+  si = gsi_last_nondebug_bb (store_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_STORE);\n \n   if (iaddr == addr)\n@@ -6480,7 +6487,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n   gassign *stmt;\n   tree t;\n \n-  si = gsi_last_bb (load_bb);\n+  si = gsi_last_nondebug_bb (load_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_LOAD);\n \n   t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START);\n@@ -6491,7 +6498,7 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n   gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n   gsi_remove (&si, true);\n \n-  si = gsi_last_bb (store_bb);\n+  si = gsi_last_nondebug_bb (store_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_STORE);\n \n   stmt = gimple_build_assign (build_simple_mem_ref (unshare_expr (addr)),\n@@ -6990,7 +6997,7 @@ expand_omp_target (struct omp_region *region)\n \n       /* Split ENTRY_BB at GIMPLE_*,\n \t so that it can be moved to the child function.  */\n-      gsi = gsi_last_bb (entry_bb);\n+      gsi = gsi_last_nondebug_bb (entry_bb);\n       stmt = gsi_stmt (gsi);\n       gcc_assert (stmt\n \t\t  && gimple_code (stmt) == gimple_code (entry_stmt));\n@@ -7002,7 +7009,7 @@ expand_omp_target (struct omp_region *region)\n       /* Convert GIMPLE_OMP_RETURN into a RETURN_EXPR.  */\n       if (exit_bb)\n \t{\n-\t  gsi = gsi_last_bb (exit_bb);\n+\t  gsi = gsi_last_nondebug_bb (exit_bb);\n \t  gcc_assert (!gsi_end_p (gsi)\n \t\t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n \t  stmt = gimple_build_return (NULL);\n@@ -7184,7 +7191,7 @@ expand_omp_target (struct omp_region *region)\n \te = split_block_after_labels (new_bb);\n       else\n \t{\n-\t  gsi = gsi_last_bb (new_bb);\n+\t  gsi = gsi_last_nondebug_bb (new_bb);\n \t  gsi_prev (&gsi);\n \t  e = split_block (new_bb, gsi_stmt (gsi));\n \t}\n@@ -7219,11 +7226,11 @@ expand_omp_target (struct omp_region *region)\n       make_edge (else_bb, new_bb, EDGE_FALLTHRU);\n \n       device = tmp_var;\n-      gsi = gsi_last_bb (new_bb);\n+      gsi = gsi_last_nondebug_bb (new_bb);\n     }\n   else\n     {\n-      gsi = gsi_last_bb (new_bb);\n+      gsi = gsi_last_nondebug_bb (new_bb);\n       device = force_gimple_operand_gsi (&gsi, device, true, NULL_TREE,\n \t\t\t\t\t true, GSI_SAME_STMT);\n     }\n@@ -7367,7 +7374,7 @@ expand_omp_target (struct omp_region *region)\n     }\n   if (data_region && region->exit)\n     {\n-      gsi = gsi_last_bb (region->exit);\n+      gsi = gsi_last_nondebug_bb (region->exit);\n       g = gsi_stmt (gsi);\n       gcc_assert (g && gimple_code (g) == GIMPLE_OMP_RETURN);\n       gsi_remove (&gsi, true);\n@@ -7448,17 +7455,17 @@ grid_expand_omp_for_loop (struct omp_region *kfor, bool intra_group)\n       gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n     }\n   /* Remove the omp for statement.  */\n-  gsi = gsi_last_bb (kfor->entry);\n+  gsi = gsi_last_nondebug_bb (kfor->entry);\n   gsi_remove (&gsi, true);\n \n   /* Remove the GIMPLE_OMP_CONTINUE statement.  */\n-  gsi = gsi_last_bb (kfor->cont);\n+  gsi = gsi_last_nondebug_bb (kfor->cont);\n   gcc_assert (!gsi_end_p (gsi)\n \t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_CONTINUE);\n   gsi_remove (&gsi, true);\n \n   /* Replace the GIMPLE_OMP_RETURN with a barrier, if necessary.  */\n-  gsi = gsi_last_bb (kfor->exit);\n+  gsi = gsi_last_nondebug_bb (kfor->exit);\n   gcc_assert (!gsi_end_p (gsi)\n \t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n   if (intra_group)\n@@ -7602,11 +7609,11 @@ grid_expand_target_grid_body (struct omp_region *target)\n   grid_expand_omp_for_loop (kfor, false);\n \n   /* Remove the omp for statement.  */\n-  gimple_stmt_iterator gsi = gsi_last_bb (gpukernel->entry);\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (gpukernel->entry);\n   gsi_remove (&gsi, true);\n   /* Replace the GIMPLE_OMP_RETURN at the end of the kernel region with a real\n      return.  */\n-  gsi = gsi_last_bb (gpukernel->exit);\n+  gsi = gsi_last_nondebug_bb (gpukernel->exit);\n   gcc_assert (!gsi_end_p (gsi)\n \t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n   gimple *ret_stmt = gimple_build_return (NULL);\n@@ -7790,7 +7797,7 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n   gimple *stmt;\n   basic_block son;\n \n-  gsi = gsi_last_bb (bb);\n+  gsi = gsi_last_nondebug_bb (bb);\n   if (!gsi_end_p (gsi) && is_gimple_omp (gsi_stmt (gsi)))\n     {\n       struct omp_region *region;"}, {"sha": "3d566aaef12bf3137ce4e4c79ba9da5d18240329", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -6963,6 +6963,8 @@ check_combined_parallel (gimple_stmt_iterator *gsi_p,\n     {\n     WALK_SUBSTMTS;\n \n+    case GIMPLE_DEBUG:\n+      break;\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_SECTIONS:\n       *info = *info == 0 ? 1 : -1;"}, {"sha": "8e4a81903f5ea3617d346c03baed41b914ae3999", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -836,7 +836,7 @@ fixup_debug_insns (rtx reg, rtx replacement, rtx_insn *from, rtx_insn *to)\n     {\n       rtx t;\n \n-      if (!DEBUG_INSN_P (insn))\n+      if (!DEBUG_BIND_INSN_P (insn))\n \tcontinue;\n       \n       t = INSN_VAR_LOCATION_LOC (insn);"}, {"sha": "33e6e62a4c267b2aee80a1e946226574f5a3fc09", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -428,6 +428,8 @@ find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n   machine_mode mode = GET_MODE (reg);\n   unsigned int i;\n \n+  gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n+\n   /* If we are accessing REG in some mode other that what we set it in,\n      make sure that the replacement is valid.  In particular, consider\n \t(set (reg:DI r11) (...))"}, {"sha": "a69ea90622da825426ef9f8aaeac63560333f5dd", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -460,7 +460,7 @@ sese_trivially_empty_bb_p (basic_block bb)\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_DEBUG\n+    if (!is_gimple_debug (gsi_stmt (gsi))\n \t&& gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n       return false;\n "}, {"sha": "b00a2913293663f3661e7a958565c0287847970e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -561,14 +561,22 @@ make_blocks_1 (gimple_seq seq, basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start (seq);\n   gimple *stmt = NULL;\n+  gimple *prev_stmt = NULL;\n   bool start_new_block = true;\n   bool first_stmt_of_seq = true;\n \n   while (!gsi_end_p (i))\n     {\n-      gimple *prev_stmt;\n-\n-      prev_stmt = stmt;\n+      /* PREV_STMT should only be set to a debug stmt if the debug\n+\t stmt is before nondebug stmts.  Once stmt reaches a nondebug\n+\t nonlabel, prev_stmt will be set to it, so that\n+\t stmt_starts_bb_p will know to start a new block if a label is\n+\t found.  However, if stmt was a label after debug stmts only,\n+\t keep the label in prev_stmt even if we find further debug\n+\t stmts, for there may be other labels after them, and they\n+\t should land in the same block.  */\n+      if (!prev_stmt || !stmt || !is_gimple_debug (stmt))\n+\tprev_stmt = stmt;\n       stmt = gsi_stmt (i);\n \n       if (stmt && is_gimple_call (stmt))\n@@ -583,6 +591,7 @@ make_blocks_1 (gimple_seq seq, basic_block bb)\n \t    gsi_split_seq_before (&i, &seq);\n \t  bb = create_basic_block (seq, bb);\n \t  start_new_block = false;\n+\t  prev_stmt = NULL;\n \t}\n \n       /* Now add STMT to BB and create the subgraphs for special statement\n@@ -996,7 +1005,11 @@ make_edges (void)\n \t      tree target;\n \n \t      if (!label_stmt)\n-\t\tbreak;\n+\t\t{\n+\t\t  if (is_gimple_debug (gsi_stmt (gsi)))\n+\t\t    continue;\n+\t\t  break;\n+\t\t}\n \n \t      target = gimple_label_label (label_stmt);\n \n@@ -1506,6 +1519,9 @@ cleanup_dead_labels (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n \t{\n+\t  if (is_gimple_debug (gsi_stmt (i)))\n+\t    continue;\n+\n \t  tree label;\n \t  glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (i));\n \n@@ -1666,6 +1682,12 @@ cleanup_dead_labels (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n \t{\n+\t  if (is_gimple_debug (gsi_stmt (i)))\n+\t    {\n+\t      gsi_next (&i);\n+\t      continue;\n+\t    }\n+\n \t  tree label;\n \t  glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (i));\n \n@@ -1841,6 +1863,8 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n        gsi_next (&gsi))\n     {\n       tree lab;\n+      if (is_gimple_debug (gsi_stmt (gsi)))\n+\tcontinue;\n       glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n       if (!label_stmt)\n \tbreak;\n@@ -2642,6 +2666,13 @@ stmt_starts_bb_p (gimple *stmt, gimple *prev_stmt)\n   if (stmt == NULL)\n     return false;\n \n+  /* PREV_STMT is only set to a debug stmt if the debug stmt is before\n+     any nondebug stmts in the block.  We don't want to start another\n+     block in this case: the debug stmt will already have started the\n+     one STMT would start if we weren't outputting debug stmts.  */\n+  if (prev_stmt && is_gimple_debug (prev_stmt))\n+    return false;\n+\n   /* Labels start a new basic block only if the preceding statement\n      wasn't a label of the same type.  This prevents the creation of\n      consecutive blocks that have nothing but a single label.  */\n@@ -5488,6 +5519,10 @@ gimple_verify_flow_info (void)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  tree label;\n+\n+\t  if (is_gimple_debug (gsi_stmt (gsi)))\n+\t    continue;\n+\n \t  gimple *prev_stmt = stmt;\n \n \t  stmt = gsi_stmt (gsi);\n@@ -5557,7 +5592,7 @@ gimple_verify_flow_info (void)\n \t    }\n \t}\n \n-      gsi = gsi_last_bb (bb);\n+      gsi = gsi_last_nondebug_bb (bb);\n       if (gsi_end_p (gsi))\n \tcontinue;\n \n@@ -5812,8 +5847,10 @@ gimple_block_label (basic_block bb)\n   tree label;\n   glabel *stmt;\n \n-  for (i = s; !gsi_end_p (i); first = false, gsi_next (&i))\n+  for (i = s; !gsi_end_p (i); gsi_next (&i))\n     {\n+      if (is_gimple_debug (gsi_stmt (i)))\n+\tcontinue;\n       stmt = dyn_cast <glabel *> (gsi_stmt (i));\n       if (!stmt)\n \tbreak;\n@@ -5824,6 +5861,7 @@ gimple_block_label (basic_block bb)\n \t    gsi_move_before (&i, &s);\n \t  return label;\n \t}\n+      first = false;\n     }\n \n   label = create_artificial_label (UNKNOWN_LOCATION);\n@@ -5899,7 +5937,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \treturn ret;\n     }\n \n-  gsi = gsi_last_bb (bb);\n+  gsi = gsi_last_nondebug_bb (bb);\n   stmt = gsi_end_p (gsi) ? NULL : gsi_stmt (gsi);\n \n   switch (stmt ? gimple_code (stmt) : GIMPLE_ERROR_MARK)"}, {"sha": "0bee21756f2b4ba93fa1d3caaceae547d73b8379", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -542,13 +542,13 @@ remove_forwarder_block (basic_block bb)\n     {\n       tree decl;\n       label = gsi_stmt (gsi);\n-      if (is_gimple_debug (label))\n-\tbreak;\n-      decl = gimple_label_label (as_a <glabel *> (label));\n-      if (EH_LANDING_PAD_NR (decl) != 0\n-\t  || DECL_NONLOCAL (decl)\n-\t  || FORCED_LABEL (decl)\n-\t  || !DECL_ARTIFICIAL (decl))\n+      if (is_gimple_debug (label)\n+\t  ? can_move_debug_stmts\n+\t  : ((decl = gimple_label_label (as_a <glabel *> (label))),\n+\t     EH_LANDING_PAD_NR (decl) != 0\n+\t     || DECL_NONLOCAL (decl)\n+\t     || FORCED_LABEL (decl)\n+\t     || !DECL_ARTIFICIAL (decl)))\n \t{\n \t  gsi_remove (&gsi, false);\n \t  gsi_insert_before (&gsi_to, label, GSI_SAME_STMT);\n@@ -557,20 +557,6 @@ remove_forwarder_block (basic_block bb)\n \tgsi_next (&gsi);\n     }\n \n-  /* Move debug statements if the destination has a single predecessor.  */\n-  if (can_move_debug_stmts)\n-    {\n-      gsi_to = gsi_after_labels (dest);\n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); )\n-\t{\n-\t  gimple *debug = gsi_stmt (gsi);\n-\t  if (!is_gimple_debug (debug))\n-\t    break;\n-\t  gsi_remove (&gsi, false);\n-\t  gsi_insert_before (&gsi_to, debug, GSI_SAME_STMT);\n-\t}\n-    }\n-\n   bitmap_set_bit (cfgcleanup_altered_bbs, dest->index);\n \n   /* Update the dominators.  */\n@@ -1309,7 +1295,8 @@ execute_cleanup_cfg_post_optimizing (void)\n \n \t  flag_dump_noaddr = flag_dump_unnumbered = 1;\n \t  fprintf (final_output, \"\\n\");\n-\t  dump_enumerated_decls (final_output, dump_flags | TDF_NOUID);\n+\t  dump_enumerated_decls (final_output,\n+\t\t\t\t dump_flags | TDF_SLIM | TDF_NOUID);\n \t  flag_dump_noaddr = save_noaddr;\n \t  flag_dump_unnumbered = save_unnumbered;\n \t  if (fclose (final_output))"}, {"sha": "bf872b8d35e9244c987b01f5867f833b22f3e5b0", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -3325,7 +3325,10 @@ print_declaration (pretty_printer *pp, tree t, int spc, dump_flags_t flags)\n \t  pp_space (pp);\n \t  pp_equal (pp);\n \t  pp_space (pp);\n-\t  dump_generic_node (pp, DECL_INITIAL (t), spc, flags, false);\n+\t  if (!(flags & TDF_SLIM))\n+\t    dump_generic_node (pp, DECL_INITIAL (t), spc, flags, false);\n+\t  else\n+\t    pp_string (pp, \"<<< omitted >>>\");\n \t}\n     }\n "}, {"sha": "3b9e1076506a4815977f3cd08bd652c945f80241", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -256,7 +256,8 @@ mark_stmt_if_obviously_necessary (gimple *stmt, bool aggressive)\n \t easily locate the debug temp bind stmt for a use thereof,\n \t would could refrain from marking all debug temps here, and\n \t mark them only if they're used.  */\n-      if (!gimple_debug_bind_p (stmt)\n+      if (gimple_debug_nonbind_marker_p (stmt)\n+\t  || !gimple_debug_bind_p (stmt)\n \t  || gimple_debug_bind_has_value_p (stmt)\n \t  || TREE_CODE (gimple_debug_bind_get_var (stmt)) != DEBUG_EXPR_DECL)\n \tmark_stmt_necessary (stmt, false);\n@@ -1442,8 +1443,7 @@ eliminate_unnecessary_stmts (void)\n \t\t     dominate others.  Walking backwards, this should\n \t\t     be the common case.  ??? Do we need to recompute\n \t\t     dominators because of cfg_altered?  */\n-\t\t  if (!MAY_HAVE_DEBUG_STMTS\n-\t\t      || !first_dom_son (CDI_DOMINATORS, bb))\n+\t\t  if (!first_dom_son (CDI_DOMINATORS, bb))\n \t\t    delete_basic_block (bb);\n \t\t  else\n \t\t    {"}, {"sha": "743ee4e1cf998bf2f46f132ca7ffa27e3e3509a2", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -1295,14 +1295,14 @@ find_duplicate (same_succ *same_succ, basic_block bb1, basic_block bb2)\n       tree label = gimple_label_label (as_a <glabel *> (gsi_stmt (gsi1)));\n       if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n \treturn;\n-      gsi_prev (&gsi1);\n+      gsi_prev_nondebug (&gsi1);\n     }\n   while (!gsi_end_p (gsi2) && gimple_code (gsi_stmt (gsi2)) == GIMPLE_LABEL)\n     {\n       tree label = gimple_label_label (as_a <glabel *> (gsi_stmt (gsi2)));\n       if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n \treturn;\n-      gsi_prev (&gsi2);\n+      gsi_prev_nondebug (&gsi2);\n     }\n   if (!(gsi_end_p (gsi1) && gsi_end_p (gsi2)))\n     return;"}, {"sha": "b324a2c97c283efb56ddf6bbb1a54636ae5db980", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f4b8759bda30d63404acb381b24a2ec960e667/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=65f4b8759bda30d63404acb381b24a2ec960e667", "patch": "@@ -9479,6 +9479,24 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n     }\n }\n \n+/* Return BB's head, unless BB is the block that succeeds ENTRY_BLOCK,\n+   in which case it searches back from BB's head for the very first\n+   insn.  Use [get_first_insn (bb), BB_HEAD (bb->next_bb)[ as a range\n+   to iterate over all insns of a function while iterating over its\n+   BBs.  */\n+\n+static rtx_insn *\n+get_first_insn (basic_block bb)\n+{\n+  rtx_insn *insn = BB_HEAD (bb);\n+\n+  if (bb->prev_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+    while (rtx_insn *prev = PREV_INSN (insn))\n+      insn = prev;\n+\n+  return insn;\n+}\n+\n /* Emit notes for the whole function.  */\n \n static void\n@@ -9507,7 +9525,8 @@ vt_emit_notes (void)\n     {\n       /* Emit the notes for changes of variable locations between two\n \t subsequent basic blocks.  */\n-      emit_notes_for_differences (BB_HEAD (bb), &cur, &VTI (bb)->in);\n+      emit_notes_for_differences (get_first_insn (bb),\n+\t\t\t\t  &cur, &VTI (bb)->in);\n \n       if (MAY_HAVE_DEBUG_BIND_INSNS)\n \tlocal_get_addr_cache = new hash_map<rtx, rtx>;\n@@ -10103,11 +10122,34 @@ vt_initialize (void)\n \t{\n \t  HOST_WIDE_INT offset = VTI (bb)->out.stack_adjust;\n \t  VTI (bb)->out.stack_adjust = VTI (bb)->in.stack_adjust;\n-\t  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n-\t       insn = NEXT_INSN (insn))\n+\n+\t  /* If we are walking the first basic block, walk any HEADER\n+\t     insns that might be before it too.  Unfortunately,\n+\t     BB_HEADER and BB_FOOTER are not set while we run this\n+\t     pass.  */\n+\t  insn = get_first_insn (bb);\n+\t  for (rtx_insn *next;\n+\t       insn != BB_HEAD (bb->next_bb)\n+\t\t ? next = NEXT_INSN (insn), true : false;\n+\t       insn = next)\n \t    {\n \t      if (INSN_P (insn))\n \t\t{\n+\t\t  basic_block save_bb = BLOCK_FOR_INSN (insn);\n+\t\t  if (!BLOCK_FOR_INSN (insn))\n+\t\t    {\n+\t\t      BLOCK_FOR_INSN (insn) = bb;\n+\t\t      gcc_assert (DEBUG_INSN_P (insn));\n+\t\t      /* Reset debug insns between basic blocks.\n+\t\t\t Their location is not reliable, because they\n+\t\t\t were probably not maintained up to date.  */\n+\t\t      if (DEBUG_BIND_INSN_P (insn))\n+\t\t\tINSN_VAR_LOCATION_LOC (insn)\n+\t\t\t  = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t\t    }\n+\t\t  else\n+\t\t    gcc_assert (BLOCK_FOR_INSN (insn) == bb);\n+\n \t\t  if (!frame_pointer_needed)\n \t\t    {\n \t\t      insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n@@ -10175,6 +10217,7 @@ vt_initialize (void)\n \t\t\t    }\n \t\t\t}\n \t\t    }\n+\t\t  BLOCK_FOR_INSN (insn) = save_bb;\n \t\t}\n \t    }\n \t  gcc_assert (offset == VTI (bb)->out.stack_adjust);\n@@ -10215,7 +10258,10 @@ delete_debug_insns (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      FOR_BB_INSNS_SAFE (bb, insn, next)\n+      for (insn = get_first_insn (bb);\n+\t   insn != BB_HEAD (bb->next_bb)\n+\t     ? next = NEXT_INSN (insn), true : false;\n+\t   insn = next)\n \tif (DEBUG_INSN_P (insn))\n \t  {\n \t    tree decl = INSN_VAR_LOCATION_DECL (insn);"}]}