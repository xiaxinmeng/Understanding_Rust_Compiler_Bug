{"sha": "4003ecbcedca2c36de762a8171b90a7969edce82", "node_id": "C_kwDOANBUbNoAKDQwMDNlY2JjZWRjYTJjMzZkZTc2MmE4MTcxYjkwYTc5NjllZGNlODI", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2022-01-03T01:40:34Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2022-01-03T17:52:59Z"}, "message": "Revamp documentation for _Complex types extension\n\nWhile cleaning up the bug database, I noticed there was a request\nto improve the documentation of the _Complex type extensions.\nSo I rewrote part of the documentation to make things clearer on\n__real/__imag and even added documentation about casts between\nthe scalar and the complex type.\nI moved the documentation of __builtin_complex under this section\ntoo because it makes more sense than having it in the other\nbuilt-in section and reference it.\n\nOK? Built make info and make html and checked out the results to\nmake sure the tables look decent.\n\ngcc/ChangeLog:\n\n\tPR c/33193\n\t* doc/extend.texi: Extend the documentation about Complex\n\ttypes for casting and also rewrite the __real__/__imag__\n\texpression portion to use tables.\n\tMove __builtin_complex to the Complex type section.", "tree": {"sha": "a98fd29e272cc587d6432fc9c3a3260d90983b24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a98fd29e272cc587d6432fc9c3a3260d90983b24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4003ecbcedca2c36de762a8171b90a7969edce82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4003ecbcedca2c36de762a8171b90a7969edce82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4003ecbcedca2c36de762a8171b90a7969edce82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4003ecbcedca2c36de762a8171b90a7969edce82/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6447f6f983ffeaecb8753ef685d702bf2594968b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6447f6f983ffeaecb8753ef685d702bf2594968b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6447f6f983ffeaecb8753ef685d702bf2594968b"}], "stats": {"total": 73, "additions": 54, "deletions": 19}, "files": [{"sha": "5eec94ed4d7f17d7fa8b5010edd19a08c4ac4cd6", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4003ecbcedca2c36de762a8171b90a7969edce82/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4003ecbcedca2c36de762a8171b90a7969edce82/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4003ecbcedca2c36de762a8171b90a7969edce82", "patch": "@@ -986,22 +986,57 @@ The ISO C++14 library also defines the @samp{i} suffix, so C++14 code\n that includes the @samp{<complex>} header cannot use @samp{i} for the\n GNU extension.  The @samp{j} suffix still has the GNU meaning.\n \n+GCC can handle both implicit and explicit casts between the @code{_Complex}\n+types and other @code{_Complex} types as casting both the real and imaginary\n+parts to the scalar type.\n+GCC can handle implicit and explicit casts from a scalar type to a @code{_Complex}\n+type and where the imaginary part will be considered zero.\n+The C front-end can handle implicit and explicit casts from a @code{_Complex} type\n+to a scalar type where the imaginary part will be ignored. In C++ code, this cast\n+is considered illformed and G++ will error out.\n+\n+GCC provides a built-in function @code{__builtin_complex} will can be used to\n+construct a complex value.\n+\n @cindex @code{__real__} keyword\n @cindex @code{__imag__} keyword\n-To extract the real part of a complex-valued expression @var{exp}, write\n-@code{__real__ @var{exp}}.  Likewise, use @code{__imag__} to\n-extract the imaginary part.  This is a GNU extension; for values of\n-floating type, you should use the ISO C99 functions @code{crealf},\n-@code{creal}, @code{creall}, @code{cimagf}, @code{cimag} and\n-@code{cimagl}, declared in @code{<complex.h>} and also provided as\n+\n+GCC has a few extensions which can be used to extract the real\n+and the imaginary part of the complex-valued expression. Note\n+these expressions are lvalues if the @var{exp} is an lvalue.\n+These expressions operands have the type of a complex type\n+which might get prompoted to a complex type from a scalar type.\n+E.g. @code{__real__ (int)@var{x}} is the same as casting to\n+@code{_Complex int} before @code{__real__} is done.\n+\n+@multitable @columnfractions .4 .6\n+@headitem Expression @tab Description\n+@item @code{__real__ @var{exp}}\n+@tab Extract the real part of @var{exp}.\n+@item @code{__imag__ @var{exp}}\n+@tab Extract the imaginary part of @var{exp}.\n+@end multitable\n+\n+For values of floating point, you should use the ISO C99\n+functions, declared in @code{<complex.h>} and also provided as\n built-in functions by GCC@.\n \n+@multitable @columnfractions .4 .2 .2 .2\n+@headitem Expression @tab float @tab double @tab long double\n+@item @code{__real__ @var{exp}}\n+@tab @code{crealf} @tab @code{creal} @tab @code{creall}\n+@item @code{__imag__ @var{exp}}\n+@tab @code{cimagf} @tab @code{cimag} @tab @code{cimagl}\n+@end multitable\n+\n @cindex complex conjugation\n The operator @samp{~} performs complex conjugation when used on a value\n with a complex type.  This is a GNU extension; for values of\n floating type, you should use the ISO C99 functions @code{conjf},\n @code{conj} and @code{conjl}, declared in @code{<complex.h>} and also\n-provided as built-in functions by GCC@.\n+provided as built-in functions by GCC@. Note unlike the @code{__real__}\n+and @code{__imag__} operators, this operator will not do an implicit cast\n+to the complex type because the @samp{~} is already a normal operator.\n \n GCC can allocate complex automatic variables in a noncontiguous\n fashion; it's even possible for the real part to be in a register while\n@@ -1013,6 +1048,18 @@ If the variable's actual name is @code{foo}, the two fictitious\n variables are named @code{foo$real} and @code{foo$imag}.  You can\n examine and set these two fictitious variables with your debugger.\n \n+@deftypefn {Built-in Function} @var{type} __builtin_complex (@var{real}, @var{imag})\n+\n+The built-in function @code{__builtin_complex} is provided for use in\n+implementing the ISO C11 macros @code{CMPLXF}, @code{CMPLX} and\n+@code{CMPLXL}.  @var{real} and @var{imag} must have the same type, a\n+real binary floating-point type, and the result has the corresponding\n+complex type with real and imaginary parts @var{real} and @var{imag}.\n+Unlike @samp{@var{real} + I * @var{imag}}, this works even when\n+infinities, NaNs and negative zeros are involved.\n+\n+@end deftypefn\n+\n @node Floating Types\n @section Additional Floating Types\n @cindex additional floating types\n@@ -13834,18 +13881,6 @@ an error if there is no such function.\n \n @end deftypefn\n \n-@deftypefn {Built-in Function} @var{type} __builtin_complex (@var{real}, @var{imag})\n-\n-The built-in function @code{__builtin_complex} is provided for use in\n-implementing the ISO C11 macros @code{CMPLXF}, @code{CMPLX} and\n-@code{CMPLXL}.  @var{real} and @var{imag} must have the same type, a\n-real binary floating-point type, and the result has the corresponding\n-complex type with real and imaginary parts @var{real} and @var{imag}.\n-Unlike @samp{@var{real} + I * @var{imag}}, this works even when\n-infinities, NaNs and negative zeros are involved.\n-\n-@end deftypefn\n-\n @deftypefn {Built-in Function} int __builtin_constant_p (@var{exp})\n You can use the built-in function @code{__builtin_constant_p} to\n determine if a value is known to be constant at compile time and hence"}]}