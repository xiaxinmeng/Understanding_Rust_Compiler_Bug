{"sha": "c24ae149dd6cec1b08f21d99c8db45fe9ba3f442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0YWUxNDlkZDZjZWMxYjA4ZjIxZDk5YzhkYjQ1ZmU5YmEzZjQ0Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-05T11:44:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-05T11:44:37Z"}, "message": "expr.c (store_expr): When copying string constant into array...\n\n\t* expr.c (store_expr): When copying string constant into array,\n\tuse functions that update memrefs instead of computations on\n\taddresses to better track MEMs.  Also properly handle 32/64 pointers.\n\t(expand_expr): Use TARGET even if not reg for multi-word CONSTRUCTOR.\n\t(expand_expr, case CONSTRUCTOR): Fix errors in parms to assign_temp.\n\nFrom-SVN: r47663", "tree": {"sha": "4802ce8c96eb6abfe2ed68fb1dabe77ef37593b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4802ce8c96eb6abfe2ed68fb1dabe77ef37593b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442/comments", "author": null, "committer": null, "parents": [{"sha": "c56e3582c20263c442e00da7ea484edf9c912165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56e3582c20263c442e00da7ea484edf9c912165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56e3582c20263c442e00da7ea484edf9c912165"}], "stats": {"total": 64, "additions": 30, "deletions": 34}, "files": [{"sha": "2476e327b5efc9944749f17e9883d41f7a642014", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c24ae149dd6cec1b08f21d99c8db45fe9ba3f442", "patch": "@@ -1,5 +1,11 @@\n Wed Dec  5 06:26:27 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* expr.c (store_expr): When copying string constant into array,\n+\tuse functions that update memrefs instead of computations on\n+\taddresses to better track MEMs.  Also properly handle 32/64 pointers.\n+\t(expand_expr): Use TARGET even if not reg for multi-word CONSTRUCTOR.\n+\t(expand_expr, case CONSTRUCTOR): Fix errors in parms to assign_temp.\n+\n \t* emit-rtl.c (component_ref_for_mem_expr): Try harder to find decl\n \tunderneath COMPONENT_REFs.\n \t(set_mem_attributes): Also strip VIEW_CONVERT_EXPR."}, {"sha": "af36b3b5820fff038176f5c9edd0d52b42c5b6db", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24ae149dd6cec1b08f21d99c8db45fe9ba3f442/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c24ae149dd6cec1b08f21d99c8db45fe9ba3f442", "patch": "@@ -4253,15 +4253,12 @@ store_expr (exp, target, want_value)\n \n       else if (GET_MODE (temp) == BLKmode && TREE_CODE (exp) == STRING_CST)\n \t{\n-\t  /* Handle copying a string constant into an array.\n-\t     The string constant may be shorter than the array.\n-\t     So copy just the string's actual length, and clear the rest.  */\n-\t  rtx size;\n-\t  rtx addr;\n+\t  /* Handle copying a string constant into an array.  The string\n+\t     constant may be shorter than the array.  So copy just the string's\n+\t     actual length, and clear the rest.  First get the size of the data\n+\t     type of the string, which is actually the size of the target.  */\n+\t  rtx size = expr_size (exp);\n \n-\t  /* Get the size of the data type of the string,\n-\t     which is actually the size of the target.  */\n-\t  size = expr_size (exp);\n \t  if (GET_CODE (size) == CONST_INT\n \t      && INTVAL (size) < TREE_STRING_LENGTH (exp))\n \t    emit_block_move (target, temp, size);\n@@ -4277,58 +4274,49 @@ store_expr (exp, target, want_value)\n \t      rtx label = 0;\n \n \t      /* Copy that much.  */\n+\t      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx, 0);\n \t      emit_block_move (target, temp, copy_size_rtx);\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n \t\t Do all calculations in ptr_mode.  */\n-\n-\t      addr = XEXP (target, 0);\n-\t      addr = convert_modes (ptr_mode, Pmode, addr, 1);\n-\n \t      if (GET_CODE (copy_size_rtx) == CONST_INT)\n \t\t{\n-\t\t  addr = plus_constant (addr, TREE_STRING_LENGTH (exp));\n-\t\t  size = plus_constant (size, -TREE_STRING_LENGTH (exp));\n+\t\t  size = plus_constant (size, -INTVAL (copy_size_rtx));\n+\t\t  target = adjust_address (target, BLKmode,\n+\t\t\t\t\t   INTVAL (copy_size_rtx));\n \t\t}\n \t      else\n \t\t{\n-\t\t  addr = force_reg (ptr_mode, addr);\n-\t\t  addr = expand_binop (ptr_mode, add_optab, addr,\n-\t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n-\t\t\t\t       OPTAB_LIB_WIDEN);\n-\n \t\t  size = expand_binop (ptr_mode, sub_optab, size,\n \t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n \t\t\t\t       OPTAB_LIB_WIDEN);\n \n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t\t  if (GET_MODE (copy_size_rtx) != Pmode)\n+\t\t    copy_size_rtx = convert_memory_address (Pmode,\n+\t\t\t\t\t\t\t    copy_size_rtx);\n+#endif\n+\n+\t\t  target = offset_address (target, copy_size_rtx,\n+\t\t\t\t\t   highest_pow2_factor (copy_size));\n \t\t  label = gen_label_rtx ();\n \t\t  emit_cmp_and_jump_insns (size, const0_rtx, LT, NULL_RTX,\n \t\t\t\t\t   GET_MODE (size), 0, label);\n \t\t}\n \n \t      if (size != const0_rtx)\n \t\t{\n-\t\t  rtx dest = gen_rtx_MEM (BLKmode, addr);\n-\n-\t\t  MEM_COPY_ATTRIBUTES (dest, target);\n-\n-\t\t  /* The residual likely does not have the same alignment\n-\t\t     as the original target.  While we could compute the\n-\t\t     alignment of the residual, it hardely seems worth\n-\t\t     the effort.  */\n-\t\t  set_mem_align (dest, BITS_PER_UNIT);\n-\n \t\t  /* Be sure we can write on ADDR.  */\n \t\t  in_check_memory_usage = 1;\n \t\t  if (current_function_check_memory_usage)\n \t\t    emit_library_call (chkr_check_addr_libfunc,\n \t\t\t\t       LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t\t       addr, Pmode,\n+\t\t\t\t       XEXP (target, 0), Pmode,\n \t\t\t\t       size, TYPE_MODE (sizetype),\n  \t\t\t\t       GEN_INT (MEMORY_USE_WO),\n \t\t\t\t       TYPE_MODE (integer_type_node));\n \t\t  in_check_memory_usage = 0;\n-\t\t  clear_storage (dest, size);\n+\t\t  clear_storage (target, size);\n \t\t}\n \n \t      if (label)\n@@ -6277,10 +6265,12 @@ expand_expr (exp, target, tmode, modifier)\n   /* If will do cse, generate all results into pseudo registers\n      since 1) that allows cse to find more things\n      and 2) otherwise cse could produce an insn the machine\n-     cannot support.  */\n+     cannot support.  And exception is a CONSTRUCTOR into a multi-word\n+     MEM: that's much more likely to be most efficient into the MEM.  */\n \n   if (! cse_not_expected && mode != BLKmode && target\n-      && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER))\n+      && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+      && ! (code == CONSTRUCTOR && GET_MODE_SIZE (mode) > UNITS_PER_WORD))\n     target = subtarget;\n \n   switch (code)\n@@ -6788,7 +6778,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t\t   (TYPE_QUALS (type)\n \t\t\t\t\t\t    | (TREE_READONLY (exp)\n \t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n-\t\t\t     TREE_ADDRESSABLE (exp), 1, 1);\n+\t\t\t     0, TREE_ADDRESSABLE (exp), 1);\n \n \t  store_constructor (exp, target, 0,\n \t\t\t     int_size_in_bytes (TREE_TYPE (exp)));"}]}