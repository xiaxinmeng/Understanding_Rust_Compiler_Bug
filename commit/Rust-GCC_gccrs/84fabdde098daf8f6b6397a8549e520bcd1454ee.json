{"sha": "84fabdde098daf8f6b6397a8549e520bcd1454ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmYWJkZGUwOThkYWY4ZjZiNjM5N2E4NTQ5ZTUyMGJjZDE0NTRlZQ==", "commit": {"author": {"name": "Jie Zhang", "email": "jie@codesourcery.com", "date": "2010-10-27T14:30:17Z"}, "committer": {"name": "Jie Zhang", "email": "jiez@gcc.gnu.org", "date": "2010-10-27T14:30:17Z"}, "message": "haifa-sched.c (ISSUE_POINTS): Remove.\n\n\t* haifa-sched.c (ISSUE_POINTS): Remove.\n\t(max_issue): Don't issue more than issue_rate instructions.\n\nCo-Authored-By: Maxim Kuvyrkov <maxim@codesourcery.com>\n\nFrom-SVN: r166002", "tree": {"sha": "35fc8222a9ddd69cc0134d2842492125d078e233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35fc8222a9ddd69cc0134d2842492125d078e233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84fabdde098daf8f6b6397a8549e520bcd1454ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fabdde098daf8f6b6397a8549e520bcd1454ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fabdde098daf8f6b6397a8549e520bcd1454ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fabdde098daf8f6b6397a8549e520bcd1454ee/comments", "author": null, "committer": null, "parents": [{"sha": "9c042d80ae7013d06741a80f7f178b5b1315827d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c042d80ae7013d06741a80f7f178b5b1315827d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c042d80ae7013d06741a80f7f178b5b1315827d"}], "stats": {"total": 38, "additions": 17, "deletions": 21}, "files": [{"sha": "c5ced16ec03d84392bd9a0df023cc3f93d819144", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fabdde098daf8f6b6397a8549e520bcd1454ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fabdde098daf8f6b6397a8549e520bcd1454ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84fabdde098daf8f6b6397a8549e520bcd1454ee", "patch": "@@ -1,3 +1,9 @@\n+2010-10-27  Jie Zhang  <jie@codesourcery.com>\n+\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* haifa-sched.c (ISSUE_POINTS): Remove.\n+\t(max_issue): Don't issue more than issue_rate instructions.\n+\n 2010-10-27  Ian Lance Taylor  <iant@google.com>\n \n \tPR target/46197"}, {"sha": "8fb988e2a628eda32be040436e53eb6f2674a4c2", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fabdde098daf8f6b6397a8549e520bcd1454ee/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fabdde098daf8f6b6397a8549e520bcd1454ee/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=84fabdde098daf8f6b6397a8549e520bcd1454ee", "patch": "@@ -199,10 +199,6 @@ struct common_sched_info_def *common_sched_info;\n /* The minimal value of the INSN_TICK of an instruction.  */\n #define MIN_TICK (-max_insn_queue_index)\n \n-/* Issue points are used to distinguish between instructions in max_issue ().\n-   For now, all instructions are equally good.  */\n-#define ISSUE_POINTS(INSN) 1\n-\n /* List of important notes we must keep around.  This is a pointer to the\n    last element in the list.  */\n rtx note_list;\n@@ -2444,8 +2440,7 @@ static int cached_issue_rate = 0;\n    insns is insns with the best rank (the first insn in READY).  To\n    make this function tries different samples of ready insns.  READY\n    is current queue `ready'.  Global array READY_TRY reflects what\n-   insns are already issued in this try.  MAX_POINTS is the sum of points\n-   of all instructions in READY.  The function stops immediately,\n+   insns are already issued in this try.  The function stops immediately,\n    if it reached the such a solution, that all instruction can be issued.\n    INDEX will contain index of the best insn in READY.  The following\n    function is used only for first cycle multipass scheduling.\n@@ -2458,7 +2453,7 @@ int\n max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \t   int *index)\n {\n-  int n, i, all, n_ready, best, delay, tries_num, max_points;\n+  int n, i, all, n_ready, best, delay, tries_num;\n   int more_issue;\n   struct choice_entry *top;\n   rtx insn;\n@@ -2477,19 +2472,9 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n     }\n \n   /* Init max_points.  */\n-  max_points = 0;\n   more_issue = issue_rate - cycle_issued_insns;\n   gcc_assert (more_issue >= 0);\n \n-  for (i = 0; i < n_ready; i++)\n-    if (!ready_try [i])\n-      {\n-\tif (more_issue-- > 0)\n-\t  max_points += ISSUE_POINTS (ready_element (ready, i));\n-\telse\n-\t  break;\n-      }\n-\n   /* The number of the issued insns in the best solution.  */\n   best = 0;\n \n@@ -2513,12 +2498,17 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n       if (/* If we've reached a dead end or searched enough of what we have\n \t     been asked...  */\n \t  top->rest == 0\n-\t  /* Or have nothing else to try.  */\n-\t  || i >= n_ready)\n+\t  /* or have nothing else to try...  */\n+\t  || i >= n_ready\n+\t  /* or should not issue more.  */\n+\t  || top->n >= more_issue)\n \t{\n \t  /* ??? (... || i == n_ready).  */\n \t  gcc_assert (i <= n_ready);\n \n+\t  /* We should not issue more than issue_rate instructions.  */\n+\t  gcc_assert (top->n <= more_issue);\n+\n \t  if (top == choice_stack)\n \t    break;\n \n@@ -2541,7 +2531,7 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \t\t  /* This is the index of the insn issued first in this\n \t\t     solution.  */\n \t\t  *index = choice_stack [1].index;\n-\t\t  if (top->n == max_points || best == all)\n+\t\t  if (top->n == more_issue || best == all)\n \t\t    break;\n \t\t}\n \t    }\n@@ -2574,7 +2564,7 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \n \t      n = top->n;\n \t      if (memcmp (top->state, state, dfa_state_size) != 0)\n-\t\tn += ISSUE_POINTS (insn);\n+\t\tn++;\n \n \t      /* Advance to the next choice_entry.  */\n \t      top++;"}]}