{"sha": "d1c566d72d9361b37213881222c7e2713cdf05b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFjNTY2ZDcyZDkzNjFiMzcyMTM4ODEyMjJjN2UyNzEzY2RmMDViNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-08T19:11:37Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-08T19:16:21Z"}, "message": "libcpp: Directly peek for initial line marker\n\nUsing the tokenizer to sniff for an initial line marker for\npreprocessed input is a little brittle, particularly with\n-fdirectives-only.  If there is no marker we'll happily munch initial\ncomments.  This patch directly sniffs the buffer.  This is safe\nbecause the initial line marker was machine generated and must be\nright at the beginning of the file.  Anything else is not such a line\nmarker.  The same is true for the initial directory marker.  For that\ntokenizing the string is simplest, but at that point it's either a\nregular line marker or a directory marker.  If it's a regular marker,\nunwinding tokens is fine.\n\n\tlibcpp/\n\t* internal.h (enum include_type): Rename IT_MAIN_INJECT to\n\tIT_PRE_MAIN.\n\t* init.c (cpp_read_main_file): If there is no line marker, adjust\n\tthe initial line marker.\n\t(read_original_filename): Return bool, peek the buffer directly\n\tbefore trying to tokenize.\n\t(read_original_directory): Likewise.  Directly prod the string\n\tliteral.\n\t* files.c (_cpp_stack_file): Adjust for IT_PRE_MAIN change.", "tree": {"sha": "aa7640d9fb655ceb26caddbd903344fb6662a1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa7640d9fb655ceb26caddbd903344fb6662a1e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1c566d72d9361b37213881222c7e2713cdf05b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c566d72d9361b37213881222c7e2713cdf05b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1c566d72d9361b37213881222c7e2713cdf05b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c566d72d9361b37213881222c7e2713cdf05b7/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd23ed8af236db2d28314e0652d04e5a0e1540b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd23ed8af236db2d28314e0652d04e5a0e1540b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd23ed8af236db2d28314e0652d04e5a0e1540b6"}], "stats": {"total": 156, "additions": 89, "deletions": 67}, "files": [{"sha": "5af41364d0a41de4b8ac634ed4c78991409cd051", "filename": "libcpp/files.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c566d72d9361b37213881222c7e2713cdf05b7/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c566d72d9361b37213881222c7e2713cdf05b7/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=d1c566d72d9361b37213881222c7e2713cdf05b7", "patch": "@@ -948,10 +948,12 @@ _cpp_stack_file (cpp_reader *pfile, _cpp_file *file, include_type type,\n \n   /* Add line map and do callbacks.  */\n   _cpp_do_file_change (pfile, LC_ENTER, file->path,\n-\t\t       /* With preamble injection, start on line zero, so\n-\t\t\t  the preamble doesn't appear to have been\n-\t\t\t  included from line 1.  */\n-\t\t       type == IT_MAIN_INJECT ? 0 : 1, sysp);\n+\t\t       /* With preamble injection, start on line zero,\n+\t\t\t  so the preamble doesn't appear to have been\n+\t\t\t  included from line 1.  Likewise when\n+\t\t\t  starting preprocessed, we expect an initial\n+\t\t\t  locating line.  */\n+\t\t       type == IT_PRE_MAIN ? 0 : 1, sysp);\n \n   return true;\n }"}, {"sha": "84c0a9efa74b7d62b3a0a776bab3a3b473b54ed2", "filename": "libcpp/init.c", "status": "modified", "additions": 81, "deletions": 61, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c566d72d9361b37213881222c7e2713cdf05b7/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c566d72d9361b37213881222c7e2713cdf05b7/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=d1c566d72d9361b37213881222c7e2713cdf05b7", "patch": "@@ -36,7 +36,7 @@ along with this program; see the file COPYING3.  If not see\n \n static void init_library (void);\n static void mark_named_operators (cpp_reader *, int);\n-static void read_original_filename (cpp_reader *);\n+static bool read_original_filename (cpp_reader *);\n static void read_original_directory (cpp_reader *);\n static void post_options (cpp_reader *);\n \n@@ -681,94 +681,114 @@ cpp_read_main_file (cpp_reader *pfile, const char *fname, bool injecting)\n     return NULL;\n \n   _cpp_stack_file (pfile, pfile->main_file,\n-\t\t   injecting ? IT_MAIN_INJECT : IT_MAIN, 0);\n+\t\t   injecting || CPP_OPTION (pfile, preprocessed)\n+\t\t   ? IT_PRE_MAIN : IT_MAIN, 0);\n \n   /* For foo.i, read the original filename foo.c now, for the benefit\n      of the front ends.  */\n   if (CPP_OPTION (pfile, preprocessed))\n-    read_original_filename (pfile);\n+    if (!read_original_filename (pfile))\n+      {\n+\t/* We're on line 1 after all.  */\n+\tauto *last = linemap_check_ordinary\n+\t  (LINEMAPS_LAST_MAP (pfile->line_table, false));\n+\tlast->to_line = 1;\n+\t/* Inform of as-if a file change.  */\n+\t_cpp_do_file_change (pfile, LC_RENAME_VERBATIM, LINEMAP_FILE (last),\n+\t\t\t     LINEMAP_LINE (last), LINEMAP_SYSP (last));\n+      }\n \n   return ORDINARY_MAP_FILE_NAME (LINEMAPS_LAST_ORDINARY_MAP (pfile->line_table));\n }\n \n-/* For preprocessed files, if the first tokens are of the form # NUM.\n-   handle the directive so we know the original file name.  This will\n-   generate file_change callbacks, which the front ends must handle\n-   appropriately given their state of initialization.  */\n-static void\n+/* For preprocessed files, if the very first characters are\n+   '#<SPACE>[01]<SPACE>', then handle a line directive so we know the\n+   original file name.  This will generate file_change callbacks,\n+   which the front ends must handle appropriately given their state of\n+   initialization.  We peek directly into the character buffer, so\n+   that we're not confused by otherwise-skipped white space &\n+   comments.  We can be very picky, because this should have been\n+   machine-generated text (by us, no less).  This way we do not\n+   interfere with the module directive state machine.  */\n+\n+static bool\n read_original_filename (cpp_reader *pfile)\n {\n-  const cpp_token *token, *token1;\n-\n-  /* Lex ahead; if the first tokens are of the form # NUM, then\n-     process the directive, otherwise back up.  */\n-  token = _cpp_lex_direct (pfile);\n-  if (token->type == CPP_HASH)\n+  auto *buf = pfile->buffer->next_line;\n+\n+  if (pfile->buffer->rlimit - buf > 4\n+      && buf[0] == '#'\n+      && buf[1] == ' '\n+      // Also permit '1', as that's what used to be here\n+      && (buf[2] == '0' || buf[2] == '1')\n+      && buf[3] == ' ')\n     {\n-      pfile->state.in_directive = 1;\n-      token1 = _cpp_lex_direct (pfile);\n-      _cpp_backup_tokens (pfile, 1);\n-      pfile->state.in_directive = 0;\n-\n-      /* If it's a #line directive, handle it.  */\n-      if (token1->type == CPP_NUMBER\n-\t  && _cpp_handle_directive (pfile, token->flags & PREV_WHITE))\n+      const cpp_token *token = _cpp_lex_direct (pfile);\n+      gcc_checking_assert (token->type == CPP_HASH);\n+      if (_cpp_handle_directive (pfile, token->flags & PREV_WHITE))\n \t{\n \t  read_original_directory (pfile);\n-\t  return;\n+\t  return true;\n \t}\n     }\n \n-  /* Backup as if nothing happened.  */\n-  _cpp_backup_tokens (pfile, 1);\n+  return false;\n }\n \n /* For preprocessed files, if the tokens following the first filename\n    line is of the form # <line> \"/path/name//\", handle the\n-   directive so we know the original current directory.  */\n+   directive so we know the original current directory.\n+\n+   As with the first line peeking, we can do this without lexing by\n+   being picky.  */\n static void\n read_original_directory (cpp_reader *pfile)\n {\n-  const cpp_token *hash, *token;\n-\n-  /* Lex ahead; if the first tokens are of the form # NUM, then\n-     process the directive, otherwise back up.  */\n-  hash = _cpp_lex_direct (pfile);\n-  if (hash->type != CPP_HASH)\n+  auto *buf = pfile->buffer->next_line;\n+\n+  if (pfile->buffer->rlimit - buf > 4\n+      && buf[0] == '#'\n+      && buf[1] == ' '\n+      // Also permit '1', as that's what used to be here\n+      && (buf[2] == '0' || buf[2] == '1')\n+      && buf[3] == ' ')\n     {\n-      _cpp_backup_tokens (pfile, 1);\n-      return;\n-    }\n-\n-  token = _cpp_lex_direct (pfile);\n+      const cpp_token *hash = _cpp_lex_direct (pfile);\n+      gcc_checking_assert (hash->type == CPP_HASH);\n+      pfile->state.in_directive = 1;\n+      const cpp_token *number = _cpp_lex_direct (pfile);\n+      gcc_checking_assert (number->type == CPP_NUMBER);\n+      const cpp_token *string = _cpp_lex_direct (pfile);\n+      pfile->state.in_directive = 0;\n \n-  if (token->type != CPP_NUMBER)\n-    {\n-      _cpp_backup_tokens (pfile, 2);\n-      return;\n-    }\n+      const unsigned char *text = nullptr;\n+      size_t len = 0;\n+      if (string->type == CPP_STRING)\n+\t{\n+\t  /* The string value includes the quotes.  */\n+\t  text = string->val.str.text;\n+\t  len = string->val.str.len;\n+\t}\n+      if (len < 5\n+\t  || !IS_DIR_SEPARATOR (text[len - 2])\n+\t  || !IS_DIR_SEPARATOR (text[len - 3]))\n+\t{\n+\t  /* That didn't work out, back out.   */\n+\t  _cpp_backup_tokens (pfile, 3);\n+\t  return;\n+\t}\n \n-  token = _cpp_lex_direct (pfile);\n+      if (pfile->cb.dir_change)\n+\t{\n+\t  /* Smash the string directly, it's dead at this point  */\n+\t  char *smashy = (char *)text;\n+\t  smashy[len - 3] = 0;\n+\t  \n+\t  pfile->cb.dir_change (pfile, smashy + 1);\n+\t}\n \n-  if (token->type != CPP_STRING\n-      || ! (token->val.str.len >= 5\n-\t    && IS_DIR_SEPARATOR (token->val.str.text[token->val.str.len-2])\n-\t    && IS_DIR_SEPARATOR (token->val.str.text[token->val.str.len-3])))\n-    {\n-      _cpp_backup_tokens (pfile, 3);\n-      return;\n+      /* We should be at EOL.  */\n     }\n-\n-  if (pfile->cb.dir_change)\n-    {\n-      char *debugdir = (char *) alloca (token->val.str.len - 3);\n-\n-      memcpy (debugdir, (const char *) token->val.str.text + 1,\n-\t      token->val.str.len - 4);\n-      debugdir[token->val.str.len - 4] = '\\0';\n-\n-      pfile->cb.dir_change (pfile, debugdir);\n-    }      \n }\n \n /* This is called at the end of preprocessing.  It pops the last"}, {"sha": "b728df7456265f98ee6e11a3142178de6efa2a73", "filename": "libcpp/internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c566d72d9361b37213881222c7e2713cdf05b7/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c566d72d9361b37213881222c7e2713cdf05b7/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=d1c566d72d9361b37213881222c7e2713cdf05b7", "patch": "@@ -124,8 +124,8 @@ enum include_type\n    IT_CMDLINE,  /* -include */\n    IT_DEFAULT,  /* forced header  */\n    IT_MAIN,     /* main, start on line 1 */\n-   IT_MAIN_INJECT,  /* main, but there will be an injected preamble\n-\t\t       before line 1 */\n+   IT_PRE_MAIN,  /* main, but there will be a preamble before line\n+\t\t    1 */\n \n    IT_DIRECTIVE_HWM = IT_IMPORT + 1,  /* Directives below this.  */\n    IT_HEADER_HWM = IT_DEFAULT + 1     /* Header files below this.  */"}]}