{"sha": "4c58124363e36ea1e835819b31e91c13109665b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM1ODEyNDM2M2UzNmVhMWU4MzU4MTliMzFlOTFjMTMxMDk2NjViOA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-29T20:03:15Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-29T20:03:15Z"}, "message": "except.c (expand_eh_region_start_tree): Add DECL argument so we can better track why the region was made for error...\n\n\t* except.c (expand_eh_region_start_tree): Add DECL argument so we\n \tcan better track why the region was made for error reporting.\n\t* except.h (expand_eh_region_start_tree): Likewise.\n\t* tree.h (expand_dhc_cleanup): Likewise.\n\t(expand_dcc_cleanup): Likewise.\n\t* except.c (expand_eh_region_start_for_decl): New routine.\n\t* except.h (expand_eh_region_start_for_decl): Likewise.\n\t* stmt.c (expand_decl_cleanup): Add DECL to call of\n\texpand_eh_region_start_tree.\n\t(expand_dcc_cleanup): Likewise.\n\t(expand_dhc_cleanup): Likewise.\n\n\t(expand_start_case): Switches introduce conditional contexts.\n\t(expand_start_case_dummy): Likewise.\n\t(expand_start_case_dummy): Likewise.\n\t(expand_end_case): Likewise.\n\nFrom-SVN: r13990", "tree": {"sha": "6e5501b204bbdd872d5ff15586006547e3e92809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e5501b204bbdd872d5ff15586006547e3e92809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c58124363e36ea1e835819b31e91c13109665b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c58124363e36ea1e835819b31e91c13109665b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c58124363e36ea1e835819b31e91c13109665b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c58124363e36ea1e835819b31e91c13109665b8/comments", "author": null, "committer": null, "parents": [{"sha": "9c6cd30ed515ec543a3258e9c96006364a6e42cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c6cd30ed515ec543a3258e9c96006364a6e42cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c6cd30ed515ec543a3258e9c96006364a6e42cb"}], "stats": {"total": 112, "additions": 58, "deletions": 54}, "files": [{"sha": "71925a575b18f311a0e5e560a4a362fa4dad8a4b", "filename": "gcc/except.c", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4c58124363e36ea1e835819b31e91c13109665b8", "patch": "@@ -911,7 +911,8 @@ start_dynamic_handler ()\n    of a using an exception region.  */\n \n int\n-expand_eh_region_start_tree (cleanup)\n+expand_eh_region_start_tree (decl, cleanup)\n+     tree decl;\n      tree cleanup;\n {\n   rtx note;\n@@ -952,52 +953,25 @@ expand_eh_region_start_tree (cleanup)\n \t{\n \t  /* Arrange for returns and gotos to pop the entry we make on the\n \t     dynamic cleanup stack.  */\n-\t  expand_dcc_cleanup ();\n+\t  expand_dcc_cleanup (decl);\n \t  start_dynamic_cleanup (func, arg);\n \t  return 1;\n \t}\n     }\n \n-  if (exceptions_via_longjmp)\n-    {\n-      /* We need a new block to record the start and end of the\n-\t dynamic handler chain.  We could always do this, but we\n-\t really want to permit jumping into such a block, and we want\n-\t to avoid any errors or performance impact in the SJ EH code\n-\t for now.  */\n-      expand_start_bindings (0);\n-\n-      /* But we don't need or want a new temporary level.  */\n-      pop_temp_slots ();\n-\n-      /* Mark this block as created by expand_eh_region_start.  This\n-\t is so that we can pop the block with expand_end_bindings\n-\t automatically.  */\n-      mark_block_as_eh_region ();\n-\n-      /* Arrange for returns and gotos to pop the entry we make on the\n-\t dynamic handler stack.  */\n-      expand_dhc_cleanup ();\n-    }\n-\n-  if (exceptions_via_longjmp == 0)\n-    note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_BEG);\n-  emit_label (push_eh_entry (&ehstack));\n-  if (exceptions_via_longjmp == 0)\n-    NOTE_BLOCK_NUMBER (note)\n-      = CODE_LABEL_NUMBER (ehstack.top->entry->exception_handler_label);\n-  if (exceptions_via_longjmp)\n-    start_dynamic_handler ();\n+  expand_eh_region_start_for_decl (decl);\n \n   return 0;\n }\n \n-/* Start an exception handling region.  All instructions emitted after\n-   this point are considered to be part of the region until\n-   expand_eh_region_end is invoked.  */\n+/* Just like expand_eh_region_start, except if a cleanup action is\n+   entered on the cleanup chain, the TREE_PURPOSE of the element put\n+   on the chain is DECL.  DECL should be the associated VAR_DECL, if\n+   any, otherwise it should be NULL_TREE.  */\n \n void\n-expand_eh_region_start ()\n+expand_eh_region_start_for_decl (decl)\n+     tree decl;\n {\n   rtx note;\n \n@@ -1024,7 +998,7 @@ expand_eh_region_start ()\n \n       /* Arrange for returns and gotos to pop the entry we make on the\n \t dynamic handler stack.  */\n-      expand_dhc_cleanup ();\n+      expand_dhc_cleanup (decl);\n     }\n \n   if (exceptions_via_longjmp == 0)\n@@ -1037,6 +1011,16 @@ expand_eh_region_start ()\n     start_dynamic_handler ();\n }\n \n+/* Start an exception handling region.  All instructions emitted after\n+   this point are considered to be part of the region until\n+   expand_eh_region_end is invoked.  */\n+\n+void\n+expand_eh_region_start ()\n+{\n+  expand_eh_region_start_for_decl (NULL_TREE);\n+}\n+\n /* End an exception handling region.  The information about the region\n    is found on the top of ehstack.\n "}, {"sha": "8d4c5a635390c1246d00a11c04876594fd9e360d", "filename": "gcc/except.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=4c58124363e36ea1e835819b31e91c13109665b8", "patch": "@@ -88,6 +88,13 @@ struct eh_queue {\n \n extern void expand_eh_region_start\t\tPROTO((void));\n \n+/* Just like expand_eh_region_start, except if a cleanup action is\n+   entered on the cleanup chain, the TREE_PURPOSE of the element put\n+   on the chain is DECL.  DECL should be the associated VAR_DECL, if\n+   any, otherwise it should be NULL_TREE.  */\n+\n+extern void expand_eh_region_start_for_decl\tPROTO((tree));\n+\n /* Start an exception handling region for the given cleanup action.\n    All instructions emitted after this point are considered to be part\n    of the region until expand_eh_region_end () is invoked.  CLEANUP is\n@@ -100,7 +107,7 @@ extern void expand_eh_region_start\t\tPROTO((void));\n    generation, and optimizes it so as to not need the exception\n    region.  */\n \n-extern int expand_eh_region_start_tree\t\tPROTO((tree));\n+extern int expand_eh_region_start_tree\t\tPROTO((tree, tree));\n \n /* End an exception handling region.  The information about the region\n    is found on the top of ehstack."}, {"sha": "6d782341106650a34bf8baa3fe48611cf6ef5901", "filename": "gcc/stmt.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4c58124363e36ea1e835819b31e91c13109665b8", "patch": "@@ -3950,7 +3950,7 @@ expand_decl_cleanup (decl, cleanup)\n       /* If this was optimized so that there is no exception region for the\n \t cleanup, then mark the TREE_LIST node, so that we can later tell\n \t if we need to call expand_eh_region_end.  */\n-      if (expand_eh_region_start_tree (cleanup))\n+      if (expand_eh_region_start_tree (decl, cleanup))\n \tTREE_ADDRESSABLE (t) = 1;\n \n       if (cond_context)\n@@ -3972,19 +3972,21 @@ expand_decl_cleanup (decl, cleanup)\n }\n \n /* Arrange for the top element of the dynamic cleanup chain to be\n-   popped if we exit the current binding contour.  If the current\n-   contour is left via an exception, then __sjthrow will pop the top\n-   element off the dynamic cleanup chain.  The code that avoids doing\n-   the action we push into the cleanup chain in the exceptional case\n-   is contained in expand_cleanups.\n+   popped if we exit the current binding contour.  DECL is the\n+   associated declaration, if any, otherwise NULL_TREE.  If the\n+   current contour is left via an exception, then __sjthrow will pop\n+   the top element off the dynamic cleanup chain.  The code that\n+   avoids doing the action we push into the cleanup chain in the\n+   exceptional case is contained in expand_cleanups.\n \n    This routine is only used by expand_eh_region_start, and that is\n    the only way in which an exception region should be started.  This\n    routine is only used when using the setjmp/longjmp codegen method\n    for exception handling.  */\n \n int\n-expand_dcc_cleanup ()\n+expand_dcc_cleanup (decl)\n+     tree decl;\n {\n   struct nesting *thisblock = block_stack;\n   tree cleanup;\n@@ -4003,27 +4005,29 @@ expand_dcc_cleanup ()\n \n   /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n   thisblock->data.block.cleanups\n-    = temp_tree_cons (NULL_TREE, cleanup, thisblock->data.block.cleanups);\n+    = temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n \n   /* If this block has a cleanup, it belongs in stack_block_stack.  */\n   stack_block_stack = thisblock;\n   return 1;\n }\n \n /* Arrange for the top element of the dynamic handler chain to be\n-   popped if we exit the current binding contour.  If the current\n-   contour is left via an exception, then __sjthrow will pop the\n-   top element off the dynamic handler chain.  The code that avoids\n-   doing the action we push into the handler chain in the exceptional\n-   case is contained in expand_cleanups.\n+   popped if we exit the current binding contour.  DECL is the\n+   assciated declaration, if any, otherwise NULL_TREE.  If the current\n+   contour is left via an exception, then __sjthrow will pop the top\n+   element off the dynamic handler chain.  The code that avoids doing\n+   the action we push into the handler chain in the exceptional case\n+   is contained in expand_cleanups.\n \n    This routine is only used by expand_eh_region_start, and that is\n    the only way in which an exception region should be started.  This\n    routine is only used when using the setjmp/longjmp codegen method\n    for exception handling.  */\n \n int\n-expand_dhc_cleanup ()\n+expand_dhc_cleanup (decl)\n+     tree decl;\n {\n   struct nesting *thisblock = block_stack;\n   tree cleanup;\n@@ -4042,7 +4046,7 @@ expand_dhc_cleanup ()\n \n   /* Add the cleanup in a manner similar to expand_decl_cleanup.  */\n   thisblock->data.block.cleanups\n-    = temp_tree_cons (NULL_TREE, cleanup, thisblock->data.block.cleanups);\n+    = temp_tree_cons (decl, cleanup, thisblock->data.block.cleanups);\n \n   /* If this block has a cleanup, it belongs in stack_block_stack.  */\n   stack_block_stack = thisblock;\n@@ -4303,6 +4307,8 @@ expand_start_case (exit_flag, expr, type, printname)\n     emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n   thiscase->data.case_stmt.start = get_last_insn ();\n+\n+  start_cleanup_deferal ();\n }\n \n \n@@ -4355,13 +4361,15 @@ expand_start_case_dummy ()\n   thiscase->data.case_stmt.num_ranges = 0;\n   case_stack = thiscase;\n   nesting_stack = thiscase;\n+  start_cleanup_deferal ();\n }\n \n /* End a dummy case statement.  */\n \n void\n expand_end_case_dummy ()\n {\n+  end_cleanup_deferal ();\n   POPSTACK (case_stack);\n }\n \n@@ -5355,6 +5363,8 @@ expand_end_case (orig_index)\n       if (count != 0)\n \trange = fold (build (MINUS_EXPR, index_type, maxval, minval));\n \n+      end_cleanup_deferal ();\n+\n       if (count == 0)\n \t{\n \t  expand_expr (index_expr, const0_rtx, VOIDmode, 0);\n@@ -5622,6 +5632,8 @@ expand_end_case (orig_index)\n       reorder_insns (before_case, get_last_insn (),\n \t\t     thiscase->data.case_stmt.start);\n     }\n+  else\n+    end_cleanup_deferal ();\n \n   if (thiscase->exit_label)\n     emit_label (thiscase->exit_label);"}, {"sha": "ff73de46ae26cfe8b25d3c4fcde67ec87d1ca8c0", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c58124363e36ea1e835819b31e91c13109665b8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4c58124363e36ea1e835819b31e91c13109665b8", "patch": "@@ -1697,7 +1697,8 @@ extern void mark_block_as_not_eh_region\t\tPROTO((void));\n extern int is_eh_region\t\t\t\tPROTO((void));\n extern int conditional_context\t\t\tPROTO((void));\n extern tree last_cleanup_this_contour\t\tPROTO((void));\n-extern int expand_dhc_cleanup\t\t\tPROTO((void));\n+extern int expand_dhc_cleanup\t\t\tPROTO((tree));\n+extern int expand_dcc_cleanup\t\t\tPROTO((tree));\n extern void expand_start_case\t\t\tPROTO((int, tree, tree,\n \t\t\t\t\t\t       char *));\n extern void expand_end_case\t\t\tPROTO((tree));"}]}