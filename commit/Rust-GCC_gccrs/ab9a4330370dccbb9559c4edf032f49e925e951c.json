{"sha": "ab9a4330370dccbb9559c4edf032f49e925e951c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI5YTQzMzAzNzBkY2NiYjk1NTljNGVkZjAzMmY0OWU5MjVlOTUxYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-11-14T17:28:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-11-14T17:28:11Z"}, "message": "sanopt.c: Include tree-ssa-operands.h.\n\n\t* sanopt.c: Include tree-ssa-operands.h.\n\t(struct sanopt_info): Add has_freeing_call_p,\n\thas_freeing_call_computed_p, imm_dom_path_with_freeing_call_p,\n\timm_dom_path_with_freeing_call_computed_p, freeing_call_events,\n\tbeing_visited_p fields.\n\t(struct sanopt_ctx): Add asan_check_map field.\n\t(imm_dom_path_with_freeing_call, maybe_optimize_ubsan_null_ifn,\n\tmaybe_optimize_asan_check_ifn): New functions.\n\t(sanopt_optimize_walker): Use them, optimize even ASAN_CHECK\n\tinternal calls.\n\t(pass_sanopt::execute): Call sanopt_optimize even for\n\t-fsanitize=address.\n\t* gimple.c (nonfreeing_call_p): Return true for non-ECF_LEAF\n\tinternal calls.\n\nCo-Authored-By: Marek Polacek <polacek@redhat.com>\n\nFrom-SVN: r217581", "tree": {"sha": "1b257a63c484c45a3351c726bc7041b331cff4ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b257a63c484c45a3351c726bc7041b331cff4ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab9a4330370dccbb9559c4edf032f49e925e951c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab9a4330370dccbb9559c4edf032f49e925e951c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab9a4330370dccbb9559c4edf032f49e925e951c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab9a4330370dccbb9559c4edf032f49e925e951c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18d11814af15e35f3cb103919585bceb5c470dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d11814af15e35f3cb103919585bceb5c470dc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18d11814af15e35f3cb103919585bceb5c470dc7"}], "stats": {"total": 484, "additions": 393, "deletions": 91}, "files": [{"sha": "e5ff6e9a615ecef186aa134c7c002b9bc4d37de1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab9a4330370dccbb9559c4edf032f49e925e951c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab9a4330370dccbb9559c4edf032f49e925e951c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab9a4330370dccbb9559c4edf032f49e925e951c", "patch": "@@ -1,3 +1,21 @@\n+2014-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\t    Marek Polacek  <polacek@redhat.com>\n+\n+\t* sanopt.c: Include tree-ssa-operands.h.\n+\t(struct sanopt_info): Add has_freeing_call_p,\n+\thas_freeing_call_computed_p, imm_dom_path_with_freeing_call_p,\n+\timm_dom_path_with_freeing_call_computed_p, freeing_call_events,\n+\tbeing_visited_p fields.\n+\t(struct sanopt_ctx): Add asan_check_map field.\n+\t(imm_dom_path_with_freeing_call, maybe_optimize_ubsan_null_ifn,\n+\tmaybe_optimize_asan_check_ifn): New functions.\n+\t(sanopt_optimize_walker): Use them, optimize even ASAN_CHECK\n+\tinternal calls.\n+\t(pass_sanopt::execute): Call sanopt_optimize even for\n+\t-fsanitize=address.\n+\t* gimple.c (nonfreeing_call_p): Return true for non-ECF_LEAF\n+\tinternal calls.\n+\n 2014-11-14  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* tree-vect-loop.c (vect_create_epilog_for_reduction): Move code for"}, {"sha": "ac753650e182cb985f73f9bb0c8523a6319c53b4", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab9a4330370dccbb9559c4edf032f49e925e951c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab9a4330370dccbb9559c4edf032f49e925e951c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ab9a4330370dccbb9559c4edf032f49e925e951c", "patch": "@@ -2538,6 +2538,9 @@ nonfreeing_call_p (gimple call)\n \tdefault:\n \t  return true;\n       }\n+  else if (gimple_call_internal_p (call)\n+\t   && gimple_call_flags (call) & ECF_LEAF)\n+    return true;\n \n   return false;\n }"}, {"sha": "f6e8ee71d70e156875e5b22a13ddf0d81f9455f5", "filename": "gcc/sanopt.c", "status": "modified", "additions": 372, "deletions": 91, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab9a4330370dccbb9559c4edf032f49e925e951c/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab9a4330370dccbb9559c4edf032f49e925e951c/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=ab9a4330370dccbb9559c4edf032f49e925e951c", "patch": "@@ -49,14 +49,38 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"ubsan.h\"\n #include \"params.h\"\n+#include \"tree-ssa-operands.h\"\n \n \n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n \n struct sanopt_info\n {\n-  /* True if this BB has been visited.  */\n+  /* True if this BB might call (directly or indirectly) free/munmap\n+     or similar operation.  */\n+  bool has_freeing_call_p;\n+\n+  /* True if HAS_FREEING_CALL_P flag has been computed.  */\n+  bool has_freeing_call_computed_p;\n+\n+  /* True if there is a block with HAS_FREEING_CALL_P flag set\n+     on any path between an immediate dominator of BB, denoted\n+     imm(BB), and BB.  */\n+  bool imm_dom_path_with_freeing_call_p;\n+\n+  /* True if IMM_DOM_PATH_WITH_FREEING_CALL_P has been computed.  */\n+  bool imm_dom_path_with_freeing_call_computed_p;\n+\n+  /* Number of possibly freeing calls encountered in this bb\n+     (so far).  */\n+  uint64_t freeing_call_events;\n+\n+  /* True if BB is currently being visited during computation\n+     of IMM_DOM_PATH_WITH_FREEING_CALL_P flag.  */\n+  bool being_visited_p;\n+\n+  /* True if this BB has been visited in the dominator walk.  */\n   bool visited_p;\n };\n \n@@ -69,131 +93,387 @@ struct sanopt_ctx\n      a vector of UBSAN_NULL call statements that check this pointer.  */\n   hash_map<tree, auto_vec<gimple> > null_check_map;\n \n+  /* This map maps a pointer (the second argument of ASAN_CHECK) to\n+     a vector of ASAN_CHECK call statements that check the access.  */\n+  hash_map<tree, auto_vec<gimple> > asan_check_map;\n+\n   /* Number of IFN_ASAN_CHECK statements.  */\n   int asan_num_accesses;\n };\n \n \n-/* Try to optimize away redundant UBSAN_NULL checks.\n-   \n+/* Return true if there might be any call to free/munmap operation\n+   on any path in between DOM (which should be imm(BB)) and BB.  */\n+\n+static bool\n+imm_dom_path_with_freeing_call (basic_block bb, basic_block dom)\n+{\n+  sanopt_info *info = (sanopt_info *) bb->aux;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (info->imm_dom_path_with_freeing_call_computed_p)\n+    return info->imm_dom_path_with_freeing_call_p;\n+\n+  info->being_visited_p = true;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      sanopt_info *pred_info = (sanopt_info *) e->src->aux;\n+\n+      if (e->src == dom)\n+\tcontinue;\n+\n+      if ((pred_info->imm_dom_path_with_freeing_call_computed_p\n+\t  && pred_info->imm_dom_path_with_freeing_call_p)\n+\t  || (pred_info->has_freeing_call_computed_p\n+\t      && pred_info->has_freeing_call_p))\n+\t{\n+\t  info->imm_dom_path_with_freeing_call_computed_p = true;\n+\t  info->imm_dom_path_with_freeing_call_p = true;\n+\t  info->being_visited_p = false;\n+\t  return true;\n+\t}\n+    }\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      sanopt_info *pred_info = (sanopt_info *) e->src->aux;\n+\n+      if (e->src == dom)\n+\tcontinue;\n+\n+      if (pred_info->has_freeing_call_computed_p)\n+\tcontinue;\n+\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (e->src); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\n+\t  if (is_gimple_call (stmt) && !nonfreeing_call_p (stmt))\n+\t    {\n+\t      pred_info->has_freeing_call_p = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+      pred_info->has_freeing_call_computed_p = true;\n+      if (pred_info->has_freeing_call_p)\n+\t{\n+\t  info->imm_dom_path_with_freeing_call_computed_p = true;\n+\t  info->imm_dom_path_with_freeing_call_p = true;\n+\t  info->being_visited_p = false;\n+\t  return true;\n+\t}\n+    }\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (e->src == dom)\n+\tcontinue;\n+\n+      basic_block src;\n+      for (src = e->src; src != dom; )\n+\t{\n+\t  sanopt_info *pred_info = (sanopt_info *) src->aux;\n+\t  if (pred_info->being_visited_p)\n+\t    break;\n+\t  basic_block imm = get_immediate_dominator (CDI_DOMINATORS, src);\n+\t  if (imm_dom_path_with_freeing_call (src, imm))\n+\t    {\n+\t      info->imm_dom_path_with_freeing_call_computed_p = true;\n+\t      info->imm_dom_path_with_freeing_call_p = true;\n+\t      info->being_visited_p = false;\n+\t      return true;\n+\t    }\n+\t  src = imm;\n+\t}\n+    }\n+\n+  info->imm_dom_path_with_freeing_call_computed_p = true;\n+  info->imm_dom_path_with_freeing_call_p = false;\n+  info->being_visited_p = false;\n+  return false;\n+}\n+\n+/* Optimize away redundant UBSAN_NULL calls.  */\n+\n+static bool\n+maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+{\n+  gcc_assert (gimple_call_num_args (stmt) == 3);\n+  tree ptr = gimple_call_arg (stmt, 0);\n+  tree cur_align = gimple_call_arg (stmt, 2);\n+  gcc_assert (TREE_CODE (cur_align) == INTEGER_CST);\n+  bool remove = false;\n+\n+  auto_vec<gimple> &v = ctx->null_check_map.get_or_insert (ptr);\n+  if (v.is_empty ())\n+    {\n+      /* For this PTR we don't have any UBSAN_NULL stmts recorded, so there's\n+\t nothing to optimize yet.  */\n+      v.safe_push (stmt);\n+      return false;\n+    }\n+\n+  /* We already have recorded a UBSAN_NULL check for this pointer. Perhaps we\n+     can drop this one.  But only if this check doesn't specify stricter\n+     alignment.  */\n+  while (!v.is_empty ())\n+    {\n+      gimple g = v.last ();\n+      /* Remove statements for BBs that have been already processed.  */\n+      sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n+      if (si->visited_p)\n+\t{\n+\t  v.pop ();\n+\t  continue;\n+\t}\n+\n+      /* At this point we shouldn't have any statements that aren't dominating\n+\t the current BB.  */\n+      tree align = gimple_call_arg (g, 2);\n+      int kind = tree_to_shwi (gimple_call_arg (g, 1));\n+      /* If this is a NULL pointer check where we had segv anyway, we can\n+\t remove it.  */\n+      if (integer_zerop (align)\n+\t  && (kind == UBSAN_LOAD_OF\n+\t      || kind == UBSAN_STORE_OF\n+\t      || kind == UBSAN_MEMBER_ACCESS))\n+\tremove = true;\n+      /* Otherwise remove the check in non-recovering mode, or if the\n+\t stmts have same location.  */\n+      else if (integer_zerop (align))\n+\tremove = (flag_sanitize_recover & SANITIZE_NULL) == 0\n+\t\t || flag_sanitize_undefined_trap_on_error\n+\t\t || gimple_location (g) == gimple_location (stmt);\n+      else if (tree_int_cst_le (cur_align, align))\n+\tremove = (flag_sanitize_recover & SANITIZE_ALIGNMENT) == 0\n+\t\t || flag_sanitize_undefined_trap_on_error\n+\t\t || gimple_location (g) == gimple_location (stmt);\n+      if (!remove && gimple_bb (g) == gimple_bb (stmt)\n+\t  && tree_int_cst_compare (cur_align, align) == 0)\n+\tv.pop ();\n+      break;\n+    }\n+\n+  if (!remove)\n+    v.safe_push (stmt);\n+  return remove;\n+}\n+\n+/* Optimize away redundant ASAN_CHECK calls.  */\n+\n+static bool\n+maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple stmt)\n+{\n+  gcc_assert (gimple_call_num_args (stmt) == 4);\n+  tree ptr = gimple_call_arg (stmt, 1);\n+  tree len = gimple_call_arg (stmt, 2);\n+  basic_block bb = gimple_bb (stmt);\n+  sanopt_info *info = (sanopt_info *) bb->aux;\n+\n+  if (TREE_CODE (len) != INTEGER_CST)\n+    return false;\n+  if (integer_zerop (len))\n+    return false;\n+\n+  gimple_set_uid (stmt, info->freeing_call_events);\n+\n+  auto_vec<gimple> &v = ctx->asan_check_map.get_or_insert (ptr);\n+  if (v.is_empty ())\n+    {\n+      /* For this PTR we don't have any ASAN_CHECK stmts recorded, so there's\n+\t nothing to optimize yet.  */\n+      v.safe_push (stmt);\n+      return false;\n+    }\n+\n+  /* We already have recorded a ASAN_CHECK check for this pointer.  Perhaps\n+     we can drop this one.  But only if this check doesn't specify larger\n+     size.  */\n+  while (!v.is_empty ())\n+    {\n+      gimple g = v.last ();\n+      /* Remove statements for BBs that have been already processed.  */\n+      sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n+      if (si->visited_p)\n+\tv.pop ();\n+      else\n+\tbreak;\n+    }\n+\n+  unsigned int i;\n+  gimple g;\n+  gimple to_pop = NULL;\n+  bool remove = false;\n+  basic_block last_bb = bb;\n+  bool cleanup = false;\n+\n+  FOR_EACH_VEC_ELT_REVERSE (v, i, g)\n+    {\n+      basic_block gbb = gimple_bb (g);\n+      sanopt_info *si = (sanopt_info *) gbb->aux;\n+      if (gimple_uid (g) < si->freeing_call_events)\n+\t{\n+\t  /* If there is a potentially freeing call after g in gbb, we should\n+\t     remove it from the vector, can't use in optimization.  */\n+\t  cleanup = true;\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (len) != INTEGER_CST)\n+\t{\n+\t  /* If there is some stmts not followed by freeing call event\n+\t     for ptr already in the current bb, no need to insert anything.\n+\t     Non-constant len is treated just as length 1.  */\n+\t  if (gbb == bb)\n+\t    return false;\n+\t  break;\n+\t}\n+\n+      tree glen = gimple_call_arg (g, 2);\n+      /* If we've checked only smaller length than we want to check now,\n+\t we can't remove the current stmt.  If g is in the same basic block,\n+\t we want to remove it though, as the current stmt is better.  */\n+      if (tree_int_cst_lt (glen, len))\n+\t{\n+\t  if (gbb == bb)\n+\t    {\n+\t      to_pop = g;\n+\t      cleanup = true;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      while (last_bb != gbb)\n+\t{\n+\t  /* Paths from last_bb to bb have been checked before.\n+\t     gbb is necessarily a dominator of last_bb, but not necessarily\n+\t     immediate dominator.  */\n+\t  if (((sanopt_info *) last_bb->aux)->freeing_call_events)\n+\t    break;\n+\n+\t  basic_block imm = get_immediate_dominator (CDI_DOMINATORS, last_bb);\n+\t  gcc_assert (imm);\n+\t  if (imm_dom_path_with_freeing_call (last_bb, imm))\n+\t    break;\n+\n+\t  last_bb = imm;\n+\t}\n+      if (last_bb == gbb)\n+\tremove = true;\n+      break;\n+    }\n+\n+  if (cleanup)\n+    {\n+      unsigned int j = 0, l = v.length ();\n+      for (i = 0; i < l; i++)\n+\tif (v[i] != to_pop\n+\t    && (gimple_uid (v[i])\n+\t\t== ((sanopt_info *)\n+\t\t    gimple_bb (v[i])->aux)->freeing_call_events))\n+\t  {\n+\t    if (i != j)\n+\t      v[j] = v[i];\n+\t    j++;\n+\t  }\n+      v.truncate (j);\n+    }\n+\n+  if (!remove)\n+    v.safe_push (stmt);\n+  return remove;\n+}\n+\n+/* Try to optimize away redundant UBSAN_NULL and ASAN_CHECK calls.\n+\n    We walk blocks in the CFG via a depth first search of the dominator\n-   tree; we push unique UBSAN_NULL statements into a vector in the\n-   NULL_CHECK_MAP as we enter the blocks.  When leaving a block, we\n-   mark the block as visited; then when checking the statements in the\n-   vector, we ignore statements that are coming from already visited\n-   blocks, because these cannot dominate anything anymore.\n-   CTX is a sanopt context.  */\n+   tree; we push unique UBSAN_NULL or ASAN_CHECK statements into a vector\n+   in the NULL_CHECK_MAP or ASAN_CHECK_MAP hash maps as we enter the\n+   blocks.  When leaving a block, we mark the block as visited; then\n+   when checking the statements in the vector, we ignore statements that\n+   are coming from already visited blocks, because these cannot dominate\n+   anything anymore.  CTX is a sanopt context.  */\n \n static void\n sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n {\n   basic_block son;\n   gimple_stmt_iterator gsi;\n+  sanopt_info *info = (sanopt_info *) bb->aux;\n+  bool asan_check_optimize\n+    = (flag_sanitize & SANITIZE_ADDRESS)\n+      && ((flag_sanitize & flag_sanitize_recover\n+\t   & SANITIZE_KERNEL_ADDRESS) == 0);\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n     {\n       gimple stmt = gsi_stmt (gsi);\n       bool remove = false;\n \n-      if (is_gimple_call (stmt)\n-\t  && gimple_call_internal_p (stmt))\n+      if (!is_gimple_call (stmt))\n+\t{\n+\t  /* Handle asm volatile or asm with \"memory\" clobber\n+\t     the same as potentionally freeing call.  */\n+\t  if (gimple_code (stmt) == GIMPLE_ASM\n+\t      && asan_check_optimize\n+\t      && (gimple_asm_clobbers_memory_p (stmt)\n+\t\t  || gimple_asm_volatile_p (stmt)))\n+\t    info->freeing_call_events++;\n+\t  gsi_next (&gsi);\n+\t  continue;\n+\t}\n+\n+      if (asan_check_optimize && !nonfreeing_call_p (stmt))\n+\tinfo->freeing_call_events++;\n+\n+      if (gimple_call_internal_p (stmt))\n \tswitch (gimple_call_internal_fn (stmt))\n \t  {\n \t  case IFN_UBSAN_NULL:\n-\t    {\n-\t      gcc_assert (gimple_call_num_args (stmt) == 3);\n-\t      tree ptr = gimple_call_arg (stmt, 0);\n-\t      tree cur_align = gimple_call_arg (stmt, 2);\n-\t      gcc_assert (TREE_CODE (cur_align) == INTEGER_CST);\n-\n-\t      auto_vec<gimple> &v = ctx->null_check_map.get_or_insert (ptr);\n-\t      if (v.is_empty ())\n-\t\t/* For this PTR we don't have any UBSAN_NULL stmts\n-\t\t   recorded, so there's nothing to optimize yet.  */\n-\t\tv.safe_push (stmt);\n-\t      else\n-\t\t{\n-\t\t  /* We already have recorded a UBSAN_NULL check\n-\t\t     for this pointer.  Perhaps we can drop this one.\n-\t\t     But only if this check doesn't specify stricter\n-\t\t     alignment.  */\n-\t\t  while (!v.is_empty ())\n-\t\t    {\n-\t\t      gimple g = v.last ();\n-\t\t      /* Remove statements for BBs that have been\n-\t\t\t already processed.  */\n-\t\t      sanopt_info *si = (sanopt_info *) gimple_bb (g)->aux;\n-\t\t      if (si->visited_p)\n-\t\t\tv.pop ();\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* At this point we shouldn't have any statements\n-\t\t\t     that aren't dominating the current BB.  */\n-\t\t\t  tree align = gimple_call_arg (g, 2);\n-\t\t\t  int kind = tree_to_shwi (gimple_call_arg (g, 1));\n-\t\t\t  /* If this is a NULL pointer check where we had segv\n-\t\t\t     anyway, we can remove it.  */\n-\t\t\t  if (integer_zerop (align)\n-\t\t\t      && (kind == UBSAN_LOAD_OF\n-\t\t\t\t  || kind == UBSAN_STORE_OF\n-\t\t\t\t  || kind == UBSAN_MEMBER_ACCESS))\n-\t\t\t    remove = true;\n-\t\t\t  /* Otherwise remove the check in non-recovering\n-\t\t\t     mode, or if the stmts have same location.  */\n-\t\t\t  else if (integer_zerop (align))\n-\t\t\t    remove = !(flag_sanitize_recover & SANITIZE_NULL)\n-\t\t\t\t     || flag_sanitize_undefined_trap_on_error\n-\t\t\t\t     || gimple_location (g)\n-\t\t\t\t\t== gimple_location (stmt);\n-\t\t\t  else if (tree_int_cst_le (cur_align, align))\n-\t\t\t    remove = !(flag_sanitize_recover\n-\t\t\t\t       & SANITIZE_ALIGNMENT)\n-\t\t\t\t     || flag_sanitize_undefined_trap_on_error\n-\t\t\t\t     || gimple_location (g)\n-\t\t\t\t\t== gimple_location (stmt);\n-\t\t\t  if (!remove && gimple_bb (g) == gimple_bb (stmt)\n-\t\t\t      && tree_int_cst_compare (cur_align, align) == 0)\n-\t\t\t    v.pop ();\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  if (remove)\n-\t\t    {\n-\t\t      /* Drop this check.  */\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (dump_file, \"Optimizing out\\n  \");\n-\t\t\t  print_gimple_stmt (dump_file, stmt, 0,\n-\t\t\t\t\t     dump_flags);\n-\t\t\t  fprintf (dump_file, \"\\n\");\n-\t\t\t}\n-\t\t      gsi_remove (&gsi, true);\n-\t\t    }\n-\t\t  else\n-\t\t    v.safe_push (stmt);\n-\t\t  }\n-\t    }\n+\t    remove = maybe_optimize_ubsan_null_ifn (ctx, stmt);\n+\t    break;\n \t  case IFN_ASAN_CHECK:\n-\t    ctx->asan_num_accesses++;\n+\t    if (asan_check_optimize)\n+\t      remove = maybe_optimize_asan_check_ifn (ctx, stmt);\n+\t    if (!remove)\n+\t      ctx->asan_num_accesses++;\n \t    break;\n \t  default:\n \t    break;\n \t  }\n \n-      /* If we were able to remove the current statement, gsi_remove\n-\t already pointed us to the next statement.  */\n-      if (!remove)\n+      if (remove)\n+\t{\n+\t  /* Drop this check.  */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Optimizing out\\n  \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  unlink_stmt_vdef (stmt);\n+\t  gsi_remove (&gsi, true);\n+\t}\n+      else\n \tgsi_next (&gsi);\n     }\n \n+  if (asan_check_optimize)\n+    {\n+      info->has_freeing_call_p = info->freeing_call_events != 0;\n+      info->has_freeing_call_computed_p = true;\n+    }\n+\n   for (son = first_dom_son (CDI_DOMINATORS, bb);\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n     sanopt_optimize_walker (son, ctx);\n \n   /* We're leaving this BB, so mark it to that effect.  */\n-  sanopt_info *info = (sanopt_info *) bb->aux;\n   info->visited_p = true;\n }\n \n@@ -259,7 +539,8 @@ pass_sanopt::execute (function *fun)\n \n   /* Try to remove redundant checks.  */\n   if (optimize\n-      && (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT)))\n+      && (flag_sanitize\n+\t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT | SANITIZE_ADDRESS)))\n     asan_num_accesses = sanopt_optimize (fun);\n   else if (flag_sanitize & SANITIZE_ADDRESS)\n     {"}]}