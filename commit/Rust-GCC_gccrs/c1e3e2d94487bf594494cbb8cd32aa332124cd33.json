{"sha": "c1e3e2d94487bf594494cbb8cd32aa332124cd33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlM2UyZDk0NDg3YmY1OTQ0OTRjYmI4Y2QzMmFhMzMyMTI0Y2QzMw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb.gcc@gmail.com", "date": "2008-01-11T14:55:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-01-11T14:55:34Z"}, "message": "re PR middle-end/30905 (Fails to cross-jump)\n\n2008-01-11  Steven Bosscher  <stevenb.gcc@gmail.com>\n\n\tPR rtl-optimization/30905\n\t* cfgcleanup.c: Include dce.h\n\t(crossjumps_occured): New global variable.\n\t(try_crossjump_bb): Exit loop after finding a fallthru edge.\n\tIf something changed, set crossjumps_occured to true.\n\t(try_optimize_cfg): Clear crossjumps_occured at the beginning.\n\tDon't add/remove fake edges to exit here...\n\t(cleanup_cfg): ...but do it here, when crossjumping.\n\tRun a fast DCE when successful crossjumps occured in the latest\n\titeration of try_optimize_cfg.\n\nFrom-SVN: r131468", "tree": {"sha": "af89a1d1e50ecbea2a77cdf1f64808b1fdd0dd05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af89a1d1e50ecbea2a77cdf1f64808b1fdd0dd05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1e3e2d94487bf594494cbb8cd32aa332124cd33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e3e2d94487bf594494cbb8cd32aa332124cd33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e3e2d94487bf594494cbb8cd32aa332124cd33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e3e2d94487bf594494cbb8cd32aa332124cd33/comments", "author": null, "committer": null, "parents": [{"sha": "8d0eca24faee76ac0ebc169695e4a79f390a5316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d0eca24faee76ac0ebc169695e4a79f390a5316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d0eca24faee76ac0ebc169695e4a79f390a5316"}], "stats": {"total": 69, "additions": 57, "deletions": 12}, "files": [{"sha": "a6017c5b481a7caaf259f615a0a036e17f42b9fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e3e2d94487bf594494cbb8cd32aa332124cd33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e3e2d94487bf594494cbb8cd32aa332124cd33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1e3e2d94487bf594494cbb8cd32aa332124cd33", "patch": "@@ -1,3 +1,16 @@\n+2008-01-11  Steven Bosscher  <stevenb.gcc@gmail.com>\n+\n+\tPR rtl-optimization/30905\n+\t* cfgcleanup.c: Include dce.h\n+\t(crossjumps_occured): New global variable.\n+\t(try_crossjump_bb): Exit loop after finding a fallthru edge.\n+\tIf something changed, set crossjumps_occured to true.\n+\t(try_optimize_cfg): Clear crossjumps_occured at the beginning.\n+\tDon't add/remove fake edges to exit here...\n+\t(cleanup_cfg): ...but do it here, when crossjumping.\n+\tRun a fast DCE when successful crossjumps occured in the latest\n+\titeration of try_optimize_cfg.\n+\n 2008-01-11  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (struct vn_binary_op_s): Move hashcode near opcode."}, {"sha": "3ec7d3f3781a3728585d1f5b1407243bfd9d8d81", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e3e2d94487bf594494cbb8cd32aa332124cd33/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e3e2d94487bf594494cbb8cd32aa332124cd33/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=c1e3e2d94487bf594494cbb8cd32aa332124cd33", "patch": "@@ -54,11 +54,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"expr.h\"\n #include \"df.h\"\n+#include \"dce.h\"\n \n #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)\n \n /* Set to true when we are running first pass of try_optimize_cfg loop.  */\n static bool first_pass;\n+\n+/* Set to true if crossjumps occured in the latest run of try_optimize_cfg.  */\n+static bool crossjumps_occured;\n+\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n@@ -1838,7 +1843,10 @@ try_crossjump_bb (int mode, basic_block bb)\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (e->flags & EDGE_FALLTHRU)\n-\tfallthru = e;\n+\t{\n+\t  fallthru = e;\n+\t  break;\n+\t}\n     }\n \n   changed = false;\n@@ -1847,7 +1855,8 @@ try_crossjump_bb (int mode, basic_block bb)\n       e = EDGE_PRED (ev, ix);\n       ix++;\n \n-      /* As noted above, first try with the fallthru predecessor.  */\n+      /* As noted above, first try with the fallthru predecessor (or, a\n+\t fallthru predecessor if we are in cfglayout mode).  */\n       if (fallthru)\n \t{\n \t  /* Don't combine the fallthru edge into anything else.\n@@ -1921,6 +1930,9 @@ try_crossjump_bb (int mode, basic_block bb)\n \t}\n     }\n \n+  if (changed)\n+    crossjumps_occured = true;\n+\n   return changed;\n }\n \n@@ -1935,12 +1947,11 @@ try_optimize_cfg (int mode)\n   int iterations = 0;\n   basic_block bb, b, next;\n \n-  if (mode & CLEANUP_CROSSJUMP)\n-    add_noreturn_fake_exit_edges ();\n-\n   if (mode & (CLEANUP_CROSSJUMP | CLEANUP_THREADING))\n     clear_bb_flags ();\n \n+  crossjumps_occured = false;\n+\n   FOR_EACH_BB (bb)\n     update_forwarder_flag (bb);\n \n@@ -2131,9 +2142,6 @@ try_optimize_cfg (int mode)\n       while (changed);\n     }\n \n-  if (mode & CLEANUP_CROSSJUMP)\n-    remove_fake_exit_edges ();\n-\n   FOR_ALL_BB (b)\n     b->flags &= ~(BB_FORWARDER_BLOCK | BB_NONTHREADABLE_BLOCK);\n \n@@ -2235,20 +2243,44 @@ cleanup_cfg (int mode)\n \n   compact_blocks ();\n \n+  /* To tail-merge blocks ending in the same noreturn function (e.g.\n+     a call to abort) we have to insert fake edges to exit.  Do this\n+     here once.  The fake edges do not interfere with any other CFG\n+     cleanups.  */\n+  if (mode & CLEANUP_CROSSJUMP)\n+    add_noreturn_fake_exit_edges ();\n+\n   while (try_optimize_cfg (mode))\n     {\n       delete_unreachable_blocks (), changed = true;\n-      if (!(mode & CLEANUP_NO_INSN_DEL)\n-\t  && (mode & CLEANUP_EXPENSIVE)\n-\t  && !reload_completed)\n+      if (!(mode & CLEANUP_NO_INSN_DEL))\n \t{\n-\t  if (!delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n+\t  /* Try to remove some trivially dead insns when doing an expensive\n+\t     cleanup.  But delete_trivially_dead_insns doesn't work after\n+\t     reload (it only handles pseudos) and run_fast_dce is too costly\n+\t     to run in every iteration.\n+\n+\t     For effective cross jumping, we really want to run a fast DCE to\n+\t     clean up any dead conditions, or they get in the way of performing\n+\t     useful tail merges.\n+\n+\t     Other transformations in cleanup_cfg are not so sensitive to dead\n+\t     code, so delete_trivially_dead_insns or even doing nothing at all\n+\t     is good enough.  */\n+\t  if ((mode & CLEANUP_EXPENSIVE) && !reload_completed\n+\t      && !delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n \t    break;\n+\t  else if ((mode & CLEANUP_CROSSJUMP)\n+\t\t   && crossjumps_occured)\n+\t    run_fast_dce ();\n \t}\n       else\n \tbreak;\n     }\n \n+  if (mode & CLEANUP_CROSSJUMP)\n+    remove_fake_exit_edges ();\n+\n   /* Don't call delete_dead_jumptables in cfglayout mode, because\n      that function assumes that jump tables are in the insns stream.\n      But we also don't _have_ to delete dead jumptables in cfglayout"}]}