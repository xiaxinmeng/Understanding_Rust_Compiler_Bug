{"sha": "b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAxNTlmYmVlOTE2ZTNiYmViMmQ2NjFiNDBhZTQ0ODNhMGJjYjliNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-11T17:46:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-11T17:46:23Z"}, "message": "[multiple changes]\n\n2009-07-11  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_util.adb, sem_res.adb, sem_warn.adb: Minor comment editing:\n\tLvalue -> lvalue\n\n\t* exp_ch6.adb: Minor reformatting\n\n2009-07-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Expand_Atomic_Aggregate): Clean up code, take into\n\taccount possible type qualification to determine whether aggregate\n\tneeds a target temporary to respect atomic type or object.\n\n\t* exp_aggr.adb (Expand_Record_Aggregate): Use new version of\n\tExpand_Atomic_Aggregate.\n\n2009-07-11  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb, prj.ads, prj-nmsc.adb (Mark_Excluded_Sources): Speed up\n\talgorithm.\n\t(Excluded_Sources_Htable): No longer a global table.\n\tChange error message to indicate which files are illegal in the list\n\tof excluded files, as opposed to only the location in the project\n\tfile.\n\t(Find_Source): New subprogram.\n\nFrom-SVN: r149515", "tree": {"sha": "13c0dad3daf6e336511830c555284e910bf763db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13c0dad3daf6e336511830c555284e910bf763db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/comments", "author": null, "committer": null, "parents": [{"sha": "3e3a9a6ac1608dcafc4ef5c96a8f30c1d5243dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3a9a6ac1608dcafc4ef5c96a8f30c1d5243dc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e3a9a6ac1608dcafc4ef5c96a8f30c1d5243dc5"}], "stats": {"total": 323, "additions": 219, "deletions": 104}, "files": [{"sha": "187fa57dbea626436b814634268f9dade0b4d359", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -1,3 +1,29 @@\n+2009-07-11  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_util.adb, sem_res.adb, sem_warn.adb: Minor comment editing:\n+\tLvalue -> lvalue\n+\n+\t* exp_ch6.adb: Minor reformatting\n+\n+2009-07-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Expand_Atomic_Aggregate): Clean up code, take into\n+\taccount possible type qualification to determine whether aggregate\n+\tneeds a target temporary to respect atomic type or object.\n+\n+\t* exp_aggr.adb (Expand_Record_Aggregate): Use new version of\n+\tExpand_Atomic_Aggregate.\n+\n+2009-07-11  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb, prj.ads, prj-nmsc.adb (Mark_Excluded_Sources): Speed up\n+\talgorithm.\n+\t(Excluded_Sources_Htable): No longer a global table.\n+\tChange error message to indicate which files are illegal in the list\n+\tof excluded files, as opposed to only the location in the project\n+\tfile.\n+\t(Find_Source): New subprogram.\n+\n 2009-07-10  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch7.adb: Update comments."}, {"sha": "fc610766266a8d0bb8d571b4d57c50333a0eca2f", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -5475,11 +5475,9 @@ package body Exp_Aggr is\n       --  an atomic move for it.\n \n       if Is_Atomic (Typ)\n-        and then Nkind_In (Parent (N), N_Object_Declaration,\n-                                       N_Assignment_Statement)\n         and then Comes_From_Source (Parent (N))\n+        and then Expand_Atomic_Aggregate (N, Typ)\n       then\n-         Expand_Atomic_Aggregate (N, Typ);\n          return;\n \n       --  No special management required for aggregates used to initialize"}, {"sha": "3142174c5ebabed8bdc538cb0ba353e6d72915ee", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -1146,7 +1146,7 @@ package body Exp_Ch6 is\n             --  resulting variable is a temporary which does not designate\n             --  the proper out-parameter, which may not be addressable. In\n             --  that case, generate an assignment to the original expression\n-            --  (before expansion of the  packed reference) so that the proper\n+            --  (before expansion of the packed reference) so that the proper\n             --  expansion of assignment to a packed component can take place.\n \n             declare\n@@ -4661,7 +4661,7 @@ package body Exp_Ch6 is\n       end if;\n \n       --  Analyze and resolve the new call. The actuals have already been\n-      --  resolved, but expansion  of a function call will add extra actuals\n+      --  resolved, but expansion of a function call will add extra actuals\n       --  if needed. Analysis of a procedure call already includes resolution.\n \n       Analyze (N);"}, {"sha": "f464f19b2effc0ba4767e6731660d408b7c84a51", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -1115,15 +1115,27 @@ package body Freeze is\n    -- Expand_Atomic_Aggregate --\n    -----------------------------\n \n-   procedure Expand_Atomic_Aggregate (E : Entity_Id; Typ : Entity_Id) is\n+   function  Expand_Atomic_Aggregate\n+     (E   : Entity_Id;\n+      Typ : Entity_Id) return Boolean\n+   is\n       Loc   : constant Source_Ptr := Sloc (E);\n       New_N : Node_Id;\n+      Par   : Node_Id;\n       Temp  : Entity_Id;\n \n    begin\n-      if (Nkind (Parent (E)) = N_Object_Declaration\n-            or else Nkind (Parent (E)) = N_Assignment_Statement)\n-        and then Comes_From_Source (Parent (E))\n+      Par := Parent (E);\n+\n+      --  Array may be qualified, so find outer context.\n+\n+      if Nkind (Par) = N_Qualified_Expression then\n+         Par := Parent (Par);\n+      end if;\n+\n+      if (Nkind (Par) = N_Object_Declaration\n+            or else Nkind (Par) = N_Assignment_Statement)\n+        and then Comes_From_Source (Par)\n       then\n          Temp :=\n            Make_Defining_Identifier (Loc,\n@@ -1134,11 +1146,14 @@ package body Freeze is\n              Defining_Identifier => Temp,\n              Object_Definition   => New_Occurrence_Of (Typ, Loc),\n              Expression          => Relocate_Node (E));\n-         Insert_Before (Parent (E), New_N);\n+         Insert_Before (Par, New_N);\n          Analyze (New_N);\n \n-         Set_Expression (Parent (E), New_Occurrence_Of (Temp, Loc));\n+         Set_Expression (Par, New_Occurrence_Of (Temp, Loc));\n+         return True;\n \n+      else\n+         return False;\n       end if;\n    end Expand_Atomic_Aggregate;\n \n@@ -2351,8 +2366,10 @@ package body Freeze is\n            and then Nkind (Parent (E)) = N_Object_Declaration\n            and then Present (Expression (Parent (E)))\n            and then Nkind (Expression (Parent (E))) = N_Aggregate\n+           and then\n+            Expand_Atomic_Aggregate (Expression (Parent (E)), Etype (E))\n          then\n-            Expand_Atomic_Aggregate (Expression (Parent (E)), Etype (E));\n+            null;\n          end if;\n \n          --  For a subprogram, freeze all parameter types and also the return"}, {"sha": "ac2fa8c2b19373183144e79158911fc2e3706c98", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -175,12 +175,17 @@ package Freeze is\n    --  do not allow a size clause if the size would not otherwise be known at\n    --  compile time in any case.\n \n-   procedure Expand_Atomic_Aggregate (E : Entity_Id; Typ : Entity_Id);\n+   function  Expand_Atomic_Aggregate\n+     (E   : Entity_Id;\n+      Typ : Entity_Id) return Boolean;\n+\n    --  If an atomic object is initialized with an aggregate or is assigned\n    --  an aggregate, we have to prevent a piecemeal access or assignment\n    --  to the object, even if the aggregate is to be expanded. We create\n    --  a temporary for the aggregate, and assign the temporary instead,\n-   --  so that the back end can generate an atomic move for it.\n+   --  so that the back end can generate an atomic move for it. This is\n+   --  only done in the context of an object declaration or an assignment.\n+   --  Function is a noop and returns false in other contexts.\n \n    function Freeze_Entity (E : Entity_Id; Loc : Source_Ptr) return List_Id;\n    --  Freeze an entity, and return Freeze nodes, to be inserted at the"}, {"sha": "8ba798140db7dab108e3f95b01876bce975740df", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 86, "deletions": 72, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -181,7 +181,7 @@ package body Prj.Nmsc is\n    No_File_Found : constant File_Found := (No_File, False, No_Location);\n    --  Comments needed ???\n \n-   package Excluded_Sources_Htable is new GNAT.HTable.Simple_HTable\n+   package Excluded_Sources_Htable is new GNAT.Dynamic_HTables.Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => File_Found,\n       No_Element => No_File_Found,\n@@ -192,8 +192,9 @@ package body Prj.Nmsc is\n    --  Find_Excluded_Sources below.\n \n    procedure Find_Excluded_Sources\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref);\n+     (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n+      Excluded : in out Excluded_Sources_Htable.Instance);\n    --  Find the list of files that should not be considered as source files\n    --  for this project. Sets the list in the Excluded_Sources_Htable.\n \n@@ -224,8 +225,9 @@ package body Prj.Nmsc is\n    --  with a file name following the naming convention.\n \n    procedure Load_Naming_Exceptions\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref);\n+     (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n+      Excluded : in out Excluded_Sources_Htable.Instance);\n    --  All source files in Data.First_Source are considered as naming\n    --  exceptions, and copied into the Source_Names and Unit_Exceptions tables\n    --  as appropriate.\n@@ -378,7 +380,8 @@ package body Prj.Nmsc is\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n       For_All_Sources           : Boolean;\n-      Allow_Duplicate_Basenames : Boolean);\n+      Allow_Duplicate_Basenames : Boolean;\n+      Excluded                  : in out Excluded_Sources_Htable.Instance);\n    --  Search the source directories to find the sources. If For_All_Sources is\n    --  True, check each regular file name against the naming schemes of the\n    --  different languages. Otherwise consider only the file names in the hash\n@@ -462,7 +465,8 @@ package body Prj.Nmsc is\n      (Project   : Project_Id;\n       In_Tree   : Project_Tree_Ref;\n       Proc_Data : in out Processing_Data;\n-      Allow_Duplicate_Basenames : Boolean);\n+      Allow_Duplicate_Basenames : Boolean;\n+      Excluded                  : in out Excluded_Sources_Htable.Instance);\n    --  Process the Source_Files and Source_List_File attributes, and store the\n    --  list of source files into the Source_Names htable. When these attributes\n    --  are not defined, find all files matching the naming schemes in the\n@@ -6573,8 +6577,9 @@ package body Prj.Nmsc is\n    ---------------------------\n \n    procedure Find_Excluded_Sources\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref)\n+     (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n+      Excluded : in out Excluded_Sources_Htable.Instance)\n    is\n       Excluded_Source_List_File : constant Variable_Value :=\n                                     Util.Value_Of\n@@ -6606,7 +6611,7 @@ package body Prj.Nmsc is\n              (Name_Locally_Removed_Files, Project.Decl.Attributes, In_Tree);\n       end if;\n \n-      Excluded_Sources_Htable.Reset;\n+      Excluded_Sources_Htable.Reset (Excluded);\n \n       --  If there are excluded sources, put them in the table\n \n@@ -6641,7 +6646,8 @@ package body Prj.Nmsc is\n                Location := Element.Location;\n             end if;\n \n-            Excluded_Sources_Htable.Set (Name, (Name, False, Location));\n+            Excluded_Sources_Htable.Set\n+              (Excluded, Name, (Name, False, Location));\n             Current := Element.Next;\n          end loop;\n \n@@ -6706,7 +6712,7 @@ package body Prj.Nmsc is\n                         end loop;\n \n                         Excluded_Sources_Htable.Set\n-                          (Name, (Name, False, Location));\n+                          (Excluded, Name, (Name, False, Location));\n                      end if;\n                   end loop;\n \n@@ -6725,7 +6731,8 @@ package body Prj.Nmsc is\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n       Proc_Data                 : in out Processing_Data;\n-      Allow_Duplicate_Basenames : Boolean)\n+      Allow_Duplicate_Basenames : Boolean;\n+      Excluded                  : in out Excluded_Sources_Htable.Instance)\n    is\n       Sources : constant Variable_Value :=\n                   Util.Value_Of\n@@ -6894,7 +6901,8 @@ package body Prj.Nmsc is\n            (Project, In_Tree,\n             For_All_Sources           =>\n               Sources.Default and then Source_List_File.Default,\n-            Allow_Duplicate_Basenames => Allow_Duplicate_Basenames);\n+            Allow_Duplicate_Basenames => Allow_Duplicate_Basenames,\n+            Excluded                  => Excluded);\n       end if;\n \n       --  Check if all exceptions have been found. For Ada, it is an error if\n@@ -7548,7 +7556,8 @@ package body Prj.Nmsc is\n      (Project                   : Project_Id;\n       In_Tree                   : Project_Tree_Ref;\n       For_All_Sources           : Boolean;\n-      Allow_Duplicate_Basenames : Boolean)\n+      Allow_Duplicate_Basenames : Boolean;\n+      Excluded                  : in out Excluded_Sources_Htable.Instance)\n    is\n       Source_Dir        : String_List_Id;\n       Element           : String_Element;\n@@ -7633,8 +7642,8 @@ package body Prj.Nmsc is\n                            --  Case_Sensitive set True (no folding)\n \n                            Path : Path_Name_Type;\n-                           FF   : File_Found :=\n-                                    Excluded_Sources_Htable.Get (File_Name);\n+                           FF   : File_Found := Excluded_Sources_Htable.Get\n+                                                  (Excluded, File_Name);\n \n                         begin\n                            Name_Len := Path_Name'Length;\n@@ -7644,7 +7653,8 @@ package body Prj.Nmsc is\n                            if FF /= No_File_Found then\n                               if not FF.Found then\n                                  FF.Found := True;\n-                                 Excluded_Sources_Htable.Set (File_Name, FF);\n+                                 Excluded_Sources_Htable.Set\n+                                   (Excluded, File_Name, FF);\n \n                                  if Current_Verbosity = High then\n                                     Write_Str (\"     excluded source \"\"\");\n@@ -7691,8 +7701,9 @@ package body Prj.Nmsc is\n    ----------------------------\n \n    procedure Load_Naming_Exceptions\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref)\n+     (Project  : Project_Id;\n+      In_Tree  : Project_Tree_Ref;\n+      Excluded : in out Excluded_Sources_Htable.Instance)\n    is\n       Source : Source_Id;\n       Iter   : Source_Iterator;\n@@ -7707,7 +7718,9 @@ package body Prj.Nmsc is\n \n          --  An excluded file cannot also be an exception file name\n \n-         if Excluded_Sources_Htable.Get (Source.File) /= No_File_Found then\n+         if Excluded_Sources_Htable.Get (Excluded, Source.File) /=\n+           No_File_Found\n+         then\n             Error_Msg_File_1 := Source.File;\n             Error_Msg\n               (Project, In_Tree,\n@@ -7764,7 +7777,9 @@ package body Prj.Nmsc is\n       Proc_Data                 : in out Processing_Data;\n       Allow_Duplicate_Basenames : Boolean)\n    is\n-      Iter : Source_Iterator;\n+      Iter     : Source_Iterator;\n+      Src      : Source_Id;\n+      Excluded_Sources : Excluded_Sources_Htable.Instance;\n \n       procedure Process_Sources_In_Multi_Language_Mode;\n       --  Find all source files when in multi language mode\n@@ -7778,69 +7793,66 @@ package body Prj.Nmsc is\n \n       procedure Mark_Excluded_Sources is\n          Source   : Source_Id := No_Source;\n-         OK       : Boolean;\n          Excluded : File_Found;\n-\n+         Proj     : Project_Id;\n       begin\n-         Excluded := Excluded_Sources_Htable.Get_First;\n-         while Excluded /= No_File_Found loop\n-            OK := False;\n+         Proj := Project;\n+         while Proj /= No_Project loop\n+            Iter := For_Each_Source (In_Tree, Proj);\n+            while Prj.Element (Iter) /= No_Source loop\n+               Source   := Prj.Element (Iter);\n+               Excluded := Excluded_Sources_Htable.Get\n+                 (Excluded_Sources, Source.File);\n+\n+               if Excluded /= No_File_Found then\n+                  Source.Locally_Removed := True;\n+                  Source.In_Interfaces   := False;\n \n-            --  ??? Don't we have a hash table to map files to Source_Id?\n-            --  ??? Why can't simply iterate over the sources of the current\n-            --  project, as opposed to the whole tree ?\n+                  if Current_Verbosity = High then\n+                     Write_Str (\"Removing file \");\n+                     Write_Line\n+                       (Get_Name_String (Excluded.File)\n+                        & \" \" & Get_Name_String (Source.Project.Name));\n+                  end if;\n \n-            Iter := For_Each_Source (In_Tree);\n-            loop\n-               Source := Prj.Element (Iter);\n-               exit when Source = No_Source;\n+                  Excluded_Sources_Htable.Remove\n+                    (Excluded_Sources, Source.File);\n+               end if;\n \n-               if Source.File = Excluded.File then\n-                  if Source.Project = Project\n-                    or else Is_Extending (Project, Source.Project)\n-                  then\n-                     OK := True;\n-                     Source.Locally_Removed := True;\n-                     Source.In_Interfaces := False;\n+               Next (Iter);\n+            end loop;\n \n-                     if Current_Verbosity = High then\n-                        Write_Str (\"Removing file \");\n-                        Write_Line\n-                          (Get_Name_String (Excluded.File)\n-                           & \" \" & Get_Name_String (Source.Project.Name));\n-                     end if;\n+            Proj := Proj.Extends;\n+         end loop;\n \n-                  else\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"cannot remove a source from another project\",\n-                        Excluded.Location);\n-                  end if;\n+         --  If we have any excluded element left, that means we did not find\n+         --  the source file\n \n-                  --  We used to exit here, but in fact when a source is\n-                  --  overridden in an extended project we have only marked the\n-                  --  original source file if we stop here, not the one from\n-                  --  the extended project.\n-                  --  ??? We could exit (and thus be faster) if the loop could\n-                  --  be done only on the current project, but this isn't\n-                  --  compatible with the way gprbuild works with excluded\n-                  --  sources apparently\n+         Excluded := Excluded_Sources_Htable.Get_First (Excluded_Sources);\n+         while Excluded /= No_File_Found loop\n \n-                  --  exit;\n-               end if;\n+            --  Check if the file belongs to another imported project to\n+            --  provide a better error message.\n \n-               Next (Iter);\n-            end loop;\n+            Src := Find_Source\n+              (In_Tree          => In_Tree,\n+               Project          => Project,\n+               In_Imported_Only => True,\n+               Base_Name        => Excluded.File);\n \n-            OK := OK or Excluded.Found;\n+            Err_Vars.Error_Msg_File_1 := Excluded.File;\n \n-            if not OK then\n-               Err_Vars.Error_Msg_File_1 := Excluded.File;\n+            if Src = No_Source then\n                Error_Msg\n                  (Project, In_Tree, \"unknown file {\", Excluded.Location);\n+            else\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"cannot remove a source from an imported project: {\",\n+                  Excluded.Location);\n             end if;\n \n-            Excluded := Excluded_Sources_Htable.Get_Next;\n+            Excluded := Excluded_Sources_Htable.Get_Next (Excluded_Sources);\n          end loop;\n       end Mark_Excluded_Sources;\n \n@@ -7949,17 +7961,19 @@ package body Prj.Nmsc is\n \n    begin\n       Source_Names.Reset;\n-      Find_Excluded_Sources (Project, In_Tree);\n+      Find_Excluded_Sources (Project, In_Tree, Excluded_Sources);\n \n       if (Get_Mode = Ada_Only and then Is_A_Language (Project, Name_Ada))\n         or else (Get_Mode = Multi_Language\n                   and then Project.Languages /= No_Language_Index)\n       then\n          if Get_Mode = Multi_Language then\n-            Load_Naming_Exceptions (Project, In_Tree);\n+            Load_Naming_Exceptions (Project, In_Tree, Excluded_Sources);\n          end if;\n \n-         Find_Sources (Project, In_Tree, Proc_Data, Allow_Duplicate_Basenames);\n+         Find_Sources\n+           (Project, In_Tree, Proc_Data, Allow_Duplicate_Basenames,\n+            Excluded => Excluded_Sources);\n          Mark_Excluded_Sources;\n \n          if Get_Mode = Multi_Language then"}, {"sha": "85408983ddf8cfe8d2780191076974d20a0dafe5", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -469,6 +469,52 @@ package body Prj is\n       Reset (Seen);\n    end For_Every_Project_Imported;\n \n+   -----------------\n+   -- Find_Source --\n+   -----------------\n+\n+   function Find_Source\n+     (In_Tree          : Project_Tree_Ref;\n+      Project          : Project_Id;\n+      In_Imported_Only : Boolean;\n+      Base_Name        : File_Name_Type) return Source_Id\n+   is\n+      Result   : Source_Id  := No_Source;\n+\n+      procedure Look_For_Sources (Proj : Project_Id; Src : in out Source_Id);\n+      --  Look for Base_Name in the sources of Proj\n+\n+      procedure Look_For_Sources (Proj : Project_Id; Src : in out Source_Id) is\n+         Iterator : Source_Iterator;\n+      begin\n+         Iterator := For_Each_Source (In_Tree => In_Tree, Project => Proj);\n+         while Element (Iterator) /= No_Source loop\n+            if Element (Iterator).File = Base_Name then\n+               Src := Element (Iterator);\n+               return;\n+            end if;\n+            Next (Iterator);\n+         end loop;\n+      end Look_For_Sources;\n+\n+      procedure For_Imported_Projects is new For_Every_Project_Imported\n+        (State => Source_Id, Action => Look_For_Sources);\n+\n+   begin\n+      if In_Imported_Only then\n+         Look_For_Sources (Project, Result);\n+         if Result = No_Source then\n+            For_Imported_Projects\n+              (By         => Project,\n+               With_State => Result);\n+         end if;\n+      else\n+         Look_For_Sources (No_Project, Result);\n+      end if;\n+\n+      return Result;\n+   end Find_Source;\n+\n    --------------\n    -- Get_Mode --\n    --------------"}, {"sha": "375c7ba19eb11f106de804560287ce5aafaf1aa8", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -1295,6 +1295,15 @@ package Prj is\n    procedure Next (Iter : in out Source_Iterator);\n    --  Move on to the next source\n \n+   function Find_Source\n+     (In_Tree          : Project_Tree_Ref;\n+      Project          : Project_Id;\n+      In_Imported_Only : Boolean;\n+      Base_Name        : File_Name_Type) return Source_Id;\n+   --  Find the first source file with the given name either in the whole tree\n+   --  (if In_Imported_Only is False) or in the projects imported or extended\n+   --  by Project otherwise.\n+\n    -----------------------\n    -- Project_Tree_Data --\n    -----------------------"}, {"sha": "639ab8bab286289864eb42503b9c80f857f6a181", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -7600,7 +7600,7 @@ package body Sem_Res is\n \n       --  Generate cross-reference. We needed to wait until full overloading\n       --  resolution was complete to do this, since otherwise we can't tell if\n-      --  we are an Lvalue of not.\n+      --  we are an lvalue of not.\n \n       if May_Be_Lvalue (N) then\n          Generate_Reference (Entity (S), S, 'm');"}, {"sha": "77bf3110f43b6621b08951a6823030ca3fbbc214", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -7155,7 +7155,7 @@ package body Sem_Util is\n          when N_Assignment_Statement =>\n             return N = Name (P);\n \n-            --  Function call arguments are never Lvalues\n+            --  Function call arguments are never lvalues\n \n          when N_Function_Call =>\n             return False;\n@@ -7241,7 +7241,7 @@ package body Sem_Util is\n             end;\n \n          --  Test for appearing in a conversion that itself appears\n-         --  in an Lvalue context, since this should be an Lvalue.\n+         --  in an lvalue context, since this should be an lvalue.\n \n          when N_Type_Conversion =>\n             return Known_To_Be_Assigned (P);\n@@ -7276,8 +7276,8 @@ package body Sem_Util is\n             return N = Prefix (P)\n               and then Name_Implies_Lvalue_Prefix (Attribute_Name (P));\n \n-         --  For an expanded name, the name is an Lvalue if the expanded name\n-         --  is an Lvalue, but the prefix is never an Lvalue, since it is just\n+         --  For an expanded name, the name is an lvalue if the expanded name\n+         --  is an lvalue, but the prefix is never an lvalue, since it is just\n          --  the scope where the name is found.\n \n          when N_Expanded_Name        =>\n@@ -7287,11 +7287,11 @@ package body Sem_Util is\n                return False;\n             end if;\n \n-         --  For a selected component A.B, A is certainly an Lvalue if A.B is\n-         --  an Lvalue. B is a little interesting, if we have A.B:=3, there is\n-         --  some discussion as to whether B is an Lvalue or not, we choose to\n-         --  say it is. Note however that A is not an Lvalue if it is of an\n-         --  access type since this is an implicit dereference.\n+         --  For a selected component A.B, A is certainly an lvalue if A.B is.\n+         --  B is a little interesting, if we have A.B := 3, there is some\n+         --  discussion as to whether B is an lvalue or not, we choose to say\n+         --  it is. Note however that A is not an lvalue if it is of an access\n+         --  type since this is an implicit dereference.\n \n          when N_Selected_Component   =>\n             if N = Prefix (P)\n@@ -7304,8 +7304,8 @@ package body Sem_Util is\n             end if;\n \n          --  For an indexed component or slice, the index or slice bounds is\n-         --  never an Lvalue. The prefix is an Lvalue if the indexed component\n-         --  or slice is an Lvalue, except if it is an access type, where we\n+         --  never an lvalue. The prefix is an lvalue if the indexed component\n+         --  or slice is an lvalue, except if it is an access type, where we\n          --  have an implicit dereference.\n \n          when N_Indexed_Component    =>\n@@ -7317,17 +7317,17 @@ package body Sem_Util is\n                return May_Be_Lvalue (P);\n             end if;\n \n-         --  Prefix of a reference is an Lvalue if the reference is an Lvalue\n+         --  Prefix of a reference is an lvalue if the reference is an lvalue\n \n          when N_Reference            =>\n             return May_Be_Lvalue (P);\n \n-         --  Prefix of explicit dereference is never an Lvalue\n+         --  Prefix of explicit dereference is never an lvalue\n \n          when N_Explicit_Dereference =>\n             return False;\n \n-         --  Function call arguments are never Lvalues\n+         --  Function call arguments are never lvalues\n \n          when N_Function_Call =>\n             return False;\n@@ -7414,7 +7414,7 @@ package body Sem_Util is\n             end;\n \n          --  Test for appearing in a conversion that itself appears in an\n-         --  Lvalue context, since this should be an Lvalue.\n+         --  lvalue context, since this should be an lvalue.\n \n          when N_Type_Conversion =>\n             return May_Be_Lvalue (P);\n@@ -7424,7 +7424,7 @@ package body Sem_Util is\n          when N_Object_Renaming_Declaration =>\n             return True;\n \n-         --  All other references are definitely not Lvalues\n+         --  All other references are definitely not lvalues\n \n          when others =>\n             return False;"}, {"sha": "bc3915568f25f288e67e1eff917adb0932d247f1", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=b0159fbee916e3bbeb2d661b40ae4483a0bcb9b7", "patch": "@@ -475,7 +475,7 @@ package body Sem_Warn is\n            and then Present (Entity (N))\n            and then Entity (N) = Var\n          then\n-            --  If this is an Lvalue, then definitely abandon, since\n+            --  If this is an lvalue, then definitely abandon, since\n             --  this could be a direct modification of the variable.\n \n             if May_Be_Lvalue (N) then"}]}