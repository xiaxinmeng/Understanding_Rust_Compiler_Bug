{"sha": "1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2MDY0M2ExMmU5YzZkODI3OGZkODUzMWIwY2NmZGZiZTkyMGY0Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T09:23:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T09:23:49Z"}, "message": "[multiple changes]\n\n2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch4.adb (Find_Indexing_Operations): Use the underlying type\n\tof the container base type in case the container is a subtype.\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Ensure that\n\tthe selector has an entity when checking for a component of a\n\tmutable object.\n\n2016-05-02  Arnaud Charlet  <charlet@adacore.com>\n\n\tRemove dead code.\n\t* opt.ads (Latest_Ada_Only): New flag.\n\t* sem_prag.adb, par-prag.adb: Ignore pragma Ada_xx under this flag.\n\t* usage.adb, switch-c.adb: Disable support for -gnatxx under this flag.\n\t* einfo.ads (Has_Predicates, Predicate_Function):\n\tClarify that Has_Predicates does not imply that Predicate_Function\n\twill return a non-empty entity.\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Qualified_Expression): Generate a predicate\n\tcheck if type requires it.\n\t* checks.adb (Apply_Predicate_Check): Disable checks in the\n\tobject declaration created for an expression with side-effects\n\tthat requires a predicate check to prevent infinite recursion\n\tduring expansion.\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Process_Formals): Check properly the type of a\n\tformal to determine whether a given convention applies to it.\n\n2016-05-02  Doug Rupp  <rupp@adacore.com>\n\n\t* tracebak.c: Add incantations for arm-vxworks[67] traceback.\n\n2016-05-02  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb (Check_Component_Storage_Order): Make it a warning, not an\n\terror, to have a component with implicit SSO within a composite type\n\tthat has explicit SSO.\n\n2016-05-02  Bob Duff  <duff@adacore.com>\n\n\t* s-stposu.adb (Allocate_Any_Controlled): Don't lock/unlock twice.\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* repinfo.adb (List_Entities): Make procedure recursive, to\n\tprovide representation information for subprograms declared\n\twithin subprogram bodies.\n\nFrom-SVN: r235713", "tree": {"sha": "879341216a285fb6ea9e7323d335d48a7420a899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879341216a285fb6ea9e7323d335d48a7420a899"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/comments", "author": null, "committer": null, "parents": [{"sha": "0ec955c28f187b8799cfbf509eb6adf3b74be21c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec955c28f187b8799cfbf509eb6adf3b74be21c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec955c28f187b8799cfbf509eb6adf3b74be21c"}], "stats": {"total": 485, "additions": 313, "deletions": 172}, "files": [{"sha": "58115af28081cc6e6940c7d80a2f919e8b034d76", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -1,3 +1,55 @@\n+2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch4.adb (Find_Indexing_Operations): Use the underlying type\n+\tof the container base type in case the container is a subtype.\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Ensure that\n+\tthe selector has an entity when checking for a component of a\n+\tmutable object.\n+\n+2016-05-02  Arnaud Charlet  <charlet@adacore.com>\n+\n+\tRemove dead code.\n+\t* opt.ads (Latest_Ada_Only): New flag.\n+\t* sem_prag.adb, par-prag.adb: Ignore pragma Ada_xx under this flag.\n+\t* usage.adb, switch-c.adb: Disable support for -gnatxx under this flag.\n+\t* einfo.ads (Has_Predicates, Predicate_Function):\n+\tClarify that Has_Predicates does not imply that Predicate_Function\n+\twill return a non-empty entity.\n+\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Qualified_Expression): Generate a predicate\n+\tcheck if type requires it.\n+\t* checks.adb (Apply_Predicate_Check): Disable checks in the\n+\tobject declaration created for an expression with side-effects\n+\tthat requires a predicate check to prevent infinite recursion\n+\tduring expansion.\n+\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Process_Formals): Check properly the type of a\n+\tformal to determine whether a given convention applies to it.\n+\n+2016-05-02  Doug Rupp  <rupp@adacore.com>\n+\n+\t* tracebak.c: Add incantations for arm-vxworks[67] traceback.\n+\n+2016-05-02  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb (Check_Component_Storage_Order): Make it a warning, not an\n+\terror, to have a component with implicit SSO within a composite type\n+\tthat has explicit SSO.\n+\n+2016-05-02  Bob Duff  <duff@adacore.com>\n+\n+\t* s-stposu.adb (Allocate_Any_Controlled): Don't lock/unlock twice.\n+\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* repinfo.adb (List_Entities): Make procedure recursive, to\n+\tprovide representation information for subprograms declared\n+\twithin subprogram bodies.\n+\n 2016-05-02  Arnaud Charlet  <charlet@adacore.com>\n \n \t* exp_ch5.adb, layout.adb, gnatcmd.adb exp_attr.adb, make.adb,"}, {"sha": "ca499e49d440cf6940e18e7d99cff1d98d06039d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2667,8 +2667,10 @@ package body Checks is\n       S : Entity_Id;\n \n    begin\n-      if Present (Predicate_Function (Typ)) then\n+      if Predicate_Checks_Suppressed (Empty) then\n+         return;\n \n+      elsif Present (Predicate_Function (Typ)) then\n          S := Current_Scope;\n          while Present (S) and then not Is_Subprogram (S) loop\n             S := Scope (S);\n@@ -2703,8 +2705,21 @@ package body Checks is\n \n             Check_Expression_Against_Static_Predicate (N, Typ);\n \n-            Insert_Action (N,\n-              Make_Predicate_Check (Typ, Duplicate_Subexpr (N)));\n+            if Is_Entity_Name (N) then\n+               Insert_Action (N,\n+                 Make_Predicate_Check\n+                   (Typ, New_Occurrence_Of (Entity (N), Sloc (N))));\n+\n+               --  If the expression is not an entity it may have side-effects,\n+               --  and the following call will create an object declaration for\n+               --  it. We disable checks during its analysis, to prevent an\n+               --  infinite recursion.\n+\n+            else\n+               Insert_Action (N,\n+                 Make_Predicate_Check (Typ, Duplicate_Subexpr (N)),\n+                 Suppress => All_Checks);\n+            end if;\n          end if;\n       end if;\n    end Apply_Predicate_Check;"}, {"sha": "df42700c06dfd95c1be4a6e328aa86b5c1f55a44", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -1910,6 +1910,9 @@ package Einfo is\n --       Defined in type and subtype entities. Set if a pragma Predicate or\n --       Predicate aspect applies to the type or subtype, or if it inherits a\n --       Predicate aspect from its parent or progenitor types.\n+--\n+--       Note: this flag is set on both partial and full view of types to which\n+--       a Predicate pragma or aspect applies.\n \n --    Has_Primitive_Operations (Flag120) [base type only]\n --       Defined in all type entities. Set if at least one primitive operation\n@@ -3747,6 +3750,14 @@ package Einfo is\n --       which takes a single argument of the given type, and returns True if\n --       the predicate holds and False if it does not.\n --\n+--       Note: flag Has_Predicate does not imply that Predicate_Function is set\n+--       to a non-empty entity; this happens, for example, for itypes created\n+--       when instantiating generic units with private types with predicates.\n+--       However, if an explicit pragma Predicate or Predicate aspect is given\n+--       either for private or full type declaration then both Has_Predicates\n+--       and a non-empty Predicate_Function will be set on both the partial and\n+--       full views of the type.\n+--\n --       Note: the reason this is marked as a synthesized attribute is that the\n --       way this is stored is as an element of the Subprograms_For_Type field.\n "}, {"sha": "c96435ce4f85c30866dec61d0f70d15db33a0ec8", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -1269,13 +1269,6 @@ package body Freeze is\n                   & \"parent\", Err_Node);\n             end if;\n \n-         --  If enclosing composite has explicit SSO then nested composite must\n-         --  have explicit SSO as well.\n-\n-         elsif Present (ADC) and then No (Comp_ADC) then\n-            Error_Msg_N (\"nested composite must have explicit scalar \"\n-                         & \"storage order\", Err_Node);\n-\n          --  If component and composite SSO differs, check that component\n          --  falls on byte boundaries and isn't packed.\n \n@@ -1306,6 +1299,13 @@ package body Freeze is\n                Error_Msg_N\n                  (\"type of non-byte-aligned component must have same scalar \"\n                   & \"storage order as enclosing composite\", Err_Node);\n+\n+            --  Warn if specified only for the outer composite\n+\n+            elsif Present (ADC) and then No (Comp_ADC) then\n+               Error_Msg_NE\n+                 (\"scalar storage order specified for& doesn''t \"\n+                  & \"apply to component?\", Err_Node, Encl_Type);\n             end if;\n          end if;\n "}, {"sha": "6feb21c89a54a00f786e2695658da04099780549", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -112,6 +112,11 @@ package Opt is\n    --  case of some binder variables, Gnatbind.Scan_Bind_Arg may modify\n    --  the default values.\n \n+   Latest_Ada_Only : Boolean := False;\n+   --  If True, the only value valid for Ada_Version is Ada_Version_Type'Last,\n+   --  trying to specify other values will be ignored (in case of pragma\n+   --  Ada_xxx) or generate an error (in case of -gnat83/95/xx switches).\n+\n    type Ada_Version_Type is (Ada_83, Ada_95, Ada_2005, Ada_2012);\n    pragma Ordered (Ada_Version_Type);\n    --  Versions of Ada for Ada_Version below. Note that these are ordered,"}, {"sha": "56299140d4d0698fd4ed9787dc8d97b5d029af42", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -329,9 +329,11 @@ begin\n       --  Ada version syntax.\n \n       when Pragma_Ada_83 =>\n-         Ada_Version := Ada_83;\n-         Ada_Version_Explicit := Ada_83;\n-         Ada_Version_Pragma := Pragma_Node;\n+         if not Latest_Ada_Only then\n+            Ada_Version := Ada_83;\n+            Ada_Version_Explicit := Ada_83;\n+            Ada_Version_Pragma := Pragma_Node;\n+         end if;\n \n       ------------\n       -- Ada_95 --\n@@ -342,9 +344,11 @@ begin\n       --  Ada version syntax.\n \n       when Pragma_Ada_95 =>\n-         Ada_Version := Ada_95;\n-         Ada_Version_Explicit := Ada_95;\n-         Ada_Version_Pragma := Pragma_Node;\n+         if not Latest_Ada_Only then\n+            Ada_Version := Ada_95;\n+            Ada_Version_Explicit := Ada_95;\n+            Ada_Version_Pragma := Pragma_Node;\n+         end if;\n \n       ---------------------\n       -- Ada_05/Ada_2005 --\n@@ -356,7 +360,7 @@ begin\n       --  must be processed at parse time.\n \n       when Pragma_Ada_05 | Pragma_Ada_2005 =>\n-         if Arg_Count = 0 then\n+         if Arg_Count = 0 and not Latest_Ada_Only then\n             Ada_Version := Ada_2005;\n             Ada_Version_Explicit := Ada_2005;\n             Ada_Version_Pragma := Pragma_Node;"}, {"sha": "28bdc4495ac5a40ab0b2e598aad74047abc3df8e", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -135,10 +135,15 @@ package body Repinfo is\n    --  Called before outputting anything for an entity. Ensures that\n    --  a blank line precedes the output for a particular entity.\n \n-   procedure List_Entities (Ent : Entity_Id; Bytes_Big_Endian : Boolean);\n+   procedure List_Entities\n+     (Ent : Entity_Id;\n+      Bytes_Big_Endian : Boolean;\n+      In_Subprogram    : Boolean := False);\n    --  This procedure lists the entities associated with the entity E, starting\n    --  with the First_Entity and using the Next_Entity link. If a nested\n    --  package is found, entities within the package are recursively processed.\n+   --  When recursing within a subprogram body, Is_Subprogram suppresses\n+   --  duplicate information about signature.\n \n    procedure List_Name (Ent : Entity_Id);\n    --  List name of entity Ent in appropriate case. The name is listed with\n@@ -314,7 +319,11 @@ package body Repinfo is\n    -- List_Entities --\n    -------------------\n \n-   procedure List_Entities (Ent : Entity_Id; Bytes_Big_Endian : Boolean) is\n+   procedure List_Entities\n+     (Ent : Entity_Id;\n+      Bytes_Big_Endian : Boolean;\n+      In_Subprogram    : Boolean := False)\n+   is\n       Body_E : Entity_Id;\n       E      : Entity_Id;\n \n@@ -353,12 +362,15 @@ package body Repinfo is\n         and then Nkind (Declaration_Node (Ent)) not in N_Renaming_Declaration\n       then\n          --  If entity is a subprogram and we are listing mechanisms,\n-         --  then we need to list mechanisms for this entity.\n+         --  then we need to list mechanisms for this entity. We skip this\n+         --  if it is a nested subprogram, as the information has already\n+         --  been produced when listing the enclosing scope.\n \n          if List_Representation_Info_Mechanisms\n            and then (Is_Subprogram (Ent)\n                       or else Ekind (Ent) = E_Entry\n                       or else Ekind (Ent) = E_Entry_Family)\n+           and then not In_Subprogram\n          then\n             Need_Blank_Line := True;\n             List_Mechanisms (Ent);\n@@ -386,6 +398,13 @@ package body Repinfo is\n                      List_Mechanisms (E);\n                   end if;\n \n+                  --  Recurse into entities local to subprogram\n+\n+                  List_Entities (E, Bytes_Big_Endian, True);\n+\n+               elsif Ekind (E) in Formal_Kind and then In_Subprogram then\n+                  null;\n+\n                elsif Ekind_In (E, E_Entry,\n                                   E_Entry_Family,\n                                   E_Subprogram_Type)"}, {"sha": "1ea23b3304e1d374e8a0f00a20cb66b334f6ac01", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2011-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -123,9 +123,6 @@ package body System.Storage_Pools.Subpools is\n       N_Size  : Storage_Count;\n       Subpool : Subpool_Handle := null;\n \n-      Allocation_Locked : Boolean;\n-      --  This flag stores the state of the associated collection\n-\n       Header_And_Padding : Storage_Offset;\n       --  This offset includes the size of a FM_Node plus any additional\n       --  padding due to a larger alignment.\n@@ -170,25 +167,25 @@ package body System.Storage_Pools.Subpools is\n \n       else\n          --  If the master is missing, then the expansion of the access type\n-         --  failed to create one. This is a serious error.\n+         --  failed to create one. This is a compiler bug.\n \n-         if Context_Master = null then\n-            raise Program_Error\n-              with \"missing master in pool allocation\";\n+         pragma Assert\n+           (Context_Master /= null, \"missing master in pool allocation\");\n \n          --  If a subpool is present, then this is the result of erroneous\n          --  allocator expansion. This is not a serious error, but it should\n          --  still be detected.\n \n-         elsif Context_Subpool /= null then\n+         if Context_Subpool /= null then\n             raise Program_Error\n               with \"subpool not required in pool allocation\";\n+         end if;\n \n          --  If the allocation is intended to be on a subpool, but the access\n          --  type's pool does not support subpools, then this is the result of\n-         --  erroneous end-user code.\n+         --  incorrect end-user code.\n \n-         elsif On_Subpool then\n+         if On_Subpool then\n             raise Program_Error\n               with \"pool of access type does not support subpools\";\n          end if;\n@@ -209,24 +206,20 @@ package body System.Storage_Pools.Subpools is\n          --    Write - finalization\n \n          Lock_Task.all;\n-         Allocation_Locked := Finalization_Started (Master.all);\n-         Unlock_Task.all;\n \n          --  Do not allow the allocation of controlled objects while the\n          --  associated master is being finalized.\n \n-         if Allocation_Locked then\n+         if Finalization_Started (Master.all) then\n             raise Program_Error with \"allocation after finalization started\";\n          end if;\n \n          --  Check whether primitive Finalize_Address is available. If it is\n          --  not, then either the expansion of the designated type failed or\n-         --  the expansion of the allocator failed. This is a serious error.\n+         --  the expansion of the allocator failed. This is a compiler bug.\n \n-         if Fin_Address = null then\n-            raise Program_Error\n-              with \"primitive Finalize_Address not available\";\n-         end if;\n+         pragma Assert\n+           (Fin_Address /= null, \"primitive Finalize_Address not available\");\n \n          --  The size must acount for the hidden header preceding the object.\n          --  Account for possible padding space before the header due to a\n@@ -262,7 +255,7 @@ package body System.Storage_Pools.Subpools is\n       --  Step 4: Attachment\n \n       if Is_Controlled then\n-         Lock_Task.all;\n+         --  Note that we already did \"Lock_Task.all;\" in Step 2 above.\n \n          --  Map the allocated memory into a FM_Node record. This converts the\n          --  top of the allocated bits into a list header. If there is padding\n@@ -334,6 +327,16 @@ package body System.Storage_Pools.Subpools is\n       else\n          Addr := N_Addr;\n       end if;\n+\n+   exception\n+      when others =>\n+         --  If we locked, we want to unlock\n+\n+         if Is_Controlled then\n+            Unlock_Task.all;\n+         end if;\n+\n+         raise;\n    end Allocate_Any_Controlled;\n \n    ------------\n@@ -384,59 +387,67 @@ package body System.Storage_Pools.Subpools is\n       if Is_Controlled then\n          Lock_Task.all;\n \n-         --  Destroy the relation pair object - Finalize_Address since it is no\n-         --  longer needed.\n+         begin\n+            --  Destroy the relation pair object - Finalize_Address since it is\n+            --  no longer needed.\n \n-         if Finalize_Address_Table_In_Use then\n+            if Finalize_Address_Table_In_Use then\n \n-            --  Synchronization:\n-            --    Read  - finalization\n-            --    Write - allocation, deallocation\n+               --  Synchronization:\n+               --    Read  - finalization\n+               --    Write - allocation, deallocation\n \n-            Delete_Finalize_Address_Unprotected (Addr);\n-         end if;\n+               Delete_Finalize_Address_Unprotected (Addr);\n+            end if;\n \n-         --  Account for possible padding space before the header due to a\n-         --  larger alignment.\n+            --  Account for possible padding space before the header due to a\n+            --  larger alignment.\n \n-         Header_And_Padding := Header_Size_With_Padding (Alignment);\n+            Header_And_Padding := Header_Size_With_Padding (Alignment);\n \n-         --    N_Addr  N_Ptr           Addr (from input)\n-         --    |       |               |\n-         --    V       V               V\n-         --    +-------+---------------+----------------------+\n-         --    |Padding|    Header     |        Object        |\n-         --    +-------+---------------+----------------------+\n-         --    ^       ^               ^\n-         --    |       +- Header_Size -+\n-         --    |                       |\n-         --    +- Header_And_Padding --+\n+            --    N_Addr  N_Ptr           Addr (from input)\n+            --    |       |               |\n+            --    V       V               V\n+            --    +-------+---------------+----------------------+\n+            --    |Padding|    Header     |        Object        |\n+            --    +-------+---------------+----------------------+\n+            --    ^       ^               ^\n+            --    |       +- Header_Size -+\n+            --    |                       |\n+            --    +- Header_And_Padding --+\n \n-         --  Convert the bits preceding the object into a list header\n+            --  Convert the bits preceding the object into a list header\n \n-         N_Ptr := Address_To_FM_Node_Ptr (Addr - Header_Size);\n+            N_Ptr := Address_To_FM_Node_Ptr (Addr - Header_Size);\n \n-         --  Detach the object from the related finalization master. This\n-         --  action does not need to know the prior context used during\n-         --  allocation.\n+            --  Detach the object from the related finalization master. This\n+            --  action does not need to know the prior context used during\n+            --  allocation.\n \n-         --  Synchronization:\n-         --    Write - allocation, deallocation, finalization\n+            --  Synchronization:\n+            --    Write - allocation, deallocation, finalization\n \n-         Detach_Unprotected (N_Ptr);\n+            Detach_Unprotected (N_Ptr);\n \n-         --  Move the address from the object to the beginning of the list\n-         --  header.\n+            --  Move the address from the object to the beginning of the list\n+            --  header.\n \n-         N_Addr := Addr - Header_And_Padding;\n+            N_Addr := Addr - Header_And_Padding;\n \n-         --  The size of the deallocated object must include the size of the\n-         --  hidden list header.\n+            --  The size of the deallocated object must include the size of the\n+            --  hidden list header.\n \n-         N_Size := Storage_Size + Header_And_Padding;\n+            N_Size := Storage_Size + Header_And_Padding;\n \n-         Unlock_Task.all;\n+            Unlock_Task.all;\n \n+         exception\n+            when others =>\n+               --  If we locked, we want to unlock\n+\n+               Unlock_Task.all;\n+               raise;\n+         end;\n       else\n          N_Addr := Addr;\n          N_Size := Storage_Size;"}, {"sha": "e31704b818ceb7fe253aec384114a05f51a4d7ee", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -7619,12 +7619,14 @@ package body Sem_Ch4 is\n       begin\n          Typ := T;\n \n+         --  Use the specific type when the parameter type is class-wide\n+\n          if Is_Class_Wide_Type (Typ) then\n             Typ := Root_Type (Typ);\n          end if;\n \n          Ref := Empty;\n-         Typ := Underlying_Type (Typ);\n+         Typ := Underlying_Type (Base_Type (Typ));\n \n          Inspect_Primitives   (Typ, Ref);\n          Inspect_Declarations (Typ, Ref);"}, {"sha": "bdfe02e4572abce26894290dfa0feabd47827d97", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -1817,7 +1817,7 @@ package body Sem_Ch5 is\n       Bas : Entity_Id;\n       Typ : Entity_Id;\n \n-   --   Start of processing for Analyze_iterator_Specification\n+   --   Start of processing for Analyze_Iterator_Specification\n \n    begin\n       Enter_Name (Def_Id);\n@@ -2207,6 +2207,8 @@ package body Sem_Ch5 is\n                      --  be performed.\n \n                      if Nkind (Orig_Iter_Name) = N_Selected_Component\n+                       and then\n+                         Present (Entity (Selector_Name (Orig_Iter_Name)))\n                        and then Ekind_In\n                                   (Entity (Selector_Name (Orig_Iter_Name)),\n                                    E_Component,"}, {"sha": "069372259575db691ed874994b4e879cd0a35984", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -10792,24 +10792,28 @@ package body Sem_Ch6 is\n \n          --  Force call by reference if aliased\n \n-         if Is_Aliased (Formal) then\n-            Set_Mechanism (Formal, By_Reference);\n+         declare\n+            Conv : constant Convention_Id := Convention (Etype (Formal));\n+         begin\n+            if Is_Aliased (Formal) then\n+               Set_Mechanism (Formal, By_Reference);\n \n-            --  Warn if user asked this to be passed by copy\n+               --  Warn if user asked this to be passed by copy\n \n-            if Convention (Formal_Type) = Convention_Ada_Pass_By_Copy then\n-               Error_Msg_N\n-                 (\"cannot pass aliased parameter & by copy??\", Formal);\n-            end if;\n+               if Conv = Convention_Ada_Pass_By_Copy then\n+                  Error_Msg_N\n+                    (\"cannot pass aliased parameter & by copy??\", Formal);\n+               end if;\n \n-         --  Force mechanism if type has Convention Ada_Pass_By_Ref/Copy\n+            --  Force mechanism if type has Convention Ada_Pass_By_Ref/Copy\n \n-         elsif Convention (Formal_Type) = Convention_Ada_Pass_By_Copy then\n-            Set_Mechanism (Formal, By_Copy);\n+            elsif Conv = Convention_Ada_Pass_By_Copy then\n+               Set_Mechanism (Formal, By_Copy);\n \n-         elsif Convention (Formal_Type) = Convention_Ada_Pass_By_Reference then\n-            Set_Mechanism (Formal, By_Reference);\n-         end if;\n+            elsif Conv = Convention_Ada_Pass_By_Reference then\n+               Set_Mechanism (Formal, By_Reference);\n+            end if;\n+         end;\n \n       <<Next_Parameter>>\n          Next (Param_Spec);"}, {"sha": "2516df2b245dccd7c65b3ca8aaa0c06cca48d479", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -5203,32 +5203,22 @@ package body Sem_Prag is\n          Handler_Proc := Find_Unique_Parameterless_Procedure (Arg1_X, Arg1);\n          Proc_Scope := Scope (Handler_Proc);\n \n-         --  On AAMP only, a pragma Interrupt_Handler is supported for\n-         --  nonprotected parameterless procedures.\n-\n-         if not AAMP_On_Target\n-           or else Prag_Id = Pragma_Attach_Handler\n-         then\n-            if Ekind (Proc_Scope) /= E_Protected_Type then\n-               Error_Pragma_Arg\n-                 (\"argument of pragma% must be protected procedure\", Arg1);\n-            end if;\n+         if Ekind (Proc_Scope) /= E_Protected_Type then\n+            Error_Pragma_Arg\n+              (\"argument of pragma% must be protected procedure\", Arg1);\n+         end if;\n \n-            --  For pragma case (as opposed to access case), check placement.\n-            --  We don't need to do that for aspects, because we have the\n-            --  check that they aspect applies an appropriate procedure.\n+         --  For pragma case (as opposed to access case), check placement.\n+         --  We don't need to do that for aspects, because we have the\n+         --  check that they aspect applies an appropriate procedure.\n \n-            if not From_Aspect_Specification (N)\n-              and then Parent (N) /= Protected_Definition (Parent (Proc_Scope))\n-            then\n-               Error_Pragma (\"pragma% must be in protected definition\");\n-            end if;\n+         if not From_Aspect_Specification (N)\n+           and then Parent (N) /= Protected_Definition (Parent (Proc_Scope))\n+         then\n+            Error_Pragma (\"pragma% must be in protected definition\");\n          end if;\n \n-         if not Is_Library_Level_Entity (Proc_Scope)\n-           or else (AAMP_On_Target\n-                     and then not Is_Library_Level_Entity (Handler_Proc))\n-         then\n+         if not Is_Library_Level_Entity (Proc_Scope) then\n             Error_Pragma_Arg\n               (\"argument for pragma% must be library level entity\", Arg1);\n          end if;\n@@ -9027,14 +9017,9 @@ package body Sem_Prag is\n          Mark_Pragma_As_Ghost (N, Handler);\n          Set_Is_Interrupt_Handler (Handler);\n \n-         --  If the pragma is not associated with a handler procedure within a\n-         --  protected type, then it must be for a nonprotected procedure for\n-         --  the AAMP target, in which case we don't associate a representation\n-         --  item with the procedure's scope.\n+         pragma Assert (Ekind (Prot_Typ) = E_Protected_Type);\n \n-         if Ekind (Prot_Typ) = E_Protected_Type then\n-            Record_Rep_Item (Prot_Typ, N);\n-         end if;\n+         Record_Rep_Item (Prot_Typ, N);\n \n          --  Chain the pragma on the contract for completeness\n \n@@ -11064,9 +11049,11 @@ package body Sem_Prag is\n \n             --  Now set Ada 83 mode\n \n-            Ada_Version          := Ada_83;\n-            Ada_Version_Explicit := Ada_83;\n-            Ada_Version_Pragma   := N;\n+            if not Latest_Ada_Only then\n+               Ada_Version          := Ada_83;\n+               Ada_Version_Explicit := Ada_83;\n+               Ada_Version_Pragma   := N;\n+            end if;\n \n          ------------\n          -- Ada_95 --\n@@ -11096,9 +11083,11 @@ package body Sem_Prag is\n \n             --  Now set Ada 95 mode\n \n-            Ada_Version          := Ada_95;\n-            Ada_Version_Explicit := Ada_95;\n-            Ada_Version_Pragma   := N;\n+            if not Latest_Ada_Only then\n+               Ada_Version          := Ada_95;\n+               Ada_Version_Explicit := Ada_95;\n+               Ada_Version_Pragma   := N;\n+            end if;\n \n          ---------------------\n          -- Ada_05/Ada_2005 --\n@@ -11153,9 +11142,11 @@ package body Sem_Prag is\n \n                --  Now set appropriate Ada mode\n \n-               Ada_Version          := Ada_2005;\n-               Ada_Version_Explicit := Ada_2005;\n-               Ada_Version_Pragma   := N;\n+               if not Latest_Ada_Only then\n+                  Ada_Version          := Ada_2005;\n+                  Ada_Version_Explicit := Ada_2005;\n+                  Ada_Version_Pragma   := N;\n+               end if;\n             end if;\n          end;\n \n@@ -28957,12 +28948,10 @@ package body Sem_Prag is\n    begin\n       --  If first character is asterisk, this is a link name, and we leave it\n       --  completely unmodified. We also ignore null strings (the latter case\n-      --  happens only in error cases) and no encoding should occur for AAMP\n-      --  interface names.\n+      --  happens only in error cases).\n \n       if Len = 0\n         or else Get_String_Char (Str, 1) = Get_Char_Code ('*')\n-        or else AAMP_On_Target\n       then\n          Set_Interface_Name (E, S);\n "}, {"sha": "bf326bf72859b0abba80c51b625063de383330bc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -9445,6 +9445,24 @@ package body Sem_Res is\n       if Nkind (N) = N_Qualified_Expression and then Is_Scalar_Type (Typ) then\n          Apply_Scalar_Range_Check (Expr, Typ);\n       end if;\n+\n+      --  Finally, check whether a predicate applies to the target type.\n+      --  This comes from AI12-0100. As for type conversions, check the\n+      --  enclosing context to prevent an infinite expansion.\n+\n+      if Has_Predicates (Target_Typ) then\n+         if Nkind (Parent (N)) = N_Function_Call\n+           and then Present (Name (Parent (N)))\n+           and then (Is_Predicate_Function (Entity (Name (Parent (N))))\n+                       or else\n+                     Is_Predicate_Function_M (Entity (Name (Parent (N)))))\n+         then\n+            null;\n+\n+         elsif Nkind (N) = N_Qualified_Expression then\n+            Apply_Predicate_Check (N, Target_Typ);\n+         end if;\n+      end if;\n    end Resolve_Qualified_Expression;\n \n    ------------------------------"}, {"sha": "b282245ddcd22beba61224328a7d6d82ebe50aab", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1400,7 +1400,7 @@ package body Switch.C is\n \n                Ptr := Ptr + 1;\n \n-               if Switch_Chars (Ptr) /= '3' then\n+               if Switch_Chars (Ptr) /= '3' or else Latest_Ada_Only then\n                   Bad_Switch (\"-gnat8\" & Switch_Chars (Ptr .. Max));\n                else\n                   Ptr := Ptr + 1;\n@@ -1418,7 +1418,7 @@ package body Switch.C is\n \n                Ptr := Ptr + 1;\n \n-               if Switch_Chars (Ptr) /= '5' then\n+               if Switch_Chars (Ptr) /= '5' or else Latest_Ada_Only then\n                   Bad_Switch (\"-gnat9\" & Switch_Chars (Ptr .. Max));\n                else\n                   Ptr := Ptr + 1;\n@@ -1436,7 +1436,7 @@ package body Switch.C is\n \n                Ptr := Ptr + 1;\n \n-               if Switch_Chars (Ptr) /= '5' then\n+               if Switch_Chars (Ptr) /= '5' or else Latest_Ada_Only then\n                   Bad_Switch (\"-gnat0\" & Switch_Chars (Ptr .. Max));\n                else\n                   Ptr := Ptr + 1;\n@@ -1469,7 +1469,9 @@ package body Switch.C is\n                if Ptr > Max - 3 then\n                   Bad_Switch (\"-gnat\" & Switch_Chars (Ptr .. Max));\n \n-               elsif Switch_Chars (Ptr .. Ptr + 3) = \"2005\" then\n+               elsif Switch_Chars (Ptr .. Ptr + 3) = \"2005\"\n+                 and then not Latest_Ada_Only\n+               then\n                   Ada_Version := Ada_2005;\n \n                elsif Switch_Chars (Ptr .. Ptr + 3) = \"2012\" then"}, {"sha": "7532ca2d71bdf6c4cab2c1632c8d8a030ea4e526", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -300,7 +300,20 @@ __gnat_backtrace (void **array,\n #define PC_ADJUST -2\n /* The minimum size of call instructions on this architecture is 2 bytes */\n \n-/*---------------------- PPC AIX/PPC Lynx 178/Older Darwin ------------------*/\n+/*---------------------- ARM VxWorks ------------------------------------*/\n+#elif (defined (ARMEL) && defined (__vxworks))\n+\n+#include \"vxWorks.h\"\n+#include \"version.h\"\n+\n+#define USE_GCC_UNWINDER\n+#define PC_ADJUST -2\n+\n+#if (_WRS_VXWORKS_MAJOR >= 7)\n+#define USING_ARM_UNWINDING 1\n+#endif\n+\n+/*---------------------- PPC AIX/PPC Lynx 178/Older Darwin --------------*/\n #elif ((defined (_POWER) && defined (_AIX)) || \\\n        (defined (__powerpc__) && defined (__Lynx__) && !defined(__ELF__)) || \\\n        (defined (__ppc__) && defined (__APPLE__)))\n@@ -518,6 +531,12 @@ struct layout\n    The condition is expressed the way above because we cannot reliably rely on\n    any other macro from the base compiler when compiling stage1.  */\n \n+#ifdef USING_ARM_UNWINDING\n+/* This value is not part of the enumerated reason codes defined in unwind.h\n+   for ARM style unwinding, but is used in the included \"C\" code, so we\n+   define it to a reasonable value to avoid a compilation error.  */\n+#define _URC_NORMAL_STOP 0\n+#endif\n #include \"tb-gcc.c\"\n \n /*------------------------------------------------------------------*"}, {"sha": "cb7d6a386b6a1aecc5556051d5243bc98a4d0644", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60643a12e9c6d8278fd8531b0ccfdfbe920f43/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=1e60643a12e9c6d8278fd8531b0ccfdfbe920f43", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,7 +26,6 @@\n --  Warning: the output of this usage for warnings is duplicated in the GNAT\n --  reference manual. Be sure to update that if you change the warning list.\n \n-with Targparm; use Targparm;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -91,19 +90,6 @@ begin\n \n    Write_Eol;\n \n-   --  Common GCC switches not available for AAMP targets\n-\n-   if not AAMP_On_Target then\n-      Write_Switch_Char (\"fstack-check \", \"\");\n-      Write_Line (\"Generate stack checking code\");\n-\n-      Write_Switch_Char (\"fno-inline   \", \"\");\n-      Write_Line (\"Inhibit all inlining (makes executable smaller)\");\n-\n-      Write_Switch_Char (\"fpreserve-control-flow \", \"\");\n-      Write_Line (\"Preserve control flow for coverage analysis\");\n-   end if;\n-\n    --  Common switches available everywhere\n \n    Write_Switch_Char (\"g            \", \"\");\n@@ -681,29 +667,31 @@ begin\n    Write_Switch_Char (\"zr\");\n    Write_Line (\"Distribution stub generation for receiver stubs\");\n \n-   --  Line for -gnat83 switch\n+   if not Latest_Ada_Only then\n+      --  Line for -gnat83 switch\n \n-   Write_Switch_Char (\"83\");\n-   Write_Line (\"Ada 83 mode\");\n+      Write_Switch_Char (\"83\");\n+      Write_Line (\"Ada 83 mode\");\n \n-   --  Line for -gnat95 switch\n+      --  Line for -gnat95 switch\n \n-   Write_Switch_Char (\"95\");\n+      Write_Switch_Char (\"95\");\n \n-   if Ada_Version_Default = Ada_95 then\n-      Write_Line (\"Ada 95 mode (default)\");\n-   else\n-      Write_Line (\"Ada 95 mode\");\n-   end if;\n+      if Ada_Version_Default = Ada_95 then\n+         Write_Line (\"Ada 95 mode (default)\");\n+      else\n+         Write_Line (\"Ada 95 mode\");\n+      end if;\n \n-   --  Line for -gnat2005 switch\n+      --  Line for -gnat2005 switch\n \n-   Write_Switch_Char (\"2005\");\n+      Write_Switch_Char (\"2005\");\n \n-   if Ada_Version_Default = Ada_2005 then\n-      Write_Line (\"Ada 2005 mode (default)\");\n-   else\n-      Write_Line (\"Ada 2005 mode\");\n+      if Ada_Version_Default = Ada_2005 then\n+         Write_Line (\"Ada 2005 mode (default)\");\n+      else\n+         Write_Line (\"Ada 2005 mode\");\n+      end if;\n    end if;\n \n    --  Line for -gnat2012 switch"}]}