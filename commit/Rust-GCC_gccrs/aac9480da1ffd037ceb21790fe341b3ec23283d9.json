{"sha": "aac9480da1ffd037ceb21790fe341b3ec23283d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjOTQ4MGRhMWZmZDAzN2NlYjIxNzkwZmUzNDFiM2VjMjMyODNkOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-07-09T04:15:42Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-07-09T04:15:42Z"}, "message": "PR middle-end/71924 - missing -Wreturn-local-addr returning alloca result\n\nPR middle-end/71924 - missing -Wreturn-local-addr returning alloca result\nPR middle-end/90549 - missing -Wreturn-local-addr maybe returning an address of a local array plus offset\n\ngcc/ChangeLog:\n\n\tPR middle-end/71924\n\tPR middle-end/90549\n\t* gimple-ssa-isolate-paths.c (isolate_path): Add attribute.  Update\n\tcomment.\n\t(args_loc_t): New type.\n\t(args_loc_t, locmap_t): same.\n\t(diag_returned_locals): New function.\n\t(is_addr_local): Same.\n\t(handle_return_addr_local_phi_arg, warn_return_addr_local): Same.\n\t(find_implicit_erroneous_behavior): Call warn_return_addr_local_phi_arg.\n\t(find_explicit_erroneous_behavior): Call warn_return_addr_local.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/71924\n\tPR middle-end/90549\n\t* gcc.c-torture/execute/return-addr.c: New test.\n\t* gcc.dg/Wreturn-local-addr-2.c: New test.\n\t* gcc.dg/Wreturn-local-addr-4.c: New test.\n\t* gcc.dg/Wreturn-local-addr-5.c: New test.\n\t* gcc.dg/Wreturn-local-addr-6.c: New test.\n\t* gcc.dg/Wreturn-local-addr-7.c: New test.\n\t* gcc.dg/Wreturn-local-addr-8.c: New test.\n\t* gcc.dg/Wreturn-local-addr-9.c: New test.\n\t* gcc.dg/Wreturn-local-addr-10.c: New test.\n\t* gcc.dg/Walloca-4.c: Handle expected warnings.\n\t* gcc.dg/pr41551.c: Same.\n\t* gcc.dg/pr59523.c: Same.\n\t* gcc.dg/tree-ssa/pr88775-2.c: Same.\n\t* gcc.dg/tree-ssa/alias-37.c: Same.\n\t* gcc.dg/winline-7.c: Same.\n\nFrom-SVN: r273261", "tree": {"sha": "4951dd2f7b63d615f0746cec0cc0235637d4b588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4951dd2f7b63d615f0746cec0cc0235637d4b588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aac9480da1ffd037ceb21790fe341b3ec23283d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac9480da1ffd037ceb21790fe341b3ec23283d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac9480da1ffd037ceb21790fe341b3ec23283d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac9480da1ffd037ceb21790fe341b3ec23283d9/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d64aec499687f593a1bab4ae7cac843bc1d47af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d64aec499687f593a1bab4ae7cac843bc1d47af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d64aec499687f593a1bab4ae7cac843bc1d47af"}], "stats": {"total": 2084, "additions": 1989, "deletions": 95}, "files": [{"sha": "a6c99aca4b236bc9e7baf98a32b6ed3a4d412e4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -1,3 +1,17 @@\n+2019-07-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/71924\n+\tPR middle-end/90549\n+\t* gimple-ssa-isolate-paths.c (isolate_path): Add attribute.  Update\n+\tcomment.\n+\t(args_loc_t): New type.\n+\t(args_loc_t, locmap_t): same.\n+\t(diag_returned_locals): New function.\n+\t(is_addr_local): Same.\n+\t(handle_return_addr_local_phi_arg, warn_return_addr_local): Same.\n+\t(find_implicit_erroneous_behavior): Call warn_return_addr_local_phi_arg.\n+\t(find_explicit_erroneous_behavior): Call warn_return_addr_local.\n+\n 2019-07-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vect-stmts.c (scan_operand_equal_p): Look through MEM_REF"}, {"sha": "72e6c779c34e0ef00730eb1fa91b53e99d98d623", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 397, "deletions": 91, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -128,9 +128,9 @@ insert_trap (gimple_stmt_iterator *si_p, tree op)\n \n    DUPLICATE is a pre-existing duplicate, use it as BB' if it exists.\n \n-   Return BB'.  */\n+   Return BB' (which may be equal to DUPLICATE).  */\n \n-basic_block\n+ATTRIBUTE_RETURNS_NONNULL basic_block\n isolate_path (basic_block bb, basic_block duplicate,\n \t      edge e, gimple *stmt, tree op, bool ret_zero)\n {\n@@ -341,6 +341,322 @@ stmt_uses_0_or_null_in_undefined_way (gimple *stmt)\n   return false;\n }\n \n+/* Describes the property of a return statement that may return\n+   the address of one or more local variables.  The type must\n+   be safely assignable and copyable so that it can be stored in\n+   a hash_map.  */\n+class args_loc_t\n+{\n+ public:\n+\n+  args_loc_t (): nargs (), locvec (), ptr (&ptr)\n+  {\n+    locvec.create (4);\n+  }\n+\n+  args_loc_t (const args_loc_t &rhs)\n+    : nargs (rhs.nargs), locvec (rhs.locvec.copy ()), ptr (&ptr) { }\n+\n+  args_loc_t& operator= (const args_loc_t &rhs)\n+  {\n+    nargs = rhs.nargs;\n+    locvec.release ();\n+    locvec = rhs.locvec.copy ();\n+    return *this;\n+  }\n+\n+  ~args_loc_t ()\n+  {\n+    locvec.release ();\n+    gcc_assert (ptr == &ptr);\n+  }\n+\n+  /* For a PHI in a return statement its number of arguments.  When greater\n+     than LOCVEC.LENGTH () implies that an address of one of the locals in\n+     LOCVEC may but need not be returned by the statement.  Otherwise,\n+     unless both are zero, it implies it definitely is returned.  */\n+  unsigned nargs;\n+  /* The locations of local variables/alloca calls returned by the return\n+     statement.  Avoid using auto_vec here since it's not safe to copy due\n+     to pr90904.  */\n+  vec <location_t> locvec;\n+  void *ptr;\n+};\n+\n+/* A mapping from a return statement to the locations of local variables\n+   whose addresses it may return.  */\n+typedef hash_map <gimple *, args_loc_t> locmap_t;\n+\n+/* Given the LOCMAP mapping, issue diagnostics about returning addresses\n+   of local variables.  When MAYBE is set, all diagnostics will be of\n+   the \"may return\" kind.  Otherwise each will be determined based on\n+   the equality of the corresponding NARGS and LOCVEC.LENGTH () values.  */\n+\n+static void\n+diag_returned_locals (bool maybe, const locmap_t &locmap)\n+{\n+  for (locmap_t::iterator it = locmap.begin (); it != locmap.end (); ++it)\n+    {\n+      gimple *stmt = (*it).first;\n+      const args_loc_t &argsloc = (*it).second;\n+      location_t stmtloc = gimple_location (stmt);\n+\n+      auto_diagnostic_group d;\n+      unsigned nargs = argsloc.locvec.length ();\n+      if (warning_at (stmtloc, OPT_Wreturn_local_addr,\n+\t\t      (maybe || argsloc.nargs > nargs\n+\t\t       ? G_(\"function may return address of local variable\")\n+\t\t       : G_(\"function returns address of local variable\"))))\n+\t{\n+\t  for (unsigned i = 0; i != nargs; ++i)\n+\t    inform (argsloc.locvec[i], \"declared here\");\n+\t}\n+    }\n+}\n+\n+/* Return true if EXPR is an expression of pointer type that refers\n+   to the address of one or more variables with automatic storage\n+   duration.  If so, add an entry to *PLOCMAP and insert into\n+   PLOCMAP->LOCVEC the locations of the corresponding local variables\n+   whose address is returned by the RETURN_STMT (which may be set to\n+   (gimple*)-1 as a placeholder for such a statement).  VISITED is\n+   a bitmap of PHI nodes already visited by recursive calls.  When\n+   null, PHI expressions are not considered.  */\n+\n+static bool\n+is_addr_local (gimple *return_stmt, tree exp, locmap_t *plocmap,\n+\t       hash_set<gphi *> *visited)\n+{\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    {\n+      tree baseaddr = get_base_address (TREE_OPERAND (exp, 0));\n+      if (TREE_CODE (baseaddr) == MEM_REF)\n+\treturn is_addr_local (return_stmt, TREE_OPERAND (baseaddr, 0),\n+\t\t\t      plocmap, visited);\n+\n+      if ((!VAR_P (baseaddr)\n+\t   || is_global_var (baseaddr))\n+\t  && TREE_CODE (baseaddr) != PARM_DECL)\n+\treturn false;\n+\n+      args_loc_t &argsloc = plocmap->get_or_insert (return_stmt);\n+      argsloc.locvec.safe_push (DECL_SOURCE_LOCATION (baseaddr));\n+      return true;\n+    }\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (exp)))\n+    return false;\n+\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (exp);\n+      enum gimple_code code = gimple_code (def_stmt);\n+\n+      if (is_gimple_assign (def_stmt))\n+\t{\n+\t  tree type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n+\t  if (POINTER_TYPE_P (type))\n+\t    {\n+\t      tree_code code = gimple_assign_rhs_code (def_stmt);\n+\t      tree ptr1 = NULL_TREE, ptr2 = NULL_TREE;\n+\n+\t      /* Set to the number of arguments examined that should\n+\t\t be added to ARGSLOC->NARGS to identify expressions\n+\t\t only some but not all of whose operands refer to local\n+\t\t addresses.  */\n+\t      unsigned nargs = 0;\n+\t      if (code == COND_EXPR)\n+\t\t{\n+\t\t  ptr1 = gimple_assign_rhs2 (def_stmt);\n+\t\t  ptr2 = gimple_assign_rhs3 (def_stmt);\n+\t\t  nargs = 2;\n+\t\t}\n+\t      else if (code == MAX_EXPR || code == MIN_EXPR)\n+\t\t{\n+\t\t  ptr1 = gimple_assign_rhs1 (def_stmt);\n+\t\t  ptr2 = gimple_assign_rhs2 (def_stmt);\n+\t\t  nargs = 2;\n+\t\t}\n+\t      else if (code == ADDR_EXPR\n+\t\t       || code == NOP_EXPR\n+\t\t       || code == POINTER_PLUS_EXPR)\n+\t\t/* Leave NARGS at zero and let the recursive call set it.  */\n+\t\tptr1 = gimple_assign_rhs1 (def_stmt);\n+\n+\t      /* Avoid short-circuiting the logical OR result in case\n+\t\t both operands refer to local variables, in which case\n+\t\t both should be considered and identified in the warning.  */\n+\t      bool res1 = false, res2 = false;\n+\t      if (ptr1)\n+\t\tres1 = is_addr_local (return_stmt, ptr1, plocmap, visited);\n+\t      if (ptr2)\n+\t\tres2 = is_addr_local (return_stmt, ptr2, plocmap, visited);\n+\n+\t      if (nargs)\n+\t\tif (args_loc_t *argsloc = plocmap->get (return_stmt))\n+\t\t  argsloc->nargs += nargs;\n+\n+\t      return res1 || res2;\n+\t    }\n+\t  return false;\n+\t}\n+\n+      if (code == GIMPLE_CALL\n+\t  && gimple_call_builtin_p (def_stmt))\n+\t{\n+\t  /* Handle alloca and friends that return pointers to automatic\n+\t     storage.  */\n+\t  tree fn = gimple_call_fndecl (def_stmt);\n+\t  int code = DECL_FUNCTION_CODE (fn);\n+\t  if (code == BUILT_IN_ALLOCA\n+\t      || code == BUILT_IN_ALLOCA_WITH_ALIGN\n+\t      || code == BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX)\n+\t    {\n+\t      args_loc_t &argsloc = plocmap->get_or_insert (return_stmt);\n+\t      argsloc.locvec.safe_push (gimple_location (def_stmt));\n+\t      return true;\n+\t    }\n+\n+\t  if (gimple_call_num_args (def_stmt) < 1)\n+\t    return false;\n+\n+\t  /* Recursively examine the first argument of calls to built-ins\n+\t     that return it.  */\n+\t  switch (code)\n+\t    {\n+\t    case BUILT_IN_MEMCPY:\n+\t    case BUILT_IN_MEMCPY_CHK:\n+\t    case BUILT_IN_MEMPCPY:\n+\t    case BUILT_IN_MEMPCPY_CHK:\n+\t    case BUILT_IN_MEMMOVE:\n+\t    case BUILT_IN_MEMMOVE_CHK:\n+\t    case BUILT_IN_STPCPY:\n+\t    case BUILT_IN_STPCPY_CHK:\n+\t    case BUILT_IN_STPNCPY:\n+\t    case BUILT_IN_STPNCPY_CHK:\n+\t    case BUILT_IN_STRCAT:\n+\t    case BUILT_IN_STRCAT_CHK:\n+\t    case BUILT_IN_STRCHR:\n+\t    case BUILT_IN_STRCPY:\n+\t    case BUILT_IN_STRCPY_CHK:\n+\t    case BUILT_IN_STRNCAT:\n+\t    case BUILT_IN_STRNCAT_CHK:\n+\t    case BUILT_IN_STRNCPY:\n+\t    case BUILT_IN_STRNCPY_CHK:\n+\t    case BUILT_IN_STRRCHR:\n+\t    case BUILT_IN_STRSTR:\n+\t      return is_addr_local (return_stmt,\n+\t\t\t\t    gimple_call_arg (def_stmt, 0),\n+\t\t\t\t    plocmap, visited);\n+\t    default:\n+\t      return false;\n+\t    }\n+\t}\n+\n+      if (code == GIMPLE_PHI && visited)\n+\t{\n+\t  gphi *phi_stmt = as_a <gphi *> (def_stmt);\n+\t  if (visited->add (phi_stmt))\n+\t    return false;\n+\n+\t  unsigned count = 0;\n+\t  unsigned nargs = gimple_phi_num_args (phi_stmt);\n+\t  args_loc_t &argsloc = plocmap->get_or_insert (return_stmt);\n+\t  /* Bump up the number of operands examined by the number of\n+\t     operands of this PHI.  */\n+\t  argsloc.nargs += nargs;\n+\t  for (unsigned i = 0; i < gimple_phi_num_args (phi_stmt); ++i)\n+\t    {\n+\t      tree arg = gimple_phi_arg_def (phi_stmt, i);\n+\t      if (is_addr_local (return_stmt, arg, plocmap, visited))\n+\t\t++count;\n+\t    }\n+\t  return count != 0;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Detect returning the address of a local variable in a PHI result LHS\n+   and argument ARG and PHI edge E in basic block BB.  Add an entry for\n+   each use to LOCMAP, setting its NARGS member to the NARGS argument\n+   (the number of PHI operands) plus the number of arguments in binary\n+   expressions refereced by ARG.  Call isolate_path for each returned\n+   address and set *ISOLATED to true if called.\n+   Return either DUPLICATE or the most recent result of isolate_path.  */\n+\n+static basic_block\n+handle_return_addr_local_phi_arg (basic_block bb, basic_block duplicate,\n+\t\t\t\t  tree lhs, tree arg, edge e, locmap_t &locmap,\n+\t\t\t\t  unsigned nargs, bool *isolated)\n+{\n+  /* Use (gimple*)-1 as a temporary placeholder and replace it with\n+     the return statement below once it is known.  Using a null doesn't\n+     work because it's used by the hash_map to mean \"no-entry.\"  Pass\n+     null instead of a visited_phis bitmap to avoid descending into\n+     PHIs since they are being processed by the caller.  Those that\n+     remain will be checked again later.  */\n+  if (!is_addr_local ((gimple*)-1, arg, &locmap, NULL))\n+    {\n+      /* Remove the placeholder regardless of success or failure.  */\n+      locmap.remove ((gimple*)-1);\n+      return duplicate;\n+    }\n+\n+  const args_loc_t* const placeargsloc = locmap.get ((gimple*)-1);\n+  const unsigned nlocs = placeargsloc->locvec.length ();\n+  gcc_assert (nlocs);\n+\n+  /* Add to the number of PHI arguments determined by the caller\n+     the number of operands of the expressions referenced by ARG.\n+     This lets the caller determine whether it's dealing with\n+     a \"may return\" or \"definitely returns.\"  */\n+  nargs += placeargsloc->nargs;\n+\n+  /* Set to true if any expressions referenced by ARG involve\n+     multiple addresses only some of which are those of locals.  */\n+  bool maybe = placeargsloc->nargs > placeargsloc->locvec.length ();\n+\n+  gimple *use_stmt;\n+  imm_use_iterator iter;\n+\n+  /* Look for uses of the PHI result LHS in return statements.  */\n+  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+    {\n+      greturn *return_stmt = dyn_cast <greturn *> (use_stmt);\n+      if (!return_stmt)\n+\tcontinue;\n+\n+      if (gimple_return_retval (return_stmt) != lhs)\n+\tcontinue;\n+\n+      /* Add an entry for the return statement and the locations\n+\t oof the PHI arguments obtained above to the map.  */\n+      args_loc_t &argsloc = locmap.get_or_insert (use_stmt);\n+      argsloc.nargs = nargs;\n+      unsigned nelts = argsloc.locvec.length () + nlocs;\n+      argsloc.locvec.reserve (nelts);\n+      argsloc.locvec.splice (placeargsloc->locvec);\n+\n+      if (!maybe\n+\t  && (flag_isolate_erroneous_paths_dereference\n+\t      || flag_isolate_erroneous_paths_attribute)\n+\t  && gimple_bb (use_stmt) == bb)\n+\t{\n+\t  duplicate = isolate_path (bb, duplicate, e,\n+\t\t\t\t    use_stmt, lhs, true);\n+\n+\t  /* Let caller know the path has been isolated.  */\n+\t  *isolated = true;\n+\t}\n+    }\n+\n+  locmap.remove ((gimple*)-1);\n+\n+  return duplicate;\n+}\n+\n /* Look for PHI nodes which feed statements in the same block where\n    the value of the PHI node implies the statement is erroneous.\n \n@@ -352,6 +668,8 @@ stmt_uses_0_or_null_in_undefined_way (gimple *stmt)\n static void\n find_implicit_erroneous_behavior (void)\n {\n+  locmap_t locmap;\n+\n   basic_block bb;\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -388,70 +706,46 @@ find_implicit_erroneous_behavior (void)\n \t  gphi *phi = si.phi ();\n \t  tree lhs = gimple_phi_result (phi);\n \n+\t  /* Initial number of PHI arguments.  The result may change\n+\t     from one iteration of the loop below to the next in\n+\t     response to changes to the CFG but only the initial\n+\t     value is stored below for use by diagnostics.  */\n+\t  unsigned nargs = gimple_phi_num_args (phi);\n+\n \t  /* PHI produces a pointer result.  See if any of the PHI's\n \t     arguments are NULL.\n \n \t     When we remove an edge, we want to reprocess the current\n-\t     index, hence the ugly way we update I for each iteration.  */\n+\t     index since the argument at that index will have been\n+\t     removed, hence the ugly way we update I for each iteration.  */\n \t  basic_block duplicate = NULL;\n \t  for (unsigned i = 0, next_i = 0;\n-\t       i < gimple_phi_num_args (phi);\n-\t       i = next_i)\n+\t       i < gimple_phi_num_args (phi); i = next_i)\n \t    {\n-\t      tree op = gimple_phi_arg_def (phi, i);\n+\t      tree arg = gimple_phi_arg_def (phi, i);\n \t      edge e = gimple_phi_arg_edge (phi, i);\n-\t      imm_use_iterator iter;\n-\t      gimple *use_stmt;\n \n+\t      /* Advance the argument index unless a path involving\n+\t\t the current argument has been isolated.  */\n \t      next_i = i + 1;\n-\n-\t      if (TREE_CODE (op) == ADDR_EXPR)\n+\t      bool isolated = false;\n+\t      duplicate = handle_return_addr_local_phi_arg (bb, duplicate, lhs,\n+\t\t\t\t\t\t\t    arg, e, locmap,\n+\t\t\t\t\t\t\t    nargs, &isolated);\n+\t      if (isolated)\n \t\t{\n-\t\t  tree valbase = get_base_address (TREE_OPERAND (op, 0));\n-\t\t  if ((VAR_P (valbase) && !is_global_var (valbase))\n-\t\t      || TREE_CODE (valbase) == PARM_DECL)\n-\t\t    {\n-\t\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-\t\t\t{\n-\t\t\t  greturn *return_stmt\n-\t\t\t    = dyn_cast <greturn *> (use_stmt);\n-\t\t\t  if (!return_stmt)\n-\t\t\t    continue;\n-\n-\t\t\t  if (gimple_return_retval (return_stmt) != lhs)\n-\t\t\t    continue;\n-\n-\t\t\t  {\n-\t\t\t    auto_diagnostic_group d;\n-\t\t\t    if (warning_at (gimple_location (use_stmt),\n-\t\t\t\t\t      OPT_Wreturn_local_addr,\n-\t\t\t\t\t      \"function may return address \"\n-\t\t\t\t\t      \"of local variable\"))\n-\t\t\t      inform (DECL_SOURCE_LOCATION(valbase),\n-\t\t\t\t\t\"declared here\");\n-\t\t\t  }\n-\n-\t\t\t  if ((flag_isolate_erroneous_paths_dereference\n-\t\t\t       || flag_isolate_erroneous_paths_attribute)\n-\t\t\t      && gimple_bb (use_stmt) == bb)\n-\t\t\t    {\n-\t\t\t      duplicate = isolate_path (bb, duplicate, e,\n-\t\t\t\t\t\t\tuse_stmt, lhs, true);\n-\n-\t\t\t      /* When we remove an incoming edge, we need to\n-\t\t\t\t reprocess the Ith element.  */\n-\t\t\t      next_i = i;\n-\t\t\t      cfg_altered = true;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n+\t\t  cfg_altered = true;\n+\t\t  next_i = i;\n \t\t}\n \n-\t      if (!integer_zerop (op))\n+\t      if (!integer_zerop (arg))\n \t\tcontinue;\n \n \t      location_t phi_arg_loc = gimple_phi_arg_location (phi, i);\n \n+\t      imm_use_iterator iter;\n+\t      gimple *use_stmt;\n+\n \t      /* We've got a NULL PHI argument.  Now see if the\n  \t         PHI's result is dereferenced within BB.  */\n \t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n@@ -480,6 +774,57 @@ find_implicit_erroneous_behavior (void)\n \t    }\n \t}\n     }\n+\n+  diag_returned_locals (false, locmap);\n+}\n+\n+/* Detect and diagnose returning the address of a local variable\n+   in RETURN_STMT in basic block BB.  This only becomes undefined\n+   behavior if the result is used, so we do not insert a trap and\n+   only return NULL instead.  */\n+\n+static void\n+warn_return_addr_local (basic_block bb, greturn *return_stmt)\n+{\n+  tree val = gimple_return_retval (return_stmt);\n+  if (!val)\n+    return;\n+\n+  locmap_t locmap;\n+  hash_set<gphi *> visited_phis;\n+  if (!is_addr_local (return_stmt, val, &locmap, &visited_phis))\n+    return;\n+\n+  /* We only need it for this particular case.  */\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n+  const args_loc_t *argsloc = locmap.get (return_stmt);\n+  gcc_assert (argsloc);\n+\n+  bool maybe = argsloc->nargs > argsloc->locvec.length ();\n+  if (!maybe)\n+    maybe = !dominated_by_p (CDI_POST_DOMINATORS,\n+\t\t\t     single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)), bb);\n+\n+  diag_returned_locals (maybe, locmap);\n+\n+  /* Bail if the statement isn't certain to return the address\n+     of a local (e.g., if it involves a conditional expression\n+     that wasn't trasnformed into a PHI or if it involves\n+     a MAX_EXPR or MIN_EXPR only one of whose operands is a local\n+     (even though such an expression isn't valid in C or has\n+     defined semantics in C++).  */\n+  if (maybe)\n+    return;\n+\n+  /* Do not modify code if the user only asked for warnings.  */\n+  if (flag_isolate_erroneous_paths_dereference\n+      || flag_isolate_erroneous_paths_attribute)\n+    {\n+      tree zero = build_zero_cst (TREE_TYPE (val));\n+      gimple_return_set_retval (return_stmt, zero);\n+      update_stmt (return_stmt);\n+    }\n }\n \n /* Look for statements which exhibit erroneous behavior.  For example\n@@ -525,49 +870,10 @@ find_explicit_erroneous_behavior (void)\n \t      break;\n \t    }\n \n-\t  /* Detect returning the address of a local variable.  This only\n-\t     becomes undefined behavior if the result is used, so we do not\n-\t     insert a trap and only return NULL instead.  */\n+\t  /* Look for a return statement that returns the address\n+\t     of a local variable or the result of alloca.  */\n \t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n-\t    {\n-\t      tree val = gimple_return_retval (return_stmt);\n-\t      if (val && TREE_CODE (val) == ADDR_EXPR)\n-\t\t{\n-\t\t  tree valbase = get_base_address (TREE_OPERAND (val, 0));\n-\t\t  if ((VAR_P (valbase) && !is_global_var (valbase))\n-\t\t      || TREE_CODE (valbase) == PARM_DECL)\n-\t\t    {\n-\t\t      /* We only need it for this particular case.  */\n-\t\t      calculate_dominance_info (CDI_POST_DOMINATORS);\n-\t\t      const char* msg;\n-\t\t      bool always_executed = dominated_by_p\n-\t\t\t(CDI_POST_DOMINATORS,\n-\t\t\t single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)), bb);\n-\t\t      if (always_executed)\n-\t\t\tmsg = N_(\"function returns address of local variable\");\n-\t\t      else\n-\t\t\tmsg = N_(\"function may return address of \"\n-\t\t\t\t \"local variable\");\n-\t\t      {\n-\t\t\tauto_diagnostic_group d;\n-\t\t\tif (warning_at (gimple_location (stmt),\n-\t\t\t\t\t  OPT_Wreturn_local_addr, msg))\n-\t\t\t  inform (DECL_SOURCE_LOCATION(valbase),\n-\t\t\t\t  \"declared here\");\n-\t\t      }\n-\n-\t\t      /* Do not modify code if the user only asked for\n-\t\t\t warnings.  */\n-\t\t      if (flag_isolate_erroneous_paths_dereference\n-\t\t\t  || flag_isolate_erroneous_paths_attribute)\n-\t\t\t{\n-\t\t\t  tree zero = build_zero_cst (TREE_TYPE (val));\n-\t\t\t  gimple_return_set_retval (return_stmt, zero);\n-\t\t\t  update_stmt (stmt);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n+\t    warn_return_addr_local (bb, return_stmt);\n \t}\n     }\n }"}, {"sha": "2941e438c43c877c4fea5f3328d3f8f7af308475", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -1,3 +1,23 @@\n+2019-07-08  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/71924\n+\tPR middle-end/90549\n+\t* gcc.c-torture/execute/return-addr.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-2.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-4.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-5.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-6.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-7.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-8.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-9.c: New test.\n+\t* gcc.dg/Wreturn-local-addr-10.c: New test.\n+\t* gcc.dg/Walloca-4.c: Handle expected warnings.\n+\t* gcc.dg/pr41551.c: Same.\n+\t* gcc.dg/pr59523.c: Same.\n+\t* gcc.dg/tree-ssa/pr88775-2.c: Same.\n+\t* gcc.dg/tree-ssa/alias-37.c: Same.\n+\t* gcc.dg/winline-7.c: Same.\n+\n 2019-07-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/vect/simd-6.cc: Replace xfail with target x86."}, {"sha": "7981818b3be9f5e1c75f59b540a8a6a8a0db09e9", "filename": "gcc/testsuite/gcc.c-torture/execute/return-addr.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Freturn-addr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Freturn-addr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Freturn-addr.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,122 @@\n+/* Test to verify that a function that returns either the address\n+   of a local variable or a non-local via a MAX_EXPR or MIN_EXPR\n+   doesn't return null when the result of the expression is\n+   the latter.  */\n+\n+#define NOIPA __attribute__ ((noclone, noinline, noipa))\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+/* Return a bigger value than P.  The address still points (just\n+   past) the local variable pointed to by P so the caller does\n+   return the address of a local variable but that's hidden from\n+   GCC by the attribute and the point of the test is to verify\n+   that the address in the return statement in the caller isn't\n+   replaced by null when GCC cannot prove the address doesn't\n+   reference a non-local variable.  */\n+\n+NOIPA char* get_max_2 (char *p)\n+{\n+  return p + 1;\n+}\n+\n+NOIPA char* get_max_3 (char *p, char *q)\n+{\n+  return p < q ? q + 1 : p + 1;\n+}\n+\n+/* Analogous to the above.  The expressions are undefined because\n+   they form an address prior to the beginning of the object but\n+   it's hidden from GCC by the attributes.  */\n+\n+NOIPA char* get_min_2 (char *p)\n+{\n+  return p - 1;\n+}\n+\n+NOIPA char* get_min_3 (char *p, char *q)\n+{\n+  return p < q ? p - 1 : q - 1;\n+}\n+\n+\n+NOIPA void* test_max_2 (void)\n+{\n+  char c;\n+\n+  char *p = get_max_2 (&c);\n+\n+  void *q = p > &c ? p : &c;  /* MAX_EXPR */\n+  return q;\n+}\n+\n+NOIPA void* test_max_3 (void)\n+{\n+  char c;\n+  char d;\n+\n+  char *p = get_max_3 (&c, &d);\n+\n+  void *q = p < &c ? &c < &d ? &d : &c : p;\n+  return q;\n+}\n+\n+NOIPA void* test_min_2 (void)\n+{\n+  char c;\n+\n+  char *p = get_min_2 (&c);\n+\n+  void *q = p < &c ? p : &c;  /* MIN_EXPR\" */\n+  return q;\n+}\n+\n+NOIPA void* test_min_3 (void)\n+{\n+  char c;\n+  char d;\n+\n+  char *p = get_min_3 (&c, &d);\n+\n+  void *q = p > &c ? &c > &d ? &d : &c : p;\n+  return q;\n+}\n+\n+NOIPA void* test_min_3_phi (int i)\n+{\n+  char a, b;\n+\n+  char *p0 = &a;\n+  char *p1 = &b;\n+  char *p2 = get_min_3 (&a, &b);\n+  char *p3 = get_min_3 (&a, &b);\n+\n+  char *p4 = p2 < p0 ? p2 : p0;\n+  char *p5 = p3 < p1 ? p3 : p1;\n+\n+  __builtin_printf (\"%p %p %p %p\\n\", p2, p3, p4, p5);\n+\n+  if (i == 1)\n+    return p4;\n+  else\n+    return p5;\n+}\n+\n+int main ()\n+{\n+  A (0 != test_max_2 ());\n+  A (0 != test_max_3 ());\n+\n+  A (0 != test_min_2 ());\n+  A (0 != test_min_3 ());\n+\n+  A (0 != test_min_3_phi (0));\n+}"}, {"sha": "1fbed597b98a573b156c9d87c5b22aa8b00ca29d", "filename": "gcc/testsuite/gcc.dg/Walloca-4.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloca-4.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -7,11 +7,12 @@\n {\n \n   char *src;\n- _Bool \n-      use_alloca = (((rear_ptr - w) * sizeof (char)) < 4096U);\n- if (use_alloca)\n+  _Bool use_alloca = (((rear_ptr - w) * sizeof (char)) < 4096U);\n+  if (use_alloca)\n     src = (char *) __builtin_alloca ((rear_ptr - w) * sizeof (char));\n   else\n     src = (char *) __builtin_malloc ((rear_ptr - w) * sizeof (char));\n   return src;\n }\n+\n+/* { dg-prune-output \"-Wreturn-local-addr\" } */"}, {"sha": "ddd2c36cf1fb2e494cf78d147c6ba50e06f5fb6e", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-10.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-10.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,56 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   Test reduced from libstdc++-v3/testsuite/ext/ext_pointer/1.cc.\n+   It verifies that iteration in find_implicit_erroneous_behavior\n+   in gimple-ssa-isolate-path.c terminates under specific conditions.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+struct A { int i; };\n+struct P { uintptr_t d; };\n+\n+static inline struct A* get (const struct P *p)\n+{\n+  if (p->d == 1)\n+    return 0;\n+\n+  return (struct A*)((uintptr_t)p + p->d);\n+}\n+\n+static inline void set (struct P *p, struct A* q)\n+{\n+  /* The basic block below would cause an infinite loop in\n+     find_implicit_erroneous_behavior due to assuming the DUPLICATE\n+     pointer returned from isolate_path would distinct from the one\n+     passed to it.  (Replacing the if statement with the ternary ?:\n+     expression did not have this effect (it gets optimized early\n+     on).\n+    <bb 4> [local count: 1073741823]:\n+    # _14 = PHI <0B(2), &MEM <struct A[2]> [(void *)&a + 4B](3)>\n+    _2 = _14->i;\n+    if (_2 != 2)\n+      goto <bb 5>; [0.00%]\n+    else\n+      goto <bb 6>; [100.00%]\n+  */\n+  if (!q)\n+    p->d = 1;\n+  else\n+    p->d = (uintptr_t)(q) - (uintptr_t)(p);\n+}\n+\n+void f (void)\n+{\n+  struct A a[2] = { { 1 }, { 2 } };\n+\n+  struct P p, q;\n+  set (&p, a);\n+  set (&q, get (&p));\n+\n+  set (&q, get (&q) + 0);\n+  set (&q, get (&q) + 1);\n+\n+  if (get (&q)[0].i != get (&p)[1].i)\n+    __builtin_abort ();\n+}"}, {"sha": "0e3435c825686cc1cca57898a448c81305e3d9d4", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-2.c", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-2.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,293 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+struct A { int a, b, c; };\n+struct B { int a, b, c[]; };\n+\n+void sink (void*, ...);\n+\n+ATTR (noipa) void*\n+return_alloca (int n)\n+{\n+  void *p = __builtin_alloca (n);\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_index_cst (int n)\n+{\n+  int *p = (int*)__builtin_alloca (n);\n+  p = &p[1];\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_plus_cst (int n)\n+{\n+  int *p = (int*)__builtin_alloca (n);\n+  p += 1;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_plus_var (int n, int i)\n+{\n+  char *p = (char*)__builtin_alloca (n);\n+  p += i;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_member_1 (int n)\n+{\n+  struct A *p = (struct A*)__builtin_alloca (n);\n+  sink (&p->a);\n+  return &p->a;     /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_member_2 (int n)\n+{\n+  struct A *p = (struct A*)__builtin_alloca (n);\n+  sink (&p->b);\n+  return &p->b;     /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_flexarray (int n)\n+{\n+  struct B *p = (struct B*)__builtin_alloca (n);\n+  sink (p->c);\n+  return p->c;      /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+\n+ATTR (noipa) void*\n+return_array (void)\n+{\n+  int a[32];\n+  void *p = a;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_index_cst (void)\n+{\n+  int a[32];\n+  void *p = &a[2];\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_plus_cst (void)\n+{\n+  int a[32];\n+  void *p = a + 2;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_plus_var (int i)\n+{\n+  int a[32];\n+  void *p = a + i;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_member_1 (void)\n+{\n+  struct A a[2];\n+  int *p = &a[1].a;\n+  sink (a, p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_member_2 (void)\n+{\n+  struct A a[32];\n+  int *p = &a[1].b;\n+  sink (a, p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+\n+ATTR (noipa) void*\n+return_vla (int n)\n+{\n+  char a[n];\n+  void *p = a;\n+  sink (p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_vla_index_cst (int n)\n+{\n+  char a[n];\n+  char *p = &a[3];\n+  sink (p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_vla_plus_cst (int n)\n+{\n+  char a[n];\n+  char *p = a + 3;\n+  sink (p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_vla_index_var (int n, int i)\n+{\n+  char a[n];\n+  char *p = &a[i];\n+  sink (p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_vla_plus_var (int n, int i)\n+{\n+  char a[n];\n+  char *p = a + i;\n+  sink (p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_vla_member_1 (int n, int i)\n+{\n+  struct A a[n];\n+  void *p = &a[i].a;\n+  sink (a, p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_vla_member_2 (int n, int i)\n+{\n+  struct A a[n];\n+  void *p = &a[i].b;\n+  sink (a, p);\n+  return p;   /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+\n+ATTR (noipa) void*\n+return_alloca_or_alloca (int n, int i)\n+{\n+  void *p = i ? __builtin_alloca (n * i) : __builtin_alloca (n);\n+  sink (p);\n+  /* The warning here should really be \"function returns\".  */\n+  return p;   /* { dg-warning \"function (returns|may return) address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_or_alloca_2 (int n, int i)\n+{\n+  void *p0 = __builtin_alloca (n);\n+  void *p1 = __builtin_alloca (n * 2);\n+  void *p = i ? p0 : p1;\n+  sink (p0, p1, p);\n+  /* Same as above.  */\n+  return p;   /* { dg-warning \"function (returns|may return) address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_or_array (int i)\n+{\n+  int a[5];\n+  int b[7];\n+  void *p = i ? a : b;\n+  sink (a, b, p);\n+  /* The warning here should really be \"function returns\".  */\n+  return p;   /* { dg-warning \"function (returns|may return) address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_array_or_array_plus_var (int i, int j)\n+{\n+  int a[5];\n+  int b[7];\n+\n+  void *p0 = a + i;\n+  void *p1 = b + j;\n+\n+  void *p = i < j ? p0 : p1;\n+  sink (a, b, p0, p1, p);\n+  /* The warning here should really be \"function returns\".  */\n+  return p;   /* { dg-warning \"function (returns|may return) address of local\" } */\n+}\n+\n+extern int global[32];\n+\n+ATTR (noipa) void*\n+may_return_global_or_alloca (int n, int i)\n+{\n+  void *p = i ? global : __builtin_alloca (n);\n+  sink (p);\n+  return p;   /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+\n+ATTR (noipa) void*\n+may_return_global_or_alloca_plus_cst (int n, int i)\n+{\n+  int *p = i ? global : (int*)__builtin_alloca (n);\n+  p += 7;\n+  sink (p);\n+  return p;   /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+may_return_global_or_array (int n, int i)\n+{\n+  int a[32];\n+  void *p = i ? global : a;\n+  sink (p);\n+  return p;   /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+may_return_global_or_array_plus_cst (int n, int i)\n+{\n+  int a[32];\n+  int *p = i ? global : a;\n+  p += 4;\n+  sink (p);\n+  return p;   /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+may_return_global_or_vla (int n, int i)\n+{\n+  int a[n];\n+  void *p = i ? global : a;\n+  sink (p);\n+  return p;   /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+may_return_global_or_vla_plus_cst (int n, int i)\n+{\n+  int a[n];\n+  int *p = i ? global : a;\n+  p += 4;\n+  sink (p);\n+  return p;   /* { dg-warning \"function may return address of local\" } */\n+}"}, {"sha": "6dad7af97e649261742f2b06198a16c7632c8a9b", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-3.c", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-3.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,248 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+\n+struct A { int a, b, c; };\n+struct B { int a, b, c[]; };\n+\n+extern int g1[5], g2[5], g3[5], g4[5], g5[5];\n+\n+void sink (void*, ...);\n+\n+/* Verify that a pointer difference expression is handled correctly\n+   even when converted to a pointer.  */\n+\n+ATTR (noipa) void*\n+return_local_diff_cst (void)\n+{\n+  int a[5];\n+  void *p = (void*)(&a[4] - &a[1]);\n+  return p;\n+}\n+\n+ATTR (noipa) void*\n+return_local_diff_var (int i, int j)\n+{\n+  int a[5];\n+  void *p = (void*)(&a[j] - &a[i]);\n+  return p;\n+}\n+\n+ATTR (noipa) void*\n+return_2_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  void *p = i < 0 ? a : b;\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+/* Verify that returning the address of a local converted to intptr_t\n+   is not diagnosed (see bug 90737 for a case the front-end gets wrong).  */\n+\n+ATTR (noipa) intptr_t\n+return_int_2_locals (int i)\n+{\n+  int a[1];\n+  int b[2];\n+  void *p = i < 0 ? a : b;\n+  return (intptr_t)p;\n+}\n+\n+/* Verify that a conditional expression with a pointer first operand\n+   is handled correctly.  */\n+\n+ATTR (noipa) void*\n+return_2_locals_ptrcond (void *q)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  void *p = q ? a : b;\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+/* Verify that a preincrement expression with a pointer operand is\n+   handled correctly.  */\n+\n+ATTR (noipa) void*\n+return_2_locals_ptrinc (void *q)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int *p = q ? a : b;\n+  return ++p;       /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  void *p = i < 0 ? a : 0 < i ? c : b;\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+/* Verify that a conditional expression with a pointer first operand\n+   is handled correctly.  */\n+\n+ATTR (noipa) void*\n+return_3_locals_ptrcond (void *p, void *q)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  void *r = q ? r ? a : b : c;\n+  return r;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_5_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+  int d[4];         /* { dg-message \"declared here\" } */\n+  int e[5];         /* { dg-message \"declared here\" } */\n+\n+  void *p = i < -1 ? a : i < 0 ? b : 1 < i ? e : 0 < i ? d : c;\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_1_global_4_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+  int d[4];         /* { dg-message \"declared here\" } */\n+\n+  void *p = i < -1 ? a : i < 0 ? b : 1 < i ? g1 : 0 < i ? d : c;\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_globals_3_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  void *p = i < -1 ? a : i < 0 ? b : 1 < i ? g1 : 0 < i ? g2 : c;\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_globals_2_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+\n+  void *p = i < -1 ? a : i < 0 ? b : 1 < i ? g1 : 0 < i ? g2 : g3;\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_4_globals_1_local (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+\n+  void *p = i < -1 ? a : i < 0 ? g1 : 1 < i ? g2 : 0 < i ? g4 : g3;\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_all_globals (int i)\n+{\n+  void *p = i < -1 ? g1 : i < 0 ? g2 : 1 < i ? g3 : 0 < i ? g5 : g4;\n+  return p;\n+}\n+\n+\n+ATTR (noipa) void*\n+return_2_alloca_local_cstoff (int n, int i)\n+{\n+  int *a = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int *b = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int *p = i < 0 ? a : b;\n+  p += 1;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_local_cstoff (int n, int i)\n+{\n+  int *a = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int b[2];                       /* { dg-message \"declared here\" } */\n+  int *p = i < 0 ? a : b;\n+  p += 1;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_local_alloca_cstoff (int n, int i)\n+{\n+  int a[2];                       /* { dg-message \"declared here\" } */\n+  int *b = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int *p = i < 0 ? a : b;\n+  p += 1;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_locals_cstoff (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int *p = i < 0 ? a : b;\n+  p += 1;\n+  sink (p);\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_globals_3_locals_cstoff (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  int *p = i < -1 ? a : i < 0 ? b : 1 < i ? g1 : 0 < i ? g2 : c;\n+  p += 1;\n+  sink (p);\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_globals_alloca_local_varoff (int n, int i, int j)\n+{\n+  int *a = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int b[2];                       /* { dg-message \"declared here\" } */\n+\n+  int *p = i < -1 ? a : i < 0 ? b : 1 < i ? g1 : 0 < i ? g2 : g3;\n+  p += j;\n+  sink (p);\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_globals_2_locals_varoff (int i, int j)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+\n+  int *p = i < -1 ? a : i < 0 ? b : 1 < i ? g1 : 0 < i ? g2 : g3;\n+  p += j;\n+  sink (p);\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+"}, {"sha": "0a451efcaf03ea5510760588f7e16faac709af36", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-4.c", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-4.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,370 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+struct A { int a, b, c; };\n+struct B { int a, b, c[]; };\n+\n+extern int g1[5], g2[5], g3[5], g4[5], g5[5];\n+\n+void sink (void*, ...);\n+\n+ATTR (noipa) void*\n+return_2_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  void *p = b;\n+  if (i < 0)\n+    p = a;\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_locals_after_2_globals (int i, int j)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+\n+  int *p;\n+  if (i < 0)\n+    p = g1;\n+  else\n+    p = g2;\n+\n+  sink (p);\n+\n+  if (j < 0)\n+    p = a;\n+  else\n+    p = b;\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  void *p = b + 1;\n+  if (i < 0)\n+    p = a;\n+  else if (0 < i)\n+    p = c + 2;\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_5_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+  int d[4];         /* { dg-message \"declared here\" } */\n+  int e[5];         /* { dg-message \"declared here\" } */\n+\n+  void *p = &c[2];\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = &b[1];\n+  else if (1 < i)\n+    p = &e[4];\n+  else if (0 < i)\n+    p = &d[3];\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_5_locals_switch (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+  int d[4];         /* { dg-message \"declared here\" } */\n+  int e[5];         /* { dg-message \"declared here\" } */\n+\n+  void *p = 0;\n+\n+  switch (i)\n+    {\n+    case 0: p = &a[1]; break;\n+    case 1: p = &b[2]; break;\n+    case 2: p = &c[3]; break;\n+    case 3: p = &d[4]; break;\n+    default: p = &e[5]; break;\n+    }\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_1_global_4_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+  int d[4];         /* { dg-message \"declared here\" } */\n+\n+  void *p = c;\n+  if (i < -1)\n+    sink (p = a);\n+  else if (i < 0)\n+    sink (p = b);\n+  else if (1 < i)\n+    sink (p = g1);\n+  else if (0 < i)\n+    sink (p = d);\n+\n+  sink (p, a, b, c, d);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_1_global_4_locals_switch (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+  int d[4];         /* { dg-message \"declared here\" } */\n+\n+  void *p = 0;\n+\n+  switch (i)\n+    {\n+    case 0: p = &a[0]; break;\n+    case 1: p = &b[1]; break;\n+    case 2: p = &c[2]; break;\n+    case 3: p = &d[3]; break;\n+    }\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_globals_3_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  void *p = c;\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = b;\n+  else if (1 < i)\n+    p = g1;\n+  else if (0 < i)\n+    p = g2;\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_globals_2_locals (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+\n+  void *p = g3;\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = b;\n+  else if (1 < i)\n+    p = g1;\n+  else if (0 < i)\n+    p = g2;\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_4_globals_1_local (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+\n+  void *p = g3;\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = g1;\n+  else if (1 < i)\n+    p = g2;\n+  else if (0 < i)\n+    p = g4;\n+\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_all_globals (int i)\n+{\n+  void *p = g4;\n+  if (i < -1)\n+    p = g1;\n+  else if (i < 0)\n+    p = g2;\n+  else if (1 < i)\n+    p = g3;\n+  else if (0 < i)\n+    p = g5;\n+  return p;\n+}\n+\n+\n+ATTR (noipa) void*\n+return_2_alloca_local_cstoff (int n, int i)\n+{\n+  int *a = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int *b = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int *p = i < 0 ? a : b;\n+\n+  p += 1;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_alloca_local_cstoff (int n, int i)\n+{\n+  int *a = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int b[2];                       /* { dg-message \"declared here\" } */\n+\n+  int *p = b;\n+  if (i < 0)\n+    p = a;\n+\n+  p += 1;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_local_alloca_cstoff (int n, int i)\n+{\n+  int a[2];                       /* { dg-message \"declared here\" } */\n+  int *b = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int *p = b;\n+  if (i < 0)\n+    p = a;\n+\n+  p += 1;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_locals_cstoff (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+\n+  int *p = b;\n+  if (i < 0)\n+    p = a;\n+\n+  p += 1;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function returns address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_2_globals_3_locals_cstoff (int i)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+  int c[3];         /* { dg-message \"declared here\" } */\n+\n+  int *p = c;\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = b;\n+  else if (1 < i)\n+    p = g1;\n+  else if (0 < i)\n+    p = g2;\n+\n+  p += 1;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_globals_alloca_local_varoff (int n, int i, int j)\n+{\n+  int *a = __builtin_alloca (n);  /* { dg-message \"declared here\" } */\n+  int b[2];                       /* { dg-message \"declared here\" } */\n+\n+  int *p = g3;\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = b;\n+  else if (1 < i)\n+    p = g1;\n+  else if (0 < i)\n+    p = g2;\n+\n+  p += j;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+\n+ATTR (noipa) void*\n+return_3_globals_2_locals_varoff (int i, int j)\n+{\n+  int a[1];         /* { dg-message \"declared here\" } */\n+  int b[2];         /* { dg-message \"declared here\" } */\n+\n+  int *p = g3;\n+  if (i < -1)\n+    p = a;\n+  else if (i < 0)\n+    p = b;\n+  else if (1 < i)\n+    p = g1;\n+  else if (0 < i)\n+    p = g2;\n+\n+  p += j;\n+  sink (p);\n+\n+  return p;         /* { dg-warning \"function may return address of local\" } */\n+}\n+"}, {"sha": "bdf1cd40c1b61a447444455096b2fbb7964ac3b7", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-5.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-5.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,40 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void sink (void*);\n+\n+void* loop_idx (int x)\n+{\n+  char a[32];       /* { dg-message \"declared here\" } */\n+  char *p = a;\n+\n+  sink (a);\n+\n+  int i;\n+  for (i = 0; i != 32; ++i)\n+    if (p[i] == x)\n+      break;\n+\n+  p = i < 32 ? &p[i] : 0;\n+  return p;  /* { dg-warning \"may return address of local variable\" } */\n+}\n+\n+\n+void* loop_ptr (int i, int x)\n+{\n+  char a[32];       /* { dg-message \"declared here\" } */\n+  char *p;\n+\n+  sink (a);\n+\n+  /* The warning for the statement below would ideally be a \"returns\"\n+     because it definitely returns the address of a, but when both\n+     returns get merged into one we end up with a \"may return\".  */\n+  for (p = a; *p; ++p)\n+    if (*p == x)\n+      return p;     /* { dg-warning \"(returns|may return) address of local variable\" \"missing location\" { xfail *-*-* } } */\n+  /* { dg-warning \"(returns|may return) address of local variable\" \"pr90735\" { target *-*-* } 0 } */\n+\n+  return 0;\n+}"}, {"sha": "70138b3eff8fb17d749ba31b74bce987cb93f577", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-6.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-6.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,203 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* memcpy (void*, const void*, size_t);\n+void* mempcpy (void*, const void*, size_t);\n+void* memmove (void*, const void*, size_t);\n+\n+char* stpcpy (char*, const char*);\n+char* stpncpy (char*, const char*, size_t);\n+\n+size_t strlen (const char*);\n+size_t strnlen (const char*, size_t);\n+\n+char* strcat (char*, const char*);\n+char* strncat (char*, const char*, size_t);\n+\n+char* strcpy (char*, const char*);\n+char* strncpy (char*, const char*, size_t);\n+\n+char* strdup (const char*);\n+\n+char* strchr (const char*, int);\n+char* strrchr (const char*, int);\n+char* strstr (const char*, const char*);\n+\n+void sink (void*, ...);\n+\n+\n+void* return_memcpy (const void *s, unsigned n)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  void *p = memcpy (a, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+void* return_memcpy_cst (const void *s, unsigned n)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  void *p = memcpy (a + 1, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+void* return_memcpy_var (const void *s, unsigned n, int i)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  void *p = memcpy (a + i, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+void* return_mempcpy (const void *s, unsigned n)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  void *p = mempcpy (a, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+void* return_memmove_cst (unsigned n)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  void *p = memmove (a + 1, a, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+void* return_memmove_var (unsigned n, int i)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  void *p = memmove (a + i, a, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_stpcpy (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  char *p = stpcpy (a, s);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_stpncpy (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  char *p = stpncpy (a, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strcat (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strcat (a, s);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strncat (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strncat (a, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+\n+}\n+char* return_strcpy (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  char *p = strcpy (a, s);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strcpy_plus_strlen (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  char *p = strcpy (a, s);\n+  sink (p);\n+  p += strlen (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strcpy_cst_plus_strlen (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strcpy (a + 1, s);\n+  sink (p);\n+  p += strlen (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strcpy_var_plus_strlen (unsigned n, const char *s, int i)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strcpy (a + i, s);\n+  sink (p);\n+  p += strlen (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strncpy (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  char *p = strncpy (a, s, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strncpy_plus_strnlen (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  char *p = strncpy (a, s, n);\n+  p += strnlen (p, n);\n+  sink (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strdup (unsigned n)\n+{\n+  char a[n];\n+  sink (a);\n+  char *p = strdup (a);\n+  return p;\n+}\n+\n+char* return_strchr (unsigned n, int c)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strchr (a, c);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strstr (unsigned n, const char *s)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strstr (a, s);\n+  if (p)\n+    p += strlen (p);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+}\n+\n+char* return_strrchr (unsigned n, int c)\n+{\n+  char a[n];                  /* { dg-message \"declared here\" } */\n+  sink (a);\n+  char *p = strrchr (a, c);\n+  return p;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr]\" } */\n+\n+}"}, {"sha": "ac1fb769ba8dccbf32a7dea2d1ccc3eae1cf308e", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-7.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-7.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,50 @@\n+/* Test to verify that a PHI with a COND_EXPR argument in a return\n+   statement is handled correctly.\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wall\" } */\n+\n+extern struct S s;\n+\n+void* f (int n)\n+{\n+  void *p;\n+  int x = 0;\n+\n+  for (int i = n; i >= 0; i--)\n+    {\n+      p = &s;\n+      if (p == (void*)-1)\n+         x = 1;\n+      else if (p)\n+         return p;\n+    }\n+\n+  /* The return statement below ends up with the following IL:\n+     <bb 6> [local count: 59055800]:\n+     # x_10 = PHI <1(5), 0(2)>\n+     _5 = x_10 != 0 ? -1B : 0B;\n+\n+     <bb 7> [local count: 114863532]:\n+     # _3 = PHI <&s(4), _5(6), &s(3)>\n+     return _3;  */\n+  return x ? (void*)-1 : 0;\n+}\n+\n+void* g (int n)\n+{\n+  void *p;\n+  int x = 0;                  /* { dg-message \"declared here\" } */\n+\n+  for (int i = n; i >= 0; i--)\n+    {\n+      p = &s;\n+      if (p == (void*)-1)\n+         x = 1;\n+      else if (p)\n+         return p;\n+    }\n+\n+  /* The return statement below does not reference a COND_EXPR argument.  */\n+  return x ? &x : 0;          /* { dg-warning \"may return address of local variable\" \"missing location\" { xfail *-*-* } } */\n+  /* { dg-warning \"may return address of local variable\" \"pr90735\" { target *-*-* } 0 } */\n+}"}, {"sha": "98a3805b5f01c0d895c7898e10eb42117aad9128", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-8.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-8.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,88 @@\n+/* Test to verify that a MAX_EXPR and MIN_EXPR in a return statement\n+   is handled correctly and that all local variables whose address\n+   is or may be returned are identified.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+char* sink (char*, ...);\n+\n+void* test_max_2 (void)\n+{\n+  char c;                     /* { dg-message \"declared here\" } */\n+\n+  char *p = sink (&c);\n+\n+  void *q = p > &c ? p : &c;  /* MAX_EXPR */\n+  return q;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr\" } */\n+}\n+\n+void* test_max_3 (void)\n+{\n+  char c;                     /* { dg-message \"declared here\" } */\n+  char d;                     /* { dg-message \"declared here\" } */\n+\n+  char *p = sink (&c, &d);\n+\n+  void *q = p < &c ? &c < &d ? &d : &c : p;\n+  return q;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr\" } */\n+}\n+\n+void* test_min_2 (void)\n+{\n+  char c;                     /* { dg-message \"declared here\" } */\n+\n+  char *p = sink (&c);\n+\n+  void *q = p < &c ? p : &c;  /* MIN_EXPR\" */\n+  return q;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr\" } */\n+}\n+\n+void* test_min_3 (void)\n+{\n+  char c;                     /* { dg-message \"declared here\" } */\n+  char d;                     /* { dg-message \"declared here\" } */\n+\n+  char *p = sink (&c, &d);\n+\n+  void *q = p > &c ? &c > &d ? &d : &c : p;\n+  return q;                   /* { dg-warning \"\\\\\\[-Wreturn-local-addr\" } */\n+}\n+\n+void* test_min_2_phi (int i)\n+{\n+  char a;                     /* { dg-message \"declared here\" } */\n+\n+  char *p = &a;\n+  char *q = sink (&a);\n+  p = p < q ? p : q;\n+  if (i == 1)\n+    return p;\n+  /* { dg-warning \"may return address of local variable\" \"missing location\" { xfail *-*-* } } */\n+  else\n+    return q;\n+}\n+\n+void* test_min_3_phi (int i)\n+{\n+  char a;                     /* { dg-message \"declared here\" } */\n+  char b;                     /* { dg-message \"declared here\" } */\n+\n+  char *p0 = &a;\n+  char *p1 = &b;\n+  char *p2 = sink (&a, &b);\n+  char *p3 = sink (&a, &b);\n+\n+  char *p4 = p2 < p0 ? p2 : p0;\n+  char *p5 = p3 < p1 ? p3 : p1;\n+\n+  if (i == 1)\n+    /* { dg-warning \"may return address of local variable\" \"missing location\" { xfail *-*-* } } */\n+    return p4;\n+  else\n+    /* { dg-warning \"may return address of local variable\" \"missing location\" { xfail *-*-* } } */\n+    return p5;\n+}\n+\n+/* The directive below \"swallows\" warnings for both test_min_2_phi\n+   and test_min_3_phi.\n+  { dg-warning \"may return address of local variable\" \"pr90735\" { target *-*-* } 0 } */"}, {"sha": "d24f911e9cd1817c6ce18be341ad60bf55397a29", "filename": "gcc/testsuite/gcc.dg/Wreturn-local-addr-9.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWreturn-local-addr-9.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -0,0 +1,73 @@\n+/* PR c/71924 - missing -Wreturn-local-addr returning alloca result\n+   Test derived from gcc.c-torture/execute/20071108-1.c.  It shows\n+   a false positive at -Os caused by the jump threading/vrp1 pass.\n+   { dg-do compile }\n+   { dg-options \"-Os -fdump-tree-optimized\" } */\n+\n+struct S\n+{\n+  int i;\n+};\n+\n+void* f (void);\n+\n+__attribute__ ((noinline))\n+struct S* g (int i)\n+{\n+  struct S *p = f (), q;\n+\n+  if (p == 0)\n+    p = &q;\n+\n+  p->i = i;\n+\n+  if (p == &q)\n+    p = 0;\n+\n+  /* With -Os the warning pass sees:\n+\n+       ...\n+       <bb 4>\n+       # p_1 = PHI <&q(2), p_5(3)>\n+       p_1->i = i_6(D);\n+       if (&q == p_1)\n+         goto <bb 6>; [14.90%]\n+       else\n+         goto <bb 5>; [85.10%]\n+\n+       <bb 5>\n+\n+       <bb 6>\n+       # p_2 = PHI <0B(4), p_1(5)>\n+       q ={v} {CLOBBER};\n+       return p_2;\n+     }\n+\n+     which leads to:  */\n+  return p;         /* { dg-bogus \"may return address of local variable\" \"\" { xfail *-*-* } } */\n+\n+  /* Whereas as -O2 the pass sees:\n+\n+       <bb 2>\n+       p_5 = f ();\n+       if (p_5 == 0B)\n+         goto <bb 4>; [30.00%]\n+       else\n+         goto <bb 3>; [70.00%]\n+\n+       <bb 3>\n+       # p_2 = PHI <0B(5), p_5(4)>\n+       q ={v} {CLOBBER};\n+       return p_2;\n+\n+       <bb 4>\n+       p_5->i = i_6(D);\n+       goto <bb 3>; [100.00%]\n+\n+       <bb 5>\n+       q.i = i_6(D);\n+       goto <bb 3>; [100.00%]\n+     }\n+\n+     and no warning.  */\n+}"}, {"sha": "e1123206cc61684634a0c5d3bac5abeb30d52e69", "filename": "gcc/testsuite/gcc.dg/pr41551.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41551.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41551.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41551.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -10,3 +10,5 @@ int main(void)\n  int var, *p = &var;\n  return (double)(uintptr_t)(p);\n }\n+\n+/* { dg-prune-output \"-Wreturn-local-addr\" } */"}, {"sha": "49cbe5dd27a61faed54c933cf86f8e53c6a79437", "filename": "gcc/testsuite/gcc.dg/pr59523.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59523.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59523.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59523.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -16,3 +16,5 @@ foo (int a, int *b, int *c, int *d)\n       r[i] = 1;\n   return r;\n }\n+\n+/* { dg-prune-output \"-Wreturn-local-addr\" } */"}, {"sha": "c913d26d1323216245ee3cb420cb5669bdc27f61", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-37.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-37.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -12,7 +12,7 @@ int *foo (int bogus, int n)\n     p = &a[2];\n   else\n     p = &i;\n-  return p;\n+  return p;         /* { dg-warning \"\\\\\\[-Wreturn-local-addr\" } */\n }\n \n /* { dg-final { scan-tree-dump \"Deleted dead store\" \"dse1\" } } */"}, {"sha": "ed5df8264327e47ea71ebb677dcf6649c6656fc2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88775-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88775-2.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -41,3 +41,5 @@ f5 (void)\n   int c[64] = {}, d[64] = {};\n   return (__UINTPTR_TYPE__) &c[64] != (__UINTPTR_TYPE__) &d[0];\n }\n+\n+/* { dg-prune-output \"-Wreturn-local-addr\" } */"}, {"sha": "239d748926d8dbe59107c50603f83e18bcec1b49", "filename": "gcc/testsuite/gcc.dg/winline-7.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-7.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -13,3 +13,5 @@ inline void *t (void)\n {\n \treturn q ();\t\t /* { dg-message \"called from here\" } */\n }\n+\n+/* { dg-prune-output \"-Wreturn-local-addr\" } */"}, {"sha": "2dc373305fb53f80318bd9d50cbf5d1ce694783a", "filename": "libgcc/generic-morestack.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac9480da1ffd037ceb21790fe341b3ec23283d9/libgcc%2Fgeneric-morestack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac9480da1ffd037ceb21790fe341b3ec23283d9/libgcc%2Fgeneric-morestack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.c?ref=aac9480da1ffd037ceb21790fe341b3ec23283d9", "patch": "@@ -23,6 +23,8 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+#pragma GCC optimize (\"no-isolate-erroneous-paths-dereference\")\n+\n /* powerpc 32-bit not supported.  */\n #if !defined __powerpc__ || defined __powerpc64__\n "}]}