{"sha": "4dcc7f03b54087638e084ac69d40d7507fe83bd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRjYzdmMDNiNTQwODc2MzhlMDg0YWM2OWQ0MGQ3NTA3ZmU4M2JkOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-25T11:08:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-25T11:11:53Z"}, "message": "tree-optimization/97199 - fix virtual operand update in if-conversion\n\nThis fixes a corner case with virtual operand update in if-conversion\nby re-organizing the code to remove edges only after the last point\nwe need virtual PHI operands to be available.\n\n2020-09-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97199\n\t* tree-if-conv.c (combine_blocks): Remove edges only\n\tafter looking at virtual PHI args.", "tree": {"sha": "9887a0cbbf9948f9767ed49f93e505fbd81e6ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9887a0cbbf9948f9767ed49f93e505fbd81e6ae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dcc7f03b54087638e084ac69d40d7507fe83bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dcc7f03b54087638e084ac69d40d7507fe83bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dcc7f03b54087638e084ac69d40d7507fe83bd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dcc7f03b54087638e084ac69d40d7507fe83bd8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c775bf447e190024fa08c55e38db94dd013a393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c775bf447e190024fa08c55e38db94dd013a393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c775bf447e190024fa08c55e38db94dd013a393"}], "stats": {"total": 107, "additions": 63, "deletions": 44}, "files": [{"sha": "2062758f40ffc01accc93de14c3b56d88837b72a", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 63, "deletions": 44, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dcc7f03b54087638e084ac69d40d7507fe83bd8/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dcc7f03b54087638e084ac69d40d7507fe83bd8/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=4dcc7f03b54087638e084ac69d40d7507fe83bd8", "patch": "@@ -2544,8 +2544,7 @@ combine_blocks (class loop *loop)\n   if (need_to_predicate)\n     predicate_statements (loop);\n \n-  /* Merge basic blocks: first remove all the edges in the loop,\n-     except for those from the exit block.  */\n+  /* Merge basic blocks.  */\n   exit_bb = NULL;\n   bool *predicated = XNEWVEC (bool, orig_loop_num_nodes);\n   for (i = 0; i < orig_loop_num_nodes; i++)\n@@ -2561,43 +2560,6 @@ combine_blocks (class loop *loop)\n     }\n   gcc_assert (exit_bb != loop->latch);\n \n-  for (i = 1; i < orig_loop_num_nodes; i++)\n-    {\n-      bb = ifc_bbs[i];\n-\n-      for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei));)\n-\t{\n-\t  if (e->src == exit_bb)\n-\t    ei_next (&ei);\n-\t  else\n-\t    remove_edge (e);\n-\t}\n-    }\n-\n-  if (exit_bb != NULL)\n-    {\n-      if (exit_bb != loop->header)\n-\t{\n-\t  /* Connect this node to loop header.  */\n-\t  make_single_succ_edge (loop->header, exit_bb, EDGE_FALLTHRU);\n-\t  set_immediate_dominator (CDI_DOMINATORS, exit_bb, loop->header);\n-\t}\n-\n-      /* Redirect non-exit edges to loop->latch.  */\n-      FOR_EACH_EDGE (e, ei, exit_bb->succs)\n-\t{\n-\t  if (!loop_exit_edge_p (loop, e))\n-\t    redirect_edge_and_branch (e, loop->latch);\n-\t}\n-      set_immediate_dominator (CDI_DOMINATORS, loop->latch, exit_bb);\n-    }\n-  else\n-    {\n-      /* If the loop does not have an exit, reconnect header and latch.  */\n-      make_edge (loop->header, loop->latch, EDGE_FALLTHRU);\n-      set_immediate_dominator (CDI_DOMINATORS, loop->latch, loop->header);\n-    }\n-\n   merge_target_bb = loop->header;\n \n   /* Get at the virtual def valid for uses starting at the first block\n@@ -2682,13 +2644,9 @@ combine_blocks (class loop *loop)\n       last = gsi_last_bb (merge_target_bb);\n       gsi_insert_seq_after_without_update (&last, bb_seq (bb), GSI_NEW_STMT);\n       set_bb_seq (bb, NULL);\n-\n-      delete_basic_block (bb);\n     }\n \n-  /* If possible, merge loop header to the block with the exit edge.\n-     This reduces the number of basic blocks to two, to please the\n-     vectorizer that handles only loops with two nodes.  */\n+  /* Fixup virtual operands in the exit block.  */\n   if (exit_bb\n       && exit_bb != loop->header)\n     {\n@@ -2698,6 +2656,11 @@ combine_blocks (class loop *loop)\n       vphi = get_virtual_phi (exit_bb);\n       if (vphi)\n \t{\n+\t  /* When there's just loads inside the loop a stray virtual\n+\t     PHI merging the uses can appear, update last_vdef from\n+\t     it.  */\n+\t  if (!last_vdef)\n+\t    last_vdef = gimple_phi_arg_def (vphi, 0);\n \t  imm_use_iterator iter;\n \t  use_operand_p use_p;\n \t  gimple *use_stmt;\n@@ -2711,7 +2674,63 @@ combine_blocks (class loop *loop)\n \t  gimple_stmt_iterator gsi = gsi_for_stmt (vphi); \n \t  remove_phi_node (&gsi, true);\n \t}\n+    }\n+\n+  /* Now remove all the edges in the loop, except for those from the exit\n+     block and delete the blocks we elided.  */\n+  for (i = 1; i < orig_loop_num_nodes; i++)\n+    {\n+      bb = ifc_bbs[i];\n+\n+      for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei));)\n+\t{\n+\t  if (e->src == exit_bb)\n+\t    ei_next (&ei);\n+\t  else\n+\t    remove_edge (e);\n+\t}\n+    }\n+  for (i = 1; i < orig_loop_num_nodes; i++)\n+    {\n+      bb = ifc_bbs[i];\n+\n+      if (bb == exit_bb || bb == loop->latch)\n+\tcontinue;\n+\n+      delete_basic_block (bb);\n+    }\n+\n+  /* Re-connect the exit block.  */\n+  if (exit_bb != NULL)\n+    {\n+      if (exit_bb != loop->header)\n+\t{\n+\t  /* Connect this node to loop header.  */\n+\t  make_single_succ_edge (loop->header, exit_bb, EDGE_FALLTHRU);\n+\t  set_immediate_dominator (CDI_DOMINATORS, exit_bb, loop->header);\n+\t}\n \n+      /* Redirect non-exit edges to loop->latch.  */\n+      FOR_EACH_EDGE (e, ei, exit_bb->succs)\n+\t{\n+\t  if (!loop_exit_edge_p (loop, e))\n+\t    redirect_edge_and_branch (e, loop->latch);\n+\t}\n+      set_immediate_dominator (CDI_DOMINATORS, loop->latch, exit_bb);\n+    }\n+  else\n+    {\n+      /* If the loop does not have an exit, reconnect header and latch.  */\n+      make_edge (loop->header, loop->latch, EDGE_FALLTHRU);\n+      set_immediate_dominator (CDI_DOMINATORS, loop->latch, loop->header);\n+    }\n+\n+  /* If possible, merge loop header to the block with the exit edge.\n+     This reduces the number of basic blocks to two, to please the\n+     vectorizer that handles only loops with two nodes.  */\n+  if (exit_bb\n+      && exit_bb != loop->header)\n+    {\n       if (can_merge_blocks_p (loop->header, exit_bb))\n \tmerge_blocks (loop->header, exit_bb);\n     }"}]}