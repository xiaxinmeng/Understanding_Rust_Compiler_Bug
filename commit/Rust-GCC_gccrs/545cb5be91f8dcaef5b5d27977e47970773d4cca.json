{"sha": "545cb5be91f8dcaef5b5d27977e47970773d4cca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ1Y2I1YmU5MWY4ZGNhZWY1YjVkMjc5NzdlNDc5NzA3NzNkNGNjYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T17:17:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T17:17:57Z"}, "message": "[multiple changes]\n\n2010-06-22  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb: Minor reformatting\n\tMinor code reorganization (use Nkind_In and Ekind_In).\n\n2010-06-22  Bob Duff  <duff@adacore.com>\n\n\t* gnat1drv.adb (Gnat1drv): Remove the messages that recommend using \n\t-gnatc when a file is compiled that we cannot generate code for, not\n\thelpful and confusing.\n\n2010-06-22  Vincent Celier  <celier@adacore.com>\n\n\t* switch-m.adb (Normalize_Compiler_Switches): Process correctly\n\tswitches -gnatknn.\n\n2010-06-22  Paul Hilfinger  <hilfinger@adacore.com>\n\n\t* s-rannum.adb: Replace constants with commented symbols.\n\t* s-rannum.ads: Explain significance of the initial value of the data\n\tstructure.\n\n2010-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-ngcoty.adb: Clarify comment.\n\n2010-06-22  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_pakd.adb (Expand_Bit_Packed_Element_Set): Return without\n\texpansion for indexing packed arrays with small power-of-2 component\n\tsizes when the target is AAMP.\n\t(Expand_Packed_Element_Reference): Return without expansion for\n\tindexing packed arrays with small power-of-2 component sizes when the\n\ttarget is AAMP.\n\n2010-06-22  Geert Bosch  <bosch@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_In): Do not substitute a valid check for X in\n\tFloat'Range.\n\n2010-06-22  Robert Dewar  <dewar@adacore.com>\n\n\t* g-mbdira.adb, g-mbflra.adb, a-nuflra.adb, a-nudira.adb: Minor comment\n\tupdates.\n\nFrom-SVN: r161213", "tree": {"sha": "6078bcaac066b9b80d5acf54d2737daa1f56b9ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6078bcaac066b9b80d5acf54d2737daa1f56b9ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/545cb5be91f8dcaef5b5d27977e47970773d4cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545cb5be91f8dcaef5b5d27977e47970773d4cca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/545cb5be91f8dcaef5b5d27977e47970773d4cca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545cb5be91f8dcaef5b5d27977e47970773d4cca/comments", "author": null, "committer": null, "parents": [{"sha": "879e23f05867aed40198a68fcd3ba8df62ee104c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/879e23f05867aed40198a68fcd3ba8df62ee104c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/879e23f05867aed40198a68fcd3ba8df62ee104c"}], "stats": {"total": 378, "additions": 228, "deletions": 150}, "files": [{"sha": "12a741a4b97247f04bc19e04365e4c7c7aa545de", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -1,3 +1,48 @@\n+2010-06-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb: Minor reformatting\n+\tMinor code reorganization (use Nkind_In and Ekind_In).\n+\n+2010-06-22  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat1drv.adb (Gnat1drv): Remove the messages that recommend using \n+\t-gnatc when a file is compiled that we cannot generate code for, not\n+\thelpful and confusing.\n+\n+2010-06-22  Vincent Celier  <celier@adacore.com>\n+\n+\t* switch-m.adb (Normalize_Compiler_Switches): Process correctly\n+\tswitches -gnatknn.\n+\n+2010-06-22  Paul Hilfinger  <hilfinger@adacore.com>\n+\n+\t* s-rannum.adb: Replace constants with commented symbols.\n+\t* s-rannum.ads: Explain significance of the initial value of the data\n+\tstructure.\n+\n+2010-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-ngcoty.adb: Clarify comment.\n+\n+2010-06-22  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_pakd.adb (Expand_Bit_Packed_Element_Set): Return without\n+\texpansion for indexing packed arrays with small power-of-2 component\n+\tsizes when the target is AAMP.\n+\t(Expand_Packed_Element_Reference): Return without expansion for\n+\tindexing packed arrays with small power-of-2 component sizes when the\n+\ttarget is AAMP.\n+\n+2010-06-22  Geert Bosch  <bosch@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_In): Do not substitute a valid check for X in\n+\tFloat'Range.\n+\n+2010-06-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-mbdira.adb, g-mbflra.adb, a-nuflra.adb, a-nudira.adb: Minor comment\n+\tupdates.\n+\n 2010-06-22  Doug Rupp  <rupp@adacore.com>\n \n \t* system-vms.ads, system-vms-zcx.ads: Remove old unused VMS system"}, {"sha": "7cf48713a6b03cee1103bddffaa40d9a79a2f478", "filename": "gcc/ada/a-ngcoty.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fa-ngcoty.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fa-ngcoty.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoty.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -60,15 +60,16 @@ package body Ada.Numerics.Generic_Complex_Types is\n \n       if not Standard'Fast_Math then\n \n-         --  ??? the test below is weird, it needs a comment, otherwise I or\n-         --  someone else will change it back to R'Last > abs (X) ???\n+         --  Note that the test below is written as a negation. This is to\n+         --  account for the fact that X and Y may be NaNs, because both of\n+         --  their operands could overflow. Given that all operations on NaNs\n+         --  return false, the test can only be written thus.\n \n          if not (abs (X) <= R'Last) then\n             X := Scale**2 * ((Left.Re / Scale) * (Right.Re / Scale) -\n                              (Left.Im / Scale) * (Right.Im / Scale));\n          end if;\n \n-         --  ??? same weird test ???\n          if not (abs (Y) <= R'Last) then\n             Y := Scale**2 * ((Left.Re / Scale) * (Right.Im / Scale)\n                            + (Left.Im / Scale) * (Right.Re / Scale));"}, {"sha": "d352418efcca81d68d0321ee71133cb8c95e9d5a", "filename": "gcc/ada/a-nudira.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -37,13 +37,14 @@ package body Ada.Numerics.Discrete_Random is\n    -- Implementation Note --\n    -------------------------\n \n-   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  The design of this spec is a bit awkward, as a result of Ada 95 not\n    --  permitting in-out parameters for function formals (most naturally\n    --  Generator values would be passed this way). In pure Ada 95, the only\n-   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n-   --  controlled types.\n+   --  solution would be to add a self-referential component to the generator\n+   --  allowing access to the generator object from inside the function. This\n+   --  would work because the generator is limited, which prevents any copy.\n \n-   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  This is a bit heavy, so what we do is to use Unrestricted_Access to\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n "}, {"sha": "0c62f0fea4b00e76544b6dbd68f3295128fec36e", "filename": "gcc/ada/a-nuflra.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fa-nuflra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fa-nuflra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nuflra.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -39,13 +39,14 @@ package body Ada.Numerics.Float_Random is\n    -- Implementation Note --\n    -------------------------\n \n-   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  The design of this spec is a bit awkward, as a result of Ada 95 not\n    --  permitting in-out parameters for function formals (most naturally\n    --  Generator values would be passed this way). In pure Ada 95, the only\n-   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n-   --  controlled types.\n+   --  solution would be to add a self-referential component to the generator\n+   --  allowing access to the generator object from inside the function. This\n+   --  would work because the generator is limited, which prevents any copy.\n \n-   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  This is a bit heavy, so what we do is to use Unrestricted_Access to\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n "}, {"sha": "d90b787b70fd01710b32b8ac93bcc3fb975e0396", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -4378,9 +4378,12 @@ package body Exp_Ch4 is\n \n       --  Check case of explicit test for an expression in range of its\n       --  subtype. This is suspicious usage and we replace it with a 'Valid\n-      --  test and give a warning.\n+      --  test and give a warning. For floating point types however, this\n+      --  is a standard way to check for finite numbers, and using 'Valid\n+      --  would typically be a pessimization\n \n       if Is_Scalar_Type (Etype (Lop))\n+        and then not Is_Floating_Point_Type (Etype (Lop))\n         and then Nkind (Rop) in N_Has_Entity\n         and then Etype (Lop) = Entity (Rop)\n         and then Comes_From_Source (N)"}, {"sha": "bd8a69771a447f3dc8a58e82f38574b7ad9d7abc", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -1381,6 +1381,19 @@ package body Exp_Pakd is\n          Analyze_And_Resolve (Rhs, Ctyp);\n       end if;\n \n+      --  For the AAMP target, indexing of certain packed array is passed\n+      --  through to the back end without expansion, because the expansion\n+      --  results in very inefficient code on that target. This allows the\n+      --  GNAAMP back end to generate specialized macros that support more\n+      --  efficient indexing of packed arrays with components having sizes\n+      --  that are small powers of two.\n+\n+      if AAMP_On_Target\n+        and then (Csiz = 1 or else Csiz = 2 or else Csiz = 4)\n+      then\n+         return;\n+      end if;\n+\n       --  Case of component size 1,2,4 or any component size for the modular\n       --  case. These are the cases for which we can inline the code.\n \n@@ -1933,6 +1946,19 @@ package body Exp_Pakd is\n       Ctyp := Component_Type (Atyp);\n       Csiz := UI_To_Int (Component_Size (Atyp));\n \n+      --  For the AAMP target, indexing of certain packed array is passed\n+      --  through to the back end without expansion, because the expansion\n+      --  results in very inefficient code on that target. This allows the\n+      --  GNAAMP back end to generate specialized macros that support more\n+      --  efficient indexing of packed arrays with components having sizes\n+      --  that are small powers of two.\n+\n+      if AAMP_On_Target\n+        and then (Csiz = 1 or else Csiz = 2 or else Csiz = 4)\n+      then\n+         return;\n+      end if;\n+\n       --  Case of component size 1,2,4 or any component size for the modular\n       --  case. These are the cases for which we can inline the code.\n "}, {"sha": "079534f66ed3b2682c02631fc6cfcf1c7dc39cc6", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 43, "deletions": 62, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -210,7 +210,6 @@ package body Freeze is\n       Renamed_Subp : Entity_Id;\n \n    begin\n-\n       --  If the renamed subprogram is intrinsic, there is no need for a\n       --  wrapper body: we set the alias that will be called and expanded which\n       --  completes the declaration. This transformation is only legal if the\n@@ -221,7 +220,7 @@ package body Freeze is\n       --  is frozen. See RM 8.5.4 (5).\n \n       if Nkind (Body_Decl) = N_Subprogram_Renaming_Declaration\n-         and then Is_Entity_Name (Name (Body_Decl))\n+        and then Is_Entity_Name (Name (Body_Decl))\n       then\n          Renamed_Subp := Entity (Name (Body_Decl));\n       else\n@@ -233,20 +232,20 @@ package body Freeze is\n         and then\n           (not In_Same_Source_Unit (Renamed_Subp, Ent)\n             or else Sloc (Renamed_Subp) < Sloc (Ent))\n-        and then\n \n-         --  We can make the renaming entity intrisic if the renamed function\n-         --  has an interface name, or it is one of the shift/rotate operations\n-         --  known to the compiler.\n+        --  We can make the renaming entity intrisic if the renamed function\n+        --  has an interface name, or if it is one of the shift/rotate\n+        --  operations known to the compiler.\n \n-        (Present (Interface_Name (Renamed_Subp))\n-          or else Chars (Renamed_Subp) = Name_Rotate_Left\n-          or else Chars (Renamed_Subp) = Name_Rotate_Right\n-          or else Chars (Renamed_Subp) = Name_Shift_Left\n-          or else Chars (Renamed_Subp) = Name_Shift_Right\n-          or else Chars (Renamed_Subp) = Name_Shift_Right_Arithmetic)\n+        and then (Present (Interface_Name (Renamed_Subp))\n+                   or else Chars (Renamed_Subp) = Name_Rotate_Left\n+                   or else Chars (Renamed_Subp) = Name_Rotate_Right\n+                   or else Chars (Renamed_Subp) = Name_Shift_Left\n+                   or else Chars (Renamed_Subp) = Name_Shift_Right\n+                   or else Chars (Renamed_Subp) = Name_Shift_Right_Arithmetic)\n       then\n          Set_Interface_Name (Ent, Interface_Name (Renamed_Subp));\n+\n          if Present (Alias (Renamed_Subp)) then\n             Set_Alias (Ent, Alias (Renamed_Subp));\n          else\n@@ -274,12 +273,12 @@ package body Freeze is\n       New_S : Entity_Id) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (New_S);\n-      --  We use for the source location of the renamed body, the location\n-      --  of the spec entity. It might seem more natural to use the location\n-      --  of the renaming declaration itself, but that would be wrong, since\n-      --  then the body we create would look as though it was created far\n-      --  too late, and this could cause problems with elaboration order\n-      --  analysis, particularly in connection with instantiations.\n+      --  We use for the source location of the renamed body, the location of\n+      --  the spec entity. It might seem more natural to use the location of\n+      --  the renaming declaration itself, but that would be wrong, since then\n+      --  the body we create would look as though it was created far too late,\n+      --  and this could cause problems with elaboration order analysis,\n+      --  particularly in connection with instantiations.\n \n       N          : constant Node_Id := Unit_Declaration_Node (New_S);\n       Nam        : constant Node_Id := Name (N);\n@@ -355,8 +354,7 @@ package body Freeze is\n             Call_Name := New_Copy (Name (N));\n          end if;\n \n-         --  The original name may have been overloaded, but\n-         --  is fully resolved now.\n+         --  Original name may have been overloaded, but is fully resolved now\n \n          Set_Is_Overloaded (Call_Name, False);\n       end if;\n@@ -365,8 +363,7 @@ package body Freeze is\n       --  calls to the renamed entity. The body must be generated in any case\n       --  for calls that may appear elsewhere.\n \n-      if (Ekind (Old_S) = E_Function\n-           or else Ekind (Old_S) = E_Procedure)\n+      if Ekind_In (Old_S, E_Function, E_Procedure)\n         and then Nkind (Decl) = N_Subprogram_Declaration\n       then\n          Set_Body_To_Inline (Decl, Old_S);\n@@ -385,7 +382,6 @@ package body Freeze is\n             Form_Type : constant Entity_Id := Etype (First_Formal (Old_S));\n \n          begin\n-\n             --  The controlling formal may be an access parameter, or the\n             --  actual may be an access value, so adjust accordingly.\n \n@@ -434,10 +430,8 @@ package body Freeze is\n       if Present (Formal) then\n          O_Formal := First_Formal (Old_S);\n          Param_Spec := First (Parameter_Specifications (Spec));\n-\n          while Present (Formal) loop\n             if Is_Entry (Old_S) then\n-\n                if Nkind (Parameter_Type (Param_Spec)) /=\n                                                     N_Access_Definition\n                then\n@@ -500,7 +494,6 @@ package body Freeze is\n         Make_Defining_Identifier (Loc, Chars => Chars (New_S)));\n \n       Param_Spec := First (Parameter_Specifications (Spec));\n-\n       while Present (Param_Spec) loop\n          Set_Defining_Identifier (Param_Spec,\n            Make_Defining_Identifier (Loc,\n@@ -569,27 +562,20 @@ package body Freeze is\n \n          if (No (Expression (Decl))\n               and then not Needs_Finalization (Typ)\n-              and then\n-                (not Has_Non_Null_Base_Init_Proc (Typ)\n-                  or else Is_Imported (E)))\n-\n-           or else\n-             (Present (Expression (Decl))\n-               and then Is_Scalar_Type (Typ))\n-\n-           or else\n-             Is_Access_Type (Typ)\n-\n+              and then (not Has_Non_Null_Base_Init_Proc (Typ)\n+                         or else Is_Imported (E)))\n+           or else (Present (Expression (Decl)) and then Is_Scalar_Type (Typ))\n+           or else Is_Access_Type (Typ)\n            or else\n              (Is_Bit_Packed_Array (Typ)\n-               and then\n-                 Is_Modular_Integer_Type (Packed_Array_Type (Typ)))\n+               and then Is_Modular_Integer_Type (Packed_Array_Type (Typ)))\n          then\n             null;\n \n          --  Otherwise, we require the address clause to be constant because\n          --  the call to the initialization procedure (or the attach code) has\n          --  to happen at the point of the declaration.\n+\n          --  Actually the IP call has been moved to the freeze actions\n          --  anyway, so maybe we can relax this restriction???\n \n@@ -843,7 +829,7 @@ package body Freeze is\n                  and then Present (Parent (T))\n                  and then Nkind (Parent (T)) = N_Full_Type_Declaration\n                  and then Nkind (Type_Definition (Parent (T))) =\n-                            N_Record_Definition\n+                                               N_Record_Definition\n                  and then not Null_Present (Type_Definition (Parent (T)))\n                  and then Present (Variant_Part\n                             (Component_List (Type_Definition (Parent (T)))))\n@@ -855,8 +841,7 @@ package body Freeze is\n \n                   if not Is_Constrained (T)\n                     and then\n-                      No (Discriminant_Default_Value\n-                           (First_Discriminant (T)))\n+                      No (Discriminant_Default_Value (First_Discriminant (T)))\n                     and then Unknown_Esize (T)\n                   then\n                      return False;\n@@ -1242,10 +1227,7 @@ package body Freeze is\n       -- Freeze_All_Ent --\n       --------------------\n \n-      procedure Freeze_All_Ent\n-        (From  : Entity_Id;\n-         After : in out Node_Id)\n-      is\n+      procedure Freeze_All_Ent (From : Entity_Id; After : in out Node_Id) is\n          E     : Entity_Id;\n          Flist : List_Id;\n          Lastn : Node_Id;\n@@ -1328,7 +1310,6 @@ package body Freeze is\n \n                begin\n                   Prim  := First_Elmt (Prim_List);\n-\n                   while Present (Prim) loop\n                      Subp := Node (Prim);\n \n@@ -1363,11 +1344,11 @@ package body Freeze is\n                   Bod : constant Node_Id := Next (After);\n \n                begin\n-                  if (Nkind (Bod) = N_Subprogram_Body\n-                        or else Nkind (Bod) = N_Entry_Body\n-                        or else Nkind (Bod) = N_Package_Body\n-                        or else Nkind (Bod) = N_Protected_Body\n-                        or else Nkind (Bod) = N_Task_Body\n+                  if (Nkind_In (Bod, N_Subprogram_Body,\n+                                     N_Entry_Body,\n+                                     N_Package_Body,\n+                                     N_Protected_Body,\n+                                     N_Task_Body)\n                         or else Nkind (Bod) in N_Body_Stub)\n                      and then\n                        List_Containing (After) = List_Containing (Parent (E))\n@@ -1437,11 +1418,10 @@ package body Freeze is\n          then\n             declare\n                Ent : Entity_Id;\n+\n             begin\n                Ent := First_Entity (E);\n-\n                while Present (Ent) loop\n-\n                   if Is_Entry (Ent)\n                     and then not Default_Expressions_Processed (Ent)\n                   then\n@@ -1919,12 +1899,12 @@ package body Freeze is\n \n             --  If the component is an Itype with Delayed_Freeze and is either\n             --  a record or array subtype and its base type has not yet been\n-            --  frozen, we must remove this from the entity list of this\n-            --  record and put it on the entity list of the scope of its base\n-            --  type. Note that we know that this is not the type of a\n-            --  component since we cleared Has_Delayed_Freeze for it in the\n-            --  previous loop. Thus this must be the Designated_Type of an\n-            --  access type, which is the type of a component.\n+            --  frozen, we must remove this from the entity list of this record\n+            --  and put it on the entity list of the scope of its base type.\n+            --  Note that we know that this is not the type of a component\n+            --  since we cleared Has_Delayed_Freeze for it in the previous\n+            --  loop. Thus this must be the Designated_Type of an access type,\n+            --  which is the type of a component.\n \n             if Is_Itype (Comp)\n               and then Is_Type (Scope (Comp))\n@@ -2347,6 +2327,7 @@ package body Freeze is\n             S : Entity_Id := Current_Scope;\n \n          begin\n+\n             while Present (S) loop\n                if Is_Overloadable (S) then\n                   if Comes_From_Source (S)\n@@ -2408,8 +2389,8 @@ package body Freeze is\n          --  Skip this if the entity is stubbed, since we don't need a name\n          --  for any stubbed routine. For the case on intrinsics, if no\n          --  external name is specified, then calls will be handled in\n-         --  Exp_Intr.Expand_Intrinsic_Call, and no name is needed; if\n-         --  an external name is provided, then Expand_Intrinsic_Call leaves\n+         --  Exp_Intr.Expand_Intrinsic_Call, and no name is needed. If an\n+         --  external name is provided, then Expand_Intrinsic_Call leaves\n          --  calls in place for expansion by GIGI.\n \n          if (Is_Imported (E) or else Is_Exported (E))"}, {"sha": "e7e1c470d67fbc5db1785f535817b5b952fb79a7", "filename": "gcc/ada/g-mbdira.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fg-mbdira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fg-mbdira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbdira.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -39,13 +39,14 @@ package body GNAT.MBBS_Discrete_Random is\n    -- Implementation Note --\n    -------------------------\n \n-   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  The design of this spec is a bit awkward, as a result of Ada 95 not\n    --  permitting in-out parameters for function formals (most naturally\n    --  Generator values would be passed this way). In pure Ada 95, the only\n-   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n-   --  controlled types.\n+   --  solution would be to add a self-referential component to the generator\n+   --  allowing access to the generator object from inside the function. This\n+   --  would work because the generator is limited, which prevents any copy.\n \n-   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  This is a bit heavy, so what we do is to use Unrestricted_Access to\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n "}, {"sha": "1d59069d11242d71840a8ed345fd52b2cc574d75", "filename": "gcc/ada/g-mbflra.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fg-mbflra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fg-mbflra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-mbflra.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -37,13 +37,14 @@ package body GNAT.MBBS_Float_Random is\n    -- Implementation Note --\n    -------------------------\n \n-   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  The design of this spec is a bit awkward, as a result of Ada 95 not\n    --  permitting in-out parameters for function formals (most naturally\n    --  Generator values would be passed this way). In pure Ada 95, the only\n-   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n-   --  controlled types.\n+   --  solution would be to add a self-referential component to the generator\n+   --  allowing access to the generator object from inside the function. This\n+   --  would work because the generator is limited, which prevents any copy.\n \n-   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  This is a bit heavy, so what we do is to use Unrestricted_Access to\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n "}, {"sha": "c49b307fdc6a4cebbe5ba395925199507a7809e8", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -861,42 +861,28 @@ begin\n          if Subunits_Missing then\n             Write_Str (\" (missing subunits)\");\n             Write_Eol;\n-            Write_Str (\"to check parent unit\");\n \n          elsif Main_Kind = N_Subunit then\n             Write_Str (\" (subunit)\");\n             Write_Eol;\n-            Write_Str (\"to check subunit\");\n \n          elsif Main_Kind = N_Subprogram_Declaration then\n             Write_Str (\" (subprogram spec)\");\n             Write_Eol;\n-            Write_Str (\"to check subprogram spec\");\n \n          --  Generic package body in GNAT implementation mode\n \n          elsif Main_Kind = N_Package_Body and then GNAT_Mode then\n             Write_Str (\" (predefined generic)\");\n             Write_Eol;\n-            Write_Str (\"to check predefined generic\");\n \n          --  Only other case is a package spec\n \n          else\n             Write_Str (\" (package spec)\");\n             Write_Eol;\n-            Write_Str (\"to check package spec\");\n          end if;\n \n-         Write_Str (\" for errors, use \");\n-\n-         if Hostparm.OpenVMS then\n-            Write_Str (\"/NOLOAD\");\n-         else\n-            Write_Str (\"-gnatc\");\n-         end if;\n-\n-         Write_Eol;\n          Set_Standard_Output;\n \n          Sem_Ch13.Validate_Unchecked_Conversions;"}, {"sha": "87408c30804e2acc9bb8a5845d3ef4de065ef8c3", "filename": "gcc/ada/s-rannum.adb", "status": "modified", "additions": 79, "deletions": 47, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fs-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fs-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -99,30 +99,71 @@ package body System.Random_Numbers is\n    -- Implementation Note --\n    -------------------------\n \n-   --  The design of this spec is very awkward, as a result of Ada 95 not\n-   --  permitting in-out parameters for function formals (most naturally,\n+   --  The design of this spec is a bit awkward, as a result of Ada 95 not\n+   --  permitting in-out parameters for function formals (most naturally\n    --  Generator values would be passed this way). In pure Ada 95, the only\n-   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n-   --  controlled types.\n+   --  solution would be to add a self-referential component to the generator\n+   --  allowing access to the generator object from inside the function. This\n+   --  would work because the generator is limited, which prevents any copy.\n \n-   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  This is a bit heavy, so what we do is to use Unrestricted_Access to\n    --  get a pointer to the state in the passed Generator. This works because\n    --  Generator is a limited type and will thus always be passed by reference.\n \n-   Low31_Mask : constant := 2**31-1;\n-   Bit31_Mask : constant := 2**31;\n-\n-   Matrix_A_X : constant array (State_Val range 0 .. 1) of State_Val :=\n-                  (0, 16#9908b0df#);\n-\n    Y2K : constant Calendar.Time :=\n            Calendar.Time_Of\n              (Year => 2000, Month => 1, Day => 1, Seconds => 0.0);\n-   --  First Year 2000 day\n+   --  First day of Year 2000 (what is this for???)\n \n    Image_Numeral_Length : constant := Max_Image_Width / N;\n    subtype Image_String is String (1 .. Max_Image_Width);\n \n+   ----------------------------\n+   -- Algorithmic Parameters --\n+   ----------------------------\n+\n+   Lower_Mask : constant := 2**31-1;\n+   Upper_Mask : constant := 2**31;\n+\n+   Matrix_A   : constant array (State_Val range 0 .. 1) of State_Val\n+     := (0, 16#9908b0df#);\n+   --  The twist transformation is represented by a matrix of the form\n+   --\n+   --               [  0    I(31) ]\n+   --               [    _a       ]\n+   --\n+   --  where 0 is a 31x31 block of 0s, I(31) is the 31x31 identity matrix and\n+   --  _a is a particular bit row-vector, represented here by a 32-bit integer.\n+   --  If integer x represents a row vector of bits (with x(0), the units bit,\n+   --  last), then\n+   --           x * A = [0 x(31..1)] xor Matrix_A(x(0)).\n+\n+   U      : constant := 11;\n+   S      : constant := 7;\n+   B_Mask : constant := 16#9d2c5680#;\n+   T      : constant := 15;\n+   C_Mask : constant := 16#efc60000#;\n+   L      : constant := 18;\n+   --  The tempering shifts and bit masks, in the order applied\n+\n+   Seed0 : constant := 5489;\n+   --  Default seed, used to initialize the state vector when Reset not called\n+\n+   Seed1 : constant := 19650218;\n+   --  Seed used to initialize the state vector when calling Reset with an\n+   --  initialization vector.\n+\n+   Mult0 : constant := 1812433253;\n+   --  Multiplier for a modified linear congruential generator used to\n+   --  initialize the state vector when calling Reset with a single integer\n+   --  seed.\n+\n+   Mult1 : constant := 1664525;\n+   Mult2 : constant := 1566083941;\n+   --  Multipliers for two modified linear congruential generators used to\n+   --  initialize the state vector when calling Reset with an initialization\n+   --  vector.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -153,40 +194,40 @@ package body System.Random_Numbers is\n    function Random (Gen : Generator) return Unsigned_32 is\n       G : Generator renames Gen'Unrestricted_Access.all;\n       Y : State_Val;\n-      I : Integer;\n+      I : Integer;      --  should avoid use of identifier I ???\n \n    begin\n       I := G.I;\n \n       if I < N - M then\n-         Y := (G.S (I) and Bit31_Mask) or (G.S (I + 1) and Low31_Mask);\n-         Y := G.S (I + M) xor Shift_Right (Y, 1) xor Matrix_A_X (Y and 1);\n+         Y := (G.S (I) and Upper_Mask) or (G.S (I + 1) and Lower_Mask);\n+         Y := G.S (I + M) xor Shift_Right (Y, 1) xor Matrix_A (Y and 1);\n          I := I + 1;\n \n       elsif I < N - 1 then\n-         Y := (G.S (I) and Bit31_Mask) or (G.S (I + 1) and Low31_Mask);\n+         Y := (G.S (I) and Upper_Mask) or (G.S (I + 1) and Lower_Mask);\n          Y := G.S (I + (M - N))\n                 xor Shift_Right (Y, 1)\n-                xor Matrix_A_X (Y and 1);\n+                xor Matrix_A (Y and 1);\n          I := I + 1;\n \n       elsif I = N - 1 then\n-         Y := (G.S (I) and Bit31_Mask) or (G.S (0) and Low31_Mask);\n-         Y := G.S (M - 1) xor Shift_Right (Y, 1) xor Matrix_A_X (Y and 1);\n+         Y := (G.S (I) and Upper_Mask) or (G.S (0) and Lower_Mask);\n+         Y := G.S (M - 1) xor Shift_Right (Y, 1) xor Matrix_A (Y and 1);\n          I := 0;\n \n       else\n-         Init (G, 5489);\n+         Init (G, Seed0);\n          return Random (Gen);\n       end if;\n \n       G.S (G.I) := Y;\n       G.I := I;\n \n-      Y := Y xor Shift_Right (Y, 11);\n-      Y := Y xor (Shift_Left (Y, 7)  and 16#9d2c5680#);\n-      Y := Y xor (Shift_Left (Y, 15) and 16#efc60000#);\n-      Y := Y xor Shift_Right (Y, 18);\n+      Y := Y xor Shift_Right (Y, U);\n+      Y := Y xor (Shift_Left (Y, S)  and B_Mask);\n+      Y := Y xor (Shift_Left (Y, T) and C_Mask);\n+      Y := Y xor Shift_Right (Y, L);\n \n       return Y;\n    end Random;\n@@ -265,17 +306,10 @@ package body System.Random_Numbers is\n \n             Mantissa : Unsigned;\n \n-            X : Real;\n-            --  Scaled mantissa\n-\n-            R : Unsigned_32;\n-            --  Supply of random bits\n-\n-            R_Bits : Natural;\n-            --  Number of bits left in R\n-\n-            K : Bit_Count;\n-            --  Next decrement to exponent\n+            X      : Real;            --  Scaled mantissa\n+            R      : Unsigned_32;     --  Supply of random bits\n+            R_Bits : Natural;         --  Number of bits left in R\n+            K      : Bit_Count;       --  Next decrement to exponent\n \n          begin\n             Mantissa := Random (Gen) / 2**Extra_Bits;\n@@ -388,7 +422,7 @@ package body System.Random_Numbers is\n          declare\n             --  In the 64-bit case, we have to be careful, since not all 64-bit\n             --  unsigned values are representable in GNAT's root_integer type.\n-            --  Ignore different-size warnings here; since GNAT's handling\n+            --  Ignore different-size warnings here since GNAT's handling\n             --  is correct.\n \n             pragma Warnings (\"Z\");  -- better to use msg string! ???\n@@ -482,7 +516,7 @@ package body System.Random_Numbers is\n \n    procedure Reset (Gen : out Generator; Initiator : Integer) is\n    begin\n-      pragma Warnings (\"C\");\n+      pragma Warnings (Off, \"condition is always *\");\n       --  This is probably an unnecessary precaution against future change, but\n       --  since the test is a static expression, no extra code is involved.\n \n@@ -502,23 +536,23 @@ package body System.Random_Numbers is\n          end;\n       end if;\n \n-      pragma Warnings (\"c\");\n+      pragma Warnings (On, \"condition is always *\");\n    end Reset;\n \n    procedure Reset (Gen : out Generator; Initiator : Initialization_Vector) is\n       I, J : Integer;\n \n    begin\n-      Init (Gen, 19650218); -- please give this constant a name ???\n+      Init (Gen, Seed1);\n       I := 1;\n       J := 0;\n \n       if Initiator'Length > 0 then\n          for K in reverse 1 .. Integer'Max (N, Initiator'Length) loop\n             Gen.S (I) :=\n               (Gen.S (I)\n-                 xor ((Gen.S (I - 1) xor Shift_Right (Gen.S (I - 1), 30))\n-                                                                 * 1664525))\n+               xor ((Gen.S (I - 1) xor Shift_Right (Gen.S (I - 1), 30))\n+                    * Mult1))\n               + Initiator (J + Initiator'First) + Unsigned_32 (J);\n \n             I := I + 1;\n@@ -538,7 +572,7 @@ package body System.Random_Numbers is\n       for K in reverse 1 .. N - 1 loop\n          Gen.S (I) :=\n            (Gen.S (I) xor ((Gen.S (I - 1)\n-                            xor Shift_Right (Gen.S (I - 1), 30)) * 1566083941))\n+                            xor Shift_Right (Gen.S (I - 1), 30)) * Mult2))\n            - Unsigned_32 (I);\n          I := I + 1;\n \n@@ -548,7 +582,7 @@ package body System.Random_Numbers is\n          end if;\n       end loop;\n \n-      Gen.S (0) := Bit31_Mask;\n+      Gen.S (0) := Upper_Mask;\n    end Reset;\n \n    procedure Reset (Gen : out Generator; From_State : Generator) is\n@@ -612,7 +646,6 @@ package body System.Random_Numbers is\n \n    begin\n       Result := (others => ' ');\n-\n       for J in 0 .. N - 1 loop\n          Insert_Image (Result, J, Gen.S ((J + Gen.I) mod N));\n       end loop;\n@@ -643,9 +676,8 @@ package body System.Random_Numbers is\n \n       for I in 1 .. N - 1 loop\n          Gen.S (I) :=\n-           1812433253\n-             * (Gen.S (I - 1) xor Shift_Right (Gen.S (I - 1), 30))\n-           + Unsigned_32 (I);\n+           Mult0 * (Gen.S (I - 1) xor Shift_Right (Gen.S (I - 1), 30)) +\n+                                                             Unsigned_32 (I);\n       end loop;\n \n       Gen.I := 0;"}, {"sha": "c61d86b94c64dcf29003cf011c62330439337704", "filename": "gcc/ada/s-rannum.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fs-rannum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fs-rannum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.ads?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2007,2009  Free Software Foundation, Inc.         --\n+--          Copyright (C) 2007-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -140,7 +140,7 @@ private\n       --  The shift register, a circular buffer\n \n       I : Integer := N;\n-      --  Current starting position in shift register S\n+      --  Current starting position in shift register S (N means uninitialized)\n    end record;\n \n end System.Random_Numbers;"}, {"sha": "98fc4c1d04cf104758dc82fa832077202d98510d", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545cb5be91f8dcaef5b5d27977e47970773d4cca/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=545cb5be91f8dcaef5b5d27977e47970773d4cca", "patch": "@@ -215,18 +215,18 @@ package body Switch.M is\n \n                   --  One-letter switches\n \n-                  when 'a' | 'A' | 'b' | 'c' | 'D' | 'E' | 'f' |\n-                    'F' | 'g' | 'h' | 'H' | 'k' | 'l' | 'L' | 'n' | 'N' |\n-                    'o' | 'O' | 'p' | 'P' | 'q' | 'Q' | 'r' | 's' | 't' |\n-                    'u' | 'U' | 'v' | 'x' | 'X' | 'Z' =>\n+                  when 'a' | 'A' | 'b' | 'c' | 'D' | 'E' | 'f' | 'F' |\n+                       'g' | 'h' | 'H' | 'l' | 'L' | 'n' | 'N' | 'o' |\n+                       'O' | 'p' | 'P' | 'q' | 'Q' | 'r' | 's' | 't' |\n+                       'u' | 'U' | 'v' | 'x' | 'X' | 'Z' =>\n                      Storing (First_Stored) := C;\n                      Add_Switch_Component\n                        (Storing (Storing'First .. First_Stored));\n                      Ptr := Ptr + 1;\n \n                   --  One-letter switches followed by a positive number\n \n-                  when 'm' | 'T' =>\n+                  when 'k' | 'm' | 'T' =>\n                      Storing (First_Stored) := C;\n                      Last_Stored := First_Stored;\n "}]}