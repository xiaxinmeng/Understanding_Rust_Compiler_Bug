{"sha": "af795c3cac686b80f842a66e8bd836c01654dce5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY3OTVjM2NhYzY4NmI4MGY4NDJhNjZlOGJkODM2YzAxNjU0ZGNlNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-14T23:53:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-14T23:53:02Z"}, "message": "ia64.h (enum fetchop_code): Remove.\n\n        * config/ia64/ia64.h (enum fetchop_code): Remove.\n        (enum ia64_builtins): Move ...\n        * config/ia64/ia64.c (enum ia64_builtins): ... here.  Remove all\n        members except BSP and FLUSHRS.\n        (ia64_init_builtins): Remove __sync builtins.\n        (ia64_expand_builtin): Likewise.\n        (ia64_expand_fetch_and_op, ia64_expand_op_and_fetch): Remove.\n        (ia64_expand_compare_and_swap, ia64_expand_lock_test_and_set): Remove.\n        (ia64_expand_lock_release): Remove.\n        * config/ia64/ia64.md (mf): Move to sync.md.\n        (mf_internal, fetchadd_acq_si, fetchadd_acq_di, cmpxchg_acq_si,\n        cmpxchg_acq_di, xchgsi, xchgdi): Likewise.\n        * config/ia64/sync.md: New file.\n        (memory_barrier): Rename from mf.\n        (fetchadd_acq_<I48MODE>): Macroize from _si/_di patterns.\n        (cmpxchg_acq_<I48MODE>): Likewise.\n        (sync_lock_test_and_set<I48MODE>): Likewise.\n\n        * config/ia64/ia64intrin.h: Define nothing for C; limit #defines\n        to c++.  Remove __sync* declarations.  s/_si/_4/.  s/_di/_8/.\n\nFrom-SVN: r98156", "tree": {"sha": "82f8ab5a2bb454f3279533ed84e6f0989b9069b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f8ab5a2bb454f3279533ed84e6f0989b9069b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af795c3cac686b80f842a66e8bd836c01654dce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af795c3cac686b80f842a66e8bd836c01654dce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af795c3cac686b80f842a66e8bd836c01654dce5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af795c3cac686b80f842a66e8bd836c01654dce5/comments", "author": null, "committer": null, "parents": [{"sha": "1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef45b7773cfcce6e6e952b8a15713bd321adc9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef45b7773cfcce6e6e952b8a15713bd321adc9e"}], "stats": {"total": 914, "additions": 187, "deletions": 727}, "files": [{"sha": "eb8f4db0ea4b54d272bcc1a72cd310cc1488237a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af795c3cac686b80f842a66e8bd836c01654dce5", "patch": "@@ -1,3 +1,26 @@\n+2004-04-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.h (enum fetchop_code): Remove.\n+\t(enum ia64_builtins): Move ...\n+\t* config/ia64/ia64.c (enum ia64_builtins): ... here.  Remove all\n+\tmembers except BSP and FLUSHRS.\n+\t(ia64_init_builtins): Remove __sync builtins.\n+\t(ia64_expand_builtin): Likewise.\n+\t(ia64_expand_fetch_and_op, ia64_expand_op_and_fetch): Remove.\n+\t(ia64_expand_compare_and_swap, ia64_expand_lock_test_and_set): Remove.\n+\t(ia64_expand_lock_release): Remove.\n+\t* config/ia64/ia64.md (mf): Move to sync.md.\n+\t(mf_internal, fetchadd_acq_si, fetchadd_acq_di, cmpxchg_acq_si,\n+\tcmpxchg_acq_di, xchgsi, xchgdi): Likewise.\n+\t* config/ia64/sync.md: New file.\n+\t(memory_barrier): Rename from mf.\n+\t(fetchadd_acq_<I48MODE>): Macroize from _si/_di patterns.\n+\t(cmpxchg_acq_<I48MODE>): Likewise.\n+\t(sync_lock_test_and_set<I48MODE>): Likewise.\n+\n+\t* config/ia64/ia64intrin.h: Define nothing for C; limit #defines\n+\tto c++.  Remove __sync* declarations.  s/_si/_4/.  s/_di/_8/.\n+\n 2004-04-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (x86_cmpxchg, x86_xadd): New."}, {"sha": "55fde10d029b828c8db8290cf69810b50cbc5d13", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 6, "deletions": 510, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=af795c3cac686b80f842a66e8bd836c01654dce5", "patch": "@@ -199,12 +199,6 @@ static bool ia64_in_small_data_p (tree);\n static void process_epilogue (void);\n static int process_set (FILE *, rtx);\n \n-static rtx ia64_expand_fetch_and_op (optab, enum machine_mode, tree, rtx);\n-static rtx ia64_expand_op_and_fetch (optab, enum machine_mode, tree, rtx);\n-static rtx ia64_expand_compare_and_swap (enum machine_mode, enum machine_mode,\n-\t\t\t\t\t int, tree, rtx);\n-static rtx ia64_expand_lock_test_and_set (enum machine_mode, tree, rtx);\n-static rtx ia64_expand_lock_release (enum machine_mode, tree, rtx);\n static bool ia64_assemble_integer (rtx, unsigned int, int);\n static void ia64_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void ia64_output_function_epilogue (FILE *, HOST_WIDE_INT);\n@@ -7854,51 +7848,15 @@ process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n }\n \n \f\n+enum ia64_builtins\n+{\n+  IA64_BUILTIN_BSP,\n+  IA64_BUILTIN_FLUSHRS\n+};\n+\n void\n ia64_init_builtins (void)\n {\n-  tree psi_type_node = build_pointer_type (integer_type_node);\n-  tree pdi_type_node = build_pointer_type (long_integer_type_node);\n-\n-  /* __sync_val_compare_and_swap_si, __sync_bool_compare_and_swap_si */\n-  tree si_ftype_psi_si_si\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tpsi_type_node, integer_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-\n-  /* __sync_val_compare_and_swap_di */\n-  tree di_ftype_pdi_di_di\n-    = build_function_type_list (long_integer_type_node,\n-\t\t\t\tpdi_type_node, long_integer_type_node,\n-\t\t\t\tlong_integer_type_node, NULL_TREE);\n-  /* __sync_bool_compare_and_swap_di */\n-  tree si_ftype_pdi_di_di\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tpdi_type_node, long_integer_type_node,\n-\t\t\t\tlong_integer_type_node, NULL_TREE);\n-  /* __sync_synchronize */\n-  tree void_ftype_void\n-    = build_function_type (void_type_node, void_list_node);\n-\n-  /* __sync_lock_test_and_set_si */\n-  tree si_ftype_psi_si\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tpsi_type_node, integer_type_node, NULL_TREE);\n-\n-  /* __sync_lock_test_and_set_di */\n-  tree di_ftype_pdi_di\n-    = build_function_type_list (long_integer_type_node,\n-\t\t\t\tpdi_type_node, long_integer_type_node,\n-\t\t\t\tNULL_TREE);\n-\n-  /* __sync_lock_release_si */\n-  tree void_ftype_psi\n-    = build_function_type_list (void_type_node, psi_type_node, NULL_TREE);\n-\n-  /* __sync_lock_release_di */\n-  tree void_ftype_pdi\n-    = build_function_type_list (void_type_node, pdi_type_node, NULL_TREE);\n-\n   tree fpreg_type;\n   tree float80_type;\n \n@@ -7933,27 +7891,6 @@ ia64_init_builtins (void)\n   lang_hooks.builtin_function ((name), (type), (code), BUILT_IN_MD,\t\\\n \t\t\t       NULL, NULL_TREE)\n \n-  def_builtin (\"__sync_val_compare_and_swap_si\", si_ftype_psi_si_si,\n-\t       IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI);\n-  def_builtin (\"__sync_val_compare_and_swap_di\", di_ftype_pdi_di_di,\n-\t       IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI);\n-  def_builtin (\"__sync_bool_compare_and_swap_si\", si_ftype_psi_si_si,\n-\t       IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI);\n-  def_builtin (\"__sync_bool_compare_and_swap_di\", si_ftype_pdi_di_di,\n-\t       IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI);\n-\n-  def_builtin (\"__sync_synchronize\", void_ftype_void,\n-\t       IA64_BUILTIN_SYNCHRONIZE);\n-\n-  def_builtin (\"__sync_lock_test_and_set_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_LOCK_TEST_AND_SET_SI);\n-  def_builtin (\"__sync_lock_test_and_set_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_LOCK_TEST_AND_SET_DI);\n-  def_builtin (\"__sync_lock_release_si\", void_ftype_psi,\n-\t       IA64_BUILTIN_LOCK_RELEASE_SI);\n-  def_builtin (\"__sync_lock_release_di\", void_ftype_pdi,\n-\t       IA64_BUILTIN_LOCK_RELEASE_DI);\n-\n   def_builtin (\"__builtin_ia64_bsp\",\n \t       build_function_type (ptr_type_node, void_list_node),\n \t       IA64_BUILTIN_BSP);\n@@ -7962,412 +7899,19 @@ ia64_init_builtins (void)\n \t       build_function_type (void_type_node, void_list_node),\n \t       IA64_BUILTIN_FLUSHRS);\n \n-  def_builtin (\"__sync_fetch_and_add_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_FETCH_AND_ADD_SI);\n-  def_builtin (\"__sync_fetch_and_sub_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_FETCH_AND_SUB_SI);\n-  def_builtin (\"__sync_fetch_and_or_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_FETCH_AND_OR_SI);\n-  def_builtin (\"__sync_fetch_and_and_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_FETCH_AND_AND_SI);\n-  def_builtin (\"__sync_fetch_and_xor_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_FETCH_AND_XOR_SI);\n-  def_builtin (\"__sync_fetch_and_nand_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_FETCH_AND_NAND_SI);\n-\n-  def_builtin (\"__sync_add_and_fetch_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_ADD_AND_FETCH_SI);\n-  def_builtin (\"__sync_sub_and_fetch_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_SUB_AND_FETCH_SI);\n-  def_builtin (\"__sync_or_and_fetch_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_OR_AND_FETCH_SI);\n-  def_builtin (\"__sync_and_and_fetch_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_AND_AND_FETCH_SI);\n-  def_builtin (\"__sync_xor_and_fetch_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_XOR_AND_FETCH_SI);\n-  def_builtin (\"__sync_nand_and_fetch_si\", si_ftype_psi_si,\n-\t       IA64_BUILTIN_NAND_AND_FETCH_SI);\n-\n-  def_builtin (\"__sync_fetch_and_add_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_FETCH_AND_ADD_DI);\n-  def_builtin (\"__sync_fetch_and_sub_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_FETCH_AND_SUB_DI);\n-  def_builtin (\"__sync_fetch_and_or_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_FETCH_AND_OR_DI);\n-  def_builtin (\"__sync_fetch_and_and_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_FETCH_AND_AND_DI);\n-  def_builtin (\"__sync_fetch_and_xor_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_FETCH_AND_XOR_DI);\n-  def_builtin (\"__sync_fetch_and_nand_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_FETCH_AND_NAND_DI);\n-\n-  def_builtin (\"__sync_add_and_fetch_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_ADD_AND_FETCH_DI);\n-  def_builtin (\"__sync_sub_and_fetch_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_SUB_AND_FETCH_DI);\n-  def_builtin (\"__sync_or_and_fetch_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_OR_AND_FETCH_DI);\n-  def_builtin (\"__sync_and_and_fetch_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_AND_AND_FETCH_DI);\n-  def_builtin (\"__sync_xor_and_fetch_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_XOR_AND_FETCH_DI);\n-  def_builtin (\"__sync_nand_and_fetch_di\", di_ftype_pdi_di,\n-\t       IA64_BUILTIN_NAND_AND_FETCH_DI);\n-\n #undef def_builtin\n }\n \n-/* Expand fetch_and_op intrinsics.  The basic code sequence is:\n-\n-     mf\n-     tmp = [ptr];\n-     do {\n-       ret = tmp;\n-       ar.ccv = tmp;\n-       tmp <op>= value;\n-       cmpxchgsz.acq tmp = [ptr], tmp\n-     } while (tmp != ret)\n-*/\n-\n-static rtx\n-ia64_expand_fetch_and_op (optab binoptab, enum machine_mode mode,\n-\t\t\t  tree arglist, rtx target)\n-{\n-  rtx ret, label, tmp, ccv, insn, mem, value;\n-  tree arg0, arg1;\n-\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-  if (GET_MODE(mem) != Pmode)\n-    mem = convert_memory_address (Pmode, mem);\n-#endif\n-  value = expand_expr (arg1, NULL_RTX, mode, 0);\n-\n-  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n-  MEM_VOLATILE_P (mem) = 1;\n-\n-  if (target && register_operand (target, mode))\n-    ret = target;\n-  else\n-    ret = gen_reg_rtx (mode);\n-\n-  emit_insn (gen_mf ());\n-\n-  /* Special case for fetchadd instructions.  */\n-  if (binoptab == add_optab && fetchadd_operand (value, VOIDmode))\n-    {\n-      if (mode == SImode)\n-        insn = gen_fetchadd_acq_si (ret, mem, value);\n-      else\n-        insn = gen_fetchadd_acq_di (ret, mem, value);\n-      emit_insn (insn);\n-      return ret;\n-    }\n-\n-  tmp = gen_reg_rtx (mode);\n-  /* ar.ccv must always be loaded with a zero-extended DImode value.  */\n-  ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n-  emit_move_insn (tmp, mem);\n-\n-  label = gen_label_rtx ();\n-  emit_label (label);\n-  emit_move_insn (ret, tmp);\n-  convert_move (ccv, tmp, /*unsignedp=*/1);\n-\n-  /* Perform the specific operation.  Special case NAND by noticing\n-     one_cmpl_optab instead.  */\n-  if (binoptab == one_cmpl_optab)\n-    {\n-      tmp = expand_unop (mode, binoptab, tmp, NULL, OPTAB_WIDEN);\n-      binoptab = and_optab;\n-    }\n-  tmp = expand_binop (mode, binoptab, tmp, value, tmp, 1, OPTAB_WIDEN);\n-\n-  if (mode == SImode)\n-    insn = gen_cmpxchg_acq_si (tmp, mem, tmp, ccv);\n-  else\n-    insn = gen_cmpxchg_acq_di (tmp, mem, tmp, ccv);\n-  emit_insn (insn);\n-\n-  emit_cmp_and_jump_insns (tmp, ret, NE, 0, mode, 1, label);\n-\n-  return ret;\n-}\n-\n-/* Expand op_and_fetch intrinsics.  The basic code sequence is:\n-\n-     mf\n-     tmp = [ptr];\n-     do {\n-       old = tmp;\n-       ar.ccv = tmp;\n-       ret = tmp <op> value;\n-       cmpxchgsz.acq tmp = [ptr], ret\n-     } while (tmp != old)\n-*/\n-\n-static rtx\n-ia64_expand_op_and_fetch (optab binoptab, enum machine_mode mode,\n-\t\t\t  tree arglist, rtx target)\n-{\n-  rtx old, label, tmp, ret, ccv, insn, mem, value;\n-  tree arg0, arg1;\n-\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  mem = expand_expr (arg0, NULL_RTX, Pmode, 0);\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-  if (GET_MODE(mem) != Pmode)\n-    mem = convert_memory_address (Pmode, mem);\n-#endif\n-\n-  value = expand_expr (arg1, NULL_RTX, mode, 0);\n-\n-  mem = gen_rtx_MEM (mode, force_reg (Pmode, mem));\n-  MEM_VOLATILE_P (mem) = 1;\n-\n-  if (target && ! register_operand (target, mode))\n-    target = NULL_RTX;\n-\n-  emit_insn (gen_mf ());\n-  tmp = gen_reg_rtx (mode);\n-  old = gen_reg_rtx (mode);\n-  /* ar.ccv must always be loaded with a zero-extended DImode value.  */\n-  ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n-\n-  emit_move_insn (tmp, mem);\n-\n-  label = gen_label_rtx ();\n-  emit_label (label);\n-  emit_move_insn (old, tmp);\n-  convert_move (ccv, tmp, /*unsignedp=*/1);\n-\n-  /* Perform the specific operation.  Special case NAND by noticing\n-     one_cmpl_optab instead.  */\n-  if (binoptab == one_cmpl_optab)\n-    {\n-      tmp = expand_unop (mode, binoptab, tmp, NULL, OPTAB_WIDEN);\n-      binoptab = and_optab;\n-    }\n-  ret = expand_binop (mode, binoptab, tmp, value, target, 1, OPTAB_WIDEN);\n-\n-  if (mode == SImode)\n-    insn = gen_cmpxchg_acq_si (tmp, mem, ret, ccv);\n-  else\n-    insn = gen_cmpxchg_acq_di (tmp, mem, ret, ccv);\n-  emit_insn (insn);\n-\n-  emit_cmp_and_jump_insns (tmp, old, NE, 0, mode, 1, label);\n-\n-  return ret;\n-}\n-\n-/* Expand val_ and bool_compare_and_swap.  For val_ we want:\n-\n-     ar.ccv = oldval\n-     mf\n-     cmpxchgsz.acq ret = [ptr], newval, ar.ccv\n-     return ret\n-\n-   For bool_ it's the same except return ret == oldval.\n-*/\n-\n-static rtx\n-ia64_expand_compare_and_swap (enum machine_mode rmode, enum machine_mode mode,\n-\t\t\t      int boolp, tree arglist, rtx target)\n-{\n-  tree arg0, arg1, arg2;\n-  rtx mem, old, new, ccv, tmp, insn;\n-\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-  mem = expand_expr (arg0, NULL_RTX, ptr_mode, 0);\n-  old = expand_expr (arg1, NULL_RTX, mode, 0);\n-  new = expand_expr (arg2, NULL_RTX, mode, 0);\n-\n-  mem = gen_rtx_MEM (mode, force_reg (ptr_mode, mem));\n-  MEM_VOLATILE_P (mem) = 1;\n-\n-  if (GET_MODE (old) != mode)\n-    old = convert_to_mode (mode, old, /*unsignedp=*/1);\n-  if (GET_MODE (new) != mode)\n-    new = convert_to_mode (mode, new, /*unsignedp=*/1);\n-\n-  if (! register_operand (old, mode))\n-    old = copy_to_mode_reg (mode, old);\n-  if (! register_operand (new, mode))\n-    new = copy_to_mode_reg (mode, new);\n-\n-  if (! boolp && target && register_operand (target, mode))\n-    tmp = target;\n-  else\n-    tmp = gen_reg_rtx (mode);\n-\n-  ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n-  convert_move (ccv, old, /*unsignedp=*/1);\n-  emit_insn (gen_mf ());\n-  if (mode == SImode)\n-    insn = gen_cmpxchg_acq_si (tmp, mem, new, ccv);\n-  else\n-    insn = gen_cmpxchg_acq_di (tmp, mem, new, ccv);\n-  emit_insn (insn);\n-\n-  if (boolp)\n-    {\n-      if (! target)\n-\ttarget = gen_reg_rtx (rmode);\n-      return emit_store_flag_force (target, EQ, tmp, old, mode, 1, 1);\n-    }\n-  else\n-    return tmp;\n-}\n-\n-/* Expand lock_test_and_set.  I.e. `xchgsz ret = [ptr], new'.  */\n-\n-static rtx\n-ia64_expand_lock_test_and_set (enum machine_mode mode, tree arglist,\n-\t\t\t       rtx target)\n-{\n-  tree arg0, arg1;\n-  rtx mem, new, ret, insn;\n-\n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  mem = expand_expr (arg0, NULL_RTX, ptr_mode, 0);\n-  new = expand_expr (arg1, NULL_RTX, mode, 0);\n-\n-  mem = gen_rtx_MEM (mode, force_reg (ptr_mode, mem));\n-  MEM_VOLATILE_P (mem) = 1;\n-  if (! register_operand (new, mode))\n-    new = copy_to_mode_reg (mode, new);\n-\n-  if (target && register_operand (target, mode))\n-    ret = target;\n-  else\n-    ret = gen_reg_rtx (mode);\n-\n-  if (mode == SImode)\n-    insn = gen_xchgsi (ret, mem, new);\n-  else\n-    insn = gen_xchgdi (ret, mem, new);\n-  emit_insn (insn);\n-\n-  return ret;\n-}\n-\n-/* Expand lock_release.  I.e. `stsz.rel [ptr] = r0'.  */\n-\n-static rtx\n-ia64_expand_lock_release (enum machine_mode mode, tree arglist,\n-\t\t\t  rtx target ATTRIBUTE_UNUSED)\n-{\n-  tree arg0;\n-  rtx mem;\n-\n-  arg0 = TREE_VALUE (arglist);\n-  mem = expand_expr (arg0, NULL_RTX, ptr_mode, 0);\n-\n-  mem = gen_rtx_MEM (mode, force_reg (ptr_mode, mem));\n-  MEM_VOLATILE_P (mem) = 1;\n-\n-  emit_move_insn (mem, const0_rtx);\n-\n-  return const0_rtx;\n-}\n-\n rtx\n ia64_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  enum machine_mode rmode = VOIDmode;\n \n   switch (fcode)\n     {\n-    case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI:\n-    case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI:\n-      mode = SImode;\n-      rmode = SImode;\n-      break;\n-\n-    case IA64_BUILTIN_LOCK_TEST_AND_SET_SI:\n-    case IA64_BUILTIN_LOCK_RELEASE_SI:\n-    case IA64_BUILTIN_FETCH_AND_ADD_SI:\n-    case IA64_BUILTIN_FETCH_AND_SUB_SI:\n-    case IA64_BUILTIN_FETCH_AND_OR_SI:\n-    case IA64_BUILTIN_FETCH_AND_AND_SI:\n-    case IA64_BUILTIN_FETCH_AND_XOR_SI:\n-    case IA64_BUILTIN_FETCH_AND_NAND_SI:\n-    case IA64_BUILTIN_ADD_AND_FETCH_SI:\n-    case IA64_BUILTIN_SUB_AND_FETCH_SI:\n-    case IA64_BUILTIN_OR_AND_FETCH_SI:\n-    case IA64_BUILTIN_AND_AND_FETCH_SI:\n-    case IA64_BUILTIN_XOR_AND_FETCH_SI:\n-    case IA64_BUILTIN_NAND_AND_FETCH_SI:\n-      mode = SImode;\n-      break;\n-\n-    case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI:\n-      mode = DImode;\n-      rmode = SImode;\n-      break;\n-\n-    case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI:\n-      mode = DImode;\n-      rmode = DImode;\n-      break;\n-\n-    case IA64_BUILTIN_LOCK_TEST_AND_SET_DI:\n-    case IA64_BUILTIN_LOCK_RELEASE_DI:\n-    case IA64_BUILTIN_FETCH_AND_ADD_DI:\n-    case IA64_BUILTIN_FETCH_AND_SUB_DI:\n-    case IA64_BUILTIN_FETCH_AND_OR_DI:\n-    case IA64_BUILTIN_FETCH_AND_AND_DI:\n-    case IA64_BUILTIN_FETCH_AND_XOR_DI:\n-    case IA64_BUILTIN_FETCH_AND_NAND_DI:\n-    case IA64_BUILTIN_ADD_AND_FETCH_DI:\n-    case IA64_BUILTIN_SUB_AND_FETCH_DI:\n-    case IA64_BUILTIN_OR_AND_FETCH_DI:\n-    case IA64_BUILTIN_AND_AND_FETCH_DI:\n-    case IA64_BUILTIN_XOR_AND_FETCH_DI:\n-    case IA64_BUILTIN_NAND_AND_FETCH_DI:\n-      mode = DImode;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  switch (fcode)\n-    {\n-    case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI:\n-    case IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI:\n-      return ia64_expand_compare_and_swap (rmode, mode, 1, arglist,\n-\t\t\t\t\t   target);\n-\n-    case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI:\n-    case IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI:\n-      return ia64_expand_compare_and_swap (rmode, mode, 0, arglist,\n-\t\t\t\t\t   target);\n-\n-    case IA64_BUILTIN_SYNCHRONIZE:\n-      emit_insn (gen_mf ());\n-      return const0_rtx;\n-\n-    case IA64_BUILTIN_LOCK_TEST_AND_SET_SI:\n-    case IA64_BUILTIN_LOCK_TEST_AND_SET_DI:\n-      return ia64_expand_lock_test_and_set (mode, arglist, target);\n-\n-    case IA64_BUILTIN_LOCK_RELEASE_SI:\n-    case IA64_BUILTIN_LOCK_RELEASE_DI:\n-      return ia64_expand_lock_release (mode, arglist, target);\n-\n     case IA64_BUILTIN_BSP:\n       if (! target || ! register_operand (target, DImode))\n \ttarget = gen_reg_rtx (DImode);\n@@ -8381,54 +7925,6 @@ ia64_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       emit_insn (gen_flushrs ());\n       return const0_rtx;\n \n-    case IA64_BUILTIN_FETCH_AND_ADD_SI:\n-    case IA64_BUILTIN_FETCH_AND_ADD_DI:\n-      return ia64_expand_fetch_and_op (add_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_FETCH_AND_SUB_SI:\n-    case IA64_BUILTIN_FETCH_AND_SUB_DI:\n-      return ia64_expand_fetch_and_op (sub_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_FETCH_AND_OR_SI:\n-    case IA64_BUILTIN_FETCH_AND_OR_DI:\n-      return ia64_expand_fetch_and_op (ior_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_FETCH_AND_AND_SI:\n-    case IA64_BUILTIN_FETCH_AND_AND_DI:\n-      return ia64_expand_fetch_and_op (and_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_FETCH_AND_XOR_SI:\n-    case IA64_BUILTIN_FETCH_AND_XOR_DI:\n-      return ia64_expand_fetch_and_op (xor_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_FETCH_AND_NAND_SI:\n-    case IA64_BUILTIN_FETCH_AND_NAND_DI:\n-      return ia64_expand_fetch_and_op (one_cmpl_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_ADD_AND_FETCH_SI:\n-    case IA64_BUILTIN_ADD_AND_FETCH_DI:\n-      return ia64_expand_op_and_fetch (add_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_SUB_AND_FETCH_SI:\n-    case IA64_BUILTIN_SUB_AND_FETCH_DI:\n-      return ia64_expand_op_and_fetch (sub_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_OR_AND_FETCH_SI:\n-    case IA64_BUILTIN_OR_AND_FETCH_DI:\n-      return ia64_expand_op_and_fetch (ior_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_AND_AND_FETCH_SI:\n-    case IA64_BUILTIN_AND_AND_FETCH_DI:\n-      return ia64_expand_op_and_fetch (and_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_XOR_AND_FETCH_SI:\n-    case IA64_BUILTIN_XOR_AND_FETCH_DI:\n-      return ia64_expand_op_and_fetch (xor_optab, mode, arglist, target);\n-\n-    case IA64_BUILTIN_NAND_AND_FETCH_SI:\n-    case IA64_BUILTIN_NAND_AND_FETCH_DI:\n-      return ia64_expand_op_and_fetch (one_cmpl_optab, mode, arglist, target);\n-\n     default:\n       break;\n     }"}, {"sha": "857de66122fa5ddad70e90158b9e5bac453f90c4", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=af795c3cac686b80f842a66e8bd836c01654dce5", "patch": "@@ -2034,66 +2034,6 @@ struct machine_function GTY(())\n   int state_num;\n };\n \n-\n-enum ia64_builtins\n-{\n-  IA64_BUILTIN_SYNCHRONIZE,\n-\n-  IA64_BUILTIN_FETCH_AND_ADD_SI,\n-  IA64_BUILTIN_FETCH_AND_SUB_SI,\n-  IA64_BUILTIN_FETCH_AND_OR_SI,\n-  IA64_BUILTIN_FETCH_AND_AND_SI,\n-  IA64_BUILTIN_FETCH_AND_XOR_SI,\n-  IA64_BUILTIN_FETCH_AND_NAND_SI,\n-\n-  IA64_BUILTIN_ADD_AND_FETCH_SI,\n-  IA64_BUILTIN_SUB_AND_FETCH_SI,\n-  IA64_BUILTIN_OR_AND_FETCH_SI,\n-  IA64_BUILTIN_AND_AND_FETCH_SI,\n-  IA64_BUILTIN_XOR_AND_FETCH_SI,\n-  IA64_BUILTIN_NAND_AND_FETCH_SI,\n-\n-  IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI,\n-  IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI,\n-\n-  IA64_BUILTIN_SYNCHRONIZE_SI,\n-\n-  IA64_BUILTIN_LOCK_TEST_AND_SET_SI,\n-\n-  IA64_BUILTIN_LOCK_RELEASE_SI,\n-\n-  IA64_BUILTIN_FETCH_AND_ADD_DI,\n-  IA64_BUILTIN_FETCH_AND_SUB_DI,\n-  IA64_BUILTIN_FETCH_AND_OR_DI,\n-  IA64_BUILTIN_FETCH_AND_AND_DI,\n-  IA64_BUILTIN_FETCH_AND_XOR_DI,\n-  IA64_BUILTIN_FETCH_AND_NAND_DI,\n-\n-  IA64_BUILTIN_ADD_AND_FETCH_DI,\n-  IA64_BUILTIN_SUB_AND_FETCH_DI,\n-  IA64_BUILTIN_OR_AND_FETCH_DI,\n-  IA64_BUILTIN_AND_AND_FETCH_DI,\n-  IA64_BUILTIN_XOR_AND_FETCH_DI,\n-  IA64_BUILTIN_NAND_AND_FETCH_DI,\n-\n-  IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI,\n-  IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI,\n-\n-  IA64_BUILTIN_SYNCHRONIZE_DI,\n-\n-  IA64_BUILTIN_LOCK_TEST_AND_SET_DI,\n-\n-  IA64_BUILTIN_LOCK_RELEASE_DI,\n-\n-  IA64_BUILTIN_BSP,\n-  IA64_BUILTIN_FLUSHRS\n-};\n-\n-/* Codes for expand_compare_and_swap and expand_swap_and_compare.  */\n-enum fetchop_code {\n-  IA64_ADD_OP, IA64_SUB_OP, IA64_OR_OP, IA64_AND_OP, IA64_XOR_OP, IA64_NAND_OP\n-};\n-\n #define DONT_USE_BUILTIN_SETJMP\n \n /* Output any profiling code before the prologue.  */\n@@ -2104,7 +2044,6 @@ enum fetchop_code {\n /* Initialize library function table. */\n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS ia64_init_libfuncs\n-\n \f\n \n /* Switch on code for querying unit reservations.  */"}, {"sha": "d4ab9ffa18cca3d4df562e34519ccad2598d0283", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=af795c3cac686b80f842a66e8bd836c01654dce5", "patch": "@@ -6047,88 +6047,6 @@\n   DONE;\n })\n \n-\f\n-;;; Intrinsics support.\n-\n-(define_expand \"mf\"\n-  [(set (mem:BLK (match_dup 0))\n-\t(unspec:BLK [(mem:BLK (match_dup 0))] UNSPEC_MF))]\n-  \"\"\n-{\n-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n-  MEM_VOLATILE_P (operands[0]) = 1;\n-})\n-\n-(define_insn \"*mf_internal\"\n-  [(set (match_operand:BLK 0 \"\" \"\")\n-\t(unspec:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPEC_MF))]\n-  \"\"\n-  \"mf\"\n-  [(set_attr \"itanium_class\" \"syst_m\")])\n-\n-(define_insn \"fetchadd_acq_si\"\n-  [(set (match_operand:SI 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-\t(unspec:SI [(match_dup 1)\n-\t\t    (match_operand:SI 2 \"fetchadd_operand\" \"n\")]\n-\t\t   UNSPEC_FETCHADD_ACQ))]\n-  \"\"\n-  \"fetchadd4.acq %0 = %1, %2\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n-\n-(define_insn \"fetchadd_acq_di\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-\t(unspec:DI [(match_dup 1)\n-\t\t    (match_operand:DI 2 \"fetchadd_operand\" \"n\")]\n-\t\t   UNSPEC_FETCHADD_ACQ))]\n-  \"\"\n-  \"fetchadd8.acq %0 = %1, %2\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n-\n-(define_insn \"cmpxchg_acq_si\"\n-  [(set (match_operand:SI 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-        (unspec:SI [(match_dup 1)\n-                    (match_operand:SI 2 \"gr_register_operand\" \"r\")\n-\t\t    (match_operand:DI 3 \"ar_ccv_reg_operand\" \"\")]\n-\t\t   UNSPEC_CMPXCHG_ACQ))]\n-  \"\"\n-  \"cmpxchg4.acq %0 = %1, %2, %3\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n-\n-(define_insn \"cmpxchg_acq_di\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-        (unspec:DI [(match_dup 1)\n-                    (match_operand:DI 2 \"gr_register_operand\" \"r\")\n-\t\t    (match_operand:DI 3 \"ar_ccv_reg_operand\" \"\")]\n-\t\t   UNSPEC_CMPXCHG_ACQ))]\n-  \"\"\n-  \"cmpxchg8.acq %0 = %1, %2, %3\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n-\n-(define_insn \"xchgsi\"\n-  [(set (match_operand:SI 0 \"gr_register_operand\" \"=r\")\n-        (match_operand:SI 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-        (match_operand:SI 2 \"gr_register_operand\" \"r\"))]\n-  \"\"\n-  \"xchg4 %0 = %1, %2\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n-\n-(define_insn \"xchgdi\"\n-  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n-        (match_operand:DI 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-        (match_operand:DI 2 \"gr_register_operand\" \"r\"))]\n-  \"\"\n-  \"xchg8 %0 = %1, %2\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n \f\n ;; Predication.\n \n@@ -6200,3 +6118,5 @@\n \n ;; Vector operations\n (include \"vect.md\")\n+;; Atomic operations\n+(include \"sync.md\")"}, {"sha": "6054219f48a8a45ac5d33433414913f89a9b6e83", "filename": "gcc/config/ia64/ia64intrin.h", "status": "modified", "additions": 35, "deletions": 74, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fia64intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64intrin.h?ref=af795c3cac686b80f842a66e8bd836c01654dce5", "patch": "@@ -1,130 +1,91 @@\n #ifndef _IA64INTRIN_H_INCLUDED\n #define _IA64INTRIN_H_INCLUDED\n \n-/* Actually, everything is a compiler builtin, but just so\n-   there's no confusion...  */\n+/* ??? Overloaded builtins havn't been ported to C++ yet.  */\n #ifdef __cplusplus\n-extern \"C\" {\n-#endif\n \n-extern void __sync_synchronize (void);\n-\n-extern int __sync_val_compare_and_swap_si (int *, int, int);\n-extern long __sync_val_compare_and_swap_di (long *, long, long);\n #define __sync_val_compare_and_swap(PTR, OLD, NEW)\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n   ? (__typeof__(*(PTR)))\t\t\t\t\t\t\\\n-    __sync_val_compare_and_swap_si((int *)(void *)(PTR),(int)(OLD),(int)(NEW))\t\\\n+    __sync_val_compare_and_swap_4((int *)(void *)(PTR),(int)(OLD),(int)(NEW))\t\\\n   : (__typeof__(*(PTR)))\t\t\t\t\t\t\\\n-    __sync_val_compare_and_swap_di((long *)(void *)(PTR),(long)(OLD),(long)(NEW)))\n+    __sync_val_compare_and_swap_8((long *)(void *)(PTR),(long)(OLD),(long)(NEW)))\n \n-extern int __sync_bool_compare_and_swap_si (int *, int, int);\n-extern int __sync_bool_compare_and_swap_di (long *, long, long);\n #define __sync_bool_compare_and_swap(PTR, OLD, NEW)\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? __sync_bool_compare_and_swap_si((int *)(void *)(PTR),(int)(OLD),(int)(NEW))\t\\\n-  : __sync_bool_compare_and_swap_di((long *)(void *)(PTR),(long)(OLD),(long)(NEW)))\n+  ? __sync_bool_compare_and_swap_4((int *)(void *)(PTR),(int)(OLD),(int)(NEW))\t\\\n+  : __sync_bool_compare_and_swap_8((long *)(void *)(PTR),(long)(OLD),(long)(NEW)))\n \n-extern void __sync_lock_release_si (int *);\n-extern void __sync_lock_release_di (long *);\n #define __sync_lock_release(PTR)\t\t\\\n   ((sizeof (*(PTR)) == sizeof(int))\t\t\\\n-   ? __sync_lock_release_si((int *)(void *)(PTR))\t\\\n-   : __sync_lock_release_di((long *)(void *)(PTR)))\n+   ? __sync_lock_release_4((int *)(void *)(PTR))\t\\\n+   : __sync_lock_release_8((long *)(void *)(PTR)))\n \n-extern int __sync_lock_test_and_set_si (int *, int);\n-extern long __sync_lock_test_and_set_di (long *, long);\n #define __sync_lock_test_and_set(PTR,VAL)\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_lock_test_and_set_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_lock_test_and_set_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_lock_test_and_set_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_lock_test_and_set_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_fetch_and_add_si (int *, int);\n-extern long __sync_fetch_and_add_di (long *, long);\n #define __sync_fetch_and_add(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_fetch_and_add_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_fetch_and_add_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_fetch_and_add_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_fetch_and_add_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_fetch_and_sub_si (int *, int);\n-extern long __sync_fetch_and_sub_di (long *, long);\n #define __sync_fetch_and_sub(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_fetch_and_sub_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_fetch_and_sub_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_fetch_and_sub_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_fetch_and_sub_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_fetch_and_and_si (int *, int);\n-extern long __sync_fetch_and_and_di (long *, long);\n #define __sync_fetch_and_and(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_fetch_and_and_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_fetch_and_and_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_fetch_and_and_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_fetch_and_and_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_fetch_and_or_si (int *, int);\n-extern long __sync_fetch_and_or_di (long *, long);\n #define __sync_fetch_and_or(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_fetch_and_or_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_fetch_and_or_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_fetch_and_or_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_fetch_and_or_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_fetch_and_xor_si (int *, int);\n-extern long __sync_fetch_and_xor_di (long *, long);\n #define __sync_fetch_and_xor(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_fetch_and_xor_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_fetch_and_xor_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_fetch_and_xor_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_fetch_and_xor_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_fetch_and_nand_si (int *, int);\n-extern long __sync_fetch_and_nand_di (long *, long);\n #define __sync_fetch_and_nand(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_fetch_and_nand_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_fetch_and_nand_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_fetch_and_nand_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_fetch_and_nand_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_add_and_fetch_si (int *, int);\n-extern long __sync_add_and_fetch_di (long *, long);\n #define __sync_add_and_fetch(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_add_and_fetch_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_add_and_fetch_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_add_and_fetch_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_add_and_fetch_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_sub_and_fetch_si (int *, int);\n-extern long __sync_sub_and_fetch_di (long *, long);\n #define __sync_sub_and_fetch(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_sub_and_fetch_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_sub_and_fetch_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_sub_and_fetch_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_sub_and_fetch_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_and_and_fetch_si (int *, int);\n-extern long __sync_and_and_fetch_di (long *, long);\n #define __sync_and_and_fetch(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_and_and_fetch_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_and_and_fetch_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_and_and_fetch_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_and_and_fetch_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_or_and_fetch_si (int *, int);\n-extern long __sync_or_and_fetch_di (long *, long);\n #define __sync_or_and_fetch(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_or_and_fetch_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_or_and_fetch_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_or_and_fetch_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_or_and_fetch_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_xor_and_fetch_si (int *, int);\n-extern long __sync_xor_and_fetch_di (long *, long);\n #define __sync_xor_and_fetch(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_xor_and_fetch_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_xor_and_fetch_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_xor_and_fetch_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_xor_and_fetch_8((long *)(void *)(PTR),(long)(VAL)))\n \n-extern int __sync_nand_and_fetch_si (int *, int);\n-extern long __sync_nand_and_fetch_di (long *, long);\n #define __sync_nand_and_fetch(PTR,VAL)\t\t\t\t\t\\\n  ((sizeof (*(PTR)) == sizeof(int))\t\t\t\t\t\\\n-  ? (__typeof__(*(PTR))) __sync_nand_and_fetch_si((int *)(void *)(PTR),(int)(VAL)) \\\n-  : (__typeof__(*(PTR))) __sync_nand_and_fetch_di((long *)(void *)(PTR),(long)(VAL)))\n+  ? (__typeof__(*(PTR))) __sync_nand_and_fetch_4((int *)(void *)(PTR),(int)(VAL)) \\\n+  : (__typeof__(*(PTR))) __sync_nand_and_fetch_8((long *)(void *)(PTR),(long)(VAL)))\n \n-#ifdef __cplusplus\n-}\n-#endif\n+#endif /* __cplusplus */\n \n-#endif\n+#endif /* _IA64INTRIN_H_INCLUDED */"}, {"sha": "ed3304a7ad6eefb63f0866462928e16535c10f70", "filename": "gcc/config/ia64/sync.md", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af795c3cac686b80f842a66e8bd836c01654dce5/gcc%2Fconfig%2Fia64%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsync.md?ref=af795c3cac686b80f842a66e8bd836c01654dce5", "patch": "@@ -0,0 +1,121 @@\n+;; GCC machine description for IA-64 synchronization instructions.\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_mode_macro I48MODE [SI DI])\n+(define_mode_attr modesuffix [(SI \"4\") (DI \"8\")])\n+\n+\n+(define_expand \"memory_barrier\"\n+  [(set (mem:BLK (match_dup 0))\n+\t(unspec:BLK [(mem:BLK (match_dup 0))] UNSPEC_MF))]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+})\n+\n+(define_insn \"*mf_internal\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPEC_MF))]\n+  \"\"\n+  \"mf\"\n+  [(set_attr \"itanium_class\" \"syst_m\")])\n+\n+(define_expand \"sync_add<mode>\"\n+  [(match_operand:I48MODE 0 \"gr_register_operand\" \"\")\n+   (match_operand:I48MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I48MODE 2 \"general_operand\" \"\")]\n+  \"\"\n+{\n+  if (!fetchadd_operand (operands[2], <MODE>mode))\n+    FAIL;\n+  emit_insn (gen_memory_barrier ());\n+  emit_insn (gen_fetchadd_acq_<mode> (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"sync_old_add<mode>\"\n+  [(match_operand:I48MODE 0 \"gr_register_operand\" \"\")\n+   (match_operand:I48MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I48MODE 2 \"general_operand\" \"\")]\n+  \"\"\n+{\n+  if (!fetchadd_operand (operands[2], <MODE>mode))\n+    FAIL;\n+  emit_insn (gen_memory_barrier ());\n+  emit_insn (gen_fetchadd_acq_<mode> (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"fetchadd_acq_<mode>\"\n+  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+\t(unspec:I48MODE [(match_dup 1)\n+\t\t\t (match_operand:I48MODE 2 \"fetchadd_operand\" \"n\")]\n+\t\t        UNSPEC_FETCHADD_ACQ))]\n+  \"\"\n+  \"fetchadd<modesuffix>.acq %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(match_operand:I48MODE 0 \"gr_register_operand\" \"\")\n+   (match_operand:I48MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I48MODE 2 \"gr_register_operand\" \"\")\n+   (match_operand:I48MODE 3 \"gr_register_operand\" \"\")]\n+  \"\"\n+{\n+  rtx ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n+  convert_move (ccv, operands[2], 1);\n+  emit_insn (gen_memory_barrier ());\n+  emit_insn (gen_cmpxchg_acq_<mode> (operands[0], operands[1],\n+\t\t\t\t     ccv, operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"cmpxchg_acq_<mode>\"\n+  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+        (unspec:I48MODE [(match_dup 1)\n+\t\t\t (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n+\t\t\t (match_operand:I48MODE 3 \"gr_register_operand\" \"r\")]\n+\t\t\tUNSPEC_CMPXCHG_ACQ))]\n+  \"\"\n+  \"cmpxchg<modesuffix>.acq %0 = %1, %3, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_insn \"sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n+        (match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+        (match_operand:I48MODE 2 \"gr_register_operand\" \"r\"))]\n+  \"\"\n+  \"xchg<modesuffix> %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_expand \"sync_lock_release<mode>\"\n+  [(set (match_operand:I48MODE 0 \"memory_operand\" \"\")\n+        (const_int 0))]\n+  \"\"\n+{\n+  gcc_assert (MEM_VOLATILE_P (operands[0]));\n+})"}]}