{"sha": "90b480138a5492776e9fab6e7f95aae874d6a0ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBiNDgwMTM4YTU0OTI3NzZlOWZhYjZlN2Y5NWFhZTg3NGQ2YTBlYQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-11-13T12:07:12Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-11-13T12:07:12Z"}, "message": "[ARC] Refurbish and improve prologue/epilogue functions.\n\nReimplement how prologue and epilogue is emitted to accomodate\nenter/leave instructions, as well as improving the size of the\nexisting techinques.\n\nThe following modifications are added:\n\n- millicode thunk calls can be now selected regardless of the\n  optimization level. However they are enabled for size optimizations\n  by default.  Also, the millicode optimization is turned off when we\n  compile for long jumps.\n\n- the compiler is able to use enter/leave instructions for prologue\n  and epilogue. As these instructions are not ABI compatible we gurad\n  them under a switch (i.e., -mcode-density-frame). When this option\n  is on, the compiler will try emitting enter/leave instructions, if\n  not, then millicode thunk calls (if enabled), and latter the regular\n  push/pop instructions.\n\n- The prologue/epilogue is now optimized to use pointer walks, hence\n  improving the chance to have push_s/pop_s instructions emitted. It\n  also tries to combine the stack adjustments with load/store\n  operations.\n\ngcc/\nxxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n        * common/config/arc/arc-common.c (arc_option_optimization_table):\n        Millicode optimization is default on for size optimizations.\n        * config/arc/arc-protos.h (arc_check_multi): New function.\n        * config/arc/arc.c (RTX_OK_FOR_OFFSET_P): Rearange.\n        (ENTER_LEAVE_START_REG): Define.\n        (ENTER_LEAVE_END_REG): Likewise.\n        (arc_override_options): Disable millicode when long calls option\n        is on.\n        (arc_frame_info): Change it from int to bool.\n        (arc_compute_frame_size): Clean up.\n        (arc_save_restore): Remove.\n        (frame_save_reg): New function.\n        (frame_restore_reg): Likewise.\n        (arc_enter_leave_p): Likewise.\n        (arc_save_callee_saves): Likewise.\n        (arc_restore_callee_saves): Likewise.\n        (arc_save_callee_enter): Likewise.\n        (arc_restore_callee_leave): Likewise.\n        (arc_save_callee_milli): Likewise.\n        (arc_restore_callee_milli): Likewise.\n        (arc_expand_prologue): Reimplement to emit enter/leave\n        instructions.\n        (arc_expand_epilogue): Likewise.\n        (arc_check_multi): New function.\n        * config/arc/arc.md (push_multi_fp): New pattern.\n        (push_multi_fp_blink): Likewise.\n        (pop_multi_fp): Likewise.\n        (pop_multi_fp_blink): Likewise.\n        (pop_multi_fp_ret): Likewise.\n        (pop_multi_fp_blink_ret): Likewise.\n        * config/arc/arc.opt (mmillicode): Update option.\n        (mcode-density-frame): New option.\n        * config/arc/predicates.md (push_multi_operand): New predicate.\n        (pop_multi_operand): Likewise.\n        * doc/invoke.texi (ARC): Update ARC options information.\n\ngcc/testsuite\nxxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n        * gcc.target/arc/firq-1.c: Update test.\n        * gcc.target/arc/firq-3.c: Likewise.\n        * gcc.target/arc/firq-4.c: Likewise.\n        * gcc.target/arc/interrupt-6.c: Likewise.\n\nFrom-SVN: r266065", "tree": {"sha": "b009dad794b86a822eabf2473e17109b5ac96aac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b009dad794b86a822eabf2473e17109b5ac96aac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90b480138a5492776e9fab6e7f95aae874d6a0ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b480138a5492776e9fab6e7f95aae874d6a0ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90b480138a5492776e9fab6e7f95aae874d6a0ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b480138a5492776e9fab6e7f95aae874d6a0ea/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fa2c211f7852b1fe330423f4af096016bb3acbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fa2c211f7852b1fe330423f4af096016bb3acbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fa2c211f7852b1fe330423f4af096016bb3acbc"}], "stats": {"total": 1596, "additions": 1131, "deletions": 465}, "files": [{"sha": "6d904d9dc685e45789d7de85c4c45f5f167376ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -1,3 +1,42 @@\n+2018-11-13  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* common/config/arc/arc-common.c (arc_option_optimization_table):\n+\tMillicode optimization is default on for size optimizations.\n+\t* config/arc/arc-protos.h (arc_check_multi): New function.\n+\t* config/arc/arc.c (RTX_OK_FOR_OFFSET_P): Rearange.\n+\t(ENTER_LEAVE_START_REG): Define.\n+\t(ENTER_LEAVE_END_REG): Likewise.\n+\t(arc_override_options): Disable millicode when long calls option\n+\tis on.\n+\t(arc_frame_info): Change it from int to bool.\n+\t(arc_compute_frame_size): Clean up.\n+\t(arc_save_restore): Remove.\n+\t(frame_save_reg): New function.\n+\t(frame_restore_reg): Likewise.\n+\t(arc_enter_leave_p): Likewise.\n+\t(arc_save_callee_saves): Likewise.\n+\t(arc_restore_callee_saves): Likewise.\n+\t(arc_save_callee_enter): Likewise.\n+\t(arc_restore_callee_leave): Likewise.\n+\t(arc_save_callee_milli): Likewise.\n+\t(arc_restore_callee_milli): Likewise.\n+\t(arc_expand_prologue): Reimplement to emit enter/leave\n+\tinstructions.\n+\t(arc_expand_epilogue): Likewise.\n+\t(arc_check_multi): New function.\n+\t* config/arc/arc.md (push_multi_fp): New pattern.\n+\t(push_multi_fp_blink): Likewise.\n+\t(pop_multi_fp): Likewise.\n+\t(pop_multi_fp_blink): Likewise.\n+\t(pop_multi_fp_ret): Likewise.\n+\t(pop_multi_fp_blink_ret): Likewise.\n+\t* config/arc/arc.opt (mmillicode): Update option.\n+\t(mcode-density-frame): New option.\n+\t* config/arc/predicates.md (push_multi_operand): New predicate.\n+\t(pop_multi_operand): Likewise.\n+\t* doc/invoke.texi (ARC): Update ARC options information.\n+\n+\n 2018-11-13  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc-protos.h (gen_operands_ldd_std): Add."}, {"sha": "2872388de2c0618fcec7a44c6d2539790e209e86", "filename": "gcc/common/config/arc/arc-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farc%2Farc-common.c?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -59,6 +59,7 @@ static const struct default_options arc_option_optimization_table[] =\n     { OPT_LEVELS_SIZE, OPT_mq_class, NULL, 1 },\n     { OPT_LEVELS_SIZE, OPT_mcase_vector_pcrel, NULL, 1 },\n     { OPT_LEVELS_SIZE, OPT_msize_level_, NULL, 3 },\n+    { OPT_LEVELS_SIZE, OPT_mmillicode, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n     { OPT_LEVELS_3_PLUS_SPEED_ONLY, OPT_msize_level_, NULL, 0 },\n     { OPT_LEVELS_3_PLUS_SPEED_ONLY, OPT_malign_call, NULL, 1 },"}, {"sha": "e653f7f3ae0b09bdec1a709088f0e52ac5a57c4b", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -45,8 +45,8 @@ extern bool compact_memory_operand_p (rtx, machine_mode, bool, bool);\n extern int arc_return_address_register (unsigned int);\n extern unsigned int arc_compute_function_type (struct function *);\n extern bool arc_is_uncached_mem_p (rtx);\n-extern bool arc_lra_p (void);\n extern bool gen_operands_ldd_std (rtx *operands, bool load, bool commute);\n+extern bool arc_check_multi (rtx, bool);\n #endif /* RTX_CODE */\n \n extern unsigned int arc_compute_frame_size (int);"}, {"sha": "75c2384eede8af6307f8998cc61e220745605b2e", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 858, "deletions": 437, "changes": 1295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -87,14 +87,14 @@ HARD_REG_SET overrideregs;\n /* Maximum size of a loop.  */\n #define ARC_MAX_LOOP_LENGTH 4095\n \n-/* ??? Loads can handle any constant, stores can only handle small ones.  */\n-/* OTOH, LIMMs cost extra, so their usefulness is limited.  */\n-#define RTX_OK_FOR_OFFSET_P(MODE, X) \\\n-(GET_CODE (X) == CONST_INT \\\n- && SMALL_INT_RANGE (INTVAL (X), (GET_MODE_SIZE (MODE) - 1) & -4, \\\n-\t\t     (INTVAL (X) & (GET_MODE_SIZE (MODE) - 1) & 3 \\\n-\t\t      ? 0 \\\n-\t\t      : -(-GET_MODE_SIZE (MODE) | -4) >> 1)))\n+/* Check if an rtx fits in the store instruction format.  Loads can\n+   handle any constant.  */\n+#define RTX_OK_FOR_OFFSET_P(MODE, X)\t\t\t\t\t\\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+   && SMALL_INT_RANGE (INTVAL (X), (GET_MODE_SIZE (MODE) - 1) & (~0x03), \\\n+\t\t       (INTVAL (X) & (GET_MODE_SIZE (MODE) - 1) & 3\t\\\n+\t\t\t? 0\t\t\t\t\t\t\\\n+\t\t\t: -(-GET_MODE_SIZE (MODE) | (~0x03)) >> 1)))\n \n /* Array of valid operand punctuation characters.  */\n char arc_punct_chars[256];\n@@ -171,6 +171,12 @@ static int rgf_banked_register_count;\n       || get_attr_iscompact (INSN) == ISCOMPACT_TRUE_LIMM) \\\n    : get_attr_iscompact (INSN) != ISCOMPACT_FALSE)\n \n+/* Start enter/leave register range.  */\n+#define ENTER_LEAVE_START_REG 13\n+\n+/* End enter/leave register range.  */\n+#define ENTER_LEAVE_END_REG 26\n+\n /* The maximum number of insns skipped which will be conditionalised if\n    possible.  */\n /* When optimizing for speed:\n@@ -1307,6 +1313,10 @@ arc_override_options (void)\n   if (TARGET_ARC700 && (arc_tune != ARC_TUNE_ARC7XX))\n     flag_delayed_branch = 0;\n \n+  /* Millicode thunks doesn't work with long calls.  */\n+  if (TARGET_LONG_CALLS_SET)\n+    target_flags &= ~MASK_MILLICODE_THUNK_SET;\n+\n   /* These need to be done at start up.  It's convenient to do them here.  */\n   arc_init ();\n }\n@@ -2617,9 +2627,8 @@ struct GTY (()) arc_frame_info\n   unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n   unsigned int reg_size;\t/* # bytes needed to store regs.  */\n   unsigned int var_size;\t/* # bytes that variables take up.  */\n-  unsigned int reg_offset;\t/* Offset from new sp to store regs.  */\n   unsigned int gmask;\t\t/* Mask of saved gp registers.  */\n-  int          initialized;\t/* Nonzero if frame size already calculated.  */\n+  bool initialized; /* FALSE if frame size already calculated.  */\n   short millicode_start_reg;\n   short millicode_end_reg;\n   bool save_return_addr;\n@@ -2835,10 +2844,12 @@ arc_compute_frame_size (void)\n {\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n-  unsigned int reg_size, reg_offset;\n+  unsigned int reg_size;\n   unsigned int gmask;\n   struct arc_frame_info *frame_info;\n   int size;\n+  unsigned int extra_plus_reg_size;\n+  unsigned int extra_plus_reg_size_aligned;\n \n   /* The answer might already be known.  */\n   if (cfun->machine->frame_info.initialized)\n@@ -2882,23 +2893,23 @@ arc_compute_frame_size (void)\n     for (regno = 0; EH_RETURN_DATA_REGNO (regno) != INVALID_REGNUM; regno++)\n       {\n \treg_size += UNITS_PER_WORD;\n-\tgmask |= 1 << regno;\n+\tgmask |= 1L << regno;\n       }\n \n-  /* 4) Space for back trace data structure.\n-\t<return addr reg size> (if required) + <fp size> (if required).  */\n-  frame_info->save_return_addr\n-    = (!crtl->is_leaf || df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n-       || crtl->calls_eh_return);\n-  /* Saving blink reg in case of leaf function for millicode thunk calls.  */\n-  if (optimize_size\n-      && !TARGET_NO_MILLICODE_THUNK_SET\n+  /* Check if we need to save the return address.  */\n+  frame_info->save_return_addr = (!crtl->is_leaf\n+\t\t\t\t  || df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n+\t\t\t\t  || crtl->calls_eh_return);\n+\n+  /* Saving blink reg for millicode thunk calls.  */\n+  if (TARGET_MILLICODE_THUNK_SET\n       && !crtl->calls_eh_return)\n     {\n       if (arc_compute_millicode_save_restore_regs (gmask, frame_info))\n \tframe_info->save_return_addr = true;\n     }\n \n+  /* 4) Calculate extra size made up of the blink + fp size.  */\n   extra_size = 0;\n   if (arc_must_save_return_addr (cfun))\n     extra_size = 4;\n@@ -2909,14 +2920,9 @@ arc_compute_frame_size (void)\n   pretend_size\t= crtl->args.pretend_args_size;\n \n   /* Ensure everything before the locals is aligned appropriately.  */\n-    {\n-       unsigned int extra_plus_reg_size;\n-       unsigned int extra_plus_reg_size_aligned;\n-\n-       extra_plus_reg_size = extra_size + reg_size;\n-       extra_plus_reg_size_aligned = ARC_STACK_ALIGN(extra_plus_reg_size);\n-       reg_size = extra_plus_reg_size_aligned - extra_size;\n-    }\n+  extra_plus_reg_size = extra_size + reg_size;\n+  extra_plus_reg_size_aligned = ARC_STACK_ALIGN (extra_plus_reg_size);\n+  reg_size = extra_plus_reg_size_aligned - extra_size;\n \n   /* Compute total frame size.  */\n   total_size = var_size + args_size + extra_size + pretend_size + reg_size;\n@@ -2927,208 +2933,20 @@ arc_compute_frame_size (void)\n      as an issue I've changed this to an assert for now.  */\n   gcc_assert (total_size == ARC_STACK_ALIGN (total_size));\n \n-  /* Compute offset of register save area from stack pointer:\n-     Frame: pretend_size <blink> reg_size <fp> var_size args_size <--sp\n-  */\n-  reg_offset = (total_size - (pretend_size + reg_size + extra_size)\n-\t\t+ (arc_frame_pointer_needed () ? 4 : 0));\n-\n   /* Save computed information.  */\n   frame_info->total_size   = total_size;\n   frame_info->extra_size   = extra_size;\n   frame_info->pretend_size = pretend_size;\n   frame_info->var_size     = var_size;\n   frame_info->args_size    = args_size;\n   frame_info->reg_size     = reg_size;\n-  frame_info->reg_offset   = reg_offset;\n   frame_info->gmask        = gmask;\n   frame_info->initialized  = reload_completed;\n \n   /* Ok, we're done.  */\n   return total_size;\n }\n \n-/* Common code to save/restore registers.  */\n-/* BASE_REG is the base register to use for addressing and to adjust.\n-   GMASK is a bitmask of general purpose registers to save/restore.\n-   epilogue_p 0: prologue 1:epilogue 2:epilogue, sibling thunk\n-   If *FIRST_OFFSET is non-zero, add it first to BASE_REG - preferably\n-   using a pre-modify for the first memory access.  *FIRST_OFFSET is then\n-   zeroed.  */\n-\n-static void\n-arc_save_restore (rtx base_reg,\n-\t\t  unsigned int gmask, int epilogue_p, int *first_offset)\n-{\n-  unsigned int offset = 0;\n-  int regno;\n-  struct arc_frame_info *frame = &cfun->machine->frame_info;\n-  rtx sibthunk_insn = NULL_RTX;\n-\n-  if (gmask)\n-    {\n-      /* Millicode thunks implementation:\n-\t Generates calls to millicodes for registers starting from r13 to r25\n-\t Present Limitations:\n-\t - Only one range supported. The remaining regs will have the ordinary\n-\t   st and ld instructions for store and loads. Hence a gmask asking\n-\t   to store r13-14, r16-r25 will only generate calls to store and\n-\t   load r13 to r14 while store and load insns will be generated for\n-\t   r16 to r25 in the prologue and epilogue respectively.\n-\n-\t - Presently library only supports register ranges starting from r13.\n-      */\n-      if (epilogue_p == 2 || frame->millicode_end_reg > 14)\n-\t{\n-\t  int start_call = frame->millicode_start_reg;\n-\t  int end_call = frame->millicode_end_reg;\n-\t  int n_regs = end_call - start_call + 1;\n-\t  int i = 0, r, off = 0;\n-\t  rtx insn;\n-\t  rtx ret_addr = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n-\n-\t  if (*first_offset)\n-\t    {\n-\t      /* \"reg_size\" won't be more than 127 .  */\n-\t      gcc_assert (epilogue_p || abs (*first_offset) <= 127);\n-\t      frame_add (base_reg, *first_offset);\n-\t      *first_offset = 0;\n-\t    }\n-\t  insn = gen_rtx_PARALLEL\n-\t\t  (VOIDmode, rtvec_alloc ((epilogue_p == 2) + n_regs + 1));\n-\t  if (epilogue_p == 2)\n-\t    i += 2;\n-\t  else\n-\t    XVECEXP (insn, 0, n_regs) = gen_rtx_CLOBBER (VOIDmode, ret_addr);\n-\t  for (r = start_call; r <= end_call; r++, off += UNITS_PER_WORD, i++)\n-\t    {\n-\t      rtx reg = gen_rtx_REG (SImode, r);\n-\t      rtx mem\n-\t\t= gen_frame_mem (SImode, plus_constant (Pmode, base_reg, off));\n-\n-\t      if (epilogue_p)\n-\t\tXVECEXP (insn, 0, i) = gen_rtx_SET (reg, mem);\n-\t      else\n-\t\tXVECEXP (insn, 0, i) = gen_rtx_SET (mem, reg);\n-\t      gmask = gmask & ~(1L << r);\n-\t    }\n-\t  if (epilogue_p == 2)\n-\t    sibthunk_insn = insn;\n-\t  else\n-\t    {\n-\t      insn = frame_insn (insn);\n-\t      for (r = start_call, off = 0;\n-\t\t   r <= end_call;\n-\t\t   r++, off += UNITS_PER_WORD)\n-\t\t{\n-\t\t  rtx reg = gen_rtx_REG (SImode, r);\n-\t\t  if (epilogue_p)\n-\t\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t\t  else\n-\t\t    {\n-\t\t      rtx mem = gen_rtx_MEM (SImode, plus_constant (Pmode,\n-\t\t\t\t\t\t\t\t    base_reg,\n-\t\t\t\t\t\t\t\t    off));\n-\n-\t\t      add_reg_note (insn, REG_CFA_OFFSET,\n-\t\t\t\t    gen_rtx_SET (mem, reg));\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  offset += off;\n-\t}\n-\n-      for (regno = 0; regno <= 31; regno++)\n-\t{\n-\t  machine_mode mode = SImode;\n-\t  bool found = false;\n-\n-\t  if (TARGET_LL64\n-\t      && (regno % 2 == 0)\n-\t      && ((gmask & (1L << regno)) != 0)\n-\t      && ((gmask & (1L << (regno+1))) != 0))\n-\t    {\n-\t      found = true;\n-\t      mode  = DImode;\n-\t    }\n-\t  else if ((gmask & (1L << regno)) != 0)\n-\t    {\n-\t      found = true;\n-\t      mode  = SImode;\n-\t    }\n-\n-\t  if (found)\n-\t    {\n-\t      rtx reg = gen_rtx_REG (mode, regno);\n-\t      rtx addr, mem;\n-\t      int cfa_adjust = *first_offset;\n-\n-\t      if (*first_offset)\n-\t\t{\n-\t\t  gcc_assert (!offset);\n-\t\t  addr = plus_constant (Pmode, base_reg, *first_offset);\n-\t\t  addr = gen_rtx_PRE_MODIFY (Pmode, base_reg, addr);\n-\t\t  *first_offset = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (SMALL_INT (offset));\n-\t\t  addr = plus_constant (Pmode, base_reg, offset);\n-\t\t}\n-\t      mem = gen_frame_mem (mode, addr);\n-\t      if (epilogue_p)\n-\t\t{\n-\t\t  rtx insn =\n-\t\t    frame_move_inc (reg, mem, base_reg, addr);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t\t  if (cfa_adjust)\n-\t\t    {\n-\t\t      enum reg_note note = REG_CFA_ADJUST_CFA;\n-\t\t      add_reg_note (insn, note,\n-\t\t\t\t    gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t\t\t plus_constant (Pmode,\n-\t\t\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t\t\tcfa_adjust)));\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tframe_move_inc (mem, reg, base_reg, addr);\n-\t      offset += UNITS_PER_WORD;\n-\t      if (mode == DImode)\n-\t\t{\n-\t\t  offset += UNITS_PER_WORD;\n-\t\t  ++regno;\n-\t\t}\n-\t    } /* if */\n-\t} /* for */\n-    }/* if */\n-  if (sibthunk_insn)\n-    {\n-      int start_call = frame->millicode_start_reg;\n-      int end_call = frame->millicode_end_reg;\n-      int r;\n-\n-      rtx r12 = gen_rtx_REG (Pmode, 12);\n-\n-      frame_insn (gen_rtx_SET (r12, GEN_INT (offset)));\n-      XVECEXP (sibthunk_insn, 0, 0) = ret_rtx;\n-      XVECEXP (sibthunk_insn, 0, 1)\n-\t= gen_rtx_SET (stack_pointer_rtx,\n-\t\t       gen_rtx_PLUS (Pmode, stack_pointer_rtx, r12));\n-      sibthunk_insn = emit_jump_insn (sibthunk_insn);\n-      RTX_FRAME_RELATED_P (sibthunk_insn) = 1;\n-\n-      /* Would be nice if we could do this earlier, when the PARALLEL\n-\t is populated, but these need to be attached after the\n-\t emit.  */\n-      for (r = start_call; r <= end_call; r++)\n-\t{\n-\t  rtx reg = gen_rtx_REG (SImode, r);\n-\t  add_reg_note (sibthunk_insn, REG_CFA_RESTORE, reg);\n-\t}\n-    }\n-} /* arc_save_restore */\n-\n /* Build dwarf information when the context is saved via AUX_IRQ_CTRL\n    mechanism.  */\n \n@@ -3199,20 +3017,709 @@ arc_dwarf_emit_irq_save_regs (void)\n   RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n+/* Helper for prologue: emit frame store with pre_modify or pre_dec to\n+   save register REG on stack.  An initial offset OFFSET can be passed\n+   to the function.  */\n+\n+static int\n+frame_save_reg (rtx reg, HOST_WIDE_INT offset)\n+{\n+  rtx addr;\n+\n+  if (offset)\n+    {\n+      rtx tmp = plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t       offset - GET_MODE_SIZE (GET_MODE (reg)));\n+      addr = gen_frame_mem (GET_MODE (reg),\n+\t\t\t    gen_rtx_PRE_MODIFY (Pmode,\n+\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\ttmp));\n+    }\n+  else\n+    addr = gen_frame_mem (GET_MODE (reg), gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\t\t   stack_pointer_rtx));\n+  frame_move_inc (addr, reg, stack_pointer_rtx, 0);\n+\n+  return GET_MODE_SIZE (GET_MODE (reg)) - offset;\n+}\n+\n+/* Helper for epilogue: emit frame load with post_modify or post_inc\n+   to restore register REG from stack.  The initial offset is passed\n+   via OFFSET.  */\n+\n+static int\n+frame_restore_reg (rtx reg, HOST_WIDE_INT offset)\n+{\n+  rtx addr, insn;\n+\n+  if (offset)\n+    {\n+      rtx tmp = plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t       offset + GET_MODE_SIZE (GET_MODE (reg)));\n+      addr = gen_frame_mem (GET_MODE (reg),\n+\t\t\t    gen_rtx_POST_MODIFY (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t tmp));\n+    }\n+  else\n+    addr = gen_frame_mem (GET_MODE (reg), gen_rtx_POST_INC (Pmode,\n+\t\t\t\t\t\t\t    stack_pointer_rtx));\n+  insn = frame_move_inc (reg, addr, stack_pointer_rtx, 0);\n+  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\n+  if (reg == frame_pointer_rtx)\n+    add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t  plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t GET_MODE_SIZE (GET_MODE (reg)) + offset));\n+  else\n+    add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t  gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      GET_MODE_SIZE (GET_MODE (reg))\n+\t\t\t\t\t      + offset)));\n+\n+  return GET_MODE_SIZE (GET_MODE (reg)) + offset;\n+}\n+\n+/* Check if we have a continous range to be save/restored with the\n+   help of enter/leave instructions.  A vaild register range starts\n+   from $r13 and is up to (including) $r26.  */\n+\n+static bool\n+arc_enter_leave_p (unsigned int gmask)\n+{\n+  int regno;\n+  unsigned int rmask = 0;\n+\n+  if (!gmask)\n+    return false;\n+\n+  for (regno = ENTER_LEAVE_START_REG;\n+       regno <= ENTER_LEAVE_END_REG && (gmask & (1L << regno)); regno++)\n+    rmask |= 1L << regno;\n+\n+  if (rmask ^ gmask)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* ARC's prologue, save any needed call-saved regs (and call-used if\n+   this is an interrupt handler) for ARCompact ISA, using ST/STD\n+   instructions.  */\n+\n+static int\n+arc_save_callee_saves (unsigned int gmask,\n+\t\t       bool save_blink,\n+\t\t       bool save_fp,\n+\t\t       HOST_WIDE_INT offset)\n+{\n+  rtx reg;\n+  int frame_allocated = 0;\n+\n+  /* The home-grown ABI says link register is saved first.  */\n+  if (save_blink)\n+    {\n+      reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      frame_allocated += frame_save_reg (reg, offset);\n+      offset = 0;\n+    }\n+\n+  /* N.B. FRAME_POINTER_MASK and RETURN_ADDR_MASK are cleared in gmask.  */\n+  if (gmask)\n+    for (int i = 31; i >= 0; i--)\n+      {\n+\tmachine_mode save_mode = SImode;\n+\n+\tif (TARGET_LL64\n+\t    && ((i - 1) % 2 == 0)\n+\t    && ((gmask & (1L << i)) != 0)\n+\t    && ((gmask & (1L << (i - 1))) != 0))\n+\t  {\n+\t    save_mode = DImode;\n+\t    --i;\n+\t  }\n+\telse if ((gmask & (1L << i)) == 0)\n+\t  continue;\n+\n+\treg = gen_rtx_REG (save_mode, i);\n+\tframe_allocated += frame_save_reg (reg, offset);\n+\toffset = 0;\n+      }\n+\n+  /* Save frame pointer if needed.  First save the FP on stack, if not\n+     autosaved.  Unfortunately, I cannot add it to gmask and use the\n+     above loop to save fp because our ABI states fp goes aftert all\n+     registers are saved.  */\n+  if (save_fp)\n+    {\n+      frame_allocated += frame_save_reg (frame_pointer_rtx, offset);\n+      offset = 0;\n+    }\n+\n+  /* Emit mov fp,sp.  */\n+  if (arc_frame_pointer_needed ())\n+    frame_move (frame_pointer_rtx, stack_pointer_rtx);\n+\n+  return frame_allocated;\n+}\n+\n+/* ARC's epilogue, restore any required call-saved regs (and call-used\n+   if it is for an interrupt handler) using LD/LDD instructions.  */\n+\n+static int\n+arc_restore_callee_saves (unsigned int gmask,\n+\t\t\t  bool restore_blink,\n+\t\t\t  bool restore_fp,\n+\t\t\t  HOST_WIDE_INT offset,\n+\t\t\t  HOST_WIDE_INT allocated)\n+{\n+  rtx reg;\n+  int frame_deallocated = 0;\n+\n+  /* Emit mov fp,sp.  */\n+  if (arc_frame_pointer_needed () && offset)\n+    {\n+      frame_move (stack_pointer_rtx, frame_pointer_rtx);\n+      frame_deallocated += offset;\n+      offset = 0;\n+    }\n+\n+  if (restore_fp)\n+    {\n+      /* Any offset is taken care by previous if-statement.  */\n+      gcc_assert (offset == 0);\n+      frame_deallocated += frame_restore_reg (frame_pointer_rtx, 0);\n+    }\n+\n+  if (offset)\n+    {\n+      /* No $fp involved, we need to do an add to set the $sp to the\n+\t location of the first register.  */\n+      frame_stack_add (offset);\n+      frame_deallocated += offset;\n+      offset = 0;\n+    }\n+\n+  /* N.B. FRAME_POINTER_MASK and RETURN_ADDR_MASK are cleared in gmask.  */\n+  if (gmask)\n+    for (int i = 0; i <= 31; i++)\n+      {\n+\tmachine_mode restore_mode = SImode;\n+\n+\tif (TARGET_LL64\n+\t    && ((i % 2) == 0)\n+\t    && ((gmask & (1L << i)) != 0)\n+\t    && ((gmask & (1L << (i + 1))) != 0))\n+\t  restore_mode = DImode;\n+\telse if ((gmask & (1L << i)) == 0)\n+\t  continue;\n+\n+\treg = gen_rtx_REG (restore_mode, i);\n+\tframe_deallocated += frame_restore_reg (reg, 0);\n+\toffset = 0;\n+\n+\tif (restore_mode == DImode)\n+\t  i++;\n+      }\n+\n+  if (restore_blink)\n+    {\n+      reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      frame_deallocated += frame_restore_reg (reg, allocated\n+\t\t\t\t\t      - frame_deallocated\n+\t\t\t\t\t      /* Consider as well the\n+\t\t\t\t\t\t current restored\n+\t\t\t\t\t\t register size.  */\n+\t\t\t\t\t      - UNITS_PER_WORD);\n+    }\n+\n+  return frame_deallocated;\n+}\n+\n+/* ARC prologue, save the registers using enter instruction.  Leave\n+   instruction can also save $blink (SAVE_BLINK) and $fp (SAVE_FP)\n+   register.  */\n+\n+static int\n+arc_save_callee_enter (unsigned int gmask,\n+\t\t       bool save_blink,\n+\t\t       bool save_fp,\n+\t\t       HOST_WIDE_INT offset)\n+{\n+  int start_reg = ENTER_LEAVE_START_REG;\n+  int end_reg = ENTER_LEAVE_END_REG;\n+  int regno, indx, off, nregs;\n+  rtx insn, reg, mem;\n+  int frame_allocated = 0;\n+\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+    regno++;\n+\n+  end_reg = regno - 1;\n+  nregs = end_reg - start_reg + 1;\n+  nregs += save_blink ? 1 : 0;\n+  nregs += save_fp ? 1 : 0;\n+\n+  if (offset)\n+    frame_stack_add (offset);\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs + (save_fp ? 1 : 0)\n+\t\t\t\t\t\t  + 1));\n+  indx = 0;\n+\n+  reg = gen_rtx_SET (stack_pointer_rtx,\n+\t\t     plus_constant (Pmode,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    nregs * UNITS_PER_WORD));\n+  RTX_FRAME_RELATED_P (reg) = 1;\n+  XVECEXP (insn, 0, indx++) = reg;\n+  off = nregs * UNITS_PER_WORD;\n+\n+  if (save_blink)\n+    {\n+      reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n+      off -= UNITS_PER_WORD;\n+      save_blink = false;\n+    }\n+\n+  for (regno = start_reg;\n+       regno <= end_reg;\n+       regno++, indx++, off -= UNITS_PER_WORD)\n+    {\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n+      gmask = gmask & ~(1L << regno);\n+    }\n+\n+  if (save_fp)\n+    {\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, frame_pointer_rtx);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n+      off -= UNITS_PER_WORD;\n+\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (frame_pointer_rtx,\n+\t\t\t\t\t     stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n+      save_fp = false;\n+    }\n+\n+  gcc_assert (off == 0);\n+  insn = frame_insn (insn);\n+\n+  add_reg_note (insn, REG_INC, stack_pointer_rtx);\n+\n+  frame_allocated = nregs * UNITS_PER_WORD;\n+\n+  /* offset is a negative number, make sure we add it.  */\n+  return frame_allocated - offset;\n+}\n+\n+/* ARC epilogue, restore the registers using leave instruction.  An\n+   initial offset is passed in OFFSET.  Besides restoring an register\n+   range, leave can also restore $blink (RESTORE_BLINK), or $fp\n+   (RESTORE_FP), and can automatic return (RETURN_P).  */\n+\n+static int\n+arc_restore_callee_leave (unsigned int gmask,\n+\t\t\t  bool restore_blink,\n+\t\t\t  bool restore_fp,\n+\t\t\t  bool return_p,\n+\t\t\t  HOST_WIDE_INT offset)\n+{\n+  int start_reg = ENTER_LEAVE_START_REG;\n+  int end_reg = ENTER_LEAVE_END_REG;\n+  int regno, indx, off, nregs;\n+  rtx insn, reg, mem;\n+  int frame_allocated = 0;\n+\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+    regno++;\n+\n+  end_reg = regno - 1;\n+  nregs = end_reg - start_reg + 1;\n+  nregs += restore_blink ? 1 : 0;\n+  nregs += restore_fp ? 1 : 0;\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs + 1\n+\t\t\t\t\t\t  + (return_p ? 1 : 0)));\n+  indx = 0;\n+\n+  if (return_p)\n+    XVECEXP (insn, 0, indx++) = ret_rtx;\n+\n+  if (restore_fp)\n+    {\n+      /* I cannot emit set (sp, fp) here as cselib expects a single sp\n+\t set and not two.  Thus, use the offset, and change sp adjust\n+\t value.  */\n+      frame_allocated += offset;\n+    }\n+\n+  if (offset && !restore_fp)\n+    {\n+      /* This add is only emmited when we do not restore fp with leave\n+\t instruction.  */\n+      frame_stack_add (offset);\n+      frame_allocated += offset;\n+      offset = 0;\n+    }\n+\n+  reg = gen_rtx_SET (stack_pointer_rtx,\n+\t\t     plus_constant (Pmode,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    offset + nregs * UNITS_PER_WORD));\n+  RTX_FRAME_RELATED_P (reg) = 1;\n+  XVECEXP (insn, 0, indx++) = reg;\n+  off = nregs * UNITS_PER_WORD;\n+\n+  if (restore_blink)\n+    {\n+      reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (reg, mem);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n+      off -= UNITS_PER_WORD;\n+    }\n+\n+  for (regno = start_reg;\n+       regno <= end_reg;\n+       regno++, indx++, off -= UNITS_PER_WORD)\n+    {\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (reg, mem);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n+      gmask = gmask & ~(1L << regno);\n+    }\n+\n+  if (restore_fp)\n+    {\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (frame_pointer_rtx, mem);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n+      off -= UNITS_PER_WORD;\n+    }\n+\n+  gcc_assert (off == 0);\n+  if (return_p)\n+    {\n+      insn = emit_jump_insn (insn);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    insn = frame_insn (insn);\n+\n+  add_reg_note (insn, REG_INC, stack_pointer_rtx);\n+\n+  /* Dwarf related info.  */\n+  if (restore_fp)\n+    {\n+      add_reg_note (insn, REG_CFA_RESTORE, frame_pointer_rtx);\n+      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t    plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t   offset + nregs * UNITS_PER_WORD));\n+    }\n+  else\n+    {\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t    gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t\t plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\tnregs * UNITS_PER_WORD)));\n+    }\n+  if (restore_blink)\n+    add_reg_note (insn, REG_CFA_RESTORE,\n+\t\t  gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM));\n+  for (regno = start_reg; regno <= end_reg; regno++)\n+    add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (SImode, regno));\n+\n+  frame_allocated += nregs * UNITS_PER_WORD;\n+\n+  return frame_allocated;\n+}\n+\n+/* Millicode thunks implementation:\n+   Generates calls to millicodes for registers starting from r13 to r25\n+   Present Limitations:\n+   - Only one range supported.  The remaining regs will have the ordinary\n+   st and ld instructions for store and loads.  Hence a gmask asking\n+   to store r13-14, r16-r25 will only generate calls to store and\n+   load r13 to r14 while store and load insns will be generated for\n+   r16 to r25 in the prologue and epilogue respectively.\n+\n+   - Presently library only supports register ranges starting from r13.\n+*/\n+\n+static int\n+arc_save_callee_milli (unsigned int gmask,\n+\t\t       bool save_blink,\n+\t\t       bool save_fp,\n+\t\t       HOST_WIDE_INT offset,\n+\t\t       HOST_WIDE_INT reg_size)\n+{\n+  int start_reg = 13;\n+  int end_reg = 25;\n+  int regno, indx, off, nregs;\n+  rtx insn, reg, mem;\n+  int frame_allocated = 0;\n+\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+    regno++;\n+\n+  end_reg = regno - 1;\n+  nregs = end_reg - start_reg + 1;\n+  gcc_assert (end_reg > 14);\n+\n+\n+  /* Allocate space on stack for the registers, and take into account\n+     also the initial offset.  The registers will be saved using\n+     offsets.  N.B. OFFSET is a negative number.  */\n+  if (save_blink)\n+    {\n+      reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      frame_allocated += frame_save_reg (reg, offset);\n+      offset = 0;\n+    }\n+\n+  if (reg_size || offset)\n+    {\n+      frame_stack_add (offset - reg_size);\n+      frame_allocated += nregs * UNITS_PER_WORD - offset;\n+      offset = 0;\n+    }\n+\n+  /* Start generate millicode call.  */\n+  insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs + 1));\n+  indx = 0;\n+\n+  /* This is a call, we clobber blink.  */\n+  XVECEXP (insn, 0, nregs) =\n+    gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM));\n+\n+  for (regno = start_reg, indx = 0, off = 0;\n+       regno <= end_reg;\n+       regno++, indx++, off += UNITS_PER_WORD)\n+    {\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n+      gmask = gmask & ~(1L << regno);\n+    }\n+  insn = frame_insn (insn);\n+\n+  /* Add DWARF info.  */\n+  for (regno = start_reg, off = 0;\n+       regno <= end_reg;\n+       regno++, off += UNITS_PER_WORD)\n+    {\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_rtx_MEM (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\tstack_pointer_rtx, off));\n+      add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (mem, reg));\n+\n+    }\n+\n+  /* In the case of millicode thunk, we need to restore the\n+     clobbered blink register.  */\n+  if (arc_must_save_return_addr (cfun))\n+    {\n+      emit_insn (gen_rtx_SET (gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM),\n+\t\t\t      gen_rtx_MEM (Pmode,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t\t  reg_size))));\n+    }\n+\n+  /* Save remaining registers using st instructions.  */\n+  for (regno = 0; regno <= 31; regno++)\n+    {\n+      if ((gmask & (1L << regno)) == 0)\n+\tcontinue;\n+\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  off));\n+      frame_move_inc (mem, reg, stack_pointer_rtx, 0);\n+      frame_allocated += UNITS_PER_WORD;\n+      off += UNITS_PER_WORD;\n+    }\n+\n+  /* Save frame pointer if needed.  First save the FP on stack, if not\n+     autosaved.  Unfortunately, I cannot add it to gmask and use the\n+     above loop to save fp because our ABI states fp goes aftert all\n+     registers are saved.  */\n+  if (save_fp)\n+    frame_allocated += frame_save_reg (frame_pointer_rtx, offset);\n+\n+  /* Emit mov fp,sp.  */\n+  if (arc_frame_pointer_needed ())\n+    frame_move (frame_pointer_rtx, stack_pointer_rtx);\n+\n+  return frame_allocated;\n+}\n+\n+/* Like the previous function but restore.  */\n+\n+static int\n+arc_restore_callee_milli (unsigned int gmask,\n+\t\t\t  bool restore_blink,\n+\t\t\t  bool restore_fp,\n+\t\t\t  bool return_p,\n+\t\t\t  HOST_WIDE_INT offset)\n+{\n+  int start_reg = 13;\n+  int end_reg = 25;\n+  int regno, indx, off, nregs;\n+  rtx insn, reg, mem;\n+  int frame_allocated = 0;\n+\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+    regno++;\n+\n+  end_reg = regno - 1;\n+  nregs = end_reg - start_reg + 1;\n+  gcc_assert (end_reg > 14);\n+\n+  /* Emit mov fp,sp.  */\n+  if (arc_frame_pointer_needed () && offset)\n+    {\n+      frame_move (stack_pointer_rtx, frame_pointer_rtx);\n+      frame_allocated = offset;\n+      offset = 0;\n+    }\n+\n+  if (restore_fp)\n+    frame_allocated += frame_restore_reg (frame_pointer_rtx, 0);\n+\n+  if (offset)\n+    {\n+      /* No fp involved, hence, we need to adjust the sp via an\n+\t add.  */\n+      frame_stack_add (offset);\n+      frame_allocated += offset;\n+      offset = 0;\n+    }\n+\n+  /* Start generate millicode call.  */\n+  insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc ((return_p ? 1 : 0)\n+\t\t\t\t\t\t  + nregs + 1));\n+  indx = 0;\n+\n+  if (return_p)\n+    {\n+      /* sibling call, the blink is restored with the help of the\n+\t value held into r12.  */\n+      reg = gen_rtx_REG (Pmode, 12);\n+      XVECEXP (insn, 0, indx++) = ret_rtx;\n+      XVECEXP (insn, 0, indx++) =\n+\tgen_rtx_SET (stack_pointer_rtx,\n+\t\t     gen_rtx_PLUS (Pmode, stack_pointer_rtx, reg));\n+      frame_allocated += UNITS_PER_WORD;\n+    }\n+  else\n+    {\n+      /* This is a call, we clobber blink.  */\n+      XVECEXP (insn, 0, nregs) =\n+\tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM));\n+    }\n+\n+  for (regno = start_reg, off = 0;\n+       regno <= end_reg;\n+       regno++, indx++, off += UNITS_PER_WORD)\n+    {\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  off));\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (reg, mem);\n+      RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n+      gmask = gmask & ~(1L << regno);\n+    }\n+\n+  /* Restore remaining registers using LD instructions.  */\n+  for (regno = 0; regno <= 31; regno++)\n+    {\n+      if ((gmask & (1L << regno)) == 0)\n+\tcontinue;\n+\n+      reg = gen_rtx_REG (SImode, regno);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  off));\n+      rtx tmp = frame_move_inc (reg, mem, stack_pointer_rtx, 0);\n+      add_reg_note (tmp, REG_CFA_RESTORE, reg);\n+      off += UNITS_PER_WORD;\n+    }\n+\n+  /* Emit millicode call.  */\n+  if (return_p)\n+    {\n+      reg = gen_rtx_REG (Pmode, 12);\n+      frame_insn (gen_rtx_SET (reg, GEN_INT (off)));\n+      frame_allocated += off;\n+      insn = emit_jump_insn (insn);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    insn = frame_insn (insn);\n+\n+  /* Add DWARF info.  */\n+  for (regno = start_reg, off = 0;\n+       regno <= end_reg;\n+       regno++, off += UNITS_PER_WORD)\n+    {\n+      reg = gen_rtx_REG (SImode, regno);\n+      add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\n+    }\n+\n+  if (restore_blink && !return_p)\n+    {\n+      reg = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      mem = gen_frame_mem (Pmode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t off));\n+      insn = frame_insn (gen_rtx_SET (reg, mem));\n+      add_reg_note (insn, REG_CFA_RESTORE, reg);\n+    }\n+\n+  return frame_allocated;\n+}\n+\n /* Set up the stack and frame pointer (if desired) for the function.  */\n \n void\n arc_expand_prologue (void)\n {\n   int size;\n   unsigned int gmask = cfun->machine->frame_info.gmask;\n-  /*  unsigned int frame_pointer_offset;*/\n+  struct arc_frame_info *frame = &cfun->machine->frame_info;\n   unsigned int frame_size_to_allocate;\n-  /* (FIXME: The first store will use a PRE_MODIFY; this will usually be r13.\n-     Change the stack layout so that we rather store a high register with the\n-     PRE_MODIFY, thus enabling more short insn generation.)  */\n   int first_offset = 0;\n   unsigned int fn_type = arc_compute_function_type (cfun);\n+  bool save_blink = false;\n+  bool save_fp = false;\n \n   /* Naked functions don't have prologue.  */\n   if (ARC_NAKED_P (fn_type))\n@@ -3235,87 +3742,42 @@ arc_expand_prologue (void)\n   gcc_assert (!(size == 0 && gmask));\n \n   /* Allocate space for register arguments if this is a variadic function.  */\n-  if (cfun->machine->frame_info.pretend_size != 0)\n-    {\n-       /* Ensure pretend_size is maximum of 8 * word_size.  */\n-      gcc_assert (cfun->machine->frame_info.pretend_size <= 32);\n-\n-      frame_stack_add (-(HOST_WIDE_INT)cfun->machine->frame_info.pretend_size);\n-      frame_size_to_allocate -= cfun->machine->frame_info.pretend_size;\n-    }\n+  if (frame->pretend_size != 0)\n+    first_offset = -frame->pretend_size;\n \n   /* IRQ using automatic save mechanism will save the register before\n      anything we do.  */\n   if (ARC_AUTO_IRQ_P (fn_type)\n       && !ARC_FAST_INTERRUPT_P (fn_type))\n     {\n-      arc_dwarf_emit_irq_save_regs ();\n-    }\n-\n-  /* The home-grown ABI says link register is saved first.  */\n-  if (arc_must_save_return_addr (cfun)\n-      && !ARC_AUTOBLINK_IRQ_P (fn_type))\n-    {\n-      rtx ra = gen_rtx_REG (SImode, RETURN_ADDR_REGNUM);\n-      rtx mem = gen_frame_mem (Pmode,\n-\t\t\t       gen_rtx_PRE_DEC (Pmode,\n-\t\t\t\t\t\tstack_pointer_rtx));\n-\n-      frame_move_inc (mem, ra, stack_pointer_rtx, 0);\n-      frame_size_to_allocate -= UNITS_PER_WORD;\n-    }\n-\n-  /* Save any needed call-saved regs (and call-used if this is an\n-     interrupt handler) for ARCompact ISA.  */\n-  if (cfun->machine->frame_info.reg_size)\n-    {\n-      first_offset = -cfun->machine->frame_info.reg_size;\n-      /* N.B. FRAME_POINTER_MASK and RETURN_ADDR_MASK are cleared in gmask.  */\n-      arc_save_restore (stack_pointer_rtx, gmask, 0, &first_offset);\n-      frame_size_to_allocate -= cfun->machine->frame_info.reg_size;\n-    }\n-\n-  /* In the case of millicode thunk, we need to restore the clobbered\n-     blink register.  */\n-  if (cfun->machine->frame_info.millicode_end_reg > 0\n-      && arc_must_save_return_addr (cfun))\n-    {\n-      HOST_WIDE_INT tmp = cfun->machine->frame_info.reg_size;\n-      emit_insn (gen_rtx_SET (gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM),\n-\t\t\t      gen_rtx_MEM (Pmode,\n-\t\t\t\t\t   plus_constant (Pmode,\n-\t\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t\t  tmp))));\n-    }\n-\n-  /* Save frame pointer if needed.  First save the FP on stack, if not\n-     autosaved.  */\n-  if (arc_frame_pointer_needed ()\n-      && !ARC_AUTOFP_IRQ_P (fn_type))\n-    {\n-      rtx addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-UNITS_PER_WORD + first_offset));\n-      rtx mem = gen_frame_mem (Pmode, gen_rtx_PRE_MODIFY (Pmode,\n-\t\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t\t  addr));\n-      frame_move_inc (mem, frame_pointer_rtx, stack_pointer_rtx, 0);\n-      frame_size_to_allocate -= UNITS_PER_WORD;\n+      frame_stack_add (first_offset);\n       first_offset = 0;\n+      arc_dwarf_emit_irq_save_regs ();\n     }\n \n-  /* Emit mov fp,sp.  */\n-  if (arc_frame_pointer_needed ())\n-    {\n-      frame_move (frame_pointer_rtx, stack_pointer_rtx);\n-    }\n-\n-  /* ??? We don't handle the case where the saved regs are more than 252\n-     bytes away from sp.  This can be handled by decrementing sp once, saving\n-     the regs, and then decrementing it again.  The epilogue doesn't have this\n-     problem as the `ld' insn takes reg+limm values (though it would be more\n-     efficient to avoid reg+limm).  */\n+  save_blink = arc_must_save_return_addr (cfun)\n+    && !ARC_AUTOBLINK_IRQ_P (fn_type);\n+  save_fp = arc_frame_pointer_needed () && !ARC_AUTOFP_IRQ_P (fn_type);\n+\n+  /* Use enter/leave only for non-interrupt functions.  */\n+  if (TARGET_CODE_DENSITY\n+      && TARGET_CODE_DENSITY_FRAME\n+      && !ARC_AUTOFP_IRQ_P (fn_type)\n+      && !ARC_AUTOBLINK_IRQ_P (fn_type)\n+      && !ARC_INTERRUPT_P (fn_type)\n+      && arc_enter_leave_p (gmask))\n+      frame_size_to_allocate -= arc_save_callee_enter (gmask, save_blink,\n+\t\t\t\t\t\t       save_fp,\n+\t\t\t\t\t\t       first_offset);\n+  else if (frame->millicode_end_reg > 14)\n+    frame_size_to_allocate -= arc_save_callee_milli (gmask, save_blink,\n+\t\t\t\t\t\t     save_fp,\n+\t\t\t\t\t\t     first_offset,\n+\t\t\t\t\t\t     frame->reg_size);\n+  else\n+    frame_size_to_allocate -= arc_save_callee_saves (gmask, save_blink, save_fp,\n+\t\t\t\t\t\t     first_offset);\n \n-  frame_size_to_allocate -= first_offset;\n   /* Allocate the stack frame.  */\n   if (frame_size_to_allocate > 0)\n     {\n@@ -3324,8 +3786,7 @@ arc_expand_prologue (void)\n \t will prevent the scheduler from moving stores to the frame\n \t before the stack adjustment.  */\n       if (arc_frame_pointer_needed ())\n-\temit_insn (gen_stack_tie (stack_pointer_rtx,\n-\t\t\t\t  hard_frame_pointer_rtx));\n+\temit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n     }\n }\n \n@@ -3337,170 +3798,71 @@ arc_expand_epilogue (int sibcall_p)\n {\n   int size;\n   unsigned int fn_type = arc_compute_function_type (cfun);\n-\n-  size = arc_compute_frame_size ();\n-\n-  unsigned int pretend_size = cfun->machine->frame_info.pretend_size;\n-  unsigned int frame_size;\n   unsigned int size_to_deallocate;\n   int restored;\n   int can_trust_sp_p = !cfun->calls_alloca;\n-  int first_offset = 0;\n-  int millicode_p = cfun->machine->frame_info.millicode_end_reg > 0;\n-  rtx insn;\n+  int first_offset;\n+  bool restore_fp = arc_frame_pointer_needed () && !ARC_AUTOFP_IRQ_P (fn_type);\n+  bool restore_blink = arc_must_save_return_addr (cfun)\n+    && !ARC_AUTOBLINK_IRQ_P (fn_type);\n+  unsigned int gmask = cfun->machine->frame_info.gmask;\n+  bool return_p = !sibcall_p && fn_type == ARC_FUNCTION_NORMAL\n+\t\t   && !cfun->machine->frame_info.pretend_size;\n+  struct arc_frame_info *frame = &cfun->machine->frame_info;\n+\n \n   /* Naked functions don't have epilogue.  */\n   if (ARC_NAKED_P (fn_type))\n     return;\n \n+  size = arc_compute_frame_size ();\n   size_to_deallocate = size;\n \n-  frame_size = size - (pretend_size +\n-\t\t       cfun->machine->frame_info.reg_size +\n-\t\t       cfun->machine->frame_info.extra_size);\n-\n-  /* ??? There are lots of optimizations that can be done here.\n-     EG: Use fp to restore regs if it's closer.\n-     Maybe in time we'll do them all.  For now, always restore regs from\n-     sp, but don't restore sp if we don't have to.  */\n+  first_offset = size - (frame->pretend_size + frame->reg_size\n+\t\t\t + frame->extra_size);\n \n   if (!can_trust_sp_p)\n     gcc_assert (arc_frame_pointer_needed ());\n \n-  /* Restore stack pointer to the beginning of saved register area for\n-     ARCompact ISA.  */\n-  if (frame_size)\n-    {\n-      if (arc_frame_pointer_needed ())\n-\tframe_move (stack_pointer_rtx, frame_pointer_rtx);\n-      else\n-\tfirst_offset = frame_size;\n-      size_to_deallocate -= frame_size;\n-    }\n-  else if (!can_trust_sp_p)\n-    frame_stack_add (-frame_size);\n-\n-\n-  /* Restore any saved registers.  */\n-  if (arc_frame_pointer_needed ()\n-      && !ARC_AUTOFP_IRQ_P (fn_type))\n-    {\n-      rtx addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n-\n-      insn = frame_move_inc (frame_pointer_rtx, gen_frame_mem (Pmode, addr),\n-\t\t\t     stack_pointer_rtx, 0);\n-      add_reg_note (insn, REG_CFA_RESTORE, frame_pointer_rtx);\n-      add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t    plus_constant (SImode, stack_pointer_rtx,\n-\t\t\t\t   4));\n-      size_to_deallocate -= UNITS_PER_WORD;\n-    }\n-\n-  /* Load blink after the calls to thunk calls in case of optimize size.  */\n-  if (millicode_p)\n-    {\n-\t  int sibthunk_p = (!sibcall_p\n-\t\t\t    && fn_type == ARC_FUNCTION_NORMAL\n-\t\t\t    && !cfun->machine->frame_info.pretend_size);\n-\n-\t  gcc_assert (!(cfun->machine->frame_info.gmask\n-\t\t\t& (FRAME_POINTER_MASK | RETURN_ADDR_MASK)));\n-\t  arc_save_restore (stack_pointer_rtx,\n-\t\t\t    cfun->machine->frame_info.gmask,\n-\t\t\t    1 + sibthunk_p, &first_offset);\n-\t  if (sibthunk_p)\n-\t    return;\n-    }\n-  /* If we are to restore registers, and first_offset would require\n-     a limm to be encoded in a PRE_MODIFY, yet we can add it with a\n-     fast add to the stack pointer, do this now.  */\n-  if ((!SMALL_INT (first_offset)\n-       && cfun->machine->frame_info.gmask\n-       && ((TARGET_ARC700 && !optimize_size)\n-\t    ? first_offset <= 0x800\n-\t    : satisfies_constraint_C2a (GEN_INT (first_offset))))\n-       /* Also do this if we have both gprs and return\n-\t  address to restore, and they both would need a LIMM.  */\n-      || (arc_must_save_return_addr (cfun)\n-\t  && !SMALL_INT ((cfun->machine->frame_info.reg_size + first_offset) >> 2)\n-\t  && cfun->machine->frame_info.gmask))\n-    {\n-      frame_stack_add (first_offset);\n-      first_offset = 0;\n+  if (TARGET_CODE_DENSITY\n+      && TARGET_CODE_DENSITY_FRAME\n+      && !ARC_AUTOFP_IRQ_P (fn_type)\n+      && !ARC_AUTOBLINK_IRQ_P (fn_type)\n+      && !ARC_INTERRUPT_P (fn_type)\n+      && arc_enter_leave_p (gmask))\n+    {\n+      /* Using leave instruction.  */\n+      size_to_deallocate -= arc_restore_callee_leave (gmask, restore_blink,\n+\t\t\t\t\t\t      restore_fp,\n+\t\t\t\t\t\t      return_p,\n+\t\t\t\t\t\t      first_offset);\n+      if (return_p)\n+\t{\n+\t  gcc_assert (size_to_deallocate == 0);\n+\t  return;\n+\t}\n     }\n-  if (arc_must_save_return_addr (cfun)\n-      && !ARC_AUTOBLINK_IRQ_P (fn_type))\n+  else if (frame->millicode_end_reg > 14)\n     {\n-      rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n-      int ra_offs = cfun->machine->frame_info.reg_size + first_offset;\n-      rtx addr = plus_constant (Pmode, stack_pointer_rtx, ra_offs);\n-      HOST_WIDE_INT cfa_adjust = 0;\n-\n-      /* If the load of blink would need a LIMM, but we can add\n-\t the offset quickly to sp, do the latter.  */\n-      if (!SMALL_INT (ra_offs >> 2)\n-\t  && !cfun->machine->frame_info.gmask\n-\t  && ((TARGET_ARC700 && !optimize_size)\n-\t       ? ra_offs <= 0x800\n-\t       : satisfies_constraint_C2a (GEN_INT (ra_offs))))\n-\t{\n-\t   size_to_deallocate -= ra_offs - first_offset;\n-\t   first_offset = 0;\n-\t   frame_stack_add (ra_offs);\n-\t   ra_offs = 0;\n-\t   addr = stack_pointer_rtx;\n-\t}\n-      /* See if we can combine the load of the return address with the\n-\t final stack adjustment.\n-\t We need a separate load if there are still registers to\n-\t restore.  We also want a separate load if the combined insn\n-\t would need a limm, but a separate load doesn't.  */\n-      if (ra_offs\n-\t  && !cfun->machine->frame_info.gmask\n-\t  && (SMALL_INT (ra_offs) || !SMALL_INT (ra_offs >> 2)))\n-\t{\n-\t  addr = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, addr);\n-\t  cfa_adjust = ra_offs;\n-\t  first_offset = 0;\n-\t  size_to_deallocate -= cfun->machine->frame_info.reg_size;\n-\t}\n-      else if (!ra_offs && size_to_deallocate == UNITS_PER_WORD)\n-\t{\n-\t  addr = gen_rtx_POST_INC (Pmode, addr);\n-\t  cfa_adjust = GET_MODE_SIZE (Pmode);\n-\t  size_to_deallocate = 0;\n-\t}\n-\n-      insn = frame_move_inc (ra, gen_frame_mem (Pmode, addr),\n-\t\t\t     stack_pointer_rtx, addr);\n-      if (cfa_adjust)\n+      /* Using millicode calls.  */\n+      size_to_deallocate -= arc_restore_callee_milli (gmask, restore_blink,\n+\t\t\t\t\t\t      restore_fp,\n+\t\t\t\t\t\t      return_p,\n+\t\t\t\t\t\t      first_offset);\n+      if (return_p)\n \t{\n-\t  enum reg_note note = REG_CFA_ADJUST_CFA;\n-\n-\t  add_reg_note (insn, note,\n-\t\t\tgen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t     plus_constant (SImode, stack_pointer_rtx,\n-\t\t\t\t\t\t    cfa_adjust)));\n+\t  gcc_assert (size_to_deallocate == 0);\n+\t  return;\n \t}\n-      add_reg_note (insn, REG_CFA_RESTORE, ra);\n-    }\n-\n-  if (!millicode_p)\n-    {\n-       if (cfun->machine->frame_info.reg_size)\n-\t arc_save_restore (stack_pointer_rtx,\n-\t   /* The zeroing of these two bits is unnecessary, but leave this in for clarity.  */\n-\t\t\t   cfun->machine->frame_info.gmask\n-\t\t\t   & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK), 1, &first_offset);\n     }\n+  else\n+    size_to_deallocate -= arc_restore_callee_saves (gmask, restore_blink,\n+\t\t\t\t\t\t    restore_fp,\n+\t\t\t\t\t\t    first_offset,\n+\t\t\t\t\t\t    size_to_deallocate);\n \n-  /* The rest of this function does the following:\n-     ARCompact    : handle epilogue_delay, restore sp (phase-2), return\n-  */\n-\n-  /* Keep track of how much of the stack pointer we've restored.\n-     It makes the following a lot more readable.  */\n-  size_to_deallocate += first_offset;\n+  /* Keep track of how much of the stack pointer we've restored.  It\n+     makes the following a lot more readable.  */\n   restored = size - size_to_deallocate;\n \n   if (size > restored)\n@@ -3523,6 +3885,65 @@ arc_expand_epilogue (int sibcall_p)\n     emit_jump_insn (gen_simple_return ());\n }\n \n+/* Helper for {push/pop}_multi_operand: check if rtx OP is a suitable\n+   construct to match either enter or leave instruction.  Which one\n+   which is selected by PUSH_P argument.  */\n+\n+bool\n+arc_check_multi (rtx op, bool push_p)\n+{\n+  HOST_WIDE_INT len = XVECLEN (op, 0);\n+  unsigned int regno, i, start;\n+  unsigned int memp = push_p ? 0 : 1;\n+  rtx elt;\n+\n+  if (len <= 1)\n+    return false;\n+\n+  start = 1;\n+  elt = XVECEXP (op, 0, 0);\n+  if (!push_p && GET_CODE (elt) == RETURN)\n+    start = 2;\n+\n+  for (i = start, regno = ENTER_LEAVE_START_REG; i < len; i++, regno++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+      rtx reg, mem, addr;\n+\n+      if (GET_CODE (elt) != SET)\n+\treturn false;\n+      mem = XEXP (elt, memp);\n+      reg = XEXP (elt, 1 - memp);\n+\n+      if (!REG_P (reg)\n+\t  || !MEM_P (mem))\n+\treturn false;\n+\n+      /* Check for blink.  */\n+      if (REGNO (reg) == RETURN_ADDR_REGNUM\n+\t  && i == start)\n+\tregno = 12;\n+      else if (REGNO (reg) == FRAME_POINTER_REGNUM)\n+\t++i;\n+      else if (REGNO (reg) != regno)\n+\treturn false;\n+\n+      addr = XEXP (mem, 0);\n+      if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  if (!rtx_equal_p (stack_pointer_rtx, XEXP (addr, 0))\n+\t      || !CONST_INT_P (XEXP (addr, 1)))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (!rtx_equal_p (stack_pointer_rtx, addr))\n+\t    return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n /* Return rtx for the location of the return address on the stack,\n    suitable for use in __builtin_eh_return.  The new return address\n    will be written to this location in order to redirect the return to"}, {"sha": "dc0a65cce3a6b25297e7dca41209e513ee336870", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -6432,6 +6432,182 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n    }\n )\n \n+(define_insn \"*push_multi_fp\"\n+  [(match_parallel 0 \"push_multi_operand\"\n+\t\t   [(set (reg:SI SP_REG)\n+\t\t\t (plus:SI (reg:SI SP_REG)\n+\t\t\t\t  (match_operand 1 \"immediate_operand\" \"\")))\n+\t\t    (set (mem:SI (plus:SI (reg:SI SP_REG)\n+\t\t\t\t\t  (match_dup 1)))\n+\t\t\t (reg:SI 13))])]\n+  \"TARGET_CODE_DENSITY\"\n+  {\n+   int len = XVECLEN (operands[0], 0);\n+   rtx tmp = XVECEXP (operands[0], 0, len - 1);\n+   if (MEM_P (XEXP (tmp, 0)))\n+     {\n+      operands[2] = XEXP (tmp, 1);\n+      return \"enter_s\\\\t{r13-%2} ; sp=sp-%1\";\n+     }\n+   else\n+     {\n+      tmp = XVECEXP (operands[0], 0, len - 3);\n+      operands[2] = XEXP (tmp, 1);\n+      return \"enter_s\\\\t{r13-%2, fp} ; sp=sp-%1\";\n+     }\n+  }\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*push_multi_fp_blink\"\n+  [(match_parallel 0 \"push_multi_operand\"\n+\t\t   [(set (reg:SI SP_REG)\n+\t\t\t (plus:SI (reg:SI SP_REG)\n+\t\t\t\t  (match_operand 1 \"immediate_operand\" \"\")))\n+\t\t    (set (mem:SI (plus:SI (reg:SI SP_REG)\n+\t\t\t\t\t  (match_dup 1)))\n+\t\t\t (reg:SI RETURN_ADDR_REGNUM))])]\n+  \"TARGET_CODE_DENSITY\"\n+  {\n+   int len = XVECLEN (operands[0], 0);\n+   rtx tmp = XVECEXP (operands[0], 0, len - 1);\n+   if (MEM_P (XEXP (tmp, 0)))\n+     {\n+      operands[2] = XEXP (tmp, 1);\n+      return \"enter_s\\\\t{r13-%2, blink} ; sp=sp-%1\";\n+     }\n+   else\n+     {\n+      tmp = XVECEXP (operands[0], 0, len - 3);\n+      operands[2] = XEXP (tmp, 1);\n+      return \"enter_s\\\\t{r13-%2, fp, blink} ; sp=sp-%1\";\n+     }\n+  }\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*pop_multi_fp\"\n+  [(match_parallel 0 \"pop_multi_operand\"\n+\t\t   [(set (reg:SI SP_REG)\n+\t\t\t (plus:SI (reg:SI SP_REG)\n+\t\t\t\t  (match_operand 1 \"immediate_operand\" \"\")))\n+\t\t    (set (reg:SI 13)\n+\t\t\t (mem:SI\n+\t\t\t  (plus:SI\n+\t\t\t   (reg:SI SP_REG)\n+\t\t\t   (match_operand 2 \"immediate_operand\" \"\"))))])]\n+  \"TARGET_CODE_DENSITY\"\n+  {\n+   int len = XVECLEN (operands[0], 0);\n+   rtx tmp = XVECEXP (operands[0], 0, len - 1);\n+   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+     {\n+      operands[3] = XEXP (tmp, 0);\n+      gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n+      return \"leave_s\\\\t{r13-%3} ; sp=sp+%1\";\n+     }\n+   else\n+     {\n+      tmp = XVECEXP (operands[0], 0, len - 2);\n+      operands[3] = XEXP (tmp, 0);\n+      return \"leave_s\\\\t{r13-%3, fp} ; sp=sp+%1\";\n+     }\n+  }\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*pop_multi_fp_blink\"\n+  [(match_parallel 0 \"pop_multi_operand\"\n+\t\t   [(set (reg:SI SP_REG)\n+\t\t\t (plus:SI (reg:SI SP_REG)\n+\t\t\t\t  (match_operand 1 \"immediate_operand\" \"\")))\n+\t\t    (set (reg:SI RETURN_ADDR_REGNUM)\n+\t\t\t (mem:SI\n+\t\t\t  (plus:SI\n+\t\t\t   (reg:SI SP_REG)\n+\t\t\t   (match_operand 2 \"immediate_operand\" \"\"))))])]\n+  \"TARGET_CODE_DENSITY\"\n+  {\n+   int len = XVECLEN (operands[0], 0);\n+   rtx tmp = XVECEXP (operands[0], 0, len - 1);\n+   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+     {\n+      operands[3] = XEXP (tmp, 0);\n+      gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n+      return \"leave_s\\\\t{r13-%3, blink} ; sp=sp+%1\";\n+     }\n+   else\n+     {\n+      tmp = XVECEXP (operands[0], 0, len - 2);\n+      operands[3] = XEXP (tmp, 0);\n+      return \"leave_s\\\\t{r13-%3, fp, blink} ; sp=sp+%1\";\n+     }\n+  }\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*pop_multi_fp_ret\"\n+  [(match_parallel 0 \"pop_multi_operand\"\n+\t\t   [(return)\n+\t\t    (set (reg:SI SP_REG)\n+\t\t\t (plus:SI (reg:SI SP_REG)\n+\t\t\t\t  (match_operand 1 \"immediate_operand\" \"\")))\n+\t\t    (set (reg:SI 13)\n+\t\t\t (mem:SI\n+\t\t\t  (plus:SI\n+\t\t\t   (reg:SI SP_REG)\n+\t\t\t   (match_operand 2 \"immediate_operand\" \"\"))))])]\n+  \"TARGET_CODE_DENSITY\"\n+  {\n+   int len = XVECLEN (operands[0], 0);\n+   rtx tmp = XVECEXP (operands[0], 0, len - 1);\n+   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+     {\n+      operands[3] = XEXP (tmp, 0);\n+      gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n+      return \"leave_s\\\\t{r13-%3, pcl} ; sp=sp+%1\";\n+     }\n+   else\n+     {\n+      tmp = XVECEXP (operands[0], 0, len - 2);\n+      operands[3] = XEXP (tmp, 0);\n+      return \"leave_s\\\\t{r13-%3, fp, pcl} ; sp=sp+%1\";\n+     }\n+  }\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*pop_multi_fp_blink_ret\"\n+  [(match_parallel 0 \"pop_multi_operand\"\n+\t\t   [(return)\n+\t\t    (set (reg:SI SP_REG)\n+\t\t\t (plus:SI (reg:SI SP_REG)\n+\t\t\t\t  (match_operand 1 \"immediate_operand\" \"\")))\n+\t\t    (set (reg:SI RETURN_ADDR_REGNUM)\n+\t\t\t (mem:SI\n+\t\t\t  (plus:SI\n+\t\t\t   (reg:SI SP_REG)\n+\t\t\t   (match_operand 2 \"immediate_operand\" \"\"))))])]\n+  \"TARGET_CODE_DENSITY\"\n+  {\n+   int len = XVECLEN (operands[0], 0);\n+   rtx tmp = XVECEXP (operands[0], 0, len - 1);\n+   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+     {\n+      operands[3] = XEXP (tmp, 0);\n+      gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n+      return \"leave_s\\\\t{r13-%3, blink, pcl} ; sp=sp+%1\";\n+     }\n+   else\n+     {\n+      tmp = XVECEXP (operands[0], 0, len - 2);\n+      operands[3] = XEXP (tmp, 0);\n+      return \"leave_s\\\\t{r13-%3, fp, blink, pcl} ; sp=sp+%1\";\n+     }\n+  }\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"2\")])\n+\n ;; include the arc-FPX instructions\n (include \"fpx.md\")\n "}, {"sha": "e8f97e4d1afabdd1d219b4affa2d0479a518980e", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -193,9 +193,9 @@ msdata\n Target Report InverseMask(NO_SDATA_SET)\n Generate sdata references.  This is the default, unless you compile for PIC.\n \n-mno-millicode\n-Target Report Mask(NO_MILLICODE_THUNK_SET)\n-Do not generate millicode thunks (needed only with -Os).\n+mmillicode\n+Target Report Mask(MILLICODE_THUNK_SET)\n+Generate millicode thunks.\n \n mspfp\n Target Report Mask(SPFP_COMPACT_SET)\n@@ -538,3 +538,7 @@ Enable 16-entry register file.\n mbranch-index\n Target Report Var(TARGET_BRANCH_INDEX) Init(DEFAULT_BRANCH_INDEX)\n Enable use of BI/BIH instructions when available.\n+\n+mcode-density-frame\n+Target Report Var(TARGET_CODE_DENSITY_FRAME)\n+Enable ENTER_S and LEAVE_S opcodes for ARCv2."}, {"sha": "efa3650e1fa5d8d9ca95510a14bb4487b039f9e7", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -800,3 +800,15 @@\n (define_predicate \"arc_short_operand\"\n   (ior (match_test \"register_operand (op, mode)\")\n        (match_test \"short_unsigned_const_operand (op, mode)\")))\n+\n+(define_special_predicate \"push_multi_operand\"\n+  (match_code \"parallel\")\n+  {\n+   return arc_check_multi (op, true);\n+})\n+\n+(define_special_predicate \"pop_multi_operand\"\n+  (match_code \"parallel\")\n+  {\n+   return arc_check_multi (op, false);\n+})"}, {"sha": "755a00017f71a04cee1742dca8c57172573a87fa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -651,9 +651,9 @@ Objective-C and Objective-C++ Dialects}.\n -malign-call  -mauto-modify-reg  -mbbit-peephole  -mno-brcc @gol\n -mcase-vector-pcrel  -mcompact-casesi  -mno-cond-exec  -mearly-cbranchsi @gol\n -mexpand-adddi  -mindexed-loads  -mlra  -mlra-priority-none @gol\n--mlra-priority-compact mlra-priority-noncompact  -mno-millicode @gol\n+-mlra-priority-compact mlra-priority-noncompact  -mmillicode @gol\n -mmixed-code  -mq-class  -mRcq  -mRcw  -msize-level=@var{level} @gol\n--mtune=@var{cpu}  -mmultcost=@var{num} @gol\n+-mtune=@var{cpu}  -mmultcost=@var{num} -mcode-density-frame @gol\n -munalign-prob-threshold=@var{probability}  -mmpy-option=@var{multo} @gol\n -mdiv-rem  -mcode-density  -mll64  -mfpu=@var{fpu} -mrf16  -mbranch-index}\n \n@@ -16229,15 +16229,21 @@ Indicate target register priority for r0..r3 / r12..r15.\n @opindex mlra-priority-noncompact\n Reduce target register priority for r0..r3 / r12..r15.\n \n-@item -mno-millicode\n-@opindex mno-millicode\n+@item -mmillicode\n+@opindex mmillicode\n When optimizing for size (using @option{-Os}), prologues and epilogues\n that have to save or restore a large number of registers are often\n shortened by using call to a special function in libgcc; this is\n referred to as a @emph{millicode} call.  As these calls can pose\n performance issues, and/or cause linking issues when linking in a\n-nonstandard way, this option is provided to turn off millicode call\n-generation.\n+nonstandard way, this option is provided to turn on or off millicode\n+call generation.\n+\n+@item -mcode-density-frame\n+@opindex mcode-density-frame\n+This option enable the compiler to emit @code{enter} and @code{leave}\n+instructions.  These instructions are only valid for CPUs with\n+code-density feature.\n \n @item -mmixed-code\n @opindex mmixed-code"}, {"sha": "3e5a88438351b10523e27bd9d22df06d97f049c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -1,3 +1,10 @@\n+2018-11-13  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/firq-1.c: Update test.\n+\t* gcc.target/arc/firq-3.c: Likewise.\n+\t* gcc.target/arc/firq-4.c: Likewise.\n+\t* gcc.target/arc/interrupt-6.c: Likewise.\n+\n 2018-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/87918"}, {"sha": "34d2fedcb45d1e5629bd75aa403f73e1c7dee7a0", "filename": "gcc/testsuite/gcc.target/arc/firq-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-1.c?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -20,8 +20,8 @@ handler1 (void)\n        : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\",\n \t \"r5\", \"r6\", \"r7\", \"r8\", \"r9\");\n }\n-/* { dg-final { scan-assembler-times \"r2,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r4,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r6,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r8,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r2,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r4,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r6,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r8,\\\\\\[sp\" 2 } } */\n /* { dg-final { scan-assembler \"rtie\" } } */"}, {"sha": "63de53af570a9f8a01c4df648ada86eef2ed8bed", "filename": "gcc/testsuite/gcc.target/arc/firq-3.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-3.c?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -28,13 +28,13 @@ handler1 (void)\n /* { dg-final { scan-assembler-not \"r15,\\\\\\[sp\" } } */\n \n /* { dg-final { scan-assembler-times \"r4,\\\\\\[sp\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r6,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r8,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r10,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r16,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r18,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r20,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r24,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r6,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r8,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r10,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r16,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r18,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r20,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r24,\\\\\\[sp\" 2 } } */\n /* { dg-final { scan-assembler-times \"fp,\\\\\\[sp,\" 2 } } */\n \n /* { dg-final { scan-assembler \"rtie\" } } */"}, {"sha": "969ee796f03bd6c13fea3c4e6eb9fe54c3de19f8", "filename": "gcc/testsuite/gcc.target/arc/firq-4.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Ffirq-4.c?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -18,13 +18,13 @@ handler1 (void)\n \t\t  \"r25\", \"fp\");\n }\n /* { dg-final { scan-assembler-times \"r4,\\\\\\[sp\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r6,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r8,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r6,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r8,\\\\\\[sp\" 2 } } */\n \n-/* { dg-final { scan-assembler-times \"r16,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r18,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r20,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n-/* { dg-final { scan-assembler-times \"r24,\\\\\\[sp,\\[0-9\\]+\\\\\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r16,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r18,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r20,\\\\\\[sp\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r24,\\\\\\[sp\" 2 } } */\n \n /* { dg-final { scan-assembler-not \"fp,\\\\\\[sp\" } } */\n /* { dg-final { scan-assembler-not \"push.*fp\" } } */"}, {"sha": "d82bd67edd83448f9e7dc3b37520760b9985139e", "filename": "gcc/testsuite/gcc.target/arc/interrupt-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b480138a5492776e9fab6e7f95aae874d6a0ea/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-6.c?ref=90b480138a5492776e9fab6e7f95aae874d6a0ea", "patch": "@@ -18,5 +18,5 @@ foo(void)\n   bar (p);\n }\n /* { dg-final { scan-assembler-not \".*fp,\\\\\\[sp\" } } */\n-/* { dg-final { scan-assembler \"ld.*blink,\\\\\\[sp\\\\\\]\" } } */\n+/* { dg-final { scan-assembler \"ld.*blink,\\\\\\[sp\" } } */\n /* { dg-final { scan-assembler \"push_s.*blink\" } } */"}]}