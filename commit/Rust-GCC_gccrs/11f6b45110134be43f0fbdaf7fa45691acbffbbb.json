{"sha": "11f6b45110134be43f0fbdaf7fa45691acbffbbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmNmI0NTExMDEzNGJlNDNmMGZiZGFmN2ZhNDU2OTFhY2JmZmJiYg==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-01-08T17:32:13Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-01-08T17:32:13Z"}, "message": "* decl.c: ANSIfy function declarations.\n\nFrom-SVN: r61049", "tree": {"sha": "b2af28ad82a9811343e16a018aa9b31cf4062f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2af28ad82a9811343e16a018aa9b31cf4062f22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11f6b45110134be43f0fbdaf7fa45691acbffbbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f6b45110134be43f0fbdaf7fa45691acbffbbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f6b45110134be43f0fbdaf7fa45691acbffbbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f6b45110134be43f0fbdaf7fa45691acbffbbb/comments", "author": null, "committer": null, "parents": [{"sha": "8caf4c38d83943bcc708ee5707e81076a16f5f43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8caf4c38d83943bcc708ee5707e81076a16f5f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8caf4c38d83943bcc708ee5707e81076a16f5f43"}], "stats": {"total": 1020, "additions": 381, "deletions": 639}, "files": [{"sha": "3435016603ecbdda6392870b1d0c62589a46905e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f6b45110134be43f0fbdaf7fa45691acbffbbb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f6b45110134be43f0fbdaf7fa45691acbffbbb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=11f6b45110134be43f0fbdaf7fa45691acbffbbb", "patch": "@@ -1,3 +1,7 @@\n+2003-01-08  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t* decl.c: ANSIfy function declarations.\n+\n 2003-01-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* parser.c (cp_parser_asm_definition): Correct handling of omitted"}, {"sha": "8740df6c5c47ff96b45bb6db7ccc4714b99aa45a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 377, "deletions": 639, "changes": 1016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f6b45110134be43f0fbdaf7fa45691acbffbbb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f6b45110134be43f0fbdaf7fa45691acbffbbb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=11f6b45110134be43f0fbdaf7fa45691acbffbbb", "patch": "@@ -52,104 +52,105 @@ Boston, MA 02111-1307, USA.  */\n #include \"diagnostic.h\"\n #include \"debug.h\"\n \n-static tree grokparms\t\t\t\tPARAMS ((tree));\n-static const char *redeclaration_error_message\tPARAMS ((tree, tree));\n-\n-static void push_binding_level PARAMS ((struct cp_binding_level *, int,\n-\t\t\t\t      int));\n-static void pop_binding_level PARAMS ((void));\n-static void suspend_binding_level PARAMS ((void));\n-static void resume_binding_level PARAMS ((struct cp_binding_level *));\n-static struct cp_binding_level *make_binding_level PARAMS ((void));\n-static void declare_namespace_level PARAMS ((void));\n-static int decl_jump_unsafe PARAMS ((tree));\n-static void storedecls PARAMS ((tree));\n-static void require_complete_types_for_parms PARAMS ((tree));\n-static int ambi_op_p PARAMS ((enum tree_code));\n-static int unary_op_p PARAMS ((enum tree_code));\n-static tree store_bindings PARAMS ((tree, tree));\n-static tree lookup_tag_reverse PARAMS ((tree, tree));\n-static void push_local_name PARAMS ((tree));\n-static void warn_extern_redeclared_static PARAMS ((tree, tree));\n-static tree grok_reference_init PARAMS ((tree, tree, tree));\n-static tree grokfndecl PARAMS ((tree, tree, tree, tree, int,\n-\t\t\t      enum overload_flags, tree,\n-\t\t\t      tree, int, int, int, int, int, int, tree));\n-static tree grokvardecl PARAMS ((tree, tree, RID_BIT_TYPE *, int, int, tree));\n-static tree follow_tag_typedef PARAMS ((tree));\n-static tree lookup_tag PARAMS ((enum tree_code, tree,\n-\t\t\t      struct cp_binding_level *, int));\n+static tree grokparms (tree);\n+static const char *redeclaration_error_message (tree, tree);\n+\n+static void push_binding_level (struct cp_binding_level *, int,\n+\t\t\t\tint);\n+static void pop_binding_level (void);\n+static void suspend_binding_level (void);\n+static void resume_binding_level (struct cp_binding_level *);\n+static struct cp_binding_level *make_binding_level (void);\n+static void declare_namespace_level (void);\n+static int decl_jump_unsafe (tree);\n+static void storedecls (tree);\n+static void require_complete_types_for_parms (tree);\n+static int ambi_op_p (enum tree_code);\n+static int unary_op_p (enum tree_code);\n+static tree store_bindings (tree, tree);\n+static tree lookup_tag_reverse (tree, tree);\n+static void push_local_name (tree);\n+static void warn_extern_redeclared_static (tree, tree);\n+static tree grok_reference_init (tree, tree, tree);\n+static tree grokfndecl (tree, tree, tree, tree, int,\n+\t\t\tenum overload_flags, tree,\n+\t\t\ttree, int, int, int, int, int, int, tree);\n+static tree grokvardecl (tree, tree, RID_BIT_TYPE *, int, int, tree);\n+static tree follow_tag_typedef (tree);\n+static tree lookup_tag (enum tree_code, tree,\n+\t\t\tstruct cp_binding_level *, int);\n static void set_identifier_type_value_with_scope\n-\tPARAMS ((tree, tree, struct cp_binding_level *));\n-static void record_unknown_type PARAMS ((tree, const char *));\n-static tree builtin_function_1 PARAMS ((const char *, tree, tree, int,\n-                                      enum built_in_class, const char *,\n-\t\t\t\t      tree));\n-static tree build_library_fn_1 PARAMS ((tree, enum tree_code, tree));\n-static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n-static void bad_specifiers PARAMS ((tree, const char *, int, int, int, int,\n-\t\t\t\t  int));\n-static tree maybe_process_template_type_declaration PARAMS ((tree, int, struct cp_binding_level*));\n-static void check_for_uninitialized_const_var PARAMS ((tree));\n-static hashval_t typename_hash PARAMS ((const void *));\n-static int typename_compare PARAMS ((const void *, const void *));\n-static void push_binding PARAMS ((tree, tree, struct cp_binding_level*));\n-static int add_binding PARAMS ((tree, tree));\n-static void pop_binding PARAMS ((tree, tree));\n-static tree local_variable_p_walkfn PARAMS ((tree *, int *, void *));\n-static tree find_binding PARAMS ((tree, tree));\n-static tree select_decl PARAMS ((tree, int));\n-static int lookup_flags PARAMS ((int, int));\n-static tree qualify_lookup PARAMS ((tree, int));\n-static tree record_builtin_java_type PARAMS ((const char *, int));\n-static const char *tag_name PARAMS ((enum tag_types code));\n-static void find_class_binding_level PARAMS ((void));\n-static struct cp_binding_level *innermost_nonclass_level PARAMS ((void));\n-static void warn_about_implicit_typename_lookup PARAMS ((tree, tree));\n-static int walk_namespaces_r PARAMS ((tree, walk_namespaces_fn, void *));\n-static int walk_globals_r PARAMS ((tree, void *));\n-static int walk_vtables_r PARAMS ((tree, void*));\n-static void add_decl_to_level PARAMS ((tree, struct cp_binding_level *));\n-static tree make_label_decl PARAMS ((tree, int));\n-static void use_label PARAMS ((tree));\n-static void check_previous_goto_1 PARAMS ((tree, struct cp_binding_level *, tree,\n-\t\t\t\t\t   const char *, int));\n-static void check_previous_goto PARAMS ((struct named_label_use_list *));\n-static void check_switch_goto PARAMS ((struct cp_binding_level *));\n-static void check_previous_gotos PARAMS ((tree));\n-static void pop_label PARAMS ((tree, tree));\n-static void pop_labels PARAMS ((tree));\n-static void maybe_deduce_size_from_array_init PARAMS ((tree, tree));\n-static void layout_var_decl PARAMS ((tree));\n-static void maybe_commonize_var PARAMS ((tree));\n+\t(tree, tree, struct cp_binding_level *);\n+static void record_unknown_type (tree, const char *);\n+static tree builtin_function_1 (const char *, tree, tree, int,\n+                                enum built_in_class, const char *,\n+\t\t\t\ttree);\n+static tree build_library_fn_1 (tree, enum tree_code, tree);\n+static int member_function_or_else (tree, tree, enum overload_flags);\n+static void bad_specifiers (tree, const char *, int, int, int, int,\n+\t\t\t    int);\n+static tree maybe_process_template_type_declaration \n+\t(tree, int, struct cp_binding_level*);\n+static void check_for_uninitialized_const_var (tree);\n+static hashval_t typename_hash (const void *);\n+static int typename_compare (const void *, const void *);\n+static void push_binding (tree, tree, struct cp_binding_level*);\n+static int add_binding (tree, tree);\n+static void pop_binding (tree, tree);\n+static tree local_variable_p_walkfn (tree *, int *, void *);\n+static tree find_binding (tree, tree);\n+static tree select_decl (tree, int);\n+static int lookup_flags (int, int);\n+static tree qualify_lookup (tree, int);\n+static tree record_builtin_java_type (const char *, int);\n+static const char *tag_name (enum tag_types code);\n+static void find_class_binding_level (void);\n+static struct cp_binding_level *innermost_nonclass_level (void);\n+static void warn_about_implicit_typename_lookup (tree, tree);\n+static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n+static int walk_globals_r (tree, void*);\n+static int walk_vtables_r (tree, void*);\n+static void add_decl_to_level (tree, struct cp_binding_level *);\n+static tree make_label_decl (tree, int);\n+static void use_label (tree);\n+static void check_previous_goto_1 (tree, struct cp_binding_level *, tree,\n+\t\t\t\t   const char *, int);\n+static void check_previous_goto (struct named_label_use_list *);\n+static void check_switch_goto (struct cp_binding_level *);\n+static void check_previous_gotos (tree);\n+static void pop_label (tree, tree);\n+static void pop_labels (tree);\n+static void maybe_deduce_size_from_array_init (tree, tree);\n+static void layout_var_decl (tree);\n+static void maybe_commonize_var (tree);\n static tree check_initializer (tree, tree, int);\n-static void make_rtl_for_nonlocal_decl PARAMS ((tree, tree, const char *));\n-static void save_function_data PARAMS ((tree));\n-static void check_function_type PARAMS ((tree, tree));\n-static void begin_constructor_body PARAMS ((void));\n-static void finish_constructor_body PARAMS ((void));\n-static void begin_destructor_body PARAMS ((void));\n-static void finish_destructor_body PARAMS ((void));\n-static tree create_array_type_for_decl PARAMS ((tree, tree, tree));\n-static tree get_atexit_node PARAMS ((void));\n-static tree get_dso_handle_node PARAMS ((void));\n-static tree start_cleanup_fn PARAMS ((void));\n-static void end_cleanup_fn PARAMS ((void));\n-static tree cp_make_fname_decl PARAMS ((tree, int));\n-static void initialize_predefined_identifiers PARAMS ((void));\n-static tree check_special_function_return_type\n-  PARAMS ((special_function_kind, tree, tree));\n-static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n-static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n-static void store_parm_decls PARAMS ((tree));\n-static int cp_missing_noreturn_ok_p PARAMS ((tree));\n+static void make_rtl_for_nonlocal_decl (tree, tree, const char *);\n+static void save_function_data (tree);\n+static void check_function_type (tree, tree);\n+static void begin_constructor_body (void);\n+static void finish_constructor_body (void);\n+static void begin_destructor_body (void);\n+static void finish_destructor_body (void);\n+static tree create_array_type_for_decl (tree, tree, tree);\n+static tree get_atexit_node (void);\n+static tree get_dso_handle_node (void);\n+static tree start_cleanup_fn (void);\n+static void end_cleanup_fn (void);\n+static tree cp_make_fname_decl (tree, int);\n+static void initialize_predefined_identifiers (void);\n+static tree check_special_function_return_type \n+\t(special_function_kind, tree, tree);\n+static tree push_cp_library_fn (enum tree_code, tree);\n+static tree build_cp_library_fn (tree, enum tree_code, tree);\n+static void store_parm_decls (tree);\n+static int cp_missing_noreturn_ok_p (tree);\n static void initialize_local_var (tree, tree);\n static void expand_static_init (tree, tree);\n static tree next_initializable_field (tree);\n static tree reshape_init (tree, tree *);\n \n #if defined (DEBUG_BINDING_LEVELS)\n-static void indent PARAMS ((void));\n+static void indent (void);\n #endif\n \n /* Erroneous argument lists can use this *IFF* they do not modify it.  */\n@@ -464,7 +465,7 @@ static int binding_depth = 0;\n static int is_class_level = 0;\n \n static void\n-indent ()\n+indent (void)\n {\n   register unsigned i;\n \n@@ -473,12 +474,12 @@ indent ()\n }\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n \n-static tree pushdecl_with_scope\tPARAMS ((tree, struct cp_binding_level *));\n+static tree pushdecl_with_scope\t(tree, struct cp_binding_level *);\n \n static void\n-push_binding_level (newlevel, tag_transparent, keep)\n-     struct cp_binding_level *newlevel;\n-     int tag_transparent, keep;\n+push_binding_level (struct cp_binding_level *newlevel, \n+                    int tag_transparent, \n+                    int keep)\n {\n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n@@ -503,7 +504,7 @@ push_binding_level (newlevel, tag_transparent, keep)\n    CLASS_BINDING_LEVEL appropriately.  */\n \n static void\n-find_class_binding_level ()\n+find_class_binding_level (void)\n {\n   struct cp_binding_level *level = current_binding_level;\n \n@@ -516,7 +517,7 @@ find_class_binding_level ()\n }\n \n static void\n-pop_binding_level ()\n+pop_binding_level (void)\n {\n   if (global_binding_level)\n     {\n@@ -552,7 +553,7 @@ pop_binding_level ()\n }\n \n static void\n-suspend_binding_level ()\n+suspend_binding_level (void)\n {\n   if (class_binding_level)\n     current_binding_level = class_binding_level;\n@@ -582,8 +583,7 @@ suspend_binding_level ()\n }\n \n static void\n-resume_binding_level (b)\n-     struct cp_binding_level *b;\n+resume_binding_level (struct cp_binding_level* b)\n {\n   /* Resuming binding levels is meant only for namespaces,\n      and those cannot nest into classes.  */\n@@ -605,7 +605,7 @@ resume_binding_level (b)\n \n static\n struct cp_binding_level *\n-make_binding_level ()\n+make_binding_level (void)\n {\n   /* NOSTRICT */\n   return (struct cp_binding_level *) ggc_alloc (sizeof (struct cp_binding_level));\n@@ -614,15 +614,15 @@ make_binding_level ()\n /* Nonzero if we are currently in the global binding level.  */\n \n int\n-global_bindings_p ()\n+global_bindings_p (void)\n {\n   return current_binding_level == global_binding_level;\n }\n \n /* Return the innermost binding level that is not for a class scope.  */\n \n static struct cp_binding_level *\n-innermost_nonclass_level ()\n+innermost_nonclass_level (void)\n {\n   struct cp_binding_level *b;\n \n@@ -640,7 +640,7 @@ innermost_nonclass_level ()\n    also include a class whose context is toplevel.  */\n \n int\n-toplevel_bindings_p ()\n+toplevel_bindings_p (void)\n {\n   struct cp_binding_level *b = innermost_nonclass_level ();\n \n@@ -652,7 +652,7 @@ toplevel_bindings_p ()\n    such a class, etc.  */\n \n int\n-namespace_bindings_p ()\n+namespace_bindings_p (void)\n {\n   struct cp_binding_level *b = innermost_nonclass_level ();\n \n@@ -664,16 +664,15 @@ namespace_bindings_p ()\n    or not to create a BLOCK.  */\n \n void\n-keep_next_level (keep)\n-     int keep;\n+keep_next_level (int keep)\n {\n   keep_next_level_flag = keep;\n }\n \n /* Nonzero if the current level needs to have a BLOCK made.  */\n \n int\n-kept_level_p ()\n+kept_level_p (void)\n {\n   return (current_binding_level->blocks != NULL_TREE\n \t  || current_binding_level->keep\n@@ -683,7 +682,7 @@ kept_level_p ()\n }\n \n static void\n-declare_namespace_level ()\n+declare_namespace_level (void)\n {\n   current_binding_level->namespace_p = 1;\n }\n@@ -692,7 +691,7 @@ declare_namespace_level ()\n    parameters.  */\n \n int\n-template_parm_scope_p ()\n+template_parm_scope_p (void)\n {\n   return current_binding_level->template_parms_p;\n }\n@@ -702,8 +701,7 @@ template_parm_scope_p ()\n    explicit scope qualifications.  */\n \n tmpl_spec_kind\n-current_tmpl_spec_kind (n_class_scopes)\n-     int n_class_scopes;\n+current_tmpl_spec_kind (int n_class_scopes)\n {\n   int n_template_parm_scopes = 0;\n   int seen_specialization_p = 0;\n@@ -787,8 +785,7 @@ current_tmpl_spec_kind (n_class_scopes)\n }\n \n void\n-set_class_shadows (shadows)\n-     tree shadows;\n+set_class_shadows (tree shadows)\n {\n   class_binding_level->class_shadowed = shadows;\n }\n@@ -798,8 +795,7 @@ set_class_shadows (shadows)\n    not for that of tags.  */\n \n void\n-pushlevel (tag_transparent)\n-     int tag_transparent;\n+pushlevel (int tag_transparent)\n {\n   struct cp_binding_level *newlevel;\n \n@@ -828,8 +824,7 @@ pushlevel (tag_transparent)\n    scope, create a new binding level.  */\n \n void\n-maybe_push_cleanup_level (type)\n-     tree type;\n+maybe_push_cleanup_level (tree type)\n {\n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n       && current_binding_level->more_cleanups_ok == 0)\n@@ -845,8 +840,7 @@ maybe_push_cleanup_level (type)\n    created.  */\n \n void\n-begin_scope (sk)\n-     scope_kind sk;\n+begin_scope (scope_kind sk)\n {\n   pushlevel (0);\n \n@@ -883,7 +877,7 @@ begin_scope (sk)\n /* Exit the current scope.  */\n \n void\n-finish_scope ()\n+finish_scope (void)\n {\n   poplevel (0, 0, 0);\n }\n@@ -902,10 +896,9 @@ static GTY((deletable (\"\"))) tree free_bindings;\n    level at which this declaration is being bound.  */\n \n static void\n-push_binding (id, decl, level)\n-     tree id;\n-     tree decl;\n-     struct cp_binding_level* level;\n+push_binding (tree id, \n+              tree decl,\n+              struct cp_binding_level* level)\n {\n   tree binding;\n \n@@ -937,9 +930,7 @@ push_binding (id, decl, level)\n    responsibility of the caller to check that inserting this name is\n    valid here.  Returns nonzero if the new binding was successful.  */\n static int\n-add_binding (id, decl)\n-     tree id;\n-     tree decl;\n+add_binding (tree id, tree decl)\n {\n   tree binding = IDENTIFIER_BINDING (id);\n   int ok = 1;\n@@ -1006,9 +997,8 @@ add_binding (id, decl)\n /* Add DECL to the list of things declared in B.  */\n \n static void\n-add_decl_to_level (decl, b)\n-     tree decl;\n-     struct cp_binding_level *b;\n+add_decl_to_level (tree decl, \n+                   struct cp_binding_level* b)\n {\n   if (TREE_CODE (decl) == NAMESPACE_DECL \n       && !DECL_NAMESPACE_ALIAS (decl))\n@@ -1037,10 +1027,7 @@ add_decl_to_level (decl, b)\n    through a using-declaration.  */\n \n void\n-push_local_binding (id, decl, flags)\n-     tree id;\n-     tree decl;\n-     int flags;\n+push_local_binding (tree id, tree decl, int flags)\n {\n   struct cp_binding_level *b;\n \n@@ -1078,9 +1065,7 @@ push_local_binding (id, decl, flags)\n    binding was successful.  */\n \n int\n-push_class_binding (id, decl)\n-     tree id;\n-     tree decl;\n+push_class_binding (tree id, tree decl)\n {\n   int result = 1;\n   tree binding = IDENTIFIER_BINDING (id);\n@@ -1144,9 +1129,7 @@ push_class_binding (id, decl)\n    for ID.  */\n \n static void\n-pop_binding (id, decl)\n-     tree id;\n-     tree decl;\n+pop_binding (tree id, tree decl)\n {\n   tree binding;\n \n@@ -1191,9 +1174,7 @@ pop_binding (id, decl)\n    in a valid manner, and issue any appropriate warnings or errors.  */\n \n static void\n-pop_label (label, old_value)\n-     tree label;\n-     tree old_value;\n+pop_label (tree label, tree old_value)\n {\n   if (!processing_template_decl && doing_semantic_analysis_p ())\n     {\n@@ -1215,8 +1196,7 @@ pop_label (label, old_value)\n    function.  */\n \n static void\n-pop_labels (block)\n-     tree block;\n+pop_labels (tree block)\n {\n   struct named_label_list *link;\n \n@@ -1250,10 +1230,7 @@ pop_labels (block)\n    them into the BLOCK.  */\n \n tree\n-poplevel (keep, reverse, functionbody)\n-     int keep;\n-     int reverse;\n-     int functionbody;\n+poplevel (int keep, int reverse, int functionbody)\n {\n   register tree link;\n   /* The chain of decls was accumulated in reverse order.\n@@ -1567,8 +1544,7 @@ poplevel (keep, reverse, functionbody)\n    so that the block can be reinserted where appropriate.  */\n \n void\n-delete_block (block)\n-     tree block;\n+delete_block (tree block)\n {\n   tree t;\n   if (current_binding_level->blocks == block)\n@@ -1591,8 +1567,7 @@ delete_block (block)\n    to handle the BLOCK node inside the BIND_EXPR.  */\n \n void\n-insert_block (block)\n-     tree block;\n+insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n   current_binding_level->blocks\n@@ -1603,8 +1578,7 @@ insert_block (block)\n    (the one we are currently in).  */\n \n void\n-set_block (block)\n-    tree block ATTRIBUTE_UNUSED;\n+set_block (tree block ATTRIBUTE_UNUSED )\n {\n   /* The RTL expansion machinery requires us to provide this callback,\n      but it is not applicable in function-at-a-time mode.  */\n@@ -1614,7 +1588,7 @@ set_block (block)\n /* Do a pushlevel for class declarations.  */\n \n void\n-pushlevel_class ()\n+pushlevel_class (void)\n {\n   register struct cp_binding_level *newlevel;\n \n@@ -1645,7 +1619,7 @@ pushlevel_class ()\n /* ...and a poplevel for class declarations.  */\n \n void\n-poplevel_class ()\n+poplevel_class (void)\n {\n   register struct cp_binding_level *level = class_binding_level;\n   tree shadowed;\n@@ -1720,7 +1694,7 @@ poplevel_class ()\n    for any names in enclosing classes.  */\n \n void\n-clear_identifier_class_values ()\n+clear_identifier_class_values (void)\n {\n   tree t;\n \n@@ -1736,9 +1710,7 @@ clear_identifier_class_values ()\n /* Returns nonzero if T is a virtual function table.  */\n \n int\n-vtable_decl_p (t, data)\n-     tree t;\n-     void *data ATTRIBUTE_UNUSED;\n+vtable_decl_p (tree t, void* data ATTRIBUTE_UNUSED )\n {\n   return (TREE_CODE (t) == VAR_DECL && DECL_VIRTUAL_P (t));\n }\n@@ -1747,9 +1719,7 @@ vtable_decl_p (t, data)\n    functions.  */\n \n int\n-vtype_decl_p (t, data)\n-     tree t;\n-     void *data ATTRIBUTE_UNUSED;\n+vtype_decl_p (tree t, void *data ATTRIBUTE_UNUSED )\n {\n   return (TREE_CODE (t) == TYPE_DECL\n \t  && TREE_CODE (TREE_TYPE (t)) == RECORD_TYPE\n@@ -1759,8 +1729,7 @@ vtype_decl_p (t, data)\n /* Return the declarations that are members of the namespace NS.  */\n \n tree\n-cp_namespace_decls (ns)\n-     tree ns;\n+cp_namespace_decls (tree ns)\n {\n   return NAMESPACE_LEVEL (ns)->names;\n }\n@@ -1776,9 +1745,7 @@ struct walk_globals_data {\n    to F returns a nonzero value, return a nonzero value.  */\n \n static int\n-walk_vtables_r (namespace, data)\n-     tree namespace;\n-     void *data;\n+walk_vtables_r (tree namespace, void* data)\n {\n   struct walk_globals_data* wgd = (struct walk_globals_data *) data;\n   walk_globals_fn f = wgd->f;\n@@ -1810,10 +1777,7 @@ walk_vtables (walk_globals_pred p, walk_globals_fn f, void *data)\n    itself, calling F for each.  The DATA is passed to F as well.  */\n \n static int\n-walk_namespaces_r (namespace, f, data)\n-     tree namespace;\n-     walk_namespaces_fn f;\n-     void *data;\n+walk_namespaces_r (tree namespace, walk_namespaces_fn f, void* data)\n {\n   int result = 0;\n   tree current = NAMESPACE_LEVEL (namespace)->namespaces;     \n@@ -1830,9 +1794,7 @@ walk_namespaces_r (namespace, f, data)\n    F as well.  */\n \n int\n-walk_namespaces (f, data)\n-     walk_namespaces_fn f;\n-     void *data;\n+walk_namespaces (walk_namespaces_fn f, void* data)\n {\n   return walk_namespaces_r (global_namespace, f, data);\n }\n@@ -1842,9 +1804,7 @@ walk_namespaces (f, data)\n    to F returns a nonzero value, return a nonzero value.  */\n \n static int\n-walk_globals_r (namespace, data)\n-     tree namespace;\n-     void *data;\n+walk_globals_r (tree namespace, void* data)\n {\n   struct walk_globals_data* wgd = (struct walk_globals_data *) data;\n   walk_globals_pred p = wgd->p;\n@@ -1891,9 +1851,7 @@ walk_globals (walk_globals_pred p, walk_globals_fn f, void *data)\n    wrapup_global_declarations for this NAMESPACE.  */\n \n int\n-wrapup_globals_for_namespace (namespace, data)\n-     tree namespace;\n-     void *data;\n+wrapup_globals_for_namespace (tree namespace, void* data)\n {\n   tree globals = cp_namespace_decls (namespace);\n   int len = NAMESPACE_LEVEL (namespace)->names_size;\n@@ -1930,8 +1888,7 @@ static int no_print_functions = 0;\n static int no_print_builtins = 0;\n \n void\n-print_binding_level (lvl)\n-     struct cp_binding_level *lvl;\n+print_binding_level (struct cp_binding_level* lvl)\n {\n   tree t;\n   int i = 0, len;\n@@ -2031,8 +1988,7 @@ print_binding_level (lvl)\n }\n \n void\n-print_other_binding_stack (stack)\n-     struct cp_binding_level *stack;\n+print_other_binding_stack (struct cp_binding_level *stack)\n {\n   struct cp_binding_level *level;\n   for (level = stack; level != global_binding_level; level = level->level_chain)\n@@ -2045,7 +2001,7 @@ print_other_binding_stack (stack)\n }\n \n void\n-print_binding_stack ()\n+print_binding_stack (void)\n {\n   struct cp_binding_level *b;\n   fprintf (stderr, \"current_binding_level=\");\n@@ -2082,9 +2038,7 @@ print_binding_stack ()\n    of bindings. Returns the binding found, or NULL_TREE.  */\n \n static tree\n-find_binding (name, scope)\n-     tree name;\n-     tree scope;\n+find_binding (tree name, tree scope)\n {\n   tree iter, prev = NULL_TREE;\n \n@@ -2116,9 +2070,7 @@ find_binding (name, scope)\n    If no binding is found, make a new one.  */\n \n tree\n-binding_for_name (name, scope)\n-     tree name;\n-     tree scope;\n+binding_for_name (tree name, tree scope)\n {\n   tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n   tree result;\n@@ -2148,9 +2100,7 @@ binding_for_name (name, scope)\n    namespace_binding may or may not be a list of CPLUS_BINDINGS.  */\n \n tree\n-namespace_binding (name, scope)\n-     tree name;\n-     tree scope;\n+namespace_binding (tree name, tree scope)\n {\n   tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n   if (b == NULL_TREE)\n@@ -2169,10 +2119,7 @@ namespace_binding (name, scope)\n    of global_namespace is attempted, try to optimize it.  */\n \n void\n-set_namespace_binding (name, scope, val)\n-     tree name;\n-     tree scope;\n-     tree val;\n+set_namespace_binding (tree name, tree scope, tree val)\n {\n   tree b;\n \n@@ -2196,8 +2143,7 @@ set_namespace_binding (name, scope, val)\n    select a name that is unique to this compilation unit.  */\n \n void\n-push_namespace (name)\n-     tree name;\n+push_namespace (tree name)\n {\n   tree d = NULL_TREE;\n   int need_new = 1;\n@@ -2265,7 +2211,7 @@ push_namespace (name)\n /* Pop from the scope of the current namespace.  */\n \n void\n-pop_namespace ()\n+pop_namespace (void)\n {\n   my_friendly_assert (current_namespace != global_namespace, 20010801);\n   current_namespace = CP_DECL_CONTEXT (current_namespace);\n@@ -2277,8 +2223,7 @@ pop_namespace ()\n    nested within another namespace.  */\n \n void\n-push_nested_namespace (ns)\n-     tree ns;\n+push_nested_namespace (tree ns)\n {\n   if (ns == global_namespace)\n     push_to_top_level ();\n@@ -2293,8 +2238,7 @@ push_nested_namespace (ns)\n    entered with push_nested_namespace.  */\n \n void\n-pop_nested_namespace (ns)\n-     tree ns;\n+pop_nested_namespace (tree ns)\n {\n   while (ns != global_namespace)\n     {\n@@ -2314,8 +2258,7 @@ pop_nested_namespace (ns)\n struct saved_scope *scope_chain;\n \n static tree\n-store_bindings (names, old_bindings)\n-     tree names, old_bindings;\n+store_bindings (tree names, tree old_bindings)\n {\n   tree t;\n   tree search_bindings = old_bindings;\n@@ -2357,8 +2300,7 @@ store_bindings (names, old_bindings)\n }\n \n void\n-maybe_push_to_top_level (pseudo)\n-     int pseudo;\n+maybe_push_to_top_level (int pseudo)\n {\n   struct saved_scope *s;\n   struct cp_binding_level *b;\n@@ -2421,13 +2363,13 @@ maybe_push_to_top_level (pseudo)\n }\n \n void\n-push_to_top_level ()\n+push_to_top_level (void)\n {\n   maybe_push_to_top_level (0);\n }\n \n void\n-pop_from_top_level ()\n+pop_from_top_level (void)\n {\n   struct saved_scope *s = scope_chain;\n   tree t;\n@@ -2470,10 +2412,9 @@ pop_from_top_level ()\n    the type that ID maps to.  */\n \n static void\n-set_identifier_type_value_with_scope (id, type, b)\n-     tree id;\n-     tree type;\n-     struct cp_binding_level *b;\n+set_identifier_type_value_with_scope (tree id, \n+                                      tree type, \n+                                      struct cp_binding_level* b)\n {\n   if (!b->namespace_p)\n     {\n@@ -2496,18 +2437,15 @@ set_identifier_type_value_with_scope (id, type, b)\n /* As set_identifier_type_value_with_scope, but using current_binding_level.  */\n \n void\n-set_identifier_type_value (id, type)\n-     tree id;\n-     tree type;\n+set_identifier_type_value (tree id, tree type)\n {\n   set_identifier_type_value_with_scope (id, type, current_binding_level);\n }\n \n /* Return the type associated with id.  */\n \n tree\n-identifier_type_value (id)\n-     tree id;\n+identifier_type_value (tree id)\n {\n   /* There is no type with that name, anywhere.  */\n   if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n@@ -2528,7 +2466,7 @@ identifier_type_value (id)\n    We don't pop past namespaces, as they might be valid.  */\n \n void\n-pop_everything ()\n+pop_everything (void)\n {\n #ifdef DEBUG_BINDING_LEVELS\n   fprintf (stderr, \"XXX entering pop_everything ()\\n\");\n@@ -2555,10 +2493,9 @@ pop_everything ()\n    processing.  */\n \n static tree\n-maybe_process_template_type_declaration (type, globalize, b)\n-     tree type;\n-     int globalize;\n-     struct cp_binding_level* b;\n+maybe_process_template_type_declaration (tree type, \n+                                         int globalize, \n+                                         struct cp_binding_level* b)\n {\n   tree decl = TYPE_NAME (type);\n \n@@ -2621,9 +2558,7 @@ maybe_process_template_type_declaration (type, globalize, b)\n    the TYPE_DECL for TYPE.  */\n \n tree\n-create_implicit_typedef (name, type)\n-     tree name;\n-     tree type;\n+create_implicit_typedef (tree name, tree type)\n {\n   tree decl;\n \n@@ -2641,8 +2576,7 @@ create_implicit_typedef (name, type)\n /* Remember a local name for name-mangling purposes.  */\n \n static void\n-push_local_name (decl)\n-     tree decl;\n+push_local_name (tree decl)\n {\n   size_t i, nelts;\n   tree t, name;\n@@ -2680,9 +2614,7 @@ push_local_name (decl)\n    The latter is needed for implicit declarations.  */\n \n void\n-pushtag (name, type, globalize)\n-     tree name, type;\n-     int globalize;\n+pushtag (tree name, tree type, int globalize)\n {\n   register struct cp_binding_level *b;\n \n@@ -2805,7 +2737,7 @@ static int anon_cnt = 0;\n    anonymous structs and unions.  */\n \n tree\n-make_anon_name ()\n+make_anon_name (void)\n {\n   char buf[32];\n \n@@ -2817,7 +2749,7 @@ make_anon_name ()\n    This keeps dbxout from getting confused.  */\n \n void\n-clear_anon_tags ()\n+clear_anon_tags (void)\n {\n   register struct cp_binding_level *b;\n   register tree tags;\n@@ -2852,8 +2784,7 @@ clear_anon_tags ()\n    `const int&'.  */\n \n int\n-decls_match (newdecl, olddecl)\n-     tree newdecl, olddecl;\n+decls_match (tree newdecl, tree olddecl)\n {\n   int types_match;\n \n@@ -2956,8 +2887,7 @@ decls_match (newdecl, olddecl)\n    the user's control.  */\n \n static void\n-warn_extern_redeclared_static (newdecl, olddecl)\n-     tree newdecl, olddecl;\n+warn_extern_redeclared_static (tree newdecl, tree olddecl)\n {\n   static const char *const explicit_extern_static_warning\n     = \"`%D' was declared `extern' and later `static'\";\n@@ -3002,8 +2932,7 @@ warn_extern_redeclared_static (newdecl, olddecl)\n    Otherwise, return 0.  */\n \n int\n-duplicate_decls (newdecl, olddecl)\n-     tree newdecl, olddecl;\n+duplicate_decls (tree newdecl, tree olddecl)\n {\n   unsigned olddecl_uid = DECL_UID (olddecl);\n   int olddecl_friend = 0, types_match = 0;\n@@ -3761,8 +3690,7 @@ duplicate_decls (newdecl, olddecl)\n    to agree with what X says.  */\n \n tree\n-pushdecl (x)\n-     tree x;\n+pushdecl (tree x)\n {\n   register tree t;\n   register tree name;\n@@ -4208,9 +4136,7 @@ pushdecl (x)\n    caller to set DECL_CONTEXT properly.  */\n \n static tree\n-pushdecl_with_scope (x, level)\n-     tree x;\n-     struct cp_binding_level *level;\n+pushdecl_with_scope (tree x, struct cp_binding_level* level)\n {\n   register struct cp_binding_level *b;\n   tree function_decl = current_function_decl;\n@@ -4238,8 +4164,7 @@ pushdecl_with_scope (x, level)\n    if appropriate.  */\n \n tree\n-pushdecl_namespace_level (x)\n-     tree x;\n+pushdecl_namespace_level (tree x)\n {\n   register struct cp_binding_level *b = current_binding_level;\n   register tree t;\n@@ -4284,8 +4209,7 @@ pushdecl_namespace_level (x)\n    if appropriate.  */\n \n tree\n-pushdecl_top_level (x)\n-     tree x;\n+pushdecl_top_level (tree x)\n {\n   push_to_top_level ();\n   x = pushdecl_namespace_level (x);\n@@ -4296,8 +4220,7 @@ pushdecl_top_level (x)\n /* Make the declaration of X appear in CLASS scope.  */\n \n void\n-pushdecl_class_level (x)\n-     tree x;\n+pushdecl_class_level (tree x)\n {\n   tree name;\n \n@@ -4329,8 +4252,7 @@ pushdecl_class_level (x)\n    DECL, or a modified version thereof.  */\n \n tree\n-maybe_push_decl (decl)\n-     tree decl;\n+maybe_push_decl (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -4359,9 +4281,7 @@ maybe_push_decl (decl)\n    under the name NAME.  */\n \n void\n-push_class_level_binding (name, x)\n-     tree name;\n-     tree x;\n+push_class_level_binding (tree name, tree x)\n {\n   tree binding;\n   /* The class_binding_level will be NULL if x is a template\n@@ -4440,9 +4360,7 @@ push_class_level_binding (name, x)\n    scope, a using decl might extend any previous bindings).  */\n \n tree\n-push_using_decl (scope, name)\n-     tree scope;\n-     tree name;\n+push_using_decl (tree scope, tree name)\n {\n   tree decl;\n \n@@ -4465,8 +4383,7 @@ push_using_decl (scope, name)\n    TREE_LIST otherwise.  */\n \n tree\n-push_using_directive (used)\n-     tree used;\n+push_using_directive (tree used)\n {\n   tree ud = current_binding_level->using_directives;\n   tree iter, ancestor;\n@@ -4506,9 +4423,7 @@ push_using_directive (used)\n    it's always DECL (and never something that's not a _DECL).  */\n \n tree\n-push_overloaded_decl (decl, flags)\n-     tree decl;\n-     int flags;\n+push_overloaded_decl (tree decl, int flags)\n {\n   tree name = DECL_NAME (decl);\n   tree old;\n@@ -4624,8 +4539,7 @@ push_overloaded_decl (decl, flags)\n    as a function of type int ().  Print a warning if appropriate.  */\n \n tree\n-implicitly_declare (functionid)\n-     tree functionid;\n+implicitly_declare (tree functionid)\n {\n   register tree decl;\n \n@@ -4661,8 +4575,7 @@ implicitly_declare (functionid)\n    where the identifier should go.  */\n \n static const char *\n-redeclaration_error_message (newdecl, olddecl)\n-     tree newdecl, olddecl;\n+redeclaration_error_message (tree newdecl, tree olddecl)\n {\n   if (TREE_CODE (newdecl) == TYPE_DECL)\n     {\n@@ -4738,9 +4651,7 @@ redeclaration_error_message (newdecl, olddecl)\n /* Create a new label, named ID.  */\n \n static tree\n-make_label_decl (id, local_p)\n-     tree id;\n-     int local_p;\n+make_label_decl (tree id, int local_p)\n {\n   tree decl;\n \n@@ -4770,8 +4681,7 @@ make_label_decl (id, local_p)\n    this use is valid.  */\n \n static void\n-use_label (decl)\n-     tree decl;\n+use_label (tree decl)\n {\n   if (named_label_uses == NULL\n       || named_label_uses->names_in_scope != current_binding_level->names\n@@ -4795,8 +4705,7 @@ use_label (decl)\n    labels, and complain about them at the end of a function.)  */\n \n tree\n-lookup_label (id)\n-     tree id;\n+lookup_label (tree id)\n {\n   tree decl;\n   struct named_label_list *ent;\n@@ -4835,8 +4744,7 @@ lookup_label (id)\n /* Declare a local label named ID.  */\n \n tree\n-declare_local_label (id)\n-     tree id;\n+declare_local_label (tree id)\n {\n   tree decl;\n \n@@ -4858,8 +4766,7 @@ declare_local_label (id)\n    DECL.  Returns 2 if it's also a real problem.  */\n \n static int\n-decl_jump_unsafe (decl)\n-     tree decl;\n+decl_jump_unsafe (tree decl)\n {\n   if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl))\n     return 0;\n@@ -4883,12 +4790,11 @@ decl_jump_unsafe (decl)\n    context; FILE and LINE are the source position of the jump or 0.  */\n \n static void\n-check_previous_goto_1 (decl, level, names, file, line)\n-     tree decl;\n-     struct cp_binding_level *level;\n-     tree names;\n-     const char *file;\n-     int line;\n+check_previous_goto_1 (tree decl,\n+                       struct cp_binding_level* level,\n+                       tree names,\n+                       const char* file,\n+                       int line)\n {\n   int identified = 0;\n   int saw_eh = 0;\n@@ -4949,17 +4855,15 @@ check_previous_goto_1 (decl, level, names, file, line)\n }\n \n static void\n-check_previous_goto (use)\n-     struct named_label_use_list *use;\n+check_previous_goto (struct named_label_use_list* use)\n {\n   check_previous_goto_1 (use->label_decl, use->binding_level,\n \t\t\t use->names_in_scope, use->filename_o_goto,\n \t\t\t use->lineno_o_goto);\n }\n \n static void\n-check_switch_goto (level)\n-     struct cp_binding_level *level;\n+check_switch_goto (struct cp_binding_level* level)\n {\n   check_previous_goto_1 (NULL_TREE, level, level->names, NULL, 0);\n }\n@@ -4968,8 +4872,7 @@ check_switch_goto (level)\n    are OK.  Called by define_label.  */\n \n static void\n-check_previous_gotos (decl)\n-     tree decl;\n+check_previous_gotos (tree decl)\n {\n   struct named_label_use_list **usep;\n \n@@ -4993,8 +4896,7 @@ check_previous_gotos (decl)\n    finish_goto_stmt.  */\n \n void\n-check_goto (decl)\n-     tree decl;\n+check_goto (tree decl)\n {\n   int identified = 0;\n   tree bad;\n@@ -5054,10 +4956,7 @@ check_goto (decl)\n    Otherwise return 0.  */\n \n tree\n-define_label (filename, line, name)\n-     const char *filename;\n-     int line;\n-     tree name;\n+define_label (const char* filename, int line, tree name)\n {\n   tree decl = lookup_label (name);\n   struct named_label_list *ent;\n@@ -5123,8 +5022,7 @@ static struct cp_switch *switch_stack;\n    SWITCH_STMT is the switch statement being parsed.  */\n \n void\n-push_switch (switch_stmt)\n-     tree switch_stmt;\n+push_switch (tree switch_stmt)\n {\n   struct cp_switch *p\n     = (struct cp_switch *) xmalloc (sizeof (struct cp_switch));\n@@ -5136,7 +5034,7 @@ push_switch (switch_stmt)\n }\n \n void\n-pop_switch ()\n+pop_switch (void)\n {\n   struct cp_switch *cs;\n \n@@ -5150,9 +5048,7 @@ pop_switch ()\n    is a bad place for one.  */\n \n tree\n-finish_case_label (low_value, high_value)\n-     tree low_value;\n-     tree high_value;\n+finish_case_label (tree low_value, tree high_value)\n {\n   tree cond, r;\n   register struct cp_binding_level *p;\n@@ -5204,15 +5100,15 @@ finish_case_label (low_value, high_value)\n    store the result back using `storedecls' or you will lose.  */\n \n tree\n-getdecls ()\n+getdecls (void)\n {\n   return current_binding_level->names;\n }\n \n /* Return the list of type-tags (for structs, etc) of the current level.  */\n \n tree\n-gettags ()\n+gettags (void)\n {\n   return current_binding_level->tags;\n }\n@@ -5222,17 +5118,15 @@ gettags ()\n    after they are modified in the light of any missing parameters.  */\n \n static void\n-storedecls (decls)\n-     tree decls;\n+storedecls (tree decls)\n {\n   current_binding_level->names = decls;\n }\n \n /* Similarly, store the list of tags of the current level.  */\n \n void\n-storetags (tags)\n-     tree tags;\n+storetags (tree tags)\n {\n   current_binding_level->tags = tags;\n }\n@@ -5261,8 +5155,7 @@ storetags (tags)\n    Return null for this case.  */\n \n static tree\n-follow_tag_typedef (type)\n-     tree type;\n+follow_tag_typedef (tree type)\n {\n   tree original;\n \n@@ -5290,11 +5183,10 @@ follow_tag_typedef (type)\n    reported.  */\n \n static tree\n-lookup_tag (form, name, binding_level, thislevel_only)\n-     enum tree_code form;\n-     tree name;\n-     struct cp_binding_level *binding_level;\n-     int thislevel_only;\n+lookup_tag (enum tree_code form,\n+            tree name,\n+            struct cp_binding_level* binding_level,\n+            int thislevel_only)\n {\n   register struct cp_binding_level *level;\n   /* Nonzero if, we should look past a template parameter level, even\n@@ -5391,15 +5283,6 @@ lookup_tag (form, name, binding_level, thislevel_only)\n   return NULL_TREE;\n }\n \n-#if 0\n-void\n-set_current_level_tags_transparency (tags_transparent)\n-     int tags_transparent;\n-{\n-  current_binding_level->tag_transparent = tags_transparent;\n-}\n-#endif\n-\n /* Given a type, find the tag that was defined for it and return the tag name.\n    Otherwise return 0.  However, the value can never be 0\n    in the cases in which this is used.\n@@ -5408,9 +5291,7 @@ set_current_level_tags_transparency (tags_transparent)\n    done when replacing anonymous tags with real tag names.  */\n \n static tree\n-lookup_tag_reverse (type, name)\n-     tree type;\n-     tree name;\n+lookup_tag_reverse (tree type, tree name)\n {\n   register struct cp_binding_level *level;\n \n@@ -5433,8 +5314,7 @@ lookup_tag_reverse (type, name)\n /* Look up NAME in the NAMESPACE.  */\n \n tree\n-lookup_namespace_name (namespace, name)\n-     tree namespace, name;\n+lookup_namespace_name (tree namespace, tree name)\n {\n   tree val;\n   tree template_id = NULL_TREE;\n@@ -5513,8 +5393,7 @@ lookup_namespace_name (namespace, name)\n /* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */\n \n static hashval_t\n-typename_hash (k)\n-     const void * k;\n+typename_hash (const void* k)\n {\n   hashval_t hash;\n   tree t = (tree) k;\n@@ -5528,9 +5407,7 @@ typename_hash (k)\n /* Compare two TYPENAME_TYPEs.  K1 and K2 are really of type `tree'.  */\n \n static int\n-typename_compare (k1, k2)\n-     const void * k1;\n-     const void * k2;\n+typename_compare (const void * k1, const void * k2)\n {\n   tree t1;\n   tree t2;\n@@ -5561,11 +5438,7 @@ typename_compare (k1, k2)\n static GTY ((param_is (union tree_node))) htab_t typename_htab;\n \n tree\n-build_typename_type (context, name, fullname, base_type)\n-     tree context;\n-     tree name;\n-     tree fullname;\n-     tree base_type;\n+build_typename_type (tree context, tree name, tree fullname, tree base_type)\n {\n   tree t;\n   tree d;\n@@ -5608,9 +5481,7 @@ build_typename_type (context, name, fullname, base_type)\n    complain about errors, otherwise be quiet.  */\n \n tree\n-make_typename_type (context, name, complain)\n-     tree context, name;\n-     tsubst_flags_t complain;\n+make_typename_type (tree context, tree name, tsubst_flags_t complain)\n {\n   tree fullname;\n \n@@ -5751,9 +5622,7 @@ make_typename_type (context, name, complain)\n    that occur.  */\n \n tree\n-make_unbound_class_template (context, name, complain)\n-     tree context, name;\n-     tsubst_flags_t complain;\n+make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n {\n   tree t;\n   tree d;\n@@ -5809,9 +5678,7 @@ make_unbound_class_template (context, name, complain)\n /* Select the right _DECL from multiple choices.  */\n \n static tree\n-select_decl (binding, flags)\n-     tree binding;\n-     int flags;\n+select_decl (tree binding, int flags)\n {\n   tree val;\n   val = BINDING_VALUE (binding);\n@@ -5844,10 +5711,7 @@ select_decl (binding, flags)\n    of the namespaces we've considered in it.  */\n \n tree\n-unqualified_namespace_lookup (name, flags, spacesp)\n-     tree name;\n-     int flags;\n-     tree *spacesp;\n+unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n {\n   tree b = make_node (CPLUS_BINDING);\n   tree initial = current_decl_namespace ();\n@@ -5913,8 +5777,7 @@ unqualified_namespace_lookup (name, flags, spacesp)\n /* Combine prefer_type and namespaces_only into flags.  */\n \n static int\n-lookup_flags (prefer_type, namespaces_only)\n-  int prefer_type, namespaces_only;\n+lookup_flags (int prefer_type, int namespaces_only)\n {\n   if (namespaces_only)\n     return LOOKUP_PREFER_NAMESPACES;\n@@ -5929,9 +5792,7 @@ lookup_flags (prefer_type, namespaces_only)\n    ignore it or not.  Subroutine of lookup_name_real.  */\n \n static tree\n-qualify_lookup (val, flags)\n-     tree val;\n-     int flags;\n+qualify_lookup (tree val, int flags)\n {\n   if (val == NULL_TREE)\n     return val;\n@@ -5948,9 +5809,7 @@ qualify_lookup (val, flags)\n    that.  */\n \n static void\n-warn_about_implicit_typename_lookup (typename, binding)\n-     tree typename;\n-     tree binding;\n+warn_about_implicit_typename_lookup (tree typename, tree binding)\n {\n   tree subtype = TREE_TYPE (TREE_TYPE (typename));\n   tree name = DECL_NAME (typename);\n@@ -6168,24 +6027,19 @@ lookup_name_real (tree name,\n }\n \n tree\n-lookup_name_nonclass (name)\n-     tree name;\n+lookup_name_nonclass (tree name)\n {\n   return lookup_name_real (name, 0, 1, 0, LOOKUP_COMPLAIN);\n }\n \n tree\n-lookup_function_nonclass (name, args)\n-     tree name;\n-     tree args;\n+lookup_function_nonclass (tree name, tree args)\n {\n   return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n }\n \n tree\n-lookup_name (name, prefer_type)\n-     tree name;\n-     int prefer_type;\n+lookup_name (tree name, int prefer_type)\n {\n   return lookup_name_real (name, prefer_type, 0, 0, LOOKUP_COMPLAIN);\n }\n@@ -6194,8 +6048,7 @@ lookup_name (name, prefer_type)\n    binding level.  */\n \n tree\n-lookup_name_current_level (name)\n-     tree name;\n+lookup_name_current_level (tree name)\n {\n   struct cp_binding_level *b;\n   tree t = NULL_TREE;\n@@ -6233,8 +6086,7 @@ lookup_name_current_level (name)\n /* Like lookup_name_current_level, but for types.  */\n \n tree\n-lookup_type_current_level (name)\n-     tree name;\n+lookup_type_current_level (tree name)\n {\n   register tree t = NULL_TREE;\n \n@@ -6265,10 +6117,9 @@ lookup_type_current_level (name)\n    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */\n \n void\n-record_builtin_type (rid_index, name, type)\n-     enum rid rid_index;\n-     const char *name;\n-     tree type;\n+record_builtin_type (enum rid rid_index, \n+                     const char* name, \n+                     tree type)\n {\n   tree rname = NULL_TREE, tname = NULL_TREE;\n   tree tdecl = NULL_TREE;\n@@ -6309,9 +6160,7 @@ record_builtin_type (rid_index, name, type)\n  * otherwise it is the negative of the size of one of the other types.  */\n \n static tree\n-record_builtin_java_type (name, size)\n-     const char *name;\n-     int size;\n+record_builtin_java_type (const char* name, int size)\n {\n   tree type, decl;\n   if (size > 0)\n@@ -6342,9 +6191,7 @@ record_builtin_java_type (name, size)\n /* Push a type into the namespace so that the back-ends ignore it.  */\n \n static void\n-record_unknown_type (type, name)\n-     tree type;\n-     const char *name;\n+record_unknown_type (tree type, const char* name)\n {\n   tree decl = pushdecl (build_decl (TYPE_DECL, get_identifier (name), type));\n   /* Make sure the \"unknown type\" typedecl gets ignored for debug info.  */\n@@ -6372,7 +6219,7 @@ typedef struct predefined_identifier\n /* Create all the predefined identifiers.  */\n \n static void\n-initialize_predefined_identifiers ()\n+initialize_predefined_identifiers (void)\n {\n   const predefined_identifier *pid;\n \n@@ -6413,7 +6260,7 @@ initialize_predefined_identifiers ()\n    Make definitions for built-in primitive functions.  */\n \n void\n-cxx_init_decl_processing ()\n+cxx_init_decl_processing (void)\n {\n   tree void_ftype;\n   tree void_ftype_ptr;\n@@ -6621,8 +6468,7 @@ cxx_init_decl_processing ()\n    ERROR_MARK node which should be replaced later.  */\n \n tree\n-cp_fname_init (name)\n-     const char *name;\n+cp_fname_init (const char* name)\n {\n   tree domain = NULL_TREE;\n   tree type;\n@@ -6656,9 +6502,7 @@ cp_fname_init (name)\n    lazily at the point of first use, so we musn't push the decl now.  */\n \n static tree\n-cp_make_fname_decl (id, type_dep)\n-     tree id;\n-     int type_dep;\n+cp_make_fname_decl (tree id, int type_dep)\n {\n   const char *const name = (type_dep && processing_template_decl\n \t\t      ? NULL : fname_as_string (type_dep));\n@@ -6702,14 +6546,13 @@ cp_make_fname_decl (id, type_dep)\n    list.  */\n \n static tree\n-builtin_function_1 (name, type, context, code, class, libname, attrs)\n-     const char *name;\n-     tree type;\n-     tree context;\n-     int code;\n-     enum built_in_class class;\n-     const char *libname;\n-     tree attrs;\n+builtin_function_1 (const char* name,\n+                    tree type,\n+                    tree context,\n+                    int code,\n+                    enum built_in_class class,\n+                    const char* libname,\n+                    tree attrs)\n {\n   tree decl = build_library_fn_1 (get_identifier (name), ERROR_MARK, type);\n   DECL_BUILT_IN_CLASS (decl) = class;\n@@ -6756,13 +6599,12 @@ builtin_function_1 (name, type, context, code, class, libname, attrs)\n    list.  */\n \n tree\n-builtin_function (name, type, code, class, libname, attrs)\n-     const char *name;\n-     tree type;\n-     int code;\n-     enum built_in_class class;\n-     const char *libname;\n-     tree attrs;\n+builtin_function (const char* name,\n+                  tree type,\n+                  int code,\n+                  enum built_in_class class,\n+                  const char* libname,\n+                  tree attrs)\n {\n   /* All builtins that don't begin with an '_' should additionally\n      go in the 'std' namespace.  */\n@@ -6781,10 +6623,7 @@ builtin_function (name, type, code, class, libname, attrs)\n    function.  Not called directly.  */\n \n static tree\n-build_library_fn_1 (name, operator_code, type)\n-     tree name;\n-     enum tree_code operator_code;\n-     tree type;\n+build_library_fn_1 (tree name, enum tree_code operator_code, tree type)\n {\n   tree fn = build_lang_decl (FUNCTION_DECL, name, type);\n   DECL_EXTERNAL (fn) = 1;\n@@ -6801,20 +6640,15 @@ build_library_fn_1 (name, operator_code, type)\n    callers should unset TREE_NOTHROW.  */\n \n tree\n-build_library_fn (name, type)\n-     tree name;\n-     tree type;\n+build_library_fn (tree name, tree type)\n {\n   return build_library_fn_1 (name, ERROR_MARK, type);\n }\n \n /* Returns the _DECL for a library function with C++ linkage.  */\n \n static tree\n-build_cp_library_fn (name, operator_code, type)\n-     tree name;\n-     enum tree_code operator_code;\n-     tree type;\n+build_cp_library_fn (tree name, enum tree_code operator_code, tree type)\n {\n   tree fn = build_library_fn_1 (name, operator_code, type);\n   TREE_NOTHROW (fn) = TYPE_NOTHROW_P (type);\n@@ -6828,9 +6662,7 @@ build_cp_library_fn (name, operator_code, type)\n    IDENTIFIER_NODE.  */\n \n tree\n-build_library_fn_ptr (name, type)\n-     const char *name;\n-     tree type;\n+build_library_fn_ptr (const char* name, tree type)\n {\n   return build_library_fn (get_identifier (name), type);\n }\n@@ -6839,9 +6671,7 @@ build_library_fn_ptr (name, type)\n    IDENTIFIER_NODE.  */\n \n tree\n-build_cp_library_fn_ptr (name, type)\n-     const char *name;\n-     tree type;\n+build_cp_library_fn_ptr (const char* name, tree type)\n {\n   return build_cp_library_fn (get_identifier (name), ERROR_MARK, type);\n }\n@@ -6850,8 +6680,7 @@ build_cp_library_fn_ptr (name, type)\n    be able to find it via IDENTIFIER_GLOBAL_VALUE.  */\n \n tree\n-push_library_fn (name, type)\n-     tree name, type;\n+push_library_fn (tree name, tree type)\n {\n   tree fn = build_library_fn (name, type);\n   pushdecl_top_level (fn);\n@@ -6862,9 +6691,7 @@ push_library_fn (name, type)\n    will be found by normal lookup.  */\n \n static tree\n-push_cp_library_fn (operator_code, type)\n-     enum tree_code operator_code;\n-     tree type;\n+push_cp_library_fn (enum tree_code operator_code, tree type)\n {\n   tree fn = build_cp_library_fn (ansi_opname (operator_code),\n \t\t\t\t operator_code,\n@@ -6877,8 +6704,7 @@ push_cp_library_fn (operator_code, type)\n    a FUNCTION_TYPE.  */\n \n tree\n-push_void_library_fn (name, parmtypes)\n-     tree name, parmtypes;\n+push_void_library_fn (tree name, tree parmtypes)\n {\n   tree type = build_function_type (void_type_node, parmtypes);\n   return push_library_fn (name, type);\n@@ -6888,8 +6714,7 @@ push_void_library_fn (name, parmtypes)\n    and does not return.  Used for __throw_foo and the like.  */\n \n tree\n-push_throw_library_fn (name, type)\n-     tree name, type;\n+push_throw_library_fn (tree name, tree type)\n {\n   tree fn = push_library_fn (name, type);\n   TREE_THIS_VOLATILE (fn) = 1;\n@@ -6901,8 +6726,7 @@ push_throw_library_fn (name, type)\n    attributes.  */\n \n void\n-cxx_insert_default_attributes (decl)\n-     tree decl;\n+cxx_insert_default_attributes (tree decl)\n {\n   if (!DECL_EXTERN_C_FUNCTION_P (decl))\n     return;\n@@ -6922,8 +6746,7 @@ cxx_insert_default_attributes (decl)\n    union type.)  */\n \n void\n-fixup_anonymous_aggr (t)\n-     tree t;\n+fixup_anonymous_aggr (tree t)\n {\n   tree *q;\n \n@@ -6984,8 +6807,7 @@ fixup_anonymous_aggr (t)\n    Returns the type declared; or NULL_TREE if none.  */\n \n tree\n-check_tag_decl (declspecs)\n-     tree declspecs;\n+check_tag_decl (tree declspecs)\n {\n   int found_type = 0;\n   int saw_friend = 0;\n@@ -7121,8 +6943,7 @@ check_tag_decl (declspecs)\n    Returns the TYPE declared -- or NULL_TREE if none.  */\n \n tree\n-shadow_tag (declspecs)\n-     tree declspecs;\n+shadow_tag (tree declspecs)\n {\n   tree t = check_tag_decl (declspecs);\n \n@@ -7154,8 +6975,7 @@ shadow_tag (declspecs)\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n-groktypename (typename)\n-     tree typename;\n+groktypename (tree typename)\n {\n   tree specs, attrs;\n   tree type;\n@@ -7185,20 +7005,16 @@ groktypename (typename)\n    grokfield and not through here.  */\n \n tree\n-start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n-     tree declarator, declspecs;\n-     int initialized;\n-     tree attributes, prefix_attributes;\n+start_decl (tree declarator, \n+            tree declspecs, \n+            int initialized, \n+            tree attributes, \n+            tree prefix_attributes)\n {\n   tree decl;\n   register tree type, tem;\n   tree context;\n \n-#if 0\n-  /* See code below that used this.  */\n-  int init_written = initialized;\n-#endif\n-\n   /* This should only be done once on the top most decl.  */\n   if (have_extern_spec)\n     {\n@@ -7371,8 +7187,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n }\n \n void\n-start_decl_1 (decl)\n-     tree decl;\n+start_decl_1 (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n   int initialized = (DECL_INITIAL (decl) != NULL_TREE);\n@@ -7446,8 +7261,7 @@ start_decl_1 (decl)\n    Quotes on semantics can be found in ARM 8.4.3.  */\n \n static tree\n-grok_reference_init (decl, type, init)\n-     tree decl, type, init;\n+grok_reference_init (tree decl, tree type, tree init)\n {\n   tree tmp;\n \n@@ -7512,9 +7326,7 @@ grok_reference_init (decl, type, init)\n    situation we're in, update DECL accordingly.  */\n \n static void\n-maybe_deduce_size_from_array_init (decl, init)\n-     tree decl;\n-     tree init;\n+maybe_deduce_size_from_array_init (tree decl, tree init)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -7556,8 +7368,7 @@ maybe_deduce_size_from_array_init (decl, init)\n    any appropriate error messages regarding the layout.  */\n \n static void\n-layout_var_decl (decl)\n-     tree decl;\n+layout_var_decl (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n #if 0\n@@ -7621,8 +7432,7 @@ layout_var_decl (decl)\n    instance of the variable at link-time.  */\n \n static void\n-maybe_commonize_var (decl)\n-     tree decl;\n+maybe_commonize_var (tree decl)\n {\n   /* Static data in a function with comdat linkage also has comdat\n      linkage.  */\n@@ -7673,8 +7483,7 @@ maybe_commonize_var (decl)\n /* Issue an error message if DECL is an uninitialized const variable.  */\n \n static void\n-check_for_uninitialized_const_var (decl)\n-     tree decl;\n+check_for_uninitialized_const_var (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -8054,10 +7863,7 @@ check_initializer (tree decl, tree init, int flags)\n /* If DECL is not a local variable, give it RTL.  */\n \n static void\n-make_rtl_for_nonlocal_decl (decl, init, asmspec)\n-     tree decl;\n-     tree init;\n-     const char *asmspec;\n+make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n {\n   int toplev = toplevel_bindings_p ();\n   int defer_p;\n@@ -8142,8 +7948,7 @@ make_rtl_for_nonlocal_decl (decl, init, asmspec)\n    declaration into the surrounding scope.  */\n \n void\n-maybe_inject_for_scope_var (decl)\n-     tree decl;\n+maybe_inject_for_scope_var (tree decl)\n {\n   if (!DECL_NAME (decl))\n     return;\n@@ -8186,9 +7991,7 @@ maybe_inject_for_scope_var (decl)\n /* Generate code to initialize DECL (a local variable).  */\n \n static void\n-initialize_local_var (decl, init)\n-     tree decl;\n-     tree init;\n+initialize_local_var (tree decl, tree init)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -8265,10 +8068,7 @@ initialize_local_var (decl, init)\n    if the (init) syntax was used.  */\n \n void\n-cp_finish_decl (decl, init, asmspec_tree, flags)\n-     tree decl, init;\n-     tree asmspec_tree;\n-     int flags;\n+cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n {\n   register tree type;\n   tree ttype = NULL_TREE;\n@@ -8525,9 +8325,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n /* This is here for a midend callback from c-common.c */\n \n void\n-finish_decl (decl, init, asmspec_tree)\n-     tree decl, init;\n-     tree asmspec_tree;\n+finish_decl (tree decl, tree init, tree asmspec_tree)\n {\n   cp_finish_decl (decl, init, asmspec_tree, 0);\n }\n@@ -8540,9 +8338,7 @@ finish_decl (decl, init, asmspec_tree)\n    variables.  */\n \n tree\n-declare_global_var (name, type)\n-     tree name;\n-     tree type;\n+declare_global_var (tree name, tree type)\n {\n   tree decl;\n \n@@ -8563,7 +8359,7 @@ declare_global_var (name, type)\n    `__cxa_atexit' function specified in the IA64 C++ ABI.  */\n \n static tree\n-get_atexit_node ()\n+get_atexit_node (void)\n {\n   tree atexit_fndecl;\n   tree arg_types;\n@@ -8626,7 +8422,7 @@ get_atexit_node ()\n /* Returns the __dso_handle VAR_DECL.  */\n \n static tree\n-get_dso_handle_node ()\n+get_dso_handle_node (void)\n {\n   if (dso_handle_node)\n     return dso_handle_node;\n@@ -8642,7 +8438,7 @@ get_dso_handle_node ()\n    to destroy some particular variable.  */\n \n static tree\n-start_cleanup_fn ()\n+start_cleanup_fn (void)\n {\n   static int counter = 0;\n   int old_interface_only = interface_only;\n@@ -8708,7 +8504,7 @@ start_cleanup_fn ()\n /* Finish the cleanup function begun by start_cleanup_fn.  */\n \n static void\n-end_cleanup_fn ()\n+end_cleanup_fn (void)\n {\n   expand_body (finish_function (0));\n \n@@ -8719,8 +8515,7 @@ end_cleanup_fn ()\n    static storage duration.  */\n \n void\n-register_dtor_fn (decl)\n-     tree decl;\n+register_dtor_fn (tree decl)\n {\n   tree cleanup;\n   tree compound_stmt;\n@@ -8775,9 +8570,7 @@ register_dtor_fn (decl)\n    and destruction of DECL.  */\n \n static void\n-expand_static_init (decl, init)\n-     tree decl;\n-     tree init;\n+expand_static_init (tree decl, tree init)\n {\n   tree oldstatic;\n \n@@ -8877,9 +8670,7 @@ expand_static_init (decl, init)\n /* Finish the declaration of a catch-parameter.  */\n \n tree\n-start_handler_parms (declspecs, declarator)\n-     tree declspecs;\n-     tree declarator;\n+start_handler_parms (tree declspecs, tree declarator)\n {\n   tree decl;\n   if (declspecs)\n@@ -8901,9 +8692,7 @@ start_handler_parms (declspecs, declarator)\n    2 if there was no information (in which case assume 0 if DO_DEFAULT).  */\n \n int\n-complete_array_type (type, initial_value, do_default)\n-     tree type, initial_value;\n-     int do_default;\n+complete_array_type (tree type, tree initial_value, int do_default)\n {\n   register tree maxindex = NULL_TREE;\n   int value = 0;\n@@ -8998,9 +8787,7 @@ complete_array_type (type, initial_value, do_default)\n    message to print in that case.  Otherwise, quietly return 1.  */\n \n static int\n-member_function_or_else (ctype, cur_type, flags)\n-     tree ctype, cur_type;\n-     enum overload_flags flags;\n+member_function_or_else (tree ctype, tree cur_type, enum overload_flags flags)\n {\n   if (ctype && ctype != cur_type)\n     {\n@@ -9021,10 +8808,13 @@ member_function_or_else (ctype, cur_type, flags)\n    This is for ARM $7.1.2.  */\n \n static void\n-bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n-     tree object;\n-     const char *type;\n-     int virtualp, quals, friendp, raises, inlinep;\n+bad_specifiers (tree object,\n+                const char* type,\n+                int virtualp,\n+                int quals,\n+                int friendp,\n+                int raises,\n+                int inlinep)\n {\n   if (virtualp)\n     error (\"`%D' declared as a `virtual' %s\", object, type);\n@@ -9059,17 +8849,21 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    applicable error messages.  */\n \n static tree\n-grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n-\t    raises, check, friendp, publicp, inlinep, funcdef_flag,\n-\t    template_count, in_namespace)\n-     tree ctype, type;\n-     tree declarator;\n-     tree orig_declarator;\n-     int virtualp;\n-     enum overload_flags flags;\n-     tree quals, raises;\n-     int check, friendp, publicp, inlinep, funcdef_flag, template_count;\n-     tree in_namespace;\n+grokfndecl (tree ctype, \n+            tree type,\n+            tree declarator,\n+            tree orig_declarator,\n+            int virtualp,\n+            enum overload_flags flags,\n+            tree quals, \n+            tree raises,\n+            int check, \n+            int friendp, \n+            int publicp, \n+            int inlinep, \n+            int funcdef_flag, \n+            int template_count,\n+            tree in_namespace)\n {\n   tree decl;\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n@@ -9347,13 +9141,12 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n    the innermost enclosings scope.  */\n \n static tree\n-grokvardecl (type, name, specbits_in, initialized, constp, scope)\n-     tree type;\n-     tree name;\n-     RID_BIT_TYPE *specbits_in;\n-     int initialized;\n-     int constp;\n-     tree scope;\n+grokvardecl (tree type,\n+             tree name,\n+             RID_BIT_TYPE * specbits_in,\n+             int initialized,\n+             int constp,\n+             tree scope)\n {\n   tree decl;\n   RID_BIT_TYPE specbits;\n@@ -9467,8 +9260,7 @@ grokvardecl (type, name, specbits_in, initialized, constp, scope)\n    TYPE, which is a POINTER_TYPE to a METHOD_TYPE.  */\n \n tree\n-build_ptrmemfunc_type (type)\n-     tree type;\n+build_ptrmemfunc_type (tree type)\n {\n   tree field, fields;\n   tree t;\n@@ -9545,9 +9337,7 @@ build_ptrmem_type (tree class_type, tree member_type)\n    otherwise.  */\n \n int\n-check_static_variable_definition (decl, type)\n-     tree decl;\n-     tree type;\n+check_static_variable_definition (tree decl, tree type)\n {\n   /* Motion 10 at San Diego: If a static const integral data member is\n      initialized with an integral constant expression, the initializer\n@@ -9579,9 +9369,7 @@ check_static_variable_definition (decl, type)\n    name of the thing being declared.  */\n \n tree\n-compute_array_index_type (name, size)\n-     tree name;\n-     tree size;\n+compute_array_index_type (tree name, tree size)\n {\n   tree itype;\n \n@@ -9709,8 +9497,7 @@ compute_array_index_type (name, size)\n    unqualified name, NULL_TREE is returned.  */\n \n tree\n-get_scope_of_declarator (declarator)\n-     tree declarator;\n+get_scope_of_declarator (tree declarator)\n {\n   if (!declarator)\n     return NULL_TREE;\n@@ -9751,10 +9538,7 @@ get_scope_of_declarator (declarator)\n    with this type.  */\n \n static tree\n-create_array_type_for_decl (name, type, size)\n-     tree name;\n-     tree type;\n-     tree size;\n+create_array_type_for_decl (tree name, tree type, tree size)\n {\n   tree itype = NULL_TREE;\n   const char* error_msg;\n@@ -9834,10 +9618,9 @@ create_array_type_for_decl (name, type, size)\n    special functions.  */\n \n static tree\n-check_special_function_return_type (sfk, type, optype)\n-     special_function_kind sfk;\n-     tree type;\n-     tree optype;\n+check_special_function_return_type (special_function_kind sfk,\n+                                    tree type,\n+                                    tree optype)\n {\n   switch (sfk)\n     {\n@@ -9910,12 +9693,11 @@ check_special_function_return_type (sfk, type, optype)\n    should not be `S'.  */\n \n tree\n-grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n-     tree declspecs;\n-     tree declarator;\n-     enum decl_context decl_context;\n-     int initialized;\n-     tree *attrlist;\n+grokdeclarator (tree declarator,\n+                tree declspecs,\n+                enum decl_context decl_context,\n+                int initialized,\n+                tree* attrlist)\n {\n   RID_BIT_TYPE specbits;\n   int nclasses = 0;\n@@ -12129,8 +11911,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n    is a parmlist.  Otherwise, it is an exprlist.  */\n \n int\n-parmlist_is_exprlist (exprs)\n-     tree exprs;\n+parmlist_is_exprlist (tree exprs)\n {\n   if (exprs == NULL_TREE || TREE_PARMLIST (exprs))\n     return 0;\n@@ -12155,8 +11936,7 @@ parmlist_is_exprlist (exprs)\n    function definition.  */\n \n static void\n-require_complete_types_for_parms (parms)\n-     tree parms;\n+require_complete_types_for_parms (tree parms)\n {\n   for (; parms; parms = TREE_CHAIN (parms))\n     {\n@@ -12173,8 +11953,7 @@ require_complete_types_for_parms (parms)\n /* Returns nonzero if T is a local variable.  */\n \n int\n-local_variable_p (t)\n-     tree t;\n+local_variable_p (tree t)\n {\n   if ((TREE_CODE (t) == VAR_DECL\n        /* A VAR_DECL with a context that is a _TYPE is a static data\n@@ -12193,8 +11972,7 @@ local_variable_p (t)\n    containing them is duplicated.)  */\n \n int\n-nonstatic_local_decl_p (t)\n-     tree t;\n+nonstatic_local_decl_p (tree t)\n {\n   return ((local_variable_p (t) && !TREE_STATIC (t))\n \t  || TREE_CODE (t) == LABEL_DECL\n@@ -12205,10 +11983,9 @@ nonstatic_local_decl_p (t)\n    function.  */\n \n static tree\n-local_variable_p_walkfn (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+local_variable_p_walkfn (tree* tp,\n+                         int* walk_subtrees ATTRIBUTE_UNUSED ,\n+                         void* data ATTRIBUTE_UNUSED )\n {\n   return ((local_variable_p (*tp) && !DECL_ARTIFICIAL (*tp))\n \t  ? *tp : NULL_TREE);\n@@ -12220,9 +11997,7 @@ local_variable_p_walkfn (tp, walk_subtrees, data)\n    DECL, if there is no DECL available.  */\n \n tree\n-check_default_argument (decl, arg)\n-     tree decl;\n-     tree arg;\n+check_default_argument (tree decl, tree arg)\n {\n   tree var;\n   tree decl_type;\n@@ -12304,8 +12079,7 @@ check_default_argument (decl, arg)\n    Also set last_function_parms to the chain of PARM_DECLs.  */\n \n static tree\n-grokparms (first_parm)\n-     tree first_parm;\n+grokparms (tree first_parm)\n {\n   tree result = NULL_TREE;\n   tree decls = NULL_TREE;\n@@ -12442,8 +12216,7 @@ grokparms (first_parm)\n    operator.  */\n \n int\n-copy_fn_p (d)\n-     tree d;\n+copy_fn_p (tree d)\n {\n   tree args;\n   tree arg_type;\n@@ -12489,8 +12262,7 @@ copy_fn_p (d)\n \n /* Remember any special properties of member function DECL.  */\n \n-void grok_special_member_properties (decl)\n-     tree decl;\n+void grok_special_member_properties (tree decl)\n {\n   if (!DECL_NONSTATIC_MEMBER_FUNCTION_P(decl))\n     ; /* Not special.  */\n@@ -12539,8 +12311,7 @@ void grok_special_member_properties (decl)\n    if the class has a constructor of the form X(X).  */\n \n int\n-grok_ctor_properties (ctype, decl)\n-     tree ctype, decl;\n+grok_ctor_properties (tree ctype, tree decl)\n {\n   int ctor_parm = copy_fn_p (decl);\n \n@@ -12573,8 +12344,7 @@ grok_ctor_properties (ctype, decl)\n /* An operator with this code is unary, but can also be binary.  */\n \n static int\n-ambi_op_p (code)\n-     enum tree_code code;\n+ambi_op_p (enum tree_code code)\n {\n   return (code == INDIRECT_REF\n \t  || code == ADDR_EXPR\n@@ -12587,8 +12357,7 @@ ambi_op_p (code)\n /* An operator with this name can only be unary.  */\n \n static int\n-unary_op_p (code)\n-     enum tree_code code;\n+unary_op_p (enum tree_code code)\n {\n   return (code == TRUTH_NOT_EXPR\n \t  || code == BIT_NOT_EXPR\n@@ -12599,9 +12368,7 @@ unary_op_p (code)\n /* Do a little sanity-checking on how they declared their operator.  */\n \n void\n-grok_op_properties (decl, friendp)\n-     tree decl;\n-     int friendp;\n+grok_op_properties (tree decl, int friendp)\n {\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   tree argtype;\n@@ -12929,8 +12696,7 @@ grok_op_properties (decl, friendp)\n }\n \f\n static const char *\n-tag_name (code)\n-     enum tag_types code;\n+tag_name (enum tag_types code)\n {\n   switch (code)\n     {\n@@ -13172,9 +12938,7 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n }\n \n tree\n-xref_tag_from_type (old, id, globalize)\n-     tree old, id;\n-     int globalize;\n+xref_tag_from_type (tree old, tree id, int globalize)\n {\n   enum tag_types tag_kind;\n \n@@ -13196,9 +12960,7 @@ xref_tag_from_type (old, id, globalize)\n    struct, or union.  */\n \n void\n-xref_basetypes (ref, binfo)\n-     tree ref;\n-     tree binfo;\n+xref_basetypes (tree ref, tree binfo)\n {\n   /* In the declaration `A : X, Y, ... Z' we mark all the types\n      (A, X, Y, ..., Z) so we can check for duplicates.  */\n@@ -13372,8 +13134,7 @@ xref_basetypes (ref, binfo)\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (name)\n-     tree name;\n+start_enum (tree name)\n {\n   register tree enumtype = NULL_TREE;\n   struct cp_binding_level *b = current_binding_level;\n@@ -13406,8 +13167,7 @@ start_enum (name)\n    ENUMTYPE is the type object and VALUES a list of name-value pairs.  */\n \n void\n-finish_enum (enumtype)\n-     tree enumtype;\n+finish_enum (tree enumtype)\n {\n   tree pair;\n   tree minnode;\n@@ -13528,10 +13288,7 @@ finish_enum (enumtype)\n    Assignment of sequential values by default is handled here.  */\n \n void\n-build_enumerator (name, value, enumtype)\n-     tree name;\n-     tree value;\n-     tree enumtype;\n+build_enumerator (tree name, tree value, tree enumtype)\n {\n   tree decl;\n   tree context;\n@@ -13650,9 +13407,7 @@ build_enumerator (name, value, enumtype)\n /* We're defining DECL.  Make sure that it's type is OK.  */\n \n static void\n-check_function_type (decl, current_function_parms)\n-     tree decl;\n-     tree current_function_parms;\n+check_function_type (tree decl, tree current_function_parms)\n {\n   tree fntype = TREE_TYPE (decl);\n   tree return_type = complete_type (TREE_TYPE (fntype));\n@@ -13709,9 +13464,7 @@ check_function_type (decl, current_function_parms)\n    applied to it with the argument list [1, 2].  */\n \n int\n-start_function (declspecs, declarator, attrs, flags)\n-     tree declspecs, declarator, attrs;\n-     int flags;\n+start_function (tree declspecs, tree declarator, tree attrs, int flags)\n {\n   tree decl1;\n   tree ctype = NULL_TREE;\n@@ -14071,8 +13824,7 @@ start_function (declspecs, declarator, attrs, flags)\n    Also install to binding contour return value identifier, if any.  */\n \n static void\n-store_parm_decls (current_function_parms)\n-     tree current_function_parms;\n+store_parm_decls (tree current_function_parms)\n {\n   register tree fndecl = current_function_decl;\n   register tree parm;\n@@ -14149,8 +13901,7 @@ store_parm_decls (current_function_parms)\n    when we want to generate RTL later we know what to do.  */\n \n static void\n-save_function_data (decl)\n-     tree decl;\n+save_function_data (tree decl)\n {\n   struct language_function *f;\n \n@@ -14190,7 +13941,7 @@ save_function_data (decl)\n    fully-constructed bases and members.  */\n \n static void\n-begin_constructor_body ()\n+begin_constructor_body (void)\n {\n }\n \n@@ -14199,15 +13950,15 @@ begin_constructor_body ()\n    members.  */\n \n static void\n-finish_constructor_body ()\n+finish_constructor_body (void)\n {\n }\n \n /* Do all the processing for the beginning of a destructor; set up the\n    vtable pointers and cleanups for bases and members.  */\n \n static void\n-begin_destructor_body ()\n+begin_destructor_body (void)\n {\n   tree if_stmt;\n   tree compound_stmt;\n@@ -14254,7 +14005,7 @@ begin_destructor_body ()\n    necessary.  Do that now.  */\n \n static void\n-finish_destructor_body ()\n+finish_destructor_body (void)\n {\n   tree exprstmt;\n \n@@ -14296,7 +14047,7 @@ finish_destructor_body ()\n    In other functions, this isn't necessary, but it doesn't hurt.  */\n \n tree\n-begin_function_body ()\n+begin_function_body (void)\n {\n   tree stmt;\n \n@@ -14331,8 +14082,7 @@ begin_function_body ()\n    main() would also need to return 0.  */\n \n void\n-finish_function_body (compstmt)\n-     tree compstmt;\n+finish_function_body (tree compstmt)\n {\n   /* Close the block.  */\n   finish_compound_stmt (0, compstmt);\n@@ -14356,8 +14106,7 @@ finish_function_body (compstmt)\n        after the class definition is complete.)  */\n \n tree\n-finish_function (flags)\n-     int flags;\n+finish_function (int flags)\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n@@ -14555,8 +14304,7 @@ finish_function (flags)\n    CHANGES TO CODE IN `grokfield'.  */\n \n tree\n-start_method (declspecs, declarator, attrlist)\n-     tree declarator, declspecs, attrlist;\n+start_method (tree declspecs, tree declarator, tree attrlist)\n {\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n \t\t\t\t&attrlist);\n@@ -14633,8 +14381,7 @@ start_method (declspecs, declarator, attrlist)\n    DECL is the ..._DECL that `start_method' provided.  */\n \n tree\n-finish_method (decl)\n-     tree decl;\n+finish_method (tree decl)\n {\n   register tree fndecl = decl;\n   tree old_initial;\n@@ -14686,8 +14433,7 @@ finish_method (decl)\n    we can lay it out later, when and if its type becomes complete.  */\n \n void\n-maybe_register_incomplete_var (var)\n-     tree var;\n+maybe_register_incomplete_var (tree var)\n {\n   my_friendly_assert (TREE_CODE (var) == VAR_DECL, 20020406);\n \n@@ -14714,8 +14460,7 @@ maybe_register_incomplete_var (var)\n    declaration, update them now.  */\n \n void\n-complete_vars (type)\n-     tree type;\n+complete_vars (tree type)\n {\n   tree *list = &incomplete_vars;\n \n@@ -14740,8 +14485,7 @@ complete_vars (type)\n    here.  */\n \n tree\n-cxx_maybe_build_cleanup (decl)\n-     tree decl;\n+cxx_maybe_build_cleanup (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n \n@@ -14779,7 +14523,7 @@ cxx_maybe_build_cleanup (decl)\n /* When a stmt has been parsed, this function is called.  */\n \n void\n-finish_stmt ()\n+finish_stmt (void)\n {\n   /* Always assume this statement was not an expression statement.  If\n      it actually was an expression statement, its our callers\n@@ -14791,8 +14535,7 @@ finish_stmt ()\n    but turned out to be static.  Update it accordingly.  */\n \n void\n-revert_static_member_fn (decl)\n-     tree decl;\n+revert_static_member_fn (tree decl)\n {\n   tree tmp;\n   tree function = TREE_TYPE (decl);\n@@ -14818,8 +14561,7 @@ revert_static_member_fn (decl)\n    function.  */\n \n void\n-cxx_push_function_context (f)\n-     struct function *f;\n+cxx_push_function_context (struct function * f)\n {\n   struct language_function *p\n     = ((struct language_function *)\n@@ -14839,8 +14581,7 @@ cxx_push_function_context (f)\n    compiling the function.  */\n \n void\n-cxx_pop_function_context (f)\n-     struct function *f;\n+cxx_pop_function_context (struct function * f)\n {\n   f->language = 0;\n }\n@@ -14849,8 +14590,7 @@ cxx_pop_function_context (f)\n    one of the language-independent trees.  */\n \n enum cp_tree_node_structure_enum\n-cp_tree_node_structure (t)\n-     union lang_tree_node *t;\n+cp_tree_node_structure (union lang_tree_node * t)\n {\n   switch (TREE_CODE (&t->generic))\n     {\n@@ -14870,24 +14610,22 @@ cp_tree_node_structure (t)\n    the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */\n \n tree\n-identifier_global_value\t(t)\n-     tree t;\n+identifier_global_value\t(tree t)\n {\n   return IDENTIFIER_GLOBAL_VALUE (t);\n }\n \n /* Build the void_list_node (void_type_node having been created).  */\n tree\n-build_void_list_node ()\n+build_void_list_node (void)\n {\n   tree t = build_tree_list (NULL_TREE, void_type_node);\n   TREE_PARMLIST (t) = 1;\n   return t;\n }\n \n static int\n-cp_missing_noreturn_ok_p (decl)\n-     tree decl;\n+cp_missing_noreturn_ok_p (tree decl)\n {\n   /* A missing noreturn is ok for the `main' function.  */\n   return DECL_MAIN_P (decl);"}]}