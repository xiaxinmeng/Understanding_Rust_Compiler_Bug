{"sha": "2f84b963e9556be5bc0219aec23941ea15b61596", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY4NGI5NjNlOTU1NmJlNWJjMDIxOWFlYzIzOTQxZWExNWI2MTU5Ng==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenth@gcc.gnu.org", "date": "2005-06-16T16:39:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-06-16T16:39:51Z"}, "message": "extend.texi: Document sseregparm target attribute.\n\n2005-06-16  Richard Guenther  <rguenth@gcc.gnu.org>\n\n\t* doc/extend.texi: Document sseregparm target attribute.\n\tClarify fastcall and regparm documentation.\n\t* config/i386/i386.h: Adjust float_in_sse documentation.\n\t* config/i386/i386.c: Add new target attribute sseregparm.\n\t(ix86_handle_cdecl_attribute, ix86_handle_regparm_attribute):\n\tMerge into ...\n\t(ix86_handle_cconv_attribute): ... here.  Also handle\n\tsseregparm attribute.\n\t(ix86_comp_type_attributes): Compare sseregparm attributes.\n\t(ix86_function_sseregparm): New function, split out from ...\n\t(init_cumulative_args): ... here.  Use to decide use\n\tof SSE registers and error in case of missing support.\n\t(ix86_value_regno): Likewise.\n\t(function_arg_advance): Do not bail out for DFmode if we need\n\tto pass doubles in registers.\n\t(function_arg): Likewise.\n\n\t* gcc.target/i386/attributes-error.c: New testcase.\n\t* gcc.target/i386/fastcall-sseregparm.c: Likewise.\n\t* gcc.target/i386/regparm-stdcall.c: Likewise.\n\t* gcc.target/i386/sseregparm-1.c: Likewise.\n\t* gcc.target/i386/sseregparm-2.c: Likewise.\n\nFrom-SVN: r101085", "tree": {"sha": "a3006dc02705766a9adcabb69887d2a2d4c2d6f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3006dc02705766a9adcabb69887d2a2d4c2d6f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f84b963e9556be5bc0219aec23941ea15b61596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f84b963e9556be5bc0219aec23941ea15b61596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f84b963e9556be5bc0219aec23941ea15b61596", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f84b963e9556be5bc0219aec23941ea15b61596/comments", "author": null, "committer": null, "parents": [{"sha": "9f18db39e6bdfba98347725bd8376365ac5817e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f18db39e6bdfba98347725bd8376365ac5817e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f18db39e6bdfba98347725bd8376365ac5817e9"}], "stats": {"total": 382, "additions": 279, "deletions": 103}, "files": [{"sha": "40e204c462cb7aac5b982b02c4263b7e54bd180a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -1,3 +1,22 @@\n+2005-06-16  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\t* doc/extend.texi: Document sseregparm target attribute.\n+\tClarify fastcall and regparm documentation.\n+\t* config/i386/i386.h: Adjust float_in_sse documentation.\n+\t* config/i386/i386.c: Add new target attribute sseregparm.\n+\t(ix86_handle_cdecl_attribute, ix86_handle_regparm_attribute):\n+\tMerge into ...\n+\t(ix86_handle_cconv_attribute): ... here.  Also handle\n+\tsseregparm attribute.\n+\t(ix86_comp_type_attributes): Compare sseregparm attributes.\n+\t(ix86_function_sseregparm): New function, split out from ...\n+\t(init_cumulative_args): ... here.  Use to decide use\n+\tof SSE registers and error in case of missing support.\n+\t(ix86_value_regno): Likewise.\n+\t(function_arg_advance): Do not bail out for DFmode if we need\n+\tto pass doubles in registers.\n+\t(function_arg): Likewise.\n+\n 2005-06-16  Paolo Bonzini  <bonzini@gnu.org>\n             Daniel Jacobowitz  <dan@codesourcery.com>\n \t    Alan Modra <amodra.bigpond.net.au>"}, {"sha": "781daee98d0452f915ffc822d9f290b5f3a20ab0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 148, "deletions": 95, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -890,8 +890,7 @@ static int ix86_comp_type_attributes (tree, tree);\n static int ix86_function_regparm (tree, tree);\n const struct attribute_spec ix86_attribute_table[];\n static bool ix86_function_ok_for_sibcall (tree, tree);\n-static tree ix86_handle_cdecl_attribute (tree *, tree, tree, int, bool *);\n-static tree ix86_handle_regparm_attribute (tree *, tree, tree, int, bool *);\n+static tree ix86_handle_cconv_attribute (tree *, tree, tree, int, bool *);\n static int ix86_value_regno (enum machine_mode, tree);\n static bool contains_128bit_aligned_vector_p (tree);\n static rtx ix86_struct_value_rtx (tree, int);\n@@ -1660,15 +1659,18 @@ const struct attribute_spec ix86_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   /* Stdcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n-  { \"stdcall\",   0, 0, false, true,  true,  ix86_handle_cdecl_attribute },\n+  { \"stdcall\",   0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n   /* Fastcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n-  { \"fastcall\",  0, 0, false, true,  true,  ix86_handle_cdecl_attribute },\n+  { \"fastcall\",  0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n   /* Cdecl attribute says the callee is a normal C declaration */\n-  { \"cdecl\",     0, 0, false, true,  true,  ix86_handle_cdecl_attribute },\n+  { \"cdecl\",     0, 0, false, true,  true,  ix86_handle_cconv_attribute },\n   /* Regparm attribute specifies how many integer arguments are to be\n      passed in registers.  */\n-  { \"regparm\",   1, 1, false, true,  true,  ix86_handle_regparm_attribute },\n+  { \"regparm\",   1, 1, false, true,  true,  ix86_handle_cconv_attribute },\n+  /* Sseregparm attribute says we are using x86_64 calling conventions\n+     for FP arguments.  */\n+  { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute },\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute },\n   { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute },\n@@ -1743,59 +1745,15 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n   return true;\n }\n \n-/* Handle a \"cdecl\", \"stdcall\", or \"fastcall\" attribute;\n+/* Handle \"cdecl\", \"stdcall\", \"fastcall\", \"regparm\" and \"sseregparm\"\n+   calling convention attributes;\n    arguments as in struct attribute_spec.handler.  */\n-static tree\n-ix86_handle_cdecl_attribute (tree *node, tree name,\n-\t\t\t     tree args ATTRIBUTE_UNUSED,\n-\t\t\t     int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FUNCTION_TYPE\n-      && TREE_CODE (*node) != METHOD_TYPE\n-      && TREE_CODE (*node) != FIELD_DECL\n-      && TREE_CODE (*node) != TYPE_DECL)\n-    {\n-      warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n-\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    {\n-      if (is_attribute_p (\"fastcall\", name))\n-        {\n-          if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (*node)))\n-            {\n-              error (\"fastcall and stdcall attributes are not compatible\");\n-            }\n-           else if (lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (*node)))\n-            {\n-              error (\"fastcall and regparm attributes are not compatible\");\n-            }\n-        }\n-      else if (is_attribute_p (\"stdcall\", name))\n-        {\n-          if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (*node)))\n-            {\n-              error (\"fastcall and stdcall attributes are not compatible\");\n-            }\n-        }\n-    }\n-\n-  if (TARGET_64BIT)\n-    {\n-      warning (OPT_Wattributes, \"%qs attribute ignored\",\n-\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n \n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"regparm\" attribute;\n-   arguments as in struct attribute_spec.handler.  */\n static tree\n-ix86_handle_regparm_attribute (tree *node, tree name, tree args,\n-\t\t\t       int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+ix86_handle_cconv_attribute (tree *node, tree name,\n+\t\t\t\t   tree args,\n+\t\t\t\t   int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t   bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_TYPE\n       && TREE_CODE (*node) != METHOD_TYPE\n@@ -1805,11 +1763,19 @@ ix86_handle_regparm_attribute (tree *node, tree name, tree args,\n       warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n \t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n-  else\n+\n+  /* Can combine regparm with all attributes but fastcall.  */\n+  if (is_attribute_p (\"regparm\", name))\n     {\n       tree cst;\n \n+      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"fastcall and regparm attributes are not compatible\");\n+\t}\n+\n       cst = TREE_VALUE (args);\n       if (TREE_CODE (cst) != INTEGER_CST)\n \t{\n@@ -1825,12 +1791,63 @@ ix86_handle_regparm_attribute (tree *node, tree name, tree args,\n \t  *no_add_attrs = true;\n \t}\n \n-      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (*node)))\n-\t{\n+      return NULL_TREE;\n+    }\n+\n+  if (TARGET_64BIT)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* Can combine fastcall with stdcall (redundant) and sseregparm.  */\n+  if (is_attribute_p (\"fastcall\", name))\n+    {\n+      if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"fastcall and cdecl attributes are not compatible\");\n+\t}\n+      if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"fastcall and stdcall attributes are not compatible\");\n+\t}\n+      if (lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (*node)))\n+        {\n \t  error (\"fastcall and regparm attributes are not compatible\");\n \t}\n     }\n \n+  /* Can combine stdcall with fastcall (redundant), regparm and\n+     sseregparm.  */\n+  else if (is_attribute_p (\"stdcall\", name))\n+    {\n+      if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"stdcall and cdecl attributes are not compatible\");\n+\t}\n+      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"stdcall and fastcall attributes are not compatible\");\n+\t}\n+    }\n+\n+  /* Can combine cdecl with regparm and sseregparm.  */\n+  else if (is_attribute_p (\"cdecl\", name))\n+    {\n+      if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"stdcall and cdecl attributes are not compatible\");\n+\t}\n+      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (*node)))\n+        {\n+\t  error (\"fastcall and cdecl attributes are not compatible\");\n+\t}\n+    }\n+\n+  /* Can combine sseregparm with all attributes.  */\n+\n   return NULL_TREE;\n }\n \n@@ -1847,18 +1864,23 @@ ix86_comp_type_attributes (tree type1, tree type2)\n   if (TREE_CODE (type1) != FUNCTION_TYPE)\n     return 1;\n \n-  /*  Check for mismatched fastcall types */\n-  if (!lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type1))\n-      != !lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type2)))\n+  /* Check for mismatched fastcall/regparm types.  */\n+  if ((!lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type1))\n+       != !lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type2)))\n+      || (ix86_function_regparm (type1, NULL)\n+\t  != ix86_function_regparm (type2, NULL)))\n+    return 0;\n+\n+  /* Check for mismatched sseregparm types.  */\n+  if (!lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type1))\n+      != !lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type2)))\n     return 0;\n \n   /* Check for mismatched return types (cdecl vs stdcall).  */\n   if (!lookup_attribute (rtdstr, TYPE_ATTRIBUTES (type1))\n       != !lookup_attribute (rtdstr, TYPE_ATTRIBUTES (type2)))\n     return 0;\n-  if (ix86_function_regparm (type1, NULL)\n-      != ix86_function_regparm (type2, NULL))\n-    return 0;\n+\n   return 1;\n }\n \f\n@@ -1907,6 +1929,47 @@ ix86_function_regparm (tree type, tree decl)\n   return regparm;\n }\n \n+/* Return 1 or 2, if we can pass up to 8 SFmode (1) and DFmode (2) arguments\n+   in SSE registers for a function with the indicated TYPE and DECL.\n+   DECL may be NULL when calling function indirectly\n+   or considering a libcall.  Otherwise return 0.  */\n+\n+static int\n+ix86_function_sseregparm (tree type, tree decl)\n+{\n+  /* Use SSE registers to pass SFmode and DFmode arguments if requested\n+     by the sseregparm attribute.  */\n+  if (type\n+      && lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type)))\n+    {\n+      if (!TARGET_SSE)\n+\t{\n+\t  if (decl)\n+\t    error (\"Calling %qD with attribute sseregparm without \"\n+\t\t   \"SSE/SSE2 enabled\", decl);\n+\t  else\n+\t    error (\"Calling %qT with attribute sseregparm without \"\n+\t\t   \"SSE/SSE2 enabled\", type);\n+\t  return 0;\n+\t}\n+\n+      return 2;\n+    }\n+\n+  /* For local functions, pass SFmode (and DFmode for SSE2) arguments\n+     in SSE registers even for 32-bit mode and not just 3, but up to\n+     8 SSE arguments in registers.  */\n+  if (!TARGET_64BIT && decl\n+      && TARGET_SSE_MATH && flag_unit_at_a_time && !profile_flag)\n+    {\n+      struct cgraph_local_info *i = cgraph_local_info (decl);\n+      if (i && i->local)\n+\treturn TARGET_SSE2 ? 2 : 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Return true if EAX is live at the start of the function.  Used by\n    ix86_expand_prologue to determine if we need special help before\n    calling allocate_stack_worker.  */\n@@ -2041,10 +2104,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n   *cum = zero_cum;\n \n   /* Set up the number of registers to use for passing arguments.  */\n-  if (fntype)\n-    cum->nregs = ix86_function_regparm (fntype, fndecl);\n-  else\n-    cum->nregs = ix86_regparm;\n+  cum->nregs = ix86_regparm;\n   if (TARGET_SSE)\n     cum->sse_nregs = SSE_REGPARM_MAX;\n   if (TARGET_MMX)\n@@ -2053,16 +2113,23 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n   cum->warn_mmx = true;\n   cum->maybe_vaarg = false;\n \n-  /* Use ecx and edx registers if function has fastcall attribute */\n+  /* Use ecx and edx registers if function has fastcall attribute,\n+     else look for regparm information.  */\n   if (fntype && !TARGET_64BIT)\n     {\n       if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (fntype)))\n \t{\n \t  cum->nregs = 2;\n \t  cum->fastcall = 1;\n \t}\n+      else\n+\tcum->nregs = ix86_function_regparm (fntype, fndecl);\n     }\n \n+  /* Set up the number of SSE registers used for passing SFmode\n+     and DFmode arguments.  Warn for mismatching ABI.  */\n+  cum->float_in_sse = ix86_function_sseregparm (fntype, fndecl);\n+\n   /* Determine if this function has variable arguments.  This is\n      indicated by the last argument being 'void_type_mode' if there\n      are no variable arguments.  If there are variable arguments, then\n@@ -2084,6 +2151,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t\t  cum->warn_sse = 0;\n \t\t  cum->warn_mmx = 0;\n \t\t  cum->fastcall = 0;\n+\t\t  cum->float_in_sse = 0;\n \t\t}\n \t      cum->maybe_vaarg = true;\n \t    }\n@@ -2093,21 +2161,6 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n       || (fntype && !TYPE_ARG_TYPES (fntype)))\n     cum->maybe_vaarg = true;\n \n-  /* For local functions, pass SFmode (and DFmode for SSE2) arguments\n-     in SSE registers even for 32-bit mode and not just 3, but up to\n-     8 SSE arguments in registers.  */\n-  if (!TARGET_64BIT && !cum->maybe_vaarg && !cum->fastcall\n-      && cum->sse_nregs == SSE_REGPARM_MAX && fndecl\n-      && TARGET_SSE_MATH && flag_unit_at_a_time && !profile_flag)\n-    {\n-      struct cgraph_local_info *i = cgraph_local_info (fndecl);\n-      if (i && i->local)\n-\t{\n-\t  cum->sse_nregs = 8;\n-\t  cum->float_in_sse = true;\n-\t}\n-    }\n-\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr, \", nregs=%d )\\n\", cum->nregs);\n \n@@ -2785,10 +2838,10 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  break;\n \n \tcase DFmode:\n-\t  if (!TARGET_SSE2)\n+\t  if (cum->float_in_sse < 2)\n \t    break;\n \tcase SFmode:\n-\t  if (!cum->float_in_sse)\n+\t  if (cum->float_in_sse < 1)\n \t    break;\n \t  /* FALLTHRU */\n \n@@ -2914,10 +2967,10 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode orig_mode,\n \t  }\n \tbreak;\n       case DFmode:\n-\tif (!TARGET_SSE2)\n+\tif (cum->float_in_sse < 2)\n \t  break;\n       case SFmode:\n-\tif (!cum->float_in_sse)\n+\tif (cum->float_in_sse < 1)\n \t  break;\n \t/* FALLTHRU */\n       case TImode:\n@@ -3274,13 +3327,13 @@ ix86_value_regno (enum machine_mode mode, tree func)\n     return 0;\n \n   /* Floating point return values in %st(0), except for local functions when\n-     SSE math is enabled.  */\n-  if (func && SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH\n-      && flag_unit_at_a_time)\n+     SSE math is enabled or for functions with sseregparm attribute.  */\n+  if (func && (mode == SFmode || mode == DFmode))\n     {\n-      struct cgraph_local_info *i = cgraph_local_info (func);\n-      if (i && i->local)\n-\treturn FIRST_SSE_REG;\n+      int sse_level = ix86_function_sseregparm (TREE_TYPE (func), func);\n+      if ((sse_level >= 1 && mode == SFmode)\n+\t  || (sse_level == 2 && mode == DFmode))\n+        return FIRST_SSE_REG;\n     }\n \n   return FIRST_FLOAT_REG;"}, {"sha": "3358948f82619c3ac367df4661eb14ff2cbd7949", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -1478,8 +1478,8 @@ typedef struct ix86_args {\n   int mmx_nregs;\t\t/* # mmx registers available for passing */\n   int mmx_regno;\t\t/* next available mmx register number */\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n-  int float_in_sse;\t\t/* true if in 32-bit mode SFmode/DFmode should\n-\t\t\t\t   be passed in SSE registers.  */\n+  int float_in_sse;\t\t/* 1 if in 32-bit mode SFmode (2 for DFmode) should\n+\t\t\t\t   be passed in SSE registers.  Otherwise 0.  */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}, {"sha": "6a31e9cd325fb4163b82ba2182ba808f78b93716", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -1752,9 +1752,10 @@ the @code{rtc}.\n @item fastcall\n @cindex functions that pop the argument stack on the 386\n On the Intel 386, the @code{fastcall} attribute causes the compiler to\n-pass the first two arguments in the registers ECX and EDX@.  Subsequent\n-arguments are passed on the stack.  The called function will pop the\n-arguments off the stack.  If the number of arguments is variable all\n+pass the first argument (if of integral type) in the register ECX and\n+the second argument (if of integral type) in the register EDX@.  Subsequent\n+and other typed arguments are passed on the stack.  The called function will\n+pop the arguments off the stack.  If the number of arguments is variable all\n arguments are pushed on the stack.\n \n @item format (@var{archetype}, @var{string-index}, @var{first-to-check})\n@@ -2126,9 +2127,9 @@ than 2.96.\n @cindex @code{regparm} attribute\n @cindex functions that are passed arguments in registers on the 386\n On the Intel 386, the @code{regparm} attribute causes the compiler to\n-pass up to @var{number} integer arguments in registers EAX,\n-EDX, and ECX instead of on the stack.  Functions that take a\n-variable number of arguments will continue to be passed all of their\n+pass arguments number one to @var{number} if they are of integral type\n+in registers EAX, EDX, and ECX instead of on the stack.  Functions that\n+take a variable number of arguments will continue to be passed all of their\n arguments on the stack.\n \n Beware that on some ELF systems this attribute is unsuitable for\n@@ -2141,6 +2142,14 @@ safe since the loaders there save all registers.  (Lazy binding can be\n disabled with the linker or the loader if desired, to avoid the\n problem.)\n \n+@item sseregparm\n+@cindex @code{sseregparm} attribute\n+On the Intel 386 with SSE support, the @code{sseregparm} attribute\n+causes the compiler to pass up to 8 floating point arguments in\n+SSE registers instead of on the stack.  Functions that take a\n+variable number of arguments will continue to pass all of their\n+floating point arguments on the stack.\n+\n @item returns_twice\n @cindex @code{returns_twice} attribute\n The @code{returns_twice} attribute tells the compiler that a function may"}, {"sha": "09f9d7186605e87c9b73b83fb1d12a4e074cd32e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -1,3 +1,11 @@\n+2005-06-16  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\t* gcc.target/i386/attributes-error.c: New testcase.\n+\t* gcc.target/i386/fastcall-sseregparm.c: Likewise.\n+\t* gcc.target/i386/regparm-stdcall.c: Likewise.\n+\t* gcc.target/i386/sseregparm-1.c: Likewise.\n+\t* gcc.target/i386/sseregparm-2.c: Likewise.\n+\n 2005-06-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/rtti/crash2.C: New."}, {"sha": "05c21299ac58c6987c17bdb1cbdc1eda1f1bb337", "filename": "gcc/testsuite/gcc.target/i386/attributes-error.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fattributes-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fattributes-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fattributes-error.c?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+\n+void foo1(int i, int j) __attribute__((fastcall, cdecl)); /* { dg-error \"not compatible\" } */\n+void foo2(int i, int j) __attribute__((fastcall, stdcall)); /* { dg-error \"not compatible\" } */\n+void foo3(int i, int j) __attribute__((fastcall, regparm(2))); /* { dg-error \"not compatible\" } */\n+void foo4(int i, int j) __attribute__((stdcall, cdecl)); /* { dg-error \"not compatible\" } */\n+void foo5(int i, int j) __attribute__((stdcall, fastcall)); /* { dg-error \"not compatible\" } */\n+void foo6(int i, int j) __attribute__((cdecl, fastcall)); /* { dg-error \"not compatible\" } */\n+void foo7(int i, int j) __attribute__((cdecl, stdcall)); /* { dg-error \"not compatible\" } */\n+void foo8(int i, int j) __attribute__((regparm(2), fastcall)); /* { dg-error \"not compatible\" } */\n+"}, {"sha": "e711411a4dd5f569dfaa3f058c635008bea89e5d", "filename": "gcc/testsuite/gcc.target/i386/fastcall-sseregparm.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffastcall-sseregparm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffastcall-sseregparm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffastcall-sseregparm.c?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mpreferred-stack-boundary=4 -msse\" } */\n+\n+extern void abort(void);\n+\n+void __attribute__((fastcall, sseregparm)) foo(int i, int j, float x)\n+{\n+  static int last_align = -1;\n+  int dummy, align = (int)&dummy & 15;\n+  if (last_align < 0)\n+    last_align = align;\n+  else if (align != last_align)\n+    abort ();\n+}\n+\n+int main()\n+{\n+\tfoo(0,0,0.0);\n+\tfoo(0,0,0.0);\n+\treturn 0;\n+}"}, {"sha": "6605e799ac773ae7ed48cc77f10b2e7987b983f6", "filename": "gcc/testsuite/gcc.target/i386/regparm-stdcall.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fregparm-stdcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fregparm-stdcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fregparm-stdcall.c?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options -mpreferred-stack-boundary=4 } */\n+\n+extern void abort(void);\n+\n+void __attribute__((regparm(2), stdcall)) foo(int i, int j, float x)\n+{\n+  static int last_align = -1;\n+  int dummy, align = (int)&dummy & 15;\n+  if (last_align < 0)\n+    last_align = align;\n+  else if (align != last_align)\n+    abort ();\n+}\n+\n+int main()\n+{\n+\tfoo(0,0,0.0);\n+\tfoo(0,0,0.0);\n+\treturn 0;\n+}"}, {"sha": "afe012bd3e88338debef9355423b13961121389e", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-1.c?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -0,0 +1,18 @@\n+/*  { dg-do compile } */\n+/*  { dg-options \"-O2 -msse\" } */\n+\n+float essef(float) __attribute__((sseregparm));\n+double essed(double) __attribute__((sseregparm));\n+float __attribute__((sseregparm, noinline)) ssef(float f) { return f; }\n+double __attribute__((sseregparm, noinline)) ssed(double d) { return d; }\n+extern double d;\n+extern float f;\n+void test(void)\n+{\n+  f = essef(f);\n+  d = essed(d);\n+  f = ssef(f);\n+  d = ssed(d);\n+}\n+\n+/* { dg-final { scan-assembler-not \"fldl\" } } */"}, {"sha": "32510b9dd9afefa87137a11e9e4f257073f7cf43", "filename": "gcc/testsuite/gcc.target/i386/sseregparm-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f84b963e9556be5bc0219aec23941ea15b61596/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsseregparm-2.c?ref=2f84b963e9556be5bc0219aec23941ea15b61596", "patch": "@@ -0,0 +1,16 @@\n+/*  { dg-do compile } */\n+/*  { dg-options \"-mno-sse\" } */\n+\n+float essef(float) __attribute__((sseregparm));\n+double essed(double) __attribute__((sseregparm));\n+float __attribute__((sseregparm, noinline)) ssef(float f) { return f; } /* { dg-warning \"SSE\" } */\n+double __attribute__((sseregparm, noinline)) ssed(double d) { return d; } /* { dg-warning \"SSE\" } */\n+extern double d;\n+extern float f;\n+void test(void)\n+{\n+  f = essef(f); /* { dg-warning \"SSE\" } */\n+  d = essed(d); /* { dg-warning \"SSE\" } */\n+  f = ssef(f); /* { dg-warning \"SSE\" } */\n+  d = ssed(d); /* { dg-warning \"SSE\" } */\n+}"}]}