{"sha": "e62b90b403f1e528aef8dc5042e45f921b365cf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYyYjkwYjQwM2YxZTUyOGFlZjhkYzUwNDJlNDVmOTIxYjM2NWNmOA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2010-06-06T18:24:27Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2010-06-06T18:24:27Z"}, "message": "re PR c++/44188 (Fails to produce DW_AT_typedef for typedef of anonymous struct)\n\nFix PR c++/44188\n\ngcc/ChangeLog:\n\tPR c++/44188\n\t* c-common.c (is_typedef_decl): Move this definition ...\n\t* tree.c (is_typedef_decl): ... here.\n\t(typdef_variant_p): Move definition here from gcc/cp/tree.c.\n\t* c-common.h (is_typedef_decl): Move this declaration ...\n\t* tree.h (is_typedef_decl): ... here.\n\t(typedef_variant_p): Move declaration here from gcc/cp/cp-tree.h\n\t* dwarf2out.c (is_naming_typedef_decl): New function.\n\t(gen_tagged_type_die): Split out of ...\n\t(gen_type_die_with_usage): ... this function. When an anonymous\n\ttagged type is named by a typedef, make sure a DW_TAG_typedef DIE\n\tis emitted for the typedef.\n\t(gen_typedef_die): Emit DW_TAG_typedef also for typedefs naming\n\tanonymous tagged types.\n\ngcc/cp/ChangeLog:\n\tPR c++/44188\n\t* cp-tree.h (typedef_variant_p): Move this declaration to\n\tgcc/tree.h.\n\t* tree.c (typedef_variant_p): Move this definition to gcc/tree.c.\n\t* decl.c (grokdeclarator): Do not rename debug info of an\n\tanonymous tagged type named by a typedef.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/44188\n\t* g++.dg/debug/dwarf2/typedef3.C: New test.\n\nFrom-SVN: r160347", "tree": {"sha": "31545405e61d6e5cd67227f67bdd497a66fde528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31545405e61d6e5cd67227f67bdd497a66fde528"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e62b90b403f1e528aef8dc5042e45f921b365cf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62b90b403f1e528aef8dc5042e45f921b365cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62b90b403f1e528aef8dc5042e45f921b365cf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62b90b403f1e528aef8dc5042e45f921b365cf8/comments", "author": null, "committer": null, "parents": [{"sha": "04087cd0369ca9f978942715031c7dbd545ffb0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04087cd0369ca9f978942715031c7dbd545ffb0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04087cd0369ca9f978942715031c7dbd545ffb0f"}], "stats": {"total": 295, "additions": 217, "deletions": 78}, "files": [{"sha": "c82ec2302759c31e726666bb9ac8c6048f19bc74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -1,3 +1,20 @@\n+2010-05-25  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/44188\n+\t* c-common.c (is_typedef_decl): Move this definition ...\n+\t* tree.c (is_typedef_decl): ... here.\n+\t(typdef_variant_p): Move definition here from gcc/cp/tree.c.\n+\t* c-common.h (is_typedef_decl): Move this declaration ...\n+\t* tree.h (is_typedef_decl): ... here.\n+\t(typedef_variant_p): Move declaration here from gcc/cp/cp-tree.h\n+\t* dwarf2out.c (is_naming_typedef_decl): New function.\n+\t(gen_tagged_type_die): Split out of ...\n+\t(gen_type_die_with_usage): ... this function. When an anonymous\n+\ttagged type is named by a typedef, make sure a DW_TAG_typedef DIE\n+\tis emitted for the typedef.\n+\t(gen_typedef_die): Emit DW_TAG_typedef also for typedefs naming\n+\tanonymous tagged types.\n+\n 2010-06-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/20000"}, {"sha": "545f2e2800838a6663728bfdcf136c191ba97c99", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -9364,15 +9364,6 @@ set_underlying_type (tree x)\n     }\n }\n \n-/* Returns true if X is a typedef decl.  */\n-\n-bool\n-is_typedef_decl (tree x)\n-{\n-  return (x && TREE_CODE (x) == TYPE_DECL\n-          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n-}\n-\n /* Record the types used by the current global variable declaration\n    being parsed, so that we can decide later to emit their debug info.\n    Those types are in types_used_by_cur_var_decl, and we are going to"}, {"sha": "5fda1ab7e44be07a64b537633c3db9f8bef4050d", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -1071,7 +1071,6 @@ extern void warn_for_sign_compare (location_t,\n \t\t\t\t   tree result_type,\n \t\t\t\t   enum tree_code resultcode);\n extern void set_underlying_type (tree x);\n-extern bool is_typedef_decl (tree x);\n extern VEC(tree,gc) *make_tree_vector (void);\n extern void release_tree_vector (VEC(tree,gc) *);\n extern VEC(tree,gc) *make_tree_vector_single (tree);"}, {"sha": "2350ae68ba0d8590d59d0e0c63f2e285746f381b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -1,3 +1,12 @@\n+2010-05-25  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/44188\n+\t* cp-tree.h (typedef_variant_p): Move this declaration to\n+\tgcc/tree.h.\n+\t* tree.c (typedef_variant_p): Move this definition to gcc/tree.c.\n+\t* decl.c (grokdeclarator): Do not rename debug info of an\n+\tanonymous tagged type named by a typedef.\n+\n 2010-06-05  Fabien Ch\ufffdne  <fabien@gcc.gnu.org>\n \t\n \tPR c++/44086"}, {"sha": "5efe2798d321821071779327008b75feb83c147e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -5261,7 +5261,6 @@ extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern tree strip_typedefs\t\t\t(tree);\n-extern bool typedef_variant_p\t\t\t(tree);\n extern void cp_set_underlying_type\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);"}, {"sha": "c9f864a6eaf3dd092816dc6d4a59697535789e2b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -9088,10 +9088,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n \t    {\n \t      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n-\t\t{\n-\t\t  debug_hooks->set_name (t, decl);\n-\t\t  TYPE_NAME (t) = decl;\n-\t\t}\n+\t\t/* We do not rename the debug info representing the\n+\t\t   anonymous tagged type because the standard says in\n+\t\t   [dcl.typedef] that the naming applies only for\n+\t\t   linkage purposes.  */\n+\t\t/*debug_hooks->set_name (t, decl);*/\n+\t\tTYPE_NAME (t) = decl;\n   \t    }\n \n \t  if (TYPE_LANG_SPECIFIC (type))"}, {"sha": "2971283239133d3192510e5020563e3aa2f2bea9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -1056,14 +1056,6 @@ strip_typedefs (tree t)\n   return cp_build_qualified_type (result, cp_type_quals (t));\n }\n \n-/* Returns true iff TYPE is a type variant created for a typedef. */\n-\n-bool\n-typedef_variant_p (tree type)\n-{\n-  return is_typedef_decl (TYPE_NAME (type));\n-}\n-\n /* Setup a TYPE_DECL node as a typedef representation.\n    See comments of set_underlying_type in c-common.c.  */\n "}, {"sha": "0cdd2dc274d3683dc28daa34fc7509f3cccde96a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 142, "deletions": 55, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -6202,6 +6202,7 @@ static void gen_type_die (tree, dw_die_ref);\n static void gen_block_die (tree, dw_die_ref, int);\n static void decls_for_scope (tree, dw_die_ref, int);\n static int is_redundant_typedef (const_tree);\n+static bool is_naming_typedef_decl (const_tree);\n static inline dw_die_ref get_context_die (tree);\n static void gen_namespace_die (tree, dw_die_ref);\n static void gen_decl_die (tree, tree, dw_die_ref);\n@@ -6213,6 +6214,8 @@ static struct dwarf_file_data * lookup_filename (const char *);\n static void retry_incomplete_types (void);\n static void gen_type_die_for_member (tree, tree, dw_die_ref);\n static void gen_generic_params_dies (tree);\n+static void gen_tagged_type_die (tree, dw_die_ref, enum debug_info_usage);\n+static void gen_type_die_with_usage (tree, dw_die_ref, enum debug_info_usage);\n static void splice_child_die (dw_die_ref, dw_die_ref);\n static int file_info_cmp (const void *, const void *);\n static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *,\n@@ -19426,10 +19429,36 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \t  equate_type_number_to_die (TREE_TYPE (decl), type_die);\n \t}\n       else\n-\ttype = TREE_TYPE (decl);\n+\t{\n+\t  type = TREE_TYPE (decl);\n+\n+\t  if (is_naming_typedef_decl (TYPE_NAME (type)))\n+\t    /* \n+\t       Here, we are in the case of decl being a typedef naming\n+\t       an anonymous type, e.g:\n+\t             typedef struct {...} foo;\n+\t       In that case TREE_TYPE (decl) is not a typedef variant\n+\t       type and TYPE_NAME of the anonymous type is set to the\n+\t       TYPE_DECL of the typedef. This construct is emitted by\n+\t       the C++ FE.\n+\n+\t       TYPE is the anonymous struct named by the typedef\n+\t       DECL. As we need the DW_AT_type attribute of the\n+\t       DW_TAG_typedef to point to the DIE of TYPE, let's\n+\t       generate that DIE right away. add_type_attribute\n+\t       called below will then pick (via lookup_type_die) that\n+\t       anonymous struct DIE.  */\n+\t    gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);\n+\t}\n \n       add_type_attribute (type_die, type, TREE_READONLY (decl),\n \t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n+\n+      if (is_naming_typedef_decl (decl))\n+\t/* We want that all subsequent calls to lookup_type_die with\n+\t   TYPE in argument yield the DW_TAG_typedef we have just\n+\t   created.  */\n+\tequate_type_number_to_die (type, type_die);\n     }\n \n   if (DECL_ABSTRACT (decl))\n@@ -19439,22 +19468,86 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n     add_pubtype (decl, type_die);\n }\n \n+/* Generate a DIE for a struct, class, enum or union type.  */\n+\n+static void\n+gen_tagged_type_die (tree type,\n+\t\t     dw_die_ref context_die,\n+\t\t     enum debug_info_usage usage)\n+{\n+  int need_pop;\n+\n+  if (type == NULL_TREE\n+      || !is_tagged_type (type))\n+    return;\n+\n+  /* If this is a nested type whose containing class hasn't been written\n+     out yet, writing it out will cover this one, too.  This does not apply\n+     to instantiations of member class templates; they need to be added to\n+     the containing class as they are generated.  FIXME: This hurts the\n+     idea of combining type decls from multiple TUs, since we can't predict\n+     what set of template instantiations we'll get.  */\n+  if (TYPE_CONTEXT (type)\n+      && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n+      && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+    {\n+      gen_type_die_with_usage (TYPE_CONTEXT (type), context_die, usage);\n+\n+      if (TREE_ASM_WRITTEN (type))\n+\treturn;\n+\n+      /* If that failed, attach ourselves to the stub.  */\n+      push_decl_scope (TYPE_CONTEXT (type));\n+      context_die = lookup_type_die (TYPE_CONTEXT (type));\n+      need_pop = 1;\n+    }\n+  else if (TYPE_CONTEXT (type) != NULL_TREE\n+\t   && (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL))\n+    {\n+      /* If this type is local to a function that hasn't been written\n+\t out yet, use a NULL context for now; it will be fixed up in\n+\t decls_for_scope.  */\n+      context_die = lookup_decl_die (TYPE_CONTEXT (type));\n+      need_pop = 0;\n+    }\n+  else\n+    {\n+      context_die = declare_in_namespace (type, context_die);\n+      need_pop = 0;\n+    }\n+\n+  if (TREE_CODE (type) == ENUMERAL_TYPE)\n+    {\n+      /* This might have been written out by the call to\n+\t declare_in_namespace.  */\n+      if (!TREE_ASM_WRITTEN (type))\n+\tgen_enumeration_type_die (type, context_die);\n+    }\n+  else\n+    gen_struct_or_union_type_die (type, context_die, usage);\n+\n+  if (need_pop)\n+    pop_decl_scope ();\n+\n+  /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n+     it up if it is ever completed.  gen_*_type_die will set it for us\n+     when appropriate.  */\n+}\n+\n /* Generate a type description DIE.  */\n \n static void\n gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \t\t\t\tenum debug_info_usage usage)\n {\n-  int need_pop;\n   struct array_descr_info info;\n \n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n \n   /* If TYPE is a typedef type variant, let's generate debug info\n      for the parent typedef which TYPE is a type of.  */\n-  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n+  if (typedef_variant_p (type))\n     {\n       if (TREE_ASM_WRITTEN (type))\n \treturn;\n@@ -19469,6 +19562,21 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \tcontext_die = get_context_die (DECL_CONTEXT (TYPE_NAME (type)));\n \n       TREE_ASM_WRITTEN (type) = 1;\n+\n+      gen_decl_die (TYPE_NAME (type), NULL, context_die);\n+      return;\n+    }\n+\n+  /* If type is an anonymous tagged type named by a typedef, let's\n+     generate debug info for the typedef.  */\n+  if (is_naming_typedef_decl (TYPE_NAME (type)))\n+    {\n+      /* Use the DIE of the containing namespace as the parent DIE of\n+         the type description DIE we want to generate.  */\n+      if (DECL_CONTEXT (TYPE_NAME (type))\n+\t  && TREE_CODE (DECL_CONTEXT (TYPE_NAME (type))) == NAMESPACE_DECL)\n+\tcontext_die = get_context_die (DECL_CONTEXT (TYPE_NAME (type)));\n+      \n       gen_decl_die (TYPE_NAME (type), NULL, context_die);\n       return;\n     }\n@@ -19556,57 +19664,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      /* If this is a nested type whose containing class hasn't been written\n-\t out yet, writing it out will cover this one, too.  This does not apply\n-\t to instantiations of member class templates; they need to be added to\n-\t the containing class as they are generated.  FIXME: This hurts the\n-\t idea of combining type decls from multiple TUs, since we can't predict\n-\t what set of template instantiations we'll get.  */\n-      if (TYPE_CONTEXT (type)\n-\t  && AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n-\t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n-\t{\n-\t  gen_type_die_with_usage (TYPE_CONTEXT (type), context_die, usage);\n-\n-\t  if (TREE_ASM_WRITTEN (type))\n-\t    return;\n-\n-\t  /* If that failed, attach ourselves to the stub.  */\n-\t  push_decl_scope (TYPE_CONTEXT (type));\n-\t  context_die = lookup_type_die (TYPE_CONTEXT (type));\n-\t  need_pop = 1;\n-\t}\n-      else if (TYPE_CONTEXT (type) != NULL_TREE\n-\t       && (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL))\n-\t{\n-\t  /* If this type is local to a function that hasn't been written\n-\t     out yet, use a NULL context for now; it will be fixed up in\n-\t     decls_for_scope.  */\n-\t  context_die = lookup_decl_die (TYPE_CONTEXT (type));\n-\t  need_pop = 0;\n-\t}\n-      else\n-\t{\n-\t  context_die = declare_in_namespace (type, context_die);\n-\t  need_pop = 0;\n-\t}\n-\n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t{\n-\t  /* This might have been written out by the call to\n-\t     declare_in_namespace.  */\n-\t  if (!TREE_ASM_WRITTEN (type))\n-\t    gen_enumeration_type_die (type, context_die);\n-\t}\n-      else\n-\tgen_struct_or_union_type_die (type, context_die, usage);\n-\n-      if (need_pop)\n-\tpop_decl_scope ();\n-\n-      /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n-\t it up if it is ever completed.  gen_*_type_die will set it for us\n-\t when appropriate.  */\n+      gen_tagged_type_die (type, context_die, usage);\n       return;\n \n     case VOID_TYPE:\n@@ -19814,6 +19872,35 @@ is_redundant_typedef (const_tree decl)\n   return 0;\n }\n \n+/* Return TRUE if TYPE is a typedef that names a type for linkage\n+   purposes. This kind of typedefs is produced by the C++ FE for\n+   constructs like:\n+\n+   typedef struct {...} foo;\n+\n+   In that case, there is no typedef variant type produced for foo.\n+   Rather, the TREE_TYPE of the TYPE_DECL of foo is the anonymous\n+   struct type.  */\n+\n+static bool\n+is_naming_typedef_decl (const_tree decl)\n+{\n+  if (decl == NULL_TREE\n+      || TREE_CODE (decl) != TYPE_DECL\n+      || !is_tagged_type (TREE_TYPE (decl))\n+      || is_redundant_typedef (decl)\n+      /* It looks like Ada produces TYPE_DECLs that are very similar\n+         to C++ naming typedefs but that have different\n+         semantics. Let's be specific to c++ for now.  */\n+      || !is_cxx ())\n+    return FALSE;\n+\n+  return (DECL_ORIGINAL_TYPE (decl) == NULL_TREE\n+\t  && TYPE_NAME (TREE_TYPE (decl)) == decl\n+\t  && (TYPE_STUB_DECL (TREE_TYPE (decl))\n+\t      != TYPE_NAME (TREE_TYPE (decl))));\n+}\n+\n /* Returns the DIE for a context.  */\n \n static inline dw_die_ref"}, {"sha": "345318bce139a1143e0e8c386c1aa897135bdd28", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -1,3 +1,8 @@\n+2010-05-25  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/44188\n+\t* g++.dg/debug/dwarf2/typedef3.C: New test.\n+\n 2010-06-06  Manuel L\ufffdpez-Ib\ufffd\ufffdez  <manu@gcc.gnu.org>\n \n \tPR c/20000"}, {"sha": "ca70d9cacfac7e38cd0aead1ee507dcbb9d46e99", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/typedef3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ftypedef3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ftypedef3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Ftypedef3.C?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -0,0 +1,19 @@\n+// Origin: PR debug/44188\n+// { dg-options \"-g -dA\" }\n+// { dg-do compile }\n+\n+// { dg-final { scan-assembler-times \"\\[^\\n\\r\\]*\\\\(DIE\\[^\\n\\r\\]*DW_TAG_typedef\\\\)\" 1 } }\n+\n+// { dg-final { scan-assembler-times \"\\[^\\n\\r\\]*\\\\(DIE\\[^\\n\\r\\]*DW_TAG_structure_type\\\\)\" 1 } }\n+\n+typedef struct\n+{\n+  int i;\n+} AAA;\n+\n+int\n+main(void)\n+{\n+  AAA aa;\n+  return 0;\n+}"}, {"sha": "7b1a489a03f43ad58768ede74b12b70b8039d662", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -10818,4 +10818,21 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n   return binfo;\n }\n \n+/* Returns true if X is a typedef decl.  */\n+\n+bool\n+is_typedef_decl (tree x)\n+{\n+  return (x && TREE_CODE (x) == TYPE_DECL\n+          && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n+}\n+\n+/* Returns true iff TYPE is a type variant created for a typedef. */\n+\n+bool\n+typedef_variant_p (tree type)\n+{\n+  return is_typedef_decl (TYPE_NAME (type));\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "31d80dfa7e26d5635fd2723695f2635382300282", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e62b90b403f1e528aef8dc5042e45f921b365cf8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e62b90b403f1e528aef8dc5042e45f921b365cf8", "patch": "@@ -4820,6 +4820,8 @@ extern tree create_artificial_label (location_t);\n extern const char *get_name (tree);\n extern bool stdarg_p (tree);\n extern bool prototype_p (tree);\n+extern bool is_typedef_decl (tree x);\n+extern bool typedef_variant_p (tree);\n extern bool auto_var_in_fn_p (const_tree, const_tree);\n extern tree build_low_bits_mask (tree, unsigned);\n extern tree tree_strip_nop_conversions (tree);"}]}