{"sha": "bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2MDRhNWVlYjRiOTQyMzQ4ZThmMWNkYWY0YmFmNmQ3NzQ5N2FlYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T13:41:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T13:41:04Z"}, "message": "[multiple changes]\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Known_Non_Null): Moved to Sem_Util.\n\t(Known_Null): Moved to Sem_Util.\n\t* exp_util.ads (Known_Non_Null): Moved to Sem_Util.\n\t(Known_Null): Moved to Sem_Util.\n\t* sem_util.adb Add new enumeration type Null_Status_Kind.\n\t(Known_Non_Null): Moved from Exp_Util. Most of the logic in\n\tthis routine is now carried out by Null_Status.\n\t(Known_Null): Moved from Exp_Util. Most of the logic in this routine\n\tis now carried out by Null_Status.\n\t(Null_Status): New routine.\n\t* sem_util.ads (Known_Non_Null): Moved from Exp_Util.\n\t(Known_Null): Moved from Exp_Util.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): Do not report an\n\terror on the return type of an expression function that is a\n\tcompletion, if the type is derived from a generic formal type.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_dim.adb (Dimensions_Of_Operand): The dimensions of a type\n\tconversion are those of the target type.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* a-clrefi.adb: Minor cleanup.\n\nFrom-SVN: r247236", "tree": {"sha": "3c50c75a81069576fb48b9af44f1bf9960bb974f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c50c75a81069576fb48b9af44f1bf9960bb974f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/comments", "author": null, "committer": null, "parents": [{"sha": "178c3cba2df14a093537dbd9ffbf639510bd5b55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178c3cba2df14a093537dbd9ffbf639510bd5b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/178c3cba2df14a093537dbd9ffbf639510bd5b55"}], "stats": {"total": 589, "additions": 412, "deletions": 177}, "files": [{"sha": "5cca5c8b65e0b38ecaa6624e6e84c1d8dc994560", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -1,3 +1,33 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Known_Non_Null): Moved to Sem_Util.\n+\t(Known_Null): Moved to Sem_Util.\n+\t* exp_util.ads (Known_Non_Null): Moved to Sem_Util.\n+\t(Known_Null): Moved to Sem_Util.\n+\t* sem_util.adb Add new enumeration type Null_Status_Kind.\n+\t(Known_Non_Null): Moved from Exp_Util. Most of the logic in\n+\tthis routine is now carried out by Null_Status.\n+\t(Known_Null): Moved from Exp_Util. Most of the logic in this routine\n+\tis now carried out by Null_Status.\n+\t(Null_Status): New routine.\n+\t* sem_util.ads (Known_Non_Null): Moved from Exp_Util.\n+\t(Known_Null): Moved from Exp_Util.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): Do not report an\n+\terror on the return type of an expression function that is a\n+\tcompletion, if the type is derived from a generic formal type.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_dim.adb (Dimensions_Of_Operand): The dimensions of a type\n+\tconversion are those of the target type.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* a-clrefi.adb: Minor cleanup.\n+\n 2017-04-25  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_util.adb, exp_util.ads, types.ads: Minor reformatting."}, {"sha": "914d8f4a013c3a9a3a7d289f0b13ac40e5373056", "filename": "gcc/ada/a-clrefi.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fa-clrefi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fa-clrefi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-clrefi.adb?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2007-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2007-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -105,7 +105,10 @@ package body Ada.Command_Line.Response_File is\n       -------------\n \n       procedure Recurse (File_Name : String) is\n-         FD : File_Descriptor;\n+         --  Open the response file. If not found, fail or report a warning,\n+         --  depending on the value of Ignore_Non_Existing_Files.\n+\n+         FD : constant File_Descriptor := Open_Read (File_Name, Text);\n \n          Buffer_Size : constant := 1500;\n          Buffer : String (1 .. Buffer_Size);\n@@ -222,11 +225,6 @@ package body Ada.Command_Line.Response_File is\n       begin\n          Last_Arg := 0;\n \n-         --  Open the response file. If not found, fail or report a warning,\n-         --  depending on the value of Ignore_Non_Existing_Files.\n-\n-         FD := Open_Read (File_Name, Text);\n-\n          if FD = Invalid_FD then\n             if Ignore_Non_Existing_Files then\n                return;"}, {"sha": "04cd7c4980a2fff49fe68ecda14989518f6c9d55", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 39, "deletions": 155, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -5197,53 +5197,68 @@ package body Exp_Util is\n    is\n       U_Typ : constant Entity_Id := Unique_Entity (Typ);\n \n+      Calls_OK : Boolean := False;\n+      --  This flag is set to True when expression Expr contains at\n+      --  least one call to a non-dispatching primitive function of\n+      --  Typ.\n+\n       function Search_Primitive_Calls (N : Node_Id) return Traverse_Result;\n       --  Search for nondispatching calls to primitive functions of type Typ\n \n       ----------------------------\n       -- Search_Primitive_Calls --\n       ----------------------------\n \n-      function Search_Primitive_Calls (N : Node_Id) return Traverse_Result is\n+      function Search_Primitive_Calls\n+        (N : Node_Id) return Traverse_Result\n+      is\n+         Disp_Typ : Entity_Id;\n+         Subp     : Entity_Id;\n+\n       begin\n-         if Nkind (N) = N_Identifier\n-           and then Present (Entity (N))\n-           and then\n-             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n-           and then Nkind (Parent (N)) = N_Function_Call\n+         --  Detect a function call which could denote a non-dispatching\n+         --  primitive of the input type.\n+\n+         if Nkind (N) = N_Function_Call\n+           and then Is_Entity_Name (Name (N))\n          then\n-            --  Do not consider dispatching calls\n+            Subp := Entity (Name (N));\n \n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-              and then Present (Controlling_Argument (Parent (N)))\n+            --  Do not consider function calls with a controlling argument\n+            --  as those are always dispatching calls.\n+\n+            if Is_Dispatching_Operation (Subp)\n+              and then No (Controlling_Argument (N))\n             then\n-               return OK;\n-            end if;\n+               Disp_Typ := Find_Dispatching_Type (Subp);\n \n-            --  If N is a function call, and E is dispatching, search for the\n-            --  controlling type to see if it is Ty.\n+               --  To qualify as a suitable primitive, the dispatching\n+               --  type of the function must be the input type.\n \n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-              and then Is_Dispatching_Operation (Entity (N))\n-              and then Present (Find_Dispatching_Type (Entity (N)))\n-              and then\n-                Unique_Entity (Find_Dispatching_Type (Entity (N))) = U_Typ\n-            then\n-               return Abandon;\n+               if Present (Disp_Typ)\n+                 and then Unique_Entity (Disp_Typ) = U_Typ\n+               then\n+                  Calls_OK := True;\n+\n+                  --  There is no need to continue the traversal as one\n+                  --  such call suffices.\n+\n+                  return Abandon;\n+               end if;\n             end if;\n          end if;\n \n          return OK;\n       end Search_Primitive_Calls;\n \n-      function Search_Calls is new Traverse_Func (Search_Primitive_Calls);\n+      procedure Search_Calls is\n+        new Traverse_Proc (Search_Primitive_Calls);\n \n    --  Start of processing for Expression_Contains_Primitives_Calls_Of_Type\n \n    begin\n-      return Search_Calls (Expr) = Abandon;\n+      Search_Calls (Expr);\n+      return Calls_OK;\n    end Expression_Contains_Primitives_Calls_Of;\n \n    ----------------------\n@@ -8938,137 +8953,6 @@ package body Exp_Util is\n       end if;\n    end Known_Non_Negative;\n \n-   --------------------\n-   -- Known_Non_Null --\n-   --------------------\n-\n-   function Known_Non_Null (N : Node_Id) return Boolean is\n-   begin\n-      --  Checks for case where N is an entity reference\n-\n-      if Is_Entity_Name (N) and then Present (Entity (N)) then\n-         declare\n-            E   : constant Entity_Id := Entity (N);\n-            Op  : Node_Kind;\n-            Val : Node_Id;\n-\n-         begin\n-            --  First check if we are in decisive conditional\n-\n-            Get_Current_Value_Condition (N, Op, Val);\n-\n-            if Known_Null (Val) then\n-               if Op = N_Op_Eq then\n-                  return False;\n-               elsif Op = N_Op_Ne then\n-                  return True;\n-               end if;\n-            end if;\n-\n-            --  If OK to do replacement, test Is_Known_Non_Null flag\n-\n-            if OK_To_Do_Constant_Replacement (E) then\n-               return Is_Known_Non_Null (E);\n-\n-            --  Otherwise if not safe to do replacement, then say so\n-\n-            else\n-               return False;\n-            end if;\n-         end;\n-\n-      --  True if access attribute\n-\n-      elsif Nkind (N) = N_Attribute_Reference\n-        and then Nam_In (Attribute_Name (N), Name_Access,\n-                                             Name_Unchecked_Access,\n-                                             Name_Unrestricted_Access)\n-      then\n-         return True;\n-\n-      --  True if allocator\n-\n-      elsif Nkind (N) = N_Allocator then\n-         return True;\n-\n-      --  For a conversion, true if expression is known non-null\n-\n-      elsif Nkind (N) = N_Type_Conversion then\n-         return Known_Non_Null (Expression (N));\n-\n-      --  Above are all cases where the value could be determined to be\n-      --  non-null. In all other cases, we don't know, so return False.\n-\n-      else\n-         return False;\n-      end if;\n-   end Known_Non_Null;\n-\n-   ----------------\n-   -- Known_Null --\n-   ----------------\n-\n-   function Known_Null (N : Node_Id) return Boolean is\n-   begin\n-      --  Checks for case where N is an entity reference\n-\n-      if Is_Entity_Name (N) and then Present (Entity (N)) then\n-         declare\n-            E   : constant Entity_Id := Entity (N);\n-            Op  : Node_Kind;\n-            Val : Node_Id;\n-\n-         begin\n-            --  Constant null value is for sure null\n-\n-            if Ekind (E) = E_Constant\n-              and then Known_Null (Constant_Value (E))\n-            then\n-               return True;\n-            end if;\n-\n-            --  First check if we are in decisive conditional\n-\n-            Get_Current_Value_Condition (N, Op, Val);\n-\n-            if Known_Null (Val) then\n-               if Op = N_Op_Eq then\n-                  return True;\n-               elsif Op = N_Op_Ne then\n-                  return False;\n-               end if;\n-            end if;\n-\n-            --  If OK to do replacement, test Is_Known_Null flag\n-\n-            if OK_To_Do_Constant_Replacement (E) then\n-               return Is_Known_Null (E);\n-\n-            --  Otherwise if not safe to do replacement, then say so\n-\n-            else\n-               return False;\n-            end if;\n-         end;\n-\n-      --  True if explicit reference to null\n-\n-      elsif Nkind (N) = N_Null then\n-         return True;\n-\n-      --  For a conversion, true if expression is known null\n-\n-      elsif Nkind (N) = N_Type_Conversion then\n-         return Known_Null (Expression (N));\n-\n-      --  Above are all cases where the value could be determined to be null.\n-      --  In all other cases, we don't know, so return False.\n-\n-      else\n-         return False;\n-      end if;\n-   end Known_Null;\n-\n    -----------------------------\n    -- Make_CW_Equivalent_Type --\n    -----------------------------"}, {"sha": "b1fded9bcefae5a62b67e2d5cff15c171ba48e67", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -860,18 +860,6 @@ package Exp_Util is\n    --  that cannot possibly be negative, and if so returns True. A value of\n    --  False means that it is not known if the value is positive or negative.\n \n-   function Known_Non_Null (N : Node_Id) return Boolean;\n-   --  Given a node N for a subexpression of an access type, determines if\n-   --  this subexpression yields a value that is known at compile time to\n-   --  be non-null and returns True if so. Returns False otherwise. It is\n-   --  an error to call this function if N is not of an access type.\n-\n-   function Known_Null (N : Node_Id) return Boolean;\n-   --  Given a node N for a subexpression of an access type, determines if this\n-   --  subexpression yields a value that is known at compile time to be null\n-   --  and returns True if so. Returns False otherwise. It is an error to call\n-   --  this function if N is not of an access type.\n-\n    function Make_Invariant_Call (Expr : Node_Id) return Node_Id;\n    --  Expr is an object of a type which Has_Invariants set (and which thus\n    --  also has an Invariant_Procedure set). If invariants are enabled, this"}, {"sha": "020ffb8400a1d27666c6d78cf6a7cc0b6b572c4b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -382,14 +382,15 @@ package body Sem_Ch6 is\n          --  An entity can only be frozen if it is complete, so if the type\n          --  is still unfrozen it must still be incomplete in some way, e.g.\n          --  a private type without a full view, or a type derived from such\n-         --  in an enclosing scope. Except in a generic context, such use of\n+         --  in an enclosing scope. Except in a generic context (where the\n+         --  type may be a generic formal or derived from such), such use of\n          --  an incomplete type is an error. On the other hand, if this is a\n          --  limited view of a type, the type is declared in another unit and\n          --  frozen there. We must be in a context seeing the nonlimited view\n          --  of the type, which will be installed when the body is compiled.\n \n          if not Is_Frozen (Ret_Type)\n-           and then not Is_Generic_Type (Ret_Type)\n+           and then not Is_Generic_Type (Root_Type (Ret_Type))\n            and then not Inside_A_Generic\n          then\n             if From_Limited_With (Ret_Type)"}, {"sha": "64a5f5b991d71ccc7745f6b804f759ced4624bc5", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1376,6 +1376,13 @@ package body Sem_Dim is\n                return Dimensions_Of (Etype (N));\n             end if;\n \n+         --  A type conversion may have been inserted to rewrite other\n+         --  expressions, e.g. function returns. Dimensions are those of\n+         --  the target type.\n+\n+         elsif Nkind (N) = N_Type_Conversion then\n+            return Dimensions_Of (Etype (N));\n+\n          --  Otherwise return the default dimensions\n \n          else"}, {"sha": "5b552bfcb4f045bb303c041f349ef492e118c8a4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -100,6 +100,25 @@ package body Sem_Util is\n    --  components in the selected variant to determine whether all of them\n    --  have a default.\n \n+   type Null_Status_Kind is\n+     (Is_Null,\n+      --  This value indicates that a subexpression is known to have a null\n+      --  value at compile time.\n+\n+      Is_Non_Null,\n+      --  This value indicates that a subexpression is known to have a non-null\n+      --  value at compile time.\n+\n+      Unknown);\n+      --  This value indicates that it cannot be determined at compile time\n+      --  whether a subexpression yields a null or non-null value.\n+\n+   function Null_Status (N : Node_Id) return Null_Status_Kind;\n+   --  Determine whether subexpression N of an access type yields a null value,\n+   --  a non-null value, or the value cannot be determined at compile time. The\n+   --  routine does not take simple flow diagnostics into account, it relies on\n+   --  static facts such as the presence of null exclusions.\n+\n    function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n    function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n    --  ???We retain the old and new algorithms for Requires_Transient_Scope for\n@@ -15966,6 +15985,104 @@ package body Sem_Util is\n       end if;\n    end Kill_Size_Check_Code;\n \n+   --------------------\n+   -- Known_Non_Null --\n+   --------------------\n+\n+   function Known_Non_Null (N : Node_Id) return Boolean is\n+      Status : constant Null_Status_Kind := Null_Status (N);\n+\n+      Id  : Entity_Id;\n+      Op  : Node_Kind;\n+      Val : Node_Id;\n+\n+   begin\n+      --  The expression yields a non-null value ignoring simple flow analysis\n+\n+      if Status = Is_Non_Null then\n+         return True;\n+\n+      --  Otherwise check whether N is a reference to an entity that appears\n+      --  within a conditional construct.\n+\n+      elsif Is_Entity_Name (N) and then Present (Entity (N)) then\n+\n+         --  First check if we are in decisive conditional\n+\n+         Get_Current_Value_Condition (N, Op, Val);\n+\n+         if Known_Null (Val) then\n+            if Op = N_Op_Eq then\n+               return False;\n+            elsif Op = N_Op_Ne then\n+               return True;\n+            end if;\n+         end if;\n+\n+         --  If OK to do replacement, test Is_Known_Non_Null flag\n+\n+         Id := Entity (N);\n+\n+         if OK_To_Do_Constant_Replacement (Id) then\n+            return Is_Known_Non_Null (Id);\n+         end if;\n+      end if;\n+\n+      --  Otherwise it is not possible to determine whether N yields a non-null\n+      --  value.\n+\n+      return False;\n+   end Known_Non_Null;\n+\n+   ----------------\n+   -- Known_Null --\n+   ----------------\n+\n+   function Known_Null (N : Node_Id) return Boolean is\n+      Status : constant Null_Status_Kind := Null_Status (N);\n+\n+      Id  : Entity_Id;\n+      Op  : Node_Kind;\n+      Val : Node_Id;\n+\n+   begin\n+      --  The expression yields a null value ignoring simple flow analysis\n+\n+      if Status = Is_Null then\n+         return True;\n+\n+      --  Otherwise check whether N is a reference to an entity that appears\n+      --  within a conditional construct.\n+\n+      elsif Is_Entity_Name (N) and then Present (Entity (N)) then\n+\n+         --  First check if we are in decisive conditional\n+\n+         Get_Current_Value_Condition (N, Op, Val);\n+\n+         if Known_Null (Val) then\n+            if Op = N_Op_Eq then\n+               return True;\n+            elsif Op = N_Op_Ne then\n+               return False;\n+            end if;\n+         end if;\n+\n+         --  If OK to do replacement, test Is_Known_Null flag\n+\n+         Id := Entity (N);\n+\n+         if OK_To_Do_Constant_Replacement (Id) then\n+            return Is_Known_Null (Id);\n+         end if;\n+      end if;\n+\n+      --  Otherwise it is not possible to determine whether N yields a null\n+      --  value.\n+\n+      return False;\n+   end Known_Null;\n+\n    --------------------------\n    -- Known_To_Be_Assigned --\n    --------------------------\n@@ -18347,6 +18464,204 @@ package body Sem_Util is\n       end loop;\n    end Note_Possible_Modification;\n \n+   -----------------\n+   -- Null_Status --\n+   -----------------\n+\n+   function Null_Status (N : Node_Id) return Null_Status_Kind is\n+      function Is_Null_Excluding_Def (Def : Node_Id) return Boolean;\n+      --  Determine whether definition Def carries a null exclusion\n+\n+      function Null_Status_Of_Entity (Id : Entity_Id) return Null_Status_Kind;\n+      --  Determine the null status of arbitrary entity Id\n+\n+      function Null_Status_Of_Type (Typ : Entity_Id) return Null_Status_Kind;\n+      --  Determine the null status of type Typ\n+\n+      ---------------------------\n+      -- Is_Null_Excluding_Def --\n+      ---------------------------\n+\n+      function Is_Null_Excluding_Def (Def : Node_Id) return Boolean is\n+      begin\n+         return\n+           Nkind_In (Def, N_Access_Definition,\n+                          N_Access_Function_Definition,\n+                          N_Access_Procedure_Definition,\n+                          N_Access_To_Object_Definition,\n+                          N_Component_Definition,\n+                          N_Derived_Type_Definition)\n+             and then Null_Exclusion_Present (Def);\n+      end Is_Null_Excluding_Def;\n+\n+      ---------------------------\n+      -- Null_Status_Of_Entity --\n+      ---------------------------\n+\n+      function Null_Status_Of_Entity\n+        (Id : Entity_Id) return Null_Status_Kind\n+      is\n+         Decl : constant Node_Id := Declaration_Node (Id);\n+         Def  : Node_Id;\n+\n+      begin\n+         --  The value of an imported or exported entity may be set externally\n+         --  regardless of a null exclusion. As a result, the value cannot be\n+         --  determined statically.\n+\n+         if Is_Imported (Id) or else Is_Exported (Id) then\n+            return Unknown;\n+\n+         elsif Nkind_In (Decl, N_Component_Declaration,\n+                               N_Discriminant_Specification,\n+                               N_Formal_Object_Declaration,\n+                               N_Object_Declaration,\n+                               N_Object_Renaming_Declaration,\n+                               N_Parameter_Specification)\n+         then\n+            --  A component declaration yields a non-null value when either\n+            --  its component definition or access definition carries a null\n+            --  exclusion.\n+\n+            if Nkind (Decl) = N_Component_Declaration then\n+               Def := Component_Definition (Decl);\n+\n+               if Is_Null_Excluding_Def (Def) then\n+                  return Is_Non_Null;\n+               end if;\n+\n+               Def := Access_Definition (Def);\n+\n+               if Present (Def) and then Is_Null_Excluding_Def (Def) then\n+                  return Is_Non_Null;\n+               end if;\n+\n+            --  A formal object declaration yields a non-null value if its\n+            --  access definition carries a null exclusion. If the object is\n+            --  default initialized, then the value depends on the expression.\n+\n+            elsif Nkind (Decl) = N_Formal_Object_Declaration then\n+               Def := Access_Definition  (Decl);\n+\n+               if Present (Def) and then Is_Null_Excluding_Def (Def) then\n+                  return Is_Non_Null;\n+               end if;\n+\n+            --  A constant may yield a null or non-null value depending on its\n+            --  initialization expression.\n+\n+            elsif Ekind (Id) = E_Constant then\n+               return Null_Status (Constant_Value (Id));\n+\n+            --  The construct yields a non-null value when it has a null\n+            --  exclusion.\n+\n+            elsif Null_Exclusion_Present (Decl) then\n+               return Is_Non_Null;\n+\n+            --  An object renaming declaration yields a non-null value if its\n+            --  access definition carries a null exclusion. Otherwise the value\n+            --  depends on the renamed name.\n+\n+            elsif Nkind (Decl) = N_Object_Renaming_Declaration then\n+               Def := Access_Definition (Decl);\n+\n+               if Present (Def) and then Is_Null_Excluding_Def (Def) then\n+                  return Is_Non_Null;\n+\n+               else\n+                  return Null_Status (Name (Decl));\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  At this point the declaration of the entity does not carry a null\n+         --  exclusion and lacks an initialization expression. Check the status\n+         --  of its type.\n+\n+         return Null_Status_Of_Type (Etype (Id));\n+      end Null_Status_Of_Entity;\n+\n+      -------------------------\n+      -- Null_Status_Of_Type --\n+      -------------------------\n+\n+      function Null_Status_Of_Type (Typ : Entity_Id) return Null_Status_Kind is\n+         Curr : Entity_Id;\n+         Decl : Node_Id;\n+\n+      begin\n+         --  Traverse the type chain looking for types with null exclusion\n+\n+         Curr := Typ;\n+         while Present (Curr) and then Etype (Curr) /= Curr loop\n+            Decl := Parent (Curr);\n+\n+            --  Guard against itypes which do not always have declarations. A\n+            --  type yields a non-null value if it carries a null exclusion.\n+\n+            if Present (Decl) then\n+               if Nkind (Decl) = N_Full_Type_Declaration\n+                 and then Is_Null_Excluding_Def (Type_Definition (Decl))\n+               then\n+                  return Is_Non_Null;\n+\n+               elsif Nkind (Decl) = N_Subtype_Declaration\n+                 and then Null_Exclusion_Present (Decl)\n+               then\n+                  return Is_Non_Null;\n+               end if;\n+            end if;\n+\n+            Curr := Etype (Curr);\n+         end loop;\n+\n+         --  The type chain does not contain any null excluding types\n+\n+         return Unknown;\n+      end Null_Status_Of_Type;\n+\n+   --  Start of processing for Null_Status\n+\n+   begin\n+      --  An allocator always creates a non-null value\n+\n+      if Nkind (N) = N_Allocator then\n+         return Is_Non_Null;\n+\n+      --  Taking the 'Access of something yields a non-null value\n+\n+      elsif Nkind (N) = N_Attribute_Reference\n+        and then Nam_In (Attribute_Name (N), Name_Access,\n+                                             Name_Unchecked_Access,\n+                                             Name_Unrestricted_Access)\n+      then\n+         return Is_Non_Null;\n+\n+      --  \"null\" yields null\n+\n+      elsif Nkind (N) = N_Null then\n+         return Is_Null;\n+\n+      --  Check the status of the operand of a type conversion\n+\n+      elsif Nkind (N) = N_Type_Conversion then\n+         return Null_Status (Expression (N));\n+\n+      --  The input denotes a reference to an entity. Determine whether the\n+      --  entity or its type yields a null or non-null value.\n+\n+      elsif Is_Entity_Name (N) and then Present (Entity (N)) then\n+         return Null_Status_Of_Entity (Entity (N));\n+      end if;\n+\n+      --  Otherwise it is not possible to determine the null status of the\n+      --  subexpression at compile time without resorting to simple flow\n+      --  analysis.\n+\n+      return Unknown;\n+   end Null_Status;\n+\n    --------------------------------------\n    --  Null_To_Null_Address_Convert_OK --\n    --------------------------------------"}, {"sha": "2b6a362cbc36d01f28f6c27c6e37b009b3653f09", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf604a5eeb4b942348e8f1cdaf4baf6d77497aec/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=bf604a5eeb4b942348e8f1cdaf4baf6d77497aec", "patch": "@@ -1889,6 +1889,18 @@ package Sem_Util is\n    --  present, this size check code is killed, since the object will not be\n    --  allocated by the program.\n \n+   function Known_Non_Null (N : Node_Id) return Boolean;\n+   --  Given a node N for a subexpression of an access type, determines if\n+   --  this subexpression yields a value that is known at compile time to\n+   --  be non-null and returns True if so. Returns False otherwise. It is\n+   --  an error to call this function if N is not of an access type.\n+\n+   function Known_Null (N : Node_Id) return Boolean;\n+   --  Given a node N for a subexpression of an access type, determines if this\n+   --  subexpression yields a value that is known at compile time to be null\n+   --  and returns True if so. Returns False otherwise. It is an error to call\n+   --  this function if N is not of an access type.\n+\n    function Known_To_Be_Assigned (N : Node_Id) return Boolean;\n    --  The node N is an entity reference. This function determines whether the\n    --  reference is for sure an assignment of the entity, returning True if"}]}