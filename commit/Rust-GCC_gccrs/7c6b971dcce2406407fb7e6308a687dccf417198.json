{"sha": "7c6b971dcce2406407fb7e6308a687dccf417198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M2Yjk3MWRjY2UyNDA2NDA3ZmI3ZTYzMDhhNjg3ZGNjZjQxNzE5OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-01T22:49:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-01T22:49:12Z"}, "message": "i386.md (QImode patterns): Remove '*' before the 'r' constraints.\n\n\t* i386.md (QImode patterns): Remove '*' before the 'r' constraints.\n\t* i386.h (procesor_costs): Add movzbl_load field.\n\t(HARD_REGNO_MODE_OK): Accept QImode on non PARTIAL_REGISTER_STALL in\n\tnon-Q registers, accept DImode registers anywhere.\n\t(Q_CLASS_P): New.\n\t(MEMORY_MOVE_COST): Calculate QImode moves correctly.\n\t* i386.c (*_cost): Set value for movxbl_load field.\n\nFrom-SVN: r30746", "tree": {"sha": "d1e98c8fda04cfb1a459e2b4d12f6b1ec6501fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1e98c8fda04cfb1a459e2b4d12f6b1ec6501fd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c6b971dcce2406407fb7e6308a687dccf417198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6b971dcce2406407fb7e6308a687dccf417198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c6b971dcce2406407fb7e6308a687dccf417198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c6b971dcce2406407fb7e6308a687dccf417198/comments", "author": null, "committer": null, "parents": [{"sha": "1c27d4b20f0bfb8e17e28b51678069b18f2d4cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c27d4b20f0bfb8e17e28b51678069b18f2d4cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c27d4b20f0bfb8e17e28b51678069b18f2d4cb1"}], "stats": {"total": 63, "additions": 42, "deletions": 21}, "files": [{"sha": "34b75e25b3d0c99ff80e54ab0dfd0600e1c0b7a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c6b971dcce2406407fb7e6308a687dccf417198", "patch": "@@ -1,5 +1,13 @@\n Fri Nov 26 10:59:12 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* i386.md (QImode patterns): Remove '*' before the 'r' constraints.\n+\t* i386.h (procesor_costs): Add movzbl_load field.\n+\t(HARD_REGNO_MODE_OK): Accept QImode on non PARTIAL_REGISTER_STALL in\n+\tnon-Q registers, accept DImode registers anywhere.\n+\t(Q_CLASS_P): New.\n+\t(MEMORY_MOVE_COST): Calculate QImode moves correctly.\n+\t* i386.c (*_cost): Set value for movxbl_load field.\n+\n \t* (addsi): New add to lea splitter.\n \t(ashlsi): Likewise.\n \t(lea to add/shift peep2): New."}, {"sha": "cad1c3887d4dbea8f8211c459e3ffb31a0720ee2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7c6b971dcce2406407fb7e6308a687dccf417198", "patch": "@@ -64,6 +64,7 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   23,\t\t\t\t\t/* cost of a divide/mod */\n   15,\t\t\t\t\t/* \"large\" insn */\n+  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2). */\n@@ -83,6 +84,7 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   40,\t\t\t\t\t/* cost of a divide/mod */\n   15,\t\t\t\t\t/* \"large\" insn */\n+  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2). */\n@@ -102,6 +104,7 @@ struct processor_costs pentium_cost = {\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   25,\t\t\t\t\t/* cost of a divide/mod */\n   8,\t\t\t\t\t/* \"large\" insn */\n+  6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2). */\n@@ -121,6 +124,7 @@ struct processor_costs pentiumpro_cost = {\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   17,\t\t\t\t\t/* cost of a divide/mod */\n   8,\t\t\t\t\t/* \"large\" insn */\n+  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2). */\n@@ -140,6 +144,7 @@ struct processor_costs k6_cost = {\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   18,\t\t\t\t\t/* cost of a divide/mod */\n   8,\t\t\t\t\t/* \"large\" insn */\n+  3,\t\t\t\t\t/* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2). */"}, {"sha": "ab6205052988431371b85640c4dd69f95cac8909", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7c6b971dcce2406407fb7e6308a687dccf417198", "patch": "@@ -62,6 +62,7 @@ struct processor_costs {\n   int mult_bit;\t\t\t/* cost of multiply per each bit set */\n   int divide;\t\t\t/* cost of a divide/mod */\n   int large_insn;\t\t/* insns larger than this cost more */\n+  int movzbl_load;\t\t/* cost of loading using movzbl */\n   int int_load[3];\t\t/* cost of loading integer registers\n \t\t\t\t   in QImode, HImode and SImode relative\n \t\t\t\t   to reg-reg move (2).  */\n@@ -704,13 +705,11 @@ extern int ix86_arch;\n    ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n        || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n       && GET_MODE_UNIT_SIZE (MODE) <= (LONG_DOUBLE_TYPE_SIZE == 96 ? 12 : 8))\\\n-   /* Only allow DImode in even registers.  */\t\t\t\\\n-   : (MODE) == DImode && ((REGNO) & 1) ? 0\t\t\t\\\n-   /* The first four integer regs can hold any mode.  */\t\\\n    : (REGNO) < 4 ? 1\t\t\t\t\t\t\\\n    /* Other regs cannot do byte accesses.  */\t\t\t\\\n    : (MODE) != QImode ? 1\t\t\t\t\t\\\n-   : reload_in_progress || reload_completed)\n+   : reload_in_progress || reload_completed\t\t\t\\\n+     || !TARGET_PARTIAL_REG_STALL)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -843,6 +842,8 @@ enum reg_class\n \n #define FLOAT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, FLOAT_REGS))\n \n+#define Q_CLASS_P(CLASS) (reg_class_subset_p (CLASS, Q_REGS))\n+\n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n@@ -1993,7 +1994,11 @@ while (0)\n \n    If moving between registers and memory is more expensive than\n    between two registers, you should define this macro to express the\n-   relative cost.  */\n+   relative cost.  \n+ \n+   Model also increased moving costs of QImode registers in non\n+   Q_REGS classes.\n+ */\n \n #define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\t\t\t\t\\\n   (FLOAT_CLASS_P (CLASS)\t\t\t\t\t\t\\\n@@ -2003,7 +2008,10 @@ while (0)\n \t ? (IN ? ix86_cost->fp_load[1] : ix86_cost->fp_store[1])\t\\\n \t : (IN ? ix86_cost->fp_load[2] : ix86_cost->fp_store[2])))\t\\\n    : (GET_MODE_SIZE (MODE)==1\t\t\t\t\t\t\\\n-      ? (IN ? ix86_cost->int_load[0] : ix86_cost->int_store[0])\t\t\\\n+      ? (IN ? (Q_CLASS_P (CLASS) ? ix86_cost->int_load[0]\t\t\\\n+\t\t\t\t : ix86_cost->movzbl_load)\t\t\\\n+\t    : (Q_CLASS_P (CLASS) ? ix86_cost->int_store[0]\t\t\\\n+\t\t\t\t : ix86_cost->int_store[0] + 4))\t\\\n       : (GET_MODE_SIZE (MODE)==2\t\t\t\t\t\\\n \t ? (IN ? ix86_cost->int_load[1] : ix86_cost->int_store[1])\t\\\n \t : ((IN ? ix86_cost->int_load[2] : ix86_cost->int_store[2])\t\\"}, {"sha": "dc23e1d8abe6bbbd0462f2ce3fc7102e59e49510", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c6b971dcce2406407fb7e6308a687dccf417198/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7c6b971dcce2406407fb7e6308a687dccf417198", "patch": "@@ -1348,8 +1348,8 @@\n    (set_attr \"length_prefix\" \"1\")])\n \n (define_insn \"*movqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q,*r,*r,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"qn,qm,*rn,qm,qn\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q,r,?r,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"qn,qm,rn,qm,qn\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n@@ -1454,8 +1454,8 @@\n   [(set_attr \"type\" \"imovx\")])\n \n (define_insn \"*movqi_extv_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm*r\")\n-        (sign_extract:QI (match_operand:SI 1 \"register_operand\" \"q\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,?r\")\n+        (sign_extract:QI (match_operand:SI 1 \"register_operand\" \"q,q\")\n                          (const_int 8)\n                          (const_int 8)))]\n   \"\"\n@@ -1487,8 +1487,8 @@\n   [(set_attr \"type\" \"imovx\")])\n \n (define_insn \"*movqi_extzv_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm*r\")\n-        (subreg:QI (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"q\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,?r\")\n+        (subreg:QI (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"q,q\")\n \t\t\t\t    (const_int 8)\n \t\t\t\t    (const_int 8)) 0))]\n   \"\"\n@@ -3295,9 +3295,9 @@\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*addqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,*r\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r\")\n \t(plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"qn,qmn,*rn\")))\n+\t\t (match_operand:QI 2 \"general_operand\" \"qn,qmn,rn\")))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (PLUS, QImode, operands)\"\n   \"*\n@@ -4366,9 +4366,9 @@\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*andqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,*r\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r\")\n \t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qi,qmi,*ri\")))\n+\t\t(match_operand:QI 2 \"general_operand\" \"qi,qmi,ri\")))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (AND, QImode, operands)\"\n   \"@\n@@ -4554,9 +4554,9 @@\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*iorqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,*r\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qmi,qi,*ri\")))\n+\t\t(match_operand:QI 2 \"general_operand\" \"qmi,qi,ri\")))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (IOR, QImode, operands)\"\n   \"@\n@@ -4659,9 +4659,9 @@\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n (define_insn \"*xorqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,*r\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n \t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qmi,qi,*ri\")))\n+\t\t(match_operand:QI 2 \"general_operand\" \"qmi,qi,ri\")))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (XOR, QImode, operands)\"\n   \"@\n@@ -5301,7 +5301,7 @@\n   \"ix86_expand_unary_operator (NOT, QImode, operands); DONE;\")\n \n (define_insn \"*one_cmplqi2_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,*r\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r\")\n \t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n   \"ix86_unary_operator_ok (NEG, QImode, operands)\"\n   \"@"}]}