{"sha": "0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhYjM0M2E0OTVmZWNkNTBlM2JmN2Q1ZmQ2YTMyYzZmMGEwM2M3Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-06T20:39:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-06T20:39:56Z"}, "message": "genrecog.c (validate_pattern): Warn for constraints in define_{expand,split,peephole2}.\n\n        * genrecog.c (validate_pattern): Warn for constraints in\n        define_{expand,split,peephole2}.  Remove strict_low_part\n        before looking up match_dup.\n\nFrom-SVN: r43821", "tree": {"sha": "f4511d063f1fd72d9ce1956384ae465e11f7a0c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4511d063f1fd72d9ce1956384ae465e11f7a0c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73/comments", "author": null, "committer": null, "parents": [{"sha": "15c0d35d4ee36a31f92febda7cf672d167c8c221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c0d35d4ee36a31f92febda7cf672d167c8c221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c0d35d4ee36a31f92febda7cf672d167c8c221"}], "stats": {"total": 75, "additions": 49, "deletions": 26}, "files": [{"sha": "28ef80085f0fcfd304bd93d3dba16fd96094fe02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "patch": "@@ -1,3 +1,9 @@\n+2001-07-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* genrecog.c (validate_pattern): Warn for constraints in\n+\tdefine_{expand,split,peephole2}.  Remove strict_low_part\n+\tbefore looking up match_dup.\n+\n 2001-07-06  DJ Delorie  <dj@redhat.com>\n \n \t* doc/gcc.texi (Makefile): Rename to be a more general purpose"}, {"sha": "8dfaa61f807cb1698bec22658f8a5e2c370f607e", "filename": "gcc/genrecog.c", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=0dab343a495fecd50e3bf7d5fd6a32c6f0a03c73", "patch": "@@ -545,35 +545,52 @@ validate_pattern (pattern, insn, set, set_code)\n \t\t}\n \t  }\n \n-\t/* A MATCH_OPERAND that is a SET should have an output reload.  */\n-\tif (set && code == MATCH_OPERAND\n-\t    && XSTR (pattern, 2)[0] != '\\0')\n+\tif (code == MATCH_OPERAND)\n \t  {\n-\t    if (set_code == '+')\n+\t    const char constraints0 = XSTR (pattern, 2)[0];\n+\n+\t    /* In DEFINE_EXPAND, DEFINE_SPLIT, and DEFINE_PEEPHOLE2, we \n+\t       don't use the MATCH_OPERAND constraint, only the predicate.\n+\t       This is confusing to folks doing new ports, so help them\n+\t       not make the mistake.  */\n+\t    if (GET_CODE (insn) == DEFINE_EXPAND\n+\t\t|| GET_CODE (insn) == DEFINE_SPLIT\n+\t\t|| GET_CODE (insn) == DEFINE_PEEPHOLE2)\n \t      {\n-\t\tif (XSTR (pattern, 2)[0] == '+')\n-\t\t  ;\n-\t\t/* If we've only got an output reload for this operand,\n-\t\t   we'd better have a matching input operand.  */\n-\t\telse if (XSTR (pattern, 2)[0] == '='\n-\t\t\t && find_matching_operand (insn, XINT (pattern, 0)))\n-\t\t  ;\n-\t\telse\n+\t\tif (constraints0)\n+\t\t  message_with_line (pattern_lineno,\n+\t\t\t\t     \"warning: constraints not supported in %s\",\n+\t\t\t\t     rtx_name[GET_CODE (insn)]);\n+\t      }\n+\t      \n+\t    /* A MATCH_OPERAND that is a SET should have an output reload.  */\n+\t    else if (set && constraints0)\n+\t      {\n+\t\tif (set_code == '+')\n+\t\t  {\n+\t\t    if (constraints0 == '+')\n+\t\t      ;\n+\t\t    /* If we've only got an output reload for this operand,\n+\t\t       we'd better have a matching input operand.  */\n+\t\t    else if (constraints0 == '='\n+\t\t\t     && find_matching_operand (insn, XINT (pattern, 0)))\n+\t\t      ;\n+\t\t    else\n+\t\t      {\n+\t\t\tmessage_with_line (pattern_lineno,\n+\t\t\t\t\t   \"operand %d missing in-out reload\",\n+\t\t\t\t\t   XINT (pattern, 0));\n+\t\t\terror_count++;\n+\t\t      }\n+\t\t  }\n+\t\telse if (constraints0 != '=' && constraints0 != '+')\n \t\t  {\n \t\t    message_with_line (pattern_lineno,\n-\t\t\t\t       \"operand %d missing in-out reload\",\n+\t\t\t\t       \"operand %d missing output reload\", \n \t\t\t\t       XINT (pattern, 0));\n \t\t    error_count++;\n \t\t  }\n \t      }\n-\t    else if (XSTR (pattern, 2)[0] != '='\n-\t\t     && XSTR (pattern, 2)[0] != '+')\n-\t      {\n-\t\tmessage_with_line (pattern_lineno,\n-\t\t\t\t   \"operand %d missing output reload\",\n-\t\t\t\t   XINT (pattern, 0));\n-\t\terror_count++;\n-\t      }\n \t  }\n \n \t/* Allowing non-lvalues in destinations -- particularly CONST_INT --\n@@ -623,6 +640,11 @@ validate_pattern (pattern, insn, set, set_code)\n \tdest = SET_DEST (pattern);\n \tsrc = SET_SRC (pattern);\n \n+\t/* STRICT_LOW_PART is a wrapper.  Its argument is the real\n+\t   destination, and it's mode should match the source.  */\n+\tif (GET_CODE (dest) == STRICT_LOW_PART)\n+\t  dest = XEXP (dest, 0);\n+\n \t/* Find the referant for a DUP.  */\n \n \tif (GET_CODE (dest) == MATCH_DUP\n@@ -635,11 +657,6 @@ validate_pattern (pattern, insn, set, set_code)\n \t    || GET_CODE (src) == MATCH_PAR_DUP)\n \t  src = find_operand (insn, XINT (src, 0));\n \n-\t/* STRICT_LOW_PART is a wrapper.  Its argument is the real\n-\t   destination, and it's mode should match the source.  */\n-\tif (GET_CODE (dest) == STRICT_LOW_PART)\n-\t  dest = XEXP (dest, 0);\n-\n \tdmode = GET_MODE (dest);\n \tsmode = GET_MODE (src);\n "}]}