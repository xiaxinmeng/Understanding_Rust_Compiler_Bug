{"sha": "f7a8132ae8f97e55dfd62d527f3d528a2a560ca5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdhODEzMmFlOGY5N2U1NWRmZDYyZDUyN2YzZDUyOGEyYTU2MGNhNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-12T17:58:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-12T17:58:24Z"}, "message": "re PR c++/16273 (Memory exhausted when using nested classes and virtual functions)\n\n\tPR c++/16273\n\t* class.c (count_depth_data): New type.\n\t(dfs_depth_post): New function.\n\t(dfs_depth_q): Likewise.\n\t(find_final_overrider_data_s): Change type of vpath.\n\tAdd vpath_list.\n\t(dfs_find_final_overrider_1): New function.\n\t(dfs_find_final_overrider): Use it.\n\t(dfs_find_final_overrider_q): Adjust use of vpath.\n\t(dfs_find_final_overrider_post): Likewise.\n\t(find_final_overrider): Use dfs_depth.  Allocate and deallocate\n\tvpath_list.\n\nFrom-SVN: r85886", "tree": {"sha": "406f8be5909f6d4b63c7cfda27be68b073845501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/406f8be5909f6d4b63c7cfda27be68b073845501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5/comments", "author": null, "committer": null, "parents": [{"sha": "28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e99c6271f33c9f03eb2fda746b40ab1241e3aa"}], "stats": {"total": 173, "additions": 115, "deletions": 58}, "files": [{"sha": "4e3f8d700431847e5990ff05742238afdfc76fed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f7a8132ae8f97e55dfd62d527f3d528a2a560ca5", "patch": "@@ -1,3 +1,18 @@\n+2004-08-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16273\n+\t* class.c (count_depth_data): New type.\n+\t(dfs_depth_post): New function.\n+\t(dfs_depth_q): Likewise.\n+\t(find_final_overrider_data_s): Change type of vpath.\n+\tAdd vpath_list.\n+\t(dfs_find_final_overrider_1): New function.\n+\t(dfs_find_final_overrider): Use it.\n+\t(dfs_find_final_overrider_q): Adjust use of vpath.\n+\t(dfs_find_final_overrider_post): Likewise.\n+\t(find_final_overrider): Use dfs_depth.  Allocate and deallocate\n+\tvpath_list.\n+\n 2004-08-12 Jan Beulich <jbeulich@novell.com>\n \n \t* parser.c (cp_parser_asm_definition): Properly consume scope operator"}, {"sha": "f46cdbe20d22ba7bea6906dd26df14e986cefac9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 100, "deletions": 58, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7a8132ae8f97e55dfd62d527f3d528a2a560ca5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f7a8132ae8f97e55dfd62d527f3d528a2a560ca5", "patch": "@@ -1842,6 +1842,36 @@ base_derived_from (tree derived, tree base)\n   return false;\n }\n \n+typedef struct count_depth_data {\n+  /* The depth of the current subobject, with \"1\" as the depth of the\n+     most derived object in the hierarchy.  */\n+  size_t depth;\n+  /* The maximum depth found so far.  */\n+  size_t max_depth;\n+} count_depth_data;\n+\n+/* Called from find_final_overrider via dfs_walk.  */\n+\n+static tree\n+dfs_depth_post (tree binfo ATTRIBUTE_UNUSED, void *data)\n+{\n+  count_depth_data *cd = (count_depth_data *) data;\n+  if (cd->depth > cd->max_depth)\n+    cd->max_depth = cd->depth;\n+  cd->depth--;\n+  return NULL_TREE;\n+}\n+\n+/* Called from find_final_overrider via dfs_walk.  */\n+\n+static tree\n+dfs_depth_q (tree derived, int i, void *data)\n+{\n+  count_depth_data *cd = (count_depth_data *) data;\n+  cd->depth++;\n+  return BINFO_BASE_BINFO (derived, i);\n+}\n+\n typedef struct find_final_overrider_data_s {\n   /* The function for which we are trying to find a final overrider.  */\n   tree fn;\n@@ -1851,70 +1881,73 @@ typedef struct find_final_overrider_data_s {\n   tree most_derived_type;\n   /* The candidate overriders.  */\n   tree candidates;\n-  /* Binfos which inherited virtually on the current path.  */\n-  tree vpath;\n+  /* Each entry in this array is the next-most-derived class for a\n+     virtual base class along the current path.  */\n+  tree *vpath_list;\n+  /* A pointer one past the top of the VPATH_LIST.  */\n+  tree *vpath;\n } find_final_overrider_data;\n \n-/* Called from find_final_overrider via dfs_walk.  */\n+/* Add the overrider along the current path to FFOD->CANDIDATES.\n+   Returns true if an overrider was found; false otherwise.  */\n \n-static tree\n-dfs_find_final_overrider (tree binfo, void* data)\n+static bool\n+dfs_find_final_overrider_1 (tree binfo, \n+\t\t\t    tree *vpath, \n+\t\t\t    find_final_overrider_data *ffod)\n {\n-  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n-\n-  if (binfo == ffod->declaring_base)\n+  /* If BINFO is not the most derived type, try a more derived class.\n+     A definition there will overrider a definition here.  */\n+  if (!same_type_p (BINFO_TYPE (binfo), ffod->most_derived_type))\n     {\n-      /* We've found a path to the declaring base.  Walk the path from\n-\t derived to base, looking for an overrider for FN.  */\n-      tree path, probe, vpath;\n+      tree derived;\n \n-      /* Build the path, using the inheritance chain and record of\n-\t virtual inheritance.  */\n-      for (path = NULL_TREE, probe = binfo, vpath = ffod->vpath;;)\n+      if (BINFO_VIRTUAL_P (binfo))\n+\tderived = *--vpath;\n+      else\n+\tderived = BINFO_INHERITANCE_CHAIN (binfo);\n+      if (dfs_find_final_overrider_1 (derived, vpath, ffod))\n+\treturn true;\n+    }\n+\n+  tree method = look_for_overrides_here (BINFO_TYPE (binfo), ffod->fn);\n+\t  \n+  if (method)\n+    {\n+      tree *candidate = &ffod->candidates;\n+      \n+      /* Remove any candidates overridden by this new function.  */\n+      while (*candidate)\n \t{\n-\t  path = tree_cons (NULL_TREE, probe, path);\n-\t  if (same_type_p (BINFO_TYPE (probe), ffod->most_derived_type))\n-\t    break;\n-\t  if (BINFO_VIRTUAL_P (probe))\n-\t    {\n-\t      probe = TREE_VALUE (vpath);\n-\t      vpath = TREE_CHAIN (vpath);\n-\t    }\n+\t  /* If *CANDIDATE overrides METHOD, then METHOD\n+\t     cannot override anything else on the list.  */\n+\t  if (base_derived_from (TREE_VALUE (*candidate), binfo))\n+\t    return true;\n+\t  /* If METHOD overrides *CANDIDATE, remove *CANDIDATE.  */\n+\t  if (base_derived_from (binfo, TREE_VALUE (*candidate)))\n+\t    *candidate = TREE_CHAIN (*candidate);\n \t  else\n-\t    probe = BINFO_INHERITANCE_CHAIN (probe);\n-\t}\n-      /* Now walk path, looking for overrides.  */\n-      for (; path; path = TREE_CHAIN (path))\n-\t{\n-\t  tree method = look_for_overrides_here\n-\t    (BINFO_TYPE (TREE_VALUE (path)), ffod->fn);\n-\t  \n-\t  if (method)\n-\t    {\n-\t      tree *candidate = &ffod->candidates;\n-\t      path = TREE_VALUE (path);\n-\n-\t      /* Remove any candidates overridden by this new function.  */\n-\t      while (*candidate)\n-\t\t{\n-\t\t  /* If *CANDIDATE overrides METHOD, then METHOD\n-\t\t     cannot override anything else on the list.  */\n-\t\t  if (base_derived_from (TREE_VALUE (*candidate), path))\n-\t\t    return NULL_TREE;\n-\t\t  /* If METHOD overrides *CANDIDATE, remove *CANDIDATE.  */\n-\t\t  if (base_derived_from (path, TREE_VALUE (*candidate)))\n-\t\t    *candidate = TREE_CHAIN (*candidate);\n-\t\t  else\n-\t\t    candidate = &TREE_CHAIN (*candidate);\n-\t\t}\n-\t      \n-\t      /* Add the new function.  */\n-\t      ffod->candidates = tree_cons (method, path, ffod->candidates);\n-\t      break;\n-\t    }\n+\t    candidate = &TREE_CHAIN (*candidate);\n \t}\n+      \n+      /* Add the new function.  */\n+      ffod->candidates = tree_cons (method, binfo, ffod->candidates);\n+      return true;\n     }\n \n+  return false;\n+}\n+\n+/* Called from find_final_overrider via dfs_walk.  */\n+\n+static tree\n+dfs_find_final_overrider (tree binfo, void* data)\n+{\n+  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n+\n+  if (binfo == ffod->declaring_base)\n+    dfs_find_final_overrider_1 (binfo, ffod->vpath, ffod);\n+\n   return NULL_TREE;\n }\n \n@@ -1925,7 +1958,7 @@ dfs_find_final_overrider_q (tree derived, int ix, void *data)\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n   if (BINFO_VIRTUAL_P (binfo))\n-    ffod->vpath = tree_cons (NULL_TREE, derived, ffod->vpath);\n+    *ffod->vpath++ = derived;\n   \n   return binfo;\n }\n@@ -1935,8 +1968,8 @@ dfs_find_final_overrider_post (tree binfo, void *data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-  if (BINFO_VIRTUAL_P (binfo) && TREE_CHAIN (ffod->vpath))\n-    ffod->vpath = TREE_CHAIN (ffod->vpath);\n+  if (BINFO_VIRTUAL_P (binfo))\n+    ffod->vpath--;\n   \n   return NULL_TREE;\n }\n@@ -1950,6 +1983,7 @@ static tree\n find_final_overrider (tree derived, tree binfo, tree fn)\n {\n   find_final_overrider_data ffod;\n+  count_depth_data cd;\n \n   /* Getting this right is a little tricky.  This is valid:\n \n@@ -1971,19 +2005,27 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n      different overriders along any two, then there is a problem.  */\n   if (DECL_THUNK_P (fn))\n     fn = THUNK_TARGET (fn);\n-  \n+\n+  /* Determine the depth of the hierarchy.  */\n+  cd.depth = 0;\n+  cd.max_depth = 0;\n+  dfs_walk (derived, dfs_depth_post, dfs_depth_q, &cd);\n+\n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n   ffod.most_derived_type = BINFO_TYPE (derived);\n   ffod.candidates = NULL_TREE;\n-  ffod.vpath = NULL_TREE;\n+  ffod.vpath_list = (tree *) xcalloc (cd.max_depth, sizeof (tree));\n+  ffod.vpath = ffod.vpath_list;\n \n   dfs_walk_real (derived,\n \t\t dfs_find_final_overrider,\n \t\t dfs_find_final_overrider_post,\n \t\t dfs_find_final_overrider_q,\n \t\t &ffod);\n \n+  free (ffod.vpath_list);\n+\n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n     {"}]}