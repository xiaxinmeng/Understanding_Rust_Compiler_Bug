{"sha": "9e990d143674829b6583da2ab91030abbb8257dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5OTBkMTQzNjc0ODI5YjY1ODNkYTJhYjkxMDMwYWJiYjgyNTdkYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-09-22T12:20:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-09-22T12:20:22Z"}, "message": "* ipa-inline-analysis.c: Fix overly long lines.\n\nFrom-SVN: r179084", "tree": {"sha": "90d3c92ca94d2af91d3f970f3d275f1d2fe2e808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90d3c92ca94d2af91d3f970f3d275f1d2fe2e808"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e990d143674829b6583da2ab91030abbb8257dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e990d143674829b6583da2ab91030abbb8257dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e990d143674829b6583da2ab91030abbb8257dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e990d143674829b6583da2ab91030abbb8257dc/comments", "author": null, "committer": null, "parents": [{"sha": "5ee53a067403d9cccadb7f599652581c298088b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee53a067403d9cccadb7f599652581c298088b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ee53a067403d9cccadb7f599652581c298088b3"}], "stats": {"total": 77, "additions": 49, "deletions": 28}, "files": [{"sha": "74482ede3affdfd1fe4622fab6e79d7bd481d0be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e990d143674829b6583da2ab91030abbb8257dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e990d143674829b6583da2ab91030abbb8257dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e990d143674829b6583da2ab91030abbb8257dc", "patch": "@@ -1,3 +1,7 @@\n+2011-09-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c: Fix overly long lines.\n+\n 2011-09-22  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-transform.c (inline_call): Always update jump functions"}, {"sha": "8534bf811fd67516b50dd0c2c8b1bc889c5cdca5", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e990d143674829b6583da2ab91030abbb8257dc/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e990d143674829b6583da2ab91030abbb8257dc/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9e990d143674829b6583da2ab91030abbb8257dc", "patch": "@@ -269,7 +269,8 @@ add_clause (conditions conditions, struct predicate *p, clause_t clause)\n       /* If p->clause[i] implies clause, there is nothing to add.  */\n       if ((p->clause[i] & clause) == p->clause[i])\n \t{\n-\t  /* We had nothing to add, none of clauses should've become redundant.  */\n+\t  /* We had nothing to add, none of clauses should've become\n+\t     redundant.  */\n \t  gcc_checking_assert (i == i2);\n \t  return;\n \t}\n@@ -359,7 +360,8 @@ predicates_equal_p (struct predicate *p, struct predicate *p2)\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n       gcc_checking_assert (p->clause [i] > p->clause[i + 1]);\n-      gcc_checking_assert (!p2->clause[i] || p2->clause [i] > p2->clause[i + 1]);\n+      gcc_checking_assert (!p2->clause[i]\n+\t\t\t   || p2->clause [i] > p2->clause[i + 1]);\n       if (p->clause[i] != p2->clause[i])\n         return false;\n     }\n@@ -394,8 +396,8 @@ or_predicates (conditions conditions, struct predicate *p, struct predicate *p2)\n }\n \n \n-/* Having partial truth assignment in POSSIBLE_TRUTHS, return false if predicate P\n-   to be false.  */\n+/* Having partial truth assignment in POSSIBLE_TRUTHS, return false\n+   if predicate P is known to be false.  */\n \n static bool\n evaluate_predicate (struct predicate *p, clause_t possible_truths)\n@@ -488,7 +490,8 @@ dump_predicate (FILE *f, conditions conds, struct predicate *pred)\n /* Record SIZE and TIME under condition PRED into the inline summary.  */\n \n static void\n-account_size_time (struct inline_summary *summary, int size, int time, struct predicate *pred)\n+account_size_time (struct inline_summary *summary, int size, int time,\n+\t\t   struct predicate *pred)\n {\n   size_time_entry *e;\n   bool found = false;\n@@ -523,7 +526,8 @@ account_size_time (struct inline_summary *summary, int size, int time, struct pr\n   if (dump_file && (dump_flags & TDF_DETAILS) && (time || size))\n     {\n       fprintf (dump_file, \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate:\",\n-\t       ((double)size) / INLINE_SIZE_SCALE, ((double)time) / INLINE_TIME_SCALE,\n+\t       ((double)size) / INLINE_SIZE_SCALE,\n+\t       ((double)time) / INLINE_TIME_SCALE,\n \t       found ? \"\" : \"new \");\n       dump_predicate (dump_file, summary->conds, pred);\n     }\n@@ -679,7 +683,8 @@ inline_summary_alloc (void)\n     VEC_safe_grow_cleared (inline_edge_summary_t, heap,\n \t\t\t   inline_edge_summary_vec, cgraph_edge_max_uid + 1);\n   if (!edge_predicate_pool)\n-    edge_predicate_pool = create_alloc_pool (\"edge predicates\", sizeof (struct predicate),\n+    edge_predicate_pool = create_alloc_pool (\"edge predicates\",\n+\t\t\t\t\t     sizeof (struct predicate),\n \t\t\t\t\t     10);\n }\n \n@@ -764,7 +769,8 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n       /* Remap size_time vectors.\n \t Simplify the predicate by prunning out alternatives that are known\n \t to be false.\n-\t TODO: as on optimization, we can also eliminate conditions known to be true.  */\n+\t TODO: as on optimization, we can also eliminate conditions known\n+\t to be true.  */\n       for (i = 0; VEC_iterate (size_time_entry, entry, i, e); i++)\n \t{\n \t  struct predicate new_predicate = true_predicate ();\n@@ -786,7 +792,8 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t    account_size_time (info, e->size, e->time, &new_predicate);\n \t}\n \n-      /* Remap edge predicates with the same simplificaiton as above.  */\n+      /* Remap edge predicates with the same simplification as above.\n+\t Also copy constantness arrays.   */\n       for (edge = dst->callees; edge; edge = edge->next_callee)\n \t{\n \t  struct predicate new_predicate = true_predicate ();\n@@ -817,7 +824,8 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t  *es->predicate = new_predicate;\n \t}\n \n-      /* Remap indirect edge predicates with the same simplificaiton as above.  */\n+      /* Remap indirect edge predicates with the same simplificaiton as above. \n+\t Also copy constantness arrays.   */\n       for (edge = dst->indirect_calls; edge; edge = edge->next_callee)\n \t{\n \t  struct predicate new_predicate = true_predicate ();\n@@ -977,7 +985,8 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n-      fprintf (f, \"%*sindirect call loop depth:%2i freq:%4i size:%2i time: %2i\\n\",\n+      fprintf (f, \"%*sindirect call loop depth:%2i freq:%4i size:%2i\"\n+\t       \" time: %2i\\n\",\n \t       indent, \"\",\n \t       es->loop_depth,\t\n                edge->frequency,\n@@ -989,7 +998,7 @@ dump_inline_edge_summary (FILE * f, int indent, struct cgraph_node *node,\n \t  dump_predicate (f, info->conds, es->predicate);\n \t}\n       else\n-\t  fprintf (f, \"\\n\");\n+\tfprintf (f, \"\\n\");\n     }\n }\n \n@@ -1219,8 +1228,9 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n       if (index == -1)\n \treturn;\n       code = gimple_cond_code (last);\n-      inverted_code = invert_tree_comparison (code,\n-\t\t\t\t\t      HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n+      inverted_code\n+\t = invert_tree_comparison (code,\n+\t\t\t\t   HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n@@ -1364,7 +1374,8 @@ compute_bb_predicates (struct cgraph_node *node,\n     }\n \n   /* Entry block is always executable.  */\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux = pool_alloc (edge_predicate_pool);\n+  ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n+    = pool_alloc (edge_predicate_pool);\n   *(struct predicate *)ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n     = true_predicate ();\n \n@@ -1382,10 +1393,12 @@ compute_bb_predicates (struct cgraph_node *node,\n \t    {\n \t      if (e->src->aux)\n \t\t{\n-\t\t  struct predicate this_bb_predicate = *(struct predicate *)e->src->aux;\n+\t\t  struct predicate this_bb_predicate\n+\t\t     = *(struct predicate *)e->src->aux;\n \t\t  if (e->aux)\n-\t\t    this_bb_predicate = and_predicates (summary->conds, &this_bb_predicate,\n-\t\t\t\t\t\t\t(struct predicate *)e->aux);\n+\t\t    this_bb_predicate\n+\t\t       = and_predicates (summary->conds, &this_bb_predicate,\n+\t\t\t\t\t (struct predicate *)e->aux);\n \t\t  p = or_predicates (summary->conds, &p, &this_bb_predicate);\n \t\t  if (true_predicate_p (&p))\n \t\t    break;\n@@ -1419,8 +1432,8 @@ DEF_VEC_O (predicate_t);\n DEF_VEC_ALLOC_O (predicate_t, heap);\n \n \n-/* Return predicate specifying when the STMT might have result that is not a compile\n-   time constant.  */\n+/* Return predicate specifying when the STMT might have result that is not\n+   a compile time constant.  */\n \n static struct predicate\n will_be_nonconstant_predicate (struct ipa_node_params *info,\n@@ -1625,9 +1638,9 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t mismatches in argument or return types.  */\n \t      if (edge->callee\n \t\t  && cgraph_function_or_thunk_node (edge->callee, NULL)\n-\t\t  && !gimple_check_call_matching_types (stmt,\n-\t\t\t\t\t\t\tcgraph_function_or_thunk_node (edge->callee,\n-\t\t\t\t\t\t\t\t\t\t       NULL)->decl))\n+\t\t  && !gimple_check_call_matching_types\n+\t\t       (stmt, cgraph_function_or_thunk_node (edge->callee,\n+\t\t\tNULL)->decl))\n \t\t{\n \t\t  edge->call_stmt_cannot_inline_p = true;\n \t\t  gimple_call_set_cannot_inline (stmt, true);\n@@ -1658,7 +1671,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\tfprintf (dump_file, \"\\t\\twill eliminated by inlining\\n\");\n \n \t      if (parms_info)\n-\t\tp = and_predicates (info->conds, &bb_predicate, &will_be_nonconstant);\n+\t\tp = and_predicates (info->conds, &bb_predicate,\n+\t\t\t\t    &will_be_nonconstant);\n \t      else\n \t\tp = true_predicate ();\n \n@@ -2347,19 +2361,22 @@ do_estimate_growth (struct cgraph_node *node)\n       if (!DECL_EXTERNAL (node->decl)\n \t  && cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \td.growth -= info->size;\n-      /* COMDAT functions are very often not shared across multiple units since they\n-\t come from various template instantiations.  Take this into account.  */\n+      /* COMDAT functions are very often not shared across multiple units\n+\t since they come from various template instantiations.\n+\t Take this into account.  */\n       else  if (DECL_COMDAT (node->decl)\n \t\t&& cgraph_can_remove_if_no_direct_calls_p (node))\n \td.growth -= (info->size\n-\t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n+\t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n+\t\t     + 50) / 100;\n     }\n \n   if (node_growth_cache)\n     {\n       if ((int)VEC_length (int, node_growth_cache) <= node->uid)\n \tVEC_safe_grow_cleared (int, heap, node_growth_cache, cgraph_max_uid);\n-      VEC_replace (int, node_growth_cache, node->uid, d.growth + (d.growth >= 0));\n+      VEC_replace (int, node_growth_cache, node->uid,\n+\t\t   d.growth + (d.growth >= 0));\n     }\n   return d.growth;\n }"}]}