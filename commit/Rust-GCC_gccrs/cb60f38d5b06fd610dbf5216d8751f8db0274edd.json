{"sha": "cb60f38d5b06fd610dbf5216d8751f8db0274edd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I2MGYzOGQ1YjA2ZmQ2MTBkYmY1MjE2ZDg3NTFmOGRiMDI3NGVkZA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-03-11T06:42:21Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-03-11T06:42:21Z"}, "message": "Makefile.in: Update.\n\n\t* Makefile.in: Update.\n\t* c-common.c: Don't include real.h or except.h.\n\t(REGISTER_PREFIX): Remove.\n\t(builtin_define_std, builtin_define_with_value,\n\tbuiltin_define_with_int_value, builtin_define_with_hex_fp_value,\n\tbuiltin_define_type_max, builtin_define_type_precision,\n\tbuiltin_define_float_constants): Move to c-cppbuiltin.c.\n\t(c_stddef_cpp_builtins): New.\n\t* c-common.h (builtin_define_with_value, c_stddef_cpp_builtins): New.\n\t* c-cppbuiltin.c: New, extracted from c-common.c.\n\t(define__GNUC__): New.\n\t* cppspec.c (lang_specific_driver): Remove support of -no-gcc.\n\t* gcc.c: Remove support of %v1, %v2 and %v3 specs.\n\t(cpp_unique_options): Don't support no-gcc.\n\t(do_spec_1): Remove support of version specs.\n\t* doc/invoke.texi: Remove documentation of %v1, %v2 and %v3.\n\t* doc/passes.texi: Update.\n\t* doc/tm.texi: Update.\ncp:\n\t* Make-lang.in (CXX_C_OBJS): Update.\n\t* lang-specs.h: Don't define __GNUG__ here.\n\nFrom-SVN: r64162", "tree": {"sha": "4a61a1ebad36b280444ec7dd62765959ac5bd940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a61a1ebad36b280444ec7dd62765959ac5bd940"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb60f38d5b06fd610dbf5216d8751f8db0274edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb60f38d5b06fd610dbf5216d8751f8db0274edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb60f38d5b06fd610dbf5216d8751f8db0274edd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb60f38d5b06fd610dbf5216d8751f8db0274edd/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5858cd26b2a70d195dd6cac584a154a6550d8cf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5858cd26b2a70d195dd6cac584a154a6550d8cf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5858cd26b2a70d195dd6cac584a154a6550d8cf0"}], "stats": {"total": 1192, "additions": 623, "deletions": 569}, "files": [{"sha": "1d595301e73e438a9ec6571124eee0872525b489", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -1,3 +1,24 @@\n+2003-03-11  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in: Update.\n+\t* c-common.c: Don't include real.h or except.h.\n+\t(REGISTER_PREFIX): Remove.\n+\t(builtin_define_std, builtin_define_with_value,\n+\tbuiltin_define_with_int_value, builtin_define_with_hex_fp_value,\n+\tbuiltin_define_type_max, builtin_define_type_precision,\n+\tbuiltin_define_float_constants): Move to c-cppbuiltin.c.\n+\t(c_stddef_cpp_builtins): New.\n+\t* c-common.h (builtin_define_with_value, c_stddef_cpp_builtins): New.\n+\t* c-cppbuiltin.c: New, extracted from c-common.c.\n+\t(define__GNUC__): New.\n+\t* cppspec.c (lang_specific_driver): Remove support of -no-gcc.\n+\t* gcc.c: Remove support of %v1, %v2 and %v3 specs.\n+\t(cpp_unique_options): Don't support no-gcc.\n+\t(do_spec_1): Remove support of version specs.\n+\t* doc/invoke.texi: Remove documentation of %v1, %v2 and %v3.\n+\t* doc/passes.texi: Update.\n+\t* doc/tm.texi: Update.\n+\n 2003-03-10  Aldy Hernandez  <aldyh@redhat.com>\n \n         * dwarf2out.c (multiple_reg_loc_descriptor): Fix thinko."}, {"sha": "967ff381dcacad1ac268db03854ef1ec2b0d5799", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -760,7 +760,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n-  c-incpath.o cppdefault.o c-ppoutput.o \\\n+  c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o \\\n   c-objc-common.o c-dump.o c-pch.o libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n@@ -1273,16 +1273,20 @@ tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h\n # A file used by all variants of C.\n \n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-\t$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) \\\n-\t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \\\n-\tdiagnostic.h except.h gt-c-common.h real.h langhooks.h varray.h\n+\t$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h \\\n+\t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \\\n+\tdiagnostic.h gt-c-common.h langhooks.h varray.h $(RTL_H) $(TARGET_H)\n c-pretty-print.o : c-pretty-print.c c-pretty-print.h pretty-print.h \\\n \t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h\n \n c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_COMMON_H) \\\n         c-pragma.h flags.h toplev.h langhooks.h tree-inline.h diagnostic.h \\\n \tintl.h\n \n+c-cppbuiltin.o : c-cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+\t$(TREE_H) $(C_COMMON_H) c-pragma.h flags.h toplev.h langhooks.h \\\n+\toutput.h except.h real.h\n+\n # A file used by all variants of C and some other languages.\n \n attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flags.h \\"}, {"sha": "00654309f1f8367768376fe114939a6e4e4a22ab", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 468, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines shared by all languages that are variants of C.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002 Free Software Foundation, Inc.\n+   2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -24,7 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"real.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n@@ -40,9 +39,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cpplib.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n-#include \"except.h\"\t\t/* For USING_SJLJ_EXCEPTIONS.  */\n #include \"tree-inline.h\"\n \n+\n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n /* We let tm.h override the types used here, to handle trivial differences\n@@ -87,10 +86,6 @@ cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \t\t\t: \"long long unsigned int\"))\n #endif\n \n-#ifndef REGISTER_PREFIX\n-#define REGISTER_PREFIX \"\"\n-#endif\n-\n /* The variant of the C language being processed.  */\n \n enum c_language_kind c_language;\n@@ -806,18 +801,6 @@ static void check_nonnull_arg\t\tPARAMS ((void *, tree,\n static bool nonnull_check_p\t\tPARAMS ((tree, unsigned HOST_WIDE_INT));\n static bool get_nonnull_operand\t\tPARAMS ((tree,\n \t\t\t\t\t\t unsigned HOST_WIDE_INT *));\n-void builtin_define_std PARAMS ((const char *));\n-static void builtin_define_with_value PARAMS ((const char *, const char *,\n-                                               int));\n-static void builtin_define_with_int_value PARAMS ((const char *,\n-\t\t\t\t\t\t   HOST_WIDE_INT));\n-static void builtin_define_with_hex_fp_value PARAMS ((const char *, tree,\n-\t\t\t\t\t\t      int, const char *,\n-\t\t\t\t\t\t      const char *));\n-static void builtin_define_type_max PARAMS ((const char *, tree, int));\n-static void builtin_define_type_precision PARAMS ((const char *, tree));\n-static void builtin_define_float_constants PARAMS ((const char *,\n-\t\t\t\t\t\t    const char *, tree));\n \n /* Table of machine-independent attributes common to all C-like languages.  */\n const struct attribute_spec c_common_attribute_table[] =\n@@ -4761,461 +4744,15 @@ boolean_increment (code, arg)\n   return val;\n }\n \f\n-/* Define NAME with value TYPE precision.  */\n-static void\n-builtin_define_type_precision (name, type)\n-     const char *name;\n-     tree type;\n-{\n-  builtin_define_with_int_value (name, TYPE_PRECISION (type));\n-}\n-\n-/* Define the float.h constants for TYPE using NAME_PREFIX and FP_SUFFIX.  */\n-static void\n-builtin_define_float_constants (name_prefix, fp_suffix, type)\n-     const char *name_prefix;\n-     const char *fp_suffix;\n-     tree type;\n-{\n-  /* Used to convert radix-based values to base 10 values in several cases.\n-\n-     In the max_exp -> max_10_exp conversion for 128-bit IEEE, we need at\n-     least 6 significant digits for correct results.  Using the fraction\n-     formed by (log(2)*1e6)/(log(10)*1e6) overflows a 32-bit integer as an\n-     intermediate; perhaps someone can find a better approximation, in the\n-     mean time, I suspect using doubles won't harm the bootstrap here.  */\n-\n-  const double log10_2 = .30102999566398119521;\n-  double log10_b;\n-  const struct real_format *fmt;\n-\n-  char name[64], buf[128];\n-  int dig, min_10_exp, max_10_exp;\n-  int decimal_dig;\n-\n-  fmt = real_format_for_mode[TYPE_MODE (type) - QFmode];\n-\n-  /* The radix of the exponent representation.  */\n-  if (type == float_type_node)\n-    builtin_define_with_int_value (\"__FLT_RADIX__\", fmt->b);\n-  log10_b = log10_2 * fmt->log2_b;\n-\n-  /* The number of radix digits, p, in the floating-point significand.  */\n-  sprintf (name, \"__%s_MANT_DIG__\", name_prefix);\n-  builtin_define_with_int_value (name, fmt->p);\n-\n-  /* The number of decimal digits, q, such that any floating-point number\n-     with q decimal digits can be rounded into a floating-point number with\n-     p radix b digits and back again without change to the q decimal digits,\n-\n-\tp log10 b\t\t\tif b is a power of 10\n- \tfloor((p - 1) log10 b)\t\totherwise\n-  */\n-  dig = (fmt->p - 1) * log10_b;\n-  sprintf (name, \"__%s_DIG__\", name_prefix);\n-  builtin_define_with_int_value (name, dig);\n-\n-  /* The minimum negative int x such that b**(x-1) is a normalized float.  */\n-  sprintf (name, \"__%s_MIN_EXP__\", name_prefix);\n-  sprintf (buf, \"(%d)\", fmt->emin);\n-  builtin_define_with_value (name, buf, 0);\n-\n-  /* The minimum negative int x such that 10**x is a normalized float,\n-\n-\t  ceil (log10 (b ** (emin - 1)))\n-\t= ceil (log10 (b) * (emin - 1))\n-\n-     Recall that emin is negative, so the integer truncation calculates\n-     the ceiling, not the floor, in this case.  */\n-  min_10_exp = (fmt->emin - 1) * log10_b;\n-  sprintf (name, \"__%s_MIN_10_EXP__\", name_prefix);\n-  sprintf (buf, \"(%d)\", min_10_exp);\n-  builtin_define_with_value (name, buf, 0);\n-\n-  /* The maximum int x such that b**(x-1) is a representable float.  */\n-  sprintf (name, \"__%s_MAX_EXP__\", name_prefix);\n-  builtin_define_with_int_value (name, fmt->emax);\n-\n-  /* The maximum int x such that 10**x is in the range of representable\n-     finite floating-point numbers,\n-\n-\t  floor (log10((1 - b**-p) * b**emax))\n-\t= floor (log10(1 - b**-p) + log10(b**emax))\n-\t= floor (log10(1 - b**-p) + log10(b)*emax)\n-\n-     The safest thing to do here is to just compute this number.  But since\n-     we don't link cc1 with libm, we cannot.  We could implement log10 here\n-     a series expansion, but that seems too much effort because:\n-\n-     Note that the first term, for all extant p, is a number exceedingly close\n-     to zero, but slightly negative.  Note that the second term is an integer\n-     scaling an irrational number, and that because of the floor we are only\n-     interested in its integral portion.\n-\n-     In order for the first term to have any effect on the integral portion\n-     of the second term, the second term has to be exceedingly close to an\n-     integer itself (e.g. 123.000000000001 or something).  Getting a result\n-     that close to an integer requires that the irrational multiplicand have\n-     a long series of zeros in its expansion, which doesn't occur in the\n-     first 20 digits or so of log10(b).\n-\n-     Hand-waving aside, crunching all of the sets of constants above by hand\n-     does not yield a case for which the first term is significant, which\n-     in the end is all that matters.  */\n-  max_10_exp = fmt->emax * log10_b;\n-  sprintf (name, \"__%s_MAX_10_EXP__\", name_prefix);\n-  builtin_define_with_int_value (name, max_10_exp);\n-\n-  /* The number of decimal digits, n, such that any floating-point number\n-     can be rounded to n decimal digits and back again without change to\n-     the value. \n-\n-\tp * log10(b)\t\t\tif b is a power of 10\n-\tceil(1 + p * log10(b))\t\totherwise\n-\n-     The only macro we care about is this number for the widest supported\n-     floating type, but we want this value for rendering constants below.  */\n-  {\n-    double d_decimal_dig = 1 + fmt->p * log10_b;\n-    decimal_dig = d_decimal_dig;\n-    if (decimal_dig < d_decimal_dig)\n-      decimal_dig++;\n-  }\n-  if (type == long_double_type_node)\n-    builtin_define_with_int_value (\"__DECIMAL_DIG__\", decimal_dig);\n-\n-  /* Since, for the supported formats, B is always a power of 2, we\n-     construct the following numbers directly as a hexadecimal\n-     constants.  */\n-\n-  /* The maximum representable finite floating-point number,\n-     (1 - b**-p) * b**emax  */\n-  {\n-    int i, n;\n-    char *p;\n-\n-    strcpy (buf, \"0x0.\");\n-    n = fmt->p * fmt->log2_b;\n-    for (i = 0, p = buf + 4; i + 3 < n; i += 4)\n-      *p++ = 'f';\n-    if (i < n)\n-      *p++ = \"08ce\"[n - i];\n-    sprintf (p, \"p%d\", fmt->emax * fmt->log2_b);\n-  }\n-  sprintf (name, \"__%s_MAX__\", name_prefix);\n-  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n-\n-  /* The minimum normalized positive floating-point number,\n-     b**(emin-1).  */\n-  sprintf (name, \"__%s_MIN__\", name_prefix);\n-  sprintf (buf, \"0x1p%d\", (fmt->emin - 1) * fmt->log2_b);\n-  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n-\n-  /* The difference between 1 and the least value greater than 1 that is\n-     representable in the given floating point type, b**(1-p).  */\n-  sprintf (name, \"__%s_EPSILON__\", name_prefix);\n-  sprintf (buf, \"0x1p%d\", (1 - fmt->p) * fmt->log2_b);\n-  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n-\n-  /* For C++ std::numeric_limits<T>::denorm_min.  The minimum denormalized\n-     positive floating-point number, b**(emin-p).  Zero for formats that\n-     don't support denormals.  */\n-  sprintf (name, \"__%s_DENORM_MIN__\", name_prefix);\n-  if (fmt->has_denorm)\n-    {\n-      sprintf (buf, \"0x1p%d\", (fmt->emin - fmt->p) * fmt->log2_b);\n-      builtin_define_with_hex_fp_value (name, type, decimal_dig,\n-\t\t\t\t\tbuf, fp_suffix);\n-    }\n-  else\n-    {\n-      sprintf (buf, \"0.0%s\", fp_suffix);\n-      builtin_define_with_value (name, buf, 0);\n-    }\n-\n-  /* For C++ std::numeric_limits<T>::has_infinity.  */\n-  sprintf (name, \"__%s_HAS_INFINITY__\", name_prefix);\n-  builtin_define_with_int_value (name, \n-\t\t\t\t MODE_HAS_INFINITIES (TYPE_MODE (type)));\n-  /* For C++ std::numeric_limits<T>::has_quiet_NaN.  We do not have a\n-     predicate to distinguish a target that has both quiet and\n-     signalling NaNs from a target that has only quiet NaNs or only\n-     signalling NaNs, so we assume that a target that has any kind of\n-     NaN has quiet NaNs.  */\n-  sprintf (name, \"__%s_HAS_QUIET_NAN__\", name_prefix);\n-  builtin_define_with_int_value (name, MODE_HAS_NANS (TYPE_MODE (type)));\n-}\n-\n-/* Hook that registers front end and target-specific built-ins.  */\n+/* Built-in macros for stddef.h, that require macros defined in this\n+   file.  */\n void\n-cb_register_builtins (pfile)\n-     cpp_reader *pfile;\n+c_stddef_cpp_builtins()\n {\n-  /* -undef turns off target-specific built-ins.  */\n-  if (flag_undef)\n-    return;\n-\n-  if (c_language == clk_cplusplus)\n-    {\n-      if (SUPPORTS_ONE_ONLY)\n-\tcpp_define (pfile, \"__GXX_WEAK__=1\");\n-      else\n-\tcpp_define (pfile, \"__GXX_WEAK__=0\");\n-      if (flag_exceptions)\n-\tcpp_define (pfile, \"__EXCEPTIONS\");\n-      if (warn_deprecated)\n-\tcpp_define (pfile, \"__DEPRECATED\");\n-    }\n-\n-  /* represents the C++ ABI version, always defined so it can be used while\n-     preprocessing C and assembler.  */\n-  cpp_define (pfile, \"__GXX_ABI_VERSION=102\");\n-\n-  /* libgcc needs to know this.  */\n-  if (USING_SJLJ_EXCEPTIONS)\n-    cpp_define (pfile, \"__USING_SJLJ_EXCEPTIONS__\");\n-\n-  /* stddef.h needs to know these.  */\n   builtin_define_with_value (\"__SIZE_TYPE__\", SIZE_TYPE, 0);\n   builtin_define_with_value (\"__PTRDIFF_TYPE__\", PTRDIFF_TYPE, 0);\n   builtin_define_with_value (\"__WCHAR_TYPE__\", MODIFIED_WCHAR_TYPE, 0);\n   builtin_define_with_value (\"__WINT_TYPE__\", WINT_TYPE, 0);\n-\n-  /* limits.h needs to know these.  */\n-  builtin_define_type_max (\"__SCHAR_MAX__\", signed_char_type_node, 0);\n-  builtin_define_type_max (\"__SHRT_MAX__\", short_integer_type_node, 0);\n-  builtin_define_type_max (\"__INT_MAX__\", integer_type_node, 0);\n-  builtin_define_type_max (\"__LONG_MAX__\", long_integer_type_node, 1);\n-  builtin_define_type_max (\"__LONG_LONG_MAX__\", long_long_integer_type_node, 2);\n-  builtin_define_type_max (\"__WCHAR_MAX__\", wchar_type_node, 0);\n-\n-  builtin_define_type_precision (\"__CHAR_BIT__\", char_type_node);\n-\n-  /* float.h needs to know these.  */\n-\n-  builtin_define_with_int_value (\"__FLT_EVAL_METHOD__\",\n-\t\t\t\t TARGET_FLT_EVAL_METHOD);\n-\n-  builtin_define_float_constants (\"FLT\", \"F\", float_type_node);\n-  builtin_define_float_constants (\"DBL\", \"\", double_type_node);\n-  builtin_define_float_constants (\"LDBL\", \"L\", long_double_type_node);\n-\n-  /* For use in assembly language.  */\n-  builtin_define_with_value (\"__REGISTER_PREFIX__\", REGISTER_PREFIX, 0);\n-  builtin_define_with_value (\"__USER_LABEL_PREFIX__\", user_label_prefix, 0);\n-\n-  /* Misc.  */\n-  builtin_define_with_value (\"__VERSION__\", version_string, 1);\n-\n-  /* Other target-independent built-ins determined by command-line\n-     options.  */\n-  if (optimize_size)\n-    cpp_define (pfile, \"__OPTIMIZE_SIZE__\");\n-  if (optimize)\n-    cpp_define (pfile, \"__OPTIMIZE__\");\n-\n-  if (flag_hosted)\n-    cpp_define (pfile, \"__STDC_HOSTED__=1\");\n-  else\n-    cpp_define (pfile, \"__STDC_HOSTED__=0\");\n-\n-  if (fast_math_flags_set_p ())\n-    cpp_define (pfile, \"__FAST_MATH__\");\n-  if (flag_really_no_inline)\n-    cpp_define (pfile, \"__NO_INLINE__\");\n-  if (flag_signaling_nans)\n-    cpp_define (pfile, \"__SUPPORT_SNAN__\");\n-  if (flag_finite_math_only)\n-    cpp_define (pfile, \"__FINITE_MATH_ONLY__=1\");\n-  else\n-    cpp_define (pfile, \"__FINITE_MATH_ONLY__=0\");\n-\n-  if (flag_iso)\n-    cpp_define (pfile, \"__STRICT_ANSI__\");\n-\n-  if (!flag_signed_char)\n-    cpp_define (pfile, \"__CHAR_UNSIGNED__\");\n-\n-  if (c_language == clk_cplusplus && TREE_UNSIGNED (wchar_type_node))\n-    cpp_define (pfile, \"__WCHAR_UNSIGNED__\");\n-\n-  /* Make the choice of ObjC runtime visible to source code.  */\n-  if (flag_objc && flag_next_runtime)\n-    cpp_define (pfile, \"__NEXT_RUNTIME__\");\n-\n-  /* A straightforward target hook doesn't work, because of problems\n-     linking that hook's body when part of non-C front ends.  */\n-# define preprocessing_asm_p() (cpp_get_options (pfile)->lang == CLK_ASM)\n-# define preprocessing_trad_p() (cpp_get_options (pfile)->traditional)\n-# define builtin_define(TXT) cpp_define (pfile, TXT)\n-# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n-  TARGET_CPU_CPP_BUILTINS ();\n-  TARGET_OS_CPP_BUILTINS ();\n-}\n-\n-/* Pass an object-like macro.  If it doesn't lie in the user's\n-   namespace, defines it unconditionally.  Otherwise define a version\n-   with two leading underscores, and another version with two leading\n-   and trailing underscores, and define the original only if an ISO\n-   standard was not nominated.\n-\n-   e.g. passing \"unix\" defines \"__unix\", \"__unix__\" and possibly\n-   \"unix\".  Passing \"_mips\" defines \"__mips\", \"__mips__\" and possibly\n-   \"_mips\".  */\n-void\n-builtin_define_std (macro)\n-     const char *macro;\n-{\n-  size_t len = strlen (macro);\n-  char *buff = alloca (len + 5);\n-  char *p = buff + 2;\n-  char *q = p + len;\n-\n-  /* prepend __ (or maybe just _) if in user's namespace.  */\n-  memcpy (p, macro, len + 1);\n-  if (!( *p == '_' && (p[1] == '_' || ISUPPER (p[1]))))\n-    {\n-      if (*p != '_')\n-\t*--p = '_';\n-      if (p[1] != '_')\n-\t*--p = '_';\n-    }\n-  cpp_define (parse_in, p);\n-\n-  /* If it was in user's namespace...  */\n-  if (p != buff + 2)\n-    {\n-      /* Define the macro with leading and following __.  */\n-      if (q[-1] != '_')\n-\t*q++ = '_';\n-      if (q[-2] != '_')\n-\t*q++ = '_';\n-      *q = '\\0';\n-      cpp_define (parse_in, p);\n-\n-      /* Finally, define the original macro if permitted.  */\n-      if (!flag_iso)\n-\tcpp_define (parse_in, macro);\n-    }\n-}\n-\n-/* Pass an object-like macro and a value to define it to.  The third\n-   parameter says whether or not to turn the value into a string\n-   constant.  */\n-static void\n-builtin_define_with_value (macro, expansion, is_str)\n-     const char *macro;\n-     const char *expansion;\n-     int is_str;\n-{\n-  char *buf;\n-  size_t mlen = strlen (macro);\n-  size_t elen = strlen (expansion);\n-  size_t extra = 2;  /* space for an = and a NUL */\n-\n-  if (is_str)\n-    extra += 2;  /* space for two quote marks */\n-\n-  buf = alloca (mlen + elen + extra);\n-  if (is_str)\n-    sprintf (buf, \"%s=\\\"%s\\\"\", macro, expansion);\n-  else\n-    sprintf (buf, \"%s=%s\", macro, expansion);\n-\n-  cpp_define (parse_in, buf);\n-}\n-\n-/* Pass an object-like macro and an integer value to define it to.  */\n-static void\n-builtin_define_with_int_value (macro, value)\n-     const char *macro;\n-     HOST_WIDE_INT value;\n-{\n-  char *buf;\n-  size_t mlen = strlen (macro);\n-  size_t vlen = 18;\n-  size_t extra = 2; /* space for = and NUL.  */\n-\n-  buf = alloca (mlen + vlen + extra);\n-  memcpy (buf, macro, mlen);\n-  buf[mlen] = '=';\n-  sprintf (buf + mlen + 1, HOST_WIDE_INT_PRINT_DEC, value);\n-\n-  cpp_define (parse_in, buf);\n-}\n-\n-/* Pass an object-like macro a hexadecimal floating-point value.  */\n-static void\n-builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n-     const char *macro;\n-     tree type ATTRIBUTE_UNUSED;\n-     int digits;\n-     const char *hex_str;\n-     const char *fp_suffix;\n-{\n-  REAL_VALUE_TYPE real;\n-  char dec_str[64], buf[256];\n-\n-  /* Hex values are really cool and convenient, except that they're\n-     not supported in strict ISO C90 mode.  First, the \"p-\" sequence\n-     is not valid as part of a preprocessor number.  Second, we get a\n-     pedwarn from the preprocessor, which has no context, so we can't\n-     suppress the warning with __extension__.\n-\n-     So instead what we do is construct the number in hex (because \n-     it's easy to get the exact correct value), parse it as a real,\n-     then print it back out as decimal.  */\n-\n-  real_from_string (&real, hex_str);\n-  real_to_decimal (dec_str, &real, sizeof (dec_str), digits, 0);\n-\n-  sprintf (buf, \"%s=%s%s\", macro, dec_str, fp_suffix);\n-  cpp_define (parse_in, buf);\n-}\n-\n-/* Define MAX for TYPE based on the precision of the type.  IS_LONG is\n-   1 for type \"long\" and 2 for \"long long\".  We have to handle\n-   unsigned types, since wchar_t might be unsigned.  */\n-\n-static void\n-builtin_define_type_max (macro, type, is_long)\n-     const char *macro;\n-     tree type;\n-     int is_long;\n-{\n-  static const char *const values[]\n-    = { \"127\", \"255\",\n-\t\"32767\", \"65535\",\n-\t\"2147483647\", \"4294967295\",\n-\t\"9223372036854775807\", \"18446744073709551615\",\n-\t\"170141183460469231731687303715884105727\",\n-\t\"340282366920938463463374607431768211455\" };\n-  static const char *const suffixes[] = { \"\", \"U\", \"L\", \"UL\", \"LL\", \"ULL\" };\n-\n-  const char *value, *suffix;\n-  char *buf;\n-  size_t idx;\n-\n-  /* Pre-rendering the values mean we don't have to futz with printing a\n-     multi-word decimal value.  There are also a very limited number of\n-     precisions that we support, so it's really a waste of time.  */\n-  switch (TYPE_PRECISION (type))\n-    {\n-    case 8:\tidx = 0; break;\n-    case 16:\tidx = 2; break;\n-    case 32:\tidx = 4; break;\n-    case 64:\tidx = 6; break;\n-    case 128:\tidx = 8; break;\n-    default:    abort ();\n-    }\n-\n-  value = values[idx + TREE_UNSIGNED (type)];\n-  suffix = suffixes[is_long * 2 + TREE_UNSIGNED (type)];\n-\n-  buf = alloca (strlen (macro) + 1 + strlen (value) + strlen (suffix) + 1);\n-  sprintf (buf, \"%s=%s%s\", macro, value, suffix);\n-\n-  cpp_define (parse_in, buf);\n }\n \n static void"}, {"sha": "ddd557da09c69f76e8016e270b5785a99eea2245", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -1292,6 +1292,9 @@ extern void c_common_read_pch\t\t\tPARAMS ((cpp_reader *pfile,\n \t\t\t\t\t\t\t int fd,\n \t\t\t\t\t\t\t const char *orig));\n extern void c_common_write_pch\t\t\tPARAMS ((void));\n+extern void builtin_define_with_value\t\tPARAMS ((const char *,\n+\t\t\t\t\t\t\t const char *, int));\n+extern void c_stddef_cpp_builtins\t\tPARAMS ((void));\n \n /* In c-ppoutput.c  */\n extern void init_pp_output\t\t\tPARAMS ((FILE *));"}, {"sha": "adbefd0894a26aac2af37d232e788c752aa7a2ed", "filename": "gcc/c-cppbuiltin.c", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -0,0 +1,570 @@\n+/* Define builtin-in macros for the C family front ends.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"real.h\"\n+#include \"c-common.h\"\n+#include \"c-pragma.h\"\n+#include \"output.h\"\n+#include \"except.h\"\t\t/* For USING_SJLJ_EXCEPTIONS.  */\n+#include \"toplev.h\"\n+\n+#ifndef REGISTER_PREFIX\n+#define REGISTER_PREFIX \"\"\n+#endif\n+\n+static void builtin_define_std PARAMS ((const char *));\n+static void builtin_define_with_value_n PARAMS ((const char *, const char *,\n+\t\t\t\t\t\t size_t));\n+static void builtin_define_with_int_value PARAMS ((const char *,\n+\t\t\t\t\t\t   HOST_WIDE_INT));\n+static void builtin_define_with_hex_fp_value PARAMS ((const char *, tree,\n+\t\t\t\t\t\t      int, const char *,\n+\t\t\t\t\t\t      const char *));\n+static void builtin_define_type_max PARAMS ((const char *, tree, int));\n+static void builtin_define_type_precision PARAMS ((const char *, tree));\n+static void builtin_define_float_constants PARAMS ((const char *,\n+\t\t\t\t\t\t    const char *, tree));\n+static void define__GNUC__\t\tPARAMS ((void));\n+\n+/* Define NAME with value TYPE precision.  */\n+static void\n+builtin_define_type_precision (name, type)\n+     const char *name;\n+     tree type;\n+{\n+  builtin_define_with_int_value (name, TYPE_PRECISION (type));\n+}\n+\n+/* Define the float.h constants for TYPE using NAME_PREFIX and FP_SUFFIX.  */\n+static void\n+builtin_define_float_constants (name_prefix, fp_suffix, type)\n+     const char *name_prefix;\n+     const char *fp_suffix;\n+     tree type;\n+{\n+  /* Used to convert radix-based values to base 10 values in several cases.\n+\n+     In the max_exp -> max_10_exp conversion for 128-bit IEEE, we need at\n+     least 6 significant digits for correct results.  Using the fraction\n+     formed by (log(2)*1e6)/(log(10)*1e6) overflows a 32-bit integer as an\n+     intermediate; perhaps someone can find a better approximation, in the\n+     mean time, I suspect using doubles won't harm the bootstrap here.  */\n+\n+  const double log10_2 = .30102999566398119521;\n+  double log10_b;\n+  const struct real_format *fmt;\n+\n+  char name[64], buf[128];\n+  int dig, min_10_exp, max_10_exp;\n+  int decimal_dig;\n+\n+  fmt = real_format_for_mode[TYPE_MODE (type) - QFmode];\n+\n+  /* The radix of the exponent representation.  */\n+  if (type == float_type_node)\n+    builtin_define_with_int_value (\"__FLT_RADIX__\", fmt->b);\n+  log10_b = log10_2 * fmt->log2_b;\n+\n+  /* The number of radix digits, p, in the floating-point significand.  */\n+  sprintf (name, \"__%s_MANT_DIG__\", name_prefix);\n+  builtin_define_with_int_value (name, fmt->p);\n+\n+  /* The number of decimal digits, q, such that any floating-point number\n+     with q decimal digits can be rounded into a floating-point number with\n+     p radix b digits and back again without change to the q decimal digits,\n+\n+\tp log10 b\t\t\tif b is a power of 10\n+ \tfloor((p - 1) log10 b)\t\totherwise\n+  */\n+  dig = (fmt->p - 1) * log10_b;\n+  sprintf (name, \"__%s_DIG__\", name_prefix);\n+  builtin_define_with_int_value (name, dig);\n+\n+  /* The minimum negative int x such that b**(x-1) is a normalized float.  */\n+  sprintf (name, \"__%s_MIN_EXP__\", name_prefix);\n+  sprintf (buf, \"(%d)\", fmt->emin);\n+  builtin_define_with_value (name, buf, 0);\n+\n+  /* The minimum negative int x such that 10**x is a normalized float,\n+\n+\t  ceil (log10 (b ** (emin - 1)))\n+\t= ceil (log10 (b) * (emin - 1))\n+\n+     Recall that emin is negative, so the integer truncation calculates\n+     the ceiling, not the floor, in this case.  */\n+  min_10_exp = (fmt->emin - 1) * log10_b;\n+  sprintf (name, \"__%s_MIN_10_EXP__\", name_prefix);\n+  sprintf (buf, \"(%d)\", min_10_exp);\n+  builtin_define_with_value (name, buf, 0);\n+\n+  /* The maximum int x such that b**(x-1) is a representable float.  */\n+  sprintf (name, \"__%s_MAX_EXP__\", name_prefix);\n+  builtin_define_with_int_value (name, fmt->emax);\n+\n+  /* The maximum int x such that 10**x is in the range of representable\n+     finite floating-point numbers,\n+\n+\t  floor (log10((1 - b**-p) * b**emax))\n+\t= floor (log10(1 - b**-p) + log10(b**emax))\n+\t= floor (log10(1 - b**-p) + log10(b)*emax)\n+\n+     The safest thing to do here is to just compute this number.  But since\n+     we don't link cc1 with libm, we cannot.  We could implement log10 here\n+     a series expansion, but that seems too much effort because:\n+\n+     Note that the first term, for all extant p, is a number exceedingly close\n+     to zero, but slightly negative.  Note that the second term is an integer\n+     scaling an irrational number, and that because of the floor we are only\n+     interested in its integral portion.\n+\n+     In order for the first term to have any effect on the integral portion\n+     of the second term, the second term has to be exceedingly close to an\n+     integer itself (e.g. 123.000000000001 or something).  Getting a result\n+     that close to an integer requires that the irrational multiplicand have\n+     a long series of zeros in its expansion, which doesn't occur in the\n+     first 20 digits or so of log10(b).\n+\n+     Hand-waving aside, crunching all of the sets of constants above by hand\n+     does not yield a case for which the first term is significant, which\n+     in the end is all that matters.  */\n+  max_10_exp = fmt->emax * log10_b;\n+  sprintf (name, \"__%s_MAX_10_EXP__\", name_prefix);\n+  builtin_define_with_int_value (name, max_10_exp);\n+\n+  /* The number of decimal digits, n, such that any floating-point number\n+     can be rounded to n decimal digits and back again without change to\n+     the value. \n+\n+\tp * log10(b)\t\t\tif b is a power of 10\n+\tceil(1 + p * log10(b))\t\totherwise\n+\n+     The only macro we care about is this number for the widest supported\n+     floating type, but we want this value for rendering constants below.  */\n+  {\n+    double d_decimal_dig = 1 + fmt->p * log10_b;\n+    decimal_dig = d_decimal_dig;\n+    if (decimal_dig < d_decimal_dig)\n+      decimal_dig++;\n+  }\n+  if (type == long_double_type_node)\n+    builtin_define_with_int_value (\"__DECIMAL_DIG__\", decimal_dig);\n+\n+  /* Since, for the supported formats, B is always a power of 2, we\n+     construct the following numbers directly as a hexadecimal\n+     constants.  */\n+\n+  /* The maximum representable finite floating-point number,\n+     (1 - b**-p) * b**emax  */\n+  {\n+    int i, n;\n+    char *p;\n+\n+    strcpy (buf, \"0x0.\");\n+    n = fmt->p * fmt->log2_b;\n+    for (i = 0, p = buf + 4; i + 3 < n; i += 4)\n+      *p++ = 'f';\n+    if (i < n)\n+      *p++ = \"08ce\"[n - i];\n+    sprintf (p, \"p%d\", fmt->emax * fmt->log2_b);\n+  }\n+  sprintf (name, \"__%s_MAX__\", name_prefix);\n+  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n+\n+  /* The minimum normalized positive floating-point number,\n+     b**(emin-1).  */\n+  sprintf (name, \"__%s_MIN__\", name_prefix);\n+  sprintf (buf, \"0x1p%d\", (fmt->emin - 1) * fmt->log2_b);\n+  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n+\n+  /* The difference between 1 and the least value greater than 1 that is\n+     representable in the given floating point type, b**(1-p).  */\n+  sprintf (name, \"__%s_EPSILON__\", name_prefix);\n+  sprintf (buf, \"0x1p%d\", (1 - fmt->p) * fmt->log2_b);\n+  builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix);\n+\n+  /* For C++ std::numeric_limits<T>::denorm_min.  The minimum denormalized\n+     positive floating-point number, b**(emin-p).  Zero for formats that\n+     don't support denormals.  */\n+  sprintf (name, \"__%s_DENORM_MIN__\", name_prefix);\n+  if (fmt->has_denorm)\n+    {\n+      sprintf (buf, \"0x1p%d\", (fmt->emin - fmt->p) * fmt->log2_b);\n+      builtin_define_with_hex_fp_value (name, type, decimal_dig,\n+\t\t\t\t\tbuf, fp_suffix);\n+    }\n+  else\n+    {\n+      sprintf (buf, \"0.0%s\", fp_suffix);\n+      builtin_define_with_value (name, buf, 0);\n+    }\n+\n+  /* For C++ std::numeric_limits<T>::has_infinity.  */\n+  sprintf (name, \"__%s_HAS_INFINITY__\", name_prefix);\n+  builtin_define_with_int_value (name, \n+\t\t\t\t MODE_HAS_INFINITIES (TYPE_MODE (type)));\n+  /* For C++ std::numeric_limits<T>::has_quiet_NaN.  We do not have a\n+     predicate to distinguish a target that has both quiet and\n+     signalling NaNs from a target that has only quiet NaNs or only\n+     signalling NaNs, so we assume that a target that has any kind of\n+     NaN has quiet NaNs.  */\n+  sprintf (name, \"__%s_HAS_QUIET_NAN__\", name_prefix);\n+  builtin_define_with_int_value (name, MODE_HAS_NANS (TYPE_MODE (type)));\n+}\n+\n+/* Define __GNUC__, __GNUC_MINOR__ and __GNUC_PATCHLEVEL__.  */\n+static void\n+define__GNUC__ ()\n+{\n+  /* The format of the version string, enforced below, is\n+     ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n+  const char *q, *v = version_string;\n+\n+  while (*v && ! ISDIGIT (*v))\n+    v++;\n+  if (!*v || (v > version_string && v[-1] != '-'))\n+    abort ();\n+\n+  q = v;\n+  while (ISDIGIT (*v))\n+    v++;\n+  builtin_define_with_value_n (\"__GNUC__\", q, v - q);\n+  if (c_language == clk_cplusplus)\n+    builtin_define_with_value_n (\"__GNUG__\", q, v - q);\n+\n+  if (*v != '.' || !ISDIGIT (v[1]))\n+    abort ();\n+  q = ++v;\n+  while (ISDIGIT (*v))\n+    v++;\n+  builtin_define_with_value_n (\"__GNUC_MINOR__\", q, v - q);\n+\n+  if (*v == '.')\n+    {\n+      if (!ISDIGIT (v[1]))\n+\tabort ();\n+      q = ++v;\n+      while (ISDIGIT (*v))\n+\tv++;\n+      builtin_define_with_value_n (\"__GNUC_PATCHLEVEL__\", q, v - q);\n+    }\n+  else\n+    builtin_define_with_value_n (\"__GNUC_PATCHLEVEL__\", \"0\", 1);\n+\n+  if (*v && *v != ' ' && *v != '-')\n+    abort ();\n+}\n+\n+/* Hook that registers front end and target-specific built-ins.  */\n+void\n+cb_register_builtins (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* -undef turns off target-specific built-ins.  */\n+  if (flag_undef)\n+    return;\n+\n+  define__GNUC__ ();\n+\n+  /* For stddef.h.  They require macros defined in c-common.c.  */\n+  c_stddef_cpp_builtins ();\n+\n+  if (c_language == clk_cplusplus)\n+    {\n+      if (SUPPORTS_ONE_ONLY)\n+\tcpp_define (pfile, \"__GXX_WEAK__=1\");\n+      else\n+\tcpp_define (pfile, \"__GXX_WEAK__=0\");\n+      if (flag_exceptions)\n+\tcpp_define (pfile, \"__EXCEPTIONS\");\n+      if (warn_deprecated)\n+\tcpp_define (pfile, \"__DEPRECATED\");\n+    }\n+\n+  /* represents the C++ ABI version, always defined so it can be used while\n+     preprocessing C and assembler.  */\n+  cpp_define (pfile, \"__GXX_ABI_VERSION=102\");\n+\n+  /* libgcc needs to know this.  */\n+  if (USING_SJLJ_EXCEPTIONS)\n+    cpp_define (pfile, \"__USING_SJLJ_EXCEPTIONS__\");\n+\n+  /* limits.h needs to know these.  */\n+  builtin_define_type_max (\"__SCHAR_MAX__\", signed_char_type_node, 0);\n+  builtin_define_type_max (\"__SHRT_MAX__\", short_integer_type_node, 0);\n+  builtin_define_type_max (\"__INT_MAX__\", integer_type_node, 0);\n+  builtin_define_type_max (\"__LONG_MAX__\", long_integer_type_node, 1);\n+  builtin_define_type_max (\"__LONG_LONG_MAX__\", long_long_integer_type_node, 2);\n+  builtin_define_type_max (\"__WCHAR_MAX__\", wchar_type_node, 0);\n+\n+  builtin_define_type_precision (\"__CHAR_BIT__\", char_type_node);\n+\n+  /* float.h needs to know these.  */\n+\n+  builtin_define_with_int_value (\"__FLT_EVAL_METHOD__\",\n+\t\t\t\t TARGET_FLT_EVAL_METHOD);\n+\n+  builtin_define_float_constants (\"FLT\", \"F\", float_type_node);\n+  builtin_define_float_constants (\"DBL\", \"\", double_type_node);\n+  builtin_define_float_constants (\"LDBL\", \"L\", long_double_type_node);\n+\n+  /* For use in assembly language.  */\n+  builtin_define_with_value (\"__REGISTER_PREFIX__\", REGISTER_PREFIX, 0);\n+  builtin_define_with_value (\"__USER_LABEL_PREFIX__\", user_label_prefix, 0);\n+\n+  /* Misc.  */\n+  builtin_define_with_value (\"__VERSION__\", version_string, 1);\n+\n+  /* Other target-independent built-ins determined by command-line\n+     options.  */\n+  if (optimize_size)\n+    cpp_define (pfile, \"__OPTIMIZE_SIZE__\");\n+  if (optimize)\n+    cpp_define (pfile, \"__OPTIMIZE__\");\n+\n+  if (flag_hosted)\n+    cpp_define (pfile, \"__STDC_HOSTED__=1\");\n+  else\n+    cpp_define (pfile, \"__STDC_HOSTED__=0\");\n+\n+  if (fast_math_flags_set_p ())\n+    cpp_define (pfile, \"__FAST_MATH__\");\n+  if (flag_really_no_inline)\n+    cpp_define (pfile, \"__NO_INLINE__\");\n+  if (flag_signaling_nans)\n+    cpp_define (pfile, \"__SUPPORT_SNAN__\");\n+  if (flag_finite_math_only)\n+    cpp_define (pfile, \"__FINITE_MATH_ONLY__=1\");\n+  else\n+    cpp_define (pfile, \"__FINITE_MATH_ONLY__=0\");\n+\n+  if (flag_iso)\n+    cpp_define (pfile, \"__STRICT_ANSI__\");\n+\n+  if (!flag_signed_char)\n+    cpp_define (pfile, \"__CHAR_UNSIGNED__\");\n+\n+  if (c_language == clk_cplusplus && TREE_UNSIGNED (wchar_type_node))\n+    cpp_define (pfile, \"__WCHAR_UNSIGNED__\");\n+\n+  /* Make the choice of ObjC runtime visible to source code.  */\n+  if (flag_objc && flag_next_runtime)\n+    cpp_define (pfile, \"__NEXT_RUNTIME__\");\n+\n+  /* A straightforward target hook doesn't work, because of problems\n+     linking that hook's body when part of non-C front ends.  */\n+# define preprocessing_asm_p() (cpp_get_options (pfile)->lang == CLK_ASM)\n+# define preprocessing_trad_p() (cpp_get_options (pfile)->traditional)\n+# define builtin_define(TXT) cpp_define (pfile, TXT)\n+# define builtin_assert(TXT) cpp_assert (pfile, TXT)\n+  TARGET_CPU_CPP_BUILTINS ();\n+  TARGET_OS_CPP_BUILTINS ();\n+}\n+\n+/* Pass an object-like macro.  If it doesn't lie in the user's\n+   namespace, defines it unconditionally.  Otherwise define a version\n+   with two leading underscores, and another version with two leading\n+   and trailing underscores, and define the original only if an ISO\n+   standard was not nominated.\n+\n+   e.g. passing \"unix\" defines \"__unix\", \"__unix__\" and possibly\n+   \"unix\".  Passing \"_mips\" defines \"__mips\", \"__mips__\" and possibly\n+   \"_mips\".  */\n+static void\n+builtin_define_std (macro)\n+     const char *macro;\n+{\n+  size_t len = strlen (macro);\n+  char *buff = alloca (len + 5);\n+  char *p = buff + 2;\n+  char *q = p + len;\n+\n+  /* prepend __ (or maybe just _) if in user's namespace.  */\n+  memcpy (p, macro, len + 1);\n+  if (!( *p == '_' && (p[1] == '_' || ISUPPER (p[1]))))\n+    {\n+      if (*p != '_')\n+\t*--p = '_';\n+      if (p[1] != '_')\n+\t*--p = '_';\n+    }\n+  cpp_define (parse_in, p);\n+\n+  /* If it was in user's namespace...  */\n+  if (p != buff + 2)\n+    {\n+      /* Define the macro with leading and following __.  */\n+      if (q[-1] != '_')\n+\t*q++ = '_';\n+      if (q[-2] != '_')\n+\t*q++ = '_';\n+      *q = '\\0';\n+      cpp_define (parse_in, p);\n+\n+      /* Finally, define the original macro if permitted.  */\n+      if (!flag_iso)\n+\tcpp_define (parse_in, macro);\n+    }\n+}\n+\n+/* Pass an object-like macro and a value to define it to.  The third\n+   parameter says whether or not to turn the value into a string\n+   constant.  */\n+void\n+builtin_define_with_value (macro, expansion, is_str)\n+     const char *macro;\n+     const char *expansion;\n+     int is_str;\n+{\n+  char *buf;\n+  size_t mlen = strlen (macro);\n+  size_t elen = strlen (expansion);\n+  size_t extra = 2;  /* space for an = and a NUL */\n+\n+  if (is_str)\n+    extra += 2;  /* space for two quote marks */\n+\n+  buf = alloca (mlen + elen + extra);\n+  if (is_str)\n+    sprintf (buf, \"%s=\\\"%s\\\"\", macro, expansion);\n+  else\n+    sprintf (buf, \"%s=%s\", macro, expansion);\n+\n+  cpp_define (parse_in, buf);\n+}\n+\n+/* Pass an object-like macro and a value to define it to.  The third\n+   parameter is the length of the expansion.  */\n+static void\n+builtin_define_with_value_n (macro, expansion, elen)\n+     const char *macro;\n+     const char *expansion;\n+     size_t elen;\n+{\n+  char *buf;\n+  size_t mlen = strlen (macro);\n+  \n+  /* Space for an = and a NUL.  */\n+  buf = alloca (mlen + elen + 2);\n+  memcpy (buf, macro, mlen);\n+  buf[mlen]= '=';\n+  memcpy (buf + mlen + 1, expansion, elen);\n+  buf[mlen + elen + 1] = '\\0';\n+\n+  cpp_define (parse_in, buf);\n+}\n+\n+/* Pass an object-like macro and an integer value to define it to.  */\n+static void\n+builtin_define_with_int_value (macro, value)\n+     const char *macro;\n+     HOST_WIDE_INT value;\n+{\n+  char *buf;\n+  size_t mlen = strlen (macro);\n+  size_t vlen = 18;\n+  size_t extra = 2; /* space for = and NUL.  */\n+\n+  buf = alloca (mlen + vlen + extra);\n+  memcpy (buf, macro, mlen);\n+  buf[mlen] = '=';\n+  sprintf (buf + mlen + 1, HOST_WIDE_INT_PRINT_DEC, value);\n+\n+  cpp_define (parse_in, buf);\n+}\n+\n+/* Pass an object-like macro a hexadecimal floating-point value.  */\n+static void\n+builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n+     const char *macro;\n+     tree type ATTRIBUTE_UNUSED;\n+     int digits;\n+     const char *hex_str;\n+     const char *fp_suffix;\n+{\n+  REAL_VALUE_TYPE real;\n+  char dec_str[64], buf[256];\n+\n+  /* Hex values are really cool and convenient, except that they're\n+     not supported in strict ISO C90 mode.  First, the \"p-\" sequence\n+     is not valid as part of a preprocessor number.  Second, we get a\n+     pedwarn from the preprocessor, which has no context, so we can't\n+     suppress the warning with __extension__.\n+\n+     So instead what we do is construct the number in hex (because \n+     it's easy to get the exact correct value), parse it as a real,\n+     then print it back out as decimal.  */\n+\n+  real_from_string (&real, hex_str);\n+  real_to_decimal (dec_str, &real, sizeof (dec_str), digits, 0);\n+\n+  sprintf (buf, \"%s=%s%s\", macro, dec_str, fp_suffix);\n+  cpp_define (parse_in, buf);\n+}\n+\n+/* Define MAX for TYPE based on the precision of the type.  IS_LONG is\n+   1 for type \"long\" and 2 for \"long long\".  We have to handle\n+   unsigned types, since wchar_t might be unsigned.  */\n+\n+static void\n+builtin_define_type_max (macro, type, is_long)\n+     const char *macro;\n+     tree type;\n+     int is_long;\n+{\n+  static const char *const values[]\n+    = { \"127\", \"255\",\n+\t\"32767\", \"65535\",\n+\t\"2147483647\", \"4294967295\",\n+\t\"9223372036854775807\", \"18446744073709551615\",\n+\t\"170141183460469231731687303715884105727\",\n+\t\"340282366920938463463374607431768211455\" };\n+  static const char *const suffixes[] = { \"\", \"U\", \"L\", \"UL\", \"LL\", \"ULL\" };\n+\n+  const char *value, *suffix;\n+  char *buf;\n+  size_t idx;\n+\n+  /* Pre-rendering the values mean we don't have to futz with printing a\n+     multi-word decimal value.  There are also a very limited number of\n+     precisions that we support, so it's really a waste of time.  */\n+  switch (TYPE_PRECISION (type))\n+    {\n+    case 8:\tidx = 0; break;\n+    case 16:\tidx = 2; break;\n+    case 32:\tidx = 4; break;\n+    case 64:\tidx = 6; break;\n+    case 128:\tidx = 8; break;\n+    default:    abort ();\n+    }\n+\n+  value = values[idx + TREE_UNSIGNED (type)];\n+  suffix = suffixes[is_long * 2 + TREE_UNSIGNED (type)];\n+\n+  buf = alloca (strlen (macro) + 1 + strlen (value) + strlen (suffix) + 1);\n+  sprintf (buf, \"%s=%s%s\", macro, value, suffix);\n+\n+  cpp_define (parse_in, buf);\n+}"}, {"sha": "c3299d7d51b2ecce6ee1bb519948ba4f21fc86c8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -1,3 +1,8 @@\n+2003-03-11  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Update.\n+\t* lang-specs.h: Don't define __GNUG__ here.\n+\n 2003-03-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (perform_overload_resolution): New function."}, {"sha": "39e84155e79558326a0121b543646691e4fca85f", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -80,7 +80,7 @@ g++-cross$(exeext): g++$(exeext)\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n \tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \\\n-\tc-incpath.o cppdefault.o c-ppoutput.o\n+\tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\"}, {"sha": "8a871d8196cddb787c28190ffd4eb53879875ad6", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -36,24 +36,22 @@ Boston, MA 02111-1307, USA.  */\n   {\".H\",   \"@c++-header\", 0},\n   {\".hh\",  \"@c++-header\", 0},\n   {\"@c++-header\",\n-    \"%{E|M|MM:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n-       %(cpp_options) %2 %(cpp_debug_options)}\\\n+    \"%{E|M|MM:cc1plus -E %(cpp_options) %2 %(cpp_debug_options)}\\\n      %{!E:%{!M:%{!MM:\\\n-       %{save-temps:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n+       %{save-temps:cc1plus -E\\\n \t\t%(cpp_options) %2 %b.ii \\n}\\\n       cc1plus %{save-temps:-fpreprocessed %b.ii}\\\n-\t      %{!save-temps:%(cpp_unique_options) %{!no-gcc:-D__GNUG__=%v1}}\\\n+\t      %{!save-temps:%(cpp_unique_options)}\\\n \t%(cc1_options) %2 %{+e1*}\\\n         -o %g.s %{!o*:--output-pch=%i.gch} %W{o*:--output-pch=%*}%V}}}\",\n      CPLUSPLUS_CPP_SPEC},\n   {\"@c++\",\n-    \"%{E|M|MM:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n-       %(cpp_options) %2 %(cpp_debug_options)}\\\n+    \"%{E|M|MM:cc1plus -E %(cpp_options) %2 %(cpp_debug_options)}\\\n      %{!E:%{!M:%{!MM:\\\n-       %{save-temps|no-integrated-cpp:cc1plus -E %{!no-gcc:-D__GNUG__=%v1}\\\n+       %{save-temps|no-integrated-cpp:cc1plus -E\\\n \t\t%(cpp_options) %2 %{save-temps:%b.ii} %{!save-temps:%g.ii} \\n}\\\n       cc1plus %{save-temps|no-integrated-cpp:-fpreprocessed %{save-temps:%b.ii} %{!save-temps:%g.ii}}\\\n-\t      %{!save-temps:%{!no-integrated-cpp:%(cpp_unique_options) %{!no-gcc:-D__GNUG__=%v1}}}\\\n+\t      %{!save-temps:%{!no-integrated-cpp:%(cpp_unique_options)}}\\\n \t%(cc1_options) %2 %{+e1*}\\\n        %{!fsyntax-only:%(invoke_as)}}}}\",\n      CPLUSPLUS_CPP_SPEC},"}, {"sha": "db15d7dfd37aa41161f2f9ebb82a01fcc10f201b", "filename": "gcc/cppspec.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppspec.c?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -65,9 +65,6 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   /* Do we need to insert -E? */\n   int need_E = 1;\n \n-  /* Do we need to insert -no-gcc? */\n-  int need_no_gcc = 1;\n-\n   /* Have we seen an input file? */\n   int seen_input = 0;\n \n@@ -122,8 +119,6 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \t    }\n \t  else if (argv[i][1] == 'x')\n \t    need_fixups = 0;\n-\t  else if (argv[i][1] == 'g' && !strcmp(&argv[i][2], \"cc\"))\n-\t    need_no_gcc = 0;\n \t  else if (WORD_SWITCH_TAKES_ARG (&argv[i][1]))\n \t    quote = 1;\n \t}\n@@ -172,7 +167,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n \n   /* If we don't need to edit the command line, we can bail early.  */\n \n-  new_argc = argc + need_E + need_no_gcc + read_stdin\n+  new_argc = argc + need_E + read_stdin\n     + !!o_here + !!lang_c_here + !!lang_S_here;\n \n   if (new_argc == argc)\n@@ -187,9 +182,6 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   if (need_E)\n     new_argv[j++] = \"-E\";\n \n-  if (need_no_gcc)\n-    new_argv[j++] = \"-no-gcc\";\n-\n   for (i = 1; i < argc; i++, j++)\n     {\n       if (i == lang_c_here)"}, {"sha": "67ae67fb228ba208565e2f9b12879a27572b94ad", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -5306,18 +5306,6 @@ Output the accumulated assembler options specified by @option{-Wa}.\n @item %Z\n Output the accumulated preprocessor options specified by @option{-Wp}.\n \n-@item %v1\n-Substitute the major version number of GCC@.\n-(For version 2.9.5, this is 2.)\n-\n-@item %v2\n-Substitute the minor version number of GCC@.\n-(For version 2.9.5, this is 9.)\n-\n-@item %v3\n-Substitute the patch level number of GCC@.\n-(For version 2.9.5, this is 5.)\n-\n @item %a\n Process the @code{asm} spec.  This is used to compute the\n switches to be passed to the assembler."}, {"sha": "15f64335db0f83f98c6b19bda4ee08dfbd6e5e17", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -84,6 +84,7 @@ the other C-like languages: @file{c-common.c},\n @file{c-lex.c},\n @file{c-incpath.c},\n @file{c-ppoutput.c},\n+@file{c-cppbuiltin.c},\n @file{c-common.h},\n @file{c-dump.h},\n @file{c-incpath.h}"}, {"sha": "05689ef930bb1bfc798ab701d5f1f0a97d0f8b47", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -619,7 +619,7 @@ Here are run-time target specifications.\n This function-like macro expands to a block of code that defines\n built-in preprocessor macros and assertions for the target cpu, using\n the functions @code{builtin_define}, @code{builtin_define_std} and\n-@code{builtin_assert} defined in @file{c-common.c}.  When the front end\n+@code{builtin_assert}.  When the front end\n calls this macro it provides a trailing semicolon, and since it has\n finished command line option processing your code can use those\n results freely."}, {"sha": "37f8b2c42052bb6019bd10a947522865424845d3", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 66, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb60f38d5b06fd610dbf5216d8751f8db0274edd/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=cb60f38d5b06fd610dbf5216d8751f8db0274edd", "patch": "@@ -466,12 +466,6 @@ or with constant text in a single argument.\n  %X\tOutput the accumulated linker options specified by compilations.\n  %Y\tOutput the accumulated assembler options specified by compilations.\n  %Z\tOutput the accumulated preprocessor options specified by compilations.\n- %v1\tSubstitute the major version number of GCC.\n-\t(For version 2.5.3, this is 2.)\n- %v2\tSubstitute the minor version number of GCC.\n-\t(For version 2.5.3, this is 5.)\n- %v3\tSubstitute the patch level number of GCC.\n-\t(For version 2.5.3, this is 3.)\n  %a     process ASM_SPEC as a spec.\n         This allows config.h to specify part of the spec for running as.\n  %A\tprocess ASM_FINAL_SPEC as a spec.  A capital A is actually\n@@ -740,14 +734,12 @@ static const char *trad_capable_cpp =\n    therefore no dependency entry, confuses make into thinking a .o\n    file that happens to exist is up-to-date.  */\n static const char *cpp_unique_options =\n-\"%{C:%{!E:%eGNU C does not support -C without using -E}}\\\n- %{CC:%{!E:%eGNU C does not support -CC without using -E}}\\\n+\"%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\\\n  %{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*} %{P} %I\\\n  %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\\\n  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\\\n  %{!E:%{!M:%{!MM:%{MD|MMD:%{o*:-MQ %*}}}}}\\\n- %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\\\n  %{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\\\n  %{remap} %{g3:-dD} %{H} %C %{D*&U*&A*} %{i*} %Z %i\\\n  %{E|M|MM:%W{o*}}\";\n@@ -5305,63 +5297,6 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    }\n \t    break;\n \n-\t  case 'v':\n-\t    {\n-\t      int c1 = *p++;  /* Select first or second version number.  */\n-\t      const char *v = compiler_version;\n-\t      const char *q;\n-\t      static const char zeroc = '0';\n-\n-\t      /* The format of the version string is\n-\t\t ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n-\n-\t      /* Ignore leading non-digits.  i.e. \"foo-\" in \"foo-2.7.2\".  */\n-\t      while (! ISDIGIT (*v))\n-\t\tv++;\n-\t      if (v > compiler_version && v[-1] != '-')\n-\t\tabort ();\n-\n-\t      /* If desired, advance to second version number.  */\n-\t      if (c1 >= '2')\n-\t\t{\n-\t\t  /* Set V after the first period.  */\n-\t\t  while (ISDIGIT (*v))\n-\t\t    v++;\n-\t\t  if (*v != '.')\n-\t\t    abort ();\n-\t\t  v++;\n-\t\t}\n-\n-\t      /* If desired, advance to third version number.\n-                 But don't complain if it's not present */\n-\t      if (c1 == '3')\n-\t\t{\n-\t\t  /* Set V after the second period.  */\n-\t\t  while (ISDIGIT (*v))\n-\t\t    v++;\n-\t\t  if ((*v != 0) && (*v != ' ') && (*v != '.') && (*v != '-'))\n-\t\t    abort ();\n-\t\t  if (*v != 0)\n-\t\t    v++;\n-\t\t}\n-\n-\t      /* Set Q at the next period or at the end.  */\n-\t      q = v;\n-\t      while (ISDIGIT (*q))\n-\t\tq++;\n-\t      if (*q != 0 && q > v && *q != ' ' && *q != '.' && *q != '-')\n-\t\tabort ();\n-\n-\t      if (q > v)\n-\t\t/* Put that part into the command.  */\n-\t\tobstack_grow (&obstack, v, q - v);\n-\t      else\n-\t\t/* Default to \"0\" */\n-\t\tobstack_grow (&obstack, &zeroc, 1);\n-\t      arg_going = 1;\n-\t    }\n-\t    break;\n-\n \t  default:\n \t    error (\"spec failure: unrecognized spec option '%c'\", c);\n \t    break;"}]}