{"sha": "9a38b8b940299eeceb51652bc070834809bb126e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzOGI4Yjk0MDI5OWVlY2ViNTE2NTJiYzA3MDgzNDgwOWJiMTI2ZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2016-12-06T20:02:03Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2016-12-06T20:02:03Z"}, "message": "lra-lives.c (process_bb_lives): Update biggest mode for implicitly used hard reg.\n\n2016-12-06  Vladimir Makarov  <vmakarov@redhat.com>\n\n\ttarget/77761\n\t* lra-lives.c (process_bb_lives): Update biggest mode for\n\timplicitly used hard reg.\n\n2016-12-06  Vladimir Makarov  <vmakarov@redhat.com>\n\n\ttarget/77761\n\t* testsuite/gcc.target/i386/pr77761.c: New.\n\nFrom-SVN: r243316", "tree": {"sha": "10275f75468cc6d0f1db8d23b43cb71ca65ff672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10275f75468cc6d0f1db8d23b43cb71ca65ff672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a38b8b940299eeceb51652bc070834809bb126e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a38b8b940299eeceb51652bc070834809bb126e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a38b8b940299eeceb51652bc070834809bb126e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a38b8b940299eeceb51652bc070834809bb126e/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd3fe55a185181aeb1a6b626cfbaa6e14839b7e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3fe55a185181aeb1a6b626cfbaa6e14839b7e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd3fe55a185181aeb1a6b626cfbaa6e14839b7e9"}], "stats": {"total": 87, "additions": 83, "deletions": 4}, "files": [{"sha": "b57a189396a5fa25b803ede8341a43d748821b33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a38b8b940299eeceb51652bc070834809bb126e", "patch": "@@ -1,3 +1,9 @@\n+2016-12-06  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\ttarget/77761\n+\t* lra-lives.c (process_bb_lives): Update biggest mode for\n+\timplicitly used hard reg.\n+\n 2016-12-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/predicates.md (general_gr_operand): New predicate."}, {"sha": "3ffec903f29c7763489287981eebc6ba08fb8f96", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=9a38b8b940299eeceb51652bc070834809bb126e", "patch": "@@ -702,11 +702,24 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       /* Update max ref width and hard reg usage.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \t{\n+\t  int i, regno = reg->regno;\n+\t  \n \t  if (GET_MODE_SIZE (reg->biggest_mode)\n-\t      > GET_MODE_SIZE (lra_reg_info[reg->regno].biggest_mode))\n-\t    lra_reg_info[reg->regno].biggest_mode = reg->biggest_mode;\n-\t  if (reg->regno < FIRST_PSEUDO_REGISTER)\n-\t    lra_hard_reg_usage[reg->regno] += freq;\n+\t      > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode))\n+\t    lra_reg_info[regno].biggest_mode = reg->biggest_mode;\n+\t  if (regno < FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      lra_hard_reg_usage[regno] += freq;\n+\t      /* A hard register explicitly can be used in small mode,\n+\t\t but implicitly it can be used in natural mode as a\n+\t\t part of multi-register group.  Process this case\n+\t\t here.  */\n+\t      for (i = 1; i < hard_regno_nregs[regno][reg->biggest_mode]; i++)\n+\t\tif (GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno + i]))\n+\t\t    > GET_MODE_SIZE (lra_reg_info[regno + i].biggest_mode))\n+\t\t  lra_reg_info[regno + i].biggest_mode\n+\t\t    = GET_MODE (regno_reg_rtx[regno + i]);\n+\t    }\n \t}\n \n       call_p = CALL_P (curr_insn);"}, {"sha": "95167b3d8de51e01fcf63bbf92abebaad94ae2db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9a38b8b940299eeceb51652bc070834809bb126e", "patch": "@@ -1,3 +1,8 @@\n+2016-12-06  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\ttarget/77761\n+\t* testsuite/gcc.target/i386/pr77761.c: New.\n+\n 2016-12-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/78659"}, {"sha": "a39b3afb46918c11e19be4260c336783ba03efc1", "filename": "gcc/testsuite/gcc.target/i386/pr77761.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr77761.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a38b8b940299eeceb51652bc070834809bb126e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr77761.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr77761.c?ref=9a38b8b940299eeceb51652bc070834809bb126e", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-guess-branch-probability -fschedule-insns -fno-tree-ter -mavx512f --param=max-pending-list-length=512\" } */\n+/* { dg-require-effective-target avx512f } */\n+\n+#include \"avx512f-check.h\"\n+\n+typedef unsigned char u8;\n+typedef unsigned char v64u8 __attribute__ ((vector_size (64)));\n+typedef unsigned short u16;\n+typedef unsigned short v64u16 __attribute__ ((vector_size (64)));\n+typedef unsigned int u32;\n+typedef unsigned int v64u32 __attribute__ ((vector_size (64)));\n+typedef unsigned long long u64;\n+typedef unsigned long long v64u64 __attribute__ ((vector_size (64)));\n+typedef unsigned __int128 u128;\n+typedef unsigned __int128 v64u128 __attribute__ ((vector_size (64)));\n+\n+v64u128 __attribute__ ((noinline, noclone))\n+foo(u8 x1, u16 x2, u32 x3, u64 x4, v64u8 x5, v64u16 x6, v64u32 x7, v64u64 x8, v64u128 x9)\n+{\n+  u8 *p = &x1;\n+  x9[0] -= *p;\n+  x5 %= (v64u8){ 1, -x4, 0, x3, x5[9], x7[1], 4, x6[1], 13 << 4} | 1;\n+  x5[1] = x5[0];\n+  x8 %= (v64u64){1, x1} | 1;\n+  x9 /= x9 | 1;\n+  x5 -= (v64u8){0, 0, 3, 0, 0, 0, 0, x4, x9[0], 0, 1};\n+  return x1 + x2 + x3 + x4 + (v64u128) x5 + (v64u128) x6 + (v64u128) x7 +\n+    (v64u128) x8 + x9;\n+}\n+\n+int\n+do_main ()\n+{\n+  v64u128 x = foo(1, 0, 0, 0, (v64u8){}, (v64u16){}, (v64u32){}, (v64u64){}, (v64u128){});\n+\n+  if ((u64)(x[0] >> 64) != 0x0000000000ff00ff)\n+    __builtin_abort();\n+  if ((u64)(x[0] >>  0) != 0x0000000000fd0002)\n+    __builtin_abort();\n+\n+  if (x[1] != 1)\n+    __builtin_abort();\n+  if (x[2] != 1)\n+    __builtin_abort();\n+  if (x[3] != 1)\n+    __builtin_abort();\n+  return 0;\n+}\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}]}