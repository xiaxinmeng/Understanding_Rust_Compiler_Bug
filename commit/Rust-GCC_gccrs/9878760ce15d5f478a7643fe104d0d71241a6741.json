{"sha": "9878760ce15d5f478a7643fe104d0d71241a6741", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg3ODc2MGNlMTVkNWY0NzhhNzY0M2ZlMTA0ZDBkNzEyNDFhNjc0MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-02-09T19:26:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-02-09T19:26:21Z"}, "message": "Initial revision\n\nFrom-SVN: r296", "tree": {"sha": "0d65fe991a66912715e7435501fb2b80d6b0d87f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d65fe991a66912715e7435501fb2b80d6b0d87f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9878760ce15d5f478a7643fe104d0d71241a6741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9878760ce15d5f478a7643fe104d0d71241a6741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9878760ce15d5f478a7643fe104d0d71241a6741", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9878760ce15d5f478a7643fe104d0d71241a6741/comments", "author": null, "committer": null, "parents": [{"sha": "c98f874233428d7e6ba83def7842fd703ac0ddf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98f874233428d7e6ba83def7842fd703ac0ddf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c98f874233428d7e6ba83def7842fd703ac0ddf1"}], "stats": {"total": 1509, "additions": 1509, "deletions": 0}, "files": [{"sha": "47e9342a63a669e53cd1e1a55b9d0563ee3ef576", "filename": "gcc/config/rs6000/rs6000.c", "status": "added", "additions": 1509, "deletions": 0, "changes": 1509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9878760ce15d5f478a7643fe104d0d71241a6741/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9878760ce15d5f478a7643fe104d0d71241a6741/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9878760ce15d5f478a7643fe104d0d71241a6741", "patch": "@@ -0,0 +1,1509 @@\n+/* Subroutines used for code generation on IBM RS/6000.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"obstack.h\"\n+\n+#define min(A,B)\t((A) < (B) ? (A) : (B))\n+#define max(A,B)\t((A) > (B) ? (A) : (B))\n+\n+/* Names of bss and data sections.  These should be unique names for each\n+   compilation unit.  */\n+\n+char *rs6000_bss_section_name;\n+char *rs6000_private_data_section_name;\n+char *rs6000_read_only_section_name;\n+\n+/* Set to non-zero by \"fix\" operation to indicate that itrunc and\n+   uitrunc must be defined.  */\n+\n+int rs6000_trunc_used;\n+\n+/* Set to non-zero once they have been defined.  */\n+\n+static int trunc_defined;\n+\n+/* Save information from a \"cmpxx\" operation until the branch or scc is\n+   emitted.  */\n+\n+rtx rs6000_compare_op0, rs6000_compare_op1;\n+int rs6000_compare_fp_p;\n+\f\n+/* Return non-zero if this function is known to have a null epilogue.  */\n+\n+int\n+direct_return ()\n+{\n+  return (reload_completed\n+\t  && first_reg_to_save () == 32\n+\t  && first_fp_reg_to_save () == 64\n+\t  && ! regs_ever_live[65]\n+\t  && ! rs6000_pushes_stack ());\n+}\n+\n+/* Returns 1 always.  */\n+\n+int\n+any_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a constant that can fit in a D field.  */\n+\n+int\n+short_cint_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (unsigned) (INTVAL (op) + 0x8000) < 0x10000);\n+}\n+\n+/* Similar for a unsigned D field.  */\n+\n+int\n+u_short_cint_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff0000) == 0);\n+}\n+\n+/* Returns 1 if OP is a register that is not special (i.e., not MQ,\n+   ctr, or lr).  */\n+\n+int\n+gen_reg_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  && (GET_CODE (op) != REG || REGNO (op) >= 67 || REGNO (op) < 64));\n+}\n+\n+/* Returns 1 if OP is either a pseudo-register or a register denoting a\n+   CR field.  */\n+\n+int\n+cc_reg_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  && (GET_CODE (op) != REG\n+\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || CR_REGNO_P (REGNO (op))));\n+}\n+\n+/* Returns 1 if OP is either a constant integer valid for a D-field or a\n+   non-special register.  If a register, it must be in the proper mode unless\n+   MODE is VOIDmode.  */\n+\n+int\n+reg_or_short_operand (op, mode)\n+      register rtx op;\n+      enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return short_cint_operand (op, mode);\n+\n+  return gen_reg_operand (op, mode);\n+}\n+\n+/* Similar, except check if the negation of the constant would be valid for\n+   a D-field.  */\n+\n+int\n+reg_or_neg_short_operand (op, mode)\n+      register rtx op;\n+      enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return CONST_OK_FOR_LETTER_P (INTVAL (op), 'P');\n+\n+  return gen_reg_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is either a register or an integer whose high-order\n+   16 bits are zero.  */\n+\n+int\n+reg_or_u_short_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT\n+      && (INTVAL (op) & 0xffff0000) == 0)\n+    return 1;\n+\n+  return gen_reg_operand (op, mode);\n+}\n+\n+/* Return 1 is the operand is either a non-special register or ANY\n+   constant integer.  */\n+\n+int\n+reg_or_cint_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+     return GET_CODE (op) == CONST_INT || gen_reg_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a\n+   register with one instruction per word.  For SFmode, this means  that\n+   the low 16-bits are zero.  For DFmode, it means the low 16-bits of\n+   the first word are zero and the high 16 bits of the second word\n+   are zero (usually all bits in the low-order word will be zero).\n+\n+   We only do this if we can safely read CONST_DOUBLE_{LOW,HIGH}.  */\n+\n+int\n+easy_fp_constant (op, mode)\n+     register rtx op;\n+     register enum machine_mode mode;\n+{\n+  rtx low, high;\n+\n+  if (GET_CODE (op) != CONST_DOUBLE\n+      || GET_MODE (op) != mode\n+      || GET_MODE_CLASS (mode) != MODE_FLOAT)\n+    return 0;\n+\n+  high = operand_subword (op, 0, 0, mode);\n+  low = operand_subword (op, 1, 0, mode);\n+\n+  if (high == 0 || GET_CODE (high) != CONST_INT || (INTVAL (high) & 0xffff))\n+    return 0;\n+\n+  return (mode == SFmode\n+\t  || (low != 0 && GET_CODE (low) == CONST_INT\n+\t      && (INTVAL (low) & 0xffff0000) == 0));\n+}\n+      \n+/* Return 1 if the operand is either a floating-point register, a pseudo\n+   register, or memory.  */\n+\n+int\n+fp_reg_or_mem_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (memory_operand (op, mode)\n+\t  || (register_operand (op, mode)\n+\t      && (GET_CODE (op) != REG\n+\t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t\t  || FP_REGNO_P (REGNO (op)))));\n+}\n+\n+/* Return 1 if the operand is either an easy FP constant (see above) or\n+   memory.  */\n+\n+int\n+mem_or_easy_const_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return memory_operand (op, mode) || easy_fp_constant (op, mode);\n+}\n+\n+/* Return 1 if the operand is either a non-special register or an item\n+   that can be used as the operand of an SI add insn.  */\n+\n+int\n+add_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return (reg_or_short_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff) == 0));\n+}\n+\n+/* Return 1 if the operand is a non-special register or a constant that\n+   can be used as the operand of an OR or XOR insn on the RS/6000.  */\n+\n+int\n+logical_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return (gen_reg_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && ((INTVAL (op) & 0xffff0000) == 0\n+\t\t  || (INTVAL (op) & 0xffff) == 0)));\n+}\n+\n+/* Return 1 if C is a constant that can be encoded in a mask on the\n+   RS/6000.  It is if there are no more than two 1->0 or 0->1 transitions.\n+   Reject all ones and all zeros, since these should have been optimized\n+   away and confuse the making of MB and ME.  */\n+\n+int\n+mask_constant (c)\n+     register int c;\n+{\n+  int i;\n+  int last_bit_value;\n+  int transitions = 0;\n+\n+  if (c == 0 || c == ~0)\n+    return 0;\n+\n+  last_bit_value = c & 1;\n+\n+  for (i = 1; i < 32; i++)\n+    if (((c >>= 1) & 1) != last_bit_value)\n+      last_bit_value ^= 1, transitions++;\n+\n+  return transitions <= 2;\n+}\n+\n+/* Return 1 if the operand is a constant that is a mask on the RS/6000. */\n+\n+int\n+mask_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == CONST_INT && mask_constant (INTVAL (op));\n+}\n+\n+/* Return 1 if the operand is either a non-special register or a\n+   constant that can be used as the operand of an RS/6000 logical AND insn.  */\n+\n+int\n+and_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return (reg_or_short_operand (op, mode)\n+\t  || logical_operand (op, mode)\n+\t  || mask_operand (op, mode));\n+}\n+\n+/* Return 1 if the operand is a general register or memory operand.  */\n+\n+int\n+reg_or_mem_operand (op, mode)\n+     register rtx op;\n+     register enum machine_mode mode;\n+{\n+  return gen_reg_operand (op, mode) || memory_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand, used inside a MEM, is a valid first argument\n+   to CALL.  This is a SYMBOL_REF or a pseudo-register, which will be\n+   forced to lr.  */\n+\n+int\n+call_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+\n+  return (GET_CODE (op) == SYMBOL_REF\n+\t  || (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER));\n+}\n+\n+/* Return 1 if this operand is a valid input for a move insn.  */\n+\n+int\n+input_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (memory_operand (op, mode))\n+    return 1;\n+\n+  /* For floating-point or multi-word mode, only register or memory\n+     is valid.  */\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      || GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return gen_reg_operand (op, mode);\n+\n+  /* For SImode, we can also load from a special register, so any register\n+     is valid.  */\n+  if (mode == SImode && register_operand (op, mode))\n+    return 1;\n+\n+  /* For HImode and QImode, any constant is valid along with any\n+     non-special register.  */\n+  if (mode == HImode || mode == QImode)\n+    return register_operand (op, mode) || GET_CODE (op) == CONST_INT;\n+\n+  /* Otherwise, we will be doing this SET with an add, so anything valid\n+     for an add will be valid.  */\n+  return add_operand (op, mode);\n+}\n+\f\n+/* Return 1 if OP is a load multiple operation.  It is known to be a\n+   PARALLEL and the first section will be tested.  */\n+\n+int\n+load_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0);\n+  int dest_regno;\n+  rtx src_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Similar, but tests for store multiple.  Here, the second vector element\n+   is a CLOBBER.  It will be tested later.  */\n+\n+int\n+store_multiple_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0) - 1;\n+  int src_regno;\n+  rtx dest_addr;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return 0;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i + 1);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != i * 4)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\f\n+/* Return 1 if OP is a comparison operation that is valid for a branch insn.\n+   We only check the opcode against the mode of the CC value here.  */\n+\n+int\n+branch_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode cc_mode;\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  cc_mode = GET_MODE (XEXP (op, 0));\n+  if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n+    return 0;\n+\n+  if ((code == GT || code == LT || code == GE || code == LE)\n+      && cc_mode == CCUNSmode)\n+    return 0;\n+\n+  if ((code == GTU || code == LTU || code == GEU || code == LEU)\n+      && (cc_mode != CCUNSmode))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a comparison operation that is valid for an scc insn.\n+   We check the opcode against the mode of the CC value and disallow EQ or\n+   NE comparisons for integers.  */\n+\n+int\n+scc_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode cc_mode;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+\n+  cc_mode = GET_MODE (XEXP (op, 0));\n+  if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n+    return 0;\n+\n+  if (code == NE && cc_mode != CCFPmode)\n+    return 0;\n+\n+  if ((code == GT || code == LT || code == GE || code == LE)\n+      && cc_mode == CCUNSmode)\n+    return 0;\n+\n+  if ((code == GTU || code == LTU || code == GEU || code == LEU)\n+      && (cc_mode != CCUNSmode))\n+    return 0;\n+\n+  return 1;\n+}\n+\f\n+/* Return 1 if ANDOP is a mask that has no bits on that are not in the\n+   mask required to convert the result of a rotate insn into a shift\n+   left insn of SHIFTOP bits.  Both are known to be CONST_INT.  */\n+\n+int\n+includes_lshift_p (shiftop, andop)\n+     register rtx shiftop;\n+     register rtx andop;\n+{\n+  int shift_mask = (~0 << INTVAL (shiftop));\n+\n+  return (INTVAL (andop) & ~shift_mask) == 0;\n+}\n+\n+/* Similar, but for right shift.  */\n+\n+int\n+includes_rshift_p (shiftop, andop)\n+     register rtx shiftop;\n+     register rtx andop;\n+{\n+  unsigned shift_mask = ~0;\n+\n+  shift_mask >>= INTVAL (shiftop);\n+\n+  return (INTVAL (andop) & ~ shift_mask) == 0;\n+}\n+\f\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno = true_regnum (in);\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    regno = -1;\n+\n+  /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n+     into anything.  */\n+  if (class == GENERAL_REGS || class == BASE_REGS\n+      || (regno >= 0 && INT_REGNO_P (regno)))\n+    return NO_REGS;\n+\n+  /* Constants, memory, and FP registers can go into FP registers.  */\n+  if ((regno == -1 || FP_REGNO_P (regno))\n+      && (class == FLOAT_REGS || class == NON_SPECIAL_REGS))\n+    return NO_REGS;\n+\n+  /* We can copy among the CR registers.  */\n+  if ((class == CR_REGS || class == CR0_REGS)\n+      && regno >= 0 && CR_REGNO_P (regno))\n+    return NO_REGS;\n+\n+  /* Otherwise, we need GENERAL_REGS.  */\n+  return GENERAL_REGS;\n+}\n+\f\n+/* Given a comparison operation, return the bit number in CCR to test.  We\n+   know this is a valid comparison.  \n+\n+   SCC_P is 1 if this is for an scc.  That means that %D will have been\n+   used instead of %C, so the bits will be in different places.\n+\n+   Return -1 if OP isn't a valid compaison for some reason.  */\n+\n+int\n+ccr_bit (op, scc_p)\n+     register rtx op;\n+     int scc_p;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  enum machine_mode cc_mode;\n+  int cc_regnum;\n+  int base_bit;\n+\n+  if (GET_RTX_CLASS (code) != '<')\n+    return -1;\n+\n+  cc_mode = GET_MODE (XEXP (op, 0));\n+  cc_regnum = REGNO (XEXP (op, 0));\n+  base_bit = 4 * (cc_regnum - 68);\n+\n+  switch (code)\n+    {\n+    case NE:\n+      return scc_p ? base_bit + 3 : base_bit + 2;\n+    case EQ:\n+      return base_bit + 2;\n+    case GT:  case GTU:\n+      return base_bit + 1;\n+    case LT:  case LTU:\n+      return base_bit;\n+\n+    case GE:  case GEU:\n+      /* If floating-point, we will have done a cror to put the bit in the\n+\t unordered position.  So test that bit.  For integer, this is ! LT\n+\t unless this is an scc insn.  */\n+      return cc_mode == CCFPmode || scc_p ? base_bit + 3 : base_bit;\n+\n+    case LE:  case LEU:\n+      return cc_mode == CCFPmode || scc_p ? base_bit + 3 : base_bit + 1;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\f\n+/* Print an operand.  Recognize special options, documented below.  */\n+\n+void\n+print_operand (file, x, code)\n+    FILE *file;\n+    rtx x;\n+    char code;\n+{\n+  int i;\n+  int val;\n+\n+  /* These macros test for integers and extract the low-order bits.  */\n+#define INT_P(X)  \\\n+((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)\t\\\n+ && GET_MODE (X) == VOIDmode)\n+\n+#define INT_LOWPART(X) \\\n+  (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n+\n+  switch (code)\n+    {\n+    case 'h':\n+      /* If constant, output low-order six bits.  Otherwise, write normally. */\n+      if (INT_P (x))\n+\tfprintf (file, \"%d\", INT_LOWPART (x) & 31);\n+      else\n+\tprint_operand (file, x, 0);\n+      return;\n+\n+    case 'H':\n+      /* X must be a constant.  Output the low order 6 bits plus 24.  */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%H value\");\n+\n+      fprintf (file, \"%d\", (INT_LOWPART (x) + 24) & 31);\n+      return;\n+\n+    case 'b':\n+      /* Low-order 16 bits of constant, unsigned.  */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%b value\");\n+\n+      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+      return;\n+\n+    case 'w':\n+      /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n+\t normally.  */\n+      if (INT_P (x))\n+\tfprintf (file, \"%d\", (INT_LOWPART (x) << 16) >> 16);\n+      else\n+\tprint_operand (file, x, 0);\n+      return;\n+\n+    case 'W':\n+      /* If constant, low-order 16 bits of constant, unsigned.\n+\t Otherwise, write normally.  */\n+      if (INT_P (x))\n+\tfprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+      else\n+\tprint_operand (file, x, 0);\n+      return;\n+\n+    case 'u':\n+      /* High-order 16 bits of constant.  */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%u value\");\n+\n+      fprintf (file, \"%d\", (INT_LOWPART (x) >> 16) & 0xffff);\n+      return;\n+\n+    case 's':\n+      /* Low 5 bits of 32 - value */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%s value\");\n+\n+      fprintf (file, \"%d\", (32 - INT_LOWPART (x)) & 31);\n+      return;\n+\n+    case 'S':\n+      /* Low 5 bits of 31 - value */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%S value\");\n+\n+      fprintf (file, \"%d\", (31 - INT_LOWPART (x)) & 31);\n+      return;\n+\n+    case 'p':\n+      /* X is a CONST_INT that is a power of two.  Output the logarithm.  */\n+      if (! INT_P (x)\n+\t  || (i = exact_log2 (INT_LOWPART (x))) < 0)\n+\toutput_operand_lossage (\"invalid %%p value\");\n+\n+      fprintf (file, \"%d\", i);\n+      return;\n+\n+    case 'm':\n+      /* MB value for a mask operand.  */\n+      if (! mask_operand (x, VOIDmode))\n+\toutput_operand_lossage (\"invalid %%m value\");\n+\n+      val = INT_LOWPART (x);\n+\n+      /* If the high bit is set and the low bit is not, the value is zero.\n+\t If the high bit is zero, the value is the first 1 bit we find from\n+\t the left.  */\n+      if (val < 0 && (val & 1) == 0)\n+\t{\n+\t  fprintf (file, \"0\");\n+\t  return;\n+\t}\n+      else if (val >= 0)\n+\t{\n+\t  for (i = 1; i < 32; i++)\n+\t    if ((val <<= 1) < 0)\n+\t      break;\n+\t  fprintf (file, \"%d\", i);\n+\t  return;\n+\t}\n+\t  \n+      /* Otherwise, look for the first 0 bit from the right.  The result is its\n+\t number plus 1. We know the low-order bit is one.  */\n+      for (i = 0; i < 32; i++)\n+\tif (((val >>= 1) & 1) == 0)\n+\t  break;\n+\n+      /* If we ended in ...01, I would be 0.  The correct value is 31, so\n+\t we want 31 - i.  */\n+      fprintf (file, \"%d\", 31 - i);\n+      return;\n+\n+    case 'M':\n+      /* ME value for a mask operand.  */\n+      if (! mask_operand (x, VOIDmode))\n+\toutput_operand_lossage (\"invalid %%m value\");\n+\n+      val = INT_LOWPART (x);\n+\n+      /* If the low bit is set and the high bit is not, the value is 31.\n+\t If the low bit is zero, the value is the first 1 bit we find from\n+\t the right.  */\n+      if ((val & 1) && val >= 0)\n+\t{\n+\t  fprintf (file, \"31\");\n+\t  return;\n+\t}\n+      else if ((val & 1) == 0)\n+\t{\n+\t  for (i = 0; i < 32; i++)\n+\t    if ((val >>= 1) & 1)\n+\t      break;\n+\n+\t  /* If we had ....10, I would be 0.  The result should be\n+\t     30, so we need 30 - i.  */\n+\t  fprintf (file, \"%d\", 30 - i);\n+\t  return;\n+\t}\n+\t  \n+      /* Otherwise, look for the first 0 bit from the left.  The result is its\n+\t number minus 1. We know the high-order bit is one.  */\n+      for (i = 0; i < 32; i++)\n+\tif ((val <<= 1) >= 0)\n+\t  break;\n+\n+      fprintf (file, \"%d\", i);\n+      return;\n+\n+    case 'f':\n+      /* X is a CR register.  Print the shift count needed to move it\n+\t to the high-order four bits.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%f value\");\n+      else\n+\tfprintf (file, \"%d\", 4 * (REGNO (x) - 68));\n+      return;\n+\n+    case 'F':\n+      /* Similar, but print the count for the rotate in the opposite\n+\t direction.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%F value\");\n+      else\n+\tfprintf (file, \"%d\", 32 - 4 * (REGNO (x) - 68));\n+      return;\n+\n+    case 'R':\n+      /* X is a CR register.  Print the mask for `mtcrf'.  */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%R value\");\n+      else\n+\tfprintf (file, \"%d\", 128 >> (REGNO (x) - 68));\n+      return;\n+\n+    case 'X':\n+      if (GET_CODE (x) == MEM\n+\t  && LEGITIMATE_INDEXED_ADDRESS_P (XEXP (x, 0)))\n+\tfprintf (file, \"x\");\n+      return;\n+\n+    case 'U':\n+      /* Print `u' is this has an auto-increment or auto-decremement.  */\n+      if (GET_CODE (x) == MEM\n+\t  && (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC))\n+\tfprintf (file, \"u\");\n+      return;\n+\n+    case 'I':\n+      /* Print `i' is this is a constant, else nothing.  */\n+      if (INT_P (x))\n+\tfprintf (file, \"i\");\n+      return;\n+\n+    case 'N':\n+      /* Write the number of elements in the vector times 4.  */\n+      if (GET_CODE (x) != PARALLEL)\n+\toutput_operand_lossage (\"invalid %%N value\");\n+\n+      fprintf (file, \"%d\", XVECLEN (x, 0) * 4);\n+      return;\n+\n+    case 'O':\n+      /* Similar, but subtract 1 first.  */\n+      if (GET_CODE (x) != PARALLEL)\n+\toutput_operand_lossage (\"invalid %%N value\");\n+\n+      fprintf (file, \"%d\", (XVECLEN (x, 0) - 1) * 4);\n+      return;\n+\n+    case 'P':\n+      /* The operand must be an indirect memory reference.  The result\n+\t is the register number. */\n+      if (GET_CODE (x) != MEM || GET_CODE (XEXP (x, 0)) != REG\n+\t  || REGNO (XEXP (x, 0)) >= 32)\n+\toutput_operand_lossage (\"invalid %%P value\");\n+\n+      fprintf (file, \"%d\", REGNO (XEXP (x, 0)));\n+      return;\n+\n+    case 'L':\n+      /* Write second word of DImode or DFmode reference.  Works on register\n+\t or non-indexed memory only.  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%d\", REGNO (x) + 1);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* Handle possible auto-increment.  Since it is pre-increment and\n+\t     we have already done it, we can just use an offset of four.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 4));\n+\t}\n+      return;\n+\t\t\t    \n+    case 'Y':\n+      /* Similar, for third word of TImode  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%d\", REGNO (x) + 2);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 8));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 8));\n+\t}\n+      return;\n+\t\t\t    \n+    case 'Z':\n+      /* Similar, for last word of TImode.  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%d\", REGNO (x) + 3);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 12));\n+\t  else\n+\t    output_address (plus_constant (XEXP (x, 0), 12));\n+\t}\n+      return;\n+\t\t\t    \n+    case 't':\n+      /* Write 12 if this jump operation will branch if true, 4 otherwise. \n+\t All floating-point operations except NE branch true and integer\n+\t EQ, LT, GT, LTU and GTU also branch true.  */\n+      if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n+\toutput_operand_lossage (\"invalid %%t value\");\n+\n+      else if ((GET_MODE (XEXP (x, 0)) == CCFPmode\n+\t\t&& GET_CODE (x) != NE)\n+\t       || GET_CODE (x) == EQ\n+\t       || GET_CODE (x) == LT || GET_CODE (x) == GT\n+\t       || GET_CODE (x) == LTU || GET_CODE (x) == GTU)\n+\tfprintf (file, \"12\");\n+      else\n+\tfprintf (file, \"4\");\n+      return;\n+      \n+    case 'T':\n+      /* Opposite of 't': write 4 if this jump operation will branch if true,\n+\t 12 otherwise.   */\n+      if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n+\toutput_operand_lossage (\"invalid %%t value\");\n+\n+      else if ((GET_MODE (XEXP (x, 0)) == CCFPmode\n+\t\t&& GET_CODE (x) != NE)\n+\t       || GET_CODE (x) == EQ\n+\t       || GET_CODE (x) == LT || GET_CODE (x) == GT\n+\t       || GET_CODE (x) == LTU || GET_CODE (x) == GTU)\n+\tfprintf (file, \"4\");\n+      else\n+\tfprintf (file, \"12\");\n+      return;\n+      \n+    case 'j':\n+      /* Write the bit number in CCR for jump.  */\n+      i = ccr_bit (x, 0);\n+      if (i == -1)\n+\toutput_operand_lossage (\"invalid %%j code\");\n+      else\n+\tfprintf (file, \"%d\", i);\n+      return;\n+\n+    case 'J':\n+      /* Similar, but add one for shift count in rlinm for scc and pass\n+\t scc flag to `ccr_bit'.  */\n+      i = ccr_bit (x, 1);\n+      if (i == -1)\n+\toutput_operand_lossage (\"invalid %%J code\");\n+      else\n+\tfprintf (file, \"%d\", i + 1);\n+      return;\n+\n+    case 'C':\n+      /* This is an optional cror needed for LE or GE floating-point\n+\t comparisons.  Otherwise write nothing.  */\n+      if ((GET_CODE (x) == LE || GET_CODE (x) == GE)\n+\t  && GET_MODE (XEXP (x, 0)) == CCFPmode)\n+\t{\n+\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+\n+\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t   base_bit + 2, base_bit + (GET_CODE (x) == GE));\n+\t}\n+      return;\n+\n+    case 'D':\n+      /* Similar, except that this is for an scc, so we must be able to\n+\t encode the test in a single bit that is one.  We do the above\n+\t for any LE, GE, GEU, or LEU and invert the bit for NE.  */\n+      if (GET_CODE (x) == LE || GET_CODE (x) == GE\n+\t  || GET_CODE (x) == LEU || GET_CODE (x) == GEU)\n+\t{\n+\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+\n+\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t   base_bit + 2,\n+\t\t   base_bit + (GET_CODE (x) == GE || GET_CODE (x) == GEU));\n+\t}\n+\n+      else if (GET_CODE (x) == NE)\n+\t{\n+\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - 68);\n+\n+\t  fprintf (file, \"crnor %d,%d,%d\\n\\t\", base_bit + 3,\n+\t\t   base_bit + 2, base_bit + 2);\n+\t}\n+      return;\n+\n+    case 'z':\n+      /* X is a SYMBOL_REF.  Write out the name preceeded by a\n+\t period and without any trailing data in backets.  Used for function\n+\t names.  */\n+      if (GET_CODE (x) != SYMBOL_REF)\n+\tabort ();\n+\n+      fprintf (file, \".\");\n+      RS6000_OUTPUT_BASENAME (file, XSTR (x, 0));\n+      return;\n+\n+    case 0:\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* We need to handle PRE_INC and PRE_DEC here, since we need to\n+\t     know the width from the mode.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC)\n+\t    fprintf (file, \"%d(%d)\", GET_MODE_SIZE (GET_MODE (x)),\n+\t\t     REGNO (XEXP (XEXP (x, 0), 0)));\n+\t  else if (GET_CODE (XEXP (x, 0)) == PRE_DEC)\n+\t    fprintf (file, \"%d(%d)\", - GET_MODE_SIZE (GET_MODE (x)),\n+\t\t     REGNO (XEXP (XEXP (x, 0), 0)));\n+\t  else\n+\t    output_address (XEXP (x, 0));\n+\t}\n+      else\n+\toutput_addr_const (file, x);\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid %%xn code\");\n+    }\n+}\n+\f\n+/* Print the address of an operand.  */\n+\n+void\n+print_operand_address (file, x)\n+     FILE *file;\n+     register rtx x;\n+{\n+  if (GET_CODE (x) == REG)\n+    fprintf (file, \"0(%d)\", REGNO (x));\n+  else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n+    {\n+      output_addr_const (file, x);\n+      fprintf (file, \"(2)\");\n+    }\n+  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n+    {\n+      if (REGNO (XEXP (x, 0)) == 0)\n+\tfprintf (file, \"%d,%d\", REGNO (XEXP (x, 1)), REGNO (XEXP (x, 0)));\n+      else\n+\tfprintf (file, \"%d,%d\", REGNO (XEXP (x, 0)), REGNO (XEXP (x, 1)));\n+    }\n+  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    fprintf (file, \"%d(%d)\", INTVAL (XEXP (x, 1)), REGNO (XEXP (x, 0)));\n+  else\n+    abort ();\n+}\n+\f\n+/* This page contains routines that are used to determine what the function\n+   prologue and epilogue code will do and write them out.  */\n+\n+/*  Return the first fixed-point register that is required to be saved. 32 if\n+    none.  */\n+\n+int\n+first_reg_to_save ()\n+{\n+  int first_reg;\n+\n+  /* Find lowest numbered live register.  */\n+  for (first_reg = 13; first_reg <= 31; first_reg++)\n+    if (regs_ever_live[first_reg])\n+      break;\n+\n+  return first_reg;\n+}\n+\n+/* Similar, for FP regs.  */\n+\n+int\n+first_fp_reg_to_save ()\n+{\n+  int first_reg;\n+\n+  /* Find lowest numbered live register.  */\n+  for (first_reg = 14 + 32; first_reg <= 63; first_reg++)\n+    if (regs_ever_live[first_reg])\n+      break;\n+\n+  return first_reg;\n+}\n+\n+/* Return 1 if we need to save CR.  */\n+\n+int\n+must_save_cr ()\n+{\n+  return regs_ever_live[70] || regs_ever_live[71] || regs_ever_live[72];\n+}\n+\n+/* Compute the size of the save area in the stack, including the space for\n+   the fixed area.  */\n+\n+int\n+rs6000_sa_size ()\n+{\n+  int size;\n+  int i;\n+\n+  /* We have the six fixed words, plus the size of the register save \n+     areas, rounded to a double-word.  */\n+  size = 6 + (32 - first_reg_to_save ()) + (64 - first_fp_reg_to_save ()) * 2;\n+  if (size & 1)\n+    size++;\n+\n+  return size * 4;\n+}\n+\n+/* Return non-zero if this function makes calls.  */\n+\n+int\n+rs6000_makes_calls ()\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = next_insn (insn))\n+    if (GET_CODE (insn) == CALL_INSN)\n+      return 1;\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if this function needs to push space on the stack.  */\n+\n+int\n+rs6000_pushes_stack ()\n+{\n+  int total_size = (rs6000_sa_size () + get_frame_size ()\n+\t\t    + current_function_outgoing_args_size);\n+\n+  /* We need to push the stack if a frame pointer is needed (because the\n+     stack might be dynamically adjusted), if we are debugging, if the\n+     total stack size is more than 220 bytes, or if we make calls.  */\n+\n+  return (frame_pointer_needed || write_symbols != NO_DEBUG\n+\t  || total_size > 220\n+\t  || rs6000_makes_calls ());\n+}\n+\n+/* Write function prologue.  */\n+\n+void\n+output_prolog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int first_reg = first_reg_to_save ();\n+  int must_push = rs6000_pushes_stack ();\n+  int first_fp_reg = first_fp_reg_to_save ();\n+  int basic_size = rs6000_sa_size ();\n+  int total_size = (basic_size + size + current_function_outgoing_args_size);\n+\n+  /* Round size to multiple of 8 bytes.  */\n+  total_size = (total_size + 7) & ~7;\n+\n+  /* Write .extern for any function we will call to save and restore fp\n+     values.  */\n+  if (first_fp_reg < 62)\n+    fprintf (file, \"\\t.extern ._savef%d\\n\\t.extern ._restf%d\\n\",\n+\t     first_fp_reg - 32, first_fp_reg - 32);\n+\n+  /* Write .extern for truncation routines, if needed.  */\n+  if (rs6000_trunc_used && ! trunc_defined)\n+    {\n+      fprintf (file, \"\\t.extern .itrunc\\n\\t.extern .uitrunc\\n\");\n+      trunc_defined = 1;\n+    }\n+\n+  /* If we have to call a function to save fpr's, we will be using LR.  */\n+  if (first_fp_reg < 62)\n+    regs_ever_live[65] = 1;\n+\n+  /* If we use the link register, get it into r0.  */\n+  if (regs_ever_live[65])\n+    fprintf (file, \"\\tmflr 0\\n\");\n+\n+  /* If we need to save CR, put it into r12.  */\n+  if (must_save_cr ())\n+    fprintf (file, \"\\tmfcr 12\\n\");\n+\n+  /* Do any required saving of fpr's.  If only one or two to save, do it\n+     ourself.  Otherwise, call function.  */\n+  if (first_fp_reg == 62)\n+    fprintf (file, \"\\tstfd 30,-16(1)\\n\\tstfd 31,-8(1)\\n\");\n+  else if (first_fp_reg == 63)\n+    fprintf (file, \"\\tstfd 31,-8(1)\\n\");\n+  else if (first_fp_reg != 64)\n+    fprintf (file, \"\\tbl ._savef%d\\n\\tcror 15,15,15\\n\", first_fp_reg - 32);\n+\n+  /* Now save gpr's.  */\n+  if (first_reg == 31)\n+    fprintf (file, \"\\tst 31,%d(1)\\n\", -4 - (64 - first_fp_reg) * 8);\n+  else if (first_reg != 32)\n+    fprintf (file, \"\\tstm %d,%d(1)\\n\", first_reg,\n+\t     - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n+\n+  /* Save lr if we used it.  */\n+  if (regs_ever_live[65])\n+    fprintf (file, \"\\tst 0,8(1)\\n\");\n+\n+  /* Save CR if we use any that must be preserved.  */\n+  if (must_save_cr ())\n+    fprintf (file, \"\\tst 12,4(1)\\n\");\n+\n+  /* Update stack and set back pointer.  */\n+  if (must_push)\n+    {\n+      if (total_size < 32767)\n+\tfprintf (file, \"\\tstu 1,%d(1)\\n\", - total_size);\n+      else\n+\t{\n+\t  fprintf (file, \"\\tcau 0,0,%d\\n\\toril 0,0,%d\\n\",\n+\t\t   (total_size >> 16) & 0xffff, total_size & 0xffff);\n+\t  fprintf (file, \"\\tsf 12,0,1\\n\\tst 1,0(12)\\n\\toril 1,12,0\\n\");\n+\t}\n+    }\n+\n+  /* Set frame pointer, if needed.  */\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\toril 31,1,0\\n\");\n+}\n+\n+/* Write function epilogue.  */\n+\n+void\n+output_epilog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int first_reg = first_reg_to_save ();\n+  int must_push = rs6000_pushes_stack ();\n+  int first_fp_reg = first_fp_reg_to_save ();\n+  int basic_size = rs6000_sa_size ();\n+  int total_size = (basic_size + size + current_function_outgoing_args_size);\n+  rtx insn = get_last_insn ();\n+\n+  /* Round size to multiple of 8 bytes.  */\n+  total_size = (total_size + 7) & ~7;\n+\n+  /* If the last insn was a BARRIER, we don't have to write anything except\n+     the trace table.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn == 0 ||  GET_CODE (insn) != BARRIER)\n+    {\n+      /* If we have a frame pointer, a call to alloca,  or a large stack\n+\t frame, restore the old stack pointer using the backchain.  Otherwise,\n+\t we know what size to update it with.  */\n+      if (frame_pointer_needed || current_function_calls_alloca\n+\t  || total_size > 32767)\n+\tfprintf (file, \"\\tl 1,0(1)\\n\");\n+      else if (must_push)\n+\tfprintf (file, \"\\tai 1,1,%d\\n\", total_size);\n+\n+      /* Get the old lr if we saved it.  To speed things up, copy it into\n+\t lr here if we don't have to save more than 2 fp regs.  */\n+      if (regs_ever_live[65])\n+\t{\n+\t  fprintf (file, \"\\tl 0,8(1)\\n\");\n+\t  if (first_fp_reg >= 62)\n+\t    fprintf (file, \"\\tmtlr 0\\n\");\n+\t}\n+\n+      /* Get the old cr if we saved it.  */\n+      if (must_save_cr ())\n+\tfprintf (file, \"\\tl 12,4(1)\\n\");\n+\n+      /* Restore gpr's.  */\n+      if (first_reg == 31)\n+\tfprintf (file, \"\\tl 31,%d(1)\\n\", -4 - (64 - first_fp_reg) * 8);\n+      else if (first_reg != 32)\n+\tfprintf (file, \"\\tlm %d,%d(1)\\n\", first_reg,\n+\t\t - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n+\n+      /* Restore fpr's.  */\n+      if (first_fp_reg == 62)\n+\tfprintf (file, \"\\tlfd 30,-16(1)\\n\\tlfd 31,-8(1)\\n\");\n+      else if (first_fp_reg == 63)\n+\tfprintf (file, \"\\tlfd 31,-8(1)\\n\");\n+      else if (first_fp_reg != 64)\n+\tfprintf (file, \"\\tbl ._restf%d\\n\\tcror 15,15,15\\n\", first_fp_reg - 32);\n+\n+      /* If we used the link register, get it from r0 if we haven't\n+\t already.  */\n+      if (regs_ever_live[65] && first_fp_reg < 62)\n+\tfprintf (file, \"\\tmtlr 0\\n\");\n+\n+      /* If we saved cr, restore it here.  Just set cr2, cr3, and cr4.  */\n+      if (must_save_cr ())\n+\tfprintf (file, \"\\tmtcrf 0x38,12\\n\");\n+\n+      fprintf (file, \"\\tbr\\n\");\n+    }\n+}\n+\f\n+/* Output a TOC entry.  We derive the entry name from what is\n+   being written.  */\n+\n+void\n+output_toc (file, x, labelno)\n+     FILE *file;\n+     rtx x;\n+     int labelno;\n+{\n+  char buf[256];\n+  char *name = buf;\n+  rtx base = x;\n+  int offset = 0;\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"LC\", labelno);\n+\n+  /* Handle FP constants specially.  */\n+  if (GET_CODE (x) == CONST_DOUBLE\n+      && GET_MODE (x) == DFmode\n+      && TARGET_FLOAT_FORMAT == HOST_FLOAT_FORMAT\n+      && BITS_PER_WORD == HOST_BITS_PER_INT\n+      && TARGET_FP_IN_TOC)\n+    {\n+      fprintf (file, \"\\t.tc FD_%x_%x[TC],%d,%d\\n\",\n+\t       CONST_DOUBLE_LOW (x), CONST_DOUBLE_HIGH (x),\n+\t       CONST_DOUBLE_LOW (x), CONST_DOUBLE_HIGH (x));\n+      return;\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode\n+\t   && TARGET_FP_IN_TOC)\n+    {\n+      rtx val = operand_subword (x, 0, 0, SFmode);\n+\n+      if (val == 0 || GET_CODE (val) != CONST_INT)\n+\tabort ();\n+\n+      fprintf (file, \"\\t.tc FS_%x[TC],%d\\n\", INTVAL (val), INTVAL (val));\n+      return;\n+    }\n+\n+  if (GET_CODE (x) == CONST)\n+    {\n+      base = XEXP (XEXP (x, 0), 0);\n+      offset = INTVAL (XEXP (XEXP (x, 0), 1));\n+    }\n+  \n+  if (GET_CODE (base) == SYMBOL_REF)\n+    name = XSTR (base, 0);\n+  else if (GET_CODE (base) == LABEL_REF)\n+    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (XEXP (base, 0)));\n+  else if (GET_CODE (base) == CODE_LABEL)\n+    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (base));\n+  else\n+    abort ();\n+\n+  fprintf (file, \"\\t.tc \");\n+  RS6000_OUTPUT_BASENAME (file, name);\n+\n+  if (offset < 0)\n+    fprintf (file, \"P.N.%d\", - offset);\n+  else if (offset)\n+    fprintf (file, \".P.%d\", offset);\n+\n+  fprintf (file, \"[TC],\");\n+  output_addr_const (file, x);\n+  fprintf (file, \"\\n\");\n+}\n+\f\n+/* Output an assembler pseudo-op to write an ASCII string of N characters\n+   starting at P to FILE.\n+\n+   On the RS/6000, we have to do this using the .byte operation and\n+   write out special characters outside the quoted string.\n+   Also, the assembler is broken; very long strings are truncated,\n+   so we must artificially break them up early. */\n+\n+void\n+output_ascii (file, p, n)\n+     FILE *file;\n+     char *p;\n+     int n;\n+{\n+  char c;\n+  int i, count_string;\n+  char *for_string = \"\\t.byte \\\"\";\n+  char *for_decimal = \"\\t.byte \";\n+  char *to_close = NULL;\n+\n+  count_string = 0;\n+  for (i = 0; i < n; i++)\n+    {\n+      c = *p++;\n+      if (c >= ' ' && c < 0177)\n+\t{\n+\t  if (for_string)\n+\t    fputs (for_string, file);\n+\t  putc (c, file);\n+\n+\t  /* Write two quotes to get one.  */\n+\t  if (c == '\"')\n+\t    {\n+\t      putc (c, file);\n+\t      ++count_string;\n+\t    }\n+\n+\t  for_string = NULL;\n+\t  for_decimal = \"\\\"\\n\\t.byte \";\n+\t  to_close = \"\\\"\\n\";\n+\t  ++count_string;\n+\n+\t  if (count_string >= 512)\n+\t    {\n+\t      fputs (to_close, file);\n+\n+\t      for_string = \"\\t.byte \\\"\";\n+\t      for_decimal = \"\\t.byte \";\n+\t      to_close = NULL;\n+\t      count_string = 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (for_decimal)\n+\t    fputs (for_decimal, file);\n+\t  fprintf (file, \"%d\", c);\n+\n+\t  for_string = \"\\n\\t.byte \\\"\";\n+\t  for_decimal = \", \";\n+\t  to_close = \"\\n\";\n+\t  count_string = 0;\n+\t}\n+    }\n+\n+  /* Now close the string if we have written one.  Then end the line.  */\n+  if (to_close)\n+    fprintf (file, to_close);\n+}\n+\f\n+/* Generate a unique section name for FILENAME for a section type\n+   represented by SECTION_DESC.  Output goes into BUF.\n+\n+   SECTION_DESC can be any string, as long as it is different for each\n+   possible section type.\n+\n+   We name the section in the same manner as xlc.  The name begins with an\n+   underscore followed by the filename (after stripping any leading directory\n+   names) with the period replaced by the string SECTION_DESC.  If FILENAME\n+   does not contain a period, SECTION_DESC is appended at the end of the\n+   name.  */\n+\n+void\n+rs6000_gen_section_name (buf, filename, section_desc)\n+     char **buf;\n+     char *filename;\n+     char *section_desc;\n+{\n+  char *q, *after_last_slash;\n+  char *p;\n+  int len;\n+  int used_desc = 0;\n+\n+  after_last_slash = filename;\n+  for (q = filename; *q; q++)\n+    if (*q == '/')\n+      after_last_slash = q + 1;\n+\n+  len = strlen (filename) + strlen (section_desc) + 2;\n+  *buf = (char *) permalloc (len);\n+\n+  p = *buf;\n+  *p++ = '_';\n+\n+  for (q = after_last_slash; *q; q++)\n+    {\n+      if (*q == '.')\n+        {\n+\t  strcpy (p, section_desc);\n+\t  p += strlen (section_desc);\n+\t  used_desc = 1;\n+        }\n+\n+      else if (isalnum (*q))\n+        *p++ = *q;\n+    }\n+\n+  if (! used_desc)\n+    strcpy (p, section_desc);\n+  else\n+    *p = '\\0';\n+}"}]}