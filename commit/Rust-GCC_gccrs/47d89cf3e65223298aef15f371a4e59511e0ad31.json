{"sha": "47d89cf3e65223298aef15f371a4e59511e0ad31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkODljZjNlNjUyMjMyOThhZWYxNWYzNzFhNGU1OTUxMWUwYWQzMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-11T07:33:39Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-11T07:33:39Z"}, "message": "c-lex.c (map): Make const.\n\n\t* c-lex.c (map): Make const.\n\t(cb_file_change): Update for callback passing a line map.\n\tDon't assume we have a previous map.  Remove sanity check\n\tabout popping too many files.\n\t* cpperror.c (print_location): Make map const.\n\t* cppfiles.c (stack_include_file): Update; line maps now hold sysp.\n\t(cpp_make_system_header): Similarly.\n\t(search_from): Similarly.\n\t(_cpp_execute_include): Don't remember where we came from.\n\t* cpphash.h (struct cpp_buffer): Remove return_to_line, sysp.\n\t(struct cpp_reader): Make map const.\n\t(CPP_IN_SYSTEM_HEADER, _cpp_do_file_change): Update.\n\t* cpplib.c (do_line): Update; line maps now hold sysp.\n\t(cpp_push_buffer): Similarly.\n\t(_cpp_do_file_change): Similarly; callback with map instead.\n\t(cpp_get_line_maps): Constify return value.\n\t(_cpp_pop_buffer): Update.\n\t* cpplib.h (struct cpp_file_change): Remove.\n\t(struct cpp_callbacks): Update.\n\t(cpp_get_line_maps): Constify return value.\n\t* cppmacro.c (_cpp_create_definition): Update.\n\t* cppmain.c (struct printer): Constify map.\n\t(maybe_print_line): Similarly.\n\t(print_line): Similarly.  Deduce flags 1 and 2 here.\n\t(cb_file_change): Update.\n\t* line-map.c (free_line_maps): Warn regardless.\n\t(add_line_map): Return pointer to const.  When passed NULL to_file\n\twith LC_LEAVE, use the obvious values for the return point so the\n\tcaller doesn't have to figure them out.\n\t(lookup_line): Return pointer to const.\n\t(print_containing_files): Take pointer to const.\n\t* line-map.h (struct line_map): New members reason, sysp.\n\t(add_line_map): Return pointer to const.\n\t(lookup_line): Similarly.\n\t(print_containing_files): Take pointer to const.\n\nFrom-SVN: r44789", "tree": {"sha": "c6597f82b6f803c65532fe99e5912e516912053f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6597f82b6f803c65532fe99e5912e516912053f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d89cf3e65223298aef15f371a4e59511e0ad31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d89cf3e65223298aef15f371a4e59511e0ad31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d89cf3e65223298aef15f371a4e59511e0ad31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d89cf3e65223298aef15f371a4e59511e0ad31/comments", "author": null, "committer": null, "parents": [{"sha": "16568b922ec8cd76f86cfe0a492c298c7c4f6d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16568b922ec8cd76f86cfe0a492c298c7c4f6d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16568b922ec8cd76f86cfe0a492c298c7c4f6d67"}], "stats": {"total": 326, "additions": 163, "deletions": 163}, "files": [{"sha": "c47fb22af5853c98f97522df711ad7f99e8c8836", "filename": "gcc/c-lex.c", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -58,7 +58,7 @@ Boston, MA 02111-1307, USA.  */\n static const char *cpp_filename;\n \n /* The current line map.  */\n-static struct line_map *map;\n+static const struct line_map *map;\n \n /* We may keep statistics about how long which files took to compile.  */\n static int header_time, body_time;\n@@ -91,7 +91,7 @@ static void update_header_times\tPARAMS ((const char *));\n static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n static void cb_ident\t\tPARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t\t const cpp_string *));\n-static void cb_file_change    PARAMS ((cpp_reader *, const cpp_file_change *));\n+static void cb_file_change    PARAMS ((cpp_reader *, const struct line_map *));\n static void cb_def_pragma\tPARAMS ((cpp_reader *, unsigned int));\n static void cb_define\t\tPARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t\t cpp_hashnode *));\n@@ -244,70 +244,65 @@ cb_ident (pfile, line, str)\n }\n \n static void\n-cb_file_change (pfile, fc)\n+cb_file_change (pfile, new_map)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const cpp_file_change *fc;\n+     const struct line_map *new_map;\n {\n-  unsigned int from_line = SOURCE_LINE (fc->map - 1, fc->line - 1);\n+  unsigned int to_line = SOURCE_LINE (new_map, new_map->to_line);\n \n-  if (fc->reason == LC_ENTER)\n+  if (new_map->reason == LC_ENTER)\n     {\n       /* Don't stack the main buffer on the input stack;\n \t we already did in compile_file.  */\n-      if (MAIN_FILE_P (fc->map))\n-\tmain_input_filename = fc->map->to_file;\n+      if (map == NULL)\n+\tmain_input_filename = new_map->to_file;\n       else\n \t{\n-\t  lineno = from_line;\n-\t  push_srcloc (fc->map->to_file, 1);\n+\t  lineno = SOURCE_LINE (new_map - 1, new_map->from_line - 1);\n+\t  push_srcloc (new_map->to_file, 1);\n \t  input_file_stack->indent_level = indent_level;\n-\t  (*debug_hooks->start_source_file) (lineno, fc->map->to_file);\n+\t  (*debug_hooks->start_source_file) (lineno, new_map->to_file);\n #ifndef NO_IMPLICIT_EXTERN_C\n \t  if (c_header_level)\n \t    ++c_header_level;\n-\t  else if (fc->externc)\n+\t  else if (new_map->sysp == 2)\n \t    {\n \t      c_header_level = 1;\n \t      ++pending_lang_change;\n \t    }\n #endif\n \t}\n     }\n-  else if (fc->reason == LC_LEAVE)\n+  else if (new_map->reason == LC_LEAVE)\n     {\n-      /* Popping out of a file.  */\n-      if (input_file_stack->next)\n-\t{\n #ifndef NO_IMPLICIT_EXTERN_C\n-\t  if (c_header_level && --c_header_level == 0)\n-\t    {\n-\t      if (fc->externc)\n-\t\twarning (\"badly nested C headers from preprocessor\");\n-\t      --pending_lang_change;\n-\t    }\n+      if (c_header_level && --c_header_level == 0)\n+\t{\n+\t  if (new_map->sysp == 2)\n+\t    warning (\"badly nested C headers from preprocessor\");\n+\t  --pending_lang_change;\n+\t}\n #endif\n #if 0\n-\t  if (indent_level != input_file_stack->indent_level)\n-\t    {\n-\t      warning_with_file_and_line\n-\t\t(input_filename, lineno,\n-\t\t \"This file contains more '%c's than '%c's.\",\n-\t\t indent_level > input_file_stack->indent_level ? '{' : '}',\n-\t\t indent_level > input_file_stack->indent_level ? '}' : '{');\n-\t    }\n-#endif\n-\t  pop_srcloc ();\n-\t  (*debug_hooks->end_source_file) (from_line);\n+      if (indent_level != input_file_stack->indent_level)\n+\t{\n+\t  warning_with_file_and_line\n+\t    (input_filename, lineno,\n+\t     \"This file contains more '%c's than '%c's.\",\n+\t     indent_level > input_file_stack->indent_level ? '{' : '}',\n+\t     indent_level > input_file_stack->indent_level ? '}' : '{');\n \t}\n-      else\n-\terror (\"leaving more files than we entered\");\n+#endif\n+      pop_srcloc ();\n+      \n+      (*debug_hooks->end_source_file) (to_line);\n     }\n \n-  update_header_times (fc->map->to_file);\n-  map = fc->map;\n-  in_system_header = fc->sysp != 0;\n-  input_filename = map->to_file;\n-  lineno = SOURCE_LINE (map, fc->line);\n+  update_header_times (new_map->to_file);\n+  in_system_header = new_map->sysp != 0;\n+  input_filename = new_map->to_file;\n+  lineno = to_line;\n+  map = new_map;\n \n   /* Hook for C++.  */\n   extract_interface_info ();"}, {"sha": "73cb418b473d54fbf57136fbc85d46af4da79126", "filename": "gcc/cpperror.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -61,7 +61,7 @@ print_location (pfile, filename, pos)\n \tline = 0;\n       else\n \t{\n-\t  struct line_map *map;\n+\t  const struct line_map *map;\n \n \t  if (type == BUF_PRAGMA)\n \t    buffer = buffer->prev;"}, {"sha": "657130400f1e088d5179d158e1373d634567d9f2", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -290,7 +290,7 @@ stack_include_file (pfile, inc)\n \n   /* We'll try removing deps_sysp after the release of 3.0.  */\n   deps_sysp = pfile->system_include_depth != 0;\n-  sysp = MAX ((pfile->buffer ? pfile->buffer->sysp : 0),\n+  sysp = MAX ((pfile->map ? pfile->map->sysp : 0),\n \t      (inc->foundhere ? inc->foundhere->sysp : 0));\n \n   /* For -M, add the file to the dependencies on its first inclusion.  */\n@@ -329,15 +329,14 @@ stack_include_file (pfile, inc)\n   fp = cpp_push_buffer (pfile, inc->buffer, len, BUF_FILE, inc->name, 0);\n   fp->inc = inc;\n   fp->inc->refcnt++;\n-  fp->sysp = sysp;\n \n   /* Initialise controlling macro state.  */\n   pfile->mi_valid = true;\n   pfile->mi_cmacro = 0;\n   pfile->include_depth++;\n \n   /* Generate the call back.  */\n-  _cpp_do_file_change (pfile, LC_ENTER, 1);\n+  _cpp_do_file_change (pfile, LC_ENTER, fp->nominal_fname, 1, sysp);\n }\n \n /* Read the file referenced by INC into the file cache.\n@@ -576,9 +575,8 @@ cpp_make_system_header (pfile, syshdr, externc)\n   /* 1 = system header, 2 = system header to be treated as C.  */\n   if (syshdr)\n     flags = 1 + (externc != 0);\n-  pfile->buffer->sysp = flags;\n-  _cpp_do_file_change (pfile, LC_RENAME,\n-\t\t       SOURCE_LINE (pfile->map, pfile->line));\n+  _cpp_do_file_change (pfile, LC_RENAME, pfile->map->to_file,\n+\t\t       SOURCE_LINE (pfile->map, pfile->line), flags);\n }\n \n /* Report on all files that might benefit from a multiple include guard.\n@@ -678,7 +676,6 @@ _cpp_execute_include (pfile, header, type)\n       if (header->type == CPP_HEADER_NAME)\n \tpfile->system_include_depth++;\n \n-      pfile->buffer->return_to_line = SOURCE_LINE (pfile->map, pfile->line);\n       stack_include_file (pfile, inc);\n \n       if (type == IT_IMPORT)\n@@ -808,7 +805,7 @@ search_from (pfile, type)\n \n       buffer->dir.len = dlen;\n       buffer->dir.next = CPP_OPTION (pfile, quote_include);\n-      buffer->dir.sysp = buffer->sysp;\n+      buffer->dir.sysp = pfile->map->sysp;\n     }\n \n   return &buffer->dir;"}, {"sha": "366655b71e92ee272cce08fc64940a02ab33fff2", "filename": "gcc/cpphash.h", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -66,7 +66,7 @@ struct cpp_chunk\n typedef struct cpp_pool cpp_pool;\n struct cpp_pool\n {\n-  struct cpp_chunk *cur, *locked;\n+  struct cpp_chunk *cur, *locked, *first;\n   unsigned char *pos;\t\t/* Current position.  */\n   unsigned int align;\n   unsigned int locks;\n@@ -190,11 +190,6 @@ struct cpp_buffer\n   /* Token column position adjustment owing to tabs in whitespace.  */\n   unsigned int col_adjust;\n \n-  /* The line of the buffer that we return to after a #include.\n-     Strictly this is redundant, since it can be calculated from the\n-     line maps, but it is clearest to save it here.  */\n-  unsigned int return_to_line;\n-\n   /* Contains PREV_WHITE and/or AVOID_LPASTE.  */\n   unsigned char saved_flags;\n \n@@ -213,9 +208,6 @@ struct cpp_buffer\n      buffers.  */\n   unsigned char from_stage3;\n \n-  /* 1 = system header file, 2 = C system header file used for C++.  */\n-  unsigned char sysp;\n-\n   /* Nonzero means that the directory to start searching for \"\"\n      include files has been calculated and stored in \"dir\" below.  */\n   unsigned char search_cached;\n@@ -247,7 +239,7 @@ struct cpp_reader\n \n   /* Source line tracking.  */\n   struct line_maps line_maps;\n-  struct line_map *map;\n+  const struct line_map *map;\n   unsigned int line;\n \n   /* The position of the last lexed token and last lexed directive.  */\n@@ -376,8 +368,7 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n /* Macros.  */\n \n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n-#define CPP_IN_SYSTEM_HEADER(PFILE) \\\n-  (CPP_BUFFER (PFILE) && CPP_BUFFER (PFILE)->sysp)\n+#define CPP_IN_SYSTEM_HEADER(PFILE) (pfile->map && pfile->map->sysp)\n #define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n #define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n \n@@ -439,7 +430,8 @@ extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_directives PARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n-\t\t\t\t\t unsigned int));\n+\t\t\t\t\t const char *,\n+\t\t\t\t\t unsigned int, unsigned int));\n extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */"}, {"sha": "9404a00ea8e8668c173ec3919b4338625c2551cc", "filename": "gcc/cpplib.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -713,7 +713,7 @@ do_line (pfile)\n   cpp_buffer *buffer = pfile->buffer;\n   enum lc_reason reason = LC_RENAME;\n   unsigned long new_lineno;\n-  unsigned int cap;\n+  unsigned int cap, sysp = pfile->map->sysp;\n   cpp_token token;\n \n   /* C99 raised the minimum limit on #line numbers.  */\n@@ -741,9 +741,10 @@ do_line (pfile)\n       /* Only accept flags for the # 55 form.  */\n       if (pfile->state.line_extension)\n \t{\n-\t  int flag = 0, sysp = 0;\n+\t  int flag;\n \n-\t  flag = read_flag (pfile, flag);\n+\t  sysp = 0;\n+\t  flag = read_flag (pfile, 0);\n \t  if (flag == 1)\n \t    {\n \t      reason = LC_ENTER;\n@@ -763,7 +764,6 @@ do_line (pfile)\n \t      if (flag == 4)\n \t\tsysp = 2;\n \t    }\n-\t  buffer->sysp = sysp;\n \t}\n       check_eol (pfile);\n     }\n@@ -775,34 +775,27 @@ do_line (pfile)\n     }\n \n   end_directive (pfile, 1);\n-  _cpp_do_file_change (pfile, reason, new_lineno);\n+  _cpp_do_file_change (pfile, reason, (const char *) buffer->nominal_fname,\n+\t\t       new_lineno, sysp);\n }\n \n /* Arrange the file_change callback.  pfile->line has changed to\n-   FILE_LINE of the current buffer, for reason REASON.  */\n+   FILE_LINE of TO_FILE, for reason REASON.  SYSP is 1 for a system\n+   header, 2 for a sytem header that needs to be extern \"C\" protected,\n+   and zero otherwise.  */\n void\n-_cpp_do_file_change (pfile, reason, file_line)\n+_cpp_do_file_change (pfile, reason, to_file, file_line, sysp)\n      cpp_reader *pfile;\n      enum lc_reason reason;\n+     const char *to_file;\n      unsigned int file_line;\n+     unsigned int sysp;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  \n-  pfile->map = add_line_map (&pfile->line_maps, reason,\n-\t\t\t     pfile->line, buffer->nominal_fname, file_line);\n+  pfile->map = add_line_map (&pfile->line_maps, reason, sysp,\n+\t\t\t     pfile->line, to_file, file_line);\n \n   if (pfile->cb.file_change)\n-    {\n-      cpp_file_change fc;\n-      \n-      fc.map = pfile->map;\n-      fc.line = pfile->line;\n-      fc.reason = reason;\n-      fc.sysp = buffer->sysp;\n-      fc.externc = CPP_OPTION (pfile, cplusplus) && buffer->sysp == 2;\n-\n-      (*pfile->cb.file_change) (pfile, &fc);\n-    }\n+    (*pfile->cb.file_change) (pfile, pfile->map);\n }\n \n /*\n@@ -908,7 +901,8 @@ cpp_register_pragma (pfile, space, name, handler)\n     }\n \n  found:\n-  new = xnew (struct pragma_entry);\n+  new = (struct pragma_entry *)\n+    _cpp_pool_alloc (&pfile->macro_pool, sizeof (struct pragma_entry));\n   new->name = name;\n   new->len = strlen (name);\n   new->isnspace = 0;\n@@ -936,7 +930,8 @@ cpp_register_pragma_space (pfile, space)\n       p = p->next;\n     }\n \n-  new = xnew (struct pragma_entry);\n+  new = (struct pragma_entry *)\n+    _cpp_pool_alloc (&pfile->macro_pool, sizeof (struct pragma_entry));\n   new->name = space;\n   new->len = len;\n   new->isnspace = 1;\n@@ -1722,7 +1717,7 @@ cpp_get_callbacks (pfile)\n }\n \n /* The line map set.  */\n-struct line_maps *\n+const struct line_maps *\n cpp_get_line_maps (pfile)\n      cpp_reader *pfile;\n {\n@@ -1764,7 +1759,6 @@ cpp_push_buffer (pfile, buffer, len, type, filename, return_at_eof)\n \n   new->line_base = new->buf = new->cur = buffer;\n   new->rlimit = buffer + len;\n-  new->sysp = 0;\n \n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n@@ -1813,7 +1807,7 @@ _cpp_pop_buffer (pfile)\n     {\n       /* Callbacks are not generated for popping the main file.  */\n       if (buffer->prev)\n-\t_cpp_do_file_change (pfile, LC_LEAVE, buffer->prev->return_to_line);\n+\t_cpp_do_file_change (pfile, LC_LEAVE, 0, 0, 0);\n \n       _cpp_pop_file_buffer (pfile, buffer);\n     }"}, {"sha": "acce60620fd3f47c3d88f883118a94cf21f86ed4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -387,20 +387,10 @@ struct cpp_options\n   unsigned char help_only;\n };\n \n-typedef struct cpp_file_change cpp_file_change;\n-struct cpp_file_change\n-{\n-  struct line_map *map;\t\t/* Line map, valid until next callback.  */\n-  unsigned int line;\t\t/* Logical line number of next line.  */\n-  enum lc_reason reason;\t/* Reason for change.  */\n-  unsigned char sysp;\t\t/* Nonzero if system header.  */\n-  unsigned char externc;\t/* Nonzero if wrapper needed.  */\n-};\n-\n /* Call backs.  */\n struct cpp_callbacks\n {\n-    void (*file_change) PARAMS ((cpp_reader *, const cpp_file_change *));\n+    void (*file_change) PARAMS ((cpp_reader *, const struct line_map *));\n     void (*include) PARAMS ((cpp_reader *, unsigned int,\n \t\t\t     const unsigned char *, const cpp_token *));\n     void (*define) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n@@ -501,7 +491,7 @@ extern int cpp_destroy PARAMS ((cpp_reader *));\n    through the pointer returned from cpp_get_callbacks, or set them\n    with cpp_set_callbacks.  */\n extern cpp_options *cpp_get_options PARAMS ((cpp_reader *));\n-extern struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\n+extern const struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\n extern cpp_callbacks *cpp_get_callbacks PARAMS ((cpp_reader *));\n extern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n "}, {"sha": "8eb67e1d3a3e6e996aafa8632f002c65077c5265", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -1466,7 +1466,7 @@ _cpp_create_definition (pfile, node)\n \t\t     && macro->expansion[0].val.node == node);\n \n   /* To suppress some diagnostics.  */\n-  macro->syshdr = pfile->buffer->sysp != 0;\n+  macro->syshdr = pfile->map->sysp != 0;\n \n   /* Commit the memory.  */\n   POOL_COMMIT (&pfile->macro_pool, macro->count * sizeof (cpp_token));"}, {"sha": "5cb0746bece9d1a53d93cf02336fadac77687467", "filename": "gcc/cppmain.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -31,8 +31,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n struct printer\n {\n   FILE *outf;\t\t\t/* Stream to write to.  */\n-  const char *syshdr_flags;\t/* System header flags, if any.  */\n-  struct line_map *map;\t\t/* Logical to physical line mappings.  */\n+  const struct line_map *map;\t/* Logical to physical line mappings.  */\n   unsigned int line;\t\t/* Line currently being written.  */\n   unsigned char printed;\t/* Nonzero if something output at line.  */\n };\n@@ -47,9 +46,9 @@ static void scan_translation_unit PARAMS ((cpp_reader *));\n static void check_multiline_token PARAMS ((cpp_string *));\n static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n-static void print_line PARAMS ((struct line_map *, unsigned int,\n+static void print_line PARAMS ((const struct line_map *, unsigned int,\n \t\t\t\tconst char *));\n-static void maybe_print_line PARAMS ((struct line_map *, unsigned int));\n+static void maybe_print_line PARAMS ((const struct line_map *, unsigned int));\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n@@ -59,7 +58,7 @@ static void cb_include\tPARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t const unsigned char *, const cpp_token *));\n static void cb_ident\t  PARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t   const cpp_string *));\n-static void cb_file_change PARAMS ((cpp_reader *, const cpp_file_change *));\n+static void cb_file_change PARAMS ((cpp_reader *, const struct line_map *));\n static void cb_def_pragma PARAMS ((cpp_reader *, unsigned int));\n \n const char *progname;\t\t/* Needs to be global.  */\n@@ -285,7 +284,7 @@ check_multiline_token (str)\n \n static void\n maybe_print_line (map, line)\n-     struct line_map *map;\n+     const struct line_map *map;\n      unsigned int line;\n {\n   /* End the previous line of text.  */\n@@ -308,9 +307,11 @@ maybe_print_line (map, line)\n     print_line (map, line, \"\");\n }\n \n+/* Output a line marker for logical line LINE.  Special flags are \"1\"\n+   or \"2\" indicating entering or leaving a file.  */\n static void\n print_line (map, line, special_flags)\n-     struct line_map *map;\n+     const struct line_map *map;\n      unsigned int line;\n      const char *special_flags;\n {\n@@ -321,9 +322,17 @@ print_line (map, line, special_flags)\n \n   print.line = line;\n   if (! options->no_line_commands)\n-    fprintf (print.outf, \"# %u \\\"%s\\\"%s%s\\n\",\n-\t     SOURCE_LINE (map, print.line), map->to_file,\n-\t     special_flags, print.syshdr_flags);\n+    {\n+      fprintf (print.outf, \"# %u \\\"%s\\\"%s\",\n+\t       SOURCE_LINE (map, print.line), map->to_file, special_flags);\n+\n+      if (map->sysp == 2)\n+\tfputs (\" 3 4\", print.outf);\n+      else if (map->sysp == 1)\n+\tfputs (\" 3\", print.outf);\n+\n+      putc ('\\n', print.outf);\n+    }\n }\n \n /* Callbacks.  */\n@@ -382,40 +391,32 @@ cb_include (pfile, line, dir, header)\n }\n \n /* The file name, line number or system header flags have changed, as\n-   described in FC.  NB: the old print.map must be considered invalid.  */\n+   described in MAP.  From this point on, the old print.map might be\n+   pointing to freed memory, and so must not be dereferenced.  */\n \n static void\n-cb_file_change (pfile, fc)\n+cb_file_change (pfile, map)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const cpp_file_change *fc;\n+     const struct line_map *map;\n {\n-  bool first_time = print.map == NULL;\n-\n-  /* Bring current file to correct line.  We handle the first file\n-     change callback specially, so that a first line of \"# 1 \"foo.c\"\n-     in file foo.i outputs just the foo.c line, and not a foo.i line.  */\n-  if (fc->reason == LC_ENTER && !first_time)\n-    maybe_print_line (fc->map - 1, fc->line - 1);\n-\n-  print.map = fc->map;\n-  if (fc->externc)\n-    print.syshdr_flags = \" 3 4\";\n-  else if (fc->sysp)\n-    print.syshdr_flags = \" 3\";\n-  else\n-    print.syshdr_flags = \"\";\n-\n-  if (!first_time)\n+  /* Not first time?  */\n+  if (print.map)\n     {\n       const char *flags = \"\";\n \n-      if (fc->reason == LC_ENTER)\n+      /* Bring current file to correct line when entering a new file.  */\n+      if (map->reason == LC_ENTER)\n+\tmaybe_print_line (map - 1, map->from_line - 1);\n+\n+      if (map->reason == LC_ENTER)\n \tflags = \" 1\";\n-      else if (fc->reason == LC_LEAVE)\n+      else if (map->reason == LC_LEAVE)\n \tflags = \" 2\";\n \n-      print_line (print.map, fc->line, flags);\n+      print_line (map, map->from_line, flags);\n     }\n+\n+  print.map = map;\n }\n \n /* Copy a #pragma directive to the preprocessed output.  LINE is the"}, {"sha": "d1df5572b83cd24d95c5c6002dca0eb42949e5f5", "filename": "gcc/line-map.c", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -45,14 +45,15 @@ free_line_maps (set)\n {\n   if (set->maps)\n     {\n-#ifdef ENABLE_CHECKING\n       struct line_map *map;\n \n+      /* Depending upon whether we are handling preprocessed input or\n+\t not, this can be a user error or an ICE.  */\n       for (map = CURRENT_LINE_MAP (set); ! MAIN_FILE_P (map);\n \t   map = INCLUDED_FROM (set, map))\n \tfprintf (stderr, \"line-map.c: file \\\"%s\\\" entered but not left\\n\",\n \t\t map->to_file);\n-#endif\n+\n       free (set->maps);\n     }\n }\n@@ -64,10 +65,11 @@ free_line_maps (set)\n    FROM_LINE should be monotonic increasing across calls to this\n    function.  */\n \n-struct line_map *\n-add_line_map (set, reason, from_line, to_file, to_line)\n+const struct line_map *\n+add_line_map (set, reason, sysp, from_line, to_file, to_line)\n      struct line_maps *set;\n      enum lc_reason reason;\n+     unsigned int sysp;\n      unsigned int from_line;\n      const char *to_file;\n      unsigned int to_line;\n@@ -85,27 +87,49 @@ add_line_map (set, reason, from_line, to_file, to_line)\n     }\n \n   map = &set->maps[set->used];\n-  map->from_line = from_line;\n-  map->to_file = to_file;\n-  map->to_line = to_line;\n \n   /* If we don't keep our line maps consistent, we can easily\n      segfault.  Don't rely on the client to do it for us.  */\n   if (set->used == 0)\n     reason = LC_ENTER;\n   else if (reason == LC_LEAVE)\n     {\n-      if (MAIN_FILE_P (map - 1)\n-\t  || strcmp (INCLUDED_FROM (set, map - 1)->to_file, to_file))\n+      struct line_map *from;\n+      bool error;\n+\n+      if (MAIN_FILE_P (map - 1))\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  fprintf (stderr, \"line-map.c: file \\\"%s\\\" left but not entered\\n\",\n-\t\t   to_file);\n-#endif\n+\t  error = true;\n \t  reason = LC_RENAME;\n+\t  from = map - 1;\n+\t}\n+      else\n+\t{\n+\t  from = INCLUDED_FROM (set, map - 1);\n+\t  error = to_file && strcmp (from->to_file, to_file);\n+\t}\n+\n+      /* Depending upon whether we are handling preprocessed input or\n+\t not, this can be a user error or an ICE.  */\n+      if (error)\n+\tfprintf (stderr, \"line-map.c: file \\\"%s\\\" left but not entered\\n\",\n+\t\t to_file);\n+\n+      /* A TO_FILE of NULL is special - we use the natural values.  */\n+      if (error || to_file == NULL)\n+\t{\n+\t  to_file = from->to_file;\n+\t  to_line = LAST_SOURCE_LINE (from) + 1;\n+\t  sysp = from->sysp;\n \t}\n     }\n \n+  map->reason = reason;\n+  map->sysp = sysp;\n+  map->from_line = from_line;\n+  map->to_file = to_file;\n+  map->to_line = to_line;\n+\n   if (reason == LC_ENTER)\n     map->included_from = set->used - 1;\n   else if (reason == LC_RENAME)\n@@ -122,7 +146,7 @@ add_line_map (set, reason, from_line, to_file, to_line)\n    chronologically, the logical lines are monotonic increasing, and so\n    the list is sorted and we can use a binary search.  */\n \n-struct line_map *\n+const struct line_map *\n lookup_line (set, line)\n      struct line_maps *set;\n      unsigned int line;\n@@ -151,7 +175,7 @@ lookup_line (set, line)\n void\n print_containing_files (set, map)\n      struct line_maps *set;\n-     struct line_map *map;\n+     const struct line_map *map;\n {\n   if (MAIN_FILE_P (map) || set->last_listed == map->included_from)\n     return;"}, {"sha": "ed02420e1122a5a4899cc60db16b599e7ea6b37c", "filename": "gcc/line-map.h", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d89cf3e65223298aef15f371a4e59511e0ad31/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=47d89cf3e65223298aef15f371a4e59511e0ad31", "patch": "@@ -23,17 +23,29 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #ifndef GCC_LINE_MAP_H\n #define GCC_LINE_MAP_H\n \n+/* Reason for adding a line change with add_line_map ().  LC_ENTER is\n+   when including a new file, e.g. a #include directive in C.\n+   LC_LEAVE is when reaching a file's end.  LC_RENAME is when a file\n+   name or line number changes for neither of the above reasons\n+   (e.g. a #line directive in C).  */\n+enum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n+\n /* The logical line FROM_LINE maps to physical source file TO_FILE at\n    line TO_LINE, and subsequently one-to-one until the next line_map\n    structure in the set.  INCLUDED_FROM is an index into the set that\n    gives the line mapping at whose end the current one was included.\n-   File(s) at the bottom of the include stack have this set to -1.  */\n+   File(s) at the bottom of the include stack have this set to -1.\n+   REASON is the reason for creation of this line map, SYSP is one for\n+   a system header, two for a C system header file that therefore\n+   needs to be extern \"C\" protected in C++, and zero otherwise.  */\n struct line_map\n {\n   const char *to_file;\n   unsigned int to_line;\n   unsigned int from_line;\n   int included_from;\n+  ENUM_BITFIELD (lc_reason) reason : CHAR_BIT;\n+  unsigned char sysp;\n };\n \n /* A set of chronological line_map structures.  */\n@@ -49,13 +61,6 @@ struct line_maps\n   int last_listed;\n };\n \n-/* Reason for adding a line change with add_line_map ().  LC_ENTER is\n-   when including a new file, e.g. a #include directive in C.\n-   LC_LEAVE is when reaching a file's end.  LC_RENAME is when a file\n-   name or line number changes for neither of the above reasons\n-   (e.g. a #line directive in C).  */\n-enum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n-\n /* Initialize a line map set.  */\n extern void init_line_maps\n   PARAMS ((struct line_maps *));\n@@ -66,25 +71,27 @@ extern void free_line_maps\n \n /* Add a mapping of logical source line to physical source file and\n    line number.  The text pointed to by TO_FILE must have a lifetime\n-   at least as long as the final call to lookup_line ().\n+   at least as long as the line maps.  If reason is LC_LEAVE, and\n+   TO_FILE is NULL, then TO_FILE, TO_LINE and SYSP are given their\n+   natural values considering the file we are returning to.\n \n    FROM_LINE should be monotonic increasing across calls to this\n    function.  A call to this function can relocate the previous set of\n    maps, so any stored line_map pointers should not be used.  */\n-extern struct line_map *add_line_map\n-  PARAMS ((struct line_maps *, enum lc_reason,\n+extern const struct line_map *add_line_map\n+  PARAMS ((struct line_maps *, enum lc_reason, unsigned int sysp,\n \t   unsigned int from_line, const char *to_file, unsigned int to_line));\n \n /* Given a logical line, returns the map from which the corresponding\n    (source file, line) pair can be deduced.  */\n-extern struct line_map *lookup_line\n+extern const struct line_map *lookup_line\n   PARAMS ((struct line_maps *, unsigned int));\n \n /* Print the file names and line numbers of the #include commands\n    which led to the map MAP, if any, to stderr.  Nothing is output if\n    the most recently listed stack is the same as the current one.  */\n extern void print_containing_files\n-  PARAMS ((struct line_maps *, struct line_map *));\n+  PARAMS ((struct line_maps *, const struct line_map *));\n \n /* Converts a map and logical line to source line.  */\n #define SOURCE_LINE(MAP, LINE) ((LINE) + (MAP)->to_line - (MAP)->from_line)"}]}