{"sha": "b098aaf2ae8a6323bcc18933a6269e6846a634e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA5OGFhZjJhZThhNjMyM2JjYzE4OTMzYTYyNjllNjg0NmE2MzRlMA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2007-02-25T20:56:46Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2007-02-25T20:56:46Z"}, "message": "reload.c (find_reloads_address_1): Handle PLUS expressions resulting from register elimination as PRE_MODIFY /...\n\n\t* reload.c (find_reloads_address_1): Handle PLUS expressions resulting\n\tfrom register elimination as PRE_MODIFY / POST_MODIFY increments.\n\tDo not attempt to handle MEM inside auto-inc expressions.\n\t* reload1.c (eliminate_regs_1): Do not attempt to handle elimination\n\tof a register modified by an auto-inc expression.  However, do handle\n\telimination of a register used as PRE_MODIFY / POST_MODIFY increment.\n\t(elimination_effects): Prohibit elimination of a register modified\n\tby an auto-inc expression.  Disable register elimination rules whose\n\ttarget register is modified by an auto-inc expression with variable\n\tincrement.\n\nFrom-SVN: r122318", "tree": {"sha": "f43a6eb2bfabc2b51c7f153a8a2a49f931ad9e74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f43a6eb2bfabc2b51c7f153a8a2a49f931ad9e74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b098aaf2ae8a6323bcc18933a6269e6846a634e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b098aaf2ae8a6323bcc18933a6269e6846a634e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b098aaf2ae8a6323bcc18933a6269e6846a634e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b098aaf2ae8a6323bcc18933a6269e6846a634e0/comments", "author": null, "committer": null, "parents": [{"sha": "ae19c0415ca51979541adc2baab05383f41e5284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae19c0415ca51979541adc2baab05383f41e5284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae19c0415ca51979541adc2baab05383f41e5284"}], "stats": {"total": 110, "additions": 63, "deletions": 47}, "files": [{"sha": "2ed49124480c1babcefbae2c20c2407ac7cdfe20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b098aaf2ae8a6323bcc18933a6269e6846a634e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b098aaf2ae8a6323bcc18933a6269e6846a634e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b098aaf2ae8a6323bcc18933a6269e6846a634e0", "patch": "@@ -1,3 +1,16 @@\n+2007-02-25  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads_address_1): Handle PLUS expressions resulting\n+\tfrom register elimination as PRE_MODIFY / POST_MODIFY increments.\n+\tDo not attempt to handle MEM inside auto-inc expressions.\n+\t* reload1.c (eliminate_regs_1): Do not attempt to handle elimination\n+\tof a register modified by an auto-inc expression.  However, do handle\n+\telimination of a register used as PRE_MODIFY / POST_MODIFY increment.\n+\t(elimination_effects): Prohibit elimination of a register modified\n+\tby an auto-inc expression.  Disable register elimination rules whose\n+\ttarget register is modified by an auto-inc expression with variable\n+\tincrement.\n+\n 2007-02-25  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-loop-niter.c (compute_estimated_nb_iterations): Fix"}, {"sha": "c297494f11960a5f820a961cac2dd8c6c69c67e9", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b098aaf2ae8a6323bcc18933a6269e6846a634e0/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b098aaf2ae8a6323bcc18933a6269e6846a634e0/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b098aaf2ae8a6323bcc18933a6269e6846a634e0", "patch": "@@ -5543,16 +5543,20 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t   auto-modify by a constant then we could try replacing a pseudo\n \t   register with its equivalent constant where applicable.\n \n+\t   We also handle the case where the register was eliminated\n+\t   resulting in a PLUS subexpression.\n+\n \t   If we later decide to reload the whole PRE_MODIFY or\n \t   POST_MODIFY, inc_for_reload might clobber the reload register\n \t   before reading the index.  The index register might therefore\n \t   need to live longer than a TYPE reload normally would, so be\n \t   conservative and class it as RELOAD_OTHER.  */\n-\tif (REG_P (XEXP (op1, 1)))\n-\t  if (!REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n-\t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,\n-\t\t\t\t    &XEXP (op1, 1), opnum, RELOAD_OTHER,\n-\t\t\t\t    ind_levels, insn);\n+\tif ((REG_P (XEXP (op1, 1))\n+\t     && !REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n+\t    || GET_CODE (XEXP (op1, 1)) == PLUS)\n+\t  find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,\n+\t\t\t\t  &XEXP (op1, 1), opnum, RELOAD_OTHER,\n+\t\t\t\t  ind_levels, insn);\n \n \tgcc_assert (REG_P (XEXP (op1, 0)));\n \n@@ -5733,43 +5737,6 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t    }\n \t  return value;\n \t}\n-\n-      else if (MEM_P (XEXP (x, 0)))\n-\t{\n-\t  /* This is probably the result of a substitution, by eliminate_regs,\n-\t     of an equivalent address for a pseudo that was not allocated to a\n-\t     hard register.  Verify that the specified address is valid and\n-\t     reload it into a register.  */\n-\t  /* Variable `tem' might or might not be used in FIND_REG_INC_NOTE.  */\n-\t  rtx tem ATTRIBUTE_UNUSED = XEXP (x, 0);\n-\t  rtx link;\n-\t  int reloadnum;\n-\n-\t  /* Since we know we are going to reload this item, don't decrement\n-\t     for the indirection level.\n-\n-\t     Note that this is actually conservative:  it would be slightly\n-\t     more efficient to use the value of SPILL_INDIRECT_LEVELS from\n-\t     reload1.c here.  */\n-\t  /* We can't use ADDR_TYPE (type) here, because we need to\n-\t     write back the value after reading it, hence we actually\n-\t     need two registers.  */\n-\t  find_reloads_address (GET_MODE (x), &XEXP (x, 0),\n-\t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n-\t\t\t\topnum, type, ind_levels, insn);\n-\n-\t  reloadnum = push_reload (x, NULL_RTX, loc, (rtx*) 0,\n-\t\t\t\t   context_reg_class,\n-\t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t  rld[reloadnum].inc\n-\t    = find_inc_amount (PATTERN (this_insn), XEXP (x, 0));\n-\n-\t  link = FIND_REG_INC_NOTE (this_insn, tem);\n-\t  if (link != 0)\n-\t    push_replacement (&XEXP (link, 0), reloadnum, VOIDmode);\n-\n-\t  return 1;\n-\t}\n       return 0;\n \n     case TRUNCATE:"}, {"sha": "c469fb0761836d752cb5b343a0e1d199649a00d0", "filename": "gcc/reload1.c", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b098aaf2ae8a6323bcc18933a6269e6846a634e0/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b098aaf2ae8a6323bcc18933a6269e6846a634e0/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b098aaf2ae8a6323bcc18933a6269e6846a634e0", "patch": "@@ -2548,6 +2548,30 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n     case POST_INC:\n     case PRE_DEC:\n     case POST_DEC:\n+      /* We do not support elimination of a register that is modified.\n+\t elimination_effects has already make sure that this does not\n+\t happen.  */\n+      return x;\n+\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      /* We do not support elimination of a register that is modified.\n+\t elimination_effects has already make sure that this does not\n+\t happen.  The only remaining case we need to consider here is\n+\t that the increment value may be an eliminable register.  */\n+      if (GET_CODE (XEXP (x, 1)) == PLUS\n+\t  && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n+\t{\n+\t  rtx new = eliminate_regs_1 (XEXP (XEXP (x, 1), 1), mem_mode,\n+\t\t\t\t      insn, true);\n+\n+\t  if (new != XEXP (XEXP (x, 1), 1))\n+\t    return gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t   gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t\t\t\t XEXP (x, 0), new));\n+\t}\n+      return x;\n+\n     case STRICT_LOW_PART:\n     case NEG:          case NOT:\n     case SIGN_EXTEND:  case ZERO_EXTEND:\n@@ -2743,6 +2767,14 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n     case POST_DEC:\n     case POST_MODIFY:\n     case PRE_MODIFY:\n+      /* If we modify the source of an elimination rule, disable it.  */\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->from_rtx == XEXP (x, 0))\n+\t  ep->can_eliminate = 0;\n+\n+      /* If we modify the target of an elimination rule by adding a constant,\n+\t update its offset.  If we modify the target in any other way, we'll\n+\t have to disable the rule as well.  */\n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \tif (ep->to_rtx == XEXP (x, 0))\n \t  {\n@@ -2757,11 +2789,15 @@ elimination_effects (rtx x, enum machine_mode mem_mode)\n \t      ep->offset += size;\n \t    else if (code == PRE_INC || code == POST_INC)\n \t      ep->offset -= size;\n-\t    else if ((code == PRE_MODIFY || code == POST_MODIFY)\n-\t\t     && GET_CODE (XEXP (x, 1)) == PLUS\n-\t\t     && XEXP (x, 0) == XEXP (XEXP (x, 1), 0)\n-\t\t     && CONSTANT_P (XEXP (XEXP (x, 1), 1)))\n-\t      ep->offset -= INTVAL (XEXP (XEXP (x, 1), 1));\n+\t    else if (code == PRE_MODIFY || code == POST_MODIFY)\n+\t      {\n+\t\tif (GET_CODE (XEXP (x, 1)) == PLUS\n+\t\t    && XEXP (x, 0) == XEXP (XEXP (x, 1), 0)\n+\t\t    && CONST_INT_P (XEXP (XEXP (x, 1), 1)))\n+\t\t  ep->offset -= INTVAL (XEXP (XEXP (x, 1), 1));\n+\t\telse\n+\t\t  ep->can_eliminate = 0;\n+\t      }\n \t  }\n \n       /* These two aren't unary operators.  */"}]}