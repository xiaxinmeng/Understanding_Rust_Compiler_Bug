{"sha": "90a6c3b6d69765ea9269ba7ae16ef02d5527e875", "node_id": "C_kwDOANBUbNoAKDkwYTZjM2I2ZDY5NzY1ZWE5MjY5YmE3YWUxNmVmMDJkNTUyN2U4NzU", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-31T17:42:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-08T14:44:20Z"}, "message": "c++: Reimplement static init/fini generation\n\nCurrently we generate static init/fini code by generating a set of\nfunctions taking an 'initp' bool and an unsigned priority.  (There can\nbe more than one, as we repeat the end-of-compile loop.)  We then\ngenerate a set of real init or fini functions for each needed\nprioroty, calling the previous set of functions.  This is of course\nvery tangled, but excitingly the value-range-propagator is clever\nenough to unentangle it.  However, the current arrangement makes\ngeneration awkward, particularly as to how to optimize the\nmodule-global-init generation.\n\nThis reimplements the generation to generate a set of separate\ninit/fini functions for each needed priority, and then call them from\nthe real inits previously mentioned.  This replaces a splay tree,\nrecording which priority/init combos we needed, with a pair of hash\ntables, mapping priority to init functions.  Much simpler.\n\nWhile there, rename several of the functions as they are only dealing\nwith part of the init/fini generation, not the whole set.\n\n\tgcc/cp/\n\t* decl2.cc (struct priority_info_s, priority_info): Delete.\n\t(priority_map_traits, priority_map_t): New.\n\t(static_init_fini_fns): New.\n\t(INITIALIZE_P_IDENTIFIER, PRIORITY_IDENTIFIER): Delete.\n\t(initialize_p_decl, priority_decl): Delete.\n\t(ssdf_decls, priority_info_map): Delete.\n\t(start_static_storage_duration_function): Rename to ...\n\t(start_partial_init_fini_fn): ... here. Create a void arg fn.\n\tAdd it to the slot in the appropriate static_init_fini_fns\n\thash table.\n\t(finish_static_storage_duration_function): Rename to ...\n\t(finish_partial_init_fini_fn): ... here.\n\t(get_priority_info): Delete.\n\t(one_static_initialization_or_destruction): Assert not\n\ttrivial dtor.\n\t(do_static_initialization_or_destruction): Rename to ...\n\t(emit_partial_init_fini_fn) ... here.  Start & finish the fn.\n\tSimply init/fini each var.\n\t(partition_vars_for_init_fini): Partition vars according to\n\tpriority and add to init and/or fini list.\n\t(generate_ctor_or_dtor_function): Start and finish the function.\n\tDo santitizer calls here.\n\t(generate_ctor_and_dtor_functions_for_priority): Delete.\n\t(c_parse_final_cleanups): Reimplement global init/fini\n\tprocessing.\n\n\tgcc/testsuite/\n\t* g++.dg/init/static-cdtor1.C: New.", "tree": {"sha": "3a1bec473070f87248219f1a6ffae3c22079bebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a1bec473070f87248219f1a6ffae3c22079bebf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90a6c3b6d69765ea9269ba7ae16ef02d5527e875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a6c3b6d69765ea9269ba7ae16ef02d5527e875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a6c3b6d69765ea9269ba7ae16ef02d5527e875", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a6c3b6d69765ea9269ba7ae16ef02d5527e875/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8c258094195896a32bd7dc0601bc767c9258a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8c258094195896a32bd7dc0601bc767c9258a71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8c258094195896a32bd7dc0601bc767c9258a71"}], "stats": {"total": 505, "additions": 205, "deletions": 300}, "files": [{"sha": "bfb6a32e3b6005da34247086dfa9266953fc5aa7", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 188, "deletions": 300, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a6c3b6d69765ea9269ba7ae16ef02d5527e875/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a6c3b6d69765ea9269ba7ae16ef02d5527e875/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=90a6c3b6d69765ea9269ba7ae16ef02d5527e875", "patch": "@@ -55,27 +55,14 @@ int raw_dump_id;\n  \n extern cpp_reader *parse_in;\n \n-/* This structure contains information about the initializations\n-   and/or destructions required for a particular priority level.  */\n-typedef struct priority_info_s {\n-  /* Nonzero if there have been any initializations at this priority\n-     throughout the translation unit.  */\n-  int initializations_p;\n-  /* Nonzero if there have been any destructions at this priority\n-     throughout the translation unit.  */\n-  int destructions_p;\n-} *priority_info;\n-\n static tree start_objects (bool, unsigned);\n static tree finish_objects (bool, unsigned, tree);\n-static tree start_static_storage_duration_function (unsigned);\n-static void finish_static_storage_duration_function (tree);\n-static priority_info get_priority_info (int);\n-static void do_static_initialization_or_destruction (bool, tree);\n+static tree start_partial_init_fini_fn (bool, unsigned, unsigned);\n+static void finish_partial_init_fini_fn (tree);\n+static void emit_partial_init_fini_fn (bool, unsigned, tree,\n+\t\t\t\t       unsigned, location_t);\n static void one_static_initialization_or_destruction (bool, tree, tree);\n-static void generate_ctor_or_dtor_function (bool, unsigned, location_t *);\n-static int generate_ctor_and_dtor_functions_for_priority (splay_tree_node,\n-\t\t\t\t\t\t\t  void *);\n+static void generate_ctor_or_dtor_function (bool, unsigned, tree, location_t);\n static tree prune_vars_needing_no_initialization (tree *);\n static void write_out_vars (tree);\n static void import_export_class (tree);\n@@ -136,6 +123,51 @@ struct mangled_decl_hash : ggc_remove <tree>\n    we need compatibility aliases.  */\n static GTY(()) hash_table<mangled_decl_hash> *mangled_decls;\n \n+// Hash table mapping priority to lists of variables or functions.\n+struct priority_map_traits\n+{\n+  typedef unsigned key_type;\n+  typedef tree value_type;\n+  static const bool maybe_mx = true;\n+  static hashval_t hash (key_type v)\n+  {\n+    return hashval_t (v);\n+  }\n+  static bool equal_keys (key_type k1, key_type k2)\n+  {\n+    return k1 == k2;\n+  }\n+  template <typename T> static void remove (T &)\n+  {\n+  }\n+  // Zero is not a priority\n+  static const bool empty_zero_p = true;\n+  template <typename T> static bool is_empty (const T &entry)\n+  {\n+    return entry.m_key == 0;\n+  }\n+  template <typename T> static void mark_empty (T &entry)\n+  {\n+    entry.m_key = 0;\n+  }\n+  // Entries are not deleteable\n+  template <typename T> static bool is_deleted (const T &)\n+  {\n+    return false;\n+  }\n+  template <typename T> static void mark_deleted (T &entry)\n+  {\n+    gcc_unreachable ();\n+  }\n+};\n+\n+typedef hash_map<unsigned/*Priority*/, tree/*List*/,\n+\t\t priority_map_traits> priority_map_t;\n+\n+/* A pair of such hash tables, indexed by initp -- one for fini and\n+   one for init.  The fini table is only ever used when !cxa_atexit.  */\n+static GTY(()) priority_map_t *static_init_fini_fns[2];\n+\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n int at_eof;\n@@ -3927,55 +3959,26 @@ finish_objects (bool initp, unsigned priority, tree body)\n   return fn;\n }\n \n-/* The names of the parameters to the function created to handle\n-   initializations and destructions for objects with static storage\n-   duration.  */\n-#define INITIALIZE_P_IDENTIFIER \"__initialize_p\"\n-#define PRIORITY_IDENTIFIER \"__priority\"\n-\n /* The name of the function we create to handle initializations and\n    destructions for objects with static storage duration.  */\n #define SSDF_IDENTIFIER \"__static_initialization_and_destruction\"\n \n-/* The declaration for the __INITIALIZE_P argument.  */\n-static GTY(()) tree initialize_p_decl;\n-\n-/* The declaration for the __PRIORITY argument.  */\n-static GTY(()) tree priority_decl;\n-\n-/* All the static storage duration functions created in this\n-   translation unit.  */\n-static GTY(()) vec<tree, va_gc> *ssdf_decls;\n-\n-/* A map from priority levels to information about that priority\n-   level.  There may be many such levels, so efficient lookup is\n-   important.  */\n-static splay_tree priority_info_map;\n-\n /* Begins the generation of the function that will handle all\n-   initialization and destruction of objects with static storage\n-   duration.  The function generated takes two parameters of type\n-   `int': __INITIALIZE_P and __PRIORITY.  If __INITIALIZE_P is\n-   nonzero, it performs initializations.  Otherwise, it performs\n-   destructions.  It only performs those initializations or\n-   destructions with the indicated __PRIORITY.  The generated function\n-   returns no value.\n-\n-   It is assumed that this function will only be called once per\n-   translation unit.  */\n+   initialization or destruction of objects with static storage\n+   duration at PRIORITY.\n+\n+   It is assumed that this function will only be called once.  */\n \n static tree\n-start_static_storage_duration_function (unsigned count)\n+start_partial_init_fini_fn (bool initp, unsigned priority, unsigned count)\n {\n   char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\\0' */ + 32];\n \n   /* Create the identifier for this function.  It will be of the form\n      SSDF_IDENTIFIER_<number>.  */\n   sprintf (id, \"%s_%u\", SSDF_IDENTIFIER, count);\n \n-  tree type = build_function_type_list (void_type_node,\n-\t\t\t\t\tinteger_type_node, integer_type_node,\n-\t\t\t\t\tNULL_TREE);\n+  tree type = build_function_type (void_type_node, void_list_node);\n \n   /* Create the FUNCTION_DECL itself.  */\n   tree fn = build_lang_decl (FUNCTION_DECL, get_identifier (id), type);\n@@ -3984,36 +3987,10 @@ start_static_storage_duration_function (unsigned count)\n \n   /* Put this function in the list of functions to be called from the\n      static constructors and destructors.  */\n-  if (!ssdf_decls)\n-    {\n-      vec_alloc (ssdf_decls, 32);\n-\n-      /* Take this opportunity to initialize the map from priority\n-\t numbers to information about that priority level.  */\n-      priority_info_map = splay_tree_new (splay_tree_compare_ints,\n-\t\t\t\t\t  /*delete_key_fn=*/0,\n-\t\t\t\t\t  /*delete_value_fn=*/\n-\t\t\t\t\t  splay_tree_delete_pointers);\n-\n-      /* We always need to generate functions for the\n-\t DEFAULT_INIT_PRIORITY so enter it now.  That way when we walk\n-\t priorities later, we'll be sure to find the\n-\t DEFAULT_INIT_PRIORITY.  */\n-      get_priority_info (DEFAULT_INIT_PRIORITY);\n-    }\n-\n-  vec_safe_push (ssdf_decls, fn);\n-\n-  /* Create the argument list.  */\n-  initialize_p_decl = cp_build_parm_decl\n-    (fn, get_identifier (INITIALIZE_P_IDENTIFIER), integer_type_node);\n-  TREE_USED (initialize_p_decl) = 1;\n-  priority_decl = cp_build_parm_decl\n-    (fn, get_identifier (PRIORITY_IDENTIFIER), integer_type_node);\n-  TREE_USED (priority_decl) = 1;\n-\n-  DECL_CHAIN (initialize_p_decl) = priority_decl;\n-  DECL_ARGUMENTS (fn) = initialize_p_decl;\n+  if (!static_init_fini_fns[initp])\n+    static_init_fini_fns[initp] = priority_map_t::create_ggc ();\n+  auto &slot = static_init_fini_fns[initp]->get_or_insert (priority);\n+  slot = tree_cons (fn, NULL_TREE, slot);\n \n   /* Put the function in the global scope.  */\n   pushdecl (fn);\n@@ -4032,46 +4009,16 @@ start_static_storage_duration_function (unsigned count)\n }\n \n /* Finish the generation of the function which performs initialization\n-   and destruction of objects with static storage duration.  After\n-   this point, no more such objects can be created.  */\n+   or destruction of objects with static storage duration.  */\n \n static void\n-finish_static_storage_duration_function (tree body)\n+finish_partial_init_fini_fn (tree body)\n {\n   /* Close out the function.  */\n   finish_compound_stmt (body);\n   expand_or_defer_fn (finish_function (/*inline_p=*/false));\n }\n \n-/* Return the information about the indicated PRIORITY level.  If no\n-   code to handle this level has yet been generated, generate the\n-   appropriate prologue.  */\n-\n-static priority_info\n-get_priority_info (int priority)\n-{\n-  priority_info pi;\n-  splay_tree_node n;\n-\n-  n = splay_tree_lookup (priority_info_map,\n-\t\t\t (splay_tree_key) priority);\n-  if (!n)\n-    {\n-      /* Create a new priority information structure, and insert it\n-\t into the map.  */\n-      pi = XNEW (struct priority_info_s);\n-      pi->initializations_p = 0;\n-      pi->destructions_p = 0;\n-      splay_tree_insert (priority_info_map,\n-\t\t\t (splay_tree_key) priority,\n-\t\t\t (splay_tree_value) pi);\n-    }\n-  else\n-    pi = (priority_info) n->value;\n-\n-  return pi;\n-}\n-\n /* The effective initialization priority of a DECL.  */\n \n #define DECL_EFFECTIVE_INIT_PRIORITY(decl)\t\t\t\t      \\\n@@ -4117,9 +4064,7 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n {\n   /* If we are supposed to destruct and there's a trivial destructor,\n      nothing has to be done.  */\n-  if (!initp\n-      && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n-    return;\n+  gcc_checking_assert (init || !TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)));\n \n   /* Trick the compiler into thinking we are at the file and line\n      where DECL was declared so that error-messages make sense, and so\n@@ -4241,90 +4186,29 @@ one_static_initialization_or_destruction (bool initp, tree decl, tree init)\n    Whether initialization or destruction is performed is specified by INITP.  */\n \n static void\n-do_static_initialization_or_destruction (bool initp, tree vars)\n+emit_partial_init_fini_fn (bool initp, unsigned priority, tree vars,\n+\t\t\t   unsigned counter, location_t locus)\n {\n-  /* Build the outer if-stmt to check for initialization or destruction.  */\n-  tree init_if_stmt = begin_if_stmt ();\n-  tree cond = initp ? integer_one_node : integer_zero_node;\n-  cond = cp_build_binary_op (input_location,\n-\t\t\t     EQ_EXPR,\n-\t\t\t     initialize_p_decl,\n-\t\t\t     cond,\n-\t\t\t     tf_warning_or_error);\n-  finish_if_stmt_cond (cond, init_if_stmt);\n-\n-  /* To make sure dynamic construction doesn't access globals from other\n-     compilation units where they might not be yet constructed, for\n-     -fsanitize=address insert __asan_before_dynamic_init call that\n-     prevents access to either all global variables that need construction\n-     in other compilation units, or at least those that haven't been\n-     initialized yet.  Variables that need dynamic construction in\n-     the current compilation unit are kept accessible.  */\n-  if (initp && (flag_sanitize & SANITIZE_ADDRESS))\n-    finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/false));\n-\n-  tree node = vars;\n-  do {\n-    tree decl = TREE_VALUE (node);\n-\n-    /* If we don't need a destructor, there's nothing to do.  Avoid\n-       creating a possibly empty if-stmt.  */\n-    if (!initp && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n-      {\n-\tnode = TREE_CHAIN (node);\n-\tcontinue;\n-      }\n-\n-    /* Remember that we had an initialization or finalization at this\n-       priority.  */\n-    int priority = DECL_EFFECTIVE_INIT_PRIORITY (decl);\n-    priority_info pi = get_priority_info (priority);\n-    if (initp)\n-      pi->initializations_p = 1;\n-    else\n-      pi->destructions_p = 1;\n-\n-    /* Conditionalize this initialization on being in the right priority\n-       and being initializing/finalizing appropriately.  */\n-    tree priority_if_stmt = begin_if_stmt ();\n-    cond = cp_build_binary_op (input_location,\n-\t\t\t       EQ_EXPR,\n-\t\t\t       priority_decl,\n-\t\t\t       build_int_cst (NULL_TREE, priority),\n-\t\t\t       tf_warning_or_error);\n-    finish_if_stmt_cond (cond, priority_if_stmt);\n-\n-    /* Process initializers with same priority.  */\n-    for (; node\n-\t   && DECL_EFFECTIVE_INIT_PRIORITY (TREE_VALUE (node)) == priority;\n-\t node = TREE_CHAIN (node))\n-      /* Do one initialization or destruction.  */\n-      one_static_initialization_or_destruction (initp, TREE_VALUE (node),\n-\t\t\t\t\t\tTREE_PURPOSE (node));\n-\n-    /* Finish up the priority if-stmt body.  */\n-    finish_then_clause (priority_if_stmt);\n-    finish_if_stmt (priority_if_stmt);\n-\n-  } while (node);\n-\n-  /* Revert what __asan_before_dynamic_init did by calling\n-     __asan_after_dynamic_init.  */\n-  if (initp && (flag_sanitize & SANITIZE_ADDRESS))\n-    finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/true));\n-\n-  /* Finish up the init/destruct if-stmt body.  */\n-  finish_then_clause (init_if_stmt);\n-  finish_if_stmt (init_if_stmt);\n+  input_location = locus;\n+  tree body = start_partial_init_fini_fn (initp, priority, counter);\n+\n+  for (tree node = vars; node; node = TREE_CHAIN (node))\n+    /* Do one initialization or destruction.  */\n+    one_static_initialization_or_destruction (initp, TREE_VALUE (node),\n+\t\t\t\t\t      TREE_PURPOSE (node));\n+\n+  /* Finish up the static storage duration function for this\n+     round.  */\n+  input_location = locus;\n+  finish_partial_init_fini_fn (body);\n }\n \n /* VARS is a list of variables with static storage duration which may\n    need initialization and/or finalization.  Remove those variables\n    that don't really need to be initialized or finalized, and return\n    the resulting list.  The order in which the variables appear in\n    VARS is in reverse order of the order in which they should actually\n-   be initialized.  The list we return is in the unreversed order;\n-   i.e., the first variable should be initialized first.  */\n+   be initialized.  That order is preserved.  */\n \n static tree\n prune_vars_needing_no_initialization (tree *vars)\n@@ -4375,6 +4259,39 @@ prune_vars_needing_no_initialization (tree *vars)\n   return result;\n }\n \n+/* Split VAR_LIST by init priority and add into PARTS hash table.\n+   This reverses the variable ordering.  */\n+\n+void\n+partition_vars_for_init_fini (tree var_list, priority_map_t *(&parts)[2])\n+{\n+  for (auto node = var_list; node; node = TREE_CHAIN (node))\n+    {\n+      tree decl = TREE_VALUE (node);\n+      tree init = TREE_PURPOSE (node);\n+      bool has_cleanup = !TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl));\n+      unsigned priority = DECL_EFFECTIVE_INIT_PRIORITY (decl);\n+\n+      if (init || (flag_use_cxa_atexit && has_cleanup))\n+\t{\n+\t  // Add to initialization list.\n+\t  if (!parts[true])\n+\t    parts[true] = priority_map_t::create_ggc ();\n+\t  auto &slot = parts[true]->get_or_insert (priority);\n+\t  slot = tree_cons (init, decl, slot);\n+\t}\n+\n+      if (!flag_use_cxa_atexit && has_cleanup)\n+\t{\n+\t  // Add to finalization list.\n+\t  if (!parts[false])\n+\t    parts[false] = priority_map_t::create_ggc ();\n+\t  auto &slot = parts[false]->get_or_insert (priority);\n+\t  slot = tree_cons (NULL_TREE, decl, slot);\n+\t}\n+    }\n+}\n+\n /* Make sure we have told the back end about all the variables in\n    VARS.  */\n \n@@ -4399,76 +4316,51 @@ write_out_vars (tree vars)\n    storage duration having the indicated PRIORITY.  */\n \n static void\n-generate_ctor_or_dtor_function (bool initp, unsigned priority, location_t *locus)\n+generate_ctor_or_dtor_function (bool initp, unsigned priority,\n+\t\t\t\ttree fns, location_t locus)\n {\n-  input_location = *locus;\n+  input_location = locus;\n \n-  /* We emit the function lazily, to avoid generating empty\n-     global constructors and destructors.  */\n-  tree body = NULL_TREE;\n+  tree body = start_objects (initp, priority);\n \n-  if (initp && priority == DEFAULT_INIT_PRIORITY)\n+  /* To make sure dynamic construction doesn't access globals from other\n+     compilation units where they might not be yet constructed, for\n+     -fsanitize=address insert __asan_before_dynamic_init call that\n+     prevents access to either all global variables that need construction\n+     in other compilation units, or at least those that haven't been\n+     initialized yet.  Variables that need dynamic construction in\n+     the current compilation unit are kept accessible.  */\n+  if (initp && (flag_sanitize & SANITIZE_ADDRESS))\n+    finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/false));\n+\n+  if (initp && priority == DEFAULT_INIT_PRIORITY\n+      && c_dialect_objc () && objc_static_init_needed_p ())\n+    /* For Objective-C++, we may need to initialize metadata found in\n+       this module.  This must be done _before_ any other static\n+       initializations.  */\n+    objc_generate_static_init_call (NULL_TREE);\n+\n+  /* Call the static init/fini functions.  */\n+  for (tree node = fns; node; node = TREE_CHAIN (node))\n     {\n-      bool objc = c_dialect_objc () && objc_static_init_needed_p ();\n+      tree fn = TREE_PURPOSE (node);\n \n-      /* We may have module initialization to emit and/or insert\n-\t before other intializations.  */\n-      if (module_initializer_kind () || objc)\n-\tbody = start_objects (initp, priority);\n+      // We should never find a pure or constant cdtor.\n+      gcc_checking_assert (!(flags_from_decl_or_type (fn)\n+\t\t\t     & (ECF_CONST | ECF_PURE)));\n \n-      /* For Objective-C++, we may need to initialize metadata found\n-         in this module.  This must be done _before_ any other static\n-         initializations.  */\n-      if (objc)\n-\tobjc_generate_static_init_call (NULL_TREE);\n+      tree call = cp_build_function_call_nary (fn, tf_warning_or_error,\n+\t\t\t\t\t       NULL_TREE);\n+      finish_expr_stmt (call);\n     }\n \n-  /* Call the static storage duration function with appropriate\n-     arguments.  */\n-  tree fndecl;\n-  size_t i;\n-  FOR_EACH_VEC_SAFE_ELT (ssdf_decls, i, fndecl)\n-    {\n-      /* Calls to pure or const functions will expand to nothing.  */\n-      if (! (flags_from_decl_or_type (fndecl) & (ECF_CONST | ECF_PURE)))\n-\t{\n-\t  if (! body)\n-\t    body = start_objects (initp, priority);\n-\n-\t  tree call = cp_build_function_call_nary (fndecl, tf_warning_or_error,\n-\t\t\t\t\t\t   build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t\t  initp),\n-\t\t\t\t\t\t   build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t\t  priority),\n-\t\t\t\t\t\t   NULL_TREE);\n-\t  finish_expr_stmt (call);\n-\t}\n-    }\n+  /* Revert what __asan_before_dynamic_init did by calling\n+     __asan_after_dynamic_init.  */\n+  if (initp && (flag_sanitize & SANITIZE_ADDRESS))\n+    finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/true));\n \n   /* Close out the function.  */\n-  if (body)\n-    expand_or_defer_fn (finish_objects (initp, priority, body));\n-}\n-\n-/* Generate constructor and destructor functions for the priority\n-   indicated by N.  */\n-\n-static int\n-generate_ctor_and_dtor_functions_for_priority (splay_tree_node n, void * data)\n-{\n-  location_t *locus = (location_t *) data;\n-  int priority = (int) n->key;\n-  priority_info pi = (priority_info) n->value;\n-\n-  /* Generate the functions themselves, but only if they are really\n-     needed.  */\n-  if (pi->initializations_p)\n-    generate_ctor_or_dtor_function (/*initp=*/true, priority, locus);\n-  if (pi->destructions_p)\n-    generate_ctor_or_dtor_function (/*initp=*/false, priority, locus);\n-\n-  /* Keep iterating.  */\n-  return 0;\n+  expand_or_defer_fn (finish_objects (initp, priority, body));\n }\n \n /* Return C++ property of T, based on given operation OP.  */\n@@ -5124,44 +5016,29 @@ c_parse_final_cleanups (void)\n \t  /* Make sure the back end knows about all the variables.  */\n \t  write_out_vars (vars);\n \n-\t  /* We need to start a new initialization function each time\n-\t     through the loop.  That's because we need to know which\n-\t     vtables have been referenced, and TREE_SYMBOL_REFERENCED\n-\t     isn't computed until a function is finished, and written\n-\t     out.  That's a deficiency in the back end.  When this is\n-\t     fixed, these initialization functions could all become\n-\t     inline, with resulting performance improvements.  */\n-\n-\t  /* Set the line and file, so that it is obviously not from\n-\t     the source file.  */\n-\t  input_location = locus_at_end_of_parsing;\n-\t  tree ssdf_body = start_static_storage_duration_function (ssdf_count);\n-\n-\t  /* First generate code to do all the initializations.  */\n-\t  do_static_initialization_or_destruction (/*initp=*/true, vars);\n-\n-\t  /* Then, generate code to do all the destructions.  Do these\n-\t     in reverse order so that the most recently constructed\n-\t     variable is the first destroyed.  If we're using\n-\t     __cxa_atexit, then we don't need to do this; functions\n-\t     were registered at initialization time to destroy the\n-\t     local statics.  */\n-\t  if (!flag_use_cxa_atexit)\n-\t    {\n-\t      vars = nreverse (vars);\n-\t      do_static_initialization_or_destruction (/*initp=*/false, vars);\n-\t    }\n+\t  function_depth++; // Disable GC\n+\t  priority_map_t *parts[2] = {nullptr, nullptr};\n+\t  partition_vars_for_init_fini (vars, parts);\n \n-\t  /* Finish up the static storage duration function for this\n-\t     round.  */\n-\t  input_location = locus_at_end_of_parsing;\n-\t  finish_static_storage_duration_function (ssdf_body);\n+\t  for (unsigned initp = 2; initp--;)\n+\t    if (parts[initp])\n+\t      for (auto iter : *parts[initp])\n+\t\t{\n+\t\t  auto list = iter.second;\n+\t\t  if (initp)\n+\t\t    // Partitioning kept the vars in reverse order.\n+\t\t    // We only want that for dtors.\n+\t\t    list = nreverse (list);\n+\t\t  emit_partial_init_fini_fn (initp, iter.first, list,\n+\t\t\t\t\t     ssdf_count++,\n+\t\t\t\t\t     locus_at_end_of_parsing);\n+\t\t}\n+\t  function_depth--; // Re-enable GC\n \n \t  /* All those initializations and finalizations might cause\n \t     us to need more inline functions, more template\n \t     instantiations, etc.  */\n \t  reconsider = true;\n-\t  ssdf_count++;\n \t}\n \n       /* Now do the same for thread_local variables.  */\n@@ -5327,22 +5204,33 @@ c_parse_final_cleanups (void)\n   /* We give C linkage to static constructors and destructors.  */\n   push_lang_context (lang_name_c);\n \n+  if ((c_dialect_objc () && objc_static_init_needed_p ())\n+      || module_initializer_kind ())\n+    {\n+      // Make sure there's a default priority entry.\n+      if (!static_init_fini_fns[true])\n+\tstatic_init_fini_fns[true] = priority_map_t::create_ggc ();\n+      static_init_fini_fns[true]->get_or_insert (DEFAULT_INIT_PRIORITY);\n+    } \n+\n   /* Generate initialization and destruction functions for all\n      priorities for which they are required.  */\n-  if (priority_info_map)\n-    splay_tree_foreach (priority_info_map,\n-\t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n-\t\t\t/*data=*/&locus_at_end_of_parsing);\n-  else if ((c_dialect_objc () && objc_static_init_needed_p ())\n-\t   || module_initializer_kind ())\n-    generate_ctor_or_dtor_function (/*constructor_p=*/true,\n-\t\t\t\t    DEFAULT_INIT_PRIORITY,\n-\t\t\t\t    &locus_at_end_of_parsing);\n-\n-  /* We're done with the splay-tree now.  */\n-  if (priority_info_map)\n-    splay_tree_delete (priority_info_map);\n-\n+  for (unsigned initp = 2; initp--;)\n+    if (static_init_fini_fns[initp])\n+      {\n+\tfor (auto iter : *static_init_fini_fns[initp])\n+\t  {\n+\t    tree fns = iter.second;\n+\t    // The list of functions was constructed in reverse\n+\t    // order, which we only want for dtors.\n+\t    if (initp)\n+\t      fns = nreverse (fns);\n+\t    generate_ctor_or_dtor_function (initp, iter.first, fns,\n+\t\t\t\t\t    locus_at_end_of_parsing);\n+\t  }\n+\tstatic_init_fini_fns[initp] = nullptr;\n+      }\n+  \n   fini_modules ();\n \n   /* Generate any missing aliases.  */"}, {"sha": "343178a611409fe905acda30d8e4f1e1ef5e6e0c", "filename": "gcc/testsuite/g++.dg/init/static-cdtor1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a6c3b6d69765ea9269ba7ae16ef02d5527e875/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstatic-cdtor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a6c3b6d69765ea9269ba7ae16ef02d5527e875/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstatic-cdtor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstatic-cdtor1.C?ref=90a6c3b6d69765ea9269ba7ae16ef02d5527e875", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target { lp64 && { i?86-*-linux* x86_64-*-linux* } } } }\n+// { dg-additional-options -fno-use-cxa-atexit }\n+// Make sure we emit initializers in the correct order.\n+\n+// ctors\n+// { dg-final { scan-assembler {_Z41__static_initialization_and_destruction_0v:.*movl\t\\$var1[^\\n]*\\n[^\\n]*_ZN5LeelaC1Ev[^\\n]*\\n[^\\n]*movl\t\\$var2[^\\n]*\\n[^\\n]*_ZN5LeelaC1Ev[^\\n]*\\n[^\\n]*movl\t\\$var3[^\\n]*\\n[^\\n]*_ZN5LeelaC1Ev} } }\n+// dtors\n+// { dg-final { scan-assembler {_Z41__static_initialization_and_destruction_1v:.*movl\t\\$var3[^\\n]*\\n[^\\n]*_ZN5LeelaD1Ev[^\\n]*\\n[^\\n]*movl\t\\$var2[^\\n]*\\n[^\\n]*_ZN5LeelaD1Ev[^\\n]*\\n[^\\n]*movl\t\\$var1[^\\n]*\\n[^\\n]*_ZN5LeelaD1Ev} } }\n+\n+struct Leela {\n+  Leela ();\n+  ~Leela ();\n+};\n+\n+Leela var1;\n+Leela var2;\n+Leela var3;"}]}