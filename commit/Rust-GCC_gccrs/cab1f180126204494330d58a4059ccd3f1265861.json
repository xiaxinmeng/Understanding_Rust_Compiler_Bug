{"sha": "cab1f180126204494330d58a4059ccd3f1265861", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FiMWYxODAxMjYyMDQ0OTQzMzBkNThhNDA1OWNjZDNmMTI2NTg2MQ==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "2000-02-22T07:25:31Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "2000-02-22T07:25:31Z"}, "message": "Refer to the standard as an ISO document, not an ANSI one.\n\n\t* decl.c (grokdeclarator): Change ANSI to ISO.\n\t* lex.c (consume_string, readescape, do_identifier): Likewise.\n\t(parse_float, real_yylex): Likewise.\n\t* parse.y (paren_expr_or_null, paren_cond_or_null): Likewise.\n\t(unary_expr, new_initializer, cast_expr, primary, primary_no_id,\n\tnew_type_id, maybe_label_decls, simple_stmt,\n\tfor.init.statement): Likewise.\n\t* pt.c (do_decl_instantiation, do_type_instantiation): Likewise.\n\t* semantics.c (finish_named_return_value): Likewise.\n\t* parse.c: Regenerate.\n\nFrom-SVN: r32100", "tree": {"sha": "de59bcdc1f67de6af97d957e79125c090b6ee510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de59bcdc1f67de6af97d957e79125c090b6ee510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cab1f180126204494330d58a4059ccd3f1265861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab1f180126204494330d58a4059ccd3f1265861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cab1f180126204494330d58a4059ccd3f1265861", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab1f180126204494330d58a4059ccd3f1265861/comments", "author": null, "committer": null, "parents": [{"sha": "c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e266a6b735aed2fb29ae3bca4732cb7827ddcd"}], "stats": {"total": 178, "additions": 96, "deletions": 82}, "files": [{"sha": "a6952c1db3b93a72018cc3cb719653fd1cfc9fa0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -1,3 +1,16 @@\n+2000-02-21  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\t* decl.c (grokdeclarator): Change ANSI to ISO.\n+\t* lex.c (consume_string, readescape, do_identifier): Likewise.\n+\t(parse_float, real_yylex): Likewise.\n+\t* parse.y (paren_expr_or_null, paren_cond_or_null): Likewise.\n+\t(unary_expr, new_initializer, cast_expr, primary, primary_no_id,\n+\tnew_type_id, maybe_label_decls, simple_stmt, \n+\tfor.init.statement): Likewise.\n+\t* pt.c (do_decl_instantiation, do_type_instantiation): Likewise.\n+\t* semantics.c (finish_named_return_value): Likewise.\n+\t* parse.c: Regenerate.\n+\n 2000-02-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CPTI_VTABLE_INDEX_TYPE): New macro."}, {"sha": "fa252a3f1761721fcc58105a9c65473a886bbc28", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -1926,7 +1926,7 @@ type_decays_to (type)\n    1) bool-taking candidates.  These are the same regardless of the input.\n    2) pointer-pair taking candidates.  These are generated for each type\n       one of the input types converts to.\n-   3) arithmetic candidates.  According to the WP, we should generate\n+   3) arithmetic candidates.  According to the standard, we should generate\n       all of these, but I'm trying not to... */\n \n static struct z_candidate *\n@@ -4883,10 +4883,10 @@ joust (cand1, cand2, warn)\n   /* for some argument j, ICSj(F1) is a better conversion  sequence  than\n      ICSj(F2) */\n \n-  /* For comparing static and non-static member functions, we ignore the\n-     implicit object parameter of the non-static function.  The WP says to\n-     pretend that the static function has an object parm, but that won't\n-     work with operator overloading.  */\n+  /* For comparing static and non-static member functions, we ignore\n+     the implicit object parameter of the non-static function.  The\n+     standard says to pretend that the static function has an object\n+     parm, but that won't work with operator overloading.  */\n   len = TREE_VEC_LENGTH (cand1->convs);\n   if (len != TREE_VEC_LENGTH (cand2->convs))\n     {"}, {"sha": "2342fd661f6bb5a9b946d129796b5de7ca942092", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -484,7 +484,7 @@ struct tree_srcloc\n               OPERATOR_TYPENAME_FORMAT,\t\t\t\\\n \t      strlen (OPERATOR_TYPENAME_FORMAT)))\n \n-/* Nonzero means reject anything that ANSI standard C forbids.  */\n+/* Nonzero means reject anything that ISO standard C++ forbids.  */\n extern int pedantic;\n \n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n@@ -1114,8 +1114,9 @@ extern int interface_only, interface_unknown;\n \n extern int flag_elide_constructors;\n \n-/* Nonzero means enable obscure ANSI features and disable GNU extensions\n-   that might cause ANSI-compliant code to be miscompiled.  */\n+/* Nonzero means enable obscure standard features and disable GNU\n+   extensions that might cause standard-compliant code to be\n+   miscompiled.  */\n \n extern int flag_ansi;\n "}, {"sha": "b23052c87573765fba42c5f6dc1eb93dfc7a8310", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -453,7 +453,7 @@ struct binding_level\n     tree incomplete;\n \n     /* List of VAR_DECLS saved from a previous for statement.\n-       These would be dead in ANSI-conforming code, but might\n+       These would be dead in ISO-conforming code, but might\n        be referenced in ARM-era code.  These are stored in a\n        TREE_LIST; the TREE_VALUE is the actual declaration.  */\n     tree dead_vars_from_for;\n@@ -484,7 +484,7 @@ struct binding_level\n     unsigned namespace_p : 1;\n \n     /* True if this level is that of a for-statement where we need to\n-       worry about ambiguous (ARM or ANSI) scope rules.  */\n+       worry about ambiguous (ARM or ISO) scope rules.  */\n     unsigned is_for_scope : 1;\n \n     /* True if this level corresponds to an EH region, as for a try block.  */\n@@ -4509,7 +4509,7 @@ implicitly_declare (functionid)\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n \n-  /* ANSI standard says implicit declarations are in the innermost block.\n+  /* ISO standard says implicit declarations are in the innermost block.\n      So we record the decl in the standard fashion.  */\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, NULL_PTR, 0, 0);\n@@ -6511,8 +6511,7 @@ fixup_anonymous_aggr (t)\n \tq = &TREE_CHAIN (*q);\n     }\n \n-  /* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have\n-     function members.  */\n+  /* ISO C++ 9.5.3.  Anonymous unions may not have function members.  */\n   if (TYPE_METHODS (t))\n     error (\"an anonymous union cannot have function members\");\n }\n@@ -10185,9 +10184,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\tif (flags == DTOR_FLAG)\n \t\t  {\n-\t\t    /* ANSI C++ June 5 1992 WP 12.4.1.  A destructor may\n-\t\t       not be declared const or volatile.  A destructor\n-\t\t       may not be static.  */\n+\t\t    /* ISO C++ 12.4/2.  A destructor may not be\n+\t\t       declared const or volatile.  A destructor may\n+\t\t       not be static.  */\n \t\t    if (staticp == 2)\n \t\t      error (\"destructor cannot be static member function\");\n \t\t    if (quals)\n@@ -10208,9 +10207,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  {\n \t\t    if (explicitp == 1)\n \t\t      explicitp = 2;\n-\t\t    /* ANSI C++ June 5 1992 WP 12.1.2.  A constructor may\n-\t\t       not be declared const or volatile.  A constructor may\n-\t\t       not be virtual.  A constructor may not be static.  */\n+\t\t    /* ISO C++ 12.1.  A constructor may not be\n+\t\t       declared const or volatile.  A constructor may\n+\t\t       not be virtual.  A constructor may not be\n+\t\t       static.  */\n \t\t    if (staticp == 2)\n \t\t      error (\"constructor cannot be static member function\");\n \t\t    if (virtualp)\n@@ -11110,7 +11110,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t       the rest of the compiler does not correctly\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n-\t\t    cp_pedwarn (\"ANSI C++ forbids initialization of member `%D'\",\n+\t\t    cp_pedwarn (\"ISO C++ forbids initialization of member `%D'\",\n \t\t\t\tdeclarator);\n \t\t    cp_pedwarn (\"making `%D' static\", declarator);\n \t\t    staticp = 1;\n@@ -12963,9 +12963,8 @@ start_function (declspecs, declarator, attrs, flags)\n       if (TREE_CODE (fntype) == METHOD_TYPE)\n \tctype = TYPE_METHOD_BASETYPE (fntype);\n \n-      /* ANSI C++ June 5 1992 WP 11.4.5.  A friend function defined in a\n-\t class is in the (lexical) scope of the class in which it is\n-\t defined.  */\n+      /* ISO C++ 11.4/5.  A friend function defined in a class is in\n+\t the (lexical) scope of the class in which it is defined.  */\n       if (!ctype && DECL_FRIEND_P (decl1))\n \t{\n \t  ctype = DECL_FRIEND_CONTEXT (decl1);"}, {"sha": "ad0a686692595de4f7adc78dadfb3705e0373ca7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -171,8 +171,9 @@ int flag_traditional;\n \n int flag_signed_bitfields = 1;\n \n-/* Nonzero means enable obscure ANSI features and disable GNU extensions\n-   that might cause ANSI-compliant code to be miscompiled.  */\n+/* Nonzero means enable obscure standard features and disable GNU\n+   extensions that might cause standard-compliant code to be\n+   miscompiled.  */\n \n int flag_ansi;\n \n@@ -422,11 +423,11 @@ int flag_operator_names;\n \n int flag_check_new;\n \n-/* Nonzero if we want the new ANSI rules for pushing a new scope for `for'\n+/* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n    initialization variables.\n    0: Old rules, set by -fno-for-scope.\n-   2: New ANSI rules, set by -ffor-scope.\n-   1: Try to implement new ANSI rules, but with backup compatibility\n+   2: New ISO rules, set by -ffor-scope.\n+   1: Try to implement new ISO rules, but with backup compatibility\n    (and warnings).  This is the default, for now.  */\n \n int flag_new_for_scope = 1;\n@@ -455,7 +456,7 @@ int flag_honor_std;\n \n int flag_inline_trees = 0;\n \n-/* Maximum template instantiation depth. Must be at least 17 for ANSI\n+/* Maximum template instantiation depth. Must be at least 17 for ISO\n    compliance. */\n \n int max_tinst_depth = 17;"}, {"sha": "0197879853cdc97f54a942c46ebc16636a7cf1e8", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -763,7 +763,7 @@ expand_throw (exp)\n \t{\n \t  tree object, ptr;\n \n-\t  /* OK, this is kind of wacky.  The WP says that we call\n+\t  /* OK, this is kind of wacky.  The standard says that we call\n \t     terminate when the exception handling mechanism, after\n \t     completing evaluation of the expression to be thrown but\n \t     before the exception is caught (_except.throw_), calls a"}, {"sha": "7b9ab1d52e2704add1beffbf7a9ab18995c453b2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -2931,7 +2931,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n    things like padding and magic size cookies.  It has virtual in it,\n    because if you have a base pointer and you delete through a virtual\n    destructor, it should be the size of the dynamic object, not the\n-   static object, see Free Store 12.5 ANSI C++ WP.\n+   static object, see Free Store 12.5 ISO C++.\n \n    This does not call any destructors.  */\n "}, {"sha": "0bc8e34ab0dc2f2329feead01817b5f13f57edf2", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -1421,7 +1421,7 @@ consume_string (this_obstack, matching_char)\n       if (c == '\\n')\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids newline in string constant\");\n+\t    pedwarn (\"ISO C++ forbids newline in string constant\");\n \t  lineno++;\n \t}\n       obstack_1grow (this_obstack, c);\n@@ -2912,7 +2912,7 @@ readescape (ignore_ptr)\n     case 'e':\n     case 'E':\n       if (pedantic)\n-\tpedwarn (\"non-ANSI-standard escape sequence, `\\\\%c'\", c);\n+\tpedwarn (\"non-ISO-standard escape sequence, `\\\\%c'\", c);\n       return 033;\n \n     case '?':\n@@ -3148,7 +3148,7 @@ do_identifier (token, parsing, args)\n \t    {\n \t      warning (\"name lookup of `%s' changed\",\n \t\t       IDENTIFIER_POINTER (token));\n-\t      cp_warning_at (\"  matches this `%D' under current ANSI rules\",\n+\t      cp_warning_at (\"  matches this `%D' under ISO standard rules\",\n \t\t\t     shadowed);\n \t      cp_warning_at (\"  matches this `%D' under old rules\", id);\n \t      DECL_ERROR_REPORTED (id) = 1;\n@@ -3160,14 +3160,14 @@ do_identifier (token, parsing, args)\n \t  DECL_ERROR_REPORTED (id) = 1;\n \t  if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (id)))\n \t    {\n-\t      error (\"name lookup of `%s' changed for new ANSI `for' scoping\",\n+\t      error (\"name lookup of `%s' changed for new ISO `for' scoping\",\n \t\t     IDENTIFIER_POINTER (token));\n \t      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", id);\n \t      id = error_mark_node;\n \t    }\n \t  else\n \t    {\n-\t      pedwarn (\"name lookup of `%s' changed for new ANSI `for' scoping\",\n+\t      pedwarn (\"name lookup of `%s' changed for new ISO `for' scoping\",\n \t\t       IDENTIFIER_POINTER (token));\n \t      cp_pedwarn_at (\"  using obsolete binding at `%D'\", id);\n \t    }\n@@ -3361,7 +3361,7 @@ parse_float (data)\n \t  if (args->imag)\n \t    error (\"more than one `i' or `j' in numeric constant\");\n \t  else if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n+\t    pedwarn (\"ISO C++ forbids imaginary numeric constants\");\n \t  args->imag = 1;\n \t  break;\n \n@@ -4043,7 +4043,7 @@ real_yylex ()\n \t\t\tif (spec_long_long)\n \t\t\t  error (\"three `l's in integer constant\");\n \t\t\telse if (pedantic && ! in_system_header && warn_long_long)\n-\t\t\t  pedwarn (\"ANSI C++ forbids long long integer constants\");\n+\t\t\t  pedwarn (\"ISO C++ forbids long long integer constants\");\n \t\t\tspec_long_long = 1;\n \t\t      }\n \t\t    spec_long = 1;\n@@ -4053,7 +4053,7 @@ real_yylex ()\n \t\t    if (spec_imag)\n \t\t      error (\"more than one `i' or `j' in numeric constant\");\n \t\t    else if (pedantic)\n-\t\t      pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n+\t\t      pedwarn (\"ISO C++ forbids imaginary numeric constants\");\n \t\t    spec_imag = 1;\n \t\t  }\n \t\telse\n@@ -4204,7 +4204,7 @@ real_yylex ()\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  pedwarn (\"ANSI C forbids newline in character constant\");\n+\t\t  pedwarn (\"ISO C++ forbids newline in character constant\");\n \t\tlineno++;\n \t      }\n \t    else\n@@ -4366,7 +4366,7 @@ real_yylex ()\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  pedwarn (\"ANSI C++ forbids newline in string constant\");\n+\t\t  pedwarn (\"ISO C++ forbids newline in string constant\");\n \t\tlineno++;\n \t      }\n \t    else"}, {"sha": "c5d39294688bbc7fe84f9bfe0fcd30e4abc214d7", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -1,6 +1,7 @@\n \n /*  A Bison parser, made from parse.y\n-    by GNU Bison version 1.28  */\n+ by  GNU Bison version 1.27\n+  */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n@@ -4027,8 +4028,8 @@ static const short yycheck[] = {     4,\n     78,    79,    80,    81,    82,    83,    84,    85\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/lib/bison.simple\"\n-/* This file comes from bison-1.28.  */\n+#line 3 \"/usr/share/bison.simple\"\n+/* This file comes from bison-1.27.  */\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -4241,7 +4242,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 217 \"/usr/lib/bison.simple\"\n+#line 216 \"/usr/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -5266,7 +5267,7 @@ case 191:\n     break;}\n case 193:\n #line 1057 \"parse.y\"\n-{ error (\"ANSI C++ forbids an empty condition for `%s'\",\n+{ error (\"ISO C++ forbids an empty condition for `%s'\",\n \t\t\t cond_stmt_keyword);\n \t\t  yyval.ttype = integer_zero_node; ;\n     break;}\n@@ -5276,7 +5277,7 @@ case 194:\n     break;}\n case 195:\n #line 1066 \"parse.y\"\n-{ error (\"ANSI C++ forbids an empty condition for `%s'\",\n+{ error (\"ISO C++ forbids an empty condition for `%s'\",\n \t\t\t cond_stmt_keyword);\n \t\t  yyval.ttype = integer_zero_node; ;\n     break;}\n@@ -5376,7 +5377,7 @@ case 221:\n case 222:\n #line 1159 \"parse.y\"\n { if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids `&&'\");\n+\t\t    pedwarn (\"ISO C++ forbids `&&'\");\n   \t\t  yyval.ttype = finish_label_address_expr (yyvsp[0].ttype); ;\n     break;}\n case 223:\n@@ -5495,7 +5496,7 @@ case 246:\n #line 1243 \"parse.y\"\n {\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n+\t\t    pedwarn (\"ISO C++ forbids initialization of new expression with `='\");\n \t\t  if (TREE_CODE (yyvsp[0].ttype) != TREE_LIST\n \t\t      && TREE_CODE (yyvsp[0].ttype) != CONSTRUCTOR)\n \t\t    yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype);\n@@ -5525,7 +5526,7 @@ case 251:\n \t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\tnreverse (yyvsp[-2].ttype)); \n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids constructor-expressions\");\n+\t\t    pedwarn (\"ISO C++ forbids constructor-expressions\");\n \t\t  /* Indicate that this was a GNU C constructor expression.  */\n \t\t  TREE_HAS_CONSTRUCTOR (init) = 1;\n \n@@ -5746,7 +5747,7 @@ case 312:\n \t\t      YYERROR;\n \t\t    }\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");  \n+\t\t    pedwarn (\"ISO C++ forbids braced-groups within expressions\");  \n \t\t  yyval.ttype = begin_stmt_expr (); \n \t\t;\n     break;}\n@@ -6536,7 +6537,7 @@ case 480:\n \t\t  else\n \t\t    {\n \t\t      yyval.ftype.t = yyvsp[0].ftype.t;\n-\t\t      /* struct B: public A; is not accepted by the WP grammar.  */\n+\t\t      /* struct B: public A; is not accepted by the standard grammar.  */\n \t\t      if (CLASS_TYPE_P (yyval.ftype.t)\n \t\t\t  && TYPE_BINFO_BASETYPES (yyval.ftype.t) \n \t\t\t  && !TYPE_SIZE (yyval.ftype.t)\n@@ -7007,7 +7008,7 @@ case 575:\n #line 2667 \"parse.y\"\n {\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n+\t\t    pedwarn (\"ISO C++ forbids array dimensions with parenthesized type in new\");\n \t\t  yyval.ftype.t = build_parse_node (ARRAY_REF, TREE_VALUE (yyvsp[-4].ftype.t), yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_decl_list (TREE_PURPOSE (yyvsp[-4].ftype.t), yyval.ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-4].ftype.new_type_flag;\n@@ -7543,7 +7544,7 @@ case 697:\n case 704:\n #line 3167 \"parse.y\"\n { if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids label declarations\"); ;\n+\t\t    pedwarn (\"ISO C++ forbids label declarations\"); ;\n     break;}\n case 707:\n #line 3178 \"parse.y\"\n@@ -7745,7 +7746,7 @@ case 756:\n #line 3319 \"parse.y\"\n { \n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n+\t\t    pedwarn (\"ISO C++ forbids computed gotos\");\n \t\t  finish_goto_stmt (yyvsp[-1].ttype);\n \t\t;\n     break;}\n@@ -7840,7 +7841,7 @@ case 784:\n case 786:\n #line 3420 \"parse.y\"\n { if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n+\t\t    pedwarn (\"ISO C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 787:\n@@ -8231,7 +8232,7 @@ case 878:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 543 \"/usr/lib/bison.simple\"\n+#line 542 \"/usr/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "09a4d8a0f3ff419b3121ced5e5d584916deda6ef", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -1054,7 +1054,7 @@ expr:\n \n paren_expr_or_null:\n \tLEFT_RIGHT\n-\t\t{ error (\"ANSI C++ forbids an empty condition for `%s'\",\n+\t\t{ error (\"ISO C++ forbids an empty condition for `%s'\",\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' expr ')'\n@@ -1063,7 +1063,7 @@ paren_expr_or_null:\n \n paren_cond_or_null:\n \tLEFT_RIGHT\n-\t\t{ error (\"ANSI C++ forbids an empty condition for `%s'\",\n+\t\t{ error (\"ISO C++ forbids an empty condition for `%s'\",\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' condition ')'\n@@ -1157,7 +1157,7 @@ unary_expr:\n \t/* Refer to the address of a label as a pointer.  */\n \t| ANDAND identifier\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids `&&'\");\n+\t\t    pedwarn (\"ISO C++ forbids `&&'\");\n   \t\t  $$ = finish_label_address_expr ($2); }\n \t| SIZEOF unary_expr  %prec UNARY\n \t\t{ $$ = expr_sizeof ($2); }\n@@ -1242,7 +1242,7 @@ new_initializer:\n \t| '=' init\n \t\t{\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n+\t\t    pedwarn (\"ISO C++ forbids initialization of new expression with `='\");\n \t\t  if (TREE_CODE ($2) != TREE_LIST\n \t\t      && TREE_CODE ($2) != CONSTRUCTOR)\n \t\t    $$ = build_tree_list (NULL_TREE, $2);\n@@ -1272,7 +1272,7 @@ cast_expr:\n \t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\tnreverse ($3)); \n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids constructor-expressions\");\n+\t\t    pedwarn (\"ISO C++ forbids constructor-expressions\");\n \t\t  /* Indicate that this was a GNU C constructor expression.  */\n \t\t  TREE_HAS_CONSTRUCTOR (init) = 1;\n \n@@ -1467,7 +1467,7 @@ primary:\n \t\t      YYERROR;\n \t\t    }\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");  \n+\t\t    pedwarn (\"ISO C++ forbids braced-groups within expressions\");  \n \t\t  $<ttype>$ = begin_stmt_expr (); \n \t\t}\n \t  compstmt ')'\n@@ -1594,7 +1594,7 @@ primary_no_id:\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n+\t\t    pedwarn (\"ISO C++ forbids braced-groups within expressions\");\n \t\t  $$ = expand_end_stmt_expr ($<ttype>2); }\n \t| primary_no_id '(' nonnull_exprlist ')'\n \t\t{ $$ = build_x_function_call ($$, $3, current_class_ref); }\n@@ -1704,7 +1704,7 @@ fcast_or_absdcl:\n \t\t\t\t\t     NULL_TREE); }\n \t;\n \n-/* ANSI type-id (8.1) */\n+/* ISO type-id (8.1) */\n type_id:\n \t  typed_typespecs absdcl\n \t\t{ $$.t = build_decl_list ($1.t, $2); \n@@ -2199,7 +2199,7 @@ structsp:\n \t\t  else\n \t\t    {\n \t\t      $$.t = $1.t;\n-\t\t      /* struct B: public A; is not accepted by the WP grammar.  */\n+\t\t      /* struct B: public A; is not accepted by the standard grammar.  */\n \t\t      if (CLASS_TYPE_P ($$.t)\n \t\t\t  && TYPE_BINFO_BASETYPES ($$.t) \n \t\t\t  && !TYPE_SIZE ($$.t)\n@@ -2653,7 +2653,7 @@ enumerator:\n \t\t{ build_enumerator ($1, $3, current_enum_type); }\n \t;\n \n-/* ANSI new-type-id (5.3.4) */\n+/* ISO new-type-id (5.3.4) */\n new_type_id:\n \t  type_specifier_seq new_declarator\n \t\t{ $$.t = build_decl_list ($1.t, $2); \n@@ -2666,7 +2666,7 @@ new_type_id:\n \t| '(' type_id ')' '[' expr ']'\n \t\t{\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n+\t\t    pedwarn (\"ISO C++ forbids array dimensions with parenthesized type in new\");\n \t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);\n \t\t  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);\n \t\t  $$.new_type_flag = $2.new_type_flag;\n@@ -3051,7 +3051,7 @@ global_scope:\n \t\t{ got_scope = void_type_node; }\n \t;\n \n-/* ANSI new-declarator (5.3.4) */\n+/* ISO new-declarator (5.3.4) */\n new_declarator:\n \t  '*' cv_qualifiers new_declarator\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n@@ -3072,7 +3072,7 @@ new_declarator:\n \t| direct_new_declarator  %prec EMPTY\n \t;\n \n-/* ANSI direct-new-declarator (5.3.4) */\n+/* ISO direct-new-declarator (5.3.4) */\n direct_new_declarator:\n \t  '[' expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }\n@@ -3090,7 +3090,7 @@ absdcl_intern:\n \t\t}\n \t;\n \t\n-/* ANSI abstract-declarator (8.1) */\n+/* ISO abstract-declarator (8.1) */\n absdcl:\n \t  '*' nonempty_cv_qualifiers absdcl_intern\n \t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n@@ -3119,7 +3119,7 @@ absdcl:\n \t| direct_abstract_declarator  %prec EMPTY\n \t;\n \n-/* ANSI direct-abstract-declarator (8.1) */\n+/* ISO direct-abstract-declarator (8.1) */\n direct_abstract_declarator:\n \t  '(' absdcl_intern ')'\n \t\t{ $$ = $2; }\n@@ -3165,7 +3165,7 @@ maybe_label_decls:\n \t  /* empty */\n \t| label_decls\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids label declarations\"); }\n+\t\t    pedwarn (\"ISO C++ forbids label declarations\"); }\n \t;\n \n label_decls:\n@@ -3318,7 +3318,7 @@ simple_stmt:\n \t| GOTO '*' expr ';'\n                 { \n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n+\t\t    pedwarn (\"ISO C++ forbids computed gotos\");\n \t\t  finish_goto_stmt ($3);\n \t\t}\n \t| GOTO identifier ';'\n@@ -3418,7 +3418,7 @@ for.init.statement:\n \t| decl\n \t| '{' compstmtend\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n+\t\t    pedwarn (\"ISO C++ forbids compound statements inside for initializations\");\n \t\t}\n \t;\n "}, {"sha": "f909c8cb62dbbb040e6144ce25be4183d5fd122a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -9119,7 +9119,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n       if (pedantic)\n-\tcp_pedwarn (\"ANSI C++ forbids the use of `extern' on explicit instantiations\");\n+\tcp_pedwarn (\"ISO C++ forbids the use of `extern' on explicit instantiations\");\n       extern_p = 1;\n     }\n   else\n@@ -9184,7 +9184,7 @@ do_type_instantiation (t, storage)\n   if (storage != NULL_TREE)\n     {\n       if (pedantic)\n-\tcp_pedwarn(\"ANSI C++ forbids the use of `%s' on explicit instantiations\", \n+\tcp_pedwarn(\"ISO C++ forbids the use of `%s' on explicit instantiations\", \n \t\t   IDENTIFIER_POINTER (storage));\n \n       if (storage == ridpointers[(int) RID_INLINE])"}, {"sha": "b1e6239f8ca0c2412b62b439f3c0a5b47b1e981f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -1164,7 +1164,7 @@ finish_named_return_value (return_id, init)\n     /* Give this error as many times as there are occurrences,\n        so that users can use Emacs compilation buffers to find\n        and fix all such places.  */\n-    pedwarn (\"ANSI C++ does not permit named return values\");\n+    pedwarn (\"ISO C++ does not permit named return values\");\n \n   if (return_id != NULL_TREE)\n     {"}, {"sha": "385c411022d9c597a02c8da5bf82f4671940b1c4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab1f180126204494330d58a4059ccd3f1265861/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cab1f180126204494330d58a4059ccd3f1265861", "patch": "@@ -5421,8 +5421,7 @@ build_c_cast (type, expr)\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* Allow casting from T1* to T2[] because Cfront allows it.\n-\t NIHCL uses it. It is not valid ANSI C however, and hence, not\n-\t valid ANSI C++.  */\n+\t NIHCL uses it. It is not valid ISO C++ however.  */\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n \t  if (pedantic)\n@@ -5761,8 +5760,8 @@ build_modify_expr (lhs, modifycode, rhs)\n \ttree inner_lhs = TREE_OPERAND (lhs, 0);\n \ttree result;\n \n-\t/* WP 5.4.1:  The result is an lvalue if T is a reference type,\n-\t   otherwise the result is an rvalue.   */\n+\t/* ISO C++ 5.4/1: The result is an lvalue if T is a reference\n+\t   type, otherwise the result is an rvalue.  */\n \tif (! lvalue_p (lhs))\n \t  pedwarn (\"ISO C++ forbids cast to non-reference type used as lvalue\");\n "}]}