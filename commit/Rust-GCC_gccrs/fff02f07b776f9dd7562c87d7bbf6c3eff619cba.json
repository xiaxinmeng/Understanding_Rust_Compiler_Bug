{"sha": "fff02f07b776f9dd7562c87d7bbf6c3eff619cba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmMDJmMDdiNzc2ZjlkZDc1NjJjODdkN2JiZjZjM2VmZjYxOWNiYQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@cygnus.com", "date": "1999-01-21T08:50:06Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "1999-01-21T08:50:06Z"}, "message": "[multiple changes]\n\nThu Jan 21 16:00:06 1999  Andrew Haley  <aph@cygnus.com>\n\t* typeck.c (convert): Allow conversions to void type: some\n \toptimizations in gcc do this.\nThu Jan 21 15:21:49 1999  Andrew Haley  <aph@cygnus.com>\n\t* typeck.c (convert_ieee_real_to_integer): New function.\n\t(convert): When not using fast-math and using hardware fp, convert\n \tan IEEE NaN to zero.\n\nFrom-SVN: r24797", "tree": {"sha": "70f272d41e8874c040d6caef21ac1e9e4e53244e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70f272d41e8874c040d6caef21ac1e9e4e53244e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fff02f07b776f9dd7562c87d7bbf6c3eff619cba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff02f07b776f9dd7562c87d7bbf6c3eff619cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff02f07b776f9dd7562c87d7bbf6c3eff619cba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff02f07b776f9dd7562c87d7bbf6c3eff619cba/comments", "author": null, "committer": null, "parents": [{"sha": "ee5332b81a9cd1dea4c73f596648ae70533f5fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee5332b81a9cd1dea4c73f596648ae70533f5fe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee5332b81a9cd1dea4c73f596648ae70533f5fe5"}], "stats": {"total": 61, "additions": 60, "deletions": 1}, "files": [{"sha": "9c4a281874ac9afd688054e12621b7cfa6a53164", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff02f07b776f9dd7562c87d7bbf6c3eff619cba/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff02f07b776f9dd7562c87d7bbf6c3eff619cba/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=fff02f07b776f9dd7562c87d7bbf6c3eff619cba", "patch": "@@ -1,3 +1,14 @@\n+Thu Jan 21 16:00:06 1999  Andrew Haley  <aph@cygnus.com>\n+\n+\t* typeck.c (convert): Allow conversions to void type: some\n+ \toptimizations in gcc do this.\n+\n+Thu Jan 21 15:21:49 1999  Andrew Haley  <aph@cygnus.com>\n+\n+\t* typeck.c (convert_ieee_real_to_integer): New function.\n+\t(convert): When not using fast-math and using hardware fp, convert\n+ \tan IEEE NaN to zero.\n+ \n 1999-01-18  Andrew Haley  <aph@cygnus.com>\n \n \t* parse.y (patch_binop): Do a type conversion from signed to"}, {"sha": "6a37d7e92e23c1a80dd925ddeeba44b410bebda5", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff02f07b776f9dd7562c87d7bbf6c3eff619cba/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff02f07b776f9dd7562c87d7bbf6c3eff619cba/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=fff02f07b776f9dd7562c87d7bbf6c3eff619cba", "patch": "@@ -28,6 +28,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"obstack.h\"\n+#include \"flags.h\"\n #include \"java-tree.h\"\n #include \"jcf.h\"\n #include \"convert.h\"\n@@ -52,6 +53,39 @@ set_local_type (slot, type)\n     type_map[++slot] = void_type_node;\n }\n \n+/* Convert an IEEE real to an integer type.  The result of such a\n+   conversion when the source operand is a NaN isn't defined by\n+   IEEE754, but by the Java language standard: it must be zero.  This\n+   conversion produces something like:\n+   \n+   ({ double tmp = expr; (tmp != tmp) ? 0 : (int)tmp; })\n+\n+   */\n+\n+static tree\n+convert_ieee_real_to_integer (type, expr)\n+     tree type, expr;\n+{\n+  tree node, assignment, expr_decl;\n+\n+  expr_decl = build_decl (VAR_DECL, generate_name (), TREE_TYPE (expr));\n+  layout_decl (expr_decl, 0);\n+  expand_decl (pushdecl (expr_decl));\n+  assignment = build (MODIFY_EXPR, NULL_TREE, expr_decl, expr);\n+  TREE_SIDE_EFFECTS (assignment) = 1;\n+  TREE_TYPE (assignment) = type;\n+\n+  expr = build (COMPOUND_EXPR, NULL_TREE,\n+\t\tassignment,\n+\t\tbuild (COND_EXPR, type, \n+\t\t       build (NE_EXPR, boolean_type_node, expr_decl, expr_decl),\n+\t\t       build_int_2 (0, 0),\n+\t\t       convert_to_integer (type, expr_decl)));\n+\n+  TREE_TYPE (expr) = type;\n+  return expr;\n+}  \n+\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n@@ -69,10 +103,23 @@ convert (type, expr)\n     return expr;\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return error_mark_node;\n+  if (code == VOID_TYPE)\n+    return build1 (CONVERT_EXPR, type, expr);\n   if (code == BOOLEAN_TYPE)\n     return fold (convert_to_boolean (type, expr));\n   if (code == INTEGER_TYPE)\n-    return fold (convert_to_integer (type, expr));\n+    {\n+      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+#ifdef TARGET_SOFT_FLOAT\n+\t  && !TARGET_SOFT_FLOAT\n+#endif\n+\t  && !flag_emit_class_files\n+\t  && !flag_fast_math\n+\t  && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\treturn fold (convert_ieee_real_to_integer (type, expr));\n+      else\n+\treturn fold (convert_to_integer (type, expr));\n+    }\t  \n   if (code == REAL_TYPE)\n     return fold (convert_to_real (type, expr));\n   if (code == CHAR_TYPE)\n@@ -83,6 +130,7 @@ convert (type, expr)\n   return error_mark_node;\n }\n \n+\n tree\n convert_to_char (type, expr)\n     tree type, expr;"}]}