{"sha": "939347bb51d858d68453af710d4c8f9ef04e440d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5MzQ3YmI1MWQ4NThkNjg0NTNhZjcxMGQ0YzhmOWVmMDRlNDQwZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2004-11-03T22:44:30Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-11-03T22:44:30Z"}, "message": "verify.cc (state::check_no_uninitialized_objects): Removed.\n\n\t* verify.cc (state::check_no_uninitialized_objects): Removed.\n\t(push_jump): Updated.\n\t(push_exception_jump): Likewise.\n\t(handle_ret_insn): Likewise.\n\t(handle_jsr_insn): Likewise.\n\nFrom-SVN: r90040", "tree": {"sha": "b1f85702b15403d3eb0926bc441dbacc7ce69ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1f85702b15403d3eb0926bc441dbacc7ce69ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/939347bb51d858d68453af710d4c8f9ef04e440d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939347bb51d858d68453af710d4c8f9ef04e440d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939347bb51d858d68453af710d4c8f9ef04e440d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939347bb51d858d68453af710d4c8f9ef04e440d/comments", "author": null, "committer": null, "parents": [{"sha": "318627d5fc55180b3bb8619c408799eb14394cc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318627d5fc55180b3bb8619c408799eb14394cc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/318627d5fc55180b3bb8619c408799eb14394cc1"}], "stats": {"total": 63, "additions": 29, "deletions": 34}, "files": [{"sha": "3f8e756314a4f3edf2801faf0e12b46acf28b3bd", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939347bb51d858d68453af710d4c8f9ef04e440d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939347bb51d858d68453af710d4c8f9ef04e440d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=939347bb51d858d68453af710d4c8f9ef04e440d", "patch": "@@ -1,3 +1,11 @@\n+2004-11-01  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (state::check_no_uninitialized_objects): Removed.\n+\t(push_jump): Updated.\n+\t(push_exception_jump): Likewise.\n+\t(handle_ret_insn): Likewise.\n+\t(handle_jsr_insn): Likewise.\n+\n 2004-10-30  Mark Wielaard  <mark@klomp.org>\n \n \tPR libgcj/18234"}, {"sha": "63857d0341eeb63cf9f50e2fe751d58a463a81a9", "filename": "libjava/verify.cc", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939347bb51d858d68453af710d4c8f9ef04e440d/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939347bb51d858d68453af710d4c8f9ef04e440d/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=939347bb51d858d68453af710d4c8f9ef04e440d", "patch": "@@ -100,13 +100,15 @@ debug_print (MAYBE_UNUSED const char *fmt, ...)\n // subroutine is exited via `goto' or `athrow' and not `ret'.\n //\n // In some other areas the JVM specification is (mildly) incorrect,\n-// but we still implement what is specified.  For instance, you cannot\n+// so we diverge.  For instance, you cannot\n // violate type safety by allocating an object with `new' and then\n // failing to initialize it, no matter how one branches or where one\n // stores the uninitialized reference.  See \"Improving the official\n // specification of Java bytecode verification\" by Alessandro Coglio.\n-// Similarly, there's no real point in enforcing that padding bytes or\n-// the mystery byte of invokeinterface must be 0, but we do that too.\n+//\n+// Note that there's no real point in enforcing that padding bytes or\n+// the mystery byte of invokeinterface must be 0, but we do that\n+// regardless.\n //\n // The verifier is currently neither completely lazy nor eager when it\n // comes to loading classes.  It tries to represent types by name when\n@@ -1098,28 +1100,6 @@ class _Jv_BytecodeVerifier\n       return changed;\n     }\n \n-    // Throw an exception if there is an uninitialized object on the\n-    // stack or in a local variable.  EXCEPTION_SEMANTICS controls\n-    // whether we're using backwards-branch or exception-handing\n-    // semantics.\n-    void check_no_uninitialized_objects (int max_locals,\n-\t\t\t\t\t _Jv_BytecodeVerifier *verifier,\n-\t\t\t\t\t bool exception_semantics = false)\n-    {\n-      if (! exception_semantics)\n-\t{\n-\t  for (int i = 0; i < stacktop; ++i)\n-\t    if (stack[i].isreference () && ! stack[i].isinitialized ())\n-\t      verifier->verify_fail (\"uninitialized object on stack\");\n-\t}\n-\n-      for (int i = 0; i < max_locals; ++i)\n-\tif (locals[i].isreference () && ! locals[i].isinitialized ())\n-\t  verifier->verify_fail (\"uninitialized object in local variable\");\n-\n-      check_this_initialized (verifier);\n-    }\n-\n     // Ensure that `this' has been initialized.\n     void check_this_initialized (_Jv_BytecodeVerifier *verifier)\n     {\n@@ -1434,15 +1414,19 @@ class _Jv_BytecodeVerifier\n   void push_jump (int offset)\n   {\n     int npc = compute_jump (offset);\n-    if (npc < PC)\n-      current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n+    // According to the JVM Spec, we need to check for uninitialized\n+    // objects here.  However, this does not actually affect type\n+    // safety, and the Eclipse java compiler generates code that\n+    // violates this constraint.\n     merge_into (npc, current_state);\n   }\n \n   void push_exception_jump (type t, int pc)\n   {\n-    current_state->check_no_uninitialized_objects (current_method->max_locals,\n-\t\t\t\t\t\t   this, true);\n+    // According to the JVM Spec, we need to check for uninitialized\n+    // objects here.  However, this does not actually affect type\n+    // safety, and the Eclipse java compiler generates code that\n+    // violates this constraint.\n     state s (current_state, current_method->max_stack,\n \t     current_method->max_locals);\n     if (current_method->max_stack < 1)\n@@ -1504,9 +1488,10 @@ class _Jv_BytecodeVerifier\n     if (npc >= current_method->code_length)\n       verify_fail (\"fell off end\");\n \n-    if (npc < PC)\n-      current_state->check_no_uninitialized_objects (current_method->max_locals,\n-\t\t\t\t\t\t     this);\n+    // According to the JVM Spec, we need to check for uninitialized\n+    // objects here.  However, this does not actually affect type\n+    // safety, and the Eclipse java compiler generates code that\n+    // violates this constraint.\n     merge_into (npc, current_state);\n     invalidate_pc ();\n   }\n@@ -1515,8 +1500,10 @@ class _Jv_BytecodeVerifier\n   {\n     int npc = compute_jump (offset);\n \n-    if (npc < PC)\n-      current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n+    // According to the JVM Spec, we need to check for uninitialized\n+    // objects here.  However, this does not actually affect type\n+    // safety, and the Eclipse java compiler generates code that\n+    // violates this constraint.\n \n     // Modify our state as appropriate for entry into a subroutine.\n     type ret_addr (return_address_type);"}]}