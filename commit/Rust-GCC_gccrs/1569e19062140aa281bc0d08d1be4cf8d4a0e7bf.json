{"sha": "1569e19062140aa281bc0d08d1be4cf8d4a0e7bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU2OWUxOTA2MjE0MGFhMjgxYmMwZDA4ZDFiZTRjZjhkNGEwZTdiZg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-03-31T15:16:41Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-03-31T15:16:41Z"}, "message": "loop-iv.c (simplify_using_condition): A condition of the form (EQ REG CONST) can be used to simply make a substitution.\n\n\t* loop-iv.c (simplify_using_condition): A condition of the form\n\t(EQ REG CONST) can be used to simply make a substitution.\n\t(simplify_using_initial_values): Keep track of conditions we have seen\n\tand keep using them to simplify new expressions, while applying the\n\tsame substitutions to them as to the expression.\n\nFrom-SVN: r145352", "tree": {"sha": "f70a92f822f9ed585d42284f367304878fc9253d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f70a92f822f9ed585d42284f367304878fc9253d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf/comments", "author": null, "committer": null, "parents": [{"sha": "ed853664c52914caf6b9841bf6abfdb168b1b96e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed853664c52914caf6b9841bf6abfdb168b1b96e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed853664c52914caf6b9841bf6abfdb168b1b96e"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "d4686fd651be91739ac271995c21900e1077af9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1569e19062140aa281bc0d08d1be4cf8d4a0e7bf", "patch": "@@ -9,6 +9,12 @@\n \t(simplify_using_initial_values): Deal with altered regs here and track\n \tmore precisely the effect they have on the validity of our expression.\n \n+\t* loop-iv.c (simplify_using_condition): A condition of the form\n+\t(EQ REG CONST) can be used to simply make a substitution.\n+\t(simplify_using_initial_values): Keep track of conditions we have seen\n+\tand keep using them to simplify new expressions, while applying the\n+\tsame substitutions to them as to the expression.\n+\n 2009-03-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n         PR target/27237"}, {"sha": "123e37cff599a7af8acbfe1ed0bd461740e89370", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1569e19062140aa281bc0d08d1be4cf8d4a0e7bf/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=1569e19062140aa281bc0d08d1be4cf8d4a0e7bf", "patch": "@@ -1636,15 +1636,22 @@ simplify_using_condition (rtx cond, rtx *expr, regset altered)\n {\n   rtx rev, reve, exp = *expr;\n \n-  if (!COMPARISON_P (exp))\n-    return;\n-\n   /* If some register gets altered later, we do not really speak about its\n      value at the time of comparison.  */\n   if (altered\n       && for_each_rtx (&cond, altered_reg_used, altered))\n     return;\n \n+  if (GET_CODE (cond) == EQ\n+      && REG_P (XEXP (cond, 0)) && CONSTANT_P (XEXP (cond, 1)))\n+    {\n+      *expr = simplify_replace_rtx (*expr, XEXP (cond, 0), XEXP (cond, 1));\n+      return;\n+    }\n+\n+  if (!COMPARISON_P (exp))\n+    return;\n+\n   rev = reversed_condition (cond);\n   reve = reversed_condition (exp);\n \n@@ -1661,7 +1668,6 @@ simplify_using_condition (rtx cond, rtx *expr, regset altered)\n       return;\n     }\n \n-\n   if (rev && rtx_equal_p (exp, rev))\n     {\n       *expr = const0_rtx;\n@@ -1746,7 +1752,7 @@ static void\n simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n {\n   bool expression_valid;\n-  rtx head, tail, insn, last_valid_expr;\n+  rtx head, tail, insn, cond_list, last_valid_expr;\n   rtx neutral, aggr;\n   regset altered, this_altered;\n   edge e;\n@@ -1817,26 +1823,40 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n   expression_valid = true;\n   last_valid_expr = *expr;\n+  cond_list = NULL_RTX;\n   while (1)\n     {\n       insn = BB_END (e->src);\n       if (any_condjump_p (insn))\n \t{\n \t  rtx cond = get_condition (BB_END (e->src), NULL, false, true);\n-      \n+\n \t  if (cond && (e->flags & EDGE_FALLTHRU))\n \t    cond = reversed_condition (cond);\n \t  if (cond)\n \t    {\n+\t      rtx old = *expr;\n \t      simplify_using_condition (cond, expr, altered);\n-\t      if (CONSTANT_P (*expr))\n-\t\tgoto out;\n+\t      if (old != *expr)\n+\t\t{\n+\t\t  rtx note;\n+\t\t  if (CONSTANT_P (*expr))\n+\t\t    goto out;\n+\t\t  for (note = cond_list; note; note = XEXP (note, 1))\n+\t\t    {\n+\t\t      simplify_using_condition (XEXP (note, 0), expr, altered);\n+\t\t      if (CONSTANT_P (*expr))\n+\t\t\tgoto out;\n+\t\t    }\n+\t\t}\n+\t      cond_list = alloc_EXPR_LIST (0, cond, cond_list);\n \t    }\n \t}\n \n       FOR_BB_INSNS_REVERSE (e->src, insn)\n \t{\n \t  rtx src, dest;\n+\t  rtx old = *expr;\n \n \t  if (!INSN_P (insn))\n \t    continue;\n@@ -1855,9 +1875,34 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n \t  if (suitable_set_for_replacement (insn, &dest, &src))\n \t    {\n+\t      rtx *pnote, *pnote_next;\n+\n \t      *expr = simplify_replace_rtx (*expr, dest, src);\n \t      if (CONSTANT_P (*expr))\n \t\tgoto out;\n+\n+\t      for (pnote = &cond_list; *pnote; pnote = pnote_next)\n+\t\t{\n+\t\t  rtx note = *pnote;\n+\t\t  rtx old_cond = XEXP (note, 0);\n+\n+\t\t  pnote_next = &XEXP (note, 1);\n+\t\t  XEXP (note, 0) = simplify_replace_rtx (XEXP (note, 0), dest,\n+\t\t\t\t\t\t\t src);\n+\t\t  /* We can no longer use a condition that has been simplified\n+\t\t     to a constant, and simplify_using_condition will abort if\n+\t\t     we try.  */\n+\t\t  if (CONSTANT_P (XEXP (note, 0)))\n+\t\t    {\n+\t\t      *pnote = *pnote_next;\n+\t\t      pnote_next = pnote;\n+\t\t      free_EXPR_LIST_node (note);\n+\t\t    }\n+\t\t  /* Retry simplifications with this condition if either the\n+\t\t     expression or the condition changed.  */\n+\t\t  else if (old_cond != XEXP (note, 0) || old != *expr)\n+\t\t    simplify_using_condition (XEXP (note, 0), expr, altered);\n+\t\t}\n \t    }\n \t  else\n \t    /* If we did not use this insn to make a replacement, any overlap\n@@ -1866,6 +1911,9 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t    if (for_each_rtx (expr, altered_reg_used, this_altered))\n \t      goto out;\n \n+\t  if (CONSTANT_P (*expr))\n+\t    goto out;\n+\n \t  IOR_REG_SET (altered, this_altered);\n \n \t  /* If the expression now contains regs that have been altered, we\n@@ -1885,6 +1933,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n     }\n \n  out:\n+  free_EXPR_LIST_list (&cond_list);\n   if (!CONSTANT_P (*expr))\n     *expr = last_valid_expr;\n   FREE_REG_SET (altered);"}]}