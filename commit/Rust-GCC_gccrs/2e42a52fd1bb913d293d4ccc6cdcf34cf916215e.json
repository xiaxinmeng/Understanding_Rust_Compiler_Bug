{"sha": "2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU0MmE1MmZkMWJiOTEzZDI5M2Q0Y2NjNmNkY2YzNGNmOTE2MjE1ZQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2019-01-24T22:48:06Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2019-01-24T22:48:06Z"}, "message": "altivec.md (build_vector_mask_for_load): Use MEM_P.\n\n\t* config/rs6000/altivec.md (build_vector_mask_for_load): Use MEM_P.\n\t* config/rs6000/constraints.md (Q constraint): Use REG_P.\n\t* config/rs6000/darwin.h (PREFERRED_RELOAD_CLASS): Use SYMBOL_REF_P.\n\t* config/rs6000/freebsd64.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Use\n\tSYMBOL_REF_P, CONST_INT_P and CONST_DOUBLE_P.\n\t* config/rs6000/linux64.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Likewise.\n\t* config/rs6000/predicates.md (altivec_register_operand, vint_operand,\n\tvsx_register_operand, vsx_reg_sfsubreg_ok, vfloat_operand,\n\tvlogical_operand, gpc_reg_operand, int_reg_operand,\n\tint_reg_operand_not_pseudo): Use SUBREG_P and HARD_REGISTER_P.\n\t(ca_operand, base_reg_operand, htm_spr_reg_operand, cc_reg_operand,\n\tcc_reg_not_cr0_operand, input_operand): Use SUBREG_P.\n\t(save_world_operation, restore_world_operation, lmw_operation,\n\tstmw_operation): Use MEM_P and REG_P.\n\t(tie_operand): Use MEM_P.\n\t(vrsave_operation, crsave_operation): Use REG_P.\n\t(mfcr_operation, mtcrf_operation): Use REG_P and CONST_INT_P.\n\t(fpr_reg_operand): Use SUBREG_P and HARD_REGISTER_NUM_P.\n\t(quad_int_reg_operand): Use HARD_REGISTER_NUM_P.\n\t(call_operand): Use HARD_REGISTER_P.\n\t(indexed_or_indirect_operand, altivec_indexed_or_indirect_operand):\n\tUse CONST_INT_P.\n\t(lwa_operand): Use SUBREG_P, REG_P and CONST_INT_P.\n\t* config/rs6000/rs6000-p8swap.c (insn_is_load_p, insn_is_store_p,\n\tquad_aligned_load_p, replace_swapped_aligned_store,\n\trecombine_lvx_pattern, replace_swapped_aligned_load,\n\trecombine_stvx_pattern): Use MEM_P.\n\t(const_load_sequence_p, adjust_vperm, replace_swapped_load_constant):\n\tUse MEM_P and SYMBOL_REF_P.\n\t(rtx_is_swappable_p): Use REG_P and CONST_INT_P.\n\t(insn_is_swappable_p): Use REG_P and MEM_P.\n\t(insn_is_swap_p, (alignment_mask): Use CONST_INT_P.\n\t* config/rs6000/rs6000-string.c (expand_block_clear, expand_block_move):\n\tUse CONST_INT_P.\n\t* config/rs6000/rs6000.c (rs6000_secondary_reload, rs6000_emit_cmove):\n\tUse CONST_DOUBLE_P.\n\t(rs6000_output_move_128bit): Use CONST_DOUBLE_P, CONST_INT_P and\n\tCONST_WIDE_INT_P.\n\t(rs6000_legitimize_address): Use CONST_DOUBLE_P, CONST_INT_P,\n\tCONST_WIDE_INT_P, REG_P and SYMBOL_REF_P.\n\t(rs6000_emit_move): Use CONST_DOUBLE_P, CONST_INT_P, HARD_REGISTER_P,\n\tHARD_REGISTER_NUM_P, MEM_P, REG_P, SUBREG_P, SYMBOL_REF_P and\n\treg_or_subregno:\n\t(output_toc): Use CONST_DOUBLE_P, CONST_INT_P and SYMBOL_REF_P.\n\t(easy_altivec_constant, rs6000_legitimate_offset_address_p,\n\trs6000_mode_dependent_address, rs6000_expand_mtfsf_builtin,\n\trs6000_expand_set_fpscr_rn_builtin, rs6000_expand_set_fpscr_drn_builtin,\n\trs6000_expand_unop_builtin, INT_P, rs6000_generate_compare,\n\trs6000_machopic_legitimize_pic_address, rs6000_split_logical_inner,\n\trs6000_split_logical_di): Use CONST_INT_P.\n\t(rs6000_legitimize_reload_address): Use CONST_INT_P, HARD_REGISTER_P,\n\tREG_P and SYMBOL_REF_P.\n\t(setup_incoming_varargs, rs6000_rtx_costs): Use CONST_INT_P and MEM_P.\n\t(print_operand): Use CONST_INT_P, MEM_P and REG_P.\n\t(virtual_stack_registers_memory_p, rs6000_legitimate_address_p,\n\tmems_ok_for_quad_peep): Use CONST_INT_P and REG_P.\n\t(rs6000_secondary_reload_memory): Use CONST_INT_P and SUBREG_P.\n\t(small_data_operand, print_operand_address): Use CONST_INT_P and\n\tSYMBOL_REF_P.\n\t(split_stack_arg_pointer_used_p): Use HARD_REGISTER_P.\n\t(rs6000_init_hard_regno_mode_ok, direct_move_p):\n\tUse HARD_REGISTER_NUM_P.\n\t(rs6000_secondary_reload_gpr): Use HARD_REGISTER_NUM_P and MEM_P.\n\t(rs6000_secondary_reload_class): Use HARD_REGISTER_NUM_P, REG_P,\n\tSUBREG_P and SYMBOL_REF_P.\n\t(register_to_reg_type, rs6000_secondary_reload_inner): Use SUBREG_P\n\tand HARD_REGISTER_NUM_P.\n\t(rs6000_adjust_vec_address): Use HARD_REGISTER_NUM_P and\n\treg_or_subregno.\n\t(rs6000_adjust_cost, find_mem_ref): Use MEM_P.\n\t(macho_lo_sum_memory_operand, rs6000_eliminate_indexed_memrefs): Use\n\tMEM_P and REG_P.\n\t(legitimate_indirect_address_p, legitimate_lo_sum_address_p,\n\tregisters_ok_for_quad_peep, rs6000_output_function_epilogue,\n\tfind_addr_reg): Use REG_P.\n\t(altivec_expand_vec_perm_const): Use REG_P and SUBREG_P.\n\t(rs6000_emit_le_vsx_move): Use SUBREG_P.\n\t(offsettable_ok_by_alignment, constant_pool_expr_p,\n\tlegitimate_small_data_p, rs6000_output_dwarf_dtprel,\n\trs6000_delegitimize_address, rs6000_const_not_ok_for_debug_p,\n\trs6000_cannot_force_const_mem, rs6000_output_addr_const_extra,\n\trs6000_assemble_integer, create_TOC_reference,\n\trs6000_emit_allocate_stack, rs6000_xcoff_encode_section_info,\n\trs6000_call_aix, rs6000_call_aix): Use SYMBOL_REF_P.\n\t(rs6000_split_vec_extract_var): Use reg_or_subregno.\n\t* config/rs6000/rtems.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Use\n\tCONST_DOUBLE_P, CONST_INT_P and SYMBOL_REF_P.\n\t* config/rs6000/sysv4.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Likewise.\n\t* config/rs6000/xcoff.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Likewise.\n\t* config/rs6000/rs6000.h (RS6000_SYMBOL_REF_TLS_P): Use SYMBOL_REF_P.\n\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P): Use HARD_REGISTER_NUM_P.\n\t(INT_REG_OK_FOR_INDEX_P, INT_REG_OK_FOR_BASE_P): Use HARD_REGISTER_P.\n\t(CONSTANT_ADDRESS_P): Use CONST_INT_P and SYMBOL_REF_P.\n\t* config/rs6000/rs6000.md (define_expands strlensi, mod<mode>3\n\tand cbranch<mode>4): Use CONST_INT_P.\n\t(multiple define_splits): Use REG_P and SUBREG_P.\n\t(define_expands call, call_value): Use MEM_P.\n\t(define_expands sibcall, sibcall_value): Use CONST_INT_P and  MEM_P.\n\t(define insn *mtcrfsi): Use CONST_INT_P and REG_P.\n\t* config/rs6000/vsx.md (*vsx_le_perm_load_<mode>,\n\t*vsx_le_perm_load_v8hi, *vsx_le_perm_load_v16qi): Use HARD_REGISTER_P\n\tand HARD_REGISTER_NUM_P.\n\t(multiple define_splits): Use HARD_REGISTER_NUM_P.\n\nFrom-SVN: r268253", "tree": {"sha": "a3b74f2103a5ecfb98edb092530faee48fe1a049", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3b74f2103a5ecfb98edb092530faee48fe1a049"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5d0294eafc305eaf15eaee914cccab148fb51f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d0294eafc305eaf15eaee914cccab148fb51f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5d0294eafc305eaf15eaee914cccab148fb51f0"}], "stats": {"total": 793, "additions": 441, "deletions": 352}, "files": [{"sha": "7156b64dc1dc91e8e5f250a43494798bbf1d40b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -1,3 +1,109 @@\n+2019-01-24  Peter Bergner  <bergner@linux.ibm.com>\n+\n+\t* config/rs6000/altivec.md (build_vector_mask_for_load): Use MEM_P.\n+\t* config/rs6000/constraints.md (Q constraint): Use REG_P.\n+\t* config/rs6000/darwin.h (PREFERRED_RELOAD_CLASS): Use SYMBOL_REF_P.\n+\t* config/rs6000/freebsd64.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Use\n+\tSYMBOL_REF_P, CONST_INT_P and CONST_DOUBLE_P.\n+\t* config/rs6000/linux64.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Likewise.\n+\t* config/rs6000/predicates.md (altivec_register_operand, vint_operand,\n+\tvsx_register_operand, vsx_reg_sfsubreg_ok, vfloat_operand,\n+\tvlogical_operand, gpc_reg_operand, int_reg_operand,\n+\tint_reg_operand_not_pseudo): Use SUBREG_P and HARD_REGISTER_P.\n+\t(ca_operand, base_reg_operand, htm_spr_reg_operand, cc_reg_operand,\n+\tcc_reg_not_cr0_operand, input_operand): Use SUBREG_P.\n+\t(save_world_operation, restore_world_operation, lmw_operation,\n+\tstmw_operation): Use MEM_P and REG_P.\n+\t(tie_operand): Use MEM_P.\n+\t(vrsave_operation, crsave_operation): Use REG_P.\n+\t(mfcr_operation, mtcrf_operation): Use REG_P and CONST_INT_P.\n+\t(fpr_reg_operand): Use SUBREG_P and HARD_REGISTER_NUM_P.\n+\t(quad_int_reg_operand): Use HARD_REGISTER_NUM_P.\n+\t(call_operand): Use HARD_REGISTER_P.\n+\t(indexed_or_indirect_operand, altivec_indexed_or_indirect_operand):\n+\tUse CONST_INT_P.\n+\t(lwa_operand): Use SUBREG_P, REG_P and CONST_INT_P.\n+\t* config/rs6000/rs6000-p8swap.c (insn_is_load_p, insn_is_store_p,\n+\tquad_aligned_load_p, replace_swapped_aligned_store,\n+\trecombine_lvx_pattern, replace_swapped_aligned_load,\n+\trecombine_stvx_pattern): Use MEM_P.\n+\t(const_load_sequence_p, adjust_vperm, replace_swapped_load_constant):\n+\tUse MEM_P and SYMBOL_REF_P.\n+\t(rtx_is_swappable_p): Use REG_P and CONST_INT_P.\n+\t(insn_is_swappable_p): Use REG_P and MEM_P.\n+\t(insn_is_swap_p, (alignment_mask): Use CONST_INT_P.\n+\t* config/rs6000/rs6000-string.c (expand_block_clear, expand_block_move):\n+\tUse CONST_INT_P.\n+\t* config/rs6000/rs6000.c (rs6000_secondary_reload, rs6000_emit_cmove):\n+\tUse CONST_DOUBLE_P.\n+\t(rs6000_output_move_128bit): Use CONST_DOUBLE_P, CONST_INT_P and\n+\tCONST_WIDE_INT_P.\n+\t(rs6000_legitimize_address): Use CONST_DOUBLE_P, CONST_INT_P,\n+\tCONST_WIDE_INT_P, REG_P and SYMBOL_REF_P.\n+\t(rs6000_emit_move): Use CONST_DOUBLE_P, CONST_INT_P, HARD_REGISTER_P,\n+\tHARD_REGISTER_NUM_P, MEM_P, REG_P, SUBREG_P, SYMBOL_REF_P and\n+\treg_or_subregno:\n+\t(output_toc): Use CONST_DOUBLE_P, CONST_INT_P and SYMBOL_REF_P.\n+\t(easy_altivec_constant, rs6000_legitimate_offset_address_p,\n+\trs6000_mode_dependent_address, rs6000_expand_mtfsf_builtin,\n+\trs6000_expand_set_fpscr_rn_builtin, rs6000_expand_set_fpscr_drn_builtin,\n+\trs6000_expand_unop_builtin, INT_P, rs6000_generate_compare,\n+\trs6000_machopic_legitimize_pic_address, rs6000_split_logical_inner,\n+\trs6000_split_logical_di): Use CONST_INT_P.\n+\t(rs6000_legitimize_reload_address): Use CONST_INT_P, HARD_REGISTER_P,\n+\tREG_P and SYMBOL_REF_P.\n+\t(setup_incoming_varargs, rs6000_rtx_costs): Use CONST_INT_P and MEM_P.\n+\t(print_operand): Use CONST_INT_P, MEM_P and REG_P.\n+\t(virtual_stack_registers_memory_p, rs6000_legitimate_address_p,\n+\tmems_ok_for_quad_peep): Use CONST_INT_P and REG_P.\n+\t(rs6000_secondary_reload_memory): Use CONST_INT_P and SUBREG_P.\n+\t(small_data_operand, print_operand_address): Use CONST_INT_P and\n+\tSYMBOL_REF_P.\n+\t(split_stack_arg_pointer_used_p): Use HARD_REGISTER_P.\n+\t(rs6000_init_hard_regno_mode_ok, direct_move_p):\n+\tUse HARD_REGISTER_NUM_P.\n+\t(rs6000_secondary_reload_gpr): Use HARD_REGISTER_NUM_P and MEM_P.\n+\t(rs6000_secondary_reload_class): Use HARD_REGISTER_NUM_P, REG_P,\n+\tSUBREG_P and SYMBOL_REF_P.\n+\t(register_to_reg_type, rs6000_secondary_reload_inner): Use SUBREG_P\n+\tand HARD_REGISTER_NUM_P.\n+\t(rs6000_adjust_vec_address): Use HARD_REGISTER_NUM_P and\n+\treg_or_subregno.\n+\t(rs6000_adjust_cost, find_mem_ref): Use MEM_P.\n+\t(macho_lo_sum_memory_operand, rs6000_eliminate_indexed_memrefs): Use\n+\tMEM_P and REG_P.\n+\t(legitimate_indirect_address_p, legitimate_lo_sum_address_p,\n+\tregisters_ok_for_quad_peep, rs6000_output_function_epilogue,\n+\tfind_addr_reg): Use REG_P.\n+\t(altivec_expand_vec_perm_const): Use REG_P and SUBREG_P.\n+\t(rs6000_emit_le_vsx_move): Use SUBREG_P.\n+\t(offsettable_ok_by_alignment, constant_pool_expr_p,\n+\tlegitimate_small_data_p, rs6000_output_dwarf_dtprel,\n+\trs6000_delegitimize_address, rs6000_const_not_ok_for_debug_p,\n+\trs6000_cannot_force_const_mem, rs6000_output_addr_const_extra,\n+\trs6000_assemble_integer, create_TOC_reference,\n+\trs6000_emit_allocate_stack, rs6000_xcoff_encode_section_info,\n+\trs6000_call_aix, rs6000_call_aix): Use SYMBOL_REF_P.\n+\t(rs6000_split_vec_extract_var): Use reg_or_subregno.\n+\t* config/rs6000/rtems.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Use\n+\tCONST_DOUBLE_P, CONST_INT_P and SYMBOL_REF_P.\n+\t* config/rs6000/sysv4.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Likewise.\n+\t* config/rs6000/xcoff.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Likewise.\n+\t* config/rs6000/rs6000.h (RS6000_SYMBOL_REF_TLS_P): Use SYMBOL_REF_P.\n+\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P): Use HARD_REGISTER_NUM_P.\n+\t(INT_REG_OK_FOR_INDEX_P, INT_REG_OK_FOR_BASE_P): Use HARD_REGISTER_P.\n+\t(CONSTANT_ADDRESS_P): Use CONST_INT_P and SYMBOL_REF_P.\n+\t* config/rs6000/rs6000.md (define_expands strlensi, mod<mode>3\n+\tand cbranch<mode>4): Use CONST_INT_P.\n+\t(multiple define_splits): Use REG_P and SUBREG_P.\n+\t(define_expands call, call_value): Use MEM_P.\n+\t(define_expands sibcall, sibcall_value): Use CONST_INT_P and  MEM_P.\n+\t(define insn *mtcrfsi): Use CONST_INT_P and REG_P.\n+\t* config/rs6000/vsx.md (*vsx_le_perm_load_<mode>,\n+\t*vsx_le_perm_load_v8hi, *vsx_le_perm_load_v16qi): Use HARD_REGISTER_P\n+\tand HARD_REGISTER_NUM_P.\n+\t(multiple define_splits): Use HARD_REGISTER_NUM_P.\n+\n 2019-01-24  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/88948"}, {"sha": "4a1150e099496b22b675c51dbfe9d0dafd7e61ff", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -2523,7 +2523,7 @@\n   rtx addr;\n   rtx temp;\n \n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n \n   addr = XEXP (operands[1], 0);\n   temp = gen_reg_rtx (GET_MODE (addr));"}, {"sha": "27db92bf0d61e0d83318a1584adfeb77723a6a70", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -281,7 +281,7 @@ several times, or that might not access it at all.\"\n   \"Memory operand that is an offset from a register (it is usually better\n to use @samp{m} or @samp{es} in @code{asm} statements)\"\n   (and (match_code \"mem\")\n-       (match_test \"GET_CODE (XEXP (op, 0)) == REG\")))\n+       (match_test \"REG_P (XEXP (op, 0))\")))\n \n (define_memory_constraint \"Y\"\n   \"memory operand for 8 byte and 16 byte gpr load/store\""}, {"sha": "6884185f0bc163502389621d5a3ec2e7215b7323", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -342,7 +342,7 @@ extern int darwin_emit_branch_islands;\n   ((CONSTANT_P (X)\t\t\t\t\t\t\\\n     && reg_classes_intersect_p ((CLASS), FLOAT_REGS))\t\t\\\n    ? NO_REGS\t\t\t\t\t\t\t\\\n-   : ((GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == HIGH)\t\\\n+   : ((SYMBOL_REF_P (X) || GET_CODE (X) == HIGH)\t\t\\\n       && reg_class_subset_p (BASE_REGS, (CLASS)))\t\t\\\n    ? BASE_REGS\t\t\t\t\t\t\t\\\n    : (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\"}, {"sha": "d1f1d61301993ce96dab77b03db8872308de7e3e", "filename": "gcc/config/rs6000/freebsd64.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Ffreebsd64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Ffreebsd64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ffreebsd64.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -400,13 +400,13 @@ extern int dot_symbols;\n #undef  ASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)                        \\\n   (TARGET_TOC                                                           \\\n-   && (GET_CODE (X) == SYMBOL_REF                                       \\\n+   && (SYMBOL_REF_P (X)\t\t\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS      \\\n-           && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)           \\\n+           && SYMBOL_REF_P (XEXP (XEXP (X, 0), 0)))\t\t\t\\\n        || GET_CODE (X) == LABEL_REF                                     \\\n-       || (GET_CODE (X) == CONST_INT                                    \\\n+       || (CONST_INT_P (X)\t\t\t\t\t\t\\\n            && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))      \\\n-       || (GET_CODE (X) == CONST_DOUBLE                                 \\\n+       || (CONST_DOUBLE_P (X)\t\t\t\t\t\t\\\n            && ((TARGET_64BIT                                            \\\n                 && (TARGET_MINIMAL_TOC                                  \\\n                     || (SCALAR_FLOAT_MODE_P (GET_MODE (X))              \\"}, {"sha": "29e9afa7f3d9e198186a68af49f956180ff10bd0", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -580,14 +580,14 @@ extern int dot_symbols;\n #undef  ASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\\n-   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+   && (SYMBOL_REF_P (X)\t\t\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+\t   && SYMBOL_REF_P (XEXP (XEXP (X, 0), 0)))\t\t\t\\\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+       || (CONST_INT_P (X)\t\t\t\t\t\t\\\n \t   && TARGET_CMODEL != CMODEL_MEDIUM\t\t\t\t\\\n \t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n-       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+       || (CONST_DOUBLE_P (X)\t\t\t\t\t\t\\\n \t   && ((TARGET_64BIT\t\t\t\t\t\t\\\n \t\t&& (TARGET_MINIMAL_TOC\t\t\t\t\t\\\n \t\t    || (SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\\"}, {"sha": "5cc80dea66c061712478c523c6103705d46ea18b", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -65,7 +65,7 @@\n (define_predicate \"altivec_register_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -76,7 +76,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return ALTIVEC_REGNO_P (REGNO (op));\n@@ -86,7 +86,7 @@\n (define_predicate \"vsx_register_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -97,7 +97,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return VSX_REGNO_P (REGNO (op));\n@@ -107,13 +107,13 @@\n (define_predicate \"vsx_reg_sfsubreg_ok\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return VSX_REGNO_P (REGNO (op));\n@@ -124,7 +124,7 @@\n (define_predicate \"vfloat_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -135,7 +135,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return VFLOAT_REGNO_P (REGNO (op));\n@@ -146,7 +146,7 @@\n (define_predicate \"vint_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -157,7 +157,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return VINT_REGNO_P (REGNO (op));\n@@ -168,7 +168,7 @@\n (define_predicate \"vlogical_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -180,7 +180,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return VLOGICAL_REGNO_P (REGNO (op));\n@@ -190,7 +190,7 @@\n (define_predicate \"ca_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n@@ -309,7 +309,7 @@\n (define_predicate \"gpc_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -320,7 +320,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   if (TARGET_ALTIVEC && ALTIVEC_REGNO_P (REGNO (op)))\n@@ -338,7 +338,7 @@\n (define_predicate \"int_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     {\n       if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n \treturn 0;\n@@ -349,7 +349,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 1;\n \n   return INT_REGNO_P (REGNO (op));\n@@ -361,13 +361,13 @@\n (define_predicate \"int_reg_operand_not_pseudo\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_P (op))\n     return 0;\n \n   return INT_REGNO_P (REGNO (op));\n@@ -377,7 +377,7 @@\n (define_predicate \"base_reg_operand\"\n   (match_operand 0 \"int_reg_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n@@ -393,14 +393,14 @@\n {\n   HOST_WIDE_INT r;\n \n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n     return 0;\n \n   r = REGNO (op);\n-  if (r >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_NUM_P (r))\n     return 1;\n \n   return FP_REGNO_P (r);\n@@ -413,7 +413,7 @@\n   if (!TARGET_HTM)\n     return 0;\n \n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n@@ -449,7 +449,7 @@\n     return 0;\n \n   r = REGNO (op);\n-  if (r >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_NUM_P (r))\n     return 1;\n \n   return (INT_REGNO_P (r) && ((r & 1) == 0));\n@@ -459,7 +459,7 @@\n (define_predicate \"cc_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n@@ -475,7 +475,7 @@\n (define_predicate \"cc_reg_not_cr0_operand\"\n   (match_operand 0 \"register_operand\")\n {\n-  if (GET_CODE (op) == SUBREG)\n+  if (SUBREG_P (op))\n     op = SUBREG_REG (op);\n \n   if (!REG_P (op))\n@@ -780,7 +780,7 @@\n   op = XEXP (op, 0);\n   if (VECTOR_MEM_ALTIVEC_P (mode)\n       && GET_CODE (op) == AND\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op, 1))\n       && INTVAL (XEXP (op, 1)) == -16)\n     op = XEXP (op, 0);\n \n@@ -810,7 +810,7 @@\n   op = XEXP (op, 0);\n   if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode)\n       && GET_CODE (op) == AND\n-      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (op, 1))\n       && INTVAL (XEXP (op, 1)) == -16)\n     return indexed_or_indirect_address (XEXP (op, 0), mode);\n \n@@ -937,7 +937,7 @@\n   rtx inner, addr, offset;\n \n   inner = op;\n-  if (reload_completed && GET_CODE (inner) == SUBREG)\n+  if (reload_completed && SUBREG_P (inner))\n     inner = SUBREG_REG (inner);\n \n   if (gpc_reg_operand (inner, mode))\n@@ -952,13 +952,13 @@\n \t  && !legitimate_indexed_address_p (XEXP (addr, 1), 0)))\n     return false;\n   if (GET_CODE (addr) == LO_SUM\n-      && GET_CODE (XEXP (addr, 0)) == REG\n+      && REG_P (XEXP (addr, 0))\n       && GET_CODE (XEXP (addr, 1)) == CONST)\n     addr = XEXP (XEXP (addr, 1), 0);\n   if (GET_CODE (addr) != PLUS)\n     return true;\n   offset = XEXP (addr, 1);\n-  if (GET_CODE (offset) != CONST_INT)\n+  if (!CONST_INT_P (offset))\n     return true;\n   return INTVAL (offset) % 4 == 0;\n })\n@@ -1004,7 +1004,7 @@\n   (if_then_else (match_code \"reg\")\n      (match_test \"REGNO (op) == LR_REGNO\n \t\t  || REGNO (op) == CTR_REGNO\n-\t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\")\n+\t\t  || !HARD_REGISTER_P (op)\")\n      (match_code \"symbol_ref\")))\n \n ;; Return 1 if the operand, used inside a MEM, is a valid first argument\n@@ -1081,7 +1081,7 @@\n   /* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region\n      to be valid.  */\n   if (DEFAULT_ABI == ABI_V4\n-      && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST)\n+      && (SYMBOL_REF_P (op) || GET_CODE (op) == CONST)\n       && small_data_operand (op, Pmode))\n     return 1;\n \n@@ -1210,9 +1210,9 @@\n     {\n       elt = XVECEXP (op, 0, index++);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || ! memory_operand (SET_DEST (elt), DFmode)\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || !MEM_P (SET_DEST (elt))\n+\t  || !memory_operand (SET_DEST (elt), DFmode)\n+\t  || !REG_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != DFmode)\n \treturn 0;\n     }\n@@ -1221,8 +1221,8 @@\n     {\n       elt = XVECEXP (op, 0, index++);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || !MEM_P (SET_DEST (elt))\n+\t  || !REG_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != V4SImode)\n \treturn 0;\n     }\n@@ -1231,18 +1231,18 @@\n     {\n       elt = XVECEXP (op, 0, index++);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n-\t  || ! memory_operand (SET_DEST (elt), Pmode)\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || !MEM_P (SET_DEST (elt))\n+\t  || !memory_operand (SET_DEST (elt), Pmode)\n+\t  || !REG_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != Pmode)\n \treturn 0;\n     }\n \n   elt = XVECEXP (op, 0, index++);\n   if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_DEST (elt)) != MEM\n-      || ! memory_operand (SET_DEST (elt), Pmode)\n-      || GET_CODE (SET_SRC (elt)) != REG\n+      || !MEM_P (SET_DEST (elt))\n+      || !memory_operand (SET_DEST (elt), Pmode)\n+      || !REG_P (SET_SRC (elt))\n       || REGNO (SET_SRC (elt)) != CR2_REGNO\n       || GET_MODE (SET_SRC (elt)) != Pmode)\n     return 0;\n@@ -1274,9 +1274,9 @@\n \n   elt = XVECEXP (op, 0, index++);\n   if (GET_CODE (elt) != SET\n-      || GET_CODE (SET_SRC (elt)) != MEM\n-      || ! memory_operand (SET_SRC (elt), Pmode)\n-      || GET_CODE (SET_DEST (elt)) != REG\n+      || !MEM_P (SET_SRC (elt))\n+      || !memory_operand (SET_SRC (elt), Pmode)\n+      || !REG_P (SET_DEST (elt))\n       || REGNO (SET_DEST (elt)) != CR2_REGNO\n       || GET_MODE (SET_DEST (elt)) != Pmode)\n     return 0;\n@@ -1285,9 +1285,9 @@\n     {\n       elt = XVECEXP (op, 0, index++);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || ! memory_operand (SET_SRC (elt), Pmode)\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || !MEM_P (SET_SRC (elt))\n+\t  || !memory_operand (SET_SRC (elt), Pmode)\n+\t  || !REG_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != Pmode)\n \treturn 0;\n     }\n@@ -1296,8 +1296,8 @@\n     {\n       elt = XVECEXP (op, 0, index++);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || !MEM_P (SET_SRC (elt))\n+\t  || !REG_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != V4SImode)\n \treturn 0;\n     }\n@@ -1306,9 +1306,9 @@\n     {\n       elt = XVECEXP (op, 0, index++);\n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n-\t  || ! memory_operand (SET_SRC (elt), DFmode)\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || !MEM_P (SET_SRC (elt))\n+\t  || !memory_operand (SET_SRC (elt), DFmode)\n+\t  || !REG_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != DFmode)\n \treturn 0;\n     }\n@@ -1332,7 +1332,7 @@\n \n   if (count <= 1\n       || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || !REG_P (SET_DEST (XVECEXP (op, 0, 0)))\n       || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC_VOLATILE\n       || XINT (SET_SRC (XVECEXP (op, 0, 0)), 1) != UNSPECV_SET_VRSAVE)\n     return 0;\n@@ -1378,13 +1378,13 @@\n \n       src_reg = XVECEXP (SET_SRC (exp), 0, 0);\n \n-      if (GET_CODE (src_reg) != REG\n+      if (!REG_P (src_reg)\n \t  || GET_MODE (src_reg) != CCmode\n \t  || ! CR_REGNO_P (REGNO (src_reg)))\n \treturn 0;\n \n       if (GET_CODE (exp) != SET\n-\t  || GET_CODE (SET_DEST (exp)) != REG\n+\t  || !REG_P (SET_DEST (exp))\n \t  || GET_MODE (SET_DEST (exp)) != SImode\n \t  || ! INT_REGNO_P (REGNO (SET_DEST (exp))))\n \treturn 0;\n@@ -1395,7 +1395,7 @@\n \t  || XINT (unspec, 1) != UNSPEC_MOVESI_FROM_CR\n \t  || XVECLEN (unspec, 0) != 2\n \t  || XVECEXP (unspec, 0, 0) != src_reg\n-\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n+\t  || !CONST_INT_P (XVECEXP (unspec, 0, 1))\n \t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n \treturn 0;\n     }\n@@ -1418,7 +1418,7 @@\n     return 0;\n   src_reg = XVECEXP (SET_SRC (XVECEXP (op, 0, 0)), 0, 0);\n \n-  if (GET_CODE (src_reg) != REG\n+  if (!REG_P (src_reg)\n       || GET_MODE (src_reg) != SImode\n       || ! INT_REGNO_P (REGNO (src_reg)))\n     return 0;\n@@ -1430,7 +1430,7 @@\n       int maskval;\n \n       if (GET_CODE (exp) != SET\n-\t  || GET_CODE (SET_DEST (exp)) != REG\n+\t  || !REG_P (SET_DEST (exp))\n \t  || GET_MODE (SET_DEST (exp)) != CCmode\n \t  || ! CR_REGNO_P (REGNO (SET_DEST (exp))))\n \treturn 0;\n@@ -1441,7 +1441,7 @@\n \t  || XINT (unspec, 1) != UNSPEC_MOVESI_TO_CR\n \t  || XVECLEN (unspec, 0) != 2\n \t  || XVECEXP (unspec, 0, 0) != src_reg\n-\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n+\t  || !CONST_INT_P (XVECEXP (unspec, 0, 1))\n \t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n \treturn 0;\n     }\n@@ -1460,7 +1460,7 @@\n       rtx exp = XVECEXP (op, 0, i);\n \n       if (GET_CODE (exp) != USE\n-\t  || GET_CODE (XEXP (exp, 0)) != REG\n+\t  || !REG_P (XEXP (exp, 0))\n \t  || GET_MODE (XEXP (exp, 0)) != CCmode\n \t  || ! CR_REGNO_P (REGNO (XEXP (exp, 0))))\n \treturn 0;\n@@ -1482,8 +1482,8 @@\n   /* Perform a quick check so we don't blow up below.  */\n   if (count <= 1\n       || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+      || !REG_P (SET_DEST (XVECEXP (op, 0, 0)))\n+      || !MEM_P (SET_SRC (XVECEXP (op, 0, 0))))\n     return 0;\n \n   dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n@@ -1516,10 +1516,10 @@\n       HOST_WIDE_INT newoffset;\n \n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || !REG_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != SImode\n \t  || REGNO (SET_DEST (elt)) != dest_regno + i\n-\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || !MEM_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != SImode)\n \treturn 0;\n       newaddr = XEXP (SET_SRC (elt), 0);\n@@ -1557,8 +1557,8 @@\n   /* Perform a quick check so we don't blow up below.  */\n   if (count <= 1\n       || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+      || !MEM_P (SET_DEST (XVECEXP (op, 0, 0)))\n+      || !REG_P (SET_SRC (XVECEXP (op, 0, 0))))\n     return 0;\n \n   src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n@@ -1591,10 +1591,10 @@\n       HOST_WIDE_INT newoffset;\n \n       if (GET_CODE (elt) != SET\n-\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || !REG_P (SET_SRC (elt))\n \t  || GET_MODE (SET_SRC (elt)) != SImode\n \t  || REGNO (SET_SRC (elt)) != src_regno + i\n-\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || !MEM_P (SET_DEST (elt))\n \t  || GET_MODE (SET_DEST (elt)) != SImode)\n \treturn 0;\n       newaddr = XEXP (SET_DEST (elt), 0);\n@@ -1623,7 +1623,7 @@\n   (match_code \"parallel\")\n {\n   return (GET_CODE (XVECEXP (op, 0, 0)) == SET\n-\t  && GET_CODE (XEXP (XVECEXP (op, 0, 0), 0)) == MEM\n+\t  && MEM_P (XEXP (XVECEXP (op, 0, 0), 0))\n \t  && GET_MODE (XEXP (XVECEXP (op, 0, 0), 0)) == BLKmode\n \t  && XEXP (XVECEXP (op, 0, 0), 1) == const0_rtx);\n })"}, {"sha": "bb9c16758d02288757277dcdf2c6f1e165e451d2", "filename": "gcc/config/rs6000/rs6000-p8swap.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -259,11 +259,11 @@ insn_is_load_p (rtx insn)\n \n   if (GET_CODE (body) == SET)\n     {\n-      if (GET_CODE (SET_SRC (body)) == MEM)\n+      if (MEM_P (SET_SRC (body)))\n \treturn 1;\n \n       if (GET_CODE (SET_SRC (body)) == VEC_SELECT\n-\t  && GET_CODE (XEXP (SET_SRC (body), 0)) == MEM)\n+\t  && MEM_P (XEXP (SET_SRC (body), 0)))\n \treturn 1;\n \n       return 0;\n@@ -274,7 +274,7 @@ insn_is_load_p (rtx insn)\n \n   rtx set = XVECEXP (body, 0, 0);\n \n-  if (GET_CODE (set) == SET && GET_CODE (SET_SRC (set)) == MEM)\n+  if (GET_CODE (set) == SET && MEM_P (SET_SRC (set)))\n     return 1;\n \n   return 0;\n@@ -286,12 +286,12 @@ static unsigned int\n insn_is_store_p (rtx insn)\n {\n   rtx body = PATTERN (insn);\n-  if (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == MEM)\n+  if (GET_CODE (body) == SET && MEM_P (SET_DEST (body)))\n     return 1;\n   if (GET_CODE (body) != PARALLEL)\n     return 0;\n   rtx set = XVECEXP (body, 0, 0);\n-  if (GET_CODE (set) == SET && GET_CODE (SET_DEST (set)) == MEM)\n+  if (GET_CODE (set) == SET && MEM_P (SET_DEST (set)))\n     return 1;\n   return 0;\n }\n@@ -316,13 +316,13 @@ insn_is_swap_p (rtx insn)\n   for (unsigned int i = 0; i < len / 2; ++i)\n     {\n       rtx op = XVECEXP (parallel, 0, i);\n-      if (GET_CODE (op) != CONST_INT || INTVAL (op) != len / 2 + i)\n+      if (!CONST_INT_P (op) || INTVAL (op) != len / 2 + i)\n \treturn 0;\n     }\n   for (unsigned int i = len / 2; i < len; ++i)\n     {\n       rtx op = XVECEXP (parallel, 0, i);\n-      if (GET_CODE (op) != CONST_INT || INTVAL (op) != i - len / 2)\n+      if (!CONST_INT_P (op) || INTVAL (op) != i - len / 2)\n \treturn 0;\n     }\n   return 1;\n@@ -393,7 +393,7 @@ quad_aligned_load_p (swap_web_entry *insn_entry, rtx_insn *insn)\n   rtx body = PATTERN (def_insn);\n   if (GET_CODE (body) != SET\n       || GET_CODE (SET_SRC (body)) != VEC_SELECT\n-      || GET_CODE (XEXP (SET_SRC (body), 0)) != MEM)\n+      || !MEM_P (XEXP (SET_SRC (body), 0)))\n     return false;\n \n   rtx mem = XEXP (SET_SRC (body), 0);\n@@ -532,7 +532,7 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n       rtx body = PATTERN (def_insn);\n       if (GET_CODE (body) != SET\n \t  || GET_CODE (SET_SRC (body)) != VEC_SELECT\n-\t  || GET_CODE (XEXP (SET_SRC (body), 0)) != MEM)\n+\t  || !MEM_P (XEXP (SET_SRC (body), 0)))\n \treturn false;\n \n       rtx mem = XEXP (SET_SRC (body), 0);\n@@ -571,19 +571,19 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \t  /* There is an extra level of indirection for small/large\n \t     code models.  */\n \t  rtx tocrel_expr = SET_SRC (tocrel_body);\n-\t  if (GET_CODE (tocrel_expr) == MEM)\n+\t  if (MEM_P (tocrel_expr))\n \t    tocrel_expr = XEXP (tocrel_expr, 0);\n \t  if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n \t    return false;\n \t  split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n \n-\t  if (GET_CODE (base) != SYMBOL_REF || !CONSTANT_POOL_ADDRESS_P (base))\n+\t  if (!SYMBOL_REF_P (base) || !CONSTANT_POOL_ADDRESS_P (base))\n \t    return false;\n \t  else\n \t    {\n \t      /* FIXME: The conditions under which\n-\t          ((GET_CODE (const_vector) == SYMBOL_REF) &&\n-\t           !CONSTANT_POOL_ADDRESS_P (const_vector))\n+\t          (SYMBOL_REF_P (const_vector)\n+\t           && !CONSTANT_POOL_ADDRESS_P (const_vector))\n \t         are not well understood.  This code prevents\n \t         an internal compiler error which will occur in\n \t         replace_swapped_load_constant () if we were to return\n@@ -592,7 +592,7 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \t         replace_swapped_load_constant () and then we can\n \t         remove this special test.  */\n \t      rtx const_vector = get_pool_constant (base);\n-\t      if (GET_CODE (const_vector) == SYMBOL_REF\n+\t      if (SYMBOL_REF_P (const_vector)\n \t\t  && CONSTANT_POOL_ADDRESS_P (const_vector))\n \t\tconst_vector = get_pool_constant (const_vector);\n \t      if (GET_CODE (const_vector) != CONST_VECTOR)\n@@ -674,7 +674,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t and XEXP (op, 1) is a PARALLEL with a single QImode const int,\n \t it represents a vector splat for which we can do special\n \t handling.  */\n-      if (GET_CODE (XEXP (op, 0)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (op, 0)))\n \treturn 1;\n       else if (REG_P (XEXP (op, 0))\n \t       && GET_MODE_INNER (GET_MODE (op)) == GET_MODE (XEXP (op, 0)))\n@@ -694,11 +694,11 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \n     case VEC_SELECT:\n       /* A vec_extract operation is ok if we change the lane.  */\n-      if (GET_CODE (XEXP (op, 0)) == REG\n+      if (REG_P (XEXP (op, 0))\n \t  && GET_MODE_INNER (GET_MODE (XEXP (op, 0))) == GET_MODE (op)\n \t  && GET_CODE ((parallel = XEXP (op, 1))) == PARALLEL\n \t  && XVECLEN (parallel, 0) == 1\n-\t  && GET_CODE (XVECEXP (parallel, 0, 0)) == CONST_INT)\n+\t  && CONST_INT_P (XVECEXP (parallel, 0, 0)))\n \t{\n \t  *special = SH_EXTRACT;\n \t  return 1;\n@@ -711,8 +711,8 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t\t   || GET_MODE (XEXP (op, 0)) == V4DImode)\n \t       && GET_CODE ((parallel = XEXP (op, 1))) == PARALLEL\n \t       && XVECLEN (parallel, 0) == 2\n-\t       && GET_CODE (XVECEXP (parallel, 0, 0)) == CONST_INT\n-\t       && GET_CODE (XVECEXP (parallel, 0, 1)) == CONST_INT)\n+\t       && CONST_INT_P (XVECEXP (parallel, 0, 0))\n+\t       && CONST_INT_P (XVECEXP (parallel, 0, 1)))\n \t{\n \t  *special = SH_XXPERMDI;\n \t  return 1;\n@@ -861,7 +861,7 @@ insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,\n \t  rtx rhs = SET_SRC (body);\n \t  /* Even without a swap, the RHS might be a vec_select for, say,\n \t     a byte-reversing load.  */\n-\t  if (GET_CODE (rhs) != MEM)\n+\t  if (!MEM_P (rhs))\n \t    return 0;\n \t  if (GET_CODE (XEXP (rhs, 0)) == AND)\n \t    return 0;\n@@ -882,7 +882,7 @@ insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,\n \t  rtx lhs = SET_DEST (body);\n \t  /* Even without a swap, the RHS might be a vec_select for, say,\n \t     a byte-reversing store.  */\n-\t  if (GET_CODE (lhs) != MEM)\n+\t  if (!MEM_P (lhs))\n \t    return 0;\n \t  if (GET_CODE (XEXP (lhs, 0)) == AND)\n \t    return 0;\n@@ -950,7 +950,7 @@ insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,\n       && GET_CODE (SET_SRC (body)) == UNSPEC\n       && XINT (SET_SRC (body), 1) == UNSPEC_VPERM\n       && XVECLEN (SET_SRC (body), 0) == 3\n-      && GET_CODE (XVECEXP (SET_SRC (body), 0, 2)) == REG)\n+      && REG_P (XVECEXP (SET_SRC (body), 0, 2)))\n     {\n       rtx mask_reg = XVECEXP (SET_SRC (body), 0, 2);\n       struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n@@ -1360,7 +1360,7 @@ adjust_vperm (rtx_insn *insn)\n   const_rtx tocrel_base;\n   rtx tocrel_expr = SET_SRC (PATTERN (tocrel_insn));\n   /* There is an extra level of indirection for small/large code models.  */\n-  if (GET_CODE (tocrel_expr) == MEM)\n+  if (MEM_P (tocrel_expr))\n     tocrel_expr = XEXP (tocrel_expr, 0);\n   if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n     gcc_unreachable ();\n@@ -1369,7 +1369,7 @@ adjust_vperm (rtx_insn *insn)\n   /* With the extra indirection, get_pool_constant will produce the\n      real constant from the reg_equal expression, so get the real\n      constant.  */\n-  if (GET_CODE (const_vector) == SYMBOL_REF)\n+  if (SYMBOL_REF_P (const_vector))\n     const_vector = get_pool_constant (const_vector);\n   gcc_assert (GET_CODE (const_vector) == CONST_VECTOR);\n \n@@ -1645,7 +1645,7 @@ replace_swapped_aligned_store (swap_web_entry *insn_entry,\n   rtx new_body = PATTERN (new_insn);\n \n   gcc_assert ((GET_CODE (new_body) == SET)\n-\t      && (GET_CODE (SET_DEST (new_body)) == MEM));\n+\t      && MEM_P (SET_DEST (new_body)));\n \n   set_block_for_insn (new_insn, BLOCK_FOR_INSN (store_insn));\n   df_insn_rescan (new_insn);\n@@ -1728,7 +1728,7 @@ replace_swapped_aligned_load (swap_web_entry *insn_entry, rtx swap_insn)\n   rtx body = PATTERN (def_insn);\n   gcc_assert ((GET_CODE (body) == SET)\n \t      && (GET_CODE (SET_SRC (body)) == VEC_SELECT)\n-\t      && (GET_CODE (XEXP (SET_SRC (body), 0)) == MEM));\n+\t      && MEM_P (XEXP (SET_SRC (body), 0)));\n \n   rtx src_exp = XEXP (SET_SRC (body), 0);\n   enum machine_mode mode = GET_MODE (src_exp);\n@@ -1738,7 +1738,7 @@ replace_swapped_aligned_load (swap_web_entry *insn_entry, rtx swap_insn)\n   rtx new_body = PATTERN (new_insn);\n \n   gcc_assert ((GET_CODE (new_body) == SET)\n-\t      && (GET_CODE (SET_SRC (new_body)) == MEM));\n+\t      && MEM_P (SET_SRC (new_body)));\n \n   set_block_for_insn (new_insn, BLOCK_FOR_INSN (def_insn));\n   df_insn_rescan (new_insn);\n@@ -1837,7 +1837,7 @@ replace_swapped_load_constant (swap_web_entry *insn_entry, rtx swap_insn)\n   const_rtx tocrel_base;\n \n   /* There is an extra level of indirection for small/large code models.  */\n-  if (GET_CODE (tocrel_expr) == MEM)\n+  if (MEM_P (tocrel_expr))\n     tocrel_expr = XEXP (tocrel_expr, 0);\n \n   if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n@@ -1849,7 +1849,7 @@ replace_swapped_load_constant (swap_web_entry *insn_entry, rtx swap_insn)\n   /* With the extra indirection, get_pool_constant will produce the\n      real constant from the reg_equal expression, so get the real\n      constant.  */\n-  if (GET_CODE (const_vector) == SYMBOL_REF)\n+  if (SYMBOL_REF_P (const_vector))\n     const_vector = get_pool_constant (const_vector);\n   gcc_assert (GET_CODE (const_vector) == CONST_VECTOR);\n \n@@ -2048,7 +2048,7 @@ alignment_mask (rtx_insn *insn)\n \n   rtx mask = XEXP (SET_SRC (body), 1);\n \n-  if (GET_CODE (mask) == CONST_INT)\n+  if (CONST_INT_P (mask))\n     {\n       if (INTVAL (mask) == -16)\n \treturn alignment_with_canonical_addr (SET_SRC (body));\n@@ -2079,7 +2079,7 @@ alignment_mask (rtx_insn *insn)\n \n       real_mask = SET_SRC (const_body);\n \n-      if (GET_CODE (real_mask) != CONST_INT\n+      if (!CONST_INT_P (real_mask)\n \t  || INTVAL (real_mask) != -16)\n \treturn 0;\n     }\n@@ -2133,7 +2133,7 @@ recombine_lvx_pattern (rtx_insn *insn, del_info *to_delete)\n   rtx body = PATTERN (insn);\n   gcc_assert (GET_CODE (body) == SET\n \t      && GET_CODE (SET_SRC (body)) == VEC_SELECT\n-\t      && GET_CODE (XEXP (SET_SRC (body), 0)) == MEM);\n+\t      && MEM_P (XEXP (SET_SRC (body), 0)));\n \n   rtx mem = XEXP (SET_SRC (body), 0);\n   rtx base_reg = XEXP (mem, 0);\n@@ -2195,7 +2195,7 @@ recombine_stvx_pattern (rtx_insn *insn, del_info *to_delete)\n {\n   rtx body = PATTERN (insn);\n   gcc_assert (GET_CODE (body) == SET\n-\t      && GET_CODE (SET_DEST (body)) == MEM\n+\t      && MEM_P (SET_DEST (body))\n \t      && GET_CODE (SET_SRC (body)) == VEC_SELECT);\n   rtx mem = SET_DEST (body);\n   rtx base_reg = XEXP (mem, 0);"}, {"sha": "46d6f6b584972145dea3edd3d1885622d952fa52", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -49,7 +49,7 @@ expand_block_clear (rtx operands[])\n   rtx orig_dest = operands[0];\n   rtx bytes_rtx\t= operands[1];\n   rtx align_rtx = operands[3];\n-  bool constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n+  bool constp\t= CONST_INT_P (bytes_rtx);\n   HOST_WIDE_INT align;\n   HOST_WIDE_INT bytes;\n   int offset;\n@@ -61,7 +61,7 @@ expand_block_clear (rtx operands[])\n     return 0;\n \n   /* This must be a fixed size alignment  */\n-  gcc_assert (GET_CODE (align_rtx) == CONST_INT);\n+  gcc_assert (CONST_INT_P (align_rtx));\n   align = INTVAL (align_rtx) * BITS_PER_UNIT;\n \n   /* Anything to clear? */\n@@ -113,7 +113,7 @@ expand_block_clear (rtx operands[])\n \t\t reload, not one per store.  */\n \t      addr = XEXP (orig_dest, 0);\n \t      if ((GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM)\n-\t\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t  && CONST_INT_P (XEXP (addr, 1))\n \t\t  && (INTVAL (XEXP (addr, 1)) & 3) != 0)\n \t\t{\n \t\t  addr = copy_addr_to_reg (addr);\n@@ -2705,7 +2705,7 @@ expand_block_move (rtx operands[])\n   rtx orig_src\t= operands[1];\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n-  int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n+  int constp\t= CONST_INT_P (bytes_rtx);\n   int align;\n   int bytes;\n   int offset;\n@@ -2718,7 +2718,7 @@ expand_block_move (rtx operands[])\n     return 0;\n \n   /* This must be a fixed size alignment */\n-  gcc_assert (GET_CODE (align_rtx) == CONST_INT);\n+  gcc_assert (CONST_INT_P (align_rtx));\n   align = INTVAL (align_rtx) * BITS_PER_UNIT;\n \n   /* Anything to move? */\n@@ -2762,15 +2762,15 @@ expand_block_move (rtx operands[])\n \t\t reload, not one per load and/or store.  */\n \t      addr = XEXP (orig_dest, 0);\n \t      if ((GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM)\n-\t\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t  && CONST_INT_P (XEXP (addr, 1))\n \t\t  && (INTVAL (XEXP (addr, 1)) & 3) != 0)\n \t\t{\n \t\t  addr = copy_addr_to_reg (addr);\n \t\t  orig_dest = replace_equiv_address (orig_dest, addr);\n \t\t}\n \t      addr = XEXP (orig_src, 0);\n \t      if ((GET_CODE (addr) == PLUS || GET_CODE (addr) == LO_SUM)\n-\t\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT\n+\t\t  && CONST_INT_P (XEXP (addr, 1))\n \t\t  && (INTVAL (XEXP (addr, 1)) & 3) != 0)\n \t\t{\n \t\t  addr = copy_addr_to_reg (addr);"}, {"sha": "401e7194887c6cb44cd5a1b79e82db99b0f7bda2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 158, "deletions": 175, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -2996,7 +2996,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   for (r = 32; r < 64; ++r)\n     rs6000_regno_regclass[r] = FLOAT_REGS;\n \n-  for (r = 64; r < FIRST_PSEUDO_REGISTER; ++r)\n+  for (r = 64; HARD_REGISTER_NUM_P (r); ++r)\n     rs6000_regno_regclass[r] = NO_REGS;\n \n   for (r = FIRST_ALTIVEC_REGNO; r <= LAST_ALTIVEC_REGNO; ++r)\n@@ -3460,13 +3460,13 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n     }\n \n   /* Precalculate HARD_REGNO_NREGS.  */\n-  for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n+  for (r = 0; HARD_REGISTER_NUM_P (r); ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n       rs6000_hard_regno_nregs[m][r]\n \t= rs6000_hard_regno_nregs_internal (r, (machine_mode)m);\n \n   /* Precalculate TARGET_HARD_REGNO_MODE_OK.  */\n-  for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n+  for (r = 0; HARD_REGISTER_NUM_P (r); ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n       if (rs6000_hard_regno_mode_ok_uncached (r, (machine_mode)m))\n \trs6000_hard_regno_mode_ok_p[m][r] = true;\n@@ -6198,8 +6198,8 @@ easy_altivec_constant (rtx op, machine_mode mode)\n \n   else if (mode == V2DImode)\n     {\n-      if (GET_CODE (CONST_VECTOR_ELT (op, 0)) != CONST_INT\n-\t  || GET_CODE (CONST_VECTOR_ELT (op, 1)) != CONST_INT)\n+      if (!CONST_INT_P (CONST_VECTOR_ELT (op, 0))\n+\t  || !CONST_INT_P (CONST_VECTOR_ELT (op, 1)))\n \treturn false;\n \n       if (zero_constant (op, mode))\n@@ -6985,18 +6985,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n }\n \n-/* Helper function to return the register number of a RTX.  */\n-static inline int\n-regno_or_subregno (rtx op)\n-{\n-  if (REG_P (op))\n-    return REGNO (op);\n-  else if (SUBREG_P (op))\n-    return subreg_regno (op);\n-  else\n-    gcc_unreachable ();\n-}\n-\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -7120,9 +7108,9 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n     {\n       rtx op1 = XEXP (new_addr, 1);\n       addr_mask_type addr_mask;\n-      int scalar_regno = regno_or_subregno (scalar_reg);\n+      unsigned int scalar_regno = reg_or_subregno (scalar_reg);\n \n-      gcc_assert (scalar_regno < FIRST_PSEUDO_REGISTER);\n+      gcc_assert (HARD_REGISTER_NUM_P (scalar_regno));\n       if (INT_REGNO_P (scalar_regno))\n \taddr_mask = reg_addr[scalar_mode].addr_mask[RELOAD_REG_GPR];\n \n@@ -7184,9 +7172,9 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n     {\n       int bit_shift = byte_shift + 3;\n       rtx element2;\n-      int dest_regno = regno_or_subregno (dest);\n-      int src_regno = regno_or_subregno (src);\n-      int element_regno = regno_or_subregno (element);\n+      unsigned int dest_regno = reg_or_subregno (dest);\n+      unsigned int src_regno = reg_or_subregno (src);\n+      unsigned int element_regno = reg_or_subregno (element);\n \n       gcc_assert (REG_P (tmp_gpr));\n \n@@ -7473,13 +7461,13 @@ small_data_operand (rtx op ATTRIBUTE_UNUSED,\n   if (DEFAULT_ABI != ABI_V4)\n     return 0;\n \n-  if (GET_CODE (op) == SYMBOL_REF)\n+  if (SYMBOL_REF_P (op))\n     sym_ref = op;\n \n   else if (GET_CODE (op) != CONST\n \t   || GET_CODE (XEXP (op, 0)) != PLUS\n-\t   || GET_CODE (XEXP (XEXP (op, 0), 0)) != SYMBOL_REF\n-\t   || GET_CODE (XEXP (XEXP (op, 0), 1)) != CONST_INT)\n+\t   || !SYMBOL_REF_P (XEXP (XEXP (op, 0), 0))\n+\t   || !CONST_INT_P (XEXP (XEXP (op, 0), 1)))\n     return 0;\n \n   else\n@@ -7527,7 +7515,7 @@ direct_move_p (rtx op0, rtx op1)\n \n   regno0 = REGNO (op0);\n   regno1 = REGNO (op1);\n-  if (regno0 >= FIRST_PSEUDO_REGISTER || regno1 >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_NUM_P (regno0) || !HARD_REGISTER_NUM_P (regno1))\n     return false;\n \n   if (INT_REGNO_P (regno0))\n@@ -7782,12 +7770,12 @@ virtual_stack_registers_memory_p (rtx op)\n {\n   int regnum;\n \n-  if (GET_CODE (op) == REG)\n+  if (REG_P (op))\n     regnum = REGNO (op);\n \n   else if (GET_CODE (op) == PLUS\n-\t   && GET_CODE (XEXP (op, 0)) == REG\n-\t   && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+\t   && REG_P (XEXP (op, 0))\n+\t   && CONST_INT_P (XEXP (op, 1)))\n     regnum = REGNO (XEXP (op, 0));\n \n   else\n@@ -7815,7 +7803,7 @@ offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n   tree decl;\n   unsigned HOST_WIDE_INT dsize, dalign, lsb, mask;\n \n-  if (GET_CODE (op) != SYMBOL_REF)\n+  if (!SYMBOL_REF_P (op))\n     return false;\n \n   /* ISA 3.0 vector d-form addressing is restricted, don't allow\n@@ -7897,7 +7885,7 @@ constant_pool_expr_p (rtx op)\n   rtx base, offset;\n \n   split_const (op, &base, &offset);\n-  return (GET_CODE (base) == SYMBOL_REF\n+  return (SYMBOL_REF_P (base)\n \t  && CONSTANT_POOL_ADDRESS_P (base)\n \t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (base), Pmode));\n }\n@@ -7976,7 +7964,7 @@ legitimate_small_data_p (machine_mode mode, rtx x)\n {\n   return (DEFAULT_ABI == ABI_V4\n \t  && !flag_pic && !TARGET_TOC\n-\t  && (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n+\t  && (SYMBOL_REF_P (x) || GET_CODE (x) == CONST)\n \t  && small_data_operand (x, mode));\n }\n \n@@ -7999,7 +7987,7 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n     return virtual_stack_registers_memory_p (x);\n   if (legitimate_constant_pool_address_p (x, mode, strict || lra_in_progress))\n     return true;\n-  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+  if (!CONST_INT_P (XEXP (x, 1)))\n     return false;\n \n   offset = INTVAL (XEXP (x, 1));\n@@ -8074,20 +8062,20 @@ avoiding_indexed_address_p (machine_mode mode)\n bool\n legitimate_indirect_address_p (rtx x, int strict)\n {\n-  return GET_CODE (x) == REG && INT_REG_OK_FOR_BASE_P (x, strict);\n+  return REG_P (x) && INT_REG_OK_FOR_BASE_P (x, strict);\n }\n \n bool\n macho_lo_sum_memory_operand (rtx x, machine_mode mode)\n {\n   if (!TARGET_MACHO || !flag_pic\n-      || mode != SImode || GET_CODE (x) != MEM)\n+      || mode != SImode || !MEM_P (x))\n     return false;\n   x = XEXP (x, 0);\n \n   if (GET_CODE (x) != LO_SUM)\n     return false;\n-  if (GET_CODE (XEXP (x, 0)) != REG)\n+  if (!REG_P (XEXP (x, 0)))\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 0))\n     return false;\n@@ -8101,7 +8089,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n {\n   if (GET_CODE (x) != LO_SUM)\n     return false;\n-  if (GET_CODE (XEXP (x, 0)) != REG)\n+  if (!REG_P (XEXP (x, 0)))\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n@@ -8191,7 +8179,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       else\n \treturn force_reg (Pmode, x);\n     }\n-  if (GET_CODE (x) == SYMBOL_REF)\n+  if (SYMBOL_REF_P (x))\n     {\n       enum tls_model model = SYMBOL_REF_TLS_MODEL (x);\n       if (model != 0)\n@@ -8219,8 +8207,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     }\n \n   if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && REG_P (XEXP (x, 0))\n+      && CONST_INT_P (XEXP (x, 1))\n       && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000)\n \t  >= 0x10000 - extra))\n     {\n@@ -8235,8 +8223,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return plus_constant (Pmode, sum, low_int);\n     }\n   else if (GET_CODE (x) == PLUS\n-\t   && GET_CODE (XEXP (x, 0)) == REG\n-\t   && GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t   && REG_P (XEXP (x, 0))\n+\t   && !CONST_INT_P (XEXP (x, 1))\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || (/* ??? Assume floating point reg based on mode?  */\n@@ -8253,10 +8241,10 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t    )\n \t   && TARGET_32BIT\n \t   && TARGET_NO_TOC\n-\t   && ! flag_pic\n-\t   && GET_CODE (x) != CONST_INT\n-\t   && GET_CODE (x) != CONST_WIDE_INT\n-\t   && GET_CODE (x) != CONST_DOUBLE\n+\t   && !flag_pic\n+\t   && !CONST_INT_P (x)\n+\t   && !CONST_WIDE_INT_P (x)\n+\t   && !CONST_DOUBLE_P (x)\n \t   && CONSTANT_P (x)\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n@@ -8271,7 +8259,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return gen_rtx_LO_SUM (Pmode, reg, x);\n     }\n   else if (TARGET_TOC\n-\t   && GET_CODE (x) == SYMBOL_REF\n+\t   && SYMBOL_REF_P (x)\n \t   && constant_pool_expr_p (x)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n     return create_TOC_reference (x, NULL_RTX);\n@@ -8350,7 +8338,7 @@ rs6000_output_dwarf_dtprel (FILE *file, int size, rtx x)\n   output_addr_const (file, x);\n   if (TARGET_ELF)\n     fputs (\"@dtprel+0x8000\", file);\n-  else if (TARGET_XCOFF && GET_CODE (x) == SYMBOL_REF)\n+  else if (TARGET_XCOFF && SYMBOL_REF_P (x))\n     {\n       switch (SYMBOL_REF_TLS_MODEL (x))\n \t{\n@@ -8378,7 +8366,7 @@ rs6000_output_dwarf_dtprel (FILE *file, int size, rtx x)\n static bool\n rs6000_real_tls_symbol_ref_p (rtx x)\n {\n-  return (GET_CODE (x) == SYMBOL_REF\n+  return (SYMBOL_REF_P (x)\n \t  && SYMBOL_REF_TLS_MODEL (x) >= TLS_MODEL_REAL);\n }\n \n@@ -8421,7 +8409,7 @@ rs6000_delegitimize_address (rtx orig_x)\n       /* Do not associate thread-local symbols with the original\n \t constant pool symbol.  */\n       if (TARGET_XCOFF\n-\t  && GET_CODE (y) == SYMBOL_REF\n+\t  && SYMBOL_REF_P (y)\n \t  && CONSTANT_POOL_ADDRESS_P (y)\n \t  && rs6000_real_tls_symbol_ref_p (get_pool_constant (y)))\n \treturn orig_x;\n@@ -8456,7 +8444,7 @@ rs6000_const_not_ok_for_debug_p (rtx x)\n {\n   if (GET_CODE (x) == UNSPEC)\n     return true;\n-  if (GET_CODE (x) == SYMBOL_REF\n+  if (SYMBOL_REF_P (x)\n       && CONSTANT_POOL_ADDRESS_P (x))\n     {\n       rtx c = get_pool_constant (x);\n@@ -8868,7 +8856,7 @@ rs6000_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n   /* A TLS symbol in the TOC cannot contain a sum.  */\n   if (GET_CODE (x) == CONST\n       && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+      && SYMBOL_REF_P (XEXP (XEXP (x, 0), 0))\n       && SYMBOL_REF_TLS_MODEL (XEXP (XEXP (x, 0), 0)) != 0)\n     return true;\n \n@@ -8927,9 +8915,9 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n   /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && REG_P (XEXP (XEXP (x, 0), 0))\n+      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+      && CONST_INT_P (XEXP (x, 1)))\n     {\n       if (TARGET_DEBUG_ADDR)\n \t{\n@@ -8999,7 +8987,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \n   if (GET_CODE (x) == PLUS\n       && REG_P (XEXP (x, 0))\n-      && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n+      && HARD_REGISTER_P (XEXP (x, 0))\n       && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n       && CONST_INT_P (XEXP (x, 1))\n       && reg_offset_p\n@@ -9039,7 +9027,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       return x;\n     }\n \n-  if (GET_CODE (x) == SYMBOL_REF\n+  if (SYMBOL_REF_P (x)\n       && reg_offset_p\n       && !quad_offset_p\n       && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode))\n@@ -9113,9 +9101,9 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n   if (VECTOR_MEM_ALTIVEC_P (mode)\n       && GET_CODE (x) == AND\n       && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && REG_P (XEXP (XEXP (x, 0), 0))\n+      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+      && CONST_INT_P (XEXP (x, 1))\n       && INTVAL (XEXP (x, 1)) == -16)\n     {\n       x = XEXP (x, 0);\n@@ -9126,7 +9114,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n   if (TARGET_TOC\n       && reg_offset_p\n       && !quad_offset_p\n-      && GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_P (x)\n       && use_toc_relative_ref (x, mode))\n     {\n       x = create_TOC_reference (x, NULL_RTX);\n@@ -9201,7 +9189,7 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n   /* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */\n   if (VECTOR_MEM_ALTIVEC_P (mode)\n       && GET_CODE (x) == AND\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && INTVAL (XEXP (x, 1)) == -16)\n     x = XEXP (x, 0);\n \n@@ -9247,10 +9235,10 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n   if (! reg_ok_strict\n       && reg_offset_p\n       && GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == REG\n+      && REG_P (XEXP (x, 0))\n       && (XEXP (x, 0) == virtual_stack_vars_rtx\n \t  || XEXP (x, 0) == arg_pointer_rtx)\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      && CONST_INT_P (XEXP (x, 1)))\n     return 1;\n   if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict, false))\n     return 1;\n@@ -9332,7 +9320,7 @@ rs6000_mode_dependent_address (const_rtx addr)\n \t been rejected as illegitimate.  */\n       if (XEXP (addr, 0) != virtual_stack_vars_rtx\n \t  && XEXP (addr, 0) != arg_pointer_rtx\n-\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (addr, 1)))\n \t{\n \t  unsigned HOST_WIDE_INT val = INTVAL (XEXP (addr, 1));\n \t  return val + 0x8000 >= 0x10000 - (TARGET_POWERPC64 ? 8 : 12);\n@@ -9693,16 +9681,16 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c)\n static void\n rs6000_eliminate_indexed_memrefs (rtx operands[2])\n {\n-  if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (XEXP (operands[0], 0)) != REG\n+  if (MEM_P (operands[0])\n+      && !REG_P (XEXP (operands[0], 0))\n       && ! legitimate_constant_pool_address_p (XEXP (operands[0], 0),\n \t\t\t\t\t       GET_MODE (operands[0]), false))\n     operands[0]\n       = replace_equiv_address (operands[0],\n \t\t\t       copy_addr_to_reg (XEXP (operands[0], 0)));\n \n-  if (GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) != REG\n+  if (MEM_P (operands[1])\n+      && !REG_P (XEXP (operands[1], 0))\n       && ! legitimate_constant_pool_address_p (XEXP (operands[1], 0),\n \t\t\t\t\t       GET_MODE (operands[1]), false))\n     operands[1]\n@@ -9840,7 +9828,7 @@ rs6000_emit_le_vsx_move (rtx dest, rtx source, machine_mode mode)\n \n   if (MEM_P (source))\n     {\n-      gcc_assert (REG_P (dest) || GET_CODE (dest) == SUBREG);\n+      gcc_assert (REG_P (dest) || SUBREG_P (dest));\n       rs6000_emit_le_vsx_load (dest, source, mode);\n     }\n   else\n@@ -9973,8 +9961,8 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \n   /* Check if GCC is setting up a block move that will end up using FP\n      registers as temporaries.  We must make sure this is acceptable.  */\n-  if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM\n+  if (MEM_P (operands[0])\n+      && MEM_P (operands[1])\n       && mode == DImode\n       && (rs6000_slow_unaligned_access (DImode, MEM_ALIGN (operands[0]))\n \t  || rs6000_slow_unaligned_access (DImode, MEM_ALIGN (operands[1])))\n@@ -9994,7 +9982,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       return;\n     }\n \n-  if (can_create_pseudo_p () && GET_CODE (operands[0]) == MEM\n+  if (can_create_pseudo_p () && MEM_P (operands[0])\n       && !gpc_reg_operand (operands[1], mode))\n     operands[1] = force_reg (mode, operands[1]);\n \n@@ -10012,7 +10000,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t  tmp = XEXP (XEXP (tmp, 0), 0);\n \t}\n \n-      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);\n+      gcc_assert (SYMBOL_REF_P (tmp));\n       model = SYMBOL_REF_TLS_MODEL (tmp);\n       gcc_assert (model != 0);\n \n@@ -10046,15 +10034,15 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n      p1:SD) if p1 is not of floating point class and p0 is spilled as\n      we can have no analogous movsd_store for this.  */\n   if (lra_in_progress && mode == DDmode\n-      && REG_P (operands[0]) && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER\n+      && REG_P (operands[0]) && !HARD_REGISTER_P (operands[0])\n       && reg_preferred_class (REGNO (operands[0])) == NO_REGS\n-      && GET_CODE (operands[1]) == SUBREG && REG_P (SUBREG_REG (operands[1]))\n+      && SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))\n       && GET_MODE (SUBREG_REG (operands[1])) == SDmode)\n     {\n       enum reg_class cl;\n       int regno = REGNO (SUBREG_REG (operands[1]));\n \n-      if (regno >= FIRST_PSEUDO_REGISTER)\n+      if (!HARD_REGISTER_NUM_P (regno))\n \t{\n \t  cl = reg_preferred_class (regno);\n \t  regno = reg_renumber[regno];\n@@ -10070,17 +10058,15 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n     }\n   if (lra_in_progress\n       && mode == SDmode\n-      && REG_P (operands[0]) && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER\n+      && REG_P (operands[0]) && !HARD_REGISTER_P (operands[0])\n       && reg_preferred_class (REGNO (operands[0])) == NO_REGS\n       && (REG_P (operands[1])\n-\t  || (GET_CODE (operands[1]) == SUBREG\n-\t      && REG_P (SUBREG_REG (operands[1])))))\n+\t  || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1])))))\n     {\n-      int regno = REGNO (GET_CODE (operands[1]) == SUBREG\n-\t\t\t ? SUBREG_REG (operands[1]) : operands[1]);\n+      int regno = reg_or_subregno (operands[1]);\n       enum reg_class cl;\n \n-      if (regno >= FIRST_PSEUDO_REGISTER)\n+      if (!HARD_REGISTER_NUM_P (regno))\n \t{\n \t  cl = reg_preferred_class (regno);\n \t  gcc_assert (cl != NO_REGS);\n@@ -10104,15 +10090,15 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n      p:DD)) if p0 is not of floating point class and p1 is spilled as\n      we can have no analogous movsd_load for this.  */\n   if (lra_in_progress && mode == DDmode\n-      && GET_CODE (operands[0]) == SUBREG && REG_P (SUBREG_REG (operands[0]))\n+      && SUBREG_P (operands[0]) && REG_P (SUBREG_REG (operands[0]))\n       && GET_MODE (SUBREG_REG (operands[0])) == SDmode\n-      && REG_P (operands[1]) && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER\n+      && REG_P (operands[1]) && !HARD_REGISTER_P (operands[1])\n       && reg_preferred_class (REGNO (operands[1])) == NO_REGS)\n     {\n       enum reg_class cl;\n       int regno = REGNO (SUBREG_REG (operands[0]));\n \n-      if (regno >= FIRST_PSEUDO_REGISTER)\n+      if (!HARD_REGISTER_NUM_P (regno))\n \t{\n \t  cl = reg_preferred_class (regno);\n \t  regno = reg_renumber[regno];\n@@ -10129,16 +10115,14 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n   if (lra_in_progress\n       && mode == SDmode\n       && (REG_P (operands[0])\n-\t  || (GET_CODE (operands[0]) == SUBREG\n-\t      && REG_P (SUBREG_REG (operands[0]))))\n-      && REG_P (operands[1]) && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER\n+\t  || (SUBREG_P (operands[0]) && REG_P (SUBREG_REG (operands[0]))))\n+      && REG_P (operands[1]) && !HARD_REGISTER_P (operands[1])\n       && reg_preferred_class (REGNO (operands[1])) == NO_REGS)\n     {\n-      int regno = REGNO (GET_CODE (operands[0]) == SUBREG\n-\t\t\t ? SUBREG_REG (operands[0]) : operands[0]);\n+      int regno = reg_or_subregno (operands[0]);\n       enum reg_class cl;\n \n-      if (regno >= FIRST_PSEUDO_REGISTER)\n+      if (!HARD_REGISTER_NUM_P (regno))\n \t{\n \t  cl = reg_preferred_class (regno);\n \t  gcc_assert (cl != NO_REGS);\n@@ -10167,7 +10151,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n     case E_HImode:\n     case E_QImode:\n       if (CONSTANT_P (operands[1])\n-\t  && GET_CODE (operands[1]) != CONST_INT)\n+\t  && !CONST_INT_P (operands[1]))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n@@ -10206,7 +10190,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       if (TARGET_ELF\n \t  && mode == Pmode\n \t  && DEFAULT_ABI == ABI_V4\n-\t  && (GET_CODE (operands[1]) == SYMBOL_REF\n+\t  && (SYMBOL_REF_P (operands[1])\n \t      || GET_CODE (operands[1]) == CONST)\n \t  && small_data_operand (operands[1], mode))\n \t{\n@@ -10228,7 +10212,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t  && mode == Pmode\n \t  && CONSTANT_P (operands[1])\n \t  && GET_CODE (operands[1]) != HIGH\n-\t  && GET_CODE (operands[1]) != CONST_INT)\n+\t  && !CONST_INT_P (operands[1]))\n \t{\n \t  rtx target = (!can_create_pseudo_p ()\n \t\t\t? operands[0]\n@@ -10237,7 +10221,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t  /* If this is a function address on -mcall-aixdesc,\n \t     convert it to the address of the descriptor.  */\n \t  if (DEFAULT_ABI == ABI_AIX\n-\t      && GET_CODE (operands[1]) == SYMBOL_REF\n+\t      && SYMBOL_REF_P (operands[1])\n \t      && XSTR (operands[1], 0)[0] == '.')\n \t    {\n \t      const char *name = XSTR (operands[1], 0);\n@@ -10280,7 +10264,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t and we have put it in the TOC, we just need to make a TOC-relative\n \t reference to it.  */\n       if (TARGET_TOC\n-\t  && GET_CODE (operands[1]) == SYMBOL_REF\n+\t  && SYMBOL_REF_P (operands[1])\n \t  && use_toc_relative_ref (operands[1], mode))\n \toperands[1] = create_TOC_reference (operands[1], operands[0]);\n       else if (mode == Pmode\n@@ -10319,7 +10303,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n \t      && add_operand (XEXP (XEXP (operands[1], 0), 1), mode)\n \t      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n-\t\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n+\t\t  || SYMBOL_REF_P (XEXP (XEXP (operands[1], 0), 0)))\n \t      && ! side_effects_p (operands[0]))\n \t    {\n \t      rtx sym =\n@@ -10334,7 +10318,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t  operands[1] = force_const_mem (mode, operands[1]);\n \n \t  if (TARGET_TOC\n-\t      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+\t      && SYMBOL_REF_P (XEXP (operands[1], 0))\n \t      && use_toc_relative_ref (XEXP (operands[1], 0), mode))\n \t    {\n \t      rtx tocref = create_TOC_reference (XEXP (operands[1], 0),\n@@ -10361,7 +10345,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n   /* Above, we may have called force_const_mem which may have returned\n      an invalid address.  If we can, fix this up; otherwise, reload will\n      have to deal with it.  */\n-  if (GET_CODE (operands[1]) == MEM)\n+  if (MEM_P (operands[1]))\n     operands[1] = validize_mem (operands[1]);\n \n   emit_insn (gen_rtx_SET (operands[0], operands[1]));\n@@ -12533,13 +12517,13 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t    {\n \t      rtx reg_save_area\n \t\t= assign_stack_local (BLKmode, gpr_size + fpr_size, 64);\n-\t      gcc_assert (GET_CODE (reg_save_area) == MEM);\n+\t      gcc_assert (MEM_P (reg_save_area));\n \t      reg_save_area = XEXP (reg_save_area, 0);\n \t      if (GET_CODE (reg_save_area) == PLUS)\n \t\t{\n \t\t  gcc_assert (XEXP (reg_save_area, 0)\n \t\t\t      == virtual_stack_vars_rtx);\n-\t\t  gcc_assert (GET_CODE (XEXP (reg_save_area, 1)) == CONST_INT);\n+\t\t  gcc_assert (CONST_INT_P (XEXP (reg_save_area, 1)));\n \t\t  offset += INTVAL (XEXP (reg_save_area, 1));\n \t\t}\n \t      else\n@@ -13396,7 +13380,7 @@ rs6000_expand_mtfsf_builtin (enum insn_code icode, tree exp)\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n     return const0_rtx;\n \n-  if (GET_CODE (op0) != CONST_INT\n+  if (!CONST_INT_P (op0)\n       || INTVAL (op0) > 255\n       || INTVAL (op0) < 0)\n     {\n@@ -13481,7 +13465,7 @@ rs6000_expand_set_fpscr_rn_builtin (enum insn_code icode, tree exp)\n      compile time if the argument is a variable.  The least significant two\n      bits of the argument, regardless of type, are used to set the rounding\n      mode.  All other bits are ignored.  */\n-  if (GET_CODE (op0) == CONST_INT && !const_0_to_3_operand(op0, VOIDmode))\n+  if (CONST_INT_P (op0) && !const_0_to_3_operand(op0, VOIDmode))\n     {\n       error (\"Argument must be a value between 0 and 3.\");\n       return const0_rtx;\n@@ -13529,7 +13513,7 @@ rs6000_expand_set_fpscr_drn_builtin (enum insn_code icode, tree exp)\n      compile time if the argument is a variable. The least significant two\n      bits of the argument, regardless of type, are used to set the rounding\n      mode.  All other bits are ignored.  */\n-  if (GET_CODE (op0) == CONST_INT && !const_0_to_7_operand(op0, VOIDmode))\n+  if (CONST_INT_P (op0) && !const_0_to_7_operand(op0, VOIDmode))\n    {\n       error (\"Argument must be a value between 0 and 7.\");\n       return const0_rtx;\n@@ -13568,7 +13552,7 @@ rs6000_expand_unop_builtin (enum insn_code icode, tree exp, rtx target)\n       || icode == CODE_FOR_altivec_vspltisw)\n     {\n       /* Only allow 5-bit *signed* literals.  */\n-      if (GET_CODE (op0) != CONST_INT\n+      if (!CONST_INT_P (op0)\n \t  || INTVAL (op0) > 15\n \t  || INTVAL (op0) < -16)\n \t{\n@@ -18869,7 +18853,7 @@ int\n registers_ok_for_quad_peep (rtx reg1, rtx reg2)\n {\n   /* We might have been passed a SUBREG.  */\n-  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG)\n+  if (!REG_P (reg1) || !REG_P (reg2))\n     return 0;\n \n   /* We might have been passed non floating point registers.  */\n@@ -18902,18 +18886,18 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n   if (GET_CODE (addr1) == PLUS)\n     {\n       /* If not a REG, return zero.  */\n-      if (GET_CODE (XEXP (addr1, 0)) != REG)\n+      if (!REG_P (XEXP (addr1, 0)))\n \treturn 0;\n       else\n \t{\n \t  reg1 = REGNO (XEXP (addr1, 0));\n \t  /* The offset must be constant!  */\n-\t  if (GET_CODE (XEXP (addr1, 1)) != CONST_INT)\n+\t  if (!CONST_INT_P (XEXP (addr1, 1)))\n \t    return 0;\n \t  offset1 = INTVAL (XEXP (addr1, 1));\n \t}\n     }\n-  else if (GET_CODE (addr1) != REG)\n+  else if (!REG_P (addr1))\n     return 0;\n   else\n     {\n@@ -18926,18 +18910,18 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n   if (GET_CODE (addr2) == PLUS)\n     {\n       /* If not a REG, return zero.  */\n-      if (GET_CODE (XEXP (addr2, 0)) != REG)\n+      if (!REG_P (XEXP (addr2, 0)))\n \treturn 0;\n       else\n \t{\n \t  reg2 = REGNO (XEXP (addr2, 0));\n \t  /* The offset must be constant. */\n-\t  if (GET_CODE (XEXP (addr2, 1)) != CONST_INT)\n+\t  if (!CONST_INT_P (XEXP (addr2, 1)))\n \t    return 0;\n \t  offset2 = INTVAL (XEXP (addr2, 1));\n \t}\n     }\n-  else if (GET_CODE (addr2) != REG)\n+  else if (!REG_P (addr2))\n     return 0;\n   else\n     {\n@@ -18980,20 +18964,20 @@ register_to_reg_type (rtx reg, bool *is_altivec)\n   HOST_WIDE_INT regno;\n   enum reg_class rclass;\n \n-  if (GET_CODE (reg) == SUBREG)\n+  if (SUBREG_P (reg))\n     reg = SUBREG_REG (reg);\n \n   if (!REG_P (reg))\n     return NO_REG_TYPE;\n \n   regno = REGNO (reg);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n+  if (!HARD_REGISTER_NUM_P (regno))\n     {\n       if (!lra_in_progress && !reload_completed)\n \treturn PSEUDO_REG_TYPE;\n \n       regno = true_regnum (reg);\n-      if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER)\n+      if (regno < 0 || !HARD_REGISTER_NUM_P (regno))\n \treturn PSEUDO_REG_TYPE;\n     }\n \n@@ -19129,7 +19113,7 @@ rs6000_secondary_reload_memory (rtx addr,\n     case AND:\n       and_arg = XEXP (addr, 0);\n       if (GET_MODE_SIZE (mode) != 16\n-\t  || GET_CODE (XEXP (addr, 1)) != CONST_INT\n+\t  || !CONST_INT_P (XEXP (addr, 1))\n \t  || INTVAL (XEXP (addr, 1)) != -16)\n \t{\n \t  fail_msg = \"bad Altivec AND #1\";\n@@ -19541,7 +19525,7 @@ rs6000_secondary_reload (bool in_p,\n \n   /* Allow subreg of memory before/during reload.  */\n   bool memory_p = (MEM_P (x)\n-\t\t   || (!reload_completed && GET_CODE (x) == SUBREG\n+\t\t   || (!reload_completed && SUBREG_P (x)\n \t\t       && MEM_P (SUBREG_REG (x))));\n \n   sri->icode = CODE_FOR_nothing;\n@@ -19586,7 +19570,7 @@ rs6000_secondary_reload (bool in_p,\n   if (!done_p && reg_addr[mode].scalar_in_vmx_p\n       && !mode_supports_vmx_dform (mode)\n       && (rclass == VSX_REGS || rclass == ALTIVEC_REGS)\n-      && (memory_p || (GET_CODE (x) == CONST_DOUBLE)))\n+      && (memory_p || CONST_DOUBLE_P (x)))\n     {\n       ret = FLOAT_REGS;\n       default_p = false;\n@@ -19801,7 +19785,7 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n   rtx cc_clobber;\n   rtvec rv;\n \n-  if (regno < 0 || regno >= FIRST_PSEUDO_REGISTER || !MEM_P (mem)\n+  if (regno < 0 || !HARD_REGISTER_NUM_P (regno) || !MEM_P (mem)\n       || !base_reg_operand (scratch, GET_MODE (scratch)))\n     rs6000_secondary_reload_fail (__LINE__, reg, mem, scratch, store_p);\n \n@@ -19868,7 +19852,7 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n       op1 = XEXP (addr, 1);\n       if ((addr_mask & RELOAD_REG_AND_M16) == 0)\n \t{\n-\t  if (REG_P (op0) || GET_CODE (op0) == SUBREG)\n+\t  if (REG_P (op0) || SUBREG_P (op0))\n \t    op_reg = op0;\n \n \t  else if (GET_CODE (op1) == PLUS)\n@@ -20029,8 +20013,8 @@ rs6000_secondary_reload_gpr (rtx reg, rtx mem, rtx scratch, bool store_p)\n       debug_rtx (scratch);\n     }\n \n-  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n-  gcc_assert (GET_CODE (mem) == MEM);\n+  gcc_assert (regno >= 0 && HARD_REGISTER_NUM_P (regno));\n+  gcc_assert (MEM_P (mem));\n   rclass = REGNO_REG_CLASS (regno);\n   gcc_assert (rclass == GENERAL_REGS || rclass == BASE_REGS);\n   addr = XEXP (mem, 0);\n@@ -20265,27 +20249,27 @@ rs6000_secondary_reload_class (enum reg_class rclass, machine_mode mode,\n \t On Darwin, pic addresses require a load from memory, which\n \t needs a base register.  */\n       if (rclass != BASE_REGS\n-\t  && (GET_CODE (in) == SYMBOL_REF\n+\t  && (SYMBOL_REF_P (in)\n \t      || GET_CODE (in) == HIGH\n \t      || GET_CODE (in) == LABEL_REF\n \t      || GET_CODE (in) == CONST))\n \treturn BASE_REGS;\n     }\n \n-  if (GET_CODE (in) == REG)\n+  if (REG_P (in))\n     {\n       regno = REGNO (in);\n-      if (regno >= FIRST_PSEUDO_REGISTER)\n+      if (!HARD_REGISTER_NUM_P (regno))\n \t{\n \t  regno = true_regnum (in);\n-\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t  if (!HARD_REGISTER_NUM_P (regno))\n \t    regno = -1;\n \t}\n     }\n-  else if (GET_CODE (in) == SUBREG)\n+  else if (SUBREG_P (in))\n     {\n       regno = true_regnum (in);\n-      if (regno >= FIRST_PSEUDO_REGISTER)\n+      if (!HARD_REGISTER_NUM_P (regno))\n \tregno = -1;\n     }\n   else\n@@ -20604,9 +20588,9 @@ rs6000_output_move_128bit (rtx operands[])\n \n   /* Constants.  */\n   else if (dest_regno >= 0\n-\t   && (GET_CODE (src) == CONST_INT\n-\t       || GET_CODE (src) == CONST_WIDE_INT\n-\t       || GET_CODE (src) == CONST_DOUBLE\n+\t   && (CONST_INT_P (src)\n+\t       || CONST_WIDE_INT_P (src)\n+\t       || CONST_DOUBLE_P (src)\n \t       || GET_CODE (src) == CONST_VECTOR))\n     {\n       if (dest_gpr_p)\n@@ -20750,7 +20734,7 @@ rs6000_init_machine_status (void)\n   return ggc_cleared_alloc<machine_function> ();\n }\n \f\n-#define INT_P(X) (GET_CODE (X) == CONST_INT && GET_MODE (X) == VOIDmode)\n+#define INT_P(X) (CONST_INT_P (X) && GET_MODE (X) == VOIDmode)\n \n /* Write out a function code label.  */\n \n@@ -20864,7 +20848,7 @@ print_operand (FILE *file, rtx x, int code)\n     case 'G':\n       /* X is a constant integer.  If it is negative, print \"m\",\n \t otherwise print \"z\".  This is to make an aze or ame insn.  */\n-      if (GET_CODE (x) != CONST_INT)\n+      if (!CONST_INT_P (x))\n \toutput_operand_lossage (\"invalid %%G value\");\n       else if (INTVAL (x) >= 0)\n \tputc ('z', file);\n@@ -20932,9 +20916,9 @@ print_operand (FILE *file, rtx x, int code)\n       if (GET_CODE (x) == CONST)\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) != PLUS\n-\t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) != SYMBOL_REF\n+\t      || (!SYMBOL_REF_P (XEXP (XEXP (x, 0), 0))\n \t\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) != LABEL_REF)\n-\t      || GET_CODE (XEXP (XEXP (x, 0), 1)) != CONST_INT)\n+\t      || !CONST_INT_P (XEXP (XEXP (x, 0), 1)))\n \t    output_operand_lossage (\"invalid %%K value\");\n \t}\n       print_operand_address (file, x);\n@@ -21000,7 +20984,7 @@ print_operand (FILE *file, rtx x, int code)\n     case 'P':\n       /* The operand must be an indirect memory reference.  The result\n \t is the register name.  */\n-      if (GET_CODE (x) != MEM || GET_CODE (XEXP (x, 0)) != REG\n+      if (!MEM_P (x) || !REG_P (XEXP (x, 0))\n \t  || REGNO (XEXP (x, 0)) >= 32)\n \toutput_operand_lossage (\"invalid %%P value\");\n       else\n@@ -21086,8 +21070,8 @@ print_operand (FILE *file, rtx x, int code)\n       /* Print the symbolic name of a branch target register.  */\n       if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_PLTSEQ)\n \tx = XVECEXP (x, 0, 0);\n-      if (GET_CODE (x) != REG || (REGNO (x) != LR_REGNO\n-\t\t\t\t  && REGNO (x) != CTR_REGNO))\n+      if (!REG_P (x) || (REGNO (x) != LR_REGNO\n+\t\t\t && REGNO (x) != CTR_REGNO))\n \toutput_operand_lossage (\"invalid %%T value\");\n       else if (REGNO (x) == LR_REGNO)\n \tfputs (\"lr\", file);\n@@ -21180,7 +21164,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'x':\n       /* X is a FPR or Altivec register used in a VSX context.  */\n-      if (GET_CODE (x) != REG || !VSX_REGNO_P (REGNO (x)))\n+      if (!REG_P (x) || !VSX_REGNO_P (REGNO (x)))\n \toutput_operand_lossage (\"invalid %%x value\");\n       else\n \t{\n@@ -21293,7 +21277,7 @@ print_operand (FILE *file, rtx x, int code)\n \n \tif (VECTOR_MEM_ALTIVEC_OR_VSX_P (GET_MODE (x))\n \t    && GET_CODE (tmp) == AND\n-\t    && GET_CODE (XEXP (tmp, 1)) == CONST_INT\n+\t    && CONST_INT_P (XEXP (tmp, 1))\n \t    && INTVAL (XEXP (tmp, 1)) == -16)\n \t  tmp = XEXP (tmp, 0);\n \telse if (VECTOR_MEM_VSX_P (GET_MODE (x))\n@@ -21376,7 +21360,7 @@ print_operand_address (FILE *file, rtx x)\n {\n   if (REG_P (x))\n     fprintf (file, \"0(%s)\", reg_names[ REGNO (x) ]);\n-  else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST\n+  else if (SYMBOL_REF_P (x) || GET_CODE (x) == CONST\n \t   || GET_CODE (x) == LABEL_REF)\n     {\n       output_addr_const (file, x);\n@@ -21397,7 +21381,7 @@ print_operand_address (FILE *file, rtx x)\n \t\t reg_names[ REGNO (XEXP (x, 1)) ]);\n     }\n   else if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 0))\n-\t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t   && CONST_INT_P (XEXP (x, 1)))\n     fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%s)\",\n \t     INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n #if TARGET_MACHO\n@@ -21445,7 +21429,7 @@ rs6000_output_addr_const_extra (FILE *file, rtx x)\n     switch (XINT (x, 1))\n       {\n       case UNSPEC_TOCREL:\n-\tgcc_checking_assert (GET_CODE (XVECEXP (x, 0, 0)) == SYMBOL_REF\n+\tgcc_checking_assert (SYMBOL_REF_P (XVECEXP (x, 0, 0))\n \t\t\t     && REG_P (XVECEXP (x, 0, 1))\n \t\t\t     && REGNO (XVECEXP (x, 0, 1)) == TOC_REGISTER);\n \toutput_addr_const (file, XVECEXP (x, 0, 0));\n@@ -21522,7 +21506,7 @@ rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       /* Remove initial .'s to turn a -mcall-aixdesc function\n \t address into the address of the descriptor, not the function\n \t itself.  */\n-      else if (GET_CODE (x) == SYMBOL_REF\n+      else if (SYMBOL_REF_P (x)\n \t       && XSTR (x, 0)[0] == '.'\n \t       && DEFAULT_ABI == ABI_AIX)\n \t{\n@@ -21874,7 +21858,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \n   /* If we have an unsigned compare, make sure we don't have a signed value as\n      an immediate.  */\n-  if (comp_mode == CCUNSmode && GET_CODE (op1) == CONST_INT\n+  if (comp_mode == CCUNSmode && CONST_INT_P (op1)\n       && INTVAL (op1) < 0)\n     {\n       op0 = copy_rtx_if_shared (op0);\n@@ -23021,7 +23005,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n      would treat EQ different to UNORDERED, we can't do it.  */\n   if (HONOR_INFINITIES (compare_mode)\n       && code != GT && code != UNGE\n-      && (GET_CODE (op1) != CONST_DOUBLE\n+      && (!CONST_DOUBLE_P (op1)\n \t  || real_isinf (CONST_DOUBLE_REAL_VALUE (op1)))\n       /* Constructs of the form (a OP b ? a : b) are safe.  */\n       && ((! rtx_equal_p (op0, false_cond) && ! rtx_equal_p (op1, false_cond))\n@@ -25278,7 +25262,7 @@ create_TOC_reference (rtx symbol, rtx largetoc_reg)\n \n   if (TARGET_DEBUG_ADDR)\n     {\n-      if (GET_CODE (symbol) == SYMBOL_REF)\n+      if (SYMBOL_REF_P (symbol))\n \tfprintf (stderr, \"\\ncreate_TOC_reference, (symbol_ref %s)\\n\",\n \t\t XSTR (symbol, 0));\n       else\n@@ -25590,7 +25574,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)\n \t  emit_insn (insn);\n \t  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg, const0_rtx));\n \t}\n-      else if (GET_CODE (stack_limit_rtx) == SYMBOL_REF\n+      else if (SYMBOL_REF_P (stack_limit_rtx)\n \t       && TARGET_32BIT\n \t       && DEFAULT_ABI == ABI_V4\n \t       && !flag_pic)\n@@ -26396,8 +26380,7 @@ split_stack_arg_pointer_used_p (void)\n      then the arg pointer is used.  */\n   if (cfun->machine->split_stack_arg_pointer != NULL_RTX\n       && (!REG_P (cfun->machine->split_stack_arg_pointer)\n-\t  || (REGNO (cfun->machine->split_stack_arg_pointer)\n-\t      < FIRST_PSEUDO_REGISTER)))\n+\t  || HARD_REGISTER_P (cfun->machine->split_stack_arg_pointer)))\n     return true;\n \n   /* Unfortunately we also need to do some code scanning, since\n@@ -29095,7 +29078,7 @@ rs6000_output_function_epilogue (FILE *file)\n \t      rtx parameter = DECL_INCOMING_RTL (decl);\n \t      machine_mode mode = GET_MODE (parameter);\n \n-\t      if (GET_CODE (parameter) == REG)\n+\t      if (REG_P (parameter))\n \t\t{\n \t\t  if (SCALAR_FLOAT_MODE_P (mode))\n \t\t    {\n@@ -29755,7 +29738,7 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n \t  fprintf (file, \"%d\\n\", ((*found)->labelno));\n \n #ifdef HAVE_AS_TLS\n-\t  if (TARGET_XCOFF && GET_CODE (x) == SYMBOL_REF\n+\t  if (TARGET_XCOFF && SYMBOL_REF_P (x)\n \t      && (SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_GLOBAL_DYNAMIC\n \t\t  || SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC))\n \t    {\n@@ -29890,7 +29873,7 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n \t  return;\n \t}\n     }\n-  else if (GET_MODE (x) == VOIDmode && GET_CODE (x) == CONST_INT)\n+  else if (GET_MODE (x) == VOIDmode && CONST_INT_P (x))\n     {\n       unsigned HOST_WIDE_INT low;\n       HOST_WIDE_INT high;\n@@ -29956,7 +29939,7 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n   if (GET_CODE (x) == CONST)\n     {\n       gcc_assert (GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT);\n+\t\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1)));\n \n       base = XEXP (XEXP (x, 0), 0);\n       offset = INTVAL (XEXP (XEXP (x, 0), 1));\n@@ -30018,7 +30001,7 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n     output_addr_const (file, x);\n \n #if HAVE_AS_TLS\n-  if (TARGET_XCOFF && GET_CODE (base) == SYMBOL_REF)\n+  if (TARGET_XCOFF && SYMBOL_REF_P (base))\n     {\n       switch (SYMBOL_REF_TLS_MODEL (base))\n \t{\n@@ -30430,8 +30413,8 @@ rs6000_adjust_cost (rtx_insn *insn, int dep_type, rtx_insn *dep_insn, int cost,\n \tif ((rs6000_sched_groups || rs6000_tune == PROCESSOR_POWER9)\n \t    && GET_CODE (PATTERN (insn)) == SET\n \t    && GET_CODE (PATTERN (dep_insn)) == SET\n-\t    && GET_CODE (XEXP (PATTERN (insn), 1)) == MEM\n-\t    && GET_CODE (XEXP (PATTERN (dep_insn), 0)) == MEM\n+\t    && MEM_P (XEXP (PATTERN (insn), 1))\n+\t    && MEM_P (XEXP (PATTERN (dep_insn), 0))\n \t    && (GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (insn), 1)))\n \t\t> GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (dep_insn), 0)))))\n \t  return cost + 14;\n@@ -31104,7 +31087,7 @@ find_mem_ref (rtx pat, rtx *mem_ref)\n   if (tie_operand (pat, VOIDmode))\n     return false;\n \n-  if (GET_CODE (pat) == MEM)\n+  if (MEM_P (pat))\n     {\n       *mem_ref = pat;\n       return true;\n@@ -33070,10 +33053,10 @@ find_addr_reg (rtx addr)\n {\n   while (GET_CODE (addr) == PLUS)\n     {\n-      if (GET_CODE (XEXP (addr, 0)) == REG\n+      if (REG_P (XEXP (addr, 0))\n \t  && REGNO (XEXP (addr, 0)) != 0)\n \taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG\n+      else if (REG_P (XEXP (addr, 1))\n \t       && REGNO (XEXP (addr, 1)) != 0)\n \taddr = XEXP (addr, 1);\n       else if (CONSTANT_P (XEXP (addr, 0)))\n@@ -33083,7 +33066,7 @@ find_addr_reg (rtx addr)\n       else\n \tgcc_unreachable ();\n     }\n-  gcc_assert (GET_CODE (addr) == REG && REGNO (addr) != 0);\n+  gcc_assert (REG_P (addr) && REGNO (addr) != 0);\n   return addr;\n }\n \n@@ -33346,7 +33329,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, machine_mode mode,\n \trs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 1),\n \t\t\t\t\t\tPmode, reg);\n \n-      if (GET_CODE (offset) == CONST_INT)\n+      if (CONST_INT_P (offset))\n \t{\n \t  if (SMALL_INT (offset))\n \t    return plus_constant (Pmode, base, INTVAL (offset));\n@@ -34271,7 +34254,7 @@ rs6000_xcoff_encode_section_info (tree decl, rtx rtl, int first)\n   if (!MEM_P (rtl))\n     return;\n   symbol = XEXP (rtl, 0);\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n+  if (!SYMBOL_REF_P (symbol))\n     return;\n \n   flags = SYMBOL_REF_FLAGS (symbol);\n@@ -34451,7 +34434,7 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       return false;\n \n     case MULT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && satisfies_constraint_I (XEXP (x, 1)))\n \t{\n \t  if (INTVAL (XEXP (x, 1)) >= -256\n@@ -34489,7 +34472,7 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \n     case UDIV:\n     case UMOD:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+      if (CONST_INT_P (XEXP (x, 1))\n \t  && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t{\n \t  if (code == DIV || code == MOD)\n@@ -34622,7 +34605,7 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      if (GET_CODE (XEXP (x, 0)) == MEM)\n+      if (MEM_P (XEXP (x, 0)))\n \t*total = 0;\n       else\n \t*total = COSTS_N_INSNS (1);\n@@ -35660,16 +35643,16 @@ altivec_expand_vec_perm_const (rtx target, rtx op0, rtx op1,\n \t     numbering) are what we need.  */\n \t  if (!BYTES_BIG_ENDIAN\n \t      && icode == CODE_FOR_altivec_vpkuwum_direct\n-\t      && ((GET_CODE (op0) == REG\n+\t      && ((REG_P (op0)\n \t\t   && GET_MODE (op0) != V4SImode)\n-\t\t  || (GET_CODE (op0) == SUBREG\n+\t\t  || (SUBREG_P (op0)\n \t\t      && GET_MODE (XEXP (op0, 0)) != V4SImode)))\n \t    continue;\n \t  if (!BYTES_BIG_ENDIAN\n \t      && icode == CODE_FOR_altivec_vpkuhum_direct\n-\t      && ((GET_CODE (op0) == REG\n+\t      && ((REG_P (op0)\n \t\t   && GET_MODE (op0) != V8HImode)\n-\t\t  || (GET_CODE (op0) == SUBREG\n+\t\t  || (SUBREG_P (op0)\n \t\t      && GET_MODE (XEXP (op0, 0)) != V8HImode)))\n \t    continue;\n \n@@ -37775,7 +37758,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n     func = rs6000_longcall_ref (func_desc, tlsarg);\n \n   /* Handle indirect calls.  */\n-  if (GET_CODE (func) != SYMBOL_REF\n+  if (!SYMBOL_REF_P (func)\n       || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (func)))\n     {\n       /* Save the TOC into its reserved slot before the call,\n@@ -38325,7 +38308,7 @@ rs6000_split_logical_inner (rtx dest,\n   rtx bool_rtx;\n \n   /* Optimize AND of 0/0xffffffff and IOR/XOR of 0.  */\n-  if (op2 && GET_CODE (op2) == CONST_INT\n+  if (op2 && CONST_INT_P (op2)\n       && (mode == SImode || (mode == DImode && TARGET_POWERPC64))\n       && !complement_final_p && !complement_op1_p && !complement_op2_p)\n     {\n@@ -38425,7 +38408,7 @@ rs6000_split_logical_di (rtx operands[3],\n     op2_hi_lo[hi] = op2_hi_lo[lo] = NULL_RTX;\n   else\n     {\n-      if (GET_CODE (operands[2]) != CONST_INT)\n+      if (!CONST_INT_P (operands[2]))\n \t{\n \t  op2_hi_lo[hi] = gen_highpart_mode (SImode, DImode, operands[2]);\n \t  op2_hi_lo[lo] = gen_lowpart (SImode, operands[2]);\n@@ -38464,7 +38447,7 @@ rs6000_split_logical_di (rtx operands[3],\n     {\n       /* Split large IOR/XOR operations.  */\n       if ((code == IOR || code == XOR)\n-\t  && GET_CODE (op2_hi_lo[i]) == CONST_INT\n+\t  && CONST_INT_P (op2_hi_lo[i])\n \t  && !complement_final_p\n \t  && !complement_op1_p\n \t  && !complement_op2_p"}, {"sha": "bfe557d63250895d1e994ae4c2e16fc0edfe88ed", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -240,7 +240,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n /* Return 1 for a symbol ref for a thread-local storage symbol.  */\n #define RS6000_SYMBOL_REF_TLS_P(RTX) \\\n-  (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n+  (SYMBOL_REF_P (RTX) && SYMBOL_REF_TLS_MODEL (RTX) != 0)\n \n #ifdef IN_LIBGCC2\n /* For libgcc2 we make sure this is a compile time constant */\n@@ -1685,15 +1685,15 @@ typedef struct rs6000_args\n    allocation.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\\\n-((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+(HARD_REGISTER_NUM_P (REGNO)\t\t\t\t\t\\\n  ? (REGNO) <= 31 || (REGNO) == 67\t\t\t\t\\\n    || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\t\\\n  : (reg_renumber[REGNO] >= 0\t\t\t\t\t\\\n     && (reg_renumber[REGNO] <= 31 || reg_renumber[REGNO] == 67\t\\\n \t|| reg_renumber[REGNO] == FRAME_POINTER_REGNUM)))\n \n #define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n-((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+(HARD_REGISTER_NUM_P (REGNO)\t\t\t\t\t\\\n  ? ((REGNO) > 0 && (REGNO) <= 31) || (REGNO) == 67\t\t\\\n    || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\t\\\n  : (reg_renumber[REGNO] > 0\t\t\t\t\t\\\n@@ -1703,13 +1703,13 @@ typedef struct rs6000_args\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg in the non-strict case.  */\n #define INT_REG_OK_FOR_INDEX_P(X, STRICT)\t\t\t\\\n-  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n+  ((!(STRICT) && !HARD_REGISTER_P (X))\t\t\t\t\\\n    || REGNO_OK_FOR_INDEX_P (REGNO (X)))\n \n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg in the non-strict case.  */\n #define INT_REG_OK_FOR_BASE_P(X, STRICT)\t\t\t\\\n-  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n+  ((!(STRICT) && !HARD_REGISTER_P (X))\t\t\t\t\\\n    || REGNO_OK_FOR_BASE_P (REGNO (X)))\n \n \f\n@@ -1720,8 +1720,8 @@ typedef struct rs6000_args\n /* Recognize any constant value that is a valid address.  */\n \n #define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n+  (GET_CODE (X) == LABEL_REF || SYMBOL_REF_P (X)\t\t\t\\\n+   || CONST_INT_P (X) || GET_CODE (X) == CONST\t\t\t\t\\\n    || GET_CODE (X) == HIGH)\n \n #define EASY_VECTOR_15(n) ((n) >= -16 && (n) <= 15)"}, {"sha": "a307518cbdf587b0a36760f310b3ed6cb74f0a4a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -1570,7 +1570,7 @@\n   rtx addr, scratch_string, word1, word2, scratch_dlmzb;\n   rtx loop_label, end_label, mem, cr0, cond;\n   if (search_char != const0_rtx\n-      || GET_CODE (align) != CONST_INT\n+      || !CONST_INT_P (align)\n       || INTVAL (align) < 8)\n         FAIL;\n   word1 = gen_reg_rtx (SImode);\n@@ -3132,7 +3132,7 @@\n   rtx temp1;\n   rtx temp2;\n \n-  if (GET_CODE (operands[2]) != CONST_INT\n+  if (!CONST_INT_P (operands[2])\n       || INTVAL (operands[2]) <= 0\n       || (i = exact_log2 (INTVAL (operands[2]))) < 0)\n     {\n@@ -7210,9 +7210,9 @@\n   [(set (match_operand:FMOVE32 0 \"gpc_reg_operand\")\n \t(match_operand:FMOVE32 1 \"const_double_operand\"))]\n   \"reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+   && ((REG_P (operands[0]) && REGNO (operands[0]) <= 31)\n+       || (SUBREG_P (operands[0])\n+\t   && REG_P (SUBREG_REG (operands[0]))\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 3))]\n {\n@@ -7422,9 +7422,9 @@\n   [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\")\n \t(match_operand:FMOVE64 1 \"const_int_operand\"))]\n   \"! TARGET_POWERPC64 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+   && ((REG_P (operands[0]) && REGNO (operands[0]) <= 31)\n+       || (SUBREG_P (operands[0])\n+\t   && REG_P (SUBREG_REG (operands[0]))\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n@@ -7442,9 +7442,9 @@\n   [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\")\n \t(match_operand:FMOVE64 1 \"const_double_operand\"))]\n   \"! TARGET_POWERPC64 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+   && ((REG_P (operands[0]) && REGNO (operands[0]) <= 31)\n+       || (SUBREG_P (operands[0])\n+\t   && REG_P (SUBREG_REG (operands[0]))\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n@@ -7464,9 +7464,9 @@\n   [(set (match_operand:FMOVE64 0 \"gpc_reg_operand\")\n \t(match_operand:FMOVE64 1 \"const_double_operand\"))]\n   \"TARGET_POWERPC64 && reload_completed\n-   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n-       || (GET_CODE (operands[0]) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+   && ((REG_P (operands[0]) && REGNO (operands[0]) <= 31)\n+       || (SUBREG_P (operands[0])\n+\t   && REG_P (SUBREG_REG (operands[0]))\n \t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 3))]\n {\n@@ -10236,7 +10236,7 @@\n     operands[0] = machopic_indirect_call_target (operands[0]);\n #endif\n \n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n+  gcc_assert (MEM_P (operands[0]));\n \n   operands[0] = XEXP (operands[0], 0);\n \n@@ -10265,7 +10265,7 @@\n     operands[1] = machopic_indirect_call_target (operands[1]);\n #endif\n \n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n+  gcc_assert (MEM_P (operands[1]));\n \n   operands[1] = XEXP (operands[1], 0);\n \n@@ -10722,8 +10722,8 @@\n     operands[0] = machopic_indirect_call_target (operands[0]);\n #endif\n \n-  gcc_assert (GET_CODE (operands[0]) == MEM);\n-  gcc_assert (GET_CODE (operands[1]) == CONST_INT);\n+  gcc_assert (MEM_P (operands[0]));\n+  gcc_assert (CONST_INT_P (operands[1]));\n \n   operands[0] = XEXP (operands[0], 0);\n \n@@ -10752,8 +10752,8 @@\n     operands[1] = machopic_indirect_call_target (operands[1]);\n #endif\n \n-  gcc_assert (GET_CODE (operands[1]) == MEM);\n-  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n+  gcc_assert (MEM_P (operands[1]));\n+  gcc_assert (CONST_INT_P (operands[2]));\n \n   operands[1] = XEXP (operands[1], 0);\n \n@@ -11046,7 +11046,7 @@\n {\n   /* Take care of the possibility that operands[2] might be negative but\n      this might be a logical operation.  That insn doesn't exist.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && INTVAL (operands[2]) < 0)\n     {\n       operands[2] = force_reg (<MODE>mode, operands[2]);\n@@ -12950,9 +12950,9 @@\n         (unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t    (match_operand 2 \"immediate_operand\" \"n\")]\n \t\t   UNSPEC_MOVESI_TO_CR))]\n-  \"GET_CODE (operands[0]) == REG\n+  \"REG_P (operands[0])\n    && CR_REGNO_P (REGNO (operands[0]))\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && INTVAL (operands[2]) == 1 << (75 - REGNO (operands[0]))\"\n   \"mtcrf %R0,%1\"\n   [(set_attr \"type\" \"mtcr\")])"}, {"sha": "f14378129d0394c398a73c850550a06c523d8ef7", "filename": "gcc/config/rs6000/rtems.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frtems.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -222,13 +222,13 @@\n #undef  ASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\\n-   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+   && (SYMBOL_REF_P (X)\t\t\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+\t   && SYMBOL_REF_P (XEXP (XEXP (X, 0), 0)))\t\t\t\\\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+       || (CONST_INT_P (X)\t\t\t\t\t\t\\\n \t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n-       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+       || (CONST_DOUBLE_P (X)\t\t\t\t\t\t\\\n \t   && ((TARGET_64BIT\t\t\t\t\t\t\\\n \t\t&& (TARGET_MINIMAL_TOC\t\t\t\t\t\\\n \t\t    || (SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\\"}, {"sha": "22452b3c4f09e3bc6341864bda7a22f0566ca81e", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -353,14 +353,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n #define\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\\n-   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+   && (SYMBOL_REF_P (X)\t\t\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+\t   && SYMBOL_REF_P (XEXP (XEXP (X, 0), 0)))\t\t\t\\\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+       || (CONST_INT_P (X)\t\t\t\t\t\t\\\n \t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n        || (!TARGET_NO_FP_IN_TOC\t\t\t\t\t\t\\\n-\t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n+\t   && CONST_DOUBLE_P (X)\t\t\t\t\t\\\n \t   && SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\t\\\n \t   && BITS_PER_WORD == HOST_BITS_PER_INT)))\n "}, {"sha": "98bd433fa3bd8022be5f915918458205c340f63e", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -459,7 +459,7 @@\n      allocation and the hard register destination is not in the altivec\n      range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((reg_or_subregno (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+      && (!HARD_REGISTER_NUM_P (reg_or_subregno (operands[0]))\n \t  || ALTIVEC_REGNO_P (reg_or_subregno (operands[0]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n@@ -509,7 +509,7 @@\n      allocation and the hard register destination is not in the altivec\n      range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((REGNO(operands[0]) >= FIRST_PSEUDO_REGISTER)\n+      && (!HARD_REGISTER_P (operands[0])\n \t  || ALTIVEC_REGNO_P (REGNO(operands[0]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n@@ -563,7 +563,7 @@\n      allocation and the hard register destination is not in the altivec\n      range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((REGNO(operands[0]) >= FIRST_PSEUDO_REGISTER)\n+      && (!HARD_REGISTER_P (operands[0])\n \t  || ALTIVEC_REGNO_P (REGNO(operands[0]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n@@ -625,7 +625,7 @@\n      allocation and the hard register destination is not in the altivec\n      range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((REGNO(operands[0]) >= FIRST_PSEUDO_REGISTER)\n+      && (!HARD_REGISTER_P (operands[0])\n \t  || ALTIVEC_REGNO_P (REGNO(operands[0]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n@@ -678,8 +678,8 @@\n   /* Don't apply the swap optimization if we've already performed register\n      allocation and the hard register source is not in the altivec range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+      && (!HARD_REGISTER_NUM_P (reg_or_subregno (operands[1]))\n+\t  || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n       enum machine_mode mode = GET_MODE (mem);\n@@ -750,8 +750,8 @@\n   /* Don't apply the swap optimization if we've already performed register\n      allocation and the hard register source is not in the altivec range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+      && (!HARD_REGISTER_NUM_P (reg_or_subregno (operands[1]))\n+\t  || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n       enum machine_mode mode = GET_MODE (mem);\n@@ -829,8 +829,8 @@\n   /* Don't apply the swap optimization if we've already performed register\n      allocation and the hard register source is not in the altivec range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+      && (!HARD_REGISTER_NUM_P (reg_or_subregno (operands[1]))\n+\t  || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n       enum machine_mode mode = GET_MODE (mem);\n@@ -922,8 +922,8 @@\n   /* Don't apply the swap optimization if we've already performed register\n      allocation and the hard register source is not in the altivec range.  */\n   if ((MEM_ALIGN (mem) >= 128)\n-      && ((reg_or_subregno (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-          || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n+      && (!HARD_REGISTER_NUM_P (reg_or_subregno (operands[1]))\n+\t  || ALTIVEC_REGNO_P (reg_or_subregno (operands[1]))))\n     {\n       rtx mem_address = XEXP (mem, 0);\n       enum machine_mode mode = GET_MODE (mem);"}, {"sha": "80b2dcfba5501bb18246f45bd04f8e1e1a655b0d", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e42a52fd1bb913d293d4ccc6cdcf34cf916215e/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=2e42a52fd1bb913d293d4ccc6cdcf34cf916215e", "patch": "@@ -75,13 +75,13 @@\n \n #define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\\n-   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+   && (SYMBOL_REF_P (X)\t\t\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+\t   && SYMBOL_REF_P (XEXP (XEXP (X, 0), 0)))\t\t\t\\\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+       || (CONST_INT_P (X)\t\t\t\t\t\t\\\n \t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n-       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+       || (CONST_DOUBLE_P (X)\t\t\t\t\t\t\\\n \t   && (TARGET_MINIMAL_TOC\t\t\t\t\t\\\n \t       || (SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\t\\\n \t\t   && ! TARGET_NO_FP_IN_TOC)))))"}]}