{"sha": "824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI0YjlhNGM0NTRhYTczOTU1ZjFmOGMyZTI2NTBkOTI0OGJjZDJiNA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-02-04T02:31:49Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-02-04T02:31:49Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13604", "tree": {"sha": "f09819240146b28ac774ab139e0ca6750f62bb60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f09819240146b28ac774ab139e0ca6750f62bb60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/comments", "author": null, "committer": null, "parents": [{"sha": "44c389e479e9e226cd7d4e33abf8fda15209c894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c389e479e9e226cd7d4e33abf8fda15209c894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c389e479e9e226cd7d4e33abf8fda15209c894"}], "stats": {"total": 657, "additions": 456, "deletions": 201}, "files": [{"sha": "9b484f5ba75b5684e3cbdf771ec9f70e3b3a32b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -1,3 +1,145 @@\n+Thu Jan 30 19:18:00 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (lookup_name_real): Also build a TYPENAME_TYPE for nested\n+ \tclasses.\n+\t* pt.c (tsubst): Don't recurse for the type of a TYPENAME_TYPE.\n+\n+Wed Jan 29 11:40:35 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Next route, pedwarn about different\n+\texceptions if -pedantic *or* olddecl !DECL_IN_SYSTEM_HEADER.\n+\n+Tue Jan 28 20:43:29 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cp-tree.h (HAS_DEFAULT_IMPLEMENTATION): Delete macro.\n+\t(struct lang_type): Delete has_default_implementation member.\n+\tIncrease dummy to 21.\n+\t* decl.c (start_method): Delete usage.\n+\n+\t* cp-tree.h (build_call, null_ptr_cst_p, in_function_p,\n+\tstore_after_parms, start_decl_1, auto_function): Add decls.\n+\t(get_arglist_len_in_bytes, declare_implicit_exception,\n+\thave_exceptions_p, make_type_decl, typedecl_for_tag,\n+\tstore_in_parms, pop_implicit_try_blocks, push_exception_cleanup,\n+\tbuild_component_type_expr, cplus_exception_name,\n+\t{make,clear}_anon_parm_name, dont_see_typename): Removed decls.\n+\t* call.c (build_this): Make static.\n+\t(is_complete): Likewise.\n+\t(implicit_conversion): Likewise.\n+\t(reference_binding): Likewise.\n+\t(standard_conversion): Likewise.\n+\t(strip_top_quals): Likewise.\n+\t(non_reference): Likewise.\n+\t(build_conv): Likewise.\n+\t(user_harshness): Likewise.\n+\t(rank_for_ideal): Likewise.\n+\t* decl.c (start_decl_1): Delete forward decl.\n+\t(push_decl_level): Make static.\n+\t(resume_binding_level): Make static.\n+\t(namespace_bindings_p): Make static.\n+\t(declare_namespace_level): Make static.\n+\t(lookup_name_real): Make static.\n+\t(duplicate_decls): Make static.  Take register off NEWDECL and\n+\tOLDDECL parm decls.\n+\t* decl2.c (get_sentry): Make static.\n+\t(temp_name_p): Delete fn.\n+\t* except.c (auto_function): Delete decl.\n+\t* lex.c (handle_{cp,sysv}_pragma): Make static.\n+\t(handle_sysv_pragma) [HANDLE_SYSV_PRAGMA]: Add forward decl.\n+\t* method.c (do_build_{copy_constructor,assign_ref}): Make static.\n+\t* pt.c (tsubst_expr_values): Make static.\n+\t* rtti.c (combine_strings): Delete decl.\n+\n+Tue Jan 28 16:40:40 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (push_template_decl): Handle getting a typedef.\n+\n+\t* call.c (build_new_function_call): Complain about void arg.\n+\n+Tue Jan 28 15:25:09 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Give pedwarn of different exceptions\n+\tif -pedantic, instead of olddecl !DECL_IN_SYSTEM_HEADER.\n+\n+Mon Jan 27 19:21:29 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Don't expand the cleanup tree here,\n+ \tsince we are not going to write the rtl out.  Fixes problem with\n+ \t-g -O on SPARC.\n+\n+Mon Jan 27 16:24:35 1997  Sean McNeil  <sean@mcneil.com>\n+\n+\t* Make-lang.in: Add $(exeext) as necessary.\n+\n+Mon Jan 27 13:20:39 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (handler_seq): Must have at least one catch clause.\n+\n+Sat Jan 25 12:00:05 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (add_builtin_candidate): Restore ?: hack.\n+\n+\t* decl.c (grok_op_properties): More warnings.\n+\n+Sat Jan 25 08:50:03 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): On second thought, do it as a pedwarn\n+\tstill but only if !DECL_IN_SYSTEM_HEADER (olddecl).\n+\n+\t* decl.c (duplicate_decls): Scale back to a warning, and only do\n+\t'em if -pedantic.\n+\n+Fri Jan 24 17:52:54 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (duplicate_decls): pedwarn mismatched exception\n+ \tspecifications.\n+\n+Thu Jan 23 18:18:54 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (build_new_method_call): Don't display the invisible\n+ \targument for controlling virtual bases.\n+\n+Thu Jan 23 16:48:10 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* new: Add nothrow new and delete, bad_alloc and throw specifications\n+\tfor delete.\n+\t* decl.c (init_decl_processing): Add throw specification for delete.\n+\t* new.cc (nothrow): Define.\n+\t* lex.c (real_yylex): Removing warning that throw and friends are\n+\tkeywords.\n+\t* new1.cc (operator new (size_t sz, const nothrow_t&)): Define.\n+\t* new2.cc (operator new[] (size_t sz, const nothrow_t&): Define.\n+\t* Make-lang.in: Add new{1,2}.{cc,o}.\n+\n+Thu Jan 23 16:39:06 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (cons_up_default_function): Fix return type of synth op=.\n+\n+\t* init.c (emit_base_init): Add warnings for uninitialized members\n+ \tand bases.\n+\n+\t* decl.c (xref_basetypes): Add warning for non-polymorphic type\n+ \twith destructor used as base type.\n+\n+\t* decl.c (grok_op_properties): Add warning for op= returning void.\n+\t* typeck.c (c_expand_return): Add warning for op= returning anything\n+\tother than *this.\n+\n+\t* class.c (finish_struct_1): Add warning for class with pointers\n+ \tbut not copy ctor or copy op=.\n+\n+\t* cp-tree.h (TI_PENDING_TEMPLATE_FLAG): New macro.\n+\t* pt.c (add_pending_template): Use it instead of LANG_FLAG_0.\n+\t(instantiate_template): If -fexternal-templates, add this\n+ \tinstantiation to pending_templates.\n+\n+\t* decl2.c (copy_assignment_arg_p): Disable old hack to support\n+ \tBooch components.\n+\n+Tue Jan 21 18:32:04 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (cp_convert): Pedwarn enum to pointer conversions.\n+\n Mon Jan 20 17:59:51 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (standard_conversion): Handle getting references.  Tack"}, {"sha": "00551a3ad4dcd996029168b9397d5b61f231ab48", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -58,9 +58,10 @@ CXX_EXTRA_HEADERS = $(srcdir)/cp/inc/typeinfo $(srcdir)/cp/inc/exception \\\n \t$(srcdir)/cp/inc/new $(srcdir)/cp/inc/new.h\n \n # Extra code to include in libgcc2.\n-CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o exception.o\n-CXX_LIB2SRCS = $(srcdir)/cp/new.cc $(srcdir)/cp/exception.cc \\\n-\t$(srcdir)/cp/tinfo.cc $(srcdir)/cp/tinfo2.cc $(srcdir)/cp/tinfo.h\n+CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o new1.o new2.o exception.o\n+CXX_LIB2SRCS = $(srcdir)/cp/new.cc $(srcdir)/cp/new1.cc $(srcdir)/cp/new2.cc \\\n+\t$(srcdir)/cp/exception.cc $(srcdir)/cp/tinfo.cc \\\n+\t$(srcdir)/cp/tinfo2.cc $(srcdir)/cp/tinfo.h\n \f\n # Define the names for selecting c++ in LANGUAGES.\n # Note that it would be nice to move the dependency on g++\n@@ -125,9 +126,9 @@ cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n \f\n # Build hooks:\n \n-c++.all.build: g++ $(DEMANGLER_PROG)\n-c++.all.cross: g++-cross $(DEMANGLER_PROG)\n-c++.start.encap: g++\n+c++.all.build: g++$(exeext) $(DEMANGLER_PROG)\n+c++.all.cross: g++-cross$(exeext) $(DEMANGLER_PROG)\n+c++.start.encap: g++$(exeext)\n c++.rest.encap: $(DEMANGLER_PROG)\n \n c++.info:\n@@ -146,6 +147,12 @@ exception.o: cc1plus $(srcdir)/cp/exception.cc\n new.o: cc1plus $(srcdir)/cp/new.cc\n \t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n \t  -c $(srcdir)/cp/new.cc\n+new1.o: cc1plus $(srcdir)/cp/new1.cc\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n+\t  -c $(srcdir)/cp/new1.cc\n+new2.o: cc1plus $(srcdir)/cp/new2.cc\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) \\\n+\t  -c $(srcdir)/cp/new2.cc\n \n # We want to update cplib2.txt if any of the source files change...\n cplib2.txt: $(CXX_LIB2SRCS) $(CXX_EXTRA_HEADERS) cplib2.ready"}, {"sha": "f9fe74dc1d1999085a9cc503f83b1ca58ca6de5f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -82,7 +82,7 @@ rank_for_overload (x, y)\n \n /* Compare two candidates, argument by argument.  */\n \n-int\n+static int\n rank_for_ideal (x, y)\n      struct candidate *x, *y;\n {\n@@ -627,7 +627,7 @@ convert_harshness (type, parmtype, parm)\n /* A clone of build_type_conversion for checking user-defined conversions in\n    overload resolution.  */\n \n-int\n+static int\n user_harshness (type, parmtype)\n      register tree type, parmtype;\n {\n@@ -2935,7 +2935,7 @@ null_ptr_cst_p (t)\n   return 0;\n }\n \n-tree\n+static tree\n build_conv (code, type, from)\n      enum tree_code code;\n      tree type, from;\n@@ -2967,7 +2967,7 @@ build_conv (code, type, from)\n   return t;\n }\n \n-tree\n+static tree\n non_reference (t)\n      tree t;\n {\n@@ -2976,7 +2976,7 @@ non_reference (t)\n   return t;\n }\n \n-tree\n+static tree\n strip_top_quals (t)\n      tree t;\n {\n@@ -2989,7 +2989,7 @@ strip_top_quals (t)\n    TO, if any.  For proper handling of null pointer constants, you must\n    also pass the expression EXPR to convert from.  */\n \n-tree\n+static tree\n standard_conversion (to, from, expr)\n      tree to, from, expr;\n {\n@@ -3158,7 +3158,7 @@ standard_conversion (to, from, expr)\n    Currently does not distinguish in the generated trees between binding to\n    an lvalue and a temporary.  Should it?  */\n \n-tree\n+static tree\n reference_binding (rto, rfrom, expr, flags)\n      tree rto, rfrom, expr;\n      int flags;\n@@ -3218,7 +3218,7 @@ reference_binding (rto, rfrom, expr, flags)\n    FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is\n    significant.  */\n \n-tree\n+static tree\n implicit_conversion (to, from, expr, flags)\n      tree to, from, expr;\n      int flags;\n@@ -3498,7 +3498,7 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n   return cand;\n }\n \n-int\n+static int\n is_complete (t)\n      tree t;\n {\n@@ -3841,15 +3841,10 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n       break;\n \n     case COND_EXPR:\n-#if 0\n       /* Kludge around broken overloading rules whereby\n \t bool ? const char& : enum is ambiguous\n \t (between int and const char&).  */\n-      /* Not needed for compiles without -pedantic, since the rank compare\n-\t in joust will pick the int promotion.  Let's just leave this out\n-\t for now.  */\n       flags |= LOOKUP_NO_TEMP_BIND;\n-#endif\n \n       /* Extension: Support ?: of enumeral type.  Hopefully this will not\n          be an extension for long.  */\n@@ -4124,7 +4119,7 @@ splice_viable (cands)\n   return cands;\n }\n \n-tree\n+static tree\n build_this (obj)\n      tree obj;\n {\n@@ -4306,8 +4301,15 @@ build_new_function_call (fn, args, obj)\n       tree templates = NULL_TREE;\n \n       for (t = args; t; t = TREE_CHAIN (t))\n-\tif (TREE_VALUE (t) == error_mark_node)\n-\t  return error_mark_node;\n+\t{\n+\t  if (TREE_VALUE (t) == error_mark_node)\n+\t    return error_mark_node;\n+\t  else if (TREE_CODE (TREE_TYPE (TREE_VALUE (t))) == VOID_TYPE)\n+\t    {\n+\t      error (\"invalid use of void expression\");\n+\t      return error_mark_node;\n+\t    }\n+\t}\n \t\n       for (t = TREE_VALUE (fn); t; t = DECL_CHAIN (t))\n \t{\n@@ -5190,6 +5192,12 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n   struct z_candidate *candidates = 0, *cand;\n   tree basetype, mem_args, fns, instance_ptr;\n   tree pretty_name;\n+  tree user_args = args;\n+\n+  /* If there is an extra argument for controlling virtual bases,\n+     remove it for error reporting.  */\n+  if (flags & LOOKUP_HAS_IN_CHARGE)\n+    user_args = TREE_CHAIN (args);\n \n   for (fns = args; fns; fns = TREE_CHAIN (fns))\n     if (TREE_VALUE (fns) == error_mark_node)\n@@ -5284,7 +5292,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       if (flags & LOOKUP_SPECULATIVELY)\n \treturn NULL_TREE;\n       cp_error (\"no matching function for call to `%T::%D (%A)%V'\", basetype,\n-\t\tpretty_name, args, TREE_TYPE (TREE_TYPE (instance_ptr)));\n+\t\tpretty_name, user_args, TREE_TYPE (TREE_TYPE (instance_ptr)));\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -5293,7 +5301,8 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \n   if (cand == 0)\n     {\n-      cp_error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name, args);\n+      cp_error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name,\n+\t\tuser_args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }"}, {"sha": "dc179d0282858bf29d97fdc777da4ce5863e5887", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -3046,6 +3046,7 @@ finish_struct_1 (t, warn_anon)\n   tree access_decls = NULL_TREE;\n   int aggregate = 1;\n   int empty = 1;\n+  int has_pointers = 0;\n \n   if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n     pedwarn (\"anonymous class type not used to declare any objects\");\n@@ -3334,6 +3335,9 @@ finish_struct_1 (t, warn_anon)\n \t    }\n \t}\n \n+      if (TREE_CODE (TREE_TYPE (x)) == POINTER_TYPE)\n+\thas_pointers = 1;\n+\n       /* If any field is const, the structure type is pseudo-const.  */\n       if (TREE_READONLY (x))\n \t{\n@@ -3581,6 +3585,22 @@ finish_struct_1 (t, warn_anon)\n \t}\n     }\n \n+  /* Effective C++ rule 11.  */\n+  if (has_pointers && extra_warnings\n+      && ! (TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n+    {\n+      cp_warning (\"`%#T' has pointer data members\", t);\n+      \n+      if (! TYPE_HAS_INIT_REF (t))\n+\t{\n+\t  cp_warning (\"  but does not override `%T(const %T&)'\", t, t);\n+\t  if (! TYPE_HAS_ASSIGN_REF (t))\n+\t    cp_warning (\"  or `operator=(const %T&)'\", t);\n+\t}\n+      else if (! TYPE_HAS_ASSIGN_REF (t))\n+\tcp_warning (\"  but does not override `operator=(const %T&)'\", t);\n+    }\n+\n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n \n   TYPE_HAS_COMPLEX_INIT_REF (t)"}, {"sha": "cdc8dd64606b088689d3aa26ad162afe4ba5950e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 109, "deletions": 96, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -355,7 +355,6 @@ enum languages { lang_c, lang_cplusplus };\n /* #define TYPE_NAME_STRING(NODE) (type_name_string (NODE)) */\n #define FUNCTION_ARG_CHAIN(NODE) (function_arg_chain (NODE))\n #define PROMOTES_TO_AGGR_TYPE(NODE,CODE) (promotes_to_aggr_type (NODE, CODE))\n-/* #define IS_AGGR_TYPE_2(TYPE1, TYPE2) (is_aggr_type_2 (TYPE1, TYPE2)) */\n #endif\n /* Nonzero iff TYPE is uniquely derived from PARENT.  Under MI, PARENT can\n    be an ambiguous base class of TYPE, and this macro will be false.  */\n@@ -423,23 +422,22 @@ struct lang_type\n       unsigned is_signature_pointer : 1;\n \n       unsigned is_signature_reference : 1;\n-      unsigned has_default_implementation : 1;\n       unsigned has_opaque_typedecls : 1;\n       unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n       unsigned has_real_assignment : 1;\n       unsigned has_real_assign_ref : 1;\n       unsigned has_const_init_ref : 1;\n-\n       unsigned has_complex_init_ref : 1;\n+\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 20;\n+      unsigned dummy : 21;\n \n       unsigned n_vancestors : 16;\n     } type_flags;\n@@ -585,9 +583,6 @@ struct lang_type\n /* Nonzero means that this type is a signature reference type.  */\n # define IS_SIGNATURE_REFERENCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature_reference)\n \n-/* Nonzero means that this signature type has a default implementation.  */\n-# define HAS_DEFAULT_IMPLEMENTATION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_default_implementation)\n-\n /* Nonzero means that this signature contains opaque type declarations.  */\n #define SIGNATURE_HAS_OPAQUE_TYPEDECLS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_opaque_typedecls)\n \n@@ -1083,6 +1078,7 @@ struct lang_decl\n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n #define TI_ARGS(NODE) (TREE_VALUE (NODE))\n #define TI_USES_TEMPLATE_PARMS(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n #define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n@@ -1544,17 +1540,16 @@ extern int minimal_parse_mode;\n /* in class.c */\n extern tree current_class_name;\n extern tree current_class_type;\n+extern tree current_class_ptr;\n extern tree previous_class_type;\n+extern tree current_class_ref;\n \n extern tree current_lang_name, lang_name_cplusplus, lang_name_c;\n \n /* Points to the name of that function. May not be the DECL_NAME\n    of CURRENT_FUNCTION_DECL due to overloading */\n extern tree original_function_name;\n \n-extern tree current_class_name, current_class_type;\n-extern tree current_class_ptr, current_class_ref;\n-\n /* in init.c  */\n extern tree global_base_init_list;\n extern tree current_base_init_list, current_member_init_list;\n@@ -1925,33 +1920,30 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    opname_tab[(int) MINUS_EXPR] == \"-\".  */\n extern char **opname_tab, **assignop_tab;\n \f\n-/* in c-common.c */\n-extern tree convert_and_check\t\t\tPROTO((tree, tree));\n-extern void overflow_warning\t\t\tPROTO((tree));\n-extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n-\n /* in call.c */\n extern struct candidate *ansi_c_filler;\n+extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n \n extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n-extern int can_convert\t\t\t\tPROTO((tree, tree));\n-extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n extern void compute_conversion_costs\t\tPROTO((tree, tree, struct candidate *, int));\n-extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n extern tree find_scoped_type\t\t\tPROTO((tree, tree, tree));\n extern tree resolve_scope_to_name\t\tPROTO((tree, tree));\n-extern tree build_call\t\t\t\tPROTO((tree, tree, tree));\n-extern tree build_addr_func\t\t\tPROTO((tree));\n extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n+extern tree build_addr_func\t\t\tPROTO((tree));\n+extern tree build_call\t\t\t\tPROTO((tree, tree, tree));\n extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n extern tree build_overload_call\t\t\tPROTO((tree, tree, int));\n-extern tree build_new_method_call\t\tPROTO((tree, tree, tree, tree, int));\n+extern int null_ptr_cst_p\t\t\tPROTO((tree));\n+extern tree type_decays_to\t\t\tPROTO((tree));\n extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n extern tree build_new_function_call\t\tPROTO((tree, tree, tree));\n+extern tree build_object_call\t\t\tPROTO((tree, tree));\n extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n-extern tree type_decays_to\t\t\tPROTO((tree));\n+extern tree build_new_method_call\t\tPROTO((tree, tree, tree, tree, int));\n+extern int can_convert\t\t\t\tPROTO((tree, tree));\n+extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n \n /* in class.c */\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n@@ -1984,30 +1976,31 @@ extern tree build_self_reference\t\tPROTO((void));\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n extern tree convert_from_reference\t\tPROTO((tree));\n extern tree convert_to_aggr\t\t\tPROTO((tree, tree, char **, int));\n-extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n-extern tree convert_pointer_to_vbase\t\tPROTO((tree, tree));\n-extern tree convert\t\t\t\tPROTO((tree, tree));\n+extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n extern tree cp_convert\t\t\t\tPROTO((tree, tree, int, int));\n+extern tree convert\t\t\t\tPROTO((tree, tree));\n extern tree convert_force\t\t\tPROTO((tree, tree, int));\n extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern tree type_promotes_to\t\t\tPROTO((tree));\n \n /* decl.c */\n+/* resume_binding_level */\n extern int global_bindings_p\t\t\tPROTO((void));\n extern int toplevel_bindings_p\t\t\tPROTO((void));\n extern void keep_next_level\t\t\tPROTO((void));\n extern int kept_level_p\t\t\t\tPROTO((void));\n extern void declare_parm_level\t\t\tPROTO((void));\n-extern void declare_implicit_exception\t\tPROTO((void));\n-extern int have_exceptions_p\t\t\tPROTO((void));\n extern void declare_pseudo_global_level\t\tPROTO((void));\n extern int pseudo_global_level_p\t\tPROTO((void));\n+extern void set_class_shadows\t\t\tPROTO((tree));\n extern void pushlevel\t\t\t\tPROTO((int));\n+extern void note_level_for_for\t\t\tPROTO((void));\n extern void pushlevel_temporary\t\t\tPROTO((int));\n extern tree poplevel\t\t\t\tPROTO((int, int, int));\n+/* resume_level */\n extern void delete_block\t\t\tPROTO((tree));\n extern void insert_block\t\t\tPROTO((tree));\n extern void add_block_current_level\t\tPROTO((tree));\n@@ -2016,47 +2009,59 @@ extern void pushlevel_class\t\t\tPROTO((void));\n extern tree poplevel_class\t\t\tPROTO((int));\n /* skip print_other_binding_stack and print_binding_level */\n extern void print_binding_stack\t\t\tPROTO((void));\n+extern void push_namespace\t\t\tPROTO((tree));\n+extern void pop_namespace\t\t\tPROTO((void));\n+extern void maybe_push_to_top_level\t\tPROTO((int));\n extern void push_to_top_level\t\t\tPROTO((void));\n extern void pop_from_top_level\t\t\tPROTO((void));\n extern void set_identifier_type_value\t\tPROTO((tree, tree));\n extern void pop_everything\t\t\tPROTO((void));\n-extern tree make_type_decl\t\t\tPROTO((tree, tree));\n extern void pushtag\t\t\t\tPROTO((tree, tree, int));\n extern tree make_anon_name\t\t\tPROTO((void));\n extern void clear_anon_tags\t\t\tPROTO((void));\n+extern int decls_match\t\t\t\tPROTO((tree, tree));\n+extern int duplicate_decls\t\t\tPROTO((tree, tree));\n extern tree pushdecl\t\t\t\tPROTO((tree));\n extern tree pushdecl_top_level\t\t\tPROTO((tree));\n-extern void push_class_level_binding\t\tPROTO((tree, tree));\n extern void push_overloaded_decl_top_level\tPROTO((tree, int));\n extern tree pushdecl_class_level\t\tPROTO((tree));\n extern void pushdecl_nonclass_level\t\tPROTO((tree));\n+extern void push_class_level_binding\t\tPROTO((tree, tree));\n extern int overloaded_globals_p\t\t\tPROTO((tree));\n extern tree push_overloaded_decl\t\tPROTO((tree, int));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n extern tree lookup_label\t\t\tPROTO((tree));\n extern tree shadow_label\t\t\tPROTO((tree));\n extern tree define_label\t\t\tPROTO((char *, int, tree));\n+extern void push_switch\t\t\t\tPROTO((void));\n+extern void pop_switch\t\t\t\tPROTO((void));\n extern void define_case_label\t\t\tPROTO((tree));\n extern tree getdecls\t\t\t\tPROTO((void));\n extern tree gettags\t\t\t\tPROTO((void));\n extern void set_current_level_tags_transparency\tPROTO((int));\n-extern tree typedecl_for_tag\t\t\tPROTO((tree));\n-extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n+extern tree make_typename_type\t\t\tPROTO((tree, tree));\n+extern tree lookup_name_nonclass\t\tPROTO((tree));\n+extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n+extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));\n extern void init_decl_processing\t\tPROTO((void));\n extern int init_type_desc\t\t\tPROTO((void));\n /* skipped define_function */\n extern void shadow_tag\t\t\t\tPROTO((tree));\n-extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n extern tree groktypename\t\t\tPROTO((tree));\n extern tree start_decl\t\t\t\tPROTO((tree, tree, int));\n+extern void start_decl_1\t\t\tPROTO((tree));\n extern void cp_finish_decl\t\t\tPROTO((tree, tree, tree, int, int));\n+extern void finish_decl\t\t\t\tPROTO((tree, tree, tree));\n extern void expand_static_init\t\t\tPROTO((tree, tree));\n extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n /* the grokdeclarator prototype is in decl.h */\n extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n+extern int copy_args_p\t\t\t\tPROTO((tree));\n+extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n+extern void grok_op_properties\t\t\tPROTO((tree, int, int));\n extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n@@ -2065,31 +2070,30 @@ extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n extern tree build_enumerator\t\t\tPROTO((tree, tree));\n extern tree grok_enum_decls\t\t\tPROTO((tree, tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n-extern void store_parm_decls\t\t\tPROTO((void));\n+extern void store_after_parms\t\t\tPROTO((struct rtx_def *));\n extern void expand_start_early_try_stmts\tPROTO((void));\n-extern void store_in_parms\t\t\tPROTO((struct rtx_def *));\n+extern void store_parm_decls\t\t\tPROTO((void));\n extern void store_return_init\t\t\tPROTO((tree, tree));\n extern void finish_function\t\t\tPROTO((int, int, int));\n extern tree start_method\t\t\tPROTO((tree, tree));\n extern tree finish_method\t\t\tPROTO((tree));\n extern void hack_incomplete_structures\t\tPROTO((tree));\n-extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n extern tree maybe_build_cleanup_and_delete\tPROTO((tree));\n+extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n extern void cplus_expand_expr_stmt\t\tPROTO((tree));\n extern void finish_stmt\t\t\t\tPROTO((void));\n-extern void pop_implicit_try_blocks\t\tPROTO((tree));\n-extern void push_exception_cleanup\t\tPROTO((tree));\n extern void revert_static_member_fn\t\tPROTO((tree *, tree *, tree *));\n extern int id_in_current_class\t\t\tPROTO((tree));\n extern void push_cp_function_context\t\tPROTO((tree));\n extern void pop_cp_function_context\t\tPROTO((tree));\n-extern void grok_op_properties\t\t\tPROTO((tree, int, int));\n+extern int in_function_p\t\t\tPROTO((void));\n \n /* in decl2.c */\n extern int flag_assume_nonnull_objects;\n-\n extern int lang_decode_option\t\t\tPROTO((char *));\n extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n+extern void warn_if_unknown_interface\t\tPROTO((tree));\n+extern tree grok_x_components\t\t\tPROTO((tree, tree));\n extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n extern tree grok_alignof\t\t\tPROTO((tree));\n extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n@@ -2113,60 +2117,77 @@ extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));\n extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n extern tree coerce_new_type\t\t\tPROTO((tree));\n extern tree coerce_delete_type\t\t\tPROTO((tree));\n+extern void comdat_linkage\t\t\tPROTO((tree));\n extern void import_export_vtable\t\tPROTO((tree, tree, int));\n extern int finish_prevtable_vardecl\t\tPROTO((tree, tree));\n extern int walk_vtables\t\t\t\tPROTO((void (*)(), int (*)()));\n extern void walk_sigtables\t\t\tPROTO((void (*)(), void (*)()));\n+extern void import_export_decl\t\t\tPROTO((tree));\n+extern tree build_cleanup\t\t\tPROTO((tree));\n extern void finish_file\t\t\t\tPROTO((void));\n-extern void warn_if_unknown_interface\t\tPROTO((tree));\n-extern tree grok_x_components\t\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_expr\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n extern tree build_expr_from_tree\t\tPROTO((tree));\n extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n-extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree check_cp_case_value\t\t\tPROTO((tree));\n+extern tree get_namespace_id\t\t\tPROTO((void));\n+extern tree current_namespace_id\t\tPROTO((tree));\n+extern void do_namespace_alias\t\t\tPROTO((tree, tree));\n extern void do_toplevel_using_decl\t\tPROTO((tree));\n extern tree do_class_using_decl\t\t\tPROTO((tree));\n-extern tree current_namespace_id\t\tPROTO((tree));\n-extern tree get_namespace_id\t\t\tPROTO((void));\n+extern void do_using_directive\t\t\tPROTO((tree));\n extern void check_default_args\t\t\tPROTO((tree));\n extern void mark_used\t\t\t\tPROTO((tree));\n \n+/* in errfn.c */\n+extern void cp_error\t\t\t\t();\n+extern void cp_error_at\t\t\t\t();\n+extern void cp_warning\t\t\t\t();\n+extern void cp_warning_at\t\t\t();\n+extern void cp_pedwarn\t\t\t\t();\n+extern void cp_pedwarn_at\t\t\t();\n+extern void cp_compiler_error\t\t\t();\n+extern void cp_sprintf\t\t\t\t();\n+\n+/* in error.c */\n+extern void init_error\t\t\t\tPROTO((void));\n+extern char *fndecl_as_string\t\t\tPROTO((tree, int));\n+extern char *type_as_string\t\t\tPROTO((tree, int));\n+extern char *args_as_string\t\t\tPROTO((tree, int));\n+extern char *decl_as_string\t\t\tPROTO((tree, int));\n+extern char *expr_as_string\t\t\tPROTO((tree, int));\n+extern char *code_as_string\t\t\tPROTO((enum tree_code, int));\n+extern char *language_as_string\t\t\tPROTO((enum languages, int));\n+extern char *parm_as_string\t\t\tPROTO((int, int));\n+extern char *op_as_string\t\t\tPROTO((enum tree_code, int));\n+extern char *assop_as_string\t\t\tPROTO((enum tree_code, int));\n+extern char *cv_as_string\t\t\tPROTO((tree, int));\n+\n /* in except.c */\n-extern void expand_exception_blocks\t\tPROTO((void));\n-extern void start_catch_block\t\t\tPROTO((tree, tree));\n-extern void end_catch_block\t\t\tPROTO((void));\n-extern void expand_throw\t\t\tPROTO((tree));\n-extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n+extern void expand_start_catch_block\t\tPROTO((tree, tree));\n+extern void expand_end_catch_block\t\tPROTO((void));\n extern void expand_builtin_throw\t\tPROTO((void));\n extern void expand_start_eh_spec\t\tPROTO((void));\n-extern tree build_cleanup\t\t\tPROTO((tree));\n+extern void expand_exception_blocks\t\tPROTO((void));\n extern tree start_anon_func\t\t\tPROTO((void));\n+extern void end_anon_func\t\t\tPROTO((void));\n+extern void expand_throw\t\t\tPROTO((tree));\n+extern tree build_throw\t\t\t\tPROTO((tree));\n \n /* in expr.c */\n /* skip cplus_expand_expr */\n extern void init_cplus_expand\t\t\tPROTO((void));\n extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n-\n-/* in repo.c */\n-extern void init_repo\t\t\t\tPROTO((char*));\n-extern void finish_repo\t\t\t\tPROTO((void));\n-\n-/* in rtti.c */\n-extern tree get_tinfo_fn\t\t\tPROTO((tree));\n-extern tree get_tinfo_fn_dynamic\t\tPROTO((tree));\n-extern tree build_typeid\t\t\tPROTO((tree));\n-extern tree build_x_typeid\t\t\tPROTO((tree));\n-extern tree get_typeid\t\t\t\tPROTO((tree));\n-extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n+extern int extract_init\t\t\t\tPROTO((tree, tree));\n+extern void do_case\t\t\t\tPROTO((tree, tree));\n \n /* in init.c */\n+extern void init_init_processing\t\tPROTO((void));\n+extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n extern void emit_base_init\t\t\tPROTO((tree, int));\n extern void check_base_init\t\t\tPROTO((tree));\n-extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_aggr_init\t\t\tPROTO((tree, tree, int, int));\n@@ -2176,14 +2197,12 @@ extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n extern tree get_type_value\t\t\tPROTO((tree));\n extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n-extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n extern tree resolve_offset_ref\t\t\tPROTO((tree));\n extern tree decl_constant_value\t\t\tPROTO((tree));\n extern int is_friend_type\t\t\tPROTO((tree, tree));\n extern int is_friend\t\t\t\tPROTO((tree, tree));\n extern void make_friend_class\t\t\tPROTO((tree, tree));\n extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, enum overload_flags, tree, int));\n-extern void embrace_waiting_friends\t\tPROTO((tree));\n extern tree build_builtin_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n@@ -2212,6 +2231,7 @@ extern void extract_interface_info\t\tPROTO((void));\n extern int set_vardecl_interface_info\t\tPROTO((tree, tree));\n extern void do_pending_inlines\t\t\tPROTO((void));\n extern void process_next_inline\t\t\tPROTO((tree));\n+/* skip save_pending_input */\n /* skip restore_pending_input */\n extern void yyungetc\t\t\t\tPROTO((int, int));\n extern void reinit_parse_for_method\t\tPROTO((int, tree));\n@@ -2223,13 +2243,14 @@ extern void check_for_missing_semicolon\t\tPROTO((tree));\n extern void note_got_semicolon\t\t\tPROTO((tree));\n extern void note_list_got_semicolon\t\tPROTO((tree));\n extern int check_newline\t\t\tPROTO((void));\n-extern void dont_see_typename\t\t\tPROTO((void));\n+extern void do_pending_lang_change\t\tPROTO((void));\n extern int identifier_type\t\t\tPROTO((tree));\n extern void see_typename\t\t\tPROTO((void));\n extern tree do_identifier\t\t\tPROTO((tree, int));\n extern tree do_scoped_id\t\t\tPROTO((tree, int));\n extern tree identifier_typedecl_value\t\tPROTO((tree));\n extern int real_yylex\t\t\t\tPROTO((void));\n+extern int is_rid\t\t\t\tPROTO((tree));\n extern tree build_lang_decl\t\t\tPROTO((enum tree_code, tree, tree));\n extern tree build_lang_field_decl\t\tPROTO((enum tree_code, tree, tree));\n extern void copy_lang_decl\t\t\tPROTO((tree));\n@@ -2239,46 +2260,19 @@ extern void dump_time_statistics\t\tPROTO((void));\n /* extern void compiler_error\t\t\tPROTO((char *, HOST_WIDE_INT, HOST_WIDE_INT)); */\n extern void yyerror\t\t\t\tPROTO((char *));\n \n-/* in errfn.c */\n-extern void cp_error\t\t\t\t();\n-extern void cp_error_at\t\t\t\t();\n-extern void cp_warning\t\t\t\t();\n-extern void cp_warning_at\t\t\t();\n-extern void cp_pedwarn\t\t\t\t();\n-extern void cp_pedwarn_at\t\t\t();\n-extern void cp_compiler_error\t\t\t();\n-extern void cp_sprintf\t\t\t\t();\n-\n-/* in error.c */\n-extern void init_error\t\t\t\tPROTO((void));\n-extern char *fndecl_as_string\t\t\tPROTO((tree, int));\n-extern char *type_as_string\t\t\tPROTO((tree, int));\n-extern char *args_as_string\t\t\tPROTO((tree, int));\n-extern char *decl_as_string\t\t\tPROTO((tree, int));\n-extern char *expr_as_string\t\t\tPROTO((tree, int));\n-extern char *code_as_string\t\t\tPROTO((enum tree_code, int));\n-extern char *language_as_string\t\t\tPROTO((enum languages, int));\n-extern char *parm_as_string\t\t\tPROTO((int, int));\n-extern char *op_as_string\t\t\tPROTO((enum tree_code, int));\n-extern char *assop_as_string\t\t\tPROTO((enum tree_code, int));\n-extern char *cv_as_string\t\t\tPROTO((tree, int));\n-\n /* in method.c */\n extern void init_method\t\t\t\tPROTO((void));\n-extern tree make_anon_parm_name\t\t\tPROTO((void));\n-extern void clear_anon_parm_name\t\tPROTO((void));\n extern void do_inline_function_hair\t\tPROTO((tree, tree));\n /* skip report_type_mismatch */\n extern char *build_overload_name\t\tPROTO((tree, int, int));\n extern tree build_static_name\t\t\tPROTO((tree, tree));\n-extern tree cplus_exception_name\t\tPROTO((tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n extern tree build_typename_overload\t\tPROTO((tree));\n extern tree build_overload_with_type\t\tPROTO((tree, tree));\n extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPROTO((tree, tree));\n-extern tree build_component_type_expr\t\tPROTO((tree, tree, tree, int));\n extern tree make_thunk\t\t\t\tPROTO((tree, int));\n+extern void emit_thunk\t\t\t\tPROTO((tree));\n extern void synthesize_method\t\t\tPROTO((tree));\n \n /* in pt.c */\n@@ -2303,16 +2297,35 @@ extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern void mark_class_instantiated\t\tPROTO((tree, int));\n extern void do_function_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n-extern tree make_typename_type\t\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree classtype_mangled_name\t\tPROTO((tree));\n extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n extern tree *get_bindings\t\t\tPROTO((tree, tree));\n+/* CONT ... */\n+extern void add_tree\t\t\t\tPROTO((tree));\n+extern void add_maybe_template\t\t\tPROTO((tree, tree));\n+\n+/* in repo.c */\n+extern void repo_template_used\t\t\tPROTO((tree));\n+extern void repo_template_instantiated\t\tPROTO((tree, int));\n+extern void init_repo\t\t\t\tPROTO((char*));\n+extern void finish_repo\t\t\t\tPROTO((void));\n+\n+/* in rtti.c */\n+extern void init_rtti_processing\t\tPROTO((void));\n+extern tree get_tinfo_fn_dynamic\t\tPROTO((tree));\n+extern tree build_typeid\t\t\tPROTO((tree));\n+extern tree build_x_typeid\t\t\tPROTO((tree));\n+extern tree get_tinfo_fn\t\t\tPROTO((tree));\n+extern tree get_typeid\t\t\t\tPROTO((tree));\n+extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n+extern void synthesize_tinfo_fn\t\t\tPROTO((tree));\n \n /* in search.c */\n extern void push_memoized_context\t\tPROTO((tree, int));\n extern void pop_memoized_context\t\tPROTO((int));\n+extern tree convert_pointer_to_vbase\t\tPROTO((tree, tree));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n extern tree compute_access\t\t\tPROTO((tree, tree));\n@@ -2447,6 +2460,7 @@ extern tree build_indirect_ref\t\t\tPROTO((tree, char *));\n extern tree build_x_array_ref\t\t\tPROTO((tree, tree));\n extern tree build_array_ref\t\t\tPROTO((tree, tree));\n extern tree build_x_function_call\t\tPROTO((tree, tree, tree));\n+extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n extern tree build_function_call_real\t\tPROTO((tree, tree, int, int));\n extern tree build_function_call\t\t\tPROTO((tree, tree));\n extern tree build_function_call_maybe\t\tPROTO((tree, tree));\n@@ -2476,7 +2490,6 @@ extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, i\n extern void c_expand_return\t\t\tPROTO((tree));\n extern tree c_expand_start_case\t\t\tPROTO((tree));\n extern int ptr_reasonably_similar\t\tPROTO((tree, tree));\n-extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n \n /* in typeck2.c */"}, {"sha": "ad3c2080d98ee85f3fcf6692ae1f8317699e6ae0", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -1194,11 +1194,12 @@ cp_convert (type, expr, convtype, flags)\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (e);\n-      /* enum = enum, enum = int, enum = float are all errors.  */\n+      /* enum = enum, enum = int, enum = float, (enum)pointer are all\n+         errors.  */\n       if (flag_int_enum_equivalence == 0\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n-\t  && ARITHMETIC_TYPE_P (intype)\n-\t  && ! (convtype & CONV_STATIC))\n+\t  && ((ARITHMETIC_TYPE_P (intype) && ! (convtype & CONV_STATIC))\n+\t      || (TREE_CODE (intype) == POINTER_TYPE)))\n \t{\n \t  cp_pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n "}, {"sha": "3c41f225e752d45c0730bafac843722b86de68e9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -483,6 +483,7 @@ tree signed_size_zero_node;\n \f\n /* Allocate a level of searching.  */\n \n+static\n struct stack_level *\n push_decl_level (stack, obstack)\n      struct stack_level *stack;\n@@ -762,7 +763,7 @@ suspend_binding_level ()\n   }\n }\n \n-void\n+static void\n resume_binding_level (b)\n      struct binding_level *b;\n {\n@@ -841,7 +842,7 @@ toplevel_bindings_p ()\n \n /* Nonzero if this is a namespace scope.  */\n \n-int\n+static int\n namespace_bindings_p ()\n {\n   return current_binding_level->namespace_p;\n@@ -879,7 +880,7 @@ declare_pseudo_global_level ()\n   current_binding_level->pseudo_global = 1;\n }\n \n-void\n+static void\n declare_namespace_level ()\n {\n   current_binding_level->namespace_p = 1;\n@@ -2351,7 +2352,7 @@ warn_extern_redeclared_static (newdecl, olddecl)\n \n int\n duplicate_decls (newdecl, olddecl)\n-     register tree newdecl, olddecl;\n+     tree newdecl, olddecl;\n {\n   extern struct obstack permanent_obstack;\n   unsigned olddecl_uid = DECL_UID (olddecl);\n@@ -2679,11 +2680,12 @@ duplicate_decls (newdecl, olddecl)\n \t  TREE_TYPE (olddecl) = build_exception_variant (newtype,\n \t\t\t\t\t\t\t TYPE_RAISES_EXCEPTIONS (oldtype));\n \n-\t  if (! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))\n+\t  if ((pedantic || ! DECL_IN_SYSTEM_HEADER (olddecl))\n+\t      && ! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))\n \t    {\n-\t      cp_error (\"declaration of `%D' throws different exceptions...\",\n+\t      cp_pedwarn (\"declaration of `%D' throws different exceptions\",\n \t\t\tnewdecl);\n-\t      cp_error_at (\"...from previous declaration here\", olddecl);\n+\t      cp_pedwarn_at (\"previous declaration here\", olddecl);\n \t    }\n \t}\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n@@ -4275,7 +4277,7 @@ make_typename_type (context, name)\n    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n    Otherwise we prefer non-TYPE_DECLs.  */\n \n-tree\n+static tree\n lookup_name_real (name, prefer_type, nonclass)\n      tree name;\n      int prefer_type, nonclass;\n@@ -4897,6 +4899,9 @@ init_decl_processing ()\n   void_ftype_ptr\n     = build_function_type (void_type_node,\n  \t\t\t   tree_cons (NULL_TREE, ptr_type_node, endlink));\n+  void_ftype_ptr\n+    = build_exception_variant (void_ftype_ptr,\n+\t\t\t       tree_cons (NULL_TREE, NULL_TREE, NULL_TREE));\n \n   float_ftype_float\n     = build_function_type (float_type_node,\n@@ -5659,8 +5664,6 @@ groktypename (typename)\n    to parse initializers.  */\n int debug_temp_inits = 1;\n \n-void start_decl_1 ();\n-\n tree\n start_decl (declarator, declspecs, initialized)\n      tree declarator, declspecs;\n@@ -10145,6 +10148,31 @@ grok_op_properties (decl, virtualp, friendp)\n \t      else\n \t\tcp_error (\"`%D' must take either one or two arguments\", decl);\n \t    }\n+\n+\t  /* More Effective C++ rule 6.  */\n+\t  if (extra_warnings\n+\t      && (name == ansi_opname[(int) POSTINCREMENT_EXPR]\n+\t\t  || name == ansi_opname[(int) POSTDECREMENT_EXPR]))\n+\t    {\n+\t      tree arg = TREE_VALUE (argtypes);\n+\t      tree ret = TREE_TYPE (TREE_TYPE (decl));\n+\t      if (methodp || TREE_CODE (arg) == REFERENCE_TYPE)\n+\t\targ = TREE_TYPE (arg);\n+\t      arg = TYPE_MAIN_VARIANT (arg);\n+\t      if (list_length (argtypes) == 2)\n+\t\t{\n+\t\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n+\t\t      || !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n+\t\t\t\t     arg, 1))\n+\t\t    cp_warning (\"prefix `%D' should return `%T'\", decl,\n+\t\t\t\tbuild_reference_type (arg));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (!comptypes (TYPE_MAIN_VARIANT (ret), arg, 1))\n+\t\t    cp_warning (\"postfix `%D' should return `%T'\", decl, arg);\n+\t\t}\n+\t    }\n \t}\n       else if (unary_op_p (name))\n \t{\n@@ -10165,7 +10193,25 @@ grok_op_properties (decl, virtualp, friendp)\n \t      else\n \t\tcp_error (\"`%D' must take exactly two arguments\", decl);\n \t    }\n-\t}\n+\n+\t  /* More Effective C++ rule 7.  */\n+\t  if (extra_warnings\n+\t      && (name == ansi_opname [TRUTH_ANDIF_EXPR]\n+\t\t  || name == ansi_opname [TRUTH_ORIF_EXPR]\n+\t\t  || name == ansi_opname [COMPOUND_EXPR]))\n+\t    cp_warning (\"user-defined `%D' always evaluates both arguments\",\n+\t\t\tdecl);\n+\t}\n+\n+      /* Effective C++ rule 23.  */\n+      if (extra_warnings\n+\t  && list_length (argtypes) == 3\n+\t  && (name == ansi_opname [PLUS_EXPR]\n+\t      || name == ansi_opname [MINUS_EXPR]\n+\t      || name == ansi_opname [TRUNC_DIV_EXPR]\n+\t      || name == ansi_opname [MULT_EXPR])\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n+\tcp_warning (\"`%D' should return by value\", decl);\n \n       /* 13.4.0.8 */\n       if (argtypes)\n@@ -10465,6 +10511,13 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      continue;\n \t    }\n \n+\t  /* Effective C++ rule 14.  The case of virtual functions but\n+\t     non-virtual dtor is handled in finish_struct_1.  */\n+\t  if (warn_nonvdtor && ! TYPE_VIRTUAL_P (basetype)\n+\t      && TYPE_HAS_DESTRUCTOR (basetype))\n+\t    cp_warning (\"base class `%#T' has a non-virtual destructor\",\n+\t\t\tbasetype);\n+\n \t  /* Note that the BINFO records which describe individual\n \t     inheritances are *not* shared in the lattice!  They\n \t     cannot be shared because a given baseclass may be\n@@ -10990,6 +11043,12 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   if (warn_about_return_type)\n     warning (\"return-type defaults to `int'\");\n \n+  /* Effective C++ rule 15.  See also c_expand_return.  */\n+  if (extra_warnings\n+      && DECL_NAME (decl1) == ansi_opname[(int) MODIFY_EXPR]\n+      && TREE_TYPE (fntype) == void_type_node)\n+    cp_warning (\"`operator=' should return a reference to `*this'\");\n+\n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n   DECL_INITIAL (decl1) = error_mark_node;\n@@ -12045,11 +12104,7 @@ start_method (declspecs, declarator)\n     return NULL_TREE;\n \n   if (IS_SIGNATURE (current_class_type))\n-    {\n-      IS_DEFAULT_IMPLEMENTATION (fndecl) = 1;\n-      /* In case we need this info later.  */\n-      HAS_DEFAULT_IMPLEMENTATION (current_class_type) = 1;\n-    }\n+    IS_DEFAULT_IMPLEMENTATION (fndecl) = 1;\n \n   if (DECL_IN_AGGR_P (fndecl))\n     {"}, {"sha": "570068981bd29cb36b4319825ea454ffb35f4068", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -1698,7 +1698,11 @@ copy_assignment_arg_p (parmtype, virtualp)\n     parmtype = TREE_TYPE (parmtype);\n \n   if ((TYPE_MAIN_VARIANT (parmtype) == current_class_type)\n-      || (virtualp && DERIVED_FROM_P (parmtype, current_class_type)))\n+#if 0\n+      /* Non-standard hack to support old Booch components.  */\n+      || (! virtualp && DERIVED_FROM_P (parmtype, current_class_type))\n+#endif\n+      )\n     return 1;\n \n   return 0;\n@@ -1972,16 +1976,6 @@ get_temp_regvar (type, init)\n   return decl;\n }\n \n-/* Make the macro TEMP_NAME_P available to units which do not\n-   include c-tree.h.  */\n-\n-int\n-temp_name_p (decl)\n-     tree decl;\n-{\n-  return TEMP_NAME_P (decl);\n-}\n-\n /* Finish off the processing of a UNION_TYPE structure.\n    If there are static members, then all members are\n    static, and must be laid out together.  If the\n@@ -2224,8 +2218,10 @@ coerce_delete_type (type)\n       type = build_function_type (TREE_TYPE (type), TREE_CHAIN (arg_types));\n       arg_types = TREE_CHAIN (arg_types);\n     }\n+\n   if (TREE_TYPE (type) != void_type_node)\n     e1 = 1, error (\"`operator delete' must return type `void'\");\n+\n   if (arg_types == NULL_TREE\n       || TREE_VALUE (arg_types) != ptr_type_node)\n     e2 = 1, error (\"`operator delete' takes type `void *' as first parameter\");\n@@ -2249,8 +2245,10 @@ coerce_delete_type (type)\n \t    error (\"`...' invalid in specification of `operator delete'\");\n \t}\n     }\n+\n   if (e3)\n-    arg_types = tree_cons (NULL_TREE, ptr_type_node, build_tree_list (NULL_TREE, sizetype));\n+    arg_types = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t   build_tree_list (NULL_TREE, sizetype));\n   else if (e3 |= e2)\n     {\n       if (arg_types == NULL_TREE)\n@@ -2663,7 +2661,7 @@ extern tree maybe_templates;\n extern struct obstack permanent_obstack;\n extern tree get_id_2 ();\n \n-tree\n+static tree\n get_sentry (base)\n      tree base;\n {"}, {"sha": "37f6dfea6c74bbc6e8585f785ace62ebd7e73706", "filename": "gcc/cp/except.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -223,8 +223,6 @@ do_function_call (func, params, return_type)\n \n /* ========================================================================= */\n \n-extern tree auto_function PROTO((tree, tree, enum built_in_function));\n-\n /* sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.\n \n@@ -531,7 +529,8 @@ expand_start_catch_block (declspecs, declarator)\n    code to handle jumping back to the correct place, and for emitting\n    the label to jump to if this catch block didn't match.  */\n \n-void expand_end_catch_block ()\n+void\n+expand_end_catch_block ()\n {\n   rtx start_region_label_rtx;\n   rtx end_region_label_rtx;\n@@ -1070,7 +1069,6 @@ expand_throw (exp)\n \t}\n       else\n \t{\n-\t  rtx cleanup_insns;\n \t  tree object;\n \n \t  /* Make a copy of the thrown object.  WP 15.1.5  */\n@@ -1088,12 +1086,9 @@ expand_throw (exp)\n \t  object = build_reinterpret_cast (TREE_TYPE (exp), saved_throw_value);\n \t  object = build_indirect_ref (object, NULL_PTR);\n \t  cleanup = maybe_build_cleanup_and_delete (object);\n-\t  if (cleanup)\n-\t    expand_expr (cleanup, const0_rtx, VOIDmode, 0);\n-\t  cleanup_insns = get_insns ();\n \t  end_sequence ();\n \n-\t  if (cleanup && cleanup_insns)\n+\t  if (cleanup)\n \t    {\n \t      cleanup = start_anon_func ();\n "}, {"sha": "7da2d240a6e0294515e966b7e20c0ef1ee378989", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -587,7 +587,12 @@ emit_base_init (t, immediately)\n       if (TREE_PURPOSE (rbase_init_list))\n \tinit = TREE_VALUE (rbase_init_list);\n       else if (TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (base_binfo)))\n-\tinit = NULL_TREE;\n+\t{\n+\t  init = NULL_TREE;\n+\t  if (extra_warnings && copy_args_p (current_function_decl))\n+\t    cp_warning (\"base class `%#T' should be explicitly initialized in the copy constructor\",\n+\t\t\tBINFO_TYPE (base_binfo));\n+\t}\n \n       if (init != void_list_node)\n \t{\n@@ -673,6 +678,11 @@ emit_base_init (t, immediately)\n \t  init = DECL_INITIAL (member);\n \n \t  from_init_list = 0;\n+\n+\t  /* Effective C++ rule 12.  */\n+\t  if (extra_warnings && init == NULL_TREE\n+\t      && TREE_CODE (TREE_TYPE (member)) != ARRAY_TYPE)\n+\t    cp_warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n \t}\n \n       perform_member_init (member, name, init, from_init_list);"}, {"sha": "451f598d5f5694df27e21fdaeab9de4b60009a4d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -1671,12 +1671,13 @@ cons_up_default_function (type, full_name, kind)\n       break;\n \n     case 5:\n-      type = build_type_variant (type, 1, 0);\n-      /* Fall through...  */\n     case 6:\n       retref = 1;\n       declspecs = build_decl_list (NULL_TREE, type);\n \n+      if (kind == 5)\n+\ttype = build_type_variant (type, 1, 0);\n+\n       name = ansi_opname [(int) MODIFY_EXPR];\n \n       argtype = build_reference_type (type);\n@@ -1894,7 +1895,10 @@ get_last_nonwhite_on_line ()\n \n int linemode;\n \n-int handle_cp_pragma ();\n+#ifdef HANDLE_SYSV_PRAGMA\n+static int handle_sysv_pragma ();\n+#endif\n+static int handle_cp_pragma ();\n \n int\n check_newline ()\n@@ -3005,18 +3009,6 @@ real_yylex ()\n \t/* If we did not find a keyword, look for an identifier\n \t   (or a typename).  */\n \n-\tif (strcmp (\"catch\", token_buffer) == 0\n-\t    || strcmp (\"throw\", token_buffer) == 0\n-\t    || strcmp (\"try\", token_buffer) == 0)\n-\t  {\n-\t    static int did_warn = 0;\n-\t    if (! did_warn  && ! flag_exceptions)\n-\t      {\n-\t\tpedwarn (\"`catch', `throw', and `try' are all C++ reserved words\");\n-\t\tdid_warn = 1;\n-\t      }\n-\t  }\n-\n \tif (value == IDENTIFIER || value == TYPESPEC)\n \t  GNU_xref_ref (current_function_decl, token_buffer);\n \n@@ -4259,7 +4251,7 @@ yyerror (string)\n   error (buf, token_buffer);\n }\n \f\n-int\n+static int\n handle_cp_pragma (pname)\n      char *pname;\n {\n@@ -4444,7 +4436,7 @@ handle_cp_pragma (pname)\n /* This function has to be in this file, in order to get at\n    the token types.  */\n \n-int\n+static int\n handle_sysv_pragma (finput, token)\n      FILE *finput;\n      register int token;"}, {"sha": "4600c5c3ae890aa04fd25ee33c98ceeb7f1919d2", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -1664,7 +1664,7 @@ make_thunk (function, delta)\n \n void\n emit_thunk (thunk_fndecl)\n-  tree thunk_fndecl;\n+     tree thunk_fndecl;\n {\n   rtx insns;\n   char buffer[250];\n@@ -1917,7 +1917,7 @@ largest_union_member (type)\n \n /* Generate code for default X(X&) constructor.  */\n \n-void\n+static void\n do_build_copy_constructor (fndecl)\n      tree fndecl;\n {\n@@ -2020,7 +2020,7 @@ do_build_copy_constructor (fndecl)\n   pop_momentary ();\n }\n \n-void\n+static void\n do_build_assign_ref (fndecl)\n      tree fndecl;\n {"}, {"sha": "b538689bfc6f468815002d3808697911fe97130c", "filename": "gcc/cp/new.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fnew.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fnew.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fnew.cc?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -4,3 +4,5 @@\n \n #pragma implementation \"new\"\n #include \"new\"\n+\n+const nothrow_t nothrow = { };"}, {"sha": "6a53feef94117f643e96d0c78e1c8f3339364384", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -3724,8 +3724,12 @@ try_block:\n \t;\n \n handler_seq:\n-\t  /* empty */\n-\t| handler_seq CATCH\n+\t  handler\n+\t| handler_seq handler\n+\t;\n+\n+handler:\n+\t  CATCH\n \t\t{\n \t\t  if (processing_template_decl)\n \t\t    {\n@@ -3734,7 +3738,7 @@ handler_seq:\n \t\t      add_tree ($<ttype>$);\n \t\t    }\n \t\t}\n-\t.pushlevel handler_args\n+\t  .pushlevel handler_args\n \t\t{\n \t\t  if (processing_template_decl)\n \t\t    {\n@@ -3743,7 +3747,7 @@ handler_seq:\n \t\t      last_tree = $<ttype>3;\n \t\t    }\n \t\t}\t  \n-\tcompstmt\n+\t  compstmt\n \t\t{\n \t\t  if (processing_template_decl)\n \t\t    {\n@@ -3754,7 +3758,7 @@ handler_seq:\n \t\t  else\n \t\t    expand_end_catch_block ();\n \t\t}\t  \n-\t.poplevel\n+\t  .poplevel\n \t;\n \n type_specifier_seq:"}, {"sha": "58cb324a74e253808e99ceae152265f6c893c949", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -67,7 +67,7 @@ void pop_template_decls ();\n \n tree classtype_mangled_name ();\n static char * mangle_class_name_for_template ();\n-tree tsubst_expr_values ();\n+static tree tsubst_expr_values ();\n tree most_specialized_class PROTO((tree, tree));\n tree get_class_bindings PROTO((tree, tree, tree));\n tree make_temp_vec PROTO((int));\n@@ -251,7 +251,7 @@ push_template_decl (decl)\n     primary = 1;\n \n   /* Partial specialization.  */\n-  if (TREE_CODE (decl) == TYPE_DECL\n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n       && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n     {\n       tree type = TREE_TYPE (decl);\n@@ -287,7 +287,7 @@ push_template_decl (decl)\n       if (CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n \tcp_error (\"must specialize `%#T' before defining member `%#D'\",\n \t\t  ctx, decl);\n-      if (TREE_CODE (decl) == TYPE_DECL)\n+      if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n \ttmpl = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl));\n       else if (! DECL_TEMPLATE_INFO (decl))\n \t{\n@@ -309,7 +309,7 @@ push_template_decl (decl)\n \n   info = perm_tree_cons (tmpl, args, NULL_TREE);\n \n-  if (TREE_CODE (decl) == TYPE_DECL)\n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n     {\n       CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (tmpl)) = info;\n       DECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n@@ -647,13 +647,13 @@ add_pending_template (d)\n   else\n     ti = DECL_TEMPLATE_INFO (d);\n \n-  if (TREE_LANG_FLAG_0 (ti))\n+  if (TI_PENDING_TEMPLATE_FLAG (ti))\n     return;\n \n   *template_tail = perm_tree_cons\n     (current_function_decl, d, NULL_TREE);\n   template_tail = &TREE_CHAIN (*template_tail);\n-  TREE_LANG_FLAG_0 (ti) = 1;\n+  TI_PENDING_TEMPLATE_FLAG (ti) = 1;\n }\n \n /* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of\n@@ -1359,7 +1359,8 @@ tsubst (t, args, nargs, in_decl)\n   type = TREE_TYPE (t);\n   if (type == unknown_type_node)\n     my_friendly_abort (42);\n-  if (type && TREE_CODE (t) != FUNCTION_DECL)\n+  if (type && TREE_CODE (t) != FUNCTION_DECL\n+      && TREE_CODE (t) != TYPENAME_TYPE)\n     type = tsubst (type, args, nargs, in_decl);\n \n   switch (TREE_CODE (t))\n@@ -2523,6 +2524,9 @@ instantiate_template (tmpl, targ_ptr)\n   /* substitute template parameters */\n   fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr, len, tmpl);\n \n+  if (flag_external_templates)\n+    add_pending_template (fndecl);\n+\n  out:\n   function_maybepermanent_obstack = old_fmp_obstack;\n   pop_obstacks ();\n@@ -3520,7 +3524,7 @@ tsubst_chain (t, argvec)\n   return NULL_TREE;\n }\n \n-tree\n+static tree\n tsubst_expr_values (t, argvec)\n      tree t, argvec;\n {"}, {"sha": "4a2bcbbe7fbf80029c53d43a7a4df4d256ac8dfb", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -38,9 +38,6 @@ extern struct obstack *permanent_obstack;\n tree type_info_type_node;\n tree tinfo_fn_id;\n tree tinfo_fn_type;\n-\n-/* in c-common.c */\n-extern tree combine_strings PROTO((tree));\n \f\n void\n init_rtti_processing ()\n@@ -266,7 +263,7 @@ build_x_typeid (exp)\n   return convert_from_reference (exp);\n }\n \n-tree\n+static tree\n get_tinfo_var (type)\n      tree type;\n {\n@@ -358,7 +355,7 @@ get_tinfo_fn (type)\n   return d;\n }\n \n-tree\n+static tree\n get_typeid_1 (type)\n      tree type;\n {\n@@ -392,7 +389,7 @@ get_typeid (type)\n /* Check whether TEST is null before returning RESULT.  If TEST is used in\n    RESULT, it must have previously had a save_expr applied to it.  */\n \n-tree\n+static tree\n ifnonnull (test, result)\n      tree test, result;\n {"}, {"sha": "23630983e3d2a9ab1a862c38d3459a2732b6c5a9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/824b9a4c454aa73955f1f8c2e2650d9248bcd2b4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=824b9a4c454aa73955f1f8c2e2650d9248bcd2b4", "patch": "@@ -7116,6 +7116,12 @@ c_expand_return (retval)\n       retval = current_class_ptr;\n     }\n \n+  /* Effective C++ rule 15.  See also start_function.  */\n+  if (extra_warnings\n+      && DECL_NAME (current_function_decl) == ansi_opname[(int) MODIFY_EXPR]\n+      && retval != current_class_ref)\n+    cp_warning (\"`operator=' should return a reference to `*this'\");\n+\n   if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;"}]}