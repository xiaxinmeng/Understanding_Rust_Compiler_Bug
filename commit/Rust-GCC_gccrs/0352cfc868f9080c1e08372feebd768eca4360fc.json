{"sha": "0352cfc868f9080c1e08372feebd768eca4360fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1MmNmYzg2OGY5MDgwYzFlMDgzNzJmZWViZDc2OGVjYTQzNjBmYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-30T16:14:58Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-30T16:14:58Z"}, "message": "class.c (build_vtable): Use build_lang_decl when building vtables, not just build_decl.\n\n\t* class.c (build_vtable): Use build_lang_decl when building\n\tvtables, not just build_decl.\n\t(prepare_fresh_vtable): Likewise.\n\t* decl.c (wrapup_globals_for_namespace): Mark vtables as\n\tDECL_EXTERNAL when calling wrapup_global_declarations.\n\t* decl2.c (priority_info_s): Add initializations_p and\n\tdestructions_p members.\n\t(finish_vtable_vardecl): Use TREE_SYMBOL_REFERENCED, not TREE_USED,\n\twhen deciding what vtables to write out.\n\t(ssdf_decls): New variable.\n\t(ssdf_decls_used): Likewise.\n\t(start_static_storage_duration_function): Deal with being called\n\tmultiple times.  Avoid inlining this function.\n\t(generate_inits_for_priority): Deal with reuse of priority map.\n\t(get_priority_info): Clear initializations_p and destructions_p.\n\t(do_static_initialization): Tweak comment.\n\t(do_static_destruction): Likewise.  Fix condition on sentries for\n\tdestruction.\n\t(generate_ctor_or_dtor_function): Call all of the static storage\n\tduration functions.\n\t(generate_ctor_or_dtor_function_for_priority): Check\n\tinitializations_p and destructions_p to see what priorities need\n\tinitialization functions.\n\t(finish_file): Rework to generate multiple static storage duration\n\tfunctions, rather than just one.\n\nFrom-SVN: r26713", "tree": {"sha": "6965f4e433b0b6b93aba9c1755a2c69ed3107fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6965f4e433b0b6b93aba9c1755a2c69ed3107fe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0352cfc868f9080c1e08372feebd768eca4360fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0352cfc868f9080c1e08372feebd768eca4360fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0352cfc868f9080c1e08372feebd768eca4360fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0352cfc868f9080c1e08372feebd768eca4360fc/comments", "author": null, "committer": null, "parents": [{"sha": "3fd91cbd4fe2bcfb7d2db25fe2c2cc2ec2d271b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd91cbd4fe2bcfb7d2db25fe2c2cc2ec2d271b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd91cbd4fe2bcfb7d2db25fe2c2cc2ec2d271b2"}], "stats": {"total": 307, "additions": 190, "deletions": 117}, "files": [{"sha": "cde573458801dcbf4a33e35df3e31f1b9694b139", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0352cfc868f9080c1e08372feebd768eca4360fc", "patch": "@@ -1,5 +1,31 @@\n 1999-04-30  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (build_vtable): Use build_lang_decl when building\n+\tvtables, not just build_decl.\n+\t(prepare_fresh_vtable): Likewise.\n+\t* decl.c (wrapup_globals_for_namespace): Mark vtables as\n+\tDECL_EXTERNAL when calling wrapup_global_declarations.\n+\t* decl2.c (priority_info_s): Add initializations_p and\n+\tdestructions_p members.\n+\t(finish_vtable_vardecl): Use TREE_SYMBOL_REFERENCED, not TREE_USED,\n+\twhen deciding what vtables to write out.\n+\t(ssdf_decls): New variable.\n+\t(ssdf_decls_used): Likewise.\n+\t(start_static_storage_duration_function): Deal with being called\n+\tmultiple times.  Avoid inlining this function.\n+\t(generate_inits_for_priority): Deal with reuse of priority map.\n+\t(get_priority_info): Clear initializations_p and destructions_p.\n+\t(do_static_initialization): Tweak comment.\n+\t(do_static_destruction): Likewise.  Fix condition on sentries for\n+\tdestruction. \n+\t(generate_ctor_or_dtor_function): Call all of the static storage\n+\tduration functions.\n+\t(generate_ctor_or_dtor_function_for_priority): Check\n+\tinitializations_p and destructions_p to see what priorities need\n+\tinitialization functions.\n+\t(finish_file): Rework to generate multiple static storage duration\n+\tfunctions, rather than just one.\n+\t\n \t* typeck.c (build_const_cast): Tweak last change to handle\n \ttemplates correctly.\n "}, {"sha": "d3d544f05e5f52369deed251b0ca00a9a8b67d58", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0352cfc868f9080c1e08372feebd768eca4360fc", "patch": "@@ -712,7 +712,7 @@ build_vtable (binfo, type)\n       tree offset;\n \n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n-      decl = build_decl (VAR_DECL, name, TREE_TYPE (BINFO_VTABLE (binfo)));\n+      decl = build_lang_decl (VAR_DECL, name, TREE_TYPE (BINFO_VTABLE (binfo)));\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n@@ -722,7 +722,7 @@ build_vtable (binfo, type)\n   else\n     {\n       virtuals = NULL_TREE;\n-      decl = build_decl (VAR_DECL, name, void_type_node);\n+      decl = build_lang_decl (VAR_DECL, name, void_type_node);\n     }\n \n #ifdef GATHER_STATISTICS\n@@ -872,7 +872,7 @@ prepare_fresh_vtable (binfo, for_type)\n       buf2 = new_buf2;\n     }\n \n-  new_decl = build_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n+  new_decl = build_lang_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n   /* Remember which class this vtable is really for.  */\n   DECL_CONTEXT (new_decl) = for_type;\n "}, {"sha": "b37dbc8e6bc529d096dd84688fbb5854979444e8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0352cfc868f9080c1e08372feebd768eca4360fc", "patch": "@@ -1988,6 +1988,7 @@ wrapup_globals_for_namespace (namespace, data)\n   int len = list_length (globals);\n   tree *vec = (tree *) alloca (sizeof (tree) * len);\n   int i;\n+  int result;\n   tree decl;\n   int last_time = (data != 0);\n \n@@ -2001,11 +2002,35 @@ wrapup_globals_for_namespace (namespace, data)\n   for (i = 0, decl = globals; i < len; i++, decl = TREE_CHAIN (decl))\n     vec[len - i - 1] = decl;\n   \n-  if (!last_time)\n-    return wrapup_global_declarations (vec, len);\n+  if (last_time)\n+    {\n+      check_global_declarations (vec, len);\n+      return 0;\n+    }\n \n-  check_global_declarations (vec, len);\n-  return 0;\n+  /* Temporarily mark vtables as external.  That prevents\n+     wrapup_global_declarations from writing them out; we must process\n+     them ourselves in finish_vtable_vardecl.  */\n+  for (i = 0; i < len; ++i)\n+    if (vtable_decl_p (vec[i], /*data=*/0))\n+      {\n+\tDECL_NOT_REALLY_EXTERN (vec[i]) = 1;\n+\tDECL_EXTERNAL (vec[i]) = 1;\n+      }\n+\n+  /* Write out any globals that need to be output.  */\n+  result = wrapup_global_declarations (vec, len);\n+\n+  /* Undo the hack to DECL_EXTERNAL above.  */\n+  for (i = 0; i < len; ++i)\n+    if (vtable_decl_p (vec[i], /*data=*/0)\n+\t&& DECL_NOT_REALLY_EXTERN (vec[i]))\n+      {\n+\tDECL_NOT_REALLY_EXTERN (vec[i]) = 0;\n+\tDECL_EXTERNAL (vec[i]) = 0;\n+      }\n+\n+  return result;\n }\n \n \f"}, {"sha": "79261a0f7f105bc3b11e8246e21b5f628a9814cd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 132, "deletions": 110, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0352cfc868f9080c1e08372feebd768eca4360fc/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0352cfc868f9080c1e08372feebd768eca4360fc", "patch": "@@ -59,6 +59,12 @@ typedef struct priority_info_s {\n   /* A label indicating where we should generate the next destruction\n      with this priority.  */\n   rtx destruction_sequence;\n+  /* Non-zero if there have been any initializations at this priority\n+     throughout the translation unit.  */\n+  int initializations_p;\n+  /* Non-zero if there have been any destructions at this priority\n+     throughout the translation unit.  */\n+  int destructions_p;\n } *priority_info;\n \n static tree get_sentry PROTO((tree));\n@@ -2655,7 +2661,9 @@ finish_vtable_vardecl (t, data)\n   import_export_vtable (vars, ctype, 1);\n \n   if (! DECL_EXTERNAL (vars)\n-      && (DECL_INTERFACE_KNOWN (vars) || TREE_USED (vars))\n+      && (DECL_INTERFACE_KNOWN (vars) \n+\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars))\n+\t  || (hack_decl_function_context (vars) && TREE_USED (vars)))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n       /* Write it out.  */\n@@ -2700,7 +2708,7 @@ finish_vtable_vardecl (t, data)\n \n       return 1;\n     }\n-  else if (! TREE_USED (vars))\n+  else if (! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (vars)))\n     /* We don't know what to do with this one yet.  */\n     return 0;\n \n@@ -2973,6 +2981,11 @@ static tree priority_decl;\n /* The declaration for the static storage duration function.  */\n static tree ssdf_decl;\n \n+/* All the static storage duration functions created in this\n+   translation unit.  */\n+static varray_type ssdf_decls;\n+static size_t ssdf_decls_used;\n+\n /* A map from priority levels to information about that priority\n    level.  There may be many such levels, so efficient lookup is\n    important.  */\n@@ -2993,8 +3006,22 @@ static splay_tree priority_info_map;\n static void\n start_static_storage_duration_function ()\n {\n+  static unsigned ssdf_number;\n+\n   tree parm_types;\n   tree type;\n+  char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\\0' */ + 32];\n+\n+  /* Create the identifier for this function.  It will be of the form\n+     SSDF_IDENTIFIER_<number>.  */\n+  sprintf (id, \"%s_%u\", SSDF_IDENTIFIER, ssdf_number++);\n+  if (ssdf_number == 0)\n+    {\n+      /* Overflow occurred.  That means there are at least 4 billion\n+\t initialization functions.  */\n+      sorry (\"too many initialization functions required\");\n+      my_friendly_abort (19990430);\n+    }\n \n   /* Create the parameters.  */\n   parm_types = void_list_node;\n@@ -3004,11 +3031,35 @@ start_static_storage_duration_function ()\n \n   /* Create the FUNCTION_DECL itself.  */\n   ssdf_decl = build_lang_decl (FUNCTION_DECL, \n-\t\t\t       get_identifier (SSDF_IDENTIFIER),\n+\t\t\t       get_identifier (id),\n \t\t\t       type);\n   TREE_PUBLIC (ssdf_decl) = 0;\n   DECL_ARTIFICIAL (ssdf_decl) = 1;\n-  DECL_INLINE (ssdf_decl) = 1;\n+\n+  /* Put this function in the list of functions to be called from the\n+     static constructors and destructors.  */\n+  if (!ssdf_decls)\n+    {\n+      VARRAY_TREE_INIT (ssdf_decls, 32, \"ssdf_decls\");\n+\n+      /* Take this opportunity to initialize the map from priority\n+\t numbers to information about that priority level. */\n+      priority_info_map = splay_tree_new (splay_tree_compare_ints,\n+\t\t\t\t\t  /*delete_key_fn=*/0,\n+\t\t\t\t\t  /*delete_value_fn=*/\n+\t\t\t\t\t  (splay_tree_delete_value_fn) &free);\n+\n+      /* We always need to generate functions for the\n+\t DEFAULT_INIT_PRIORITY so enter it now.  That way when we walk\n+\t priorities later, we'll be sure to find the\n+\t DEFAULT_INIT_PRIORITY.  */\n+      get_priority_info (DEFAULT_INIT_PRIORITY);\n+    }\n+\n+  if (ssdf_decls_used == ssdf_decls->num_elements)\n+    VARRAY_GROW (ssdf_decls, 2 * ssdf_decls_used);\n+  VARRAY_TREE (ssdf_decls, ssdf_decls_used) = ssdf_decl;\n+  ++ssdf_decls_used;\n \n   /* Create the argument list.  */\n   initialize_p_decl = build_decl (PARM_DECL,\n@@ -3045,12 +3096,10 @@ start_static_storage_duration_function ()\n   push_momentary ();\n   expand_start_bindings (0);\n \n-  /* Initialize the map from priority numbers to information about\n-     that priority level. */\n-  priority_info_map = splay_tree_new (splay_tree_compare_ints,\n-\t\t\t\t      /*delete_key_fn=*/0,\n-\t\t\t\t      /*delete_value_fn=*/\n-\t\t\t\t      (splay_tree_delete_value_fn) &free);\n+  /* This function must not be deferred because we are depending on\n+     its compilation to tell us what is TREE_SYMBOL_REFERENCED.  */\n+  current_function_cannot_inline \n+    = \"static storage duration functions cannot be inlined\";\n }\n \n /* Generate the initialization code for the priority indicated in N.  */\n@@ -3093,6 +3142,8 @@ generate_inits_for_priority (n, data)\n       end_sequence ();\n \n       emit_insn (insns);\n+      pi->initialization_sequence = NULL_RTX;\n+      pi->initializations_p = 1;\n     }\n \n   /* Do the destructions.  */\n@@ -3106,6 +3157,8 @@ generate_inits_for_priority (n, data)\n       end_sequence ();\n \n       emit_insn (insns);\n+      pi->destruction_sequence = NULL_RTX;\n+      pi->destructions_p = 1;\n     }\n   \n   /* Close out the conditionals.  */\n@@ -3154,6 +3207,8 @@ get_priority_info (priority)\n       pi = (priority_info) xmalloc (sizeof (struct priority_info_s));\n       pi->initialization_sequence = NULL_RTX;\n       pi->destruction_sequence = NULL_RTX;\n+      pi->initializations_p = 0;\n+      pi->destructions_p = 0;\n       splay_tree_insert (priority_info_map,\n \t\t\t (splay_tree_key) priority,\n \t\t\t (splay_tree_value) pi);\n@@ -3221,7 +3276,7 @@ do_static_initialization (decl, init, sentry, priority)\n   expand_end_target_temps ();\n \n   /* Cleanup any deferred pops from function calls.  This would be done\n-     by expand_end_cond, but we also need it when !sentry, since we are\n+     by expand_end_cond, but we also need it when !SENTRY, since we are\n      constructing these sequences by parts.  */\n   do_pending_stack_adjust ();\n \n@@ -3266,21 +3321,21 @@ do_static_destruction (decl, sentry, priority)\n      variable in question.  */\n   emit_note (input_filename, lineno);\n   \n-  /* If there's a SENTRY, we only do the initialization if it is\n-     one, i.e., if we are the last to initialize it.  */\n+  /* If there's a SENTRY, we only do the destruction if it is one,\n+     i.e., if we are the last to destroy it.  */\n   if (sentry)\n     expand_start_cond (build_binary_op (EQ_EXPR,\n \t\t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n \t\t\t\t\t\t\tsentry,\n \t\t\t\t\t\t\t/*nonconvert=*/1),\n-\t\t\t\t\tinteger_one_node),\n+\t\t\t\t\tinteger_zero_node),\n \t\t       /*exit_flag=*/0);\n   \n   /* Actually to the destruction.  */\n   expand_expr_stmt (build_cleanup (decl));\n \n   /* Cleanup any deferred pops from function calls.  This would be done\n-     by expand_end_cond, but we also need it when !sentry, since we are\n+     by expand_end_cond, but we also need it when !SENTRY, since we are\n      constructing these sequences by parts.  */\n   do_pending_stack_adjust ();\n \n@@ -3390,6 +3445,7 @@ generate_ctor_or_dtor_function (constructor_p, priority)\n {\n   char function_key;\n   tree arguments;\n+  size_t i;\n \n   /* We use `I' to indicate initialization and `D' to indicate\n      destruction.  */\n@@ -3403,11 +3459,15 @@ generate_ctor_or_dtor_function (constructor_p, priority)\n \n   /* Call the static storage duration function with appropriate\n      arguments.  */\n-  arguments = tree_cons (NULL_TREE, build_int_2 (priority, 0), \n-\t\t\t NULL_TREE);\n-  arguments = tree_cons (NULL_TREE, build_int_2 (constructor_p, 0),\n-\t\t\t arguments);\n-  expand_expr_stmt (build_function_call (ssdf_decl, arguments));\n+  for (i = 0; i < ssdf_decls_used; ++i) \n+    {\n+      arguments = tree_cons (NULL_TREE, build_int_2 (priority, 0), \n+\t\t\t     NULL_TREE);\n+      arguments = tree_cons (NULL_TREE, build_int_2 (constructor_p, 0),\n+\t\t\t     arguments);\n+      expand_expr_stmt (build_function_call (VARRAY_TREE (ssdf_decls, i),\n+\t\t\t\t\t     arguments));\n+    }\n \n   /* If we're generating code for the DEFAULT_INIT_PRIORITY, throw in\n      calls to any functions marked with attributes indicating that\n@@ -3427,28 +3487,23 @@ generate_ctor_or_dtor_function (constructor_p, priority)\n }\n \n /* Generate constructor and destructor functions for the priority\n-   indicated by N.  DATA is really an `int*', and it set to `1' if we\n-   process the DEFAULT_INIT_PRIORITY.  */\n+   indicated by N.  */\n \n static int\n generate_ctor_and_dtor_functions_for_priority (n, data)\n      splay_tree_node n;\n-     void *data;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int priority = (int) n->key;\n   priority_info pi = (priority_info) n->value;\n-  int *did_default_priority_p = (int*) data;\n-\n-  if (priority == DEFAULT_INIT_PRIORITY)\n-    *did_default_priority_p = 1;\n \n   /* Generate the functions themselves, but only if they are really\n      needed.  */\n-  if (pi->initialization_sequence\n+  if (pi->initializations_p\n       || (priority == DEFAULT_INIT_PRIORITY && static_ctors))\n     generate_ctor_or_dtor_function (/*constructor_p=*/1,\n \t\t\t\t    priority);\n-  if (pi->destruction_sequence\n+  if (pi->destructions_p\n       || (priority == DEFAULT_INIT_PRIORITY && static_dtors))\n     generate_ctor_or_dtor_function (/*constructor_p=*/0,\n \t\t\t\t    priority);\n@@ -3467,7 +3522,6 @@ finish_file ()\n {\n   extern int lineno;\n   int start_time, this_time;\n-  int did_default_priority_p = 0;\n   tree vars;\n   int reconsider;\n   size_t i;\n@@ -3509,18 +3563,18 @@ finish_file ()\n   start_time = get_run_time ();\n   permanent_allocation (1);\n \n-  /* Create the function that will contain all initializations and\n-     destructions for objects with static storage duration.  We cannot\n-     conclude that because a symbol is not TREE_SYMBOL_REFERENCED the\n-     corresponding entity is not used until we call finish_function\n-     for the static storage duration function.  We give C linkage to\n-     static constructors and destructors.  */\n-  push_lang_context (lang_name_c);\n-  start_static_storage_duration_function ();\n-  push_to_top_level ();\n-\n   do \n     {\n+      /* We need to start a new initialization function each time\n+\t through the loop.  That's because we need to know which\n+\t vtables have been referenced, and TREE_SYMBOL_REFERENCED\n+\t isn't computed until a function is finished, and written out.\n+\t That's a deficiency in the back-end.  When this is fixed,\n+\t these initialization functions could all become inline, with\n+\t resulting performance improvements.  */\n+      start_static_storage_duration_function ();\n+      push_to_top_level ();\n+\n       reconsider = 0;\n \n       /* If there are templates that we've put off instantiating, do\n@@ -3560,8 +3614,11 @@ finish_file ()\n \t  reconsider = 1;\n \t  vars = TREE_CHAIN (vars);\n \t}\n-      push_to_top_level ();\n       \n+      /* Finish up the static storage duration function for this\n+         round.  */\n+      finish_static_storage_duration_function ();\n+\n       /* Go through the various inline functions, and see if any need\n \t synthesizing.  */\n       for (i = 0; i < saved_inlines_used; ++i)\n@@ -3586,89 +3643,31 @@ finish_file ()\n \t      reconsider = 1;\n \t    }\n \t}\n-    } \n-  while (reconsider);\n-\n-  /* Finish up the static storage duration function, now that we now\n-     there can be no more things in need of initialization or\n-     destruction.  */\n-  pop_from_top_level ();\n-  finish_static_storage_duration_function ();\n-\n-  /* Generate initialization and destruction functions for all\n-     priorities for which they are required.  */\n-  if (priority_info_map)\n-    splay_tree_foreach (priority_info_map, \n-\t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n-\t\t\t&did_default_priority_p);\n-\n-  if (!did_default_priority_p) \n-    {\n-      /* Even if there were no explicit initializations or\n-\t destructions required, we may still have to handle the\n-\t default priority if there functions declared as constructors\n-\t or destructors via attributes.  */\n-      if (static_ctors)\n-\tgenerate_ctor_or_dtor_function (/*constructor_p=*/1, \n-\t\t\t\t\tDEFAULT_INIT_PRIORITY);\n-      if (static_dtors)\n-\tgenerate_ctor_or_dtor_function (/*constructor_p=*/0, \n-\t\t\t\t\tDEFAULT_INIT_PRIORITY);\n-    }\n-\n-  /* We're done with the splay-tree now.  */\n-  if (priority_info_map)\n-    splay_tree_delete (priority_info_map);\n-\n-  /* We're done with static constructors, so we can go back to \"C++\"\n-     linkage now.  */\n-  pop_lang_context ();\n-\n-  /* Mark all functions that might deal with exception-handling as\n-     referenced.  */\n-  mark_all_runtime_matches ();\n-\n-  /* Now delete from the chain of variables all virtual function tables.\n-     We output them all ourselves, because each will be treated\n-     specially.  */\n-  walk_globals (vtable_decl_p, prune_vtable_vardecl, /*data=*/0);\n \n-  /* We'll let wrapup_global_declarations handle the inline functions,\n-     but it will be fooled by DECL_NOT_REALL_EXTERN funtions, so we\n-     fix them up here.  */\n-  for (i = 0; i < saved_inlines_used; ++i)\n-    {\n-      tree decl = VARRAY_TREE (saved_inlines, i);\n-      \n-      if (DECL_NOT_REALLY_EXTERN (decl) && !DECL_COMDAT (decl)\n-\t  && DECL_INITIAL (decl)) \n-\tDECL_EXTERNAL (decl) = 0;\n-    }\n+      /* Mark all functions that might deal with exception-handling as\n+\t referenced.  */\n+      mark_all_runtime_matches ();\n \n-  /* We haven't handled non-local objects that don't need dynamic\n-     initialization.  Do that now.  */\n-  do\n-    {\n-      reconsider = 0;\n-\n-      /* Above, we hung back on weak functions; they will be defined\n-\t where they are needed.  But, here we loop again, so that we\n-\t output the things that *are* needed.  */\n+      /* We lie to the back-end, pretending that some functions are\n+\t not defined when they really are.  This keeps these functions\n+\t from being put out unncessarily.  But, we must stop lying\n+\t when the functions are referenced, or if they are not comdat\n+\t since they need to be put out now.  */\n       for (i = 0; i < saved_inlines_used; ++i)\n \t{\n \t  tree decl = VARRAY_TREE (saved_inlines, i);\n       \n \t  if (DECL_NOT_REALLY_EXTERN (decl)\n \t      && DECL_INITIAL (decl)\n-\t      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t      && (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n+\t\t  || !DECL_COMDAT (decl)))\n \t    DECL_EXTERNAL (decl) = 0;\n \t}\n \n       if (saved_inlines_used\n \t  && wrapup_global_declarations (&VARRAY_TREE (saved_inlines, 0),\n \t\t\t\t\t saved_inlines_used))\n \treconsider = 1;\n-\n       if (walk_namespaces (wrapup_globals_for_namespace, /*data=*/0))\n \treconsider = 1;\n \n@@ -3686,9 +3685,32 @@ finish_file ()\n \t  && wrapup_global_declarations (&VARRAY_TREE (pending_statics, 0),\n \t\t\t\t\t pending_statics_used))\n \treconsider = 1;\n-    }\n+    } \n   while (reconsider);\n \n+  /* We give C linkage to static constructors and destructors.  */\n+  push_lang_context (lang_name_c);\n+\n+  /* Generate initialization and destruction functions for all\n+     priorities for which they are required.  */\n+  if (priority_info_map)\n+    splay_tree_foreach (priority_info_map, \n+\t\t\tgenerate_ctor_and_dtor_functions_for_priority,\n+\t\t\t/*data=*/0);\n+\n+  /* We're done with the splay-tree now.  */\n+  if (priority_info_map)\n+    splay_tree_delete (priority_info_map);\n+\n+  /* We're done with static constructors, so we can go back to \"C++\"\n+     linkage now.  */\n+  pop_lang_context ();\n+\n+  /* Now delete from the chain of variables all virtual function tables.\n+     We output them all ourselves, because each will be treated\n+     specially.  */\n+  walk_globals (vtable_decl_p, prune_vtable_vardecl, /*data=*/0);\n+\n   /* Now, issue warnings about static, but not defined, functions,\n      etc.  */\n   walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);"}]}