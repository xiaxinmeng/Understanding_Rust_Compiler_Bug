{"sha": "60838d634634a70d65a126166c944b159ac7649c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA4MzhkNjM0NjM0YTcwZDY1YTEyNjE2NmM5NDRiMTU5YWM3NjQ5Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T15:33:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T15:33:49Z"}, "message": "Consider building nodes from scalars in vect_slp_analyze_node_operations\n\nIf the statements in an SLP node aren't similar enough to be vectorised,\nor aren't something the vectoriser has code to handle, the BB vectoriser\ntries building the vector from scalars instead.  This patch does the\nsame thing if we're able to build a viable-looking tree but fail later\nduring the analysis phase, e.g. because the target doesn't support a\nparticular vector operation.\n\nThis is needed to avoid regressions with a later patch.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-slp.c (vect_contains_pattern_stmt_p): New function.\n\t(vect_slp_convert_to_external): Likewise.\n\t(vect_slp_analyze_node_operations): If analysis fails, try building\n\tthe node from scalars instead.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-div-2.c: New test.\n\nFrom-SVN: r278246", "tree": {"sha": "b64a9b2ac2d31399b5c1c0dee684a6cc4ad1818b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b64a9b2ac2d31399b5c1c0dee684a6cc4ad1818b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60838d634634a70d65a126166c944b159ac7649c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60838d634634a70d65a126166c944b159ac7649c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60838d634634a70d65a126166c944b159ac7649c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60838d634634a70d65a126166c944b159ac7649c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c437a108a14b9bdc44659c131b0da944e5ffeab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c437a108a14b9bdc44659c131b0da944e5ffeab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c437a108a14b9bdc44659c131b0da944e5ffeab"}], "stats": {"total": 83, "additions": 83, "deletions": 0}, "files": [{"sha": "4bccc164947b34b8833444b0d79e94a9c067b014", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60838d634634a70d65a126166c944b159ac7649c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60838d634634a70d65a126166c944b159ac7649c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60838d634634a70d65a126166c944b159ac7649c", "patch": "@@ -1,3 +1,10 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-slp.c (vect_contains_pattern_stmt_p): New function.\n+\t(vect_slp_convert_to_external): Likewise.\n+\t(vect_slp_analyze_node_operations): If analysis fails, try building\n+\tthe node from scalars instead.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-cfg.c (verify_gimple_assign_unary): Handle conversions"}, {"sha": "5af7ea02e5f0bc7c100ece619d49ef71c1a8356c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60838d634634a70d65a126166c944b159ac7649c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60838d634634a70d65a126166c944b159ac7649c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60838d634634a70d65a126166c944b159ac7649c", "patch": "@@ -1,3 +1,7 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/bb-slp-div-2.c: New test.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/bb-slp-pr69907.c: Do not expect BB vectorization"}, {"sha": "715c22ac6c61fe94fce52a6ff75f31c9bdc63ed5", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-div-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60838d634634a70d65a126166c944b159ac7649c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-div-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60838d634634a70d65a126166c944b159ac7649c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-div-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-div-2.c?ref=60838d634634a70d65a126166c944b159ac7649c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+int x[4], y[4], z[4];\n+\n+void\n+f (void)\n+{\n+  x[0] += y[0] / z[0] * 2;\n+  x[1] += y[1] / z[1] * 2;\n+  x[2] += y[2] / z[2] * 2;\n+  x[3] += y[3] / z[3] * 2;\n+}\n+\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" { target vect_int } } } */"}, {"sha": "1c1e5022c968b905ed264994465d517e8e2ff201", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60838d634634a70d65a126166c944b159ac7649c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60838d634634a70d65a126166c944b159ac7649c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=60838d634634a70d65a126166c944b159ac7649c", "patch": "@@ -224,6 +224,19 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n }\n \n \n+/* Return true if STMTS contains a pattern statement.  */\n+\n+static bool\n+vect_contains_pattern_stmt_p (vec<stmt_vec_info> stmts)\n+{\n+  stmt_vec_info stmt_info;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (stmts, i, stmt_info)\n+    if (is_pattern_stmt_p (stmt_info))\n+      return true;\n+  return false;\n+}\n+\n /* Find the place of the data-ref in STMT_INFO in the interleaving chain\n    that starts from FIRST_STMT_INFO.  Return -1 if the data-ref is not a part\n    of the chain.  */\n@@ -2694,6 +2707,39 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n   return vect_analyze_stmt (stmt_info, &dummy, node, node_instance, cost_vec);\n }\n \n+/* Try to build NODE from scalars, returning true on success.\n+   NODE_INSTANCE is the SLP instance that contains NODE.  */\n+\n+static bool\n+vect_slp_convert_to_external (vec_info *vinfo, slp_tree node,\n+\t\t\t      slp_instance node_instance)\n+{\n+  stmt_vec_info stmt_info;\n+  unsigned int i;\n+\n+  if (!is_a <bb_vec_info> (vinfo)\n+      || node == SLP_INSTANCE_TREE (node_instance)\n+      || vect_contains_pattern_stmt_p (SLP_TREE_SCALAR_STMTS (node)))\n+    return false;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Building vector operands from scalars instead\\n\");\n+\n+  /* Don't remove and free the child nodes here, since they could be\n+     referenced by other structures.  The analysis and scheduling phases\n+     (need to) ignore child nodes of anything that isn't vect_internal_def.  */\n+  unsigned int group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+  SLP_TREE_DEF_TYPE (node) = vect_external_def;\n+  SLP_TREE_SCALAR_OPS (node).safe_grow (group_size);\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n+    {\n+      tree lhs = gimple_get_lhs (vect_orig_stmt (stmt_info)->stmt);\n+      SLP_TREE_SCALAR_OPS (node)[i] = lhs;\n+    }\n+  return true;\n+}\n+\n /* Analyze statements contained in SLP tree NODE after recursively analyzing\n    the subtree.  NODE_INSTANCE contains NODE and VINFO contains INSTANCE.\n \n@@ -2720,6 +2766,13 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n     {\n       SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n \t= SLP_TREE_NUMBER_OF_VEC_STMTS (*leader);\n+      /* Cope with cases in which we made a late decision to build the\n+\t node from scalars.  */\n+      if (SLP_TREE_DEF_TYPE (*leader) == vect_external_def\n+\t  && vect_slp_convert_to_external (vinfo, node, node_instance))\n+\t;\n+      else\n+\tgcc_assert (SLP_TREE_DEF_TYPE (node) == SLP_TREE_DEF_TYPE (*leader));\n       return true;\n     }\n \n@@ -2779,6 +2832,11 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n     if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n       STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]) = dt[j];\n \n+  /* If this node can't be vectorized, try pruning the tree here rather\n+     than felling the whole thing.  */\n+  if (!res && vect_slp_convert_to_external (vinfo, node, node_instance))\n+    res = true;\n+\n   return res;\n }\n "}]}