{"sha": "5751cf6fef34bcadf288b8d02e287d0bb1520b99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1MWNmNmZlZjM0YmNhZGYyODhiOGQwMmUyODdkMGJiMTUyMGI5OQ==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2009-11-30T23:34:33Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2009-11-30T23:34:33Z"}, "message": "re PR libffi/35484 (libffi doesn't support AIX 64bit)\n\n2009-11-30  David Edelsohn  <edelsohn@gnu.org>\n\n        PR target/35484\n        * src/powerpc/ffitarget.h (POWERPC64): Define for PPC64 Linux and\n        AIX64.\n        * src/powerpc/aix.S: Implement AIX64 version.\n        * src/powerpc/aix_closure.S: Implement AIX64 version.\n        (ffi_closure_ASM): Use extsb, lha and displament addresses.\n        * src/powerpc/ffi_darwin.c (ffi_prep_args): Implement AIX64\n        support.\n        (ffi_prep_cif_machdep): Same.\n        (ffi_call): Same.\n        (ffi_closure_helper_DARWIN): Same.\n\nFrom-SVN: r154855", "tree": {"sha": "abc3b22bd91bc9b3d8d8907ee5124199c36b3a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abc3b22bd91bc9b3d8d8907ee5124199c36b3a6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5751cf6fef34bcadf288b8d02e287d0bb1520b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5751cf6fef34bcadf288b8d02e287d0bb1520b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5751cf6fef34bcadf288b8d02e287d0bb1520b99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5751cf6fef34bcadf288b8d02e287d0bb1520b99/comments", "author": null, "committer": null, "parents": [{"sha": "17f35e23325426fb3f95070cd3218c0b4f87c5a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f35e23325426fb3f95070cd3218c0b4f87c5a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f35e23325426fb3f95070cd3218c0b4f87c5a0"}], "stats": {"total": 545, "additions": 468, "deletions": 77}, "files": [{"sha": "c93d0b7357419e48f8d5a7953cff951b3de9fbee", "filename": "libffi/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=5751cf6fef34bcadf288b8d02e287d0bb1520b99", "patch": "@@ -1,3 +1,17 @@\n+2009-11-30  David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR target/35484\n+\t* src/powerpc/ffitarget.h (POWERPC64): Define for PPC64 Linux and\n+\tAIX64.\n+\t* src/powerpc/aix.S: Implement AIX64 version.\n+\t* src/powerpc/aix_closure.S: Implement AIX64 version.\n+\t(ffi_closure_ASM): Use extsb, lha and displament addresses.\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_args): Implement AIX64\n+\tsupport.\n+\t(ffi_prep_cif_machdep): Same.\n+\t(ffi_call): Same.\n+\t(ffi_closure_helper_DARWIN): Same.\n+\n 2009-11-02  Andreas Tobler  <a.tobler@schweiz.org>\n \n \tPR libffi/41908"}, {"sha": "7b73999f2a7ccb144ca1d14249d6f10292823d5c", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 144, "deletions": 21, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=5751cf6fef34bcadf288b8d02e287d0bb1520b99", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   aix.S - Copyright (c) 2002 Free Software Foundation, Inc.\n+   aix.S - Copyright (c) 2002,2009 Free Software Foundation, Inc.\n    based on darwin.S by John Hornkvist\n \n    PowerPC Assembly glue.\n@@ -86,20 +86,138 @@\n #define L(x) x\n \t.file \"aix.S\"\n \t.toc\n-\t.csect .text[PR]\n-\t.align 2\n-.globl ffi_prep_args\n+\n+\t/* void ffi_call_AIX(extended_cif *ecif, unsigned long bytes,\n+\t *\t\t     unsigned int flags, unsigned int *rvalue,\n+\t *\t\t     void (*fn)(),\n+\t *\t\t     void (*prep_args)(extended_cif*, unsigned *const));\n+\t * r3=ecif, r4=bytes, r5=flags, r6=rvalue, r7=fn, r8=prep_args\n+\t */\n \n .csect .text[PR]\n \t.align 2\n \t.globl ffi_call_AIX\n \t.globl .ffi_call_AIX\n .csect ffi_call_AIX[DS]\n ffi_call_AIX:\n+#ifdef __64BIT__\n+\t.llong .ffi_call_AIX, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_call_AIX:\n+\tmr\tr12,r8 // We only need r12 until the call, so it doesn't have to be saved...\n+\t/* Save the old stack pointer as AP.  */\n+\tmr\tr8,r1\n+\n+\t/* Allocate the stack space we need.  */\n+\tstdux\tr1,r1,r4\n+\n+\t/* Save registers we use.  */\n+\tmflr\tr9\n+\n+\tstd\tr28,-32(r8)\n+\tstd\tr29,-24(r8)\n+\tstd\tr30,-16(r8)\n+\tstd\tr31, -8(r8)\n+\n+\tstd\tr9, 16(r8)\n+\tstd\tr2, 40(r1)\n+\n+\t/* Save arguments over call...  */\n+\tmr\tr31,r5\t/* flags, */\n+\tmr\tr30,r6\t/* rvalue, */\n+\tmr\tr29,r7\t/* function address, */\n+\tmr\tr28,r8\t/* our AP. */\n+\n+\t/* Call ffi_prep_args.  */\n+\tmr\tr4,r1\n+\tli\tr9,0\n+\n+\tld\tr2,8(r12)\n+\tld\tr12,0(r12)\n+\tmtctr\tr12 // r12 holds address of _ffi_prep_args\n+\tbctrl\n+\tld\tr2,40(r1)\n+\n+\t/* Now do the call.  */\n+\tld\tr12,0(r29)\n+\t/* Set up cr1 with bits 4-7 of the flags.  */\n+\tmtcrf\t0x40,r31\n+\tstd\tr2,40(r1)\n+\tmtctr\tr12\n+\tld\tr2,8(r29)\n+\t/* Load all those argument registers.  */\n+\t// We have set up a nice stack frame, just load it into registers.\n+\tld\tr3, 40+(1*8)(r1)\n+\tld\tr4, 40+(2*8)(r1)\n+\tld\tr5, 40+(3*8)(r1)\n+\tld\tr6, 40+(4*8)(r1)\n+\tnop\n+\tld\tr7, 40+(5*8)(r1)\n+\tld\tr8, 40+(6*8)(r1)\n+\tld\tr9, 40+(7*8)(r1)\n+\tld\tr10,40+(8*8)(r1)\n+\n+L1:\n+\t/* Load all the FP registers.  */\n+\tbf\t6,L2 // 2f + 0x18\n+\tlfd\tf1,-32-(13*8)(r28)\n+\tlfd\tf2,-32-(12*8)(r28)\n+\tlfd\tf3,-32-(11*8)(r28)\n+\tlfd\tf4,-32-(10*8)(r28)\n+\tnop\n+\tlfd\tf5,-32-(9*8)(r28)\n+\tlfd\tf6,-32-(8*8)(r28)\n+\tlfd\tf7,-32-(7*8)(r28)\n+\tlfd\tf8,-32-(6*8)(r28)\n+\tnop\n+\tlfd\tf9,-32-(5*8)(r28)\n+\tlfd\tf10,-32-(4*8)(r28)\n+\tlfd\tf11,-32-(3*8)(r28)\n+\tlfd\tf12,-32-(2*8)(r28)\n+\tnop\n+\tlfd\tf13,-32-(1*8)(r28)\n+\n+L2:\n+\t/* Make the call.  */\n+\tbctrl\n+\tld\tr2,40(r1)\n+\n+\t/* Now, deal with the return value.  */\n+\tmtcrf\t0x01,r31\n+\n+\tbt\t30,L(done_return_value)\n+\tbt\t29,L(fp_return_value)\n+\tstd\tr3,0(r30)\n+\tbf\t28,L(done_return_value)\n+\tstd\tr4,4(r30)\n+\n+\t/* Fall through...  */\n+\n+L(done_return_value):\n+\t/* Restore the registers we used and return.  */\n+\tld\tr9,16(r28)\n+\tld\tr31,-8(r28)\n+\tmtlr\tr9\n+\tld\tr30,-16(r28)\n+\tld\tr29,-24(r28)\n+\tld\tr28,-32(r28)\n+\tld\tr1,0(r1)\n+\tblr\n+\n+L(fp_return_value):\n+\tbf\t28,L(float_return_value)\n+\tstfd\tf1,0(r30)\n+\tb\tL(done_return_value)\n+L(float_return_value):\n+\tstfs\tf1,0(r30)\n+\tb\tL(done_return_value)\n+\n+#else /* ! __64BIT__ */\n+\t\n \t.long .ffi_call_AIX, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_call_AIX:\n-\tmr      r12,r8 // We only need r12 until the call, so it doesn't have to be saved...\n+\tmr\tr12,r8 // We only need r12 until the call, so it doesn't have to be saved...\n \t/* Save the old stack pointer as AP.  */\n \tmr\tr8,r1\n \n@@ -142,15 +260,15 @@ ffi_call_AIX:\n \tlwz\tr2,4(r29)\n \t/* Load all those argument registers.  */\n \t// We have set up a nice stack frame, just load it into registers.\n-\tlwz     r3, 20+(1*4)(r1)\n-\tlwz     r4, 20+(2*4)(r1)\n-\tlwz     r5, 20+(3*4)(r1)\n-\tlwz     r6, 20+(4*4)(r1)\n+\tlwz\tr3, 20+(1*4)(r1)\n+\tlwz\tr4, 20+(2*4)(r1)\n+\tlwz\tr5, 20+(3*4)(r1)\n+\tlwz\tr6, 20+(4*4)(r1)\n \tnop\n-\tlwz     r7, 20+(5*4)(r1)\n-\tlwz     r8, 20+(6*4)(r1)\n-\tlwz     r9, 20+(7*4)(r1)\n-\tlwz     r10,20+(8*4)(r1)\n+\tlwz\tr7, 20+(5*4)(r1)\n+\tlwz\tr8, 20+(6*4)(r1)\n+\tlwz\tr9, 20+(7*4)(r1)\n+\tlwz\tr10,20+(8*4)(r1)\n \n L1:\n \t/* Load all the FP registers.  */\n@@ -165,17 +283,17 @@ L1:\n \tlfd\tf7,-16-(7*8)(r28)\n \tlfd\tf8,-16-(6*8)(r28)\n \tnop\n-\tlfd     f9,-16-(5*8)(r28)\n-\tlfd     f10,-16-(4*8)(r28)\n-\tlfd     f11,-16-(3*8)(r28)\n-\tlfd     f12,-16-(2*8)(r28)\n+\tlfd\tf9,-16-(5*8)(r28)\n+\tlfd\tf10,-16-(4*8)(r28)\n+\tlfd\tf11,-16-(3*8)(r28)\n+\tlfd\tf12,-16-(2*8)(r28)\n \tnop\n-\tlfd     f13,-16-(1*8)(r28)\n+\tlfd\tf13,-16-(1*8)(r28)\n \n L2:\n \t/* Make the call.  */\n \tbctrl\n-\tlwz r2,20(r1)\n+\tlwz\tr2,20(r1)\n \n \t/* Now, deal with the return value.  */\n \tmtcrf\t0x01,r31\n@@ -190,8 +308,8 @@ L2:\n \n L(done_return_value):\n \t/* Restore the registers we used and return.  */\n-\tlwz\tr9,   8(r28)\n-\tlwz\tr31,  -4(r28)\n+\tlwz\tr9,8(r28)\n+\tlwz\tr31,-4(r28)\n \tmtlr\tr9\n \tlwz\tr30, -8(r28)\n \tlwz\tr29,-12(r28)\n@@ -206,6 +324,7 @@ L(fp_return_value):\n L(float_return_value):\n \tstfs\tf1,0(r30)\n \tb\tL(done_return_value)\n+#endif\n \t.long 0\n \t.byte 0,0,0,1,128,4,0,0\n //END(ffi_call_AIX)\n@@ -216,7 +335,11 @@ L(float_return_value):\n \t.globl .ffi_call_DARWIN\n .csect ffi_call_DARWIN[DS]\n ffi_call_DARWIN:\n+#ifdef __64BIT__\n+\t.llong .ffi_call_DARWIN, TOC[tc0], 0\n+#else\n \t.long .ffi_call_DARWIN, TOC[tc0], 0\n+#endif\n \t.csect .text[PR]\n .ffi_call_DARWIN:\n \tblr"}, {"sha": "e1a60b468328d34ccd0519e4f26c04ab5fd329de", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 173, "deletions": 19, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=5751cf6fef34bcadf288b8d02e287d0bb1520b99", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   aix_closure.S - Copyright (c) 2002 2003 Free Software Foundation, Inc.\n+   aix_closure.S - Copyright (c) 2002, 2003, 2009 Free Software Foundation, Inc.\n    based on darwin_closure.S\n \n    PowerPC Assembly glue.\n@@ -94,8 +94,162 @@ LC..60:\n \t.globl ffi_closure_ASM\n \t.globl .ffi_closure_ASM\n .csect ffi_closure_ASM[DS]\n-\n ffi_closure_ASM:\n+#ifdef __64BIT__\n+\t.llong .ffi_closure_ASM, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_closure_ASM:\n+\n+\tmflr r0\t\t\t/* extract return address */\n+\tstd r0,16(r1)\t\t/* save the return address */\n+\n+\t/* 48  Bytes (Linkage Area) */\n+\t/* 64  Bytes (params) */\n+\t/* 104 Bytes (13*8 from FPR) */\n+\t/* 32  Bytes (result) */\n+\t/* 248 Bytes */\n+\n+\tstdu r1,-248(r1)\t/* skip over caller save area\n+\t\t\t\t   keep stack aligned to 16  */\n+\n+/* we want to build up an area for the parameters passed */\n+/* in registers (both floating point and integer) */\n+\n+\t/* we store gpr 3 to gpr 10 (aligned to 4)\n+\tin the parents outgoing area  */\n+\tstd   r3, (304+0*8)(r1)\n+\tstd   r4, (304+1*8)(r1)\n+\tstd   r5, (304+2*8)(r1)\n+\tstd   r6, (304+3*8)(r1)\n+\tstd   r7, (304+4*8)(r1)\n+\tstd   r8, (304+5*8)(r1)\n+\tstd   r9, (304+6*8)(r1)\n+\tstd   r10, (304+7*8)(r1)\n+\n+\t/* next save fpr 1 to fpr 13 (aligned to 8) */\n+\tstfd  f1, (112+0*8)(r1)\n+\tstfd  f2, (112+1*8)(r1)\n+\tstfd  f3, (112+2*8)(r1)\n+\tstfd  f4, (112+3*8)(r1)\n+\tstfd  f5, (112+4*8)(r1)\n+\tstfd  f6, (112+5*8)(r1)\n+\tstfd  f7, (112+6*8)(r1)\n+\tstfd  f8, (112+7*8)(r1)\n+\tstfd  f9, (112+8*8)(r1)\n+\tstfd  f10, (112+9*8)(r1)\n+\tstfd  f11, (112+10*8)(r1)\n+\tstfd  f12, (112+11*8)(r1)\n+\tstfd  f13, (112+12*8)(r1)\n+\n+\t/* set up registers for the routine that actually does the work */\n+\t/* get the context pointer from the trampoline */\n+\tmr r3,r11\n+\n+\t/* now load up the pointer to the result storage */\n+\taddi r4,r1,216\n+\n+\t/* now load up the pointer to the saved gpr registers */\n+\taddi r5,r1,304\n+\n+\t/* now load up the pointer to the saved fpr registers */\n+\taddi r6,r1,112\n+\n+\t/* make the call */\n+\tbl .ffi_closure_helper_DARWIN\n+\tnop\n+\n+\t/* now r3 contains the return type */\n+\t/* so use it to look up in a table */\n+\t/* so we know how to deal with each type */\n+\n+\t/* look up the proper starting point in table  */\n+\t/* by using return type as offset */\n+\taddi r5,r1,216\t\t/* get pointer to results area */\n+\tld r4,LC..60(2)\t\t/* get address of jump table */\n+\tsldi r3,r3,2\t\t/* now multiply return type by 4 */\n+\tlwzx r3,r4,r3\t\t/* get the contents of that table value */\n+\tadd r3,r3,r4\t\t/* add contents of table to table address */\n+\tmtctr r3\n+\tbctr\t\t\t/* jump to it */\n+\n+L..60:\n+\t.long L..44-L..60    /* FFI_TYPE_VOID */\n+\t.long L..51-L..60    /* FFI_TYPE_INT */\n+\t.long L..47-L..60    /* FFI_TYPE_FLOAT */\n+\t.long L..46-L..60    /* FFI_TYPE_DOUBLE */\n+\t.long L..45-L..60    /* FFI_TYPE_LONGDOUBLE */\n+\t.long L..56-L..60    /* FFI_TYPE_UINT8 */\n+\t.long L..55-L..60    /* FFI_TYPE_SINT8 */\n+\t.long L..58-L..60    /* FFI_TYPE_UINT16 */\n+\t.long L..57-L..60    /* FFI_TYPE_SINT16 */\n+\t.long L..50-L..60    /* FFI_TYPE_UINT32 */\n+\t.long L..51-L..60    /* FFI_TYPE_SINT32 */\n+\t.long L..48-L..60    /* FFI_TYPE_UINT64 */\n+\t.long L..48-L..60    /* FFI_TYPE_SINT64 */\n+\t.long L..44-L..60    /* FFI_TYPE_STRUCT */\n+\t.long L..48-L..60    /* FFI_TYPE_POINTER */\n+\n+\n+/* case long double */\n+L..45:\n+\tlfd f1,0(r5)\n+\tlfd f2,8(r5)\n+\tb L..44\n+\n+/* case double */\n+L..46:\n+\tlfd f1,0(r5)\n+\tb L..44\n+\n+/* case float */\n+L..47:\n+\tlfs f1,0(r5)\n+\tb L..44\n+\n+/* case long long / pointer */\n+L..48:\n+\tld r3,0(r5)\n+\tb L..44\n+\n+/* case uint32 */\n+L..50:\n+\tlwz r3,4(r5)\n+\tb L..44\n+\n+/* case int / sint32 */\n+L..51:\n+\tlwa r3,4(r5)\n+\tb L..44\n+\n+/* case signed int8 */\n+L..55:\n+\tlbz r3,7(r5)\n+\textsb r3,r3\n+\tb L..44\n+\n+/* case unsigned int8 */\n+L..56:\n+\tlbz r3,7(r5)\n+\tb L..44\n+\n+/* case signed int16 */\n+L..57:\n+\tlha r3,6(r5)\n+\tb L..44\n+\n+/* case unsigned int16 */\n+L..58:\n+\tlhz r3,6(r5)\n+\n+/* case void / done\t */\n+L..44:\n+\taddi r1,r1,248\t\t/* restore stack pointer */\n+\tld r0,16(r1)\t\t/* get return address */\n+\tmtlr r0\t\t\t/* reset link register */\n+\tblr\n+\n+#else /* ! __64BIT__ */\n+\t\n \t.long .ffi_closure_ASM, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_closure_ASM:\n@@ -106,8 +260,8 @@ ffi_closure_ASM:\n \t/* 24 Bytes (Linkage Area) */\n \t/* 32 Bytes (params) */\n \t/* 104 Bytes (13*8 from FPR) */\n-\t/* 8 Bytes (result) */\n-\t/* 168 Bytes */\n+\t/* 16  Bytes (result) */\n+\t/* 176 Bytes */\n \n \tstwu r1,-176(r1)\t/* skip over caller save area\n \t\t\t\tkeep stack aligned to 16  */\n@@ -177,7 +331,7 @@ L..60:\n \t.long L..50-L..60    /* FFI_TYPE_INT */\n \t.long L..47-L..60    /* FFI_TYPE_FLOAT */\n \t.long L..46-L..60    /* FFI_TYPE_DOUBLE */\n-\t.long L..46-L..60    /* FFI_TYPE_LONGDOUBLE */\n+\t.long L..45-L..60    /* FFI_TYPE_LONGDOUBLE */\n \t.long L..56-L..60    /* FFI_TYPE_UINT8 */\n \t.long L..55-L..60    /* FFI_TYPE_SINT8 */\n \t.long L..58-L..60    /* FFI_TYPE_UINT16 */\n@@ -190,6 +344,12 @@ L..60:\n \t.long L..50-L..60    /* FFI_TYPE_POINTER */\n \n \n+/* case long double */\n+L..45:\n+\tlfd f1,0(r5)\n+\tlfd f2,8(r5)\n+\tb L..44\n+\n /* case double */\n L..46:\n \tlfd f1,0(r5)\n@@ -211,37 +371,31 @@ L..50:\n \tlwz r3,0(r5)\n \tb L..44\n \n-/* case signed int8\t */\n+/* case signed int8 */\n L..55:\n-\taddi r5,r5,3\n-\tlbz r3,0(r5)\n-\tslwi r3,r3,24\n-\tsrawi r3,r3,24\n+\tlbz r3,3(r5)\n+\textsb r3,r3\n \tb L..44\n \n-/* case unsigned int8\t */\n+/* case unsigned int8 */\n L..56:\n-\taddi r5,r5,3\n-\tlbz r3,0(r5)\n+\tlbz r3,3(r5)\n \tb L..44\n \n /* case signed int16 */\n L..57:\n-\taddi r5,r5,2\n-\tlhz r3,0(r5)\n-\textsh r3,r3\n+\tlha r3,2(r5)\n \tb L..44\n \n /* case unsigned int16 */\n L..58:\n-\taddi r5,r5,2\n-\tlhz r3,0(r5)\n+\tlhz r3,2(r5)\n \n /* case void / done\t */\n L..44:\n \taddi r1,r1,176\t\t/* restore stack pointer */\n \tlwz r0,8(r1)\t\t/* get return address */\n \tmtlr r0\t\t\t/* reset link register */\n \tblr\n-\n+#endif\n /* END(ffi_closure_ASM) */"}, {"sha": "fd2a37104345b822707e39aee3d2799e5909b229", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 132, "deletions": 36, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=5751cf6fef34bcadf288b8d02e287d0bb1520b99", "patch": "@@ -3,7 +3,7 @@\n \n    Copyright (C) 1998 Geoffrey Keating\n    Copyright (C) 2001 John Hornkvist\n-   Copyright (C) 2002, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n \n    FFI support for Darwin and AIX.\n    \n@@ -80,27 +80,28 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n \n    */\n \n-void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n+void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n \n   /* 'stacktop' points at the previous backchain pointer.  */\n-  unsigned *const stacktop = stack + (bytes / sizeof(unsigned));\n+  unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));\n \n   /* 'fpr_base' points at the space for fpr1, and grows upwards as\n      we use FPR registers.  */\n-  double *fpr_base = (double*) (stacktop - ASM_NEEDS_REGISTERS) - NUM_FPR_ARG_REGISTERS;\n+  double *fpr_base = (double *) ((stacktop - ASM_NEEDS_REGISTERS)\n+\t\t\t\t - NUM_FPR_ARG_REGISTERS);\n   int fparg_count = 0;\n \n \n   /* 'next_arg' grows up as we put parameters in it.  */\n-  unsigned *next_arg = stack + 6; /* 6 reserved positions.  */\n+  unsigned long *next_arg = (unsigned long *) stack + 6; /* 6 reserved positions.  */\n \n-  int i = ecif->cif->nargs;\n+  int i;\n   double double_tmp;\n   void **p_argv = ecif->avalue;\n-  unsigned gprvalue;\n+  unsigned long gprvalue;\n   ffi_type** ptr = ecif->cif->arg_types;\n   char *dest_cpy;\n   unsigned size_al = 0;\n@@ -115,12 +116,10 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n      Return values are referenced by r3, so r4 is the first parameter.  */\n \n   if (flags & FLAG_RETVAL_REFERENCE)\n-    *next_arg++ = (unsigned)(char *)ecif->rvalue;\n+    *next_arg++ = (unsigned long)(char *)ecif->rvalue;\n \n   /* Now for the arguments.  */\n-  for (;\n-       i > 0;\n-       i--, ptr++, p_argv++)\n+  for (i = ecif->cif->nargs; i > 0; i--, ptr++, p_argv++)\n     {\n       switch ((*ptr)->type)\n \t{\n@@ -133,7 +132,11 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t    *(double *)next_arg = double_tmp;\n \t  else\n \t    *fpr_base++ = double_tmp;\n+#ifdef POWERPC64\n \t  next_arg++;\n+#else\n+\t  next_arg += 2;\n+#endif\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n@@ -152,42 +155,69 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  double_tmp = ((double *)*p_argv)[0];\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-\t    *(double *)next_arg = double_tmp;\n+#ifdef POWERPC64\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n+\t    *((long double *) fpr_base)++ = *(long double *) *p_argv;\n \t  else\n-\t    *fpr_base++ = double_tmp;\n+\t    *(long double *) next_arg = *(long double *) *p_argv;\n \t  next_arg += 2;\n-\t  fparg_count++;\n-\t  double_tmp = ((double *)*p_argv)[1];\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-\t    *(double *)next_arg = double_tmp;\n+\t  fparg_count += 2;\n+#else\n+\t  double_tmp = *((double *) *p_argv);\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n+\t    *fpr_base++ = double_tmp;\n \t  else\n+\t    *(double *) next_arg = double_tmp;\n+\n+\t  double_tmp = ((double *) *p_argv)[1];\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n \t    *fpr_base++ = double_tmp;\n+\t  else\n+\t    *(double *) next_arg = double_tmp;\n \t  next_arg += 2;\n \t  fparg_count++;\n+#endif\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n #endif\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-\t  *(long long *)next_arg = *(long long *)*p_argv;\n+#ifdef POWERPC64\n+\t  gprvalue = *(long long *) p_argv;\n+\t  goto putgpr;\n+#else\n+\t  *(long long *) next_arg = *(long long *) *p_argv;\n \t  next_arg+=2;\n+#endif\n \t  break;\n+\tcase FFI_TYPE_POINTER:\n+\t  gprvalue = *(unsigned long *) *p_argv;\n+\t  goto putgpr;\n \tcase FFI_TYPE_UINT8:\n-\t  gprvalue = *(unsigned char *)*p_argv;\n+\t  gprvalue = *(unsigned char *) *p_argv;\n \t  goto putgpr;\n \tcase FFI_TYPE_SINT8:\n-\t  gprvalue = *(signed char *)*p_argv;\n+\t  gprvalue = *(signed char *) *p_argv;\n \t  goto putgpr;\n \tcase FFI_TYPE_UINT16:\n-\t  gprvalue = *(unsigned short *)*p_argv;\n+\t  gprvalue = *(unsigned short *) *p_argv;\n \t  goto putgpr;\n \tcase FFI_TYPE_SINT16:\n-\t  gprvalue = *(signed short *)*p_argv;\n+\t  gprvalue = *(signed short *) *p_argv;\n \t  goto putgpr;\n \n \tcase FFI_TYPE_STRUCT:\n+#ifdef POWERPC64\n+\t  dest_cpy = (char *) next_arg;\n+\t  size_al = (*ptr)->size;\n+\t  if ((*ptr)->elements[0]->type == 3)\n+\t    size_al = ALIGN((*ptr)->size, 8);\n+\t  if (size_al < 3 && ecif->cif->abi == FFI_DARWIN)\n+\t    dest_cpy += 4 - size_al;\n+\n+\t  memcpy ((char *) dest_cpy, (char *) *p_argv, size_al);\n+\t  next_arg += (size_al + 7) / 8;\n+#else\n \t  dest_cpy = (char *) next_arg;\n \n \t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n@@ -204,12 +234,12 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \n \t  memcpy((char *)dest_cpy, (char *)*p_argv, size_al);\n \t  next_arg += (size_al + 3) / 4;\n+#endif\n \t  break;\n \n \tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_POINTER:\n \t  gprvalue = *(unsigned *)*p_argv;\n \tputgpr:\n \t  *next_arg++ = gprvalue;\n@@ -324,6 +354,9 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n     case FFI_TYPE_UINT64:\n     case FFI_TYPE_SINT64:\n+#ifdef POWERPC64\n+    case FFI_TYPE_POINTER:\n+#endif\n       flags |= FLAG_RETURNS_64BITS;\n       break;\n \n@@ -387,11 +420,14 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \tcase FFI_TYPE_STRUCT:\n \t  size_al = (*ptr)->size;\n \t  /* If the first member of the struct is a double, then align\n-\t     the struct to double-word.\n-\t     Type 3 is defined in include/ffi.h. #define FFI_TYPE_DOUBLE 3.  */\n-\t  if ((*ptr)->elements[0]->type == 3)\n+\t     the struct to double-word.  */\n+\t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n \t    size_al = ALIGN((*ptr)->size, 8);\n+#ifdef POWERPC64\n+\t  intarg_count += (size_al + 7) / 8;\n+#else\n \t  intarg_count += (size_al + 3) / 4;\n+#endif\n \t  break;\n \n \tdefault:\n@@ -410,23 +446,32 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n \n   /* Stack space.  */\n+#ifdef POWERPC64\n+  if ((intarg_count + fparg_count) > NUM_GPR_ARG_REGISTERS)\n+    bytes += (intarg_count + fparg_count) * sizeof(long);\n+#else\n   if ((intarg_count + 2 * fparg_count) > NUM_GPR_ARG_REGISTERS)\n     bytes += (intarg_count + 2 * fparg_count) * sizeof(long);\n+#endif\n   else\n     bytes += NUM_GPR_ARG_REGISTERS * sizeof(long);\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n+#ifdef POWERPC64\n+  bytes = (bytes + 31) & -0x1F;\n+#else\n   bytes = (bytes + 15) & ~0xF;\n+#endif\n \n   cif->flags = flags;\n   cif->bytes = bytes;\n \n   return FFI_OK;\n }\n \n-extern void ffi_call_AIX(extended_cif *, unsigned, unsigned, unsigned *,\n+extern void ffi_call_AIX(extended_cif *, long, unsigned, unsigned *,\n \t\t\t void (*fn)(void), void (*fn2)(void));\n-extern void ffi_call_DARWIN(extended_cif *, unsigned, unsigned, unsigned *,\n+extern void ffi_call_DARWIN(extended_cif *, long, unsigned, unsigned *,\n \t\t\t    void (*fn)(void), void (*fn2)(void));\n \n void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n@@ -450,11 +495,11 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n   switch (cif->abi)\n     {\n     case FFI_AIX:\n-      ffi_call_AIX(&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn,\n+      ffi_call_AIX(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,\n \t\t   ffi_prep_args);\n       break;\n     case FFI_DARWIN:\n-      ffi_call_DARWIN(&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn,\n+      ffi_call_DARWIN(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,\n \t\t      ffi_prep_args);\n       break;\n     default:\n@@ -650,7 +695,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   ffi_cif *        cif;\n   double           temp;\n   unsigned         size_al;\n-  union ldu        temp_ld;\n \n   cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n@@ -678,50 +722,81 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t{\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n+#ifdef POWERPC64\n+\t  avalue[i] = (char *) pgr + 7;\n+#else\n \t  avalue[i] = (char *) pgr + 3;\n+#endif\n \t  ng++;\n \t  pgr++;\n \t  break;\n \n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n+#ifdef POWERPC64\n+\t  avalue[i] = (char *) pgr + 6;\n+#else\n \t  avalue[i] = (char *) pgr + 2;\n+#endif\n \t  ng++;\n \t  pgr++;\n \t  break;\n \n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n+#ifdef POWERPC64\n+\t  avalue[i] = (char *) pgr + 4;\n+#else\n \tcase FFI_TYPE_POINTER:\n \t  avalue[i] = pgr;\n+#endif\n \t  ng++;\n \t  pgr++;\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n+#ifdef POWERPC64\n+\t  size_al = arg_types[i]->size;\n+\t  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)\n+\t    size_al = ALIGN (arg_types[i]->size, 8);\n+\t  if (size_al < 3 && cif->abi == FFI_DARWIN)\n+\t    avalue[i] = (void *) pgr + 8 - size_al;\n+\t  else\n+\t    avalue[i] = (void *) pgr;\n+\t  ng += (size_al + 7) / 8;\n+\t  pgr += (size_al + 7) / 8;\n+#else\n \t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n \t     SI 4 bytes) are aligned as if they were those modes.  */\n \t  size_al = arg_types[i]->size;\n \t  /* If the first member of the struct is a double, then align\n-\t     the struct to double-word.\n-\t     Type 3 is defined in include/ffi.h. #define FFI_TYPE_DOUBLE 3.  */\n-\t  if (arg_types[i]->elements[0]->type == 3)\n+\t     the struct to double-word.  */\n+\t  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)\n \t    size_al = ALIGN(arg_types[i]->size, 8);\n \t  if (size_al < 3 && cif->abi == FFI_DARWIN)\n \t    avalue[i] = (void*) pgr + 4 - size_al;\n \t  else\n \t    avalue[i] = (void*) pgr;\n \t  ng += (size_al + 3) / 4;\n \t  pgr += (size_al + 3) / 4;\n+#endif\n \t  break;\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n+#ifdef POWERPC64\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = pgr;\n+\t  ng++;\n+\t  pgr++;\n+\t  break;\n+#else\n \t  /* Long long ints are passed in two gpr's.  */\n \t  avalue[i] = pgr;\n \t  ng += 2;\n \t  pgr += 2;\n \t  break;\n+#endif\n \n \tcase FFI_TYPE_FLOAT:\n \t  /* A float value consumes a GPR.\n@@ -755,13 +830,32 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t      avalue[i] = pgr;\n \t    }\n \t  nf++;\n+#ifdef POWERPC64\n+\t  ng++;\n+\t  pgr++;\n+#else\n \t  ng += 2;\n \t  pgr += 2;\n+#endif\n \t  break;\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \n \tcase FFI_TYPE_LONGDOUBLE:\n+#ifdef POWERPC64\n+\t  if (nf < NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = pgr;\n+\t    }\n+\t  nf += 2;\n+\t  ng += 2;\n+\t  pgr += 2;\n+#else  /* POWERPC64 */\n \t  /* A long double value consumes four GPRs and two FPRs.\n \t     There are 13 64bit floating point registers.  */\n \t  if (nf < NUM_FPR_ARG_REGISTERS - 1)\n@@ -774,6 +868,7 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t     We use a union to pass the long double to avalue[i].  */\n \t  else if (nf == NUM_FPR_ARG_REGISTERS - 1)\n \t    {\n+\t      union ldu temp_ld;\n \t      memcpy (&temp_ld.lb[0], pfr, sizeof(ldbits));\n \t      memcpy (&temp_ld.lb[1], pgr + 2, sizeof(ldbits));\n \t      avalue[i] = &temp_ld.ld;\n@@ -785,6 +880,7 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t  nf += 2;\n \t  ng += 4;\n \t  pgr += 4;\n+#endif  /* POWERPC64 */\n \t  break;\n #endif\n \tdefault:"}, {"sha": "b4f992e6df4bb432b54dc68a2cfa4e1609148e2f", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751cf6fef34bcadf288b8d02e287d0bb1520b99/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=5751cf6fef34bcadf288b8d02e287d0bb1520b99", "patch": "@@ -30,7 +30,11 @@\n \n /* ---- System specific configurations ----------------------------------- */\n \n-#if defined (POWERPC) && defined (__powerpc64__)\n+#if defined (POWERPC) && defined (__powerpc64__)\t/* linux64 */\n+#define POWERPC64\n+#elif defined (POWERPC_DARWIN) && defined (__ppc64__)\t/* Darwin */\n+#define POWERPC64\n+#elif defined (POWERPC_AIX) && defined (__64BIT__)\t/* AIX64 */\n #define POWERPC64\n #endif\n "}]}