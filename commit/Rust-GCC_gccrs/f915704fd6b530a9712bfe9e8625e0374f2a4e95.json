{"sha": "f915704fd6b530a9712bfe9e8625e0374f2a4e95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxNTcwNGZkNmI1MzBhOTcxMmJmZTllODYyNWUwMzc0ZjJhNGU5NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T14:39:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T14:39:44Z"}, "message": "[multiple changes]\n\n2010-10-22  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Array_Aggregate.Add): If the type of the\n\taggregate has a non standard representation the attributes 'Val and\n\t'Pos expand into function calls and the resulting expression is\n\tconsidered non-safe for reevaluation by the backend. Relocate it into\n\ta constant temporary to indicate to the backend that it is side\n\teffects free.\n\n2010-10-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Build_Concurrent_Derived_Type): Create declaration for\n\tderived corresponding record type only when expansion is enabled.\n\nFrom-SVN: r165830", "tree": {"sha": "ea196a7c44083941b3599a1fe990b421f7e8edc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea196a7c44083941b3599a1fe990b421f7e8edc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f915704fd6b530a9712bfe9e8625e0374f2a4e95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f915704fd6b530a9712bfe9e8625e0374f2a4e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f915704fd6b530a9712bfe9e8625e0374f2a4e95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f915704fd6b530a9712bfe9e8625e0374f2a4e95/comments", "author": null, "committer": null, "parents": [{"sha": "ed00f4727ba26dd7b6cb3900162729d26de9ecdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed00f4727ba26dd7b6cb3900162729d26de9ecdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed00f4727ba26dd7b6cb3900162729d26de9ecdb"}], "stats": {"total": 81, "additions": 61, "deletions": 20}, "files": [{"sha": "4984482bc82f50244c96852706b2dff370473165", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f915704fd6b530a9712bfe9e8625e0374f2a4e95/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f915704fd6b530a9712bfe9e8625e0374f2a4e95/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f915704fd6b530a9712bfe9e8625e0374f2a4e95", "patch": "@@ -1,3 +1,17 @@\n+2010-10-22  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Array_Aggregate.Add): If the type of the\n+\taggregate has a non standard representation the attributes 'Val and\n+\t'Pos expand into function calls and the resulting expression is\n+\tconsidered non-safe for reevaluation by the backend. Relocate it into\n+\ta constant temporary to indicate to the backend that it is side\n+\teffects free.\n+\n+2010-10-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Concurrent_Derived_Type): Create declaration for\n+\tderived corresponding record type only when expansion is enabled.\n+\n 2010-10-22  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_case.adb, sem_attr.adb (Bad_Predicated_Subtype_Use): Change order"}, {"sha": "0a43e858bd6ea82e416a8005ac479563d0d6e7e2", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f915704fd6b530a9712bfe9e8625e0374f2a4e95/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f915704fd6b530a9712bfe9e8625e0374f2a4e95/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=f915704fd6b530a9712bfe9e8625e0374f2a4e95", "patch": "@@ -891,6 +891,7 @@ package body Sem_Aggr is\n    -----------------------\n \n    procedure Resolve_Aggregate (N : Node_Id; Typ : Entity_Id) is\n+      Loc   : constant Source_Ptr := Sloc (N);\n       Pkind : constant Node_Kind := Nkind (Parent (N));\n \n       Aggr_Subtyp : Entity_Id;\n@@ -978,8 +979,7 @@ package body Sem_Aggr is\n                      Next (Expr);\n                   end loop;\n \n-                  Rewrite (N,\n-                    Make_String_Literal (Sloc (N), End_String));\n+                  Rewrite (N, Make_String_Literal (Loc, End_String));\n \n                   Analyze_And_Resolve (N, Typ);\n                   return;\n@@ -999,16 +999,16 @@ package body Sem_Aggr is\n             --  subtype for the final aggregate.\n \n          begin\n-            --  In the following we determine whether an others choice is\n+            --  In the following we determine whether an OTHERS choice is\n             --  allowed inside the array aggregate. The test checks the context\n             --  in which the array aggregate occurs. If the context does not\n-            --  permit it, or the aggregate type is unconstrained, an others\n+            --  permit it, or the aggregate type is unconstrained, an OTHERS\n             --  choice is not allowed.\n \n             --  If expansion is disabled (generic context, or semantics-only\n             --  mode) actual subtypes cannot be constructed, and the type of an\n             --  object may be its unconstrained nominal type. However, if the\n-            --  context is an assignment, we assume that \"others\" is allowed,\n+            --  context is an assignment, we assume that OTHERS is allowed,\n             --  because the target of the assignment will have a constrained\n             --  subtype when fully compiled.\n \n@@ -1054,6 +1054,7 @@ package body Sem_Aggr is\n                     Index_Constr   => First_Index (Typ),\n                     Component_Typ  => Component_Type (Typ),\n                     Others_Allowed => True);\n+\n             else\n                Aggr_Resolved :=\n                  Resolve_Array_Aggregate\n@@ -1092,7 +1093,7 @@ package body Sem_Aggr is\n       if Raises_Constraint_Error (N) then\n          Aggr_Subtyp := Etype (N);\n          Rewrite (N,\n-           Make_Raise_Constraint_Error (Sloc (N),\n+           Make_Raise_Constraint_Error (Loc,\n              Reason => CE_Range_Check_Failed));\n          Set_Raises_Constraint_Error (N);\n          Set_Etype (N, Aggr_Subtyp);\n@@ -1133,10 +1134,10 @@ package body Sem_Aggr is\n       --  analyzed expression.\n \n       procedure Check_Bound (BH : Node_Id; AH : in out Node_Id);\n-      --  Checks that AH (the upper bound of an array aggregate) is <= BH\n-      --  (the upper bound of the index base type). If the check fails a\n-      --  warning is emitted, the Raises_Constraint_Error flag of N is set,\n-      --  and AH is replaced with a duplicate of BH.\n+      --  Checks that AH (the upper bound of an array aggregate) is less than\n+      --  or equal to BH (the upper bound of the index base type). If the check\n+      --  fails, a warning is emitted, the Raises_Constraint_Error flag of N is\n+      --  set, and AH is replaced with a duplicate of BH.\n \n       procedure Check_Bounds (L, H : Node_Id; AL, AH : Node_Id);\n       --  Checks that range AL .. AH is compatible with range L .. H. Emits a\n@@ -1160,7 +1161,7 @@ package body Sem_Aggr is\n       --  Resolves aggregate expression Expr. Returns False if resolution\n       --  fails. If Single_Elmt is set to False, the expression Expr may be\n       --  used to initialize several array aggregate elements (this can happen\n-      --  for discrete choices such as \"L .. H => Expr\" or the others choice).\n+      --  for discrete choices such as \"L .. H => Expr\" or the OTHERS choice).\n       --  In this event we do not resolve Expr unless expansion is disabled.\n       --  To know why, see the DELAYED COMPONENT RESOLUTION note above.\n \n@@ -1211,8 +1212,8 @@ package body Sem_Aggr is\n          if not Is_Enumeration_Type (Index_Base) then\n             Expr :=\n               Make_Op_Add (Loc,\n-                           Left_Opnd  => Duplicate_Subexpr (To),\n-                           Right_Opnd => Make_Integer_Literal (Loc, Val));\n+                Left_Opnd  => Duplicate_Subexpr (To),\n+                Right_Opnd => Make_Integer_Literal (Loc, Val));\n \n          --  If we are dealing with enumeration return\n          --    Index_Typ'Val (Index_Typ'Pos (To) + Val)\n@@ -1236,6 +1237,30 @@ package body Sem_Aggr is\n                  Prefix         => New_Reference_To (Index_Typ, Loc),\n                  Attribute_Name => Name_Val,\n                  Expressions    => New_List (Expr_Pos));\n+\n+            --  If the index type has a non standard representation, the\n+            --  attributes 'Val and 'Pos expand into function calls and the\n+            --  resulting expression is considered non-safe for reevaluation\n+            --  by the backend. Relocate it into a constant temporary in order\n+            --  to make it safe for reevaluation.\n+\n+            if Has_Non_Standard_Rep (Etype (N)) then\n+               declare\n+                  Def_Id : Entity_Id;\n+\n+               begin\n+                  Def_Id := Make_Temporary (Loc, 'R', Expr);\n+                  Set_Etype (Def_Id, Index_Typ);\n+                  Insert_Action (N,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Def_Id,\n+                      Object_Definition   => New_Reference_To (Index_Typ, Loc),\n+                      Constant_Present    => True,\n+                      Expression          => Relocate_Node (Expr)));\n+\n+                  Expr := New_Reference_To (Def_Id, Loc);\n+               end;\n+            end if;\n          end if;\n \n          return Expr;"}, {"sha": "ab7ce65ac2cbac755aff2fc45a3fcd748a17c1a3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f915704fd6b530a9712bfe9e8625e0374f2a4e95/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f915704fd6b530a9712bfe9e8625e0374f2a4e95/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f915704fd6b530a9712bfe9e8625e0374f2a4e95", "patch": "@@ -5030,33 +5030,35 @@ package body Sem_Ch3 is\n          end loop;\n       end if;\n \n-      if Present (Old_Disc) then\n+      if Present (Old_Disc) and then Expander_Active then\n \n          --  The new type has fewer discriminants, so we need to create a new\n          --  corresponding record, which is derived from the corresponding\n          --  record of the parent, and has a stored constraint that captures\n          --  the values of the discriminant constraints.\n+         --  The corresponding record is needed only if expander is active\n+         --  and code generation is enabled.\n \n-         --  The type declaration for the derived corresponding record has\n-         --  the same discriminant part and constraints as the current\n-         --  declaration. Copy the unanalyzed tree to build declaration.\n+         --  The type declaration for the derived corresponding record has the\n+         --  same discriminant part and constraints as the current declaration.\n+         --  Copy the unanalyzed tree to build declaration.\n \n          Corr_Decl_Needed := True;\n          New_N := Copy_Separate_Tree (N);\n \n          Corr_Decl :=\n            Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Corr_Record,\n+             Defining_Identifier         => Corr_Record,\n              Discriminant_Specifications =>\n                 Discriminant_Specifications (New_N),\n-             Type_Definition =>\n+             Type_Definition             =>\n                Make_Derived_Type_Definition (Loc,\n                  Subtype_Indication =>\n                    Make_Subtype_Indication (Loc,\n                      Subtype_Mark =>\n                         New_Occurrence_Of\n                           (Corresponding_Record_Type (Parent_Type), Loc),\n-                     Constraint =>\n+                     Constraint   =>\n                        Constraint\n                          (Subtype_Indication (Type_Definition (New_N))))));\n       end if;"}]}