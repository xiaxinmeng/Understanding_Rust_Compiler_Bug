{"sha": "98181563dc4c65c9d23eaa99134e18876b6ec671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxODE1NjNkYzRjNjVjOWQyM2VhYTk5MTM0ZTE4ODc2YjZlYzY3MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-01-24T22:44:10Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-01-24T22:51:19Z"}, "message": "Fix ICE due to invalid jump threading request\n\n\tPR tree-optimization/92788\n\t* tree-ssa-threadedge.c (thread_across_edge): Check EDGE_COMPLEX\n\tnot EDGE_ABNORMAL.\n\n\tPR tree-optimization/92788\n\t* g++.dg/pr92788.C: New test.", "tree": {"sha": "86a915598733f1829455cbed2e49ef61266f5a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86a915598733f1829455cbed2e49ef61266f5a00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98181563dc4c65c9d23eaa99134e18876b6ec671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98181563dc4c65c9d23eaa99134e18876b6ec671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98181563dc4c65c9d23eaa99134e18876b6ec671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98181563dc4c65c9d23eaa99134e18876b6ec671/comments", "author": null, "committer": null, "parents": [{"sha": "55dd44535d2e4e5703c0103c26e7c51ab8c502c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55dd44535d2e4e5703c0103c26e7c51ab8c502c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55dd44535d2e4e5703c0103c26e7c51ab8c502c4"}], "stats": {"total": 483, "additions": 482, "deletions": 1}, "files": [{"sha": "0f19fc44212027aef37e12eef134e4e5fbc4685f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98181563dc4c65c9d23eaa99134e18876b6ec671", "patch": "@@ -1,3 +1,9 @@\n+2020-01-24  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/92788\n+\t* tree-ssa-threadedge.c (thread_across_edge): Check EDGE_COMPLEX\n+\tnot EDGE_ABNORMAL.\n+\n 2020-01-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/93395"}, {"sha": "a8d517ad8a3fe46bf022858100598b49e327db24", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98181563dc4c65c9d23eaa99134e18876b6ec671", "patch": "@@ -1,3 +1,8 @@\n+2020-01-24  Jeff Law  <law@redhat.com\n+\n+\tPR tree-optimization/92788\n+\t* g++.dg/pr92788.C: New test.\n+\n 2020-01-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/93395"}, {"sha": "b92ae38f7aac5240fb292790aac3ac422ee3cd6e", "filename": "gcc/testsuite/g++.dg/pr92788.C", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr92788.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr92788.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr92788.C?ref=98181563dc4c65c9d23eaa99134e18876b6ec671", "patch": "@@ -0,0 +1,470 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target c++11 } */\n+/* { dg-options \"-O3 -fnon-call-exceptions -ftracer -march=k8 -Wno-return-type\" } */\n+\n+\n+template <int __v> struct integral_constant {\n+\n+  static constexpr int value = __v;\n+\n+};\n+\n+template <bool __v> using __bool_constant = integral_constant<__v>;\n+\n+template <typename _Tp, typename _Up>\n+\n+struct is_same : integral_constant<true> {};\n+\n+template <bool, typename _Tp> using __enable_if_t = _Tp;\n+\n+void *operator new(unsigned long, void *__p) { return __p; }\n+\n+template <typename _Iterator, typename> class __normal_iterator {\n+\n+  _Iterator _M_current;\n+\n+\n+\n+public:\n+\n+  __normal_iterator(_Iterator) {}\n+\n+  void operator++() { ++_M_current; }\n+\n+  _Iterator base() { return _M_current; }\n+\n+};\n+\n+template <typename _IteratorL, typename _IteratorR, typename _Container>\n+\n+bool operator!=(__normal_iterator<_IteratorL, _Container> __lhs,\n+\n+  __normal_iterator<_IteratorR, _Container> __rhs) {\n+\n+  return __lhs.base() != __rhs.base();\n+\n+}\n+\n+template <typename _Tp> void construct_at(_Tp *__location) noexcept {\n+\n+  new (__location) _Tp;\n+\n+}\n+\n+template <typename _Tp> void _Construct(_Tp __p) { construct_at(__p); }\n+\n+struct _Any_data {\n+\n+  template <typename _Tp> _Tp _M_access();\n+\n+};\n+\n+enum _Manager_operation {};\n+\n+template <typename> class function;\n+\n+class _Function_base {\n+\n+public:\n+\n+  template <typename _Functor> class _Base_manager {\n+\n+public:\n+\n+    static bool _M_manager(_Any_data, _Any_data __source, _Manager_operation) {\n+\n+      _Functor(*__source._M_access<_Functor *>());\n+\n+      return true;\n+\n+    }\n+\n+  };\n+\n+  typedef bool (*_Manager_type)(_Any_data &, const _Any_data &,\n+\n+    _Manager_operation);\n+\n+  _Manager_type _M_manager;\n+\n+};\n+\n+template <typename, typename> class _Function_handler;\n+\n+template <typename _Res, typename _Functor, typename... _ArgTypes>\n+\n+class _Function_handler<_Res(_ArgTypes...), _Functor> : _Function_base {\n+\n+public:\n+\n+  static bool _M_manager(_Any_data &__dest, const _Any_data &__source,\n+\n+    _Manager_operation __op) {\n+\n+    _Base_manager<_Functor>::_M_manager(__dest, __source, __op);\n+\n+  }\n+\n+};\n+\n+template <typename _Res, typename... _ArgTypes>\n+\n+class function<_Res(_ArgTypes...)> : _Function_base {\n+\n+  template <typename, typename _Tp> using _Requires = _Tp;\n+\n+\n+\n+public:\n+\n+  template <typename _Functor,\n+\n+            typename = _Requires<__bool_constant<!bool()>, void>,\n+\n+            typename = _Requires<_Functor, void>>\n+\n+  function(_Functor);\n+\n+};\n+\n+template <typename _Res, typename... _ArgTypes>\n+\n+template <typename _Functor, typename, typename>\n+\n+function<_Res(_ArgTypes...)>::function(_Functor) {\n+\n+  _M_manager = _Function_handler<_Res(), _Functor>::_M_manager;\n+\n+}\n+\n+template <typename _Tp> class new_allocator {\n+\n+public:\n+\n+  _Tp *allocate(long) { return static_cast<_Tp *>(operator new(sizeof(_Tp))); }\n+\n+};\n+\n+namespace std {\n+\n+  template <typename> struct allocator_traits;\n+\n+  template <typename _Tp> struct allocator_traits<new_allocator<_Tp>> {\n+\n+    using allocator_type = new_allocator<_Tp>;\n+\n+    using pointer = _Tp *;\n+\n+    using const_pointer = _Tp *;\n+\n+    using size_type = long;\n+\n+    template <typename _Up> using rebind_alloc = new_allocator<_Up>;\n+\n+    static pointer allocate(allocator_type __a, size_type __n) {\n+\n+      return __a.allocate(__n);\n+\n+    }\n+\n+    static void deallocate(allocator_type, pointer, size_type);\n+\n+  };\n+\n+}\n+\n+template <typename _Alloc>\n+\n+struct __alloc_traits : std::allocator_traits<_Alloc> {\n+\n+  template <typename _Tp> struct rebind {\n+\n+    typedef typename std::allocator_traits<_Alloc>::template rebind_alloc<_Tp> other;\n+\n+  };\n+\n+};\n+\n+namespace std {\n+\n+  struct __uninitialized_copy {\n+\n+    template <typename _InputIterator, typename _ForwardIterator>\n+\n+    static _ForwardIterator __uninit_copy(_InputIterator __first,\n+\n+      _InputIterator __last,\n+\n+      _ForwardIterator __result) {\n+\n+      for (; __first != __last; ++__first, ++__result)\n+\n+        _Construct(__result);\n+\n+      return __result;\n+\n+    }\n+\n+  };\n+\n+  template <typename _InputIterator, typename _ForwardIterator>\n+\n+  _ForwardIterator uninitialized_copy(_InputIterator __first,\n+\n+    _InputIterator __last,\n+\n+    _ForwardIterator __result) {\n+\n+    return __uninitialized_copy::__uninit_copy(__first, __last, __result);\n+\n+  }\n+\n+  template <typename _InputIterator, typename _ForwardIterator, typename _Tp>\n+\n+  _ForwardIterator __uninitialized_copy_a(_InputIterator __first,\n+\n+    _InputIterator __last,\n+\n+    _ForwardIterator __result, _Tp) {\n+\n+    return uninitialized_copy(__first, __last, __result);\n+\n+  }\n+\n+  template <typename _Tp, typename _Alloc> struct _Vector_base {\n+\n+    typedef typename __alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;\n+\n+    typedef typename __alloc_traits<_Tp_alloc_type>::pointer pointer;\n+\n+    struct _Vector_impl_data {\n+\n+      pointer _M_start;\n+\n+      pointer _M_finish;\n+\n+    };\n+\n+    struct _Vector_impl : _Tp_alloc_type, _Vector_impl_data {};\n+\n+    _Tp_alloc_type _M_get_Tp_allocator();\n+\n+    _Vector_base(long, _Alloc) {\n+\n+      _M_impl._M_start = _M_allocate();\n+\n+      _M_impl._M_finish = _M_impl._M_start;\n+\n+    }\n+\n+    ~_Vector_base() { _M_deallocate(_M_impl._M_start); }\n+\n+    _Vector_impl _M_impl;\n+\n+    long _M_allocate___n;\n+\n+    pointer _M_allocate() {\n+\n+      typedef __alloc_traits<_Tp_alloc_type> _Tr;\n+\n+      return _M_allocate___n ? _Tr::allocate(_M_impl, _M_allocate___n)\n+\n+        : pointer();\n+\n+    }\n+\n+    long _M_deallocate___n;\n+\n+    void _M_deallocate(pointer __p) {\n+\n+      typedef __alloc_traits<_Tp_alloc_type> _Tr;\n+\n+      if (__p)\n+\n+        _Tr::deallocate(_M_impl, __p, _M_deallocate___n);\n+\n+    }\n+\n+  };\n+\n+  template <typename _Tp, typename _Alloc = new_allocator<_Tp>>\n+\n+  class vector : _Vector_base<_Tp, _Alloc> {\n+\n+    typedef _Vector_base<_Tp, _Alloc> _Base;\n+\n+    typedef __normal_iterator<\n+\n+      typename __alloc_traits<typename _Base::_Tp_alloc_type>::const_pointer,\n+\n+      int>\n+\n+    const_iterator;\n+\n+    using _Base::_M_get_Tp_allocator;\n+\n+\n+\n+public:\n+\n+    vector();\n+\n+    vector(vector &__x) : _Base(0, _M_get_Tp_allocator()) {\n+\n+      this->_M_impl._M_finish = __uninitialized_copy_a(__x.begin(), __x.end(),\n+\n+        this->_M_impl._M_start, 0);\n+\n+    }\n+\n+    const_iterator begin() noexcept { return this->_M_impl._M_start; }\n+\n+    const_iterator end() noexcept { return this->_M_impl._M_finish; }\n+\n+  };\n+\n+  template <typename _Tp> class __shared_ptr_access {\n+\n+public:\n+\n+    using element_type = _Tp;\n+\n+    element_type *operator->();\n+\n+  };\n+\n+  enum syntax_option_type : int;\n+\n+  template <typename> using _Matcher = function<bool()>;\n+\n+  struct _NFA {\n+\n+    void _M_insert_matcher(_Matcher<int>);\n+\n+  };\n+\n+  template <typename _TraitsT> class _Compiler {\n+\n+public:\n+\n+    typedef typename _TraitsT::char_type *_IterT;\n+\n+    _Compiler(_IterT, _IterT, const typename _TraitsT::locale_type &, syntax_option_type);\n+\n+    template <bool> void _M_insert_character_class_matcher();\n+\n+    syntax_option_type _M_flags;\n+\n+    __shared_ptr_access<_NFA> _M_nfa;\n+\n+    _TraitsT _M_traits;\n+\n+  };\n+\n+  template <typename, typename>\n+\n+  using __enable_if_contiguous_iter =\n+\n+    __enable_if_t<integral_constant<false>::value,\n+\n+                  __shared_ptr_access<_NFA>>;\n+\n+  syntax_option_type __compile_nfa___flags;\n+\n+  struct Trans_NS___cxx11_regex_traits {\n+\n+    typedef char char_type;\n+\n+    typedef int locale_type;\n+\n+    struct _RegexMask {\n+\n+      short _M_base;\n+\n+      char _M_extended;\n+\n+      _RegexMask() : _M_extended() {}\n+\n+    } typedef char_class_type;\n+\n+  };\n+\n+  template <typename _FwdIter>\n+\n+  __enable_if_contiguous_iter<_FwdIter, char> __compile_nfa(_FwdIter) {\n+\n+    auto __cfirst = nullptr;\n+\n+    using _Cmplr = _Compiler<Trans_NS___cxx11_regex_traits>;\n+\n+    _Cmplr(__cfirst, __cfirst, 0, __compile_nfa___flags);\n+\n+  }\n+\n+  class _RegexTranslatorBase {\n+\n+public:\n+\n+    _RegexTranslatorBase(Trans_NS___cxx11_regex_traits);\n+\n+  };\n+\n+  class _RegexTranslator : _RegexTranslatorBase {\n+\n+    typedef _RegexTranslatorBase _Base;\n+\n+    using _Base::_Base;\n+\n+  };\n+\n+  template <typename _TraitsT, int> struct _BracketMatcher {\n+\n+    _BracketMatcher(bool, _TraitsT __traits) : _M_translator(__traits) {}\n+\n+    vector<typename _TraitsT::char_class_type> _M_neg_class_set;\n+\n+    _RegexTranslator _M_translator;\n+\n+  };\n+\n+  template <typename _TraitsT>\n+\n+  _Compiler<_TraitsT>::_Compiler(_IterT __b, _IterT __e,\n+\n+    const typename _TraitsT::locale_type &__loc,\n+\n+    syntax_option_type) {\n+\n+    _M_insert_character_class_matcher<false>();\n+\n+    _M_insert_character_class_matcher<true>();\n+\n+  }\n+\n+  template <typename _TraitsT>\n+\n+  template <bool __collate>\n+\n+  void _Compiler<_TraitsT>::_M_insert_character_class_matcher() {\n+\n+    _BracketMatcher<_TraitsT, __collate> __matcher(0, _M_traits);\n+\n+    _M_nfa->_M_insert_matcher(__matcher);\n+\n+  }\n+\n+  class Trans_NS___cxx11_basic_regex {\n+\n+public:\n+\n+    char Trans_NS___cxx11_basic_regex___last;\n+\n+    Trans_NS___cxx11_basic_regex()\n+\n+      : _M_automaton(__compile_nfa(Trans_NS___cxx11_basic_regex___last)) {}  /* { dg-error } */\n+\n+    __shared_ptr_access<_NFA> _M_automaton;\n+\n+  } regex_sanity_check___f;\n+\n+}"}, {"sha": "c7c08213f9aeee375a0b48031ddcac1ce7c3a48d", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98181563dc4c65c9d23eaa99134e18876b6ec671/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=98181563dc4c65c9d23eaa99134e18876b6ec671", "patch": "@@ -1323,7 +1323,7 @@ thread_across_edge (gcond *dummy_cond,\n     /* If E->dest has abnormal outgoing edges, then there's no guarantee\n        we can safely redirect any of the edges.  Just punt those cases.  */\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n-      if (taken_edge->flags & EDGE_ABNORMAL)\n+      if (taken_edge->flags & EDGE_COMPLEX)\n \t{\n \t  const_and_copies->pop_to_marker ();\n           avail_exprs_stack->pop_to_marker ();"}]}