{"sha": "c1a569ef313db23d0563be35eefa05d4d7bde772", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFhNTY5ZWYzMTNkYjIzZDA1NjNiZTM1ZWVmYTA1ZDRkN2JkZTc3Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-06-19T20:25:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-06-19T20:25:38Z"}, "message": "gigi.h (record_builtin_type): Adjust comment.\n\n\t* gcc-interface/gigi.h (record_builtin_type): Adjust comment.\n\t(tree create_type_decl): Likewise.\n\t(create_var_decl_1): Add artificial_p and debug_info_p parameters.\n\t(create_var_decl): Likewise.\n\t(create_true_var_decl): Delete.\n\t(create_subprog_decl): Add debug_info_p parameter.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add artificial_p local\n\tvariable and use it throughout.  Remove DECL_ARTIFICIAL settings.\n\t<E_Variable>: Adjust calls to create_var_decl and create_var_decl_1.\n\tRemove DECL_IGNORED_P settings.\n\t<E_Enumeration_Type>: Likewise.\n\t<E_Record_Type>: Likewise.\n\t<E_Subprogram_Type>: Likewise.  Remove artificial_flag local variable.\n\tAdjust call to create_subprog_decl.\n\t(get_minimal_subprog_decl): Likewise.\n\t(elaborate_expression_1): Adjust call to create_var_decl.\n\t* gcc-interface/trans.c (gigi): Adjust calls to create_var_decl and\n\tcreate_subprog_decl.  Remove DECL_ARTIFICIAL & DECL_IGNORED_P settings.\n\t* gcc-interface/utils.c (maybe_pad_type): Likewise.\n\t(record_builtin_type): Adjust comment.\n\t(create_type_stub_decl): Remove obsolete comment.\n\t(create_var_decl_1): Add artificial_p and debug_info_p parameters.\n\tSet DECL_ARTIFICIAL and DECL_IGNORED_P accordingly.\n\t(create_subprog_decl): Add debug_info_p parameter.  Set DECL_IGNORED_P\n\taccordingly.\n\nFrom-SVN: r224699", "tree": {"sha": "e5e61dffe1b66ad8003ea708203f7f59981c7136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5e61dffe1b66ad8003ea708203f7f59981c7136"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1a569ef313db23d0563be35eefa05d4d7bde772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a569ef313db23d0563be35eefa05d4d7bde772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a569ef313db23d0563be35eefa05d4d7bde772", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a569ef313db23d0563be35eefa05d4d7bde772/comments", "author": null, "committer": null, "parents": [{"sha": "034e7d4912a66d79b9ee8bb8c1adf5c945e47669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/034e7d4912a66d79b9ee8bb8c1adf5c945e47669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/034e7d4912a66d79b9ee8bb8c1adf5c945e47669"}], "stats": {"total": 411, "additions": 225, "deletions": 186}, "files": [{"sha": "801be514716fd70dfc960f55ef55f9fca62fb2fe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -1,3 +1,35 @@\n+2015-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (record_builtin_type): Adjust comment.\n+\t(tree create_type_decl): Likewise.\n+\t(create_var_decl_1): Add artificial_p and debug_info_p parameters.\n+\t(create_var_decl): Likewise.\n+\t(create_true_var_decl): Delete.\n+\t(create_subprog_decl): Add debug_info_p parameter.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add artificial_p local\n+\tvariable and use it throughout.  Remove DECL_ARTIFICIAL settings.\n+\t<E_Variable>: Adjust calls to create_var_decl and create_var_decl_1.\n+\tRemove DECL_IGNORED_P settings.\n+\t<E_Enumeration_Type>: Likewise.\n+\t<E_Record_Type>: Likewise.\n+\t<E_Subprogram_Type>: Likewise.  Remove artificial_flag local variable.\n+\tAdjust call to create_subprog_decl.\n+\t(get_minimal_subprog_decl): Likewise.\n+\t(elaborate_expression_1): Adjust call to create_var_decl.\n+\t* gcc-interface/trans.c (gigi): Adjust calls to create_var_decl and\n+\tcreate_subprog_decl.  Remove DECL_ARTIFICIAL & DECL_IGNORED_P settings.\n+\t* gcc-interface/utils.c (maybe_pad_type): Likewise.\n+\t(record_builtin_type): Adjust comment.\n+\t(create_type_stub_decl): Remove obsolete comment.\n+\t(create_var_decl_1): Add artificial_p and debug_info_p parameters.\n+\tSet DECL_ARTIFICIAL and DECL_IGNORED_P accordingly.\n+\t(create_subprog_decl): Add debug_info_p parameter.  Set DECL_IGNORED_P\n+\taccordingly.\n+\n+2015-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/misc.c (LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL): Define.\n+\n 2015-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Function>: Make sure"}, {"sha": "af2d11ed50a94ed96e3328a955da27cb76c3d2ef", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 45, "deletions": 73, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -244,6 +244,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   const Entity_Kind kind = Ekind (gnat_entity);\n   /* True if this is a type.  */\n   const bool is_type = IN (kind, Type_Kind);\n+  /* True if this is an artificial entity.  */\n+  const bool artificial_p = !Comes_From_Source (gnat_entity);\n   /* True if debug info is requested for this entity.  */\n   const bool debug_info_p = Needs_Debug_Info (gnat_entity);\n   /* True if this entity is to be considered as imported.  */\n@@ -1348,8 +1350,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    tree gnu_new_var\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n \t\t\t\t NULL_TREE, gnu_new_type, NULL_TREE, false,\n-\t\t\t\t false, false, false, NULL, gnat_entity);\n-\t    DECL_ARTIFICIAL (gnu_new_var) = 1;\n+\t\t\t\t false, false, false, true, debug_info_p,\n+\t\t\t\t NULL, gnat_entity);\n \n \t    /* Initialize the aligned field if we have an initializer.  */\n \t    if (gnu_expr)\n@@ -1389,12 +1391,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       just above, we have nothing to do here.  */\n \t    if (!TYPE_IS_THIN_POINTER_P (gnu_type))\n \t      {\n+\t\t/* This variable is a GNAT encoding used by Workbench: let it\n+\t\t   go through the debugging information but mark it as\n+\t\t   artificial: users are not interested in it.  */\n \t\ttree gnu_unc_var\n \t\t   = create_var_decl (concat_name (gnu_entity_name, \"UNC\"),\n \t\t\t\t      NULL_TREE, gnu_type, gnu_expr,\n \t\t\t\t      const_flag, Is_Public (gnat_entity),\n \t\t\t\t      imported_p || !definition, static_p,\n-\t\t\t\t      NULL, gnat_entity);\n+\t\t\t\t      true, debug_info_p, NULL, gnat_entity);\n \t\tgnu_expr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_unc_var);\n \t\tTREE_CONSTANT (gnu_expr) = 1;\n \n@@ -1448,7 +1453,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  = create_var_decl_1 (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t       gnu_expr, const_flag, Is_Public (gnat_entity),\n \t\t\t       imported_p || !definition, static_p,\n-\t\t\t       !renamed_obj, attr_list, gnat_entity);\n+\t\t\t       artificial_p, debug_info_p, !renamed_obj,\n+\t\t\t       attr_list, gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -1497,19 +1503,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n \t  {\n \t    tree gnu_corr_var\n-\t      = create_true_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t      gnu_expr, true, Is_Public (gnat_entity),\n-\t\t\t\t      !definition, static_p, attr_list,\n-\t\t\t\t      gnat_entity);\n+\t      = create_var_decl_1 (gnu_entity_name, gnu_ext_name, gnu_type,\n+\t\t\t\t   gnu_expr, true, Is_Public (gnat_entity),\n+\t\t\t\t   !definition, static_p, artificial_p,\n+\t\t\t\t   debug_info_p, false, attr_list,\n+\t\t\t\t   gnat_entity);\n \n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n-\n-\t    /* As debugging information will be generated for the variable,\n-\t       do not generate debugging information for the constant.  */\n-\t    if (debug_info_p)\n-\t      DECL_IGNORED_P (gnu_decl) = 1;\n-\t    else\n-\t      DECL_IGNORED_P (gnu_corr_var) = 1;\n \t  }\n \n \t/* If this is a constant, even if we don't need a true variable, we\n@@ -1618,12 +1618,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      tree gnu_value\n \t\t= UI_To_gnu (Enumeration_Rep (gnat_literal), gnu_type);\n+\t      /* Do not generate debug info for individual enumerators.  */\n \t      tree gnu_literal\n \t\t= create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n \t\t\t\t   gnu_type, gnu_value, true, false, false,\n+\t\t\t\t   false, !Comes_From_Source (gnat_literal),\n \t\t\t\t   false, NULL, gnat_literal);\n-\t      /* Do not generate debug info for individual enumerators.  */\n-\t      DECL_IGNORED_P (gnu_literal) = 1;\n \t      save_gnu_tree (gnat_literal, gnu_literal, false);\n \t      gnu_list\n \t        = tree_cons (DECL_NAME (gnu_literal), gnu_value, gnu_list);\n@@ -1731,12 +1731,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       SET_TYPE_RM_MIN_VALUE\n \t(gnu_type, elaborate_expression (Type_Low_Bound (gnat_entity),\n \t\t\t\t\t gnat_entity, \"L\", definition, true,\n-\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n+\t\t\t\t\t debug_info_p));\n \n       SET_TYPE_RM_MAX_VALUE\n \t(gnu_type, elaborate_expression (Type_High_Bound (gnat_entity),\n \t\t\t\t\t gnat_entity, \"U\", definition, true,\n-\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n+\t\t\t\t\t debug_info_p));\n \n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n \t= Has_Biased_Representation (gnat_entity);\n@@ -1911,12 +1911,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       SET_TYPE_RM_MIN_VALUE\n \t(gnu_type, elaborate_expression (Type_Low_Bound (gnat_entity),\n \t\t\t\t\t gnat_entity, \"L\", definition, true,\n-\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n+\t\t\t\t\t debug_info_p));\n \n       SET_TYPE_RM_MAX_VALUE\n \t(gnu_type, elaborate_expression (Type_High_Bound (gnat_entity),\n \t\t\t\t\t gnat_entity, \"U\", definition, true,\n-\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n+\t\t\t\t\t debug_info_p));\n \n       /* Inherit our alias set from what we're a subtype of, as for\n \t integer subtypes.  */\n@@ -2215,8 +2215,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"), tem,\n-\t\t\t  !Comes_From_Source (gnat_entity), debug_info_p,\n-\t\t\t  gnat_entity);\n+\t\t\t  artificial_p, debug_info_p, gnat_entity);\n \n \t/* Give the fat pointer type a name.  If this is a packed array, tell\n \t   the debugger how to interpret the underlying bits.  */\n@@ -2225,8 +2224,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse\n \t  gnat_name = gnat_entity;\n \tcreate_type_decl (create_concat_name (gnat_name, \"XUP\"), gnu_fat_type,\n-\t\t\t  !Comes_From_Source (gnat_entity), debug_info_p,\n-\t\t\t  gnat_entity);\n+\t\t\t  artificial_p, debug_info_p, gnat_entity);\n \n \t/* Create the type to be designated by thin pointers: a record type for\n \t   the array and its template.  We used to shift the fields to have the\n@@ -2672,8 +2670,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_decl\n \t\t= create_type_decl (gnu_entity_name, gnu_type,\n \t\t\t\t    !Comes_From_Source (Etype (gnat_entity))\n-\t\t\t\t    && !Comes_From_Source (gnat_entity),\n-\t\t\t\t    debug_info_p, gnat_entity);\n+\t\t\t\t    && artificial_p, debug_info_p,\n+\t\t\t\t    gnat_entity);\n \n \t      /* Save it as our equivalent in case the call below elaborates\n \t\t this type again.  */\n@@ -3174,7 +3172,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, false,\n \t\t\t      all_rep, is_unchecked_union,\n-\t\t\t      !Comes_From_Source (gnat_entity), debug_info_p,\n+\t\t\t      artificial_p, debug_info_p,\n \t\t\t      false, OK_To_Reorder_Components (gnat_entity),\n \t\t\t      all_rep ? NULL_TREE : bitsize_zero_node, NULL);\n \n@@ -3605,8 +3603,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      = create_var_decl (create_concat_name (gnat_entity,\n \t\t\t\t\t\t\t     \"XVZ\"),\n \t\t\t\t\t NULL_TREE, sizetype, gnu_size_unit,\n-\t\t\t\t\t false, false, false, false, NULL,\n-\t\t\t\t\t gnat_entity);\n+\t\t\t\t\t false, false, false, false, true,\n+\t\t\t\t\t debug_info_p, NULL, gnat_entity);\n \t\t}\n \n \t      gnu_variant_list.release ();\n@@ -3665,8 +3663,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    = build_pointer_type\n \t      (make_dummy_type (Directly_Designated_Type (gnat_entity)));\n \t  gnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n-\t\t\t\t       !Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p, gnat_entity);\n+\t\t\t\t       artificial_p, debug_info_p,\n+\t\t\t\t       gnat_entity);\n \t  this_made_decl = true;\n \t  gnu_type = TREE_TYPE (gnu_decl);\n \t  save_gnu_tree (gnat_entity, gnu_decl, false);\n@@ -3920,8 +3918,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \t    gnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n-\t\t\t\t\t !Comes_From_Source (gnat_entity),\n-\t\t\t\t\t debug_info_p, gnat_entity);\n+\t\t\t\t\t artificial_p, debug_info_p,\n+\t\t\t\t\t gnat_entity);\n \t    this_made_decl = true;\n \t    gnu_type = TREE_TYPE (gnu_decl);\n \t    save_gnu_tree (gnat_entity, gnu_decl, false);\n@@ -4104,7 +4102,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     || imported_p\n \t     || (Convention (gnat_entity) == Convention_Intrinsic\n \t\t && Has_Pragma_Inline_Always (gnat_entity)));\n-\tbool artificial_flag = !Comes_From_Source (gnat_entity);\n        /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n           in the back-end.  In particular, both properties are orthogonal to\n           the \"nothrow\" property if the EH circuitry is explicit in the\n@@ -4611,24 +4608,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_decl\n \t      = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t gnu_address, false, Is_Public (gnat_entity),\n-\t\t\t\t extern_flag, false, NULL, gnat_entity);\n+\t\t\t\t extern_flag, false, artificial_p,\n+\t\t\t\t debug_info_p, NULL, gnat_entity);\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n \t  {\n \t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \t    gnu_decl\n-\t      = create_type_decl (gnu_entity_name, gnu_type, artificial_flag,\n+\t      = create_type_decl (gnu_entity_name, gnu_type, artificial_p,\n \t\t\t\t  debug_info_p, gnat_entity);\n \t  }\n \telse\n \t  {\n \t    gnu_decl\n \t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t     gnu_param_list, inline_status,\n-\t\t\t\t     public_flag, extern_flag, artificial_flag,\n-\t\t\t\t     attr_list, gnat_entity);\n+\t\t\t\t     public_flag, extern_flag, artificial_p,\n+\t\t\t\t     debug_info_p, attr_list, gnat_entity);\n \t    /* This is unrelated to the stub built right above.  */\n \t    DECL_STUBBED_P (gnu_decl)\n \t      = Convention (gnat_entity) == Convention_Stubbed;\n@@ -5020,8 +5018,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       if (!gnu_decl)\n \tgnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n-\t\t\t\t     !Comes_From_Source (gnat_entity),\n-\t\t\t\t     debug_info_p, gnat_entity);\n+\t\t\t\t     artificial_p, debug_info_p,\n+\t\t\t\t     gnat_entity);\n       else\n \t{\n \t  TREE_TYPE (gnu_decl) = gnu_type;\n@@ -5185,29 +5183,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tSet_RM_Size (gnat_entity, annotate_value (rm_size (gnu_type)));\n     }\n \n-  /* If we really have a ..._DECL node, set a couple of flags on it.  But we\n-     cannot do so if we are reusing the ..._DECL node made for an equivalent\n-     type or an alias or a renamed object as the predicates don't apply to it\n-     but to GNAT_ENTITY.  */\n-  if (DECL_P (gnu_decl)\n-      && !(is_type && gnat_equiv_type != gnat_entity)\n-      && !Present (Alias (gnat_entity))\n-      && !(Present (Renamed_Object (gnat_entity)) && saved))\n-    {\n-      /* ??? DECL_ARTIFICIAL, and possibly DECL_IGNORED_P below, should\n-\t be set before calling rest_of_decl_compilation above (through\n-\t create_var_decl_1).  This is because rest_of_decl_compilation\n-\t calls the debugging backend and will create a DIE without\n-\t DW_AT_artificial.\n-\n-\t This is currently causing gnat.dg/specs/debug1.ads to FAIL.  */\n-      if (!Comes_From_Source (gnat_entity))\n-\tDECL_ARTIFICIAL (gnu_decl) = 1;\n-\n-      if (!debug_info_p)\n-\tDECL_IGNORED_P (gnu_decl) = 1;\n-    }\n-\n   /* If we haven't already, associate the ..._DECL node that we just made with\n      the input GNAT entity node.  */\n   if (!saved)\n@@ -5396,7 +5371,8 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n \n   return\n     create_subprog_decl (gnu_entity_name, gnu_ext_name, void_ftype, NULL_TREE,\n-\t\t\t is_disabled, true, true, true, attr_list, gnat_entity);\n+\t\t\t is_disabled, true, true, true, false, attr_list,\n+\t\t\t gnat_entity);\n }\n \n /* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY is\n@@ -6261,14 +6237,10 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t new variable must not be tagged \"external\", as we used to do here as\n \t soon as DEFINITION was false.  */\n       tree gnu_decl\n-\t= create_var_decl_1 (create_concat_name (gnat_entity, s), NULL_TREE,\n-\t\t\t     TREE_TYPE (gnu_expr), gnu_expr, true,\n-\t\t\t     expr_public_p, !definition && expr_global_p,\n-\t\t\t     expr_global_p, !need_debug, NULL, gnat_entity);\n-\n-      /* Whether or not gnat_entity comes from source, this variable is a\n-\t compilation artifact.  */\n-      DECL_ARTIFICIAL (gnu_decl) = 1;\n+\t= create_var_decl (create_concat_name (gnat_entity, s), NULL_TREE,\n+\t\t\t   TREE_TYPE (gnu_expr), gnu_expr, true,\n+\t\t\t   expr_public_p, !definition && expr_global_p,\n+\t\t\t   expr_global_p, true, need_debug, NULL, gnat_entity);\n \n       /* Using this variable at debug time (if need_debug is true) requires a\n \t proper location.  The back-end will compute a location for this"}, {"sha": "118ce33ccd06746d1aa6bff09a462902244556c3", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -599,7 +599,7 @@ extern void build_dummy_unc_pointer_types (Entity_Id gnat_desig_type,\n \t\t\t\t\t   tree gnu_desig_type);\n \n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.\n-   ARTIFICIAL_P is true if it's a type that was generated by the compiler.  */\n+   ARTIFICIAL_P is true if the type was generated by the compiler.  */\n extern void record_builtin_type (const char *name, tree type,\n \t\t\t\t bool artificial_p);\n \n@@ -660,10 +660,10 @@ extern tree create_range_type (tree type, tree min, tree max);\n extern tree create_type_stub_decl (tree type_name, tree type);\n \n /* Return a TYPE_DECL node.  TYPE_NAME gives the name of the type and TYPE\n-   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if this\n-   is a declaration that was generated by the compiler.  DEBUG_INFO_P is\n-   true if we need to write debug information about this type.  GNAT_NODE\n-   is used for the position of the decl.  */\n+   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if the\n+   declaration was generated by the compiler.  DEBUG_INFO_P is true if we\n+   need to write debug information about this type.  GNAT_NODE is used for\n+   the position of the decl.  */\n extern tree create_type_decl (tree type_name, tree type, bool artificial_p,\n \t\t\t      bool debug_info_p, Node_Id gnat_node);\n \n@@ -686,32 +686,28 @@ extern tree create_type_decl (tree type_name, tree type, bool artificial_p,\n    STATIC_FLAG is only relevant when not at top level.  In that case\n    it indicates whether to always allocate storage to the variable.\n \n+   ARTIFICIAL_P is true if the variable was generated by the compiler.\n+\n+   DEBUG_INFO_P is true if we need to write debug information for it.\n+\n    GNAT_NODE is used for the position of the decl.  */\n extern tree\n create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t   bool const_flag, bool public_flag, bool extern_flag,\n-\t\t   bool static_flag, bool const_decl_allowed_p,\n-\t\t   struct attrib *attr_list, Node_Id gnat_node);\n+\t\t   bool static_flag, bool artificial_p, bool debug_info_p,\n+\t\t   bool const_decl_allowed_p, struct attrib *attr_list,\n+\t\t   Node_Id gnat_node);\n \n /* Wrapper around create_var_decl_1 for cases where we don't care whether\n    a VAR or a CONST decl node is created.  */\n #define create_var_decl(var_name, asm_name, type, var_init,\t\\\n \t\t\tconst_flag, public_flag, extern_flag,\t\\\n-\t\t\tstatic_flag, attr_list, gnat_node)\t\\\n+\t\t\tstatic_flag, artificial_p, debug_info_p,\\\n+\t\t\tattr_list, gnat_node)\t\t\t\\\n   create_var_decl_1 (var_name, asm_name, type, var_init,\t\\\n \t\t     const_flag, public_flag, extern_flag,\t\\\n-\t\t     static_flag, true, attr_list, gnat_node)\n-\n-/* Wrapper around create_var_decl_1 for cases where a VAR_DECL node is\n-   required.  The primary intent is for DECL_CONST_CORRESPONDING_VARs, which\n-   must be VAR_DECLs and on which we want TREE_READONLY set to have them\n-   possibly assigned to a readonly data section.  */\n-#define create_true_var_decl(var_name, asm_name, type, var_init,\t\\\n-\t\t\t     const_flag, public_flag, extern_flag,\t\\\n-\t\t\t     static_flag, attr_list, gnat_node)\t\t\\\n-  create_var_decl_1 (var_name, asm_name, type, var_init,\t\t\\\n-\t\t     const_flag, public_flag, extern_flag,\t\t\\\n-\t\t     static_flag, false, attr_list, gnat_node)\n+\t\t     static_flag, artificial_p, debug_info_p,\t\\\n+\t\t     true, attr_list, gnat_node)\n \n /* Return a FIELD_DECL node.  FIELD_NAME is the field's name, FIELD_TYPE is\n    its type and RECORD_TYPE is the type of the enclosing record.  If SIZE is\n@@ -739,14 +735,19 @@ extern tree create_label_decl (tree label_name, Node_Id gnat_node);\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the DECL_CHAIN field).\n \n-   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n-   used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n-   used for the position of the decl.  */\n+   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG and ATTR_LIST are used to set the\n+   appropriate fields in the FUNCTION_DECL.\n+\n+   ARTIFICIAL_P is true if the subprogram was generated by the compiler.\n+\n+   DEBUG_INFO_P is true if we need to write debug information for it.\n+\n+   GNAT_NODE is used for the position of the decl.  */\n extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n \t\t\t\t tree subprog_type, tree param_decl_list,\n \t\t\t\t enum inline_status_t inline_status,\n \t\t\t\t bool public_flag, bool extern_flag,\n-\t\t\t\t bool artificial_flag,\n+\t\t\t\t bool artificial_p, bool debug_info_p,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n /* Process the attributes in ATTR_LIST for NODE, which is either a DECL or"}, {"sha": "bf15955e4df52a3d37a4d17bce515d31bc923dd8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -390,16 +390,14 @@ gigi (Node_Id gnat_root,\n   gcc_assert (t == boolean_false_node);\n   t = create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n \t\t       boolean_type_node, t, true, false, false, false,\n-\t\t       NULL, gnat_literal);\n-  DECL_IGNORED_P (t) = 1;\n+\t\t       true, false, NULL, gnat_literal);\n   save_gnu_tree (gnat_literal, t, false);\n   gnat_literal = Next_Literal (gnat_literal);\n   t = UI_To_gnu (Enumeration_Rep (gnat_literal), boolean_type_node);\n   gcc_assert (t == boolean_true_node);\n   t = create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n \t\t       boolean_type_node, t, true, false, false, false,\n-\t\t       NULL, gnat_literal);\n-  DECL_IGNORED_P (t) = 1;\n+\t\t       true, false, NULL, gnat_literal);\n   save_gnu_tree (gnat_literal, t, false);\n \n   void_ftype = build_function_type_list (void_type_node, NULL_TREE);\n@@ -412,7 +410,8 @@ gigi (Node_Id gnat_root,\n      memory.  */\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   ftype,\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n@@ -422,17 +421,17 @@ gigi (Node_Id gnat_root,\n \t\t\t   build_function_type_list (void_type_node,\n \t\t\t\t\t\t     ptr_type_node,\n \t\t\t\t\t\t     NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n \n   /* This is used for 64-bit multiplication with overflow checking.  */\n   int64_type = gnat_type_for_size (64, 0);\n   mulv64_decl\n     = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n \t\t\t   build_function_type_list (int64_type, int64_type,\n \t\t\t\t\t\t     int64_type, NULL_TREE),\n-\t\t\t   NULL_TREE, is_disabled, true, true, true, NULL,\n-\t\t\t   Empty);\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n \n   /* Name of the _Parent field in tagged record types.  */\n   parent_name_id = get_identifier (Get_Name_String (Name_uParent));\n@@ -453,16 +452,14 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n-  DECL_IGNORED_P (get_jmpbuf_decl) = 1;\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   set_jmpbuf_decl\n     = create_subprog_decl\n       (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n        NULL_TREE, build_function_type_list (void_type_node, jmpbuf_ptr_type,\n \t\t\t\t\t    NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n-  DECL_IGNORED_P (set_jmpbuf_decl) = 1;\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   /* setjmp returns an integer and has one operand, which is a pointer to\n      a jmpbuf.  */\n@@ -471,7 +468,7 @@ gigi (Node_Id gnat_root,\n       (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n        build_function_type_list (integer_type_node, jmpbuf_ptr_type,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n   DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n \n@@ -481,7 +478,7 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl\n       (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n        build_function_type_list (void_type_node, jmpbuf_ptr_type, NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n   DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n \n@@ -490,29 +487,28 @@ gigi (Node_Id gnat_root,\n \n   begin_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   ftype, NULL_TREE,\n+\t\t\t   is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n-  DECL_IGNORED_P (begin_handler_decl) = 1;\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   ftype, NULL_TREE,\n+\t\t\t   is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n-  DECL_IGNORED_P (end_handler_decl) = 1;\n \n   unhandled_except_decl\n     = create_subprog_decl (get_identifier (\"__gnat_unhandled_except_handler\"),\n-\t\t\t   NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   NULL_TREE, ftype, NULL_TREE,\n+\t\t\t   is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n-  DECL_IGNORED_P (unhandled_except_decl) = 1;\n \n   reraise_zcx_decl\n     = create_subprog_decl (get_identifier (\"__gnat_reraise_zcx\"), NULL_TREE,\n-\t\t\t   ftype, NULL_TREE, is_disabled, true, true, true,\n+\t\t\t   ftype, NULL_TREE,\n+\t\t\t   is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n   /* Indicate that these never return.  */\n-  DECL_IGNORED_P (reraise_zcx_decl) = 1;\n   TREE_THIS_VOLATILE (reraise_zcx_decl) = 1;\n   TREE_SIDE_EFFECTS (reraise_zcx_decl) = 1;\n   TREE_TYPE (reraise_zcx_decl)\n@@ -530,7 +526,7 @@ gigi (Node_Id gnat_root,\n \t\t\t\t     build_pointer_type\n \t\t\t\t     (unsigned_char_type_node),\n \t\t\t\t     integer_type_node, NULL_TREE),\n-\t   NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+\t   NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n       TREE_THIS_VOLATILE (decl) = 1;\n       TREE_SIDE_EFFECTS (decl) = 1;\n       TREE_TYPE (decl)\n@@ -561,23 +557,22 @@ gigi (Node_Id gnat_root,\n       (get_identifier (\"system__soft_links__get_gnat_exception\"), NULL_TREE,\n        build_function_type_list (build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-     NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n-  DECL_IGNORED_P (get_excptr_decl) = 1;\n+     NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   set_exception_parameter_decl\n     = create_subprog_decl\n       (get_identifier (\"__gnat_set_exception_parameter\"), NULL_TREE,\n        build_function_type_list (void_type_node, ptr_type_node, ptr_type_node,\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   raise_nodefer_decl\n     = create_subprog_decl\n       (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n        build_function_type_list (void_type_node,\n \t\t\t\t build_pointer_type (except_type_node),\n \t\t\t\t NULL_TREE),\n-       NULL_TREE, is_disabled, true, true, true, NULL, Empty);\n+       NULL_TREE, is_disabled, true, true, true, false, NULL, Empty);\n \n   /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n@@ -625,20 +620,23 @@ gigi (Node_Id gnat_root,\n   others_decl\n     = create_var_decl (get_identifier (\"OTHERS\"),\n \t\t       get_identifier (\"__gnat_others_value\"),\n-\t\t       unsigned_char_type_node,\n-\t\t       NULL_TREE, true, false, true, false, NULL, Empty);\n+\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       true, false, true, false, true, false,\n+\t\t       NULL, Empty);\n \n   all_others_decl\n     = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n \t\t       get_identifier (\"__gnat_all_others_value\"),\n-\t\t       unsigned_char_type_node,\n-\t\t       NULL_TREE, true, false, true, false, NULL, Empty);\n+\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       true, false, true, false, true, false,\n+\t\t       NULL, Empty);\n \n   unhandled_others_decl\n     = create_var_decl (get_identifier (\"UNHANDLED_OTHERS\"),\n \t\t       get_identifier (\"__gnat_unhandled_others_value\"),\n-\t\t       unsigned_char_type_node,\n-\t\t       NULL_TREE, true, false, true, false, NULL, Empty);\n+\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       true, false, true, false, true, false,\n+\t\t       NULL, Empty);\n \n   main_identifier_node = get_identifier (\"main\");\n \n@@ -750,7 +748,8 @@ build_raise_check (int check, enum exception_info_kind kind)\n   result\n     = create_subprog_decl (get_identifier (Name_Buffer),\n \t\t\t   NULL_TREE, ftype, NULL_TREE,\n-\t\t\t   is_disabled, true, true, true, NULL, Empty);\n+\t\t\t   is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n \n   /* Indicate that it never returns.  */\n   TREE_THIS_VOLATILE (result) = 1;\n@@ -3664,7 +3663,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t  gnu_return_var\n \t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n \t\t\t       gnu_return_type, NULL_TREE, false, false,\n-\t\t\t       false, false, NULL, gnat_subprog_id);\n+\t\t\t       false, false, true, false,\n+\t\t\t       NULL, gnat_subprog_id);\n \t  TREE_VALUE (gnu_return_var_elmt) = gnu_return_var;\n \t}\n \n@@ -4068,10 +4068,7 @@ create_temporary (const char *prefix, tree type)\n {\n   tree gnu_temp = create_var_decl (create_tmp_var_name (prefix), NULL_TREE,\n \t\t\t\t   type, NULL_TREE, false, false, false, false,\n-\t\t\t\t   NULL, Empty);\n-  DECL_ARTIFICIAL (gnu_temp) = 1;\n-  DECL_IGNORED_P (gnu_temp) = 1;\n-\n+\t\t\t\t   true, false, NULL, Empty);\n   return gnu_temp;\n }\n \n@@ -4847,8 +4844,8 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t= create_var_decl (get_identifier (\"JMPBUF_SAVE\"), NULL_TREE,\n \t\t\t   jmpbuf_ptr_type,\n \t\t\t   build_call_n_expr (get_jmpbuf_decl, 0),\n-\t\t\t   false, false, false, false, NULL, gnat_node);\n-      DECL_ARTIFICIAL (gnu_jmpsave_decl) = 1;\n+\t\t\t   false, false, false, false, true, false,\n+\t\t\t   NULL, gnat_node);\n \n       /* The __builtin_setjmp receivers will immediately reinstall it.  Now\n \t because of the unstructured form of EH used by setjmp_longjmp, there\n@@ -4859,8 +4856,8 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t= create_var_decl (get_identifier (\"JMP_BUF\"), NULL_TREE,\n \t\t\t   jmpbuf_type,\n \t\t\t   NULL_TREE,\n-\t\t\t   false, false, false, false, NULL, gnat_node);\n-      DECL_ARTIFICIAL (gnu_jmpbuf_decl) = 1;\n+\t\t\t   false, false, false, false, true, false,\n+\t\t\t   NULL, gnat_node);\n \n       set_block_jmpbuf_decl (gnu_jmpbuf_decl);\n \n@@ -4917,7 +4914,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t\t     create_var_decl (get_identifier (\"EXCEPT_PTR\"), NULL_TREE,\n \t\t\t\t      build_pointer_type (except_type_node),\n \t\t\t\t      build_call_n_expr (get_excptr_decl, 0),\n-\t\t\t\t      false, false, false, false,\n+\t\t\t\t      false, false, false, false, true, false,\n \t\t\t\t      NULL, gnat_node));\n \n       /* Generate code for each handler. The N_Exception_Handler case does the\n@@ -5163,10 +5160,11 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n     = build_call_expr (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t       1, integer_zero_node);\n   prev_gnu_incoming_exc_ptr = gnu_incoming_exc_ptr;\n-  gnu_incoming_exc_ptr = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n-\t\t\t\t\t  ptr_type_node, gnu_current_exc_ptr,\n-\t\t\t\t\t  false, false, false, false,\n-\t\t\t\t\t  NULL, gnat_node);\n+  gnu_incoming_exc_ptr\n+    = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n+\t\t       ptr_type_node, gnu_current_exc_ptr,\n+\t\t       false, false, false, false, true, true,\n+\t\t       NULL, gnat_node);\n \n   add_stmt_with_node (build_call_n_expr (begin_handler_decl, 1,\n \t\t\t\t\t gnu_incoming_exc_ptr),\n@@ -5212,8 +5210,8 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   tree gnu_elab_proc_decl\n     = create_subprog_decl\n       (create_concat_name (gnat_unit_entity, body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, is_disabled, true, false, true, NULL,\n-       gnat_unit);\n+       NULL_TREE, void_ftype, NULL_TREE, is_disabled, true, false, true, true,\n+       NULL, gnat_unit);\n   struct elab_info *info;\n \n   vec_safe_push (gnu_elab_proc_stack, gnu_elab_proc_decl);\n@@ -6127,7 +6125,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t (Entity (Prefix (gnat_node)),\n \t\t\t\t  attr == Attr_Elab_Body ? \"elabb\" : \"elabs\"),\n \t\t\t\t NULL_TREE, void_ftype, NULL_TREE, is_disabled,\n-\t\t\t\t true, true, true, NULL, gnat_node);\n+\t\t\t\t true, true, true, true, NULL, gnat_node);\n \n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attr);\n       }\n@@ -7087,7 +7085,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t deallocated.  */\n       gnu_expr = create_var_decl (get_identifier (\"SAVED_EXPTR\"), NULL_TREE,\n \t\t\t\t  ptr_type_node, gnu_incoming_exc_ptr,\n-\t\t\t\t  false, false, false, false, NULL, gnat_node);\n+\t\t\t\t  false, false, false, false, true, true,\n+\t\t\t\t  NULL, gnat_node);\n \n       add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_incoming_exc_ptr,\n \t\t\t\t convert (ptr_type_node, integer_zero_node)));"}, {"sha": "fbdf4733833667122320df4708d1e1321b189061", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -1377,8 +1377,25 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       && !(TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t   && DECL_IGNORED_P (TYPE_NAME (type))))\n     {\n-      tree marker = make_node (RECORD_TYPE);\n       tree name = TYPE_IDENTIFIER (record);\n+      tree size_unit = TYPE_SIZE_UNIT (record);\n+\n+      /* A variable that holds the size is required even with no encoding since\n+\t it will be referenced by debugging information attributes.  At global\n+\t level, we need a single variable across all translation units.  */\n+      if (size\n+\t  && TREE_CODE (size) != INTEGER_CST\n+\t  && (definition || global_bindings_p ()))\n+\t{\n+\t  size_unit\n+\t    = create_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n+\t\t\t      size_unit, true, global_bindings_p (),\n+\t\t\t      !definition && global_bindings_p (), false,\n+\t\t\t      true, true, NULL, gnat_entity);\n+\t  TYPE_SIZE_UNIT (record) = size_unit;\n+\t}\n+\n+      tree marker = make_node (RECORD_TYPE);\n       tree orig_name = TYPE_IDENTIFIER (type);\n \n       TYPE_NAME (marker) = concat_name (name, \"XVS\");\n@@ -1388,14 +1405,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t\t\t     marker, NULL_TREE, NULL_TREE,\n \t\t\t\t\t     0, 0),\n \t\t\t  0, true);\n+      TYPE_SIZE_UNIT (marker) = size_unit;\n \n       add_parallel_type (record, marker);\n-\n-      if (definition && size && TREE_CODE (size) != INTEGER_CST)\n-\tTYPE_SIZE_UNIT (marker)\n-\t  = create_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n-\t\t\t     TYPE_SIZE_UNIT (record), false, false, false,\n-\t\t\t     false, NULL, gnat_entity);\n     }\n \n   rest_of_record_type_compilation (record);\n@@ -1537,7 +1549,7 @@ relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n }\n \f\n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.\n-   ARTIFICIAL_P is true if it's a type that was generated by the compiler.  */\n+   ARTIFICIAL_P is true if the type was generated by the compiler.  */\n \n void\n record_builtin_type (const char *name, tree type, bool artificial_p)\n@@ -2241,20 +2253,17 @@ create_range_type (tree type, tree min, tree max)\n tree\n create_type_stub_decl (tree type_name, tree type)\n {\n-  /* Using a named TYPE_DECL ensures that a type name marker is emitted in\n-     STABS while setting DECL_ARTIFICIAL ensures that no DW_TAG_typedef is\n-     emitted in DWARF.  */\n   tree type_decl = build_decl (input_location, TYPE_DECL, type_name, type);\n   DECL_ARTIFICIAL (type_decl) = 1;\n   TYPE_ARTIFICIAL (type) = 1;\n   return type_decl;\n }\n \n /* Return a TYPE_DECL node.  TYPE_NAME gives the name of the type and TYPE\n-   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if this\n-   is a declaration that was generated by the compiler.  DEBUG_INFO_P is\n-   true if we need to write debug information about this type.  GNAT_NODE\n-   is used for the position of the decl.  */\n+   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if the\n+   declaration was generated by the compiler.  DEBUG_INFO_P is true if we\n+   need to write debug information about this type.  GNAT_NODE is used for\n+   the position of the decl.  */\n \n tree\n create_type_decl (tree type_name, tree type, bool artificial_p,\n@@ -2322,13 +2331,18 @@ create_type_decl (tree type_name, tree type, bool artificial_p,\n    STATIC_FLAG is only relevant when not at top level.  In that case\n    it indicates whether to always allocate storage to the variable.\n \n+   ARTIFICIAL_P is true if the variable was generated by the compiler.\n+\n+   DEBUG_INFO_P is true if we need to write debug information for it.\n+\n    GNAT_NODE is used for the position of the decl.  */\n \n tree\n create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t   bool const_flag, bool public_flag, bool extern_flag,\n-\t\t   bool static_flag, bool const_decl_allowed_p,\n-\t\t   struct attrib *attr_list, Node_Id gnat_node)\n+\t\t   bool static_flag, bool artificial_p, bool debug_info_p,\n+\t\t   bool const_decl_allowed_p, struct attrib *attr_list,\n+\t\t   Node_Id gnat_node)\n {\n   /* Whether the object has static storage duration, either explicitly or by\n      virtue of being declared at the global level.  */\n@@ -2379,10 +2393,14 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n   if (var_init && !init_const && global_bindings_p ())\n     Check_Elaboration_Code_Allowed (gnat_node);\n \n-  DECL_INITIAL  (var_decl) = var_init;\n-  TREE_READONLY (var_decl) = const_flag;\n+  /* Attach the initializer, if any.  */\n+  DECL_INITIAL (var_decl) = var_init;\n+\n+  /* Directly set some flags.  */\n+  DECL_ARTIFICIAL (var_decl) = artificial_p;\n   DECL_EXTERNAL (var_decl) = extern_flag;\n   TREE_CONSTANT (var_decl) = constant_p;\n+  TREE_READONLY (var_decl) = const_flag;\n \n   /* We need to allocate static storage for an object with static storage\n      duration if it isn't external.  */\n@@ -2402,14 +2420,18 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n       && !have_global_bss_p ())\n     DECL_COMMON (var_decl) = 1;\n \n-  /* For an external constant whose initializer is not absolute, do not emit\n-     debug info.  In DWARF this would mean a global relocation in a read-only\n-     section which runs afoul of the PE-COFF run-time relocation mechanism.  */\n-  if (extern_flag\n-      && constant_p\n-      && var_init\n-      && initializer_constant_valid_p (var_init, TREE_TYPE (var_init))\n-\t != null_pointer_node)\n+  /* Do not emit debug info for a CONST_DECL if optimization isn't enabled,\n+     since we will create an associated variable.  Likewise for an external\n+     constant whose initializer is not absolute, because this would mean a\n+     global relocation in a read-only section which runs afoul of the PE-COFF\n+     run-time relocation mechanism.  */\n+  if (!debug_info_p\n+      || (TREE_CODE (var_decl) == CONST_DECL && !optimize)\n+      || (extern_flag\n+\t  && constant_p\n+\t  && var_init\n+\t  && initializer_constant_valid_p (var_init, TREE_TYPE (var_init))\n+\t     != null_pointer_node))\n     DECL_IGNORED_P (var_decl) = 1;\n \n   if (TYPE_VOLATILE (type))\n@@ -3023,23 +3045,29 @@ create_label_decl (tree label_name, Node_Id gnat_node)\n    node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n    PARM_DECL nodes chained through the DECL_CHAIN field).\n \n-   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG, ARTIFICIAL_FLAG and ATTR_LIST are\n-   used to set the appropriate fields in the FUNCTION_DECL.  GNAT_NODE is\n-   used for the position of the decl.  */\n+   INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG and ATTR_LIST are used to set the\n+   appropriate fields in the FUNCTION_DECL.\n+\n+   ARTIFICIAL_P is true if the subprogram was generated by the compiler.\n+\n+   DEBUG_INFO_P is true if we need to write debug information for it.\n+\n+   GNAT_NODE is used for the position of the decl.  */\n \n tree\n create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n  \t\t     tree param_decl_list, enum inline_status_t inline_status,\n-\t\t     bool public_flag, bool extern_flag, bool artificial_flag,\n-\t\t     struct attrib *attr_list, Node_Id gnat_node)\n+\t\t     bool public_flag, bool extern_flag, bool artificial_p,\n+\t\t     bool debug_info_p, struct attrib *attr_list,\n+\t\t     Node_Id gnat_node)\n {\n   tree subprog_decl = build_decl (input_location, FUNCTION_DECL, subprog_name,\n \t\t\t\t  subprog_type);\n   tree result_decl = build_decl (input_location, RESULT_DECL, NULL_TREE,\n \t\t\t\t TREE_TYPE (subprog_type));\n   DECL_ARGUMENTS (subprog_decl) = param_decl_list;\n \n-  DECL_ARTIFICIAL (subprog_decl) = artificial_flag;\n+  DECL_ARTIFICIAL (subprog_decl) = artificial_p;\n   DECL_EXTERNAL (subprog_decl) = extern_flag;\n \n   switch (inline_status)\n@@ -3062,13 +3090,16 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n \n     case is_enabled:\n       DECL_DECLARED_INLINE_P (subprog_decl) = 1;\n-      DECL_NO_INLINE_WARNING_P (subprog_decl) = artificial_flag;\n+      DECL_NO_INLINE_WARNING_P (subprog_decl) = artificial_p;\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  if (!debug_info_p)\n+    DECL_IGNORED_P (subprog_decl) = 1;\n+\n   TREE_PUBLIC (subprog_decl) = public_flag;\n   TREE_READONLY (subprog_decl) = TYPE_READONLY (subprog_type);\n   TREE_THIS_VOLATILE (subprog_decl) = TYPE_VOLATILE (subprog_type);"}, {"sha": "42a0ee9d3352ee319f0bb4a095adaf08c99dcc95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -1,3 +1,7 @@\n+2015-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/debug1.ads: Adjust.\n+\n 2015-06-19  Jim Wilson  <jim.wilson@linaro.org>\n \n \t* gcc.target/aarch64/fmovd-zero-mem.c: New."}, {"sha": "de0a7b90798b44da94a3e7c6b4f1c2ca98245930", "filename": "gcc/testsuite/gnat.dg/specs/debug1.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdebug1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a569ef313db23d0563be35eefa05d4d7bde772/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdebug1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fdebug1.ads?ref=c1a569ef313db23d0563be35eefa05d4d7bde772", "patch": "@@ -11,4 +11,4 @@ package Debug1 is\n \n end Debug1;\n \n--- { dg-final { scan-assembler-times \"DW_AT_artificial\" 17 } }\n+-- { dg-final { scan-assembler-times \"DW_AT_artificial\" 15 } }"}]}