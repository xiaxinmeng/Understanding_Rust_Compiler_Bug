{"sha": "6328ce1f83c260ac7728f9490870c326944b17d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyOGNlMWY4M2MyNjBhYzc3MjhmOTQ5MDg3MGMzMjY5NDRiMTdkOA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-05-08T21:55:13Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-05-08T21:55:13Z"}, "message": "re PR fortran/90351 (-fc-prototypes does not dump prototypes for external procedures)\n\n2019-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n    PR fortran/90351\n    PR fortran/90329\n    * gfortran.dg/dump-parse-tree.c: Include version.h.\n    (gfc_dump_external_c_prototypes): New function.\n    (get_c_type_name): Select \"char\" as a name for a simple char.\n    Adjust to handling external functions. Also handle complex.\n    (write_decl): Add argument bind_c. Adjust for dumping of external\n    procedures.\n    (write_proc): Likewise.\n    (write_interop_decl): Add bind_c argument to call of write_proc.\n    * gfortran.h: Add prototype for gfc_dump_external_c_prototypes.\n    * lang.opt: Add -fc-prototypes-external flag.\n    * parse.c (gfc_parse_file): Move dumping of BIND(C) prototypes.\n    Call gfc_dump_external_c_prototypes if option is set.\n    * invoke.texi: Document -fc-prototypes-external.\n\nFrom-SVN: r271018", "tree": {"sha": "6b41257889c17529a03ad9bc8a581c7080a3a748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b41257889c17529a03ad9bc8a581c7080a3a748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6328ce1f83c260ac7728f9490870c326944b17d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6328ce1f83c260ac7728f9490870c326944b17d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6328ce1f83c260ac7728f9490870c326944b17d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6328ce1f83c260ac7728f9490870c326944b17d8/comments", "author": null, "committer": null, "parents": [{"sha": "8ba2bda8e4b4276770901b720dee4f3d297dda3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba2bda8e4b4276770901b720dee4f3d297dda3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba2bda8e4b4276770901b720dee4f3d297dda3c"}], "stats": {"total": 176, "additions": 150, "deletions": 26}, "files": [{"sha": "c910af439cfce2466861df664ff5f574bf7b1be8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6328ce1f83c260ac7728f9490870c326944b17d8", "patch": "@@ -1,3 +1,21 @@\n+2019-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/90351\n+\tPR fortran/90329\n+\t* gfortran.dg/dump-parse-tree.c: Include version.h.\n+\t(gfc_dump_external_c_prototypes): New function.\n+\t(get_c_type_name): Select \"char\" as a name for a simple char.\n+\tAdjust to handling external functions. Also handle complex.\n+\t(write_decl): Add argument bind_c. Adjust for dumping of external\n+\tprocedures.\n+\t(write_proc): Likewise.\n+\t(write_interop_decl): Add bind_c argument to call of write_proc.\n+\t* gfortran.h: Add prototype for gfc_dump_external_c_prototypes.\n+\t* lang.opt: Add -fc-prototypes-external flag.\n+\t* parse.c (gfc_parse_file): Move dumping of BIND(C) prototypes.\n+\tCall gfc_dump_external_c_prototypes if option is set.\n+\t* invoke.texi: Document -fc-prototypes-external.\n+\n 2019-05-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/90290"}, {"sha": "54af5dfd50dacbd8dee351653b58c9a75eb952f2", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 87, "deletions": 21, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=6328ce1f83c260ac7728f9490870c326944b17d8", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"gfortran.h\"\n #include \"constructor.h\"\n+#include \"version.h\"\n \n /* Keep track of indentation for symbol tree dumps.  */\n static int show_level = 0;\n@@ -3074,6 +3075,7 @@ gfc_dump_parse_tree (gfc_namespace *ns, FILE *file)\n /* This part writes BIND(C) definition for use in external C programs.  */\n \n static void write_interop_decl (gfc_symbol *);\n+static void write_proc (gfc_symbol *, bool);\n \n void\n gfc_dump_c_prototypes (gfc_namespace *ns, FILE *file)\n@@ -3086,6 +3088,33 @@ gfc_dump_c_prototypes (gfc_namespace *ns, FILE *file)\n   gfc_traverse_ns (ns, write_interop_decl);\n }\n \n+/* Loop over all global symbols, writing out their declrations.  */\n+\n+void\n+gfc_dump_external_c_prototypes (FILE * file)\n+{\n+  dumpfile = file;\n+  fprintf (dumpfile,\n+\t   _(\"/* Prototypes for external procedures generated from %s\\n\"\n+\t     \"   by GNU Fortran %s%s.\\n\\n\"\n+\t     \"   Use of this interface is discouraged, consider using the\\n\"\n+\t     \"   BIND(C) feature of standard Fortran instead.  */\\n\\n\"),\n+\t   gfc_source_file, pkgversion_string, version_string);\n+\n+  for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;\n+       gfc_current_ns = gfc_current_ns->sibling)\n+    {\n+      gfc_symbol *sym = gfc_current_ns->proc_name;\n+\n+      if (sym == NULL || sym->attr.flavor != FL_PROCEDURE\n+\t  || sym->attr.is_bind_c)\n+\tcontinue;\n+\n+      write_proc (sym, false);\n+    }\n+  return;\n+}\n+\n enum type_return { T_OK=0, T_WARN, T_ERROR };\n \n /* Return the name of the type for later output.  Both function pointers and\n@@ -3104,7 +3133,7 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n   *asterisk = false;\n   *post = \"\";\n   *type_name = \"<error>\";\n-  if (ts->type == BT_REAL || ts->type == BT_INTEGER)\n+  if (ts->type == BT_REAL || ts->type == BT_INTEGER || ts->type == BT_COMPLEX)\n     {\n       if (ts->is_c_interop && ts->interop_kind)\n \t{\n@@ -3113,6 +3142,12 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n \t    *type_name = \"signed char\";\n \t  else if (strcmp (*type_name, \"size_t\") == 0)\n \t    *type_name = \"ssize_t\";\n+\t  else if (strcmp (*type_name, \"float_complex\") == 0)\n+\t    *type_name = \"float complex\";\n+\t  else if (strcmp (*type_name, \"double_complex\") == 0)\n+\t    *type_name = \"double complex\";\n+\t  else if (strcmp (*type_name, \"long_double_complex\") == 0)\n+\t    *type_name = \"long double complex\";\n \n \t  ret = T_OK;\n \t}\n@@ -3130,6 +3165,12 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n \t\t    *type_name = \"signed char\";\n \t\t  else if (strcmp (*type_name, \"size_t\") == 0)\n \t\t    *type_name = \"ssize_t\";\n+\t\t  else if (strcmp (*type_name, \"float_complex\") == 0)\n+\t\t    *type_name = \"float complex\";\n+\t\t  else if (strcmp (*type_name, \"double_complex\") == 0)\n+\t\t    *type_name = \"double complex\";\n+\t\t  else if (strcmp (*type_name, \"long_double_complex\") == 0)\n+\t\t    *type_name = \"long double complex\";\n \n \t\t  ret = T_WARN;\n \t\t  break;\n@@ -3167,16 +3208,21 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n \t}\n       else\n \t{\n-\t  /* Let's select an appropriate int, with a warning. */\n-\t  for (int i = 0; i < ISOCBINDING_NUMBER; i++)\n-\t    {\n-\t      if (c_interop_kinds_table[i].f90_type == BT_INTEGER\n-\t\t  && c_interop_kinds_table[i].value == ts->kind)\n-\t\t{\n-\t\t  *type_name = c_interop_kinds_table[i].name + 2;\n-\t\t  ret = T_WARN;\n-\t\t}\n+\t  if (ts->kind == gfc_default_character_kind)\n+\t    *type_name = \"char\";\n+\t  else\n+\t    /* Let's select an appropriate int. */\n+\t    for (int i = 0; i < ISOCBINDING_NUMBER; i++)\n+\t      {\n+\t\tif (c_interop_kinds_table[i].f90_type == BT_INTEGER\n+\t\t    && c_interop_kinds_table[i].value == ts->kind)\n+\t\t  {\n+\t\t    *type_name = c_interop_kinds_table[i].name + 2;\n+\t\t    break;\n+\t\t  }\n \t    }\n+\t  ret = T_WARN;\n+\n \t}\n     }\n   else if (ts->type == BT_DERIVED)\n@@ -3200,12 +3246,14 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n \t\t}\n \t    }\n \t  *asterisk = true;\n+\t  ret = T_OK;\n \t}\n       else\n \t*type_name = ts->u.derived->name;\n \n       ret = T_OK;\n     }\n+\n   if (ret != T_ERROR && as)\n     {\n       mpz_t sz;\n@@ -3222,7 +3270,7 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,\n /* Write out a declaration.  */\n static void\n write_decl (gfc_typespec *ts, gfc_array_spec *as, const char *sym_name,\n-\t    bool func_ret, locus *where)\n+\t    bool func_ret, locus *where, bool bind_c)\n {\n   const char *pre, *type_name, *post;\n   bool asterisk;\n@@ -3245,7 +3293,7 @@ write_decl (gfc_typespec *ts, gfc_array_spec *as, const char *sym_name,\n   fputs (sym_name, dumpfile);\n   fputs (post, dumpfile);\n \n-  if (rok == T_WARN)\n+  if (rok == T_WARN && bind_c)\n     fprintf (dumpfile,\" /* WARNING: Converting '%s' to interoperable type */\",\n \t     gfc_typename (ts));\n }\n@@ -3262,7 +3310,7 @@ write_type (gfc_symbol *sym)\n   for (c = sym->components; c; c = c->next)\n     {\n       fputs (\"    \", dumpfile);\n-      write_decl (&(c->ts), c->as, c->name, false, &sym->declared_at);\n+      write_decl (&(c->ts), c->as, c->name, false, &sym->declared_at, true);\n       fputs (\";\\n\", dumpfile);\n     }\n \n@@ -3284,37 +3332,50 @@ write_variable (gfc_symbol *sym)\n     sym_name = sym->name;\n \n   fputs (\"extern \", dumpfile);\n-  write_decl (&(sym->ts), sym->as, sym_name, false, &sym->declared_at);\n+  write_decl (&(sym->ts), sym->as, sym_name, false, &sym->declared_at, true);\n   fputs (\";\\n\", dumpfile);\n }\n \n \n /* Write out a procedure, including its arguments.  */\n static void\n-write_proc (gfc_symbol *sym)\n+write_proc (gfc_symbol *sym, bool bind_c)\n {\n   const char *pre, *type_name, *post;\n   bool asterisk;\n   enum type_return rok;\n   gfc_formal_arglist *f;\n   const char *sym_name;\n   const char *intent_in;\n+  bool external_character;\n+\n+  external_character =  sym->ts.type == BT_CHARACTER && !bind_c;\n \n   if (sym->binding_label)\n     sym_name = sym->binding_label;\n   else\n     sym_name = sym->name;\n \n-  if (sym->ts.type == BT_UNKNOWN)\n+  if (sym->ts.type == BT_UNKNOWN || external_character)\n     {\n       fprintf (dumpfile, \"void \");\n       fputs (sym_name, dumpfile);\n     }\n   else\n-    write_decl (&(sym->ts), sym->as, sym_name, true, &sym->declared_at);\n+    write_decl (&(sym->ts), sym->as, sym_name, true, &sym->declared_at, bind_c);\n \n-  fputs (\" (\", dumpfile);\n+  if (!bind_c)\n+    fputs (\"_\", dumpfile);\n \n+  fputs (\" (\", dumpfile);\n+  if (external_character)\n+    {\n+      fprintf (dumpfile, \"char *result_%s, size_t result_%s_len\",\n+\t       sym_name, sym_name);\n+      if (sym->formal)\n+\tfputs (\", \", dumpfile);\n+    }\n+      \n   for (f = sym->formal; f; f = f->next)\n     {\n       gfc_symbol *s;\n@@ -3325,7 +3386,7 @@ write_proc (gfc_symbol *sym)\n \t{\n \t  gfc_error_now (\"Cannot convert %qs to interoperable type at %L\",\n \t\t\t gfc_typename (&s->ts), &s->declared_at);\n-\t  fprintf (stderr, \"/* Cannot convert '%s' to interoperable type */\",\n+\t  fprintf (dumpfile, \"/* Cannot convert '%s' to interoperable type */\",\n \t\t   gfc_typename (&s->ts));\n \t  return;\n \t}\n@@ -3346,12 +3407,17 @@ write_proc (gfc_symbol *sym)\n \n       fputs (s->name, dumpfile);\n       fputs (post, dumpfile);\n-      if (rok == T_WARN)\n+      if (bind_c && rok == T_WARN)\n \tfputs(\" /* WARNING: non-interoperable KIND */ \", dumpfile);\n \n       if (f->next)\n \tfputs(\", \", dumpfile);\n     }\n+  if (!bind_c)\n+    for (f = sym->formal; f; f = f->next)\n+      if (f->sym->ts.type == BT_CHARACTER)\n+\tfprintf (dumpfile, \", size_t %s_len\", f->sym->name);\n+\n   fputs (\");\\n\", dumpfile);\n }\n \n@@ -3375,5 +3441,5 @@ write_interop_decl (gfc_symbol *sym)\n   else if (sym->attr.flavor == FL_DERIVED)\n     write_type (sym);\n   else if (sym->attr.flavor == FL_PROCEDURE)\n-    write_proc (sym);\n+    write_proc (sym, true);\n }"}, {"sha": "0de375cf0bbb779ffb8f6e940e1f647efa88aae2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6328ce1f83c260ac7728f9490870c326944b17d8", "patch": "@@ -3462,6 +3462,7 @@ void gfc_delete_bbt (void *, void *, compare_fn);\n /* dump-parse-tree.c */\n void gfc_dump_parse_tree (gfc_namespace *, FILE *);\n void gfc_dump_c_prototypes (gfc_namespace *, FILE *);\n+void gfc_dump_external_c_prototypes (FILE *);\n \n /* parse.c */\n bool gfc_parse_file (void);"}, {"sha": "efc7aea588a9f09554563e453aa406fb891ddfda", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=6328ce1f83c260ac7728f9490870c326944b17d8", "patch": "@@ -176,7 +176,7 @@ and warnings}.\n \n @item Interoperability Options\n @xref{Interoperability Options,,Options for interoperability}.\n-@gccoptlist{-fc-prototypes}\n+@gccoptlist{-fc-prototypes -fc-prototypes-external}\n \n @item Code Generation Options\n @xref{Code Gen Options,,Options for code generation conventions}.\n@@ -1870,7 +1870,7 @@ shared by @command{gfortran}, @command{gcc}, and other GNU compilers.\n \n @item -fc-prototypes\n @opindex @code{c-prototypes}\n-@cindex Generating C prototypes from Fortran source code\n+@cindex Generating C prototypes from Fortran BIND(C) enteties\n This option will generate C prototypes from @code{BIND(C)} variable\n declarations, types and procedure interfaces and writes them to\n standard output.  @code{ENUM} is not yet supported.\n@@ -1889,6 +1889,32 @@ $ gfortran -fc-prototypes -fsyntax-only foo.f90 > foo.h\n @end smallexample\n where the C code intended for interoperating with the Fortran code\n then  uses @code{#include \"foo.h\"}.\n+\n+@item -fc-prototypes-external\n+@opindex @code{c-prototypes-external}\n+@cindex Generating C prototypes from external procedures\n+This option will generate C prototypes from external functions and\n+subroutines and write them to standard output.  This may be useful for\n+making sure that C bindings to Fortran code are correct.  This option\n+does not generate prototypes for @code{BIND(C)} procedures, use\n+@option{-fc-prototypes} for that.\n+\n+The generated prototypes may need inclusion of an appropriate\n+header, such as as @code{<stdint.h>} or @code{<stdlib.h>}.\n+\n+This is primarily meant for legacy code to ensure that existing C\n+bindings match what @command{gfortran} emits.  The generated C\n+prototypes should be correct for the current version of the compiler,\n+but may not match what other compilers or earlier versions of\n+@command{gfortran} need.  For new developments, use of the\n+@code{BIND(C)} features is recommended.\n+\n+Example of use:\n+@smallexample\n+$ gfortran -fc-prototypes-external -fsyntax-only foo.f > foo.h\n+@end smallexample\n+where the C code intended for interoperating with the Fortran code\n+then  uses @code{#include \"foo.h\"}.\n @end table\n \n @node Environment Variables"}, {"sha": "be722d7e18363be6f5fa942d85bba01a213d1d74", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=6328ce1f83c260ac7728f9490870c326944b17d8", "patch": "@@ -428,6 +428,10 @@ fc-prototypes\n Fortran Var(flag_c_prototypes)\n Generate C prototypes from BIND(C) declarations.\n \n+fc-prototypes-external\n+Fortran Var(flag_c_prototypes_external)\n+Generate C prototypes from non-BIND(C) external procedure definitions.\n+\n fd-lines-as-code\n Fortran RejectNegative\n Ignore 'D' in column one in fixed form."}, {"sha": "9d693595e207015a1c6f0f10c9d8fea3a9e04e8d", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6328ce1f83c260ac7728f9490870c326944b17d8/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6328ce1f83c260ac7728f9490870c326944b17d8", "patch": "@@ -6278,9 +6278,6 @@ gfc_parse_file (void)\n   if (flag_dump_fortran_original)\n     gfc_dump_parse_tree (gfc_current_ns, stdout);\n \n-  if (flag_c_prototypes)\n-    gfc_dump_c_prototypes (gfc_current_ns, stdout);\n-\n   gfc_get_errors (NULL, &errors);\n   if (s.state == COMP_MODULE || s.state == COMP_SUBMODULE)\n     {\n@@ -6333,6 +6330,18 @@ gfc_parse_file (void)\n \tfputs (\"------------------------------------------\\n\\n\", stdout);\n       }\n \n+  /* Dump C prototypes.  */\n+  if (flag_c_prototypes)\n+    {\n+      for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;\n+\t   gfc_current_ns = gfc_current_ns->sibling)\n+\tgfc_dump_c_prototypes (gfc_current_ns, stdout);\n+    }\n+\n+  /* Dump external prototypes.  */\n+  if (flag_c_prototypes_external)\n+    gfc_dump_external_c_prototypes (stdout);\n+\n   /* Do the translation.  */\n   translate_all_program_units (gfc_global_ns_list);\n "}]}