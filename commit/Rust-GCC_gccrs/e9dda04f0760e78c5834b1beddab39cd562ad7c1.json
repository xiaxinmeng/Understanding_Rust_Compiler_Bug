{"sha": "e9dda04f0760e78c5834b1beddab39cd562ad7c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkZGEwNGYwNzYwZTc4YzU4MzRiMWJlZGRhYjM5Y2Q1NjJhZDdjMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-09-28T22:01:48Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-09-28T22:01:48Z"}, "message": "[RS6000] .gnu.attributes Tag_GNU_Power_ABI_FP\n\nExtend this attribute to cover long double ABIs, for 64-bit too.\n\nThis patch also corrects an error that crept in to code setting\nrs6000_passes_float.  See the added comment.  Passing IEEE128 values\nin vsx regs ought to set both Tag_GNU_Power_ABI_FP and\nTag_GNU_Power_ABI_Vector.  Also adds a new option, default on, that\ndisables output of .gnu_attribute assembly directives.\n\n\t* config/rs6000/sysv4.opt (mgnu-attribute): New option.\n\t* doc/invoke.texi: Document it.\n\t* config/rs6000/rs6000.c (HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE): Define.\n\t(rs6000_passes_float): Comment.\n\t(rs6000_passes_long_double): New static var.\n\t(call_ABI_of_interest): Return false unless rs6000_gnu_attr is set.\n\t(init_cumulative_args): Set up to emit fp .gnu_attribute for\n\tELF 64-bit ABIs as well as 32-bit ELF.  Correct rs6000_passes_float\n\tto include fp values returned in vectors.\n\tSet rs6000_passes_long_double.\n\t(rs6000_function_arg_advance_1): Likewise for function args.\n\t(rs6000_elf_file_end): Emit fp .gnu_attribute for ELF 64-bit ABIs,\n\tand SPE.  Emit long double tag value too.\n\t(rs6000_opt_vars): Add gnu-attr.\n\t* configure.ac (HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE): New ppc32 test.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\nFrom-SVN: r240601", "tree": {"sha": "7d561e18cf4ecf2d793c4c34f392eac627e6209d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d561e18cf4ecf2d793c4c34f392eac627e6209d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9dda04f0760e78c5834b1beddab39cd562ad7c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9dda04f0760e78c5834b1beddab39cd562ad7c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9dda04f0760e78c5834b1beddab39cd562ad7c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9dda04f0760e78c5834b1beddab39cd562ad7c1/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91eaca5e32abab6179fba0e2543daf1cc1f64bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91eaca5e32abab6179fba0e2543daf1cc1f64bde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91eaca5e32abab6179fba0e2543daf1cc1f64bde"}], "stats": {"total": 223, "additions": 203, "deletions": 20}, "files": [{"sha": "f2c8fe47b991224e06ff0da491e46c4b582ba622", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -1,3 +1,23 @@\n+2016-09-29  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/sysv4.opt (mgnu-attribute): New option.\n+\t* doc/invoke.texi: Document it.\n+\t* config/rs6000/rs6000.c (HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE): Define.\n+\t(rs6000_passes_float): Comment.\n+\t(rs6000_passes_long_double): New static var.\n+\t(call_ABI_of_interest): Return false unless rs6000_gnu_attr is set.\n+\t(init_cumulative_args): Set up to emit fp .gnu_attribute for\n+\tELF 64-bit ABIs as well as 32-bit ELF.  Correct rs6000_passes_float\n+\tto include fp values returned in vectors.\n+\tSet rs6000_passes_long_double.\n+\t(rs6000_function_arg_advance_1): Likewise for function args.\n+\t(rs6000_elf_file_end): Emit fp .gnu_attribute for ELF 64-bit ABIs,\n+\tand SPE.  Emit long double tag value too.\n+\t(rs6000_opt_vars): Add gnu-attr.\n+\t* configure.ac (HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE): New ppc32 test.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\n 2016-09-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimple-ssa-sprintf.c (pass_sprintf_length::gate): Use x > 0 instead"}, {"sha": "84704566cf80f2e5c0806162e1f8697bfbda7ca9", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -1538,6 +1538,12 @@\n #endif\n \n \n+/* Define if your PowerPC linker has .gnu.attributes long double support. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE\n+#endif\n+\n+\n /* Define if your linker supports --push-state/--pop-state */\n #ifndef USED_FOR_TARGET\n #undef HAVE_LD_PUSHPOPSTATE_SUPPORT"}, {"sha": "c7ba617d4f02f3d0c8274a073a4732ec0c1e9d2d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 67, "deletions": 20, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -183,8 +183,16 @@ unsigned rs6000_pmode;\n unsigned rs6000_pointer_size;\n \n #ifdef HAVE_AS_GNU_ATTRIBUTE\n-/* Flag whether floating point values have been passed/returned.  */\n+# ifndef HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE\n+# define HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE 0\n+# endif\n+/* Flag whether floating point values have been passed/returned.\n+   Note that this doesn't say whether fprs are used, since the\n+   Tag_GNU_Power_ABI_FP .gnu.attributes value this flag controls\n+   should be set for soft-float values passed in gprs and ieee128\n+   values passed in vsx registers.  */\n static bool rs6000_passes_float;\n+static bool rs6000_passes_long_double;\n /* Flag whether vector values have been passed/returned.  */\n static bool rs6000_passes_vector;\n /* Flag whether small (<= 8 byte) structures have been returned.  */\n@@ -10920,7 +10928,7 @@ rs6000_return_in_msb (const_tree valtype)\n static bool\n call_ABI_of_interest (tree fndecl)\n {\n-  if (symtab->state == EXPANSION)\n+  if (rs6000_gnu_attr && symtab->state == EXPANSION)\n     {\n       struct cgraph_node *c_node;\n \n@@ -10997,7 +11005,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n     }\n \n #ifdef HAVE_AS_GNU_ATTRIBUTE\n-  if (DEFAULT_ABI == ABI_V4)\n+  if (TARGET_ELF && (TARGET_64BIT || DEFAULT_ABI == ABI_V4))\n     {\n       cum->escapes = call_ABI_of_interest (fndecl);\n       if (cum->escapes)\n@@ -11025,10 +11033,19 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t      <= 8))\n \t\trs6000_returns_struct = true;\n \t    }\n-\t  if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (return_mode))\n-\t    rs6000_passes_float = true;\n-\t  else if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode)\n-\t\t   || SPE_VECTOR_MODE (return_mode))\n+\t  if (SCALAR_FLOAT_MODE_P (return_mode))\n+\t    {\n+\t      rs6000_passes_float = true;\n+\t      if ((HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE || TARGET_64BIT)\n+\t\t  && (FLOAT128_IBM_P (return_mode)\n+\t\t      || FLOAT128_IEEE_P (return_mode)\n+\t\t      || (return_type != NULL\n+\t\t\t  && (TYPE_MAIN_VARIANT (return_type)\n+\t\t\t      == long_double_type_node))))\n+\t\trs6000_passes_long_double = true;\n+\t    }\n+\t  if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode)\n+\t      || SPE_VECTOR_MODE (return_mode))\n \t    rs6000_passes_vector = true;\n \t}\n     }\n@@ -11475,16 +11492,23 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n     cum->nargs_prototype--;\n \n #ifdef HAVE_AS_GNU_ATTRIBUTE\n-  if (DEFAULT_ABI == ABI_V4\n+  if (TARGET_ELF && (TARGET_64BIT || DEFAULT_ABI == ABI_V4)\n       && cum->escapes)\n     {\n-      if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode))\n-\trs6000_passes_float = true;\n-      else if (named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n-\trs6000_passes_vector = true;\n-      else if (SPE_VECTOR_MODE (mode)\n-\t       && !cum->stdarg\n-\t       && cum->sysv_gregno <= GP_ARG_MAX_REG)\n+      if (SCALAR_FLOAT_MODE_P (mode))\n+\t{\n+\t  rs6000_passes_float = true;\n+\t  if ((HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE || TARGET_64BIT)\n+\t      && (FLOAT128_IBM_P (mode)\n+\t\t  || FLOAT128_IEEE_P (mode)\n+\t\t  || (type != NULL\n+\t\t      && TYPE_MAIN_VARIANT (type) == long_double_type_node)))\n+\t    rs6000_passes_long_double = true;\n+\t}\n+      if ((named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n+\t  || (SPE_VECTOR_MODE (mode)\n+\t      && !cum->stdarg\n+\t      && cum->sysv_gregno <= GP_ARG_MAX_REG))\n \trs6000_passes_vector = true;\n     }\n #endif\n@@ -34292,13 +34316,33 @@ static void\n rs6000_elf_file_end (void)\n {\n #ifdef HAVE_AS_GNU_ATTRIBUTE\n+  /* ??? The value emitted depends on options active at file end.\n+     Assume anyone using #pragma or attributes that might change\n+     options knows what they are doing.  */\n+  if ((TARGET_64BIT || DEFAULT_ABI == ABI_V4)\n+      && rs6000_passes_float)\n+    {\n+      int fp;\n+\n+      if (TARGET_DF_FPR | TARGET_DF_SPE)\n+\tfp = 1;\n+      else if (TARGET_SF_FPR | TARGET_SF_SPE)\n+\tfp = 3;\n+      else\n+\tfp = 2;\n+      if (rs6000_passes_long_double)\n+\t{\n+\t  if (!TARGET_LONG_DOUBLE_128)\n+\t    fp |= 2 * 4;\n+\t  else if (TARGET_IEEEQUAD)\n+\t    fp |= 3 * 4;\n+\t  else\n+\t    fp |= 1 * 4;\n+\t}\n+      fprintf (asm_out_file, \"\\t.gnu_attribute 4, %d\\n\", fp);\n+    }\n   if (TARGET_32BIT && DEFAULT_ABI == ABI_V4)\n     {\n-      if (rs6000_passes_float)\n-\tfprintf (asm_out_file, \"\\t.gnu_attribute 4, %d\\n\",\n-\t\t ((TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT) ? 1 \n-\t\t  : (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT) ? 3 \n-\t\t  : 2));\n       if (rs6000_passes_vector)\n \tfprintf (asm_out_file, \"\\t.gnu_attribute 8, %d\\n\",\n \t\t (TARGET_ALTIVEC_ABI ? 2\n@@ -37085,6 +37129,9 @@ static struct rs6000_opt_var const rs6000_opt_vars[] =\n   { \"warn-cell-microcode\",\n     offsetof (struct gcc_options, x_rs6000_warn_cell_microcode),\n     offsetof (struct cl_target_option, x_rs6000_warn_cell_microcode), },\n+  { \"gnu-attr\",\n+    offsetof (struct gcc_options, x_rs6000_gnu_attr),\n+    offsetof (struct cl_target_option, x_rs6000_gnu_attr), },\n };\n \n /* Inner function to handle attribute((target(\"...\"))) and #pragma GCC target"}, {"sha": "cb5d7eabbeb864784fe616de203dd121440f5a46", "filename": "gcc/config/rs6000/sysv4.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.opt?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -155,3 +155,7 @@ Generate code to use a non-exec PLT and GOT.\n mbss-plt\n Target Report RejectNegative Var(secure_plt, 0) Save\n Generate code for old exec BSS PLT.\n+\n+mgnu-attribute\n+Target Report Var(rs6000_gnu_attr) Init(1) Save\n+Emit .gnu_attribute tags."}, {"sha": "47f70e6c2f4e55c29993eb1b571ca0d63c8b4ed5", "filename": "gcc/configure", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -28322,6 +28322,58 @@ fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_clearcap\" >&5\n $as_echo \"$gcc_cv_ld_clearcap\" >&6; }\n \n+case \"$target\" in\n+  powerpc*-*-*)\n+    case \"$target\" in\n+      *le-*-linux*)\n+\temul_name=\"-melf32lppc\"\n+\t;;\n+      *)\n+\temul_name=\"-melf32ppc\"\n+\t;;\n+    esac\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking linker .gnu.attributes long double support\" >&5\n+$as_echo_n \"checking linker .gnu.attributes long double support... \" >&6; }\n+if test \"${gcc_cv_ld_ppc_attr+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_ld_ppc_attr=no\n+    if test x\"$ld_is_gold\" = xyes; then\n+      gcc_cv_ld_ppc_attr=yes\n+    elif test $in_tree_ld = yes ; then\n+      if test \"$gcc_cv_gld_major_version\" -eq 2 \\\n+\t\t-a \"$gcc_cv_gld_minor_version\" -ge 28 \\\n+\t\t-o \"$gcc_cv_gld_major_version\" -gt 2; then\n+        gcc_cv_ld_ppc_attr=yes\n+      fi\n+    elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x ; then\n+      # check that merging the long double .gnu_attribute doesn't warn\n+      cat > conftest1.s <<EOF\n+\t.gnu_attribute 4,1\n+EOF\n+      cat > conftest2.s <<EOF\n+\t.gnu_attribute 4,9\n+EOF\n+      if $gcc_cv_as -a32 -o conftest1.o conftest1.s > /dev/null 2>&1 \\\n+         && $gcc_cv_as -a32 -o conftest2.o conftest2.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld $emul_name -r -o conftest.o conftest1.o conftest2.o > /dev/null 2> conftest.err \\\n+\t && test ! -s conftest.err; then\n+        gcc_cv_ld_ppc_attr=yes\n+      fi\n+      rm -f conftest.err conftest.o conftest1.o conftest2.o conftest1.s conftest2.s\n+    fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_ppc_attr\" >&5\n+$as_echo \"$gcc_cv_ld_ppc_attr\" >&6; }\n+    if test x$gcc_cv_ld_ppc_attr = xyes; then\n+\n+$as_echo \"#define HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE 1\" >>confdefs.h\n+\n+    fi\n+    ;;\n+esac\n+\n case \"$target:$tm_file\" in\n   powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)\n   case \"$target\" in"}, {"sha": "a702f176974d34181d0baa70115ee1bac8da696f", "filename": "gcc/configure.ac", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -5322,6 +5322,51 @@ if test \"x$gcc_cv_ld_clearcap\" = xyes; then\n fi\n AC_MSG_RESULT($gcc_cv_ld_clearcap)\n \n+case \"$target\" in\n+  powerpc*-*-*)\n+    case \"$target\" in\n+      *le-*-linux*)\n+\temul_name=\"-melf32lppc\"\n+\t;;\n+      *)\n+\temul_name=\"-melf32ppc\"\n+\t;;\n+    esac\n+    AC_CACHE_CHECK(linker .gnu.attributes long double support,\n+    gcc_cv_ld_ppc_attr,\n+    [gcc_cv_ld_ppc_attr=no\n+    if test x\"$ld_is_gold\" = xyes; then\n+      gcc_cv_ld_ppc_attr=yes\n+    elif test $in_tree_ld = yes ; then\n+      if test \"$gcc_cv_gld_major_version\" -eq 2 \\\n+\t\t-a \"$gcc_cv_gld_minor_version\" -ge 28 \\\n+\t\t-o \"$gcc_cv_gld_major_version\" -gt 2; then\n+        gcc_cv_ld_ppc_attr=yes\n+      fi\n+    elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x ; then\n+      # check that merging the long double .gnu_attribute doesn't warn\n+      cat > conftest1.s <<EOF\n+\t.gnu_attribute 4,1\n+EOF\n+      cat > conftest2.s <<EOF\n+\t.gnu_attribute 4,9\n+EOF\n+      if $gcc_cv_as -a32 -o conftest1.o conftest1.s > /dev/null 2>&1 \\\n+         && $gcc_cv_as -a32 -o conftest2.o conftest2.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld $emul_name -r -o conftest.o conftest1.o conftest2.o > /dev/null 2> conftest.err \\\n+\t && test ! -s conftest.err; then\n+        gcc_cv_ld_ppc_attr=yes\n+      fi\n+      rm -f conftest.err conftest.o conftest1.o conftest2.o conftest1.s conftest2.s\n+    fi\n+    ])\n+    if test x$gcc_cv_ld_ppc_attr = xyes; then\n+      AC_DEFINE(HAVE_LD_PPC_GNU_ATTR_LONG_DOUBLE, 1,\n+    [Define if your PowerPC linker has .gnu.attributes long double support.])\n+    fi\n+    ;;\n+esac\n+\n case \"$target:$tm_file\" in\n   powerpc64-*-freebsd* | powerpc64*-*-linux* | powerpc*-*-linux*rs6000/biarch64.h*)\n   case \"$target\" in"}, {"sha": "8a84e4f4823f5a17a3b62c6f804b1e3bdb7e5b18", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9dda04f0760e78c5834b1beddab39cd562ad7c1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e9dda04f0760e78c5834b1beddab39cd562ad7c1", "patch": "@@ -1017,6 +1017,7 @@ See RS/6000 and PowerPC Options.\n -mupper-regs-di -mno-upper-regs-di @gol\n -mupper-regs -mno-upper-regs @gol\n -mfloat128 -mno-float128 -mfloat128-hardware -mno-float128-hardware @gol\n+-mgnu-attribute -mno-gnu-attribute @gol\n -mlra -mno-lra}\n \n @emph{RX Options}\n@@ -21299,6 +21300,14 @@ This is the default ABI for little-endian PowerPC 64-bit Linux.\n Overriding the default ABI requires special system support and is\n likely to fail in spectacular ways.\n \n+@item -mgnu-attribute\n+@itemx -mno-gnu-attribute\n+@opindex mgnu-attribute\n+@opindex mno-gnu-attribute\n+Emit .gnu_attribute assembly directives to set tag/value pairs in a\n+.gnu.attributes section that specify ABI variations in function\n+parameters or return values.\n+\n @item -mprototype\n @itemx -mno-prototype\n @opindex mprototype"}]}