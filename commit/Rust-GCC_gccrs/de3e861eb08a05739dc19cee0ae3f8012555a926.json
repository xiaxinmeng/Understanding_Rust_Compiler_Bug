{"sha": "de3e861eb08a05739dc19cee0ae3f8012555a926", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUzZTg2MWViMDhhMDU3MzlkYzE5Y2VlMGFlM2Y4MDEyNTU1YTkyNg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-08-20T17:36:05Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-08-20T17:36:05Z"}, "message": "Add support for branch information.\n\nFrom-SVN: r45055", "tree": {"sha": "717c354a1f1b82818c8445ed90ce6ca2829f0897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/717c354a1f1b82818c8445ed90ce6ca2829f0897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de3e861eb08a05739dc19cee0ae3f8012555a926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3e861eb08a05739dc19cee0ae3f8012555a926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de3e861eb08a05739dc19cee0ae3f8012555a926", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3e861eb08a05739dc19cee0ae3f8012555a926/comments", "author": null, "committer": null, "parents": [{"sha": "d57339219334d38ac544dd1a3c8b86951b382180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d57339219334d38ac544dd1a3c8b86951b382180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d57339219334d38ac544dd1a3c8b86951b382180"}], "stats": {"total": 202, "additions": 179, "deletions": 23}, "files": [{"sha": "9a81f7e4689dc6de16afce29469606da6a191559", "filename": "gcc/testsuite/gcc.misc-tests/gcov.exp", "status": "modified", "additions": 179, "deletions": 23, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de3e861eb08a05739dc19cee0ae3f8012555a926/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de3e861eb08a05739dc19cee0ae3f8012555a926/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov.exp?ref=de3e861eb08a05739dc19cee0ae3f8012555a926", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 1997 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 2001 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -36,44 +36,200 @@ proc clean-gcov { testcase } {\n     remote_file host delete $base.bb $base.bbg $base.da $basename.gcov\n }\n \n-# Called by dg-final to run gcov and analyze the results.\n-\n-proc run-gcov { testcase } {\n-    global GCOV\n-\n-    verbose \"Running $GCOV $testcase\" 2\n-    set testcase [remote_download host $testcase];\n-    set result [remote_exec host $GCOV $testcase];\n-    if { [lindex $result 0] != 0 } {\n-\tfail \"gcov failed: [lindex $result 1]\"\n-\tclean-gcov $testcase\n-\treturn\n-    }\n-\n-    remote_upload host $testcase.gcov $testcase.gcov;\n-    set output [grep $testcase.gcov \".*count\\\\(\\[0-9\\]+\\\\)\" line]\n-    #send_user \"output:$output\\n\"\n+#\n+# verify-lines -- check that line counts are as expected\n+#\n+# TESTCASE is the name of the test.\n+# FILE is the name of the gcov output file.\n+#\n+proc verify-lines { testcase file } {\n+    global subdir\n     set failed 0\n+    set lmessage \"\"\n+    set output [grep $file \".*count\\\\(\\[0-9\\]+\\\\)\" line]\n+    #send_user \"output:$output\\n\"\n     foreach line $output {\n \tverbose \"Processing count line: $line\" 3\n \t#send_user \"line:$line\\n\"\n \tif [regexp \"(\\[0-9\\]+) *(\\[0-9\\]+).*count\\\\((\\[0-9\\]+)\\\\)\" \"$line\" all n is shouldbe] {\n \t    #send_user \"n $n:is $is:shouldbe $shouldbe\\n\"\n \t    if { $is == \"\" } {\n-\t\tfail \"$testcase:$n:no data available for this line\"\n+\t\tif { $failed == 0 } {\n+\t\t    set lmessage \"$n:no data available for this line\"\n+\t\t}\n \t\tincr failed\n \t    } elseif { $is != $shouldbe } {\n-\t\tfail \"$testcase:$n:is $is:should be $shouldbe\"\n+\t\tif { $failed == 0 } {\n+\t\t    set lmessage \"$n:is $is:should be $shouldbe\"\n+\t\t}\n \t\tincr failed\n \t    }\n \t} else {\n-\t    fail \"$testcase: can't parse $line (in wrong place?)\"\n+\t    if { $failed == 0 } {\n+\t        set lmessage \"can't parse $line (in wrong place?)\"\n+\t    }\n \t    incr failed\n \t}\n     }\n+    return [list $failed $lmessage]\n+}\n+\n+#\n+# verify-branches -- check that branch percentages are as expected\n+#\n+# TESTCASE is the name of the test.\n+# FILE is the name of the gcov output file.\n+#\n+# Checks are based on comments in the source file.  This means to look for\n+# branch percentages 10 or 90, 20 or 80, and # 70 or 30:\n+#     /* branch(10, 20, 70) */\n+# This means that all specified percentages should have been seen by now:\n+#     /* branch(end) */\n+# All specified percentages must also be seen by the next branch(n) or\n+# by the end of the file.\n+#\n+# Each check depends on the compiler having generated the expected\n+# branch instructions.  Don't check for branches that might be\n+# optimized away or replaced with predicated instructions.\n+#\n+proc verify-branches { testcase file } {\n+    global bmessage\n+    global subdir\n+    set failed 0\n+    set bmessage \"\"\n+    set shouldbe \"\"\n+    set fd [open $file r]\n+    while { [gets $fd line] >= 0 } {\n+\tif [regexp \"branch\" $line] {\n+\t    verbose \"Processing branch line: $line\" 3\n+\t    if [regexp \"branch\\\\((\\[0-9 \\]+)\\\\)\" \"$line\" all new_shouldbe] {\n+\t\t# All percentages in the current list should have been seen.\n+\t\tif {[llength $shouldbe] != 0} {\n+\t\t    if { $failed == 0 } {\n+\t\t        set bmessage \"expected percentages not found: $shouldbe\"\n+\t\t    }\n+\t\t    incr failed\n+\t\t    set shouldbe \"\"\n+\t\t}\n+\t\tset shouldbe $new_shouldbe\n+\t        # Record the percentages to check for. Replace percentage\n+\t\t# n > 50 with 100-n, since block ordering affects the\n+\t\t# direction of a branch.\n+\t\tfor {set i 0} {$i < [llength $shouldbe]} {incr i} {\n+\t\t    set num [lindex $shouldbe $i]\n+\t\t    if {$num > 50} {\n+\t\t\tset shouldbe [lreplace $shouldbe $i $i [expr 100 - $num]]\n+\t\t    }\n+\t\t}\n+\t    } elseif [regexp \"branch \\[0-9\\]+ taken = (-\\[0-9\\]+)%\" \"$line\" all taken] {\n+\t\t# Percentages should never be negative.\n+\t\tif { $failed == 0 } {\n+\t\t    set bmessage \"negative percentage: $taken\"\n+\t\t}\n+\t\tincr failed\n+\t    } elseif [regexp \"branch \\[0-9\\]+ taken = (\\[0-9\\]+)%\" \"$line\" all taken] {\n+\t\t# Percentages should never be greater than 100.\n+\t\tif {$taken > 100} {\n+\t\t    if { $failed == 0 } {\n+\t\t\tset bmessage \"percentage greater than 100: $taken\"\n+\t\t    }\n+\t\t    incr failed\n+\t\t}\n+\t\tif {$taken > 50} {\n+\t\t    set taken [expr 100 - $taken]\n+\t\t}\n+\t\t# If this percentage is one to check for then remove it\n+\t\t# from the list.  It's normal to ignore some reports.\n+\t\tset i [lsearch $shouldbe $taken]\n+\t\tif {$i != -1} {\n+\t\t    set shouldbe [lreplace $shouldbe $i $i]\n+\t\t}\n+\t    } elseif [regexp \"branch\\\\(end\\\\)\" \"$line\"] {\n+\t\t# All percentages in the list should have been seen by now.\n+\t\tif {[llength $shouldbe] != 0} {\n+\t\t    if { $failed == 0 } {\n+\t\t\tset bmessage \"expected percentages not found: $shouldbe\"\n+\t\t    }\n+\t\t    incr failed\n+\t\t}\n+\t\tset shouldbe \"\"\n+\t    }\n+\t}\n+    }\n+    # All percentages in the list should have been seen.\n+    if {[llength $shouldbe] != 0} {\n+\tif { $failed == 0 } {\n+\t    set bmessage \"expected percentages not found: $shouldbe\"\n+\t}\n+\tincr failed\n+    }\n+    close $fd\n+    return [list $failed $bmessage]\n+}\n+\n+# Called by dg-final to run gcov and analyze the results.\n+#\n+# ARGS is the options to pass to gcov followed by the name of the\n+# test source file.\n+\n+proc run-gcov { args } {\n+    global GCOV\n+    global subdir\n+\n+    # Extract the test name from the arguments.\n+    set testcase [lindex $args end]\n+\n+    verbose \"Running $GCOV $testcase\" 2\n+    set testcase [remote_download host $testcase];\n+    set result [remote_exec host $GCOV $args];\n+    if { [lindex $result 0] != 0 } {\n+\tfail \"$subdir/$testcase gcov failed: [lindex $result 1]\"\n+\tclean-gcov $testcase\n+\treturn\n+    }\n+\n+    # Get the gcov output file after making sure it exists.\n+    set files [glob -nocomplain $testcase.gcov]\n+    if { $files == \"\" } {\n+        fail \"$subdir/$testcase gcov failed: $testcase.gcov does not exist\"\n+        clean-gcov $testcase\n+        return;\n+    }\n+    remote_upload host $testcase.gcov $testcase.gcov;\n+\n+    # Check that line execution counts are as expected.\n+    set loutput [verify-lines $testcase $testcase.gcov]\n+    set lfailed [lindex $loutput 0]\n+    set lmessage [lindex $loutput 1]\n+\n+    # If we asked for branch information check that it is correct.\n+    if [regexp -- \"-b\" $args] {\n+\tset boutput [verify-branches $testcase $testcase.gcov]\n+\tset bfailed [lindex $boutput 0]\n+\tset bmessage [lindex $boutput 1]\n+    } else {\n+\tset bfailed 0\n+\tset bmessage \"\"\n+    }\n+\n     clean-gcov $testcase\n-    if !$failed {\n-\tpass \"gcov $testcase\"\n+\n+    # Report whether the gcov test passed or failed.  If there were\n+    # multiple failures then the message is a summary.\n+    set tfailed [expr $lfailed + $bfailed]\n+    if { $tfailed > 0 } {\n+\tif { $tfailed == 1 } {\n+\t    set vmessage \"$lmessage$bmessage\"\n+\t} elseif { $bfailed == 0 } {\n+\t    set vmessage \"$lfailed failures in line counts\"\n+\t} elseif { $lfailed == 0 } {\n+\t    set vmessage \"$bfailed failures in branch percentages\"\n+\t} else {\n+\t    set vmessage \"$lfailed failures in line counts, $bfailed in branch percentages\"\n+\t}\n+\tfail \"$subdir/$testcase gcov: $vmessage\"\n+    } else {\n+\tpass \"$subdir/$testcase gcov\"\n     }\n }\n "}]}