{"sha": "b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhlYjg4ZDA2ZmYwMGVmYjAwODc0ZGQ4ZDNmMzBkOGVkMDE1NTFiMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-09-17T19:52:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-09-17T19:52:34Z"}, "message": "Finish MIPS4 support, add R5000 support.\n\nFrom-SVN: r12732", "tree": {"sha": "513d771457648fcfa66af5d6e22dc67cf5a065c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/513d771457648fcfa66af5d6e22dc67cf5a065c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/comments", "author": null, "committer": null, "parents": [{"sha": "24ba333f7b7cfcdfb6f07802b3bc3c28a46eac31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ba333f7b7cfcdfb6f07802b3bc3c28a46eac31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24ba333f7b7cfcdfb6f07802b3bc3c28a46eac31"}], "stats": {"total": 1215, "additions": 746, "deletions": 469}, "files": [{"sha": "f32117b94da5553fe91fc19651339c5c04cc5659", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 237, "deletions": 98, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "patch": "@@ -256,7 +256,8 @@ char mips_reg_names[][8] =\n  \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n  \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n- \"hi\",   \"lo\",   \"accum\",\"$fcr31\",\"$rap\"\n+ \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n+ \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\"\n };\n \n /* Mips software names for the registers, used to overwrite the\n@@ -272,7 +273,8 @@ char mips_sw_reg_names[][8] =\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n-  \"hi\",   \"lo\",   \"accum\",\"$fcr31\",\"$rap\"\n+  \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\n+  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\"\n };\n \n /* Map hard register number to register class */\n@@ -295,7 +297,8 @@ enum reg_class mips_regno_to_class[] =\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   HI_REG,\tLO_REG,\t\tHILO_REG,\tST_REGS,\n-  GR_REGS\n+  ST_REGS,\tST_REGS,\tST_REGS,\tST_REGS,\n+  ST_REGS,\tST_REGS,\tST_REGS,\tGR_REGS\n };\n \n /* Map register constraint character to register class.  */\n@@ -524,6 +527,40 @@ mips_const_double_ok (op, mode)\n   return FALSE;\n }\n \n+/* Accept the floating point constant 1 in the appropriate mode.  */\n+\n+int\n+const_float_1_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  REAL_VALUE_TYPE d;\n+  static REAL_VALUE_TYPE onedf;\n+  static REAL_VALUE_TYPE onesf;\n+  static int one_initialized;\n+\n+  if (GET_CODE (op) != CONST_DOUBLE\n+      || mode != GET_MODE (op)\n+      || (mode != DFmode && mode != SFmode))\n+    return FALSE;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+\n+  /* We only initialize these values if we need them, since we will\n+     never get called unless mips_isa >= 4.  */\n+  if (! one_initialized)\n+    {\n+      onedf = REAL_VALUE_ATOF (\"1.0\", DFmode);\n+      onesf = REAL_VALUE_ATOF (\"1.0\", SFmode);\n+      one_initialized = TRUE;\n+    }\n+\n+  if (mode == DFmode)\n+    return REAL_VALUES_EQUAL (d, onedf);\n+  else\n+    return REAL_VALUES_EQUAL (d, onesf);\n+}\n+\n /* Return truth value if a memory operand fits in a single instruction\n    (ie, register + small offset).  */\n \n@@ -990,6 +1027,10 @@ mips_move_1word (operands, insn, unsignedp)\n       code1 = GET_CODE (op1);\n     }\n \n+  /* For our purposes, a condition code mode is the same as SImode.  */\n+  if (mode == CCmode)\n+    mode = SImode;\n+\n   if (code0 == REG)\n     {\n       int regno0 = REGNO (op0) + subreg_word0;\n@@ -1017,13 +1058,16 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t    ret = \"mflo\\t%0\";\n \t\t}\n \n+\t      else if (ST_REG_P (regno1) && mips_isa >= 4)\n+\t\tret = \"li\\t%0,1\\n\\tmovf\\t%0,%.,%1\";\n+\n \t      else\n \t\t{\n \t\t  delay = DELAY_LOAD;\n \t\t  if (FP_REG_P (regno1))\n \t\t    ret = \"mfc1\\t%0,%1\";\n \n-\t\t  else if (regno1 == FPSW_REGNUM)\n+\t\t  else if (regno1 == FPSW_REGNUM && mips_isa < 4)\n \t\t    ret = \"cfc1\\t%0,$31\";\n \t\t}\n \t    }\n@@ -1050,7 +1094,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t}\n \t    }\n \n-\t  else if (regno0 == FPSW_REGNUM)\n+\t  else if (regno0 == FPSW_REGNUM && mips_isa < 4)\n \t    {\n \t      if (GP_REG_P (regno1))\n \t\t{\n@@ -1079,6 +1123,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t  ret = \"lw\\t%0,%1\";\n \t\t  break;\n \t\tcase SImode:\n+\t\tcase CCmode:\n \t\t  ret = ((unsignedp && TARGET_64BIT)\n \t\t\t ? \"lwu\\t%0,%1\"\n \t\t\t : \"lw\\t%0,%1\");\n@@ -1981,112 +2026,67 @@ gen_conditional_branch (operands, test_code)\n      rtx operands[];\n      enum rtx_code test_code;\n {\n-  static enum machine_mode mode_map[(int)CMP_MAX][(int)ITEST_MAX] = {\n-    {\t\t\t\t/* CMP_SI */\n-      SImode,\t\t\t/* eq  */\n-      SImode,\t\t\t/* ne  */\n-      SImode,\t\t\t/* gt  */\n-      SImode,\t\t\t/* ge  */\n-      SImode,\t\t\t/* lt  */\n-      SImode,\t\t\t/* le  */\n-      SImode,\t\t\t/* gtu */\n-      SImode,\t\t\t/* geu */\n-      SImode,\t\t\t/* ltu */\n-      SImode,\t\t\t/* leu */\n-    },\n-    {\t\t\t\t/* CMP_DI */\n-      DImode,\t\t\t/* eq  */\n-      DImode,\t\t\t/* ne  */\n-      DImode,\t\t\t/* gt  */\n-      DImode,\t\t\t/* ge  */\n-      DImode,\t\t\t/* lt  */\n-      DImode,\t\t\t/* le  */\n-      DImode,\t\t\t/* gtu */\n-      DImode,\t\t\t/* geu */\n-      DImode,\t\t\t/* ltu */\n-      DImode,\t\t\t/* leu */\n-    },\n-    {\t\t\t\t/* CMP_SF */\n-      CC_FPmode,\t\t/* eq  */\n-      CC_REV_FPmode,\t\t/* ne  */\n-      CC_FPmode,\t\t/* gt  */\n-      CC_FPmode,\t\t/* ge  */\n-      CC_FPmode,\t\t/* lt  */\n-      CC_FPmode,\t\t/* le  */\n-      VOIDmode,\t\t\t/* gtu */\n-      VOIDmode,\t\t\t/* geu */\n-      VOIDmode,\t\t\t/* ltu */\n-      VOIDmode,\t\t\t/* leu */\n-    },\n-    {\t\t\t\t/* CMP_DF */\n-      CC_FPmode,\t\t/* eq  */\n-      CC_REV_FPmode,\t\t/* ne  */\n-      CC_FPmode,\t\t/* gt  */\n-      CC_FPmode,\t\t/* ge  */\n-      CC_FPmode,\t\t/* lt  */\n-      CC_FPmode,\t\t/* le  */\n-      VOIDmode,\t\t\t/* gtu */\n-      VOIDmode,\t\t\t/* geu */\n-      VOIDmode,\t\t\t/* ltu */\n-      VOIDmode,\t\t\t/* leu */\n-    },\n-  };\n-\n+  enum cmp_type type = branch_type;\n+  rtx cmp0 = branch_cmp[0];\n+  rtx cmp1 = branch_cmp[1];\n   enum machine_mode mode;\n-  enum cmp_type type\t  = branch_type;\n-  rtx cmp0\t\t  = branch_cmp[0];\n-  rtx cmp1\t\t  = branch_cmp[1];\n-  rtx label1\t\t  = gen_rtx (LABEL_REF, VOIDmode, operands[0]);\n-  rtx label2\t\t  = pc_rtx;\n-  rtx reg\t\t  = (rtx)0;\n-  int invert\t\t  = 0;\n-  enum internal_test test = map_test_to_internal_test (test_code);\n-\n-  if (test == ITEST_MAX)\n-    {\n-      mode = word_mode;\n-      goto fail;\n-    }\n-\n-  /* Get the machine mode to use (CCmode, CC_EQmode, CC_FPmode, or CC_REV_FPmode).  */\n-  mode = mode_map[(int)type][(int)test];\n-  if (mode == VOIDmode)\n-    goto fail;\n+  rtx reg;\n+  int invert;\n+  rtx label1, label2;\n \n   switch (type)\n     {\n     default:\n-      goto fail;\n+      abort_with_insn (gen_rtx (test_code, VOIDmode, cmp0, cmp1), \"bad test\");\n \n     case CMP_SI:\n     case CMP_DI:\n-      reg = gen_int_relational (test_code, (rtx)0, cmp0, cmp1, &invert);\n-      if (reg != (rtx)0)\n+      mode = type == CMP_SI ? SImode : DImode;\n+      invert = FALSE;\n+      reg = gen_int_relational (test_code, NULL_RTX, cmp0, cmp1, &invert);\n+      if (reg)\n \t{\n \t  cmp0 = reg;\n \t  cmp1 = const0_rtx;\n \t  test_code = NE;\n \t}\n-\n-      /* Make sure not non-zero constant if ==/!= */\n       else if (GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) != 0)\n-\tcmp1 = force_reg (mode, cmp1);\n-\n+\t{\n+\t  /* We don't want to build a comparison against a non-zero\n+             constant.  */\n+\t  cmp1 = force_reg (mode, cmp1);\n+\t}\n       break;\n \n-    case CMP_DF:\n     case CMP_SF:\n-      {\n-\trtx reg = gen_rtx (REG, mode, FPSW_REGNUM);\n-\temit_insn (gen_rtx (SET, VOIDmode, reg, gen_rtx (test_code, mode, cmp0, cmp1)));\n-\tcmp0 = reg;\n-\tcmp1 = const0_rtx;\n-\ttest_code = NE;\n-      }\n+    case CMP_DF:\n+      if (mips_isa < 4)\n+\treg = gen_rtx (REG, CCmode, FPSW_REGNUM);\n+      else\n+\treg = gen_reg_rtx (CCmode);\n+\n+      /* For cmp0 != cmp1, build cmp0 == cmp1, and test for result ==\n+         0 in the instruction built below.  The MIPS FPU handles\n+         inequality testing by testing for equality and looking for a\n+         false result.  */\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  reg,\n+\t\t\t  gen_rtx (test_code == NE ? EQ : test_code,\n+\t\t\t\t   CCmode, cmp0, cmp1)));\n+\n+      test_code = test_code == NE ? EQ : NE;\n+      mode = CCmode;\n+      cmp0 = reg;\n+      cmp1 = const0_rtx;\n+      invert = FALSE;\n       break;\n     }\n \n-  /* Generate the jump */\n+  /* Generate the branch.  */\n+\n+  label1 = gen_rtx (LABEL_REF, VOIDmode, operands[0]);\n+  label2 = pc_rtx;\n+\n   if (invert)\n     {\n       label2 = label1;\n@@ -2099,13 +2099,102 @@ gen_conditional_branch (operands, test_code)\n \t\t\t\t    gen_rtx (test_code, mode, cmp0, cmp1),\n \t\t\t\t    label1,\n \t\t\t\t    label2)));\n+}\n \n-  return;\n+/* Emit the common code for conditional moves.  OPERANDS is the array\n+   of operands passed to the conditional move defined_expand.  */\n \n-fail:\n-  abort_with_insn (gen_rtx (test_code, mode, cmp0, cmp1), \"bad test\");\n-}\n+void\n+gen_conditional_move (operands)\n+     rtx *operands;\n+{\n+  rtx op0 = branch_cmp[0];\n+  rtx op1 = branch_cmp[1];\n+  enum machine_mode mode = GET_MODE (branch_cmp[0]);\n+  enum rtx_code cmp_code = GET_CODE (operands[1]);\n+  enum rtx_code move_code = NE;\n+  enum machine_mode op_mode = GET_MODE (operands[0]);\n+  enum machine_mode cmp_mode;\n+  rtx cmp_reg;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_FLOAT)\n+    {\n+      switch (cmp_code)\n+\t{\n+\tcase EQ:\n+\t  cmp_code = XOR;\n+\t  move_code = EQ;\n+\t  break;\n+\tcase NE:\n+\t  cmp_code = XOR;\n+\t  break;\n+\tcase LT:\n+\t  break;\n+\tcase GE:\n+\t  cmp_code = LT;\n+\t  move_code = EQ;\n+\t  break;\n+\tcase GT:\n+\t  cmp_code = LT;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  break;\n+\tcase LE:\n+\t  cmp_code = LT;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  move_code = EQ;\n+\t  break;\n+\tcase LTU:\n+\t  break;\n+\tcase GEU:\n+\t  cmp_code = LTU;\n+\t  move_code = EQ;\n+\t  break;\n+\tcase GTU:\n+\t  cmp_code = LTU;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  break;\n+\tcase LEU:\n+\t  cmp_code = LTU;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  move_code = EQ;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  else\n+    {\n+      if (cmp_code == NE)\n+\t{\n+\t  cmp_code = EQ;\n+\t  move_code = EQ;\n+\t}\n+    }\n+\t  \n+  if (mode == SImode || mode == DImode)\n+    cmp_mode = mode;\n+  else if (mode == SFmode || mode == DFmode)\n+    cmp_mode = CCmode;\n+  else\n+    abort ();\n \n+  cmp_reg = gen_reg_rtx (cmp_mode);\n+  emit_insn (gen_rtx (SET, cmp_mode,\n+\t\t      cmp_reg,\n+\t\t      gen_rtx (cmp_code, cmp_mode, op0, op1)));\n+  emit_insn (gen_rtx (SET, op_mode,\n+\t\t      operands[0],\n+\t\t      gen_rtx (IF_THEN_ELSE, op_mode,\n+\t\t\t       gen_rtx (move_code, VOIDmode,\n+\t\t\t\t\tcmp_reg,\n+\t\t\t\t\tCONST0_RTX (SImode)),\n+\t\t\t       operands[2],\n+\t\t\t       operands[3])));\n+}\n \f\n #if 0\n /* Internal code to generate the load and store of one word/short/byte.\n@@ -3443,6 +3532,11 @@ override_options ()\n \t    mips_cpu = PROCESSOR_R4650;\n \t  break;\n \n+\tcase '5':\n+\t  if (!strcmp (p, \"5000\") || !strcmp (p, \"5k\") || !strcmp (p, \"5K\"))\n+\t    mips_cpu = PROCESSOR_R5000;\n+\t  break;\n+\n \tcase '6':\n \t  if (!strcmp (p, \"6000\") || !strcmp (p, \"6k\") || !strcmp (p, \"6K\"))\n \t    mips_cpu = PROCESSOR_R6000;\n@@ -3459,7 +3553,10 @@ override_options ()\n \t  break;\n \t}\n \n-      if (seen_v && mips_cpu != PROCESSOR_R4300 && mips_cpu != PROCESSOR_R4100)\n+      if (seen_v\n+\t  && mips_cpu != PROCESSOR_R4300\n+\t  && mips_cpu != PROCESSOR_R4100\n+\t  && mips_cpu != PROCESSOR_R5000)\n \tmips_cpu = PROCESSOR_DEFAULT;\n \n       if (mips_cpu == PROCESSOR_DEFAULT)\n@@ -3642,8 +3739,15 @@ override_options ()\n \t{\n \t  register int temp;\n \n-\t  if (mode == CC_FPmode || mode == CC_REV_FPmode)\n-\t    temp = (regno == FPSW_REGNUM);\n+\t  if (mode == CCmode)\n+\t    {\n+\t      if (mips_isa < 4)\n+\t\ttemp = (regno == FPSW_REGNUM);\n+\t      else\n+\t\ttemp = (ST_REG_P (regno)\n+\t\t\t|| GP_REG_P (regno)\n+\t\t\t|| FP_REG_P (regno));\n+\t    }\n \n \t  else if (GP_REG_P (regno))\n \t    temp = ((regno & 1) == 0 || (size <= UNITS_PER_WORD));\n@@ -3745,6 +3849,7 @@ mips_debugger_offset (addr, offset)\n    'b'  print 'n' for EQ, 'z' for NE\n    'T'  print 'f' for EQ, 't' for NE\n    't'  print 't' for EQ, 'f' for NE\n+   'Z'  print register and a comma, but print nothing for $fcc0\n    '('\tTurn on .set noreorder\n    ')'\tTurn on .set reorder\n    '['\tTurn on .set noat\n@@ -3935,6 +4040,19 @@ print_operand (file, op, letter)\n       assemble_name (file, buffer);\n     }\n \n+  else if (letter == 'Z')\n+    {\n+      register int regnum;\n+\n+      if (code != REG)\n+\tabort ();\n+      regnum = REGNO (op);\n+      if (! ST_REG_P (regnum))\n+\tabort ();\n+      if (regnum != ST_REG_FIRST)\n+\tfprintf (file, \"%s,\", reg_names[regnum]);\n+    }\n+\n   else if (code == REG)\n     {\n       register int regnum = REGNO (op);\n@@ -5853,5 +5971,26 @@ mips_secondary_reload_class (class, mode, x, in_p)\n       return GR_REGS;\n     }\n \n+  /* We can only copy a value to a condition code register from a\n+     floating point register, and even then we require a scratch\n+     floating point register.  We can only copy a value out of a\n+     condition code register into a general register.  */\n+  if (class == ST_REGS)\n+    {\n+      if (in_p)\n+\treturn FP_REGS;\n+      if (GP_REG_P (regno))\n+\treturn NO_REGS;\n+      return GR_REGS;\n+    }\n+  if (ST_REG_P (regno))\n+    {\n+      if (! in_p)\n+\treturn FP_REGS;\n+      if (class == GR_REGS)\n+\treturn NO_REGS;\n+      return GR_REGS;\n+    }\n+\n   return NO_REGS;\n }"}, {"sha": "c683852e4ff9b95f226142485535b649e29b33a1", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "patch": "@@ -70,6 +70,7 @@ enum processor_type {\n   PROCESSOR_R4300,\n   PROCESSOR_R4600,\n   PROCESSOR_R4650,\n+  PROCESSOR_R5000,\n   PROCESSOR_R8000\n };\n \n@@ -168,6 +169,7 @@ extern int\t\tfunction_arg_partial_nregs ();\n extern void\t\tfunction_epilogue ();\n extern void\t\tfunction_prologue ();\n extern void\t\tgen_conditional_branch ();\n+extern void\t\tgen_conditional_move ();\n extern struct rtx_def * gen_int_relational ();\n extern void\t\tinit_cumulative_args ();\n extern int\t\tlarge_int ();\n@@ -555,6 +557,18 @@ do\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tfor (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\t\\\n \t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+\tfor (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\t\\\n+\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (mips_isa < 4)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t/* We only have a single condition code register.  We\t\t\\\n+           implement this by hiding all the condition code registers,\t\\\n+           and generating RTL that refers directly to ST_REG_FIRST.  */\t\\\n+\tfor (regno = ST_REG_FIRST; regno <= ST_REG_LAST; regno++)\t\\\n+\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n@@ -1200,14 +1214,16 @@ do {                                                  \\\n    even those that are not normally considered general registers.\n \n    On the Mips, we have 32 integer registers, 32 floating point\n-   registers and the special registers hi, lo, hilo, fp status, and rap.\n-   The hilo register is only used in 64 bit mode.  It represents a 64\n-   bit value stored as two 32 bit values in the hi and lo registers;\n-   this is the result of the mult instruction.  rap is a pointer to the\n-   stack where the return address reg ($31) was stored.  This is needed\n-   for C++ exception handling.  */\n+   registers, 8 condition code registers, and the special registers\n+   hi, lo, hilo, and rap.  The 8 condition code registers are only\n+   used if mips_isa >= 4.  The hilo register is only used in 64 bit\n+   mode.  It represents a 64 bit value stored as two 32 bit values in\n+   the hi and lo registers; this is the result of the mult\n+   instruction.  rap is a pointer to the stack where the return\n+   address reg ($31) was stored.  This is needed for C++ exception\n+   handling.  */\n \n-#define FIRST_PSEUDO_REGISTER 69\n+#define FIRST_PSEUDO_REGISTER 76\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -1220,7 +1236,7 @@ do {                                                  \\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 1, 1\t\t\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\t\t\t\t\t\\\n }\n \n \n@@ -1237,7 +1253,7 @@ do {                                                  \\\n   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  1, 1, 1, 1, 1\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\t\t\\\n }\n \n \n@@ -1260,21 +1276,25 @@ do {                                                  \\\n #define MD_REG_NUM   (MD_REG_LAST - MD_REG_FIRST + 1)\n \n #define ST_REG_FIRST 67\n-#define ST_REG_LAST  67\n+#define ST_REG_LAST  74\n #define ST_REG_NUM   (ST_REG_LAST - ST_REG_FIRST + 1)\n \n-#define RAP_REG_NUM   68\n+#define RAP_REG_NUM   75\n \n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n #define HILO_REGNUM\t(MD_REG_FIRST + 2)\n+\n+/* FPSW_REGNUM is the single condition code used if mips_isa < 4.  If\n+   mips_isa >= 4, it should not be used, and an arbitrary ST_REG\n+   should be used instead.  */\n #define FPSW_REGNUM\tST_REG_FIRST\n \n #define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n #define FP_REG_P(REGNO) ((unsigned) ((REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n #define MD_REG_P(REGNO) ((unsigned) ((REGNO) - MD_REG_FIRST) < MD_REG_NUM)\n-#define ST_REG_P(REGNO) ((REGNO) == ST_REG_FIRST)\n+#define ST_REG_P(REGNO) ((unsigned) ((REGNO) - ST_REG_FIRST) < ST_REG_NUM)\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -1464,8 +1484,8 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000002 },\t/* lo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000004 },\t/* hilo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000003 },\t/* mul/div registers */\t\\\n-  { 0x00000000, 0x00000000, 0x00000008 },\t/* status registers */\t\\\n-  { 0xffffffff, 0xffffffff, 0x0000000f }\t/* all registers */\t\\\n+  { 0x00000000, 0x00000000, 0x000007f8 },\t/* status registers */\t\\\n+  { 0xffffffff, 0xffffffff, 0x000007ff }\t/* all registers */\t\\\n }\n \n \n@@ -1625,7 +1645,8 @@ extern enum reg_class mips_char_to_class[];\n \t   || (CLASS2 == GR_REGS && CLASS1 == FP_REGS))))\n \n /* The HI and LO registers can only be reloaded via the general\n-   registers.  */\n+   registers.  Condition code registers can only be loaded to the\n+   general registers, and from the floating point registers.  */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n   mips_secondary_reload_class (CLASS, MODE, X, 1)\n@@ -2868,7 +2889,8 @@ while (0)\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n+\t      || mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (4);\t\t\t\t\t\\\n \t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n@@ -2878,7 +2900,8 @@ while (0)\n \t\t\t\t\t\t\t\t\t\\\n       if (xmode == DFmode)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\\\n+\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n+\t      || mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n \t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n@@ -2890,6 +2913,8 @@ while (0)\n \treturn COSTS_N_INSNS (12);\t\t\t\t\t\\\n       else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n \treturn COSTS_N_INSNS (17);\t\t\t\t\t\\\n+      else if (mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n+\treturn COSTS_N_INSNS (5);\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \treturn COSTS_N_INSNS (10);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2926,6 +2951,8 @@ while (0)\n       return COSTS_N_INSNS (35);\t\t\t\t\t\\\n     else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n       return COSTS_N_INSNS (38);\t\t\t\t\t\\\n+    else if (mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n+      return COSTS_N_INSNS (36);\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       return COSTS_N_INSNS (69);\n \n@@ -3001,6 +3028,8 @@ while (0)\n    : (((TO) == HI_REG || (TO) == LO_REG\t\t\t\t\t\\\n        || (TO) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n       && (FROM) == GR_REGS) ? 6\t\t\t\t\t\t\\\n+   : (FROM) == ST_REGS && (TO) == GR_REGS ? 4\t\t\t\t\\\n+   : (FROM) == FP_REGS && (TO) == ST_REGS ? 8\t\t\t\t\\\n    : 12)\n \n /* ??? Fix this to be right for the R8000.  */\n@@ -3053,6 +3082,7 @@ while (0)\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"large_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"mips_const_double_ok\",\t{ CONST_DOUBLE }},\t\t\t\\\n+  {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n   {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n   {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n@@ -3082,40 +3112,6 @@ while (0)\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\t\t\\\n   final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n-\f\n-/* Tell final.c how to eliminate redundant test instructions.\n-   Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* A list of names to be used for additional modes for condition code\n-   values in registers.  These names are added to `enum machine_mode'\n-   and all have class `MODE_CC'.  By convention, they should start\n-   with `CC' and end with `mode'.\n-\n-   You should only define this macro if your machine does not use\n-   `cc0' and only if additional modes are required.\n-\n-   On the MIPS, we use CC_FPmode for all floating point except for not\n-   equal, CC_REV_FPmode for not equal (to reverse the sense of the\n-   jump), CC_EQmode for integer equality/inequality comparisons,\n-   CC_0mode for comparisons against 0, and CCmode for other integer\n-   comparisons. */\n-\n-#define EXTRA_CC_MODES CC_EQmode, CC_FPmode, CC_0mode, CC_REV_FPmode\n-\n-/* A list of C strings giving the names for the modes listed in\n-   `EXTRA_CC_MODES'.  */\n-\n-#define EXTRA_CC_NAMES \"CC_EQ\", \"CC_FP\", \"CC_0\", \"CC_REV_FP\"\n-\n-/* Returns a mode from class `MODE_CC' to be used when comparison\n-   operation code OP is applied to rtx X.  */\n-\n-#define SELECT_CC_MODE(OP, X, Y)\t\t\t\t\t\\\n-  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\t\t\t\\\n-\t? SImode\t\t\t\t\t\t\t\\\n-\t: ((OP == NE) ? CC_REV_FPmode : CC_FPmode))\n-\n \f\n /* Control the assembler format that we output.  */\n \n@@ -3217,6 +3213,13 @@ while (0)\n   &mips_reg_names[66][0],\t\t\t\t\t\t\\\n   &mips_reg_names[67][0],\t\t\t\t\t\t\\\n   &mips_reg_names[68][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[69][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[70][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[71][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[72][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[73][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[74][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[75][0],\t\t\t\t\t\t\\\n }\n \n /* print-rtl.c can't use REGISTER_NAMES, since it depends on mips.c.\n@@ -3231,7 +3234,8 @@ while (0)\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\\\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t\\\n-  \"hi\",   \"lo\",   \"accum\",\"$fcr31\",\"$rap\"\t\t\t\t\\\n+  \"hi\",   \"lo\",   \"accum\",\"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\t\\\n+  \"$fcc5\",\"$fcc6\",\"$fcc7\",\"$rap\"\t\t\t\t\t\\\n }\n \n /* If defined, a C initializer for an array of structures\n@@ -3310,8 +3314,7 @@ while (0)\n   { \"fp\",\t30 + GP_REG_FIRST },\t\t\t\t\t\\\n   { \"ra\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n   { \"$sp\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n-  { \"$fp\",\t30 + GP_REG_FIRST },\t\t\t\t\t\\\n-  { \"cc\",\tFPSW_REGNUM },\t\t\t\t\t\t\\\n+  { \"$fp\",\t30 + GP_REG_FIRST }\t\t\t\t\t\\\n }\n \n /* Define results of standard character escape sequences.  */"}, {"sha": "4a61c4f23492b13bbd406b9d2dfbe69d56b4bec8", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 452, "deletions": 317, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8eb88d06ff00efb00874dd8d3f30d8ed01551b1/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=b8eb88d06ff00efb00874dd8d3f30d8ed01551b1", "patch": "@@ -3,7 +3,7 @@\n ;;  Changes by       Michael Meissner, meissner@osf.org\n ;;  64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n ;;  Brendan Eich, brendan@microunity.com.\n-;;  Copyright (C) 1989, 90, 91, 92, 93, 94, 95 Free Software Foundation, Inc.\n+;;  Copyright (C) 1989, 90-5, 1996 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -22,12 +22,6 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n-;; ??? MIPS4 has 8 floating point condition codes.  This is not supported yet.\n-\n-;; ??? MIPS4 has floating point doubleword/word load/stores that accept a\n-;; base+index addressing mode.  There are no such load/stores for the integer\n-;; registers.  This is not supported yet.\n-\n ;; ??? Currently does not have define_function_unit support for the R8000.\n ;; Must include new entries for fmadd in addition to existing entries.\n \n@@ -93,7 +87,8 @@\n ;;          (const_string \"default\"))))\n \n ;; ??? Fix everything that tests this attribute.\n-(define_attr \"cpu\" \"default,r3000,r6000,r4000,r4100,r4300,r4600,r4650,r8000\"\n+(define_attr \"cpu\"\n+  \"default,r3000,r6000,r4000,r4100,r4300,r4600,r4650,r5000,r8000\"\n   (const (symbol_ref \"mips_cpu_attr\")))\n \n ;; Attribute defining whether or not we can use the branch-likely instructions\n@@ -151,11 +146,13 @@\n ;; Make the default case (PROCESSOR_DEFAULT) handle the worst case\n \n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"!r3000,r4600,r4650,r4100,r4300\"))\n+  (and (eq_attr \"type\" \"load\")\n+       (eq_attr \"cpu\" \"!r3000,r4600,r4650,r4100,r4300,r5000\"))\n   3 0)\n \n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"r3000,r4600,r4650,r4100,r4300\"))\n+  (and (eq_attr \"type\" \"load\")\n+       (eq_attr \"cpu\" \"r3000,r4600,r4650,r4100,r4300,r5000\"))\n   2 0)\n \n (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"store\") 1 0)\n@@ -167,7 +164,8 @@\n   1 3)\n \n (define_function_unit \"imuldiv\"  1 0\n-  (and (eq_attr \"type\" \"imul\") (eq_attr \"cpu\" \"!r3000,r4000,r4600,r4650,r4100,r4300\"))\n+  (and (eq_attr \"type\" \"imul\")\n+       (eq_attr \"cpu\" \"!r3000,r4000,r4600,r4650,r4100,r4300,r5000\"))\n   17 17)\n \n (define_function_unit \"imuldiv\"  1 0\n@@ -183,23 +181,33 @@\n   4 4)\n \n (define_function_unit \"imuldiv\"  1 0\n-  (and (eq_attr \"type\" \"imul\") (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4100\")))\n+  (and (eq_attr \"type\" \"imul\")\n+       (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4100\")))\n   1 1)\n \n (define_function_unit \"imuldiv\"  1 0\n-  (and (eq_attr \"type\" \"imul\") (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4100\")))\n+  (and (eq_attr \"type\" \"imul\")\n+       (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4100\")))\n   4 4)\n \n (define_function_unit \"imuldiv\"  1 0\n-  (and (eq_attr \"type\" \"imul\") (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4300\")))\n+  (and (eq_attr \"type\" \"imul\")\n+       (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4300,r5000\")))\n   5 5)\n \n (define_function_unit \"imuldiv\"  1 0\n-  (and (eq_attr \"type\" \"imul\") (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4300\")))\n+  (and (eq_attr \"type\" \"imul\")\n+       (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4300\")))\n   8 8)\n \n (define_function_unit \"imuldiv\"  1 0\n-  (and (eq_attr \"type\" \"idiv\") (eq_attr \"cpu\" \"!r3000,r4000,r4600,r4650,r4100,r4300\"))\n+  (and (eq_attr \"type\" \"imul\")\n+       (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r5000\")))\n+  9 9)\n+\n+(define_function_unit \"imuldiv\"  1 0\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"cpu\" \"!r3000,r4000,r4600,r4650,r4100,r4300,r5000\"))\n   38 38)\n \n (define_function_unit \"imuldiv\"  1 0\n@@ -219,21 +227,35 @@\n   69 69)\n \n (define_function_unit \"imuldiv\" 1 0\n-  (and (eq_attr \"type\" \"idiv\") (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4100\")))\n+  (and (eq_attr \"type\" \"idiv\")\n+       (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4100\")))\n   35 35)\n \n (define_function_unit \"imuldiv\" 1 0\n-  (and (eq_attr \"type\" \"idiv\") (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4100\")))\n+  (and (eq_attr \"type\" \"idiv\")\n+       (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4100\")))\n   67 67)\n \n (define_function_unit \"imuldiv\" 1 0\n-  (and (eq_attr \"type\" \"idiv\") (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4300\")))\n+  (and (eq_attr \"type\" \"idiv\")\n+       (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r4300\")))\n   37 37)\n \n (define_function_unit \"imuldiv\" 1 0\n-  (and (eq_attr \"type\" \"idiv\") (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4300\")))\n+  (and (eq_attr \"type\" \"idiv\")\n+       (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r4300\")))\n   69 69)\n \n+(define_function_unit \"imuldiv\" 1 0\n+  (and (eq_attr \"type\" \"idiv\")\n+       (and (eq_attr \"mode\" \"SI\") (eq_attr \"cpu\" \"r5000\")))\n+  36 36)\n+\n+(define_function_unit \"imuldiv\" 1 0\n+  (and (eq_attr \"type\" \"idiv\")\n+       (and (eq_attr \"mode\" \"DI\") (eq_attr \"cpu\" \"r5000\")))\n+  68 68)\n+\n ;; The R4300 does *NOT* have a seperate Floating Point Unit, instead\n ;; the FP hardware is part of the normal ALU circuitry.  This means FP\n ;; instructions affect the pipe-line, and no functional unit\n@@ -242,13 +264,17 @@\n ;; instructions to be processed in the \"imuldiv\" unit.\n \n (define_function_unit \"adder\" 1 1\n-  (and (eq_attr \"type\" \"fcmp\") (eq_attr \"cpu\" \"!r3000,r6000,r4300\"))\n+  (and (eq_attr \"type\" \"fcmp\") (eq_attr \"cpu\" \"!r3000,r6000,r4300,r5000\"))\n   3 0)\n \n (define_function_unit \"adder\" 1 1\n   (and (eq_attr \"type\" \"fcmp\") (eq_attr \"cpu\" \"r3000,r6000\"))\n   2 0)\n \n+(define_function_unit \"adder\" 1 1\n+  (and (eq_attr \"type\" \"fcmp\") (eq_attr \"cpu\" \"r5000\"))\n+  1 0)\n+\n (define_function_unit \"adder\" 1 1\n   (and (eq_attr \"type\" \"fadd\") (eq_attr \"cpu\" \"!r3000,r6000,r4300\"))\n   4 0)\n@@ -262,89 +288,129 @@\n   3 0)\n \n (define_function_unit \"adder\" 1 1\n-  (and (eq_attr \"type\" \"fabs,fneg\") (eq_attr \"cpu\" \"!r3000,r4600,r4650,r4300\"))\n+  (and (eq_attr \"type\" \"fabs,fneg\")\n+       (eq_attr \"cpu\" \"!r3000,r4600,r4650,r4300,r5000\"))\n   2 0)\n \n (define_function_unit \"adder\" 1 1\n-  (and (eq_attr \"type\" \"fabs,fneg\") (eq_attr \"cpu\" \"r3000,r4600,r4650\"))\n+  (and (eq_attr \"type\" \"fabs,fneg\") (eq_attr \"cpu\" \"r3000,r4600,r4650,r5000\"))\n   1 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"!r3000,r6000,r4600,r4650,r4300\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"SF\")\n+\t    (eq_attr \"cpu\" \"!r3000,r6000,r4600,r4650,r4300,r5000\")))\n   7 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r3000\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r3000,r5000\")))\n   4 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r6000\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r6000\")))\n   5 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n   8 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"!r3000,r6000,r4300\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"!r3000,r6000,r4300,r5000\")))\n   8 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r3000\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r3000,r5000\")))\n   5 0)\n \n (define_function_unit \"mult\" 1 1\n-  (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r6000\")))\n+  (and (eq_attr \"type\" \"fmul\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r6000\")))\n   6 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"!r3000,r6000,r4600,r4650,r4300\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"SF\")\n+\t    (eq_attr \"cpu\" \"!r3000,r6000,r4600,r4650,r4300,r5000\")))\n   23 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r3000\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r3000\")))\n   12 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r6000\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r6000\")))\n   15 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n   32 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"!r3000,r6000,r4600,r4650,r4300\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r5000\")))\n+  21 0)\n+\n+(define_function_unit \"divide\" 1 1\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"DF\")\n+\t    (eq_attr \"cpu\" \"!r3000,r6000,r4600,r4650,r4300\")))\n   36 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r3000\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r3000\")))\n   19 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r6000\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r6000\")))\n   16 0)\n \n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fdiv\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n+  (and (eq_attr \"type\" \"fdiv\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n   61 0)\n \n ;;; ??? Is this number right?\n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fsqrt\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"!r4600,r4650,r4300\")))\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"!r4600,r4650,r4300,r5000\")))\n   54 0)\n+\n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fsqrt\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n   31 0)\n \n+(define_function_unit \"divide\" 1 1\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r5000\")))\n+  21 0)\n+\n ;;; ??? Is this number right?\n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fsqrt\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"!r4600,r4650,r4300\")))\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"!r4600,r4650,r4300,r5000\")))\n   112 0)\n+\n (define_function_unit \"divide\" 1 1\n-  (and (eq_attr \"type\" \"fsqrt\") (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r4600,r4650\")))\n   60 0)\n \n+(define_function_unit \"divide\" 1 1\n+  (and (eq_attr \"type\" \"fsqrt\")\n+       (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r5000\")))\n+  36 0)\n+\n ;; R4300 FP instruction classes treated as part of the \"imuldiv\"\n ;; functional unit:\n \n@@ -1286,7 +1352,7 @@\n \t(plus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t\t  (match_operand:DF 2 \"register_operand\" \"f\"))\n \t\t (match_operand:DF 3 \"register_operand\" \"f\")))]\n-  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"madd.d\\\\t%0,%3,%1,%2\"\n   [(set_attr \"type\"\t\"fmadd\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1308,7 +1374,7 @@\n \t(minus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t\t   (match_operand:DF 2 \"register_operand\" \"f\"))\n \t\t  (match_operand:DF 3 \"register_operand\" \"f\")))]\n-  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"msub.d\\\\t%0,%3,%1,%2\"\n   [(set_attr \"type\"\t\"fmadd\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1331,7 +1397,7 @@\n \t(neg:DF (plus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t\t\t  (match_operand:DF 2 \"register_operand\" \"f\"))\n \t\t\t (match_operand:DF 3 \"register_operand\" \"f\"))))]\n-  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"nmadd.d\\\\t%0,%3,%1,%2\"\n   [(set_attr \"type\"\t\"fmadd\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1353,7 +1419,7 @@\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t  (mult:DF (match_operand:DF 2 \"register_operand\" \"f\")\n \t\t\t   (match_operand:DF 3 \"register_operand\" \"f\"))))]\n-  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"nmsub.d\\\\t%0,%1,%2,%3\"\n   [(set_attr \"type\"\t\"fmadd\")\n    (set_attr \"mode\"\t\"DF\")\n@@ -1398,6 +1464,26 @@\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"1\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_fast_math\"\n+  \"recip.d\\\\t%0,%2\"\n+  [(set_attr \"type\"\t\"fdiv\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && flag_fast_math\"\n+  \"recip.s\\\\t%0,%2\"\n+  [(set_attr \"type\"\t\"fdiv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n ;; If optimizing, prefer the divmod functions over separate div and\n ;; mod functions, since this will allow using one instruction for both\n ;; the quotient and remainder.  At present, the divmod is not moved out\n@@ -1641,6 +1727,26 @@\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"1\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t\t(sqrt:DF (match_operand:DF 2 \"register_operand\" \"f\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_fast_math\"\n+  \"rsqrt.d\\\\t%0,%2\"\n+  [(set_attr \"type\"\t\"fsqrt\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"f\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && flag_fast_math\"\n+  \"rsqrt.s\\\\t%0,%2\"\n+  [(set_attr \"type\"\t\"fsqrt\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n \f\n ;;\n ;;  ....................\n@@ -3499,6 +3605,182 @@ move\\\\t%0,%z4\\\\n\\\\\n   DONE;\n }\")\n \n+;; This insn handles moving CCmode values.  It's really just a\n+;; slightly simplified copy of movsi_internal2, with additional cases\n+;; to move a condition register to a general register and to move\n+;; between the general registers and the floating point registers.\n+\n+(define_insn \"movcc\"\n+  [(set (match_operand:CC 0 \"nonimmediate_operand\" \"=d,*d,*d,*d,*R,*m,*d,*f,*f,*f,*f,*R,*m\")\n+\t(match_operand:CC 1 \"general_operand\" \"z,*d,*R,*m,*d,*d,*f,*d,*f,*R,*m,*f,*f\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  [(set_attr \"type\"\t\"move,move,load,load,store,store,xfer,xfer,move,load,load,store,store\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,1,1,2,1,2,1,1,1,1,2,1,2\")])\n+\n+;; Reload condition code registers.  These need scratch registers.\n+\n+(define_expand \"reload_incc\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(match_operand:CC 1 \"general_operand\" \"z\"))\n+   (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"\n+{\n+  rtx source;\n+  rtx fp1, fp2;\n+\n+  /* This is called when are copying some value into a condition code\n+     register.  Operand 0 is the condition code register.  Operand 1\n+     is the source.  Operand 2 is a scratch register; we use TFmode\n+     because we actually need two floating point registers.  */\n+  if (! ST_REG_P (true_regnum (operands[0]))\n+      || ! FP_REG_P (true_regnum (operands[2])))\n+    abort ();\n+\n+  /* We need to get the source in SFmode so that the insn is\n+     recognized.  */\n+  if (GET_CODE (operands[1]) == MEM)\n+    source = change_address (operands[1], SFmode, NULL_RTX);\n+  else if (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG)\n+    source = gen_rtx (REG, SFmode, true_regnum (operands[1]));\n+  else\n+    source = operands[1];\n+\n+  fp1 = gen_rtx (REG, SFmode, REGNO (operands[2]));\n+  fp2 = gen_rtx (REG, SFmode, REGNO (operands[2]) + 1);\n+\n+  emit_insn (gen_move_insn (fp1, source));\n+  emit_insn (gen_move_insn (fp2, gen_rtx (REG, SFmode, 0)));\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t      gen_rtx (LT, CCmode, fp2, fp1)));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outcc\"\n+  [(set (match_operand:CC 0 \"general_operand\" \"=z\")\n+\t(match_operand:CC 1 \"register_operand\" \"z\"))\n+   (clobber (match_operand:CC 2 \"register_operand\" \"=&d\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"\n+{\n+  /* This is called when we are copying a condition code register out\n+     to save it somewhere.  Operand 0 should be the location we are\n+     going to save it to.  Operand 1 should be the condition code\n+     register.  Operand 2 should be a scratch general purpose register\n+     created for us by reload.  The mips_secondary_reload_class\n+     function should have told reload that we don't need a scratch\n+     register if the destination is a general purpose register anyhow.  */\n+  if (ST_REG_P (true_regnum (operands[0]))\n+      || GP_REG_P (true_regnum (operands[0]))\n+      || ! ST_REG_P (true_regnum (operands[1]))\n+      || ! GP_REG_P (true_regnum (operands[2])))\n+    abort ();\n+\n+  /* All we have to do is copy the value from the condition code to\n+     the data register, which movcc can handle, and then store the\n+     value into the real final destination.  */\n+  emit_insn (gen_move_insn (operands[2], operands[1]));\n+  emit_insn (gen_move_insn (operands[0], operands[2]));\n+\n+  DONE;\n+}\")\n+\n+;; MIPS4 supports loading and storing a floating point register from\n+;; the sum of two general registers.  We use two versions for each of\n+;; these four instructions: one where the two general registers are\n+;; SImode, and one where they are DImode.  This is because general\n+;; registers will be in SImode when they hold 32 bit values, but,\n+;; since the 32 bit values are always sign extended, the [ls][wd]xc1\n+;; instructions will still work correctly.\n+\n+;; ??? Perhaps it would be better to support these instructions by\n+;; modifying GO_IF_LEGITIMATE_ADDRESS and friends.  However, since\n+;; these instructions can only be used to load and store floating\n+;; point registers, that would probably cause trouble in reload.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"lwxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mem:SF (plus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:DI 2 \"register_operand\" \"d\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"lwxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"ldxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mem:DF (plus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:DI 2 \"register_operand\" \"d\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"ldxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t(match_operand:SF 0 \"register_operand\" \"=f\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"swxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:SF (plus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n+\t(match_operand:SF 0 \"register_operand\" \"=f\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"swxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t(match_operand:DF 0 \"register_operand\" \"=f\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"sdxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:DF (plus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n+\t(match_operand:DF 0 \"register_operand\" \"=f\"))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"sdxc1\\\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n ;; 16-bit Integer moves\n \n ;; Unlike most other insns, the move insns can't be split with\n@@ -4625,8 +4907,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"cmpdf\"\n   [(set (cc0)\n-\t(compare:CC_FP (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t       (match_operand:DF 1 \"register_operand\" \"\")))]\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t    (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n@@ -4641,8 +4923,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"cmpsf\"\n   [(set (cc0)\n-\t(compare:CC_FP (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t       (match_operand:SF 1 \"register_operand\" \"\")))]\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -4665,69 +4947,36 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"branch_fp_ne\"\n   [(set (pc)\n-\t(if_then_else (ne:CC_FP (reg:CC_FP 67)\n-\t\t\t\t(const_int 0))\n-\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  return (operands[0] != pc_rtx) ? \\\"%*bc1t%?\\\\t%0\\\" : \\\"%*bc1f%?\\\\t%1\\\";\n-}\"\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"1\")])\n-\n-(define_insn \"branch_fp_ne_rev\"\n-  [(set (pc)\n-\t(if_then_else (ne:CC_REV_FP (reg:CC_REV_FP 67)\n-\t\t\t\t    (const_int 0))\n-\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n+\t(if_then_else (ne:CC (match_operand:CC 0 \"register_operand\" \"z\")\n+\t\t\t     (const_int 0))\n+\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")\n+\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  return (operands[0] != pc_rtx) ? \\\"%*bc1f%?\\\\t%0\\\" : \\\"%*bc1t%?\\\\t%1\\\";\n+  return (operands[1] != pc_rtx) ? \\\"%*bc1t%?\\\\t%Z0%1\\\" : \\\"%*bc1f%?\\\\t%Z0%2\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n (define_insn \"branch_fp_eq\"\n   [(set (pc)\n-\t(if_then_else (eq:CC_FP (reg:CC_FP 67)\n-\t\t\t\t(const_int 0))\n-\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  return (operands[0] != pc_rtx) ? \\\"%*bc1f%?\\\\t%0\\\" : \\\"%*bc1t%?\\\\t%1\\\";\n-}\"\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"1\")])\n-\n-(define_insn \"branch_fp_eq_rev\"\n-  [(set (pc)\n-\t(if_then_else (eq:CC_REV_FP (reg:CC_REV_FP 67)\n-\t\t\t\t    (const_int 0))\n-\t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n-\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n+\t(if_then_else (eq:CC (match_operand:CC 0 \"register_operand\" \"z\")\n+\t\t\t     (const_int 0))\n+\t\t      (match_operand 1 \"pc_or_label_operand\" \"\")\n+\t\t      (match_operand 2 \"pc_or_label_operand\" \"\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n   mips_branch_likely = (final_sequence && INSN_ANNULLED_BRANCH_P (insn));\n-  return (operands[0] != pc_rtx) ? \\\"%*bc1t%?\\\\t%0\\\" : \\\"%*bc1f%?\\\\t%1\\\";\n+  return (operands[1] != pc_rtx) ? \\\"%*bc1f%?\\\\t%Z0%1\\\" : \\\"%*bc1t%?\\\\t%Z0%2\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n-\n (define_insn \"branch_zero\"\n   [(set (pc)\n \t(if_then_else (match_operator:SI 0 \"cmp_op\"\n@@ -4860,8 +5109,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"beq\"\n   [(set (pc)\n-\t(if_then_else (eq:CC_EQ (cc0)\n-\t\t\t\t(const_int 0))\n+\t(if_then_else (eq:CC (cc0)\n+\t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -4876,8 +5125,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"bne\"\n   [(set (pc)\n-\t(if_then_else (ne:CC_EQ (cc0)\n-\t\t\t\t(const_int 0))\n+\t(if_then_else (ne:CC (cc0)\n+\t\t\t     (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -5749,216 +5998,130 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;  ....................\n \n (define_insn \"seq_df\"\n-  [(set (reg:CC_FP 67)\n-\t(eq:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(eq:CC (match_operand:DF 1 \"register_operand\" \"f\")\n+\t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.eq.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")\n-  (set_attr \"length\"\t\"1\")])\n-\n-(define_insn \"sne_df\"\n-  [(set (reg:CC_REV_FP 67)\n-\t(ne:CC_REV_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t      (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.eq.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.eq.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"slt_df\"\n-  [(set (reg:CC_FP 67)\n-\t(lt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(lt:CC (match_operand:DF 1 \"register_operand\" \"f\")\n+\t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sle_df\"\n-  [(set (reg:CC_FP 67)\n-\t(le:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(le:CC (match_operand:DF 1 \"register_operand\" \"f\")\n+\t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.le.d\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.le.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sgt_df\"\n-  [(set (reg:CC_FP 67)\n-\t(gt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(gt:CC (match_operand:DF 1 \"register_operand\" \"f\")\n+\t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sge_df\"\n-  [(set (reg:CC_FP 67)\n-\t(ge:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(ge:CC (match_operand:DF 1 \"register_operand\" \"f\")\n+\t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.le.d\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.le.d\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"seq_sf\"\n-  [(set (reg:CC_FP 67)\n-\t(eq:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.eq.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")\n-  (set_attr \"length\"\t\"1\")])\n-\n-(define_insn \"sne_sf\"\n-  [(set (reg:CC_REV_FP 67)\n-\t(ne:CC_REV_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t      (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(eq:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.eq.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.eq.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"slt_sf\"\n-  [(set (reg:CC_FP 67)\n-\t(lt:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(lt:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sle_sf\"\n-  [(set (reg:CC_FP 67)\n-\t(le:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(le:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.le.s\\\\t%0,%1\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.le.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sgt_sf\"\n-  [(set (reg:CC_FP 67)\n-\t(gt:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(gt:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sge_sf\"\n-  [(set (reg:CC_FP 67)\n-\t(ge:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n+\t(ge:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n-  rtx xoperands[10];\n-  xoperands[0] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-  xoperands[1] = operands[0];\n-  xoperands[2] = operands[1];\n-\n-  return mips_fill_delay_slot (\\\"c.le.s\\\\t%1,%0\\\", DELAY_FCMP, xoperands, insn);\n+  return mips_fill_delay_slot (\\\"c.le.s\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n }\"\n  [(set_attr \"type\"\t\"fcmp\")\n   (set_attr \"mode\"\t\"FPSW\")\n@@ -6769,13 +6932,16 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:SI\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n+\t\t\t\t\t\t\t    \"register_operand\"\n+\t\t\t\t\t\t\t    \"z,z\")\n+\t\t\t\t\t  (const_int 0)])\n \t (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,0\")\n \t (match_operand:SI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n-  \"mips_isa >= 4\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n   \"@\n-    mov%T3\\\\t%0,%z1,$fcc0\n-    mov%t3\\\\t%0,%z2,$fcc0\"\n+    mov%T3\\\\t%0,%z1,%4\n+    mov%t3\\\\t%0,%z2,%4\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"mode\" \"SI\")])\n \n@@ -6812,13 +6978,16 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:DI\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n+\t\t\t\t\t\t\t    \"register_operand\"\n+\t\t\t\t\t\t\t    \"z,z\")\n+\t\t\t\t\t  (const_int 0)])\n \t (match_operand:DI 1 \"reg_or_0_operand\" \"dJ,0\")\n \t (match_operand:DI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n-  \"mips_isa >= 4\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n   \"@\n-    mov%T3\\\\t%0,%z1,$fcc0\n-    mov%t3\\\\t%0,%z2,$fcc0\"\n+    mov%T3\\\\t%0,%z1,%4\n+    mov%t3\\\\t%0,%z2,%4\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"mode\" \"DI\")])\n \n@@ -6840,13 +7009,16 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n+\t\t\t\t\t\t\t    \"register_operand\"\n+\t\t\t\t\t\t\t    \"z,z\")\n+\t\t\t\t\t  (const_int 0)])\n \t (match_operand:SF 1 \"register_operand\" \"f,0\")\n \t (match_operand:SF 2 \"register_operand\" \"0,f\")))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n   \"@\n-    mov%T3.s\\\\t%0,%1,$fcc0\n-    mov%t3.s\\\\t%0,%2,$fcc0\"\n+    mov%T3.s\\\\t%0,%1,%4\n+    mov%t3.s\\\\t%0,%2,%4\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"mode\" \"SF\")])\n \n@@ -6858,7 +7030,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t\t  (const_int 0)])\n \t (match_operand:DF 2 \"register_operand\" \"f,0\")\n \t (match_operand:DF 3 \"register_operand\" \"0,f\")))]\n-  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"@\n     mov%B4.d\\\\t%0,%2,%1\n     mov%b4.d\\\\t%0,%3,%1\"\n@@ -6868,13 +7040,16 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:DF\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(match_operand:CC 4\n+\t\t\t\t\t\t\t    \"register_operand\"\n+\t\t\t\t\t\t\t    \"z,z\")\n+\t\t\t\t\t  (const_int 0)])\n \t (match_operand:DF 1 \"register_operand\" \"f,0\")\n \t (match_operand:DF 2 \"register_operand\" \"0,f\")))]\n-  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"@\n-    mov%T3.d\\\\t%0,%1,$fcc0\n-    mov%t3.d\\\\t%0,%2,$fcc0\"\n+    mov%T3.d\\\\t%0,%1,%4\n+    mov%t3.d\\\\t%0,%2,%4\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"mode\" \"DF\")])\n \n@@ -6889,85 +7064,45 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"mips_isa >= 4\"\n   \"\n {\n-  rtx op0 = branch_cmp[0];\n-  rtx op1 = branch_cmp[1];\n-  enum machine_mode mode = GET_MODE (branch_cmp[0]);\n-  enum rtx_code compare_code = GET_CODE (operands[1]);\n-  enum rtx_code move_code = NE;\n+  gen_conditional_move (operands);\n+  DONE;\n+}\")\n \n-  if (GET_MODE_CLASS (mode) != MODE_FLOAT)\n-    {\n-      switch (compare_code)\n-\t{\n-\tcase EQ:\n-\t  compare_code = XOR;\n-\t  move_code = EQ;\n-\t  break;\n-\tcase NE:\n-\t  compare_code = XOR;\n-\t  break;\n-\tcase LT:\n-\t  break;\n-\tcase GE:\n-\t  compare_code = LT;\n-\t  move_code = EQ;\n-\t  break;\n-\tcase GT:\n-\t  compare_code = LT;\n-\t  op0 = force_reg (mode, branch_cmp[1]);\n-\t  op1 = branch_cmp[0];\n-\t  break;\n-\tcase LE:\n-\t  compare_code = LT;\n-\t  op0 = force_reg (mode, branch_cmp[1]);\n-\t  op1 = branch_cmp[0];\n-\t  move_code = EQ;\n-\t  break;\n-\tcase LTU:\n-\t  break;\n-\tcase GEU:\n-\t  compare_code = LTU;\n-\t  move_code = EQ;\n-\t  break;\n-\tcase GTU:\n-\t  compare_code = LTU;\n-\t  op0 = force_reg (mode, branch_cmp[1]);\n-\t  op1 = branch_cmp[0];\n-\t  break;\n-\tcase LEU:\n-\t  compare_code = LTU;\n-\t  op0 = force_reg (mode, branch_cmp[1]);\n-\t  op1 = branch_cmp[0];\n-\t  move_code = EQ;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  else\n-    {\n-      if (compare_code == NE)\n-\t{\n-\t  /* ??? Perhaps we need to use CC_FP_REVmode here?  */\n-\t  compare_code = EQ;\n-\t  move_code = EQ;\n-\t}\n-    }\n-\t  \n-  if (mode == SImode || mode == DImode)\n-    {\n-      operands[1] = gen_rtx (compare_code, mode, op0, op1);\n-      operands[4] = gen_reg_rtx (mode);\n-    }\n-  else if (mode == SFmode || mode == DFmode)\n-    {\n-      operands[1] = gen_rtx (compare_code, CC_FPmode, op0, op1);\n-      operands[4] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n-    }\n+(define_expand \"movdicc\"\n+  [(set (match_dup 4) (match_operand 1 \"comparison_operator\" \"\"))\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else:DI (match_dup 5)\n+\t\t\t (match_operand:DI 2 \"reg_or_0_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"reg_or_0_operand\" \"\")))]\n+  \"mips_isa >= 4\"\n+  \"\n+{\n+  gen_conditional_move (operands);\n+  DONE;\n+}\")\n \n-  operands[5] = gen_rtx (move_code, VOIDmode, operands[4],\n-\t\t\t CONST0_RTX (SImode));\n+(define_expand \"movsfcc\"\n+  [(set (match_dup 4) (match_operand 1 \"comparison_operator\" \"\"))\n+   (set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (match_dup 5)\n+\t\t\t (match_operand:SF 2 \"reg_or_0_operand\" \"\")\n+\t\t\t (match_operand:SF 3 \"reg_or_0_operand\" \"\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"\n+{\n+  gen_conditional_move (operands);\n+  DONE;\n }\")\n \n-;; ??? Need movdicc, movsfcc, and movdfcc patterns.  They should be\n-;; very similar to the above movsicc pattern.\n+(define_expand \"movdfcc\"\n+  [(set (match_dup 4) (match_operand 1 \"comparison_operator\" \"\"))\n+   (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else:DF (match_dup 5)\n+\t\t\t (match_operand:DF 2 \"reg_or_0_operand\" \"\")\n+\t\t\t (match_operand:DF 3 \"reg_or_0_operand\" \"\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"\n+{\n+  gen_conditional_move (operands);\n+  DONE;\n+}\")"}]}