{"sha": "c67dc1a321d96ffb623c72f07097ce3683811f4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY3ZGMxYTMyMWQ5NmZmYjYyM2M3MmYwNzA5N2NlMzY4MzgxMWY0Yg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-02-23T18:03:56Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-02-23T18:03:56Z"}, "message": "loop-iv.c (determine_max_iter): Moved in front of its sole user.\n\n\t* loop-iv.c (determine_max_iter): Moved in front of its sole user.\n\nFrom-SVN: r122264", "tree": {"sha": "c676c571c7691ca6abf243b7464743be445caea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c676c571c7691ca6abf243b7464743be445caea2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c67dc1a321d96ffb623c72f07097ce3683811f4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67dc1a321d96ffb623c72f07097ce3683811f4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c67dc1a321d96ffb623c72f07097ce3683811f4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67dc1a321d96ffb623c72f07097ce3683811f4b/comments", "author": null, "committer": null, "parents": [{"sha": "74a5d8b9fe448b0b12402e99de63948e10be7382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a5d8b9fe448b0b12402e99de63948e10be7382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74a5d8b9fe448b0b12402e99de63948e10be7382"}], "stats": {"total": 132, "additions": 67, "deletions": 65}, "files": [{"sha": "e3db09492a11656391bb9e5a08477378258a89f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67dc1a321d96ffb623c72f07097ce3683811f4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67dc1a321d96ffb623c72f07097ce3683811f4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c67dc1a321d96ffb623c72f07097ce3683811f4b", "patch": "@@ -3,6 +3,8 @@\n \t* config/bfin/bfin.md (doloop_end): Fail for loops that can iterate\n \t2^32-1 or more times unless flag_unsafe_loop_optimizations.\n \n+\t* loop-iv.c (determine_max_iter): Moved in front of its sole user.\n+\n 2007-02-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.c (fold_builtin_logb, fold_builtin_significand): New."}, {"sha": "58108d2d2fe3c9a1baf78edbb82b3f23b8cbd726", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67dc1a321d96ffb623c72f07097ce3683811f4b/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67dc1a321d96ffb623c72f07097ce3683811f4b/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=c67dc1a321d96ffb623c72f07097ce3683811f4b", "patch": "@@ -1261,71 +1261,6 @@ inverse (unsigned HOST_WIDEST_INT x, int mod)\n   return rslt;\n }\n \n-/* Tries to estimate the maximum number of iterations.  */\n-\n-static unsigned HOST_WIDEST_INT\n-determine_max_iter (struct niter_desc *desc)\n-{\n-  rtx niter = desc->niter_expr;\n-  rtx mmin, mmax, left, right;\n-  unsigned HOST_WIDEST_INT nmax, inc;\n-\n-  if (GET_CODE (niter) == AND\n-      && GET_CODE (XEXP (niter, 0)) == CONST_INT)\n-    {\n-      nmax = INTVAL (XEXP (niter, 0));\n-      if (!(nmax & (nmax + 1)))\n-\t{\n-\t  desc->niter_max = nmax;\n-\t  return nmax;\n-\t}\n-    }\n-\n-  get_mode_bounds (desc->mode, desc->signed_p, desc->mode, &mmin, &mmax);\n-  nmax = INTVAL (mmax) - INTVAL (mmin);\n-\n-  if (GET_CODE (niter) == UDIV)\n-    {\n-      if (GET_CODE (XEXP (niter, 1)) != CONST_INT)\n-\t{\n-\t  desc->niter_max = nmax;\n-\t  return nmax;\n-\t}\n-      inc = INTVAL (XEXP (niter, 1));\n-      niter = XEXP (niter, 0);\n-    }\n-  else\n-    inc = 1;\n-\n-  if (GET_CODE (niter) == PLUS)\n-    {\n-      left = XEXP (niter, 0);\n-      right = XEXP (niter, 0);\n-\n-      if (GET_CODE (right) == CONST_INT)\n-\tright = GEN_INT (-INTVAL (right));\n-    }\n-  else if (GET_CODE (niter) == MINUS)\n-    {\n-      left = XEXP (niter, 0);\n-      right = XEXP (niter, 0);\n-    }\n-  else\n-    {\n-      left = niter;\n-      right = mmin;\n-    }\n-\n-  if (GET_CODE (left) == CONST_INT)\n-    mmax = left;\n-  if (GET_CODE (right) == CONST_INT)\n-    mmin = right;\n-  nmax = INTVAL (mmax) - INTVAL (mmin);\n-\n-  desc->niter_max = nmax / inc;\n-  return nmax / inc;\n-}\n-\n /* Checks whether register *REG is in set ALT.  Callback for for_each_rtx.  */\n \n static int\n@@ -1981,6 +1916,71 @@ canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n   return true;\n }\n \n+/* Tries to estimate the maximum number of iterations.  */\n+\n+static unsigned HOST_WIDEST_INT\n+determine_max_iter (struct niter_desc *desc)\n+{\n+  rtx niter = desc->niter_expr;\n+  rtx mmin, mmax, left, right;\n+  unsigned HOST_WIDEST_INT nmax, inc;\n+\n+  if (GET_CODE (niter) == AND\n+      && GET_CODE (XEXP (niter, 0)) == CONST_INT)\n+    {\n+      nmax = INTVAL (XEXP (niter, 0));\n+      if (!(nmax & (nmax + 1)))\n+\t{\n+\t  desc->niter_max = nmax;\n+\t  return nmax;\n+\t}\n+    }\n+\n+  get_mode_bounds (desc->mode, desc->signed_p, desc->mode, &mmin, &mmax);\n+  nmax = INTVAL (mmax) - INTVAL (mmin);\n+\n+  if (GET_CODE (niter) == UDIV)\n+    {\n+      if (GET_CODE (XEXP (niter, 1)) != CONST_INT)\n+\t{\n+\t  desc->niter_max = nmax;\n+\t  return nmax;\n+\t}\n+      inc = INTVAL (XEXP (niter, 1));\n+      niter = XEXP (niter, 0);\n+    }\n+  else\n+    inc = 1;\n+\n+  if (GET_CODE (niter) == PLUS)\n+    {\n+      left = XEXP (niter, 0);\n+      right = XEXP (niter, 0);\n+\n+      if (GET_CODE (right) == CONST_INT)\n+\tright = GEN_INT (-INTVAL (right));\n+    }\n+  else if (GET_CODE (niter) == MINUS)\n+    {\n+      left = XEXP (niter, 0);\n+      right = XEXP (niter, 0);\n+    }\n+  else\n+    {\n+      left = niter;\n+      right = mmin;\n+    }\n+\n+  if (GET_CODE (left) == CONST_INT)\n+    mmax = left;\n+  if (GET_CODE (right) == CONST_INT)\n+    mmin = right;\n+  nmax = INTVAL (mmax) - INTVAL (mmin);\n+\n+  desc->niter_max = nmax / inc;\n+  return nmax / inc;\n+}\n+\n /* Computes number of iterations of the CONDITION in INSN in LOOP and stores\n    the result into DESC.  Very similar to determine_number_of_iterations\n    (basically its rtl version), complicated by things like subregs.  */"}]}