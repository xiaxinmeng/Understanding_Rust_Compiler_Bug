{"sha": "7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjMmY4NmI1ZmI4MDFjN2IyYzQ2YTc2NGU5ZDA1OTRjYmNiNzNiOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-05-04T15:42:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-04T15:42:18Z"}, "message": "Use backend interface for named types and array types.\n\n\t* go-gcc.cc (Gcc_backend::struct_type): Call fill_in_struct.\n\t(Gcc_backend::fill_in_struct): New function.\n\t(Gcc_backend::array_type): Implement.\n\t(Gcc_backend::fill_in_array): New function.\n\t(Gcc_backend::placeholder_pointer_type): New function.\n\t(Gcc_backend::set_placeholder_pointer_type): New function.\n\t(Gcc_backend::set_placeholder_function_type): New function.\n\t(Gcc_backend::placeholder_struct_type): New function.\n\t(Gcc_backend::set_placeholder_struct_type): New function.\n\t(Gcc_backend::placeholder_array_type): New function.\n\t(Gcc_backend::set_placeholder_array_type): New function.\n\t(Gcc_backend::named_type): New function.\n\t(Gcc_backend::circular_pointer_type): New function.\n\t(Gcc_backend::is_circular_pointer_type): New function.\n\nFrom-SVN: r173380", "tree": {"sha": "5fcc497e550723948578243837604bc805c453df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fcc497e550723948578243837604bc805c453df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/comments", "author": null, "committer": null, "parents": [{"sha": "f81b1a3d371fa51de596917243863866b1235095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81b1a3d371fa51de596917243863866b1235095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f81b1a3d371fa51de596917243863866b1235095"}], "stats": {"total": 676, "additions": 487, "deletions": 189}, "files": [{"sha": "6c53224083e6f0c4f6ad945538ef19bac66ae960", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "patch": "@@ -1,3 +1,20 @@\n+2011-05-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::struct_type): Call fill_in_struct.\n+\t(Gcc_backend::fill_in_struct): New function.\n+\t(Gcc_backend::array_type): Implement.\n+\t(Gcc_backend::fill_in_array): New function.\n+\t(Gcc_backend::placeholder_pointer_type): New function.\n+\t(Gcc_backend::set_placeholder_pointer_type): New function.\n+\t(Gcc_backend::set_placeholder_function_type): New function.\n+\t(Gcc_backend::placeholder_struct_type): New function.\n+\t(Gcc_backend::set_placeholder_struct_type): New function.\n+\t(Gcc_backend::placeholder_array_type): New function.\n+\t(Gcc_backend::set_placeholder_array_type): New function.\n+\t(Gcc_backend::named_type): New function.\n+\t(Gcc_backend::circular_pointer_type): New function.\n+\t(Gcc_backend::is_circular_pointer_type): New function.\n+\n 2011-04-26  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::struct_type): Implement."}, {"sha": "18c0bbae52ebd74ffa68fd60e4a1070d28804d5e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 228, "deletions": 6, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "patch": "@@ -161,8 +161,38 @@ class Gcc_backend : public Backend\n   struct_type(const std::vector<Btyped_identifier>&);\n \n   Btype*\n-  array_type(const Btype* /* element_type */, const Bexpression* /* length */)\n-  { gcc_unreachable(); }\n+  array_type(Btype*, Bexpression*);\n+\n+  Btype*\n+  placeholder_pointer_type(const std::string&, source_location, bool);\n+\n+  bool\n+  set_placeholder_pointer_type(Btype*, Btype*);\n+\n+  bool\n+  set_placeholder_function_type(Btype*, Btype*);\n+\n+  Btype*\n+  placeholder_struct_type(const std::string&, source_location);\n+\n+  bool\n+  set_placeholder_struct_type(Btype* placeholder,\n+\t\t\t      const std::vector<Btyped_identifier>&);\n+\n+  Btype*\n+  placeholder_array_type(const std::string&, source_location);\n+\n+  bool\n+  set_placeholder_array_type(Btype*, Btype*, Bexpression*);\n+\n+  Btype*\n+  named_type(const std::string&, Btype*, source_location);\n+\n+  Btype*\n+  circular_pointer_type(Btype*, bool);\n+\n+  bool\n+  is_circular_pointer_type(Btype*);\n \n   // Statements.\n \n@@ -270,6 +300,12 @@ class Gcc_backend : public Backend\n   Btype*\n   make_type(tree t)\n   { return new Btype(t); }\n+\n+  Btype*\n+  fill_in_struct(Btype*, const std::vector<Btyped_identifier>&);\n+\n+  Btype*\n+  fill_in_array(Btype*, Btype*, Bexpression*);\n };\n \n // A helper function.\n@@ -453,7 +489,16 @@ Gcc_backend::function_type(const Btyped_identifier& receiver,\n Btype*\n Gcc_backend::struct_type(const std::vector<Btyped_identifier>& fields)\n {\n-  tree ret = make_node(RECORD_TYPE);\n+  return this->fill_in_struct(this->make_type(make_node(RECORD_TYPE)), fields);\n+}\n+\n+// Fill in the fields of a struct type.\n+\n+Btype*\n+Gcc_backend::fill_in_struct(Btype* fill,\n+\t\t\t    const std::vector<Btyped_identifier>& fields)\n+{\n+  tree fill_tree = fill->get_tree();\n   tree field_trees = NULL_TREE;\n   tree* pp = &field_trees;\n   for (std::vector<Btyped_identifier>::const_iterator p = fields.begin();\n@@ -465,15 +510,192 @@ Gcc_backend::struct_type(const std::vector<Btyped_identifier>& fields)\n       if (type_tree == error_mark_node)\n \treturn this->error_type();\n       tree field = build_decl(p->location, FIELD_DECL, name_tree, type_tree);\n-      DECL_CONTEXT(field) = ret;\n+      DECL_CONTEXT(field) = fill_tree;\n       *pp = field;\n       pp = &DECL_CHAIN(field);\n     }\n-  TYPE_FIELDS(ret) = field_trees;\n-  layout_type(ret);\n+  TYPE_FIELDS(fill_tree) = field_trees;\n+  layout_type(fill_tree);\n+  return fill;\n+}\n+\n+// Make an array type.\n+\n+Btype*\n+Gcc_backend::array_type(Btype* element_btype, Bexpression* length)\n+{\n+  return this->fill_in_array(this->make_type(make_node(ARRAY_TYPE)),\n+\t\t\t     element_btype, length);\n+}\n+\n+// Fill in an array type.\n+\n+Btype*\n+Gcc_backend::fill_in_array(Btype* fill, Btype* element_type,\n+\t\t\t   Bexpression* length)\n+{\n+  tree element_type_tree = element_type->get_tree();\n+  tree length_tree = length->get_tree();\n+  if (element_type_tree == error_mark_node || length_tree == error_mark_node)\n+    return this->error_type();\n+\n+  gcc_assert(TYPE_SIZE(element_type_tree) != NULL_TREE);\n+\n+  length_tree = fold_convert(sizetype, length_tree);\n+\n+  // build_index_type takes the maximum index, which is one less than\n+  // the length.\n+  tree index_type_tree = build_index_type(fold_build2(MINUS_EXPR, sizetype,\n+\t\t\t\t\t\t      length_tree,\n+\t\t\t\t\t\t      size_one_node));\n+\n+  tree fill_tree = fill->get_tree();\n+  TREE_TYPE(fill_tree) = element_type_tree;\n+  TYPE_DOMAIN(fill_tree) = index_type_tree;\n+  TYPE_ADDR_SPACE(fill_tree) = TYPE_ADDR_SPACE(element_type_tree);\n+  layout_type(fill_tree);\n+\n+  if (TYPE_STRUCTURAL_EQUALITY_P(element_type_tree))\n+    SET_TYPE_STRUCTURAL_EQUALITY(fill_tree);\n+  else if (TYPE_CANONICAL(element_type_tree) != element_type_tree\n+\t   || TYPE_CANONICAL(index_type_tree) != index_type_tree)\n+    TYPE_CANONICAL(fill_tree) =\n+      build_array_type(TYPE_CANONICAL(element_type_tree),\n+\t\t       TYPE_CANONICAL(index_type_tree));\n+\n+  return fill;\n+}\n+\n+// Create a placeholder for a pointer type.\n+\n+Btype*\n+Gcc_backend::placeholder_pointer_type(const std::string& name,\n+\t\t\t\t      source_location location, bool)\n+{\n+  tree ret = build_variant_type_copy(ptr_type_node);\n+  tree decl = build_decl(location, TYPE_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t ret);\n+  TYPE_NAME(ret) = decl;\n+  return this->make_type(ret);\n+}\n+\n+// Set the real target type for a placeholder pointer type.\n+\n+bool\n+Gcc_backend::set_placeholder_pointer_type(Btype* placeholder,\n+\t\t\t\t\t  Btype* to_type)\n+{\n+  tree pt = placeholder->get_tree();\n+  if (pt == error_mark_node)\n+    return false;\n+  gcc_assert(TREE_CODE(pt) == POINTER_TYPE);\n+  tree tt = to_type->get_tree();\n+  if (tt == error_mark_node)\n+    {\n+      TREE_TYPE(pt) = tt;\n+      return false;\n+    }\n+  gcc_assert(TREE_CODE(tt) == POINTER_TYPE);\n+  TREE_TYPE(pt) = TREE_TYPE(tt);\n+  return true;\n+}\n+\n+// Set the real values for a placeholder function type.\n+\n+bool\n+Gcc_backend::set_placeholder_function_type(Btype* placeholder, Btype* ft)\n+{\n+  return this->set_placeholder_pointer_type(placeholder, ft);\n+}\n+\n+// Create a placeholder for a struct type.\n+\n+Btype*\n+Gcc_backend::placeholder_struct_type(const std::string& name,\n+\t\t\t\t     source_location location)\n+{\n+  tree ret = make_node(RECORD_TYPE);\n+  tree decl = build_decl(location, TYPE_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t ret);\n+  TYPE_NAME(ret) = decl;\n   return this->make_type(ret);\n }\n \n+// Fill in the fields of a placeholder struct type.\n+\n+bool\n+Gcc_backend::set_placeholder_struct_type(\n+    Btype* placeholder,\n+    const std::vector<Btyped_identifier>& fields)\n+{\n+  tree t = placeholder->get_tree();\n+  gcc_assert(TREE_CODE(t) == RECORD_TYPE && TYPE_FIELDS(t) == NULL_TREE);\n+  Btype* r = this->fill_in_struct(placeholder, fields);\n+  return r->get_tree() != error_mark_node;\n+}\n+\n+// Create a placeholder for an array type.\n+\n+Btype*\n+Gcc_backend::placeholder_array_type(const std::string& name,\n+\t\t\t\t    source_location location)\n+{\n+  tree ret = make_node(ARRAY_TYPE);\n+  tree decl = build_decl(location, TYPE_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t ret);\n+  TYPE_NAME(ret) = decl;\n+  return this->make_type(ret);\n+}\n+\n+// Fill in the fields of a placeholder array type.\n+\n+bool\n+Gcc_backend::set_placeholder_array_type(Btype* placeholder,\n+\t\t\t\t\tBtype* element_btype,\n+\t\t\t\t\tBexpression* length)\n+{\n+  tree t = placeholder->get_tree();\n+  gcc_assert(TREE_CODE(t) == ARRAY_TYPE && TREE_TYPE(t) == NULL_TREE);\n+  Btype* r = this->fill_in_array(placeholder, element_btype, length);\n+  return r->get_tree() != error_mark_node;\n+}\n+\n+// Return a named version of a type.\n+\n+Btype*\n+Gcc_backend::named_type(const std::string& name, Btype* btype,\n+\t\t\tsource_location location)\n+{\n+  tree type = btype->get_tree();\n+  if (type == error_mark_node)\n+    return this->error_type();\n+  type = build_variant_type_copy(type);\n+  tree decl = build_decl(location, TYPE_DECL,\n+\t\t\t get_identifier_from_string(name),\n+\t\t\t type);\n+  TYPE_NAME(type) = decl;\n+  return this->make_type(type);\n+}\n+\n+// Return a pointer type used as a marker for a circular type.\n+\n+Btype*\n+Gcc_backend::circular_pointer_type(Btype*, bool)\n+{\n+  return this->make_type(ptr_type_node);\n+}\n+\n+// Return whether we might be looking at a circular type.\n+\n+bool\n+Gcc_backend::is_circular_pointer_type(Btype* btype)\n+{\n+  return btype->get_tree() == ptr_type_node;\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "d3154c59628c24779618151f6caa914a1d3a8cb7", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "patch": "@@ -108,7 +108,93 @@ class Backend\n \n   // Get an array type.\n   virtual Btype*\n-  array_type(const Btype* element_type, const Bexpression* length) = 0;\n+  array_type(Btype* element_type, Bexpression* length) = 0;\n+\n+  // Create a placeholder pointer type.  This is used for a named\n+  // pointer type, since in Go a pointer type may refer to itself.\n+  // NAME is the name of the type, and the location is where the named\n+  // type is defined.  FOR_FUNCTION is true if this is for a Go\n+  // function type, which corresponds to a C/C++ pointer to function\n+  // type.  The return value will later be passed as the first\n+  // parameter to set_placeholder_pointer_type or\n+  // set_placeholder_function_type.\n+  virtual Btype*\n+  placeholder_pointer_type(const std::string& name, source_location,\n+\t\t\t   bool for_function) = 0;\n+\n+  // Fill in a placeholder pointer type as a pointer.  This takes a\n+  // type returned by placeholder_pointer_type and arranges for it to\n+  // point to to_type.  Returns true on success, false on failure.\n+  virtual bool\n+  set_placeholder_pointer_type(Btype* placeholder, Btype* to_type) = 0;\n+\n+  // Fill in a placeholder pointer type as a function.  This takes a\n+  // type returned by placeholder_pointer_type and arranges for it to\n+  // become a real Go function type (which corresponds to a C/C++\n+  // pointer to function type).  FT will be something returned by the\n+  // function_type method.  Returns true on success, false on failure.\n+  virtual bool\n+  set_placeholder_function_type(Btype* placeholder, Btype* ft) = 0;\n+\n+  // Create a placeholder struct type.  This is used for a named\n+  // struct type, as with placeholder_pointer_type.\n+  virtual Btype*\n+  placeholder_struct_type(const std::string& name, source_location) = 0;\n+\n+  // Fill in a placeholder struct type.  This takes a type returned by\n+  // placeholder_struct_type and arranges for it to become a real\n+  // struct type.  The parameter is as for struct_type.  Returns true\n+  // on success, false on failure.\n+  virtual bool\n+  set_placeholder_struct_type(Btype* placeholder,\n+\t\t\t      const std::vector<Btyped_identifier>& fields)\n+  \t\t\t= 0;\n+\n+  // Create a placeholder array type.  This is used for a named array\n+  // type, as with placeholder_pointer_type, to handle cases like\n+  // type A []*A.\n+  virtual Btype*\n+  placeholder_array_type(const std::string& name, source_location) = 0;\n+\n+  // Fill in a placeholder array type.  This takes a type returned by\n+  // placeholder_array_type and arranges for it to become a real array\n+  // type.  The parameters are as for array_type.  Returns true on\n+  // success, false on failure.\n+  virtual bool\n+  set_placeholder_array_type(Btype* placeholder, Btype* element_type,\n+\t\t\t     Bexpression* length) = 0;\n+\n+  // Return a named version of a type.  The location is the location\n+  // of the type definition.  This will not be called for a type\n+  // created via placeholder_pointer_type, placeholder_struct_type, or\n+  // placeholder_array_type..  (It may be called for a pointer,\n+  // struct, or array type in a case like \"type P *byte; type Q P\".)\n+  virtual Btype*\n+  named_type(const std::string& name, Btype*, source_location) = 0;\n+\n+  // Create a marker for a circular pointer type.  Go pointer and\n+  // function types can refer to themselves in ways that are not\n+  // permitted in C/C++.  When a circular type is found, this function\n+  // is called for the circular reference.  This permits the backend\n+  // to decide how to handle such a type.  PLACEHOLDER is the\n+  // placeholder type which has already been created; if the backend\n+  // is prepared to handle a circular pointer type, it may simply\n+  // return PLACEHOLDER.  FOR_FUNCTION is true if this is for a\n+  // function type.\n+  //\n+  // For \"type P *P\" the sequence of calls will be\n+  //   bt1 = placeholder_pointer_type();\n+  //   bt2 = circular_pointer_type(bt1, false);\n+  //   set_placeholder_pointer_type(bt1, bt2);\n+  virtual Btype*\n+  circular_pointer_type(Btype* placeholder, bool for_function) = 0;\n+\n+  // Return whether the argument could be a special type created by\n+  // circular_pointer_type.  This is used to introduce explicit type\n+  // conversions where needed.  If circular_pointer_type returns its\n+  // PLACEHOLDER parameter, this may safely always return false.\n+  virtual bool\n+  is_circular_pointer_type(Btype*) = 0;\n \n   // Statements.\n "}, {"sha": "fed14473d69b714b4479cb2c122cfdc49267982e", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 131, "deletions": 167, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "patch": "@@ -896,10 +896,11 @@ Type::get_tree_without_hash(Gogo* gogo)\n       tree t = this->do_get_tree(gogo);\n \n       // For a recursive function or pointer type, we will temporarily\n-      // return ptr_type_node during the recursion.  We don't want to\n-      // record that for a forwarding type, as it may confuse us\n-      // later.\n-      if (t == ptr_type_node && this->forward_declaration_type() != NULL)\n+      // return a circular pointer type during the recursion.  We\n+      // don't want to record that for a forwarding type, as it may\n+      // confuse us later.\n+      if (this->forward_declaration_type() != NULL\n+\t  && gogo->backend()->is_circular_pointer_type(tree_to_type(t)))\n \treturn t;\n \n       if (gogo == NULL || !gogo->named_types_are_converted())\n@@ -912,6 +913,16 @@ Type::get_tree_without_hash(Gogo* gogo)\n   return this->tree_;\n }\n \n+// Return the backend representation for a type without looking in the\n+// hash table for identical types.  This is used for named types,\n+// since a named type is never identical to any other type.\n+\n+Btype*\n+Type::get_btype_without_hash(Gogo* gogo)\n+{\n+  return tree_to_type(this->get_tree_without_hash(gogo));\n+}\n+\n // Return a tree representing a zero initialization for this type.\n \n tree\n@@ -3748,58 +3759,36 @@ Struct_type::method_function(const std::string& name, bool* is_ambiguous) const\n   return Type::method_function(this->all_methods_, name, is_ambiguous);\n }\n \n-// Get the tree for a struct type.\n+// Convert struct fields to the backend representation.  This is not\n+// declared in types.h so that types.h doesn't have to #include\n+// backend.h.\n \n-tree\n-Struct_type::do_get_tree(Gogo* gogo)\n+static void\n+get_backend_struct_fields(Gogo* gogo, const Struct_field_list* fields,\n+\t\t\t  std::vector<Backend::Btyped_identifier>* bfields)\n {\n-  std::vector<Backend::Btyped_identifier> fields;\n-  fields.resize(this->fields_->size());\n+  bfields->resize(fields->size());\n   size_t i = 0;\n-  for (Struct_field_list::const_iterator p = this->fields_->begin();\n-       p != this->fields_->end();\n+  for (Struct_field_list::const_iterator p = fields->begin();\n+       p != fields->end();\n        ++p, ++i)\n     {\n-      fields[i].name = Gogo::unpack_hidden_name(p->field_name());\n-      fields[i].btype = tree_to_type(p->type()->get_tree(gogo));\n-      fields[i].location = p->location();\n+      (*bfields)[i].name = Gogo::unpack_hidden_name(p->field_name());\n+      (*bfields)[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+      (*bfields)[i].location = p->location();\n     }\n-  go_assert(i == this->fields_->size());\n-  Btype* btype = gogo->backend()->struct_type(fields);\n-  return type_to_tree(btype);\n+  go_assert(i == fields->size());\n }\n \n-// Fill in the fields for a struct type.\n+// Get the tree for a struct type.\n \n tree\n-Struct_type::fill_in_tree(Gogo* gogo, tree type)\n+Struct_type::do_get_tree(Gogo* gogo)\n {\n-  tree field_trees = NULL_TREE;\n-  tree* pp = &field_trees;\n-  for (Struct_field_list::const_iterator p = this->fields_->begin();\n-       p != this->fields_->end();\n-       ++p)\n-    {\n-      std::string name = Gogo::unpack_hidden_name(p->field_name());\n-      tree name_tree = get_identifier_with_length(name.data(), name.length());\n-\n-      tree field_type_tree = p->type()->get_tree(gogo);\n-      if (field_type_tree == error_mark_node)\n-\treturn error_mark_node;\n-      go_assert(TYPE_SIZE(field_type_tree) != NULL_TREE);\n-\n-      tree field = build_decl(p->location(), FIELD_DECL, name_tree,\n-\t\t\t      field_type_tree);\n-      DECL_CONTEXT(field) = type;\n-      *pp = field;\n-      pp = &DECL_CHAIN(field);\n-    }\n-\n-  TYPE_FIELDS(type) = field_trees;\n-\n-  layout_type(type);\n-\n-  return type;\n+  std::vector<Backend::Btyped_identifier> bfields;\n+  get_backend_struct_fields(gogo, this->fields_, &bfields);\n+  Btype* btype = gogo->backend()->struct_type(bfields);\n+  return type_to_tree(btype);\n }\n \n // Initialize struct fields.\n@@ -4425,50 +4414,26 @@ Array_type::do_get_tree(Gogo* gogo)\n     }\n   else\n     {\n-      tree array_type = make_node(ARRAY_TYPE);\n-      return this->fill_in_array_tree(gogo, array_type);\n+      Btype* element = this->get_backend_element(gogo);\n+      Bexpression* len = this->get_backend_length(gogo);\n+      Btype* ret = gogo->backend()->array_type(element, len);\n+      return type_to_tree(ret);\n     }\n }\n \n-// Fill in the fields for an array type.  This is used for named array\n-// types.\n-\n-tree\n-Array_type::fill_in_array_tree(Gogo* gogo, tree array_type)\n+// Return the backend representation of the element type.\n+Btype*\n+Array_type::get_backend_element(Gogo* gogo)\n {\n-  go_assert(this->length_ != NULL);\n-\n-  tree element_type_tree = this->element_type_->get_tree(gogo);\n-  tree length_tree = this->get_length_tree(gogo);\n-  if (element_type_tree == error_mark_node\n-      || length_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  go_assert(TYPE_SIZE(element_type_tree) != NULL_TREE);\n-\n-  length_tree = fold_convert(sizetype, length_tree);\n-\n-  // build_index_type takes the maximum index, which is one less than\n-  // the length.\n-  tree index_type = build_index_type(fold_build2(MINUS_EXPR, sizetype,\n-\t\t\t\t\t\t length_tree,\n-\t\t\t\t\t\t size_one_node));\n-\n-  TREE_TYPE(array_type) = element_type_tree;\n-  TYPE_DOMAIN(array_type) = index_type;\n-  TYPE_ADDR_SPACE(array_type) = TYPE_ADDR_SPACE(element_type_tree);\n-  layout_type(array_type);\n+  return tree_to_type(this->element_type_->get_tree(gogo));\n+}\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P(element_type_tree)\n-      || TYPE_STRUCTURAL_EQUALITY_P(index_type))\n-    SET_TYPE_STRUCTURAL_EQUALITY(array_type);\n-  else if (TYPE_CANONICAL(element_type_tree) != element_type_tree\n-\t   || TYPE_CANONICAL(index_type) != index_type)\n-    TYPE_CANONICAL(array_type) =\n-      build_array_type(TYPE_CANONICAL(element_type_tree),\n-\t\t       TYPE_CANONICAL(index_type));\n+// Return the backend representation of the length.\n \n-  return array_type;\n+Bexpression*\n+Array_type::get_backend_length(Gogo* gogo)\n+{\n+  return tree_to_expr(this->get_length_tree(gogo));\n }\n \n // Fill in the fields for a slice type.  This is used for named slice\n@@ -7073,7 +7038,7 @@ Named_type::convert(Gogo* gogo)\n     (*p)->convert(gogo);\n \n   // Complete this type.\n-  tree t = this->named_tree_;\n+  Btype* bt = this->named_btype_;\n   Type* base = this->type_->base();\n   switch (base->classification())\n     {\n@@ -7092,21 +7057,37 @@ Named_type::convert(Gogo* gogo)\n \n     case TYPE_FUNCTION:\n     case TYPE_POINTER:\n-      // The size of these types is already correct.\n+      // The size of these types is already correct.  We don't worry\n+      // about filling them in until later, when we also track\n+      // circular references.\n       break;\n \n     case TYPE_STRUCT:\n-      t = base->struct_type()->fill_in_tree(gogo, t);\n+      {\n+\tstd::vector<Backend::Btyped_identifier> bfields;\n+\tget_backend_struct_fields(gogo, base->struct_type()->fields(),\n+\t\t\t\t  &bfields);\n+\tif (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n+\t  bt = gogo->backend()->error_type();\n+      }\n       break;\n \n     case TYPE_ARRAY:\n       if (!base->is_open_array_type())\n-\tt = base->array_type()->fill_in_array_tree(gogo, t);\n+\t{\n+\t  Btype* bet = base->array_type()->get_backend_element(gogo);\n+\t  Bexpression* blen = base->array_type()->get_backend_length(gogo);\n+\t  if (!gogo->backend()->set_placeholder_array_type(bt, bet, blen))\n+\t    bt = gogo->backend()->error_type();\n+\t}\n       break;\n \n     case TYPE_INTERFACE:\n       if (!base->interface_type()->is_empty())\n-\tt = base->interface_type()->fill_in_tree(gogo, t);\n+\t{\n+\t  tree t = type_to_tree(bt);\n+\t  bt = tree_to_type(base->interface_type()->fill_in_tree(gogo, t));\n+\t}\n       break;\n \n     case TYPE_ERROR:\n@@ -7120,13 +7101,7 @@ Named_type::convert(Gogo* gogo)\n       go_unreachable();\n     }\n \n-  this->named_tree_ = t;\n-\n-  if (t == error_mark_node)\n-    this->is_error_ = true;\n-  else\n-    go_assert(TYPE_SIZE(t) != NULL_TREE);\n-\n+  this->named_btype_ = bt;\n   this->is_converted_ = true;\n }\n \n@@ -7137,22 +7112,23 @@ void\n Named_type::create_placeholder(Gogo* gogo)\n {\n   if (this->is_error_)\n-    this->named_tree_ = error_mark_node;\n+    this->named_btype_ = gogo->backend()->error_type();\n \n-  if (this->named_tree_ != NULL_TREE)\n+  if (this->named_btype_ != NULL)\n     return;\n \n   // Create the structure for this type.  Note that because we call\n   // base() here, we don't attempt to represent a named type defined\n   // as another named type.  Instead both named types will point to\n   // different base representations.\n   Type* base = this->type_->base();\n-  tree t;\n+  Btype* bt;\n+  bool set_name = true;\n   switch (base->classification())\n     {\n     case TYPE_ERROR:\n       this->is_error_ = true;\n-      this->named_tree_ = error_mark_node;\n+      this->named_btype_ = gogo->backend()->error_type();\n       return;\n \n     case TYPE_VOID:\n@@ -7164,55 +7140,50 @@ Named_type::create_placeholder(Gogo* gogo)\n     case TYPE_NIL:\n       // These are simple basic types, we can just create them\n       // directly.\n-      t = Type::get_named_type_tree(gogo, base);\n-      if (t == error_mark_node)\n-\t{\n-\t  this->is_error_ = true;\n-\t  this->named_tree_ = error_mark_node;\n-\t  return;\n-\t}\n-      t = build_variant_type_copy(t);\n+      bt = Type::get_named_base_btype(gogo, base);\n       break;\n \n     case TYPE_MAP:\n     case TYPE_CHANNEL:\n-      // All maps and channels have the same type in GENERIC.\n-      t = Type::get_named_type_tree(gogo, base);\n-      if (t == error_mark_node)\n-\t{\n-\t  this->is_error_ = true;\n-\t  this->named_tree_ = error_mark_node;\n-\t  return;\n-\t}\n-      t = build_variant_type_copy(t);\n+      // All maps and channels have the same backend representation.\n+      bt = Type::get_named_base_btype(gogo, base);\n       break;\n \n     case TYPE_FUNCTION:\n     case TYPE_POINTER:\n-      t = build_variant_type_copy(ptr_type_node);\n+      {\n+\tbool for_function = base->classification() == TYPE_FUNCTION;\n+\tbt = gogo->backend()->placeholder_pointer_type(this->name(),\n+\t\t\t\t\t\t       this->location_,\n+\t\t\t\t\t\t       for_function);\n+\tset_name = false;\n+      }\n       break;\n \n     case TYPE_STRUCT:\n-      t = make_node(RECORD_TYPE);\n+      bt = gogo->backend()->placeholder_struct_type(this->name(),\n+\t\t\t\t\t\t    this->location_);\n+      set_name = false;\n       break;\n \n     case TYPE_ARRAY:\n       if (base->is_open_array_type())\n-\tt = gogo->slice_type_tree(void_type_node);\n+\tbt = tree_to_type(gogo->slice_type_tree(void_type_node));\n       else\n-\tt = make_node(ARRAY_TYPE);\n+\t{\n+\t  bt = gogo->backend()->placeholder_array_type(this->name(),\n+\t\t\t\t\t\t       this->location_);\n+\t  set_name = false;\n+\t}\n       break;\n \n     case TYPE_INTERFACE:\n       if (base->interface_type()->is_empty())\n-\t{\n-\t  t = Interface_type::empty_type_tree(gogo);\n-\t  t = build_variant_type_copy(t);\n-\t}\n+\tbt = tree_to_type(Interface_type::empty_type_tree(gogo));\n       else\n \t{\n \t  source_location loc = base->interface_type()->location();\n-\t  t = Interface_type::non_empty_type_tree(loc);\n+\t  bt = tree_to_type(Interface_type::non_empty_type_tree(loc));\n \t}\n       break;\n \n@@ -7224,13 +7195,10 @@ Named_type::create_placeholder(Gogo* gogo)\n       go_unreachable();\n     }\n \n-  // Create the named type.\n+  if (set_name)\n+    bt = gogo->backend()->named_type(this->name(), bt, this->location_);\n \n-  tree id = this->named_object_->get_id(gogo);\n-  tree decl = build_decl(this->location_, TYPE_DECL, id, t);\n-  TYPE_NAME(t) = decl;\n-\n-  this->named_tree_ = t;\n+  this->named_btype_ = bt;\n }\n \n // Get a tree for a named type.\n@@ -7241,24 +7209,22 @@ Named_type::do_get_tree(Gogo* gogo)\n   if (this->is_error_)\n     return error_mark_node;\n \n-  tree t = this->named_tree_;\n+  Btype* bt = this->named_btype_;\n \n-  // FIXME: GOGO can be NULL when called from go_type_for_size, which\n-  // is only used for basic types.\n-  if (gogo == NULL || !gogo->named_types_are_converted())\n+  if (!gogo->named_types_are_converted())\n     {\n-      // We have not completed converting named types.  NAMED_TREE_ is\n-      // a placeholder and we shouldn't do anything further.\n-      if (t != NULL_TREE)\n-\treturn t;\n+      // We have not completed converting named types.  NAMED_BTYPE_\n+      // is a placeholder and we shouldn't do anything further.\n+      if (bt != NULL)\n+\treturn type_to_tree(bt);\n \n       // We don't build dependencies for types whose sizes do not\n       // change or are not relevant, so we may see them here while\n       // converting types.\n       this->create_placeholder(gogo);\n-      t = this->named_tree_;\n-      go_assert(t != NULL_TREE);\n-      return t;\n+      bt = this->named_btype_;\n+      go_assert(bt != NULL);\n+      return type_to_tree(bt);\n     }\n \n   // We are not converting types.  This should only be called if the\n@@ -7269,11 +7235,11 @@ Named_type::do_get_tree(Gogo* gogo)\n       return error_mark_node;\n     }\n \n-  go_assert(t != NULL_TREE && TYPE_SIZE(t) != NULL_TREE);\n+  go_assert(bt != NULL);\n \n   // Complete the tree.\n   Type* base = this->type_->base();\n-  tree t1;\n+  Btype* bt1;\n   switch (base->classification())\n     {\n     case TYPE_ERROR:\n@@ -7290,61 +7256,59 @@ Named_type::do_get_tree(Gogo* gogo)\n     case TYPE_CHANNEL:\n     case TYPE_STRUCT:\n     case TYPE_INTERFACE:\n-      return t;\n+      return type_to_tree(bt);\n \n     case TYPE_FUNCTION:\n       // Don't build a circular data structure.  GENERIC can't handle\n       // it.\n       if (this->seen_ > 0)\n \t{\n \t  this->is_circular_ = true;\n-\t  return ptr_type_node;\n+\t  bt1 = gogo->backend()->circular_pointer_type(bt, true);\n+\t  return type_to_tree(bt1);\n \t}\n       ++this->seen_;\n-      t1 = Type::get_named_type_tree(gogo, base);\n+      bt1 = Type::get_named_base_btype(gogo, base);\n       --this->seen_;\n-      if (t1 == error_mark_node)\n-\treturn error_mark_node;\n       if (this->is_circular_)\n-\tt1 = ptr_type_node;\n-      go_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n-      go_assert(TREE_CODE(t1) == POINTER_TYPE);\n-      TREE_TYPE(t) = TREE_TYPE(t1);\n-      return t;\n+\tbt1 = gogo->backend()->circular_pointer_type(bt, true);\n+      if (!gogo->backend()->set_placeholder_pointer_type(bt, bt1))\n+\tbt = gogo->backend()->error_type();\n+      return type_to_tree(bt);\n \n     case TYPE_POINTER:\n       // Don't build a circular data structure. GENERIC can't handle\n       // it.\n       if (this->seen_ > 0)\n \t{\n \t  this->is_circular_ = true;\n-\t  return ptr_type_node;\n+\t  bt1 = gogo->backend()->circular_pointer_type(bt, false);\n+\t  return type_to_tree(bt1);\n \t}\n       ++this->seen_;\n-      t1 = Type::get_named_type_tree(gogo, base);\n+      bt1 = Type::get_named_base_btype(gogo, base);\n       --this->seen_;\n-      if (t1 == error_mark_node)\n-\treturn error_mark_node;\n       if (this->is_circular_)\n-\tt1 = ptr_type_node;\n-      go_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n-      go_assert(TREE_CODE(t1) == POINTER_TYPE);\n-      TREE_TYPE(t) = TREE_TYPE(t1);\n-      return t;\n+\tbt1 = gogo->backend()->circular_pointer_type(bt, false);\n+      if (!gogo->backend()->set_placeholder_pointer_type(bt, bt1))\n+\tbt = gogo->backend()->error_type();\n+      return type_to_tree(bt);\n \n     case TYPE_ARRAY:\n       if (base->is_open_array_type())\n \t{\n \t  if (this->seen_ > 0)\n-\t    return t;\n+\t    return type_to_tree(bt);\n \t  else\n \t    {\n \t      ++this->seen_;\n-\t      t = base->array_type()->fill_in_slice_tree(gogo, t);\n+\t      tree t = base->array_type()->fill_in_slice_tree(gogo,\n+\t\t\t\t\t\t\t      type_to_tree(bt));\n+\t      bt = tree_to_type(t);\n \t      --this->seen_;\n \t    }\n \t}\n-      return t;\n+      return type_to_tree(bt);\n \n     default:\n     case TYPE_SINK:\n@@ -8467,7 +8431,7 @@ tree\n Forward_declaration_type::do_get_tree(Gogo* gogo)\n {\n   if (this->is_defined())\n-    return Type::get_named_type_tree(gogo, this->real_type());\n+    return type_to_tree(Type::get_named_base_btype(gogo, this->real_type()));\n \n   if (this->warned_)\n     return error_mark_node;"}, {"sha": "3b4d5f22953d589d04ebdde97d170387a2e81f92", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=7fc2f86b5fb801c7b2c46a764e9d0594cbcb73b9", "patch": "@@ -42,6 +42,8 @@ class Function;\n class Translate_context;\n class Export;\n class Import;\n+class Btype;\n+class Bexpression;\n \n // Type codes used in type descriptors.  These must match the values\n // in libgo/runtime/go-type.h.  They also match the values in the gc\n@@ -973,10 +975,11 @@ class Type\n   static unsigned int\n   hash_string(const std::string&, unsigned int);\n \n-  // Return a tree for the underlying type of a named type.\n-  static tree\n-  get_named_type_tree(Gogo* gogo, Type* base_type)\n-  { return base_type->get_tree_without_hash(gogo); }\n+  // Return the backend representation for the underlying type of a\n+  // named type.\n+  static Btype*\n+  get_named_base_btype(Gogo* gogo, Type* base_type)\n+  { return base_type->get_btype_without_hash(gogo); }\n \n  private:\n   // Convert to the desired type classification, or return NULL.  This\n@@ -1100,6 +1103,11 @@ class Type\n   tree\n   get_tree_without_hash(Gogo*);\n \n+  // Get the backend representation for a type without looking in the\n+  // hash table for identical types.\n+  Btype*\n+  get_btype_without_hash(Gogo*);\n+\n   // A mapping from Type to tree, used to ensure that the GIMPLE\n   // representation of identical types is identical.\n   typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n@@ -1952,10 +1960,6 @@ class Struct_type : public Type\n   static Struct_type*\n   do_import(Import*);\n \n-  // Fill in the fields for a named struct type.\n-  tree\n-  fill_in_tree(Gogo*, tree);\n-\n   static Type*\n   make_struct_type_descriptor_type();\n \n@@ -2056,9 +2060,13 @@ class Array_type : public Type\n   static Array_type*\n   do_import(Import*);\n \n-  // Fill in the fields for a named array type.\n-  tree\n-  fill_in_array_tree(Gogo*, tree);\n+  // Return the backend representation of the element type.\n+  Btype*\n+  get_backend_element(Gogo*);\n+\n+  // Return the backend representation of the length.\n+  Bexpression*\n+  get_backend_length(Gogo*);\n \n   // Fill in the fields for a named slice type.\n   tree\n@@ -2430,7 +2438,7 @@ class Named_type : public Type\n       named_object_(named_object), in_function_(NULL), type_(type),\n       local_methods_(NULL), all_methods_(NULL),\n       interface_method_tables_(NULL), pointer_interface_method_tables_(NULL),\n-      location_(location), named_tree_(NULL), dependencies_(),\n+      location_(location), named_btype_(NULL), dependencies_(),\n       is_visible_(true), is_error_(false), is_converted_(false),\n       is_circular_(false), seen_(0)\n   { }\n@@ -2676,9 +2684,10 @@ class Named_type : public Type\n   Interface_method_tables* pointer_interface_method_tables_;\n   // The location where this type was defined.\n   source_location location_;\n-  // The tree for this type while converting to GENERIC.  This is used\n-  // to avoid endless recursion when a named type refers to itself.\n-  tree named_tree_;\n+  // The backend representation of this type during backend\n+  // conversion.  This is used to avoid endless recursion when a named\n+  // type refers to itself.\n+  Btype* named_btype_;\n   // A list of types which must be converted to the backend\n   // representation before this type can be converted.  This is for\n   // cases like"}]}