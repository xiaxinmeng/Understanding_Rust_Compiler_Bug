{"sha": "f179b64e3ab013ff04e705953d33a2f82de6b086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3OWI2NGUzYWIwMTNmZjA0ZTcwNTk1M2QzM2EyZjgyZGU2YjA4Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-04-26T15:38:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-04-26T15:38:33Z"}, "message": "re PR debug/90197 (Cannot step through simple loop at -O -g)\n\n\tPR debug/90197\n\t* c-tree.h (c_finish_loop): Add 2 further location_t arguments.\n\t* c-parser.c (c_parser_while_statement): Adjust c_finish_loop caller.\n\t(c_parser_do_statement): Likewise.\n\t(c_parser_for_statement): Likewise.  Formatting fixes.\n\t* c-typeck.c (c_finish_loop): Add COND_LOCUS and INCR_LOCUS arguments,\n\temit DEBUG_BEGIN_STMTs if needed.\n\nFrom-SVN: r270606", "tree": {"sha": "52464894da7f7ffd9b288bcb2b44f8dd5e1958b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52464894da7f7ffd9b288bcb2b44f8dd5e1958b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f179b64e3ab013ff04e705953d33a2f82de6b086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f179b64e3ab013ff04e705953d33a2f82de6b086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f179b64e3ab013ff04e705953d33a2f82de6b086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f179b64e3ab013ff04e705953d33a2f82de6b086/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b3a5e8a3d18c8a954c6e99072fe1859977fafbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3a5e8a3d18c8a954c6e99072fe1859977fafbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3a5e8a3d18c8a954c6e99072fe1859977fafbd"}], "stats": {"total": 99, "additions": 70, "deletions": 29}, "files": [{"sha": "ef192bf64a4859271de2d6c9b58038d6da5a2095", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=f179b64e3ab013ff04e705953d33a2f82de6b086", "patch": "@@ -1,3 +1,13 @@\n+2019-04-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/90197\n+\t* c-tree.h (c_finish_loop): Add 2 further location_t arguments.\n+\t* c-parser.c (c_parser_while_statement): Adjust c_finish_loop caller.\n+\t(c_parser_do_statement): Likewise.\n+\t(c_parser_for_statement): Likewise.  Formatting fixes.\n+\t* c-typeck.c (c_finish_loop): Add COND_LOCUS and INCR_LOCUS arguments,\n+\temit DEBUG_BEGIN_STMTs if needed.\n+\n 2019-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/89888"}, {"sha": "854cd6ce8c60ef096f61f91326123f559a85a533", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=f179b64e3ab013ff04e705953d33a2f82de6b086", "patch": "@@ -6001,7 +6001,8 @@ c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n   location_t loc_after_labels;\n   bool open_brace = c_parser_next_token_is (parser, CPP_OPEN_BRACE);\n   body = c_parser_c99_block_statement (parser, if_p, &loc_after_labels);\n-  c_finish_loop (loc, cond, NULL, body, c_break_label, c_cont_label, true);\n+  c_finish_loop (loc, loc, cond, UNKNOWN_LOCATION, NULL, body,\n+\t\t c_break_label, c_cont_label, true);\n   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n   c_parser_maybe_reclassify_token (parser);\n \n@@ -6046,6 +6047,7 @@ c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)\n   c_break_label = save_break;\n   new_cont = c_cont_label;\n   c_cont_label = save_cont;\n+  location_t cond_loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_paren_condition (parser);\n   if (ivdep && cond != error_mark_node)\n     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n@@ -6059,7 +6061,8 @@ c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)\n  \t\t   build_int_cst (integer_type_node, unroll));\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n-  c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);\n+  c_finish_loop (loc, cond_loc, cond, UNKNOWN_LOCATION, NULL, body,\n+\t\t new_break, new_cont, false);\n   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n }\n \n@@ -6132,7 +6135,9 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n   /* Silence the bogus uninitialized warning.  */\n   tree collection_expression = NULL;\n   location_t loc = c_parser_peek_token (parser)->location;\n-  location_t for_loc = c_parser_peek_token (parser)->location;\n+  location_t for_loc = loc;\n+  location_t cond_loc = UNKNOWN_LOCATION;\n+  location_t incr_loc = UNKNOWN_LOCATION;\n   bool is_foreach_statement = false;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));\n   token_indent_info for_tinfo\n@@ -6166,7 +6171,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t      c_parser_consume_token (parser);\n \t      is_foreach_statement = true;\n \t      if (check_for_loop_decls (for_loc, true) == NULL_TREE)\n-\t\tc_parser_error (parser, \"multiple iterating variables in fast enumeration\");\n+\t\tc_parser_error (parser, \"multiple iterating variables in \"\n+\t\t\t\t\t\"fast enumeration\");\n \t    }\n \t  else\n \t    check_for_loop_decls (for_loc, flag_isoc99);\n@@ -6196,7 +6202,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t\t  c_parser_consume_token (parser);\n \t\t  is_foreach_statement = true;\n \t\t  if (check_for_loop_decls (for_loc, true) == NULL_TREE)\n-\t\t    c_parser_error (parser, \"multiple iterating variables in fast enumeration\");\n+\t\t    c_parser_error (parser, \"multiple iterating variables in \"\n+\t\t\t\t\t    \"fast enumeration\");\n \t\t}\n \t      else\n \t\tcheck_for_loop_decls (for_loc, flag_isoc99);\n@@ -6218,15 +6225,18 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t\tc_parser_consume_token (parser);\n \t\tis_foreach_statement = true;\n \t\tif (! lvalue_p (init_expression))\n-\t\t  c_parser_error (parser, \"invalid iterating variable in fast enumeration\");\n-\t\tobject_expression = c_fully_fold (init_expression, false, NULL);\n+\t\t  c_parser_error (parser, \"invalid iterating variable in \"\n+\t\t\t\t\t  \"fast enumeration\");\n+\t\tobject_expression\n+\t\t  = c_fully_fold (init_expression, false, NULL);\n \t      }\n \t    else\n \t      {\n \t\tce = convert_lvalue_to_rvalue (loc, ce, true, false);\n \t\tinit_expression = ce.value;\n \t\tc_finish_expr_stmt (loc, init_expression);\n-\t\tc_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t\tc_parser_skip_until_found (parser, CPP_SEMICOLON,\n+\t\t\t\t\t   \"expected %<;%>\");\n \t      }\n \t  }\n \t}\n@@ -6235,18 +6245,19 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n       gcc_assert (!parser->objc_could_be_foreach_context);\n       if (!is_foreach_statement)\n \t{\n+\t  cond_loc = c_parser_peek_token (parser)->location;\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n \t      if (ivdep)\n \t\t{\n-\t\t  c_parser_error (parser, \"missing loop condition in loop with \"\n-\t\t\t\t  \"%<GCC ivdep%> pragma\");\n+\t\t  c_parser_error (parser, \"missing loop condition in loop \"\n+\t\t\t\t\t  \"with %<GCC ivdep%> pragma\");\n \t\t  cond = error_mark_node;\n \t\t}\n \t      else if (unroll)\n \t\t{\n-\t\t  c_parser_error (parser, \"missing loop condition in loop with \"\n-\t\t\t\t  \"%<GCC unroll%> pragma\");\n+\t\t  c_parser_error (parser, \"missing loop condition in loop \"\n+\t\t\t\t\t  \"with %<GCC unroll%> pragma\");\n \t\t  cond = error_mark_node;\n \t\t}\n \t      else\n@@ -6275,11 +6286,13 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n       /* Parse the increment expression (the third expression in a\n \t for-statement).  In the case of a foreach-statement, this is\n \t the expression that follows the 'in'.  */\n+      loc = incr_loc = c_parser_peek_token (parser)->location;\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n \t  if (is_foreach_statement)\n \t    {\n-\t      c_parser_error (parser, \"missing collection in fast enumeration\");\n+\t      c_parser_error (parser,\n+\t\t\t      \"missing collection in fast enumeration\");\n \t      collection_expression = error_mark_node;\n \t    }\n \t  else\n@@ -6288,8 +6301,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n       else\n \t{\n \t  if (is_foreach_statement)\n-\t    collection_expression = c_fully_fold (c_parser_expression (parser).value,\n-\t\t\t\t\t\t  false, NULL);\n+\t    collection_expression\n+\t      = c_fully_fold (c_parser_expression (parser).value, false, NULL);\n \t  else\n \t    {\n \t      struct c_expr ce = c_parser_expression (parser);\n@@ -6312,10 +6325,14 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n   body = c_parser_c99_block_statement (parser, if_p, &loc_after_labels);\n \n   if (is_foreach_statement)\n-    objc_finish_foreach_loop (loc, object_expression, collection_expression, body, c_break_label, c_cont_label);\n+    objc_finish_foreach_loop (for_loc, object_expression,\n+\t\t\t      collection_expression, body, c_break_label,\n+\t\t\t      c_cont_label);\n   else\n-    c_finish_loop (loc, cond, incr, body, c_break_label, c_cont_label, true);\n-  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99 || c_dialect_objc ()));\n+    c_finish_loop (for_loc, cond_loc, cond, incr_loc, incr, body,\n+\t\t   c_break_label, c_cont_label, true);\n+  add_stmt (c_end_compound_stmt (for_loc, block,\n+\t\t\t\t flag_isoc99 || c_dialect_objc ()));\n   c_parser_maybe_reclassify_token (parser);\n \n   token_indent_info next_tinfo"}, {"sha": "7e35ab1f0bcfe7ece008788547e29261592899f4", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=f179b64e3ab013ff04e705953d33a2f82de6b086", "patch": "@@ -694,7 +694,8 @@ extern int c_types_compatible_p (tree, tree);\n extern tree c_begin_compound_stmt (bool);\n extern tree c_end_compound_stmt (location_t, tree, bool);\n extern void c_finish_if_stmt (location_t, tree, tree, tree);\n-extern void c_finish_loop (location_t, tree, tree, tree, tree, tree, bool);\n+extern void c_finish_loop (location_t, location_t, tree, location_t, tree,\n+\t\t\t   tree, tree, tree, bool);\n extern tree c_begin_stmt_expr (void);\n extern tree c_finish_stmt_expr (location_t, tree);\n extern tree c_process_expr_stmt (location_t, tree);"}, {"sha": "4e4437540028ee53110aeeb89c6f8c5812097687", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f179b64e3ab013ff04e705953d33a2f82de6b086/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=f179b64e3ab013ff04e705953d33a2f82de6b086", "patch": "@@ -10858,11 +10858,14 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n    the beginning of the loop.  COND is the loop condition.  COND_IS_FIRST\n    is false for DO loops.  INCR is the FOR increment expression.  BODY is\n    the statement controlled by the loop.  BLAB is the break label.  CLAB is\n-   the continue label.  Everything is allowed to be NULL.  */\n+   the continue label.  Everything is allowed to be NULL.\n+   COND_LOCUS is the location of the loop condition, INCR_LOCUS is the\n+   location of the FOR increment expression.  */\n \n void\n-c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n-\t       tree blab, tree clab, bool cond_is_first)\n+c_finish_loop (location_t start_locus, location_t cond_locus, tree cond,\n+\t       location_t incr_locus, tree incr, tree body, tree blab,\n+\t       tree clab, bool cond_is_first)\n {\n   tree entry = NULL, exit = NULL, t;\n \n@@ -10904,12 +10907,8 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n \t    }\n \n \t  t = build_and_jump (&blab);\n-\t  if (cond_is_first)\n-\t    exit = fold_build3_loc (start_locus,\n-\t\t\t\tCOND_EXPR, void_type_node, cond, exit, t);\n-\t  else\n-\t    exit = fold_build3_loc (input_location,\n-\t\t\t\tCOND_EXPR, void_type_node, cond, exit, t);\n+\t  exit = fold_build3_loc (cond_is_first ? start_locus : input_location,\n+\t\t\t\t  COND_EXPR, void_type_node, cond, exit, t);\n \t}\n       else\n \t{\n@@ -10930,9 +10929,23 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n   if (clab)\n     add_stmt (build1 (LABEL_EXPR, void_type_node, clab));\n   if (incr)\n-    add_stmt (incr);\n+    {\n+      if (MAY_HAVE_DEBUG_MARKER_STMTS && incr_locus != UNKNOWN_LOCATION)\n+\t{\n+\t  t = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+\t  SET_EXPR_LOCATION (t, incr_locus);\n+\t  add_stmt (t);\n+\t}\n+      add_stmt (incr);\n+    }\n   if (entry)\n     add_stmt (entry);\n+  if (MAY_HAVE_DEBUG_MARKER_STMTS && cond_locus != UNKNOWN_LOCATION)\n+    {\n+      t = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+      SET_EXPR_LOCATION (t, cond_locus);\n+      add_stmt (t);\n+    }\n   if (exit)\n     add_stmt (exit);\n   if (blab)"}]}