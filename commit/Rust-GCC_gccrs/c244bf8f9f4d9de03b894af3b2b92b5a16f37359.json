{"sha": "c244bf8f9f4d9de03b894af3b2b92b5a16f37359", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0NGJmOGY5ZjRkOWRlMDNiODk0YWYzYjJiOTJiNWExNmYzNzM1OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-10T12:52:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-10T12:52:13Z"}, "message": "decl.c (gnat_to_gnu_entity): Use a reference to the original type for the type of the field of the XVS type.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Subtype>: Use\n\ta reference to the original type for the type of the field of the\n\tXVS type.\n\t(maybe_pad_type): Likewise.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Factor\n\tcommon predicate and remove redundant setting of TYPE_BY_REFERENCE_P.\n\tPass correctly typed arguments to create_field_decl.\n\t<E_Record_Subtype>: Set BLKmode for tagged and limited types in the\n\tcase of contrained discriminants as well.  Use the padded base type\n\tin the other case as well.  Rename temporary variable.  Tweak test.\n\tFactor common access pattern.  Set GNU_SIZE only once.\n\nFrom-SVN: r148345", "tree": {"sha": "999afe73f28b590fbcd4b25c94a1ce18d342beb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/999afe73f28b590fbcd4b25c94a1ce18d342beb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c244bf8f9f4d9de03b894af3b2b92b5a16f37359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c244bf8f9f4d9de03b894af3b2b92b5a16f37359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c244bf8f9f4d9de03b894af3b2b92b5a16f37359", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c244bf8f9f4d9de03b894af3b2b92b5a16f37359/comments", "author": null, "committer": null, "parents": [{"sha": "f788ca8980d123476d820104aa0e171df05bfc3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f788ca8980d123476d820104aa0e171df05bfc3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f788ca8980d123476d820104aa0e171df05bfc3d"}], "stats": {"total": 153, "additions": 86, "deletions": 67}, "files": [{"sha": "deb5f07a7ad16416e46aefadfd64b3ac1740ce2e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c244bf8f9f4d9de03b894af3b2b92b5a16f37359/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c244bf8f9f4d9de03b894af3b2b92b5a16f37359/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c244bf8f9f4d9de03b894af3b2b92b5a16f37359", "patch": "@@ -1,3 +1,18 @@\n+2009-06-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Subtype>: Use\n+\ta reference to the original type for the type of the field of the\n+\tXVS type.\n+\t(maybe_pad_type): Likewise.\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Factor\n+\tcommon predicate and remove redundant setting of TYPE_BY_REFERENCE_P.\n+\tPass correctly typed arguments to create_field_decl.\n+\t<E_Record_Subtype>: Set BLKmode for tagged and limited types in the\n+\tcase of contrained discriminants as well.  Use the padded base type\n+\tin the other case as well.  Rename temporary variable.  Tweak test.\n+\tFactor common access pattern.  Set GNU_SIZE only once.\n+\n 2009-06-09  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc-interface/utils2.c (build_call_alloc_dealloc_proc): New"}, {"sha": "14a0cd19914596a547f3949f03f57949e8d18561", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c244bf8f9f4d9de03b894af3b2b92b5a16f37359/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c244bf8f9f4d9de03b894af3b2b92b5a16f37359/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c244bf8f9f4d9de03b894af3b2b92b5a16f37359", "patch": "@@ -2727,9 +2727,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tNode_Id full_definition = Declaration_Node (gnat_entity);\n \tNode_Id record_definition = Type_Definition (full_definition);\n \tEntity_Id gnat_field;\n-\ttree gnu_field;\n-\ttree gnu_field_list = NULL_TREE;\n-\ttree gnu_get_parent;\n+\ttree gnu_field, gnu_field_list = NULL_TREE, gnu_get_parent;\n \t/* Set PACKED in keeping with gnat_to_gnu_field.  */\n \tint packed\n \t  = Is_Packed (gnat_entity)\n@@ -2741,6 +2739,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     && Known_Static_Esize (gnat_entity)))\n \t\t? -2\n \t\t: 0;\n+\tbool has_discr = Has_Discriminants (gnat_entity);\n \tbool has_rep = Has_Specified_Layout (gnat_entity);\n \tbool all_rep = has_rep;\n \tbool is_extension\n@@ -2838,7 +2837,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t void_type_node),\n \t\t\t\t     NULL_TREE);\n \n-\t    if (Has_Discriminants (gnat_entity))\n+\t    if (has_discr)\n \t      for (gnat_field = First_Stored_Discriminant (gnat_entity);\n \t\t   Present (gnat_field);\n \t\t   gnat_field = Next_Stored_Discriminant (gnat_field))\n@@ -2883,7 +2882,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     gnat_field = Next_Stored_Discriminant (gnat_field))\n \t\t  if (Present (Corresponding_Discriminant (gnat_field)))\n \t\t    {\n-\t\t      tree gnu_field = gnat_to_gnu_field_decl (gnat_field);\n+\t\t      gnu_field = gnat_to_gnu_field_decl (gnat_field);\n \t\t      tree gnu_ref\n \t\t\t= build3 (COMPONENT_REF, TREE_TYPE (gnu_field),\n \t\t\t\t  gnu_get_parent, gnu_field, NULL_TREE);\n@@ -2898,7 +2897,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       initially built.  The discriminants must reference the fields\n \t       of the parent subtype and not those of its base type for the\n \t       placeholder machinery to properly work.  */\n-\t    if (Has_Discriminants (gnat_entity))\n+\t    if (has_discr)\n \t      {\n \t\t/* The actual parent subtype is the full view.  */\n \t\tif (IN (Ekind (gnat_parent), Private_Kind))\n@@ -2935,16 +2934,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = create_field_decl (get_identifier\n \t\t\t\t   (Get_Name_String (Name_uParent)),\n \t\t\t\t   gnu_parent, gnu_type, 0,\n-\t\t\t\t   has_rep ? TYPE_SIZE (gnu_parent) : 0,\n-\t\t\t\t   has_rep ? bitsize_zero_node : 0, 1);\n+\t\t\t\t   has_rep\n+\t\t\t\t   ? TYPE_SIZE (gnu_parent) : NULL_TREE,\n+\t\t\t\t   has_rep\n+\t\t\t\t   ? bitsize_zero_node : NULL_TREE, 1);\n \t    DECL_INTERNAL_P (gnu_field) = 1;\n \t    TREE_OPERAND (gnu_get_parent, 1) = gnu_field;\n \t    TYPE_FIELDS (gnu_type) = gnu_field;\n \t  }\n \n \t/* Make the fields for the discriminants and put them into the record\n \t   unless it's an Unchecked_Union.  */\n-\tif (Has_Discriminants (gnat_entity))\n+\tif (has_discr)\n \t  for (gnat_field = First_Stored_Discriminant (gnat_entity);\n \t       Present (gnat_field);\n \t       gnat_field = Next_Stored_Discriminant (gnat_field))\n@@ -2979,18 +2980,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      gnu_field_list, packed, definition, NULL,\n \t\t\t      false, all_rep, false, is_unchecked_union);\n \n-\t/* We used to remove the associations of the discriminants and _Parent\n-\t   for validity checking but we may need them if there's a Freeze_Node\n-\t   for a subtype used in this record.  */\n-\tTYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n-\tTYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_entity);\n-\n \t/* If it is a tagged record force the type to BLKmode to insure that\n \t   these objects will always be put in memory.  Likewise for limited\n \t   record types.  */\n \tif (Is_Tagged_Type (gnat_entity) || Is_Limited_Record (gnat_entity))\n \t  SET_TYPE_MODE (gnu_type, BLKmode);\n \n+\t/* We used to remove the associations of the discriminants and _Parent\n+\t   for validity checking but we may need them if there's a Freeze_Node\n+\t   for a subtype used in this record.  */\n+\tTYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n+\n \t/* Fill in locations of fields.  */\n \tannotate_rep (gnat_entity, gnu_type);\n \n@@ -3044,25 +3044,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       else\n \t{\n \t  Entity_Id gnat_base_type = Implementation_Base_Type (gnat_entity);\n-\t  tree gnu_base_type, gnu_orig_type;\n+\t  tree gnu_base_type;\n \n \t  if (!definition)\n \t    {\n \t      defer_incomplete_level++;\n \t      this_deferred = true;\n \t    }\n \n-\t  /* Get the base type initially for its alignment and sizes.\n-\t     But if it is a padded type, we do all the other work with\n-\t     the unpadded type.  */\n \t  gnu_base_type = gnat_to_gnu_type (gnat_base_type);\n \n-\t  if (TREE_CODE (gnu_base_type) == RECORD_TYPE\n-\t      && TYPE_IS_PADDING_P (gnu_base_type))\n-\t    gnu_orig_type = TREE_TYPE (TYPE_FIELDS (gnu_base_type));\n-\t  else\n-\t    gnu_orig_type = gnu_base_type;\n-\n \t  if (present_gnu_tree (gnat_entity))\n \t    {\n \t      maybe_present = true;\n@@ -3084,18 +3075,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      && Present (Discriminant_Constraint (gnat_entity))\n \t      && Stored_Constraint (gnat_entity) != No_Elist)\n \t    {\n-\t      tree gnu_pos_list\n-\t\t= compute_field_positions (gnu_orig_type, NULL_TREE,\n-\t\t\t\t\t   size_zero_node, bitsize_zero_node,\n-\t\t\t\t\t   BIGGEST_ALIGNMENT);\n \t      tree gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n-\t      tree gnu_field_list = NULL_TREE, gnu_temp;\n+\t      tree gnu_pos_list, gnu_field_list = NULL_TREE;\n+\t      tree gnu_unpad_base_type, t;\n \t      Entity_Id gnat_field;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n-\t      TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \n \t      /* Set the size, alignment and alias set of the new type to\n \t\t match that of the old one, doing required substitutions.\n@@ -3108,43 +3095,53 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      relate_alias_sets (gnu_type, gnu_base_type, ALIAS_SET_COPY);\n \n \t      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n-\t\tfor (gnu_temp = gnu_subst_list;\n-\t\t     gnu_temp; gnu_temp = TREE_CHAIN (gnu_temp))\n+\t\tfor (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n \t\t  TYPE_SIZE (gnu_type)\n \t\t    = substitute_in_expr (TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  TREE_PURPOSE (gnu_temp),\n-\t\t\t\t\t  TREE_VALUE (gnu_temp));\n+\t\t\t\t\t  TREE_PURPOSE (t),\n+\t\t\t\t\t  TREE_VALUE (t));\n \n \t      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (gnu_type)))\n-\t\tfor (gnu_temp = gnu_subst_list;\n-\t\t     gnu_temp; gnu_temp = TREE_CHAIN (gnu_temp))\n+\t\tfor (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n \t\t  TYPE_SIZE_UNIT (gnu_type)\n \t\t    = substitute_in_expr (TYPE_SIZE_UNIT (gnu_type),\n-\t\t\t\t\t  TREE_PURPOSE (gnu_temp),\n-\t\t\t\t\t  TREE_VALUE (gnu_temp));\n+\t\t\t\t\t  TREE_PURPOSE (t),\n+\t\t\t\t\t  TREE_VALUE (t));\n \n \t      if (CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (gnu_type)))\n-\t\tfor (gnu_temp = gnu_subst_list;\n-\t\t     gnu_temp; gnu_temp = TREE_CHAIN (gnu_temp))\n+\t\tfor (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n \t\t  SET_TYPE_ADA_SIZE\n \t\t    (gnu_type, substitute_in_expr (TYPE_ADA_SIZE (gnu_type),\n-\t\t\t\t\t\t   TREE_PURPOSE (gnu_temp),\n-\t\t\t\t\t\t   TREE_VALUE (gnu_temp)));\n+\t\t\t\t\t\t   TREE_PURPOSE (t),\n+\t\t\t\t\t\t   TREE_VALUE (t)));\n+\n+\t      if (TREE_CODE (gnu_base_type) == RECORD_TYPE\n+\t\t  && TYPE_IS_PADDING_P (gnu_base_type))\n+\t\tgnu_unpad_base_type = TREE_TYPE (TYPE_FIELDS (gnu_base_type));\n+\t      else\n+\t\tgnu_unpad_base_type = gnu_base_type;\n+\n+\t      gnu_pos_list\n+\t\t= compute_field_positions (gnu_unpad_base_type, NULL_TREE,\n+\t\t\t\t\t   size_zero_node, bitsize_zero_node,\n+\t\t\t\t\t   BIGGEST_ALIGNMENT);\n \n \t      for (gnat_field = First_Entity (gnat_entity);\n-\t\t   Present (gnat_field); gnat_field = Next_Entity (gnat_field))\n+\t\t   Present (gnat_field);\n+\t\t   gnat_field = Next_Entity (gnat_field))\n \t\tif ((Ekind (gnat_field) == E_Component\n \t\t     || Ekind (gnat_field) == E_Discriminant)\n+\t\t    && !(Present (Corresponding_Discriminant (gnat_field))\n+\t\t\t && Is_Tagged_Type (gnat_base_type))\n \t\t    && Underlying_Type (Scope (Original_Record_Component\n \t\t\t\t\t       (gnat_field)))\n-\t\t       == gnat_base_type\n-\t\t    && (No (Corresponding_Discriminant (gnat_field))\n-\t\t\t|| !Is_Tagged_Type (gnat_base_type)))\n+\t\t       == gnat_base_type)\n \t\t  {\n \t\t    Name_Id gnat_name = Chars (gnat_field);\n+\t\t    Entity_Id gnat_old_field\n+\t\t      = Original_Record_Component (gnat_field);\n \t\t    tree gnu_old_field\n-\t\t      = gnat_to_gnu_field_decl\n-\t\t\t(Original_Record_Component (gnat_field));\n+\t\t      = gnat_to_gnu_field_decl (gnat_old_field);\n \t\t    tree gnu_offset\n \t\t      = TREE_VALUE\n \t\t\t(purpose_member (gnu_old_field, gnu_pos_list));\n@@ -3158,21 +3155,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t    /* If the type is the same, retrieve the GCC type from the\n \t\t       old field to take into account possible adjustments.  */\n-\t\t    if (Etype (gnat_field)\n-\t\t\t== Etype (Original_Record_Component (gnat_field)))\n+\t\t    if (Etype (gnat_field) == Etype (gnat_old_field))\n \t\t      gnu_field_type = TREE_TYPE (gnu_old_field);\n \t\t    else\n \t\t      gnu_field_type = gnat_to_gnu_type (Etype (gnat_field));\n \n-\t\t    gnu_size = TYPE_SIZE (gnu_field_type);\n-\n \t\t    /* If there was a component clause, the field types must be\n \t\t       the same for the type and subtype, so copy the data from\n \t\t       the old field to avoid recomputation here.  Also if the\n \t\t       field is justified modular and the optimization in\n \t\t       gnat_to_gnu_field was applied.  */\n-\t\t    if (Present (Component_Clause\n-\t\t\t\t (Original_Record_Component (gnat_field)))\n+\t\t    if (Present (Component_Clause (gnat_old_field))\n \t\t\t|| (TREE_CODE (gnu_field_type) == RECORD_TYPE\n \t\t\t    && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n \t\t\t    && TREE_TYPE (TYPE_FIELDS (gnu_field_type))\n@@ -3199,12 +3192,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    = make_packable_type (gnu_field_type, true);\n \t\t      }\n \n+\t\t    else\n+\t\t      gnu_size = TYPE_SIZE (gnu_field_type);\n+\n \t\t    if (CONTAINS_PLACEHOLDER_P (gnu_pos))\n-\t\t      for (gnu_temp = gnu_subst_list;\n-\t\t\t   gnu_temp; gnu_temp = TREE_CHAIN (gnu_temp))\n+\t\t      for (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n \t\t\tgnu_pos = substitute_in_expr (gnu_pos,\n-\t\t\t\t\t\t      TREE_PURPOSE (gnu_temp),\n-\t\t\t\t\t\t      TREE_VALUE (gnu_temp));\n+\t\t\t\t\t\t      TREE_PURPOSE (t),\n+\t\t\t\t\t\t      TREE_VALUE (t));\n \n \t\t    /* If the position is now a constant, we can set it as the\n \t\t       position of the field when we make it.  Otherwise, we\n@@ -3304,7 +3299,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_SIZE_UNIT (gnu_type)\n \t\t= variable_size (TYPE_SIZE_UNIT (gnu_type));\n \n-\t      compute_record_mode (gnu_type);\n+\t      /* See the E_Record_Type case for the rationale.  */\n+\t      if (Is_Tagged_Type (gnat_entity)\n+\t\t  || Is_Limited_Record (gnat_entity))\n+\t\tSET_TYPE_MODE (gnu_type, BLKmode);\n+\t      else\n+\t\tcompute_record_mode (gnu_type);\n+\n+\t      TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \n \t      /* Fill in locations of fields.  */\n \t      annotate_rep (gnat_entity, gnu_type);\n@@ -3315,16 +3317,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      if (debug_info_p)\n \t\t{\n \t\t  tree gnu_subtype_marker = make_node (RECORD_TYPE);\n-\t\t  tree gnu_orig_name = TYPE_NAME (gnu_orig_type);\n+\t\t  tree gnu_unpad_base_name = TYPE_NAME (gnu_unpad_base_type);\n \n-\t\t  if (TREE_CODE (gnu_orig_name) == TYPE_DECL)\n-\t\t    gnu_orig_name = DECL_NAME (gnu_orig_name);\n+\t\t  if (TREE_CODE (gnu_unpad_base_name) == TYPE_DECL)\n+\t\t    gnu_unpad_base_name = DECL_NAME (gnu_unpad_base_name);\n \n \t\t  TYPE_NAME (gnu_subtype_marker)\n \t\t    = create_concat_name (gnat_entity, \"XVS\");\n \t\t  finish_record_type (gnu_subtype_marker,\n-\t\t\t\t      create_field_decl (gnu_orig_name,\n-\t\t\t\t\t\t\t integer_type_node,\n+\t\t\t\t      create_field_decl (gnu_unpad_base_name,\n+\t\t\t\t\t\t\t build_reference_type\n+\t\t\t\t\t\t\t (gnu_unpad_base_type),\n \t\t\t\t\t\t\t gnu_subtype_marker,\n \t\t\t\t\t\t\t 0, NULL_TREE,\n \t\t\t\t\t\t\t NULL_TREE, 0),\n@@ -3342,7 +3345,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     them equivalent to those in the base type.  */\n \t  else\n \t    {\n-\t      gnu_type = gnu_orig_type;\n+\t      gnu_type = gnu_base_type;\n \n \t      for (gnat_temp = First_Entity (gnat_entity);\n \t\t   Present (gnat_temp);\n@@ -6172,7 +6175,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \n       TYPE_NAME (marker) = concat_name (name, \"XVS\");\n       finish_record_type (marker,\n-\t\t\t  create_field_decl (orig_name, integer_type_node,\n+\t\t\t  create_field_decl (orig_name,\n+\t\t\t\t\t     build_reference_type (type),\n \t\t\t\t\t     marker, 0, NULL_TREE, NULL_TREE,\n \t\t\t\t\t     0),\n \t\t\t  0, false);"}]}