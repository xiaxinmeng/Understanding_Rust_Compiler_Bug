{"sha": "c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxZTA5MmZiM2E4ZmI5MTYwMmI1NGQ4YjVmMTBjYzIzYzI3MDg5Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-07-06T08:10:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-07-06T08:10:29Z"}, "message": "[1/7] Remove unnecessary peeling for gaps check\n\nI recently relaxed the peeling-for-gaps conditions for LD3 but\nkept them as-is for load-and-permute.  I don't think the conditions\nare needed for load-and-permute either though.  No current load-and-\npermute should load outside the group, so if there is no gap at the end,\nthe final vector element loaded will correspond to an element loaded\nby the original scalar loop.\n\nThe patch for PR68559 (a missed optimisation PR) increased the peeled\ncases from \"exact_log2 (groupsize) == -1\" to \"vf % group_size == 0\", so\nbefore that fix, we didn't peel for gaps if there was no gap at the end\nof the group and if the group size was a power of 2.\n\nThe only current non-power-of-2 load-and-permute size is 3, which\ndoesn't require loading more than 3 vectors.\n\nThe testcase is based on gcc.dg/vect/pr49038.c.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* tree-vect-stmts.c (vectorizable_load): Remove unnecessary\n\tpeeling-for-gaps condition.\n\ngcc/testsuite/\n\t* gcc.dg/vect/group-no-gaps-1.c: New test.\n\nFrom-SVN: r238033", "tree": {"sha": "0daff3f21291e1046e74e89d511da9120198237f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0daff3f21291e1046e74e89d511da9120198237f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a07189f4555b29f44945e548461ef26246a917f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07189f4555b29f44945e548461ef26246a917f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a07189f4555b29f44945e548461ef26246a917f2"}], "stats": {"total": 123, "additions": 119, "deletions": 4}, "files": [{"sha": "5c9ecb21f3e01af5626bf872d6517f0c2cd96bbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "patch": "@@ -1,3 +1,8 @@\n+2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-stmts.c (vectorizable_load): Remove unnecessary\n+\tpeeling-for-gaps condition.\n+\n 2016-07-06  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_vec_init): Force initializer"}, {"sha": "9a85ed3f378711f46a237cbab9b31676748a4b61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "patch": "@@ -1,3 +1,7 @@\n+2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/group-no-gaps-1.c: New test.\n+\n 2016-07-05  Andi Kleen  <ak@linux.intel.com>\n \n \t* gcc.target/i386/mpx/mpx-check.h: Check XGETBV output"}, {"sha": "bcea180b2ff522cd40da194c955ff111340176b4", "filename": "gcc/testsuite/gcc.dg/vect/group-no-gaps-1.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fgroup-no-gaps-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fgroup-no-gaps-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fgroup-no-gaps-1.c?ref=c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-require-effective-target mmap } */\n+\n+#include <sys/mman.h>\n+#include <stdio.h>\n+\n+#define COUNT 320\n+#define MMAP_SIZE 0x20000\n+#define ADDRESS1 0x1122000000\n+#define ADDRESS2 (ADDRESS1 + MMAP_SIZE * 16)\n+#define TYPE unsigned int\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+#define RHS0(B) b[B]\n+#define RHS1(B) RHS0(B) + b[(B) + 1]\n+#define RHS2(B) RHS1(B) + b[(B) + 2]\n+#define RHS3(B) RHS2(B) + b[(B) + 3]\n+#define RHS4(B) RHS3(B) + b[(B) + 4]\n+#define RHS5(B) RHS4(B) + b[(B) + 5]\n+#define RHS6(B) RHS5(B) + b[(B) + 6]\n+#define RHS7(B) RHS6(B) + b[(B) + 7]\n+\n+#define LHS0(B) a[B]\n+#define LHS1(B) LHS0(B) = a[(B) + 1]\n+#define LHS2(B) LHS1(B) = a[(B) + 2]\n+#define LHS3(B) LHS2(B) = a[(B) + 3]\n+#define LHS4(B) LHS3(B) = a[(B) + 4]\n+#define LHS5(B) LHS4(B) = a[(B) + 5]\n+#define LHS6(B) LHS5(B) = a[(B) + 6]\n+#define LHS7(B) LHS6(B) = a[(B) + 7]\n+\n+#define DEF_GROUP_SIZE(MULT, GAP, NO_GAP)\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\t\\\n+  gap_load_##MULT (TYPE *__restrict a, TYPE *__restrict b)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT; i++)\t\t\t\t\\\n+      a[i] = RHS##GAP (i * MULT);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\t\\\n+  no_gap_load_##MULT (TYPE *__restrict a, TYPE *__restrict b)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT; i++)\t\t\t\t\\\n+      a[i] = RHS##NO_GAP (i * MULT);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\t\\\n+  gap_store_##MULT (TYPE *__restrict a, TYPE *__restrict b)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT; i++)\t\t\t\t\\\n+      LHS##GAP (i * MULT) = b[i];\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\t\\\n+  no_gap_store_##MULT (TYPE *__restrict a, TYPE *__restrict b)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < COUNT; i++)\t\t\t\t\\\n+      LHS##NO_GAP (i * MULT) = b[i];\t\t\t\t\\\n+  }\n+\n+#define USE_GROUP_SIZE(MULT)\t\t\t\t\t\\\n+  gap_load_##MULT (end_x - COUNT, end_y - COUNT * MULT + 1);\t\\\n+  no_gap_load_##MULT (end_x - COUNT, end_y - COUNT * MULT);\t\\\n+  gap_store_##MULT (end_x - COUNT * MULT + 1, end_y - COUNT);\t\\\n+  no_gap_store_##MULT (end_x - COUNT * MULT, end_y - COUNT)\n+\n+DEF_GROUP_SIZE (2, 0, 1)\n+DEF_GROUP_SIZE (3, 1, 2)\n+DEF_GROUP_SIZE (4, 2, 3)\n+DEF_GROUP_SIZE (5, 3, 4)\n+DEF_GROUP_SIZE (6, 4, 5)\n+DEF_GROUP_SIZE (7, 5, 6)\n+DEF_GROUP_SIZE (8, 6, 7)\n+\n+int\n+main (void)\n+{\n+  void *x, *y;\n+  TYPE *end_x, *end_y;\n+\n+  x = mmap ((void *) ADDRESS1, MMAP_SIZE, PROT_READ | PROT_WRITE,\n+\t    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (x == MAP_FAILED)\n+    {\n+      perror (\"mmap\");\n+      return 1;\n+    }\n+\n+  y = mmap ((void *) ADDRESS2, MMAP_SIZE, PROT_READ | PROT_WRITE,\n+\t    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (y == MAP_FAILED)\n+    {\n+      perror (\"mmap\");\n+      return 1;\n+    }\n+\n+  end_x = (TYPE *) ((char *) x + MMAP_SIZE);\n+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);\n+\n+  USE_GROUP_SIZE (2);\n+  USE_GROUP_SIZE (3);\n+  USE_GROUP_SIZE (4);\n+  USE_GROUP_SIZE (5);\n+  USE_GROUP_SIZE (6);\n+  USE_GROUP_SIZE (7);\n+  USE_GROUP_SIZE (8);\n+\n+  return 0;\n+}"}, {"sha": "d0a3892bc1e5fd468097b8bb59aa2d6058c47960", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01e092fb3a8fb91602b54d8b5f10cc23c27089c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c01e092fb3a8fb91602b54d8b5f10cc23c27089c", "patch": "@@ -6373,13 +6373,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  gcc_assert (GROUP_GAP (stmt_info));\n \t}\n \n-      /* If there is a gap in the end of the group or the group size cannot\n-         be made a multiple of the vector element count then we access excess\n+      /* If there is a gap in the end of the group then we access excess\n \t elements in the last iteration and thus need to peel that off.  */\n       if (loop_vinfo\n \t  && ! STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && (GROUP_GAP (vinfo_for_stmt (first_stmt)) != 0\n-\t      || (!slp && !load_lanes_p && vf % group_size != 0)))\n+\t  && GROUP_GAP (vinfo_for_stmt (first_stmt)) != 0)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}]}