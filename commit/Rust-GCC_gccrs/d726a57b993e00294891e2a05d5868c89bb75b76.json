{"sha": "d726a57b993e00294891e2a05d5868c89bb75b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcyNmE1N2I5OTNlMDAyOTQ4OTFlMmEwNWQ1ODY4Yzg5YmI3NWI3Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-06-15T13:30:18Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-06-15T13:30:18Z"}, "message": "analyzer: add class region_to_value_map\n\nAdd a class for associating symbolic values with regions, for use\ninitially for recording the sizes of dynamically-allocated regions,\nthough this also could potentially be used for e.g. tracking strlen()\nvalues.\n\ngcc/analyzer/ChangeLog:\n\t* region-model.cc (region_to_value_map::operator=): New.\n\t(region_to_value_map::operator==): New.\n\t(region_to_value_map::dump_to_pp): New.\n\t(region_to_value_map::dump): New.\n\t(region_to_value_map::can_merge_with_p): New.\n\t* region-model.h (class region_to_value_map): New class.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "6aae516c3d3becfd020e896ab35e6172cc4a2fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aae516c3d3becfd020e896ab35e6172cc4a2fd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d726a57b993e00294891e2a05d5868c89bb75b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d726a57b993e00294891e2a05d5868c89bb75b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d726a57b993e00294891e2a05d5868c89bb75b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d726a57b993e00294891e2a05d5868c89bb75b76/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "954c9235297f2e63acacefd448bc5dabe039ea7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954c9235297f2e63acacefd448bc5dabe039ea7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954c9235297f2e63acacefd448bc5dabe039ea7c"}], "stats": {"total": 155, "additions": 155, "deletions": 0}, "files": [{"sha": "43f991a2a29c81291ea06790980e9237a8f6351a", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d726a57b993e00294891e2a05d5868c89bb75b76/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d726a57b993e00294891e2a05d5868c89bb75b76/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=d726a57b993e00294891e2a05d5868c89bb75b76", "patch": "@@ -110,6 +110,116 @@ print_quoted_type (pretty_printer *pp, tree t)\n   pp_end_quote (pp, pp_show_color (pp));\n }\n \n+/* class region_to_value_map.  */\n+\n+/* Assignment operator for region_to_value_map.  */\n+\n+region_to_value_map &\n+region_to_value_map::operator= (const region_to_value_map &other)\n+{\n+  m_hash_map.empty ();\n+  for (auto iter : other.m_hash_map)\n+    {\n+      const region *reg = iter.first;\n+      const svalue *sval = iter.second;\n+      m_hash_map.put (reg, sval);\n+    }\n+  return *this;\n+}\n+\n+/* Equality operator for region_to_value_map.  */\n+\n+bool\n+region_to_value_map::operator== (const region_to_value_map &other) const\n+{\n+  if (m_hash_map.elements () != other.m_hash_map.elements ())\n+    return false;\n+\n+  for (auto iter : *this)\n+    {\n+      const region *reg = iter.first;\n+      const svalue *sval = iter.second;\n+      const svalue * const *other_slot = other.get (reg);\n+      if (other_slot == NULL)\n+\treturn false;\n+      if (sval != *other_slot)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Dump this object to PP.  */\n+\n+void\n+region_to_value_map::dump_to_pp (pretty_printer *pp, bool simple,\n+\t\t\t\t bool multiline) const\n+{\n+  auto_vec<const region *> regs;\n+  for (iterator iter = begin (); iter != end (); ++iter)\n+    regs.safe_push ((*iter).first);\n+  regs.qsort (region::cmp_ptr_ptr);\n+  if (multiline)\n+    pp_newline (pp);\n+  else\n+    pp_string (pp, \" {\");\n+  unsigned i;\n+  const region *reg;\n+  FOR_EACH_VEC_ELT (regs, i, reg)\n+    {\n+      if (multiline)\n+\tpp_string (pp, \"  \");\n+      else if (i > 0)\n+\tpp_string (pp, \", \");\n+      reg->dump_to_pp (pp, simple);\n+      pp_string (pp, \": \");\n+      const svalue *sval = *get (reg);\n+      sval->dump_to_pp (pp, true);\n+      if (multiline)\n+\tpp_newline (pp);\n+    }\n+  if (!multiline)\n+    pp_string (pp, \"}\");\n+}\n+\n+/* Dump this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+region_to_value_map::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple, true);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+\n+/* Attempt to merge THIS with OTHER, writing the result\n+   to OUT.\n+\n+   For now, write (region, value) mappings that are in common between THIS\n+   and OTHER to OUT, effectively taking the intersection, rather than\n+   rejecting differences.  */\n+\n+bool\n+region_to_value_map::can_merge_with_p (const region_to_value_map &other,\n+\t\t\t\t       region_to_value_map *out) const\n+{\n+  for (auto iter : *this)\n+    {\n+      const region *iter_reg = iter.first;\n+      const svalue *iter_sval = iter.second;\n+      const svalue * const * other_slot = other.get (iter_reg);\n+      if (other_slot)\n+\tif (iter_sval == *other_slot)\n+\t  out->put (iter_reg, iter_sval);\n+    }\n+  return true;\n+}\n+\n /* class region_model.  */\n \n /* Ctor for region_model: construct an \"empty\" model.  */"}, {"sha": "0afcb8635a9dd531db4dbedb3ee9b14d0ad298f0", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d726a57b993e00294891e2a05d5868c89bb75b76/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d726a57b993e00294891e2a05d5868c89bb75b76/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=d726a57b993e00294891e2a05d5868c89bb75b76", "patch": "@@ -128,6 +128,51 @@ one_way_id_map<T>::update (T *id) const\n   *id = get_dst_for_src (*id);\n }\n \n+/* A mapping from region to svalue for use when tracking state.  */\n+\n+class region_to_value_map\n+{\n+public:\n+  typedef hash_map<const region *, const svalue *> hash_map_t;\n+  typedef hash_map_t::iterator iterator;\n+\n+  region_to_value_map () : m_hash_map () {}\n+  region_to_value_map (const region_to_value_map &other)\n+  : m_hash_map (other.m_hash_map) {}\n+  region_to_value_map &operator= (const region_to_value_map &other);\n+\n+  bool operator== (const region_to_value_map &other) const;\n+  bool operator!= (const region_to_value_map &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  iterator begin () const { return m_hash_map.begin (); }\n+  iterator end () const { return m_hash_map.end (); }\n+\n+  const svalue * const *get (const region *reg) const\n+  {\n+    return const_cast <hash_map_t &> (m_hash_map).get (reg);\n+  }\n+  void put (const region *reg, const svalue *sval)\n+  {\n+    m_hash_map.put (reg, sval);\n+  }\n+  void remove (const region *reg)\n+  {\n+    m_hash_map.remove (reg);\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple, bool multiline) const;\n+  void dump (bool simple) const;\n+\n+  bool can_merge_with_p (const region_to_value_map &other,\n+\t\t\t region_to_value_map *out) const;\n+\n+private:\n+  hash_map_t m_hash_map;\n+};\n+\n /* Various operations delete information from a region_model.\n \n    This struct tracks how many of each kind of entity were purged (e.g."}]}