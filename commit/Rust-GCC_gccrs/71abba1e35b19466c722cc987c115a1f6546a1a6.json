{"sha": "71abba1e35b19466c722cc987c115a1f6546a1a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhYmJhMWUzNWIxOTQ2NmM3MjJjYzk4N2MxMTVhMWY2NTQ2YTFhNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-07-27T04:45:59Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-07-27T04:45:59Z"}, "message": "re PR target/71869 (__builtin_isgreater raises an invalid exception on PPC64 using __float128 inputs.)\n\n[gcc]\n2016-07-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/71869\n\t* config/rs6000/rs6000.c (rs6000_generate_compare): Rework\n\t__float128 support when we don't have hardware support, so that\n\tthe IEEE built-in functions like isgreater, first call __unordkf3\n\tto make sure neither operand is a NaN, and if both operands are\n\tordered, do the normal comparison.\n\n[gcc/testsuite]\n2016-07-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/71869\n\t* gcc.target/powerpc/float128-cmp.c: New test to make sure that\n\tIEEE built-in functions handle quiet and signalling NaNs\n\tcorrectly.\n\nFrom-SVN: r238779", "tree": {"sha": "76123d85bedded1b1d2c3de87dfbed9c00881dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76123d85bedded1b1d2c3de87dfbed9c00881dce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71abba1e35b19466c722cc987c115a1f6546a1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71abba1e35b19466c722cc987c115a1f6546a1a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71abba1e35b19466c722cc987c115a1f6546a1a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71abba1e35b19466c722cc987c115a1f6546a1a6/comments", "author": null, "committer": null, "parents": [{"sha": "2f65c3b3377fc645b071f826f8f02776fb11cae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f65c3b3377fc645b071f826f8f02776fb11cae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f65c3b3377fc645b071f826f8f02776fb11cae8"}], "stats": {"total": 203, "additions": 181, "deletions": 22}, "files": [{"sha": "acab50dbceecd472799849aa1c1011b59be58a3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71abba1e35b19466c722cc987c115a1f6546a1a6", "patch": "@@ -1,3 +1,12 @@\n+2016-07-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/71869\n+\t* config/rs6000/rs6000.c (rs6000_generate_compare): Rework\n+\t__float128 support when we don't have hardware support, so that\n+\tthe IEEE built-in functions like isgreater, first call __unordkf3\n+\tto make sure neither operand is a NaN, and if both operands are\n+\tordered, do the normal comparison.\n+\n 2016-07-26  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \t* tree-vrp.c (dump_asserts_for): Print loc->expr instead of"}, {"sha": "8a3e7994c9596e5fd79eba276105ab7479f05926", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 22, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=71abba1e35b19466c722cc987c115a1f6546a1a6", "patch": "@@ -21756,8 +21756,8 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   else if (!TARGET_FLOAT128_HW && FLOAT128_VECTOR_P (mode))\n     {\n       rtx libfunc = NULL_RTX;\n-      bool uneq_or_ltgt = false;\n-      rtx dest = gen_reg_rtx (SImode);\n+      bool check_nan = false;\n+      rtx dest;\n \n       switch (code)\n \t{\n@@ -21784,43 +21784,80 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \n \tcase UNGE:\n \tcase UNGT:\n-\t  libfunc = optab_libfunc (le_optab, mode);\n+\t  check_nan = true;\n+\t  libfunc = optab_libfunc (ge_optab, mode);\n \t  code = (code == UNGE) ? GE : GT;\n \t  break;\n \n \tcase UNLE:\n \tcase UNLT:\n-\t  libfunc = optab_libfunc (ge_optab, mode);\n+\t  check_nan = true;\n+\t  libfunc = optab_libfunc (le_optab, mode);\n \t  code = (code == UNLE) ? LE : LT;\n \t  break;\n \n \tcase UNEQ:\n \tcase LTGT:\n-\t  libfunc = optab_libfunc (le_optab, mode);\n-\t  uneq_or_ltgt = true;\n-\t  code = (code = UNEQ) ? NE : EQ;\n+\t  check_nan = true;\n+\t  libfunc = optab_libfunc (eq_optab, mode);\n+\t  code = (code = UNEQ) ? EQ : NE;\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n       gcc_assert (libfunc);\n-      dest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t\t      SImode, 2, op0, mode, op1, mode);\n-\n-      /* If this is UNEQ or LTGT, we call __lekf2, which returns -1 for less\n-\t than, 0 for equal, +1 for greater, and +2 for nan.  We add 1, to give\n-\t a value of 0..3, and then do and AND immediate of 1 to isolate whether\n-\t it is 0/Nan (i.e. bottom bit is 0), or less than/greater than\n-\t (i.e. bottom bit is 1).  */\n-      if (uneq_or_ltgt)\n-\t{\n-\t  rtx add_result = gen_reg_rtx (SImode);\n-\t  rtx and_result = gen_reg_rtx (SImode);\n-\t  emit_insn (gen_addsi3 (add_result, dest, GEN_INT (1)));\n-\t  emit_insn (gen_andsi3 (and_result, add_result, GEN_INT (1)));\n-\t  dest = and_result;\n+\n+      if (!check_nan)\n+\tdest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n+\t\t\t\t\tSImode, 2, op0, mode, op1, mode);\n+\n+      /* The library signals an exception for signalling NaNs, so we need to\n+\t handle isgreater, etc. by first checking isordered.  */\n+      else\n+\t{\n+\t  rtx ne_rtx, normal_dest, unord_dest;\n+\t  rtx unord_func = optab_libfunc (unord_optab, mode);\n+\t  rtx join_label = gen_label_rtx ();\n+\t  rtx join_ref = gen_rtx_LABEL_REF (VOIDmode, join_label);\n+\t  rtx unord_cmp = gen_reg_rtx (comp_mode);\n+\n+\n+\t  /* Test for either value being a NaN.  */\n+\t  gcc_assert (unord_func);\n+\t  unord_dest = emit_library_call_value (unord_func, NULL_RTX, LCT_CONST,\n+\t\t\t\t\t\tSImode, 2, op0, mode, op1,\n+\t\t\t\t\t\tmode);\n+\n+\t  /* Set value (0) if either value is a NaN, and jump to the join\n+\t     label.  */\n+\t  dest = gen_reg_rtx (SImode);\n+\t  emit_move_insn (dest, const1_rtx);\n+\t  emit_insn (gen_rtx_SET (unord_cmp,\n+\t\t\t\t  gen_rtx_COMPARE (comp_mode, unord_dest,\n+\t\t\t\t\t\t   const0_rtx)));\n+\n+\t  ne_rtx = gen_rtx_NE (comp_mode, unord_cmp, const0_rtx);\n+\t  emit_jump_insn (gen_rtx_SET (pc_rtx,\n+\t\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n+\t\t\t\t\t\t\t     join_ref,\n+\t\t\t\t\t\t\t     pc_rtx)));\n+\n+\t  /* Do the normal comparison, knowing that the values are not\n+\t     NaNs.  */\n+\t  normal_dest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n+\t\t\t\t\t\t SImode, 2, op0, mode, op1,\n+\t\t\t\t\t\t mode);\n+\n+\t  emit_insn (gen_cstoresi4 (dest,\n+\t\t\t\t    gen_rtx_fmt_ee (code, SImode, normal_dest,\n+\t\t\t\t\t\t    const0_rtx),\n+\t\t\t\t    normal_dest, const0_rtx));\n+\n+\t  /* Join NaN and non-Nan paths.  Compare dest against 0.  */\n+\t  emit_label (join_label);\n+\t  code = NE;\n \t}\n \n       emit_insn (gen_rtx_SET (compare_result,"}, {"sha": "0b8b40572b027c8835538dcb5ff85e430193073c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71abba1e35b19466c722cc987c115a1f6546a1a6", "patch": "@@ -1,3 +1,10 @@\n+2016-07-26  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/71869\n+\t* gcc.target/powerpc/float128-cmp.c: New test to make sure that\n+\tIEEE built-in functions handle quiet and signalling NaNs\n+\tcorrectly.\n+\n 2016-07-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/71862"}, {"sha": "247abc0f7d97fccbcf98b2f1c9b94e17623710ac", "filename": "gcc/testsuite/gcc.target/powerpc/float128-cmp.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71abba1e35b19466c722cc987c115a1f6546a1a6/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmp.c?ref=71abba1e35b19466c722cc987c115a1f6546a1a6", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-mvsx -O2 -mfloat128\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+#ifndef TYPE\n+#define TYPE __float128\n+#define NAN __builtin_nanq (\"\")\n+#define SNAN __builtin_nansq (\"\")\n+#else\n+#define NAN __builtin_nan (\"\")\n+#define SNAN __builtin_nans (\"\")\n+#endif\n+\n+extern void check (TYPE a,\n+\t\t   TYPE b,\n+\t\t   int eq,\n+\t\t   int ne,\n+\t\t   int lt,\n+\t\t   int le,\n+\t\t   int gt,\n+\t\t   int ge,\n+\t\t   int i_lt,\n+\t\t   int i_le,\n+\t\t   int i_gt,\n+\t\t   int i_ge,\n+\t\t   int i_lg,\n+\t\t   int i_un) __attribute__((__noinline__));\n+\n+void\n+check (TYPE a,\n+       TYPE b,\n+       int eq,\n+       int ne,\n+       int lt,\n+       int le,\n+       int gt,\n+       int ge,\n+       int i_lt,\n+       int i_le,\n+       int i_gt,\n+       int i_ge,\n+       int i_lg,\n+       int i_un)\n+{\n+  if (eq != (a == b))\n+    abort ();\n+\n+  if (ne != (a != b))\n+    abort ();\n+\n+  if (lt != (a < b))\n+    abort ();\n+\n+  if (le != (a <= b))\n+    abort ();\n+\n+  if (gt != (a > b))\n+    abort ();\n+\n+  if (ge != (a >= b))\n+    abort ();\n+\n+  if (i_lt != __builtin_isless (a, b))\n+    abort ();\n+\n+  if (i_le != __builtin_islessequal (a, b))\n+    abort ();\n+\n+  if (i_gt != __builtin_isgreater (a, b))\n+    abort ();\n+\n+  if (i_ge != __builtin_isgreaterequal (a, b))\n+    abort ();\n+\n+  if (i_lg != __builtin_islessgreater (a, b))\n+    abort ();\n+\n+  if (i_un != __builtin_isunordered (a, b))\n+    abort ();\n+}\n+\n+int main (void)\n+{\n+  TYPE one   = (TYPE) +1.0;\n+  TYPE two   = (TYPE) +2.0;\n+  TYPE pzero = (TYPE) +0.0;\n+  TYPE mzero = (TYPE) -0.0;\n+  TYPE nan   = (TYPE) NAN;\n+  TYPE snan  = (TYPE) SNAN;\n+\n+  check (one,   two,   0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0);\n+  check (one,   one,   1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0);\n+  check (one,   pzero, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0);\n+  check (mzero, pzero, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0);\n+  check (nan,   one,   0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  check (one,   nan,   0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  check (nan,   nan,   0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  check (snan,  one,   0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  check (one,   snan,  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  check (snan,  nan,   0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  check (nan,   snan,  0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  return 0;\n+}"}]}