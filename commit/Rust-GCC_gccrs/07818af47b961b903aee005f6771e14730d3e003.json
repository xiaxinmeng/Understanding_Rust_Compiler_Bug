{"sha": "07818af47b961b903aee005f6771e14730d3e003", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4MThhZjQ3Yjk2MWI5MDNhZWUwMDVmNjc3MWUxNDczMGQzZTAwMw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-12-24T08:42:04Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-12-24T08:42:04Z"}, "message": "re PR fortran/31821 (character pointer => target(range) should detect if lengths don't match)\n\n2010-12-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/31821\n\t* check.c (gfc_var_strlen):  New function, also including\n\tsubstring references.\n\t(gfc_check_same_strlen):  Use gfc_var_strlen.\n\n2010-12-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/31821\n\t* gfortran.dg/char_pointer_assign_6.f90:  New test.\n\nFrom-SVN: r168224", "tree": {"sha": "ba500f5c6a595579533936d48e7faf3bf7b7a1d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba500f5c6a595579533936d48e7faf3bf7b7a1d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07818af47b961b903aee005f6771e14730d3e003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07818af47b961b903aee005f6771e14730d3e003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07818af47b961b903aee005f6771e14730d3e003", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07818af47b961b903aee005f6771e14730d3e003/comments", "author": null, "committer": null, "parents": [{"sha": "ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab9d6dcfbeced3e2e0052c1cacb541e79e622bdf"}], "stats": {"total": 100, "additions": 76, "deletions": 24}, "files": [{"sha": "980d1b1a127c86f24cdae53581140300e0cc3d6f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=07818af47b961b903aee005f6771e14730d3e003", "patch": "@@ -1,3 +1,10 @@\n+2010-12-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/31821\n+\t* check.c (gfc_var_strlen):  New function, also including\n+\tsubstring references.\n+\t(gfc_check_same_strlen):  Use gfc_var_strlen.\n+\n 2010-12-23  Mikael Morin  <mikael.morin@gcc.gnu.org>\n \n \tPR fortran/46978"}, {"sha": "20163f99a556cc873a237521b036cb601f044d11", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=07818af47b961b903aee005f6771e14730d3e003", "patch": "@@ -635,40 +635,69 @@ identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n   return ret;\n }\n \n+/*  Calculate the length of a character variable, including substrings.\n+    Strip away parentheses if necessary.  Return -1 if no length could\n+    be determined.  */\n+\n+static long\n+gfc_var_strlen (const gfc_expr *a)\n+{\n+  gfc_ref *ra;\n+\n+  while (a->expr_type == EXPR_OP && a->value.op.op == INTRINSIC_PARENTHESES)\n+    a = a->value.op.op1;\n+\n+  for (ra = a->ref; ra != NULL && ra->type != REF_SUBSTRING; ra = ra->next)\n+    ;\n+\n+  if (ra)\n+    {\n+      long start_a, end_a;\n+\n+      if (ra->u.ss.start->expr_type == EXPR_CONSTANT\n+\t  && ra->u.ss.end->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  start_a = mpz_get_si (ra->u.ss.start->value.integer);\n+\t  end_a = mpz_get_si (ra->u.ss.end->value.integer);\n+\t  return end_a - start_a + 1;\n+\t}\n+      else if (gfc_dep_compare_expr (ra->u.ss.start, ra->u.ss.end) == 0)\n+\treturn 1;\n+      else\n+\treturn -1;\n+    }\n+\n+  if (a->ts.u.cl && a->ts.u.cl->length\n+      && a->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+    return mpz_get_si (a->ts.u.cl->length->value.integer);\n+  else if (a->expr_type == EXPR_CONSTANT\n+\t   && (a->ts.u.cl == NULL || a->ts.u.cl->length == NULL))\n+    return a->value.character.length;\n+  else\n+    return -1;\n+\n+}\n \n /* Check whether two character expressions have the same length;\n-   returns SUCCESS if they have or if the length cannot be determined.  */\n+   returns SUCCESS if they have or if the length cannot be determined,\n+   otherwise return FAILURE and raise a gfc_error.  */\n \n gfc_try\n gfc_check_same_strlen (const gfc_expr *a, const gfc_expr *b, const char *name)\n {\n    long len_a, len_b;\n-   len_a = len_b = -1;\n-\n-   if (a->ts.u.cl && a->ts.u.cl->length\n-       && a->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-     len_a = mpz_get_si (a->ts.u.cl->length->value.integer);\n-   else if (a->expr_type == EXPR_CONSTANT\n-\t    && (a->ts.u.cl == NULL || a->ts.u.cl->length == NULL))\n-     len_a = a->value.character.length;\n-   else\n-     return SUCCESS;\n \n-   if (b->ts.u.cl && b->ts.u.cl->length\n-       && b->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-     len_b = mpz_get_si (b->ts.u.cl->length->value.integer);\n-   else if (b->expr_type == EXPR_CONSTANT\n-\t    && (b->ts.u.cl == NULL || b->ts.u.cl->length == NULL))\n-     len_b = b->value.character.length;\n-   else\n-     return SUCCESS;\n+   len_a = gfc_var_strlen(a);\n+   len_b = gfc_var_strlen(b);\n \n-   if (len_a == len_b)\n+   if (len_a == -1 || len_b == -1 || len_a == len_b)\n      return SUCCESS;\n-\n-   gfc_error (\"Unequal character lengths (%ld/%ld) in %s at %L\",\n-\t      len_a, len_b, name, &a->where);\n-   return FAILURE;\n+   else\n+     {\n+       gfc_error (\"Unequal character lengths (%ld/%ld) in %s at %L\",\n+\t\t  len_a, len_b, name, &a->where);\n+       return FAILURE;\n+     }\n }\n \n "}, {"sha": "bd527d7a4a3f50716f49d90cd602d6f1b9ad3a70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07818af47b961b903aee005f6771e14730d3e003", "patch": "@@ -1,3 +1,8 @@\n+2010-12-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/31821\n+\t* gfortran.dg/char_pointer_assign_6.f90:  New test.\n+\n 2010-12-22  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/46758"}, {"sha": "cd90bfc06e343d6b612ac6844730a4cab020fd9f", "filename": "gcc/testsuite/gfortran.dg/char_pointer_assign_6.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_assign_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07818af47b961b903aee005f6771e14730d3e003/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_assign_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_pointer_assign_6.f90?ref=07818af47b961b903aee005f6771e14730d3e003", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! PR 31821\n+program main\n+  character (len=4), pointer:: s1\n+  character (len=20), pointer :: p1\n+  character (len=4) :: c\n+  s1 = 'abcd'\n+  p1 => s1(2:3) ! { dg-error \"Unequal character lengths \\\\(20/2\\\\)\" }\n+  p1 => c(1:) ! { dg-error \"Unequal character lengths \\\\(20/4\\\\)\" }\n+  p1 => c(:4) ! { dg-error \"Unequal character lengths \\\\(20/4\\\\)\" }\n+end"}]}