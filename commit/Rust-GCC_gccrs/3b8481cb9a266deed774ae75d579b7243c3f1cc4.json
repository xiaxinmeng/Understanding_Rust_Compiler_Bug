{"sha": "3b8481cb9a266deed774ae75d579b7243c3f1cc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I4NDgxY2I5YTI2NmRlZWQ3NzRhZTc1ZDU3OWI3MjQzYzNmMWNjNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T10:03:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T10:03:34Z"}, "message": "[multiple changes]\n\n2014-07-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-memdum.adb, g-memdum.ads: Code clean ups.\n\n2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Check_Dependency_Clause):\n\tUpdate the comment on usage. Reimplement the mechanism which\n\tattempts to match a single clause of Depends against one or\n\tmore clauses of Refined_Depends.\n\t(Input_Match): Removed.\n\t(Inputs_Match): Removed.\n\t(Is_Self_Referential): Removed.\n\t(Normalize_Clause): Update the call to Split_Multiple_Outputs.\n\t(Normalize_Outputs): Rename variable Split to New_Claue and update\n\tall its occurrences.\n\t(Report_Extra_Clauses): Update the comment on usage.\n\t(Split_Multiple_Outputs): Renamed to Normalize_Outputs.\n\n2014-07-18  Gary Dismukes  <dismukes@adacore.com>\n\n\t* i-cstrea.ads: Minor reformatting.\n\n2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb (Wrap_Statements_In_Block): Propagate both\n\tsecondary stack-related flags to the generated block.\n\t* sem_ch5.adb (Analyze_Loop_Statement): Update the scope chain\n\tonce the loop is relocated in a block.\n\nFrom-SVN: r212803", "tree": {"sha": "897427a8e9e1147dde238a1afabe6e184bc10186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897427a8e9e1147dde238a1afabe6e184bc10186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b8481cb9a266deed774ae75d579b7243c3f1cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8481cb9a266deed774ae75d579b7243c3f1cc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8481cb9a266deed774ae75d579b7243c3f1cc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8481cb9a266deed774ae75d579b7243c3f1cc4/comments", "author": null, "committer": null, "parents": [{"sha": "daff5ab71e8de29f3b3bd91a9151401f6a8ea197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daff5ab71e8de29f3b3bd91a9151401f6a8ea197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daff5ab71e8de29f3b3bd91a9151401f6a8ea197"}], "stats": {"total": 1038, "additions": 397, "deletions": 641}, "files": [{"sha": "504e7f82b24c7045ffa92943e68e765ed48e0e4d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -1,3 +1,33 @@\n+2014-07-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-memdum.adb, g-memdum.ads: Code clean ups.\n+\n+2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Check_Dependency_Clause):\n+\tUpdate the comment on usage. Reimplement the mechanism which\n+\tattempts to match a single clause of Depends against one or\n+\tmore clauses of Refined_Depends.\n+\t(Input_Match): Removed.\n+\t(Inputs_Match): Removed.\n+\t(Is_Self_Referential): Removed.\n+\t(Normalize_Clause): Update the call to Split_Multiple_Outputs.\n+\t(Normalize_Outputs): Rename variable Split to New_Claue and update\n+\tall its occurrences.\n+\t(Report_Extra_Clauses): Update the comment on usage.\n+\t(Split_Multiple_Outputs): Renamed to Normalize_Outputs.\n+\n+2014-07-18  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* i-cstrea.ads: Minor reformatting.\n+\n+2014-07-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Wrap_Statements_In_Block): Propagate both\n+\tsecondary stack-related flags to the generated block.\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Update the scope chain\n+\tonce the loop is relocated in a block.\n+\n 2014-07-18  Robert Dewar  <dewar@adacore.com>\n \n \t* repinfo.ads: Add documentation on handling of back annotation"}, {"sha": "a94a11b5994cb90a3df41f57bc716bf2fc33935a", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -6667,13 +6667,18 @@ package body Exp_Util is\n \n          --  When wrapping the statements of an iterator loop, check whether\n          --  the loop requires secondary stack management and if so, propagate\n-         --  the flag to the block. This way the secondary stack is marked and\n-         --  released at each iteration of the loop.\n+         --  the appropriate flags to the block. This ensures that the cursor\n+         --  is properly cleaned up at each iteration of the loop. Management\n+         --  is not performed when the loop contains a return statement which\n+         --  also uses the secondary stack as this will destroy the result\n+         --  prematurely.\n \n          Iter_Loop := Find_Enclosing_Iterator_Loop (Scop);\n \n-         if Present (Iter_Loop) and then Uses_Sec_Stack (Iter_Loop) then\n-            Set_Uses_Sec_Stack (Block_Id);\n+         if Present (Iter_Loop) then\n+            Set_Sec_Stack_Needed_For_Return\n+              (Block_Id, Sec_Stack_Needed_For_Return (Iter_Loop));\n+            Set_Uses_Sec_Stack (Block_Id, Uses_Sec_Stack (Iter_Loop));\n          end if;\n \n          return Block_Nod;"}, {"sha": "8aa24a72c79230c7d5f40061f51c4f39c465cdf1", "filename": "gcc/ada/g-memdum.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fg-memdum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fg-memdum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-memdum.adb?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -44,10 +44,18 @@ package body GNAT.Memory_Dump is\n    -- Dump --\n    ----------\n \n+   procedure Dump\n+     (Addr   : Address;\n+      Count  : Natural)\n+   is\n+   begin\n+      Dump (Addr, Count, Prefix => Absolute_Address);\n+   end Dump;\n+\n    procedure Dump\n      (Addr   : Address;\n       Count  : Natural;\n-      Prefix : Prefix_Type := Absolute_Address)\n+      Prefix : Prefix_Type)\n    is\n       Ctr : Natural := Count;\n       --  Count of bytes left to output"}, {"sha": "7f9951b1e06f19e248908cba73f62765a32b0999", "filename": "gcc/ada/g-memdum.ads", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fg-memdum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fg-memdum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-memdum.ads?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -42,20 +42,36 @@ package GNAT.Memory_Dump is\n \n    procedure Dump\n      (Addr   : System.Address;\n-      Count  : Natural;\n-      Prefix : Prefix_Type := Absolute_Address);\n+      Count  : Natural);\n    --  Dumps indicated number (Count) of bytes, starting at the address given\n    --  by Addr. The coding of this routine in its current form assumes the case\n    --  of a byte addressable machine (and is therefore inapplicable to machines\n    --  like the AAMP, where the storage unit is not 8 bits). The output is one\n    --  or more lines in the following format, which is for the case of 32-bit\n    --  addresses (64-bit addresses are handled appropriately):\n-   --\n+\n    --    0234_3368: 66 67 68 . . .  73 74 75 \"fghijklmnopqstuv\"\n-   --\n+\n    --  All but the last line have 16 bytes. A question mark is used in the\n    --  string data to indicate a non-printable character.\n-   --\n-   --  Please document Prefix ???\n+\n+   procedure Dump\n+     (Addr   : System.Address;\n+      Count  : Natural;\n+      Prefix : Prefix_Type);\n+   --  Same as above, but allows the selection of different line formats.\n+   --  If Prefix is set to Absolute_Address, the output is identical to the\n+   --  above version, each line starting with the absolute address of the\n+   --  first dumped storage element.\n+\n+   --  If Prefix is set to Offset, then instead each line starts with the\n+   --  indication of the offset relative to Addr:\n+\n+   --    00: 66 67 68 . . .  73 74 75 \"fghijklmnopqstuv\"\n+\n+   --  Finally if Prefix is set to None, the prefix is suppressed altogether,\n+   --  and only the memory contents are displayed:\n+\n+   --    66 67 68 . . .  73 74 75 \"fghijklmnopqstuv\"\n \n end GNAT.Memory_Dump;"}, {"sha": "dc337878031d402995053ea826859ee29fc9c59a", "filename": "gcc/ada/i-cstrea.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fi-cstrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fi-cstrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea.ads?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -230,9 +230,9 @@ package Interfaces.C_Streams is\n    procedure set_text_mode   (handle : int);\n \n    --  set_wide_text_mode is as set_text_mode but switches the translation to\n-   --  16-bits wide-character instead of 8-bits character. Again this routine\n-   --  has not effect if text_translation_required is false. On Windows this\n-   --  is used to have proper 16-bits wide string output on the console for\n+   --  16-bit wide-character instead of 8-bit character. Again, this routine\n+   --  has no effect if text_translation_required is false. On Windows this\n+   --  is used to have proper 16-bit wide-string output on the console for\n    --  example.\n \n    procedure set_wide_text_mode (handle : int);"}, {"sha": "40034e788bf13489f991cb7e94c3d51de361d098", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -2885,6 +2885,12 @@ package body Sem_Ch5 is\n \n             Add_Block_Identifier (Block_Nod, Block_Id);\n \n+            --  Fix the loop scope once the loop statement is relocated inside\n+            --  the block, otherwise the loop and the block end up sharing the\n+            --  same parent scope.\n+\n+            Set_Scope (Ent, Block_Id);\n+\n             --  The expansion of iterator loops generates an iterator in order\n             --  to traverse the elements of a container:\n "}, {"sha": "73a4f87484933a0d44699d9480c9dbc7e8595c74", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 318, "deletions": 627, "changes": 945, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8481cb9a266deed774ae75d579b7243c3f1cc4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3b8481cb9a266deed774ae75d579b7243c3f1cc4", "patch": "@@ -1340,7 +1340,7 @@ package body Sem_Prag is\n          --  Flag Multiple should be set when Output comes from a list with\n          --  multiple items.\n \n-         procedure Split_Multiple_Outputs;\n+         procedure Normalize_Outputs;\n          --  If Clause contains more than one output, split the clause into\n          --  multiple clauses with a single output. All new clauses are added\n          --  after Clause.\n@@ -1530,20 +1530,18 @@ package body Sem_Prag is\n             end if;\n          end Create_Or_Modify_Clause;\n \n-         ----------------------------\n-         -- Split_Multiple_Outputs --\n-         ----------------------------\n+         -----------------------\n+         -- Normalize_Outputs --\n+         -----------------------\n \n-         procedure Split_Multiple_Outputs is\n+         procedure Normalize_Outputs is\n             Inputs      : constant Node_Id    := Expression (Clause);\n             Loc         : constant Source_Ptr := Sloc (Clause);\n             Outputs     : constant Node_Id    := First (Choices (Clause));\n             Last_Output : Node_Id;\n+            New_Clause  : Node_Id;\n             Next_Output : Node_Id;\n             Output      : Node_Id;\n-            Split       : Node_Id;\n-\n-         --  Start of processing for Split_Multiple_Outputs\n \n          begin\n             --  Multiple outputs appear as an aggregate. Nothing to do when\n@@ -1576,7 +1574,7 @@ package body Sem_Prag is\n                      --  Generate a clause of the form:\n                      --    (Output => Inputs)\n \n-                     Split :=\n+                     New_Clause :=\n                        Make_Component_Association (Loc,\n                          Choices    => New_List (Output),\n                          Expression => New_Copy_Tree (Inputs));\n@@ -1585,14 +1583,14 @@ package body Sem_Prag is\n                      --  already been analyzed. There is not need to reanalyze\n                      --  them.\n \n-                     Set_Analyzed (Split);\n-                     Insert_After (Clause, Split);\n+                     Set_Analyzed (New_Clause);\n+                     Insert_After (Clause, New_Clause);\n                   end if;\n \n                   Output := Next_Output;\n                end loop;\n             end if;\n-         end Split_Multiple_Outputs;\n+         end Normalize_Outputs;\n \n          --  Local variables\n \n@@ -1652,7 +1650,7 @@ package body Sem_Prag is\n          --  Split a clause with multiple outputs into multiple clauses with a\n          --  single output.\n \n-         Split_Multiple_Outputs;\n+         Normalize_Outputs;\n       end Normalize_Clause;\n \n       --  Local variables\n@@ -21831,713 +21829,410 @@ package body Sem_Prag is\n       Depends      : Node_Id;\n       --  The corresponding Depends pragma along with its clauses\n \n+      Refined_States : Elist_Id := No_Elist;\n+      --  A list containing all successfully refined states\n+\n       Refinements : List_Id := No_List;\n       --  The clauses of pragma Refined_Depends\n \n       Spec_Id : Entity_Id;\n       --  The entity of the subprogram subject to pragma Refined_Depends\n \n       procedure Check_Dependency_Clause (Dep_Clause : Node_Id);\n-      --  Verify the legality of a single clause\n-\n-      function Input_Match\n-        (Dep_Input   : Node_Id;\n-         Ref_Inputs  : List_Id;\n-         Post_Errors : Boolean) return Boolean;\n-      --  Determine whether input Dep_Input matches one of inputs found in list\n-      --  Ref_Inputs. If flag Post_Errors is set, the routine reports missed or\n-      --  extra input items.\n-\n-      function Inputs_Match\n-        (Dep_Clause  : Node_Id;\n-         Ref_Clause  : Node_Id;\n-         Post_Errors : Boolean) return Boolean;\n-      --  Determine whether the inputs of Depends clause Dep_Clause match those\n-      --  of refinement clause Ref_Clause. If flag Post_Errors is set, then the\n-      --  routine reports missed or extra input items.\n-\n-      function Is_Self_Referential (Item_Id : Entity_Id) return Boolean;\n-      --  Determine whether a formal parameter, variable or state denoted by\n-      --  Item_Id appears both as input and an output in a single clause of\n-      --  pragma Depends.\n+      --  Try to match a single dependency clause Dep_Clause against one or\n+      --  more refinement clauses found in list Refinements. Each successful\n+      --  match eliminates at least one refinement clause from Refinements.\n+\n+      procedure Normalize_Clauses (Clauses : List_Id);\n+      --  Given a list of dependence or refinement clauses Clauses, normalize\n+      --  each clause by creating multiple dependencies with exactly one input\n+      --  and one output.\n \n       procedure Report_Extra_Clauses;\n-      --  Emit an error for each extra clause the appears in Refined_Depends\n+      --  Emit an error for each extra clause found in list Refinements\n \n       -----------------------------\n       -- Check_Dependency_Clause --\n       -----------------------------\n \n       procedure Check_Dependency_Clause (Dep_Clause : Node_Id) is\n-         Dep_Output      : constant Node_Id := First (Choices (Dep_Clause));\n-         Dep_Id          : Entity_Id;\n-         Matching_Clause : Node_Id := Empty;\n-         Next_Ref_Clause : Node_Id;\n-         Ref_Clause      : Node_Id;\n-         Ref_Id          : Entity_Id;\n-         Ref_Output      : Node_Id;\n-\n-         Has_Constituent : Boolean := False;\n-         --  Flag set when the refinement output list contains at least one\n-         --  constituent of the state denoted by Dep_Id.\n+         Dep_Input  : constant Node_Id := Expression (Dep_Clause);\n+         Dep_Output : constant Node_Id := First (Choices (Dep_Clause));\n+\n+         function Is_In_Out_State_Clause return Boolean;\n+         --  Determine whether dependence clause Dep_Clause denotes an abstract\n+         --  state that depends on itself (State => State).\n+\n+         procedure Match_Items\n+           (Dep_Item : Node_Id;\n+            Ref_Item : Node_Id;\n+            Matched  : out Boolean);\n+         --  Try to match dependence item Dep_Item against refinement item\n+         --  Ref_Item. To match against a possible null refinement (see 2, 7),\n+         --  set Ref_Item to Empty. Flag Matched is set to True when one of\n+         --  the following conformance scenarios is in effect:\n+         --    1) Both items denote null\n+         --    2) Dep_Item denotes null and Ref_Item is Empty (special case)\n+         --    3) Both items denote attribute 'Result\n+         --    4) Both items denote the same formal parameter\n+         --    5) Both items denote the same variable\n+         --    6) Dep_Item is an abstract state with visible null refinement\n+         --       and Ref_Item denotes null.\n+         --    7) Dep_Item is an abstract state with visible null refinement\n+         --       and Ref_Item is Empty (special case).\n+         --    8) Dep_Item is an abstract state with visible non-null\n+         --       refinement and Ref_Item denotes one of its constituents.\n+         --    9) Dep_Item is an abstract state without a visible refinement\n+         --       and Ref_Item denotes the same state.\n+         --  When scenario 8 is in effect, the entity of the abstract state\n+         --  denoted by Dep_Item is added to list Refined_States.\n \n-         Has_Null_State : Boolean := False;\n-         --  Flag set when the output of clause Dep_Clause is a state with a\n-         --  null refinement.\n+         ----------------------------\n+         -- Is_In_Out_State_Clause --\n+         ----------------------------\n \n-         Has_Refined_State : Boolean := False;\n-         --  Flag set when the output of clause Dep_Clause is a state with\n-         --  visible refinement.\n+         function Is_In_Out_State_Clause return Boolean is\n+            Dep_Input_Id  : Entity_Id;\n+            Dep_Output_Id : Entity_Id;\n \n-      begin\n-         --  The analysis of pragma Depends should produce normalized clauses\n-         --  with exactly one output. This is important because output items\n-         --  are unique in the whole dependence relation and can be used as\n-         --  keys.\n+         begin\n+            --  Detect the following clause:\n+            --    State => State\n \n-         pragma Assert (No (Next (Dep_Output)));\n+            if Is_Entity_Name (Dep_Input)\n+              and then Is_Entity_Name (Dep_Output)\n+            then\n+               --  Handle abstract views generated for limited with clauses\n \n-         --  Inspect all clauses of Refined_Depends and attempt to match the\n-         --  output of Dep_Clause against an output from the refinement clauses\n-         --  set.\n+               Dep_Input_Id  := Available_View (Entity_Of (Dep_Input));\n+               Dep_Output_Id := Available_View (Entity_Of (Dep_Output));\n \n-         Ref_Clause := First (Refinements);\n-         while Present (Ref_Clause) loop\n-            Matching_Clause := Empty;\n+               return\n+                 Ekind (Dep_Input_Id) = E_Abstract_State\n+                   and then Dep_Input_Id = Dep_Output_Id;\n+            else\n+               return False;\n+            end if;\n+         end Is_In_Out_State_Clause;\n \n-            --  Store the next clause now because a match will trim the list of\n-            --  refinement clauses and this side effect should not be visible\n-            --  in pragma Refined_Depends.\n+         -----------------\n+         -- Match_Items --\n+         -----------------\n \n-            Next_Ref_Clause := Next (Ref_Clause);\n+         procedure Match_Items\n+           (Dep_Item : Node_Id;\n+            Ref_Item : Node_Id;\n+            Matched  : out Boolean)\n+         is\n+            Dep_Item_Id : Entity_Id;\n+            Ref_Item_Id : Entity_Id;\n \n-            --  The analysis of pragma Refined_Depends should produce\n-            --  normalized clauses with exactly one output.\n+         begin\n+            --  Assume that the two items do not match\n \n-            Ref_Output := First (Choices (Ref_Clause));\n-            pragma Assert (No (Next (Ref_Output)));\n+            Matched := False;\n \n-            --  Two null output lists match if their inputs match\n+            --  A null matches null or Empty (special case)\n \n-            if Nkind (Dep_Output) = N_Null\n-              and then Nkind (Ref_Output) = N_Null\n+            if Nkind (Dep_Item) = N_Null\n+              and then (No (Ref_Item) or else Nkind (Ref_Item) = N_Null)\n             then\n-               Matching_Clause := Ref_Clause;\n-               exit;\n+               Matched := True;\n \n-            --  Two function 'Result attributes match if their inputs match.\n-            --  Note that there is no need to compare the two prefixes because\n-            --  the attributes cannot denote anything but the related function.\n+            --  Attribute 'Result matches attribute 'Result\n \n-            elsif Is_Attribute_Result (Dep_Output)\n-              and then Is_Attribute_Result (Ref_Output)\n+            elsif Is_Attribute_Result (Dep_Item)\n+              and then Is_Attribute_Result (Dep_Item)\n             then\n-               Matching_Clause := Ref_Clause;\n-               exit;\n-\n-            --  The remaining cases are formal parameters, variables and states\n-\n-            elsif Is_Entity_Name (Dep_Output) then\n-\n-               --  Handle abstract views of states and variables generated for\n-               --  limited with clauses.\n-\n-               Dep_Id := Available_View (Entity_Of (Dep_Output));\n+               Matched := True;\n \n-               if Ekind (Dep_Id) = E_Abstract_State then\n+            --  Abstract states, formal parameters and variables\n \n-                  --  A state with a null refinement matches either a null\n-                  --  output list or nothing at all (no clause):\n+            elsif Is_Entity_Name (Dep_Item) then\n \n-                  --    Refined_State   => (State => null)\n+               --  Handle abstract views generated for limited with clauses\n \n-                  --  No clause\n+               Dep_Item_Id := Available_View (Entity_Of (Dep_Item));\n \n-                  --    Depends         => (State => null)\n-                  --    Refined_Depends =>  null               --  OK\n+               if Ekind (Dep_Item_Id) = E_Abstract_State then\n \n-                  --  Null output list\n+                  --  An abstract state with visible null refinement matches\n+                  --  null or Empty (special case).\n \n-                  --    Depends         => (State => <input>)\n-                  --    Refined_Depends => (null  => <input>)  --  OK\n-\n-                  if Has_Null_Refinement (Dep_Id) then\n-                     Has_Null_State := True;\n-\n-                     --  When a state with null refinement matches a null\n-                     --  output, compare their inputs.\n-\n-                     if Nkind (Ref_Output) = N_Null then\n-                        Matching_Clause := Ref_Clause;\n-                     end if;\n-\n-                     exit;\n-\n-                  --  The state has a non-null refinement in which case the\n-                  --  match is based on constituents and inputs. A state with\n-                  --  multiple output constituents may match multiple clauses:\n-\n-                  --    Refined_State   => (State => (C1, C2))\n-                  --    Depends         => (State => <input>)\n-                  --    Refined_Depends => ((C1, C2) => <input>)\n-\n-                  --  When normalized, the above becomes:\n-\n-                  --    Refined_Depends => (C1 => <input>,\n-                  --                        C2 => <input>)\n-\n-                  elsif Has_Non_Null_Refinement (Dep_Id) then\n-                     Has_Refined_State := True;\n-\n-                     --  Account for the case where a state with a non-null\n-                     --  refinement matches a null output list:\n-\n-                     --    Refined_State   => (State_1 => (C1, C2),\n-                     --                        State_2 => (C3, C4))\n-                     --    Depends         => (State_1 => State_2)\n-                     --    Refined_Depends => (null    => C3)\n-\n-                     if Nkind (Ref_Output) = N_Null\n-                       and then Inputs_Match\n-                                  (Dep_Clause  => Dep_Clause,\n-                                   Ref_Clause  => Ref_Clause,\n-                                   Post_Errors => False)\n-                     then\n-                        Has_Constituent := True;\n-\n-                        --  Note that the search continues after the clause is\n-                        --  removed from the pool of candidates because it may\n-                        --  have been normalized into multiple simple clauses.\n-\n-                        Remove (Ref_Clause);\n-\n-                     --  Otherwise the output of the refinement clause must be\n-                     --  a valid constituent of the state:\n+                  if Has_Null_Refinement (Dep_Item_Id)\n+                    and then (No (Ref_Item) or else Nkind (Ref_Item) = N_Null)\n+                  then\n+                     Matched := True;\n \n-                     --    Refined_State   => (State => (C1, C2))\n-                     --    Depends         => (State => <input>)\n-                     --    Refined_Depends => (C1    => <input>)\n+                  --  An abstract state with visible non-null refinement\n+                  --  matches one of its constituents.\n \n-                     elsif Is_Entity_Name (Ref_Output) then\n-                        Ref_Id := Entity_Of (Ref_Output);\n+                  elsif Has_Non_Null_Refinement (Dep_Item_Id) then\n+                     if Is_Entity_Name (Ref_Item) then\n+                        Ref_Item_Id := Entity_Of (Ref_Item);\n \n-                        if Ekind_In (Ref_Id, E_Abstract_State, E_Variable)\n-                          and then Present (Encapsulating_State (Ref_Id))\n-                          and then Encapsulating_State (Ref_Id) = Dep_Id\n-                          and then Inputs_Match\n-                                     (Dep_Clause  => Dep_Clause,\n-                                      Ref_Clause  => Ref_Clause,\n-                                      Post_Errors => False)\n+                        if Ekind_In (Ref_Item_Id, E_Abstract_State, E_Variable)\n+                          and then Present (Encapsulating_State (Ref_Item_Id))\n+                          and then Encapsulating_State (Ref_Item_Id) =\n+                                     Dep_Item_Id\n                         then\n-                           Has_Constituent := True;\n+                           --  Record the successfully refined state\n \n-                           --  Note that the search continues after the clause\n-                           --  is removed from the pool of candidates because\n-                           --  it may have been normalized into multiple simple\n-                           --  clauses.\n+                           if not Contains (Refined_States, Dep_Item_Id) then\n+                              Add_Item (Dep_Item_Id, Refined_States);\n+                           end if;\n \n-                           Remove (Ref_Clause);\n+                           Matched := True;\n                         end if;\n                      end if;\n \n-                  --  The abstract view of a state matches is corresponding\n-                  --  non-abstract view:\n-\n-                  --    Depends         => (Lim_Pack.State => <input>)\n-                  --    Refined_Depends => (State          => <input>)\n+                  --  An abstract state without a visible refinement matches\n+                  --  itself.\n \n-                  elsif Is_Entity_Name (Ref_Output)\n-                    and then Entity_Of (Ref_Output) = Dep_Id\n+                  elsif Is_Entity_Name (Ref_Item)\n+                    and then Entity_Of (Ref_Item) = Dep_Item_Id\n                   then\n-                     Matching_Clause := Ref_Clause;\n-                     exit;\n+                     Matched := True;\n                   end if;\n \n-               --  Formal parameters and variables match if their inputs match\n+               --  A formal parameter or a variable matches itself\n \n-               elsif Is_Entity_Name (Ref_Output)\n-                 and then Entity_Of (Ref_Output) = Dep_Id\n+               elsif Is_Entity_Name (Ref_Item)\n+                 and then Entity_Of (Ref_Item) = Dep_Item_Id\n                then\n-                  Matching_Clause := Ref_Clause;\n-                  exit;\n+                  Matched := True;\n                end if;\n             end if;\n-\n-            Ref_Clause := Next_Ref_Clause;\n-         end loop;\n-\n-         --  Handle the case where pragma Depends contains one or more clauses\n-         --  that only mention states with null refinements. In that case the\n-         --  corresponding pragma Refined_Depends may have a null relation.\n-\n-         --    Refined_State   => (State => null)\n-         --    Depends         => (State => null)\n-         --    Refined_Depends =>  null            --  OK\n-\n-         --  Another instance of the same scenario occurs when the list of\n-         --  refinements has been depleted while processing previous clauses.\n-\n-         if Is_Entity_Name (Dep_Output)\n-           and then (No (Refinements) or else Is_Empty_List (Refinements))\n-         then\n-            Dep_Id := Entity_Of (Dep_Output);\n-\n-            if Ekind (Dep_Id) = E_Abstract_State\n-              and then Has_Null_Refinement (Dep_Id)\n-            then\n-               Has_Null_State := True;\n-            end if;\n-         end if;\n-\n-         --  The above search produced a match based on unique output. Ensure\n-         --  that the inputs match as well and if they do, remove the clause\n-         --  from the pool of candidates.\n-\n-         if Present (Matching_Clause) then\n-            if Inputs_Match\n-                 (Ref_Clause  => Ref_Clause,\n-                  Dep_Clause  => Matching_Clause,\n-                  Post_Errors => True)\n-            then\n-               Remove (Matching_Clause);\n-            end if;\n-\n-         --  A state with a visible refinement was matched against one or\n-         --  more clauses containing appropriate constituents.\n-\n-         elsif Has_Constituent then\n-            null;\n-\n-         --  A state with a null refinement did not warrant a clause\n-\n-         elsif Has_Null_State then\n-            null;\n-\n-         --  The dependence relation of pragma Refined_Depends does not contain\n-         --  a matching clause, emit an error.\n-\n-         else\n-            SPARK_Msg_NE\n-              (\"dependence clause of subprogram & has no matching refinement \"\n-               & \"in body\", Ref_Clause, Spec_Id);\n-\n-            if Has_Refined_State then\n-               SPARK_Msg_N\n-                 (\"\\check the use of constituents in dependence refinement\",\n-                  Ref_Clause);\n-            end if;\n-         end if;\n-      end Check_Dependency_Clause;\n-\n-      -----------------\n-      -- Input_Match --\n-      -----------------\n-\n-      function Input_Match\n-        (Dep_Input   : Node_Id;\n-         Ref_Inputs  : List_Id;\n-         Post_Errors : Boolean) return Boolean\n-      is\n-         procedure Match_Error (Msg : String; N : Node_Id);\n-         --  Emit a matching error if flag Post_Errors is set\n-\n-         -----------------\n-         -- Match_Error --\n-         -----------------\n-\n-         procedure Match_Error (Msg : String; N : Node_Id) is\n-         begin\n-            if Post_Errors then\n-               SPARK_Msg_N (Msg, N);\n-            end if;\n-         end Match_Error;\n+         end Match_Items;\n \n          --  Local variables\n \n-         Dep_Id         : Node_Id;\n-         Next_Ref_Input : Node_Id;\n-         Ref_Id         : Entity_Id;\n-         Ref_Input      : Node_Id;\n-\n-         Has_Constituent : Boolean := False;\n-         --  Flag set when the refinement input list contains at least one\n-         --  constituent of the state denoted by Dep_Id.\n-\n-         Has_Null_State : Boolean := False;\n-         --  Flag set when the dependency input is a state with a visible null\n-         --  refinement.\n-\n-         Has_Refined_State : Boolean := False;\n-         --  Flag set when the dependency input is a state with visible non-\n-         --  null refinement.\n+         Clause_Matched  : Boolean := False;\n+         Dummy           : Boolean := False;\n+         Inputs_Match    : Boolean;\n+         Next_Ref_Clause : Node_Id;\n+         Outputs_Match   : Boolean;\n+         Ref_Clause      : Node_Id;\n+         Ref_Input       : Node_Id;\n+         Ref_Output      : Node_Id;\n \n-      --  Start of processing for Input_Match\n+      --  Start of processing for Check_Dependency_Clause\n \n       begin\n-         --  Match a null input with another null input\n-\n-         if Nkind (Dep_Input) = N_Null then\n-            Ref_Input := First (Ref_Inputs);\n-\n-            --  Remove the matching null from the pool of candidates\n-\n-            if Nkind (Ref_Input) = N_Null then\n-               Remove (Ref_Input);\n-               return True;\n-\n-            else\n-               Match_Error\n-                 (\"null input cannot be matched in corresponding refinement \"\n-                  & \"clause\", Dep_Input);\n-            end if;\n-\n-         --  Remaining cases are formal parameters, variables, and states\n-\n-         else\n-            --  Handle abstract views of states and variables generated for\n-            --  limited with clauses.\n-\n-            Dep_Id := Available_View (Entity_Of (Dep_Input));\n-\n-            --  Inspect all inputs of the refinement clause and attempt to\n-            --  match against the inputs of the dependence clause.\n-\n-            Ref_Input := First (Ref_Inputs);\n-            while Present (Ref_Input) loop\n-\n-               --  Store the next input now because a match will remove it from\n-               --  the list.\n-\n-               Next_Ref_Input := Next (Ref_Input);\n-\n-               if Ekind (Dep_Id) = E_Abstract_State then\n-\n-                  --  A state with a null refinement matches either a null\n-                  --  input list or nothing at all (no input):\n-\n-                  --    Refined_State   => (State => null)\n-\n-                  --  No input\n-\n-                  --    Depends         => (<output> => (State, Input))\n-                  --    Refined_Depends => (<output> => Input)  --  OK\n-\n-                  --  Null input list\n-\n-                  --    Depends         => (<output> => State)\n-                  --    Refined_Depends => (<output> => null)   --  OK\n-\n-                  if Has_Null_Refinement (Dep_Id) then\n-                     Has_Null_State := True;\n-\n-                     --  Remove the matching null from the pool of candidates\n+         --  Examine all refinement clauses and compare them against the\n+         --  dependence clause.\n \n-                     if Nkind (Ref_Input) = N_Null then\n-                        Remove (Ref_Input);\n-                     end if;\n-\n-                     return True;\n-\n-                  --  The state has a non-null refinement in which case remove\n-                  --  all the matching constituents of the state:\n-\n-                  --    Refined_State   => (State    => (C1, C2))\n-                  --    Depends         => (<output> =>  State)\n-                  --    Refined_Depends => (<output> => (C1, C2))\n-\n-                  elsif Has_Non_Null_Refinement (Dep_Id) then\n-                     Has_Refined_State := True;\n-\n-                     --  A state with a visible non-null refinement may have a\n-                     --  null input_list only when it is self referential.\n-\n-                     --    Refined_State   => (State => (C1, C2))\n-                     --    Depends         => (State => State)\n-                     --    Refined_Depends => (C2 => null)  --  OK\n-\n-                     if Nkind (Ref_Input) = N_Null\n-                       and then Is_Self_Referential (Dep_Id)\n-                     then\n-                        --  Remove the null from the pool of candidates. Note\n-                        --  that the search continues because the state may be\n-                        --  represented by multiple constituents.\n+         Ref_Clause := First (Refinements);\n+         while Present (Ref_Clause) loop\n+            Next_Ref_Clause := Next (Ref_Clause);\n \n-                        Has_Constituent := True;\n-                        Remove (Ref_Input);\n+            --  Obtain the attributes of the current refinement clause\n \n-                     --  Ref_Input is an entity name\n+            Ref_Input  := Expression (Ref_Clause);\n+            Ref_Output := First (Choices (Ref_Clause));\n \n-                     elsif Is_Entity_Name (Ref_Input) then\n-                        Ref_Id := Entity_Of (Ref_Input);\n+            --  The current refinement clause matches the dependence clause\n+            --  when both outputs match and both inputs match. See routine\n+            --  Match_Items for all possible conformance scenarios.\n \n-                        --  The input of the refinement clause is a valid\n-                        --  constituent of the state. Remove the input from the\n-                        --  pool of candidates. Note that the search continues\n-                        --  because the state may be represented by multiple\n-                        --  constituents.\n+            --    Depends           Dep_Output => Dep_Input\n+            --                          ^             ^\n+            --                        match ?       match ?\n+            --                          v             v\n+            --    Refined_Depends   Ref_Output => Ref_Input\n \n-                        if Ekind_In (Ref_Id, E_Abstract_State,\n-                                             E_Variable)\n-                          and then Present (Encapsulating_State (Ref_Id))\n-                          and then Encapsulating_State (Ref_Id) = Dep_Id\n-                        then\n-                           Has_Constituent := True;\n-                           Remove (Ref_Input);\n-                        end if;\n-                     end if;\n+            Match_Items\n+              (Dep_Item => Dep_Input,\n+               Ref_Item => Ref_Input,\n+               Matched  => Inputs_Match);\n \n-                  --  The abstract view of a state matches its corresponding\n-                  --  non-abstract view:\n+            Match_Items\n+              (Dep_Item => Dep_Output,\n+               Ref_Item => Ref_Output,\n+               Matched  => Outputs_Match);\n \n-                  --    Depends         => (<output> => Lim_Pack.State)\n-                  --    Refined_Depends => (<output> => State)\n+            --  An In_Out state clause may be matched against a refinement with\n+            --  a null input or null output as long as the non-null side of the\n+            --  relation contains a valid constituent of the In_Out_State.\n \n-                  elsif Is_Entity_Name (Ref_Input)\n-                    and then Entity_Of (Ref_Input) = Dep_Id\n-                  then\n-                     Remove (Ref_Input);\n-                     return True;\n-                  end if;\n+            if Is_In_Out_State_Clause then\n \n-               --  Formal parameters and variables are matched on entities. If\n-               --  this is the case, remove the input from the candidate list.\n+               --  Depends         => (State => State)\n+               --  Refined_Depends => (null => Constit)  --  OK\n \n-               elsif Is_Entity_Name (Ref_Input)\n-                 and then Entity_Of (Ref_Input) = Dep_Id\n+               if Inputs_Match\n+                 and then not Outputs_Match\n+                 and then Nkind (Ref_Output) = N_Null\n                then\n-                  Remove (Ref_Input);\n-                  return True;\n+                  Outputs_Match := True;\n                end if;\n \n-               Ref_Input := Next_Ref_Input;\n-            end loop;\n+               --  Depends         => (State => State)\n+               --  Refined_Depends => (Constit => null)  --  OK\n \n-            --  When a state with a null refinement appears as the last input,\n-            --  it matches nothing:\n-\n-            --    Refined_State   => (State => null)\n-            --    Depends         => (<output> => (Input, State))\n-            --    Refined_Depends => (<output> => Input)  --  OK\n-\n-            if Ekind (Dep_Id) = E_Abstract_State\n-              and then Has_Null_Refinement (Dep_Id)\n-              and then No (Ref_Input)\n-            then\n-               Has_Null_State := True;\n+               if not Inputs_Match\n+                 and then Outputs_Match\n+                 and then Nkind (Ref_Input) = N_Null\n+               then\n+                  Inputs_Match := True;\n+               end if;\n             end if;\n-         end if;\n-\n-         --  A state with visible refinement was matched against one or more of\n-         --  its constituents.\n-\n-         if Has_Constituent then\n-            return True;\n-\n-         --  A state with a null refinement matched null or nothing\n-\n-         elsif Has_Null_State then\n-            return True;\n \n-         --  The input of a dependence clause does not have a matching input in\n-         --  the refinement clause, emit an error.\n+            --  The current refinement clause is legally constructed following\n+            --  the rules in SPARK RM 7.2.5, therefore it can be removed from\n+            --  the pool of candidates. The seach continues because a single\n+            --  dependence clause may have multiple matching refinements.\n \n-         else\n-            Match_Error\n-              (\"input cannot be matched in corresponding refinement clause\",\n-               Dep_Input);\n-\n-            if Has_Refined_State then\n-               Match_Error\n-                 (\"\\check the use of constituents in dependence refinement\",\n-                  Dep_Input);\n+            if Inputs_Match and then Outputs_Match then\n+               Clause_Matched := True;\n+               Remove (Ref_Clause);\n             end if;\n \n-            return False;\n-         end if;\n-      end Input_Match;\n-\n-      ------------------\n-      -- Inputs_Match --\n-      ------------------\n-\n-      function Inputs_Match\n-        (Dep_Clause  : Node_Id;\n-         Ref_Clause  : Node_Id;\n-         Post_Errors : Boolean) return Boolean\n-      is\n-         Ref_Inputs : List_Id;\n-         --  The input list of the refinement clause\n+            Ref_Clause := Next_Ref_Clause;\n+         end loop;\n \n-         procedure Report_Extra_Inputs;\n-         --  Emit errors for all extra inputs that appear in Ref_Inputs\n+         --  Depending on the order or composition of refinement clauses, an\n+         --  In_Out state clause may not be directly refinable.\n \n-         -------------------------\n-         -- Report_Extra_Inputs --\n-         -------------------------\n+         --    Depends         => ((Output, State) => (Input, State))\n+         --    Refined_State   => (State => (Constit_1, Constit_2))\n+         --    Refined_Depends => (Constit_1 => Input, Output => Constit_2)\n \n-         procedure Report_Extra_Inputs is\n-            Input : Node_Id;\n+         --  Matching normalized clause (State => State) fails because there is\n+         --  no direct refinement capable of satisfying this relation. Another\n+         --  similar case arises when clauses (Constit_1 => Input) and (Output\n+         --  => Constit_2) are matched first, leaving no candidates for clause\n+         --  (State => State). Both scenarios are legal as long as one of the\n+         --  previous clauses mentioned a valid constituent of State.\n \n-         begin\n-            if Present (Ref_Inputs) and then Post_Errors then\n-               Input := First (Ref_Inputs);\n-               while Present (Input) loop\n-                  SPARK_Msg_N\n-                    (\"unmatched or extra input in refinement clause\", Input);\n-\n-                  Next (Input);\n-               end loop;\n-            end if;\n-         end Report_Extra_Inputs;\n+         if not Clause_Matched\n+           and then Is_In_Out_State_Clause\n+           and then Contains\n+                      (Refined_States, Available_View (Entity_Of (Dep_Input)))\n+         then\n+            Clause_Matched := True;\n+         end if;\n \n-         --  Local variables\n+         --  At this point either all refinement clauses have been examined or\n+         --  pragma Refined_Depends contains a solitary null. Only an abstract\n+         --  state with null refinement can possibly match these cases.\n \n-         Dep_Inputs : constant Node_Id := Expression (Dep_Clause);\n-         Inputs     : constant Node_Id := Expression (Ref_Clause);\n-         Dep_Input  : Node_Id;\n-         Result     : Boolean;\n+         --    Depends         => (State => null)\n+         --    Refined_State   => (State => null)\n+         --    Refined_Depends =>  null            --  OK\n \n-      --  Start of processing for Inputs_Match\n+         if not Clause_Matched then\n+            Match_Items\n+              (Dep_Item => Dep_Input,\n+               Ref_Item => Empty,\n+               Matched  => Inputs_Match);\n \n-      begin\n-         --  Construct a list of all refinement inputs. Note that the input\n-         --  list is copied because the algorithm modifies its contents and\n-         --  this should not be visible in Refined_Depends. The same applies\n-         --  for a solitary input.\n+            Match_Items\n+              (Dep_Item => Dep_Output,\n+               Ref_Item => Empty,\n+               Matched  => Outputs_Match);\n \n-         if Nkind (Inputs) = N_Aggregate then\n-            Ref_Inputs := New_Copy_List (Expressions (Inputs));\n-         else\n-            Ref_Inputs := New_List (New_Copy (Inputs));\n+            Clause_Matched := Inputs_Match and Outputs_Match;\n          end if;\n \n-         --  Depending on whether the original dependency clause mentions\n-         --  states with visible refinement, the corresponding refinement\n-         --  clause may differ greatly in structure and contents:\n+         --  If the contents of Refined_Depends are legal, then the current\n+         --  dependence clause should be satisfied either by an explicit match\n+         --  or by one of the special cases.\n \n-         --  State with null refinement\n+         if not Clause_Matched then\n+            SPARK_Msg_NE\n+              (\"dependence clause of subprogram & has no matching refinement \"\n+               & \"in body\", Dep_Clause, Spec_Id);\n+         end if;\n+      end Check_Dependency_Clause;\n \n-         --    Refined_State   => (State    => null)\n-         --    Depends         => (<output> => State)\n-         --    Refined_Depends => (<output> => null)\n+      -----------------------\n+      -- Normalize_Clauses --\n+      -----------------------\n \n-         --    Depends         => (<output> => (State, Input))\n-         --    Refined_Depends => (<output> => Input)\n+      procedure Normalize_Clauses (Clauses : List_Id) is\n+         procedure Normalize_Inputs (Clause : Node_Id);\n+         --  Normalize clause Clause by creating multiple clauses for each\n+         --  input item of Clause. It is assumed that Clause has exactly one\n+         --  output. The transformation is as follows:\n+         --\n+         --    Output => (Input_1, Input_2)      --  original\n+         --\n+         --    Output => Input_1                 --  normalizations\n+         --    Output => Input_2\n \n-         --    Depends         => (<output> => (Input_1, State, Input_2))\n-         --    Refined_Depends => (<output> => (Input_1, Input_2))\n+         ----------------------\n+         -- Normalize_Inputs --\n+         ----------------------\n \n-         --  State with non-null refinement\n+         procedure Normalize_Inputs (Clause : Node_Id) is\n+            Inputs     : constant Node_Id    := Expression (Clause);\n+            Loc        : constant Source_Ptr := Sloc (Clause);\n+            Output     : constant List_Id    := Choices (Clause);\n+            Last_Input : Node_Id;\n+            Input      : Node_Id;\n+            New_Clause : Node_Id;\n+            Next_Input : Node_Id;\n \n-         --    Refined_State   => (State_1 => (C1, C2))\n-         --    Depends         => (<output> => State)\n-         --    Refined_Depends => (<output> => C1)\n-         --  or\n-         --    Refined_Depends => (<output> => (C1, C2))\n+         begin\n+            --  Normalization is performed only when the original clause has\n+            --  more than one input. Multiple inputs appear as an aggregate.\n \n-         if Nkind (Dep_Inputs) = N_Aggregate then\n-            Dep_Input := First (Expressions (Dep_Inputs));\n-            while Present (Dep_Input) loop\n-               if not Input_Match\n-                        (Dep_Input   => Dep_Input,\n-                         Ref_Inputs  => Ref_Inputs,\n-                         Post_Errors => Post_Errors)\n-               then\n-                  Result := False;\n-               end if;\n+            if Nkind (Inputs) = N_Aggregate then\n+               Last_Input := Last (Expressions (Inputs));\n \n-               Next (Dep_Input);\n-            end loop;\n+               --  Create a new clause for each input\n \n-            Result := True;\n+               Input := First (Expressions (Inputs));\n+               while Present (Input) loop\n+                  Next_Input := Next (Input);\n \n-         --  Solitary input\n+                  --  Unhook the current input from the original input list\n+                  --  because it will be relocated to a new clause.\n \n-         else\n-            Result :=\n-              Input_Match\n-                (Dep_Input   => Dep_Inputs,\n-                 Ref_Inputs  => Ref_Inputs,\n-                 Post_Errors => Post_Errors);\n-         end if;\n+                  Remove (Input);\n \n-         --  List all inputs that appear as extras\n+                  --  Special processing for the last input. At this point the\n+                  --  original aggregate has been stripped down to one element.\n+                  --  Replace the aggregate by the element itself.\n \n-         Report_Extra_Inputs;\n+                  if Input = Last_Input then\n+                     Rewrite (Inputs, Input);\n \n-         return Result;\n-      end Inputs_Match;\n+                  --  Generate a clause of the form:\n+                  --    Output => Input\n \n-      -------------------------\n-      -- Is_Self_Referential --\n-      -------------------------\n+                  else\n+                     New_Clause :=\n+                       Make_Component_Association (Loc,\n+                         Choices    => New_Copy_List_Tree (Output),\n+                         Expression => Input);\n \n-      function Is_Self_Referential (Item_Id : Entity_Id) return Boolean is\n-         function Denotes_Item (N : Node_Id) return Boolean;\n-         --  Determine whether an arbitrary node N denotes item Item_Id\n+                     --  The new clause contains replicated content that has\n+                     --  already been analyzed, mark the clause as analyzed.\n \n-         ------------------\n-         -- Denotes_Item --\n-         ------------------\n+                     Set_Analyzed (New_Clause);\n+                     Insert_After (Clause, New_Clause);\n+                  end if;\n \n-         function Denotes_Item (N : Node_Id) return Boolean is\n-         begin\n-            return\n-              Is_Entity_Name (N)\n-                and then Present (Entity (N))\n-                and then Entity (N) = Item_Id;\n-         end Denotes_Item;\n+                  Input := Next_Input;\n+               end loop;\n+            end if;\n+         end Normalize_Inputs;\n \n          --  Local variables\n \n-         Clauses : constant Node_Id :=\n-                     Get_Pragma_Arg\n-                       (First (Pragma_Argument_Associations (Depends)));\n-         Clause  : Node_Id;\n-         Input   : Node_Id;\n-         Output  : Node_Id;\n+         Clause : Node_Id;\n \n-      --  Start of processing for Is_Self_Referential\n+      --  Start of processing for Normalize_Clauses\n \n       begin\n-         Clause := First (Component_Associations (Clauses));\n+         Clause := First (Clauses);\n          while Present (Clause) loop\n-\n-            --  Due to normalization, a dependence clause has exactly one\n-            --  output even if the original clause had multiple outputs.\n-\n-            Output := First (Choices (Clause));\n-\n-            --  Detect the following scenario:\n-            --\n-            --    Item_Id => [(...,] Item_Id [, ...)]\n-\n-            if Denotes_Item (Output) then\n-               Input := Expression (Clause);\n-\n-               --  Multiple inputs appear as an aggregate\n-\n-               if Nkind (Input) = N_Aggregate then\n-                  Input := First (Expressions (Input));\n-\n-                  if Denotes_Item (Input) then\n-                     return True;\n-                  end if;\n-\n-                  Next (Input);\n-\n-               --  Solitary input\n-\n-               elsif Denotes_Item (Input) then\n-                  return True;\n-               end if;\n-            end if;\n-\n+            Normalize_Inputs (Clause);\n             Next (Clause);\n          end loop;\n-\n-         return False;\n-      end Is_Self_Referential;\n+      end Normalize_Clauses;\n \n       --------------------------\n       -- Report_Extra_Clauses --\n@@ -22607,24 +22302,29 @@ package body Sem_Prag is\n       if Nkind (Deps) = N_Null then\n          SPARK_Msg_NE\n            (\"useless refinement, subprogram & does not depend on abstract \"\n-            & \"state with visible refinement\",\n-            N, Spec_Id);\n+            & \"state with visible refinement\", N, Spec_Id);\n          return;\n       end if;\n \n-      --  Multiple dependency clauses appear as component associations of an\n-      --  aggregate.\n-\n-      pragma Assert (Nkind (Deps) = N_Aggregate);\n-      Dependencies := Component_Associations (Deps);\n-\n       --  Analyze Refined_Depends as if it behaved as a regular pragma Depends.\n       --  This ensures that the categorization of all refined dependency items\n       --  is consistent with their role.\n \n       Analyze_Depends_In_Decl_Part (N);\n \n+      --  Do not match dependencies against refinements if Refined_Depends is\n+      --  illegal to avoid emitting misleading error.\n+\n       if Serious_Errors_Detected = Errors then\n+\n+         --  Multiple dependency clauses appear as component associations of an\n+         --  aggregate. Note that the clauses are copied because the algorithm\n+         --  modifies them and this should not be visible in Depends.\n+\n+         pragma Assert (Nkind (Deps) = N_Aggregate);\n+         Dependencies := New_Copy_List_Tree (Component_Associations (Deps));\n+         Normalize_Clauses (Dependencies);\n+\n          if Nkind (Refs) = N_Null then\n             Refinements := No_List;\n \n@@ -22633,33 +22333,24 @@ package body Sem_Prag is\n          --  modifies them and this should not be visible in Refined_Depends.\n \n          else pragma Assert (Nkind (Refs) = N_Aggregate);\n-            Refinements := New_Copy_List (Component_Associations (Refs));\n+            Refinements := New_Copy_List_Tree (Component_Associations (Refs));\n+            Normalize_Clauses (Refinements);\n          end if;\n \n-         --  Inspect all the clauses of pragma Depends looking for a matching\n-         --  clause in pragma Refined_Depends. The approach is to use the\n-         --  sole output of a clause as a key. Output items are unique in a\n-         --  dependence relation. Clause normalization also ensured that all\n-         --  clauses have exactly one output. Depending on what the key is, one\n-         --  or more refinement clauses may satisfy the dependency clause. Each\n-         --  time a dependency clause is matched, its related refinement clause\n-         --  is consumed. In the end, two things may happen:\n-\n-         --    1) A clause of pragma Depends was not matched in which case\n-         --       Check_Dependency_Clause reports the error.\n-\n-         --    2) Refined_Depends has an extra clause in which case the error\n-         --       is reported by Report_Extra_Clauses.\n+         --  At this point the clauses of pragmas Depends and Refined_Depends\n+         --  have been normalized into simple dependencies between one output\n+         --  and one input. Examine all clauses of pragma Depends looking for\n+         --  matching clauses in pragma Refined_Depends.\n \n          Clause := First (Dependencies);\n          while Present (Clause) loop\n             Check_Dependency_Clause (Clause);\n             Next (Clause);\n          end loop;\n-      end if;\n \n-      if Serious_Errors_Detected = Errors then\n-         Report_Extra_Clauses;\n+         if Serious_Errors_Detected = Errors then\n+            Report_Extra_Clauses;\n+         end if;\n       end if;\n    end Analyze_Refined_Depends_In_Decl_Part;\n "}]}