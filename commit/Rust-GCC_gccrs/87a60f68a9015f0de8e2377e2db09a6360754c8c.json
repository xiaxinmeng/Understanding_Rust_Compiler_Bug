{"sha": "87a60f68a9015f0de8e2377e2db09a6360754c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdhNjBmNjhhOTAxNWYwZGU4ZTIzNzdlMmRiMDlhNjM2MDc1NGM4Yw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-03-06T19:51:42Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-03-06T19:51:42Z"}, "message": "f95-lang.c (yyerror, yylex): Remove.\n\n\t* f95-lang.c (yyerror, yylex): Remove.\n\t(clear_binding_stack): Remove, fold into its only user.\n\t(LANG_HOOKS_PRINT_IDENTIFIER): Do not re-define.\n\t(ridpointers): Remove.\n\t(gfc_eh_initialized_p): Make static.\n\t(gfc_truthvalue_conversion): Move to convert.c.\n\t(gfc_be_parse_file): Clear binding level stack when done.\n\t(gfc_print_identifier): Remove.\n\t(pushlevel): Remove ignored 'ignore' argument.  Update all callers.\n\t(poplevel): Remove unused 'reverse' argument.  Update all callers.\n\t(ggc_p): Remove.\n\t(gfc_builtin_function): Make static. Do not attempt to make RTL for\n\tbuiltin functions.\n\t* convert.c (gfc_truthvalue_conversion): Moved here from f95-lang.c,\n\tand made static.\n\t* trans.h (pushlevel, poplevel): Adjust prototypes.\n\t(gfc_truthvalue_conversion, gfc_builtin_function): Remove prototypes.\n\t* trans-openmp.c: Update calls to pushlevel and poplevel.\n\t* trans.c: Likewise.\n\t* trans-decl.c: Likewise.\n\nFrom-SVN: r185015", "tree": {"sha": "0595932f0c30a57f889841652942dd6cccd5019a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0595932f0c30a57f889841652942dd6cccd5019a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87a60f68a9015f0de8e2377e2db09a6360754c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a60f68a9015f0de8e2377e2db09a6360754c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87a60f68a9015f0de8e2377e2db09a6360754c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a60f68a9015f0de8e2377e2db09a6360754c8c/comments", "author": null, "committer": null, "parents": [{"sha": "ca4adc913ddcaca116b48569ec97c7c7841f2a35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4adc913ddcaca116b48569ec97c7c7841f2a35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4adc913ddcaca116b48569ec97c7c7841f2a35"}], "stats": {"total": 281, "additions": 122, "deletions": 159}, "files": [{"sha": "3d10d9fbc9b268d23ea7bc9ed823993dfeaad016", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -1,3 +1,26 @@\n+2012-03-06  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* f95-lang.c (yyerror, yylex): Remove.\n+\t(clear_binding_stack): Remove, fold into its only user.\n+\t(LANG_HOOKS_PRINT_IDENTIFIER): Do not re-define.\n+\t(ridpointers): Remove.\n+\t(gfc_eh_initialized_p): Make static.\n+\t(gfc_truthvalue_conversion): Move to convert.c.\n+\t(gfc_be_parse_file): Clear binding level stack when done.\n+\t(gfc_print_identifier): Remove.\n+\t(pushlevel): Remove ignored 'ignore' argument.  Update all callers.\n+\t(poplevel): Remove unused 'reverse' argument.  Update all callers.\n+\t(ggc_p): Remove.\n+\t(gfc_builtin_function): Make static. Do not attempt to make RTL for\n+\tbuiltin functions.\n+\t* convert.c (gfc_truthvalue_conversion): Moved here from f95-lang.c,\n+\tand made static.\n+\t* trans.h (pushlevel, poplevel): Adjust prototypes.\n+\t(gfc_truthvalue_conversion, gfc_builtin_function): Remove prototypes.\n+\t* trans-openmp.c: Update calls to pushlevel and poplevel.\n+\t* trans.c: Likewise.\n+\t* trans-decl.c: Likewise.\n+\n 2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/50981"}, {"sha": "be681a51c565fece82606d79cf4abb95bc59daff", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -60,6 +60,50 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Subroutines of `convert'.  */\n \n+/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n+   or validate its data type for an `if' or `while' statement or ?..: exp.\n+\n+   This preparation consists of taking the ordinary\n+   representation of an expression expr and producing a valid tree\n+   boolean expression describing whether expr is nonzero.  We could\n+   simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),\n+   but we optimize comparisons, &&, ||, and !.\n+\n+   The resulting type should always be `boolean_type_node'.\n+   This is much simpler than the corresponding C version because we have a\n+   distinct boolean type.  */\n+\n+static tree\n+gfc_truthvalue_conversion (tree expr)\n+{\n+  switch (TREE_CODE (TREE_TYPE (expr)))\n+    {\n+    case BOOLEAN_TYPE:\n+      if (TREE_TYPE (expr) == boolean_type_node)\n+\treturn expr;\n+      else if (COMPARISON_CLASS_P (expr))\n+\t{\n+\t  TREE_TYPE (expr) = boolean_type_node;\n+\t  return expr;\n+\t}\n+      else if (TREE_CODE (expr) == NOP_EXPR)\n+        return fold_build1_loc (input_location, NOP_EXPR,\n+\t\t\t    boolean_type_node, TREE_OPERAND (expr, 0));\n+      else\n+        return fold_build1_loc (input_location, NOP_EXPR, boolean_type_node,\n+\t\t\t\texpr);\n+\n+    case INTEGER_TYPE:\n+      if (TREE_CODE (expr) == INTEGER_CST)\n+\treturn integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n+      else\n+        return fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\texpr, build_int_cst (TREE_TYPE (expr), 0));\n+\n+    default:\n+      internal_error (\"Unexpected type in truthvalue_conversion\");\n+    }\n+}\n \n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value"}, {"sha": "08d22172e1842d5fd8bf7dcea83e0eeb5843e93e", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 16, "deletions": 116, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -60,7 +60,6 @@ lang_identifier {\n \n union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n      chain_next (\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n-\n lang_tree_node {\n   union tree_node GTY((tag (\"0\"),\n \t\t       desc (\"tree_node_structure (&%h)\"))) generic;\n@@ -77,25 +76,18 @@ language_function {\n   struct binding_level *binding_level;\n };\n \n-/* We don't have a lex/yacc lexer/parser, but toplev expects these to\n-   exist anyway.  */\n-void yyerror (const char *str);\n-int yylex (void);\n-\n static void gfc_init_decl_processing (void);\n static void gfc_init_builtin_functions (void);\n+static bool global_bindings_p (void);\n \n /* Each front end provides its own.  */\n static bool gfc_init (void);\n static void gfc_finish (void);\n static void gfc_write_global_declarations (void);\n-static void gfc_print_identifier (FILE *, tree, int);\n-void do_function_end (void);\n-bool global_bindings_p (void);\n-static void clear_binding_stack (void);\n static void gfc_be_parse_file (void);\n static alias_set_type gfc_get_alias_set (tree);\n static void gfc_init_ts (void);\n+static tree gfc_builtin_function (tree);\n \n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n@@ -106,7 +98,6 @@ static void gfc_init_ts (void);\n #undef LANG_HOOKS_INIT_OPTIONS\n #undef LANG_HOOKS_HANDLE_OPTION\n #undef LANG_HOOKS_POST_OPTIONS\n-#undef LANG_HOOKS_PRINT_IDENTIFIER\n #undef LANG_HOOKS_PARSE_FILE\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #undef LANG_HOOKS_TYPE_FOR_MODE\n@@ -125,6 +116,7 @@ static void gfc_init_ts (void);\n #undef LANG_HOOKS_OMP_PRIVATE_OUTER_REF\n #undef LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES\n #undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n #undef LANG_HOOKS_GET_ARRAY_DESCR_INFO\n \n /* Define lang hooks.  */\n@@ -137,7 +129,6 @@ static void gfc_init_ts (void);\n #define LANG_HOOKS_INIT_OPTIONS         gfc_init_options\n #define LANG_HOOKS_HANDLE_OPTION        gfc_handle_option\n #define LANG_HOOKS_POST_OPTIONS\t\tgfc_post_options\n-#define LANG_HOOKS_PRINT_IDENTIFIER     gfc_print_identifier\n #define LANG_HOOKS_PARSE_FILE           gfc_be_parse_file\n #define LANG_HOOKS_TYPE_FOR_MODE\tgfc_type_for_mode\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgfc_type_for_size\n@@ -166,64 +157,13 @@ struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n static GTY(()) struct binding_level *free_binding_level;\n \n-/* The elements of `ridpointers' are identifier nodes\n-   for the reserved type names and storage classes.\n-   It is indexed by a RID_... value.  */\n-tree *ridpointers = NULL;\n-\n /* True means we've initialized exception handling.  */\n-bool gfc_eh_initialized_p;\n+static bool gfc_eh_initialized_p;\n \n /* The current translation unit.  */\n static GTY(()) tree current_translation_unit;\n \n \n-/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n-   or validate its data type for an `if' or `while' statement or ?..: exp.\n-\n-   This preparation consists of taking the ordinary\n-   representation of an expression expr and producing a valid tree\n-   boolean expression describing whether expr is nonzero.  We could\n-   simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),\n-   but we optimize comparisons, &&, ||, and !.\n-\n-   The resulting type should always be `boolean_type_node'.\n-   This is much simpler than the corresponding C version because we have a\n-   distinct boolean type.  */\n-\n-tree\n-gfc_truthvalue_conversion (tree expr)\n-{\n-  switch (TREE_CODE (TREE_TYPE (expr)))\n-    {\n-    case BOOLEAN_TYPE:\n-      if (TREE_TYPE (expr) == boolean_type_node)\n-\treturn expr;\n-      else if (COMPARISON_CLASS_P (expr))\n-\t{\n-\t  TREE_TYPE (expr) = boolean_type_node;\n-\t  return expr;\n-\t}\n-      else if (TREE_CODE (expr) == NOP_EXPR)\n-        return fold_build1_loc (input_location, NOP_EXPR,\n-\t\t\t    boolean_type_node, TREE_OPERAND (expr, 0));\n-      else\n-        return fold_build1_loc (input_location, NOP_EXPR, boolean_type_node,\n-\t\t\t\texpr);\n-\n-    case INTEGER_TYPE:\n-      if (TREE_CODE (expr) == INTEGER_CST)\n-\treturn integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n-      else\n-        return fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t\texpr, build_int_cst (TREE_TYPE (expr), 0));\n-\n-    default:\n-      internal_error (\"Unexpected type in truthvalue_conversion\");\n-    }\n-}\n-\n-\n static void\n gfc_create_decls (void)\n {\n@@ -255,7 +195,9 @@ gfc_be_parse_file (void)\n   errorcount += errors;\n   warningcount += warnings;\n \n-  clear_binding_stack ();\n+  /* Clear the binding level stack.  */\n+  while (!global_bindings_p ())\n+    poplevel (0, 0);\n }\n \n \n@@ -322,16 +264,6 @@ gfc_write_global_declarations (void)\n   write_global_declarations ();\n }\n \n-\n-static void\n-gfc_print_identifier (FILE * file ATTRIBUTE_UNUSED,\n-\t\t      tree node ATTRIBUTE_UNUSED,\n-\t\t      int indent ATTRIBUTE_UNUSED)\n-{\n-  return;\n-}\n-\n-\n /* These functions and variables deal with binding contours.  We only\n    need these functions for the list of PARM_DECLs, but we leave the\n    functions more general; these are a simplified version of the\n@@ -351,9 +283,7 @@ struct GTY(())\n binding_level {\n   /* A chain of ..._DECL nodes for all variables, constants, functions,\n      parameters and type declarations.  These ..._DECL nodes are chained\n-     through the DECL_CHAIN field. Note that these ..._DECL nodes are stored\n-     in the reverse of the order supplied to be compatible with the\n-     back-end.  */\n+     through the DECL_CHAIN field.  */\n   tree names;\n   /* For each level (except the global one), a chain of BLOCK nodes for all\n      the levels that were entered and exited one level down from this one.  */\n@@ -387,11 +317,10 @@ getdecls (void)\n   return current_binding_level->names;\n }\n \n-/* Enter a new binding level. The input parameter is ignored, but has to be\n-   specified for back-end compatibility.  */\n+/* Enter a new binding level. */\n \n void\n-pushlevel (int ignore ATTRIBUTE_UNUSED)\n+pushlevel (void)\n {\n   struct binding_level *newlevel = ggc_alloc_binding_level ();\n \n@@ -413,29 +342,19 @@ pushlevel (int ignore ATTRIBUTE_UNUSED)\n \n    If FUNCTIONBODY is nonzero, this level is the body of a function,\n    so create a block as if KEEP were set and also clear out all\n-   label names.\n-\n-   If REVERSE is nonzero, reverse the order of decls before putting\n-   them into the BLOCK.  */\n+   label names.  */\n \n tree\n-poplevel (int keep, int reverse, int functionbody)\n+poplevel (int keep, int functionbody)\n {\n   /* Points to a BLOCK tree node. This is the BLOCK node constructed for the\n      binding level that we are about to exit and which is returned by this\n      routine.  */\n   tree block_node = NULL_TREE;\n-  tree decl_chain;\n+  tree decl_chain = current_binding_level->names;\n   tree subblock_chain = current_binding_level->blocks;\n   tree subblock_node;\n \n-  /* Reverse the list of XXXX_DECL nodes if desired.  Note that the ..._DECL\n-     nodes chained through the `names' field of current_binding_level are in\n-     reverse order except for PARM_DECL node, which are explicitly stored in\n-     the right order.  */\n-  decl_chain = (reverse) ? nreverse (current_binding_level->names)\n-\t\t\t : current_binding_level->names;\n-\n   /* If there were any declarations in the current binding level, or if this\n      binding level is a function body, or if there are any nested blocks then\n      create a BLOCK node to record them for the life of this function.  */\n@@ -513,10 +432,7 @@ pushdecl (tree decl)\n       DECL_CONTEXT (decl) = current_function_decl;\n     }\n \n-  /* Put the declaration on the list.  The list of declarations is in reverse\n-     order. The list will be reversed later if necessary.  This needs to be\n-     this way for compatibility with the back-end.  */\n-\n+  /* Put the declaration on the list.  */\n   DECL_CHAIN (decl) = current_binding_level->names;\n   current_binding_level->names = decl;\n \n@@ -548,16 +464,6 @@ pushdecl_top_level (tree x)\n   return t;\n }\n \n-\n-/* Clear the binding stack.  */\n-static void\n-clear_binding_stack (void)\n-{\n-  while (!global_bindings_p ())\n-    poplevel (0, 0, 0);\n-}\n-\n-\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n@@ -582,7 +488,7 @@ gfc_init_decl_processing (void)\n \n   /* Make the binding_level structure for global names. We move all\n      variables that are in a COMMON block to this binding level.  */\n-  pushlevel (0);\n+  pushlevel ();\n   global_binding_level = current_binding_level;\n \n   /* Build common tree nodes. char_type_node is unsigned because we\n@@ -617,17 +523,11 @@ gfc_get_alias_set (tree t)\n   return -1;\n }\n \n-\n-/* press the big red button - garbage (ggc) collection is on */\n-\n-int ggc_p = 1;\n-\n /* Builtin function initialization.  */\n \n-tree\n+static tree\n gfc_builtin_function (tree decl)\n {\n-  make_decl_rtl (decl);\n   pushdecl (decl);\n   return decl;\n }"}, {"sha": "8a1dd2ecd974e248afe1e303b6118f0dab322abc", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -2256,7 +2256,7 @@ trans_function_start (gfc_symbol * sym)\n   init_function_start (fndecl);\n \n   /* function.c requires a push at the start of the function.  */\n-  pushlevel (0);\n+  pushlevel ();\n }\n \n /* Create thunks for alternate entry points.  */\n@@ -2398,7 +2398,7 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n       /* Finish off this function and send it for code generation.  */\n       DECL_SAVED_TREE (thunk_fndecl) = gfc_finish_block (&body);\n       tmp = getdecls ();\n-      poplevel (1, 0, 1);\n+      poplevel (1, 1);\n       BLOCK_SUPERCONTEXT (DECL_INITIAL (thunk_fndecl)) = thunk_fndecl;\n       DECL_SAVED_TREE (thunk_fndecl)\n \t= build3_v (BIND_EXPR, tmp, DECL_SAVED_TREE (thunk_fndecl),\n@@ -4400,15 +4400,15 @@ generate_coarray_init (gfc_namespace * ns __attribute((unused)))\n   make_decl_rtl (fndecl);\n   init_function_start (fndecl);\n \n-  pushlevel (0);\n+  pushlevel ();\n   gfc_init_block (&caf_init_block);\n \n   gfc_traverse_ns (ns, generate_coarray_sym_init);\n \n   DECL_SAVED_TREE (fndecl) = gfc_finish_block (&caf_init_block);\n   decl = getdecls ();\n \n-  poplevel (1, 0, 1);\n+  poplevel (1, 1);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   DECL_SAVED_TREE (fndecl)\n@@ -4971,7 +4971,7 @@ create_main_function (tree fndecl)\n   rest_of_decl_compilation (ftn_main, 1, 0);\n   make_decl_rtl (ftn_main);\n   init_function_start (ftn_main);\n-  pushlevel (0);\n+  pushlevel ();\n \n   gfc_init_block (&body);\n \n@@ -5139,7 +5139,7 @@ create_main_function (tree fndecl)\n   decl = getdecls ();\n \n   /* Finish off this function and send it for code generation.  */\n-  poplevel (1, 0, 1);\n+  poplevel (1, 1);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (ftn_main)) = ftn_main;\n \n   DECL_SAVED_TREE (ftn_main)\n@@ -5428,7 +5428,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   decl = getdecls ();\n \n   /* Finish off this function and send it for code generation.  */\n-  poplevel (1, 0, 1);\n+  poplevel (1, 1);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   DECL_SAVED_TREE (fndecl)\n@@ -5522,7 +5522,7 @@ gfc_generate_constructors (void)\n \n   init_function_start (fndecl);\n \n-  pushlevel (0);\n+  pushlevel ();\n \n   for (; gfc_static_ctors; gfc_static_ctors = TREE_CHAIN (gfc_static_ctors))\n     {\n@@ -5532,7 +5532,7 @@ gfc_generate_constructors (void)\n     }\n \n   decl = getdecls ();\n-  poplevel (1, 0, 1);\n+  poplevel (1, 1);\n \n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n   DECL_SAVED_TREE (fndecl)"}, {"sha": "8d7aa5fe3c3fc2344e1471502d02c8163970bca2", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -651,7 +651,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   gcc_assert (t == SUCCESS);\n \n   /* Create the init statement list.  */\n-  pushlevel (0);\n+  pushlevel ();\n   if (GFC_DESCRIPTOR_TYPE_P (type)\n       && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n     {\n@@ -691,13 +691,13 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   else\n     stmt = gfc_trans_assignment (e1, e2, false, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n   OMP_CLAUSE_REDUCTION_INIT (c) = stmt;\n \n   /* Create the merge statement list.  */\n-  pushlevel (0);\n+  pushlevel ();\n   if (GFC_DESCRIPTOR_TYPE_P (type)\n       && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n     {\n@@ -714,9 +714,9 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   else\n     stmt = gfc_trans_assignment (e3, e4, false, true);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n   OMP_CLAUSE_REDUCTION_MERGE (c) = stmt;\n \n   /* And stick the placeholder VAR_DECL into the clause as well.  */\n@@ -1001,20 +1001,20 @@ gfc_trans_omp_code (gfc_code *code, bool force_empty)\n {\n   tree stmt;\n \n-  pushlevel (0);\n+  pushlevel ();\n   stmt = gfc_trans_code (code);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     {\n       if (!IS_EMPTY_STMT (stmt) || force_empty)\n \t{\n-\t  tree block = poplevel (1, 0, 0);\n+\t  tree block = poplevel (1, 0);\n \t  stmt = build3_v (BIND_EXPR, NULL, stmt, block);\n \t}\n       else\n-\tpoplevel (0, 0, 0);\n+\tpoplevel (0, 0);\n     }\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n   return stmt;\n }\n \n@@ -1501,7 +1501,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n   if (pblock != &block)\n     {\n-      pushlevel (0);\n+      pushlevel ();\n       gfc_start_block (&block);\n     }\n \n@@ -1612,12 +1612,12 @@ gfc_trans_omp_parallel_do (gfc_code *code)\n   if (!do_clauses.ordered && do_clauses.sched_kind != OMP_SCHED_STATIC)\n     pblock = &block;\n   else\n-    pushlevel (0);\n+    pushlevel ();\n   stmt = gfc_trans_omp_do (code, pblock, &do_clauses, omp_clauses);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n   stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n \t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n@@ -1638,12 +1638,12 @@ gfc_trans_omp_parallel_sections (gfc_code *code)\n   gfc_start_block (&block);\n   omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n \t\t\t\t       code->loc);\n-  pushlevel (0);\n+  pushlevel ();\n   stmt = gfc_trans_omp_sections (code, &section_clauses);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n   stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n \t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n@@ -1664,12 +1664,12 @@ gfc_trans_omp_parallel_workshare (gfc_code *code)\n   gfc_start_block (&block);\n   omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n \t\t\t\t       code->loc);\n-  pushlevel (0);\n+  pushlevel ();\n   stmt = gfc_trans_omp_workshare (code, &workshare_clauses);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n-    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n   stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n \t\t     omp_clauses);\n   OMP_PARALLEL_COMBINED (stmt) = 1;\n@@ -1763,7 +1763,7 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n \n   code = code->block->next;\n \n-  pushlevel (0);\n+  pushlevel ();\n \n   gfc_start_block (&block);\n   pblock = &block;\n@@ -1892,14 +1892,14 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n     {\n       if (!IS_EMPTY_STMT (stmt))\n \t{\n-\t  tree bindblock = poplevel (1, 0, 0);\n+\t  tree bindblock = poplevel (1, 0);\n \t  stmt = build3_v (BIND_EXPR, NULL, stmt, bindblock);\n \t}\n       else\n-\tpoplevel (0, 0, 0);\n+\tpoplevel (0, 0);\n     }\n   else\n-    poplevel (0, 0, 0);\n+    poplevel (0, 0);\n \n   if (IS_EMPTY_STMT (stmt) && !clauses->nowait)\n     stmt = gfc_trans_omp_barrier ();"}, {"sha": "5d6e6ef5190fffee7f64dcdcbb8ffcca2fb59542", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -182,7 +182,7 @@ void\n gfc_start_block (stmtblock_t * block)\n {\n   /* Start a new binding level.  */\n-  pushlevel (0);\n+  pushlevel ();\n   block->has_scope = 1;\n \n   /* The block is empty.  */\n@@ -215,7 +215,7 @@ gfc_merge_block_scope (stmtblock_t * block)\n \n   /* Remember the decls in this scope.  */\n   decl = getdecls ();\n-  poplevel (0, 0, 0);\n+  poplevel (0, 0);\n \n   /* Add them to the parent scope.  */\n   while (decl != NULL_TREE)\n@@ -250,11 +250,11 @@ gfc_finish_block (stmtblock_t * stmtblock)\n \n       if (decl)\n \t{\n-\t  block = poplevel (1, 0, 0);\n+\t  block = poplevel (1, 0);\n \t  expr = build3_v (BIND_EXPR, decl, expr, block);\n \t}\n       else\n-\tpoplevel (0, 0, 0);\n+\tpoplevel (0, 0);\n     }\n \n   return expr;"}, {"sha": "08a6732527460f9ce7e0c85c6edca419da6babc4", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a60f68a9015f0de8e2377e2db09a6360754c8c/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=87a60f68a9015f0de8e2377e2db09a6360754c8c", "patch": "@@ -427,8 +427,6 @@ int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n \n void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);\n \n-/* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */\n-\n /* Generate code for a scalar assignment.  */\n tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, gfc_typespec, bool, bool,\n \t\t\t      bool);\n@@ -632,11 +630,9 @@ void gfc_trans_deferred_vars (gfc_symbol*, gfc_wrapped_block *);\n /* In f95-lang.c.  */\n tree pushdecl (tree);\n tree pushdecl_top_level (tree);\n-void pushlevel (int);\n-tree poplevel (int, int, int);\n+void pushlevel (void);\n+tree poplevel (int, int);\n tree getdecls (void);\n-tree gfc_truthvalue_conversion (tree);\n-tree gfc_builtin_function (tree);\n \n /* In trans-types.c.  */\n struct array_descr_info;"}]}