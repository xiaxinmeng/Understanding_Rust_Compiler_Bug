{"sha": "5442fe4818ecb877fccbba726ded41f1de3583c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0MmZlNDgxOGVjYjg3N2ZjY2JiYTcyNmRlZDQxZjFkZTM1ODNjNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-12-06T14:37:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-12-06T14:37:09Z"}, "message": "re PR c++/55137 (Unexpected static structure initialization)\n\n\tPR c++/55137\n\t* fold-const.c (fold_binary_loc) <associate>: Don't introduce\n\tTREE_OVERFLOW through reassociation.  If type doesn't have defined\n\toverflow, but one or both of the operands do, use the wrapping type\n\tfor reassociation and only convert to type at the end.\n\n\t* g++.dg/opt/pr55137.C: New test.\n\t* gcc.c-torture/execute/pr55137.c: New test.\n\nFrom-SVN: r194250", "tree": {"sha": "69d8a57a66b0f88599b49c7300a7e116451e88ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69d8a57a66b0f88599b49c7300a7e116451e88ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5442fe4818ecb877fccbba726ded41f1de3583c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5442fe4818ecb877fccbba726ded41f1de3583c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5442fe4818ecb877fccbba726ded41f1de3583c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5442fe4818ecb877fccbba726ded41f1de3583c6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8169a0d2a030e0b25fc545f535328b5adfaadec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8169a0d2a030e0b25fc545f535328b5adfaadec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8169a0d2a030e0b25fc545f535328b5adfaadec"}], "stats": {"total": 116, "additions": 91, "deletions": 25}, "files": [{"sha": "348a6f6a0bba13ba70f62805c351da1575eff9dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5442fe4818ecb877fccbba726ded41f1de3583c6", "patch": "@@ -1,3 +1,11 @@\n+2012-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/55137\n+\t* fold-const.c (fold_binary_loc) <associate>: Don't introduce\n+\tTREE_OVERFLOW through reassociation.  If type doesn't have defined\n+\toverflow, but one or both of the operands do, use the wrapping type\n+\tfor reassociation and only convert to type at the end.\n+\n 2012-12-06  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-fold.c (fold_stmt_1): Remove code handling folding"}, {"sha": "0a8b90a5d09c48fa7415d06a023c43fcc73adee8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5442fe4818ecb877fccbba726ded41f1de3583c6", "patch": "@@ -10348,6 +10348,7 @@ fold_binary_loc (location_t loc,\n \t{\n \t  tree var0, con0, lit0, minus_lit0;\n \t  tree var1, con1, lit1, minus_lit1;\n+\t  tree atype = type;\n \t  bool ok = true;\n \n \t  /* Split both trees into variables, constants, and literals.  Then\n@@ -10363,10 +10364,24 @@ fold_binary_loc (location_t loc,\n \t  if (code == MINUS_EXPR)\n \t    code = PLUS_EXPR;\n \n-\t  /* With undefined overflow we can only associate constants with one\n-\t     variable, and constants whose association doesn't overflow.  */\n+\t  /* With undefined overflow prefer doing association in a type\n+\t     which wraps on overflow, if that is one of the operand types.  */\n \t  if ((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n \t      || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))\n+\t    {\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t\t  && TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0)))\n+\t\tatype = TREE_TYPE (arg0);\n+\t      else if (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n+\t\t       && TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))\n+\t\tatype = TREE_TYPE (arg1);\n+\t      gcc_assert (TYPE_PRECISION (atype) == TYPE_PRECISION (type));\n+\t    }\n+\n+\t  /* With undefined overflow we can only associate constants with one\n+\t     variable, and constants whose association doesn't overflow.  */\n+\t  if ((POINTER_TYPE_P (atype) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n+\t      || (INTEGRAL_TYPE_P (atype) && !TYPE_OVERFLOW_WRAPS (atype)))\n \t    {\n \t      if (var0 && var1)\n \t\t{\n@@ -10378,31 +10393,21 @@ fold_binary_loc (location_t loc,\n \t\t  if (CONVERT_EXPR_P (tmp0)\n \t\t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (tmp0, 0)))\n \t\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (tmp0, 0)))\n-\t\t\t  <= TYPE_PRECISION (type)))\n+\t\t\t  <= TYPE_PRECISION (atype)))\n \t\t    tmp0 = TREE_OPERAND (tmp0, 0);\n \t\t  if (TREE_CODE (tmp1) == NEGATE_EXPR)\n \t\t    tmp1 = TREE_OPERAND (tmp1, 0);\n \t\t  if (CONVERT_EXPR_P (tmp1)\n \t\t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (tmp1, 0)))\n \t\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (tmp1, 0)))\n-\t\t\t  <= TYPE_PRECISION (type)))\n+\t\t\t  <= TYPE_PRECISION (atype)))\n \t\t    tmp1 = TREE_OPERAND (tmp1, 0);\n \t\t  /* The only case we can still associate with two variables\n \t\t     is if they are the same, modulo negation and bit-pattern\n \t\t     preserving conversions.  */\n \t\t  if (!operand_equal_p (tmp0, tmp1, 0))\n \t\t    ok = false;\n \t\t}\n-\n-\t      if (ok && lit0 && lit1)\n-\t\t{\n-\t\t  tree tmp0 = fold_convert (type, lit0);\n-\t\t  tree tmp1 = fold_convert (type, lit1);\n-\n-\t\t  if (!TREE_OVERFLOW (tmp0) && !TREE_OVERFLOW (tmp1)\n-\t\t      && TREE_OVERFLOW (fold_build2 (code, type, tmp0, tmp1)))\n-\t\t    ok = false;\n-\t\t}\n \t    }\n \n \t  /* Only do something if we found more than two objects.  Otherwise,\n@@ -10413,10 +10418,16 @@ fold_binary_loc (location_t loc,\n \t\t       + (lit0 != 0) + (lit1 != 0)\n \t\t       + (minus_lit0 != 0) + (minus_lit1 != 0))))\n \t    {\n-\t      var0 = associate_trees (loc, var0, var1, code, type);\n-\t      con0 = associate_trees (loc, con0, con1, code, type);\n-\t      lit0 = associate_trees (loc, lit0, lit1, code, type);\n-\t      minus_lit0 = associate_trees (loc, minus_lit0, minus_lit1, code, type);\n+\t      bool any_overflows = false;\n+\t      if (lit0) any_overflows |= TREE_OVERFLOW (lit0);\n+\t      if (lit1) any_overflows |= TREE_OVERFLOW (lit1);\n+\t      if (minus_lit0) any_overflows |= TREE_OVERFLOW (minus_lit0);\n+\t      if (minus_lit1) any_overflows |= TREE_OVERFLOW (minus_lit1);\n+\t      var0 = associate_trees (loc, var0, var1, code, atype);\n+\t      con0 = associate_trees (loc, con0, con1, code, atype);\n+\t      lit0 = associate_trees (loc, lit0, lit1, code, atype);\n+\t      minus_lit0 = associate_trees (loc, minus_lit0, minus_lit1,\n+\t\t\t\t\t    code, atype);\n \n \t      /* Preserve the MINUS_EXPR if the negative part of the literal is\n \t\t greater than the positive part.  Otherwise, the multiplicative\n@@ -10430,38 +10441,45 @@ fold_binary_loc (location_t loc,\n \t\t      && tree_int_cst_lt (lit0, minus_lit0))\n \t\t    {\n \t\t      minus_lit0 = associate_trees (loc, minus_lit0, lit0,\n-\t\t\t\t\t\t    MINUS_EXPR, type);\n+\t\t\t\t\t\t    MINUS_EXPR, atype);\n \t\t      lit0 = 0;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      lit0 = associate_trees (loc, lit0, minus_lit0,\n-\t\t\t\t\t      MINUS_EXPR, type);\n+\t\t\t\t\t      MINUS_EXPR, atype);\n \t\t      minus_lit0 = 0;\n \t\t    }\n \t\t}\n+\n+\t      /* Don't introduce overflows through reassociation.  */\n+\t      if (!any_overflows\n+\t\t  && ((lit0 && TREE_OVERFLOW (lit0))\n+\t\t      || (minus_lit0 && TREE_OVERFLOW (minus_lit0))))\n+\t\treturn NULL_TREE;\n+\n \t      if (minus_lit0)\n \t\t{\n \t\t  if (con0 == 0)\n \t\t    return\n \t\t      fold_convert_loc (loc, type,\n \t\t\t\t\tassociate_trees (loc, var0, minus_lit0,\n-\t\t\t\t\t\t\t MINUS_EXPR, type));\n+\t\t\t\t\t\t\t MINUS_EXPR, atype));\n \t\t  else\n \t\t    {\n \t\t      con0 = associate_trees (loc, con0, minus_lit0,\n-\t\t\t\t\t      MINUS_EXPR, type);\n+\t\t\t\t\t      MINUS_EXPR, atype);\n \t\t      return\n \t\t\tfold_convert_loc (loc, type,\n \t\t\t\t\t  associate_trees (loc, var0, con0,\n-\t\t\t\t\t\t\t   PLUS_EXPR, type));\n+\t\t\t\t\t\t\t   PLUS_EXPR, atype));\n \t\t    }\n \t\t}\n \n-\t      con0 = associate_trees (loc, con0, lit0, code, type);\n+\t      con0 = associate_trees (loc, con0, lit0, code, atype);\n \t      return\n \t\tfold_convert_loc (loc, type, associate_trees (loc, var0, con0,\n-\t\t\t\t\t\t\t      code, type));\n+\t\t\t\t\t\t\t      code, atype));\n \t    }\n \t}\n "}, {"sha": "ce14c922f04f443917a9f5f43fce6977ed81fa19", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5442fe4818ecb877fccbba726ded41f1de3583c6", "patch": "@@ -1,3 +1,9 @@\n+2012-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/55137\n+\t* g++.dg/opt/pr55137.C: New test.\n+\t* gcc.c-torture/execute/pr55137.c: New test.\n+\n 2012-12-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* lib/target-supports.exp (check_effective_target_arm_v8_neon_ok):"}, {"sha": "73f8092af279dd21b10e8f544344b70baed236dc", "filename": "gcc/testsuite/g++.dg/opt/pr55137.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr55137.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr55137.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr55137.C?ref=5442fe4818ecb877fccbba726ded41f1de3583c6", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/55137\n+// { dg-do compile }\n+\n+enum E { F = -1 + (int) (sizeof (int) - 1) };"}, {"sha": "80bc973f7f8dc04a3304819e2daf3c2aa255f335", "filename": "gcc/testsuite/gcc.c-torture/execute/pr55137.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr55137.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442fe4818ecb877fccbba726ded41f1de3583c6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr55137.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr55137.c?ref=5442fe4818ecb877fccbba726ded41f1de3583c6", "patch": "@@ -0,0 +1,30 @@\n+/* PR c++/55137 */\n+\n+extern void abort (void);\n+\n+int\n+foo (unsigned int x)\n+{\n+  return ((int) (x + 1U) + 1) < (int) x;\n+}\n+\n+int\n+bar (unsigned int x)\n+{\n+  return (int) (x + 1U) + 1;\n+}\n+\n+int\n+baz (unsigned int x)\n+{\n+  return x + 1U;\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (__INT_MAX__) != (bar (__INT_MAX__) < __INT_MAX__)\n+      || foo (__INT_MAX__) != ((int) baz (__INT_MAX__) + 1 < __INT_MAX__))\n+    abort ();\n+  return 0;\n+}"}]}