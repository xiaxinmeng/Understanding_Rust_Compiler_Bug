{"sha": "691a924baf30c73fd91a19b6b9679ab9da6e29b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkxYTkyNGJhZjMwYzczZmQ5MWExOWI2Yjk2NzlhYjlkYTZlMjliMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-07T21:56:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-07T21:56:40Z"}, "message": "Avoid race condition manipulating heap when goroutine exits.\n\nFrom-SVN: r170758", "tree": {"sha": "77fc6f6a82086f63737b0bac469fcd10a0cfe69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77fc6f6a82086f63737b0bac469fcd10a0cfe69d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/691a924baf30c73fd91a19b6b9679ab9da6e29b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691a924baf30c73fd91a19b6b9679ab9da6e29b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/691a924baf30c73fd91a19b6b9679ab9da6e29b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691a924baf30c73fd91a19b6b9679ab9da6e29b3/comments", "author": null, "committer": null, "parents": [{"sha": "457186f6d55cc813cdb1cdcbfd75457930dacbd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457186f6d55cc813cdb1cdcbfd75457930dacbd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457186f6d55cc813cdb1cdcbfd75457930dacbd2"}], "stats": {"total": 23, "additions": 15, "deletions": 8}, "files": [{"sha": "3d8e9e629084eeb68666a5f4d30716058b349e65", "filename": "libgo/runtime/go-go.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691a924baf30c73fd91a19b6b9679ab9da6e29b3/libgo%2Fruntime%2Fgo-go.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691a924baf30c73fd91a19b6b9679ab9da6e29b3/libgo%2Fruntime%2Fgo-go.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-go.c?ref=691a924baf30c73fd91a19b6b9679ab9da6e29b3", "patch": "@@ -92,25 +92,32 @@ remove_current_thread (void)\n   if (list_entry->next != NULL)\n     list_entry->next->prev = list_entry->prev;\n \n+  /* This will look runtime_mheap as needed.  */\n   runtime_MCache_ReleaseAll (mcache);\n \n+  /* This should never deadlock--there shouldn't be any code that\n+     holds the runtime_mheap lock when locking __go_thread_ids_lock.\n+     We don't want to do this after releasing __go_thread_ids_lock\n+     because it will mean that the garbage collector might run, and\n+     the garbage collector does not try to lock runtime_mheap in all\n+     cases since it knows it is running single-threaded.  */\n+  runtime_lock (&runtime_mheap);\n+  mstats.heap_alloc += mcache->local_alloc;\n+  mstats.heap_objects += mcache->local_objects;\n+  __builtin_memset (mcache, 0, sizeof (struct MCache));\n+  runtime_FixAlloc_Free (&runtime_mheap.cachealloc, mcache);\n+  runtime_unlock (&runtime_mheap);\n+\n   /* As soon as we release this look, a GC could run.  Since this\n      thread is no longer on the list, the GC will not find our M\n      structure, so it could get freed at any time.  That means that\n-     any code from here to thread exit must not assume that the m is\n+     any code from here to thread exit must not assume that m is\n      valid.  */\n   m = NULL;\n \n   i = pthread_mutex_unlock (&__go_thread_ids_lock);\n   __go_assert (i == 0);\n \n-  runtime_lock (&runtime_mheap);\n-  mstats.heap_alloc += mcache->local_alloc;\n-  mstats.heap_objects += mcache->local_objects;\n-  __builtin_memset (mcache, 0, sizeof (struct MCache));\n-  runtime_FixAlloc_Free (&runtime_mheap.cachealloc, mcache);\n-  runtime_unlock (&runtime_mheap);\n-\n   free (list_entry);\n }\n "}]}