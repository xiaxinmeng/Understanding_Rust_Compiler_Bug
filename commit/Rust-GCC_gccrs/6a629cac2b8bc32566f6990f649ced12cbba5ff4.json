{"sha": "6a629cac2b8bc32566f6990f649ced12cbba5ff4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE2MjljYWMyYjhiYzMyNTY2ZjY5OTBmNjQ5Y2VkMTJjYmJhNWZmNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-03-24T01:10:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-24T01:10:13Z"}, "message": "cp-tree.h (lang_type): Remove has_assignment and has_real_assignment.\n\n\t* cp-tree.h (lang_type): Remove has_assignment and\n\thas_real_assignment.  Add befriending_classes.\n\t(TYPE_HAS_ASSIGNMENT): Remove.\n\t(TYPE_HAS_REAL_ASSIGNMENT): Likewise.\n\t(CLASSTYPE_BEFRIENDING_CLASSES): New macro.\n\t(lang_decl): Document.\n\t(DECL_BEFRIENDING_CLASSES): New macro.\n\t(FRIEND_NAME): Move declaration to more obvious location.\n\t(FRIEND_DECLS): Likewise.\n\t* class.c (finish_struct_1): Don't use TYPE_HAS_REAL_ASSIGNMENT.\n\t* decl.c (duplicate_decls): Copy DECL_BEFRIENDING_CLASSES.\n\t(fixup_anonymous_union): Don't use TYPE_HAS_ASSIGNMENT.\n\t(grok_op_properties): Likewise.\n\t* friend.c (is_friend): Use FRIEND_NAME and FRIEND_DECLS.\n\t(add_friend): Likewise.  Don't do weird things with assignment\n\toperators.  Update DECL_BEFRIENDING_CLASSES.\n\t(add_friends): Don't do weird things with assignment operators.\n\t(make_friend_class): Likewise.  Update\n\tCLASSTYPE_BEFRIENDING_CLASSES.\n\t* pt.c (instantiate_class_template): Don't set\n\tTYPE_HAS_ASSIGNMENT.\n\t(tsubst_copy): Substitute the TREE_TYPE for more unary\n\texpressions.\n\t* ptree.c (print_lang_type): Don't look at TYPE_HAS_ASSIGNMENT.\n\t* search.c (protected_accessible_p): New function.\n\t(friend_accessible_p): Likewise.\n\t(accessible_p): Use them.\n\nFrom-SVN: r25940", "tree": {"sha": "afe04b327c1dd8e574626fedc7a32975682b1f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afe04b327c1dd8e574626fedc7a32975682b1f90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a629cac2b8bc32566f6990f649ced12cbba5ff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a629cac2b8bc32566f6990f649ced12cbba5ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a629cac2b8bc32566f6990f649ced12cbba5ff4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a629cac2b8bc32566f6990f649ced12cbba5ff4/comments", "author": null, "committer": null, "parents": [{"sha": "7ad3a049d39ae396220cbd7350ee753054d22afb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad3a049d39ae396220cbd7350ee753054d22afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ad3a049d39ae396220cbd7350ee753054d22afb"}], "stats": {"total": 353, "additions": 260, "deletions": 93}, "files": [{"sha": "d0f66bce36e7693dd881b613f14b3abcd97ccfd7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -1,3 +1,33 @@\n+1999-03-24  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_type): Remove has_assignment and\n+\thas_real_assignment.  Add befriending_classes.\n+\t(TYPE_HAS_ASSIGNMENT): Remove.\n+\t(TYPE_HAS_REAL_ASSIGNMENT): Likewise.\n+\t(CLASSTYPE_BEFRIENDING_CLASSES): New macro.\n+\t(lang_decl): Document.\n+\t(DECL_BEFRIENDING_CLASSES): New macro.\n+\t(FRIEND_NAME): Move declaration to more obvious location.\n+\t(FRIEND_DECLS): Likewise.\n+\t* class.c (finish_struct_1): Don't use TYPE_HAS_REAL_ASSIGNMENT.\n+\t* decl.c (duplicate_decls): Copy DECL_BEFRIENDING_CLASSES.\n+\t(fixup_anonymous_union): Don't use TYPE_HAS_ASSIGNMENT.\n+\t(grok_op_properties): Likewise.\n+\t* friend.c (is_friend): Use FRIEND_NAME and FRIEND_DECLS.\n+\t(add_friend): Likewise.  Don't do weird things with assignment\n+\toperators.  Update DECL_BEFRIENDING_CLASSES.\n+\t(add_friends): Don't do weird things with assignment operators.\n+\t(make_friend_class): Likewise.  Update\n+\tCLASSTYPE_BEFRIENDING_CLASSES.\n+\t* pt.c (instantiate_class_template): Don't set\n+\tTYPE_HAS_ASSIGNMENT. \n+\t(tsubst_copy): Substitute the TREE_TYPE for more unary\n+\texpressions.\n+\t* ptree.c (print_lang_type): Don't look at TYPE_HAS_ASSIGNMENT.\n+\t* search.c (protected_accessible_p): New function.\n+\t(friend_accessible_p): Likewise.\n+\t(accessible_p): Use them.\n+\t\n 1999-03-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (convert_nontype_argument): Don't create things that aren't"}, {"sha": "07f8f9737e146ff0e7d58a5ad80f2b18f5f227b5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -3808,7 +3808,6 @@ finish_struct_1 (t, warn_anon)\n   if (! IS_SIGNATURE (t))\n     CLASSTYPE_NON_AGGREGATE (t)\n       = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n-  TYPE_HAS_REAL_ASSIGNMENT (t) |= TYPE_HAS_ASSIGNMENT (t);\n   TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);"}, {"sha": "307df1dd989aba1eb9714f5ede9ecb3c18b4d386", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -683,12 +683,12 @@ struct lang_type\n     {\n       unsigned has_type_conversion : 1;\n       unsigned has_init_ref : 1;\n-      unsigned has_assignment : 1;\n       unsigned has_default_ctor : 1;\n       unsigned uses_multiple_inheritance : 1;\n       unsigned const_needs_init : 1;\n       unsigned ref_needs_init : 1;\n       unsigned has_const_assign_ref : 1;\n+      unsigned anon_union : 1;\n \n       unsigned has_nonpublic_ctor : 2;\n       unsigned has_nonpublic_assign_ref : 2;\n@@ -721,22 +721,20 @@ struct lang_type\n       unsigned has_opaque_typedecls : 1;\n       unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n-      unsigned has_real_assignment : 1;\n       unsigned has_real_assign_ref : 1;\n       unsigned has_const_init_ref : 1;\n-\n       unsigned has_complex_init_ref : 1;\n+\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n       unsigned is_partial_instantiation : 1;\n       unsigned has_mutable : 1;\n-      unsigned anon_union : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 9;\n+      unsigned dummy : 11;\n     } type_flags;\n \n   int n_ancestors;\n@@ -772,8 +770,8 @@ struct lang_type\n   union tree_node *signature;\n   union tree_node *signature_pointer_to;\n   union tree_node *signature_reference_to;\n-\n   union tree_node *template_info;\n+  tree befriending_classes;\n };\n \n /* Indicates whether or not (and how) a template was expanded for this class.\n@@ -789,13 +787,6 @@ struct lang_type\n /* List of friends which were defined inline in this class definition.  */\n #define CLASSTYPE_INLINE_FRIENDS(NODE) (TYPE_NONCOPIED_PARTS (NODE))\n \n-/* Nonzero for _CLASSTYPE means that the _CLASSTYPE either has\n-   a special meaning for the assignment operator (\"operator=\"),\n-   or one of its fields (or base members) has a special meaning\n-   defined.  */\n-#define TYPE_HAS_ASSIGNMENT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_assignment)\n-#define TYPE_HAS_REAL_ASSIGNMENT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assignment)\n-\n /* Nonzero for _CLASSTYPE means that operator new and delete are defined,\n    respectively.  */\n #define TYPE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_new)\n@@ -1057,11 +1048,15 @@ struct lang_type\n /* Same, but cache a list whose value is the binfo of this type.  */\n #define CLASSTYPE_BINFO_AS_LIST(NODE) (TYPE_LANG_SPECIFIC(NODE)->binfo_as_list)\n \n-/* A list of class types with which this type is a friend.  The\n+/* A list of class types of which this type is a friend.  The\n    TREE_VALUE is normally a TYPE, but will be a TEMPLATE_DECL in the\n    case of a template friend.  */\n #define CLASSTYPE_FRIEND_CLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->friend_classes)\n \n+/* A list of the classes which grant friendship to this class.  */\n+#define CLASSTYPE_BEFRIENDING_CLASSES(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->befriending_classes)\n+\n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n \n@@ -1169,6 +1164,15 @@ struct lang_type\n /* The binding level associated with the namespace.  */\n #define NAMESPACE_LEVEL(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.level)\n \f\n+\n+/* If a DECL has DECL_LANG_SPECIFIC, it is either a lang_decl_flags or\n+   a lang_decl (which has lang_decl_flags as its initial prefix).  A\n+   FUNCTION_DECL, NAMESPACE_DECL, TYPE_DECL, or USING_DECL may have a\n+   full lang_decl.  A FIELD_DECL, or a static data member VAR_DECL,\n+   will have only lang_decl_flags.  Thus, one should only access the\n+   members of lang_decl that are not in lang_decl_flags for DECLs that\n+   are not FIELD_DECLs or VAR_DECLs.  */\n+\n struct lang_decl_flags\n {\n #ifdef ONLY_INT_FIELDS\n@@ -1215,6 +1219,7 @@ struct lang_decl\n   struct lang_decl_flags decl_flags;\n \n   tree main_decl_variant;\n+  tree befriending_classes;\n   struct pending_inline *pending_inline_info;\n };\n \n@@ -1281,6 +1286,10 @@ struct lang_decl\n    member functions for this class.  */\n #define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.friend_attr)\n \n+/* A TREE_LIST of the types which have befriended this FUNCTION_DECL.  */\n+#define DECL_BEFRIENDING_CLASSES(NODE) \\\n+  (DECL_LANG_SPECIFIC(NODE)->befriending_classes)\n+\n /* Nonzero for FUNCTION_DECL means that this decl is a static\n    member function.  */\n #define DECL_STATIC_FUNCTION_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.static_function)\n@@ -1822,6 +1831,8 @@ extern int flag_new_for_scope;\n    the TREE_PUROSE will be the class type, and the TREE_VALUE will be\n    NULL_TREE.  */\n #define DECL_FRIENDLIST(NODE)\t\t(DECL_INITIAL (NODE))\n+#define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n+#define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n \n /* The DECL_ACCESS, if non-NULL, is a TREE_LIST.  The TREE_PURPOSE of\n    each node is a type; the TREE_VALUE is the access granted for this\n@@ -2677,9 +2688,6 @@ extern tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n #define same_or_base_type_p(type1, type2) \\\n   comptypes ((type1), (type2), COMPARE_BASE)\n \n-#define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n-#define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n-\n /* These macros are used to access a TEMPLATE_PARM_INDEX.  */\n #define TEMPLATE_PARM_IDX(NODE) (((template_parm_index*) NODE)->index)\n #define TEMPLATE_PARM_LEVEL(NODE) (((template_parm_index*) NODE)->level)"}, {"sha": "64c8a6595f5ca94d96c7713bd44723c8cd6d8faf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -3326,6 +3326,13 @@ duplicate_decls (newdecl, olddecl)\n       DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n       DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       olddecl_friend = DECL_FRIEND_P (olddecl);\n+\n+      /* Only functions have DECL_BEFRIENDING_CLASSES.  */\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL\n+\t  || DECL_FUNCTION_TEMPLATE_P (newdecl))\n+\tDECL_BEFRIENDING_CLASSES (newdecl)\n+\t  = chainon (DECL_BEFRIENDING_CLASSES (newdecl),\n+\t\t     DECL_BEFRIENDING_CLASSES (olddecl));\n     }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -6668,7 +6675,6 @@ fixup_anonymous_union (t)\n   TYPE_HAS_INIT_REF (t) = 0;\n   TYPE_HAS_CONST_INIT_REF (t) = 0;\n   TYPE_HAS_ASSIGN_REF (t) = 0;\n-  TYPE_HAS_ASSIGNMENT (t) = 0;\n   TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n \n   /* Splice the implicitly generated functions out of the TYPE_METHODS\n@@ -11804,7 +11810,7 @@ grok_op_properties (decl, virtualp, friendp)\n       if (name == ansi_opname[(int) MODIFY_EXPR]\n \t  && !(DECL_TEMPLATE_INSTANTIATION (decl)\n \t       && is_member_template (DECL_TI_TEMPLATE (decl))))\n-\tTYPE_HAS_ASSIGNMENT (current_class_type) = 1;\n+\t;\n       else if (name == ansi_opname[(int) CALL_EXPR])\n \tTYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n       else if (name == ansi_opname[(int) ARRAY_REF])"}, {"sha": "2a69acd8d84d688cdcfc8d6299b873ae922d3d61", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -61,9 +61,9 @@ is_friend (type, supplicant)\n \n       for (; list ; list = TREE_CHAIN (list))\n \t{\n-\t  if (name == TREE_PURPOSE (list))\n+\t  if (name == FRIEND_NAME (list))\n \t    {\n-\t      tree friends = TREE_VALUE (list);\n+\t      tree friends = FRIEND_DECLS (list);\n \t      for (; friends ; friends = TREE_CHAIN (friends))\n \t\t{\n \t\t  if (same_type_p (ctype, TREE_PURPOSE (friends)))\n@@ -148,11 +148,13 @@ add_friend (type, decl)\n   tree list = DECL_FRIENDLIST (typedecl);\n   tree name = DECL_NAME (decl);\n \n+  type = TREE_TYPE (typedecl);\n+\n   while (list)\n     {\n-      if (name == TREE_PURPOSE (list))\n+      if (name == FRIEND_NAME (list))\n \t{\n-\t  tree friends = TREE_VALUE (list);\n+\t  tree friends = FRIEND_DECLS (list);\n \t  for (; friends ; friends = TREE_CHAIN (friends))\n \t    {\n \t      if (decl == TREE_VALUE (friends))\n@@ -170,21 +172,13 @@ add_friend (type, decl)\n \t}\n       list = TREE_CHAIN (list);\n     }\n+\n   DECL_FRIENDLIST (typedecl)\n     = tree_cons (DECL_NAME (decl), build_tree_list (error_mark_node, decl),\n \t\t DECL_FRIENDLIST (typedecl));\n-  if (DECL_NAME (decl) == ansi_opname[(int) MODIFY_EXPR])\n-    {\n-      tree parmtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-      TYPE_HAS_ASSIGNMENT (TREE_TYPE (typedecl)) = 1;\n-      if (parmtypes && TREE_CHAIN (parmtypes))\n-\t{\n-\t  tree parmtype = TREE_VALUE (TREE_CHAIN (parmtypes));\n-\t  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-\t      && TREE_TYPE (parmtypes) == TREE_TYPE (typedecl))\n-\t    TYPE_HAS_ASSIGN_REF (TREE_TYPE (typedecl)) = 1;\n-\t}\n-    }\n+  DECL_BEFRIENDING_CLASSES (decl) \n+    = tree_cons (NULL_TREE, type,\n+\t\t DECL_BEFRIENDING_CLASSES (decl));\n }\n \n /* Declare that every member function NAME in FRIEND_TYPE\n@@ -199,9 +193,9 @@ add_friends (type, name, friend_type)\n \n   while (list)\n     {\n-      if (name == TREE_PURPOSE (list))\n+      if (name == FRIEND_NAME (list))\n \t{\n-\t  tree friends = TREE_VALUE (list);\n+\t  tree friends = FRIEND_DECLS (list);\n \t  while (friends && TREE_PURPOSE (friends) != friend_type)\n \t    friends = TREE_CHAIN (friends);\n \t  if (friends)\n@@ -226,13 +220,6 @@ add_friends (type, name, friend_type)\n     = tree_cons (name,\n \t\t build_tree_list (friend_type, NULL_TREE),\n \t\t DECL_FRIENDLIST (typedecl));\n-  if (! strncmp (IDENTIFIER_POINTER (name),\n-\t\t IDENTIFIER_POINTER (ansi_opname[(int) MODIFY_EXPR]),\n-\t\t strlen (IDENTIFIER_POINTER (ansi_opname[(int) MODIFY_EXPR]))))\n-    {\n-      TYPE_HAS_ASSIGNMENT (TREE_TYPE (typedecl)) = 1;\n-      sorry (\"declaring \\\"friend operator =\\\" will not find \\\"operator = (X&)\\\" if it exists\");\n-    }\n }\n \n /* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already\n@@ -309,6 +296,11 @@ make_friend_class (type, friend_type)\n     {\n       CLASSTYPE_FRIEND_CLASSES (type)\n \t= tree_cons (NULL_TREE, friend_type, CLASSTYPE_FRIEND_CLASSES (type));\n+      if (is_template_friend)\n+\tfriend_type = TREE_TYPE (friend_type);\n+      CLASSTYPE_BEFRIENDING_CLASSES (friend_type)\n+\t= tree_cons (NULL_TREE, type, \n+\t\t     CLASSTYPE_BEFRIENDING_CLASSES (friend_type)); \n     }\n }\n "}, {"sha": "f7372dd42e1635f988029ccc91cb5e7361e16342", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -4783,7 +4783,6 @@ instantiate_class_template (type)\n \n   TYPE_HAS_CONSTRUCTOR (type) = TYPE_HAS_CONSTRUCTOR (pattern);\n   TYPE_HAS_DESTRUCTOR (type) = TYPE_HAS_DESTRUCTOR (pattern);\n-  TYPE_HAS_ASSIGNMENT (type) = TYPE_HAS_ASSIGNMENT (pattern);\n   TYPE_OVERLOADS_CALL_EXPR (type) = TYPE_OVERLOADS_CALL_EXPR (pattern);\n   TYPE_OVERLOADS_ARRAY_REF (type) = TYPE_OVERLOADS_ARRAY_REF (pattern);\n   TYPE_OVERLOADS_ARROW (type) = TYPE_OVERLOADS_ARROW (pattern);\n@@ -6682,7 +6681,7 @@ tsubst_copy (t, args, complain, in_decl)\n     case THROW_EXPR:\n     case TYPEID_EXPR:\n       return build1\n-\t(code, NULL_TREE,\n+\t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n \t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n \n     case PLUS_EXPR:"}, {"sha": "2cff6552ed9bc90c1ad90e3e6ea70a4c9e82b6ca", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -113,8 +113,6 @@ print_lang_type (file, node, indent)\n     fputs (\" delete\", file);\n   if (TYPE_GETS_DELETE (node) & 2)\n     fputs (\" delete[]\", file);\n-  if (TYPE_HAS_ASSIGNMENT (node))\n-    fputs (\" has=\", file);\n   if (TYPE_HAS_ASSIGN_REF (node))\n     fputs (\" this=(X&)\", file);\n   if (TYPE_OVERLOADS_CALL_EXPR (node))"}, {"sha": "a5301beb8b00737e4a25da6378ca0883229ff16b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 120, "deletions": 41, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -147,6 +147,8 @@ static tree access_in_type PROTO ((tree, tree));\n static tree dfs_canonical_queue PROTO ((tree, void *));\n static tree dfs_assert_unmarked_p PROTO ((tree, void *));\n static void assert_canonical_unmarked PROTO ((tree));\n+static int protected_accessible_p PROTO ((tree, tree, tree, tree));\n+static int friend_accessible_p PROTO ((tree, tree, tree, tree));\n \n /* Allocate a level of searching.  */\n \n@@ -846,6 +848,116 @@ dfs_accessible_p (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Returns non-zero if it is OK to access DECL when named in TYPE\n+   through an object indiated by BINFO in the context of DERIVED.  */\n+\n+static int\n+protected_accessible_p (type, decl, derived, binfo)\n+     tree type;\n+     tree decl;\n+     tree derived;\n+     tree binfo;\n+{\n+  tree access;\n+\n+  /* We're checking this clause from [class.access.base]\n+\n+       m as a member of N is protected, and the reference occurs in a\n+       member or friend of class N, or in a member or friend of a\n+       class P derived from N, where m as a member of P is private or\n+       protected.  \n+\n+    If DERIVED isn't derived from TYPE, then it certainly does not\n+    apply.  */\n+  if (!DERIVED_FROM_P (type, derived))\n+    return 0;\n+\n+  access = access_in_type (derived, decl);\n+  if (same_type_p (derived, type))\n+    {\n+      if (access != access_private_node)\n+\treturn 0;\n+    }\n+  else if (access != access_private_node\n+\t   && access != access_protected_node)\n+    return 0;\n+  \n+  /* [class.protected]\n+\n+     When a friend or a member function of a derived class references\n+     a protected nonstatic member of a base class, an access check\n+     applies in addition to those described earlier in clause\n+     _class.access_.4) Except when forming a pointer to member\n+     (_expr.unary.op_), the access must be through a pointer to,\n+     reference to, or object of the derived class itself (or any class\n+     derived from that class) (_expr.ref_).  If the access is to form\n+     a pointer to member, the nested-name-specifier shall name the\n+     derived class (or any class derived from that class).  */\n+  if (DECL_NONSTATIC_MEMBER_P (decl))\n+    {\n+      /* We can tell through what the reference is occurring by\n+\t chasing BINFO up to the root.  */\n+      tree t = binfo;\n+      while (BINFO_INHERITANCE_CHAIN (t))\n+\tt = BINFO_INHERITANCE_CHAIN (t);\n+      \n+      if (!DERIVED_FROM_P (derived, BINFO_TYPE (t)))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Returns non-zero if SCOPE is a friend of a type which would be able\n+   to acces DECL, named in TYPE, through the object indicated by\n+   BINFO.  */\n+\n+static int\n+friend_accessible_p (scope, type, decl, binfo)\n+     tree scope;\n+     tree type;\n+     tree decl;\n+     tree binfo;\n+{\n+  tree befriending_classes;\n+  tree t;\n+\n+  if (!scope)\n+    return 0;\n+\n+  if (TREE_CODE (scope) == FUNCTION_DECL\n+      || DECL_FUNCTION_TEMPLATE_P (scope))\n+    befriending_classes = DECL_BEFRIENDING_CLASSES (scope);\n+  else if (TYPE_P (scope))\n+    befriending_classes = CLASSTYPE_BEFRIENDING_CLASSES (scope);\n+  else\n+    return 0;\n+\n+  for (t = befriending_classes; t; t = TREE_CHAIN (t))\n+    if (protected_accessible_p (type, decl, TREE_VALUE (t), binfo))\n+      return 1;\n+\n+  if (TREE_CODE (scope) == FUNCTION_DECL\n+      || DECL_FUNCTION_TEMPLATE_P (scope))\n+    {\n+      /* Perhaps this SCOPE is a member of a class which is a \n+\t friend.  */ \n+      if (friend_accessible_p (DECL_CLASS_CONTEXT (scope), type,\n+\t\t\t       decl, binfo))\n+\treturn 1;\n+\n+      /* Or an instantiation of something which is a friend.  */\n+      if (DECL_TEMPLATE_INFO (scope))\n+\treturn friend_accessible_p (DECL_TI_TEMPLATE (scope),\n+\t\t\t\t    type, decl, binfo);\n+    }\n+  else if (CLASSTYPE_TEMPLATE_INFO (scope))\n+    return friend_accessible_p (CLASSTYPE_TI_TEMPLATE (scope),\n+\t\t\t\ttype, decl, binfo);\n+\n+  return 0;\n+}\n+   \n /* DECL is a declaration from a base class of TYPE, which was the\n    classs used to name DECL.  Return non-zero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,\n@@ -858,7 +970,6 @@ accessible_p (type, decl)\n      tree decl;\n      \n {\n-  tree scope;\n   tree binfo;\n   tree t;\n \n@@ -909,48 +1020,16 @@ accessible_p (type, decl)\n   /* Figure out where the reference is occurring.  Check to see if\n      DECL is private or protected in this scope, since that will\n      determine whether protected access in TYPE allowed.  */\n-  if (current_class_type\n-      && DERIVED_FROM_P (type, current_class_type))\n-    {\n-      tree access = access_in_type (current_class_type, decl);\n-      if (same_type_p (current_class_type, type)\n-\t  && access == access_private_node)\n-\tprotected_ok = 1;\n-      else if (access && (access == access_private_node\n-\t\t\t  || access == access_protected_node))\n-\tprotected_ok = 1;\n-    }\n+  if (current_class_type)\n+    protected_ok \n+      = protected_accessible_p (type, decl, current_class_type,\n+\t\t\t\tbinfo);\n \n-  /* Now, loop through the classes of which SCOPE is a friend.  */\n-  if (!protected_ok && scope)\n-    {\n-      /* FIXME: Implement this.  Right now, we have no way of knowing\n-\t        which classes befriend a particular function or class.  */\n-    }\n-\n-  /* [class.protected]\n+  /* Now, loop through the classes of which we are a friend.  */\n+  if (!protected_ok)\n+    protected_ok = friend_accessible_p (current_scope (),\n+\t\t\t\t\ttype, decl, binfo);\n \n-     When a friend or a member function of a derived class references\n-     a protected nonstatic member of a base class, an access check\n-     applies in addition to those described earlier in clause\n-     _class.access_.4) Except when forming a pointer to member\n-     (_expr.unary.op_), the access must be through a pointer to,\n-     reference to, or object of the derived class itself (or any class\n-     derived from that class) (_expr.ref_).  If the access is to form\n-     a pointer to member, the nested-name-specifier shall name the\n-     derived class (or any class derived from that class).  */\n-  if (protected_ok && DECL_NONSTATIC_MEMBER_P (decl))\n-    {\n-      /* We can tell through what the reference is occurring by\n-\t chasing BINFO up to the root.  */\n-      t = binfo;\n-      while (BINFO_INHERITANCE_CHAIN (t))\n-\tt = BINFO_INHERITANCE_CHAIN (t);\n-      \n-      if (!DERIVED_FROM_P (current_class_type, BINFO_TYPE (t)))\n-\tprotected_ok = 0;\n-    }\n-  \n   /* Standardize on the same that will access_in_type will use.  We\n      don't need to know what path was chosen from this point onwards.  */ \n   binfo = TYPE_BINFO (type);"}, {"sha": "76fcebe1fae8fca848deee650e130ae4ac2ec028", "filename": "gcc/testsuite/g++.old-deja/g++.other/friend1.C", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a629cac2b8bc32566f6990f649ced12cbba5ff4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Ffriend1.C?ref=6a629cac2b8bc32566f6990f649ced12cbba5ff4", "patch": "@@ -9,21 +9,77 @@\n // From: Alexandre Oliva <oliva@dcc.unicamp.br>\n // Date: 06 Mar 1998 01:43:18 -0300\n \n+template <int*>\n+class X {};\n+\n+template <typename T>\n+void g();\n+\n+struct S;\n+\n+template <typename T>\n+struct R;\n \n class B {\n protected:\n   int i; // ERROR - in this context\n-  static int j; // gets bogus error - XFAIL *-*-*\n+  static int j;\n };\n \n class D : public B {\n-    friend void f();\n+  friend void f();\n+  template <typename T>\n+  friend void g();\n+  friend struct S;\n+  template <typename T>\n+  friend struct R;\n+};\n+\n+struct S {\n+  void h();\n+  X<&B::j> x;\n+};\n+\n+template <typename T>\n+struct R {\n+  void h();\n+  X<&B::j> x;\n };\n \n void f()\n {\n     ((B*)0)->i = 3; // ERROR - protected\n     ((D*)0)->i = 4;\n-    B::j = 5;\t\t\t// gets bogus error - XFAIL *-*-*\n+    B::j = 5;\n     D::j = 6;\n }\n+\n+template <typename T>\n+void g()\n+{\n+    ((B*)0)->i = 3; // ERROR - protected\n+    ((D*)0)->i = 4;\n+    B::j = 5;\n+    D::j = 6;\n+}\n+\n+template void g<int>();\n+\n+void S::h()\n+{\n+  ((B*)0)->i = 3; // ERROR - protected\n+  ((D*)0)->i = 4;\n+  B::j = 5;\n+  D::j = 6;\n+}\n+\n+template <typename T>\n+void R<T>::h() \n+{\n+  ((B*)0)->i = 3; // ERROR - protected\n+  ((D*)0)->i = 4;\n+  B::j = 5;\n+  D::j = 6;\n+}\n+\n+template struct R<double>;"}]}