{"sha": "0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMxMGU1MzczYjE5ZDJkNWVkZWIzN2M0Y2Q0YTRmZjFhZjFkYTRjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-14T05:58:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-07-14T05:58:30Z"}, "message": "mips-protos.h (mips_va_arg): Delete.\n\n\t* config/mips/mips-protos.h (mips_va_arg): Delete.\n\t* config/mips/mips.h (EXPAND_BUILTIN_VA_ARG): Delete.\n\t* config/mips/mips.c: Include tree-gimple.h.\n\t(TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n\t(mips_arg_info): Remove special handling of must_pass_in_stck args.\n\t(mips_gimplify_va_arg_expr): Rewritten from mips_va_arg.\n\t(function_arg_pass_by_reference): Return true if must_pass_in_stack.\n\nCo-Authored-By: Richard Sandiford <rsandifo@redhat.com>\n\nFrom-SVN: r84671", "tree": {"sha": "0f73bf75fee1514e041c4cb2814c2606b731de6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f73bf75fee1514e041c4cb2814c2606b731de6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/comments", "author": null, "committer": null, "parents": [{"sha": "1cb6d0da5f66355be92cacd0f8c7617344b0e66f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb6d0da5f66355be92cacd0f8c7617344b0e66f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb6d0da5f66355be92cacd0f8c7617344b0e66f"}], "stats": {"total": 462, "additions": 188, "deletions": 274}, "files": [{"sha": "d0bfe32dbd28d2e0d9d0291f03ad5fd51a823ab5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "patch": "@@ -1,3 +1,14 @@\n+2004-07-14  Richard Henderson  <rth@redhat.com>\n+\t    Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_va_arg): Delete.\n+\t* config/mips/mips.h (EXPAND_BUILTIN_VA_ARG): Delete.\n+\t* config/mips/mips.c: Include tree-gimple.h.\n+\t(TARGET_GIMPLIFY_VA_ARG_EXPR): Define.\n+\t(mips_arg_info): Remove special handling of must_pass_in_stck args.\n+\t(mips_gimplify_va_arg_expr): Rewritten from mips_va_arg.\n+\t(function_arg_pass_by_reference): Return true if must_pass_in_stack.\n+\n 2004-07-13  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_gimplify_va_arg_expr): Swap"}, {"sha": "f38809eaf685e6ddb9f30e8167d7a62a218d2155", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "patch": "@@ -143,7 +143,6 @@ extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n extern bool mips_pad_arg_upward (enum machine_mode, tree);\n extern bool mips_pad_reg_upward (enum machine_mode, tree);\n extern void mips_va_start (tree, rtx);\n-extern struct rtx_def *mips_va_arg (tree, tree);\n \n extern bool mips_expand_unaligned_load (rtx, rtx, unsigned int, int);\n extern bool mips_expand_unaligned_store (rtx, rtx, unsigned int, int);"}, {"sha": "3e93a015a94f3574af20735d031164418a6f390b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 177, "deletions": 269, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "patch": "@@ -55,6 +55,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n+#include \"tree-gimple.h\"\n \n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n@@ -288,6 +289,7 @@ static void mips_init_libfuncs (void);\n static void mips_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\t tree, int *, int);\n static tree mips_build_builtin_va_list (void);\n+static tree mips_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n \n #if TARGET_IRIX\n static void irix_asm_named_section_1 (const char *, unsigned int,\n@@ -716,6 +718,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST mips_build_builtin_va_list\n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR mips_gimplify_va_arg_expr\n \n #undef TARGET_PROMOTE_FUNCTION_ARGS\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true\n@@ -3554,22 +3558,15 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \teven_reg_p = true;\n     }\n \n-  if (mips_abi != ABI_EABI && targetm.calls.must_pass_in_stack (mode, type))\n-    /* This argument must be passed on the stack.  Eat up all the\n-       remaining registers.  */\n-    info->reg_offset = MAX_ARGS_IN_REGISTERS;\n-  else\n-    {\n-      /* Set REG_OFFSET to the register count we're interested in.\n-\t The EABI allocates the floating-point registers separately,\n-\t but the other ABIs allocate them like integer registers.  */\n-      info->reg_offset = (mips_abi == ABI_EABI && info->fpr_p\n-\t\t\t  ? cum->num_fprs\n-\t\t\t  : cum->num_gprs);\n+  /* Set REG_OFFSET to the register count we're interested in.\n+     The EABI allocates the floating-point registers separately,\n+     but the other ABIs allocate them like integer registers.  */\n+  info->reg_offset = (mips_abi == ABI_EABI && info->fpr_p\n+\t\t      ? cum->num_fprs\n+\t\t      : cum->num_gprs);\n \n-      if (even_reg_p)\n-\tinfo->reg_offset += info->reg_offset & 1;\n-    }\n+  if (even_reg_p)\n+    info->reg_offset += info->reg_offset & 1;\n \n   /* The alignment applied to registers is also applied to stack arguments.  */\n   info->stack_offset = cum->stack_words;\n@@ -4041,272 +4038,179 @@ mips_va_start (tree valist, rtx nextarg)\n \f\n /* Implement va_arg.  */\n \n-rtx\n-mips_va_arg (tree valist, tree type)\n+static tree\n+mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n {\n   HOST_WIDE_INT size, rsize;\n-  rtx addr_rtx;\n-  tree t;\n+  tree addr;\n+  bool indirect;\n+\n+  indirect\n+    = function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n+\n+  if (indirect)\n+    type = build_pointer_type (type);\n \n   size = int_size_in_bytes (type);\n   rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n \n-  if (mips_abi == ABI_EABI)\n+  if (mips_abi != ABI_EABI || !EABI_FLOAT_VARARGS_P)\n+    addr = std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n+  else\n     {\n-      bool indirect;\n-      rtx r;\n-\n-      indirect\n-\t= function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n-\n-      if (indirect)\n-\t{\n-\t  size = POINTER_SIZE / BITS_PER_UNIT;\n-\t  rsize = UNITS_PER_WORD;\n-\t}\n-\n-      if (!EABI_FLOAT_VARARGS_P)\n+      /* Not a simple merged stack.\t */\n+\n+      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n+      tree ovfl, top, off, align;\n+      HOST_WIDE_INT osize;\n+      tree t, u;\n+\n+      f_ovfl = TYPE_FIELDS (va_list_type_node);\n+      f_gtop = TREE_CHAIN (f_ovfl);\n+      f_ftop = TREE_CHAIN (f_gtop);\n+      f_goff = TREE_CHAIN (f_ftop);\n+      f_foff = TREE_CHAIN (f_goff);\n+\n+      /* We maintain separate pointers and offsets for floating-point\n+\t and integer arguments, but we need similar code in both cases.\n+\t Let:\n+\n+\t TOP be the top of the register save area;\n+\t OFF be the offset from TOP of the next register;\n+\t ADDR_RTX be the address of the argument;\n+\t RSIZE be the number of bytes used to store the argument\n+\t when it's in the register save area;\n+\t OSIZE be the number of bytes used to store it when it's\n+\t in the stack overflow area; and\n+\t PADDING be (BYTES_BIG_ENDIAN ? OSIZE - RSIZE : 0)\n+\n+\t The code we want is:\n+\n+\t 1: off &= -rsize;\t  // round down\n+\t 2: if (off != 0)\n+\t 3:   {\n+\t 4:\t addr_rtx = top - off;\n+\t 5:\t off -= rsize;\n+\t 6:   }\n+\t 7: else\n+\t 8:   {\n+\t 9:\t ovfl += ((intptr_t) ovfl + osize - 1) & -osize;\n+\t 10:\t addr_rtx = ovfl + PADDING;\n+\t 11:\t ovfl += osize;\n+\t 14:   }\n+\n+\t [1] and [9] can sometimes be optimized away.  */\n+\n+      ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n+\t\t    NULL_TREE);\n+\n+      if (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT\n+\t  && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_FPVALUE)\n \t{\n-\t  /* Case of all args in a merged stack.  No need to check bounds,\n-\t     just advance valist along the stack.  */\n-\n-\t  tree gpr = valist;\n-\t  if (!indirect\n-\t      && !TARGET_64BIT\n-\t      && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n-\t    {\n-\t      /* Align the pointer using: ap = (ap + align - 1) & -align,\n-\t\t where align is 2 * UNITS_PER_WORD.  */\n-\t      t = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t\t build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n-\t      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t\t build_int_2 (-2 * UNITS_PER_WORD, -1));\n-\t      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n-\t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t    }\n-\n-\t  /* Emit code to set addr_rtx to the valist, and postincrement\n-\t     the valist by the size of the argument, rounded up to the\n-\t     next word.\t Account for padding on big-endian targets.  */\n-\t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t     size_int (rsize));\n-\t  addr_rtx = expand_expr (t, 0, Pmode, EXPAND_NORMAL);\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    addr_rtx = plus_constant (addr_rtx, rsize - size);\n-\n-\t  /* Flush the POSTINCREMENT.  */\n-\t  emit_queue();\n+\t  top = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n+\t\t       NULL_TREE);\n+\t  off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n+\t\t       NULL_TREE);\n+\n+\t  /* When floating-point registers are saved to the stack,\n+\t     each one will take up UNITS_PER_HWFPVALUE bytes, regardless\n+\t     of the float's precision.  */\n+\t  rsize = UNITS_PER_HWFPVALUE;\n+\n+\t  /* Overflow arguments are padded to UNITS_PER_WORD bytes\n+\t     (= PARM_BOUNDARY bits).  This can be different from RSIZE\n+\t     in two cases:\n+\n+\t     (1) On 32-bit targets when TYPE is a structure such as:\n+\n+\t     struct s { float f; };\n+\n+\t     Such structures are passed in paired FPRs, so RSIZE\n+\t     will be 8 bytes.  However, the structure only takes\n+\t     up 4 bytes of memory, so OSIZE will only be 4.\n+\n+\t     (2) In combinations such as -mgp64 -msingle-float\n+\t     -fshort-double.  Doubles passed in registers\n+\t     will then take up 4 (UNITS_PER_HWFPVALUE) bytes,\n+\t     but those passed on the stack take up\n+\t     UNITS_PER_WORD bytes.  */\n+\t  osize = MAX (GET_MODE_SIZE (TYPE_MODE (type)), UNITS_PER_WORD);\n \t}\n       else\n \t{\n-\t  /* Not a simple merged stack.\t */\n-\n-\t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n-\t  tree ovfl, top, off;\n-\t  rtx lab_over = NULL_RTX, lab_false;\n-\t  HOST_WIDE_INT osize;\n-\n-\t  addr_rtx = gen_reg_rtx (Pmode);\n-\n-\t  f_ovfl = TYPE_FIELDS (va_list_type_node);\n-\t  f_gtop = TREE_CHAIN (f_ovfl);\n-\t  f_ftop = TREE_CHAIN (f_gtop);\n-\t  f_goff = TREE_CHAIN (f_ftop);\n-\t  f_foff = TREE_CHAIN (f_goff);\n-\n-\t  /* We maintain separate pointers and offsets for floating-point\n-\t     and integer arguments, but we need similar code in both cases.\n-\t     Let:\n-\n-\t\t TOP be the top of the register save area;\n-\t\t OFF be the offset from TOP of the next register;\n-\t\t ADDR_RTX be the address of the argument;\n-\t\t RSIZE be the number of bytes used to store the argument\n-\t\t   when it's in the register save area;\n-\t\t OSIZE be the number of bytes used to store it when it's\n-\t\t   in the stack overflow area; and\n-\t\t PADDING be (BYTES_BIG_ENDIAN ? OSIZE - RSIZE : 0)\n-\n-\t     The code we want is:\n-\n-\t\t  1: off &= -rsize;\t  // round down\n-\t\t  2: if (off != 0)\n-\t\t  3:   {\n-\t\t  4:\t addr_rtx = top - off;\n-\t\t  5:\t off -= rsize;\n-\t\t  6:   }\n-\t\t  7: else\n-\t\t  8:   {\n-\t\t  9:\t ovfl += ((intptr_t) ovfl + osize - 1) & -osize;\n-\t\t 10:\t addr_rtx = ovfl + PADDING;\n-\t\t 11:\t ovfl += osize;\n-\t\t 14:   }\n-\n-\t     [1] and [9] can sometimes be optimized away.  */\n-\n-\t  lab_false = gen_label_rtx ();\n-\t  lab_over = gen_label_rtx ();\n-\n-\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n-\t\t\tNULL_TREE);\n-\t  if (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT\n-\t      && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_FPVALUE)\n+\t  top = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n+\t\t       NULL_TREE);\n+\t  off = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n+\t\t       NULL_TREE);\n+\t  if (rsize > UNITS_PER_WORD)\n \t    {\n-\t      top = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n-\t\t\t   NULL_TREE);\n-\t      off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n-\t\t\t   NULL_TREE);\n-\n-\t      /* When floating-point registers are saved to the stack,\n-\t\t each one will take up UNITS_PER_HWFPVALUE bytes, regardless\n-\t\t of the float's precision.  */\n-\t      rsize = UNITS_PER_HWFPVALUE;\n-\n-\t      /* Overflow arguments are padded to UNITS_PER_WORD bytes\n-\t\t (= PARM_BOUNDARY bits).  This can be different from RSIZE\n-\t\t in two cases:\n-\n-\t\t     (1) On 32-bit targets when TYPE is a structure such as:\n-\n-\t\t\t     struct s { float f; };\n-\n-\t\t\t Such structures are passed in paired FPRs, so RSIZE\n-\t\t\t will be 8 bytes.  However, the structure only takes\n-\t\t\t up 4 bytes of memory, so OSIZE will only be 4.\n-\n-\t\t     (2) In combinations such as -mgp64 -msingle-float\n-\t\t\t -fshort-double.  Doubles passed in registers\n-\t\t\t will then take up 4 (UNITS_PER_HWFPVALUE) bytes,\n-\t\t\t but those passed on the stack take up\n-\t\t\t UNITS_PER_WORD bytes.  */\n-\t      osize = MAX (GET_MODE_SIZE (TYPE_MODE (type)), UNITS_PER_WORD);\n+\t      /* [1] Emit code for: off &= -rsize.\t*/\n+\t      t = build (BIT_AND_EXPR, TREE_TYPE (off), off,\n+\t\t\t build_int_2 (-rsize, -1));\n+\t      t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n+\t      gimplify_and_add (t, pre_p);\n \t    }\n-\t  else\n-\t    {\n-\t      top = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n-\t\t\t   NULL_TREE);\n-\t      off = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n-\t\t\t   NULL_TREE);\n-\t      if (rsize > UNITS_PER_WORD)\n-\t\t{\n-\t\t  /* [1] Emit code for: off &= -rsize.\t*/\n-\t\t  t = build (BIT_AND_EXPR, TREE_TYPE (off), off,\n-\t\t\t     build_int_2 (-rsize, -1));\n-\t\t  t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n-\t\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t\t}\n-\t      osize = rsize;\n-\t    }\n-\n-\t  /* [2] Emit code to branch if off == 0.  */\n-\t  r = expand_expr (off, NULL_RTX, TYPE_MODE (TREE_TYPE (off)),\n-\t\t\t   EXPAND_NORMAL);\n-\t  emit_cmp_and_jump_insns (r, const0_rtx, EQ, const1_rtx, GET_MODE (r),\n-\t\t\t\t   1, lab_false);\n-\n-\t  /* [4] Emit code for: addr_rtx = top - off.  On big endian machines,\n-\t     the argument has RSIZE - SIZE bytes of leading padding.  */\n-\t  t = build (MINUS_EXPR, TREE_TYPE (top), top, off);\n-\t  if (BYTES_BIG_ENDIAN && rsize > size)\n-\t    t = build (PLUS_EXPR, TREE_TYPE (t), t,\n-\t\t       build_int_2 (rsize - size, 0));\n-\t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != addr_rtx)\n-\t    emit_move_insn (addr_rtx, r);\n-\n-\t  /* [5] Emit code for: off -= rsize.  */\n-\t  t = build (MINUS_EXPR, TREE_TYPE (off), off, build_int_2 (rsize, 0));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-\t  /* [7] Emit code to jump over the else clause, then the label\n-\t     that starts it.  */\n-\t  emit_queue();\n-\t  emit_jump (lab_over);\n-\t  emit_barrier ();\n-\t  emit_label (lab_false);\n+\t  osize = rsize;\n+\t}\n \n-\t  if (osize > UNITS_PER_WORD)\n-\t    {\n-\t      /* [9] Emit: ovfl += ((intptr_t) ovfl + osize - 1) & -osize.  */\n-\t      t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl,\n-\t\t\t build_int_2 (osize - 1, 0));\n-\t      t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), t,\n-\t\t\t build_int_2 (-osize, -1));\n-\t      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n-\t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t    }\n+      /* [2] Emit code to branch if off == 0.  */\n+      t = lang_hooks.truthvalue_conversion (off);\n+      addr = build (COND_EXPR, ptr_type_node, t, NULL, NULL);\n+\n+      /* [5] Emit code for: off -= rsize.  We do this as a form of\n+\t post-increment not available to C.  Also widen for the\n+\t coming pointer arithmetic.  */\n+      t = fold_convert (TREE_TYPE (off), build_int_2 (rsize, 0));\n+      t = build (POSTDECREMENT_EXPR, TREE_TYPE (off), off, t);\n+      t = fold_convert (sizetype, t);\n+      t = fold_convert (TREE_TYPE (top), t);\n+\n+      /* [4] Emit code for: addr_rtx = top - off.  On big endian machines,\n+\t the argument has RSIZE - SIZE bytes of leading padding.  */\n+      t = build (MINUS_EXPR, TREE_TYPE (top), top, t);\n+      if (BYTES_BIG_ENDIAN && rsize > size)\n+\t{\n+\t  u = fold_convert (TREE_TYPE (t), build_int_2 (rsize - size, 0));\n+\t  t = build (PLUS_EXPR, TREE_TYPE (t), t, u);\n+\t}\n+      COND_EXPR_THEN (addr) = t;\n \n-\t  /* [10, 11].\tEmit code to store ovfl in addr_rtx, then\n-\t     post-increment ovfl by osize.  On big-endian machines,\n-\t     the argument has OSIZE - SIZE bytes of leading padding.  */\n-\t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl,\n-\t\t     size_int (osize));\n-\t  if (BYTES_BIG_ENDIAN && osize > size)\n-\t    t = build (PLUS_EXPR, TREE_TYPE (t), t,\n-\t\t       build_int_2 (osize - size, 0));\n-\t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n-\t  if (r != addr_rtx)\n-\t    emit_move_insn (addr_rtx, r);\n-\n-\t  emit_queue();\n-\t  emit_label (lab_over);\n+      if (osize > UNITS_PER_WORD)\n+\t{\n+\t  /* [9] Emit: ovfl += ((intptr_t) ovfl + osize - 1) & -osize.  */\n+\t  u = fold_convert (TREE_TYPE (ovfl), build_int_2 (osize - 1, 0));\n+\t  t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, u);\n+\t  u = fold_convert (TREE_TYPE (ovfl), build_int_2 (-osize, -1));\n+\t  t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), t, u);\n+\t  align = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n \t}\n-      if (indirect)\n+      else\n+\talign = NULL;\n+\n+      /* [10, 11].\tEmit code to store ovfl in addr_rtx, then\n+\t post-increment ovfl by osize.  On big-endian machines,\n+\t the argument has OSIZE - SIZE bytes of leading padding.  */\n+      u = fold_convert (TREE_TYPE (ovfl), build_int_2 (osize, 0));\n+      t = build (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl, u);\n+      if (BYTES_BIG_ENDIAN && osize > size)\n \t{\n-\t  addr_rtx = force_reg (Pmode, addr_rtx);\n-\t  r = gen_rtx_MEM (Pmode, addr_rtx);\n-\t  set_mem_alias_set (r, get_varargs_alias_set ());\n-\t  emit_move_insn (addr_rtx, r);\n+\t  u = fold_convert (TREE_TYPE (t), build_int_2 (osize - size, 0));\n+\t  t = build (PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n-      return addr_rtx;\n-    }\n-  else\n-    {\n-      /* Not EABI.  */\n-      int align;\n-      HOST_WIDE_INT min_offset;\n \n-      /* ??? The original va-mips.h did always align, despite the fact\n-\t that alignments <= UNITS_PER_WORD are preserved by the va_arg\n-\t increment mechanism.  */\n+      /* String [9] and [10,11] together.  */\n+      if (align)\n+\tt = build (COMPOUND_EXPR, TREE_TYPE (t), align, t);\n+      COND_EXPR_ELSE (addr) = t;\n \n-      if (TARGET_NEWABI && TYPE_ALIGN (type) > 64)\n-\talign = 16;\n-      else if (TARGET_64BIT)\n-\talign = 8;\n-      else if (TYPE_ALIGN (type) > 32)\n-\talign = 8;\n-      else\n-\talign = 4;\n-\n-      t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t build_int_2 (align - 1, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n-\n-      /* If arguments of type TYPE must be passed on the stack,\n-\t set MIN_OFFSET to the offset of the first stack parameter.  */\n-      if (!targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n-\tmin_offset = 0;\n-      else if (TARGET_NEWABI)\n-\tmin_offset = current_function_pretend_args_size;\n-      else\n-\tmin_offset = REG_PARM_STACK_SPACE (current_function_decl);\n-\n-      /* Make sure the new address is at least MIN_OFFSET bytes from\n-\t the incoming argument pointer.  */\n-      if (min_offset > 0)\n-\tt = build (MAX_EXPR, TREE_TYPE (valist), t,\n-\t\t   make_tree (TREE_TYPE (valist),\n-\t\t\t      plus_constant (virtual_incoming_args_rtx,\n-\t\t\t\t\t     min_offset)));\n+      addr = fold_convert (build_pointer_type (type), addr);\n+      addr = build_fold_indirect_ref (addr);\n+    }\n \n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (indirect)\n+    addr = build_fold_indirect_ref (addr);\n \n-      /* Everything past the alignment is standard.  */\n-      return std_expand_builtin_va_arg (valist, type);\n-    }\n+  return addr;\n }\n \f\n /* Return true if it is possible to use left/right accesses for a\n@@ -7425,18 +7329,22 @@ function_arg_pass_by_reference (const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\t\tenum machine_mode mode, tree type,\n \t\t\t\tint named ATTRIBUTE_UNUSED)\n {\n-  int size;\n-\n-  /* The EABI is the only one to pass args by reference.  */\n-  if (mips_abi != ABI_EABI)\n-    return 0;\n+  if (mips_abi == ABI_EABI)\n+    {\n+      int size;\n \n-  /* ??? How should SCmode be handled?  */\n-  if (type == NULL_TREE || mode == DImode || mode == DFmode)\n-    return 0;\n+      /* ??? How should SCmode be handled?  */\n+      if (type == NULL_TREE || mode == DImode || mode == DFmode)\n+\treturn 0;\n \n-  size = int_size_in_bytes (type);\n-  return size == -1 || size > UNITS_PER_WORD;\n+      size = int_size_in_bytes (type);\n+      return size == -1 || size > UNITS_PER_WORD;\n+    }\n+  else\n+    {\n+      /* If we have a variable-sized parameter, we have no choice.  */\n+      return targetm.calls.must_pass_in_stack (mode, type);\n+    }\n }\n \n /* Return the class of registers for which a mode change from FROM to TO"}, {"sha": "3517780481234ab794027e0419f23b02c33e7c6f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0310e5373b19d2d5edeb37c4cd4a4ff1af1da4cd", "patch": "@@ -2387,10 +2387,6 @@ typedef struct mips_args {\n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n   mips_va_start (valist, nextarg)\n-\n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  mips_va_arg (valist, type)\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */"}]}