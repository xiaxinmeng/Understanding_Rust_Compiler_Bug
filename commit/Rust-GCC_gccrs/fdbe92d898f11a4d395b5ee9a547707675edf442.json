{"sha": "fdbe92d898f11a4d395b5ee9a547707675edf442", "node_id": "C_kwDOANBUbNoAKGZkYmU5MmQ4OThmMTFhNGQzOTViNWVlOWE1NDc3MDc2NzVlZGY0NDI", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-29T05:14:41Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:25Z"}, "message": "rust-constexpr.cc: port over NOP_EXPR case and fold_indrect_ref_1()", "tree": {"sha": "5ef9a236a990647f31425ad55a6326863c7cf01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ef9a236a990647f31425ad55a6326863c7cf01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdbe92d898f11a4d395b5ee9a547707675edf442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbe92d898f11a4d395b5ee9a547707675edf442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdbe92d898f11a4d395b5ee9a547707675edf442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbe92d898f11a4d395b5ee9a547707675edf442/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23bde7d7c663302c803f0a7e4324630eae825008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23bde7d7c663302c803f0a7e4324630eae825008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23bde7d7c663302c803f0a7e4324630eae825008"}], "stats": {"total": 153, "additions": 153, "deletions": 0}, "files": [{"sha": "1244047ef4f656a0e17aac9a92b19e59037ab30d", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbe92d898f11a4d395b5ee9a547707675edf442/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbe92d898f11a4d395b5ee9a547707675edf442/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=fdbe92d898f11a4d395b5ee9a547707675edf442", "patch": "@@ -697,6 +697,29 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      if (jump_target)\n+\t*jump_target = t;\n+      else\n+\t{\n+\t  /* Can happen with ({ return true; }) && false; passed to\n+\t     maybe_constant_value.  There is nothing to jump over in this\n+\t     case, and the bug will be diagnosed later.  */\n+\t  gcc_assert (ctx->quiet);\n+\t  *non_constant_p = true;\n+\t}\n+      break;\n+\n+    case NOP_EXPR:\n+      if (REINTERPRET_CAST_P (t))\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error_at (loc, \"%<reinterpret_cast%> is not a constant expression\");\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+\n     case MODIFY_EXPR:\n       r = eval_store_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n@@ -3032,6 +3055,132 @@ eval_unary_expression (const constexpr_ctx *ctx, tree t, bool /*lval*/,\n   return r;\n }\n \n+// forked from gcc/cp/constexpr.cc cxx_union_active_member\n+\n+/* Try to determine the currently active union member for an expression\n+   with UNION_TYPE.  If it can be determined, return the FIELD_DECL,\n+   otherwise return NULL_TREE.  */\n+\n+static tree\n+union_active_member (const constexpr_ctx *ctx, tree t)\n+{\n+  constexpr_ctx new_ctx = *ctx;\n+  new_ctx.quiet = true;\n+  bool non_constant_p = false, overflow_p = false;\n+  tree ctor = eval_constant_expression (&new_ctx, t, false, &non_constant_p,\n+\t\t\t\t\t&overflow_p);\n+  if (TREE_CODE (ctor) == CONSTRUCTOR && CONSTRUCTOR_NELTS (ctor) == 1\n+      && CONSTRUCTOR_ELT (ctor, 0)->index\n+      && TREE_CODE (CONSTRUCTOR_ELT (ctor, 0)->index) == FIELD_DECL)\n+    return CONSTRUCTOR_ELT (ctor, 0)->index;\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/constexpr.cc cxx_fold_indirect_ref_1\n+\n+static tree\n+fold_indirect_ref_1 (const constexpr_ctx *ctx, location_t loc, tree type,\n+\t\t     tree op, unsigned HOST_WIDE_INT off, bool *empty_base)\n+{\n+  tree optype = TREE_TYPE (op);\n+  unsigned HOST_WIDE_INT const_nunits;\n+  if (off == 0 && similar_type_p (optype, type))\n+    return op;\n+  else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t   && similar_type_p (type, TREE_TYPE (optype)))\n+    {\n+      /* *(foo *)&complexfoo => __real__ complexfoo */\n+      if (off == 0)\n+\treturn build1_loc (loc, REALPART_EXPR, type, op);\n+      /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+      else if (tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n+\treturn build1_loc (loc, IMAGPART_EXPR, type, op);\n+    }\n+  /* ((foo*)&vectorfoo)[x] => BIT_FIELD_REF<vectorfoo,...> */\n+  else if (VECTOR_TYPE_P (optype) && similar_type_p (type, TREE_TYPE (optype))\n+\t   && TYPE_VECTOR_SUBPARTS (optype).is_constant (&const_nunits))\n+    {\n+      unsigned HOST_WIDE_INT part_width = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+      unsigned HOST_WIDE_INT max_offset = part_width * const_nunits;\n+      if (off < max_offset && off % part_width == 0)\n+\t{\n+\t  tree index = bitsize_int (off * BITS_PER_UNIT);\n+\t  return build3_loc (loc, BIT_FIELD_REF, type, op, TYPE_SIZE (type),\n+\t\t\t     index);\n+\t}\n+    }\n+  /* ((foo *)&fooarray)[x] => fooarray[x] */\n+  else if (TREE_CODE (optype) == ARRAY_TYPE\n+\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (optype)))\n+\t   && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (optype))))\n+    {\n+      tree type_domain = TYPE_DOMAIN (optype);\n+      tree min_val = size_zero_node;\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\tmin_val = TYPE_MIN_VALUE (type_domain);\n+      unsigned HOST_WIDE_INT el_sz\n+\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (optype)));\n+      unsigned HOST_WIDE_INT idx = off / el_sz;\n+      unsigned HOST_WIDE_INT rem = off % el_sz;\n+      if (tree_fits_uhwi_p (min_val))\n+\t{\n+\t  tree index = size_int (idx + tree_to_uhwi (min_val));\n+\t  op = build4_loc (loc, ARRAY_REF, TREE_TYPE (optype), op, index,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+\t  return fold_indirect_ref_1 (ctx, loc, type, op, rem, empty_base);\n+\t}\n+    }\n+  /* ((foo *)&struct_with_foo_field)[x] => COMPONENT_REF */\n+  else if (TREE_CODE (optype) == RECORD_TYPE\n+\t   || TREE_CODE (optype) == UNION_TYPE)\n+    {\n+      if (TREE_CODE (optype) == UNION_TYPE)\n+\t/* For unions prefer the currently active member.  */\n+\tif (tree field = union_active_member (ctx, op))\n+\t  {\n+\t    unsigned HOST_WIDE_INT el_sz\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (off < el_sz)\n+\t      {\n+\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field), op, field,\n+\t\t\t\t   NULL_TREE);\n+\t\tif (tree ret = fold_indirect_ref_1 (ctx, loc, type, cop, off,\n+\t\t\t\t\t\t    empty_base))\n+\t\t  return ret;\n+\t      }\n+\t  }\n+      for (tree field = TYPE_FIELDS (optype); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && TREE_TYPE (field) != error_mark_node\n+\t    && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (field))))\n+\t  {\n+\t    tree pos = byte_position (field);\n+\t    if (!tree_fits_uhwi_p (pos))\n+\t      continue;\n+\t    unsigned HOST_WIDE_INT upos = tree_to_uhwi (pos);\n+\t    unsigned HOST_WIDE_INT el_sz\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (upos <= off && off < upos + el_sz)\n+\t      {\n+\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field), op, field,\n+\t\t\t\t   NULL_TREE);\n+\t\tif (tree ret = fold_indirect_ref_1 (ctx, loc, type, cop,\n+\t\t\t\t\t\t    off - upos, empty_base))\n+\t\t  return ret;\n+\t      }\n+\t  }\n+      /* Also handle conversion to an empty base class, which\n+\t is represented with a NOP_EXPR.  */\n+      if (is_empty_class (type) && CLASS_TYPE_P (optype))\n+\t{\n+\t  *empty_base = true;\n+\t  return op;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}, {"sha": "b7c4676f0ab3a1b49557569e0e19ebcdfea7759f", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbe92d898f11a4d395b5ee9a547707675edf442/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbe92d898f11a4d395b5ee9a547707675edf442/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=fdbe92d898f11a4d395b5ee9a547707675edf442", "patch": "@@ -1244,6 +1244,10 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    in constructors/destructors of targetm.cxx.cdtor_returns_this targets.  */\n #define LABEL_DECL_CDTOR(NODE) DECL_LANG_FLAG_2 (LABEL_DECL_CHECK (NODE))\n \n+/* Nonzero if this NOP_EXPR is a reinterpret_cast.  Such conversions\n+   are not constexprs.  Other NOP_EXPRs are.  */\n+#define REINTERPRET_CAST_P(NODE) TREE_LANG_FLAG_0 (NOP_EXPR_CHECK (NODE))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\"}]}