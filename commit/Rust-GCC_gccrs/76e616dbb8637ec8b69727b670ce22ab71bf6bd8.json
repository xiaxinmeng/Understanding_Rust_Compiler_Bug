{"sha": "76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZlNjE2ZGJiODYzN2VjOGI2OTcyN2I2NzBjZTIyYWI3MWJmNmJkOA==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1993-01-09T01:58:44Z"}, "committer": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1993-01-09T01:58:44Z"}, "message": "Initial revision\n\nFrom-SVN: r3161", "tree": {"sha": "a86f0e1e02541c776986d9cae017b23929e60f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86f0e1e02541c776986d9cae017b23929e60f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76e616dbb8637ec8b69727b670ce22ab71bf6bd8/comments", "author": null, "committer": null, "parents": [{"sha": "c6dc70d681151224404b31dc86e2071e2b20b04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6dc70d681151224404b31dc86e2071e2b20b04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6dc70d681151224404b31dc86e2071e2b20b04c"}], "stats": {"total": 373, "additions": 373, "deletions": 0}, "files": [{"sha": "c67f510188c201d7c4770dc6727d59cd018e5285", "filename": "gcc/convert.c", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e616dbb8637ec8b69727b670ce22ab71bf6bd8/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e616dbb8637ec8b69727b670ce22ab71bf6bd8/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "patch": "@@ -0,0 +1,370 @@\n+/* Utility routines for data type conversion for GNU C.\n+   Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU C.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* These routines are somewhat language-independent utility function\n+   intended to be called by the language-specific convert () functions. */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"convert.h\"\n+\n+/* Convert EXPR to some pointer type TYPE.\n+\n+   EXPR must be pointer, integer, enumeral, or literal zero;\n+   in other cases error is called. */\n+\n+tree\n+convert_to_pointer (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+  \n+  if (integer_zerop (expr))\n+    {\n+      if (type == TREE_TYPE (null_pointer_node))\n+\treturn null_pointer_node;\n+      expr = build_int_2 (0, 0);\n+      TREE_TYPE (expr) = type;\n+      return expr;\n+    }\n+\n+  if (form == POINTER_TYPE)\n+    return build1 (NOP_EXPR, type, expr);\n+\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+    {\n+      if (type_precision (intype) == POINTER_SIZE)\n+\treturn build1 (CONVERT_EXPR, type, expr);\n+      expr = convert (type_for_size (POINTER_SIZE, 0), expr);\n+      if (TYPE_MODE (TREE_TYPE (expr)) != TYPE_MODE (type))\n+\t/* There is supposed to be some integral type\n+\t   that is the same width as a pointer.  */\n+\tabort ();\n+      return convert_to_pointer (type, expr);\n+    }\n+\n+  error (\"cannot convert to a pointer type\");\n+\n+  return null_pointer_node;\n+}\n+\n+/* Convert EXPR to some floating-point type TYPE.\n+\n+   EXPR must be float, integer, or enumeral;\n+   in other cases error is called. */\n+\n+tree\n+convert_to_real (type, expr)\n+     tree type, expr;\n+{\n+  register enum tree_code form = TREE_CODE (TREE_TYPE (expr));\n+\n+  if (form == REAL_TYPE)\n+    return build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n+\t\t   type, expr);\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE)\n+    return build1 (FLOAT_EXPR, type, expr);\n+\n+  if (form == POINTER_TYPE)\n+    error (\"pointer value used where a floating point value was expected\");\n+  else\n+    error (\"aggregate value used where a float was expected\");\n+\n+  {\n+    register tree tem = make_node (REAL_CST);\n+    TREE_TYPE (tem) = type;\n+    TREE_REAL_CST (tem) = REAL_VALUE_ATOF (\"0.0\");\n+    return tem;\n+  }\n+}\n+\n+/* Convert EXPR to some integer (or enum) type TYPE.\n+\n+   EXPR must be pointer, integer, discrete (enum, char, or bool), or float;\n+   in other cases error is called.\n+\n+   The result of this is always supposed to be a newly created tree node\n+   not in use in any existing structure.  */\n+\n+tree\n+convert_to_integer (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum tree_code form = TREE_CODE (intype);\n+\n+  if (form == POINTER_TYPE)\n+    {\n+      if (integer_zerop (expr))\n+\texpr = integer_zero_node;\n+      else\n+\texpr = fold (build1 (CONVERT_EXPR,\n+\t\t\t     type_for_size (POINTER_SIZE, 0), expr));\n+      intype = TREE_TYPE (expr);\n+      form = TREE_CODE (intype);\n+      if (intype == type)\n+\treturn expr;\n+    }\n+\n+  if (form == INTEGER_TYPE || form == ENUMERAL_TYPE\n+      || form == BOOLEAN_TYPE || form == CHAR_TYPE)\n+    {\n+      register unsigned outprec = TYPE_PRECISION (type);\n+      register unsigned inprec = TYPE_PRECISION (intype);\n+      register enum tree_code ex_form = TREE_CODE (expr);\n+\n+      /* If we are widening the type, put in an explicit conversion.\n+\t Similarly if we are not changing the width.  However, if this is\n+\t a logical operation that just returns 0 or 1, we can change the\n+\t type of the expression (see below).  */\n+\n+      if (TREE_CODE_CLASS (ex_form) == '<'\n+\t  || ex_form == TRUTH_AND_EXPR || ex_form == TRUTH_ANDIF_EXPR\n+\t  || ex_form == TRUTH_OR_EXPR || ex_form == TRUTH_ORIF_EXPR\n+\t  || ex_form == TRUTH_XOR_EXPR || ex_form == TRUTH_NOT_EXPR)\n+\t{\n+\t  TREE_TYPE (expr) = type;\n+\t  return expr;\n+\t}\n+      else if (outprec >= inprec)\n+\treturn build1 (NOP_EXPR, type, expr);\n+\n+/* Here detect when we can distribute the truncation down past some arithmetic.\n+   For example, if adding two longs and converting to an int,\n+   we can equally well convert both to ints and then add.\n+   For the operations handled here, such truncation distribution\n+   is always safe.\n+   It is desirable in these cases:\n+   1) when truncating down to full-word from a larger size\n+   2) when truncating takes no work.\n+   3) when at least one operand of the arithmetic has been extended\n+   (as by C's default conversions).  In this case we need two conversions\n+   if we do the arithmetic as already requested, so we might as well\n+   truncate both and then combine.  Perhaps that way we need only one.\n+\n+   Note that in general we cannot do the arithmetic in a type\n+   shorter than the desired result of conversion, even if the operands\n+   are both extended from a shorter type, because they might overflow\n+   if combined in that type.  The exceptions to this--the times when\n+   two narrow values can be combined in their narrow type even to\n+   make a wider result--are handled by \"shorten\" in build_binary_op.  */\n+\n+      switch (ex_form)\n+\t{\n+\tcase RSHIFT_EXPR:\n+\t  /* We can pass truncation down through right shifting\n+\t     when the shift count is a nonpositive constant.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n+\t      && tree_int_cst_lt (TREE_OPERAND (expr, 1), integer_one_node))\n+\t    goto trunc1;\n+\t  break;\n+\n+\tcase LSHIFT_EXPR:\n+\t  /* We can pass truncation down through left shifting\n+\t     when the shift count is a nonnegative constant.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n+\t      && ! tree_int_cst_lt (TREE_OPERAND (expr, 1), integer_zero_node)\n+\t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n+\t    {\n+\t      /* If shift count is less than the width of the truncated type,\n+\t\t really shift.  */\n+\t      if (tree_int_cst_lt (TREE_OPERAND (expr, 1), TYPE_SIZE (type)))\n+\t\t/* In this case, shifting is like multiplication.  */\n+\t\tgoto trunc1;\n+\t      else\n+\t\t/* If it is >= that width, result is zero.\n+\t\t   Handling this with trunc1 would give the wrong result:\n+\t\t   (int) ((long long) a << 32) is well defined (as 0)\n+\t\t   but (int) a << 32 is undefined and would get a warning.  */\n+\t\treturn convert_to_integer (type, integer_zero_node);\n+\t    }\n+\t  break;\n+\n+\tcase MAX_EXPR:\n+\tcase MIN_EXPR:\n+\tcase MULT_EXPR:\n+\t  {\n+\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t    /* Don't distribute unless the output precision is at least as big\n+\t       as the actual inputs.  Otherwise, the comparison of the\n+\t       truncated values will be wrong.  */\n+\t    if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t&& outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n+\t\t/* If signedness of arg0 and arg1 don't match,\n+\t\t   we can't necessarily find a type to compare them in.  */\n+\t\t&& (TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t    == TREE_UNSIGNED (TREE_TYPE (arg1))))\n+\t      goto trunc1;\n+\t    break;\n+\t  }\n+\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\tcase BIT_AND_EXPR:\n+\tcase BIT_IOR_EXPR:\n+\tcase BIT_XOR_EXPR:\n+\tcase BIT_ANDTC_EXPR:\n+\ttrunc1:\n+\t  {\n+\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t    if (outprec >= BITS_PER_WORD\n+\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1)))\n+\t      {\n+\t\t/* Do the arithmetic in type TYPEX,\n+\t\t   then convert result to TYPE.  */\n+\t\tregister tree typex = type;\n+\n+\t\t/* Can't do arithmetic in enumeral types\n+\t\t   so use an integer type that will hold the values.  */\n+\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t\t  typex = type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t TREE_UNSIGNED (typex));\n+\n+\t\t/* But now perhaps TYPEX is as wide as INPREC.\n+\t\t   In that case, do nothing special here.\n+\t\t   (Otherwise would recurse infinitely in convert.  */\n+\t\tif (TYPE_PRECISION (typex) != inprec)\n+\t\t  {\n+\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n+\t\t       or vice versa.\n+\t\t       Exception: if either of the original operands were\n+\t\t       unsigned then can safely do the work as unsigned.\n+\t\t       And we may need to do it as unsigned\n+\t\t       if we truncate to the original size.  */\n+\t\t    typex = ((TREE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t      || TREE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t\t      || TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\t\t     ? unsigned_type (typex) : signed_type (typex));\n+\t\t    return convert (type,\n+\t\t\t\t    build_binary_op (ex_form,\n+\t\t\t\t\t\t     convert (typex, arg0),\n+\t\t\t\t\t\t     convert (typex, arg1),\n+\t\t\t\t\t\t     0));\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase NEGATE_EXPR:\n+\tcase BIT_NOT_EXPR:\n+\tcase ABS_EXPR:\n+\t  {\n+\t    register tree typex = type;\n+\n+\t    /* Can't do arithmetic in enumeral types\n+\t       so use an integer type that will hold the values.  */\n+\t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t      typex = type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t     TREE_UNSIGNED (typex));\n+\n+\t    /* But now perhaps TYPEX is as wide as INPREC.\n+\t       In that case, do nothing special here.\n+\t       (Otherwise would recurse infinitely in convert.  */\n+\t    if (TYPE_PRECISION (typex) != inprec)\n+\t      {\n+\t\t/* Don't do unsigned arithmetic where signed was wanted,\n+\t\t   or vice versa.  */\n+\t\ttypex = (TREE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t ? unsigned_type (typex) : signed_type (typex));\n+\t\treturn convert (type,\n+\t\t\t\tbuild_unary_op (ex_form,\n+\t\t\t\t\t\tconvert (typex, TREE_OPERAND (expr, 0)),\n+\t\t\t\t\t\t1));\n+\t      }\n+\t  }\n+\n+\tcase NOP_EXPR:\n+\t  /* If truncating after truncating, might as well do all at once.\n+\t     If truncating after extending, we may get rid of wasted work.  */\n+\t  return convert (type, get_unwidened (TREE_OPERAND (expr, 0), type));\n+\n+\tcase COND_EXPR:\n+\t  /* Can treat the two alternative values like the operands\n+\t     of an arithmetic expression.  */\n+\t  {\n+\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\t    tree arg2 = get_unwidened (TREE_OPERAND (expr, 2), type);\n+\n+\t    if (outprec >= BITS_PER_WORD\n+\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1))\n+\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg2)))\n+\t      {\n+\t\t/* Do the arithmetic in type TYPEX,\n+\t\t   then convert result to TYPE.  */\n+\t\tregister tree typex = type;\n+\n+\t\t/* Can't do arithmetic in enumeral types\n+\t\t   so use an integer type that will hold the values.  */\n+\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t\t  typex = type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t TREE_UNSIGNED (typex));\n+\n+\t\t/* But now perhaps TYPEX is as wide as INPREC.\n+\t\t   In that case, do nothing special here.\n+\t\t   (Otherwise would recurse infinitely in convert.  */\n+\t\tif (TYPE_PRECISION (typex) != inprec)\n+\t\t  {\n+\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n+\t\t       or vice versa.  */\n+\t\t    typex = (TREE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t     ? unsigned_type (typex) : signed_type (typex));\n+\t\t    return convert (type,\n+\t\t\t\t    fold (build (COND_EXPR, typex,\n+\t\t\t\t\t\t TREE_OPERAND (expr, 0),\n+\t\t\t\t\t\t convert (typex, arg1),\n+\t\t\t\t\t\t convert (typex, arg2))));\n+\t\t  }\n+\t\telse\n+\t\t  /* It is sometimes worthwhile\n+\t\t     to push the narrowing down through the conditional.  */\n+\t\t  return fold (build (COND_EXPR, type,\n+\t\t\t\t      TREE_OPERAND (expr, 0),\n+\t\t\t\t      convert (type, TREE_OPERAND (expr, 1)), \n+\t\t\t\t      convert (type, TREE_OPERAND (expr, 2))));\n+\t      }\n+\t  }\n+\n+\t}\n+\n+      return build1 (NOP_EXPR, type, expr);\n+    }\n+\n+  if (form == REAL_TYPE)\n+    return build1 (FIX_TRUNC_EXPR, type, expr);\n+\n+  error (\"aggregate value used where an integer was expected\");\n+\n+  {\n+    register tree tem = build_int_2 (0, 0);\n+    TREE_TYPE (tem) = type;\n+    return tem;\n+  }\n+}"}, {"sha": "5e54da36038b9f4a363e262718bcaff2358f3932", "filename": "gcc/convert.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76e616dbb8637ec8b69727b670ce22ab71bf6bd8/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76e616dbb8637ec8b69727b670ce22ab71bf6bd8/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=76e616dbb8637ec8b69727b670ce22ab71bf6bd8", "patch": "@@ -0,0 +1,3 @@\n+extern tree convert_to_integer PROTO ((tree, tree));\n+extern tree convert_to_pointer PROTO ((tree, tree));\n+extern tree convert_to_real PROTO ((tree, tree));"}]}