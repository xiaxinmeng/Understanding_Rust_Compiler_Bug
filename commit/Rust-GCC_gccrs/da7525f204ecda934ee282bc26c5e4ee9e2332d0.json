{"sha": "da7525f204ecda934ee282bc26c5e4ee9e2332d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3NTI1ZjIwNGVjZGE5MzRlZTI4MmJjMjZjNWU0ZWU5ZTIzMzJkMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-28T10:15:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-08-28T10:15:04Z"}, "message": "entered into RCS\n\nFrom-SVN: r10287", "tree": {"sha": "62aeb34a9d29b0d343001346900f126f758dd37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62aeb34a9d29b0d343001346900f126f758dd37f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da7525f204ecda934ee282bc26c5e4ee9e2332d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7525f204ecda934ee282bc26c5e4ee9e2332d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da7525f204ecda934ee282bc26c5e4ee9e2332d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7525f204ecda934ee282bc26c5e4ee9e2332d0/comments", "author": null, "committer": null, "parents": [{"sha": "1729466fdab5e694a62868be3c54723f9b569294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1729466fdab5e694a62868be3c54723f9b569294", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1729466fdab5e694a62868be3c54723f9b569294"}], "stats": {"total": 574, "additions": 574, "deletions": 0}, "files": [{"sha": "ac4719d0493ffd1a57da50704a805e2b466e83d5", "filename": "gcc/README.DWARF", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7525f204ecda934ee282bc26c5e4ee9e2332d0/gcc%2FREADME.DWARF", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7525f204ecda934ee282bc26c5e4ee9e2332d0/gcc%2FREADME.DWARF", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.DWARF?ref=da7525f204ecda934ee282bc26c5e4ee9e2332d0", "patch": "@@ -0,0 +1,574 @@\n+Notes on the GNU Implementation of DWARF Debugging Information\n+--------------------------------------------------------------\n+Last Updated: Sun Jul 17 08:17:42 PDT 1994 by rfg@segfault.us.com\n+------------------------------------------------------------\n+\n+This file describes special and unique aspects of the GNU implementation\n+of the DWARF debugging information language, as provided in the GNU version\n+2.x compiler(s).\n+\n+For general information about the DWARF debugging information language,\n+you should obtain the DWARF version 1 specification document (and perhaps\n+also the DWARF version 2 draft specification document) developed by the\n+UNIX International Programming Languages Special Interest Group.  A copy\n+of the the DWARF version 1 specification (in PostScript form) may be\n+obtained either from me <rfg@netcom.com> or from the main Data General\n+FTP server.  (See below.)  The file you are looking at now only describes\n+known deviations from the DWARF version 1 specification, together with\n+those things which are allowed by the DWARF version 1 specification but\n+which are known to cause interoperability problems (e.g. with SVR4 SDB).\n+\n+To obtain a copy of the DWARF Version 1 and/or DWARF Version 2 specification\n+from Data General's FTP server, use the following procedure:\n+\n+---------------------------------------------------------------------------\n+\tftp to machine: \"dg-rtp.dg.com\" (128.222.1.2).  \n+ \n+\tLog in as \"ftp\".\n+\tcd to \"plsig\"\n+\tget any of the following file you are interested in:\n+ \n+\tdwarf.1.0.3.ps\n+\tdwarf.2.0.0.index.ps\n+\tdwarf.2.0.0.ps\n+---------------------------------------------------------------------------\n+\n+The generation of DWARF debugging information by the GNU version 2.x C\n+compiler has now been tested rather extensively for m88k, i386, i860, and\n+Sparc targets.  The DWARF output of the GNU C compiler appears to inter-\n+operate well with the standard SVR4 SDB debugger on these kinds of target\n+systems (but of course, there are no guarantees).\n+\n+DWARF generation for the GNU g++ compiler is still not operable.  This is\n+due primarily to the many remaining cases where the g++ front end does not\n+conform to the conventions used in the GNU C front end for representing\n+various kinds of declarations in the TREE data structure.  It is not clear\n+at this time how these problems will be addressed.\n+\n+Future plans for the dwarfout.c module of the GNU compiler(s) includes the\n+addition of full support for GNU FORTRAN.  (This should, in theory, be a\n+lot simpler to add than adding support for g++... but we'll see.)\n+\n+Many features of the DWARF version 2 specification have been adapted to\n+(and used in) the GNU implementation of DWARF (version 1).  In most of\n+these cases, a DWARF version 2 approach is used in place of (or in addition\n+to) DWARF version 1 stuff simply because it is apparent that DWARF version\n+1 is not sufficiently expressive to provide the kinds of information which\n+may be necessary to support really robust debugging.  In all of these cases\n+however, the use of DWARF version 2 features should not interfere in any\n+way with the interoperability (of GNU compilers) with generally available\n+\"classic\" (pre version 1) DWARF consumer tools (e.g. SVR4 SDB).\n+\n+The DWARF generation enhancement for the GNU compiler(s) was initially\n+donated to the Free Software Foundation by Network Computing Devices.\n+(Thanks NCD!) Additional development and maintenance of dwarfout.c has\n+been largely supported (i.e. funded) by Intel Corporation.  (Thanks Intel!)\n+\n+If you have questions or comments about the DWARF generation feature, please\n+send mail to me <rfg@netcom.com>.  I will be happy to investigate any bugs\n+reported and I may even provide fixes (but of course, I can make no promises).\n+\n+The DWARF debugging information produced by GCC may deviate in a few minor\n+(but perhaps significant) respects from the DWARF debugging information\n+currently produced by other C compilers.  A serious attempt has been made\n+however to conform to the published specifications, to existing practice,\n+and to generally accepted norms in the GNU implementation of DWARF.\n+\n+    ** IMPORTANT NOTE **    ** IMPORTANT NOTE **    ** IMPORTANT NOTE **\n+\n+Under normal circumstances, the DWARF information generated by the GNU\n+compilers (in an assembly language file) is essentially impossible for\n+a human being to read.  This fact can make it very difficult to debug\n+certain DWARF-related problems.  In order to overcome this difficulty,\n+a feature has been added to dwarfout.c (enabled by the -fverbose-asm\n+option) which causes additional comments to be placed into the assembly\n+language output file, out to the right-hand side of most bits of DWARF\n+material.  The comments indicate (far more clearly that the obscure\n+DWARF hex codes do) what is actually being encoded in DWARF.  Thus, the\n+-fverbose-asm option can be highly useful for those who must study the\n+DWARF output from the GNU compilers in detail.\n+\n+---------\n+\n+(Footnote: Within this file, the term `Debugging Information Entry' will\n+be abbreviated as `DIE'.)\n+\n+\n+Release Notes  (aka known bugs)\n+-------------------------------\n+\n+In one very obscure case involving dynamically sized arrays, the DWARF\n+\"location information\" for such an array may make it appear that the\n+array has been totally optimized out of existence, when in fact it\n+*must* actually exist.  (This only happens when you are using *both* -g\n+*and* -O.)  This is due to aggressive dead store elimination in the\n+compiler, and to the fact that the DECL_RTL expressions associated with\n+variables are not always updated to correctly reflect the effects of\n+GCC's aggressive dead store elimination.\n+\n+-------------------------------\n+\n+When attempting to set a breakpoint at the \"start\" of a function compiled\n+with -g1, the debugger currently has no way of knowing exactly where the\n+end of the prologue code for the function is.  Thus, for most targets,\n+all the debugger can do is to set the breakpoint at the AT_low_pc address\n+for the function.  But if you stop there and then try to look at one or\n+more of the formal parameter values, they may not have been \"homed\" yet,\n+so you may get inaccurate answers (or perhaps even addressing errors).\n+\n+Some people may consider this simply a non-feature, but I consider it a\n+bug, and I hope to provide some some GNU-specific attributes (on function\n+DIEs) which will specify the address of the end of the prologue and the\n+address of the beginning of the epilogue in a future release.\n+\n+-------------------------------\n+\n+It is believed at this time that old bugs relating to the AT_bit_offset\n+values for bit-fields have been fixed.\n+\n+There may still be some very obscure bugs relating to the DWARF description\n+of type `long long' bit-fields for target machines (e.g. 80x86 machines)\n+where the alignment of type `long long' data objects is different from\n+(and less than) the size of a type `long long' data object.\n+\n+Please report any problems with the DWARF description of bit-fields as you\n+would any other GCC bug.  (Procedures for bug reporting are given in the\n+GNU C compiler manual.)\n+\n+--------------------------------\n+\n+At this time, GCC does not know how to handle the GNU C \"nested functions\"\n+extension.  (See the GCC manual for more info on this extension to ANSI C.)\n+\n+--------------------------------\n+\n+The GNU compilers now represent inline functions (and inlined instances\n+thereof) in exactly the manner described by the current DWARF version 2\n+(draft) specification.  The version 1 specification for handling inline\n+functions (and inlined instances) was known to be brain-damaged (by the\n+PLSIG) when the version 1 spec was finalized, but it was simply too late\n+in the cycle to get it removed before the version 1 spec was formally\n+released to the public (by UI).\n+\n+--------------------------------\n+\n+At this time, GCC does not generate the kind of really precise information\n+about the exact declared types of entities with signed integral types which\n+is required by the current DWARF draft specification.\n+\n+Specifically, the current DWARF draft specification seems to require that\n+the type of an non-unsigned integral bit-field member of a struct or union\n+type be represented as either a \"signed\" type or as a \"plain\" type,\n+depending upon the the exact set of keywords that were used in the\n+type specification for the given bit-field member.  It was felt (by the\n+UI/PLSIG) that this distinction between \"plain\" and \"signed\" integral types\n+could have some significance (in the case of bit-fields) because ANSI C\n+does not constrain the signedness of a plain bit-field, whereas it does\n+constrain the signedness of an explicitly \"signed\" bit-field.  For this\n+reason, the current DWARF specification calls for compilers to produce\n+type information (for *all* integral typed entities... not just bit-fields)\n+which explicitly indicates the signedness of the relevant type to be\n+\"signed\" or \"plain\" or \"unsigned\".\n+\n+Unfortunately, the GNU DWARF implementation is currently incapable of making\n+such distinctions.\n+\n+--------------------------------\n+\n+\n+Known Interoperability Problems\n+-------------------------------\n+\n+Although the GNU implementation of DWARF conforms (for the most part) with\n+the current UI/PLSIG DWARF version 1 specification (with many compatible\n+version 2 features added in as \"vendor specific extensions\" just for good\n+measure) there are a few known cases where GCC's DWARF output can cause\n+some confusion for \"classic\" (pre version 1) DWARF consumers such as the\n+System V Release 4 SDB debugger.  These cases are described in this section.\n+\n+--------------------------------\n+\n+The DWARF version 1 specification includes the fundamental type codes\n+FT_ext_prec_float, FT_complex, FT_dbl_prec_complex, and FT_ext_prec_complex.\n+Since GNU C is only a C compiler (and since C doesn't provide any \"complex\"\n+data types) the only one of these fundamental type codes which GCC ever\n+generates is FT_ext_prec_float.  This fundamental type code is generated\n+by GCC for the `long double' data type.  Unfortunately, due to an apparent\n+bug in the SVR4 SDB debugger, SDB can become very confused wherever any\n+attempt is made to print a variable, parameter, or field whose type was\n+given in terms of FT_ext_prec_float.\n+\n+(Actually, SVR4 SDB fails to understand *any* of the four fundamental type\n+codes mentioned here.  This will fact will cause additional problems when\n+there is a GNU FORTRAN front-end.)\n+\n+--------------------------------\n+\n+In general, it appears that SVR4 SDB is not able to effectively ignore\n+fundamental type codes in the \"implementation defined\" range.  This can\n+cause problems when a program being debugged uses the `long long' data\n+type (or the signed or unsigned varieties thereof) because these types\n+are not defined by ANSI C, and thus, GCC must use its own private fundamental\n+type codes (from the implementation-defined range) to represent these types.\n+\n+--------------------------------\n+\n+\n+General GNU DWARF extensions\n+----------------------------\n+\n+In the current DWARF version 1 specification, no mechanism is specified by\n+which accurate information about executable code from include files can be\n+properly (and fully) described.  (The DWARF version 2 specification *does*\n+specify such a mechanism, but it is about 10 times more complicated than\n+it needs to be so I'm not terribly anxious to try to implement it right\n+away.)\n+\n+In the GNU implementation of DWARF version 1, a fully downward-compatible\n+extension has been implemented which permits the GNU compilers to specify\n+which executable lines come from which files.  This extension places\n+additional information (about source file names) in GNU-specific sections\n+(which should be totally ignored by all non-GNU DWARF consumers) so that\n+this extended information can be provided (to GNU DWARF consumers) in a way\n+which is totally transparent (and invisible) to non-GNU DWARF consumers\n+(e.g. the SVR4 SDB debugger).  The additional information is placed *only*\n+in specialized GNU-specific sections, where it should never even be seen\n+by non-GNU DWARF consumers.\n+\n+To understand this GNU DWARF extension, imagine that the sequence of entries\n+in the .lines section is broken up into several subsections.  Each contiguous\n+sequence of .line entries which relates to a sequence of lines (or statements)\n+from one particular file (either a `base' file or an `include' file) could\n+be called a `line entries chunk' (LEC).\n+\n+For each LEC there is one entry in the .debug_srcinfo section.\n+\n+Each normal entry in the .debug_srcinfo section consists of two 4-byte\n+words of data as follows:\n+\n+\t(1)\tThe starting address (relative to the entire .line section)\n+\t\tof the first .line entry in the relevant LEC.\n+\n+\t(2)\tThe starting address (relative to the entire .debug_sfnames\n+\t\tsection) of a NUL terminated string representing the\n+\t\trelevant filename.  (This filename name be either a\n+\t\trelative or an absolute filename, depending upon how the\n+\t\tgiven source file was located during compilation.)\n+\n+Obviously, each .debug_srcinfo entry allows you to find the relevant filename,\n+and it also points you to the first .line entry that was generated as a result\n+of having compiled a given source line from the given source file.\n+\n+Each subsequent .line entry should also be assumed to have been produced\n+as a result of compiling yet more lines from the same file.  The end of\n+any given LEC is easily found by looking at the first 4-byte pointer in\n+the *next* .debug_srcinfo entry.  That next .debug_srcinfo entry points\n+to a new and different LEC, so the preceding LEC (implicitly) must have\n+ended with the last .line section entry which occurs at the 2 1/2 words\n+just before the address given in the first pointer of the new .debug_srcinfo\n+entry.\n+\n+The following picture may help to clarify this feature.  Let's assume that\n+`LE' stands for `.line entry'.  Also, assume that `* 'stands for a pointer.\n+\n+\n+\t.line section\t   .debug_srcinfo section     .debug_sfnames section\n+\t----------------------------------------------------------------\n+\n+\tLE  <---------------------- *\n+\tLE\t\t\t    * -----------------> \"foobar.c\" <---\n+\tLE\t\t\t\t\t\t\t\t|\n+\tLE\t\t\t\t\t\t\t\t|\n+\tLE  <---------------------- *\t\t\t\t\t|\n+\tLE\t\t\t    * -----------------> \"foobar.h\" <|\t|\n+\tLE\t\t\t\t\t\t\t     |\t|\n+\tLE\t\t\t\t\t\t\t     |\t|\n+\tLE  <---------------------- *\t\t\t\t     |\t|\n+\tLE\t\t\t    * ----------------->  \"inner.h\"  |\t|\n+\tLE\t\t\t\t\t\t\t     |\t|\n+\tLE  <---------------------- *\t\t\t\t     |\t|\n+\tLE\t\t\t    * -------------------------------\t|\n+\tLE\t\t\t\t\t\t\t\t|\n+\tLE\t\t\t\t\t\t\t\t|\n+\tLE\t\t\t\t\t\t\t\t|\n+\tLE\t\t\t\t\t\t\t\t|\n+\tLE  <---------------------- *\t\t\t\t\t|\n+\tLE\t\t\t    * -----------------------------------\n+\tLE\n+\tLE\n+\tLE\n+\n+In effect, each entry in the .debug_srcinfo section points to *both* a\n+filename (in the .debug_sfnames section) and to the start of a block of\n+consecutive LEs (in the .line section).\n+\n+Note that just like in the .line section, there are specialized first and\n+last entries in the .debug_srcinfo section for each object file.  These\n+special first and last entries for the .debug_srcinfo section are very\n+different from the normal .debug_srcinfo section entries.  They provide\n+additional information which may be helpful to a debugger when it is\n+interpreting the data in the .debug_srcinfo, .debug_sfnames, and .line\n+sections.\n+\n+The first entry in the .debug_srcinfo section for each compilation unit\n+consists of five 4-byte words of data.  The contents of these five words\n+should be interpreted (by debuggers) as follows:\n+\n+\t(1)\tThe starting address (relative to the entire .line section)\n+\t\tof the .line section for this compilation unit.\n+\n+\t(2)\tThe starting address (relative to the entire .debug_sfnames\n+\t\tsection) of the .debug_sfnames section for this compilation\n+\t\tunit.\n+\n+\t(3)\tThe starting address (in the execution virtual address space)\n+\t\tof the .text section for this compilation unit.\n+\n+\t(4)\tThe ending address plus one (in the execution virtual address\n+\t\tspace) of the .text section for this compilation unit.\n+\n+\t(5)\tThe date/time (in seconds since midnight 1/1/70) at which the\n+\t\tcompilation of this compilation unit occurred.  This value\n+\t\tshould be interpreted as an unsigned quantity because gcc\n+\t\tmight be configured to generate a default value of 0xffffffff\n+\t\tin this field (in cases where it is desired to have object\n+\t\tfiles created at different times from identical source files\n+\t\tbe byte-for-byte identical).  By default, these timestamps\n+\t\tare *not* generated by dwarfout.c (so that object files\n+\t\tcompiled at different times will be byte-for-byte identical).\n+\t\tIf you wish to enable this \"timestamp\" feature however, you\n+\t\tcan simply place a #define for the symbol `DWARF_TIMESTAMPS'\n+\t\tin your target configuration file and then rebuild the GNU\n+\t\tcompiler(s).\n+\n+Note that the first string placed into the .debug_sfnames section for each\n+compilation unit is the name of the directory in which compilation occurred.\n+This string ends with a `/' (to help indicate that it is the pathname of a\n+directory).  Thus, the second word of each specialized initial .debug_srcinfo\n+entry for each compilation unit may be used as a pointer to the (string)\n+name of the compilation directory, and that string may in turn be used to\n+\"absolutize\" any relative pathnames which may appear later on in the\n+.debug_sfnames section entries for the same compilation unit.\n+\n+The fifth and last word of each specialized starting entry for a compilation\n+unit in the .debug_srcinfo section may (depending upon your configuration)\n+indicate the date/time of compilation, and this may be used (by a debugger)\n+to determine if any of the source files which contributed code to this\n+compilation unit are newer than the object code for the compilation unit\n+itself.  If so, the debugger may wish to print an \"out-of-date\" warning\n+about the compilation unit.\n+\n+The .debug_srcinfo section associated with each compilation will also have\n+a specialized terminating entry.  This terminating .debug_srcinfo section\n+entry will consist of the following two 4-byte words of data:\n+\n+\t(1)\tThe offset, measured from the start of the .line section to\n+\t\tthe beginning of the terminating entry for the .line section.\n+\n+\t(2)\tA word containing the value 0xffffffff.\n+\n+--------------------------------\n+\n+In the current DWARF version 1 specification, no mechanism is specified by\n+which information about macro definitions and un-definitions may be provided\n+to the DWARF consumer.\n+\n+The DWARF version 2 (draft) specification does specify such a mechanism.\n+That specification was based on the GNU (\"vendor specific extension\")\n+which provided some support for macro definitions and un-definitions,\n+but the \"official\" DWARF version 2 (draft) specification mechanism for\n+handling macros and the GNU implementation have diverged somewhat.  I\n+plan to update the GNU implementation to conform to the \"official\"\n+DWARF version 2 (draft) specification as soon as I get time to do that.\n+\n+Note that in the GNU implementation, additional information about macro\n+definitions and un-definitions is *only* provided when the -g3 level of\n+debug-info production is selected.  (The default level is -g2 and the\n+plain old -g option is considered to be identical to -g2.)\n+\n+GCC records information about macro definitions and undefinitions primarily\n+in a section called the .debug_macinfo section.  Normal entries in the\n+.debug_macinfo section consist of the following three parts:\n+\n+\t(1)\tA special \"type\" byte.\n+\n+\t(2)\tA 3-byte line-number/filename-offset field.\n+\n+\t(3)\tA NUL terminated string.\n+\n+The interpretation of the second and third parts is dependent upon the\n+value of the leading (type) byte.\n+\n+The type byte may have one of four values depending upon the type of the\n+.debug_macinfo entry which follows.  The 1-byte MACINFO type codes presently\n+used, and their meanings are as follows:\n+\n+\tMACINFO_start\t\tA base file or an include file starts here.\n+\tMACINFO_resume\t\tThe current base or include file ends here.\n+\tMACINFO_define          A #define directive occurs here.\n+\tMACINFO_undef           A #undef directive occur here.\n+\n+(Note that the MACINFO_... codes mentioned here are simply symbolic names\n+for constants which are defined in the GNU dwarf.h file.)\n+\n+For MACINFO_define and MACINFO_undef entries, the second (3-byte) field\n+contains the number of the source line (relative to the start of the current\n+base source file or the current include files) when the #define or #undef\n+directive appears.  For a MACINFO_define entry, the following string field\n+contains the name of the macro which is defined, followed by its definition.\n+Note that the definition is always separated from the name of the macro\n+by at least one whitespace character.  For a MACINFO_undef entry, the\n+string which follows the 3-byte line number field contains just the name\n+of the macro which is being undef'ed.\n+\n+For a MACINFO_start entry, the 3-byte field following the type byte contains\n+the offset, relative to the start of the .debug_sfnames section for the\n+current compilation unit, of a string which names the new source file which\n+is beginning its inclusion at this point.  Following that 3-byte field,\n+each MACINFO_start entry always contains a zero length NUL terminated\n+string.\n+\n+For a MACINFO_resume entry, the 3-byte field following the type byte contains\n+the line number WITHIN THE INCLUDING FILE at which the inclusion of the\n+current file (whose inclusion ends here) was initiated.  Following that\n+3-byte field, each MACINFO_resume entry always contains a zero length NUL\n+terminated string.\n+\n+Each set of .debug_macinfo entries for each compilation unit is terminated\n+by a special .debug_macinfo entry consisting of a 4-byte zero value followed\n+by a single NUL byte.\n+\n+--------------------------------\n+\n+In the current DWARF draft specification, no provision is made for providing\n+a separate level of (limited) debugging information necessary to support\n+tracebacks (only) through fully-debugged code (e.g. code in system libraries).\n+\n+A proposal to define such a level was submitted (by me) to the UI/PLSIG.\n+This proposal was rejected by the UI/PLSIG for inclusion into the DWARF\n+version 1 specification for two reasons.  First, it was felt (by the PLSIG)\n+that the issues involved in supporting a \"traceback only\" subset of DWARF\n+were not well understood.  Second, and perhaps more importantly, the PLSIG\n+is already having enough trouble agreeing on what it means to be \"conforming\"\n+to the DWARF specification, and it was felt that trying to specify multiple\n+different *levels* of conformance would only complicate our discussions of\n+this already divisive issue.  Nonetheless, the GNU implementation of DWARF\n+provides an abbreviated \"traceback only\" level of debug-info production for\n+use with fully-debugged \"system library\" code.  This level should only be\n+used for fully debugged system library code, and even then, it should only\n+be used where there is a very strong need to conserve disk space.  This\n+abbreviated level of debug-info production can be used by specifying the\n+-g1 option on the compilation command line.\n+\n+--------------------------------\n+\n+As mentioned above, the GNU implementation of DWARF currently uses the DWARF\n+version 2 (draft) approach for inline functions (and inlined instances\n+thereof).  This is used in preference to the version 1 approach because\n+(quite simply) the version 1 approach is highly brain-damaged and probably\n+unworkable.\n+\n+--------------------------------\n+\n+\n+GNU DWARF Representation of GNU C Extensions to ANSI C\n+------------------------------------------------------\n+\n+The file dwarfout.c has been designed and implemented so as to provide\n+some reasonable DWARF representation for each and every declarative\n+construct which is accepted by the GNU C compiler.  Since the GNU C\n+compiler accepts a superset of ANSI C, this means that there are some\n+cases in which the DWARF information produced by GCC must take some\n+liberties in improvising DWARF representations for declarations which\n+are only valid in (extended) GNU C.\n+\n+In particular, GNU C provides at least three significant extensions to\n+ANSI C when it comes to declarations.  These are (1) inline functions,\n+and (2) dynamic arrays, and (3) incomplete enum types.  (See the GCC\n+manual for more information on these GNU extensions to ANSI C.)  When\n+used, these GNU C extensions are represented (in the generated DWARF\n+output of GCC) in the most natural and intuitively obvious ways.\n+\n+In the case of inline functions, the DWARF representation is exactly as\n+called for in the DWARF version 2 (draft) specification for an identical\n+function written in C++; i.e. we \"reuse\" the representation of inline\n+functions which has been defined for C++ to support this GNU C extension.\n+\n+In the case of dynamic arrays, we use the most obvious representational\n+mechanism available; i.e. an array type in which the upper bound of\n+some dimension (usually the first and only dimension) is a variable\n+rather than a constant.  (See the DWARF version 1 specification for more\n+details.)\n+\n+In the case of incomplete enum types, such types are represented simply\n+as TAG_enumeration_type DIEs which DO NOT contain either AT_byte_size\n+attributes or AT_element_list attributes.\n+\n+--------------------------------\n+\n+\n+Future Directions\n+-----------------\n+\n+The codes, formats, and other paraphernalia necessary to provide proper\n+support for symbolic debugging for the C++ language are still being worked\n+on by the UI/PLSIG.  The vast majority of the additions to DWARF which will\n+be needed to completely support C++ have already been hashed out and agreed\n+upon, but a few small issues (e.g. anonymous unions, access declarations)\n+are still being discussed.  Also, we in the PLSIG are still discussing\n+whether or not we need to do anything special for C++ templates.  (At this\n+time it is not yet clear whether we even need to do anything special for\n+these.) \n+\n+Unfortunately, as mentioned above, there are quite a few problems in the\n+g++ front end itself, and these are currently responsible for severely\n+restricting the progress which can be made on adding DWARF support\n+specifically for the g++ front-end.  Furthermore, Richard Stallman has\n+expressed the view that C++ friendships might not be important enough to\n+describe (in DWARF).  This view directly conflicts with both the DWARF\n+version 1 and version 2 (draft) specifications, so until this small\n+misunderstanding is cleared up, DWARF support for g++ is unlikely.\n+\n+With regard to FORTRAN, the UI/PLSIG has defined what is believed to be a\n+complete and sufficient set of codes and rules for adequately representing\n+all of FORTRAN 77, and most of Fortran 90 in DWARF.  While some support for\n+this has been implemented in dwarfout.c, further implementation and testing\n+will have to await the arrival of the GNU Fortran front-end (which is\n+currently in early alpha test as of this writing).\n+\n+GNU DWARF support for other languages (i.e. Pascal and Modula) is a moot\n+issue until there are GNU front-ends for these other languages.\n+\n+GNU DWARF support for DWARF version 2 will probably not be attempted until\n+such time as the version 2 specification is finalized.  (More work needs\n+to be done on the version 2 specification to make the new \"abbreviations\"\n+feature of version 2 more easily implementable.  Until then, it will be\n+a royal pain the ass to implement version 2 \"abbreviations\".)  For the\n+time being, version 2 features will be added (in a version 1 compatible\n+manner) when and where these features seem necessary or extremely desirable.\n+\n+As currently defined, DWARF only describes a (binary) language which can\n+be used to communicate symbolic debugging information from a compiler\n+through an assembler and a linker, to a debugger.  There is no clear\n+specification of what processing should be (or must be) done by the\n+assembler and/or the linker.  Fortunately, the role of the assembler\n+is easily inferred (by anyone knowledgeable about assemblers) just by\n+looking  at examples of assembly-level DWARF code.  Sadly though, the\n+allowable (or required) processing steps performed by a linker are\n+harder to infer and (perhaps) even harder to agree upon.  There are\n+several forms of very useful `post-processing' steps which intelligent\n+linkers *could* (in theory) perform on object files containing DWARF,\n+but any and all such link-time transformations are currently both disallowed\n+and unspecified.\n+\n+In particular, possible link-time transformations of DWARF code which could\n+provide significant benefits include (but are not limited to):\n+\n+\tCommonization of duplicate DIEs obtained from multiple input\n+\t(object) files.\n+\n+\tCross-compilation type checking based upon DWARF type information\n+\tfor objects and functions.\n+\n+\tOther possible `compacting' transformations designed to save disk\n+\tspace and to reduce linker & debugger I/O activity."}]}