{"sha": "ddaad3c8b1dcd40163af03d1cd5c302966257b21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhYWQzYzhiMWRjZDQwMTYzYWYwM2QxY2Q1YzMwMjk2NjI1N2IyMQ==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@CeBiTec.Uni-Bielefeld.DE", "date": "2011-08-08T15:39:35Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-08-08T15:39:35Z"}, "message": "configure.ac (THREADS): Remove posix95.\n\n\tboehm-gc:\n\t* configure.ac (THREADS): Remove posix95.\n\t* configure: Regenerate.\n\n\tgcc:\n\t* gthr-posix95.h: Remove.\n\t* gthr.h [_PTHREADS95]: Remove.\n\t* configure.ac (enable_threads): Remove posix95.\n\t* configure: Regenerate.\n\t* doc/install.texi (Configuration, --enable-threads): Remove\n\tposix95.\n\n\tlibgomp:\n\t* config/posix95/lock.c, posix95/omp-lock.h: Remove.\n\n\tlibjava:\n\t* configure.ac (THREADS): Remove posix95.\n\t* configure: Regenerate.\n\nFrom-SVN: r177568", "tree": {"sha": "e818a4b6b520de30d7c807a4a85e9a02746662bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e818a4b6b520de30d7c807a4a85e9a02746662bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddaad3c8b1dcd40163af03d1cd5c302966257b21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddaad3c8b1dcd40163af03d1cd5c302966257b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddaad3c8b1dcd40163af03d1cd5c302966257b21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddaad3c8b1dcd40163af03d1cd5c302966257b21/comments", "author": {"login": "rorth", "id": 3930951, "node_id": "MDQ6VXNlcjM5MzA5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rorth", "html_url": "https://github.com/rorth", "followers_url": "https://api.github.com/users/rorth/followers", "following_url": "https://api.github.com/users/rorth/following{/other_user}", "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rorth/subscriptions", "organizations_url": "https://api.github.com/users/rorth/orgs", "repos_url": "https://api.github.com/users/rorth/repos", "events_url": "https://api.github.com/users/rorth/events{/privacy}", "received_events_url": "https://api.github.com/users/rorth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "712c948a074b0df50a1df6c5ce2d05acbd9ac972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712c948a074b0df50a1df6c5ce2d05acbd9ac972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712c948a074b0df50a1df6c5ce2d05acbd9ac972"}], "stats": {"total": 1110, "additions": 29, "deletions": 1081}, "files": [{"sha": "15f079dd3a216eed1bf4f152d22550e6ac725095", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1,3 +1,8 @@\n+2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* configure.ac (THREADS): Remove posix95.\n+\t* configure: Regenerate.\n+\n 2011-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/39150"}, {"sha": "632a229cdf2b4c1bd65fbfca1dc87f98fb22d42c", "filename": "boehm-gc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -14712,7 +14712,7 @@ case \"$THREADS\" in\n  no | none | single)\n     THREADS=none\n     ;;\n- posix | posix95 | pthreads)\n+ posix | pthreads)\n     THREADS=posix\n     THREADLIBS=-lpthread\n     case \"$host\" in"}, {"sha": "a741ca6d27aa240e07e011fd2749481ec7fe22f6", "filename": "boehm-gc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -129,7 +129,7 @@ case \"$THREADS\" in\n  no | none | single)\n     THREADS=none\n     ;;\n- posix | posix95 | pthreads)\n+ posix | pthreads)\n     THREADS=posix\n     THREADLIBS=-lpthread\n     case \"$host\" in"}, {"sha": "f98765f5c7adf552226c858617fac389f0350684", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1,3 +1,12 @@\n+2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* gthr-posix95.h: Remove.\n+\t* gthr.h [_PTHREADS95]: Remove.\n+\t* configure.ac (enable_threads): Remove posix95.\n+\t* configure: Regenerate.\n+\t* doc/install.texi (Configuration, --enable-threads): Remove\n+\tposix95.\n+\n 2011-08-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/49781"}, {"sha": "94daddcd40c59f91fd575ef230c3caf73d7bddcb", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -11098,7 +11098,7 @@ case ${enable_threads} in\n     # default\n     target_thread_file='single'\n     ;;\n-  aix | dce | lynx | mipssde | posix | posix95 | rtems | \\\n+  aix | dce | lynx | mipssde | posix | rtems | \\\n   single | tpf | vxworks | win32)\n     target_thread_file=${enable_threads}\n     ;;"}, {"sha": "ed01904635841189c35e8d365c64b6057a52a413", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1354,7 +1354,7 @@ case ${enable_threads} in\n     # default\n     target_thread_file='single'\n     ;;\n-  aix | dce | lynx | mipssde | posix | posix95 | rtems | \\\n+  aix | dce | lynx | mipssde | posix | rtems | \\\n   single | tpf | vxworks | win32)\n     target_thread_file=${enable_threads}\n     ;;"}, {"sha": "83a7361386fa1125c51280e40cf3723d1df7c26f", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1145,8 +1145,6 @@ MIPS SDE thread support.\n This is an alias for @samp{single}.\n @item posix\n Generic POSIX/Unix98 thread support.\n-@item posix95\n-Generic POSIX/Unix95 thread support.\n @item rtems\n RTEMS thread support.\n @item single"}, {"sha": "31f6421577b326b1f56a859d9c9f9ec42d9a842c", "filename": "gcc/gthr-posix95.h", "status": "removed", "additions": 0, "deletions": 733, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712c948a074b0df50a1df6c5ce2d05acbd9ac972/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712c948a074b0df50a1df6c5ce2d05acbd9ac972/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=712c948a074b0df50a1df6c5ce2d05acbd9ac972", "patch": "@@ -1,733 +0,0 @@\n-/* Threads compatibility routines for libgcc2 and libobjc.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 2004, 2005, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_GTHR_POSIX_H\n-#define GCC_GTHR_POSIX_H\n-\n-/* POSIX threads specific definitions.\n-   Easy, since the interface is just one-to-one mapping.  */\n-\n-#define __GTHREADS 1\n-\n-/* Some implementations of <pthread.h> require this to be defined.  */\n-#ifndef _REENTRANT\n-#define _REENTRANT 1\n-#endif\n-\n-#include <pthread.h>\n-#include <unistd.h>\n-\n-typedef pthread_key_t __gthread_key_t;\n-typedef pthread_once_t __gthread_once_t;\n-typedef pthread_mutex_t __gthread_mutex_t;\n-typedef pthread_cond_t __gthread_cond_t;\n-\n-/* POSIX like conditional variables are supported.  Please look at comments\n-   in gthr.h for details. */\n-#define __GTHREAD_HAS_COND\t1\n-\n-typedef struct {\n-  long depth;\n-  pthread_t owner;\n-  pthread_mutex_t actual;\n-} __gthread_recursive_mutex_t;\n-\n-#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n-#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n-#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n-#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER\n-\n-#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n-# define __gthrw(name) \\\n-  static __typeof(name) __gthrw_ ## name __attribute__ ((__weakref__(#name)));\n-# define __gthrw_(name) __gthrw_ ## name\n-#else\n-# define __gthrw(name)\n-# define __gthrw_(name) name\n-#endif\n-\n-__gthrw(pthread_once)\n-__gthrw(pthread_key_create)\n-__gthrw(pthread_key_delete)\n-__gthrw(pthread_getspecific)\n-__gthrw(pthread_setspecific)\n-__gthrw(pthread_create)\n-__gthrw(pthread_cancel)\n-__gthrw(pthread_self)\n-\n-__gthrw(pthread_mutex_init)\n-__gthrw(pthread_mutex_destroy)\n-__gthrw(pthread_mutex_lock)\n-__gthrw(pthread_mutex_trylock)\n-__gthrw(pthread_mutex_unlock)\n-__gthrw(pthread_mutexattr_init)\n-__gthrw(pthread_mutexattr_destroy)\n-\n-__gthrw(pthread_cond_broadcast)\n-__gthrw(pthread_cond_wait)\n-\n-#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n-/* Objective-C.  */\n-__gthrw(pthread_cond_destroy)\n-__gthrw(pthread_cond_init)\n-__gthrw(pthread_cond_signal)\n-__gthrw(pthread_exit)\n-#ifdef _POSIX_PRIORITY_SCHEDULING\n-#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-__gthrw(sched_get_priority_max)\n-__gthrw(sched_get_priority_min)\n-#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n-#endif /* _POSIX_PRIORITY_SCHEDULING */\n-__gthrw(sched_yield)\n-__gthrw(pthread_attr_destroy)\n-__gthrw(pthread_attr_init)\n-__gthrw(pthread_attr_setdetachstate)\n-#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-__gthrw(pthread_getschedparam)\n-__gthrw(pthread_setschedparam)\n-#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n-#endif /* _LIBOBJC || _LIBOBJC_WEAK */\n-\n-#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n-\n-/* On Solaris 2.6 up to 9, the libc exposes a POSIX threads interface even if\n-   -pthreads is not specified.  The functions are dummies and most return an\n-   error value.  However pthread_once returns 0 without invoking the routine\n-   it is passed so we cannot pretend that the interface is active if -pthreads\n-   is not specified.  On Solaris 2.5.1, the interface is not exposed at all so\n-   we need to play the usual game with weak symbols.  On Solaris 10 and up, a\n-   working interface is always exposed.  On FreeBSD 6 and later, libc also\n-   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up\n-   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,\n-   which means the alternate __gthread_active_p below cannot be used there.  */\n-\n-#if defined(__FreeBSD__) || (defined(__sun) && defined(__svr4__))\n-\n-static volatile int __gthread_active = -1;\n-\n-static void\n-__gthread_trigger (void)\n-{\n-  __gthread_active = 1;\n-}\n-\n-static inline int\n-__gthread_active_p (void)\n-{\n-  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;\n-  static pthread_once_t __gthread_active_once = PTHREAD_ONCE_INIT;\n-\n-  /* Avoid reading __gthread_active twice on the main code path.  */\n-  int __gthread_active_latest_value = __gthread_active;\n-\n-  /* This test is not protected to avoid taking a lock on the main code\n-     path so every update of __gthread_active in a threaded program must\n-     be atomic with regard to the result of the test.  */\n-  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n-    {\n-      if (__gthrw_(pthread_once))\n-\t{\n-\t  /* If this really is a threaded program, then we must ensure that\n-\t     __gthread_active has been set to 1 before exiting this block.  */\n-\t  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);\n-\t  __gthrw_(pthread_once) (&__gthread_active_once, __gthread_trigger);\n-\t  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);\n-\t}\n-\n-      /* Make sure we'll never enter this block again.  */\n-      if (__gthread_active < 0)\n-\t__gthread_active = 0;\n-\n-      __gthread_active_latest_value = __gthread_active;\n-    }\n-\n-  return __gthread_active_latest_value != 0;\n-}\n-\n-#else /* neither FreeBSD nor Solaris */\n-\n-static inline int\n-__gthread_active_p (void)\n-{\n-  static void *const __gthread_active_ptr\n-    = __extension__ (void *) &__gthrw_(pthread_cancel);\n-  return __gthread_active_ptr != 0;\n-}\n-\n-#endif /* FreeBSD or Solaris */\n-\n-#else /* not SUPPORTS_WEAK */\n-\n-/* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread\n-   calls in shared flavors of the HP-UX C library.  Most of the stubs\n-   have no functionality.  The details are described in the \"libc cumulative\n-   patch\" for each subversion of HP-UX 11.  There are two special interfaces\n-   provided for checking whether an application is linked to a shared pthread\n-   library or not.  However, these interfaces aren't available in early\n-   pthread libraries.  We also need a test that works for archive\n-   libraries.  We can't use pthread_once as some libc versions call the\n-   init function.  We also can't use pthread_create or pthread_attr_init\n-   as these create a thread and thereby prevent changing the default stack\n-   size.  The function pthread_default_stacksize_np is available in both\n-   the archive and shared versions of libpthread.   It can be used to\n-   determine the default pthread stack size.  There is a stub in some\n-   shared libc versions which returns a zero size if pthreads are not\n-   active.  We provide an equivalent stub to handle cases where libc\n-   doesn't provide one.  */\n-\n-#if defined(__hppa__) && defined(__hpux__)\n-\n-static volatile int __gthread_active = -1;\n-\n-static inline int\n-__gthread_active_p (void)\n-{\n-  /* Avoid reading __gthread_active twice on the main code path.  */\n-  int __gthread_active_latest_value = __gthread_active;\n-  size_t __s;\n-\n-  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n-    {\n-      pthread_default_stacksize_np (0, &__s);\n-      __gthread_active = __s ? 1 : 0;\n-      __gthread_active_latest_value = __gthread_active;\n-    }\n-\n-  return __gthread_active_latest_value != 0;\n-}\n-\n-#else /* not hppa-hpux */\n-\n-static inline int\n-__gthread_active_p (void)\n-{\n-  return 1;\n-}\n-\n-#endif /* hppa-hpux */\n-\n-#endif /* SUPPORTS_WEAK */\n-\n-#ifdef _LIBOBJC\n-\n-/* This is the config.h file in libobjc/ */\n-#include <config.h>\n-\n-#ifdef HAVE_SCHED_H\n-# include <sched.h>\n-#endif\n-\n-/* Key structure for maintaining thread specific storage */\n-static pthread_key_t _objc_thread_storage;\n-static pthread_attr_t _objc_thread_attribs;\n-\n-/* Thread local storage for a single thread */\n-static void *thread_local_storage = NULL;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem.  */\n-static inline int\n-__gthread_objc_init_thread_system (void)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      /* Initialize the thread storage key.  */\n-      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)\n-\t{\n-\t  /* The normal default detach state for threads is\n-\t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n-\t   * when you think they should.  */\n-\t  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0\n-\t      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,\n-\t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n-\t    return 0;\n-\t}\n-    }\n-\n-  return -1;\n-}\n-\n-/* Close the threads subsystem.  */\n-static inline int\n-__gthread_objc_close_thread_system (void)\n-{\n-  if (__gthread_active_p ()\n-      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0\n-      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)\n-    return 0;\n-\n-  return -1;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution.  */\n-static inline objc_thread_t\n-__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  pthread_t new_thread_handle;\n-\n-  if (!__gthread_active_p ())\n-    return NULL;\n-\n-  if (!(__gthrw_(pthread_create) (&new_thread_handle, &_objc_thread_attribs,\n-\t\t\t\t  (void *) func, arg)))\n-    thread_id = (objc_thread_t) new_thread_handle;\n-  else\n-    thread_id = NULL;\n-\n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority.  */\n-static inline int\n-__gthread_objc_thread_set_priority (int priority)\n-{\n-  if (!__gthread_active_p ())\n-    return -1;\n-  else\n-    {\n-#ifdef _POSIX_PRIORITY_SCHEDULING\n-#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-      pthread_t thread_id = __gthrw_(pthread_self) ();\n-      int policy;\n-      struct sched_param params;\n-      int priority_min, priority_max;\n-\n-      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)\n-\t{\n-\t  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)\n-\t    return -1;\n-\n-\t  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)\n-\t    return -1;\n-\n-\t  if (priority > priority_max)\n-\t    priority = priority_max;\n-\t  else if (priority < priority_min)\n-\t    priority = priority_min;\n-\t  params.sched_priority = priority;\n-\n-\t  /*\n-\t   * The solaris 7 and several other man pages incorrectly state that\n-\t   * this should be a pointer to policy but pthread.h is universally\n-\t   * at odds with this.\n-\t   */\n-\t  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)\n-\t    return 0;\n-\t}\n-#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n-#endif /* _POSIX_PRIORITY_SCHEDULING */\n-      return -1;\n-    }\n-}\n-\n-/* Return the current thread's priority.  */\n-static inline int\n-__gthread_objc_thread_get_priority (void)\n-{\n-#ifdef _POSIX_PRIORITY_SCHEDULING\n-#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-  if (__gthread_active_p ())\n-    {\n-      int policy;\n-      struct sched_param params;\n-\n-      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)\n-\treturn params.sched_priority;\n-      else\n-\treturn -1;\n-    }\n-  else\n-#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n-#endif /* _POSIX_PRIORITY_SCHEDULING */\n-    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread.  */\n-static inline void\n-__gthread_objc_thread_yield (void)\n-{\n-  if (__gthread_active_p ())\n-    __gthrw_(sched_yield) ();\n-}\n-\n-/* Terminate the current thread.  */\n-static inline int\n-__gthread_objc_thread_exit (void)\n-{\n-  if (__gthread_active_p ())\n-    /* exit the thread */\n-    __gthrw_(pthread_exit) (&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread.  */\n-static inline objc_thread_t\n-__gthread_objc_thread_id (void)\n-{\n-  if (__gthread_active_p ())\n-    return (objc_thread_t) __gthrw_(pthread_self) ();\n-  else\n-    return (objc_thread_t) 1;\n-}\n-\n-/* Sets the thread's local storage pointer.  */\n-static inline int\n-__gthread_objc_thread_set_data (void *value)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);\n-  else\n-    {\n-      thread_local_storage = value;\n-      return 0;\n-    }\n-}\n-\n-/* Returns the thread's local storage pointer.  */\n-static inline void *\n-__gthread_objc_thread_get_data (void)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_getspecific) (_objc_thread_storage);\n-  else\n-    return thread_local_storage;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex.  */\n-static inline int\n-__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n-\n-      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))\n-\t{\n-\t  objc_free (mutex->backend);\n-\t  mutex->backend = NULL;\n-\t  return -1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Deallocate a mutex.  */\n-static inline int\n-__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      int count;\n-\n-      /*\n-       * Posix Threads specifically require that the thread be unlocked\n-       * for __gthrw_(pthread_mutex_destroy) to work.\n-       */\n-\n-      do\n-\t{\n-\t  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);\n-\t  if (count < 0)\n-\t    return -1;\n-\t}\n-      while (count);\n-\n-      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))\n-\treturn -1;\n-\n-      objc_free (mutex->backend);\n-      mutex->backend = NULL;\n-    }\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex.  */\n-static inline int\n-__gthread_objc_mutex_lock (objc_mutex_t mutex)\n-{\n-  if (__gthread_active_p ()\n-      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)\n-    {\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Try to grab a lock on a mutex.  */\n-static inline int\n-__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n-{\n-  if (__gthread_active_p ()\n-      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)\n-    {\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Unlock the mutex */\n-static inline int\n-__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n-{\n-  if (__gthread_active_p ()\n-      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)\n-    {\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition.  */\n-static inline int\n-__gthread_objc_condition_allocate (objc_condition_t condition)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      condition->backend = objc_malloc (sizeof (pthread_cond_t));\n-\n-      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))\n-\t{\n-\t  objc_free (condition->backend);\n-\t  condition->backend = NULL;\n-\t  return -1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Deallocate a condition.  */\n-static inline int\n-__gthread_objc_condition_deallocate (objc_condition_t condition)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))\n-\treturn -1;\n-\n-      objc_free (condition->backend);\n-      condition->backend = NULL;\n-    }\n-  return 0;\n-}\n-\n-/* Wait on the condition */\n-static inline int\n-__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,\n-\t\t\t      (pthread_mutex_t *) mutex->backend);\n-  else\n-    return 0;\n-}\n-\n-/* Wake up all threads waiting on this condition.  */\n-static inline int\n-__gthread_objc_condition_broadcast (objc_condition_t condition)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);\n-  else\n-    return 0;\n-}\n-\n-/* Wake up one thread waiting on this condition.  */\n-static inline int\n-__gthread_objc_condition_signal (objc_condition_t condition)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);\n-  else\n-    return 0;\n-}\n-\n-#else /* _LIBOBJC */\n-\n-static inline int\n-__gthread_once (__gthread_once_t *__once, void (*__func) (void))\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_once) (__once, __func);\n-  else\n-    return -1;\n-}\n-\n-static inline int\n-__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))\n-{\n-  return __gthrw_(pthread_key_create) (__key, __dtor);\n-}\n-\n-static inline int\n-__gthread_key_delete (__gthread_key_t __key)\n-{\n-  return __gthrw_(pthread_key_delete) (__key);\n-}\n-\n-static inline void *\n-__gthread_getspecific (__gthread_key_t __key)\n-{\n-  return __gthrw_(pthread_getspecific) (__key);\n-}\n-\n-static inline int\n-__gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n-{\n-  return __gthrw_(pthread_setspecific) (__key, __ptr);\n-}\n-\n-static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_destroy) (__mutex);\n-  else\n-    return 0;\n-}\n-\n-static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_lock) (__mutex);\n-  else\n-    return 0;\n-}\n-\n-static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_trylock) (__mutex);\n-  else\n-    return 0;\n-}\n-\n-static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    return __gthrw_(pthread_mutex_unlock) (__mutex);\n-  else\n-    return 0;\n-}\n-\n-static inline int\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n-{\n-  __mutex->depth = 0;\n-  __mutex->owner = (pthread_t) 0;\n-  return __gthrw_(pthread_mutex_init) (&__mutex->actual, NULL);\n-}\n-\n-static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      pthread_t __me = __gthrw_(pthread_self) ();\n-\n-      if (__mutex->owner != __me)\n-\t{\n-\t  __gthrw_(pthread_mutex_lock) (&__mutex->actual);\n-\t  __mutex->owner = __me;\n-\t}\n-\n-      __mutex->depth++;\n-    }\n-  return 0;\n-}\n-\n-static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      pthread_t __me = __gthrw_(pthread_self) ();\n-\n-      if (__mutex->owner != __me)\n-\t{\n-\t  if (__gthrw_(pthread_mutex_trylock) (&__mutex->actual))\n-\t    return 1;\n-\t  __mutex->owner = __me;\n-\t}\n-\n-      __mutex->depth++;\n-    }\n-  return 0;\n-}\n-\n-static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n-{\n-  if (__gthread_active_p ())\n-    {\n-      if (--__mutex->depth == 0)\n-\t{\n-\t   __mutex->owner = (pthread_t) 0;\n-\t   __gthrw_(pthread_mutex_unlock) (&__mutex->actual);\n-\t}\n-    }\n-  return 0;\n-}\n-\n-static inline int\n-__gthread_cond_broadcast (__gthread_cond_t *__cond)\n-{\n-  return __gthrw_(pthread_cond_broadcast) (__cond);\n-}\n-\n-static inline int\n-__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n-{\n-  return __gthrw_(pthread_cond_wait) (__cond, __mutex);\n-}\n-\n-static inline int\n-__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n-\t\t\t       __gthread_recursive_mutex_t *__mutex)\n-{\n-  return __gthrw_(pthread_cond_wait) (__cond, &__mutex->actual);\n-}\n-\n-#endif /* _LIBOBJC */\n-\n-#endif /* ! GCC_GTHR_POSIX_H */"}, {"sha": "0c7bfb17aa34356c2d25759b7a88018ec4abf7ca", "filename": "gcc/gthr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fgthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/gcc%2Fgthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr.h?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -135,7 +135,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    Currently supported threads packages are\n      TPF threads with -D__tpf__\n      POSIX/Unix98 threads with -D_PTHREADS\n-     POSIX/Unix95 threads with -D_PTHREADS95\n      DCE threads with -D_DCE_THREADS\n \n */\n@@ -145,8 +144,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"gthr-tpf.h\"\n #elif _PTHREADS\n #include \"gthr-posix.h\"\n-#elif _PTHREADS95\n-#include \"gthr-posix95.h\"\n #elif _DCE_THREADS\n #include \"gthr-dce.h\"\n "}, {"sha": "63a8fe1d0ea1b39caa50f02427b0bfe5d3ead3c5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1,3 +1,7 @@\n+2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* config/posix95/lock.c, posix95/omp-lock.h: Remove.\n+\n 2011-08-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR libgomp/49965"}, {"sha": "22420417c68ea13649758a735962e04647109972", "filename": "libgomp/config/posix95/lock.c", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712c948a074b0df50a1df6c5ce2d05acbd9ac972/libgomp%2Fconfig%2Fposix95%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712c948a074b0df50a1df6c5ce2d05acbd9ac972/libgomp%2Fconfig%2Fposix95%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix95%2Flock.c?ref=712c948a074b0df50a1df6c5ce2d05acbd9ac972", "patch": "@@ -1,316 +0,0 @@\n-/* Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.\n-\n-   This file is part of the GNU OpenMP Library (libgomp).\n-\n-   Libgomp is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n-   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n-   more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* This is the POSIX95 implementation of the public OpenMP locking primitives.\n-\n-   Because OpenMP uses different entry points for normal and recursive\n-   locks, and pthreads uses only one entry point, a system may be able\n-   to do better and streamline the locking as well as reduce the size\n-   of the types exported.  */\n-\n-#include \"libgomp.h\"\n-\n-#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n-void\n-gomp_init_lock_30 (omp_lock_t *lock)\n-{\n-  pthread_mutex_init (lock, NULL);\n-}\n-\n-void\n-gomp_destroy_lock_30 (omp_lock_t *lock)\n-{\n-  pthread_mutex_destroy (lock);\n-}\n-\n-void\n-gomp_set_lock_30 (omp_lock_t *lock)\n-{\n-  pthread_mutex_lock (lock);\n-}\n-\n-void\n-gomp_unset_lock_30 (omp_lock_t *lock)\n-{\n-  pthread_mutex_unlock (lock);\n-}\n-\n-int\n-gomp_test_lock_30 (omp_lock_t *lock)\n-{\n-  return pthread_mutex_trylock (lock) == 0;\n-}\n-\n-void\n-gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  pthread_mutex_init (&lock->lock, NULL);\n-  lock->owner = NULL;\n-  lock->count = 0;\n-}\n-\n-void\n-gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  pthread_mutex_destroy (&lock->lock);\n-}\n-\n-void\n-gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  void *me = gomp_icv (true);\n-\n-  if (lock->owner != me)\n-    {\n-      pthread_mutex_lock (&lock->lock);\n-      lock->owner = me;\n-    }\n-\n-  lock->count++;\n-}\n-\n-void\n-gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  lock->count--;\n-\n-  if (lock->count == 0)\n-    {\n-      lock->owner = NULL;\n-      pthread_mutex_unlock (&lock->lock);\n-    }\n-}\n-\n-int\n-gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  void *me = gomp_icv (true);\n-\n-  if (lock->owner != me)\n-    {\n-      if (pthread_mutex_trylock (&lock->lock) != 0)\n-\treturn 0;\n-      lock->owner = me;\n-    }\n-\n-  return ++lock->count;\n-}\n-\n-#else\n-\n-void\n-gomp_init_lock_30 (omp_lock_t *lock)\n-{\n-  sem_init (lock, 0, 1);\n-}\n-\n-void\n-gomp_destroy_lock_30 (omp_lock_t *lock)\n-{\n-  sem_destroy (lock);\n-}\n-\n-void\n-gomp_set_lock_30 (omp_lock_t *lock)\n-{\n-  while (sem_wait (lock) != 0)\n-    ;\n-}\n-\n-void\n-gomp_unset_lock_30 (omp_lock_t *lock)\n-{\n-  sem_post (lock);\n-}\n-\n-int\n-gomp_test_lock_30 (omp_lock_t *lock)\n-{\n-  return sem_trywait (lock) == 0;\n-}\n-\n-void\n-gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  sem_init (&lock->lock, 0, 1);\n-  lock->count = 0;\n-  lock->owner = NULL;\n-}\n-\n-void\n-gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  sem_destroy (&lock->lock);\n-}\n-\n-void\n-gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  void *me = gomp_icv (true);\n-\n-  if (lock->owner != me)\n-    {\n-      while (sem_wait (&lock->lock) != 0)\n-\t;\n-      lock->owner = me;\n-    }\n-  lock->count++;\n-}\n-\n-void\n-gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  if (--lock->count == 0)\n-    {\n-      lock->owner = NULL;\n-      sem_post (&lock->lock);\n-    }\n-}\n-\n-int\n-gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n-{\n-  void *me = gomp_icv (true);\n-\n-  if (lock->owner != me)\n-    {\n-      if (sem_trywait (&lock->lock) != 0)\n-\treturn 0;\n-      lock->owner = me;\n-    }\n-\n-  return ++lock->count;\n-}\n-#endif\n-\n-#ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n-void\n-gomp_init_lock_25 (omp_lock_25_t *lock)\n-{\n-  pthread_mutex_init (lock, NULL);\n-}\n-\n-void\n-gomp_destroy_lock_25 (omp_lock_25_t *lock)\n-{\n-  pthread_mutex_destroy (lock);\n-}\n-\n-void\n-gomp_set_lock_25 (omp_lock_25_t *lock)\n-{\n-  pthread_mutex_lock (lock);\n-}\n-\n-void\n-gomp_unset_lock_25 (omp_lock_25_t *lock)\n-{\n-  pthread_mutex_unlock (lock);\n-}\n-\n-int\n-gomp_test_lock_25 (omp_lock_25_t *lock)\n-{\n-  return pthread_mutex_trylock (lock) == 0;\n-}\n-\n-void\n-gomp_init_nest_lock_25 (omp_nest_lock_25_t *lock)\n-{\n-  pthread_mutex_init (&lock->lock, NULL);\n-  lock->owner = (pthread_t) 0;\n-  lock->count = 0;\n-}\n-\n-void\n-gomp_destroy_nest_lock_25 (omp_nest_lock_25_t *lock)\n-{\n-  pthread_mutex_destroy (&lock->lock);\n-}\n-\n-void\n-gomp_set_nest_lock_25 (omp_nest_lock_25_t *lock)\n-{\n-  pthread_t me = pthread_self ();\n-\n-  if (lock->owner != me)\n-    {\n-      pthread_mutex_lock (&lock->lock);\n-      lock->owner = me;\n-    }\n-\n-  lock->count++;\n-}\n-\n-void\n-gomp_unset_nest_lock_25 (omp_nest_lock_25_t *lock)\n-{\n-  lock->count--;\n-\n-  if (lock->count == 0)\n-    {\n-      lock->owner = (pthread_t) 0;\n-      pthread_mutex_unlock (&lock->lock);\n-    }\n-}\n-\n-int\n-gomp_test_nest_lock_25 (omp_nest_lock_25_t *lock)\n-{\n-  pthread_t me = pthread_self ();\n-\n-  if (lock->owner != me)\n-    {\n-      if (pthread_mutex_trylock (&lock->lock) != 0)\n-\treturn 0;\n-      lock->owner = me;\n-    }\n-\n-  return ++lock->count;\n-}\n-\n-omp_lock_symver (omp_init_lock)\n-omp_lock_symver (omp_destroy_lock)\n-omp_lock_symver (omp_set_lock)\n-omp_lock_symver (omp_unset_lock)\n-omp_lock_symver (omp_test_lock)\n-omp_lock_symver (omp_init_nest_lock)\n-omp_lock_symver (omp_destroy_nest_lock)\n-omp_lock_symver (omp_set_nest_lock)\n-omp_lock_symver (omp_unset_nest_lock)\n-omp_lock_symver (omp_test_nest_lock)\n-\n-#else\n-\n-ialias (omp_init_lock)\n-ialias (omp_init_nest_lock)\n-ialias (omp_destroy_lock)\n-ialias (omp_destroy_nest_lock)\n-ialias (omp_set_lock)\n-ialias (omp_set_nest_lock)\n-ialias (omp_unset_lock)\n-ialias (omp_unset_nest_lock)\n-ialias (omp_test_lock)\n-ialias (omp_test_nest_lock)\n-\n-#endif"}, {"sha": "b542ba13192324b34d39b62097eee8af7d716589", "filename": "libgomp/config/posix95/omp-lock.h", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712c948a074b0df50a1df6c5ce2d05acbd9ac972/libgomp%2Fconfig%2Fposix95%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712c948a074b0df50a1df6c5ce2d05acbd9ac972/libgomp%2Fconfig%2Fposix95%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix95%2Fomp-lock.h?ref=712c948a074b0df50a1df6c5ce2d05acbd9ac972", "patch": "@@ -1,21 +0,0 @@\n-/* This header is used during the build process to find the size and \n-   alignment of the public OpenMP locks, so that we can export data\n-   structures without polluting the namespace.\n-\n-   In this POSIX95 implementation, we map the two locks to the\n-   same PTHREADS primitive.  */\n-\n-#include <pthread.h>\n-#include <semaphore.h>\n-\n-typedef pthread_mutex_t omp_lock_25_t;\n-typedef struct { pthread_mutex_t lock; pthread_t owner; int count; } omp_nest_lock_25_t;\n-#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n-/* If we don't have working semaphores, we'll make all explicit tasks\n-   tied to the creating thread.  */\n-typedef pthread_mutex_t omp_lock_t;\n-typedef struct { pthread_mutex_t lock; int count; void *owner; } omp_nest_lock_t;\n-#else\n-typedef sem_t omp_lock_t;\n-typedef struct { sem_t lock; int count; void *owner; } omp_nest_lock_t;\n-#endif"}, {"sha": "8af4a5faea7086baca5961bb7745cdd4525014a8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1,3 +1,8 @@\n+2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* configure.ac (THREADS): Remove posix95.\n+\t* configure: Regenerate.\n+\n 2011-08-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (GCC_UNWIND_INCLUDE): Rename to"}, {"sha": "b38728e1957bfb8f0b95e8ab94eea7592eb103df", "filename": "libjava/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -20697,7 +20697,7 @@ case \"$THREADS\" in\n  no | none | single)\n     THREADS=none\n     ;;\n- aix | posix | posix95 | pthreads)\n+ aix | posix | pthreads)\n     THREADS=posix\n     case \"$host\" in\n      *-*-linux*)"}, {"sha": "f0ed99ca248edb40ebc3637cc12034388967522e", "filename": "libjava/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddaad3c8b1dcd40163af03d1cd5c302966257b21/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=ddaad3c8b1dcd40163af03d1cd5c302966257b21", "patch": "@@ -1043,7 +1043,7 @@ case \"$THREADS\" in\n  no | none | single)\n     THREADS=none\n     ;;\n- aix | posix | posix95 | pthreads)\n+ aix | posix | pthreads)\n     THREADS=posix\n     case \"$host\" in\n      *-*-linux*)"}]}